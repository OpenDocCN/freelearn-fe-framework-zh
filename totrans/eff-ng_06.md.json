["```js\n    <div (click)=\"on:\n\n    ```", "```js\n    import { interval } from 'rxjs'\n    numbers$ = interval(1000);\n    ```", "```js\n\n    ```", "```js\n<cdk-virtual-scroll-viewport itemSize=\"50\" class=\"example-viewport\">\n  <div *cdkVirtualFor=\"let item of items\" class=\"example-item\">{{item}}</div>\n</cdk-virtual-scroll-viewport>\n```", "```js\n<ng-container *ngIf=\"obs$ | async as observable\">\n  <ng-container *ngIf=»obs2$ | async as observable2»>\n  </ng-container>\n</ng-container>\n```", "```js\nobservables$ = combineLatest({a: of(123), b: of(456)}).pipe(map(({a, b}) => ({obs: a, obs2: b})));\n```", "```js\n@Injectable({ providedIn: 'root'})\nexport class ExpensesService {}\n```", "```js\nproviders: [\n  { provide: LoggerService, useFactory: env.prod ? ProdLogger : DevLogger }\n]\n```", "```js\ncreateProduct(name: string, props: ProductProps): Product {\n  return new Product(name, props);\n}\n```", "```js\n{\n  \"compilerOptions\": { \"experimentalDecorators\": true}\n}\n```", "```js\nexport function LogMethod(target: unknown, propertyKey: string, descriptor: PropertyDescriptor) {\n  const originalMethod = descriptor.value;\n  descriptor.value = function (...args: unknown[]) {\n    console.log(`Method ${propertyKey} is called with args: ${JSON.stringify(args)}`);\n    return originalMethod.apply(this, args);\n  };\n  return descriptor;\n}\n```", "```js\n@LogMethod\ntest(a: number, b: number) {\n  return a + b;\n}\n```", "```js\nthis.test(1, 2);\nLogs: Method test is called with args: [1,2]\n```", "```js\n@Injectable({ providedIn: 'root' })\nexport class ExpenseFacadeService {\n  protected readonly expenses: inject(ExpensesStore);\n  protected readonly approvedExpenses: inject(ApprovedExpensesStore);\n  getAllExpenses(): Expense[] {\n    return [...this.expenses.getAll(), ...this.approvedExpenses.getAll()];\n  }\n  addExpense(expense: Expense): void {\n    this.expenses.addExpense(new Expense(expense));\n  }\n  updateExpense(expense: Expense): void {\n    if (expense.isApproved) {\n      this.approvedExpenses.addExpense(expense);\n    } else {\n      this.expenses.addExpense(expense);\n    }\n  }\n}\n```", "```js\n{\n  title: \"My Title\",\n  ……\n}\n```", "```js\nproviders: [provideHttpClient function, add the withInterceptors function and provide it with an array:\n\n```", "```js\nexport const AuthInterceptor: HttpInterceptorFn = (\n  req: HttpRequest<unknown>, next: HttpHandlerFn) =>  next(req.clone({ setHeaders: { Authorization: 'auth_token' } }));\n```", "```js\nprovideHttpClient(withInterceptors([auth_token will be added to all your HTTP requests. Now that you know what the interceptor pattern is and how you can create functional HTTP interceptors, let’s move on to the Redux pattern.\nRedux pattern\nThe **Redux pattern** is another commonly used design pattern within Angular applications. When you think about the Redux pattern, you might think of the Redux library, commonly used within the React framework, but the Redux pattern and the Redux library are two different things. The Redux pattern is a design pattern implemented by multiple state management libraries. Within Angular, the Redux pattern is commonly implemented by using the *NgRx* or *NgXs* state management libraries.\nThe Redux pattern focuses on predictable state management where the entire application state is stored in a single immutable state tree. The core principles of Redux involve defining actions that describe state changes and reducers that specify how those actions modify the state. The Redux pattern enforces a unidirectional data flow, allowing data changes to flow in a single direction, from actions to reducers to updating the application state. Changes to the state are made with pure functions called reducers (pure functions are functions that have the same output given the same input without performing any side effects). Retrieving the state is done by using pure functions named selectors.\nIn Angular applications, we create reactive code using observable streams. Because Angular uses observable streams, the libraries implementing the Redux pattern for Angular combine it with RxJS so that we can use the Redux Pattern in a reactive manner. This means actions are dispatched asynchronously, and you can use RxJS pipe operators in combination with the selectors for your state.\nThe Redux pattern is a bit too complex to explain in a couple of paragraphs, so we will come back to this topic in [*Chapter 8*](B21625_08.xhtml#_idTextAnchor150). For now, you just need to know that the Redux pattern focuses on handling state in an immutable and unidirectional way and has four key elements:\n\n*   **Actions**: It describes unique events to modify the state.\n*   **Reducers**: It has pure function implementations to modify the state based on the described actions.\n*   **Selectors**: It has a pure function to retrieve pieces of the state.\n*   **Store**: It has a class defining the state.\n\nYou now know about creational, structural, and behavioral design patterns within Angular applications. You learned about patterns such as the singleton, factory, decorator, facade, observer, and Redux patterns. You learned when these patterns are used by the framework and how you can use them to improve your code.\nBuilding a generic HTTP service containing a model adapter\nTo build your generic HTTP service with a model adapter, start by creating a new library named `generic-http of type data-access` in the domain shared. In this library, create a file named `generic-http.service.ts` and a file named `model-adapter.interface.ts`.\nInside the `model-adapter` interface file, add this interface:\n\n```", "```js\n\n We use generic types so we can make our model adapter type-safe. The `T` and `S` are placeholders for the **data transfer object** (**DTO**) and frontend model we will provide to the adapter. After creating the interface, start with the generic HTTP service.\nThe generic HTTP service will need a property for the API URL and the default HTTP headers, and the service needs to inject the HTTP client.\n\n```", "```js\n\n As you can see, we also use generic types in the model adapter so we can maintain a type-safe generic HTTP service. For the HTTP service, we will also use the `T` and `S` as placeholders for the generic types. Next, we add the `constructor` so we can pass an API endpoint, base URL, and model adapter to the generic HTTP service:\n\n```", "```js\n\n Inside the `constructor` function brackets, we will construct the API URL from the base URL and the endpoint we receive from the constructor parameters. Now, you need to implement the API requests. The generic HTTP service will be used for common API requests: `get`, `get by id`, `post`, `put`, `patch`, and `delete`. Each request will use the URL we constructed, so this approach will only work if your API shares the same API route for these requests. Otherwise, you need to add an additional parameter to your constructor for the API routes (this can be done with a `Record` class, for example).\nThe API requests will include the request headers, and there will be an option to append additional headers if needed. Each request will also implement the model adapter so the objects received from the API will automatically be adapted to the frontend models. Here is an example of the `get` and `post` request:\n\n```", "```js\n\n You can implement the other requests by yourself or take them from the GitHub repository from this book.\nAs you can see, the requests implement a function `prepareRequestOptions`. This `prepare` **RequestOptions** function is used to append additional API headers if needed. The implementation for this function looks as follows:\n\n```", "```js\n\n Now you can add additional HTTP headers if needed. Now that you’ve created a generic HTTP service, let’s explore how you can use the service.\nUsing the generic HTTP service\nUsing the generic HTTP service is done with inheritance when you create other HTTP services. For example, we need an HTTP service in our finance `data-access` library to get, update, and delete our expenses. Suppose you’re not using the generic HTTP service with a model adapter. In that case, you will create an HTTP file in the finance `data-access` library that would look similar to the generic HTTP file, only with predefined types API URLs and models.\nBecause all these HTTP services commonly look more or less the same, with the exception of the API URL and the models, we created the generic HTTP service so we don’t have to rewrite the same every time. Instead, we can inherit the generic HTTP service and share the common functionality.\nLet’s implement the generic HTTP service and start by creating a new folder named `HTTP` inside the finance `data-access` library in your *Nx monorepo*. Inside this new `HTTP` folder, create a file named `expenses.http.ts`. In the `expenses.http.ts` file, you have to create an `ExpensesHttpService` like this:\n\n```", "```js\nexport interface ExpenseDto {\n  id: number | null;\n  title: string;\n  amount: number;\n  vatPercentage: number;   date: string;\n  tags?: string[];\n}\nexport interface ExpenseModel {\n  id: number | null;\n  description: string;\n  amount: {\n    amountExclVat: number;\n    vatPercentage: number;\n  };\n  date: string;\n  tags?: string[];\n}\n```", "```js\nexport class ExpensesModelAdapter implements ModelAdapter<ExpenseDto, ExpenseModel> {\n  fromDto(dto: ExpenseDto): ExpenseModel {\n    return {\n      description: dto.title,\n      amount: {\n        amountExclVat: dto.amount,\n        vatPercentage: dto.vatPercentage\n      },\n      date: dto.date,\n      tags: dto.tags,\n      id: dto.id\n    };\n  }\n  toDto(model: ExpenseModel): ExpenseDto {\n    return {\n      id: model.id ? model.id : null,\n      title: model.description,\n      amount: model.amount.amountExclVat,\n      vatPercentage: model.amount.vatPercentage,\n      date: model.date,\n      tags: model.tags ? model.tags : []\n    };\n  }\n}\n```", "```js\n@Injectable({\n  providedIn: 'root'\n})\nexport class ExpensesHttpService extends GenericHttpService<ExpenseDto, ExpenseModel> {\n  constructor() {\n    super(\n      ‹/expenses',\n      ‹›,\n      new ExpensesModelAdapter()\n    );\n  }\n}\n```", "```js\nGenericHttpService<ExpenseDto, ExpenseModel>\n```", "```js\nGenericHttpService<T, S>\n```", "```js\nprotected readonly expensesApi = inject(ExpensesHttpService);\n```", "```js\nthis.expensesApi.get()\n  .pipe(takeUntilDestroyed(this.destroyRef))\n  .subscribe((data) => { console.log(‹data ==>›, data); });\n```", "```js\nexport const MockInterceptor: HttpInterceptorFn = (\n  req: HttpRequest<unknown>,\n  next: HttpHandlerFn,\n) => {\n  if (!isDevMode()) return next(req);\n  const clonedRequest = req.clone({\n    url: `assets${req.url}.json`,\n    method: ‹GET›,\n  });\n  return next(clonedRequest).pipe(\n    map((event: HttpEvent<unknown>) => {\n      if (event instanceof HttpResponse && req.method !== 'GET') {\n        // Modify the response body here\n        return event.clone({ body: req.body });\n      }\n      return event;\n    }));\n};\n```", "```js\n[\n  {\n    \"id\": 1,\n    \"title\": \"Office Supplies\",\n    \"amount\": 50.0,\n    \"vatPercentage\": 20,\n    \"date\": \"2019-01-04\",\n    \"tags\": [\n       \"printer\"\n    ]\n  },\n  ………\n]\n```", "```js\nprovideHttpClient(withInterceptors([ApplicationConfig, your API request will return with your mock data for GET requests and the request body for all other types of requests.\nIf you make API requests to other API endpoints, you need to add additional JSON files in the `assets` folder to mock the response for these requests. That was it for the generic HTTP service and model adapter. In the next chapter, we will start implementing RxJS and signals and use the observer pattern in practice.\nSummary\nIn this chapter, you learned about Angular code conventions and best practices. You learned about naming conventions for your folders and files and naming conventions for properties, functions, and classes within your Angular applications. You also learned about best practices to improve performance and prevent bugs and hard-to-debug code.\nBesides conventions and best practices, we looked at some of the most commonly used design patterns within Angular applications. You learned when the Angular framework uses specific patterns and how you can write cleaner and more scalable code using design patterns such as the facade, decorator, and inheritance patterns.\nWe finished the chapter by creating a generic HTTP service using the inheritance pattern. The HTTP service can easily be used to construct HTTP services for all your data access libraries. The generic HTTP service also has a model adapter to transform DTOs into your frontend models automatically. Lastly, because we don’t have an API, we made an HTTP interceptor to intercept our HTTP requests and provide mock data.\nIn the next chapter, we will learn about reactive programming and implement RxJS and signals within our expenses application.\n\n```", "```js\n\n```", "```js\n\n```"]