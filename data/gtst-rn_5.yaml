- en: Chapter 5. Displaying and Saving Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章。显示和保存数据
- en: Now that we know how to style a React Native application, let's figure out how
    to actually make it do something. In this chapter, we'll start saving notes to
    the device, populate a list with the notes we've saved, and select notes from
    the list to view and edit.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何为 React Native 应用程序设置样式，让我们来看看如何让它真正做些事情。在本章中，我们将开始将笔记保存到设备上，用我们保存的笔记填充列表，并从列表中选择笔记以查看和编辑。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Using a `ListView` to display rows of data
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ListView` 显示数据行
- en: Managing state
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态管理
- en: Using props to pass data and callbacks into components
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 props 将数据和回调传递到组件中
- en: Using `AsyncStorage` to store data on both iOS and Android devices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `AsyncStorage` 在 iOS 和 Android 设备上存储数据
- en: Our strategy in this chapter is to first build the basic functionality using
    dummy data so we can learn some fundamental skills before we learn about saving
    and loading the data with the `AsyncStorage` API. By the end of the chapter, you
    will have a fully functional note-taking application!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的策略是首先使用虚拟数据构建基本功能，这样我们就可以在学习如何使用 `AsyncStorage` API 保存和加载数据之前学习一些基本技能。到本章结束时，您将拥有一个完全功能的笔记应用程序！
- en: Lists
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表
- en: 'The `HomeScreen` of our application is going to display a list of the notes
    that we have saved. To do this, we will introduce the `ListView` component. Let''s
    start by creating a new file in our `Components` directory called `NoteList` and
    add the following code:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的 `HomeScreen` 将显示我们已保存的笔记列表。为此，我们将引入 `ListView` 组件。让我们首先在我们的 `Components`
    目录中创建一个名为 `NoteList` 的新文件，并添加以下代码：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `ListView` component is fairly simple to use. You must provide two pieces
    of information, the `dataSource` that will provide the data for all of the rows
    and the `renderRow` function, which is simply a function that takes each row's
    data (a single note) and returns a React component. In the preceding example,
    this function returns a `<Text/>` component that displays the title of the note.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListView` 组件使用起来相当简单。您必须提供两块信息，一个是提供所有行数据的 `dataSource`，另一个是 `renderRow` 函数，它是一个简单的函数，接受每一行的数据（一个单独的笔记）并返回一个
    React 组件。在上面的示例中，这个函数返回一个 `<Text/>` 组件，用于显示笔记的标题。'
- en: We instantiate a `ListView`. The `DataSource` is in the constructor because
    we only want to create it once. The `DataSource` constructor takes a `params`
    object to configure the `DataSource`; however, the only required parameter is
    a `rowHasChanged` function. This function is used by the `DataSource` when it
    receives new data so that it can efficiently determine which rows need to be re-rendered.
    If `r1` and `r2` point to the same object, the row hasn't changed.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实例化一个 `ListView`。`DataSource` 在构造函数中，因为我们只想创建一次。`DataSource` 构造函数接受一个 `params`
    对象来配置 `DataSource`；然而，唯一必需的参数是一个 `rowHasChanged` 函数。当 `DataSource` 收到新数据时，该函数被
    `DataSource` 使用，以便它可以有效地确定哪些行需要重新渲染。如果 `r1` 和 `r2` 指向同一个对象，则行没有变化。
- en: You'll also notice that we don't pass the `DataSource` reference directly to
    our `ListView`. Instead we use `cloneWithRows()`, passing it to the `rowData`
    we want to use. We're hardcoding the row data for now, but by the end of this
    chapter you will know how to update the `ListView` with new data.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您还会注意到我们没有直接将 `DataSource` 引用传递给我们的 `ListView`。相反，我们使用 `cloneWithRows()`，将其传递给我们要使用的
    `rowData`。目前我们正在硬编码行数据，但到本章结束时，您将知道如何使用新数据更新 `ListView`。
- en: 'Next, let''s add the `NoteList` component to the `HomeScreen` and learn how
    to respond to touch events on each row. Open the `HomeScreen` component and add
    the following line to import your new `NoteList` component:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将 `NoteList` 组件添加到 `HomeScreen` 中，并学习如何响应对每一行的触摸事件。打开 `HomeScreen` 组件，并添加以下行以导入您的新
    `NoteList` 组件：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Also, let''s drop the `NoteList` component into `HomeScreen''s` `render` method
    just inside the `View` component, before the `<Text/>` component:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，让我们将 `NoteList` 组件放入 `HomeScreen` 的 `render` 方法中，在 `View` 组件内，在 `<Text/>`
    组件之前：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Before we try out our `NoteList`, let''s modify our styles to make sure that
    the list content isn''t obscured by the `NavigationBar`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们尝试 `NoteList` 之前，让我们修改我们的样式以确保列表内容不会被 `NavigationBar` 遮挡：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, when you reload the application you should see the following screenshot:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您重新加载应用程序时，您应该看到以下截图：
- en: '![Lists](img/B05162_05_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![列表](img/B05162_05_01.jpg)'
- en: We still have the **You haven't created any notes!** Message at the bottom of
    the screen, but we'll learn how to take care of that later in the chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕底部仍然显示着**您还没有创建任何笔记**的消息，但我们将学习如何在章节的后面处理这个问题。
- en: 'Now that we have a list of items, we''d like to be able to respond when the
    user touches one of the items. To do that, we''ll wrap the `<Text/>` component
    in our `renderRow` function with the `TouchableHighlight` component. First, let''s
    add `TouchableHighlight` to our list of imports:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个项目列表，我们希望当用户触摸其中一个项目时能够做出响应。为了做到这一点，我们将使用`TouchableHighlight`组件包裹我们的`renderRow`函数中的`<Text/>`组件。首先，让我们将`TouchableHighlight`添加到我们的导入列表中：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then update the `renderRow` function in our `ListView`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然后更新我们的`ListView`中的`renderRow`函数：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, you can reload the application and touch each row to see that the `rowData`
    has been logged to the console.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以重新加载应用程序并触摸每一行，以查看`rowData`已经被记录到控制台。
- en: 'Our goal is to be able to touch a row, navigate to the `NoteScreen`, and populate
    the title and body with the data from the row. Let''s add an `_onPress` event
    handler to our `NoteList` component, as shown:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目的是能够触摸一行，导航到`NoteScreen`，并使用该行的数据填充标题和正文。让我们给我们的`NoteList`组件添加一个`_onPress`事件处理程序，如下所示：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And we will call this function from our `TouchableHighlight`, as shown:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个`TouchableHighlight`函数中调用这个函数，如下所示：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Before we try this out, take a look at the `_onPress` handler and notice that
    we are referring to `this.props.navigator`. This is the navigator that we've been
    using to go back and forth between the `HomeScreen` and the `NoteScreen`, but
    what's this props business?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们尝试这个功能之前，看看`_onPress`处理程序，并注意我们正在引用`this.props.navigator`。这是我们用来在`HomeScreen`和`NoteScreen`之间来回导航的导航器，但这个props业务是什么意思呢？
- en: Understanding props
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解props
- en: 'If you take a look at the constructor function of the `NoteList`, you will
    notice that it takes an argument called **props**:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看看`NoteList`的构造函数，你会注意到它接受一个名为**props**的参数：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Props is the mechanism we use to pass data to React components. In our case,
    we want to pass a navigator reference from the `HomeScreen` component to the `NoteList`,
    so let''s make a quick change to our `NoteList` declaration, as shown:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Props是我们用来向React组件传递数据的机制。在我们的例子中，我们想从`HomeScreen`组件传递一个导航器引用到`NoteList`，所以让我们快速修改一下我们的`NoteList`声明，如下所示：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When you touch a row in the `NoteList`, you push the note data associated with
    that row to the navigator, which then triggers `renderScene` that passes the note
    to the `NoteScreen`. So how do we use this note inside the `NoteScreen`? We learned
    earlier that props are passed into the component''s constructor, but how do we
    actually get our `TextInput` components to display the note''s title and body?
    Let''s see what happens if we bind the value property of each of our inputs to
    the passed-in note, as shown:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在`NoteList`中触摸一行时，你将把与该行相关的笔记数据推送到导航器，然后触发`renderScene`，将笔记传递给`NoteScreen`。那么我们如何在`NoteScreen`中使用这个笔记呢？我们之前了解到props被传递到组件的构造函数中，但我们如何实际上让我们的`TextInput`组件显示笔记的标题和正文呢？让我们看看如果我们将每个输入的值属性绑定到传入的笔记会发生什么，如下所示：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now when we reload the application and touch the first note in the list, we
    will see the following screenshot:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们重新加载应用程序并触摸列表中的第一个笔记时，我们将看到以下截图：
- en: '![Understanding props](img/B05162_05_02.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![理解props](img/B05162_05_02.jpg)'
- en: 'But what happens when you try to edit the title or body? Nothing happens! Before
    we diagnose what is wrong, let''s tap the **Back** button and touch the second
    note in the `NoteList`. You will see it displayed, as shown:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 但当你尝试编辑标题或正文时会发生什么？什么都没有发生！在我们诊断出问题之前，让我们点击**返回**按钮并触摸`NoteList`中的第二个笔记。你会看到它被显示出来，如下所示：
- en: '![Understanding props](img/B05162_05_03.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![理解props](img/B05162_05_03.jpg)'
- en: Ok, so our `NoteScreen` does update, but only when we pass it new props from
    outside, not when we try to edit the `TextInputs`. Props can only be passed from
    the outside of a component. As tempting as it may seem, it's a bad idea to try
    to modify `this.props.note` from inside the `NoteScreen` when the value of each
    `TextInput` changes. What we need instead is some way to manage the changes made
    to the internal state of our `NoteScreen` when the user makes changes to the `TextInputs`.
    For that, each React component has something called **state**.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，所以我们的 `NoteScreen` 确实更新了，但只是在从外部传递新的 props 时，而不是在我们尝试编辑 `TextInputs` 时。Props
    只能从组件外部传递。虽然这样做可能很有吸引力，但在每个 `TextInput` 的值改变时尝试在 `NoteScreen` 内部修改 `this.props.note`
    是一个坏主意。我们需要的是一种方式来管理用户更改 `TextInputs` 时对 `NoteScreen` 内部状态的更改。为此，每个 React 组件都有一个叫做
    **状态** 的东西。
- en: Using state
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用状态
- en: 'React components have a built-in variable called `state` that you can use to
    keep track of the component''s `state`. In the preceding example, we know that
    we are passing in a note that we want to display, so the initial state of the
    component is represented by that note. Let''s do something totally crazy and modify
    the `NoteScreen` constructor, as shown:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: React 组件有一个内置的变量叫做 `state`，你可以用它来跟踪组件的 `state`。在上面的例子中，我们知道我们正在传递一个我们想要显示的笔记，因此组件的初始状态由那个笔记表示。让我们做一些完全疯狂的事情，修改
    `NoteScreen` 构造函数，如下所示：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: So, `this.state` is an object with title and body properties that are initially
    set to the title and body of the note we passed. Why the call to *super (props)?*
    The superclass of our `NoteScreen` is `React.Component`, which takes props as
    an argument and sets `this.props`. If we omit `super(props)` in `NoteScreen`,
    then `this.props` will be undefined.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`this.state` 是一个具有标题和正文属性的初始设置为传递的笔记标题和正文的对象。为什么会有对 *super (props)* 的调用？我们的
    `NoteScreen` 的超类是 `React.Component`，它将 props 作为参数并设置 `this.props`。如果我们省略 `NoteScreen`
    中的 `super(props)`，那么 `this.props` 将是未定义的。
- en: 'You may have already guessed that we''re going to update the `TextInputs` to
    bind to `this.state.title` and `this.state.body` respectively, but we''re also
    going to listen for `onChangeText` events for each input:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经猜到了，我们将更新 `TextInputs` 以分别绑定到 `this.state.title` 和 `this.state.body`，但我们还将监听每个输入的
    `onChangeText` 事件：
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that the `arrow` function that we're using to handle the `onChangeText`
    event is calling `this.setState(...)` instead of directly setting `this.state.title`.
    This is an important thing to remember. Anytime you modify state you must use
    `this.setState()` so that React knows that your component needs to be re-rendered.
    For performance reasons, calling `setState()` doesn't immediately update `this.state`,
    so don't let that trip you up!
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们用来处理 `onChangeText` 事件的箭头函数正在调用 `this.setState(...)` 而不是直接设置 `this.state.title`。这是一个重要的事情要记住。每次修改状态时，你必须使用
    `this.setState()`，这样 React 就知道你的组件需要重新渲染。出于性能原因，调用 `setState()` 并不会立即更新 `this.state`，所以不要因此困惑！
- en: 'Reload the application, touch **Note 1** in the list and then change the title
    to **My note**:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载应用程序，触摸列表中的 **笔记 1**，然后将标题更改为 **我的笔记**：
- en: '![Using state](img/B05162_05_04.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![使用状态](img/B05162_05_04.jpg)'
- en: The `TextInput` attribute now reflects the value of `this.state.title` on every
    call to `render()`, which happens after every call to `this.setState({title})`.
    So far so good, but what do you think we will see when we navigate back to the
    `HomeScreen`? Tap the **Back** button and take a look —the title of the first
    note is still **Note 1** instead of **My note**. Now, when you click on **Note
    1** to go back to the `NoteScreen` you'll see that your changes have disappeared.
    Let's fix this!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextInput` 属性现在在每次调用 `render()` 时都会反映 `this.state.title` 的值，这发生在每次调用 `this.setState({title})`
    之后。到目前为止一切顺利，但当你导航回 `HomeScreen` 时，你认为我们会看到什么？点击 **返回** 按钮看看——第一个笔记的标题仍然是 **笔记
    1** 而不是 **我的笔记**。现在，当你点击 **笔记 1** 返回到 `NoteScreen` 时，你会看到你的更改已经消失了。让我们来修复这个问题！'
- en: We've just identified the need to update our `ListView` when a note is changed.
    We know that the internal state of the `NoteScreen` changes when we type into
    the `TextInput` components, but how do we communicate these changes to the rest
    of the application?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚确定了在笔记更改时需要更新我们的 `ListView`。我们知道当我们在 `TextInput` 组件中输入时，`NoteScreen` 的内部状态会发生变化，但我们如何将这些更改传达给应用程序的其他部分？
- en: Passing callbacks in props
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 props 中传递回调
- en: 'A common pattern in React is to pass a callback to a component via props. In
    our case, we want to pass a callback to our `NoteScreen` so that it can let us
    know when the note is changed. Let''s return to the `ReactNotes` component in
    our `index.ios.js` or `index.android.js` file and update our `renderScene` function,
    as shown:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 中，一个常见的模式是通过 props 将回调传递给组件。在我们的情况下，我们想要将一个回调传递给我们的 `NoteScreen`，以便它能够让我们知道笔记何时被更改。让我们回到我们的
    `index.ios.js` 或 `index.android.js` 文件中的 `ReactNotes` 组件，并更新我们的 `renderScene`
    函数，如下所示：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here, we are defining a prop called `onChangeNote` and setting its value to
    an arrow function that will be called when we invoke `onChangeNote` inside our
    `NoteScreen` component. So, somewhere inside our `NoteScreen` code we''re going
    to add the following line:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个名为 `onChangeNote` 的属性，并将其值设置为当我们在 `NoteScreen` 组件内部调用 `onChangeNote`
    时将被调用的箭头函数。所以，在我们的 `NoteScreen` 代码内部，我们将添加以下行：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s revisit the `NoteScreen` and a function to handle the updating of notes:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下 `NoteScreen` 和一个用于更新笔记的函数：
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In our title `TextInput`, update the `onChangeText` function, as shown:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的标题 `TextInput` 中，更新 `onChangeText` 函数，如下所示：
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And in the body `TextInput`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 并且在 `TextInput` 的主体中：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now let''s reload our application, touch **Note 1**, and start making changes.
    If you look at the console you should see each change being logged:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重新加载我们的应用程序，触摸**笔记 1**，并开始进行更改。如果你查看控制台，你应该会看到每次更改都被记录下来：
- en: '![Passing callbacks in props](img/B05162_05_05.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![在 props 中传递回调](img/B05162_05_05.jpg)'
- en: 'Getting notified of the changes to a note only gets us halfway to our goal
    to update the `ListView`. Recall that our `NoteList` component''s `dataSource`
    is currently just a hardcoded array of notes:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 仅通过通知笔记的更改，我们只完成了更新 `ListView` 目标的一半。回想一下，我们的 `NoteList` 组件的 `dataSource` 目前只是一个硬编码的笔记数组：
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We need to be able to pass in the list of notes to the `NoteList` component
    instead of hardcoding them. Now that you''re familiar with props, you know that
    we can pass the list in from the `HomeScreen`, as shown:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要能够将笔记列表传递给 `NoteList` 组件而不是硬编码它们。现在，由于你已经熟悉了 props，你知道我们可以从 `HomeScreen`
    中传递列表，如下所示：
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then modify the `NoteList` component to use `this.props.notes` in the `dataSource`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后修改 `NoteList` 组件以在 `dataSource` 中使用 `this.props.notes`：
- en: '[PRE20]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s take our refactoring one step further. We don''t really want the `HomeScreen`
    to be responsible for managing the state of our list of notes, that''s a job for
    our top-level component, `ReactNotes`. We can repeat the same trick we just used
    and replace the hardcoded array of notes in `HomeScreen` with `this.props.notes`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把重构再进一步。我们并不想让 `HomeScreen` 负责管理笔记列表的状态，这是一个顶级组件 `ReactNotes` 的工作。我们可以重复我们刚刚使用的技巧，并用
    `this.props.notes` 替换 `HomeScreen` 中的硬编码的笔记数组：
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In our `ReactNotes` component, we can pass the notes to the `HomeScreen` using
    props:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `ReactNotes` 组件中，我们可以使用 props 将笔记传递给 `HomeScreen`：
- en: '[PRE22]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You may sense that we are getting tantalizingly close to our goal of being able
    to modify notes and see the changes in the `ListView`. The source of our notes
    is now in close proximity to the event handler that knows when the user has modified
    a note on the `NoteScreen`. What we're really talking about here is managing the
    state of our application.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会感觉到我们正越来越接近我们的目标，即能够修改笔记并在 `ListView` 中看到更改。我们笔记的来源现在与知道用户在 `NoteScreen`
    上修改了笔记的事件处理程序非常接近。我们真正讨论的是管理我们应用程序的状态。
- en: 'The `ReactNotes` component is the top-level component that is responsible for
    managing the application state, which consists entirely of notes. So, let''s make
    it official and move the array of notes into the component''s initial state:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReactNotes` 组件是负责管理应用程序状态的最高级组件，该状态完全由笔记组成。所以，让我们正式一下，将笔记数组移动到组件的初始状态中：'
- en: '[PRE23]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Storing notes in an array makes it a little tricky to update a particular note;
    let''s do a quick refactor using an object instead of an array, as shown:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 将笔记存储在数组中使得更新特定笔记变得有些棘手；让我们快速重构，使用对象而不是数组，如下所示：
- en: '[PRE24]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, `notes` is the object in which the keys correspond to the `ids` of the
    notes. Since the `NoteList` component is still expecting an array, let''s use
    `underscore.js` to do the conversion:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`notes` 是一个对象，其中的键对应于笔记的 `ids`。由于 `NoteList` 组件仍然期望一个数组，让我们使用 `underscore.js`
    来进行转换：
- en: '[PRE25]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `NoteList` should continue to function the way it did earlier; we are just
    keeping track of our notes a little differently.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`NoteList` 应该继续以之前的方式工作；我们只是以不同的方式跟踪我们的笔记。'
- en: 'Here are the changes that we need to make for the `onChangeNote` handler to
    actually update a note via state:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们需要为`onChangeNote`处理程序所做的更改，以便实际上通过状态更新笔记：
- en: '[PRE26]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Let's walk through the `updateNote` function to understand what's happening.
    First, we create a copy of `this.state.notes` using `Object.assign()`. Any time
    you work with nested data in your state object, we recommend making a copy like
    this to avoid unexpected behavior. React compares the two objects to determine
    if a component's state has changed and needs to be re-rendered; hence, using a
    copy like this ensures that the old state and the new state point to different
    objects. We then put our modified note into `newNotes` using `note.id` as the
    key. Lastly, we call `setState()` to replace the entire notes object with the
    new copy.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步分析`updateNote`函数，以了解发生了什么。首先，我们使用`Object.assign()`创建`this.state.notes`的一个副本。每次你在状态对象中处理嵌套数据时，我们都建议创建这样的副本，以避免意外的行为。React通过比较两个对象来确定组件的状态是否已更改，需要重新渲染；因此，使用这样的副本确保旧状态和新状态指向不同的对象。然后，我们使用`note.id`作为键将我们的修改后的笔记放入`newNotes`中。最后，我们调用`setState()`来用新的副本替换整个笔记对象。
- en: 'We''ve got a few more refactorings to do before we can try out our handiwork.
    Now that we know how to pass callbacks to our components via props, we can eliminate
    the need to pass in a navigator to the `HomeScreen` and `NoteList` components,
    and instead pass in a callback so that the `NoteList` can tell us when the user
    has selected a note:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以尝试我们的手艺之前，我们还有一些重构要做。现在我们知道如何通过props将回调传递给我们的组件，我们可以消除将导航器传递给`HomeScreen`和`NoteList`组件的需要，而是传递一个回调，这样`NoteList`就可以告诉我们用户是否已选择了一个笔记：
- en: '[PRE27]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This means that we have to update our `HomeScreen` to pass the `onSelectNote`
    callback into the `NoteList`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们必须更新我们的`HomeScreen`，将`onSelectNote`回调传递给`NoteList`：
- en: '[PRE28]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Also, we''ll have to update `NoteList`. We no longer need the `_onPress` handler
    or a reference to the navigator, we can just invoke the provided callback with
    `rowData`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要更新`NoteList`。我们不再需要`_onPress`处理程序或导航器的引用，我们只需使用`rowData`调用提供的回调即可：
- en: '[PRE29]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You should now be able to reload the application, touch a note, change the
    title, go back, and see the updated title appear in the `NoteList`, as shown in
    the following screenshot:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能够重新加载应用程序，触摸一个笔记，更改标题，返回，并看到更新的标题出现在`NoteList`中，如下面的截图所示：
- en: '![Passing callbacks in props](img/B05162_05_06.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![通过props传递回调](img/B05162_05_06.jpg)'
- en: 'When you select a note and navigate to the `NoteScreen`, the title that appears
    in the `NavigationBar` is still **Create Note**. Let''s modify it, so that even
    if we select an existing note from the list, we use the note''s title instead
    of **Create Note**:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当你选择一个笔记并导航到`NoteScreen`时，在`NavigationBar`中显示的标题仍然是**创建笔记**。让我们修改它，这样即使我们从列表中选择一个现有的笔记，我们也使用笔记的标题而不是**创建笔记**：
- en: '[PRE30]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'When you reload the application, the `NoteScreen` should reflect the title
    of the selected note:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当你重新加载应用程序时，`NoteScreen`应该反映所选笔记的标题：
- en: '![Passing callbacks in props](img/B05162_05_07.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![通过props传递回调](img/B05162_05_07.jpg)'
- en: Creating new notes
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建新笔记
- en: 'So far, we''ve been updating existing notes. How do we add new ones? Well,
    that''s actually very easy. We just need to update the **Create Note** button
    in the `NavigationBar`, as shown:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在更新现有的笔记。我们如何添加新的笔记？实际上，这非常简单。我们只需要更新`NavigationBar`中的**创建笔记**按钮，如下所示：
- en: '[PRE31]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can see, we're now passing an empty note with a generated id. (A better
    approach to generate ids will be to use a `uuid` generator, but we'll leave that
    as an exercise for the reader!)
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们现在传递了一个带有生成id的空笔记。 (生成id的一个更好的方法是将`uuid`生成器用于，但我们将把这个作为读者的练习！)
- en: That's it! We finally have a full, end-to-end note taking application! However,
    our notes only exist in memory. We need to be able to save notes to the device,
    so let's meet our new friend, `AsyncStorage`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们终于拥有了一个完整的、端到端的笔记应用！然而，我们的笔记只存在于内存中。我们需要能够将笔记保存到设备上，所以让我们认识我们的新朋友，`AsyncStorage`。
- en: Using AsyncStorage
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用AsyncStorage
- en: React Native provides an abstraction over the native local storage mechanism
    so that you don't have to worry about the underlying differences between how iOS
    and Android save data to the device.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: React Native提供了一个本地存储机制的抽象，这样你就不必担心iOS和Android在设备上保存数据时的底层差异。
- en: 'It''s really simple to use, so let''s update our `ReactNotes` component to
    use `AsyncStorage`. First, let''s add `AsyncStorage` to our list of imports:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 它的使用非常简单，所以让我们更新我们的`ReactNotes`组件以使用`AsyncStorage`。首先，让我们将`AsyncStorage`添加到我们的导入列表中：
- en: '[PRE32]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, let''s add a `saveNotes()` function:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们添加一个`saveNotes()`函数：
- en: '[PRE33]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You may be wondering what the `async` and `await` keywords are doing in your
    JavaScript! These are new keywords in ES7 that simplify working with promises.
    The `AsyncStorage` methods are, well, asynchronous and they return promises. Without
    going into too much detail, the `async` keyword in front of a function allows
    us to use the await keyword within the function body. The await keyword will resolve
    the promise, and if there's a problem, it will throw an error.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道JavaScript中的`async`和`await`关键字在做什么！这些是ES7中的新关键字，它们简化了与promises的工作。`AsyncStorage`方法实际上是异步的，并且返回promises。不深入细节，函数前面的`async`关键字允许我们在函数体内使用`await`关键字。`await`关键字将解析promise，如果出现问题，它将抛出一个错误。
- en: 'Let''s modify our `updateNote` function to call our new `saveNotes` function:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改我们的`updateNote`函数来调用我们新的`saveNotes`函数：
- en: '[PRE34]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We''ll also need a function to `loadNotes` from `AsyncStorage`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个函数来从`AsyncStorage`中`loadNotes`：
- en: '[PRE35]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We want to load our saved notes from the device in our constructor:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想在构造函数中从设备加载我们的已保存笔记：
- en: '[PRE36]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Reload your application, and save the changes made to a note or create a new
    note. Then reload the application again. Your changes have been saved! We just
    have one more job to do, deleting notes!
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载你的应用程序，并保存对笔记所做的更改或创建一个新的笔记。然后再次重新加载应用程序。你的更改已经保存！我们只剩下一个任务要做，那就是删除笔记！
- en: Deleting notes
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除笔记
- en: 'The last thing we need to do before we have a fully functional note-taking
    application is to add a **Delete** button to our `NoteScreen`. To accomplish that,
    we''ll update our `NavigationBarRouteMapper` to add a `RightButton` when the route
    name is `createNote`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们拥有一个完全功能的笔记应用之前，我们需要做的最后一件事是在我们的`NoteScreen`中添加一个**删除**按钮。为了实现这一点，我们将更新我们的`NavigationBarRouteMapper`，在路由名为`createNote`时添加一个`RightButton`：
- en: '[PRE37]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The first thing to notice is that I've added a condition to check if the note
    has already been saved (we will need to tweak our `updateNote` function to set
    this). This is to make sure that the **Delete** button doesn't show up for new
    notes. The `Create Note` `onPress` handler has been updated to set `isSaved =
    false` in the empty note that we pass to the `NoteScreen`, when that button is
    pressed.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，我添加了一个条件来检查笔记是否已经被保存（我们需要调整我们的`updateNote`函数来设置这个）。这是为了确保**删除**按钮不会出现在新笔记上。当按下按钮时，`Create
    Note`的`onPress`处理程序已被更新，将`isSaved`设置为`false`，在传递给`NoteScreen`的空笔记中。
- en: 'Now, let''s look at the `onPress` handler for the **Delete** button:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看**删除**按钮的`onPress`处理程序：
- en: '[PRE38]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We''ve seen `navigator.pop()` before, but we''re also invoking a new callback
    called `onDeleteNote`. We need to pass that callback in through props in our `ReactNotes`
    `render` function:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前见过`navigator.pop()`，但我们还调用了一个新的回调函数`onDeleteNote`。我们需要通过`ReactNotes`的`render`函数中的props传递这个回调函数：
- en: '[PRE39]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, we need to modify our `updateNote` function to mark the notes that have
    been saved:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要修改我们的`updateNote`函数来标记已保存的笔记：
- en: '[PRE40]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Just below that, we''ll add the `deleteNote` function:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在那下面，我们将添加`deleteNote`函数：
- en: '[PRE41]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'That''s it! Reload the application and create a new note. Notice that there
    is no **Delete** button in the `NavigationBar`. Press the **Back** button to view
    the note in the list, then tap that item in the list to view it. You should be
    able to see the **Delete** button in the top right corner, as shown:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！重新加载应用程序并创建一个新的笔记。注意在`NavigationBar`中没有**删除**按钮。按下**返回**按钮查看列表中的笔记，然后点击列表中的该项来查看。你应该能在右上角看到**删除**按钮，如图所示：
- en: '![Deleting notes](img/B05162_05_08.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![删除笔记](img/B05162_05_08.jpg)'
- en: Press the **Delete** button and you will be returned to the `HomeScreen` where
    the deleted note will disappear from the list!
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 按下**删除**按钮，你将被返回到`HomeScreen`，在那里被删除的笔记将从列表中消失！
- en: Summary
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we have created a complete note-taking application. You have
    learned how to use the `ListView` to display data, pass data into components using
    props, keep track of a component's state, and save data to the device using AsyncStorage.
    Moreover, you have done did all of this without writing any `platform-specific`
    code!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经创建了一个完整的笔记应用。你学习了如何使用`ListView`来显示数据，通过props将数据传递到组件中，跟踪组件的状态，以及使用AsyncStorage将数据保存到设备上。此外，你完成所有这些操作而没有编写任何`平台特定`的代码！
