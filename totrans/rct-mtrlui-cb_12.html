<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Autocomplete and Chips - Text Input Suggestions for Multiple Items</h1>
                </header>
            
            <article>
                
<p>In this <span>chapter, you will learn the following topics</span>:<br/></p>
<ul>
<li>Building an Autocomplete component </li>
<li>Selecting Autocomplete suggestions</li>
<li>API-driven Autocomplete</li>
<li>Highlighting search results</li>
<li>Standalone chip input</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>Web application<span>s typically provide autocomplete input fields when there are too many choices to select from. Autocomplete fields are like text input fields—as users starts typing, they are given a smaller list of choices based on what they've typed. Once the user is ready to make a selection, the actual input is filled with components called </span><kbd>Chips</kbd>—<span>especially relevant when the user needs to be able to make multiple selections.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building an Autocomplete component</h1>
                </header>
            
            <article>
                
<p>Material-UI doesn't actually come with an <kbd>Autocomplete</kbd> component. The reason is that, since there are so many different implementations of autocomplete selection components in the React ecosystem already, it doesn't make sense to provide another one. Instead, you can pick an existing implementation and augment it with Material-UI components so that it can integrate nicely with your Material-UI application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let's say that you have a selector for a hockey team. But there are too many teams to reasonably fit in a simple select component—you need autocomplete capabilities. You can use the <kbd>Select</kbd> component from the <kbd>react-select</kbd> package to provide the autocomplete functionality that you need. You can use <kbd>Select</kbd> properties to replace key autocomplete components with Material-UI components so that the autocomplete matches the look and feel of the rest of your app.</p>
<p>Let's make a reusable <kbd>Autocomplete</kbd> component. The <kbd>Select</kbd> component allows you to replace certain aspects of the autocomplete experience. In particular, following are the components that you'll be replacing:</p>
<ul>
<li><kbd>Control</kbd>: The text input component to use</li>
<li><kbd>Menu</kbd>: A menu with suggestions, displayed when the user starts typing</li>
<li><kbd>NoOptionsMessage</kbd>: The message that's displayed when there aren't any suggestions to display</li>
<li><kbd>Option</kbd>: The component used for each suggestion in <kbd>Menu</kbd></li>
<li><kbd>Placeholder</kbd>: <span>The </span>placeholder text component for the text input</li>
<li><kbd>SingleValue</kbd>: The component for showing a value once it's selected</li>
<li><kbd>ValueContainer</kbd>: <span>The </span>component that wraps <kbd>SingleValue</kbd></li>
<li><kbd>IndicatorSeparator</kbd>: Separates buttons on the right side of the autocomplete</li>
<li><kbd>ClearIndicator</kbd>: <span>The c</span>omponent used for the button that clears the current value</li>
<li><kbd>DropdownIndicator</kbd>: <span>The </span>component used for the button that shows <kbd>Menu</kbd></li>
</ul>
<p>Each of these components is replaced with Material-UI components that change the look and feel of the autocomplete. Moreover, you'll have all of this as new <kbd>Autocomplete</kbd> components that you can reuse throughout your app.</p>
<p>Let's look at the result before diving into the implementation of each replacement component. Following is what you'll see when the screen first loads:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e8652835-9527-4e14-a21c-a86aaa9c6758.png" style="width:32.08em;height:5.33em;"/></p>
<p>If you click on the down arrow, you'll see a menu with all the values, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/cc087afe-8b45-47d1-b055-0674ad9bc621.png" style="width:28.00em;height:22.33em;"/></p>
<p>Try typing <span class="packt_screen">tor</span> into the autocomplete text field<span>, as follows</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/13533835-14d8-4a30-8bf4-ed22eefce653.png" style="width:29.92em;height:14.58em;"/></p>
<p>If you make a selection, the menu is closed and the text field is populated with the selected value<span>, as follows</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3ab8e42a-a338-42a3-85b8-40854fce22f6.png" style="width:31.58em;height:5.42em;"/></p>
<p>You can change your selection by opening the menu and selecting another value, or you can clear the selection by clicking on the clear button to the right of the text.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Let's break down the source by looking at the individual components that make up the <kbd>Autocomplete</kbd> component and replacing pieces of the <kbd>Select</kbd> component. Then, we'll look at the final <kbd>Autocomplete</kbd> component.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Text input control</h1>
                </header>
            
            <article>
                
<p>Here's the source for the <kbd>Control</kbd> component:</p>
<pre>const inputComponent = ({ inputRef, ...props }) =&gt; (<br/>  &lt;div ref={inputRef} {...props} /&gt;<br/>);<br/><br/>const Control = props =&gt; (<br/>  &lt;TextField<br/>    fullWidth<br/>    InputProps={{<br/>      inputComponent,<br/>      inputProps: {<br/>        className: props.selectProps.classes.input,<br/>        inputRef: props.innerRef,<br/>        children: props.children,<br/>        ...props.innerProps<br/>      }<br/>    }}<br/>    {...props.selectProps.textFieldProps}<br/>  /&gt;<br/>);</pre>
<p>The <kbd>inputComponent()</kbd> function is a component that passes the <kbd>inputRef</kbd> value—a reference to the underlying input element—to the <kbd>ref</kbd> prop. Then, <kbd>inputComponent</kbd> is passed to <kbd>InputProps</kbd> to set the input component used by <kbd>TextField</kbd>. This component is a little bit confusing because it's passing references around and it uses a <kbd>helper</kbd> component for this purpose. The important thing to remember is that the job of <kbd>Control</kbd> is to set up the <kbd>Select</kbd> component to use a Material-UI<kbd>TextField</kbd> component.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Options menu</h1>
                </header>
            
            <article>
                
<p>Here's the component that displays the autocomplete options when the user starts typing or clicks on the down arrow:</p>
<pre>const Menu = props =&gt; (<br/>  &lt;Paper<br/>    square<br/>    className={props.selectProps.classes.paper}<br/>    {...props.innerProps}<br/>  &gt;<br/>    {props.children}<br/>  &lt;/Paper&gt;<br/>);</pre>
<p>The <kbd>Menu</kbd> component renders a Material-UI <kbd>Paper</kbd> component so that the element surrounding the options is themed accordingly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">No options available</h1>
                </header>
            
            <article>
                
<p>Here's the <kbd>NoOptionsMessage</kbd> component. It is rendered when there aren't any autocomplete options to display, as follows:</p>
<pre>const NoOptionsMessage = props =&gt; (<br/>  &lt;Typography<br/>    color="textSecondary"<br/>    className={props.selectProps.classes.noOptionsMessage}<br/>    {...props.innerProps}<br/>  &gt;<br/>    {props.children}<br/>  &lt;/Typography&gt;<br/>);</pre>
<p>This renders a <kbd>Typography</kbd> component with <kbd>textSecondary</kbd> as the <kbd>color</kbd> property value.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Individual option</h1>
                </header>
            
            <article>
                
<p>Individual options that are displayed in the autocomplete menu are rendered using the <kbd>MenuItem</kbd> component, as follows:</p>
<pre>const Option = props =&gt; (<br/>  &lt;MenuItem<br/>    buttonRef={props.innerRef}<br/>    selected={props.isFocused}<br/>    component="div"<br/>    style={{<br/>      fontWeight: props.isSelected ? 500 : 400<br/>    }}<br/>    {...props.innerProps}<br/>  &gt;<br/>    {props.children}<br/>  &lt;/MenuItem&gt;<br/>);</pre>
<p>The <kbd>selected</kbd> and <kbd>style</kbd> properties alter the way that the item is displayed, based on the <kbd>isSelected</kbd> and <kbd>isFocused</kbd> properties. The <kbd>children</kbd> property sets the value of the item.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Placeholder text</h1>
                </header>
            
            <article>
                
<p>The <kbd>Placeholder</kbd> text of the <kbd>Autocomplete</kbd> component is shown before the user types anything or makes a selection, as follows:</p>
<pre>const Placeholder = props =&gt; (<br/>  &lt;Typography<br/>    color="textSecondary"<br/>    className={props.selectProps.classes.placeholder}<br/>    {...props.innerProps}<br/>  &gt;<br/>    {props.children}<br/>  &lt;/Typography&gt;<br/>);</pre>
<p>The Material-UI <kbd>Typography</kbd> component is used to theme the <kbd>Placeholder</kbd> text.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">SingleValue</h1>
                </header>
            
            <article>
                
<p>Once again, the Material-UI <kbd>Typography</kbd> component is used to render the selected value from the menu within the autocomplete input, as follows:</p>
<pre>const SingleValue = props =&gt; (<br/>  &lt;Typography<br/>    className={props.selectProps.classes.singleValue}<br/>    {...props.innerProps}<br/>  &gt;<br/>    {props.children}<br/>  &lt;/Typography&gt;<br/>);</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">ValueContainer</h1>
                </header>
            
            <article>
                
<p>The <kbd>ValueContainer</kbd> component is used to wrap the <kbd>SingleValue</kbd> component with a <kbd>div</kbd> and the <kbd>valueContainer</kbd> CSS class, as follows:</p>
<pre>const ValueContainer = props =&gt; (<br/>  &lt;div className={props.selectProps.classes.valueContainer}&gt;<br/>    {props.children}<br/>  &lt;/div&gt;<br/>);</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">IndicatorSeparator</h1>
                </header>
            
            <article>
                
<p>By default, the <kbd>Select</kbd> component uses a pipe character as a separator between the buttons on the right side of the autocomplete menu. Since they're going to be replaced by Material-UI button components, this separator is no longer necessary, as follows:</p>
<pre>const IndicatorSeparator = () =&gt; null;</pre>
<p>By having the component return <kbd>null</kbd>, nothing is rendered.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Clear option indicator</h1>
                </header>
            
            <article>
                
<p>This button is used to clear any selection made previously by the user, as follows:</p>
<pre>const ClearIndicator = props =&gt; (<br/>  &lt;IconButton {...props.innerProps}&gt;<br/>    &lt;CancelIcon /&gt;<br/>  &lt;/IconButton&gt;<br/>);</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The purpose of this component is to use the Material-UI <kbd>IconButton</kbd> component and to render a Material-UI icon. The click handler is passed in through <kbd>innerProps</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Show menu indicator</h1>
                </header>
            
            <article>
                
<p>Just like the <kbd>ClearIndicator</kbd> component, the <kbd>DropdownIndicator</kbd> component replaces the button used to show the autocomplete menu with an icon from Material-UI, as follows:</p>
<pre>const DropdownIndicator = props =&gt; (<br/>  &lt;IconButton {...props.innerProps}&gt;<br/>    &lt;ArrowDropDownIcon /&gt;<br/>  &lt;/IconButton&gt;<br/>);</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Styles</h1>
                </header>
            
            <article>
                
<p>Here are the styles used by the various sub-components of the autocomplete:</p>
<pre>const useStyles = makeStyles(theme =&gt; ({<br/>  root: {<br/>    flexGrow: 1,<br/>    height: 250<br/>  },<br/>  input: {<br/>    display: 'flex',<br/>    padding: 0<br/>  },<br/>  valueContainer: {<br/>    display: 'flex',<br/>    flexWrap: 'wrap',<br/>    flex: 1,<br/>    alignItems: 'center',<br/>    overflow: 'hidden'<br/>  },<br/>  noOptionsMessage: {<br/>    padding: `${theme.spacing(1)}px ${theme.spacing(2)}px`<br/>  },<br/>  singleValue: {<br/>    fontSize: 16<br/>  },<br/>  placeholder: {<br/>    position: 'absolute',<br/>    left: 2,<br/>    fontSize: 16<br/>  },<br/>  paper: {<br/>    position: 'absolute',<br/>    zIndex: 1,<br/>    marginTop: theme.spacing(1),<br/>    left: 0,<br/>    right: 0<br/>  }<br/>}));</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Autocomplete</h1>
                </header>
            
            <article>
                
<p>Finally, following is the <kbd>Autocomplete</kbd> component that you can reuse throughout your application:</p>
<pre>export default function Autocomplete(props) {<br/>  const classes = useStyles();<br/>  const [value, setValue] = useState(null);<br/><br/>  return (<br/>    &lt;div className={classes.root}&gt;<br/>      &lt;Select<br/>        value={value}<br/>        onChange={v =&gt; setValue(v)}<br/>        textFieldProps={{<br/>          label: 'Team',<br/>          InputLabelProps: {<br/>            shrink: true<br/>          }<br/>        }}<br/>        {...{ ...props, classes }}<br/>      /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}<br/><br/>Autocomplete.defaultProps = {<br/>  isClearable: true,<br/>  components: {<br/>    Control,<br/>    Menu,<br/>    NoOptionsMessage,<br/>    Option,<br/>    Placeholder,<br/>    SingleValue,<br/>    ValueContainer,<br/>    IndicatorSeparator,<br/>    ClearIndicator,<br/>    DropdownIndicator<br/>  },<br/>  options: [<br/>    { label: 'Boston Bruins', value: 'BOS' },<br/>    { label: 'Buffalo Sabres', value: 'BUF' },<br/>    { label: 'Detroit Red Wings', value: 'DET' },<br/>    { label: 'Florida Panthers', value: 'FLA' },<br/>    { label: 'Montreal Canadiens', value: 'MTL' },<br/>    { label: 'Ottawa Senators', value: 'OTT' },<br/>    { label: 'Tampa Bay Lightning', value: 'TBL' },<br/>    { label: 'Toronto Maple Leafs', value: 'TOR' },<br/>    { label: 'Carolina Hurricanes', value: 'CAR' },<br/>    { label: 'Columbus Blue Jackets', value: 'CBJ' },<br/>    { label: 'New Jersey Devils', value: 'NJD' },<br/>    { label: 'New York Islanders', value: 'NYI' },<br/>    { label: 'New York Rangers', value: 'NYR' },<br/>    { label: 'Philadelphia Flyers', value: 'PHI' },<br/>    { label: 'Pittsburgh Penguins', value: 'PIT' },<br/>    { label: 'Washington Capitals', value: 'WSH' },<br/>    { label: 'Chicago Blackhawks', value: 'CHI' },<br/>    { label: 'Colorado Avalanche', value: 'COL' },<br/>    { label: 'Dallas Stars', value: 'DAL' },<br/>    { label: 'Minnesota Wild', value: 'MIN' },<br/>    { label: 'Nashville Predators', value: 'NSH' },<br/>    { label: 'St. Louis Blues', value: 'STL' },<br/>    { label: 'Winnipeg Jets', value: 'WPG' },<br/>    { label: 'Anaheim Ducks', value: 'ANA' },<br/>    { label: 'Arizona Coyotes', value: 'ARI' },<br/>    { label: 'Calgary Flames', value: 'CGY' },<br/>    { label: 'Edmonton Oilers', value: 'EDM' },<br/>    { label: 'Los Angeles Kings', value: 'LAK' },<br/>    { label: 'San Jose Sharks', value: 'SJS' },<br/>    { label: 'Vancouver Canucks', value: 'VAN' },<br/>    { label: 'Vegas Golden Knights', value: 'VGK' }<br/>  ]<br/>};</pre>
<p>The piece that ties all of the previous components together is the <kbd>components</kbd> property that's passed to <kbd>Select</kbd>. This is actually set as a <kbd>default</kbd> property in <kbd>Autocomplete</kbd>, so it can be further overridden. The value passed to <kbd>components</kbd> is a simple object that maps the component name to its implementation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><kbd>Select</kbd> components for React: <a href="https://react-select.com/">https://react-select.com/</a></li>
<li><kbd>Autocomplete</kbd> demos: <a href="https://material-ui.com/demos/autocomplete/">https://material-ui.com/demos/autocomplete/</a></li>
<li><kbd>TextField</kbd> API documentation: <a href="https://material-ui.com/api/text-field/">https://material-ui.com/api/text-field/</a></li>
<li><kbd>Typography</kbd> API documentation: <a href="https://material-ui.com/api/typography/">https://material-ui.com/api/typography/</a></li>
<li><kbd>Paper</kbd> API documentation: <a href="https://material-ui.com/api/paper/">https://material-ui.com/api/paper/</a></li>
<li><kbd>MenuItem</kbd> API documentation: <a href="https://material-ui.com/api/menu-item/">https://material-ui.com/api/menu-item/</a></li>
<li><kbd>IconButton</kbd> API documentation: <a href="https://material-ui.com/api/icon-button/">https://material-ui.com/api/icon-button/</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Selecting autocomplete suggestions</h1>
                </header>
            
            <article>
                
<p>In the previous section, you built an <kbd>Autocomplete</kbd> component capable of selecting a single value. Sometimes, you need the ability to select multiple values from an <kbd>Autocomplete</kbd> component. The good news is that, with a few small additions, the component that you created in the previous section already does most of the work.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let's walk through the additions that need to be made in order to support multi-value selection in the <kbd>Autocomplete</kbd> component, starting with the new <kbd>MultiValue</kbd> component, as follows:</p>
<pre>const MultiValue = props =&gt; (<br/>  &lt;Chip<br/>    tabIndex={-1}<br/>    label={props.children}<br/>    className={clsx(props.selectProps.classes.chip, {<br/>      [props.selectProps.classes.chipFocused]: props.isFocused<br/>    })}<br/>    onDelete={props.removeProps.onClick}<br/>    deleteIcon={&lt;CancelIcon {...props.removeProps} /&gt;}<br/>  /&gt;<br/>);</pre>
<p>The <kbd>MultiValue</kbd> component uses the Material-UI <kbd>Chip</kbd> component to render a selected value. In order to pass <kbd>MultiValue</kbd> to <kbd>Select</kbd>, add it to the <kbd>components</kbd> object that's passed to <kbd>Select</kbd>:</p>
<pre>components: {<br/>  Control,<br/>  Menu,<br/>  NoOptionsMessage,<br/>  Option,<br/>  Placeholder,<br/>  SingleValue,<br/>  MultiValue,<br/>  ValueContainer,<br/>  IndicatorSeparator,<br/>  ClearIndicator,<br/>  DropdownIndicator<br/>},</pre>
<p>Now you can use your <kbd>Autocomplete</kbd> component for single value selection, or for multi-value selection. You can add the <kbd>isMulti</kbd> property with a default value of <kbd>true</kbd> to <kbd>defaultProps</kbd>, as follows:</p>
<pre>isMulti: true,</pre>
<p>Now, you should be able to select multiple values from the autocomplete.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Nothing looks different about the autocomplete when it's first rendered, or when you show the menu. When you make a selection, the <kbd>Chip</kbd> component is used to display the value. Chips are ideal for displaying small pieces of information like this. <span>Furthermore,</span> the close button integrates nicely with it, making it easy for the user to remove individual selections after they've been made.</p>
<p>Here's what the autocomplete looks like after multiple selections have been made:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1fc802a1-8a20-4800-a893-31e726536ce7.png" style="width:33.08em;height:5.50em;"/></p>
<div class="packt_tip">Values that have been selected are removed from the menu.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>Select components for React: <a href="https://react-select.com/">https://react-select.com/</a></li>
<li><kbd>Autocomplete</kbd> demos: <a href="https://material-ui.com/demos/autocomplete/">https://material-ui.com/demos/autocomplete/</a></li>
<li><kbd>TextField</kbd> API documentation: <a href="https://material-ui.com/api/text-field/">https://material-ui.com/api/text-field/</a></li>
<li><kbd>Typography</kbd> API documentation: <a href="https://material-ui.com/api/typography/">https://material-ui.com/api/typography/</a></li>
<li><kbd>Paper</kbd> API documentation: <a href="https://material-ui.com/api/paper/">https://material-ui.com/api/paper/</a></li>
<li><kbd>MenuItem</kbd> API documentation: <a href="https://material-ui.com/api/menu-item/">https://material-ui.com/api/menu-item/</a></li>
<li><kbd>IconButton</kbd> API documentation: <a href="https://material-ui.com/api/icon-button/">https://material-ui.com/api/icon-button/</a></li>
<li><kbd>Chip</kbd> API documentation: <a href="https://material-ui.com/api/chip/">https://material-ui.com/api/chip/</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">API-driven Autocomplete</h1>
                </header>
            
            <article>
                
<p>You can't always have your autocomplete data ready to render on the initial page load. Imagine trying to load hundreds or thousands of items before the user can interact with anything. The better approach is to keep the data on the server and supply an API endpoint with the autocomplete text as the user types. Then you only need to load a smaller set of data returned by the API.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let's rework the example from the previous section. We'll keep all of the same autocomplete functionality, except that, instead of passing an array to the <kbd>options</kbd> property, we'll pass in an API function that returns a <kbd>Promise</kbd>. Here's the API function that mocks an API call that resolves a <kbd>Promise</kbd>:</p>
<pre>const someAPI = searchText =&gt;<br/>  new Promise(resolve =&gt; {<br/>    setTimeout(() =&gt; {<br/>      const teams = [<br/>        { label: 'Boston Bruins', value: 'BOS' },<br/>        { label: 'Buffalo Sabres', value: 'BUF' },<br/>        { label: 'Detroit Red Wings', value: 'DET' },<br/>        ...<br/>      ];<br/><br/>      resolve(<br/>        teams.filter(<br/>          team =&gt;<br/>            searchText &amp;&amp;<br/>            team.label<br/>              .toLowerCase()<br/>              .includes(searchText.toLowerCase())<br/>        )<br/>      );<br/>    }, 1000);<br/>  });</pre>
<p>This function takes a search string argument and returns a <kbd>Promise</kbd>. The same data that would otherwise be passed to the <kbd>Select</kbd> component in the <kbd>options</kbd> property is filtered here instead. Think of anything that happens in this function as happening behind an API in a real app. The returned <kbd>Promise</kbd> is then resolved with an array of matching items following a simulated latency of one second.</p>
<p>You also need to add a couple of components to the composition of the <kbd>Select</kbd> component (we're up to 13 now!), as follows:</p>
<pre>const LoadingIndicator = () =&gt; &lt;CircularProgress size={20} /&gt;;<br/><br/>const LoadingMessage = props =&gt; (<br/>  &lt;Typography<br/>    color="textSecondary"<br/>    className={props.selectProps.classes.noOptionsMessage}<br/>    {...props.innerProps}<br/>  &gt;<br/>    {props.children}<br/>  &lt;/Typography&gt;<br/>);</pre>
<p>The <kbd>LoadingIndicator</kbd> component is shown on the right the autocomplete text input. It's using the <kbd>CircularProgress</kbd> component from Material-UI to indicate that the autocomplete is doing something. The <kbd>LoadingMessage</kbd> component follows the same pattern as the other text replacement components used with <kbd>Select</kbd> in this example. The loading text is displayed when the menu is shown, but the <kbd>Promise</kbd> that resolves the <kbd>options</kbd> is still pending.</p>
<p class="mce-root"/>
<p>Lastly, there's the <kbd>Select</kbd> component. Instead of using <kbd>Select</kbd>, you need to use the <kbd>AsyncSelect</kbd> version, as follows:</p>
<pre>import AsyncSelect from 'react-select/lib/Async';</pre>
<p>Otherwise, <kbd>AsyncSelect</kbd> works the same as <kbd>Select</kbd>, as follows:</p>
<pre>&lt;AsyncSelect<br/>  value={value}<br/>  onChange={value =&gt; setValue(value)}<br/>  textFieldProps={{<br/>    label: 'Team',<br/>    InputLabelProps: {<br/>      shrink: true<br/>    }<br/>  }}<br/>  {...{ ...props, classes }}<br/>/&gt;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The only difference between a <kbd>Select</kbd> autocomplete and an <kbd>AsyncSelect</kbd> autocomplete is what happens while the request to the API is pending. Here is what the autocomplete looks like while this is happening:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b6333f07-5b9f-48f4-9661-1e50aebdfc32.png" style="width:31.17em;height:9.00em;"/></p>
<p>As the user types the <kbd>CircularProgress</kbd> component is rendered to the right, while the loading message is rendered in the menu using a <kbd>Typography</kbd> component.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>Select components for React: <a href="https://react-select.com/">https://react-select.com/</a></li>
<li><kbd>Autocomplete</kbd> demos: <a href="https://material-ui.com/demos/autocomplete/">https://material-ui.com/demos/autocomplete/</a></li>
<li><kbd>TextField</kbd> API documentation: <a href="https://material-ui.com/api/text-field/">https://material-ui.com/api/text-field/</a></li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<ul>
<li><kbd>Typography</kbd> API documentation: <a href="https://material-ui.com/api/typography/">https://material-ui.com/api/typography/</a></li>
<li><kbd>Paper</kbd> API documentation: <a href="https://material-ui.com/api/paper/">https://material-ui.com/api/paper/</a></li>
<li><kbd>MenuItem</kbd> API documentation: <a href="https://material-ui.com/api/menu-item/">https://material-ui.com/api/menu-item/</a></li>
<li><kbd>IconButton</kbd> API documentation: <a href="https://material-ui.com/api/icon-button/">https://material-ui.com/api/icon-button/</a></li>
<li><kbd>Chip</kbd> API documentation: <a href="https://material-ui.com/api/chip/">https://material-ui.com/api/chip/</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Highlighting search results</h1>
                </header>
            
            <article>
                
<p>When the user starts typing in an autocomplete and the results are displayed in the dropdown, it isn't always obvious how a given item matches the search criteria. You can help your users better understand the results by highlighting the matched portion of the string value.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>You'll want to use two functions from the <kbd>autosuggest-highlight</kbd> package to help <kbd>highlight</kbd> the text presented in the autocomplete dropdown, as follows:</p>
<pre>import match from 'autosuggest-highlight/match';<br/>import parse from 'autosuggest-highlight/parse';</pre>
<p>Now, you can build a new component that will render the item text, highlighting as and when necessary, as follows:</p>
<pre>const ValueLabel = ({ label, search }) =&gt; {<br/>  const matches = match(label, search);<br/>  const parts = parse(label, matches);<br/><br/>  return parts.map((part, index) =&gt;<br/>    part.highlight ? (<br/>      &lt;span key={index} style={{ fontWeight: 500 }}&gt;<br/>        {part.text}<br/>      &lt;/span&gt;<br/>    ) : (<br/>      &lt;span key={index}&gt;{part.text}&lt;/span&gt;<br/>    )<br/>  );<br/>};</pre>
<p>The end result is that <kbd>ValueLabel</kbd> renders an array of <kbd>span</kbd> elements, determined by the <kbd>parse()</kbd> and <kbd>match()</kbd> functions. One of the spans will be bolded if <kbd>part.highlight</kbd> is true. Now, you can use <kbd>ValueLabel</kbd> in the <kbd>Option</kbd> component, as follows:</p>
<pre>const Option = props =&gt; (<br/>  &lt;MenuItem<br/>    buttonRef={props.innerRef}<br/>    selected={props.isFocused}<br/>    component="div"<br/>    style={{<br/>      fontWeight: props.isSelected ? 500 : 400<br/>    }}<br/>    {...props.innerProps}<br/>  &gt;<br/>    &lt;ValueLabel<br/>      label={props.children}<br/>      search={props.selectProps.inputValue}<br/>    /&gt;<br/>  &lt;/MenuItem&gt;<br/>);</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Now, when you search for values in the autocomplete text input, the results will highlight the search criteria in each item, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ca6b27c7-d31c-478a-9580-f6b27935e5e3.png" style="width:31.08em;height:9.42em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>Autosuggest for React: <a href="https://github.com/moroshko/autosuggest-highlight">https://github.com/moroshko/autosuggest-highlight</a></li>
<li><kbd>Select</kbd> components for React: <a href="https://react-select.com/">https://react-select.com/</a></li>
<li><kbd>Autocomplete</kbd> demos: <a href="https://material-ui.com/demos/autocomplete/">https://material-ui.com/demos/autocomplete/</a></li>
<li><kbd>TextField</kbd> API documentation: <a href="https://material-ui.com/api/text-field/">https://material-ui.com/api/text-field/</a></li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<ul>
<li><kbd>Typography</kbd> API documentation: <a href="https://material-ui.com/api/typography/">https://material-ui.com/api/typography/</a></li>
<li><kbd>Paper</kbd> API documentation: <a href="https://material-ui.com/api/paper/">https://material-ui.com/api/paper/</a></li>
<li><kbd>MenuItem</kbd> API documentation: <a href="https://material-ui.com/api/menu-item/">https://material-ui.com/api/menu-item/</a></li>
<li><kbd>IconButton</kbd> API documentation: <a href="https://material-ui.com/api/icon-button/">https://material-ui.com/api/icon-button/</a></li>
<li><kbd>Chip</kbd> API documentation: <a href="https://material-ui.com/api/chip/">https://material-ui.com/api/chip/</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Standalone chip input</h1>
                </header>
            
            <article>
                
<p>Some applications require multi-value inputs but don't have a predefined list for the user to choose from. This rules out the possibility of using an autocomplete or a <kbd>select</kbd> component, for example, if you're asking the user for a list of names.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>You can install the <kbd>material-ui-chip-input</kbd> package and use the <kbd>ChipInput</kbd> component, which brings together the <kbd>Chip</kbd> and <kbd>TextInput</kbd> components from Material-UI. <span>The code is as follows:</span></p>
<pre>import React, { useState } from 'react';<br/><br/>import { makeStyles } from '@material-ui/styles';<br/>import ChipInput from 'material-ui-chip-input';<br/><br/>const useStyles = makeStyles(theme =&gt; ({<br/>  chipInput: { minWidth: 300 }<br/>}));<br/><br/>export default function StandaloneChipInput() {<br/>  const classes = useStyles();<br/>  const [values, setValues] = useState([]);<br/><br/>  const onAdd = chip =&gt; {<br/>    setValues([...values, chip]);<br/>  };<br/><br/>  const onDelete = (chip, index) =&gt; {<br/>    setValues(values.slice(0, index).concat(values.slice(index + 1)));<br/>  };<br/><br/>  return (<br/>    &lt;ChipInput<br/>      className={classes.chipInput}<br/>      helperText="Type name, hit enter to type another"<br/>      value={values}<br/>      onAdd={onAdd}<br/>      onDelete={onDelete}<br/>    /&gt;<br/>  );<br/>}</pre>
<p>When the screen first loads, the field looks like a regular text field that you can type in, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ec82a6ad-fbb5-4c78-94ee-c754191aef69.png" style="width:25.50em;height:5.50em;"/></p>
<p>As the helper text indicates, you can hit <em>Enter</em> to add the item and enter more text, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0127adc0-2486-4c7a-bed5-b6c5ff5804a9.png" style="width:25.42em;height:5.83em;"/></p>
<p>You can keep adding items to the field as you please, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f3edb601-f8e7-42bf-9d75-0d789d5dca3c.png" style="width:32.58em;height:5.33em;"/></p>
<div class="packt_tip">It's important that the helper text mentions the <span class="packt_screen">enter</span> key. Otherwise, the user might not be able to figure out that they can enter multiple values.</div>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The state that holds the value of the <kbd>chip</kbd> input field is an array—because there are multiple values. The two actions involved with the <kbd>chip</kbd> input state are adding and removing strings from this array. Let's take a closer look at the <kbd>onAdd()</kbd> and <kbd>onDelete()</kbd> functions, as follows:</p>
<pre>const onAdd = chip =&gt; {<br/>  setValues([...values, chip]);<br/>};<br/><br/>const onDelete = (chip, index) =&gt; {<br/>  setValues(values.slice(0, index).concat(values.slice(index + 1)));<br/>};</pre>
<p>The <kbd>onAdd()</kbd> function adds the <kbd>chip</kbd> to the array, while the <kbd>onDelete()</kbd> function deletes the <kbd>chip</kbd> at the given <kbd>index</kbd>. The chips are deleted when the <kbd>Delete</kbd> icon in the chip is clicked on by the user. Lastly, let's look at the <kbd>ChipInput</kbd> component itself, as follows:</p>
<pre>&lt;ChipInput<br/>  className={classes.chipInput}<br/>  helperText="Type name, hit enter to type another"<br/>  value={values}<br/>  onAdd={onAdd}<br/>  onDelete={onDelete}<br/>/&gt;</pre>
<p>It's very similar to a <kbd>TextInput</kbd> component. It actually takes the same properties, such as <kbd>helperText</kbd>. It also takes additional properties not found in <kbd>TextInput</kbd>, such as <kbd>onAdd</kbd> and <kbd>onDelete</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>A Material-UI <kbd>ChipInput</kbd> component:<a href="https://www.npmjs.com/package/material-ui-chip-input"> https://www.npmjs.com/package/material-ui-chip-input</a></li>
</ul>


            </article>

            
        </section>
    </body></html>