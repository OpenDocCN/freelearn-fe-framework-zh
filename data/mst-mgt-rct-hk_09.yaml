- en: '*Chapter 6*: Introducing Global State Libraries'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第6章*：介绍全局状态库'
- en: We have learned about several patterns used to share state among components
    so far. The rest of this book will introduce various global state libraries that
    use such patterns.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了用于在组件间共享状态的几种模式。本书的剩余部分将介绍使用这些模式的各种全局状态库。
- en: 'Before diving into the libraries, we will recap the challenges associated with
    global states and discuss two aspects of libraries: where the state resides and
    how to control re-renders. With this in hand, we will be able to understand the
    characteristics of global state libraries.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨库之前，我们将回顾与全局状态相关的挑战，并讨论库的两个方面：状态存储的位置以及如何控制重新渲染。有了这些知识，我们将能够理解全局状态库的特点。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Working with global state management issues
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理全局状态管理问题
- en: Using the data-centric and component-centric approaches
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以数据和组件为中心的方法
- en: Optimizing re-renders
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化重新渲染
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You are expected to have moderate knowledge of React, including React hooks.
    Refer to the official site at [https://reactjs.org](https://reactjs.org) to learn
    more.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 预期您对React有一定的了解，包括React钩子。请参考官方网站[https://reactjs.org](https://reactjs.org)以获取更多信息。
- en: To run the code snippets, you need a React environment, for example, Create
    React App ([https://create-react-app.dev](https://create-react-app.dev)) or CodeSandbox
    ([https://codesandbox.io](https://codesandbox.io)).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行代码片段，您需要一个React环境，例如，Create React App ([https://create-react-app.dev](https://create-react-app.dev))或CodeSandbox
    ([https://codesandbox.io](https://codesandbox.io))。
- en: Working with global state management issues
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理全局状态管理问题
- en: React is designed around the concept of components. In the component model,
    everything is expected to be reusable. Global state is something that exists outside
    of components. It's often true that we should avoid using a global state where
    possible because it requires an extra dependency on a component. However, a global
    state is sometimes very handy and allows us to be more productive. For some app
    requirements, global state fits well.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: React的设计围绕组件的概念。在组件模型中，一切都被期望是可重用的。全局状态是存在于组件之外的东西。通常情况下，我们应该尽量避免使用全局状态，因为它需要一个额外的组件依赖。然而，全局状态有时非常方便，并允许我们更高效地工作。对于某些应用程序需求，全局状态非常适合。
- en: 'There are two challenges when designing a global state:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 设计全局状态时有两个挑战：
- en: The first challenge is how to read a global state.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个挑战是如何读取全局状态。
- en: Global state tends to have multiple values. It's often the case that a component
    using a global state doesn't need all the values in it. If a component re-renders
    when a global state is changed but the changed values are not relevant to the
    component, it's an extra re-render. Extra re-renders are not desirable, and global
    state libraries should provide a solution for them. There are several approaches
    to avoiding extra re-renders, and we will discuss them in more detail in the *Optimizing
    re-renders* section.
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 全局状态通常包含多个值。通常情况下，使用全局状态的组件不需要其中的所有值。如果一个组件在全局状态改变时重新渲染，但改变后的值与组件无关，这将是一个额外的渲染。额外的渲染是不希望的，全局状态库应该提供解决方案。避免额外渲染有几种方法，我们将在*优化重新渲染*部分更详细地讨论它们。
- en: The second challenge is how to write or update a global state.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个挑战是如何编写或更新全局状态。
- en: 'Again, global state is likely to have multiple values, some of which may be
    nested objects. It might not be a good idea to have a single global variable and
    accept arbitrary mutations. The following code block shows an example of a global
    variable and one arbitrary mutation:'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次强调，全局状态可能包含多个值，其中一些可能是嵌套对象。拥有一个单独的全局变量并接受任意的突变可能不是一个好主意。下面的代码块展示了全局变量和一个任意的突变示例：
- en: '[PRE0]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The mutation `globalVariable.b.d = 9` in the example may not work for a global
    state because there's no way to detect the change and trigger React components
    to re-render.
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 示例中的突变`globalVariable.b.d = 9`可能对全局状态不起作用，因为没有方法可以检测变化并触发React组件重新渲染。
- en: 'To have more control over how to write a global state, we often provide functions
    to update a global state. It''s also often necessary to hide a variable in a closure
    so that the variable can''t be mutated directly. The following code block shows
    an example of creating two functions for reading and writing a variable in a closure:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要更好地控制全局状态如何编写，我们通常会提供更新全局状态的函数。通常还需要在闭包中隐藏一个变量，以便不能直接修改该变量。下面的代码块展示了在闭包中创建用于读取和写入变量的两个函数的示例：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `createContainer` function creates `globalContainer`, which holds `getState`
    and `setState` functions. `getState` is a function to read a global state and
    `setState` is a function to update a global state. There are several ways to implement
    functions such as `setState` to update a global state. We will look at concrete
    examples in the following chapters.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`createContainer` 函数创建了 `globalContainer`，它包含 `getState` 和 `setState` 函数。`getState`
    是一个读取全局状态的函数，而 `setState` 是一个更新全局状态的函数。实现如 `setState` 这样的更新全局状态的函数有几种方式。我们将在接下来的章节中具体探讨。'
- en: Global versus General State Management
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 全局状态管理与通用状态管理
- en: This book focuses on *global* state management; *general* state management is
    out of scope. In the field of general state management, popular approaches include
    the one-way data flow approach, as in Redux ([https://redux.js.org](https://redux.js.org)),
    and the state machine-based approach, as in XState ([https://xstate.js.org](https://xstate.js.org)).
    General state management approaches are useful not only for a global state but
    also for a local state.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本书专注于 *全局* 状态管理；*通用* 状态管理不在此书的范畴之内。在通用状态管理的领域，流行的方法包括像 Redux ([https://redux.js.org](https://redux.js.org))
    那样的单向数据流方法，以及像 XState ([https://xstate.js.org](https://xstate.js.org)) 那样的基于状态机的方法。通用状态管理方法不仅对全局状态有用，对局部状态也很有用。
- en: Notes about Redux and React Redux
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Redux 和 React Redux 的注意事项
- en: Redux has been a big player in a global state management. Redux solves state
    management with one-way data flow with a global state in mind. However, Redux
    itself has nothing to do with React. It's React Redux ([https://react-redux.js.org](https://react-redux.js.org))
    that binds React and Redux. While Redux itself doesn't have a capability or a
    notion to avoid extra re-renders, React Redux has such a capability.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Redux 在全局状态管理领域一直是一个重要角色。Redux 通过全局状态的单向数据流解决了状态管理问题。然而，Redux 本身与 React 没有关系。是
    React Redux ([https://react-redux.js.org](https://react-redux.js.org)) 将 React
    和 Redux 绑定在一起。虽然 Redux 本身没有避免额外重新渲染的能力或概念，但 React Redux 有这样的能力。
- en: Because Redux and React Redux were so popular, some people overused them in
    the past. This was due to the lack of React Context before React 16.3, and there
    were no other popular options. Such people (mis-)used React Redux mainly for (legacy)
    Context, without needing the one-way data flow. With React Context since React
    16.3 and the `useContext` hook since React 16.8, we can easily solve use cases
    to avoid prop drilling and extra re-renders. That brings us to microstate management
    – our focus in this book.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Redux 和 React Redux 非常受欢迎，过去有些人过度使用它们。这主要是因为 React 16.3 之前缺乏 React Context，并且没有其他流行的选择。这样的人（错误地）主要使用
    React Redux 来（遗留）Context，而不需要单向数据流。自从 React 16.3 引入 React Context 和 React 16.8
    引入的 `useContext` 钩子以来，我们可以轻松解决避免 prop 传递和额外重新渲染的用例。这使我们转向了微状态管理——本书的重点。
- en: Hence, technically speaking, React Redux minus Redux is within the scope of
    this book. Redux itself is a great solution for general state management, and
    along with React Redux, it solves the global state issues we discussed in this
    section.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从技术角度讲，React Redux 减去 Redux 就属于本书的范畴。Redux 本身是一个优秀的通用状态管理解决方案，与 React Redux
    结合使用，它解决了本节讨论的全局状态问题。
- en: In this section, we discussed the general challenges when it comes to global
    state libraries. Next up, we will learn about where state resides.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了全局状态库的一般挑战。接下来，我们将学习状态驻留的位置。
- en: Using the data-centric and component-centric approaches
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用以数据为中心和以组件为中心的方法
- en: 'Global state can technically be divided into two types: data-centric and component-centric.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上来说，全局状态可以分为两种类型：以数据为中心和以组件为中心。
- en: In the following sections, we will discuss both these approaches in detail.
    Then, we will also talk about some exceptions.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将详细讨论这两种方法。然后，我们还将讨论一些例外情况。
- en: Understanding the data-centric approach
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解以数据为中心的方法
- en: When you design an app, you may have a data model as a singleton in your app
    and you may already have the data to deal with. In this case, you would define
    components and connect the data and the components. The data can be changed from
    the outside, such as by other libraries or from other servers.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当你设计一个应用时，你可能在应用中有一个作为单例的数据模型，并且你可能已经有了处理数据。在这种情况下，你会定义组件并将数据与组件连接起来。数据可以从外部更改，例如由其他库或其他服务器。
- en: For the data-centric approach, module state would fit better, because module
    state resides in JavaScript memory outside React. Module state can exist before
    React starts rendering or even after all React components are unmounted.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以数据为中心的方法，模块状态会更为合适，因为模块状态位于React之外的JavaScript内存中。模块状态可以在React开始渲染之前存在，甚至在所有React组件卸载之后。
- en: Global state libraries using the data-centric approach would provide APIs to
    create module state and to connect the module state to React components. Module
    state is usually wrapped in a `store` object, which has methods to access and
    update a `state` variable.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数据为中心的方法的全局状态库将提供API来创建模块状态并将模块状态连接到React组件。模块状态通常被封装在一个`store`对象中，该对象有访问和更新`state`变量的方法。
- en: Understanding the component-centric approach
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解以组件为中心的方法
- en: Unlike the data-centric approach, with the component-centric approach, you can
    design components first. At some point, some components may need to access shared
    information. As we discussed in the *Effectively using local states* section in
    [*Chapter 2*](B17780_02_Final_VK_ePub.xhtml#_idTextAnchor035), *Using Local and
    Global States*, we can lift state and pass it down with props (a.k.a. prop drilling).
    If prop drilling won't work as a solution, that's when we can introduce a global
    state. Certainly, we can start by designing a data model first, but in the component-centric
    approach, the data model is fairly tied to components.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据为中心的方法不同，使用以组件为中心的方法，你可以首先设计组件。在某个时刻，某些组件可能需要访问共享信息。正如我们在[*第二章*](B17780_02_Final_VK_ePub.xhtml#_idTextAnchor035)中的*有效使用本地状态*部分所讨论的，*使用本地和全局状态*，我们可以提升状态并通过props（即属性钻取）向下传递。如果属性钻取不能作为解决方案，那么我们就可以引入全局状态。当然，我们可以先设计数据模型，但在以组件为中心的方法中，数据模型与组件紧密相关。
- en: For the component-centric approach, component state, which holds a global state
    in the component lifecycle, fits better. This is because when all the corresponding
    components are unmounted, a global state is gone too. This capability allows us
    to have two or more global states that exist in JavaScript memory because they
    are in different component subtrees (or different portals).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以组件为中心的方法，组件状态，它在组件生命周期中持有全局状态，更为合适。这是因为当所有相应的组件都卸载时，全局状态也随之消失。这种能力使我们能够在JavaScript内存中有两个或更多全局状态存在，因为它们位于不同的组件子树（或不同的
    portals）中。
- en: Global state libraries using a data-centric approach provide a factory function
    to create functions that initialize a global state for use in React components.
    A factory function doesn't directly create a global state, but by using the generated
    functions, we let React handle a global state lifecycle.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数据为中心的方法的全局状态库提供了一个工厂函数来创建初始化全局状态以在React组件中使用的方法。工厂函数并不直接创建全局状态，但通过使用生成的函数，我们让React处理全局状态的生命周期。
- en: Exploring the exceptions of both approaches
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索两种方法的例外情况
- en: What we have described are typical use cases, and there are always some exceptions.
    The data-centric approach and the component-centric approach are not really two
    sides of the same coin. In reality, you can use one of two approaches or a hybrid
    of the two approaches.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所描述的是典型的用例，但总会有一些例外。以数据为中心的方法和以组件为中心的方法并不是同一枚硬币的两面。实际上，你可以使用这两种方法中的一种，或者两种方法的混合。
- en: Module state is often used as a singleton pattern, but you can create multiple
    module states for subtrees. You can even control the lifecycles of them.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 模块状态通常被用作单例模式，但你可以为子树创建多个模块状态。你甚至可以控制它们的生命周期。
- en: Component state is often used to provide a state in a subtree, but if you put
    the provider component at the root of the tree and there's only one tree in JavaScript
    memory, it can be treated like a singleton pattern.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 组件状态通常用于在子树中提供状态，但如果你在树的根处放置提供者组件，并且JavaScript内存中只有一个树，它可以被看作是单例模式。
- en: Component state is often implemented with the `useState` hook, but if we need
    to have a mutable variable or `store`, an implementation with the `useRef` hook
    is possible. The implementation might be more complicated than using `useState`,
    but it still comes under the component lifecycle.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 组件状态通常使用`useState`钩子实现，但如果我们需要一个可变的变量或`store`，可以使用`useRef`钩子实现。这种实现可能比使用`useState`更复杂，但它仍然属于组件生命周期的一部分。
- en: In this section, we learned about two approaches for using a global state. Module
    state is mainly for use with the data-centric approach, and component state is
    mainly for use with the component-centric approach. Next, we will learn about
    several patterns to optimize re-renders.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了两种使用全局状态的方法。模块状态主要用于数据为中心的方法，而组件状态主要用于组件为中心的方法。接下来，我们将学习几种优化重新渲染的模式。
- en: Optimizing re-renders
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化重新渲染
- en: Avoiding extra re-renders is a major challenge when it comes to a global state.
    This is a big point to consider when designing a global state library for React.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 避免额外的重新渲染是全局状态时的一个主要挑战。在设计React的全局状态库时，这是一个需要考虑的重要点。
- en: 'Typically, a global state has multiple properties, and they can be nested objects.
    See the following, for example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，全局状态有多个属性，它们可以是嵌套对象。以下是一个例子：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'With this `state` object, let''s assume two components `ComponentA` and `ComponentB`,
    which use `state.b.c` and `state.e.g`, respectively. The following is pseudocode
    of the two components:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个`state`对象，假设有两个组件`ComponentA`和`ComponentB`，分别使用`state.b.c`和`state.e.g`。以下是两个组件的伪代码：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, let''s suppose we change `state` as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们假设我们按照以下方式更改`state`：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This changes the `a` property of `state`, but it doesn't change either `state.b.c`
    or `state.e.g`. In this case, the two components don't need to re-render.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这会改变`state`的`a`属性，但不会改变`state.b.c`或`state.e.g`。在这种情况下，两个组件不需要重新渲染。
- en: 'The goal of optimizing re-renders is to specify which part of `state` is used
    in a component. We have several approaches to specify the part of `state`. This
    section describes three approaches:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 优化重新渲染的目标是指定组件中使用了`state`的哪个部分。我们有几种方法来指定`state`的部分。本节描述了三种方法：
- en: Using a selector function
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用选择器函数
- en: Detecting property access
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测属性访问
- en: Using atoms
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原子
- en: We will discuss each of these now.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将讨论这些内容。
- en: Using a selector function
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用选择器函数
- en: One approach is using a selector function. A selector function takes a `state`
    variable and returns a part of the `state` variable.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是使用选择器函数。选择器函数接受一个`state`变量并返回`state`变量的一部分。
- en: 'For example, let''s suppose we have a `useSelector` hook that takes a selector
    function and returns part of `state`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们假设我们有一个`useSelector`钩子，它接受一个选择器函数并返回`state`的一部分：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If `state.b.c` is `2`, then `Component` will show `2`. Now that we know that
    this component cares only about `state.b.c`, we can avoid extra re-renders only
    when `state.a` is changed.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`state.b.c`是`2`，那么`Component`将显示`2`。既然我们知道这个组件只关心`state.b.c`，我们就可以在`state.a`改变时避免额外的重新渲染。
- en: '`useSelector` will be used to compare the selector function''s result every
    time `state` is changed. Hence, it''s important that the selector function returns
    the referentially equal result when given the same input.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`useSelector`将在每次`state`改变时比较选择器函数的结果。因此，当给定相同的输入时，选择器函数返回的引用相等的结果非常重要。'
- en: 'The selector function is so flexible that it can return not only a part of
    `state`, but also any derived value. For example, it can return a doubled value,
    like here:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 选择器函数非常灵活，不仅可以返回`state`的一部分，还可以返回任何派生值。例如，它可以返回一个双倍值，如下所示：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: A Note about Selector and Memoization
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 关于选择器和记忆化的注意事项
- en: If a value returned by the selector function is a primitive value such as a
    number, there are no issues. However, if the selector function returns a derived
    object value, we need to make sure to return a referentially equal object with
    the so-called memoization technique. You can read more about memoization at [https://en.wikipedia.org/wiki/Memoization](https://en.wikipedia.org/wiki/Memoization).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果选择器函数返回的值是原始值，如数字，则没有问题。然而，如果选择器函数返回一个派生对象值，我们需要确保使用所谓的记忆化技术返回一个引用相等的对象。你可以在[https://en.wikipedia.org/wiki/Memoization](https://en.wikipedia.org/wiki/Memoization)上了解更多关于记忆化的信息。
- en: As a selector function is a means to explicitly specify which part of a component
    will be used, we call this a manual optimization.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于选择器函数是一种显式指定组件将使用哪一部分的手段，我们将其称为手动优化。
- en: Detecting property access
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测属性访问
- en: Can we do render optimization automatically, without using a selector function
    to explicitly specify which part of a state is to be used in a component? There
    is something called state usage tracking, which is used to detect property access
    and use the detected information for render optimization.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否在不使用选择器函数显式指定组件中要使用哪个状态部分的情况下自动进行渲染优化？有一种称为状态使用跟踪的技术，用于检测属性访问并使用检测到的信息进行渲染优化。
- en: 'For example, let''s suppose we have a `useTrackedState` hook that has the state
    usage tracking capability:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个具有状态使用跟踪能力的`useTrackedState`钩子：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This works as `trackedState` can detect that the `.b.c` property is accessed,
    and `useTrackedState` only triggers re-renders when the `.b.c` property value
    is changed. This is automatic render optimization, whereas `useSelector` is manual
    render optimization.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`trackedState`可以检测到`.b.c`属性被访问，而`useTrackedState`只有在`.b.c`属性值发生变化时才会触发重新渲染。这是自动渲染优化，而`useSelector`是手动渲染优化。
- en: 'For simplicity, the previous code block example is contrived. This example
    can easily be implemented with `useSelector`, the manual render optimization.
    Let''s look at another example using two values:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，之前的代码块示例是人为设计的。这个例子可以很容易地通过使用`useSelector`和手动渲染优化来实现。让我们看看另一个使用两个值的例子：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, this is surprisingly difficult to implement with a single `useSelector`
    hook. If we were to write a selector, it would require memoization or a custom
    equality function, which are complicated techniques. However, if we use `useTrackedState`,
    it works without such complicated techniques.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在令人惊讶的是，使用单个`useSelector`钩子来实现这一点非常困难。如果我们编写一个选择器，它将需要记忆化或自定义相等函数，这些是复杂的技术。然而，如果我们使用`useTrackedState`，它无需这些复杂技术就能工作。
- en: The implementation of `useTrackedState` requires Proxy ([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy))
    to trap the property access to the `state` object. If this is implemented properly,
    it can replace most use cases of `useSelector` and can do the automatic render
    optimization. However, there's a subtle case where the automatic render optimization
    doesn't work perfectly. Let's take a closer look in the next section.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`useTrackedState`的实现需要使用代理([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy))来拦截对`state`对象的属性访问。如果正确实现，它可以替代大多数`useSelector`的使用场景，并可以进行自动渲染优化。然而，存在一个微妙的情况，自动渲染优化并不完美。让我们在下一节中更详细地探讨。'
- en: The difference between useSelector and useTrackedState
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`useSelector`和`useTrackedState`的区别'
- en: There are some use cases in which `useSelector` works better than `useTrackedState`.
    Because `useSelector` can create any derived values, it can derive state into
    simpler values.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些使用场景中，`useSelector`比`useTrackedState`表现更好。因为`useSelector`可以创建任何派生值，它可以派生更简单的状态值。
- en: 'The difference between the working of `useSelector` and `useTrackedState` can
    be seen with the help of a simple example. The following is an example component
    with `useSelector`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一个简单的例子，我们可以看到`useSelector`和`useTrackedState`的工作方式之间的区别。以下是一个使用`useSelector`的示例组件：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If we were to create the same component with `useTrackedState`, it would be
    the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用`useTrackedState`创建相同的组件，它将是以下内容：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Functionality-wise, this component with `useTrackedState` works fine, but it
    will trigger re-renders every time `state.a` is changed. On the contrary, with
    `useSelector`, it will trigger re-renders only when `isSmall` is changed, which
    means it's better render optimized.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 从功能上讲，这个带有`useTrackedState`的组件工作得很好，但它会在每次`state.a`发生变化时触发重新渲染。相反，使用`useSelector`时，只有在`isSmall`发生变化时才会触发重新渲染，这意味着它具有更好的渲染优化。
- en: Using atoms
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用原子
- en: There's another approach, which we call using atoms. An atom is a minimal unit
    of state used to trigger re-renders. Instead of subscribing to the whole global
    state and trying to avoid extra re-renders, atoms allow you to subscribe granularly.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法，我们称之为使用原子。原子是用于触发重新渲染的最小状态单元。与订阅整个全局状态并尝试避免额外重新渲染不同，原子允许你进行粒度更细的订阅。
- en: 'For example, let''s suppose we have a `useAtom` hook that only subscribes to
    an atom. An `atom` function would create such a unit (that is, `atom`) of a `state`
    object:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个只订阅原子的`useAtom`钩子。一个`atom`函数会创建这样的单元（即`atom`）的`state`对象：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If atoms are completely separated, it''s almost equivalent to having separate
    global states. However, we could create a derived value with atoms. For example,
    say we would like to sum the `globalState` values. The pseudocode would be the
    following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果原子完全分离，几乎等同于拥有单独的全局状态。然而，我们可以使用原子创建派生值。例如，假设我们想要对`globalState`值求和。伪代码如下：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To make this work, we need to track the dependency and re-evaluate the derived
    value when a dependency atom is updated. We will look closely at how such an API
    is implemented in [*Chapter 8*](B17780_08_Final_VK_ePub.xhtml#_idTextAnchor100),
    *Use Case Scenario 2 – Jotai*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这可行，我们需要跟踪依赖关系，并在依赖原子更新时重新评估派生值。我们将仔细研究如何在[*第8章*](B17780_08_Final_VK_ePub.xhtml#_idTextAnchor100)，“用例场景2
    – Jotai”中实现这样的API。
- en: The approach using atoms can be seen as something between a manual approach
    and an automatic approach. While the definition of atoms and derived values is
    explicit (manual), the dependency tracking is automatic.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用原子的方法可以看作是手动方法和自动方法之间的某种折中。虽然原子和派生值的定义是明确的（手动），但依赖跟踪是自动的。
- en: In this section, we learned about the various patterns for optimizing re-renders.
    It's important for a global state library to design how to optimize re-renders.
    It often affects the library API, and understanding how to optimize re-renders
    is also worthwhile for library users.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了优化重新渲染的各种模式。对于全局状态库来说，设计如何优化重新渲染是很重要的。这通常会影响库的API，理解如何优化重新渲染对于库用户来说也是值得的。
- en: Summary
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, before diving into the actual implementation of global state
    libraries, we learned about some basic challenges associated with it, and some
    categories to differentiate global state libraries. When choosing a global state
    library, we can see how the library lets us read a global state and write a global
    state, where the library stores a global state, and how the library optimizes
    re-renders. These are important aspects to understand which libraries work well
    for certain use cases, and they should help you to choose a library that suits
    your needs.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，在深入探讨全局状态库的实际实现之前，我们了解了一些与之相关的基本挑战，以及一些用于区分全局状态库的分类。在选择全局状态库时，我们可以看到库如何让我们读取全局状态和写入全局状态，库存储全局状态的位置，以及库如何优化重新渲染。这些是理解哪些库适用于特定用例的重要方面，它们应该有助于你选择适合你需求的库。
- en: In the next chapter, we will learn about the Zustand library, a library that
    takes a data-centric approach and optimizes re-renders with selector functions.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习关于Zustand库的内容，这是一个采用数据为中心的方法并使用选择器函数优化重新渲染的库。
