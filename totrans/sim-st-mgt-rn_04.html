<html><head></head><body>
<div id="_idContainer026">
<h1 class="chapter-number" id="_idParaDest-47"><a id="_idTextAnchor048"/><span class="koboSpan" id="kobo.1.1">4</span></h1>
<h1 id="_idParaDest-48"><a id="_idTextAnchor049"/><span class="koboSpan" id="kobo.2.1">Styling and Populating the Funbook App</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the previous chapter, we planned what surfaces and components will be needed for our app based on the design file. </span><span class="koboSpan" id="kobo.3.2">We also got comfortable previewing and debugging the app – at least I hope you got comfortable, my dear reader! </span><span class="koboSpan" id="kobo.3.3">Whether you’re using an iPhone or Android simulator or a real device with the Expo Go app, make sure you prefer checking your app that way. </span><span class="koboSpan" id="kobo.3.4">There’s no wrong answer for previewing apps built with Expo. </span><span class="koboSpan" id="kobo.3.5">In this chapter, we will style our surfaces and components. </span><span class="koboSpan" id="kobo.3.6">We will finally see an app that looks, hopefully, close to the design! </span><span class="koboSpan" id="kobo.3.7">After that, we will add some </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">real data.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">Here’s a very short list of what we’re planning to achieve in </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">Creating and </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">styling components</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">Pulling in data for </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">the app</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.11.1">By the end of this chapter, we will have a good-looking app that fetches data from an external API. </span><span class="koboSpan" id="kobo.11.2">Feel free to follow closely or write your </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">own code.</span></span></p>
<h1 id="_idParaDest-49"><a id="_idTextAnchor050"/><span class="koboSpan" id="kobo.13.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.14.1">In order to follow along with this chapter, you will need some knowledge of JavaScript and ReactJS. </span><span class="koboSpan" id="kobo.14.2">If you have followed along the first two chapters of this book, you should be able to go forward without </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">any issues.</span></span></p>
<p><span class="koboSpan" id="kobo.16.1">Feel free to use an IDE of your choice, as React Native does not need any specific functionality. </span><span class="koboSpan" id="kobo.16.2">Currently, the most popular IDEs for frontend developers are Microsoft’s Visual Studio Code, Atom, Sublime Text, </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">and WebStorm.</span></span></p>
<p><span class="koboSpan" id="kobo.18.1">The code snippets provided in this chapter are here to illustrate what we should be doing with the code. </span><span class="koboSpan" id="kobo.18.2">They do not provide the whole picture. </span><span class="koboSpan" id="kobo.18.3">For a better experience of coding along, open the GitHub repo in your IDE and look at the files </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">in there.</span></span></p>
<p><span class="koboSpan" id="kobo.20.1">If you get stuck or lost, you can check the code in the GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">repo: </span></span><a href="https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-4"><span class="No-Break"><span class="koboSpan" id="kobo.22.1">https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-4</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.23.1">.</span></span></p>
<h1 id="_idParaDest-50"><a id="_idTextAnchor051"/><span class="koboSpan" id="kobo.24.1">Creating and styling components</span></h1>
<p><span class="koboSpan" id="kobo.25.1">It’s time to create some real </span><a id="_idIndexMarker149"/><span class="koboSpan" id="kobo.26.1">components! </span><span class="koboSpan" id="kobo.26.2">Let’s start with the </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">home surface.</span></span></p>
<p><span class="koboSpan" id="kobo.28.1">I like to work from top to bottom, so we will start with the header. </span><span class="koboSpan" id="kobo.28.2">Our free design template includes the app name (“Socially”) and a bell icon at the top of the feed surface. </span><span class="koboSpan" id="kobo.28.3">We won’t be implementing notifications in our example app, so we’ll overlook this part of the design file. </span><span class="koboSpan" id="kobo.28.4">Adding styles to the header is done through React Navigation. </span><span class="koboSpan" id="kobo.28.5">We will add the following properties </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.30.1">&lt;Tab.Navigator&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.32.1">
// …
  headerTransparent: true,
  headerTitleAlign: "left",
  headerTitleStyle: {
  paddingTop: 140,
  paddingBottom: 40,
  textAlign: "left",
  fontWeight: "bold",
},
// …</span></pre>
<p><span class="koboSpan" id="kobo.33.1">As we analyzed the</span><a id="_idIndexMarker150"/><span class="koboSpan" id="kobo.34.1"> home surface before, we know we need to create two parts of this surface: a list of avatars and a list of cards with images. </span><span class="koboSpan" id="kobo.34.2">The list of avatars will use a horizontal </span><strong class="source-inline"><span class="koboSpan" id="kobo.35.1">FlatList</span></strong><span class="koboSpan" id="kobo.36.1"> component. </span><span class="koboSpan" id="kobo.36.2">The first item on the list is different; it’s a button used by the user to add content. </span><span class="koboSpan" id="kobo.36.3">We’ll add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.37.1">ListHeaderComponent</span></strong><span class="koboSpan" id="kobo.38.1"> property to </span><strong class="source-inline"><span class="koboSpan" id="kobo.39.1">FlatList</span></strong><span class="koboSpan" id="kobo.40.1">, where we will add this special item. </span><span class="koboSpan" id="kobo.40.2">Let’s create a placeholder component </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">for now:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.42.1">
// src/components/ListHeaderComponent
import React from "react";
import { View, Text } from "react-native";
export const ListHeaderComponent = () =&gt; {
  return (
    &lt;View&gt;
      &lt;Text&gt;List Header component placeholder&lt;/Text&gt;
    &lt;/View&gt;
  );
};</span></pre>
<p><span class="koboSpan" id="kobo.43.1">In the preceding code, we created a component named </span><strong class="source-inline"><span class="koboSpan" id="kobo.44.1">ListHeaderComponent</span></strong><span class="koboSpan" id="kobo.45.1">, so we can import it into </span><strong class="source-inline"><span class="koboSpan" id="kobo.46.1">FlatList</span></strong><span class="koboSpan" id="kobo.47.1">. </span><span class="koboSpan" id="kobo.47.2">So far, this component only displays </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">placeholder text.</span></span></p>
<p><span class="koboSpan" id="kobo.49.1">I added a few </span><a id="_idIndexMarker151"/><span class="koboSpan" id="kobo.50.1">profile images exported from the design file into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.51.1">assets</span></strong><span class="koboSpan" id="kobo.52.1"> folder. </span><span class="koboSpan" id="kobo.52.2">We’ll use</span><a id="_idIndexMarker152"/><span class="koboSpan" id="kobo.53.1"> them for our list </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">of avatars.</span></span></p>
<p><span class="koboSpan" id="kobo.55.1">Here’s what the </span><strong class="source-inline"><span class="koboSpan" id="kobo.56.1">ListOfAvatars</span></strong><span class="koboSpan" id="kobo.57.1"> component </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">looks like:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.59.1">
// src/components/ListOfAvatars.js
import React from "react";
import { View, Text, FlatList} from "react-native";
import { ListHeaderComponent } from "./ListHeaderComponent";
const arrayOfAvatars = [
  {
    id: 1,
    url: "",
  },
  {
    id: 2,
    url: "",
  },
  {
    id: 3,
    url: "",
  },
];
export const ListOfAvatars = () =&gt; {
  const renderItem = ({ item }) =&gt; {
    return &lt;Text&gt;{item.id}&lt;/Text&gt;
  };
  return (
    &lt;View style={{ paddingTop: 30 }}&gt;
      &lt;FlatList
        data={arrayOfAvatars}
        renderItem={renderItem}
        keyExtractor={(item) =&gt; item.id}
        horizontal
        ListHeaderComponent={&lt;ListHeaderComponent /&gt;}
      /&gt;
    &lt;/View&gt;
  );
};</span></pre>
<p><span class="koboSpan" id="kobo.60.1">Remember to import the</span><a id="_idIndexMarker153"/><span class="koboSpan" id="kobo.61.1"> necessary components from </span><strong class="bold"><span class="koboSpan" id="kobo.62.1">React Native</span></strong><span class="koboSpan" id="kobo.63.1"> – in this case, we need to import </span><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">FlatList</span></strong><span class="koboSpan" id="kobo.65.1">. </span><span class="koboSpan" id="kobo.65.2">You may </span><a id="_idIndexMarker154"/><span class="koboSpan" id="kobo.66.1">also notice I set up a very simple data array to be fed into the list of avatars. </span><span class="koboSpan" id="kobo.66.2">We’ll </span><a id="_idIndexMarker155"/><span class="koboSpan" id="kobo.67.1">manage connecting this component to our sample </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">data later.</span></span></p>
<p><span class="koboSpan" id="kobo.69.1">If you prefer to look at this code on your screen instead of the book, you can always look in the repo. </span><span class="koboSpan" id="kobo.69.2">The code we are working on currently can be found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.70.1">chapter-3</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.71.1">branch: </span></span><a href="https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-3"><span class="No-Break"><span class="koboSpan" id="kobo.72.1">https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-3</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.73.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.74.1">Once we have </span><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">FlatList</span></strong><span class="koboSpan" id="kobo.76.1"> set up with links to actual images, we can change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">&lt;Text&gt;</span></strong><span class="koboSpan" id="kobo.78.1"> component for an </span><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">&lt;Image&gt;</span></strong><span class="koboSpan" id="kobo.80.1"> component, feed it data from our array, add some styles so that the images are rounded, and </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">we’re done!</span></span></p>
<p><span class="koboSpan" id="kobo.82.1">We’ll add a list of cards, which will be very similar to the list of avatars. </span><span class="koboSpan" id="kobo.82.2">We’ll also use an array with temporary data and add some styling, and we should end up with a component looking </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.84.1">
// src/components/ListOfCards.js
export const ListOfCards = () =&gt; {
  const renderItem = ({ item }) =&gt; {
    return (
      &lt;Image
        style={{
          width: "100%",
          height: 288,
          borderRadius: 20,
          marginBottom: 32,
        }}
        source={{
          uri: item.url,
        }}
      /&gt;
    );
  };
  return (
    &lt;View style={{ paddingVertical: 30 }}&gt;
      &lt;FlatList
        data={arrayOfImages}
        renderItem={renderItem}
        keyExtractor={(item) =&gt; item.id}
        showsVerticalScrollIndicator={false}
      /&gt;
    &lt;/View&gt;
  );
};</span></pre>
<p><span class="koboSpan" id="kobo.85.1">The surface </span><a id="_idIndexMarker156"/><span class="koboSpan" id="kobo.86.1">component called </span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">Feed</span></strong><span class="koboSpan" id="kobo.88.1"> should only concern itself with importing the </span><a id="_idIndexMarker157"/><span class="koboSpan" id="kobo.89.1">correct children components and general styling. </span><span class="koboSpan" id="kobo.89.2">It looks </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.91.1">
// src/surfaces/Feed.js
export const Feed = () =&gt; {
  const headerHeight = useHeaderHeight();
  return (
    &lt;SafeAreaView
        style={{ flex: 1, paddingTop: headerHeight + 20,          paddingHorizontal: 20 }}
    &gt;
      &lt;View&gt;
        &lt;ListOfAvatars /&gt;
        &lt;ListOfCards /&gt;
      &lt;/View&gt;
    &lt;/SafeAreaView&gt;
  );
};</span></pre>
<p><span class="koboSpan" id="kobo.92.1">And the </span><strong class="bold"><span class="koboSpan" id="kobo.93.1">Feed</span></strong><span class="koboSpan" id="kobo.94.1"> surface of our </span><a id="_idIndexMarker158"/><span class="koboSpan" id="kobo.95.1">app should look </span><a id="_idIndexMarker159"/><span class="No-Break"><span class="koboSpan" id="kobo.96.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer024">
<span class="koboSpan" id="kobo.97.1"><img alt="Figure 4.1 – An iPhone simulator screenshot of the Feed surface " src="image/Figure_4.01_B18396.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.98.1">Figure 4.1 – An iPhone simulator screenshot of the Feed surface</span></p>
<p><span class="koboSpan" id="kobo.99.1">You can leave your app as is, or</span><a id="_idIndexMarker160"/><span class="koboSpan" id="kobo.100.1"> you can copy some styling tweaks that I added in the GitHub repo. </span><span class="koboSpan" id="kobo.100.2">We’re </span><a id="_idIndexMarker161"/><span class="koboSpan" id="kobo.101.1">not focusing on styles in this book, so we’re not going to go over them in detail; nonetheless, I encourage you to have a </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">look around.</span></span></p>
<p><span class="koboSpan" id="kobo.103.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.104.1">Feed</span></strong><span class="koboSpan" id="kobo.105.1"> surface is looking quite similar to the design, so we can move forward to the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.106.1">Conversations</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.107.1"> surface.</span></span></p>
<p><span class="koboSpan" id="kobo.108.1">Our </span><strong class="bold"><span class="koboSpan" id="kobo.109.1">Conversations</span></strong><span class="koboSpan" id="kobo.110.1"> surface needs to be wrapped in a new navigator because we want our users to be able to go into the conversation </span><a id="_idIndexMarker162"/><span class="koboSpan" id="kobo.111.1">details. </span><span class="koboSpan" id="kobo.111.2">We’ll add a new </span><a id="_idIndexMarker163"/><span class="koboSpan" id="kobo.112.1">component called </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">&lt;ConversationsNavigation&gt;</span></strong><span class="koboSpan" id="kobo.114.1">, where we will create a </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">Stack Navigator:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.116.1">
// src/surfaces/ConversationsNavigation.js
import React from "react";
import { Conversations } from "./Conversations";
import { Messages } from "./Messages";
import { createStackNavigator } from "@react-navigation/stack";
const Stack = createStackNavigator();
export const ConversationsNavigation = () =&gt; {
  return (
    &lt;Stack.Navigator
      screenOptions={{
        //…
      }}
    &gt;
        &lt;Stack.Screen name='Conversations'          component={Conversations} /&gt;
      &lt;Stack.Screen
        name='Messages'
        component={Messages}
        options={({ route }) =&gt; ({
          title: route.params.name,
          //…
        })}
      /&gt;
    &lt;/Stack.Navigator&gt;
  );
};</span></pre>
<p><span class="koboSpan" id="kobo.117.1">The most interesting</span><a id="_idIndexMarker164"/><span class="koboSpan" id="kobo.118.1"> option we’re setting in this component is </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">this </span></span><span class="No-Break"><a id="_idIndexMarker165"/></span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">one:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.121.1">
options={({ route }) =&gt; ({
          title: route.params.name,
          //…</span></pre>
<p><span class="koboSpan" id="kobo.122.1">This line of code tells </span><strong class="bold"><span class="koboSpan" id="kobo.123.1">React Navigation</span></strong><span class="koboSpan" id="kobo.124.1"> to use </span><a id="_idIndexMarker166"/><span class="koboSpan" id="kobo.125.1">a route parameter as the header title for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">Messages</span></strong><span class="koboSpan" id="kobo.127.1"> surface. </span><span class="koboSpan" id="kobo.127.2">If you test your app now, you will notice this is not happening yet. </span><span class="koboSpan" id="kobo.127.3">We also need to set this parameter at the time the user will choose to go to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">Messages</span></strong><span class="koboSpan" id="kobo.129.1"> surface, which means we need to set it when </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">Conversation</span></strong><span class="koboSpan" id="kobo.131.1"> is clicked. </span><span class="koboSpan" id="kobo.131.2">We will create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">Conversations</span></strong><span class="koboSpan" id="kobo.133.1"> surface with an input box at the top, followed by a list of conversations in </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">FlatList</span></strong><span class="koboSpan" id="kobo.135.1">. </span><span class="koboSpan" id="kobo.135.2">Each item in the list will be wrapped in a &lt;</span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">Pressable</span></strong><span class="koboSpan" id="kobo.137.1">&gt; component, which will look </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.139.1">
&lt;Pressable onPress={() =&gt; navigation.navigate("Messages", { name: item.name })} &gt;</span></pre>
<p><span class="koboSpan" id="kobo.140.1">When our users choose a conversation, this conversation will pass the assigned </span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">name</span></strong><span class="koboSpan" id="kobo.142.1"> parameter to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">Messages</span></strong><span class="koboSpan" id="kobo.144.1"> surface, which in turn will display this name as the header. </span><span class="koboSpan" id="kobo.144.2">We can now add a list of dummy messages and conditional styling, which will style differently messages from the user and to the user. </span><span class="koboSpan" id="kobo.144.3">A useful thing to remember for message lists is to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">inverted</span></strong><span class="koboSpan" id="kobo.146.1"> prop on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">FlatList</span></strong><span class="koboSpan" id="kobo.148.1"> component of messages. </span><span class="koboSpan" id="kobo.148.2">After all, we want the latest item to appear at the bottom of </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">the list.</span></span></p>
<p><span class="koboSpan" id="kobo.150.1">You may notice at this point that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">Conversations</span></strong><span class="koboSpan" id="kobo.152.1"> surface and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">Messages</span></strong><span class="koboSpan" id="kobo.154.1"> surface do not have the bottom tabs visible. </span><span class="koboSpan" id="kobo.154.2">The best way to achieve this functionality is to move our &lt;</span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">ConversationsNavigation</span></strong><span class="koboSpan" id="kobo.156.1">&gt; out of the tab navigator and move it into the main stack navigator. </span><span class="koboSpan" id="kobo.156.2">The surfaces</span><a id="_idIndexMarker167"/><span class="koboSpan" id="kobo.157.1"> listed in the main stack will be displayed above the surfaces in the</span><a id="_idIndexMarker168"/><span class="koboSpan" id="kobo.158.1"> Tab Navigator, plus we will be able to use the pre-configured back button provided by the React Navigation library. </span><span class="koboSpan" id="kobo.158.2">Here’s what the </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">App.js</span></strong><span class="koboSpan" id="kobo.160.1"> root component should </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">look like:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.162.1">
// src/App.js
export default function App() {
  //…
  return (
    &lt;SafeAreaProvider&gt;
      &lt;NavigationContainer&gt;
        &lt;Stack.Navigator&gt;
          {!userLoggedIn ? </span><span class="koboSpan" id="kobo.162.2">(
            &lt;Stack.Screen name='Login' component={Login} /&gt;
          ) : (
            &lt;&gt;
              &lt;Stack.Screen
                name='Home'
                component={Home}
                options={{ headerShown: false }}
              /&gt;
              &lt;Stack.Screen
                name='ConversationsNav'
                component={ConversationsNavigation}
                options={{ headerShown: false }}
              /&gt;
            &lt;/&gt;
          )}
        &lt;/Stack.Navigator&gt;
      &lt;/NavigationContainer&gt;
    &lt;/SafeAreaProvider&gt;
  );
}</span></pre>
<p><span class="koboSpan" id="kobo.163.1">In order to have a button</span><a id="_idIndexMarker169"/><span class="koboSpan" id="kobo.164.1"> for our </span><strong class="bold"><span class="koboSpan" id="kobo.165.1">Conversations</span></strong><span class="koboSpan" id="kobo.166.1"> surface displayed in the tabs, we will need to create an </span><a id="_idIndexMarker170"/><span class="koboSpan" id="kobo.167.1">empty dummy surface and pass it into the </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">Tab Navigator:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.169.1">
// src/surfaces/Home.js
&lt;Tab.Screen name='Feed' component={Feed} /&gt;
      &lt;Tab.Screen
        name='ConversationsMain'
          component={ConversationsBase} // just a dummy             component which will never be called
        options={{
          tabBarIcon: ({ size }) =&gt; (
              &lt;Ionicons name='chatbox-outline' color='#000000'                size={size} /&gt;
          ),
        }}
        listeners={({ navigation }) =&gt; ({
          tabPress: (e) =&gt; {
            e.preventDefault();
            navigation.navigate("ConversationsNav");
          },
        })}
      /&gt;
      &lt;Tab.Screen name='AddPost' component={AddPost} /&gt;
// …</span></pre>
<p><span class="koboSpan" id="kobo.170.1">We’ll add a floating button at the bottom of the </span><strong class="bold"><span class="koboSpan" id="kobo.171.1">Conversations</span></strong><span class="koboSpan" id="kobo.172.1"> surface, and </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">we’re done!</span></span></p>
<p><span class="koboSpan" id="kobo.174.1">I’m going over these </span><a id="_idIndexMarker171"/><span class="koboSpan" id="kobo.175.1">code changes fairly quickly, because we don’t want to spend</span><a id="_idIndexMarker172"/><span class="koboSpan" id="kobo.176.1"> too much time focusing on styling or React Navigation tips and tricks. </span><span class="koboSpan" id="kobo.176.2">We want to be up and running with an app that’s close to something you may find in the real world, so we can start playing with state and data management. </span><span class="koboSpan" id="kobo.176.3">Feel free to go over all code changes in the GitHub repo, where you can also ask questions and </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">raise issues.</span></span></p>
<p><span class="koboSpan" id="kobo.178.1">We’ll continue our progress by adding content to the </span><strong class="bold"><span class="koboSpan" id="kobo.179.1">Favorites</span></strong><span class="koboSpan" id="kobo.180.1"> surface. </span><span class="koboSpan" id="kobo.180.2">This will be a list of cards, like what can be found on the </span><strong class="bold"><span class="koboSpan" id="kobo.181.1">Feed</span></strong><span class="koboSpan" id="kobo.182.1"> surface. </span><span class="koboSpan" id="kobo.182.2">Next, we’ll add components to the </span><strong class="bold"><span class="koboSpan" id="kobo.183.1">Profile</span></strong><span class="koboSpan" id="kobo.184.1"> surface. </span><span class="koboSpan" id="kobo.184.2">We will need an avatar, a name, some statistics, and two </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">FlatList</span></strong><span class="koboSpan" id="kobo.186.1"> components that will display added images and </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">favorited images.</span></span></p>
<p><span class="koboSpan" id="kobo.188.1">We will finish up this surface by adding a custom component to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">Tab Navigator</span></strong><span class="koboSpan" id="kobo.190.1"> for the central item, the black button for adding posts. </span><span class="koboSpan" id="kobo.190.2">We can add any custom component that we want as the tab </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">bar icon:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.192.1">
// src/surfaces/Home.js
function Home() {
  return (
    &lt;Tab.Navigator&gt;
//…
   &lt;Tab.Screen
        name='AddPost'
        component={AddPost}
        options={{
          tabBarIcon: ({ size }) =&gt; (
            &lt;View
              style={{
                marginTop: -30,
              }}
            &gt;
              &lt;View
                style={{
                  position: "absolute",
                  backgroundColor: "#000000",
                  padding: 30,
                  bottom: -10,
                  left: -13,
                  borderRadius: 23,
                  transform: [{ rotate: "-45deg" }],
                  shadowColor: "#000000",
                  shadowOffset: { width: 0, height: 4 },
                  shadowOpacity: 0.2,
                  shadowRadius: 4,
                }}
              /&gt;
                &lt;Ionicons name='add-circle-outline'                  color='#ffffff' size={36} /&gt;
            &lt;/View&gt;
          ),
        }}
      /&gt;
//…</span></pre>
<p><span class="koboSpan" id="kobo.193.1">If you look closely, you</span><a id="_idIndexMarker173"/><span class="koboSpan" id="kobo.194.1"> will notice that the styling for this button is very similar to the floating button on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">Conversations</span></strong><span class="koboSpan" id="kobo.196.1"> surface. </span><span class="koboSpan" id="kobo.196.2">In cases where we’re repeating a lot of code, it’s a good idea to </span><a id="_idIndexMarker174"/><span class="koboSpan" id="kobo.197.1">abstract it into a separate file. </span><span class="koboSpan" id="kobo.197.2">This is called </span><strong class="bold"><span class="koboSpan" id="kobo.198.1">Don’t Repeat Yourself</span></strong><span class="koboSpan" id="kobo.199.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.200.1">DRY</span></strong><span class="koboSpan" id="kobo.201.1">) programming. </span><span class="koboSpan" id="kobo.201.2">We don’t want</span><a id="_idIndexMarker175"/><span class="koboSpan" id="kobo.202.1"> to go too far, making abstractions for every little thing. </span><span class="koboSpan" id="kobo.202.2">There’s another programming principle called </span><strong class="bold"><span class="koboSpan" id="kobo.203.1">Write Everything Twice</span></strong><span class="koboSpan" id="kobo.204.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.205.1">WET</span></strong><span class="koboSpan" id="kobo.206.1">) programming, which advocates writing verbose code, especially when starting a new</span><a id="_idIndexMarker176"/><span class="koboSpan" id="kobo.207.1"> project. </span><span class="koboSpan" id="kobo.207.2">My personal preference is </span><strong class="bold"><span class="koboSpan" id="kobo.208.1">Avoid Hasty Abstractions</span></strong><span class="koboSpan" id="kobo.209.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.210.1">AHA</span></strong><span class="koboSpan" id="kobo.211.1">) programming, proposed by </span><em class="italic"><span class="koboSpan" id="kobo.212.1">Kent C. </span><span class="koboSpan" id="kobo.212.2">Dodds</span></em><span class="koboSpan" id="kobo.213.1">. </span><span class="koboSpan" id="kobo.213.2">This approach marries DRY and WET principles and encourages us programmers to find the best use cases for abstractions </span><a id="_idIndexMarker177"/><span class="koboSpan" id="kobo.214.1">while not </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">overusing them.</span></span></p>
<p><span class="koboSpan" id="kobo.216.1">In this specific case, we are repeating styling. </span><span class="koboSpan" id="kobo.216.2">We can easily create a class called something like </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">floatingButton</span></strong><span class="koboSpan" id="kobo.218.1"> and apply it to both of our components. </span><span class="koboSpan" id="kobo.218.2">We could also use the </span><strong class="bold"><span class="koboSpan" id="kobo.219.1">Styled Components</span></strong><span class="koboSpan" id="kobo.220.1"> library</span><a id="_idIndexMarker178"/><span class="koboSpan" id="kobo.221.1"> and create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">&lt;FloatingButton&gt;</span></strong><span class="koboSpan" id="kobo.223.1"> styled component. </span><span class="koboSpan" id="kobo.223.2">There are more ways to achieve this goal of having reusable styles, but we are not going to dive into them. </span><span class="koboSpan" id="kobo.223.3">I’ll do some cleanup in our components, and I’ll meet you right back here in a few moments so that we can hook up some real data from our (almost) </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">real API.</span></span></p>
<h1 id="_idParaDest-51"><a id="_idTextAnchor052"/><span class="koboSpan" id="kobo.225.1">Pulling in data for the app</span></h1>
<p><span class="koboSpan" id="kobo.226.1">Welcome back! </span><span class="koboSpan" id="kobo.226.2">Did you take a </span><a id="_idIndexMarker179"/><span class="koboSpan" id="kobo.227.1">moment to look at our app code? </span><span class="koboSpan" id="kobo.227.2">Did you clone the</span><a id="_idIndexMarker180"/><span class="koboSpan" id="kobo.228.1"> repo from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">chapter-3</span></strong><span class="koboSpan" id="kobo.230.1"> branch, or did you create your own components following the broad strokes I described previously? </span><span class="koboSpan" id="kobo.230.2">Either way, I’m glad you’re here! </span><span class="koboSpan" id="kobo.230.3">Let’s fetch some data and use </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">some state!</span></span></p>
<p><span class="koboSpan" id="kobo.232.1">A quick reminder about the data we’ll be using: I set up GitHub Pages in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">/docs</span></strong><span class="koboSpan" id="kobo.234.1"> folder, which you can find </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">here: </span></span><a href="https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/docs"><span class="No-Break"><span class="koboSpan" id="kobo.236.1">https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/docs</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.237.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.238.1">You can preview every </span><a id="_idIndexMarker181"/><span class="koboSpan" id="kobo.239.1">JSON file right in the GitHub UI. </span><span class="koboSpan" id="kobo.239.2">You can also view the raw contents of any file by clicking the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.240.1">Raw</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.241.1"> button:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer025">
<span class="koboSpan" id="kobo.242.1"><img alt="Figure 4.2 – GitHub UI with the Raw button circled in red " src="image/Figure_4.02_B18396.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.243.1">Figure 4.2 – GitHub UI with the Raw button circled in red</span></p>
<p><span class="koboSpan" id="kobo.244.1">The text file</span><a id="_idIndexMarker182"/><span class="koboSpan" id="kobo.245.1"> visible after clicking this button is what you could see as an </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">API response.</span></span></p>
<p><span class="koboSpan" id="kobo.247.1">We’ll start with fetching the list of users. </span><span class="koboSpan" id="kobo.247.2">This list contains user IDs and links to user avatars. </span><span class="koboSpan" id="kobo.247.3">Our API depends on us to manage the user avatars everywhere in the app and passes them in this one </span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">endpoint only.</span></span></p>
<p><span class="koboSpan" id="kobo.249.1">So, let’s check where we need the list of users. </span><span class="koboSpan" id="kobo.249.2">We need it on the </span><strong class="bold"><span class="koboSpan" id="kobo.250.1">Feed</span></strong><span class="koboSpan" id="kobo.251.1"> surface to display the list of avatars. </span><span class="koboSpan" id="kobo.251.2">We will also need it to display avatars on the cards on the </span><strong class="bold"><span class="koboSpan" id="kobo.252.1">Feed</span></strong><span class="koboSpan" id="kobo.253.1"> surface. </span><span class="koboSpan" id="kobo.253.2">We will also need the user data on the </span><strong class="bold"><span class="koboSpan" id="kobo.254.1">Conversations</span></strong><span class="koboSpan" id="kobo.255.1"> surface and the </span><strong class="bold"><span class="koboSpan" id="kobo.256.1">Messaging</span></strong><span class="koboSpan" id="kobo.257.1"> surface. </span><span class="koboSpan" id="kobo.257.2">At this point, it will be beneficial to find the common parent of those surfaces and call our API in the said parent. </span><span class="koboSpan" id="kobo.257.3">In our case, the parent is the root component declared </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">App.js</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.261.1">The first thing we’ll do is fetch our data in </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">the parent:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.263.1">
// src/App.js
export default function App() {
  const [userLoggedIn, setIsUserLoggedIn] = useState(true);
  const [userList, setUserList] = useState(null);
//…
  async function fetchUserData(id) {
    const response = await fetch(requestBase + "/users.json");
    setUserList(await response.json());
  }
  useEffect(() =&gt; {
    fetchUserData();
  }, []);
  //…
  if (!userList) {
    return &lt;AppLoading /&gt;;
  }</span></pre>
<p><span class="koboSpan" id="kobo.264.1">Once we have our</span><a id="_idIndexMarker183"/><span class="koboSpan" id="kobo.265.1"> data fetched and inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">userList</span></strong><span class="koboSpan" id="kobo.267.1"> object, we can</span><a id="_idIndexMarker184"/><span class="koboSpan" id="kobo.268.1"> pass it as a prop from the parent component to the children. </span><span class="koboSpan" id="kobo.268.2">According to the React Navigation docs, you can pass additional props through the render callback of the navigator. </span><span class="koboSpan" id="kobo.268.3">Here’s what it would look like for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">Home</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.270.1"> component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.271.1">
&lt;Stack.Screen name='Home' options={{ headerShown: false }}&gt;
    {(props) =&gt; &lt;Home {...props} userList={userList} /&gt;}
&lt;/Stack.Screen&gt;</span></pre>
<p><span class="koboSpan" id="kobo.272.1">Once we have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">userList</span></strong><span class="koboSpan" id="kobo.274.1"> prop in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">Home</span></strong><span class="koboSpan" id="kobo.276.1"> surface, we should be done, yes? </span><span class="koboSpan" id="kobo.276.2">Unfortunately, no. </span><span class="koboSpan" id="kobo.276.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">Home</span></strong><span class="koboSpan" id="kobo.278.1"> surface is a parent for the tab navigator, so we need to do the whole song and dance of adding the render callback for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">Feed</span></strong><span class="koboSpan" id="kobo.280.1"> surface. </span><span class="koboSpan" id="kobo.280.2">Once we get to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">Feed</span></strong><span class="koboSpan" id="kobo.282.1"> surface, we will need to pass the </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">userList</span></strong><span class="koboSpan" id="kobo.284.1"> prop to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">ListOfAvatars</span></strong><span class="koboSpan" id="kobo.286.1"> component… This is starting to be a bit much, don’t you think? </span><span class="koboSpan" id="kobo.286.2">This is a taste of what would be called prop</span><a id="_idIndexMarker185"/><span class="koboSpan" id="kobo.287.1"> drilling in a bigger app. </span><span class="koboSpan" id="kobo.287.2">Passing an object through multiple surfaces and components</span><a id="_idIndexMarker186"/><span class="koboSpan" id="kobo.288.1"> is not only tedious but also error-prone. </span><span class="koboSpan" id="kobo.288.2">This sort of setup is brittle – it suffices that one component in the chain changes, and the whole app may become unusable. </span><span class="koboSpan" id="kobo.288.3">What can we do to avoid this? </span><span class="koboSpan" id="kobo.288.4">We</span><a id="_idIndexMarker187"/><span class="koboSpan" id="kobo.289.1"> can use </span><strong class="bold"><span class="koboSpan" id="kobo.290.1">React Context</span></strong><span class="koboSpan" id="kobo.291.1">. </span><span class="koboSpan" id="kobo.291.2">This is also the strategy recommended by the maintainers of </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">React Navigation.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.293.1">What is context?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.294.1">Context is used to pass </span><a id="_idIndexMarker188"/><span class="koboSpan" id="kobo.295.1">data down the component tree without having to thread the props manually through </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">every component.</span></span></p>
<p><span class="koboSpan" id="kobo.297.1">The first step we need to take is to create our context with an </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">initial value:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.299.1">
const UserListContext = React.createContext(null);</span></pre>
<p><span class="koboSpan" id="kobo.300.1">Then, we need to wrap the parent component in a Context Provider with an </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">updated value:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.302.1">
// src/App.js
return (
    &lt;SafeAreaProvider&gt;
      &lt;UserListContext.Provider value={{ userList: userList }}&gt;
        &lt;NavigationContainer theme={MyTheme}&gt;
          &lt;Stack.Navigator&gt;
//…</span></pre>
<p><span class="koboSpan" id="kobo.303.1">The last piece of the context puzzle is how to use it, or “consume it.” </span><span class="koboSpan" id="kobo.303.2">Once the context is provided to the parent, we can </span><a id="_idIndexMarker189"/><span class="koboSpan" id="kobo.304.1">consume it in any one of its children through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">&lt;Context.Consumer&gt;</span></strong><span class="koboSpan" id="kobo.306.1"> component. </span><span class="koboSpan" id="kobo.306.2">We will add this consumer to our list </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">of avatars:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.308.1">
// src/components/ListOfAvatars.js
export const ListOfAvatars = () =&gt; {
  const renderItem = ({ item }) =&gt; {
   //…
  };
  return (
    &lt;UserListContext.Consumer&gt;
      {({ userList }) =&gt; (
          &lt;View
          //…
          &gt;
            &lt;FlatList
              data={userList}
              renderItem={renderItem}
              keyExtractor={(item) =&gt; item.id}
              horizontal
              //…</span></pre>
<p><span class="koboSpan" id="kobo.309.1">And there we go! </span><span class="koboSpan" id="kobo.309.2">We successfully fetched external data, fed it to our app, and passed the data around with the help of React Context. </span><span class="koboSpan" id="kobo.309.3">Using context offers a much better developer experience; however, it does come with its own set of issues. </span><span class="koboSpan" id="kobo.309.4">The biggest issue that you should always</span><a id="_idIndexMarker190"/><span class="koboSpan" id="kobo.310.1"> keep in mind when using context is that any change to the context will cause a re-render of the component where the </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">Provider</span></strong><span class="koboSpan" id="kobo.312.1"> is placed, along with all the children of the said component. </span><span class="koboSpan" id="kobo.312.2">This means that if we were to have an API where the user can add or remove other users to their list, every time they would do this, the entire app would have to re-render. </span><span class="koboSpan" id="kobo.312.3">Sometimes, that’s what we want; we want to have the avatar list and the list of images in </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">Feed</span></strong><span class="koboSpan" id="kobo.314.1"> updated. </span><span class="koboSpan" id="kobo.314.2">We also</span><a id="_idIndexMarker191"/><span class="koboSpan" id="kobo.315.1"> want to update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">Conversations</span></strong><span class="koboSpan" id="kobo.317.1"> surface in such a case. </span><span class="koboSpan" id="kobo.317.2">But what about the </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">Profile</span></strong><span class="koboSpan" id="kobo.319.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">Add</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.321.1">Post</span></strong><span class="koboSpan" id="kobo.322.1"> surfaces? </span><span class="koboSpan" id="kobo.322.2">We will not be answering those questions now, as </span><a id="_idIndexMarker192"/><span class="koboSpan" id="kobo.323.1">we’re working with an example app. </span><span class="koboSpan" id="kobo.323.2">However, every time you decide to use React’s Context, you should ask yourself where to place the Provider and what will happen when the data of the </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">context changes.</span></span></p>
<p><span class="koboSpan" id="kobo.325.1">Let’s continue fetching real data for other parts of our app. </span><span class="koboSpan" id="kobo.325.2">We’d like to display images on </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">Feed</span></strong><span class="koboSpan" id="kobo.327.1">. </span><span class="koboSpan" id="kobo.327.2">We’ll start by fetching data in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">ListOfCards</span></strong><span class="koboSpan" id="kobo.329.1"> component with a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">useEffect</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.331.1"> hook:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.332.1">
// src/components/ListOfCards.js
import AppLoading from "expo-app-loading";
import { requestBase } from "../utils/constants";
export const ListOfCards = () =&gt; {
  const [cardList, setCardList] = useState(null);
  async function fetchCardData() {
    const response = await fetch(requestBase + "/home.json");
    setCardList(await response.json());
  }
  useEffect(() =&gt; {
    fetchCardData();
  }, []);
  if (!cardList) {
    return &lt;AppLoading /&gt;;
  }
  return (
  //…
      &lt;FlatList
        data={cardList.listOfitems}
        renderItem={renderItem}
        keyExtractor={(item) =&gt; item.itemId}</span></pre>
<p><span class="koboSpan" id="kobo.333.1">Once our card items are</span><a id="_idIndexMarker193"/><span class="koboSpan" id="kobo.334.1"> fetched and passed on to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">Card</span></strong><span class="koboSpan" id="kobo.336.1"> component, we can do</span><a id="_idIndexMarker194"/><span class="koboSpan" id="kobo.337.1"> something more with them – namely, we can check the author ID against the user list in our context and display the correct username and avatar thanks to </span><span class="No-Break"><span class="koboSpan" id="kobo.338.1">this information.</span></span></p>
<p><span class="koboSpan" id="kobo.339.1">We will add the same context consumer to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">Card</span></strong><span class="koboSpan" id="kobo.341.1"> component as the one we added to </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">ListOfAvatars</span></strong><span class="koboSpan" id="kobo.343.1">, but that is not going to be enough in this case. </span><span class="koboSpan" id="kobo.343.2">Once we get the whole list, we also need to find the user whose ID matches the author ID of the card. </span><span class="koboSpan" id="kobo.343.3">We’ll adjust the way we pass the context value, and we’ll filter the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">userList</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.345.1"> array:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.346.1">
// src/components/Card.js
import { UserListContext } from "../context";
export const Card = ({ item }) =&gt; {
  return (
    &lt;UserListContext.Consumer&gt;
      {({ userList }) =&gt; {
        const currentUser = userList.filter(
          (user) =&gt; user.id === item.authorId
        );
        return (
          &lt;View&gt;
            &lt;Image
            //…</span></pre>
<p><span class="koboSpan" id="kobo.347.1">We created a variable called </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">currentUser</span></strong><span class="koboSpan" id="kobo.349.1">, which is an array holding precisely one item – the user who posted the specific card. </span><span class="koboSpan" id="kobo.349.2">Unfortunately, this variable is accessible to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">Card</span></strong><span class="koboSpan" id="kobo.351.1"> component only. </span><span class="koboSpan" id="kobo.351.2">If we wanted to use the same information, for example, on a modal that would open when we tap the image, we would have to either nest the modal component in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">Card</span></strong><span class="koboSpan" id="kobo.353.1"> component or search for the current user again. </span><span class="koboSpan" id="kobo.353.2">You will see an example of this issue in our very own app in a few moments, when we’ll be working with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">Conversations</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.355.1"> surface.</span></span></p>
<p><span class="koboSpan" id="kobo.356.1">On the other hand, we have composed </span><a id="_idIndexMarker195"/><span class="koboSpan" id="kobo.357.1">another surface using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">Card</span></strong><span class="koboSpan" id="kobo.359.1"> component – the </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">Favorites</span></strong><span class="koboSpan" id="kobo.361.1"> surface. </span><span class="koboSpan" id="kobo.361.2">All we must do to have it working correctly is fetch the </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">Favorites</span></strong><span class="koboSpan" id="kobo.363.1"> data. </span><span class="koboSpan" id="kobo.363.2">All the rest should fall </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">into place.</span></span></p>
<p><span class="koboSpan" id="kobo.365.1">If you encounter any problems </span><a id="_idIndexMarker196"/><span class="koboSpan" id="kobo.366.1">with loading data from our example API hosted on GitHub pages, start by making sure the data is fetched. </span><span class="koboSpan" id="kobo.366.2">You can do so by using </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">console.log</span></strong><span class="koboSpan" id="kobo.368.1"> in your code and looking in the terminal to see whether the object is fetched or not. </span><span class="koboSpan" id="kobo.368.2">Then, you need to check whether you have all the names and object keys spelled and nested correctly. </span><span class="koboSpan" id="kobo.368.3">If you get stuck at any point, remember that you can always go to the repo hosted on GitHub, clone it, and look around at any stage you </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">would like.</span></span></p>
<p><span class="koboSpan" id="kobo.370.1">Let’s move on to the next component that needs to fetch data – </span><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">Conversations</span></strong><span class="koboSpan" id="kobo.372.1">. </span><span class="koboSpan" id="kobo.372.2">As I mentioned before, we will need to tweak and repeat some code we already wrote for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">Card</span></strong><span class="koboSpan" id="kobo.374.1"> component used in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">Feed</span></strong><span class="koboSpan" id="kobo.376.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">Favorites</span></strong><span class="koboSpan" id="kobo.378.1"> surfaces. </span><span class="koboSpan" id="kobo.378.2">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">Conversations</span></strong><span class="koboSpan" id="kobo.380.1">, we will also fetch the user list and search for the current user. </span><span class="koboSpan" id="kobo.380.2">Make sure to spell everything correctly. </span><span class="koboSpan" id="kobo.380.3">The sneaky API author named everything differently! </span><span class="koboSpan" id="kobo.380.4">Here’s what my </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">Conversations</span></strong><span class="koboSpan" id="kobo.382.1"> component </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">looks like:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.384.1">
// src/components/ConversationItem.js
export const ConversationItem = ({ navigation, item }) =&gt; {
  return (
    &lt;UserListContext.Consumer&gt;
      {({ userList }) =&gt; {
          const currentUser = userList.filter((user) =&gt;            user.id === item.userId);
        return (
          &lt;Pressable
            onPress={() =&gt;
              navigation.navigate("Messages", {
                name: currentUser[0].name,
                avatar: currentUser[0].url,
              })
            }
            style={{
              height: 103,
         //…</span></pre>
<p><span class="koboSpan" id="kobo.385.1">Please pay attention to </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">[0]</span></strong><span class="koboSpan" id="kobo.387.1"> after </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">currentUser</span></strong><span class="koboSpan" id="kobo.389.1">. </span><span class="koboSpan" id="kobo.389.2">We used a filter function on an array, and we have an array as a result. </span><span class="koboSpan" id="kobo.389.3">Omitting </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">[0]</span></strong><span class="koboSpan" id="kobo.391.1"> means the app will not be displaying any data because</span><a id="_idIndexMarker197"/><span class="koboSpan" id="kobo.392.1"> it will see an array instead of </span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">an object.</span></span></p>
<p><span class="koboSpan" id="kobo.394.1">We have our list of </span><a id="_idIndexMarker198"/><span class="koboSpan" id="kobo.395.1">conversations; now’s the time to fetch the specific conversation when one is tapped by the user. </span><span class="koboSpan" id="kobo.395.2">The action of redirecting to the messages screen happens in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">&lt;ConversationItem&gt;</span></strong><span class="koboSpan" id="kobo.397.1"> component in </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">FlatList</span></strong><span class="koboSpan" id="kobo.399.1"> on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">Conversations</span></strong><span class="koboSpan" id="kobo.401.1"> surface. </span><span class="koboSpan" id="kobo.401.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">Messages</span></strong><span class="koboSpan" id="kobo.403.1"> surface is a part of the same stack navigator as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">Conversations</span></strong><span class="koboSpan" id="kobo.405.1">, which means we could go two </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">ways here:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.407.1">Add context to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">&lt;ConversationsNavigation&gt;</span></strong><span class="koboSpan" id="kobo.409.1"> component, set its value when a conversation is tapped, and consume it on the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">Messaging</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.411.1"> surface.</span></span></li>
<li><span class="koboSpan" id="kobo.412.1">Pass the conversation ID as a route parameter, along with </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">user data.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.414.1">The second approach is very tempting because it’s simple. </span><span class="koboSpan" id="kobo.414.2">We’re just adding a piece of data that’s already accessible to us, and we’re passing it through the navigation to the correct place. </span><span class="koboSpan" id="kobo.414.3">There’s nothing</span><a id="_idIndexMarker199"/><span class="koboSpan" id="kobo.415.1"> inherently wrong with this approach that I could criticize off the bat. </span><span class="koboSpan" id="kobo.415.2">It is foreseeable, however, that in a real-world app, you would end up writing very big or duplicated </span><a id="_idIndexMarker200"/><span class="koboSpan" id="kobo.416.1">objects to be passed around in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">route</span></strong><span class="koboSpan" id="kobo.418.1"> params. </span><span class="koboSpan" id="kobo.418.2">As per the React Navigation documentation, even though using route params is convenient, they should not be used as a replacement for a global app state. </span><span class="koboSpan" id="kobo.418.3">Manually passing data through route params can lead to bugs and an app showing outdated data. </span><span class="koboSpan" id="kobo.418.4">If you’d like a little bit of exercise, you could implement this solution in your own copy of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">FunBook</span></strong><span class="koboSpan" id="kobo.420.1"> app </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">right now.</span></span></p>
<p><span class="koboSpan" id="kobo.422.1">When you’re ready, come back here and I’ll walk you through creating and consuming the new context for </span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">the conversations.</span></span></p>
<p><span class="koboSpan" id="kobo.424.1">We’ll start like before, by creating the context with its </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">initial value:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.426.1">
export const ConversationContext = React.createContext(null);</span></pre>
<p><span class="koboSpan" id="kobo.427.1">I’ve decided to hold the functions to create context in a separate file, called </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">context.js</span></strong><span class="koboSpan" id="kobo.429.1"> for simplicity’s sake. </span><span class="koboSpan" id="kobo.429.2">Once the context is created, we need to wrap it around the correct component. </span><span class="koboSpan" id="kobo.429.3">In this case, we will need to add the Provider around the nested </span><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">Stack</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.431.1">Navigator</span></strong><span class="koboSpan" id="kobo.432.1"> of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">Conversations</span></strong><span class="koboSpan" id="kobo.434.1"> surface. </span><span class="koboSpan" id="kobo.434.2">Let’s add the following code to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">&lt;</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">ConversationsNavigation&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.437.1"> component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.438.1">
// src/surfaces/ConversationsNavigation.js
import { ConversationContext } from "../context";
//…
export const ConversationsNavigation = () =&gt; {
  const [conversationId, setConversationId] = useState(null);
  return (
    &lt;ConversationContext.Provider
      value={{
        conversationId: conversationId,
        setConversationId: setConversationId,
      }}
    &gt;
      &lt;Stack.Navigator
        screenOptions={{
          headerBackTitleVisible: false,
// …</span></pre>
<p><span class="koboSpan" id="kobo.439.1">You will notice we are passing </span><a id="_idIndexMarker201"/><span class="koboSpan" id="kobo.440.1">both the</span><a id="_idIndexMarker202"/><span class="koboSpan" id="kobo.441.1"> value and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">setter</span></strong><span class="koboSpan" id="kobo.443.1"> function to the context this time. </span><span class="koboSpan" id="kobo.443.2">This is because we will need to set the value of the context deeper in the tree, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">&lt;ConversationItem&gt;</span></strong><span class="koboSpan" id="kobo.445.1"> component. </span><span class="koboSpan" id="kobo.445.2">Not to worry though; passing functions through context is </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">100% a-okay!</span></span></p>
<p><span class="koboSpan" id="kobo.447.1">What about multiple contexts, you may ask, when you notice that </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">&lt;ConversationItem&gt;</span></strong><span class="koboSpan" id="kobo.449.1"> is already wrapped in </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">&lt;UserListContext.Consumer&gt;</span></strong><span class="koboSpan" id="kobo.451.1">? </span><span class="koboSpan" id="kobo.451.2">Again, this is totally fine. </span><span class="koboSpan" id="kobo.451.3">You can have just as many wrappers as you need and like! </span><span class="koboSpan" id="kobo.451.4">Here’s what our component with two contexts will </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">look like:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.453.1">
// src/components/ConversationItem.js
export const ConversationItem = ({ navigation, item }) =&gt; {
  const onPressItem = (setConversationId, currentUser) =&gt; {
    setConversationId(item.id);
    navigation.navigate("Messages", {
      name: currentUser[0].name,
      avatar: currentUser[0].url,
    });
  };
  return (
    &lt;ConversationContext.Consumer&gt;
      {({ setConversationId }) =&gt; (
        &lt;UserListContext.Consumer&gt;
          {({ userList }) =&gt; {
            const currentUser = userList.filter(
              (user) =&gt; user.id === item.userId
            );
            return (
              &lt;Pressable
                  onPress={() =&gt; onPressItem(setConversationId,                    currentUser)}
                //…</span></pre>
<p><span class="koboSpan" id="kobo.454.1">Now that we’re</span><a id="_idIndexMarker203"/><span class="koboSpan" id="kobo.455.1"> setting the context, let’s consume it in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">Messages</span></strong><span class="koboSpan" id="kobo.457.1"> surface. </span><span class="koboSpan" id="kobo.457.2">We need</span><a id="_idIndexMarker204"/><span class="koboSpan" id="kobo.458.1"> to first get the conversation ID from the context and then fetch the correct </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">JSON</span></strong><span class="koboSpan" id="kobo.460.1"> file for the given conversation. </span><span class="koboSpan" id="kobo.460.2">We’ll add </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">&lt;ConversationContext.Consumer&gt;</span></strong><span class="koboSpan" id="kobo.462.1"> as a wrapper on the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">Messages</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.464.1"> surface:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.465.1">
// src/surfaces/Messages.js
export const Messages = ({ route }) =&gt; {
  const headerHeight = useHeaderHeight();
  return (
      &lt;SafeAreaView style={{ flex: 1, paddingTop: headerHeight         + 100 }}&gt;
      &lt;ConversationContext.Consumer&gt;
        {({ conversationId }) =&gt; (</span></pre>
<p><span class="koboSpan" id="kobo.466.1">Once we get the</span><a id="_idIndexMarker205"/><span class="koboSpan" id="kobo.467.1"> conversation ID, we’ll use it in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">ListOfMessages</span></strong><span class="koboSpan" id="kobo.469.1"> component to </span><a id="_idIndexMarker206"/><span class="koboSpan" id="kobo.470.1">fetch the data pertinent to the </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">given screen:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.472.1">
// src/components/ListOfMessages.js
import AppLoading from "expo-app-loading";
import { requestBase } from "../utils/constants";
export const ListOfMessages = ({ conversationId }) =&gt; {
  const [messages, setMessages] = useState(null);
  async function fetchMessages() {
    const response = await fetch(
      requestBase + "/messages/" + conversationId + ".json"
    );
    setMessages(await response.json());
  }
  useEffect(() =&gt; {
    fetchMessages();
  }, []);
  if (!messages) {
    return &lt;AppLoading /&gt;;
  }
  const renderItem = ({ item }) =&gt; {
    //…
  };
  return (
    //…
      &lt;FlatList
        data={messages.messages}
        renderItem={renderItem}
        keyExtractor={(item) =&gt; item.id}
        showsVerticalScrollIndicator={false}
        inverted
      /&gt;
    &lt;/View&gt;
  //…</span></pre>
<p><span class="koboSpan" id="kobo.473.1">And there we go! </span><span class="koboSpan" id="kobo.473.2">We’ve </span><a id="_idIndexMarker207"/><span class="koboSpan" id="kobo.474.1">done some solid work here; it’s time for a pat on the </span><a id="_idIndexMarker208"/><span class="koboSpan" id="kobo.475.1">back. </span><span class="koboSpan" id="kobo.475.2">We have multiple components fetching data and passing it around when necessary. </span><span class="koboSpan" id="kobo.475.3">We’ve set up the </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">Feed</span></strong><span class="koboSpan" id="kobo.477.1"> component, </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">Favorites</span></strong><span class="koboSpan" id="kobo.479.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">Conversations</span></strong><span class="koboSpan" id="kobo.481.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">Messaging</span></strong><span class="koboSpan" id="kobo.483.1">. </span><span class="koboSpan" id="kobo.483.2">The last surface left is </span><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">Profile</span></strong><span class="koboSpan" id="kobo.485.1">. </span><span class="koboSpan" id="kobo.485.2">I will leave it to you, dear reader, to manage data on this surface. </span><span class="koboSpan" id="kobo.485.3">I trust that you have learned enough in this chapter to be able to do it on </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">your own.</span></span></p>
<p><span class="koboSpan" id="kobo.487.1">When you go to the book repo, you will find all work related to this chapter on a branch called </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">chapter-3</span></strong><span class="koboSpan" id="kobo.489.1">. </span><span class="koboSpan" id="kobo.489.2">You can browse through commits to see how the app development progressed, or you can simply check out the final state of the app. </span><span class="koboSpan" id="kobo.489.3">In the next chapter, we will see whether we can replace all our context, props, and filtering users with a more global solution called Redux. </span><span class="koboSpan" id="kobo.489.4">Onward </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">and upward!</span></span></p>
<h1 id="_idParaDest-52"><a id="_idTextAnchor053"/><span class="koboSpan" id="kobo.491.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.492.1">We have done a lot of great work in this chapter! </span><span class="koboSpan" id="kobo.492.2">There’s a very specific sort of satisfaction when you see an app that looks nice and works smoothly, </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">isn’t there?</span></span></p>
<p><span class="koboSpan" id="kobo.494.1">Here’s where we are at after this chapter – we have an app that’s styled according to design. </span><span class="koboSpan" id="kobo.494.2">This app pulls in external data from an API. </span><span class="koboSpan" id="kobo.494.3">I admit that our app is rather simple. </span><span class="koboSpan" id="kobo.494.4">There are many more functionalities that could be added to a social media clone app. </span><span class="koboSpan" id="kobo.494.5">And there’s nothing stopping you from doing just that. </span><span class="koboSpan" id="kobo.494.6">You can play around and add and delete whatever you want. </span><span class="koboSpan" id="kobo.494.7">I will also add a few more functionalities, maybe a modal, or a functioning “like” button, and I’ll see you in </span><a href="B18396_05.xhtml#_idTextAnchor056"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.495.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.496.1">, where we’ll start investigating our first state management solution – </span><span class="No-Break"><span class="koboSpan" id="kobo.497.1">Redux.</span></span></p>
<h1 id="_idParaDest-53"><a id="_idTextAnchor054"/><span class="koboSpan" id="kobo.498.1">Further reading</span></h1>
<ul>
<li><a href="https://www.digitalocean.com/community/tutorials/what-is-dry-development"><span class="koboSpan" id="kobo.499.1">https://www.digitalocean.com/community/tutorials/what-is-dry-development</span></a><span class="koboSpan" id="kobo.500.1">: </span><span class="No-Break"><span class="koboSpan" id="kobo.501.1">DRY programming.</span></span></li>
<li><a href="https://betterprogramming.pub/when-dry-doesnt-work-go-wet-6befda0444bf"><span class="koboSpan" id="kobo.502.1">https://betterprogramming.pub/when-dry-doesnt-work-go-wet-6befda0444bf</span></a><span class="koboSpan" id="kobo.503.1">: </span><span class="No-Break"><span class="koboSpan" id="kobo.504.1">WET programming.</span></span></li>
<li><a href="https://kentcdodds.com/blog/aha-programming"><span class="koboSpan" id="kobo.505.1">https://kentcdodds.com/blog/aha-programming</span></a><span class="koboSpan" id="kobo.506.1">: </span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">AHA programming.</span></span></li>
<li><a href="https://reactnavigation.org/docs/hello-react-navigation/#passing-additional-props"><span class="koboSpan" id="kobo.508.1">https://reactnavigation.org/docs/hello-react-navigation/#passing-additional-props</span></a><span class="koboSpan" id="kobo.509.1">: Passing additional props in </span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">React Navigation.</span></span></li>
<li><a href="https://reactjs.org/docs/context.html"><span class="koboSpan" id="kobo.511.1">https://reactjs.org/docs/context.html</span></a><span class="koboSpan" id="kobo.512.1">: </span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">React Context.</span></span></li>
<li><a href="https://reactnavigation.org/docs/params/#what-should-be-in-params"><span class="koboSpan" id="kobo.514.1">https://reactnavigation.org/docs/params/#what-should-be-in-params</span></a><span class="koboSpan" id="kobo.515.1">: React Navigation – what should be </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">in params?</span></span></li>
</ul>
</div>


<div>
<div class="Basic-Graphics-Frame" id="_idContainer027">
</div>
</div>
<div class="Content" id="_idContainer028">
<h1 id="_idParaDest-54"><a id="_idTextAnchor055"/><span class="koboSpan" id="kobo.1.1">Part 3 – Exploring Various Libraries for State Management in React Native</span></h1>
<p><span class="koboSpan" id="kobo.2.1">In this part, we will start with Redux and its Toolkit; we will learn why they were created, how to configure them, and how to use them for managing liked images in the example app. </span><span class="koboSpan" id="kobo.2.2">Next, we will learn about MobX, what problems it wants to solve, and how to configure it and use it to manage liked images in the Funbook app. </span><span class="koboSpan" id="kobo.2.3">Then, we will learn about XState, what the mathematical bases for this library are, how to configure it, and how to visualize data thanks to its Visualizer. </span><span class="koboSpan" id="kobo.2.4">Finally, we will implement it for managing liked images in the Funbook app. </span><span class="koboSpan" id="kobo.2.5">Next comes Jotai; we will see why it was created and what problems it solves. </span><span class="koboSpan" id="kobo.2.6">Then, we will configure it for the Funbook app and use it to manage liked images. </span><span class="koboSpan" id="kobo.2.7">Finally, we will learn about React Query (or TanStack Query). </span><span class="koboSpan" id="kobo.2.8">We will learn why this library is even mentioned in a book about state management. </span><span class="koboSpan" id="kobo.2.9">Then, we will configure it and use it for fetching liked images in the </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">Funbook app.</span></span></p>
<p><span class="koboSpan" id="kobo.4.1">This part includes the </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">following chapters:</span></span></p>
<ul>
<li><a href="B18396_05.xhtml#_idTextAnchor056"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 5</span></em></a><span class="koboSpan" id="kobo.7.1">, </span><em class="italic"><span class="koboSpan" id="kobo.8.1">Implementing Redux in Our Funbook App</span></em></li>
<li><a href="B18396_06.xhtml#_idTextAnchor072"><em class="italic"><span class="koboSpan" id="kobo.9.1">Chapter 6</span></em></a><span class="koboSpan" id="kobo.10.1">, </span><em class="italic"><span class="koboSpan" id="kobo.11.1">Using MobX as a State Manager in a React Native App</span></em></li>
<li><a href="B18396_07.xhtml#_idTextAnchor084"><em class="italic"><span class="koboSpan" id="kobo.12.1">Chapter 7</span></em></a><span class="koboSpan" id="kobo.13.1">, </span><em class="italic"><span class="koboSpan" id="kobo.14.1">Untangling Complex Flows in React Native Apps with XState</span></em></li>
<li><a href="B18396_08.xhtml#_idTextAnchor097"><em class="italic"><span class="koboSpan" id="kobo.15.1">Chapter 8</span></em></a><span class="koboSpan" id="kobo.16.1">, </span><a href="https://epic.packtpub.services/index.php?module=oss_Chapters&amp;action=DetailView&amp;record=254c4c24-4e8a-0b72-fab6-61f37807c398"><em class="italic"><span class="koboSpan" id="kobo.17.1">Integrating Jotai in a React Native App</span></em></a></li>
<li><a href="B18396_09.xhtml#_idTextAnchor110"><em class="italic"><span class="koboSpan" id="kobo.18.1">Chapter  9</span></em></a><span class="koboSpan" id="kobo.19.1">, </span><em class="italic"><span class="koboSpan" id="kobo.20.1">Using React Query for Server-Side - Driven State Management</span></em></li>
</ul>
</div>
<div>
<div id="_idContainer029">
</div>
</div>
</body></html>