- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Working with Animations
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与动画一起工作
- en: Animations are part of every mobile app. Smooth animations can make the difference
    between whether a user feels comfortable using an app or not. Essentially, an
    animation is just the screen rendering again and again, transitioning from one
    state to another.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 动画是每个移动应用的一部分。平滑的动画可以决定用户是否感到舒适地使用应用。实质上，动画只是屏幕反复渲染，从一个状态过渡到另一个状态。
- en: This rendering should happen so quickly that the user doesn’t realize the single
    states of the animation but perceives it as a smooth animation. To take this one
    step further, animations not only transform from state A to state B over time,
    but they also react to user interactions such as scrolling, pressing, or swiping.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这种渲染应该非常快，以至于用户不会意识到动画的单个状态，而是感知到它是一个平滑的动画。更进一步，动画不仅随时间从状态 A 变换到状态 B，而且还会对用户的交互做出反应，如滚动、按下或滑动。
- en: Most devices have a screen frame rate of 60 **frames per second** (**fps**),
    and modern devices already have 120 fps (at the time of writing, React Native
    only supports 60 fps, which you can learn about on GitHub at [bit.ly/prn-rn-fps](http://bit.ly/prn-rn-fps)).
    This means that when running an animation, the screen has to be re-rendered at
    60 fps.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数设备的屏幕帧率为 60 **帧/秒**（**fps**），而现代设备已经达到 120 fps（截至编写本文时，React Native 仅支持 60
    fps，你可以在 GitHub 上了解相关信息：[bit.ly/prn-rn-fps](http://bit.ly/prn-rn-fps))。这意味着当运行动画时，屏幕必须以
    60 fps 的速度重新渲染。
- en: This is quite challenging because calculating complex animations and re-rendering
    the screen are some of the most compute-intense operations. Especially on low-end
    devices, the computing of the animation can become too slow, and the screen refresh
    rate drops below 60/120 fps. This then makes the animation and the app feel sluggish
    and slow.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当具有挑战性，因为计算复杂的动画和重新渲染屏幕是一些计算密集型操作。特别是在低端设备上，动画的计算可能会变得太慢，屏幕刷新率低于 60/120 fps。这会使动画和应用程序感觉迟钝和缓慢。
- en: 'Essentially, you can group animations into two different types:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，你可以将动画分为两种不同类型：
- en: '**On-screen animations**: These animations only apply to a part of the screen.
    There are a lot of different use cases for this type of animation such as grabbing
    user attention, giving touch feedback, showing indications of progress or loading,
    or improving the scrolling experience.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**屏幕动画**：这类动画仅适用于屏幕的一部分。这种类型的动画有很多不同的用途，例如吸引用户注意、提供触摸反馈、显示进度或加载指示，或者改善滚动体验。'
- en: '**Full-screen animations**: These animations transition the whole screen. Most
    of the time, this type of animation is used to navigate to another screen.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全屏动画**：这类动画过渡整个屏幕。大多数情况下，这种类型的动画用于导航到另一个屏幕。'
- en: Since full-screen animations are handled internally by all popular navigation
    libraries, this chapter will focus on on-screen animations. Full-screen animations
    have been covered in the *Navigating in React Native apps* section of [*Chapter
    4*](B16694_04.xhtml#_idTextAnchor079)*, Styling, Storage, and Navigation, Section
    Navigation*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于全屏动画由所有流行的导航库内部处理，因此本章将重点介绍屏幕动画。全屏动画已在 [*第 4 章*](B16694_04.xhtml#_idTextAnchor079)*，样式、存储和导航，导航部分*
    中介绍。
- en: There are multiple ways to achieve smooth animations in React Native. Depending
    on the type of project and animations you want to build, you can choose from a
    wide range of solutions, each with its own advantages and disadvantages. We will
    discuss the best and most widely used solutions in this chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React Native 中实现平滑动画有多种方法。根据项目类型和想要构建的动画类型，你可以从众多解决方案中选择，每种方案都有其自身的优缺点。在本章中，我们将讨论最佳和最广泛使用的解决方案。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding the architectural challenge of animations in React Native
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 React Native 中动画的架构挑战
- en: Using the internal React Native Animated API
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 React Native 内置的 Animated API
- en: Creating simple animations with `react-native-animatable`
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `react-native-animatable` 创建简单动画
- en: Exploring Reanimated 2 – the most complete animation framework for React Native
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 Reanimated 2 – React Native 最完整的动画框架
- en: Using Lottie animations in React Native
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 React Native 中使用 Lottie 动画
- en: Info
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: There have been some interesting developments about using the Skia rendering
    engine (which powers Chrome, Firefox, Android, and Flutter) to render animations
    in React Native, but at the time of writing, this approach is not production ready.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用 Skia 渲染引擎（它为 Chrome、Firefox、Android 和 Flutter 提供动力）在 React Native 中渲染动画的一些有趣的发展，但在撰写本文时，这种方法尚未准备好投入生产。
- en: Technical requirements
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To be able to run the code in this chapter, you have to set up the following
    things:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本章中的代码，您必须设置以下内容：
- en: A working React Native environment ([bit.ly/prn-setup-rn](http://bit.ly/prn-setup-rn)
    – React Native CLI Quickstart)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可工作的 React Native 环境 ([bit.ly/prn-setup-rn](http://bit.ly/prn-setup-rn) –
    React Native CLI 快速入门)
- en: An iOS/Android simulator or a real device (a real device is preferred)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 iOS/Android 模拟器或真实设备（真实设备更受欢迎）
- en: Understanding the architectural challenge of animations in React Native
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 React Native 中动画的架构挑战
- en: 'The current architecture of React Native is suboptimal when it comes to animations.
    Think of an animation that scales or moves a title image based on the vertical
    scroll value of a `ScrollView`; this animation has to be calculated based on the
    scroll value of the `ScrollView` and immediately re-render the image. The following
    diagram shows what would happen when using the plain React Native architecture:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到动画时，React Native 的当前架构并不理想。想象一下，一个基于 `ScrollView` 垂直滚动值来缩放或移动标题图片的动画；这个动画必须基于
    `ScrollView` 的滚动值进行计算，并立即重新渲染图片。以下图表显示了使用纯 React Native 架构时会发生什么：
- en: '![Figure 6.1 – The React Native architecture while animating based on scroll
    values'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.1 – 基于滚动值进行动画时的 React Native 架构'
- en: '](img/B16694_06_01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16694_06_01.jpg](img/B16694_06_01.jpg)'
- en: Figure 6.1 – The React Native architecture while animating based on scroll values
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 基于滚动值进行动画时的 React Native 架构
- en: Here, you can see the general React Native architecture. The JavaScript thread
    is where you write your code. Every command will be serialized and sent via the
    bridge to the native thread. In this thread, the command is deserialized and executed.
    The same happens with the user input, but it occurs the other way around.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到一般的 React Native 架构。JavaScript 线程是您编写代码的地方。每个命令都将序列化并通过桥接发送到原生线程。在这个线程中，命令被反序列化并执行。同样，用户输入也是如此，但方向相反。
- en: For our animation, this means that the scroll value would have to be serialized,
    sent via the bridge, deserialized, transferred via a complex calculation to an
    animation value, serialized, transferred back via the bridge, deserialized, and
    then rendered. This whole process has to be done every 16 milliseconds (or 60
    times a second).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的动画来说，这意味着滚动值必须序列化，通过桥接发送，反序列化，通过复杂的计算转换为动画值，序列化，通过桥接返回，反序列化，然后渲染。整个过程必须在每
    16 毫秒（或每秒 60 次）内完成。
- en: 'This round-trip leads to multiple problems:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这种往返会导致多个问题：
- en: The serialization/deserialization process consumes unnecessary compute power
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列化/反序列化过程消耗了不必要的计算能力
- en: In most cases, the calculation in JavaScript is slower than in native code
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大多数情况下，JavaScript 中的计算速度比原生代码慢
- en: The calculation can block the JavaScript thread and make the app unresponsive
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算可能会阻塞 JavaScript 线程，使应用无响应
- en: The round-trip can lead to frame drops and make the animation look sluggish
    and slow
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种往返过程可能导致帧率下降，使动画看起来迟缓且缓慢
- en: Because of these problems, it is not a good idea to write animations in your
    own plain React Native code (for example, by setting a state in a loop). Fortunately,
    there are multiple production-ready solutions to avoid these problems and achieve
    high-quality animations.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些问题，不建议在您自己的纯 React Native 代码中编写动画（例如，通过在循环中设置状态）。幸运的是，有多个现成的解决方案可以避免这些问题，并实现高质量的动画。
- en: In the following sections, we will have a look at four different solutions.
    Every solution has advantages and disadvantages, and which solution should be
    preferred depends on the project and the use case. Let’s start with the built-in
    Animated API.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将探讨四种不同的解决方案。每个解决方案都有其优缺点，而应该选择哪种解决方案则取决于项目和用例。让我们从内置的 Animated API
    开始。
- en: Using the internal Animated API of React Native
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 React Native 的内部动画 API
- en: React Native comes with a built-in Animated API. This API is quite powerful,
    and you can achieve a lot of different animation goals with it. In this section,
    we will have a brief look at how it works and what advantages and limitations
    the internal Animated API has.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: React Native自带内置的Animated API。这个API非常强大，你可以用它实现许多不同的动画目标。在本节中，我们将简要了解它是如何工作的，以及内部Animated
    API的优势和局限性。
- en: For a complete tutorial, please have a look at the official documentation at
    [bit.ly/prn-animated-api](http://bit.ly/prn-animated-api).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取完整的教程，请查看官方文档，链接为[bit.ly/prn-animated-api](http://bit.ly/prn-animated-api)。
- en: To understand how the Animated API works, let’s start with a simple example.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解Animated API的工作原理，让我们从一个简单的例子开始。
- en: Starting with a simple example
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从一个简单的例子开始
- en: 'The following code implements a simple fade-in animation, which makes a view
    appear over the duration of 2 seconds:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码实现了一个简单的淡入动画，使视图在2秒内出现：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Animated API is based on animated values. These values are changed over
    time and are used as part of the application styling. In this example, we initialize
    `opacityValue` as an `Animated.Value` component with the initial value of `0`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 动画API基于动画值。这些值随时间变化，并作为应用程序样式的组成部分使用。在这个例子中，我们将`opacityValue`初始化为一个`Animated.Value`组件，其初始值为`0`。
- en: As you can see, the JSX code contains an `Animated.View` component whose style
    uses `opacityValue` as the opacity property. When running this code, the `Animated.View`
    component is completely hidden at the beginning; this is because the opacity is
    set to `0`. When pressing the `showView` is called, which starts an `Animated.timing`
    function.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，JSX代码包含一个`Animated.View`组件，其样式使用`opacityValue`作为透明度属性。当运行此代码时，`Animated.View`组件最初是完全隐藏的；这是因为透明度被设置为`0`。当调用`showView`时，它启动一个`Animated.timing`函数。
- en: This `Animated.timing` function expects an `Animated.Value` component as the
    first property and a config object as the second parameter. The `Animated.Value`
    component is the value that should be changed during the animation. With the config
    object, you can define the general conditions of the animation.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Animated.timing`函数期望一个`Animated.Value`组件作为第一个属性，一个配置对象作为第二个参数。`Animated.Value`组件是动画过程中应该改变的价值。通过配置对象，你可以定义动画的一般条件。
- en: In this example, we want to change the `Animated.Value` component to 1 over
    the duration of 2 seconds (2,000 ms). Then, the `Animated.timing` function calculates
    the different states of the animation and takes care of the rendering of the `Animated.View`
    component.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们想在2秒（2,000毫秒）内将`Animated.Value`组件的值从0变为1。然后，`Animated.timing`函数计算动画的不同状态，并负责渲染`Animated.View`组件。
- en: Good to know
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 值得了解
- en: Essentially, you can animate every part of your UI. The Animated API exports
    some components directly, such as `Animated.View`, `Animated.Image`, `Animated.ScrollView`,
    `Animated.Text`, and `Animated.FlatList`. But you can animate any component by
    using `Animated.createAnimatedComponent()`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你可以对UI的任何部分进行动画处理。Animated API直接导出了一些组件，例如`Animated.View`、`Animated.Image`、`Animated.ScrollView`、`Animated.Text`和`Animated.FlatList`。但你可以通过使用`Animated.createAnimatedComponent()`来对任何组件进行动画处理。
- en: While the Animated API does not completely solve the problem of the React Native
    architecture, it is an improvement over just setting the state again and again
    and again, as it greatly reduces the payload that has to be transferred from the
    JavaScript thread to the native thread, but this transfer has to be done every
    frame. To prevent this transfer in every frame, you have to use the native driver,
    as shown in the following subsection.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Animated API并没有完全解决React Native架构的问题，但它比反复设置状态要好，因为它大大减少了从JavaScript线程传输到原生线程的负载，但这种传输必须每帧进行。为了防止每帧都进行这种传输，你必须使用原生驱动程序，如下面的子节所示。
- en: Using the native driver
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用原生驱动程序
- en: When configuring the animation with the config object, you can set a property
    called `useNativeDriver`. This is very important and should be done whenever possible.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用配置对象配置动画时，你可以设置一个名为`useNativeDriver`的属性。这非常重要，并且尽可能应该这样做。
- en: 'When using the native driver with `useNativeDriver: true`, React Native sends
    everything to the native thread before starting the animation. This means that
    the animation runs completely on the native thread, which guarantees a smooth-running
    animation and no frame drops.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '当使用`useNativeDriver: true`的原生驱动程序时，React Native在开始动画之前将所有内容发送到原生线程。这意味着动画完全在原生线程上运行，这保证了动画的流畅运行和没有帧丢失。'
- en: Unfortunately, the native driver is currently limited to non-layout properties.
    So, things such as transform and opacity can be used in an animation with the
    native driver, whereas all the Flexbox and position properties, such as `height`,
    `width`, `top`, or `left`, can’t be used.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，原生驱动程序目前仅限于非布局属性。因此，如变换和透明度等属性可以使用原生驱动程序进行动画处理，而所有 Flexbox 和位置属性，如 `height`、`width`、`top`
    或 `left`，则不能使用。
- en: Interpolate animated values
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插值动画值
- en: 'In some cases, you don’t want to use the `Animated.Value` component directly.
    This is where interpolation comes into play. Interpolation is a simple mapping
    of input and output ranges. In the following code example, you can see an interpolation,
    which adds a position change to the simple example from before:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你不想直接使用 `Animated.Value` 组件。这就是插值发挥作用的地方。插值是输入和输出范围的简单映射。在下面的代码示例中，你可以看到一个插值，它向之前的简单示例添加了一个位置变化：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this code example, we added a transform `translateY` property to the `style`
    object. This property transforms the vertical position of an object. We don’t
    set a fixed value, nor do we bind `opacityValue` directly.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例中，我们向 `style` 对象中添加了一个 `translateY` 变换属性。这个属性改变了一个对象的垂直位置。我们既没有设置一个固定值，也没有直接绑定
    `opacityValue`。
- en: We use an interpolate function with a defined `inputRange` value of `[0,1]`
    and a defined `outputRange` value of `[50,0]`. Essentially, this means that the
    `translateY` value will be `50` when `opacityValue` (which is our `AnimatedValue`)
    is `0` and will be `0` when `opacityValue` is `1`. This results in our `AnimatedView`
    moving up `50px` to its original position while fading in.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个具有定义的 `inputRange` 值 `[0,1]` 和定义的 `outputRange` 值 `[50,0]` 的插值函数。本质上，这意味着当
    `opacityValue`（我们的 `AnimatedValue`）为 `0` 时，`translateY` 值将是 `50`，而当 `opacityValue`
    为 `1` 时，`translateY` 值将是 `0`。这导致我们的 `AnimatedView` 在淡入的同时向上移动 `50px` 到其原始位置。
- en: Tip
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Try to use interpolation to reduce the number of animated values you have to
    use in your application. Most of the time, you can use one animated value and
    just interpolate on it, even in complex animations.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量使用插值来减少你需要在应用程序中使用的动画值数量。大多数情况下，你可以使用一个动画值，并在其上进行插值，即使在复杂的动画中也是如此。
- en: The Animated API interpolate function is quite powerful. You can have multiple
    values to define the range, extrapolate or clamp beyond the ranges, or specify
    the easing function of the animation.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Animated API 的插值函数非常强大。你可以有多个值来定义范围，超出范围外推或夹紧，或指定动画的缓动函数。
- en: Getting to know the advanced options of the Animated API
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解 Animated API 的高级选项
- en: 'The Animated API brings a lot of different options, which give you the possibility
    to create almost every animation you can imagine:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Animated API 带来了很多不同的选项，这让你几乎可以创建你所能想象的任何动画：
- en: You can do mathematical operations on animated values such as `add()`, `subtract()`,
    `divide()`, `multiply()`, `modulo()`, and more.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以对动画值执行数学运算，如 `add()`、`subtract()`、`divide()`、`multiply()`、`modulo()` 等。
- en: You can combine animations sequentially using `Animated.sequence()`, or combine
    them at the same time using `Animated.parallel()` (you can even combine these
    options, too).
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 `Animated.sequence()` 顺序组合动画，或者使用 `Animated.parallel()` 同时组合它们（你甚至可以将这些选项结合起来）。
- en: You can also work with delayed animations with `Animated.delay()` or loop animations
    with `Animated.loop()`.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你还可以使用 `Animated.delay()` 进行延迟动画或使用 `Animated.loop()` 进行循环动画。
- en: There are also other options to change an `Animated.Value` component aside from
    `Animated.timing()`. One of them is to use `Animated.event()` to bind the scroll
    value of a `ScrollView` to an `AnimatedValue`.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了 `Animated.timing()` 之外，还有其他选项可以改变 `Animated.Value` 组件。其中之一是使用 `Animated.event()`
    将 `ScrollView` 的滚动值绑定到 `AnimatedValue`。
- en: 'The following example is very similar to the example in the *Understanding
    the architectural challenge of animations in React Native* section of this chapter.
    The code shows you how to use a scroll value as the driver of an animation:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例与本章 *理解 React Native 中动画的架构挑战* 部分的示例非常相似。代码展示了如何使用滚动值作为动画的驱动程序：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this example, the native scroll event of the `ScrollView` is connected directly
    to the `Animated.Value` component. With the `useNativeDriver: true` property,
    the native driver is used; this means that the animation, which is driven by the
    scroll value, runs completely on the native thread.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个例子中，`ScrollView` 的原生滚动事件直接连接到 `Animated.Value` 组件。使用 `useNativeDriver: true`
    属性，使用了原生驱动程序；这意味着动画，由滚动值驱动，完全在原生线程上运行。'
- en: 'The preceding example contains two interpolations of the scroll value: the
    first one scales the image when the `ScrollView` has been over-scrolled (which
    means the `ScrollView` returns negative scroll values), while the second one moves
    the image up while scrolling.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子包含了两个滚动值的插值：第一个在`ScrollView`被过度滚动时（这意味着`ScrollView`返回负滚动值）缩放图像，而第二个在滚动时将图像向上移动。
- en: Again, due to the use of the native driver, all this interpolation is done on
    the native thread. This makes the Animated API very performant in this use case.
    You can read more about running animations based on user gestures in [*Chapter
    7*](B16694_07.xhtml#_idTextAnchor236)*, Handling Gestures in React Native*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，由于使用了原生驱动程序，所有这些插值都是在原生线程上完成的。这使得Animated API在这个用例中非常高效。你可以阅读更多关于基于用户手势运行动画的信息，请参阅[*第7章*](B16694_07.xhtml#_idTextAnchor236)*，React
    Native中的手势处理*。
- en: The Animated API also provides different easing methods alongside complex spring
    models. For more detailed information, please take a look at the official documentation
    at [bit.ly/prn-animated-api](http://bit.ly/prn-animated-api).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Animated API还提供了不同的缓动方法和复杂的弹簧模型。更多详细信息，请参阅官方文档[bit.ly/prn-animated-api](http://bit.ly/prn-animated-api)。
- en: As you can see, the Animated API is really powerful, and you can achieve nearly
    every animation goal with it. So, why are there even other solutions on the market
    when this very good animation library is built in? Well, the Animated API is far
    from perfect for every use case.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Animated API确实非常强大，你可以用它实现几乎每一个动画目标。那么，为什么市场上还有其他解决方案，当这个非常好的动画库已经内置时？嗯，对于每一个用例，Animated
    API都远非完美。
- en: Understanding the pros and cons of the Animated API
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解Animated API的优缺点
- en: 'The internal React Native Animated API is a very good solution for simple to
    mid-complexity animations. These are the most important pros of the Animated API:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 内部React Native Animated API是一个非常好的简单到中等复杂度动画的解决方案。以下是Animated API最重要的优点：
- en: '**Powerful API**: You can build nearly every animation.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强大的API**: 你可以构建几乎所有的动画。'
- en: '**No external library needed**: You don’t have to add any dependencies to your
    project to use the Animated API. This means no additional maintenance effort or
    larger bundle size.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无需外部库**: 使用Animated API时，你不需要向你的项目添加任何依赖。这意味着无需额外的维护工作或更大的包大小。'
- en: '**Smooth animations with the native driver**: When using the native driver,
    you can be sure that your animation runs at 60 fps.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用原生驱动实现平滑动画**: 当使用原生驱动程序时，你可以确信你的动画以60 fps运行。'
- en: 'There are also some cons of the Animated API, which you have to keep in mind
    when choosing the best animation solution for your project:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，Animated API也有一些缺点，你在选择最适合你项目的动画解决方案时必须牢记：
- en: '**Complex animations become quite confusing**: Due to the structure of the
    Animated API, animations with lots of elements or very high complexity can get
    very confusing, and the code can become very hard to read and understand.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂的动画变得相当混乱**: 由于Animated API的结构，包含大量元素或非常复杂的动画可能会变得非常混乱，代码也可能变得难以阅读和理解。'
- en: '**The native driver does not support all style properties**: When using the
    Animated API, you should definitely use the native driver. Since this driver does
    not support position or Flexbox properties, the Animated API is, essentially,
    limited to non-layout properties.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原生驱动程序不支持所有样式属性**: 当使用Animated API时，你绝对应该使用原生驱动程序。由于这个驱动程序不支持位置或Flexbox属性，因此本质上，Animated
    API仅限于非布局属性。'
- en: '`Animated.Value` components have to be used.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须使用`Animated.Value`组件。
- en: 'All in all, I would recommend the Animated API for small to medium complexity
    animations, when you don’t already have other animation libraries in your project.
    However, let’s look at another option: `react-native-animatable`.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，我会推荐Animated API用于小型到中型复杂度的动画，当你项目中还没有其他动画库时。然而，让我们看看另一个选项：`react-native-animatable`。
- en: Creating simple animations with react-native-animatable
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用react-native-animatable创建简单的动画
- en: There are a lot of animations that are reused in nearly every app. This is what
    `react-native-animatable` is all about. This library is built on top of the internal
    React Native Animated API and provides a very simple declarative and imperative
    API to use simple, predefined animations.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多动画在几乎每个应用中都会被重复使用。这就是`react-native-animatable`的宗旨。这个库建立在内部React Native Animated
    API之上，并提供了一个非常简单且声明性和命令性的API来使用简单、预定义的动画。
- en: Starting with a simple example
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从一个简单的例子开始
- en: 'The following code example describes a simple fade-in animation with `react-native-animatable`
    using the declarative method, along with a simple fade-out animation with `react-native-animatable`
    using the imperative method:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例描述了使用声明式方法通过`react-native-animatable`实现的简单淡入动画，以及使用命令式方法通过`react-native-animatable`实现的简单淡出动画：
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, `Animatable.View` is given one of the predefined `Animatable`
    animations as the animation property, and a duration that defines how long the
    animation runs. That is all you have to do to have an entrance animation.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`Animatable.View`被赋予了一个预定义的`Animatable`动画作为动画属性，以及一个定义动画运行多长时间的持续时间。这就是实现入场动画所需的所有操作。
- en: As stated before, Animatable also supports imperative usage, which means that
    you can call Animatable functions on Animatable components. In this example, `this.view`
    contains a reference to `Animatable.View`, which makes it possible to call Animatable
    functions on it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Animatable还支持命令式使用，这意味着您可以在Animatable组件上调用Animatable函数。在这个示例中，`this.view`包含对`Animatable.View`的引用，这使得可以在其上调用Animatable函数。
- en: This is done when pressing the `Pressable`. Here, `hideView` is called, which
    then calls the predefined `fadeOutDown` Animatable function, which makes the view
    disappear over 2 seconds (2,000 ms).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在按下`Pressable`时完成的。在这里，调用`hideView`，然后调用预定义的`fadeOutDown` Animatable函数，使视图在2秒（2,000毫秒）内消失。
- en: Using the native driver
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用原生驱动
- en: As we learned in the *Using the internal Animated API of React Native* section,
    using the native driver is crucial for achieving smooth animations. Since `react-native-animatable`
    is based on the Animated API, you should also configure your animations to use
    the native driver.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在*使用React Native的内部动画API*部分所学，使用原生驱动对于实现流畅的动画至关重要。由于`react-native-animatable`基于动画API，因此您也应该配置动画以使用原生驱动。
- en: With `react-native-animatable`, this is done by adding `useNativeDriver={true}`
    as a property to the component you run the animation on.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`react-native-animatable`，这是通过在运行动画的组件上添加`useNativeDriver={true}`属性来完成的。
- en: Important note
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Please check whether the predefined animation you want to use supports the native
    driver before using it with the native driver.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用原生驱动之前，请检查您想要使用的预定义动画是否支持原生驱动。
- en: The `react-native-animatable` library is not limited to predefined animations.
    It also supports defining custom animations with a very simple API. Let’s take
    a look at how this is done.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`react-native-animatable`库不仅限于预定义的动画。它还支持使用非常简单的API定义自定义动画。让我们看看这是如何实现的。'
- en: Working with custom animations
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用自定义动画
- en: 'The following example shows you how to create a simple fade-in and move-up
    animation, just as we did in the previous section:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何创建一个简单的淡入和上升动画，就像我们在上一节中所做的那样：
- en: '[PRE4]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The custom animations of `react-native-animatable` map the styles to the keyframes.
    In this example, we start with the first keyframe (`0`), and set the `opacity`
    value to `0` and the `translateY` value to `50`. With the last keyframe (`1`),
    the `opacity` value should be `1` and the `translateY` value should be `0`. Now
    this animation can be used as the animation property value of any Animatable component
    instead of the predefined string values.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`react-native-animatable`的自定义动画将样式映射到关键帧。在这个示例中，我们从第一个关键帧（`0`）开始，将`opacity`值设置为`0`，将`translateY`值设置为`50`。在最后一个关键帧（`1`）中，`opacity`值应该是`1`，`translateY`值应该是`0`。现在这个动画可以作为任何Animatable组件的动画属性值使用，而不是预定义的字符串值。'
- en: Understanding the pros and cons of react-native-animatable
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解react-native-animatable的优缺点
- en: 'Built on the React Native Animated API, all pros and cons of the Animated API
    also apply to `react-native-animatable`. In addition to that, the following pros
    are worth mentioning:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 基于React Native动画API构建，动画API的所有优缺点也适用于`react-native-animatable`。除此之外，以下优点也值得提及：
- en: '`react-native-animatable` is by far the easiest library to create and use high-quality
    animations.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到目前为止，`react-native-animatable`是创建和使用高质量动画最容易的库。
- en: '**Declarative approach**: The declarative approach creates code that is easy
    to read and understand.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声明式方法**：声明式方法创建的代码易于阅读和理解。'
- en: 'Since `react-native-animatable` is a library built on top of the Animated API,
    this additional layer also brings some cons:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`react-native-animatable`是一个基于动画API构建的库，这个额外的层也带来了一些缺点：
- en: '`react-native-animatable` as an additional dependency to your project. This
    is especially important because, at the time of writing, the project wasn’t maintained
    very actively. This means that if anything changes in the underlying Animated
    API, it can prevent you from upgrading your React Native project.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `react-native-animatable` 作为项目的一个额外依赖项。这尤其重要，因为在编写本文时，该项目并没有得到非常积极的维护。这意味着，如果底层
    Animated API 发生任何变化，它可能会阻止你升级你的 React Native 项目。
- en: '**Limited API**: The predefined animations and the possibilities to create
    custom animations are limited. If you want to create complex animations, you should
    use another option.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**受限的 API**：预定义的动画和创建自定义动画的可能性有限。如果你想创建复杂的动画，你应该使用其他选项。'
- en: Essentially, `react-native-animatable` is a simple library on top of the React
    Native Animated API. It simplifies working with animations and works best with
    simple, predefined animations. If you need these simple or standard animations
    and you are very limited in time to create your animations, `react-native-animatable`
    is the best option for you.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`react-native-animatable` 是建立在 React Native Animated API 之上的一个简单库。它简化了动画的工作，并且与简单、预定义的动画配合得最好。如果你需要这些简单或标准的动画，而你又非常有限的时间来创建动画，`react-native-animatable`
    是你的最佳选择。
- en: If you’d like to create more complex animations, please take a look at the following
    section.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要创建更复杂的动画，请参阅以下部分。
- en: Exploring Reanimated 2 – the most complete animation solution for React Native
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Reanimated 2 – React Native 最完整的动画解决方案
- en: Reanimated is by far the most complete and mature animation solution for React
    Native. It was an improved reimplementation of the React Native Animated API in
    the first place, but with version 2, the API changed and the library’s capabilities
    increased greatly.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Reanimated 是迄今为止 React Native 最完整、最成熟的动画解决方案。它最初是对 React Native Animated API
    的改进重实现，但随着版本 2 的发布，API 发生了变化，库的功能得到了极大的增强。
- en: 'This section covers the following topics:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖了以下主题：
- en: Getting to know the Reanimated API with a simple example
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过一个简单的示例了解 Reanimated API
- en: Understanding the architecture of Reanimated 2
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Reanimated 2 的架构
- en: Understanding the pros and cons of Reanimated
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Reanimated 的优缺点
- en: Let’s get started.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Getting to know the Reanimated API with a simple example
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过一个简单的示例了解 Reanimated API
- en: Essentially, the core concept of Reanimated 2 is as simple as the Animated API.
    There are animation values that can be changed, and these animation values power
    the animations.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，Reanimated 2 的核心概念与 Animated API 一样简单。有可以更改的动画值，这些动画值驱动着动画。
- en: 'The following code shows an animation that scales in a `View` component:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了一个在 `View` 组件中缩放的动画：
- en: '[PRE5]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When looking at this code, we realize three things:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看这段代码时，我们意识到以下几点：
- en: The structure is quite similar to the Animated API. There is a `sharedValue`,
    which is `Animated.Value` in `Animated`, and a `withTiming` function, which is
    the equivalent to `Animated.timing` in `Animated`. The style object for the `Animated.View`
    component is created using a `useAnimatedStyle` function and is then used as a
    style property.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构与 Animated API 非常相似。有一个 `sharedValue`，它是 `Animated` 中的 `Animated.Value`，还有一个
    `withTiming` 函数，它是 `Animated.timing` 在 `Animated` 中的等效函数。`Animated.View` 组件的样式对象是通过
    `useAnimatedStyle` 函数创建的，然后用作样式属性。
- en: There is no `useNativeDriver` property.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有使用 `useNativeDriver` 属性。
- en: We are changing width and height values in the animation, so the layout properties
    get changed, which wasn’t possible with the React Native internal Animated API.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在动画中更改宽度和高度值，因此布局属性会发生变化，这是使用 React Native 内部 Animated API 所不可能的。
- en: One of the cool things about Reanimated is that you don’t have to care about
    the native driver. Every animation with Reanimated is processed on the UI thread.
    Another cool thing is that every style property can be used.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Reanimated 的一个酷特点是，你不必关心原生驱动程序。使用 Reanimated 的每个动画都在 UI 线程上处理。另一个酷特点是，每个样式属性都可以使用。
- en: If you compare this to the limitations of the Animated API, you immediately
    see how much more powerful Reanimated is.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将此与 Animated API 的限制进行比较，你会立即看到 Reanimated 有多么强大。
- en: To understand how this is done, let’s take a look at the Reanimated architecture.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这是如何实现的，让我们看看 Reanimated 的架构。
- en: Understanding the architecture of Reanimated 2
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 Reanimated 2 的架构
- en: Reanimated 2 is based on animation worklets. In this context, a **worklet**
    is a JavaScript function that runs on the UI thread. Reanimated 2 spawns a second,
    very minimalistic, JavaScript environment on the UI thread that handles these
    animation worklets.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Reanimated 2 基于 animation worklet。在这种情况下，**worklet** 是在 UI 线程上运行的 JavaScript
    函数。Reanimated 2 在 UI 线程上创建了一个第二、非常简约的 JavaScript 环境，用于处理这些动画 worklet。
- en: This means it runs completely independently from the React Native JavaScript
    thread and the React Native bridge, which guarantees awesome performance even
    for complex animations. This worklet context uses the new React Native architecture.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着它完全独立于 React Native JavaScript 线程和 React Native 桥接运行，这保证了即使是复杂的动画也能获得出色的性能。此
    worklet 线程使用新的 React Native 架构。
- en: Let’s start with gaining an understanding of how to use worklets.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从了解如何使用 worklet 开始。
- en: Starting to work with worklets
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开始使用 worklet
- en: 'Let’s take a look at the example from the *Understanding the architectural
    challenge of animations in React Native* section of this chapter. We have an animation
    that resizes or moves a title image based on the *Y* scroll value of a `ScrollView`.
    The following figure shows what’s happening when implementing this example with
    Reanimated 2:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看本章“理解 React Native 中动画的架构挑战”部分的示例。我们有一个根据 `ScrollView` 的 *Y* 滚动值调整标题图像大小或移动的动画。以下图显示了使用
    Reanimated 2 实现此示例时发生的情况：
- en: '![Figure 6.2 – Animation based on the scroll value in Reanimated 2'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.2 – 基于 Reanimated 2 中滚动值的动画'
- en: '](img/B16694_06_02.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.2 – 基于 Reanimated 2 中滚动值的动画](img/B16694_06_02.jpg)'
- en: Figure 6.2 – Animation based on the scroll value in Reanimated 2
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – 基于 Reanimated 2 中滚动值的动画
- en: In Reanimated 2, the animation is created as a worklet on the JavaScript thread.
    But the whole animation worklet is executed in the worklet context on the UI thread.
    So, every time a new scroll event is received, it doesn’t have to cross the bridge;
    instead, it’s processed directly in the worklet context, and the new animation
    state is passed back to the UI thread for rendering.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Reanimated 2 中，动画作为 JavaScript 线程上的 worklet 创建。但整个动画 worklet 都在 UI 线程上的 worklet
    线程中执行。因此，每次接收到新的滚动事件时，它不必跨越桥梁；相反，它直接在工作线程中处理，并将新的动画状态传递回 UI 线程进行渲染。
- en: 'To achieve this kind of architecture, Reanimated 2 comes with its own Babel
    plugin. This Babel plugin extracts every function that is annotated as `worklet`
    from the react-native code and makes it runnable in this separate worklet context
    on the UI thread. The following code example shows you how to annotate a function
    as a worklet:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这种架构，Reanimated 2 提供了自己的 Babel 插件。此 Babel 插件从 react-native 代码中提取所有标记为 `worklet`
    的函数，并使其在 UI 线程上的单独 worklet 线程中可运行。以下代码示例显示了如何将函数标记为 worklet：
- en: '[PRE6]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is a simple JavaScript function that contains the `worklet` annotation
    in line 2\. Based on this annotation, the Reanimated 2 Babel plugin knows that
    it has to process this function.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的 JavaScript 函数，在第 2 行包含 `worklet` 注解。基于这个注解，Reanimated 2 Babel 插件知道它必须处理这个函数。
- en: Now, this can be run as a standard function on the JavaScript thread, but it
    can also be run as a worklet on the UI thread, depending on how it is called.
    If the function is called like a normal function in the JavaScript code, it runs
    on the JavaScript thread, and if it is called using the Reanimated 2 `runOnUI`
    function, it runs asynchronously on the UI thread.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这可以作为 JavaScript 线程上的标准函数运行，也可以根据调用方式作为 UI 线程上的 worklet 运行。如果函数像 JavaScript
    代码中的正常函数一样被调用，它就在 JavaScript 线程上运行；如果使用 Reanimated 2 的 `runOnUI` 函数调用，它就在 UI 线程上异步运行。
- en: Of course, it is possible to pass parameters to these worklet functions, no
    matter where it runs.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，无论在哪里运行，都可以向这些 worklet 函数传递参数。
- en: Understanding the connection between the JavaScript thread and the worklet context
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解 JavaScript 线程和工作线程之间的联系
- en: 'Understanding this connection is crucial to prevent a lot of errors from happening.
    Essentially, the JavaScript thread and the worklet context run in completely different
    environments. This means it is not possible to simply access everything from the
    JavaScript thread while being in a worklet. The following connections are possible
    when it comes to worklets:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这种联系对于防止发生许多错误至关重要。本质上，JavaScript 线程和工作线程在完全不同的环境中运行。这意味着在 worklet 中，无法简单地从
    JavaScript 线程访问所有内容。当涉及到 worklet 时，以下是一些可能的连接：
- en: '`worklet` and is called with `runOnUI`. This runs the function in the worklet
    context on the UI thread. Every parameter that is passed is copied to the worklet
    context on the UI thread.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`worklet`并使用`runOnUI`调用。这将在UI线程上的Worklet上下文中运行函数。传递的每个参数都会复制到UI线程上的Worklet上下文中。'
- en: '**Worklets can access constants from the JavaScript thread**: Reanimated 2
    processes the worklet code and copies the used constants and their values to the
    worklet context. This means constants can also be used in worklets without having
    to fear performance drops.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Worklets可以访问JavaScript线程上的常量**：Reanimated 2处理Worklet代码，并将使用的常量和它们的值复制到Worklet上下文中。这意味着常量也可以在Worklets中使用，而无需担心性能下降。'
- en: '**Worklets can invoke other worklet functions synchronously**: Worklets can
    call other worklets synchronously because they run in the same environment.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Worklets可以同步调用其他Worklet函数**：Worklets可以同步调用其他Worklet，因为它们在相同的环境中运行。'
- en: '**Worklets can call non-worklet functions asynchronously**: When functions
    on the JavaScript thread are called from within a worklet, this call has to be
    asynchronous because the invoked function runs in another environment.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Worklets可以异步调用非Worklet函数**：当从Worklet内部调用JavaScript线程上的函数时，这个调用必须是异步的，因为被调用的函数在另一个环境中运行。'
- en: For more information on worklets, you can take a look at the worklet part of
    the official documentation at [https://bit.ly/prn-reanimated-worklets](https://bit.ly/prn-reanimated-worklets).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于Worklet的信息，可以查看官方文档中的Worklet部分，链接为[https://bit.ly/prn-reanimated-worklets](https://bit.ly/prn-reanimated-worklets)。
- en: Using shared values
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用共享值
- en: Like in the internal Animated API of React Native, Reanimated 2 works with animation
    values to drive the animation. These animation values are called **Shared Values**
    in Reanimated 2\. They are called Shared Values because they can be accessed from
    both JavaScript environments – the JavaScript thread and the worklet context on
    the UI thread.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在React Native的内部Animated API中一样，Reanimated 2使用动画值来驱动动画。在Reanimated 2中，这些动画值被称为**共享值**。它们被称为共享值，因为可以从JavaScript环境（JavaScript线程和UI线程上的Worklet上下文）中访问。
- en: Since these Shared Values are used to drive animations, and these animations
    run in the worklet context on the UI thread, they are optimized to be updated
    and read from the worklet context. This means reads and writes of Shared Values
    from worklets are synchronous, while reads and writes from the JavaScript thread
    are asynchronous.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些共享值用于驱动动画，而这些动画在UI线程上的Worklet上下文中运行，因此它们被优化为从Worklet上下文中更新和读取。这意味着从Worklet中读取和写入共享值是同步的，而从JavaScript线程中读取和写入是异步的。
- en: You can take a deeper look at Shared Values in the official documentation at
    [https://bit.ly/prn-reanimated-shared-values](https://bit.ly/prn-reanimated-shared-values).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在官方文档中更深入地了解共享值，链接为[https://bit.ly/prn-reanimated-shared-values](https://bit.ly/prn-reanimated-shared-values)。
- en: Working with Reanimated 2 Hooks and functions
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Reanimated 2钩子和函数
- en: When working with Reanimated 2, there is no need to create worklets for most
    use cases. Reanimated 2 provides an excellent set of Hooks and functions that
    can be used to create, run, change, interrupt, and cancel animations. These Hooks
    take care of transferring the executions of the animation to the worklet context
    automatically.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Reanimated 2时，大多数情况下不需要创建Worklet。Reanimated 2提供了一套优秀的钩子和函数，可以用来创建、运行、更改、中断和取消动画。这些钩子会自动处理将动画执行转移到Worklet上下文。
- en: This is what was used in the example at the beginning of this section. In that
    scenario, we created a Shared Value with the `useSharedValue` Hook, connected
    the View’s style with the `useAnimatedStyle` Hook, and started the animation with
    the `withTiming` function.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是本节开头示例中使用的方法。在那个场景中，我们使用`useSharedValue`钩子创建了一个共享值，将视图的样式与`useAnimatedStyle`钩子连接起来，并使用`withTiming`函数开始动画。
- en: 'Of course, you can also handle scroll values with Reanimated 2\. The following
    code example shows you how to connect a `ScrollView` to a Shared Value, to scale
    and move an image with an animation driven by user scrolling:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你也可以使用Reanimated 2处理滚动值。以下代码示例展示了如何将`ScrollView`连接到共享值，通过用户滚动来缩放和移动图像的动画：
- en: '[PRE7]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, the `ScrollView` binds the *Y* scroll value (content offset)
    to the animation value using Reanimated’s `useAnimatedScrollHandler` Hook. This
    animation value is then interpolated with the interpolate function of Reanimated
    2\. This is done inside a `useAnimatedStyle` hook.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`ScrollView` 使用 Reanimated 的 `useAnimatedScrollHandler` 钩子将 *Y* 滚动值（内容偏移量）绑定到动画值。然后，这个动画值通过
    Reanimated 2 的插值函数进行插值。这是在 `useAnimatedStyle` 钩子内部完成的。
- en: This setup makes the animation work, without ever having to send scroll values
    over the bridge to the JavaScript thread. The whole animation runs inside the
    worklet context on the UI thread. This makes the animation extremely performant.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设置使得动画工作，无需将滚动值通过桥接发送到 JavaScript 线程。整个动画在 UI 线程的工作线程中运行。这使得动画性能极高。
- en: Of course, Reanimated 2 offers a wide range of other options. It is possible
    to use spring-based animations, velocity-based animations, delay or repeat animations,
    and run animations in sequence, just to name a few.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Reanimated 2 提供了广泛的其它选项。可以使用基于弹簧的动画、基于速度的动画、延迟或重复动画，以及按顺序运行动画，仅举几例。
- en: Since a complete guide on Reanimated 2 would go beyond the scope of this book,
    please have a look at the official documentation ([https://bit.ly/prn-reanimated-docs](https://bit.ly/prn-reanimated-docs))
    and the API reference ([https://bit.ly/prn-reanimated-api-reference](https://bit.ly/prn-reanimated-api-reference)).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 由于完整的 Reanimated 2 指南超出了本书的范围，请参阅官方文档（[https://bit.ly/prn-reanimated-docs](https://bit.ly/prn-reanimated-docs)）和
    API 参考（[https://bit.ly/prn-reanimated-api-reference](https://bit.ly/prn-reanimated-api-reference)）。
- en: To complete this section, we will have a look at the pros and cons of Reanimated
    2.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这一部分，我们将探讨 Reanimated 2 的优缺点。
- en: Understanding the pros and cons of Reanimated
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 Reanimated 的优缺点
- en: 'Reanimated 2 is, by far, the most advanced and complete solution for animations
    in React Native. There are a lot of reasons to use Reanimated 2\. Here is a list
    of the most important ones:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，Reanimated 2 是 React Native 中动画最先进和最完整的解决方案。有很多理由使用 Reanimated 2。以下是最重要的几个原因：
- en: '**Easy-to-use API**: The Reanimated 2 API with Hooks and functions is easy
    to learn, read, and understand.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于使用的 API**：带有 Hooks 和函数的 Reanimated 2 API 容易学习、阅读和理解。'
- en: '**Awesome performance out of the box**: Animations with Reanimated 2 run smoothly
    and are performant on all devices out of the box.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**出色的性能**：Reanimated 2 的动画在所有设备上运行流畅且性能出色。'
- en: '**Animation of layout properties**: All style values can be used in animations.
    There is no limitation like in the Animated API.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**布局属性的动画**：所有样式值都可以用于动画。没有像 Animated API 中的限制。'
- en: '**Interrupting, changing, and canceling animations**: Animations with Reanimated
    2 can be interrupted, changed, or canceled while they run, without causing frame
    drops or sluggish behavior.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中断、更改和取消动画**：在 Reanimated 2 中，动画在运行时可以被中断、更改或取消，而不会导致帧率下降或操作缓慢。'
- en: 'Reanimated 2 is a very good library, but before using it, you should have a
    look at the following cons:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Reanimated 2 是一个非常好的库，但在使用它之前，您应该查看以下缺点：
- en: '**Complicated installation**: Since Reanimated 2 deeply intervenes in the architecture
    of React Native, the installation is quite complicated. You have to make some
    changes to the native code and add the Reanimated 2 Babel plugin. This is not
    a big problem because it only has to be done once, but it will take some time.
    This will change when the new architecture, including the new Fabric renderer,
    is out.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂的安装**：由于 Reanimated 2 深度干预 React Native 的架构，安装过程相当复杂。您需要对原生代码进行一些修改，并添加
    Reanimated 2 Babel 插件。这并不是一个大问题，因为它只需要做一次，但会花费一些时间。当新的架构，包括新的 Fabric 渲染器推出时，这将会改变。'
- en: '**Reanimated 2 makes you bundle larger**: While the internal Animated API is
    part of React Native, Reanimated 2 is an external dependency. This means your
    bundle will grow.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Reanimated 2 使您的包更大**：虽然内部 Animated API 是 React Native 的一部分，但 Reanimated
    2 是一个外部依赖项。这意味着您的包将会增大。'
- en: If you have an app with a lot of animations, more complex animations, and/or
    animated layout properties, I would definitely recommend using Reanimated 2\.
    If you only use basic animations, which can be achieved with the internal Animated
    API, you don’t need Reanimated and can stick to the Animated API.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序有很多动画、更复杂的动画以及/或动画布局属性，我肯定会推荐使用 Reanimated 2。如果您只使用基本的动画，这些动画可以通过内部
    Animated API 实现，那么您不需要 Reanimated，可以继续使用 Animated API。
- en: While Reanimated 2, the Animated API, and even `react-native-animatable` have
    a very similar approach, the next library we will get to know works completely
    differently. Let’s take a look at Lottie.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Reanimated 2、Animated API 以及 `react-native-animatable` 都有非常相似的方法，但接下来我们将了解的下一个库工作方式完全不同。让我们来看看
    Lottie。
- en: Using Lottie animations in React Native
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 React Native 中使用 Lottie 动画
- en: 'Lottie is a completely different approach to animations in app and web development.
    It allows you to render and control prebuilt vector animations. The following
    figure shows the process of how a Lottie animation is created and played:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Lottie 是在应用和网页开发中处理动画的完全不同的方法。它允许你渲染和控制预构建的矢量动画。以下图示展示了 Lottie 动画创建和播放的过程：
- en: '![Figure 6.3 – The workflow when animating with Lottie'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.3 – 使用 Lottie 动画时的流程](img/B16694_06_03.jpg)'
- en: '](img/B16694_06_03.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.3 – 使用 Lottie 动画时的流程](img/B16694_06_03.jpg)'
- en: Figure 6.3 – The workflow when animating with Lottie
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – 使用 Lottie 动画时的流程
- en: Essentially, Lottie consists of a player, which in the case of React Native
    is the `lottie-react-native` library. This library expects a JSON file of a Lottie
    animation. This file is created with Adobe After Effects (a professional animation
    software) and exported to JSON with the Bodymovin plugin.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，Lottie 包含一个播放器，在 React Native 的情况下是 `lottie-react-native` 库。这个库期望一个 Lottie
    动画的 JSON 文件。这个文件是用 Adobe After Effects（一款专业的动画软件）创建的，并通过 Bodymovin 插件导出为 JSON
    格式。
- en: This process completely changes the way we work with animations in apps. The
    developer is no longer responsible for creating the animations; they only have
    to include the JSON file. This can save a huge amount of time when working with
    very complex animations.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程完全改变了我们在应用中处理动画的方式。开发者不再负责创建动画；他们只需要包含 JSON 文件。当处理非常复杂的动画时，这可以节省大量的时间。
- en: All of this becomes clearer when looking at a simple Lottie animation.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些内容在查看一个简单的 Lottie 动画时都会变得更加清晰。
- en: Starting with a simple example
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从一个简单的例子开始
- en: 'The following code example shows the implementation of a loading animation
    with Lottie:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例展示了如何使用 Lottie 实现一个加载动画：
- en: '[PRE8]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is all the code that is needed to include a loading animation, no matter
    how complex the animation is. `LottieView` is imported from the `lottie-react-native`
    library and is placed where the animation should occur. The Lottie JSON file is
    passed as source to `LottieView`, which can be styled via the style property like
    a regular React Native view.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 无论动画多么复杂，以下代码就是包含加载动画所需的所有代码。`LottieView` 从 `lottie-react-native` 库中导入，并放置在动画应该发生的位置。Lottie
    JSON 文件作为源传递给 `LottieView`，可以通过样式属性像常规 React Native 视图一样进行样式化。
- en: However, `lottie-react-native` is not just a simple player. It gives you programmatic
    control over the animation. You can start and stop the animation, autoplay it
    when it loads, and loop it so that it starts again after completion. The last
    one is especially useful for loading animations.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`lottie-react-native` 不仅仅是一个简单的播放器。它为你提供了对动画的编程控制。你可以开始和停止动画，在加载时自动播放，并在完成后循环播放。最后一个特性对于加载动画特别有用。
- en: Combining Lottie animations with the React Native Animated API
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 Lottie 动画与 React Native Animated API 结合使用
- en: The best feature of `lottie-react-native` is that it is possible to bind the
    progress of an animation to an `Animated.Value` component of the React Native
    Animated API. This opens up a lot of different use cases such as Lottie animations
    running time or spring-based. You can also use easing or create Lottie animations
    running based on user interaction.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`lottie-react-native` 的最佳特性是它可以将动画的进度绑定到 React Native Animated API 的 `Animated.Value`
    组件。这为许多不同的用例打开了大门，例如基于 Lottie 的动画运行时间或弹簧动画。你还可以使用缓动或根据用户交互创建 Lottie 动画。'
- en: 'The following code example shows you how to create a Lottie animation driven
    by an `Animated.Value` component that is bound to the *Y* scroll value of a React
    Native `ScrollView`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例展示了如何创建一个由 `Animated.Value` 组件驱动的 Lottie 动画，该组件绑定到了 React Native `ScrollView`
    的 *Y* 滚动值：
- en: '[PRE9]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, the *Y* scroll value of the `ScrollView` is bound to an `Animated.Value`
    component in the `onScroll` function of the `ScrollView`. Then, the `Animated.Value`
    component is interpolated to get an `interpolatedProgress` between `0` and `1`.
    This `interpolatedProgess` is passed to `LottieView` as a progress property.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`ScrollView` 的 *Y* 滚动值绑定到了 `onScroll` 函数中的 `Animated.Value` 组件。然后，`Animated.Value`
    组件被插值以获取 `interpolatedProgress`，其值在 `0` 和 `1` 之间。这个 `interpolatedProgress` 作为进度属性传递给了
    `LottieView`。
- en: Lottie also supports animations of the React Native Animated API, that use the
    native driver. This is very important for performance reasons. For more on this,
    please read the *Using the internal Animated API of React Native* section of this
    chapter.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Lottie 还支持使用原生驱动程序的 React Native Animated API 动画。这对于性能来说非常重要。关于这方面的更多信息，请参阅本章的
    *使用 React Native 内部 Animated API* 部分。
- en: Finding or creating Lottie animations
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找或创建 Lottie 动画
- en: 'While Lottie animations are very easy to include for the developer, someone
    has to create the Lottie JSON files that contain the animations. There are three
    ways to get Lottie animation files:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Lottie 动画对开发者来说很容易包含，但有人必须创建包含动画的 Lottie JSON 文件。获取 Lottie 动画文件有三种方法：
- en: '**Find Lottie files on the internet**: There are a lot of talented animation
    artists out there who share their work on the internet. A lot of the files are
    free, but it is also possible to purchase premium animation content. The best
    place to start your search for Lottie animations is [https://lottiefiles.com/](https://lottiefiles.com/).'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在互联网上寻找 Lottie 文件**：有很多有才华的动画艺术家在互联网上分享他们的作品。许多文件是免费的，但也可以购买高级动画内容。开始搜索 Lottie
    动画的最佳地方是 [https://lottiefiles.com/](https://lottiefiles.com/)。'
- en: '**Learn to create animations with After Effects**: There are a lot of good
    beginner tutorials, and even if it seems overwhelming to begin with, After Effects
    is an awesome software, and it is quite easy to create your first animations with
    it. If you are interested in learning After Effects, you can start with the tutorial
    at [bit.ly/prn-lottie-tutorial](http://bit.ly/prn-lottie-tutorial).'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**学习使用 After Effects 创建动画**：有很多优秀的入门教程，即使一开始看起来令人望而却步，After Effects 仍然是一款出色的软件，用它来创建第一个动画相当简单。如果你对学习
    After Effects 感兴趣，可以从 [bit.ly/prn-lottie-tutorial](http://bit.ly/prn-lottie-tutorial)
    上的教程开始。 '
- en: '**Hire an animation artist**: This is, by far, the best solution from my point
    of view. An experienced animation artist will only need some hours to create a
    bunch of individual animations for your project. It will save you time and money
    to work with an animation artist, and it will greatly improve the quality of your
    app when having individual animations that exactly fit your UI concept. You can
    find and contact animation artists at [https://lottiefiles.com/](https://lottiefiles.com/).'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**雇佣一位动画艺术家**：在我看来，这是最好的解决方案。一位经验丰富的动画艺术家只需几个小时就能为你的项目创建一系列单独的动画。与动画艺术家合作可以节省时间和金钱，并且当拥有与你的
    UI 概念完全匹配的单独动画时，将大大提高你应用的质量。你可以在 [https://lottiefiles.com/](https://lottiefiles.com/)
    上找到并联系动画艺术家。'
- en: Now that we have a good understanding of how Lottie animations in React Native
    work, let’s have a look at the pros and cons.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经很好地理解了 React Native 中的 Lottie 动画是如何工作的，让我们来看看其优缺点。
- en: Understanding the pros and cons of Reanimated
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 Reanimated 的优缺点
- en: Since the Lottie approach is completely different, there are huge pros and cons
    you should keep in mind when you consider using Lottie as the animation solution
    for your project.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Lottie 方法完全不同，在考虑将 Lottie 作为项目动画解决方案时，你应该牢记其巨大的优缺点。
- en: 'The following pros stand out when using Lottie:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Lottie 时，以下优点尤为突出：
- en: '`lottie-react-native`, it just takes a few lines of code to integrate an animation,
    no matter how complex it is.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lottie-react-native`，无论动画多么复杂，只需几行代码即可集成动画。'
- en: '**Animations are much smaller than GIFs or Sprites**: Another approach when
    it comes to animated files is GIFs or Sprites. Lottie files are much smaller and
    consume far less memory than these solutions.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动画文件比 GIF 或 Sprites 小得多**：在处理动画文件时，另一种方法是 GIF 或 Sprites。Lottie 文件比这些解决方案小得多，消耗的内存也少得多。'
- en: '**Programmatic control over the animation progress**: Unlike when working with
    GIFs, you have programmatic control over the animation. You can even bind the
    animation progress to the animation values of React Native Animated.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对动画进度的程序控制**：与处理 GIF 不同，你可以对动画进行程序控制。你甚至可以将动画进度绑定到 React Native Animated
    的动画值。'
- en: 'However, Lottie also comes with the following cons:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Lottie 也存在以下缺点：
- en: '**No full control over the animation**: When working with Lottie animations,
    you are able to control the progress of the animation, but only the progress.
    You cannot change the paths of the animations based on user interaction like you
    can when completely scripting the animation.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无法完全控制动画**：当使用 Lottie 动画时，你可以控制动画的进度，但仅限于进度。你不能像完全脚本化动画那样根据用户交互更改动画路径。'
- en: '`lottie-react-native` has to be included in the app but also the Lottie module
    for the native platform.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lottie-react-native` 必须包含在应用程序中，同时也需要包含针对原生平台的 Lottie 模块。'
- en: '`lottie-react-native` will immediately work with every new React Native version.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lottie-react-native` 将立即与每个新的 React Native 版本兼容。'
- en: Lottie is an awesome option to include high-quality animations in a React Native
    project. Especially for complex loading animations, micro-animations, or any animation
    where no complete programmatic control is needed, Lottie is a great solution.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Lottie 是在 React Native 项目中包含高质量动画的绝佳选择。特别是对于复杂的加载动画、微动画或任何不需要完整程序控制的动画，Lottie
    是一个很好的解决方案。
- en: Summary
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about the general architectural challenge when
    it comes to animations in React Native. You understood that there are different
    solutions to overcome this challenge and create high-quality and performant animations.
    With Animated, `react-native-animatable`, Reanimated, and Lottie, we looked at
    the best and the most widely used animation solutions for React Native’s on-screen
    animations.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了在 React Native 中进行动画时的总体架构挑战。你了解到有不同解决方案可以克服这一挑战，并创建高质量和性能良好的动画。我们探讨了
    Animated、`react-native-animatable`、Reanimated 和 Lottie，这些都是 React Native 屏幕动画的最佳和最广泛使用的动画解决方案。
- en: This is important because you will have to use animations in your app to create
    a high-quality product, and such animation libraries are the only way to create
    high-quality and performant animations in React Native.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要，因为你在应用程序中需要使用动画来创建高质量的产品，而这些动画库是唯一在 React Native 中创建高质量和性能良好的动画的方法。
- en: In the next chapter, you will learn how to handle user gestures and also work
    with more complex user gestures to do different things – for example, to drive
    animations.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何处理用户手势，以及如何与更复杂的手势一起工作来完成不同的事情——例如，驱动动画。
