- en: '*Chapter 4*: Integration Testing and Third-Party Libraries in Your Application'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we learned how to test components in isolation separate
    from dependencies. We also learned how to test components that manage state. In
    many applications, teams can increase velocity by incorporating third-party tools
    to manage state and build components. By the end of this chapter, you will have
    learned about the benefits of using the integration approach to testing. You will
    understand how to configure tests to make assertions against components using
    advanced state management tools. You will learn how to test for errors rendered
    in applications. You will test components that interact with API servers that
    structure data differently from traditional **Representational State Transfer**
    (**REST**) APIs by allowing you to describe and receive only the specific data
    needed by your frontend application. Finally, you will learn how to test components
    that use a popular React component library.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Gaining value with integration testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing components that use the Context API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing components that use Redux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing components that use GraphQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing components built with Material-UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The skills gained in this chapter will deepen our understanding of testing React
    components in various scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the examples in this chapter, you will need to have Node.js installed on
    your machine. We will be using the `create-react-app` CLI tool for all code examples.
    Please familiarize yourself with the tool before starting the chapter if needed.
    Also, you will need to have a basic understanding of Redux and the React Context
    API. Code snippets will be provided throughout the chapter to help you understand
    the code under test, but the objective is understanding how to test the code.
    You can find code examples for this chapter here: [https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter04](https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter04).'
  prefs: []
  type: TYPE_NORMAL
- en: Testing integrated components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to test components in isolation from
    dependencies, including other components. Isolated testing has its advantages
    but also has drawbacks because real dependencies are replaced with test doubles.
    In this section, we will learn how to test components that integrate with other
    components. In many scenarios, integration testing can add more value than isolated
    testing because we can test the code in ways that are closer to its production
    use. We can also add test coverage faster for components because one test can
    cover multiple components at once. We will use integration testing in a few examples
    in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Using integration testing with the Vote component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous chapter, we tested the `Vote` component, which allowed users
    to click a button to increase or decrease the total likes. In this section, we
    will break up the implementation into separate components and write integration
    tests. The component included two `button` elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code, the properties for the two button elements are very similar
    and could be extracted into their own component files to be reusable in other
    parts of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code, we have a `VoteBtn` component created in its own file
    that can be reused anywhere throughout the application. `VoteBtn` can be used
    inside the `Vote` component to replace the hardcoded `button` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code, two instances of `VoteBtn` are integrated into the `Vote`
    component. We could test `VoteBtn` in isolation from the `Vote` component, but
    we can gain more value by testing the integration of the two together. For the
    first test, we can verify that an `"up"` vote increases the sum of total likes
    by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code, first, we rendered the `Vote` component into the DOM
    with a value of `10` passed into the `totalGlobalLikes` property. Next, we click
    the `11` in is the DOM. For the next test, we will verify that a `"down"` vote
    decreases the sum of total likes by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, the code is similar to that in the first example.
    The only difference is instead of clicking the `9` is in the DOM. The last test
    we will write will verify that a user can only vote once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, first, we rendered the `Vote` component into the DOM with
    a value of `10` passed into the `totalGlobalLikes` property. Next, we grab the
    `11` is in the DOM. The number `11` is expected because the **thumbs up** button
    was clicked first, which disables the buttons. By using the integration testing
    approach, we were able to verify the outcome of the total likes displayed on the
    screen and the state of buttons after simulating click events all in the same
    test.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run all the `Vote` component tests, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Vote component test results'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.1_B16887.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.1 – Vote component test results
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot shows that tests `Vote.test.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: Now you understand the advantages of testing components integrated with dependencies.
    However, there are scenarios where using the integrated approach may not be the
    best strategy. In the next section, we will look at a scenario where testing a
    component in isolation would provide more value than integration testing.
  prefs: []
  type: TYPE_NORMAL
- en: Planning test scenarios better suited for isolated testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous section, we learned the advantages of testing components integrated
    with dependencies. However, there are some scenarios where using the isolated
    testing approach is a better fit. In the *Implementing test-driven development*
    section of [*Chapter 3*](B16887_03_Final_PG_ePub.xhtml#_idTextAnchor046), *Testing
    Complex Components with React Testing Library*, we built a registration form.
    As a reference, the output of the component was as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Registration form](img/Figure_4.2_B16887.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Registration form
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding screenshot, we see the registration component that allows
    a user to submit an email address and password. The test used the isolated approach
    and verified the happy path of invoking a `handleRegister` method when the form
    is submitted. Let''s say a new feature is added where a success message is sent
    to the frontend from the server and replaces the form on the screen when registration
    is successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Registration success](img/Figure_4.3_B16887.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Registration success
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, the message **Registration Successful!** is displayed
    after successful form submission. Verifying the message is on the screen after
    submitting the form could be tested using the integration approach but might be
    a slow-running test. We could create a faster running isolated test by creating
    a mock server response. What about scenarios where form validation errors are
    displayed and prevent users from submitting the form? For example, form validation
    errors could be displayed when a user enters an invalid email or attempts to submit
    the form with blank fields. The password field could also present several test
    scenarios, such as displaying errors when the minimal password length is not met,
    or special characters are not included in the password.
  prefs: []
  type: TYPE_NORMAL
- en: The previous scenarios are all good use cases for the isolated test approach.
    The errors displayed on the screen do not depend on any code outside the component.
    We can test various combinations in the form and edge cases that will run extremely
    fast and quickly add a lot of value. In general, consider creating an isolated
    test for scenarios where a test setup using the integrated approach would prove
    cumbersome or when the integration approach yields slow-running tests. Also, keep
    in mind how many dependencies have to be mocked when creating an isolated test.
    Mocking multiple dependencies provides less value than testing with dependencies
    included.
  prefs: []
  type: TYPE_NORMAL
- en: Now you know how to test components integrated with dependencies. You understand
    the benefits of integration testing compared to testing in isolation. You also
    know that in some scenarios, testing a component using the isolated approach can
    yield better outcomes for your testing plan than solely using the integrated approach.
    The decision to test a component in isolation or integrated with dependencies
    will depend on your test plans. In the next section, we will visit more examples
    using the isolated and integrated testing approach and learn how to test components
    that use the Context API for state management.
  prefs: []
  type: TYPE_NORMAL
- en: Testing components that use the Context API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will learn how to test components that use the React library''s
    `Context Provider` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `LikesProvider` component, responsible for providing
    the Context state to Context consumers, is rendered with `Vote` as a child component.
    `LikesProvider` provides all the consuming components with an `initialLikes` count
    of `10`. Since `Vote` is rendered within `LikesProvider`, it can view and update
    state provided by `LikesProvider`. To test the `Context` `Provider` component's
    consumers, we need a way to access `Context Provider` within our tests. We will
    use a retail application to demonstrate how to implement the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Testing a context consuming Retail component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will test a `Retail` component that consumes state provided
    by a `RetailContext` component. The UI of the `Retail` component looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Retail component UI'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.4_B16887.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.4 – Retail component UI
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding screenshot shows the initial screen output of the `Retail` component.
    A list of clothing products and a shopping cart is shown. There is also a section
    with the text **Retail Store** that will display product details once clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Product details'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.5_B16887.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.5 – Product details
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding screenshot shows details for **Mens Casual Premium Slim Fit T-Shirts**
    after being clicked by the user. A user can click the **ADD TO FAVORITES** button
    to *favorite* the item:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 –Favorited product details](img/Figure_4.6_B16887.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 –Favorited product details
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding screenshot shows that the text **ADD TO FAVORITES** changes to
    **ADDED TO FAVORITES** once the button is clicked. Finally, a user can add a quantity
    and click the **ADD TO CART** button to add the product to their cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Product added to cart](img/Figure_4.7_B16887.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – Product added to cart
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot shows a quantity of **3** of the item **Mens Casual
    Premium Slim Fit T-Shirts** added to the cart. The cart displays **1 Items**,
    representing the total items in the cart. The cart also shows the **Subtotal**
    for all items added to the cart.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the code implementation, the `Retail` component is rendered as a child component
    of `RetailProvider` inside `App`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, `RetailProvider` receives an array of products via `retailProducts`.
    The `retailProducts` data is a local subset of data from the `Fake Store API`
    ([https://fakestoreapi.com](https://fakestoreapi.com)) API, a free open source
    REST API that provides sample products. The `Retail` component includes three
    separate child components – `ProductList`, `ProductDetail`, and `Cart` – that
    integrate together to consume and manage `RetailContext` state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `Retail` component renders the `ProductList`, `ProductDetail`, and `Cart`
    components as child components inside `div` elements in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: We will use a combination of isolated unit tests and integration tests to verify
    that the `Retail` code works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Cart component in isolation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will verify the initial state of the `Cart` component.
    We will use a unit test approach because the initial state depends on `RetailContext`
    and not other `Retail` components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code, we first render the `Cart` component as a child of `RetailProvider`.
    Next, we make two assertions. First, we assert the text `0 items` is in the DOM.
    Then, we assert the text `$0.00` is in the DOM. When we run the test for the `Cart`
    component, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – Cart component test result'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.8_B16887.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.8 – Cart component test result
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot shows the test `Cart` component.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will test the `Product` component.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Product component in isolation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will verify the `Product` component can display passed-in
    product data to the DOM. We will use `faker`, a popular library, to generate test
    data. We can write the following test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code snippet, we use `faker` to generate random `productName`,
    `price`, and `fashion image` data for our test. Using `faker` to generate our
    test data automatically, we can eliminate any confusion for new team members looking
    at our code to learn about the component under test. A new team member may see
    hardcoded data and think the component must have that specific data to work properly.
    Random data created by `faker` can make it clearer that the component does not
    need to be specifically hardcoded to function as expected. Next, we write the
    remaining code for the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code snippet, we wrap the `Product` component inside `RetailProvider`,
    pass in test data as props, and render the DOM component. Finally, assert that
    the product `title` and `price` is in the DOM. Now we have verified that the `Product`
    component accepts and renders prop data into the DOM as expected. When we run
    the test for the `Product` component, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9 – Product component test result'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.9_B16887.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.9 – Product component test result
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot shows the test `Product` component correctly displays
    passed in data to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will test the `ProductDetail` component.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the ProductDetail component in isolation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section will verify that `ProductDetail` initially renders the text **Retail
    Store** into the DOM. The **Retail Store** text serves as a placeholder until
    a user clicks one of the products. We can test the component as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we wrap `ProductDetail` inside `RetailProvider`. Then,
    we assert that the text **Retail Store** is in the DOM. Running the test results
    in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10 – ProductDetail component test result](img/Figure_4.10_B16887.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.10 – ProductDetail component test result
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot shows the test `ProductDetail` renders the correct
    text on the initial render.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will verify the error displayed when a consumer is used outside of
    `Context Provider`.
  prefs: []
  type: TYPE_NORMAL
- en: Testing context errors using error boundaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will verify that the `Retail` component must be wrapped
    in `RetailProvider` before using it in the first test. This test is important
    because the `Retail` component cannot work as expected without the stateful data
    provided by `RetailContext`. Inside the `RetailContext` code, we have a check
    to make sure the methods used to access `RetailContext` are used within `Provider`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code snippet, if a user attempts to use the `useRetail` method
    to access `RetailContent`''s stateful data outside of `RetailProvider`, a *throw
    error* will occur and stop the application from running. We can write the test
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we use the `jest.spyOn` method to keep an eye on the
    `console.log` method throughout the test. We also attach an empty callback method
    as `mockImplementation`. We use `mockImplementation` to control what happens when
    `console.error` is called. We don't want anything specific logged to the console
    in our test results related to the console for this `test.error` execution, so
    we pass in the empty callback function.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create `ErrorFallback`, a component we will use to receive the message
    included in the error thrown by `RetailContext`. Next, we wrap `Retail` in `ErrorBoundary`,
    which gives us control over errors thrown by components. We can manually create
    an error boundary component but `react-error-boundary` ([https://github.com/bvaughn/react-error-boundary](https://github.com/bvaughn/react-error-boundary))
    provides an easy-to-use error boundary component. We provide `ErrorFallback` as
    the value for `FallbackComponent`. When `Retail` is rendered, and the error is
    thrown, the `ErrorBoundary` component will pass the error on to `ErrorFallback`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we perform assertions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, first, we query the DOM for the error message `must be
    used within the RetailProvider`. Next, we expect `console.error` to have been
    called. Finally, as a test clean-up step, we restore `console.error` back to its
    original state, allowing it to be called wherever necessary for successive tests.
    Now you know how to verify that a context-consuming component cannot be rendered
    outside of `Context Provider`.
  prefs: []
  type: TYPE_NORMAL
- en: Using integration testing to test view product details
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For our next test, we will verify that a user can click a product and see product
    details. The steps involved in viewing a product''s details is a user workflow
    that would be good to test using the integration approach. We can write the test
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we wrap the `Retail` component in `RetailProvider` and
    render it in the DOM. Next, we grab the first item in the `testProducts` array
    and assign it to the variable `firstProduct`. Then, we click the `title` of the
    first product on the screen. Finally, we assert the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we assert the first product's title is displayed twice
    on the screen. Finally, we assert the product's `description` and `price` data
    is displayed on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our next test, we will verify that a user can add a product to the cart.
    We can write the following test code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code snippet, we create an `addFirstItemToCart` function to
    execute the same test steps in successive tests and avoid code duplication. Next,
    we write the main test code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we render the `Retail` component inside `RetailProvider`.
    Next, we execute the `addFirstItemToCart` method. Finally, we assert that the
    text `1 items` is in the DOM. Now we are confident a user can add an item to the
    cart using `Retail` integrated with the `Product`, `ProductDetail`, and `Cart`
    components.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a challenge, try to write the code for the following test scenarios: **A
    user can update the quantity for cart items**, **A user cannot submit a quantity
    greater than 10**, **A user cannot submit a quantity less than 1**, and **A user
    can add an item to favorites**. The solutions for these test scenarios can be
    found in the [*Chapter 4*](B16887_04_Final_PG_ePub.xhtml#_idTextAnchor062) *code
    samples* ([https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter04/ch_04_context](https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter04/ch_04_context)).
    Now you know how to write integration tests for components that use the Context
    API. You have a better understanding of unit testing components in isolation through
    multiple examples. You also know how to test for errors thrown using error boundaries.'
  prefs: []
  type: TYPE_NORMAL
- en: This section's learnings will be beneficial in the next section when we learn
    how to test components that manage state using Redux. There will be a few differences,
    but similar strategies from this section will be used in general.
  prefs: []
  type: TYPE_NORMAL
- en: Testing components that use Redux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will teach you how to test components that use the popular `Context
    Provider`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test components using Redux, components must be used within the Redux state
    providing context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have a top-level `App` passed in as a child component
    of the Redux `Provider` component. Wrapping the top-level `App` component is a
    common pattern in Redux that allows any child component in the application to
    access the stateful data provided by Redux. Stateful data and methods to modify
    state are passed to the Provider's `store` property. Typically, you will create
    this code in separate files, wire everything together using Redux's API methods,
    and pass the combined result to the `store` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'When designing Redux-consuming component tests, we need to pass in test data
    that we can use as the Redux state. Simply passing in test data to the `store`
    property of the Redux Provider will not work because we also need to include the
    Redux methods used to consume and update the stateful data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code snippet, we have a `Cart` component test that passes in
    the string **some test data** as test data to the Redux store. When we run the
    test, we receive the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11 – Failed Cart Redux component test'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.11_B16887.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.11 – Failed Cart Redux component test
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding screenshot shows the test `TypeError: store.getState is not a
    function` to the console. The `render` method. The test failed because when the
    component under test renders, it tries to access a method provided by Redux to
    access the Redux store''s state, but the method is not available. We need a way
    to pass all associated Redux state methods and controllable test data to the test.
    We will learn a strategy in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom render method for testing Redux consuming components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will learn how to create a custom `render` function for
    use in our tests. In [*Chapter 1*](B16887_01_Final_PG_ePub.xhtml#_idTextAnchor013),
    *Exploring React Testing Library*, we learned that React Testing Library''s `render`
    method is used to place components in the DOM to be tested. The custom `render`
    method uses React Testing Library `render` method''s `wrapper` option to place
    components into the DOM wrapped in a Redux Provider component that provides access
    to Redux API methods. The custom `render` method will also allow us to pass in
    controllable test data unique to each test. To get started, we will create a file
    for our method and import a number of modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we import the `configureStore` method from the Redux Toolkit
    library. The `configureStore` method is an abstraction over the standard Redux
    `createStore()` used to set up the Redux store. Next, we import the `render` method
    from React Testing Library and name it `rtlRender`. The `rtlRender` name is short
    for `React Testing Library Render`. Later in the file, we will create a custom
    `render` method to eliminate problems resulting from using identical method names.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we import the `faker` module. We will use `faker` to automatically generate
    data for the initial state to pass into our component. Then, we import the `Provider`
    method from `React-redux` to accept and give `store` to components. Finally, we
    import `retailReducer` that provides methods components can use to access and
    modify state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will create an object to serve as the `initialState` values for the
    Redux store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code, the variable `fakeStore` holds all initial state values
    for `products`, `cartItems`, `favorites`, and `showProductDetails`. The products
    data is an array of objects with values created by `faker`. Next, we will create
    a custom `render` method to use in place of React Testing Library''s `render`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code snippet, the method accepts two arguments as parameters.
    First, the `ui` parameter accepts the component under test as a child to be wrapped
    within the custom method. The following parameter is an object with many properties.
    First, `initialState` accepts custom test data we can pass into our components
    within the test file. Next, `store` uses the `configureStore` method to set up
    the Redux store with `reducer` and `preloadedState`. The `reducer` property is
    an object that accepts `reducers` we create to manage the application state. The
    `preloadedState` property accepts `initialState` passed into the component in
    the test file. Finally, any other passed-in parameters are handled by `renderOptions`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will create the `Wrapper` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `Wrapper` accepts `children`, which will be the component
    under test. Next, the method returns `Provider` with `store` and `children` passed
    in. Finally, `render` method returns a call to `rtlRender` with `ui` and an object
    including the `Wrapper` method and other `renderOptions` passed in.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step is to export the custom code to be imported and used in test
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, first, we export everything from React Testing Library.
    Finally, we export an object that includes the custom `render` method that overrides
    React Testing Library `render` method and `fakeStore` as the custom test data
    to use in any test. Now you know how to create a custom `render` method to use
    for testing Redux consuming components.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will use the custom method in a test.
  prefs: []
  type: TYPE_NORMAL
- en: Using the test Redux Provider in tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will use the custom `render` method to test a component.
    In the *Testing a context consuming Retail component* section of this chapter,
    we tested a `Retail` component and its child components. The development team
    could have decided to build the component state using Redux. The `Retail` component
    included `Cart` that we can test with the custom `render` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code, first, we import the `Cart` component to test in the
    test file. Next, we import the `render`, `screen`, and `fakeStore` methods from
    our custom method file. The `render` method is the custom method created in the
    file. The `screen` method is the real `screen` method from React Testing Library.
    The `fakeStore` method is the custom test data we created in the custom method
    file. Next, we will write the main test code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code, first, we use the customer `render` method to render
    the `Cart` component in the DOM. As a second argument to the `render` method,
    we pass in an object and `fakeStore` as the value to `initialState`. `fakeStore`
    is the default test data we can use, but we can create and pass different data
    specific to the test. The custom `render` method makes our code cleaner because
    we don''t see the test code''s `Provider` method. Finally, we assert that the
    text `0 items` and `$0.00` is in the DOM. When we run the test, we get the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.12 – Passing Cart Redux component test'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.12_B16887.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.12 – Passing Cart Redux component test
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot shows the test `render` method as expected. Please
    see the [*Chapter 4*](B16887_04_Final_PG_ePub.xhtml#_idTextAnchor062) *code samples*
    ([https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter04/ch_04_redux](https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter04/ch_04_redux))
    for more examples testing Redux consuming components. Now you know how to create
    a custom `render` method to test components that consume Redux state. The custom
    method can be used to test practically any Redux-consuming React component.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to test components that consume API data
    via GraphQL.
  prefs: []
  type: TYPE_NORMAL
- en: Testing components that use GraphQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn how to test components that use `Table` component
    we tested in the *Testing integrated components* section of this chapter, only
    now the component will be refactored to receive data via the GraphQL server using
    `Apollo Client` ([https://www.apollographql.com/docs/react/](https://www.apollographql.com/docs/react/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can look at the implementation details of the `Table` component to understand
    how it interacts with GraphQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we create an `employees` GraphQL query to access the
    `employees` data to render in `table` row elements within the component. The query
    will automatically communicate with the GraphQL server when the component renders
    and return `employee` data for the component to use. We will later use this query
    inside our test file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `App` component plays an important role in communicating with the GraphQL
    server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, a `client` variable is created and set to a new instance
    of `ApolloClient`, imported from `ApolloClient` has a `uri` property that we can
    set to the URL of the running GraphQL server, which is `http://localhost:4000`
    in the code snippet. `ApolloClient` also sets the `cache` property to the `InMemoryCache`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: The `InMemoryCache` method is an excellent performance-enhancing feature because
    it will store data received from GraphQL locally and only make additional calls
    to the GraphQL server when the data needs updating. The `App` component also uses
    `ApolloProvider` from the Apollo library to render `Table` as a child component.
    The `Table` component can now make queries to the GraphQL server. `ApolloProvider`
    behaves similarly to the Redux `Provider` component we learned about in this chapter's
    *Testing components that use Redux* section. Now that we understand the connection
    between GraphQL and the consuming `Table` component, we can start writing tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first test we will write will verify that a loading message appears on
    the screen when `Table` initially renders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we import `MockedProvider`. `MockedProvider` is a particular
    method from Apollo that we can use for testing. Using `MockedProvider`, we do
    not need to create any custom `Provider` component as we did in the *Testing components
    that use Redux* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we import `act`, `render`, and `screen` from React Testing Library. The
    `act` method will let React know we are explicitly performing actions it does
    not expect. We will cover this in detail in the associated test. Then, we import
    `faker` to help generate test data. Finally, we import the `Table` component to
    test and the `EMPLOYEES` GraphQL query.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can create a mock GraphQL response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a `mocks` variable set to an array in the preceding code, with a
    `request` property set to our `EMPLOYEES` query. The `mocks` variable will replace
    the real GraphQL query with a version we can use for testing. Next, we can create
    the test data our test will respond with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we create a `data` property set to an array of `employees`
    for the `Table` component to consume and display on the screen. The `faker` module
    is used to eliminate the need to create hardcoded values. Now we can write the
    main test code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we render the `Table` component inside `MockedProvider`
    with passed-in `mocks` data. Then, we assert that the text **Loading…** is in
    the DOM. The loading text is the first thing to display when the component renders
    until the frontend React application receives data from the GraphQL server.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the next test, we will verify the `completed` state is achieved, meaning
    the component has received and rendered employee data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we render the `Table` component inside `MockedProvider`
    with passed-in `mocks` data. Then, we set `Promise` to the `resolved` state wrapped
    in the `act` method. Although we are not accessing the real GraphQL server, the
    Apollo methods we use are asynchronous and take some time to complete. We explicitly
    complete the asynchronous process after `0` seconds to continue the test steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `0` second value may seem odd to force the `resolved` state but is necessary
    because asynchronous JavaScript actions will wait for some time before completion
    and continuing with the following action. If we do not use the `act` method, our
    test will pass but also render an error message to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.13 – Not wrapped in act error'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.13_B16887.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.13 – Not wrapped in act error
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot shows the error message displayed in the console when
    we do not use the `act` method to handle explicit component updates that React
    does not know about. Finally, we assert that two `row` elements are found in the
    DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the last test, we will verify that the error state results in the error
    message being displayed on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we render the `Table` component inside `MockedProvider`
    with passed-in `mocks` data. However, unlike previous tests, we set the `error`
    property to a new instance of the `Error` object. When the `error` property is
    set, it means that something happened, preventing the process of sending and receiving
    data from the GraphQL server to the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we set `Promise` to the `resolved` state wrapped in the `act` method
    as we did in the previous test. Finally, we assert that the text `Error` is in
    the document. When we run the tests, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.14 – Table component test results'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.14_B16887.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.14 – Table component test results
  prefs: []
  type: TYPE_NORMAL
- en: Now you know how to test components that consume GraphQL server data using Apollo
    Client. As GraphQL continues to gain popularity, it will be helpful to have the
    testing strategies we covered in your toolbox to verify expected behavior quickly.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to test components that use the popular
    Material-UI component library for frontend development.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Components that use Material-UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to test components that use the Material-UI
    component library. You can select DOM elements rendered by Material-UI components
    out of the box with React Testing Library in most cases. However, sometimes it
    is helpful to add component properties that render as attributes on resulting
    DOM elements. We will learn how to add properties to test the `Vote` and `Customer
    Table` components.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an ARIA label to test a Vote component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *Testing a context consuming Vote component* section of this chapter,
    we tested a `Vote` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could use components from Material-UI to rebuild the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we used the `Box`, `Button`, and `ThumbUpIcon` components
    from Material-UI to quickly build the **thumbs up** button complete with **Cascading
    Style Sheet** (**CSS**) styles already included to make the button look nice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will build the remaining parts of the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we use the `Typography`, `Button`, and `ThumbDownAltIcon`
    components from Material-UI to build the thumbs down button and display the total
    likes number on the screen. When we render the component in the browser, we get
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.15 – Material-UI Vote component'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.15_B16887.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.15 – Material-UI Vote component
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot shows a `Vote` component we tested in previous sections
    of this chapter, a user can vote up or down to change the total likes. However,
    grabbing and clicking the buttons with React Testing Library would be difficult
    with the current component implementation. There are no accessible ways to access
    the buttons, such as a label.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, we can add `aria-label` properties to the `Button` components.
    `aria-label` will add a visible label to elements allowing users with screen readers
    to understand the elements'' purpose. We can add `aria-label` to the component
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We added `aria-label` to the first `Button` component in the previous code
    snippet. Next, we will add `aria-label` to the other `Button` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we added `aria-label` to the second `Button` component.
    Material UI will forward the `Button aria-label` properties to the resulting button
    element that will render in the DOM. Since `aria-label` attributes are accessible
    by all users, including those using assistive devices to navigate the screen,
    React Testing Library can grab elements by those attributes. Now that we can select
    the elements, we can write tests and assert the resulting behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the first test, we will verify that a user can only decrease the total
    like count by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we render the `Vote` component with the value of `10`
    for `totalGlobalLikes`. Next, we grab the `aria-label` attribute we added and
    assign it to the `thumbsUpBtn` variable. Next, we click the `11` is in the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the next test, we will verify that a user can remove their **"up"** vote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we render the `Vote` component with the value of `10`
    for `totalGlobalLikes`. Next, we grab the `aria-label` properties we added to
    both `Buttons` and assign them to variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we click the `10` is on the screen. When we run the test, we get the
    following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.16 – Material-UI Vote test results'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.16_B16887.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.16 – Material-UI Vote test results
  prefs: []
  type: TYPE_NORMAL
- en: The previous screenshot shows that the tests **given multiple "down" votes,
    total likes only decrease by one**, and **given retracted "up" vote, returns original
    total likes** pass as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a challenge, try writing tests for the following scenarios: **given "up"
    vote, total likes increases by one**; **given multiple "up" votes, total likes
    only increase by one**; and **given retracted "down" vote, returns original total
    likes**. The solutions for these test scenarios can be found in the *chapter 4
    code samples*. Now you know how to make Material-UI components testable by adding
    aria-labels.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to add an attribute specific to React
    Testing Library to make components testable.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a test ID to test a CustomerTable component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous section, we learned how to make Material-UI components testable
    by adding `aria-labels`. In this section, we will learn how to add `data-testid`
    to make components testable. `data-testid` is another option to query DOM elements
    with React Testing Library. The `data-testid` query is a last-resort way to grab
    DOM elements when other preferred methods such as `*byText` or `*byRole` cannot
    be used, and we want to avoid using `class` or `ID` selectors. We can use `data-testid`
    by attaching it as an attribute to a DOM element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We add a `"product-type"` `data-testid` to select the heading element uniquely
    in the previous code snippet. We will test a `CustomerTable` component in this
    section that accepts customer data and renders the following to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.17 – Material-UI table component'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.17_B16887.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.17 – Material-UI table component
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous screenshot shows a table with multiple rows of customer data.
    A user can use the `da`, the following results will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.18 – Material-UI table filtered results'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.18_B16887.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.18 – Material-UI table filtered results
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot shows two resulting rows. The two rows are displayed
    as matching results because the text **da** is visible in the rows' associated
    columns. We will write three tests for the component.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the first test, we will verify that the component can receive and render
    passed-in customer data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we create an array of test objects to pass into the component.
    It should be noted that the code snippet only shows one customer object. The code
    sample for the `CustomerTable` test file will have three.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can write the main test code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code, first, we render `CustomerTable` with `fakeCustomers`
    passed into the `data` property. Finally, we assert that the number of rows is
    equal to `3`. We use the `getAllByTestId` query to access all the rows. The `*allBy`
    queries allow us to grab multiple, similar DOM elements. In the code implementation
    for `CustomerTable`, `data-testid` is added as a property to each `TableRow` component
    created for each customer data object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code, a `data-testid` property is added to the `TableRow` component.
    The `data-testid` is used because the preferred query methods cannot be used to
    select all the rows in this scenario. For the second test, we verify that queries
    returning one match return one result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, first, we render `CustomerTable` with `testData` passed
    into the `data` property. Then, we grab the textbox and store it in the `searchBox`
    variable. Finally, we assert that the number of rows in the DOM is 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the final test, we will verify that non-matching queries return no `row`
    elements to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is similar to the previous test with two differences. First,
    we type `zzz` into `searchBox`. Then, we assert that `0 row` elements are found
    in the DOM. When we run the tests, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.19 – Material-UI table test results ](img/Figure_4.19_B16887.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.19 – Material-UI table test results
  prefs: []
  type: TYPE_NORMAL
- en: The previous screenshot shows that the tests **given data, renders table rows**,
    **given single-matching query, single result returned**, and **given non-matching
    query, no results returned** all pass as expected. As a challenge, try writing
    a test for the scenario **given multi-matching query, multiple results returned**.
    The previous test scenario solution can be found in the [*Chapter 4*](B16887_04_Final_PG_ePub.xhtml#_idTextAnchor062)
    *code samples* ([https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter04/ch_04_mui](https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter04/ch_04_mui)).
  prefs: []
  type: TYPE_NORMAL
- en: This section's content has provided you with the skills to test specific Material-UI
    components by adding `aria-label` and `data-testid` attributes to grab them with
    React Testing Library when needed.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned how to test components using the integration
    test approach compared to the unit test approach with mocked dependencies. You
    know how to test components that use the Context API to manage application state.
    You also learned how to create a custom method to test components in projects
    using the third-party Redux library. Finally, you learned how to add attributes
    to test components built using the popular Material-UI library.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to refactor tests for legacy projects.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Explain the benefits of testing integrated components versus in isolation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When should you use the `data-testid` attribute to grab components?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When should you use the `act` method from React Testing Library?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
