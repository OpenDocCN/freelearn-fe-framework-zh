- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit Testing Angular Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we went through many aspects of how to build an Angular
    enterprise application from scratch. But how can we ensure that an application
    can be maintained in the future without much hassle? A comprehensive automated
    testing layer can become our lifeline once our application begins to scale up
    and we have to mitigate the impact of bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Testing, specifically unit testing, is meant to be carried out by the developer
    as the project is being developed. Now that our knowledge of the framework is
    mature, we will briefly cover all the intricacies of unit testing an Angular application
    in this chapter including the use of testing tools..
  prefs: []
  type: TYPE_NORMAL
- en: For simplicity, the examples in this chapter are not related to the e-shop application
    that we have built throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'In more detail, we will learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need unit tests?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The anatomy of a unit test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing unit tests in Angular
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing pipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing directives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the router
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The chapter contains various code samples to walk you through the concept of
    unit testing in Angular. You can find the related source code in the `ch13` folder
    of the following GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.github.com/PacktPublishing/Learning-Angular-Fifth-Edition](https://www.github.com/PacktPublishing/Learning-Angular-Fifth-Edition)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need unit tests?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn what unit tests are and why they are useful in
    web development.
  prefs: []
  type: TYPE_NORMAL
- en: You can skip to the next section if you’re familiar with unit testing and test-driven
    development.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests are part of an engineering philosophy for efficient and agile development
    processes. They add a layer of automated testing to the application code before
    it is developed. The core concept is that a piece of code is accompanied by its
    test, both of which are built by the developer who works on that code. First,
    we design the test against the feature we want to deliver, checking the accuracy
    of its output and behavior. Since the feature is still not implemented, the test
    will fail, so the developer’s job is to build the feature to pass the test.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing is quite controversial. While test-driven development is beneficial
    for ensuring code quality and maintenance over time, not everybody undertakes
    unit testing in their daily development workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Building tests as we develop our code can sometimes feel like a burden, especially
    when the test results become larger than the functionality it aims to test. However,
    the arguments in favor of testing outnumber the arguments against it:'
  prefs: []
  type: TYPE_NORMAL
- en: Building tests contributes to better code design. Our code must conform to the
    test requirements and not vice versa. If we try to test an existing piece of code
    and find ourselves blocked at some point, the chances are that the code is not
    well designed and requires some rethinking. On the other hand, building testable
    features can help with the early detection of side effects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring tested code is a lifeline against introducing bugs in later stages.
    Development is meant to evolve with time, and the risk of introducing a bug with
    every refactor is high. Unit tests are an excellent way to ensure we catch bugs
    early, either when introducing new features or updating existing ones.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building tests is an excellent way to document our code. It becomes a priceless
    resource when someone unfamiliar with the code base takes over the development
    endeavor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are only a few arguments, but you can find countless resources on the
    web about the benefits of testing your code. If you do not feel convinced yet,
    give it a try; otherwise, let’s continue with our journey and look at the overall
    form of a unit test.
  prefs: []
  type: TYPE_NORMAL
- en: The anatomy of a unit test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many different ways to test a piece of code. In this chapter, we will
    look at the anatomy of a unit test—the separate parts it’s made of.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test any code, we need a framework for writing the test and a runner to
    run it on. In this section, we will focus on the test framework. The test framework
    should provide utility functions for building test suites containing one or several
    test specs. As a result, unit testing involves the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Test suite** : A suite that creates a logical grouping for many tests. A
    suite, for example, can contain all the tests for a specific feature.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test spec** : The actual unit test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will use **Jasmine** in this chapter, a popular test framework that is also
    used by default in Angular CLI projects. This is what a unit test looks like in
    Jasmine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `describe` method defines the test suite and accepts a name and an arrow
    function as parameters. The arrow function is the body of the test suite and contains
    several unit tests. The `it` method defines a single unit test. It accepts a name
    and an arrow function as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Each test spec validates a specific functionality of the feature described in
    the suite name and declares one or several expectations in its body. Each expectation
    takes a value, called the **expected** value, which is compared against an **actual**
    value using a **matcher** function. The function checks whether the expected and
    actual values match accordingly, which is called an **assertion** . The test framework
    passes or fails the spec depending on the result of such assertions. In the previous
    example, `1+1` will return the actual value that is supposed to match the expected
    value, `2` , declared in the `toBe` matcher function.
  prefs: []
  type: TYPE_NORMAL
- en: The Jasmine framework contains various matcher functions according to user-specific
    needs, as we will see later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose the previous code contains another mathematical operation that must
    be tested. It would make sense to group both operations under the `Calculator`
    suite, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: So far, we have learned about test suites and how to use them to group tests
    according to their functionality. Furthermore, we have learned about invoking
    the code we want to test and affirming that it does what it should do. However,
    more concepts are involved in unit tests that are worth knowing about, namely,
    the **setup** and **teardown** functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: 'A setup functionality prepares your code before you start running the tests.
    It’s a way to keep your code clean by focusing on invoking the code and checking
    the assertions. A teardown functionality is the opposite. It is responsible for
    tearing down what we initially set up, involving activities such as cleaning up
    resources. Let’s see what this looks like in practice with a code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `beforeEach` method is used for the setup functionality and runs before
    every unit test. In this example, we set the value of the `total` variable to
    `1` before each test. The `afterEach` method is used to run teardown logic. After
    each test, we reset the value of the `total` variable to `0` .
  prefs: []
  type: TYPE_NORMAL
- en: It is evident that the test only has to care about invoking application code
    and asserting the outcome, which makes tests cleaner; however, tests tend to have
    much more setup in a real-world application. Most importantly, the `beforeEach`
    method tends to make it easier to add new tests, which is great. We want well-tested
    code; the easier it is to write and maintain such code, the better for our software.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered the basics of a unit test, let’s see how we can implement
    them in the context of the Angular framework.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing unit tests in Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we familiarized ourselves with unit testing and its
    general concepts, such as test suites, test specs, and assertions. It is time
    to venture into unit testing with Angular, armed with that knowledge. Before we
    start writing tests for Angular, though, let’s have a look at the tooling that
    the Angular framework and the Angular CLI provide us with:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Jasmine** : We have already learned that this is the testing framework.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Karma** : The test runner for running our unit tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Angular testing utilities** : A set of helper methods that assist us in setting
    up our unit tests and writing our assertions in the context of the Angular framework.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we use the Angular CLI, we do not have to do anything to configure Jasmine
    and Karma in an Angular application. Unit testing works out of the box when we
    create a new Angular CLI project. Most of the time, we will interact with the
    Angular testing utilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular testing utilities help us to create a testing environment that makes
    writing tests for our Angular artifacts easy. It consists of the `TestBed` class
    and various helper methods in the `@angular/core/testing` namespace. As this chapter
    progresses, we will learn what these are and how they can help us test various
    artifacts. For now, let’s have a look at the most commonly used concepts so that
    you are familiar with them when we look at them in more detail later on:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TestBed` : A class that creates a testing module. We attach an Angular artifact
    to this testing module when we test it. The `TestBed` class contains the `configureTestingModule`
    method we use to set up the test module as needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ComponentFixture` : A wrapper class around an Angular component instance.
    It allows us to interact with the component and its corresponding HTML element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DebugElement` : A wrapper around the DOM element of the component. It is an
    abstraction that operates cross-platform so that our tests are platform-independent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we know our testing environment and the frameworks and libraries used,
    we can start writing our first unit tests in Angular.
  prefs: []
  type: TYPE_NORMAL
- en: All the examples described in this chapter have been created in a new Angular
    CLI project.
  prefs: []
  type: TYPE_NORMAL
- en: We will embark on this great journey from the most fundamental building block
    in Angular, the component.
  prefs: []
  type: TYPE_NORMAL
- en: Testing components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have noticed that whenever we used the Angular CLI to scaffold a new
    Angular application or generate an Angular artifact, it created some test files
    for us.
  prefs: []
  type: TYPE_NORMAL
- en: Test files in the Angular CLI contain the word `spec` in their filename. The
    filename of a test is the same as the Angular artifact it is testing, followed
    by the suffix `.spec.ts` . For example, the test file for the main component of
    an Angular application is `app.component.spec.ts` and it resides in the same path
    as the component file.
  prefs: []
  type: TYPE_NORMAL
- en: We should consider an Angular artifact and its corresponding test one thing.
    When we change the logic of the artifact, we may need to modify the unit test
    as well. Placing unit test files with their Angular artifacts makes it easier
    for us to remember and edit them. It also helps us when we need to refactor our
    code, such as moving artifacts (not forgetting to move the unit test).
  prefs: []
  type: TYPE_NORMAL
- en: 'When we scaffold a new Angular application, the Angular CLI automatically creates
    a test for the main component, `AppComponent` . At the beginning of the file,
    there is a `beforeEach` statement that is used for setup purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It uses the `configureTestingModule` method of the `TestBed` class and passes
    an object as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: We can specify an `imports` array that contains the component we want to test.
    Additionally, we can define teardown options using the `teardown` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `teardown` property contains an object of the `ModuleTeardownOptions` type
    that can set the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`destroyAfterEach` : It creates a new instance of the module at each test to
    eliminate bugs caused by the incomplete cleanup of HTML elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rethrowErrors` : It throws any errors that occur when the module is destroyed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we call the `compileComponents` method to compile the TypeScript class
    and the HTML template of our component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first unit test verifies whether we can create a new instance of `AppComponent`
    using the `createComponent` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The result of the `createComponent` method is a `ComponentFixture` instance
    of the `AppComponent` type that can give us the component instance using the `componentInstance`
    property. We also use the `toBeTruthy` matcher function to check whether the resulting
    instance is valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'As soon as we have access to the component instance, we can query any of its
    public properties and methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the previous test, we check whether the `title` component property is set
    to `my-app` using another matcher function, `toEqual` .
  prefs: []
  type: TYPE_NORMAL
- en: The value of the `title` component property in a new Angular application will
    be the name you passed in the `ng new` command while creating the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have learned, a component consists of a TypeScript class and a template
    file. So, testing it only from the class perspective, as in the previous test,
    is not sufficient. We should also test whether the class interacts correctly with
    the DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Many developers favor class testing over DOM testing and rely on **end-to-end**
    ( **E2E** ) testing, which is slower and performs poorly. E2E tests often validate
    the integration of an application with a backend API and are easy to break. Thus,
    performing DOM unit testing in your Angular applications is recommended.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding test, we create a component and call the `detectChanges` method
    of the `ComponentFixture` . The `detectChanges` method triggers the Angular change
    detection mechanism, forcing the data bindings to be updated. It executes the
    `ngOnInit` life cycle event of the component the first time it is called and the
    `ngOnChanges` in subsequent calls so that we can query the DOM element of the
    component using the `nativeElement` property. In this example, we check the `textContent`
    of the HTML element corresponding to the `title` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run tests, we use the `ng test` command of the Angular CLI. It will start
    the Karma test runner, fetch all unit test files, execute them, and open a browser
    to display the results of each test. The Angular CLI uses the Google Chrome browser
    by default. The output will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Εικόνα που περιέχει κείμενο, γραμματοσειρά, στιγμιότυπο οθόνης, λευκό  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_13_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.1: Test execution output'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous figure, we can see the result of each test at the top of the
    page. We can also see how Karma visually groups each test by suite. In our case,
    the only test suite is **AppComponent** .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s make one of our tests fail. Open the `app.component.ts` file, change
    the value of the `title` property to `my-new-app` , and save the file. Karma will
    re-execute our tests and display the results on the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά, αριθμός  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_13_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.2: Test failure'
  prefs: []
  type: TYPE_NORMAL
- en: Karma runs in **watch mode** , so we do not need to execute the Angular CLI
    test command every time we make a change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, reading the output of tests in the browser is not very convenient.
    Alternatively, we can inspect the console window that we used to run the `ng test`
    command, which contains a trimmed version of the test results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We’ve gained quite a lot of insight just by looking at the test of `AppComponent`
    that the Angular CLI automatically created for us. In the following section, we
    will look at a more advanced scenario for testing a component with dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Testing with dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a real-world scenario, components are not usually as simple as the main component.
    They will almost certainly be dependent on one or more services. They will also
    possibly contain other child components in their template.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have different ways of dealing with testing in such situations. One thing
    is clear: if we are testing the component, we should not test the service or its
    child components. So, when we set up such a test, the dependency should not be
    the real class. There are different ways of dealing with that when it comes to
    unit testing; no solution is strictly better than another:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stubbing** : A method that instructs the dependency injector to inject a
    stub of the dependency that we provide instead of the real class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spying** : A method that injects the actual dependency but attaches a spy
    to the method that we call in our component. We can then either return mock data
    or let the method call through.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using stubbing over spying is preferable when a dependency is complicated. Some
    services inject other services, so using the real dependency in a test requires
    you to compensate for other dependencies. It is also the preferred method when
    the component we want to test contains child components in its template.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Regardless of the approach, we ensure that the test does not perform unintended
    actions, such as accessing the filesystem or attempting to communicate via HTTP;
    we are testing the component in complete isolation.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing the dependency with a stub
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Replacing a dependency with a stub means that we completely replace the dependency
    with a fake one.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a fake dependency in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a constant variable or class that contains properties and methods of
    the real dependency.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a mock definition of the actual class of the dependency.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The approaches are not so different. In this section, we will look at the first
    one as it is most common in Angular development. Feel free to explore the second
    one at your own pace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following `stub.component.ts` component file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It injects `StubService` , which contains two public properties. Providing
    a stub for this service in tests is pretty straightforward, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We have declared the service as `Partial` because we want only to set the `name`
    property initially. We can now use the object literal syntax to inject the stub
    service in our testing module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `msg` component property relies on the value of the `isBusy` service property.
    Therefore, we need to get a reference to the service in the test suite and provide
    alternate values for this property in each test. We can get the injected instance
    of `StubService` using the `inject` method of the `TestBed` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We pass the real `StubService` as a parameter to the `inject` method, not the
    stubbed version we created. Modifying the value of the stub will not affect the
    injected service since our component uses an instance of the real service. The
    `inject` method asks the root injector of the application for the requested service.
    If the service was provided from the component injector, we would need to get
    it from the component injector using `fixture.debugElement.injector.get(StubService)`
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now write our tests to check whether the `msg` component property behaves
    correctly during data binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We have removed the `fixture.detectChanges` line from the `beforeEach` statement
    because we want to trigger change detection in our tests separately.
  prefs: []
  type: TYPE_NORMAL
- en: 'Stubbing a dependency is not always viable, especially when the root injector
    does not provide it. A service can be provided at the component injector level.
    Providing a stub using the process we looked at earlier doesn’t have any effect.
    To tackle such a scenario, we can use the `overrideComponent` method of the `TestBed`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `overrideComponent` method accepts two parameters: the type of component
    that provides the service and an override metadata object. The metadata object
    contains the `set` property, which provides services to the component.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that the component we want to test contains a child component in its
    template, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding case, when we tested the `StubComponent` , we also needed
    to import the TypeScript class of the `<app-child>` component when configuring
    the testing module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ChildComponent` class may have other dependencies as well. Providing stubs
    for those dependencies is not viable because it is not the responsibility of the
    component under test. Instead, we can create a stub TypeScript class for the component
    and import it when configuring the testing module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we passed an empty array in the `template` property
    of the component because we are not interested in the internal implementation
    of the child component.
  prefs: []
  type: TYPE_NORMAL
- en: If the child component contains properties and methods that are used while testing
    the parent component, we need to define them as well in the `ChildStubComponent`
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, to provide a stub of the component, we can pass the `NO_ERRORS_SCHEMA`
    from the `@angular/core` npm package while configuring the testing module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet instructs Angular to ignore any components that have not
    been imported into the testing module.
  prefs: []
  type: TYPE_NORMAL
- en: Stubbing a dependency is very simple, but it is not always possible, as we will
    see in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Spying on the dependency method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using a stub is not the only way to isolate logic in a unit test. We don’t have
    to replace the entire dependency—only the parts our component uses. Replacing
    certain parts means we point out specific methods on the dependency and assign
    a spy to them. A spy can answer what you want, but you can also see how many times
    it was called and with what arguments. So, a spy gives you much more information
    about what is happening.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to set up a spy in a dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: Inject the actual dependency and spy on its methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the Jasmine `createSpyObj` method to create a fake dependency instance.
    We can then spy on the methods of this dependency as we would with the real one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first case is most common in Angular development. Let’s see how to set
    it up. Consider the following `spy.component.ts` file, which uses the `Title`
    service of the Angular framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `Title` service interacts with the title of the main HTML document in an
    Angular application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We do not have any control over the `Title` service since it is built into
    the framework. It may have dependencies that we do not know about. Spying on its
    methods is the easiest and safest way to use it in our tests. We inject it in
    the testing module using the `providers` array and then use it in our test, such
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the Jasmine `spyOn` method, which accepts two parameters: the object
    and its specific method to spy. We used it before calling the `ngOnInit` component
    method to attach the spy before triggering the change detection mechanism. The
    `expect` statement validates that the `setTitle` method was called with the correct
    arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our component also uses the `getTitle` method to get the document title. We
    can spy directly on that method and return mock data:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to define the `Title` service as a spy object and initialize
    it by passing two parameters—the name of the service and an array of the method
    names that the component currently uses:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we attach a spy to the `getTitle` method and return a custom title using
    the Jasmine `returnValue` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we add the `titleSpy` variable in the `providers` array of the testing
    module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The resulting test should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Very few services are well behaved and straightforward, such as the `Title`
    service, in the sense that they are synchronous. Most of the time, they are asynchronous
    and can return observables or promises. In the following section, we will learn
    how to test asynchronous dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Testing asynchronous services
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Angular testing utilities provide two artifacts to tackle asynchronous testing
    scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '`waitForAsync` : An asynchronous approach to unit test services. It is combined
    with the `whenStable` method of the `ComponentFixture` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fakeAsync` : A synchronous approach to unit test services. It is used in combination
    with the `tick` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both approaches provide roughly the same functionality; they only differ in
    how we use them. Let’s see how we can use each by looking at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following `async.component.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'It injects the `AsyncService` from the `async.service.ts` file and calls its
    `getItems` method inside the `ngOnInit` method. As we can see, the `getItems`
    method returns an observable of strings. It also introduces a slight delay so
    that the scenario looks asynchronous:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The unit test queries the native element of the component and checks whether
    the value of the `items$` observable is displayed correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We wrap the test body inside the `waitForAsync` method and call the `detectChanges`
    method to trigger change detection. Furthermore, we call the `whenStable` method,
    which returns a promise that is resolved immediately when the `items$` observable
    is complete. When the promise is resolved, we call the `detectChanges` method
    again to trigger data binding and query the DOM accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: The `whenStable` method is also used when we want to test a component that contains
    a template-driven form. The asynchronous nature of this method makes it preferable
    to use reactive forms in our Angular applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative synchronous approach would be to use the `fakeAsync` method
    and write the same unit test as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the previous snippet, we wrapped the test body in a `fakeAsync` method and
    replaced the `whenStable` method with the `tick` function. The `tick` function
    advances the time by `500` ms, which is the virtual delay we introduced in the
    `getItems` method of the `AsyncService` .
  prefs: []
  type: TYPE_NORMAL
- en: Testing components with asynchronous services can sometimes become a nightmare.
    Still, each of the described approaches can significantly help us in this task.
    However, components are not only about services but also input and output bindings.
    In the following section, we will learn how to test the public API of a component.
  prefs: []
  type: TYPE_NORMAL
- en: Testing with inputs and outputs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have learned how to test components with simple properties and tackle
    synchronous and asynchronous dependencies. But there is more to a component than
    that. As we learned in *Chapter 3* , *Structuring User Interfaces with Components*
    , a component has a public API consisting of inputs and outputs that should also
    be tested.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we want to test the public API of a component, it makes sense to test
    how it interacts when hosted from another component. Testing such a component
    can be done in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: We can verify that our input binding is correctly set.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can verify that our output binding triggers correctly and that what it emits
    is received.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Suppose that we have the following `bindings.component.ts` file with an input
    and output binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we start writing our tests, we should create a test host component inside
    the `bindings.component.spec.ts` file that is going to use the component under
    test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the setup phase, notice that the `ComponentFixture` is of the `TestHostComponent`
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Our unit tests will validate the behavior of `BindingsComponent` when interacting
    with `TestHostComponent` .
  prefs: []
  type: TYPE_NORMAL
- en: 'The first test checks whether the input binding to the `title` property has
    been applied correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The second test validates whether the `isFavorite` property is wired up correctly
    with the `liked` output event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous test, we query the DOM for the `<button>` element using the
    `nativeElement` property of the `ComponentFixture` class. Then, we click on it
    for the output event to emit. Alternatively, we could have used the `debugElement`
    property to find the button and use its `triggerEventHandler` method to click
    on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding test, we use the `query` method, which accepts a **predicate**
    function as a parameter. The predicate uses the CSS method of the `By` class to
    locate an element by its CSS selector.
  prefs: []
  type: TYPE_NORMAL
- en: As we learned in the *Introducing unit tests in Angular* section, the `debugElement`
    is framework agnostic. If you are sure that your tests will only run in a browser,
    you should go with the `nativeElement` property.
  prefs: []
  type: TYPE_NORMAL
- en: The `triggerEventHandler` method accepts the event name we want to trigger as
    a parameter; in this case, it is the `click` event.
  prefs: []
  type: TYPE_NORMAL
- en: We could have avoided a lot of code if we had only tested the `BindingsComponent`
    , which would still have been valid. But we would have missed the opportunity
    to test it as a real-world scenario. The public API of a component is intended
    to be used by other components, so we should test it in this way.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, the button we use in the template of the `BindingsComponent` is a
    native HTML `<button>` element. If the button was an Angular Material button component,
    we could use an alternate approach for interacting with it, which is the topic
    of the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Testing with a component harness
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Angular CDK library, the core of Angular Material, contains a set of utilities
    that allow a test to interact with a component over a public testing API. Angular
    CDK testing utilities enable us to access Angular Material components without
    relying on their internal implementation using a **component harness** .
  prefs: []
  type: TYPE_NORMAL
- en: 'The process of testing an Angular component using a harness consists of the
    following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@angular/cdk/testing` : The npm package that contains infrastructure for interacting
    with a component harness.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing environment** : The environment in which the component harness test
    will be loaded. The Angular CDK contains a built-in testing environment for unit
    testing with Karma. It also provides a rich set of tools that allow developers
    to create custom testing environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Component harness** : A class that gives the developer access to the instance
    of a component in the browser DOM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To learn how to use component harnesses, we will convert the `<button>` element
    of the `BindingsComponent` into an Angular Material button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet assumes that you have added the Angular Material library
    to the project that you are working on.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start using a component harness from the Angular CDK, we need to import
    the following artifacts from the `@angular/cdk/testing` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we have added the following classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TestbedHarnessEnvironment` : Represents the testing environment for running
    unit tests with Karma.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MatButtonHarness` : The component harness for the Angular Material button
    component. Almost all components of the Angular Material library have a corresponding
    component harness that we can use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are a component library author, the Angular CDK provides all the necessary
    tools for creating harnesses for your UI components.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After we have finished importing all the necessary artifacts, we can write
    our test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding test, the `loader` method of the testing environment accepts
    the `ComponentFixture` instance of the current component as a parameter and returns
    a `HarnessLoader` object. The abstraction that an Angular CDK harness provides
    is based on the concept that it operates on the component fixture, which is an
    abstraction layer on top of the actual DOM element.
  prefs: []
  type: TYPE_NORMAL
- en: We surround the body of the test inside an `async` function because component
    harnesses are promise-based. We use the `getHarness` method of the harness loader
    to load the specific harness for the button component. Finally, we call the `click`
    method of the button component harness to trigger the button click event.
  prefs: []
  type: TYPE_NORMAL
- en: We do not need to call the `detectChanges` method because the Angular CDK component
    harness triggers change detection automatically.
  prefs: []
  type: TYPE_NORMAL
- en: The component harness is a powerful Angular CDK tool that ensures we interact
    with components abstractly and safely during testing.
  prefs: []
  type: TYPE_NORMAL
- en: We have discussed many ways to test a component with a dependency. Now, it is
    time to learn how to test the dependency itself.
  prefs: []
  type: TYPE_NORMAL
- en: Testing services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we learned in *Chapter 5* , *Managing Complex Tasks with Services* , a service
    can inject other services. Testing a standalone service is pretty straightforward:
    we get an instance from the injector and then start to query its public properties
    and methods.'
  prefs: []
  type: TYPE_NORMAL
- en: We are only interested in testing the public API of a service, which is the
    interface that components and other artifacts use. Private properties and methods
    do not have any value when tested because they represent the internal implementation
    of the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two different types of testing that we can perform in a service:'
  prefs: []
  type: TYPE_NORMAL
- en: Testing synchronous and asynchronous operations, such as a method that returns
    a simple array or one that returns an observable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing services with dependencies, such as a method that makes HTTP requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following sections, we will go through each in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Testing synchronous/asynchronous methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we create an Angular service using the Angular CLI, it also creates a
    corresponding test file. Consider the following `async.service.spec.ts` file,
    which is the test file for the `AsyncService` we used earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `AsyncService` is not dependent on anything. It is also provided with the
    root injector of the Angular application, so it passes an empty object to the
    `configureTestingModule` method. We can get an instance of the service we test
    using the `inject` method of the `TestBed` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first test that we can write is pretty straightforward as it calls the
    `setItems` method and inspects its result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Writing a test for synchronous methods, as in the previous case, is usually
    relatively easy; however, things are different when we want to test an asynchronous
    method such as the following.
  prefs: []
  type: TYPE_NORMAL
- en: 'This second test is a bit tricky because it involves an observable. We need
    to subscribe to the `getItems` method and inspect the value as soon as the observable
    is complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The Karma test runner does not know when an observable will complete, so we
    provide the `done` method to signal that the observable has been completed, and
    we can now assert the `expect` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Testing services with dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Testing services with dependencies is similar to testing components with dependencies.
    Every method we saw in the *Testing components* section can be applied similarly;
    however, we follow a different approach when testing a service that injects the
    `HttpClient` service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following `deps.service.ts` file that uses the HTTP client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Angular testing utilities provide two artifacts for mocking HTTP requests in
    unit tests: the `provideHttpClientTesting` function, which provides an HTTP client
    for testing, and the `HttpTestingController` , which mocks the `HttpClient` service.
    We can import both from the `@angular/common/http/testing` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Our tests should not make a real HTTP request. They only need to validate that
    it will be made with the correct options. The following is the first test that
    validates the `getItems` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding test, we create a fake request using the `expectOne` method
    of the `HttpTestingController` that takes a URL as an argument. The `expectOne`
    method creates a mock request object and asserts that only one request is made
    to the specific URL. After we have created our request, we can validate that its
    method is `GET` .
  prefs: []
  type: TYPE_NORMAL
- en: 'We follow a similar approach when testing the `addItem` method, except that
    we need to make sure that the body of the request contains the correct data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'After each test, we make sure that no unmatched requests are pending using
    the `verify` method inside an `afterEach` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In the following section, we continue our journey through the testing world
    by learning how to test a pipe.
  prefs: []
  type: TYPE_NORMAL
- en: Testing pipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we learned in *Chapter 4* , *Enriching Applications Using Pipes and Directives*
    , a pipe is a TypeScript class that implements the `PipeTransform` interface.
    It exposes a `transform` method, which is usually synchronous, which means it
    is straightforward to test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the `list.pipe.ts` file containing a pipe that converts a comma-separated
    string into a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Writing a test is simple. The only thing that we need to do is to instantiate
    an instance of the `ListPipe` class and verify the outcome of the `transform`
    method with some mock data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Angular testing utilities are not involved when testing a pipe. We create an
    instance of the pipe class, and we can start calling the `transform` method.
  prefs: []
  type: TYPE_NORMAL
- en: Angular directives are artifacts that we may not create very often since the
    built-in collection that the framework provides is more than enough; however,
    if we create custom directives, we should also test them. In the following section,
    we will learn how to accomplish this.
  prefs: []
  type: TYPE_NORMAL
- en: Testing directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Directives are usually quite straightforward in their overall shape, being components
    with no view attached. The fact that directives usually work with components gives
    us a good idea of how to proceed when testing them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the `copyright.directive.ts` file that we created in *Chapter 5* ,
    *Enriching Applications Using Pipes and Directives* :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'A directive is usually used with a component, so it makes sense to unit test
    it while using it on a component. Let’s create a test host component and add it
    to the `imports` array of the testing module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now write our tests that check whether the `<span>` element contains
    the `copyright` class and displays the current year in its `textContent` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This is how simple it can be to test a directive. The key takeaways are that
    you need a component to place the directive on and that you implicitly test the
    directive using the component.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will learn how to test reactive forms.
  prefs: []
  type: TYPE_NORMAL
- en: Testing forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in *Chapter 10* , *Collecting User Data with Forms* , forms are integral
    to an Angular application. It is rare for an Angular application not to have at
    least one simple form, such as a search form. In this chapter, we will focus on
    reactive forms because they are easier to test than template-driven forms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following `search.component.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding component, we can write our unit tests to verify that:'
  prefs: []
  type: TYPE_NORMAL
- en: The value of the `searchText` form control can be set correctly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Search` button is disabled when the form is invalid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `console.log` method is called when the form is valid, and the user clicks
    the **Search** button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To test a reactive form, we first need to import `ReactiveFormsModule` into
    the testing module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'For the first test, we need to assert whether the value propagates to the `searchText`
    form control when we type something into the input control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding test, we use the `querySelector` method of the `nativeElement`
    property to find the `<input>` HTML element and set its value. But this alone
    will not be sufficient for the value to propagate to the form control. The Angular
    framework will not know whether the value of the `<input>` HTML element has changed
    until we trigger the `input` DOM event to that element. We are using the `dispatchEvent`
    method to trigger the event, which accepts a single method as a parameter that
    points to an instance of the `CustomEvent` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we are sure that the `searchText` form control is wired up correctly,
    we can use it to write the remaining tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Note that in the second test, we set the value of the `searchText` form control,
    and then we call the `detectChanges` method for the button to be enabled. Clicking
    on the button triggers the `submit` event of the form, and we can finally assert
    the expectation of our test.
  prefs: []
  type: TYPE_NORMAL
- en: 'In cases where a form has many controls, it is not convenient to query them
    inside our tests. Alternatively, we can create a `Page` object that takes care
    of querying HTML elements and spying on services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We can then create an instance of the `Page` object in the `beforeEach` statement
    and access its properties and methods in our tests.
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen, reactive forms are very easy to test since the form model is
    the single source of truth. In the following section, we will learn how to test
    parts of an Angular application that use the router.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Testing code interacting with the Angular router could easily be a separate
    chapter. In this section, we will focus on the following router concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Routed and routing components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Guards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resolvers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s see first how to test routed and routing components.
  prefs: []
  type: TYPE_NORMAL
- en: Routed and routing components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A routed component is a component that is activated when we navigate to a specific
    application route. Consider the following `app.routes.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The `RoutedComponent` class is defined in the following `routed.component.ts`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The preceding component binds the value of the `title` component property to
    a `<span>` HTML element. The test we will write will assert if the binding works
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular router testing is based on the component harness approach we learned
    about in the *Testing components* section. It exposes the `RouterTestingHarness`
    class, which contains various utility methods for working with routed components
    in tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we can start testing a routed component, we must register the application
    routing configuration in the testing module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding setup process, we provide the application routing configuration
    as in the `app.config.ts` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already learned that we can query the DOM of the native HTML element
    from the `ComponentFixture` class. When a component is loaded using the router,
    we use the `routeNativeElement` property instead from the `RouterTestingHarness`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding test is separated into the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We use the `create` method of the `RouterTestingHarness` to create a new routing
    harness for our component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We navigate to the registered route path using the `navigateByUrl` method. According
    to the application routing configuration, the `/routed` URL will activate the
    component under test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use standard query methods of the `routeNativeElement` property to verify
    that the `<span>` HTML element displays the correct text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `RouterTestingHarness` class also contains the `routeDebugElement` property,
    which works cross-platform similarly to the `debugElement` property of the `ComponentFixture`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'A routing component is a component that is used to navigate to another component
    in an Angular application. It usually involves calling the `navigate` method of
    the `Router` service as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'According to the preceding snippet, our test should verify that the router
    will navigate to the root path when we call the `goBack` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding test, we use the `inject` method of the `TestBed` class to
    get a reference to the `Router` service. We then access the `url` property to
    verify that the navigation process was completed correctly.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will learn how to test router guards.
  prefs: []
  type: TYPE_NORMAL
- en: Guards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We learned in *Chapter 9* , *Navigating through Applications with Routing* ,
    that router guards are plain functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following guard that checks the authentication status of a user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding guard, we check the `isLoggedIn` property of the following
    `AuthService` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: We decided to keep the `AuthService` class simple and focus on the logic of
    the authentication guard.
  prefs: []
  type: TYPE_NORMAL
- en: If the `isLoggedIn` property is `true` , the guard also returns `true` . Otherwise,
    it executes the `parseUrl` method of the `Router` service to redirect users to
    the root path.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Angular CLI has created the following unit test for the guard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, the `executeGuard` variable encapsulates the creation
    of the `authGuard` function. It uses the `runInInjectionContext` method of the
    `TestBed` class to allow the injection of required services using the `inject`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create unit tests that validate the usage of the authentication guard, we
    must execute the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `import` statement of the `@angular/router` npm package as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following `import` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the following variables that correspond to the injected services:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize the preceding variables in the `beforeEach` statement of the test
    suite:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding snippet, we use the `createSpyObj` method to create a spy object
    for the `Router` service and provide it to the testing module. Additionally, we
    get the instance of the actual `AuthService` class using the `inject` method of
    the `TestBed` class because it is a simple service with no dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first unit test should assert that the guard execution returns `true` when
    the user is authenticated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We pass an empty object for the `ActivatedRouteSnapshot` and `RouterStateSnapshot`
    parameters because they are unnecessary in the guard.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second unit test should verify that the guard execution causes a redirection
    to the root path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the following section, we will learn how to test guard resolvers.
  prefs: []
  type: TYPE_NORMAL
- en: Resolvers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Router resolvers are plain functions of a specific type similar to guards. The
    most common scenario when testing resolvers is to verify that the returned data
    is correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following resolver, which returns a list of items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The resolver uses the `AsyncService` we saw earlier, which returns an observable
    of items using the `getItems` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Angular CLI will initially create the following unit test file when scaffolding
    the resolver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, the `executeResolver` variable encapsulates the creation
    of the `itemsResolver` function, similar to how it does with guards. It also uses
    the `runInInjectionContext` method of the `TestBed` class to allow the injection
    of required services.
  prefs: []
  type: TYPE_NORMAL
- en: 'The logic of our resolver is very simple, so we must write a single unit test:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `import` statement of the `@angular/router` npm package as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following `import` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the type of the `executeResolver` variable to `ResolveFn<string[]>`
    so that it matches the signature of the `itemsResolver` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write the following unit test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To verify that the resolver returns correct data, we must subscribe to the `executeResolver`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to unit test some important features of the
    Angular router.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are at the end of our testing journey, and it’s been a long but exciting
    one. In this chapter, we saw the importance of introducing unit testing in our
    Angular applications, the basic shape of a unit test, and the process of setting
    up Jasmine for our tests.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned how to write robust tests for our components, directives, pipes,
    and services. We also discussed how to test Angular reactive forms and the router.
  prefs: []
  type: TYPE_NORMAL
- en: This unit testing chapter has almost completed the puzzle of building a complete
    Angular application. Only the last piece remains, which is important because web
    applications are ultimately destined for the web. Therefore, in the next chapter,
    we will learn how to produce a production build for an Angular application and
    deploy it to share with the rest of the world!
  prefs: []
  type: TYPE_NORMAL
