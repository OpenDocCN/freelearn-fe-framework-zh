- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What Changes in React Query v5?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the time of writing, version 5.0.0-alpha.1 of @tanstack/react-query has just
    been released. While it might take a couple of weeks for the stable version to
    be released, when this book is published, it might already be the version that
    installs by default every time you add React Query to your project.
  prefs: []
  type: TYPE_NORMAL
- en: To make sure you understand the changes that the content of this book may undergo
    after v5 is released, this bonus chapter was added.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter might also serve as a helper to guide you when migrating from v4
    to v5.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, as a disclaimer, *the snippets of this chapter were tested on version
    5.0.0-alpha.1 of @tanstack/react-query. Some of these things might still change,
    or some new ones might show up*. Either way, the snippets will be kept updated
    online in the next couple of months until a stable version is released. You can
    find them on the GitHub repository mentioned in the *Technical* *requirements*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be aware of all the changes in React Query
    v5 that will have an impact on some of the things in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What are the support changes?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using only the object format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing the logger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Renaming `loading` to `pending`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Renaming `cacheTime` to `gcTime`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Renaming `Hydrate` to `HydrationBoundary`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing `keepPreviousData` and using `placeholderData`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing a new way to do optimistic updates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing `maxPages` to infinite queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_9](https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_9).
  prefs: []
  type: TYPE_NORMAL
- en: What are the support changes?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing to be aware of here is that the browser support has changed.
    From v5, your browser needs to be compatible with the following configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: The Google Chrome version needs to be at least version 84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Mozilla Firefox version needs to be at least version 90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Microsoft Edge version needs to be at least version 84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Safari version needs to be at least version 15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Opera version needs to be at least version 70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we know the support changes, let's see what features changed from v4
    to v5, starting with the object format for custom hooks and functions.
  prefs: []
  type: TYPE_NORMAL
- en: Using only the object format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In v4 of React Query, most custom hooks and functions were overloaded to support
    previous patterns. This means that in your code, both of the `useQuery` hooks
    in the following snippet would be the same thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding snippet, we create a query with `queryKey`
    `["api"]` and `queryFn` `fetchData` twice. This is because the second and first
    examples are just instances of the same hook that has been overloaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the introduction of v5, the second example shown in the preceding snippet
    is no longer supported; therefore, you can only use your hooks by passing them
    a single object with the needed options. Here is the syntax that you need to follow
    from now on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the preceding snippet, we have three React Query hooks,
    and each one of them receives a couple of things:'
  prefs: []
  type: TYPE_NORMAL
- en: The `useQuery` and `useInfiniteQuery` hooks need to receive `queryKey` and `queryFn`
    as required parameters. These hooks allow you to pass them some of the options
    you should already know from the previous chapters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `useMutation` hook needs to receive `mutationFn` as a required parameter.
    It also allows you to pass it some of the options we learned about in [*Chapter
    6*](B18501_06.xhtml#_idTextAnchor159) when we saw what options our `useMutation`
    hook receives.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Luckily, throughout the book, we followed the object approach right from the
    beginning, so you should have followed the right approach from the start and won’t
    suffer much from the change.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to be aware of is that this change applies to the `queryClient`
    functions. Functions such as `invalidateQueries`, `refetchQueries`, and `prefetchQuery`
    must also receive the expected object.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know about the single object format, we can look at one thing that
    was removed in v5 – `logger`.
  prefs: []
  type: TYPE_NORMAL
- en: Removing the logger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, React Query logged failed queries to the console in the production
    environment. This quickly became an issue because our application users could
    see implementation detail errors that they shouldn’t be aware of. To deal with
    this issue, the ability to create a custom logger was added, where you could override
    what React Query used for logging.
  prefs: []
  type: TYPE_NORMAL
- en: Recently, React Query removed all logging in production and improved their development
    logs. Given this scenario, in v5, `logger` was no longer needed and was removed.
  prefs: []
  type: TYPE_NORMAL
- en: From now on, `console` will be used as the default logger.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know this change, let's see the first renaming of v5 – `loading`
    to `pending`.
  prefs: []
  type: TYPE_NORMAL
- en: Renaming loading to pending
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `loading` status has caused some confusion. This is because most people
    associate it with data loading; secondly, if your query is disabled due to having
    the `enabled` option as `false`, it will show up as `loading`. To avoid more confusion
    and have a clearer name, the `loading` status has been renamed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the changes that have been applied:'
  prefs: []
  type: TYPE_NORMAL
- en: The `loading` status has been renamed `pending`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The derived `isLoading` status has been renamed `isPending`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new derived `isLoading` flag has been added, which basically translates as
    the `isPending &&` `isFetching` expression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Considering that there was already a flag doing the same thing called `isInitialLoading`,
    the `isInitialLoading` flag has been deprecated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let us now review `ComponentA`, which we saw in [*Chapter 4*](B18501_04.xhtml#_idTextAnchor091),
    and apply these changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding snippet, all we have to do is rename `isLoading`
    `isPending`.
  prefs: []
  type: TYPE_NORMAL
- en: As for the behavior, it is also the same. What we have to be aware of here is
    that after the first query mounts when we don’t have data, our `status` query
    will be `pending` instead of `loading`, as it was previously.
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, we can move to the next renaming of v5 – `cacheTime` is now
    `gcTime`.
  prefs: []
  type: TYPE_NORMAL
- en: Renaming cacheTime to gcTime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This was one of the changes I’m most personally happy about because it is probably
    the most misunderstood option in React Query. Most often, it is assumed that `cacheTime`
    means the length of time that data will be cached instead of what it really means,
    which is the time that inactive data in the cache will remain in memory.
  prefs: []
  type: TYPE_NORMAL
- en: To stop this misconception, the `cacheTime` option has been renamed `gcTime`.
    This is because `gc` is often a shortened way to refer to the garbage collector.
    Therefore, from now on, we explicitly declare the time until our data is garbage-collected.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use it, all you need to do is add the `gcTime` option to your `useQuery`/`useMutation`
    hook, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the snippet, we define that after our query is inactive for one minute, the
    data will be garbage-collected.
  prefs: []
  type: TYPE_NORMAL
- en: To wrap up the renaming spree, let us see how our `Hydrate` component changed.
  prefs: []
  type: TYPE_NORMAL
- en: Renaming Hydrate to HydrationBoundary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using the hydrate pattern in SSR, the `Hydrate` component was not fully
    descriptive about what it meant. To make it more concise and match other boundaries
    defined in TanStack Query, it was renamed `HydrationBoundary`. Due to this, you
    now have to rename it in your Next.js or Remix code.
  prefs: []
  type: TYPE_NORMAL
- en: Let us now see how the snippets change.
  prefs: []
  type: TYPE_NORMAL
- en: Next.js hydrate pattern renaming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is what our Next.js `_app` component will look like now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding snippet, all we have to do is rename `Hydrate`
    to `HydrationBoundary`. Everything else remains the same.
  prefs: []
  type: TYPE_NORMAL
- en: Remix hydrate pattern changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is what our Remix root component will look like now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding snippet, and just as we saw in the Next.js
    example, all we have to do is rename `Hydrate` to `HydrationBoundary`. Everything
    else remains the same.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know this change, let us look at something that impacted how we
    do paginated queries.
  prefs: []
  type: TYPE_NORMAL
- en: Removing keepPreviousData and using placeholderData
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `keepPreviousData` option and the `isPreviousData` flags have been removed.
    This is because they did almost the same task as the `placeholderData` option
    and the `isPlaceholderData` flag.
  prefs: []
  type: TYPE_NORMAL
- en: So that `placeholderData` can fully do exactly the same thing as `keepPreviousData`,
    the previous query data was added as an argument to the `placeholderData` function.
    This now means that by leveraging the `keepPreviousData` custom function from
    React Query, `useQuery` will allow `placeholderData` to work the same way as `keepPreviousData`
    did previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see how our `PaginatedQuery` code changes in v5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we changed our `PaginatedQuery` component to adapt
    to the changes necessary due to the removal of the `keepPreviousData` option.
    This is what we do:'
  prefs: []
  type: TYPE_NORMAL
- en: We import our `keepPreviousData` helper from React Query.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since we need to refactor the component, we rename `isLoading` to `isPending`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We rename `isPreviousData` to `isPlaceholderData`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We rename the `keepPreviousData` option to `placeholderData` and pass it the
    `keepPreviousData` helper.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, v5 did not only remove and rename things. It also added some new things,
    including a new way to perform optimistic updates.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing a new way to perform optimistic updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When performing optimistic updates, you must always be careful about the changes
    you make to your cache. One typo or mistake might accidentally impact other queries
    outside of the one you want to change initially.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, with v5, TanStack Query has introduced a way to perform optimistic
    updates where you can fully rely on your UI and stop changing your cache.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we can see the new way React Query allows us to perform
    optimistic updates. This is what we do:'
  prefs: []
  type: TYPE_NORMAL
- en: Create state variables and respective setters for the name and age inputs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get access to our `queryClient`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create our query, using the query factory `all` function to give us the query
    key and `fetchAllData` as the `query` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create our mutation, using `createUser` as the mutation function. Inside this
    mutation, we leverage the `onSettled` callback to invalidate our query.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In our component return, we create `div` with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use `data` from our query to display our users’ data.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We use our mutation `isPending` flag to let us know whether we have any mutation
    currently being performed. If this flag is `true`, we can access and render our
    `mutation` variables on the DOM.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We create our controlled form with our name and age inputs.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We also create a button that, upon `onClick`, will trigger our mutation with
    our name and age values.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see now, we can perform mutations without changing our query cache
    data. This is super powerful and can save you a lot of unintentional headaches
    caused by messing up your cache.
  prefs: []
  type: TYPE_NORMAL
- en: By checking the code of the preceding snippet, one thing you might wonder is
    whether the mutation lives on the same component as the query. Does this mean
    that if you have a mutation that lives outside of the same place of your query,
    you won’t be able to perform optimistic updates this way? It does not.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a mutation performing somewhere else and want to perform an optimistic
    update, you can leverage the `useMutationState` custom hook.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we have the `NewOptimisticMutationV2` component. In
    this component, we perform an optimistic update outside the component where your
    mutation lives. In this component, we render our query data and have the component
    where our mutation happens, called `MutationForm`, rendered as a child component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what we do in the `NewOptimisticMutationV2` component:'
  prefs: []
  type: TYPE_NORMAL
- en: Create our query, using our query factory `all` function to give us the query
    key and `fetchAllData` as the `query` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get access to our mutation by using the `useMutationState` hook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this hook, we access a mutation currently with the pending status and the
    `mutationKey` `userKeys.userMutation()` that comes from our query factory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, leverage the `select` option from the `useMutationState` hook to get the
    `mutation` variables and the `submittedAt` property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In our component return, we create a `div` with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use `data` from our query to display our users’ data.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If we have any mutation currently being performed, we can access and render
    our `mutation` variables on the DOM.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'I mentioned in the previous description that the mutation needs to have `mutationKey`
    to be able to be found. This is how to add it to your mutation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding snippet, we added the `userKeys.userMutation()`
    key from our query factory and added it to our `useMutation` hook’s `mutationKey`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know about the new way to perform optimistic updates, let us see
    what changed in our infinite queries.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing maxPages to infinite queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Infinite queries is an amazing pattern that helps you build infinite lists.
    However, there is one issue with it before v5 – all the fetched pages are cached
    in memory; therefore, the more pages you see, the more memory you consume.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent this from happening and improve your user experience, the `maxPages`
    option was added to the `useInfiniteQuery` hook. This option limits the number
    of pages that will be stored in the query cache.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what our infinite query example, seen in [*Chapter 5*](B18501_05.xhtml#_idTextAnchor140),
    would look like now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we can see our infinite query code refactor after
    v5 and leverage the `maxPages` option. Here is what changed:'
  prefs: []
  type: TYPE_NORMAL
- en: We use `isPending` instead of `isLoading`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `defaultPageParam` option indicates which is the default page that React
    Query will use to fetch the first page. This option is now required, so it was
    added.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We add `5` as our `maxPages` option. This means that only five pages will be
    stored in memory. Since we use this option, the `getPreviousPageParam` option
    is now required so that React Query can fetch pages in both directions if needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this, we have now wrapped up all the relevant changes in React Query v5
    that might impact this book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about all the changes v5 might bring to React Query.
    By now, you should know about the support changes you will need to be aware of
    in your browser and understand why we’ve always followed the object format throughout
    the book.
  prefs: []
  type: TYPE_NORMAL
- en: You’ve seen why `logger` was removed and understand why renaming `loading` to
    `pending` makes more sense.
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of renaming, you won’t be confused again because `gcTime` is a more
    accurate word than `cacheTime`, and `HydrationBoundary` represents better what
    it does than `Hydrate`.
  prefs: []
  type: TYPE_NORMAL
- en: You’ve learned that for paginated queries, the `placeholderData` option is the
    way to go and that `keepPreviousData` was removed.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you were introduced to a new way to perform optimistic updates without
    updating your cache and found a way to save memory in your infinite queries, by
    leveraging the `maxPages` option.
  prefs: []
  type: TYPE_NORMAL
- en: As you may recall from what I said previously, this was tested in an alpha version
    of React Query, so some of these things might still change.
  prefs: []
  type: TYPE_NORMAL
- en: It is exciting to see some of these changes, as they progressively improve the
    library.
  prefs: []
  type: TYPE_NORMAL
- en: Personally, I can’t wait to see what comes next to TanStack Query. With every
    new version, it always finds a new way to make my life easier when dealing with
    server state. Hopefully, it will do the same for you from now on.
  prefs: []
  type: TYPE_NORMAL
