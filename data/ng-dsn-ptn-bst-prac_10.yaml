- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: 'Design for Tests: Best Practices'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试设计：最佳实践
- en: One of the best practices in a software project, be it a frontend or backend
    project, is testing. After all, if you and your team don’t rigorously test your
    system, the people who will inevitably test the system and find possible bugs
    are the users, and we don’t want that.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件项目中，无论是前端还是后端项目，最佳实践之一就是进行测试。毕竟，如果你和你的团队不严格测试你的系统，那么不可避免地测试系统并发现潜在错误的人将是用户，我们不想看到这种情况发生。
- en: For this reason, it is no wonder that the Angular team has, since the first
    versions of the framework, been concerned with creating and integrating automated
    testing tools.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Angular 团队自框架的第一版以来就关注于创建和集成自动化测试工具，这并不奇怪。
- en: We can notice this with the fact that, by default, the Angular CLI always generates,
    together with the component, its test files as if saying, “*Hey, buddy, don’t
    forget the* *unit test!*”
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过默认情况下 Angular CLI 总是与组件一起生成测试文件这一事实来注意到这一点，就好像在说，“嘿，朋友，别忘了*单元测试*！”
- en: 'In this chapter, we will explore this topic by covering the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过以下内容来探讨这个主题：
- en: What to test
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要测试的内容
- en: Service tests
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务测试
- en: Understanding `TestBed`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 `TestBed`
- en: Component testing
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件测试
- en: E2E tests with Cypress
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Cypress 进行端到端测试
- en: At the end of the chapter, you will be able to create tests for your components
    and service, improving the quality of your delivery and your team.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将能够为你的组件和服务创建测试，从而提高你交付的质量和团队的工作效率。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow the instructions in this chapter, you’ll need the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章的说明，你需要以下内容：
- en: Visual Studio Code ([https://code.visualstudio.com/Download](https://code.visualstudio.com/Download))
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code ([https://code.visualstudio.com/Download](https://code.visualstudio.com/Download))
- en: Node.js 18 or higher ([https://nodejs.org/en/download/](https://nodejs.org/en/download/))
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 18 或更高版本 ([https://nodejs.org/en/download/](https://nodejs.org/en/download/))
- en: The code files for this chapter are available at [https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch10](https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch10).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可在 [https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch10](https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch10)
    找到。
- en: During the study of this chapter, remember to run the backend of the application
    found in the `gym-diary-backend` folder with the `npm` `start` command.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习本章的过程中，请记住使用 `npm start` 命令运行位于 `gym-diary-backend` 文件夹中的应用程序的后端。
- en: What to test
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需要测试的内容
- en: Within a software project, we can do several types of tests to ensure the quality
    of the product. In this discipline, it is very common to categorize tests using
    a pyramid.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个软件项目中，我们可以进行多种类型的测试以确保产品的质量。在这个领域，使用金字塔结构对测试进行分类是非常常见的。
- en: '![Figure 10.1 – Test pyramid](img/B19562_10_1.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1 – 测试金字塔](img/B19562_10_1.jpg)'
- en: Figure 10.1 – Test pyramid
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – 测试金字塔
- en: At the base of the pyramid, we have unit tests, whose objective is to verify
    the quality of the smallest elements within a software project, such as functions
    or methods of a class. Due to their narrow scope and atomic nature, they are quickly
    executed by tools and should ideally make up the majority of an application’s
    tests.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在金字塔的底部，我们有单元测试，其目标是验证软件项目中最小元素的质量，例如函数或类的成员方法。由于它们的范围狭窄和原子性，它们可以快速由工具执行，并且理想情况下应该构成应用程序测试的大多数。
- en: In the middle layer, we have integration tests, which are focused on verifying
    how the project components interact with each other, being able, for example,
    to test an API through an HTTP request. Because these tests use more elements
    and need certain environmental requirements, they are less performant and have
    a higher execution cost, which is why we see them in smaller quantities compared
    to unit tests.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在中间层，我们有集成测试，这些测试专注于验证项目组件之间的交互，例如，可以通过 HTTP 请求测试一个 API。因为这些测试使用更多元素并需要一定的环境要求，所以它们的性能较低，执行成本较高，这也是为什么与单元测试相比，我们看到的数量较少的原因。
- en: At the top of the pyramid, we have **end-to-end tests** (**E2E tests**), which
    validate the system from the user’s point of view, emulating their actions and
    behaviors. These tests require an almost complete environment, including a database
    and servers. In addition, they are slower and therefore there are fewer of them
    compared to the previous ones.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在金字塔的顶端，我们有 **端到端测试**（**E2E 测试**），这些测试从用户的角度验证系统，模拟他们的动作和行为。这些测试需要一个几乎完整的环境，包括数据库和服务器。此外，它们运行较慢，因此与之前的测试相比，它们的数量更少。
- en: Finally, we have manual and exploratory tests, which are tests performed by
    quality analysts. Ideally, these tests will serve as a basis for the creation
    of E2E tests, mainly on new features. As they are run by humans, they are the
    most expensive, but they are the best for discovering new bugs in new features.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有手动和探索性测试，这些是由质量分析师执行的测试。理想情况下，这些测试将作为创建端到端测试的基础，主要针对新功能。由于它们是由人类运行的，因此成本最高，但它们对于发现新功能中的新错误是最好的。
- en: It is important to highlight that no test is better or more important than another.
    Here, we have the classification by volume of test executions in a period of time.
    You and your team must identify which tests to prioritize based on the capacity
    and resources available for your project. These types of tests can be applied
    to any type of software project, but you must be wondering how we fit this concept
    into an Angular project.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 需要强调的是，没有哪个测试比另一个更好或更重要。在这里，我们有根据一段时间内测试执行量进行的分类。你和你的团队必须根据项目可用的能力和资源来确定哪些测试需要优先考虑。这些类型的测试可以应用于任何类型的软件项目，但你可能想知道我们如何将这个概念应用到
    Angular 项目中。
- en: The concept of manual testing can be applied without tools because what we need
    is a quality analyst and an application with a complete environment, that is,
    the backend services responding to our application.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 手动测试的概念可以不使用工具来应用，因为我们需要的只是一个质量分析师和一个具有完整环境的应用程序，即后端服务对我们的应用程序做出响应。
- en: E2E tests are performed by specific tools that simulate user behavior. Up to
    version 14, Angular already had a built-in tool called **Protractor**, but the
    Angular team no longer recommends it because there are more modern, faster alternatives.
    In this chapter, we are going to use **Cypress** for this purpose.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试是由模拟用户行为的特定工具执行的。截至版本 14，Angular 已经有一个内置工具叫做 **Protractor**，但 Angular 团队不再推荐它，因为现在有更多现代、更快的替代品。在本章中，我们将使用
    **Cypress** 来实现这一目的。
- en: Finally, unit tests are performed on the methods of our services and components,
    verifying their behavior.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，单元测试是对我们的服务和组件的方法进行的，以验证其行为。
- en: 'In the Angular toolbox, we have two tools for creating and running these tests:
    Jasmine and Karma. These tools are installed by default when we start a new project.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 工具箱中，我们有两个用于创建和运行这些测试的工具：Jasmine 和 Karma。这些工具在我们启动新项目时默认安装。
- en: Jasmine is a testing framework that has several checking functions, in addition
    to providing the ability to change the functionality of a method or class at runtime
    with an element called a **spy**. For the execution of unit tests, the Karma tool
    is used, which has the characteristic of running tests in a browser, giving the
    team the ability to analyze the behavior of the application in different types
    of environments. Although rare nowadays, we may have some bugs depending on the
    browser it runs on.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine 是一个具有多个检查功能的测试框架，除了提供使用称为 **spy** 的元素在运行时更改方法或类功能的能力外。对于单元测试的执行，我们使用
    Karma 工具，它具有在浏览器中运行测试的特征，这使得团队能够分析应用程序在不同类型环境中的行为。尽管现在很少见，但我们可能有一些依赖于它所运行的浏览器的错误。
- en: 'To use these two tools, we don’t need any configuration of our project; we
    just need to execute the following command in the command line of our operating
    system:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这两个工具，我们不需要对我们的项目进行任何配置；我们只需要在我们的操作系统命令行中执行以下命令：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once we execute the preceding command, we get a compilation error. This happens
    because, until then, Angular only compiled the files of our components and ignored
    the test files because they will not be deployed to users in the final version.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们执行前面的命令，就会得到一个编译错误。这是因为，在此之前，Angular 只编译了我们的组件文件，而忽略了测试文件，因为它们不会在最终版本中部署给用户。
- en: 'Running the test, we notice that we have an error in the `diary.resolver.spec.ts`
    test file, so let’s make a correction:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试时，我们注意到我们在`diary.resolver.spec.ts`测试文件中有一个错误，所以让我们进行修正：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The test generated by the Angular CLI contains all of Jasmine’s boilerplate.
    In the `describe` function, we define our test case, which is a test group that
    we will create.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由 Angular CLI 生成的测试包含所有 Jasmine 的样板代码。在 `describe` 函数中，我们定义我们的测试用例，这是一个我们将创建的测试组。
- en: This function has, in the first parameter, a string that represents the name
    of the test case and will even identify it in reports.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的第一个参数是一个字符串，表示测试用例的名称，它甚至会在报告中识别它。
- en: In the second parameter, we have the function where we will have the preparation
    and the tests. Here, we made a correction because the resolver we want to test
    returns an object of type `ExerciseSetList` and not a Boolean as it was before.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个参数中，我们有准备和测试的函数。在这里，我们进行了一个修正，因为我们想要测试的解析器返回的是 `ExerciseSetList` 类型的对象，而不是之前作为布尔值返回。
- en: On the next line, we have the `TestBed` class, which is the most fundamental
    element of Angular tests.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行，我们有 `TestBed` 类，这是 Angular 测试中最基本元素。
- en: This framework class has the function of preparing the Angular execution environment
    for the tests to run. We will see in the following sections its use in different
    situations.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这个框架类具有为测试运行准备 Angular 执行环境的函数。我们将在以下章节中看到它在不同情况下的使用。
- en: The `beforeEach` function has the objective of performing some common action
    before executing the tests.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`beforeEach` 函数的目的是在执行测试之前执行一些常见操作。'
- en: Finally, the `it` function is where we will create the tests. Inside a `describe`
    function, we can have numerous functions of the `it type`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`it` 函数是我们创建测试的地方。在一个 `describe` 函数内部，我们可以有多个 `it` 类型的函数。
- en: 'If we run Karma again, the browser will open, and we can follow the execution
    of the tests:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次运行 Karma，浏览器将打开，我们可以跟踪测试的执行过程：
- en: '![Figure 10.2 – Execution of tests by Karma](img/B19562_10_2.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2 – Karma 执行测试](img/B19562_10_2.jpg)'
- en: Figure 10.2 – Execution of tests by Karma
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – Karma 执行测试
- en: As this project already had the tests when we created the elements of our application,
    we have some broken tests that we will correct in the next sections, but the important
    thing now is for us to understand how to run the unit tests of our application.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在创建应用程序元素时，这个项目已经有了测试，因此我们有一些损坏的测试将在下一节中修复，但现在对我们来说重要的是要了解如何运行我们应用程序的单元测试。
- en: In the next section, we’ll learn how to create tests for our project’s services.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何为我们的项目服务创建测试。
- en: Service tests
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务测试
- en: As we studied in detail in [*Chapter 5*](B19562_05.xhtml#_idTextAnchor163),
    *Angular Services and the Singleton Pattern*, the service that works as a repository
    of business rules in an Angular application. Consequently, it is crucial for us
    to develop unit tests for these services. In this section, we will focus on the
    `ExerciseSetsService` service to illustrate the Angular unit testing techniques
    in our project. Let’s begin.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 [*第5章*](B19562_05.xhtml#_idTextAnchor163) 中详细研究的，*Angular 服务和单例模式*，Angular
    应用程序中作为业务规则存储库工作的服务。因此，对我们来说，为这些服务开发单元测试至关重要。在本节中，我们将专注于 `ExerciseSetsService`
    服务，以展示我们在项目中使用的 Angular 单元测试技术。让我们开始吧。
- en: 'In the `exercise-sets.service.spec.ts` test file, let’s start by fixing the
    tests automatically created by the Angular CLI that are not running correctly:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `exercise-sets.service.spec.ts` 测试文件中，让我们首先修复由 Angular CLI 自动创建但运行不正确的测试：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As we want to work on service testing, at this time, we replace the `describe`
    function with the `fdescribe` function, so the Karma test runner will only execute
    this test case. The `fdescribe` feature is also available for isolating a specific
    test, in this case replacing the `it` function with the `fit` function. To fix
    the error identified by the Angular compiler, we import the `'HttpClientTestingModule'`
    module in the `TestBed` component.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要进行服务测试，因此在此阶段，我们将 `describe` 函数替换为 `fdescribe` 函数，这样 Karma 测试运行器将只执行这个测试用例。`fdescribe`
    功能也可以用于隔离特定的测试，在这种情况下，将 `it` 函数替换为 `fit` 函数。为了修复 Angular 编译器识别出的错误，我们在 `TestBed`
    组件中导入 `'HttpClientTestingModule'` 模块。
- en: We need to understand how Karma, Jasmine, and Angular work together to run tests.
    Before each test case is defined in `it` functions, Angular sets up an isolated
    environment for the tests. This environment has virtually no module configuration
    at first, as your real application has, and the `TestBed` component comes into
    play, where we configure the minimum necessary dependencies for your test to run.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要了解Karma、Jasmine和Angular如何协同工作以运行测试。在`it`函数中定义每个测试案例之前，Angular为测试设置一个隔离的环境。最初，这个环境几乎没有模块配置，就像您的真实应用程序一样，`TestBed`组件开始发挥作用，在那里我们配置测试运行所需的最小必要依赖项。
- en: In this service, as it depends on `HttpClient` to perform HTTP requests, we
    need to import the `HttpClientModule` module to have this dependency. You might
    be wondering, “But here you are using `HttpClientTestingModule`. Is this correct?”
    As we will see in the following code, not only will we want to use `HttpClient`
    but we will also need to simulate HTTP calls, and to make this task easier, the
    Angular team has prepared a specific module for this type of testing.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个服务中，因为它依赖于`HttpClient`来执行HTTP请求，所以我们需要导入`HttpClientModule`模块来拥有这个依赖项。您可能会想，“但在这里您正在使用`HttpClientTestingModule`。这是正确的吗？”正如我们将在下面的代码中看到的那样，我们不仅想要使用`HttpClient`，我们还需要模拟HTTP调用，为了使这项任务更容易，Angular团队已经为这种类型的测试准备了一个特定的模块。
- en: 'With our basic “should be created” test case in place, let’s test the methods
    of the class:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的基本“应该被创建”测试案例就绪后，让我们测试类的这些方法：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see from the preceding code, this service is designed to handle requests
    related to gym diary entries. In the initial method, `getInitialList`, our objective
    is to verify whether the service accurately initiates an HTTP request to the backend
    using the `GET` method. By creating a new case with the `it` function in the first
    parameter, we place a description of the test case that will be important for
    viewing during test execution. The test function, unlike the “should be created”
    test case, is contained within the `fakeAsync` function created by the Angular
    team to facilitate the testing of asynchronous methods, such as an HTTP request.
    Inside the function, we begin to assemble our test. Here, we need to define what
    the structure of a unit test looks like.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的代码中可以看到，此服务旨在处理与健身日记条目相关的请求。在初始方法`getInitialList`中，我们的目标是验证服务是否准确使用`GET`方法向后端发起HTTP请求。通过在第一个参数中使用`it`函数创建一个新的案例，我们放置了一个在测试执行期间将重要的测试案例描述。与“应该被创建”的测试案例不同，测试函数包含在Angular团队创建的`fakeAsync`函数中，以方便测试异步方法，如HTTP请求。在函数内部，我们开始组装我们的测试。在这里，我们需要定义单元测试的结构看起来是什么样子。
- en: 'A unit test consists of three parts:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试由三个部分组成：
- en: The test setup, where we prepare all the elements for the tests to take place
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试设置，其中我们准备所有测试所需的元素
- en: The execution of the method to be executed
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行要执行的方法
- en: The test assertion, where we compare the execution result with the expected
    return
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试断言，其中我们比较执行结果与预期的返回值
- en: In this test case, part of the setup was done in the `beforeEach` function,
    but note that, instead, we must put the setup common to all test cases that will
    be executed to avoid slowdowns in the test cases. In the test in question, we
    defined a fake return from our server, since the unit tests must be executed independently
    of the backend service. In the execution phase, we call the service with the `getInitialList`
    method.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试案例中，部分设置是在`beforeEach`函数中完成的，但请注意，相反，我们必须放置所有将要执行的测试案例的共同设置，以避免测试案例中的减速。在所讨论的测试中，我们定义了一个来自服务器的模拟返回值，因为单元测试必须独立于后端服务执行。在执行阶段，我们使用`getInitialList`方法调用服务。
- en: We call the `subscribe` method of the observable that the service returns, and
    inside it, we make the assertion that we expect the return to be equal to the
    item element of the `fakeBody` object. Here, the assertion phase can be tricky
    because, to check the return of this observable, we need to simulate the backend
    processing of the project.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用服务返回的可观察对象的`subscribe`方法，并在其中，我们做出预期的返回值等于`fakeBody`对象的`item`元素的断言。在这里，断言阶段可能很棘手，因为为了检查这个可观察对象的返回值，我们需要模拟项目的后端处理。
- en: Enter the Angular `HttpTestingController` service, with which we can emulate
    a response from our backend service. Here, we also create an assertion to ensure
    that our method is calling the API with the `GET` HTTP verb. In order to simulate
    the HTTP request , we use the `flush` method of the service and what we want to
    send – in this case, the `fakebody` object. But we need to remember that an HTTP
    operation is asynchronous so we use the `tick` function, available within the
    context of the `fakeAsync` function, to simulate the time that would pass for
    an asynchronous execution.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 进入 Angular 的 `HttpTestingController` 服务，我们可以用它来模拟后端服务的响应。在这里，我们还创建了一个断言来确保我们的方法正在使用
    `GET` HTTP 动词调用 API。为了模拟 HTTP 请求，我们使用服务的 `flush` 方法以及我们想要发送的内容——在这种情况下，是 `fakebody`
    对象。但我们需要记住，HTTP 操作是异步的，所以我们使用 `fakeAsync` 函数上下文中的 `tick` 函数来模拟异步执行所需的时间。
- en: 'We will create a test for the same service to simulate the creation of a new
    entry:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为同一服务创建一个测试来模拟创建新条目的过程：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We start with the definition of the new test that will appear in Karma and then
    we create the test function, again within the context of the `fakeAsync` function.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义将在 Karma 中出现的新测试，然后我们在 `fakeAsync` 函数的上下文中创建测试函数。
- en: In the test setup, we define an object called `fakeBody` with the payload we
    want to send and make the assertion. In the execution phase of the method we want
    to test, we call the `addNewItem` method and place the assertion inside the `subscribe`
    function. We perform the assertion of the `POST verb`, and finally, we simulate
    the request using the `flush` and `tick` functions.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试设置中，我们定义了一个名为 `fakeBody` 的对象，其中包含我们想要发送的有效负载，并进行断言。在我们要测试的方法的执行阶段，我们调用 `addNewItem`
    方法，并在 `subscribe` 函数内放置断言。我们执行 `POST` 动词的断言，最后，我们使用 `flush` 和 `tick` 函数模拟请求。
- en: 'To end this session, let’s switch the `fdescribe` function to the `describe`
    function. In the test file of the `ExercisesService`, `AuthInterceptor`, and `AuthService`
    services, let’s make the following change:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束这次会议，让我们将 `fdescribe` 函数切换到 `describe` 函数。在 `ExercisesService`、`AuthInterceptor`
    和 `AuthService` 服务的测试文件中，让我们进行以下更改：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As we saw in this section, we need to inform Angular of the test’s dependency,
    that is, declaring `HttpClientTestingModule` in the configuration of the `TestBed`
    component.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本节中看到的，我们需要通知 Angular 测试的依赖项，即在 `TestBed` 组件的配置中声明 `HttpClientTestingModule`。
- en: 'We still have to correct the test of the `NotificationInterceptor` service,
    which uses an external library as a dependency. We will refactor the `notification.interceptor.spec.ts`
    file as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要纠正 `NotificationInterceptor` 服务的测试，该服务使用外部库作为依赖项。我们将按照以下方式重构 `notification.interceptor.spec.ts`
    文件：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the case of general dependencies that we need to simulate in our tests, we
    can define the service in the `providers` property in the `TestBed` class definition.
    But instead of offering the original `ToastrService` class, we declare an object
    and, using the `useValue` property, it tells Angular which class to provide for
    the test.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们需要在测试中模拟的一般依赖项的情况下，我们可以在 `TestBed` 类定义中的 `providers` 属性中定义该服务。但不是提供原始的 `ToastrService`
    类，我们声明一个对象，并使用 `useValue` 属性告诉 Angular 为测试提供哪个类。
- en: Here, we could create a class that has the same original methods, but better
    than that, we are using a feature of the Jasmine test framework, which is the
    spy objects. With them, we can mock entire classes for our tests, thus managing
    to simulate unit test dependencies.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以创建一个具有相同原始方法但更好的类，但更好的是，我们正在使用 Jasmine 测试框架的一个特性，即间谍对象。通过它们，我们可以为我们的测试模拟整个类，从而成功地模拟单元测试依赖项。
- en: In the next section, we’ll fix all the tests and understand how Angular’s `TestBed`
    component works.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将修复所有测试并了解 Angular 的 `TestBed` 组件是如何工作的。
- en: Fixing the tests and understanding TestBed
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复测试和了解 TestBed
- en: 'To better understand the use of `TestBed`, we’ll fix the rest of our project’s
    tests by adding dependencies to the test files. We’ll start with the `app.component.spec.ts`
    file and make the fixes as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解 `TestBed` 的使用，我们将通过向测试文件添加依赖项来修复我们项目的其余测试。我们将从 `app.component.spec.ts`
    文件开始，并按照以下方式进行修复：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this test, we cleaned up the test cases that had already been created by
    the Angular CLI when we started the project. It has the `router-outlet` component
    so we need to mock Angular’s route services. Like the `HttpClient` service, the
    Angular team has also prepared a specific module for testing, and so we are importing
    the `RouterTestingModule` module here.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们清理了Angular CLI在项目启动时已经创建的测试用例。它有`router-outlet`组件，因此我们需要模拟Angular的路由服务。像`HttpClient`服务一样，Angular团队也为测试准备了一个特定的模块，因此我们在这里导入`RouterTestingModule`模块。
- en: 'We’ll change the test in the `login.component.spec.ts` file next:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将修改`login.component.spec.ts`文件中的测试：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Since the `Login` component relies on the `ReactiveFormsModule` module, we also
    need to import it into our test. Furthermore, the component utilizes the `AuthService`
    service, and for our mocking purposes, we employ the `useValue` property, as demonstrated
    earlier. In unit testing, it’s crucial to concentrate on the component itself,
    and we achieve this by isolating it through the mocking of its dependencies.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Login`组件依赖于`ReactiveFormsModule`模块，我们还需要将其导入到我们的测试中。此外，该组件使用了`AuthService`服务，并且为了我们的模拟目的，我们使用了前面演示的`useValue`属性。在单元测试中，集中关注组件本身至关重要，我们通过模拟其依赖项来实现这一点。
- en: 'The next test to tune will be for the `home.component.spec.ts` file:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个需要调整的测试是针对`home.component.spec.ts`文件：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When testing the `Home` component, we need to include the `'RouterTestingModule'`
    dependency because we are using route services and we are mocking the `'AuthService'`
    service due to the application’s logout action.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试`Home`组件时，我们需要包含`'RouterTestingModule'`依赖项，因为我们正在使用路由服务，并且由于应用程序的注销操作，我们正在模拟`'AuthService'`服务。
- en: 'Next, let’s fix the test for the `new-entry-form-template.component.spec.ts`
    file:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们修复`new-entry-form-template.component.spec.ts`文件的测试：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This page employs template-driven form techniques, so for the test run, we include
    the `'FormsModule'` module by importing it. As it only uses the `'ExerciseSetsService'`
    service, we mocked it with the help of the Jasmine framework.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个页面使用了模板驱动的表单技术，因此在测试运行时，我们通过导入它来包含`'FormsModule'`模块。因为它只使用了`'ExerciseSetsService'`服务，所以我们用Jasmine框架帮助模拟它。
- en: 'We’ll work on testing the `new-entry-form-reactive.component.spec` page next:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始测试`new-entry-form-reactive.component.spec`页面：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In [*Chapter 9*](B19562_09.xhtml#_idTextAnchor242), *Exploring Reactivity with
    RxJS*, we incorporated the search exercise into the form, so in this test case,
    we need to import the `'ReactiveFormsModule'` and `'RouterTestingModule'` modules.
    In addition, we need to mock the `'ExerciseSetsService'` and `'``ExercisesService'`
    services.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第9章*](B19562_09.xhtml#_idTextAnchor242)《使用RxJS探索响应性》中，我们将搜索练习纳入了表单，因此在这个测试用例中，我们需要导入`'ReactiveFormsModule'`和`'RouterTestingModule'`模块。此外，我们还需要模拟`'ExerciseSetsService'`和`'ExercisesService'`服务。
- en: 'With this test set, let’s go to the last component, `diary.component.spec.ts`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个测试集，让我们转到最后一个组件`diary.component.spec.ts`：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This component, as it is a smart component in our suggested architecture, needs
    to declare the components that compose it in your test. Here, they are `DiaryComponent`,
    `ListEntriesComponent`, and `NewItemButtonComponent`. Finally, we imported the
    `RouterTestingModule` module into the test setup and mocked up the `ExerciseSetsService`
    service, thus correcting all the tests in our project.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件，作为我们建议架构中的智能组件，需要在测试中声明它所组成的组件。在这里，它们是`DiaryComponent`、`ListEntriesComponent`和`NewItemButtonComponent`。最后，我们将`RouterTestingModule`模块导入到测试设置中，并模拟了`ExerciseSetsService`服务，从而纠正了我们项目中所有的测试。
- en: To understand how `TestBed` works, let’s create a test case for our component.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解`TestBed`是如何工作的，让我们为我们的组件创建一个测试用例。
- en: Component testing
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件测试
- en: Angular component unit tests not only examine logic but also assess the values
    that will be presented on the screen.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Angular组件单元测试不仅检查逻辑，还评估将在屏幕上呈现的值。
- en: If your application follows the component architecture recommended by the Angular
    team (more details in [*Chapter 4*](B19562_04.xhtml#_idTextAnchor141), *Components
    and Pages*), you probably won’t have much business logic in your components, delegating
    it to services.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序遵循Angular团队推荐的组件架构（更多详情见[*第4章*](B19562_04.xhtml#_idTextAnchor141)《组件和页面》），你可能不会在组件中有太多业务逻辑，而是将其委托给服务。
- en: To exemplify, in this section, we will create tests for some methods of the
    `DiaryComponent` component.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例说明，在本节中，我们将为`DiaryComponent`组件的一些方法创建测试。
- en: 'We will create the test case for the gym diary entry deletion operation and
    check whether the service’s `delete` method is called:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为健身房日记条目删除操作创建测试用例，并检查服务是否调用了`delete`方法：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding code block, we are testing the `DiaryComponent` component,
    so we mock the service it depends on with `TestBed`. But for this test, we need
    a reference to this service, and for that, we declare a variable called `exerciseSetsService`.
    With the `TestBed.inject` method, we assign the value to this variable.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们正在测试`DiaryComponent`组件，因此我们使用`TestBed`模拟它所依赖的服务。但在这个测试中，我们需要这个服务的引用，为此，我们声明一个名为`exerciseSetsService`的变量。使用`TestBed.inject`方法，我们将值分配给这个变量。
- en: In the test setup, we need to use the `createSpy` function to assign the service’s
    `deleteItem` method because the mock generated by the Jasmine framework does not
    have the full implementation of the service and therefore does not return the
    observable that the component is expecting.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试设置中，我们需要使用`createSpy`函数来分配服务的`deleteItem`方法，因为Jasmine框架生成的模拟没有服务的完整实现，因此不会返回组件期望的可观察对象。
- en: In the execution phase, we call the `deleteItem` method of the component.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行阶段，我们调用组件的`deleteItem`方法。
- en: As this operation is asynchronous, we use the `tick` function to simulate the
    passage of time.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此操作是异步的，我们使用`tick`函数来模拟时间的流逝。
- en: In the assertion phase, we check that the `exerciseSetsService` service method
    was called once and with the expected parameter.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在断言阶段，我们检查`exerciseSetsService`服务方法是否被调用一次，并且使用了预期的参数。
- en: 'Let’s test the `editEntry` method next:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们测试`editEntry`方法：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To perform the assertion of the route, we are going to use an object of type
    `Location` – that’s why we declare it at the beginning of the test and assign
    it using the `TestBed` component. Note that we want the `@angular/common` library
    object and not the browser’s default `Location` object. Also, in `TestBed`, we
    need to declare a route, because as we are in the context of unit testing, Angular
    does not know the routes available for use.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行路由的断言，我们将使用一个`Location`类型的对象——这就是为什么我们在测试开始时声明它并使用`TestBed`组件来分配它。请注意，我们想要的是`@angular/common`库对象，而不是浏览器的默认`Location`对象。此外，在`TestBed`中，我们需要声明一个路由，因为我们处于单元测试的上下文中，Angular不知道可用的路由。
- en: In the test case, we first create a dummy `ExerciseSet` object and call the
    `editEntry` method. Again, we use the `tick` function to simulate the passage
    of time. Finally, in the assertion, we verify that the path is correct. Note that,
    here, we don’t need to create any mock for the router as the `RouterTestingModule`
    module creates it for us.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试用例中，我们首先创建一个虚拟的`ExerciseSet`对象并调用`editEntry`方法。再次使用`tick`函数来模拟时间的流逝。最后，在断言中，我们验证路径是否正确。请注意，在这里，我们不需要为路由器创建任何模拟，因为`RouterTestingModule`模块为我们创建了它。
- en: In the next section, we will explore E2E testing with the Cypress framework.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探索使用Cypress框架的端到端（E2E）测试。
- en: E2E tests with Cypress
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cypress的端到端（E2E）测试
- en: '**E2E** tests aim to evaluate the system from the user’s point of view, simulating
    operations such as typing in a field, clicking on a button, carrying out the assertion,
    and evaluating the messages on the screen, just as a user would evaluate whether
    the action was successful or not.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**E2E**测试旨在从用户的角度评估系统，模拟在字段中输入、点击按钮、执行断言和评估屏幕上的消息等操作，就像用户评估操作是否成功一样。'
- en: In the Angular ecosystem, in the past, there was a tool called **Protractor**
    to help with this type of testing, but it was discontinued by the Angular team
    in favor of other, more focused open source tools.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular生态系统中，过去有一个名为**Protractor**的工具来帮助进行此类测试，但Angular团队已经停止了它，转而支持其他更专注的开源工具。
- en: Among these new tools, we are going to use one of the most popular ones, called
    Cypress.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些新工具中，我们将使用最受欢迎的一个，称为Cypress。
- en: The Cypress framework is a tool that aims to help developers create and run
    all types of tests in the test pyramid, from unitary to E2E.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Cypress框架是一个旨在帮助开发者创建和运行测试金字塔中所有类型测试的工具，从单元测试到端到端测试。
- en: 'Let’s see it in action in our project. For that, we need to install and configure
    it. Follow these steps to install and configure Cypress:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的项目中看看它的实际应用。为此，我们需要安装和配置它。按照以下步骤安装和配置Cypress：
- en: 'We will use the Angular CLI to install and configure Cypress. In the command
    line of your operating system, run the following command:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用Angular CLI来安装和配置Cypress。在你的操作系统命令行中运行以下命令：
- en: '[PRE15]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To run the tool, run the following command at the operating system prompt:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行此工具，请在操作系统提示符中运行以下命令：
- en: '[PRE16]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![Figure 10.3 – Execution of tests by Cypress](img/B19562_10_3.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.3 – Cypress 执行测试](img/B19562_10_3.jpg)'
- en: Figure 10.3 – Execution of tests by Cypress
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 – Cypress 执行测试
- en: Select the desired browser and click on **Start E2E Testing** and we will have
    the test execution interface.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所需的浏览器并点击 **开始端到端测试**，我们将获得测试执行界面。
- en: 'Notice that we already have a file called `spec.cy.ts`. It was generated by
    Cypress to exemplify the creation of the test script. Let’s go back to Visual
    Studio Code and check this file:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经有了一个名为 `spec.cy.ts` 的文件。它是 Cypress 生成的，以示例化测试脚本的创建。让我们回到 Visual Studio
    Code 并检查此文件：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Unlike Angular, Cypress uses Mocha ([https://mochajs.org/](https://mochajs.org/))
    as a testing framework. However, in practice, as we can see in the preceding example,
    it is very similar to the Jasmine framework.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Angular 不同，Cypress 使用 Mocha ([https://mochajs.org/](https://mochajs.org/))
    作为测试框架。然而，在实践中，正如前一个示例所示，它与 Jasmine 框架非常相似。
- en: We have the `describe` function to create the test suite and the `it` function
    to create the test cases. The difference here is the `cy` object, which represents
    the browser’s interface, and with this object, we can perform actions and evaluate
    the state of the page, from the user’s point of view. Here, we use the `visit`
    method to go to the initial endpoint and we use the `contains` method to evaluate
    whether the text app is running appears on the page. We are going to delete this
    file because we are going to create the scripts for our application.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有 `describe` 函数来创建测试套件，以及 `it` 函数来创建测试用例。这里的区别在于 `cy` 对象，它代表浏览器界面，并且通过这个对象，我们可以从用户的角度执行操作并评估页面状态。在这里，我们使用
    `visit` 方法访问初始端点，并使用 `contains` 方法评估文本应用是否运行出现在页面上。我们将删除此文件，因为我们将要为我们的应用程序创建脚本。
- en: 'In the same folder as where the previous file was, we will create the `login.cy.ts`
    file and add the following code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个文件所在的同一文件夹中，我们将创建 `login.cy.ts` 文件并添加以下代码：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this test, we used the `get` method to obtain the page element through CSS
    queries so that we could act on them. First, we take the `username` and `password`
    fields and use the `type` method to simulate the user typing in these fields.
    Then we locate the `click` method to simulate the mouse click action.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们使用了 `get` 方法通过 CSS 查询获取页面元素，以便对其执行操作。首先，我们获取 `username` 和 `password`
    字段，并使用 `type` 方法模拟用户在这些字段中输入。然后我们定位到 `click` 方法来模拟鼠标点击动作。
- en: To assert the test, we used the `contains` method to assess whether the diary
    screen was displayed.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了断言测试，我们使用了 `contains` 方法来评估日记屏幕是否显示。
- en: The tricky part of creating this script is the CSS queries needed to get the
    elements we need. But at this point, Cypress helps us a lot.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 创建此脚本棘手的部分是需要进行 CSS 查询以获取所需的元素。但在此阶段，Cypress 为我们提供了大量帮助。
- en: By running the test, we can see that there is a target icon at the top of the
    screen. By clicking on it and selecting the element we want, Cypress will generate
    the necessary command ready to copy and paste into our script.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行测试，我们可以看到屏幕顶部有一个目标图标。通过点击它并选择我们想要的元素，Cypress 将生成必要的命令，以便我们可以将其复制并粘贴到脚本中。
- en: "![Figure 10.4 – Cypress helping with\uFEFF the CSS query](img/B19562_10_4.jpg)"
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.4 – Cypress 帮助进行 CSS 查询](img/B19562_10_4.jpg)'
- en: Figure 10.4 – Cypress helping with the CSS query
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4 – Cypress 帮助进行 CSS 查询
- en: In this script, however, there is a problem in selecting the button, in addition
    to the query not being clear to another person reading the test script. If the
    team needs to change the layout, the test could break unduly.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这个脚本中，在选择按钮时存在问题，而且查询对于阅读测试脚本的其他人来说不够清晰。如果团队需要更改布局，测试可能会不当地中断。
- en: 'To avoid this error, let’s change the `login` component template:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这个错误，让我们更改 `login` 组件模板：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'With this custom HTML element, we can use the element marked with the `data-cy`
    attribute for our test:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个自定义 HTML 元素，我们可以使用带有 `data-cy` 属性标记的元素进行测试：
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We replaced the previous CSS query with a simpler one that does not depend on
    layout elements. Use this good practice in your project templates to facilitate
    E2E testing and make the test less likely to break.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将之前的 CSS 查询替换为一个更简单的查询，该查询不依赖于布局元素。在您的项目模板中使用此良好实践，以方便端到端测试，并使测试更不容易出错。
- en: 'We’ll create an E2E test for the new journal entry form, but first, let’s apply
    the best practice to the templates we’ll be using in this test. In the `Home`
    component template, we will refactor as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为新的日记条目表单创建一个端到端测试，但首先，让我们将最佳实践应用到我们将在这个测试中使用的模板上。在`Home`组件模板中，我们将按照以下方式重构：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the template, we add the `data-cy` HTML element to the items of the menu.
    Note that as the test is from the user’s point of view, we need to simulate how
    they get to the form.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中，我们在菜单项中添加`data-cy` HTML元素。请注意，由于测试是从用户的角度进行的，我们需要模拟他们如何到达表单。
- en: 'In the `new-entry-form-reactive.component.html` template, we will change the
    submit button like so:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在`new-entry-form-reactive.component.html`模板中，我们将按如下方式更改提交按钮：
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As with the login screen, we mark the button with the `data-cy` element to facilitate
    the development of the E2E test.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 与登录屏幕一样，我们使用`data-cy`元素标记按钮，以方便端到端测试的开发。
- en: 'With our application better adapted for testing, we will create the `new-entry-form.cy.ts`
    file in the `cypress/e2e` folder of our workspace and add the following code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序更适合测试后，我们将在工作区的`cypress/e2e`文件夹中创建`new-entry-form.cy.ts`文件，并添加以下代码：
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Like Jasmine, the Mocha.js framework also has the `beforeEach` function, but
    here, instead of setting up the environment with `TestBed`, we use the function
    to perform the login, since each test where we are simulating the user is necessary
    for this action.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 与Jasmine一样，Mocha.js框架也有`beforeEach`函数，但在这里，我们不是使用`TestBed`设置环境，而是使用该函数执行登录，因为我们在模拟用户的地方进行每个测试时都需要这个动作。
- en: In the test case of the form, since we are already logged in, we click on the
    menu of the input form and check whether there is a **Date** label. From then
    on, we fill in the form fields with data and click on the button. In the assertion
    phase, we check whether the **Item created** message appears on the screen.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在表单测试用例中，由于我们已登录，我们点击输入表单的菜单并检查是否有**日期**标签。从那时起，我们用数据填写表单字段并点击按钮。在断言阶段，我们检查屏幕上是否出现**项目已创建**的消息。
- en: One thing to note is that at no point do we tell the script how long to wait
    for the backend response, which can vary. This happens because the Cypress framework
    does this work for us and makes this waiting process transparent to our development.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个需要注意的事项是，我们从未告诉脚本等待后端响应的时间有多长，这可能会变化。这是因为Cypress框架为我们做了这项工作，并使这个等待过程对我们来说变得透明。
- en: 'We will create a test case to evaluate the form validations:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个测试用例来评估表单验证：
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this test case, we don’t need to worry about the login because the `beforeEach`
    function performs this function and we work directly on the form. We fill in the
    fields, but this time, with information that is not valid. In the assertion phase,
    we check whether the validation messages appear correctly with the `contains`
    method.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试用例中，我们不需要担心登录，因为`beforeEach`函数执行这个功能，我们直接在表单上工作。我们填写字段，但这次，用不正确的信息。在断言阶段，我们使用`contains`方法检查验证消息是否正确出现。
- en: With that, you’ve learned about Cypress and E2E testing in an Angular application,
    so let’s summarize what we looked at in the chapter.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，你已经了解了在Angular应用程序中使用Cypress和端到端测试，所以让我们总结一下本章我们看到了什么。
- en: Summary
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we learned how to perform tests in an Angular project. We studied
    what types of tests there are, their importance, and how to apply them in our
    daily lives. We worked on our project by first creating tests for the services
    and looking at how to isolate the dependencies for a unit test. Furthermore, we
    explored testing HTTP requests using the `HttpClientTestingModule` module. We
    learned about the `TestBed` component and its important task of setting up the
    environment for each unit test to run. We also looked at component testing and
    how to assert components that use routes. Finally, we explored E2E tests with
    the Cypress tool, which simplifies the creation of scripts that simulate the behavior
    of our application from the client’s point of view.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何在Angular项目中执行测试。我们研究了有哪些类型的测试，它们的重要性，以及如何在我们的日常生活中应用它们。我们通过首先为服务创建测试并查看如何为单元测试隔离依赖项来工作在我们的项目上。此外，我们还探讨了使用`HttpClientTestingModule`模块测试HTTP请求。我们了解了`TestBed`组件及其为每个单元测试运行设置环境的重要任务。我们还研究了组件测试以及如何断言使用路由的组件。最后，我们使用Cypress工具探索了端到端测试，该工具简化了从客户端视角模拟我们应用程序行为的脚本的创建。
- en: In the next chapter, we will explore the concept of the micro frontend using
    the Angular framework.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用 Angular 框架来探讨微前端的概念。
