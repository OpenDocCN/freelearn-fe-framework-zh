<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer045">
<h1 class="chapter-number" id="_idParaDest-163"><a id="_idTextAnchor162"/>10</h1>
<h1 id="_idParaDest-164"><a id="_idTextAnchor163"/>Going Beyond</h1>
<p>Our application is finally in production. It might be getting some users as we speak. However, as with every piece of software, our application may never be fully completed. There is always room for improvement, and since the application we built is just an MVP, there are a lot of potential improvements <span class="No-Break">worth mentioning.</span></p>
<p>In this chapter, we will be covering some of the most important improvements from both feature and technical perspectives. These topics might give us some ideas on extending and improving the <span class="No-Break">existing application.</span></p>
<p>In this chapter, we will be covering the <span class="No-Break">following topics:</span></p>
<ul>
<li><span class="No-Break">Feature improvements</span></li>
<li><span class="No-Break">Technical improvements</span></li>
<li><span class="No-Break">Appendix</span></li>
</ul>
<p>By the end of this chapter, we will have covered some features we can add to the existing application to make it more complete. We will also mention some topics that were not covered in this book but are worth exploring on <span class="No-Break">your own.</span></p>
<h1 id="_idParaDest-165"><a id="_idTextAnchor164"/>Feature improvements</h1>
<p>Since our application is at the MVP stage at the moment, there are many potential improvements from the user’s perspective that would make the application <span class="No-Break">more usable.</span></p>
<h2 id="_idParaDest-166"><a id="_idTextAnchor165"/>Jobs feature improvements</h2>
<p>The jobs feature <a id="_idIndexMarker438"/>is the most important feature of this app. There are several improvements we can implement to make the <span class="No-Break">application better:</span></p>
<ul>
<li><span class="No-Break">Updating jobs</span></li>
<li>Adding jobs in a <span class="No-Break">draft state</span></li>
<li><span class="No-Break">Deleting jobs</span></li>
<li>Adding/updating<a id="_idIndexMarker439"/> jobs information with markdown/the <span class="No-Break"><em class="italic">WYSIWYG</em></span><span class="No-Break"> editor</span></li>
</ul>
<h3>Updating jobs</h3>
<p>Right now, our<a id="_idIndexMarker440"/> application only supports job creation. What happens when we want to change some information about the given job posting? It would be great if we could edit job data after it’s <span class="No-Break">been created.</span></p>
<p>Here is how we can <span class="No-Break">do that:</span></p>
<ul>
<li>Create the <em class="italic">update</em> endpoint handler at <strong class="source-inline">PATCH /jobs/:jobId</strong>, which will update the data in <span class="No-Break">the database</span></li>
<li>Create the <em class="italic">update job</em> page at <strong class="source-inline">/dashboard/jobs/:jobId/update</strong>, which is where the update form <span class="No-Break">should be</span></li>
<li>Create the <em class="italic">update</em> form with all the fields that we want to be able to update for <span class="No-Break">a job</span></li>
<li>Upon successful submission, we should invalidate the job query so that its data <span class="No-Break">gets refetched</span></li>
</ul>
<h3>Adding jobs in a draft state</h3>
<p>Currently, when <a id="_idIndexMarker441"/>we create a job for our organization, it will become immediately available to the public. However, it would be great if we could extend its functionality so that we can choose when we want to publish job postings to <span class="No-Break">the public.</span></p>
<p>This can be done by doing <span class="No-Break">the following:</span></p>
<ul>
<li>Extending the job model with the <span class="No-Break"><strong class="source-inline">status</strong></span><span class="No-Break"> property.</span></li>
<li>Setting the <strong class="source-inline">status</strong> value to <strong class="source-inline">draft</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">published</strong></span><span class="No-Break">.</span></li>
<li>When submitting the job creation form, the newly created job will initially have a <strong class="source-inline">status</strong> <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">draft</strong></span><span class="No-Break">.</span></li>
<li>Then, we could update the status of the job via the <em class="italic">update</em> form, where we send the desired status as a value. Another way we could do this would be to expose a <a id="_idIndexMarker442"/>separate endpoint that would only update the status of <span class="No-Break">the job.</span></li>
</ul>
<h3>Deleting jobs</h3>
<p>Most of the <a id="_idIndexMarker443"/>time, job positions get closed. In that case, no one wants a job posting that is no longer relevant, so it might be a good idea to allow organization admins to delete jobs they don’t find <span class="No-Break">relevant anymore.</span></p>
<p>This can be done in <span class="No-Break">two ways:</span></p>
<ul>
<li>Having a <em class="italic">Delete</em> endpoint that will handle deleting the job from the database. Clicking on a button would send the request and, on a successful request, redirect the user to the <span class="No-Break">jobs list.</span></li>
<li>Extending the <strong class="source-inline">status</strong> property, which could now have an additional <strong class="source-inline">archived</strong> or <strong class="source-inline">deleted</strong> value. This method is <a id="_idIndexMarker444"/>called <strong class="bold">soft delete</strong> because we are not deleting the entry from the database, but from the application’s perspective, it looks as if it was deleted. Archiving job postings might be useful for tracking different stats from <span class="No-Break">previous hires.</span></li>
</ul>
<h3>Adding/updating jobs information with markdown/the WYSIWYG editor</h3>
<p>Currently, the<a id="_idIndexMarker445"/> job<a id="_idIndexMarker446"/> information is filled with a <strong class="source-inline">textarea</strong> input field, which is convenient for plain text values. However, the admin’s ability to add as much information as possible is limited to <span class="No-Break">text only.</span></p>
<p>It would be great if we could allow admins to add things, such as different headers, lists, links, and so on, to the job information so that the job posting provides as much information <span class="No-Break">as possible.</span></p>
<p>The solution would be to replace the <strong class="source-inline">textarea</strong> input field with a rich text editor, which would allow us to add more than just text. Just make sure that you sanitize the inputs <a id="_idIndexMarker447"/>before <a id="_idIndexMarker448"/>submitting them to keep the application as safe <span class="No-Break">as possible.</span></p>
<h2 id="_idParaDest-167"><a id="_idTextAnchor166"/>Organization improvements</h2>
<p>Currently, there is <a id="_idIndexMarker449"/>no way for the organization admin to update the organization’s information. The organization should be able to change any of the information at <span class="No-Break">any time.</span></p>
<p>To make this possible, we can do <span class="No-Break">the following:</span></p>
<ul>
<li>Create the endpoint for updating the organization at <span class="No-Break"><strong class="source-inline">PATCH /organizations/:organizationId</strong></span></li>
<li>Create a page at <strong class="source-inline">/dashboard/organization/update</strong> where we can have the <span class="No-Break">update form</span></li>
</ul>
<h2 id="_idParaDest-168"><a id="_idTextAnchor167"/>Adding job applications</h2>
<p>One more<a id="_idIndexMarker450"/> thing we can improve is the ability to add <span class="No-Break">job applications.</span></p>
<p>Currently, there is no mechanism to apply to jobs directly in the application. When the user clicks the <strong class="bold">Apply</strong> button, the email client is opened with the correctly set subject. Then, the user would send an email to the organization’s email address, and that would be the <span class="No-Break">entire flow.</span></p>
<p>To take it to the next level, we can create another entity <a id="_idIndexMarker451"/>called <em class="italic">Application</em> that will be submitted when the user applies for a job. This approach will allow admins to track job applications for <span class="No-Break">their organizations.</span></p>
<p>Let’s rethink what the data model of the application will look like with this <span class="No-Break">new feature:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer044">
<img alt="Figure 10.1 – Applications in the data model " height="1358" src="image/B17297_10_01.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – Applications in the data model</p>
<p>As we can see, an application should contain some basic information about the candidate, a message, a report from the interviewer, and <span class="No-Break">so on.</span></p>
<p>Once the data model has been updated, we can build the applications feature, which will handle all <a id="_idIndexMarker452"/>things related. This would include things such as <span class="No-Break">the following:</span></p>
<ul>
<li>Endpoints for creating and <span class="No-Break">browsing applications.</span></li>
<li>Pages on the dashboard where the admins can browse through all the applications. They can be defined at <strong class="source-inline">/dashboard/applications</strong> and <strong class="source-inline">/dashboard/applications/:applicationId</strong> for the listing and details <span class="No-Break">pages, respectively.</span></li>
</ul>
<h2 id="_idParaDest-169"><a id="_idTextAnchor168"/>Filtering and paginating lists of data</h2>
<p>Displaying<a id="_idIndexMarker453"/> lists<a id="_idIndexMarker454"/> of data in tables is fine, but what happens when the number of entries starts to grow significantly? It is not very optimal to load all the entries in one go because not all entries might be needed in the <span class="No-Break">first place.</span></p>
<p>To optimize data lists, we can add support for filtering and paginating data. This will help users narrow down the search results to what they need. Both filtering and paginating should happen on <span class="No-Break">the server.</span></p>
<p>Tracking current<a id="_idIndexMarker455"/> filter and pagination values should be <a id="_idIndexMarker456"/>handled by URL parameters. This will make it easy for the application to deep link the search results for any <span class="No-Break">further usage.</span></p>
<h2 id="_idParaDest-170"><a id="_idTextAnchor169"/>Adding user registration</h2>
<p>This one is <a id="_idIndexMarker457"/>pretty straightforward. Until now, we have relied on test data, which had one test user that we used to sign in to the dashboard. However, there is no way to register new users. If we want to make this application usable by more than one organization, we should add this functionality. This can be implemented by doing <span class="No-Break">the following:</span></p>
<ul>
<li>Creating the registration endpoint at POST <strong class="source-inline">/auth/register</strong>, which would take the required data from a form and create a user and its corresponding organization in <span class="No-Break">the database</span></li>
<li>Create the registration page at <strong class="source-inline">/auth/register</strong>, where there is the registration form which, when submitted, calls the <span class="No-Break">registration endpoint</span></li>
</ul>
<h1 id="_idParaDest-171"><a id="_idTextAnchor170"/>Technical improvements</h1>
<p>Our application <a id="_idIndexMarker458"/>is in good shape, but several things should be kept in mind in case the application starts growing. Let’s take <span class="No-Break">a look.</span></p>
<h2 id="_idParaDest-172"><a id="_idTextAnchor171"/>Server-side rendering and caching</h2>
<p>There are <a id="_idIndexMarker459"/>several improvements <a id="_idIndexMarker460"/>we can make to further optimize how the public pages are rendered on <span class="No-Break">the server.</span></p>
<p>Currently, we are rendering the pages on each request, which is good if the data changes frequently; otherwise, it might increase the loading time and server costs because rendering on the server is a <span class="No-Break">compute-intensive operation.</span></p>
<p>Fortunately, Next.js supports another rendering<a id="_idIndexMarker461"/> strategy called <strong class="bold">Incremental </strong><span class="No-Break"><strong class="bold">Static Regeneration</strong></span><span class="No-Break">.</span></p>
<p>It works <span class="No-Break">as follows:</span></p>
<ol>
<li><em class="italic">User1</em> requests <span class="No-Break">a page.</span></li>
<li>The server returns the cached version of the page and <span class="No-Break">returns it.</span></li>
<li>During that request, Next.js is triggered to regenerate the same page with the <span class="No-Break">latest data.</span></li>
<li><em class="italic">User2</em> requests <span class="No-Break">a page.</span></li>
<li>The server returns the new version of <span class="No-Break">the page.</span></li>
</ol>
<p>If we take <a id="_idIndexMarker462"/>our<a id="_idIndexMarker463"/> public job details page as an example, it will work <span class="No-Break">as follows.</span></p>
<p>First, we would need to use <strong class="source-inline">getStaticPaths</strong> to generate all the paths for all <span class="No-Break">the jobs:</span></p>
<pre class="source-code">
export const getStaticPaths = async () =&gt; {
  const jobs = await getJobs();
  const paths = jobs.map((job) =&gt; ({
     params: { jobId: job.id }
  }));
  return { paths, fallback: true };
}</pre>
<p>This will generate a list of paths for all the jobs that exist in the database. The key thing here is the <strong class="source-inline">fallback</strong> property, which will make Next.js not return the 404 page but try to generate a <span class="No-Break">new one.</span></p>
<p>We must also replace <strong class="source-inline">getServerSideProps</strong> with <strong class="source-inline">getStaticProps</strong>, which would look something <span class="No-Break">like this:</span></p>
<pre class="source-code">
export const getStaticProps = async ({
  params,
}: GetStaticPropsContext) =&gt; {
  const jobId = params?.jobId as string;
  const job = await getJob({ jobId });
  return {
    props: {
      job
    },
    revalidate: 60,
  };
};</pre>
<p>Notice how we can add the <strong class="source-inline">revalidate</strong> property to the <strong class="source-inline">return</strong> value. This will force the page to revalidate after <span class="No-Break">60 seconds.</span></p>
<p>Since jobs and <a id="_idIndexMarker464"/>organizations’ data <a id="_idIndexMarker465"/>don’t change very frequently, this rendering strategy sounds more optimal in the long run, especially once the number of requests starts <span class="No-Break">to grow.</span></p>
<p>It makes for a good compromise between the performance and freshness of <span class="No-Break">the data.</span></p>
<h2 id="_idParaDest-173"><a id="_idTextAnchor172"/>React Query hydration for SSR</h2>
<p>Currently, we <a id="_idIndexMarker466"/>are using<a id="_idIndexMarker467"/> React <a id="_idIndexMarker468"/>Query for handling data fetching on the client, but data fetching on the server is being handled without it. We are just fetching the data and passing and rendering it on the page. This is fine if we don’t have many levels of components, but there is a better way to <span class="No-Break">do this.</span></p>
<p>React Query supports two ways of fetching data on the server and passing it to <span class="No-Break">the client:</span></p>
<ul>
<li>Fetching the data on the server and then passing it as <strong class="source-inline">initialData</strong> to <span class="No-Break">the query</span></li>
<li>Prefetching on the server, dehydrating the cache, and rehydrating it on <span class="No-Break">the client</span></li>
</ul>
<p>The first option is good for smaller apps where there is not a very large hierarchy between the component, so there is no need to pass the server data down multiple levels to the <span class="No-Break">desired query.</span></p>
<p>The second option might take more initial setup, but in the end, it makes the code base <span class="No-Break">much simpler.</span></p>
<p>In the <strong class="source-inline">pages/_app.tsx</strong> file, we should wrap anything that is inside <strong class="source-inline">QueryClientProvider</strong> with <strong class="source-inline">Hydrate</strong>, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
import { Hydrate, QueryClient, QueryClientProvider }
  from '@tanstack/react-query'
export const App = ({ Component, pageProps }) =&gt; {
  const [queryClient] = React.useState(() =&gt; new
    QueryClient())
  return (
    &lt;QueryClientProvider client={queryClient}&gt;
      &lt;Hydrate state={pageProps.dehydratedState}&gt;
        &lt;Component {...pageProps} /&gt;
      &lt;/Hydrate&gt;
    &lt;/QueryClientProvider&gt;
  )
}</pre>
<p>This will prepare the application to process any dehydrated state. But how do we provide a dehydrated state to <span class="No-Break">the page?</span></p>
<p>On a specific <a id="_idIndexMarker469"/>page, we <a id="_idIndexMarker470"/>can<a id="_idIndexMarker471"/> modify <strong class="source-inline">getStaticProps</strong> or <strong class="source-inline">getServerSideProps</strong> <span class="No-Break">as follows:</span></p>
<pre class="source-code">
export const getServerSideProps = async () =&gt; {
     const queryClient = new QueryClient()
  await queryClient.prefetchQuery(['jobs'], getJobs)
  return {
    props: {
      dehydratedState: dehydrate(queryClient),
    },
  }
}</pre>
<p>Then, we can consume the jobs as we would if we were fetching them on <span class="No-Break">the client:</span></p>
<pre class="source-code">
const JobsPage = () =&gt; {
     const jobs = useJobs();
     // ...
}</pre>
<p>This will make it much easier to handle all the server states with <span class="No-Break">React Query.</span></p>
<h2 id="_idParaDest-174"><a id="_idTextAnchor173"/>Using query key factories</h2>
<p>Having many <a id="_idIndexMarker472"/>queries all<a id="_idIndexMarker473"/> over the app might get pretty difficult to manage once the number of queries starts to grow. It is hard to track all the variations of the queries and where they are being used. Preventing duplicate query keys might be one of the problems <span class="No-Break">as well.</span></p>
<p>That’s why we should think about using query key factories instead of just deliberately adding the query keys all over <span class="No-Break">the place.</span></p>
<p>We can define all potential keys <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">src/lib/react-query.ts</strong></span><span class="No-Break">:</span></p>
<p>First, we can define a simplified version of <span class="No-Break">the factory:</span></p>
<pre class="source-code">
const getQueryKeys = (baseKey: string) =&gt; {
  return {
    all: [baseKey],
    many: (params: Record&lt;string, unknown&gt;) =&gt; [baseKey,
      params],
    one: (id: string) =&gt; [baseKey, id],
  };
};</pre>
<p>Then, we can create the keys for <span class="No-Break">the queries:</span></p>
<pre class="source-code">
export const queryKeys = {
  auth: {
    authUser: ['auth-user'],
  },
  jobs: getQueryKeys('jobs'),
  organizations: {
    one: getQueryKeys('organizations').one,
  },
};</pre>
<p>As you can see, not all the features have the same key structure, but we can combine different factories to create what <span class="No-Break">we need.</span></p>
<p>Then, if we wanted to use a key in a query, we could do so <span class="No-Break">as follows:</span></p>
<pre class="source-code">
const useJobs = () =&gt; {
     const { data, isLoading } = useQuery({
    queryKey: queryKeys.jobs.many(params),
    queryFn: () =&gt; getJobs({ params }),
    enabled: !!params.organizationId,
    initialData: [],
  });
  //...
}</pre>
<p>What is good with this approach is that we have a centralized overview of all the keys, which reduces the possibility of making mistakes by mistyping a key or <span class="No-Break">something similar.</span></p>
<p>This was an <a id="_idIndexMarker474"/>example of a<a id="_idIndexMarker475"/> simplified query key factory. If you need a more robust solution, there is a great library for this that can be found <span class="No-Break">at </span><a href="https://www.npmjs.com/package/@lukemorales/query-key-factory"><span class="No-Break">https://www.npmjs.com/package/@lukemorales/query-key-factory</span></a><span class="No-Break">.</span></p>
<h2 id="_idParaDest-175"><a id="_idTextAnchor174"/>Code scaffolding</h2>
<p>When <a id="_idIndexMarker476"/>looking at our application, we <a id="_idIndexMarker477"/>might notice that there is some level of boilerplate. Creating components, for example, requires a folder that looks <span class="No-Break">like this:</span></p>
<pre class="source-code">
- my-component
     - index.ts
     - my-component.tsx</pre>
<p>We must remember to re-export the component from <strong class="source-inline">index.ts</strong> to make <span class="No-Break">it available.</span></p>
<p>The same thing can be said for API requests. We need to create the request function and then the hook that consumes it. These things can be automated with tools that can help us generate these kinds of files easier via <span class="No-Break">their CLI.</span></p>
<p>Having some <a id="_idIndexMarker478"/>scaffolding tools such <a id="_idIndexMarker479"/>as Plop.js and Hygen.io also brings better consistency to the <span class="No-Break">code base.</span></p>
<h2 id="_idParaDest-176"><a id="_idTextAnchor175"/>Validating form inputs and API responses with Zod</h2>
<p>Let’s talk briefly about validation. With validation, we want to make sure the data is in the expected form. For our application, we can validate form inputs and <span class="No-Break">API responses.</span></p>
<p>For validation, we can use Zod, which is a great validation library that is TypeScript-first. This means that we can define a schema out of which we can infer types we <span class="No-Break">can use.</span></p>
<h3>Form input validation</h3>
<p>The <strong class="source-inline">react-hooks-form</strong> library <a id="_idIndexMarker480"/>comes <a id="_idIndexMarker481"/>with great<a id="_idIndexMarker482"/> support for Zod, which we could utilize for this. Taking the current login form, we could modify it so that it looks <span class="No-Break">like this:</span></p>
<pre class="source-code">
import { z } from 'zod';
import { yupResolver } from '@hookform/resolvers/yup';
const schema = z.object({
  email: z.string().min(1, 'Required'),
  password: z.string().min(1, 'Required'),
});
const LoginForm  = () =&gt; {
     const { register, handleSubmit } = useForm({
          resolver: yupResolver(schema);
     })
     // ...
     return (
          &lt;Stack
      as="form"
      onSubmit={handleSubmit(onSubmit)}
      spacing="5"
      w="full"
    &gt;
      &lt;InputField
        label="Email"
        type="email"
        {...register('email')}
        error={formState.errors['email']}
      /&gt;
      &lt;InputField
        label="Password"
        type="password"
        {...register('password')}
        error={formState.errors['password']}
      /&gt;
      &lt;Button
        isLoading={login.isLoading}
        isDisabled={login.isLoading}
        type="submit"
      &gt;
        Log in
      &lt;/Button&gt;
    &lt;/Stack&gt;
     )
}</pre>
<p>Here, we are creating an object schema and providing that to <strong class="source-inline">useForm</strong> with the help <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">yupResolver</strong></span><span class="No-Break">.</span></p>
<p>This will <a id="_idIndexMarker483"/>make<a id="_idIndexMarker484"/> sure<a id="_idIndexMarker485"/> the form will never be submitted unless all the fields have <span class="No-Break">valid values.</span></p>
<h3>API requests validation</h3>
<p>We do<a id="_idIndexMarker486"/> have<a id="_idIndexMarker487"/> TypeScript<a id="_idIndexMarker488"/> types in place, but they don’t protect us from runtime errors. That’s why we should consider validating API responses in some cases. Let’s take a look at the <span class="No-Break">following example:</span></p>
<pre class="source-code">
import { z } from 'zod';
const JobSchema = z.object({
     position: z.string(),
     info: z.string(),
     location: z.string()
});</pre>
<p>Since Zod is a TypeScript-first library, we can use it to infer the types of the given <span class="No-Break">object’s shape:</span></p>
<pre class="source-code">
type Job = z.infer&lt;typeof JobSchema&gt;</pre>
<p>This might help with reducing duplicate type definitions. Finally, we can validate our requests, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
const getJob = async () =&gt; {
     const jobResponse = await apiClient.get('/jobs/123');
     const job = JobSchema.parse(jobResponse);
     return job;
}</pre>
<p>If any of the<a id="_idIndexMarker489"/> job <a id="_idIndexMarker490"/>properties <a id="_idIndexMarker491"/>do not match the schema, Zod will throw a runtime error, which we can then <span class="No-Break">handle properly.</span></p>
<h2 id="_idParaDest-177"><a id="_idTextAnchor176"/>Next.js 13</h2>
<p>Next.js 13 is around<a id="_idIndexMarker492"/> the corner! It was released <a id="_idIndexMarker493"/>recently with some big changes, including <span class="No-Break">the following:</span></p>
<ul>
<li>A new routing system with the <span class="No-Break">app folder</span></li>
<li><span class="No-Break">Server components</span></li>
<li>A new data <span class="No-Break">fetching approach</span></li>
</ul>
<p>It’s worth noting that it is backward compatible with older versions, so it allows incremental upgrades. It might take some time for everything to get polished out, but it is worth keeping an eye on it and upgrading to the new approach at <span class="No-Break">some point.</span></p>
<h1 id="_idParaDest-178"><a id="_idTextAnchor177"/>Appendix</h1>
<p>There are a couple of topics that are not directly related to the application we built, but they are <span class="No-Break">worth mentioning.</span></p>
<h2 id="_idParaDest-179"><a id="_idTextAnchor178"/>GraphQL</h2>
<p>Having a GraphQL API is a<a id="_idIndexMarker494"/> very common thing nowadays, especially in a microservices architecture. We worked with a REST API in our application, but how would we structure our API layer if it were a <span class="No-Break">GraphQL API?</span></p>
<p>Well, the implementation would be very similar. We could choose to use a different library, such as Apollo, but we will stick with <span class="No-Break">React Query.</span></p>
<p>Look at the <span class="No-Break">following request:</span></p>
<pre class="source-code">
import { request, gql } from "graphql-request";
import { useQuery } from '@tanstack/react-query';
const jobsQuery = gql`
     query {
          jobs {
               data {
                    position
                    department
                    location
               }
          }
     }
`;
const getJobs = () =&gt; {
     return request('/api/graphql', jobsQuery);
};
const useJobs = () =&gt; {
     const { data, isLoading } = useQuery({
          queryKey: ['jobs'],
          queryFn: getJobs
     })
     // ...
};</pre>
<p>As you can see, first, we are defining the GraphQL query, which we then use to define the request<a id="_idIndexMarker495"/> function. Finally, we use the request function to create the <span class="No-Break"><strong class="source-inline">useJobs</strong></span><span class="No-Break"> hook.</span></p>
<h2 id="_idParaDest-180"><a id="_idTextAnchor179"/>Monorepos</h2>
<p>A <strong class="bold">monorepo</strong> is a Git <a id="_idIndexMarker496"/>repository that contains more than one project with a clearly defined relationship between those projects. This means that a good monorepo setup should provide the <span class="No-Break">following features:</span></p>
<ul>
<li>Easy code<a id="_idIndexMarker497"/> sharing <span class="No-Break">between projects</span></li>
<li>Project constraints <span class="No-Break">and visibility</span></li>
<li><span class="No-Break">Computation caching</span></li>
<li>Clear boundaries of <span class="No-Break">the projects</span></li>
</ul>
<p>It is worth exploring monorepos because they are being used in some of the largest software projects and make such large projects easier <span class="No-Break">to manage.</span></p>
<p>Some of the most popular monorepo tools are <span class="No-Break">as follows:</span></p>
<ul>
<li><span class="No-Break">Lerna</span></li>
<li><span class="No-Break">Nx</span></li>
<li><span class="No-Break">Turborepo</span></li>
<li><span class="No-Break">Yarn workspaces</span></li>
</ul>
<h2 id="_idParaDest-181"><a id="_idTextAnchor180"/>Micro frontend architecture</h2>
<p><strong class="bold">Micro frontend</strong> architecture<a id="_idIndexMarker498"/> is a very interesting concept. It means that we can build and deploy components of the application as separate applications, and they would look and feel as if they were part of the <span class="No-Break">same application.</span></p>
<p>Some of the benefits <a id="_idIndexMarker499"/>of using this kind of architecture are <span class="No-Break">as follows:</span></p>
<ul>
<li>Useful when working on a platform that has many <span class="No-Break">different teams.</span></li>
<li>Does not constrain the apps to a specific technology. Each micro frontend application can have a different stack, and they would work together <span class="No-Break">really well.</span></li>
</ul>
<p>However, there are also <span class="No-Break">some drawbacks:</span></p>
<ul>
<li>Building<a id="_idIndexMarker500"/> micro frontend architectures with different technologies, even though it’s possible, should be discouraged. It is best to choose one framework and create standards for how the applications <span class="No-Break">are built.</span></li>
<li>Micro frontend architecture requires much more complex tooling, which for most of the use cases might not be <span class="No-Break">worth it.</span></li>
</ul>
<p>A couple of<a id="_idIndexMarker501"/> tools to explore are <span class="No-Break">as follows:</span></p>
<ul>
<li><span class="No-Break">Module Federation</span></li>
<li><span class="No-Break">Single SPA</span></li>
</ul>
<h1 id="_idParaDest-182"><a id="_idTextAnchor181"/>Summary</h1>
<p>In this chapter, we went through the rest of the topics that are worth exploring after finishing this book. Things such as feature improvements and technical improvements can take your application to the next level. Hopefully, you can take what you have learned here and apply it to a similar <span class="No-Break">real-world scenario.</span></p>
</div>
</div></body></html>