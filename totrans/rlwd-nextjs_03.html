<html><head></head><body>
		<div id="_idContainer007">
			<h1 id="_idParaDest-30"><em class="italic"><a id="_idTextAnchor029"/>Chapter 2</em>: Exploring Different Rendering Strategies</h1>
			<p>When talking about rendering strategies, we refer to how we serve a web page (or a web application) to a web browser. There are frameworks, such as Gatsby (as seen in the previous chapter), that are incredibly good at serving statically generated pages. Other frameworks will make it easy to create server-side rendered pages. </p>
			<p>But Next.js brings those concepts to a whole new level, letting you decide which page should be rendered at build time and which should be served dynamically at runtime, regenerating the entire page for each request making certain parts of your applications incredibly dynamic. The framework also allows you to decide which components should exclusively be rendered on the client side, making your development experience extremely satisfying.</p>
			<p>In this chapter, we'll have a closer look at:</p>
			<ul>
				<li>How to dynamically render a page for each request using server-side rendering</li>
				<li>Different ways to render certain components on the client side only</li>
				<li>Generating static pages at build time</li>
				<li>How to regenerate static pages in production using incremental static regeneration</li>
			</ul>
			<h1 id="_idParaDest-31"><a id="_idTextAnchor030"/>Technical requirements</h1>
			<p>To run the code examples in this chapter, make sure you have Node.js and <strong class="source-inline">npm</strong> installed on your machine. As an alternative, you can use an online IDE such as <a href="https://repl.it">https://repl.it</a> or <a href="https://codesandbox.io">https://codesandbox.io</a>.</p>
			<p>You can find the code for this chapter in the GitHub repository: <a href="https://github.com/PacktPublishing/Real-World-Next.js">https://github.com/PacktPublishing/Real-World-Next.js</a>.</p>
			<h1 id="_idParaDest-32"><a id="_idTextAnchor031"/>Server-side rendering (SSR)</h1>
			<p>Even<a id="_idIndexMarker042"/> though <strong class="bold">server-side rendering</strong> (<strong class="bold">SSR</strong>) sounds like a new term in the developer's vocabulary, it is actually the most common way for serving web pages. If you think of languages such as PHP, Ruby, or Python, they all render the HTML on the server before sending it to the browser, which will make the markup dynamic once all the JavaScript contents have been loaded.</p>
			<p>Well, Next.js does the same thing by dynamically rendering an HTML page on the server for each request, then sending it to the web browser. The framework will also inject its own scripts to make<a id="_idIndexMarker043"/> the server-side rendered pages dynamic in a process called <strong class="bold">hydration</strong>.</p>
			<p>Imagine you're building a blog and you want to display all the articles written by a specific author on a single page. This can be a great use case for SSR: a user wants to access this page, so the server renders it and sends the resulting HTML to the client. At this point, the browser will download all the scripts requested by the page and hydrate the DOM, making it interactive without any kind of page refresh or glitch (you can read more about React hydration at <a href="https://reactjs.org/docs/react-dom.html#hydrate">https://reactjs.org/docs/react-dom.html#hydrate</a>). From this point, thanks to React hydration, the web app can also become a <strong class="bold">single-page application</strong> (<strong class="bold">SPA</strong>), taking <a id="_idIndexMarker044"/>all the advantages of <a id="_idIndexMarker045"/>both <strong class="bold">client-side rendering</strong> (<strong class="bold">CSR</strong>) (as we'll see in the next section) and SSR.</p>
			<p>Talking about the advantages of adopting a specific rendering strategy, SSR provides multiple benefits over the standard React CSR:</p>
			<ul>
				<li><strong class="bold">More secure web apps</strong>: Rendering <a id="_idIndexMarker046"/>a page on the server side means that activities such as managing cookies, calling private APIs, and data validation happen on the server, so we will never expose private data to the client.</li>
				<li><strong class="bold">More compatible websites</strong>: The website will be available even if the user has disabled JavaScript or uses an older browser.</li>
				<li><strong class="bold">Enhanced search engine optimization</strong>: Since the client will receive the HTML content as soon as the server renders and sends it, the search engine spiders (bots that crawl the web pages) will not need to wait for the page to be rendered on the client side. This will improve your web app's SEO score.</li>
			</ul>
			<p>Despite those great advantages, there are times where SSR might not be the best solution for your website. In fact, with SSR, you will need to deploy your web application to a server that will re-render a page as soon as it's required. As we'll see later, with both CSR <a id="_idIndexMarker047"/>and <strong class="bold">static site generation</strong> (<strong class="bold">SSG</strong>), you can deploy static HTML files to any cloud provider, such as Vercel or Netlify, for free (or at a meager cost); if you're already deploying your web app using a custom server, you have to remember that an SSR app will always lead to a more significant server workload and maintenance costs.</p>
			<p>Another thing to keep in mind when you want to server-side render your pages is that you're adding some latency to each request; your pages might need to call some external API or data<a id="_idIndexMarker048"/> source, and they'll call it for every page render. Navigating between server-side rendered pages will always be a bit slower than navigating between client-side rendered or statically served pages.</p>
			<p>Of course, Next.js provides some great features for improving navigation performances, as we'll see in <a href="B16985_03_Final_SB_epub.xhtml#_idTextAnchor038"><em class="italic">Chapter 3</em></a>, <em class="italic">Next.js Basics and Built-In Components</em>.</p>
			<p>Another thing to consider is that by default, a Next.js page is statically generated at build time. If we want to make it more dynamic by calling an external API, a database, or other data sources, we will need to export a particular function from our page:</p>
			<p class="source-code">function IndexPage() {</p>
			<p class="source-code">  return &lt;div&gt;This is the index page.&lt;/div&gt;;</p>
			<p class="source-code">}</p>
			<p class="source-code">export default IndexPage;</p>
			<p>As you can see, the page only prints the <strong class="bold">This is the index page.</strong> text inside a <strong class="source-inline">div</strong>. It doesn't need to call external APIs or any other data source to work, and its content will always be the same for each request. But now, let's pretend that we want to greet the user on every request; we will need to call a REST API on the server to get some specific user information and pass the result to the client using the Next.js flow. We will do that by using the reserved <strong class="source-inline">getServerSideProps</strong> function:</p>
			<p class="source-code">export async function getServerSideProps() {</p>
			<p class="source-code">  const userRequest =     await fetch('https://example.com/api/user');</p>
			<p class="source-code">  const userData = await userRequest.json();</p>
			<p class="source-code">  return {</p>
			<p class="source-code">    props: {</p>
			<p class="source-code">      user: userData</p>
			<p class="source-code">    }</p>
			<p class="source-code">  };</p>
			<p class="source-code">}</p>
			<p class="source-code">function IndexPage(props) {</p>
			<p class="source-code">  return &lt;div&gt;Welcome, {props.user.name}!&lt;/div&gt;;</p>
			<p class="source-code">}</p>
			<p class="source-code">export default IndexPage;</p>
			<p>In the preceding <a id="_idIndexMarker049"/>example, we used the Next.js reserved <strong class="source-inline">getServerSideProps</strong> function for making a REST API call on the server side for each request. Let's break it down into small steps so that we can better understand what we're doing:</p>
			<ol>
				<li>We start by exporting an async function called <strong class="source-inline">getServerSideProps</strong>. During the build phase, Next.js will look for every page exporting this function and make them dynamically server-side rendered for each request. All the code written within this function scope will always be executed on the server side.</li>
				<li>Inside the <strong class="source-inline">getServerSideProps</strong> function, we return an object containing a property called <strong class="source-inline">props</strong>. This is required because Next.js will inject those props inside our <strong class="source-inline">page</strong> component, making them available both on the client and server side. In case you're wondering, we don't need to polyfill the fetch API when we use it on the server side, as Next.js already does that for us.</li>
				<li>We then refactor the <strong class="source-inline">IndexPage</strong> function, which now accepts a <strong class="source-inline">props</strong> parameter containing all the props passed from the <strong class="source-inline">getServerSideProps</strong> function.</li>
			</ol>
			<p>And that's all! After we ship this code, Next.js will always dynamically render our <strong class="source-inline">IndexPage</strong> on the server, calling an external API and showing different results as soon as we make changes in our data source.</p>
			<p>As seen at the beginning of this section, SSR provides some significant advantages but has some caveats. If you want to use any component that relies on browser-specific APIs, you will need<a id="_idIndexMarker050"/> to render it on the browser explicitly because, by default, Next.js renders the entire page content on the server, which does not expose certain APIs, such as <strong class="source-inline">window</strong> or <strong class="source-inline">document</strong>. So here comes the concept of CSR.</p>
			<h1 id="_idParaDest-33"><a id="_idTextAnchor032"/>Client-side rendering (CSR)</h1>
			<p>As seen in the <a id="_idIndexMarker051"/>previous chapter, a standard React app is rendered once the JavaScript bundle has been transferred from the server to the client.</p>
			<p>If you're familiar <a id="_idIndexMarker052"/>with <strong class="bold">create-react-app</strong> (<strong class="bold">CRA</strong>), you may have noticed that right before the web app renders, the whole web page is entirely white. That's because the server only serves a very basic HTML markup, which contains all the required scripts and styles to make our web app dynamic. Let's take a closer look at that HTML generated by CRA:</p>
			<p class="source-code">&lt;!DOCTYPE html&gt;</p>
			<p class="source-code">&lt;html lang="en"&gt;</p>
			<p class="source-code">  &lt;head&gt;</p>
			<p class="source-code">    &lt;meta charset="utf-8" /&gt;</p>
			<p class="source-code">    &lt;link rel="icon" href="%PUBLIC_URL%/favicon.ico" /&gt;</p>
			<p class="source-code">    &lt;meta</p>
			<p class="source-code">      name="viewport"</p>
			<p class="source-code">      content="width=device-width, initial-scale=1"</p>
			<p class="source-code">    /&gt;</p>
			<p class="source-code">    &lt;meta name="theme-color" content="#000000" /&gt;</p>
			<p class="source-code">    &lt;meta</p>
			<p class="source-code">      name="description"</p>
			<p class="source-code">      content="Web site created using create-react-app"</p>
			<p class="source-code">    /&gt;</p>
			<p class="source-code">    &lt;link rel="apple-touch-icon" </p>
			<p class="source-code">      href="%PUBLIC_URL%/logo192.png" /&gt;</p>
			<p class="source-code">    &lt;link rel="manifest" href="%PUBLIC_URL%/manifest.json" /&gt;</p>
			<p class="source-code">    &lt;title&gt;React App&lt;/title&gt;</p>
			<p class="source-code">  &lt;/head&gt;</p>
			<p class="source-code">  &lt;body&gt;</p>
			<p class="source-code">    &lt;noscript&gt;</p>
			<p class="source-code">      You need to enable JavaScript to run this app.</p>
			<p class="source-code">    &lt;/noscript&gt;</p>
			<p class="source-code">    &lt;div id="root"&gt;&lt;/div&gt;</p>
			<p class="source-code">  &lt;/body&gt;</p>
			<p class="source-code">&lt;/html&gt;</p>
			<p>As you can see, we can only find one <strong class="source-inline">div</strong> inside the <strong class="source-inline">body</strong> tag: <strong class="source-inline">&lt;div id="root"&gt;&lt;/div&gt;</strong>.</p>
			<p>During the build phase, <strong class="source-inline">create-react-app</strong> will inject the compiled JavaScript and CSS files into this HTML page and use the <strong class="source-inline">root</strong> div as a target container for rendering the whole application.</p>
			<p>That means that once we publish this page to any hosting provider (Vercel, Netlify, Google Cloud, AWS, and so on), the first time we call the desired URL, our browser will first render the preceding HTML. Then, following the <strong class="source-inline">script</strong> and <strong class="source-inline">link</strong> tags contained in the preceding markup (injected by CRA at build time), the browser will render the whole application, making<a id="_idIndexMarker053"/> it available for any sort of interaction.</p>
			<p>The main advantages of CSR are:</p>
			<ul>
				<li><strong class="bold">It makes your app feel like a native app</strong>: Downloading the whole JavaScript bundle<a id="_idIndexMarker054"/> means that you already have every page of your web app downloaded in your browser. If you want to navigate to a different page, it will swap the page content instead of downloading new content from the server. You don't need to refresh the page to update its content.</li>
				<li><strong class="bold">Page transitions made easy</strong>: Client-side navigation allows us to switch from one page to another without reloading the browser window. This comes in handy when you want to show some cool transitions between pages with ease because you don't have any reload that might interrupt your animations.</li>
				<li><strong class="bold">Lazy loading and performances</strong>: With CSR, the browser will only render the minimum HTML markup required for the web app to work. If you have a modal that appears once the user clicks on a button, its HTML markup is not present on the HTML page. It will be created dynamically by React once the button click event occurs.</li>
				<li><strong class="bold">Less server-side workload</strong>: Given that the whole rendering phase is delegated to the browser, the server only needs to send a very basic HTML page to the client. You then don't need a very powerful server; indeed, there are cases where you can host your web app on <strong class="bold">serverless</strong> environments, such as AWS Lambda, Firebase, and<a id="_idIndexMarker055"/> so on.</li>
			</ul>
			<p>But all those benefits come at a cost. As we've previously seen, the server only sends an empty HTML page. If the user's internet connection is slow, the downloading of JavaScript and CSS files will take some seconds to complete, leaving the user waiting with an empty screen for several moments.</p>
			<p>This will also affect your web app SEO score; the search engine spiders will reach your page and will find it empty. Google bots, for instance, will wait for the JavaScript bundle to be transferred but will assign a low-performance score to your website because of their waiting time.</p>
			<p>By default, Next.js renders all the React components inside a given page on the server side (as seen in the previous section) or at build time. In the first chapter, under the Moving from React to <em class="italic">Next.js </em>section, we saw that the Node.js runtime doesn't expose some browser-specific APIs, such as <strong class="source-inline">window</strong> or <strong class="source-inline">document</strong>, or HTML elements, such as <strong class="source-inline">canvas</strong>, so if you try to render any component that needs access to those APIs, the rendering process<a id="_idIndexMarker056"/> will crash.</p>
			<p>There are many different ways to avoid those kinds of problems with Next.js, demanding the rendering of specific components to the browser.</p>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor033"/>Using the React.useEffect hook</h2>
			<p>If you're coming<a id="_idIndexMarker057"/> from <a id="_idIndexMarker058"/>a React version before 16.8.0, you may be used to the <strong class="source-inline">componentDidMount</strong> method of the <strong class="source-inline">React.Component</strong> class. With more modern versions of React, which emphasize the <a id="_idIndexMarker059"/>usage of <strong class="bold">function components</strong>, you can achieve the same results using the <strong class="source-inline">React.useEffect</strong> hook. It will let you perform side effects (such as data fetching and manual DOM changes) inside your function components, and it will do it after the component has been mounted. That means that with Next.js, the <strong class="source-inline">useEffect</strong> callback will run on the browser after React hydration, letting you perform certain actions only on the client side.</p>
			<p>For example, let's pretend that we want to display a code snippet on a web page using the Highlight.js library, making it easy to highlight and make code more readable. We could just create a component called <strong class="source-inline">Highlight</strong>, which would look as follows:</p>
			<p class="source-code">import Head from 'next/head';</p>
			<p class="source-code">import hljs from 'highlight.js';</p>
			<p class="source-code">import javascript from 'highlight.js/lib/languages/javascript';</p>
			<p class="source-code">function Highlight({ code }) {</p>
			<p class="source-code">   hljs.registerLanguage('javascript', javascript);</p>
			<p class="source-code">   hljs.initHighlighting();</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;&gt;</p>
			<p class="source-code">      &lt;Head&gt;</p>
			<p class="source-code">        &lt;link rel='stylesheet' href='/highlight.css' /&gt;</p>
			<p class="source-code">      &lt;/Head&gt;</p>
			<p class="source-code">      &lt;pre&gt;</p>
			<p class="source-code">        &lt;code className='js'&gt;{code}&lt;/code&gt;</p>
			<p class="source-code">      &lt;/pre&gt;</p>
			<p class="source-code">    &lt;/&gt;</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p class="source-code">export default Highlight;</p>
			<p>While this piece <a id="_idIndexMarker060"/>of <a id="_idIndexMarker061"/>code would perfectly run on a client-side React app, it will crash during the rendering or build phase on Next.js because Highlight.js needs the <strong class="source-inline">document</strong> global variable, which does not exist in Node.js, as it's exposed by browsers only.</p>
			<p>You can easily<a id="_idIndexMarker062"/> fix this by wrapping all the <strong class="source-inline">hljs</strong> calls<a id="_idIndexMarker063"/> in the <strong class="source-inline">useEffect</strong> hook:</p>
			<p class="source-code">import { useEffect } from 'react';</p>
			<p class="source-code">import Head from 'next/head';</p>
			<p class="source-code">import hljs from 'highlight.js';</p>
			<p class="source-code">import javascript from</p>
			<p class="source-code"> 'highlight.js/lib/languages/javascript';</p>
			<p class="source-code">function Highlight({ code }) {</p>
			<p class="source-code">  useEffect(() =&gt; {</p>
			<p class="source-code">    hljs.registerLanguage('javascript', javascript);</p>
			<p class="source-code">    hljs.initHighlighting();</p>
			<p class="source-code">  }, []);</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;&gt;</p>
			<p class="source-code">      &lt;Head&gt;</p>
			<p class="source-code">        &lt;link rel='stylesheet' href='/highlight.css' /&gt;</p>
			<p class="source-code">      &lt;/Head&gt;</p>
			<p class="source-code">      &lt;pre&gt;</p>
			<p class="source-code">        &lt;code className='js'&gt;{code}&lt;/code&gt;</p>
			<p class="source-code">      &lt;/pre&gt;</p>
			<p class="source-code">    &lt;/&gt;</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p class="source-code">export default Highlight;</p>
			<p>That way, Next.js will render the HTML markup returned by our component, inject the Highlight.js script into our page, and, once the component is mounted on the browser, it will call the library functions on the client side.</p>
			<p>You can also use that exact approach for rendering a component exclusively on the client side<a id="_idIndexMarker064"/> by <a id="_idIndexMarker065"/>using both <strong class="source-inline">React.useEffect</strong> and <strong class="source-inline">React.useState</strong> together:</p>
			<p class="source-code">import {useEffect, useState} from 'react';</p>
			<p class="source-code">import Highlight from '../components/Highlight';</p>
			<p class="source-code">function UseEffectPage() {</p>
			<p class="source-code">  const [isClient, setIsClient] = useState(false);</p>
			<p class="source-code">  useEffect(() =&gt; {</p>
			<p class="source-code">    setIsClient(true);</p>
			<p class="source-code">  }, []);</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;div&gt;</p>
			<p class="source-code">      {isClient &amp;&amp;</p>
			<p class="source-code">        (&lt;Highlight</p>
			<p class="source-code">          code={"console.log('Hello, world!')"}</p>
			<p class="source-code">          language='js'</p>
			<p class="source-code">        /&gt;)</p>
			<p class="source-code">      }</p>
			<p class="source-code">    &lt;/div&gt;</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p class="source-code">export default UseEffectPage;</p>
			<p>That way, the <strong class="source-inline">Highlight</strong> component<a id="_idIndexMarker066"/> will be <a id="_idIndexMarker067"/>rendered on the browser exclusively.</p>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor034"/>Using the process.browser variable</h2>
			<p>Another way<a id="_idIndexMarker068"/> of avoiding the <a id="_idIndexMarker069"/>server-side process crashing when using browser-specific APIs is to conditionally execute scripts and components depending on the <strong class="source-inline">process.browser</strong> global variable. Indeed, Next.js appends this incredibly useful property to Node.js' <strong class="source-inline">process</strong> object. It is a Boolean value set to <strong class="source-inline">true</strong> when the code runs on the client side and <strong class="source-inline">false</strong> when running on the server. Let's see how it works:</p>
			<p class="source-code">function IndexPage() {</p>
			<p class="source-code">  const side = process.browser ? 'client' : 'server';</p>
			<p class="source-code">  return &lt;div&gt;You're currently on the {side}-side.&lt;/div&gt;;</p>
			<p class="source-code">}</p>
			<p class="source-code">export default IndexPage;</p>
			<p>If you try to run the preceding example, you will notice that for a brief moment, the browser will show the following text: <strong class="bold">You're currently running on the server-side</strong>; it will be replaced by the <strong class="bold">You're currently running on the client-side</strong> text as soon as React hydration occurs.</p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor035"/>Using dynamic component loading</h2>
			<p>As we saw in the<a id="_idIndexMarker070"/> first chapter, Next.js<a id="_idIndexMarker071"/> extends React functionalities by adding some great built-in components and utility functions. One of these is called <strong class="source-inline">dynamic</strong>, and it's one of the most interesting modules provided by the framework.</p>
			<p>Remember the Highlight.js component that we built to understand how to render a component on the browser using the <strong class="source-inline">React.useEffect</strong> hook? Here is another way to render it using the Next.js <strong class="source-inline">dynamic</strong> function:</p>
			<p class="source-code">import dynamic from 'next/dynamic';</p>
			<p class="source-code">const Highlight = dynamic(</p>
			<p class="source-code">  () =&gt; import('../components/Highlight'),</p>
			<p class="source-code">  { ssr: false }</p>
			<p class="source-code">);</p>
			<p class="source-code">import styles from '../styles/Home.module.css';</p>
			<p class="source-code">function DynamicPage() {</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;div className={styles.main}&gt;</p>
			<p class="source-code">      &lt;Highlight</p>
			<p class="source-code">        code={"console.log('Hello, world!')"}</p>
			<p class="source-code">        language='js'</p>
			<p class="source-code">      /&gt;</p>
			<p class="source-code">    &lt;/div&gt;</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p class="source-code">export default DynamicPage;</p>
			<p>With the preceding code, we're importing our <strong class="source-inline">Highlight</strong> component via <strong class="bold">dynamic imports</strong>, specifying that we want it to be executed on the client only thanks to the <strong class="source-inline">ssr: false</strong> option. That way, Next.js won't try to render that component on the server and we'll have to wait for React hydration to make it available on the browser.</p>
			<p>CSR can be a fantastic alternative to SSR for building very dynamic web pages. If you're working on a page that doesn't need to be indexed by search engines, it could make sense to first load your application's JavaScript, and then, from the client side, fetch any necessary data from the server; this would lighten the server-side workload since this approach does not involve SSR and your application could scale better.</p>
			<p>So, here's a question – if we need to build a dynamic page and SEO is not really important (admin pages, private profile pages, and so on), why don't we just send a static page to the<a id="_idIndexMarker072"/> client and load<a id="_idIndexMarker073"/> all the data once the page has been transferred to the browser? We'll explore this possibility in the next section.</p>
			<h1 id="_idParaDest-37"><a id="_idTextAnchor036"/>Static site generation</h1>
			<p>So far, we've seen <a id="_idIndexMarker074"/>two different ways of rendering our web apps: on the client side and server side. Next.js gives us a third option called <strong class="bold">static site generation</strong> (<strong class="bold">SSG</strong>).</p>
			<p>With SSG, we will be able to pre-render some specific pages (or even the whole website if necessary) at build time; that means that when we're building our web app, there might be some pages that won't change their content very often, so it makes sense for us to serve them as static assets. Next.js will render these pages during the build phase and will always serve that specific HTML that, just like SSR, will become interactive thanks to the React hydration process.</p>
			<p>SSG brings a lot of advantages when compared to both CSR and SSR:</p>
			<ul>
				<li><strong class="bold">Easy to scale</strong>: Static<a id="_idIndexMarker075"/> pages are just HTML files that can be served and cached easily by any <strong class="bold">content delivery network</strong> (from<a id="_idIndexMarker076"/> now on, <strong class="bold">CDN</strong>). But even if you want to serve them using your own web server, it will result in a very low workload, given that no hard computations are needed for serving a static asset.</li>
				<li><strong class="bold">Outstanding performances</strong>: As said before, the HTML is pre-rendered at build time, so both the client and server can bypass the runtime rendering phase for each request. The web server will send the static file and the browser will just display it, as easy as that. No data fetching is required on the server side; everything we need is already pre-rendered inside the static HTML markup, and that reduces the potential latency for each request.</li>
				<li><strong class="bold">More secure requests</strong>: We don't need to send any sensitive data to the web server for rendering the page, and that makes life a bit harder for malicious users. No access to <a id="_idIndexMarker077"/>APIs, databases, or other private information is required because every piece of information needed is already part of the pre-rendered page.</li>
			</ul>
			<p>SSG is probably one of<a id="_idIndexMarker078"/> the best solutions for building performant and highly scalable frontend applications. The biggest concern about this rendering technique is that once the page has been built, the content will remain the same until the next deployment.</p>
			<p>For instance, let's pretend that we're writing a blog post and we misspell a word in the title. Using other static site generators, such as Gatsby or Jekyll, we would need to rebuild the whole website to change just a word in a blog post title because we would need to repeat the data fetching and rendering phase at build time. Remember what we said at the beginning of this section: statically generated pages are created at build time and served as static assets for each request.</p>
			<p>While this is true for other static site generators, Next.js provides a unique approach for solving this <a id="_idIndexMarker079"/>problem: <strong class="bold">incremental static regeneration</strong> (<strong class="bold">ISR</strong>). Thanks to ISR, we can specify at the page level how long Next.js should wait before re-rendering a static page updating its content.</p>
			<p>For instance, let's say that we want to build a page showing some dynamic content, but the data fetching phase, for some reason, takes too long to succeed. This would lead to bad performance, giving our users a terrible user experience. A combination of SSG and ISR would solve this problem by taking a hybrid approach between SSR and SSG.</p>
			<p>Let's pretend we've built a very complex dashboard that can handle a lot of data… but the REST API request for this data is taking up to a few seconds to succeed. In that case, we are lucky <a id="_idIndexMarker080"/>because that data won't change a lot during this time, so we can <strong class="bold">cache</strong> it for up to 10 minutes (600 seconds) using SSG and ISR:</p>
			<p class="source-code">import fetch from 'isomorphic-unfetch';</p>
			<p class="source-code">import Dashboard from './components/Dashboard';</p>
			<p class="source-code">export async function getStaticProps() {</p>
			<p class="source-code">  const userReq = await fetch('/api/user');</p>
			<p class="source-code">  const userData = await userReq.json();</p>
			<p class="source-code">  const dashboardReq = await fetch('/api/dashboard');</p>
			<p class="source-code">  const dashboardData = await dashboardReq.json();</p>
			<p class="source-code">  return {</p>
			<p class="source-code">    props: {</p>
			<p class="source-code">      user: userData,</p>
			<p class="source-code">      data: dashboardData,</p>
			<p class="source-code">    },</p>
			<p class="source-code">    revalidate: 600 // time in seconds (10 minutes)</p>
			<p class="source-code">  };</p>
			<p class="source-code">}</p>
			<p class="source-code">function IndexPage(props) {</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;div&gt;</p>
			<p class="source-code">      &lt;Dashboard</p>
			<p class="source-code">        user={props.user}</p>
			<p class="source-code">        data={props.data}</p>
			<p class="source-code">      /&gt;</p>
			<p class="source-code">    &lt;/div&gt;</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p class="source-code">export default IndexPage;</p>
			<p>We're now using a function called <strong class="source-inline">getStaticProps</strong>, which looks similar to the <strong class="source-inline">getServerSideProps</strong> one that we saw in the previous section. As you may have guessed, <strong class="source-inline">getStaticProps</strong> is used at build time by Next.js for getting the data and rendering the page, and <a id="_idIndexMarker081"/>it won't be called again until the next build. As said before, while this can be incredibly powerful, it comes with a cost: if we want to update the page content, we have to rebuild the entire website.</p>
			<p>To avoid the whole website rebuild, Next.js recently introduced an option called <strong class="source-inline">revalidate</strong>, which can be set inside the returning object of our <strong class="source-inline">getStaticProps</strong> function. It indicates after how many seconds we should rebuild the page once a new request arrives.</p>
			<p>In the preceding code, we've set our <strong class="source-inline">revalidate</strong> option to <strong class="source-inline">600</strong> seconds, so Next.js will behave as follows:</p>
			<ol>
				<li value="1">Next.js fills the page with the results of <strong class="source-inline">getStaticProps</strong> at build time, statically generating the page during the build process.</li>
				<li>In the first 10 minutes, every user will access the exact same static page.</li>
				<li>After 10 minutes, if a new request occurs, Next.js will server-side render that page, re-execute the <strong class="source-inline">getStaticProps</strong> function, save and cache the newly rendered page as a static asset, overriding the previous one created at build time.</li>
				<li>Every new request, within the next 10 minutes, will be served with that new statically generated page.</li>
			</ol>
			<p><em class="italic">Remember that the ISR process is lazy, so if no requests occur after 10 minutes, Next.js won't rebuild its pages.</em></p>
			<p>In case you're wondering, at the moment there's no way of forcing ISR revalidation via the API; once your website has been deployed, you'll have to wait the length of the expiration time set in the <strong class="source-inline">revalidate</strong> option for the page to be rebuilt.</p>
			<p>Static-site generation is a great way to create fast and secure web pages, but sometimes we might want to have more dynamic content. Thanks to Next.js, we can always decide which page should be rendered at build time (SSG) or request time (SSR). We can take the best of both<a id="_idIndexMarker082"/> approaches by using SSG + ISR, making our pages a "hybrid" between SSR and SSG, and that's a game-changer for modern web development.</p>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor037"/>Summary</h1>
			<p>In this chapter, we've seen three different rendering strategies and why Next.js brings them to a whole new level with its hybrid rendering approach. We've also seen the benefits of these strategies, when we want to use them, and how they can affect the user experience or the server workload. We will always keep an eye on these rendering methodologies during the following chapters, adding more and more examples and use cases for each of them. They are the core concepts behind the choice of using Next.js as a framework.</p>
			<p>In the next chapter, we're going to have a closer look at some of the most useful built-in Next.js components, its routing system, and how to manage metadata dynamically for improving both SEO and user experience.</p>
		</div>
	</body></html>