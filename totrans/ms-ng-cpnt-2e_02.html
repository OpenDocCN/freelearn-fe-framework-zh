<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Ready, Set, Go!</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will start building our task management application. We'll jump right into the core of the application and create the initial components required to manage a simple task list.</p>
<p>In the process of going through this chapter, you'll learn about the following topics:</p>
<ul>
<li>Introduction to <kbd>NgModule</kbd></li>
<li>Bootstrapping an Angular application using a main module</li>
<li>Component input and output</li>
<li>Host property binding</li>
<li>Styling and view encapsulation</li>
<li>Using <kbd>EventEmitter</kbd> to emit custom events</li>
<li>Component life cycle</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Managing tasks</h1>
                </header>
            
            <article>
                
<p>After picking up the basics from the previous chapter, we will now go on and create a task management application together in the upcoming chapters. You'll learn about some concepts during these chapters and then use them with practical examples. You'll also learn how to structure an application using components. This begins with the folder structure and ends with setting up the interaction between components.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Vision</h1>
                </header>
            
            <article>
                
<p>The task management application, which we're going to create during the course of this book, should enable users to manage tasks easily and help them organize small projects. Usability is the central aspect of any application; therefore, you'll need to design a modern and flexible user interface that will support the users managing their tasks:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/bfbc15e1-5f86-4f48-9c80-2ccf9f0c5e12.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">A preview of the task management application we are going to build</div>
<p>Our task management application will consist of components that will allow us to design a platform, providing a great user experience for the purpose of managing tasks. Let's define the core features of our application:</p>
<ul>
<li>Managing tasks within multiple projects and providing a project overview</li>
<li>Simple scheduling as well as a time-and-effort-tracking mechanism</li>
<li>Overviewing the DASHBOARD using graphical charts</li>
<li>Tracking activities and providing a visual audit log</li>
<li>A simple commenting system that will work across different components</li>
</ul>
<p>The task management application is the main example in this book. Therefore, the building blocks within this book should only contain the code that is relevant to the theme of this book. Of course, other than components, an application needs other functionalities, such as visual design, data, session management, and other important parts, to work. While the required code for each chapter can be downloaded online, we'll only discuss the code that is relevant to the topics that we will be learning about in this book.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Starting from scratch</h1>
                </header>
            
            <article>
                
<p>Let's start out by creating a new Angular project using the Angular CLI. We'll name it <kbd>mastering-angular-components</kbd>:</p>
<ol>
<li>Open a console window and navigate to a proper workspace for our project. Let's use the Angular CLI to create our initial project structure:</li>
</ol>
<pre style="padding-left: 60px"><strong>ng new mastering-angular-components --prefix=mac</strong></pre>
<ol start="2">
<li>After the project has been successfully created, let's move into the project folder and start serving using the <kbd>ng serve</kbd> command:</li>
</ol>
<pre style="padding-left: 60px"><strong>cd mastering-angular-components</strong><br/><strong>ng serve</strong></pre>
<p>After following the preceding steps, you should be able to open up your browser and point it to <kbd>http://localhost:4200</kbd>. You should be able to see the generated application app with a welcome message saying <span class="packt_screen">Welcome to mac!</span>.</p>
<div class="packt_tip">It's recommended that you leave the serving mode of the CLI running all the time while in development. Since the underlying webpack will use caching when recompiling the output bundles, it will speed up your development process quite a lot. I recommend that you always have a second command-line window open and start Angular CLI in serve mode there.</div>
<p>Let's examine what the <span>Angular CLI tool has created for us</span> so far. Along with a lot of files that we'll cover in later chapters, the Angular CLI tool has created the core files that are needed in order to assemble a simple Angular application. The following directory listing shows all the critical files, which you'll also find within your generated project folder:</p>
<pre><strong>mastering-angular-components</strong><br/><strong>├── node_modules</strong><br/><strong>├── package.json</strong><br/><strong>└── src</strong><br/><strong>    ├── app</strong><br/><strong>    │   ├── app.component.css</strong><br/><strong>    │   ├── app.component.html</strong><br/><strong>    │   ├── app.component.ts</strong><br/><strong>    │   └── app.module.ts</strong><br/><strong>    ├── index.html</strong><br/><strong>    ├── styles.css</strong><br/><strong>    └── main.ts</strong></pre>
<p>Let's take a quick look at these dependencies, development dependencies, and their purpose:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td style="width: 26.2149%">
<p><strong>File(s)</strong></p>
</td>
<td style="width: 73.3011%">
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td style="width: 26.2149%">
<p><kbd>package.json</kbd><br/>
<kbd>node_modules</kbd></p>
</td>
<td style="width: 73.3011%">
<p>Since the Angular CLI uses Node.js for tooling, our project contains a <kbd>package.json</kbd> to store all required dependencies and their versions. Node dependencies get installed within the <kbd>node_modules</kbd> folder.</p>
<p>If you want to check which version of Angular has been installed along with your project, you can check the dependencies within the <kbd>package.json</kbd> file.</p>
</td>
</tr>
<tr>
<td style="width: 26.2149%">
<p><kbd>src/index.html</kbd></p>
</td>
<td style="width: 73.3011%">
<p>The main HTML file of your project. Within this file, you'll find the host element of your root component. This is the place where you root or main component will be rendered. Just open the file and you'll notice an element called <kbd>&lt;mac-root&gt;</kbd>. Since we've specified the prefix <kbd>mac</kbd> when creating our project using the Angular CLI, all our components and therefore all our component host elements contain this prefix.</p>
</td>
</tr>
<tr>
<td style="width: 26.2149%">
<p><kbd>src/main.ts</kbd></p>
</td>
<td style="width: 73.3011%">
<p>This is the main entry file of our TypeScript project code. It contains all the necessary code to start Angular and bootstrap our main application module.</p>
</td>
</tr>
<tr>
<td style="width: 26.2149%">
<p><kbd>src/styles.css</kbd></p>
</td>
<td style="width: 73.3011%">
<p>Any global CSS styles we'd like to apply to our application website go here.</p>
</td>
</tr>
<tr>
<td style="width: 26.2149%">
<p><kbd>src/app/app.module.ts</kbd></p>
</td>
<td style="width: 73.3011%">
<p>The main <kbd>NgModule</kbd> of your Angular project. This module is bootstrapped when your application is starting up. It contains references to your project components and specifies your main entry component, which should be rendered at startup.</p>
</td>
</tr>
<tr>
<td style="width: 26.2149%">
<p><kbd><span>src/app/app.component.ts<br/></span></kbd></p>
<p><kbd><span>src/app/app.component.html<br/></span></kbd></p>
<p><kbd><span>src/app/app.component.css<br/></span></kbd></p>
</td>
<td style="width: 73.3011%">
<p>The main component of your Angular application. This component represents the outermost component, sometimes just called app or root component. The TypeScript, HTML, and CSS code is separated into different files by default. This can also be changed so that everything is embedded within the TypeScript file. However, following a good separation practice, it makes absolute sense to have all concerns about the component in individual files.</p>
</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Main application component</h1>
                </header>
            
            <article>
                
<p>Let's take a look at our main application component. You can think of it as the outermost component of your application. It's called the main component because it represents your whole application. This is where your component tree has its roots and therefore it's sometimes also called the root component.</p>
<p>First, let's look at the component TypeScript file located in <kbd>src/app/app.component.ts</kbd>:</p>
<pre>import {Component} from '@angular/core';<br/><br/>@Component({<br/>  selector: 'mac-root',<br/>  templateUrl: './app.component.html',<br/>  styleUrls: ['./app.component.css']<br/>})<br/>export class AppComponent {<br/>  title = 'mac';<br/>} </pre>
<p>There's nothing different here from what we already know about structuring a component, something that we learned in the previous chapter. However, there are two main differences here compared to how we created the components before. Instead of using the <kbd>template</kbd> property to write our HTML template inline, we're using the <kbd>templateUrl</kbd> property to tell Angular to load the HTML from the specified file. The second thing which we've not covered yet is how to load CSS for your component. The <kbd>styleUrls</kbd> property allows us to specify an array of URLs which get resolved to assemble the styles of our component. Similar to the HTML template mechanism, we could also use a property called <kbd>styles</kbd> to write our styles inline within the component TypeScript file.</p>
<p>For our application, we'd like to change the behaviour slightly on how we handle styling. The default way of organizing styles when creating components is that each component contains its own encapsulated styles. However, for our project, we want to use the global <kbd>styles.css</kbd> file to add all our component styles. This will make it much easier to work with the books source repository and eliminates the need to include CSS code excerpts within this book.</p>
<p><span>By default, Angular uses a Shadow DOM emulation on our components, which is preventing styles within a component to leak outside and influence other components. However, this behaviour can be changed easily by configuring the view encapsulation on components.</span></p>
<p>Angular has three ways to handle view encapsulation and each way has its own pros and cons. Let's look at the different settings:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Encapsulation type</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>ViewEncapsulation.Emulated</kbd></p>
</td>
<td>
<p>If a component is set to emulated view encapsulation, it will emulate style encapsulation by attaching the generated attributes to the component element and modifying CSS selectors to include these attribute selectors. This will enable certain forms of encapsulation, although the outer styles can still leak into the component if there are other global styles.</p>
<p>This view encapsulation mode is the default mode, if not specified otherwise.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>ViewEncapsulation.Native</kbd></p>
</td>
<td>
<p>Native view encapsulation is supposed to be the ultimate goal of the view encapsulation concept within Angular. It makes use of Shadow DOM, as described in the previous chapter, to create an isolated DOM for the whole component. This mode depends on the browser to support Shadow DOM natively, and therefore, can't always be used. It's also important to note that global styles will no longer be respected and local styles need to be placed within the component in inline style tags (or use the <kbd>styles</kbd> property on the component annotation).</p>
</td>
</tr>
<tr>
<td>
<p><kbd>ViewEncapsulation.None</kbd></p>
</td>
<td>
<p>This mode tells Angular not to provide any template or style encapsulation. Within our application, we rely on styles coming from a global CSS; therefore, we use this mode for most of the components. Neither Shadow DOM, nor attributes will be used to create style encapsulation; we can simply use the classes specified within our global CSS file.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Let's change the view encapsulation of our main component to use the <kbd>ViewEncapsulation.None</kbd> mode. Since we're going to put all our styles in the global <kbd>src/styles.css</kbd> file, we can also remove the <kbd>styleUrls</kbd> property from our component configuration completely:</p>
<pre>import {Component, ViewEncapsulation} from '@angular/core';<br/><br/>@Component({<br/>  selector: 'mac-root',<br/>  templateUrl: './app.component.html',<br/>  encapsulation: ViewEncapsulation.None<br/>})<br/>export class AppComponent {<br/>  title = 'mac';<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Resource download</h1>
                </header>
            
            <article>
                
<p>The goal of the first few chapters of this book is to build our application from scratch. There's some code which is necessary to build an application, which does not exactly meet the topic of this book, <span>to master the creation of a solid component architecture</span>. One of those things is CSS styling. Although an integral part of everything built with web technology, it's definitely not something to be bothered too much by in this book.</p>
<p>For this purpose, I've prepared all the CSS styling which is used within the components created throughout this book. Before you continue working on your application, you should download these styles and apply them to your project. <span>Please find the exact download link in the download section of <a href="">Chapter 11</a>, </span><em>Task Management Application Source Code</em><span>.</span></p>
<p>Place the downloaded StyleSheet into the <kbd>src</kbd> folder of your project where it will replace the existing <kbd>styles.css</kbd> file.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Main application NgModule</h1>
                </header>
            
            <article>
                
<p>Let's also take a look at the main <kbd>NgModule</kbd> generated by the Angular CLI. You can find it in the path <kbd>src/app/app.module.ts</kbd>:</p>
<pre>import {BrowserModule} from '@angular/platform-browser';<br/>import {NgModule} from '@angular/core';<br/>import {AppComponent} from './app.component';<br/><br/>@NgModule({<br/>  declarations: [AppComponent],<br/>  imports: [BrowserModule],<br/>  bootstrap: [AppComponent],<br/>  providers: []<br/>})<br/>export class AppModule { }</pre>
<p>If you've been following the section <em>Angular NgModule</em>, about <kbd>NgModule</kbd> within the first chapter of this book, there should not be any surprises when looking at our generated main application module.</p>
<p>Our application currently only consists of one component, the <kbd>AppComponent</kbd>, which we're declaring within our <kbd>AppModule</kbd>. We also specify that this component should be bootstrapped when this module is being bootstrapped.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Bootstrapping</h1>
                </header>
            
            <article>
                
<p>The starting point of our project is located within the <kbd>src/main.ts</kbd> file. This file is responsible for bootstrapping the Angular framework and starting our applications main module.</p>
<p class="mce-root">We can go ahead and bootstrap our Angular application by providing our main application module, <kbd>AppModule</kbd>.</p>
<p class="mce-root">In order to bootstrap an Angular module, we first need to create a platform. There are many ways for different platforms and environments to create a platform. If you'd like to create a browser platform, which is the default platform for browser environments, we need to import the platform factory function <kbd>platformBrowserDynamic</kbd> from the <kbd>@angular/platform-browser-dynamic</kbd> module. Simply by calling the platform factory function, we will receive an instance of the newly created platform. On the platform instance, we can then call the <kbd>bootstrapModule</kbd> function, passing our main application module as a parameter:</p>
<pre>import {platformBrowserDynamic} from '@angular/platform-browser-dynamic';<br/>import {AppModule} from './app/app.module';<br/><br/>platformBrowserDynamic().bootstrapModule(AppModule)<br/>  .catch(err =&gt; console.log(err));</pre>
<p>Let's take a closer look at the steps involved in the bootstrapping mechanism of Angular. We should try to understand how our root component is getting rendered in the right place by calling the <kbd>bootstrapModule</kbd> function on the platform instance:</p>
<ol>
<li>First, we call the <kbd>bootstrapModule</kbd> function on our platform instance, passing our main application module as a parameter</li>
<li>Angular will examine our main application module metadata and find the <kbd>AppComponent</kbd> listed in the <kbd>bootstrap</kbd> property of the <kbd>NgModule</kbd> configuration</li>
<li>By evaluating the metadata on the <kbd>AppComponent</kbd>, looking at the <kbd>selector</kbd> property, Angular will know where to render our root component</li>
<li>The <kbd>AppComponent</kbd> is rendered as our root component into the host element found within the <kbd>index.html</kbd> file matching the CSS selector in the <kbd>selector</kbd> property on the component metadata</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the application</h1>
                </header>
            
            <article>
                
<p>To make sure our modifications to the main component, <kbd>AppComponent</kbd>, are working as expected and we didn't break anything, let's start our application using the Angular CLI. Open a command line and point it to your project directory. Then, start the CLI in serve mode:</p>
<pre><strong>ng serve</strong></pre>
<p>If everything goes well, you will have an open web browser that shows <span class="packt_screen">Welcome to mac!</span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Recap</h1>
                </header>
            
            <article>
                
<p>Let's recap what we have done so far:</p>
<ol>
<li>We initialized a new project using Angular CLI</li>
<li>We modified our main application component in <kbd>src/app/app.component.ts</kbd> to include <kbd>ViewEncapsulation.None</kbd> for enabling global styles</li>
<li>We've looked at the generated <kbd>MainModule</kbd> as well as the bootstrapping happening within our main entry file <kbd>src/main.ts</kbd></li>
<li>Finally, we used the Angular CLI to start our application</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a task list</h1>
                </header>
            
            <article>
                
<p>Now that we have our main application component set up, we can go on and start fleshing out our task management application. The second component that we're going to create will be responsible for listing tasks. Following the concept of composition, we'll create a task list component as a subcomponent of our main application component.</p>
<p>Let's create a new component for our task list by using the Angular CLI generator functionality. We already want to structure our application by area, where we put all task-relevant components into a <kbd>tasks</kbd> subfolder:</p>
<pre><strong>ng generate component --spec false -ve none tasks/task-list</strong></pre>
<p>Using the <kbd>--spec false</kbd> option while generating our component, we can skip creating test specifications. Since we're going to cover testing in a later chapter, we're skipping this process for the moment. Also, by using the <kbd>-ve none</kbd> parameter, we can tell Angular to create the component using <kbd>ViewEncapsulation.None</kbd> as a default encapsulation setting.</p>
<div class="packt_infobox">If you're using the Angular CLI tool to generate components, they will be automatically added to your main module. This is really handy and offloads a lot of boilerplate work on your side. If you're creating a component manually, you should never forget to include the newly created component within your <kbd>NgModule</kbd> declarations.</div>
<p>Let's open the generated file <kbd>src/app/tasks/task-list.ts</kbd> and do some modifications to it:</p>
<pre>import {Component, ViewEncapsulation} from '@angular/core';

@Component({ 
  selector: 'mac-task-list',<br/>  templateUrl: './task-list.component.html',<br/>  encapsulation: ViewEncapsulation.None <br/>})<br/>export class TaskListComponent {<br/>  tasks = [<br/>    {id: 1, title: 'Task 1', done: false}, <br/>    {id: 2, title: 'Task 2', done: true}<br/>  ];<br/>}</pre>
<p>We've created a very simple task list component that has a list of tasks stored internally. This component will be attached to HTML elements that match the CSS element selector <kbd>mac-task-list</kbd>.</p>
<p>Now, let's create a view template for this component to display the tasks. As you can see from the <kbd>templateUrl</kbd> property within the component metadata, we are looking for a file called <kbd>task-list.component.html</kbd>.</p>
<p>Let's change the content of this file to match the following excerpt:</p>
<pre>&lt;div *ngFor="let task of tasks"&gt; 
  &lt;input type="checkbox" [checked]="task.done"&gt; 
  &lt;div&gt;{{task.title}}&lt;/div&gt; 
&lt;/div&gt; </pre>
<p>We use the <kbd>NgFor</kbd> directive to repeat the outermost DIV element for as many tasks as we have on the task list of our component. The <kbd>NgFor</kbd> directive in Angular will create a template element from its underlying content and instantiate as many elements from the template as the expression evaluates to. We currently have two tasks in our task list component, so this will create two instances of our template.</p>
<p>All that's left to do in order to make our task list work is include the task list component within the main application component. We can go ahead and modify our <kbd>src/app/app.component.html</kbd> file and change its content to match the following:</p>
<pre>&lt;mac-task-list&gt;&lt;/mac-task-list&gt;</pre>
<p>This was the last change we needed to make in order to make our task list component work. To view your changes, you can start the serving mode of Angular CLI, if you don't have it running already.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Recap</h1>
                </header>
            
            <article>
                
<p>Let's look at what we did in the previous building block. We achieved a simple listing of tasks within an encapsulated component by following these steps:</p>
<ol>
<li>We created the component TypeScript file that contains the logic of our component</li>
<li>We created the component's view within a separate HTML file</li>
<li>We included the component HTML element within our main application view template</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The right size of components</h1>
                </header>
            
            <article>
                
<p>Our task list is displayed correctly and the code we used to achieve this looks quite okay. However, if we want to follow a better approach for composition, we should rethink the design of our task list component. If we draw a line at enlisting the task list's responsibilities, we would come up with things such as listing tasks, adding new tasks to the list, sorting or filtering the task list; however, operations are not performed on an individual task itself. Also, rendering the task itself falls outside of the responsibilities of the task list. The task list component should only serve as a container for tasks.</p>
<p>If we look at our code again, we will see that we're violating the single responsibility principle and rendered the whole task body within our task list component. Let's take a look at how we can fix this by increasing the granularity of our components.</p>
<p>The goal now is to do a code refactoring exercise, also known as extraction. We are pulling our task's relevant template out of the task list template and creating a new component that encapsulates the tasks.</p>
<p>Let's use the Angular CLI to create a new task component. Open a command line and enter the root folder of our application. Execute the necessary code to create the task component:</p>
<pre><strong>ng generate component --spec false -ve none tasks/task</strong></pre>
<p>This will generate a new folder which includes all the code for our new task component. Now, let's open the HTML template on the path <kbd>src/app/tasks/task/task.component.html</kbd> and change the content to represent a single task:</p>
<pre>&lt;input type="checkbox" [checked]="task.done"&gt; 
&lt;div&gt;{{task.title}}&lt;/div&gt; </pre>
<p>The content of our new <kbd><span>task.component.html</span></kbd> file is pretty much the same as what we already have within our task list component. However, within the newly created task component, we're only concerned about what a task looks like and not about the whole list of tasks.</p>
<p>Let's change the task component TypeScript file located on the path <kbd>src/app/tasks/task/task.component.ts</kbd>:</p>
<pre>import {Component, Input, ViewEncapsulation} from '@angular/core'; 
 
@Component({ 
  selector: 'mac-task',
  templateUrl: './task.component.html', 
  encapsulation: ViewEncapsulation.None 
}) 
export class TaskComponent {
  @Input() task: any; 
}</pre>
<p>In the previous chapter of this book, we spoke about encapsulation and the preconditions to establish a clean encapsulation for UI components. One of these preconditions is the possibility to design proper interfaces in and out of the component. Such input and output methods are necessary to make the component work within compositions. That's how a component will receive and publish information.</p>
<p>As you can see from our task component implementation, we are now building such an interface using the <kbd>@Input</kbd> decorator on a class instance property. In order to use this decorator, we will first need to import it from the angular core module.</p>
<p>Input properties in Angular allow us to bind expressions in our templates to class instance properties on our components. This way, we can pass data from the outside of the component to the component inside, using the component's template. This can be thought of as an example of one-way binding, from the view of a parent component to the child component instance.</p>
<p>If we're using property binding on a regular DOM property, Angular will create a binding of the expression directly to the element's DOM property. We're using such a type of binding to bind the task completed flag to the <kbd>checked</kbd> property of the checkbox's <kbd>input</kbd> element:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Usage</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>@Input() inputProp;</kbd></p>
</td>
<td>
<p>This allows us to bind the <kbd>inputProp</kbd> attribute to the component element within the parent component.</p>
<p>Angular assumes that the attribute on the host element has the same name as that of the <kbd>input</kbd> property.</p>
<p> </p>
</td>
</tr>
<tr>
<td>
<p><kbd>@Input('inp') inputProp;</kbd></p>
</td>
<td>
<p>You can also override the name of the attribute that should be mapped to this input. Here, the <kbd>inp</kbd> attribute of the component's host element is mapped to the component's input property, <kbd>inputProp</kbd>.</p>
</td>
</tr>
</tbody>
</table>
<div class="packt_figure"/>
<p> </p>
<p>The last missing piece so that we can use our newly created task component is the modification of the existing template of the task list.</p>
<p>We include the task component within our task list template by using a <kbd>&lt;mac-task&gt;</kbd> element, as specified in the selector within our task component. Also, we need to create an input binding on the task component to pass the <kbd>task</kbd> object from the current <kbd>NgFor</kbd> iteration to the <kbd>task</kbd> input of the <kbd>task</kbd> component. We need to replace all the existing content in the <kbd>src/app/tasks/task-list/task-list.component.html</kbd> file with the following lines of code:</p>
<pre>&lt;mac-task *ngFor="let task of tasks"
          [task]="task"&gt;&lt;/mac-task&gt; </pre>
<p>Congratulations! You've successfully refactored your task list by extracting the task into its own component and established a clean composition, encapsulation, and single responsibility. Also, we can now say that our task list is a composition of tasks.</p>
<p>If you think about maintainability and re-usability, this was actually a very important step in the process of building our application. You should constantly look out for such composition opportunities, and if you feel something could be arranged into multiple subcomponents, you should probably go for it. Of course, you can also overdo this. There's simply no golden rule to determine what granularity of composition is the right one. </p>
<div class="packt_tip"><span>The right granularity of composition and encapsulation for a component architecture always depends on the context. My personal tip here is to use known principles from OOP, such as single responsibility, to lay the groundwork for a good design of your component tree. Always make sure your components are only doing things that they are supposed to do as their names suggest. A task list has the responsibility of listing tasks and providing some filters or other controls for the list. The responsibility of operating on individual task data and rendering the necessary view clearly belongs to a task component and not the task list.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Recap</h1>
                </header>
            
            <article>
                
<p>In this building block, we cleaned up our component tree and established clean encapsulation using subcomponents. Then, we set up the interfaces provided by Angular using input bindings. We performed these actions by following the ensuing steps:</p>
<ol>
<li>We created a task subcomponent</li>
<li>We used the task subcomponent with the task list component</li>
<li>We used input bindings and DOM element property bindings to establish one-way data binding in the task component</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding tasks</h1>
                </header>
            
            <article>
                
<p>Our task list looks nice already, but it would be quite useless if the user is unable to add new tasks to the list. Let's create a component for entering new tasks together. Let's create a new component with the responsibilities of handling all the UI logic necessary for entering a new task to our list.</p>
<p>Let's use the Angular CLI tool to create a new component stub:</p>
<pre><strong>ng generate component --spec false -ve none tasks/enter-task</strong></pre>
<p>Open up the template of the newly created component located at <kbd>src/app/tasks/enter-task/enter-task.component.html</kbd> and apply the following changes:</p>
<pre>&lt;input type="text"
       placeholder="Enter new task title..." 
       #titleInput&gt; 
&lt;button (click)="enterTask(titleInput)"&gt; 
  Add Task 
&lt;/button&gt;</pre>
<p>This template consists of an input field as well as a button to enter a new task. If you take a closer look at the input field, you can see that we've added a special attribute called <kbd>#titleInput</kbd>. This is called a local view reference and we can use this reference within the current component view, or query for the element within our component code.</p>
<p>In this case, we are actually using the local view reference to pass the input field DOM element to the <kbd>enterTask</kbd> function that we call on a click event on the <kbd>Add Task</kbd> button. All local view references are available as variables within expressions in the view of a component.</p>
<p>Let's take a look at the implementation of our component class for entering a new task. For this, we need to replace the generated code in the <kbd><span>src/app/tasks/enter-task/enter-task.component.ts</span></kbd> file with the following code:</p>
<pre>import {Component, Output, ViewEncapsulation, EventEmitter} from '@angular/core'; 
 
@Component({ 
  selector: 'mac-enter-task',
  templateUrl: './enter-task.component.html', 
  encapsulation: ViewEncapsulation.None 
}) 
export class EnterTaskComponent {
  @Output() outEnterTask = new EventEmitter&lt;string&gt;();<br/>  enterTask(titleInput: HTMLInputElement) { 
    this.outEnterTask.emit(titleInput.value); 
    titleInput.value = '';  
    titleInput.focus();
  } 
} </pre>
<p>For this component, we've chosen a design approach where we use a loose relation to our task list where the actual task will be created. Although this component is closely related to the task list, it's better to keep the components as loosely coupled as possible.</p>
<p>One of the simplest forms of inversion of control, a callback function or event listener is a great principle to establish loose coupling. In this component, we are using the <kbd>@Output</kbd> decorator to create an event emitter. The output properties need to be instance properties that hold an event emitter within the component. On the component's host element, we can then use event bindings to capture any events emitted. This gives us a great flexibility that we can use to create a clean application design, where we glue components together through the binding within the view:</p>
<div class="packt_infobox"><span>Most of the time, your output names will clash with your component instance methods names. For this purpose, it's advised that you stick to some naming conventions when naming your outputs and methods which will trigger the outputs. Within this book, we are sticking to the naming convention of prefixing all output names with the prefix "out". This way, we can avoid name clashes and still keep names similar.</span></div>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Usage</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>@Output() outputProp = new EventEmitter()</kbd>;</p>
</td>
<td>
<p>When <kbd>outputProp.emit()</kbd> is called, a custom event with the name <kbd>outputProp</kbd> will be emitted on the component. Angular will look for event bindings on the component's HTML element (where the component is used) and execute them:</p>
<pre>&lt;my-comp (outputProp)="doSomething()"&gt;   </pre>
<p>Within the expressions in event bindings, you will always have access to a synthetic variable called <kbd>$event</kbd>. This variable is a reference to the data emitted by the event emitter.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>@Output('out') outputProp = new EventEmitter();</kbd></p>
</td>
<td>
<p>Use this way of declaring your output properties if you'd want to name your events differently from what your property name is. In this example, a custom event with the name <kbd>out</kbd> will be fired when <kbd>outputProp.emit()</kbd> is called:</p>
<pre>&lt;my-comp (out)= "doSomething()"&gt;   </pre></td>
</tr>
</tbody>
</table>
<div class="packt_figure"/>
<p> </p>
<p>Okay, let's use our newly created component to add new tasks to our task list component. First, let's modify the existing template of the task list component. Open the task list template file, <kbd>src/app/tasks/task-list/task-list.component.html</kbd>. We need to add the <kbd>enter-task</kbd> component to the template and also handle the custom event that we're going to emit, once a new task is entered:</p>
<pre>&lt;mac-enter-task (outEnterTask)="addTask($event)"&gt;&lt;/mac-enter-task&gt;<br/>&lt;div class="tasks"&gt;
  &lt;mac-task *ngFor="let task of tasks"  
            [task]="task"&gt;&lt;/mac-task&gt; <br/>&lt;/div&gt;</pre>
<p>Since the output property within the enter task component is called <kbd>outEnterTask</kbd>, we can bind it with the event binding attribute <kbd>(outEnterTask)=""</kbd> on the host element of the component.</p>
<p>Within the event binding expression, we then call a function on our task list component called <kbd>addTask</kbd>. We also use the synthetic variable <kbd>$event</kbd>, which contains the task title emitted from the enter task component. Now, whenever we push the button in our enter task component and an event gets emitted from the component, we catch the event in our event binding and handle it within the task list component.</p>
<p>We also need to make some minor changes to the task list component's TypeScript file. We need to implement the <kbd>addTask</kbd> function, which gets called within the template of the task list component. Let's open <kbd>src/app/tasks/task-list/task-list.component.ts</kbd> and modify it with the following changes:</p>
<pre>import {Component, ViewEncapsulation} from '@angular/core';<br/><br/>@Component({<br/>  selector: 'mac-task-list',<br/>  templateUrl: './task-list.component.html',<br/>  encapsulation: ViewEncapsulation.None<br/>})<br/>export class TaskListComponent {<br/>  tasks = [<br/>    {id: 1, title: 'Task 1', done: false},<br/>    {id: 2, title: 'Task 2', done: true}<br/>  ];<br/><br/>  addTask(title: string) {<br/>    this.tasks.push({<br/>      title, done: false<br/>    });<br/>  }<br/>}</pre>
<p>We have created a function, <kbd>addTask</kbd>, which will add a new task to our task list with a title that is passed to the function. Now, the loop is closed and our event from the enter task component is forwarded to this function within the view of the task list component.</p>
<p>Now is a good time to preview your changes if you haven't already. Try adding new tasks to the list and relate the behaviour to the changes you've applied to the code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Recap</h1>
                </header>
            
            <article>
                
<p>We have added a new enter <span>task </span>component which is responsible for providing the UI logic to add new tasks. We have covered the following topics:</p>
<ul>
<li>We created a child component that is loosely coupled using output properties and event emitters</li>
<li>We learned about the <kbd>@Output</kbd> decorator and how to use it to create output properties</li>
<li>We used event bindings to react on component output and execute actions</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Custom UI elements</h1>
                </header>
            
            <article>
                
<p>The standard UI elements in the browser are great, but sometimes, modern web applications require smarter and more complex input elements than the ones available within the browser.</p>
<p>We'll now create two specific custom UI elements that we'll use within our application going forward in order to provide a nice user experience:</p>
<ul>
<li><strong>Checkbox</strong>: There's already a native checkbox input in the browser, but sometimes, it's hard to fit it into the visual design of an application. Native checkboxes are limited in their styling possibilities, and therefore, it's hard to make them look great. Sometimes, it's those minor details that make an application look appealing.</li>
<li><strong>Toggle buttons</strong>: This is a list of toggle buttons, where only one button can be toggled within the list. They can also be represented with a native radio button list. However, like with native checkboxes, radio buttons are sometimes not really the nicest visual solution to the problem. A list of toggle buttons that also represent a select-one-user input element is much more modern and provides the visual aspect that we are looking for. Besides, who doesn't like to push buttons?</li>
</ul>
<p>Let's create our custom checkbox UI element first. As we'll probably come up with a few custom UI elements, we will introduce a new top-level UI folder. By calling the Angular CLI generator with the right parameter, we can create the stub for our checkbox component in the right folder:</p>
<pre><strong>ng generate component --spec false -ve none ui/checkbox</strong></pre>
<p>Let's start with the template of our new component and change the content of <kbd>src/app/ui/checkbox/checkbox.component.html</kbd>:</p>
<pre>&lt;label class="label"&gt;<br/>  &lt;input class="input" type="checkbox"<br/>         [checked]="checked"<br/>         (change)="check($event.target.checked)"&gt;<br/>  &lt;span class="text"&gt;{{label}}&lt;/span&gt;<br/>&lt;/label&gt;</pre>
<p>On the checkbox input, we have two bindings. First, we have a property binding for the <kbd>checked</kbd> property on the DOM element. We are binding the DOM property to the <kbd>checked</kbd> member field on our component, which we are going to create in a moment.</p>
<p>Also, we have an event binding on the input element where we listen for the checkbox change DOM event and call the method <kbd>check</kbd> on our component instance. We use the synthetic variable <kbd>$event</kbd> to pass the <kbd>checked</kbd> property of the checkbox DOM element where the change event originated.</p>
<p>Moving on to our component class implementation, let's edit the TypeScript file on the path <kbd>src/app/ui/checkbox/checkbox.component.ts</kbd>:</p>
<pre>import {Component, Input, Output, ViewEncapsulation, EventEmitter} from '@angular/core';

@Component({<br/>  selector: 'mac-checkbox',<br/>  templateUrl: './checkbox.component.html',<br/>  encapsulation: ViewEncapsulation.None<br/>})<br/>export class CheckboxComponent {<br/>  @Input() label: string;<br/>  @Input() checked: boolean;<br/>  @Output() outCheck = new EventEmitter&lt;boolean&gt;();<br/><br/>  check(checked: boolean) {<br/>    this.outCheck.emit(checked);<br/>  }<br/>}</pre>
<p>There's nothing special about this component class. It uses an input property to set the checked state from the outside, and it also has an output property with an event emitter that allows us to notify the outer component about the changes of the checked state.</p>
<p>Let's integrate our checkbox in the task component to replace the native checkbox input we're currently using there. For this purpose, we need to modify the <kbd>src/app/tasks/task/task.component.html</kbd> file by replacing its previous content with the following code:</p>
<pre>&lt;mac-checkbox [checked]="task.done"<br/>              (outCheck)="task.done = $event"&gt;&lt;/mac-checkbox&gt;<br/>&lt;div class="title"&gt;{{task.title}}&lt;/div&gt;</pre>
<p>You should now already be able to see the changes in your browser and our nice custom checkbox component in action. As a next step, we'd like to apply some styling changes when a task is marked as done. This gives us better visual feedback than just the tick of the checkbox. For this, we're looking at a new concept to manipulate the host element of a component. Let's open the task component class on the path <kbd>src/app/tasks/task/task.component.ts</kbd> and add the following code to the body of the <kbd>TaskComponent</kbd> class:</p>
<pre>@HostBinding('class.done') 
get done() { 
  return this.task &amp;&amp; this.task.done; 
}</pre>
<p>Using the <kbd>@HostBinding</kbd> decorator, we can create property bindings on the component host element based on the members of our component. Let's use this decorator in order to create a binding that will conditionally set a class with the name <kbd>done</kbd> on the component's HTML element. This is used to make some visual distinctions of finished tasks within our styles.</p>
<p>This is a good time to check your result and play around with these large new checkboxes in the task list. Isn't that much more fun to do than activating regular checkboxes? Don't underestimate the effect of a user interface that is pleasing to use. This can have a very positive impact on the usage of your product:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0d491a9c-a40a-4b89-8537-f3fd766160dd.png" style=""/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Our task list after adding our custom checkbox component</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Recap</h1>
                </header>
            
            <article>
                
<p>In this section, you learned how to build custom UI components that are generic and loosely coupled so that they can be used in other components as subcomponents. We also completed the following tasks:</p>
<ul>
<li>We created a subcomponent that is loosely coupled using output properties and event emitters</li>
<li>We learned what the <kbd>@Output</kbd> decorator is and how to use it to create output properties</li>
<li>We used event bindings to link the behaviour together from the view of a component</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Task data service</h1>
                </header>
            
            <article>
                
<p>We have already learned a lot about building basic components and how to compose them together in order to form larger components. In the previous building block, we created a reusable checkbox UI component, which we've used to enhance the usability of our task list.</p>
<p>In this topic, we will use the toggle button component to create a filter for our task list. But before we start to introduce more complexity into our application, we're going to refactor our application by introducing data services. As our application gets larger, it's crucial to centralize our data manipulation and streamline our data flow. Services come in very handy since they allow us to store state which is accessible in all our components using Angular's dependency injection.</p>
<p>Going forward, we'll deal with quite a lot of data within our application. TypeScript supports us very well when it comes to <span>building</span><span> type-safe </span>data structures. So far, we've treated our task data as object literals, and TypeScript was extracting type information from there. However, as we start to use our data in different areas of our application, it makes sense to model our data in a central location. For this purpose, we're going to create our first TypeScript interface for representing our task data. In TypeScript, we can not only use interfaces for implementing classes and polymorphism, we can also use it to solely add type safety to our object literals and operations on objects. This is considered a very useful practice and will save us from a lot of potential bugs in the future.</p>
<p>Let's create a new TypeScript file on the path <kbd>src/app/model.ts</kbd> and add the following content to the file:</p>
<pre>export interface Task {<br/>  id?: number;<br/>  title: string;<br/>  done: boolean;<br/>}</pre>
<p><span>So far, we have stored our task list data directly within the task list component, but let's change that here and use a service that will provide task data for us. It's generally never a good idea to store data directly within a component. Refactoring our data into services is only the first step toward a clean component architecture, and we will learn about different methods about how to store our state and data in later chapters of this book.</span></p>
<p>In order to use the service we're about to create, we're going to make use of Angular's dependency injection for the first time. The Angular CLI comes in handy here, too. We can use it to generate a stub service for us:</p>
<pre><strong>ng generate service --spec false tasks/task</strong></pre>
<p>This will generate a file for us located on the path <kbd>src/app/tasks/task.service.ts</kbd>. Let's open this file in an editor and edit it with the following changes:</p>
<pre>import {Injectable} from '@angular/core';<br/>import {Task} from '../model';<br/><br/>@Injectable()<br/>export class TaskService {<br/>  private tasks: Task[] = [<br/>    {id: 1, title: 'Task 1', done: false},<br/>    {id: 2, title: 'Task 2', done: false},<br/>    {id: 3, title: 'Task 3', done: true},<br/>    {id: 4, title: 'Task 4', done: false}<br/>  ];<br/><br/>  getTasks(): Task[] {<br/>    return this.tasks.slice();<br/>  }<br/><br/>  addTask(task: Task) {<br/>    this.tasks.push({<br/>      ...task,<br/>      id: this.tasks.length + 1<br/>    });<br/>  }<br/><br/>  updateTask(task: Task) {<br/>    const index = this.tasks<br/>      .findIndex((t) =&gt; t.id === task.id);<br/>    this.tasks[index] = task;<br/>  }<br/>}</pre>
<p>We've moved all our task data into the newly created service. In order to make our service class injectable, we need to decorate it with the <kbd>@Injectable</kbd> decorator.</p>
<p>We're also using the <kbd>Task</kbd> interface for our tasks so that we have better type safety when working with task objects. In order to keep our data encapsulated and safe, we're going to create a clone of the internal tasks list when we're exposing it to any consumers. In JavaScript, we can simply call <kbd>Array.prototype.slice</kbd> in order to create a copy of an existing array.</p>
<p>Before we can use our task service within components, we need to provide it as a dependency. Dependencies are typically provided on the application level. In order to provide a dependency on the application level, we need to do some modifications to our main application module located on the path <kbd>src/app/app.module.ts</kbd>. The changes to the module are highlighted in the following code excerpt. The ellipsis character indicates that there's more code in the existing file, which is irrelevant for the changes we are applying:</p>
<pre>...<br/><strong>import {TaskService} from './tasks/task.service';</strong><br/>...<br/>@NgModule({<br/>...<br/> <strong>providers: [TaskService],</strong><br/> ...<br/>})<br/>export class AppModule {<br/>}</pre>
<p>Since we've provided our task service to the main module as a dependency, it will now be available for injection from the application injector.</p>
<p>Now, we can go ahead and modify our task list component to consume our task service. All our tasks are now stored in the task service and we need to remove the data which we previously embedded into the task list component.</p>
<p>Let's apply the changes to our task list component and modify the <kbd>src/app/tasks/task-list/task-list.component.ts</kbd> file. The following excerpt contains the whole code for the task list component. The changed and new sections are highlighted:</p>
<pre>import {Component, ViewEncapsulation} from '@angular/core';<br/><strong>import {TaskService} from '../task-list.service';</strong><br/><strong>import {Task} from '../../model';</strong><br/><br/>@Component({<br/>  selector: 'mac-task-list',<br/>  templateUrl: './task-list.component.html',<br/>  encapsulation: ViewEncapsulation.None<br/>})<br/>export class TaskListComponent {<br/><strong>  tasks: Task[];</strong><br/><br/><strong>  constructor(private taskService: TaskService) {</strong><br/><strong>    this.tasks = taskService.getTasks();</strong><br/><strong>  }</strong><br/><br/>  addTask(title: string) {<br/><strong>    const task: Task = {</strong><br/><strong>      title, done: false</strong><br/><strong>    };</strong><br/><strong>    this.taskService.addTask(task);</strong><br/><strong>    this.tasks = this.taskService.getTasks();</strong><br/>  }<br/><br/><strong>  updateTask(task: Task) {</strong><br/><strong>    this.taskService.updateTask(task);</strong><br/><strong>    this.tasks = this.taskService.getTasks();</strong><br/><strong>  }</strong><br/>}</pre>
<p>Instead of storing all our tasks within the task list component, we're now just declaring the <kbd>tasks</kbd> member. On the constructor of our component, we're using dependency injection to inject our newly created task service. Within the constructor body, we're retrieving task data by calling the <kbd>getTasks</kbd> method on our service. The resulting list is then stored within the <kbd>tasks</kbd> member of our component.</p>
<p>Within the <kbd>addTask</kbd> method, we're no longer directly modifying our task list. Instead, we're using the service to add a new task. After that, we need to get the updated list from the service by calling <kbd>getTasks</kbd> again.</p>
<p>We've also created a method called <kbd>updateTask</kbd> to update our tasks using our task service. Until now, we have updated the task data directly within our task component. The output binding on our checkbox was modifying the task's state on updates directly from within the view. While we're shaping our application, it becomes critical that we modify the state of our application in a more controlled manner. Imagine that you have dozens of components within your application, where each of them is modifying the state of your application. This would be a true maintenance hell.</p>
<p>So, how should we best approach this problem? The answer is delegation. We will delegate state manipulation to our parent components until we reach a component which is supposed to handle the manipulation. Component output is perfect for this use-case. We can tell our parent component about a change by emitting an output value. In our case, this means the following flow should occur:</p>
<ol>
<li>The checkbox component will tell the task component that the checkbox was ticked</li>
<li>The task component will tell the task list component that the task should be updated</li>
<li>The task list component will call the service to update the task data</li>
</ol>
<p>First, we're going to fix the state manipulation which is happening within the task component. Open up the task component template located at <kbd>src/app/tasks/task/task.component.html</kbd> and perform the following changes:</p>
<pre>&lt;mac-checkbox [checked]="task.done"<br/>              (outCheck)="<strong>updateTask($event)</strong>"&gt;&lt;/mac-checkbox&gt;<br/>&lt;div class="title"&gt;{{task.title}}&lt;/div&gt;</pre>
<p>Now, we're adding a new output to our task component and implementing the <kbd>updateTask</kbd> method in <kbd><span>src/app/tasks/task/task.component.ts</span></kbd>:</p>
<pre>...<br/>export class TaskComponent {<br/>  @Input() task: Task;<br/>  <strong>@Output() outUpdateTask = new EventEmitter&lt;Task&gt;();</strong><br/>  ...<br/><br/>  <strong>updateTask(done: boolean) {</strong><br/><strong>    this.outUpdateTask.emit({</strong><br/><strong>      ...this.task,</strong><br/><strong>      done</strong><br/><strong>    });</strong><br/><strong>  }</strong><br/>}</pre>
<p>Great! All whats left to do now is to catch the <kbd>outUpdateTask</kbd> output in the task list component template and call the <kbd>updateTask</kbd> method, which we've already added to the component class. Let's edit the file <kbd>src/app/tasks/task-list/task-list.component.html</kbd>:</p>
<pre>&lt;mac-enter-task (outEnterTask)="addTask($event)"&gt;&lt;/mac-enter-task&gt;<br/>&lt;div class="tasks"&gt;<br/>  &lt;mac-task *ngFor="let task of filteredTasks"<br/>            [task]="task"<br/>            <strong>(outUpdateTask)="updateTask($event)"</strong>&gt;&lt;/mac-task&gt;<br/>&lt;/div&gt;</pre>
<p>Now is a good time to preview your changes in the browser. Our task list should be fully functional again. Try adding new tasks and marking tasks as done. Our task list component is already much cleaner since we're not storing any data within the component. Instead, we're using a service which can also be used in other components.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Recap</h1>
                </header>
            
            <article>
                
<p>Within this section, we've not created anything new in the user interface of our application. However, it was still one of the more important sections of this chapter. We've learned about clean data flow, data and state best practices, and have created and integrated our first Angular service:</p>
<ol>
<li>We have created a task service to store and manipulate our task data</li>
<li>We've delegated state manipulation from our task component to the task list component which was then interacting with our service</li>
<li>We have learned about <kbd>@Injectable</kbd> and how to provide dependencies at the application level</li>
<li>We've injected our task service in the constructor of our task list component where we use it to obtain data</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Filtering tasks</h1>
                </header>
            
            <article>
                
<p>In this section, we're going to implement some filter functionality for our task list. In order to control the active filter criteria, we are first building a toggle button list component. Let's go ahead and create a new component using the Angular CLI: </p>
<pre><strong>ng generate component --spec false -ve none ui/toggle</strong></pre>
<p>After running the Angular CLI generator command on your console, let's edit the HTML template of the newly created component in<span> </span><kbd>src/app/ui/toggle/toggle.component.html</kbd>:</p>
<pre>&lt;button class="toggle-button" 
        *ngFor="let button of buttonList" 
        [class.active]="button === activeButton" 
        (click)="activate(button)"&gt;{{button}}&lt;/button&gt; </pre>
<p>Nothing special here, really! We repeat a button by iterating over an instance field called<span> </span><kbd>buttonList</kbd><span> </span>using the<span> </span><kbd>NgFor</kbd><span> </span>directive. This button list will contain the labels of our toggle buttons. Conditionally, we set a class called<span> </span><kbd>active</kbd><span> </span>using a property binding and check it against our current button within the iteration against an instance field called<span> </span><kbd>selectedButton</kbd>. When the button is clicked, we call a method,<span> </span><kbd>activate</kbd>, on our component instance and pass the current button label from the iteration.</p>
<p>Now, let's change the code of our component class on the path <kbd>src/app/ui/toggle/toggle.component.ts</kbd>:</p>
<pre>import {Component, Input, Output, ViewEncapsulation, EventEmitter, OnInit} from '@angular/core';<br/><br/>@Component({<br/>  selector: 'mac-toggle',<br/>  templateUrl: './toggle.component.html',<br/>  encapsulation: ViewEncapsulation.None<br/>})<br/>export class ToggleComponent implements OnInit {<br/>  @Input() buttonList: string[];<br/>  @Input() activeButton: string;<br/>  @Output() outActivate = new EventEmitter&lt;string&gt;();<br/><br/>  ngOnInit() {<br/>    if (!this.activeButton) {<br/>      this.activeButton = this.buttonList[0];<br/>    }<br/>  }<br/><br/>  activate(button: string) {<br/>    this.outActivate.emit(button);<br/>  }<br/>}</pre>
<p>Within our toggle component, we rely on the<span> </span><kbd>buttonList</kbd><span> </span>input to be an array of button label strings. We are using this array within our template on a<span> </span><kbd>NgFor</kbd><span> </span>directive.</p>
<p>The<span> </span><kbd>activeButton</kbd><span> </span>input is expected to be set to the button label string which is currently active within the toggle list. We also create an output named<span> </span><kbd>outActivate</kbd> to notify the outside world about state changes of the active toggle button.</p>
<p>Within the<span> </span><kbd>activate</kbd><span> </span>function, we are only emitting the<span> </span><kbd>outActivate</kbd><span> </span>output. From the binding outside of the component, we then expect the<span> </span><kbd>activeButton</kbd><span> </span>input to be updated accordingly. It's important to understand that our toggle component is only communicating to the parent component about a button that got activated. It's not updating any state, really. We're expecting that the parent component which uses our toggle component will then update the<span> </span><kbd>activeButton</kbd><span> </span>input accordingly.</p>
<p>The<span> </span><kbd>ngOnInit</kbd><span> </span>method is called by Angular<span> </span><span>automatically </span>within the life cycle of directives and components. This is also the reason why our toggle component class is implementing the life cycle hook interface<span> </span><kbd>OnInit</kbd>. In the case where the<span> </span><kbd>activeButton</kbd><span> </span>input property was not specified, we'll add a check and select the first button from the available button list. Since<span> </span><kbd>activeButton</kbd>, as well as<span> </span><kbd>buttonList</kbd>, are input properties, we need to wait for them to be initialized in order to execute this logic. It's important not to perform this initialization within the component constructor. Only within the life cycle hook <kbd>OnInit</kbd> do we have the guarantee that our input properties have been set already. It is invoked only once for each component which is created.</p>
<div class="packt_tip"><span>Angular will call any life cycle hooks that have been implemented in your component automatically. The interfaces which are available for each life cycle hook are only helpful in the sense that they ensure you have implemented all desired callbacks for the individual life cycle hooks.</span></div>
<p>The following diagram illustrates the life cycle of an Angular component. Upon component construction, all the life cycle hooks will be called as per the order which is shown in the diagram, except the<span> </span><kbd>OnDestroy</kbd><span> </span>hook, which will be called upon component destruction.</p>
<p>Change detection will also start a subset of life cycle hooks, where some of the hooks which are called during creation are skipped:</p>
<ul>
<li><kbd>doCheck</kbd></li>
<li><kbd>afterContentChecked</kbd></li>
<li><kbd>afterViewChecked</kbd></li>
<li><kbd>onChanges<span> </span>(if any changes are detected)</kbd></li>
</ul>
<p class="mce-root">A detailed description of the life cycle hooks and their purposes is available on the Angular documentation website at <a href="https://angular.io/guide/lifecycle-hooks" target="_blank">https://angular.io/guide/lifecycle-hooks</a>:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/db407698-3cc5-4c75-a878-4e7ff8fc780a.png" style=""/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">An illustration of the life cycle of an Angular component</div>
<p>Alright! We have created a new UI component to render a toggle button list. Now, it's time to move on with our main goal within this chapter, implementing a filtering system in our task list component.</p>
<p>First, we should think about the model for our filter. We'd want to include three states, all, open, and done, which should each result in a different view of our task list. Let's open up our model file located at <kbd>src/app/model.ts</kbd> and add the following changes:</p>
<pre>export interface Task {<br/>  id?: number;<br/>  title: string;<br/>  done: boolean;<br/>}<br/><br/><strong>export type TaskListFilterType = 'all' | 'open' | 'done';</strong></pre>
<p><span>We're defining a type alias, which represents a list of valid filter types. TypeScript type aliases are really helpful in order to make certain things more type safe. Especially when you're dealing with string types, you can use type aliases to create string literal types. By creating a type alias </span><kbd>TaskListFilterType</kbd><span>, and later using it in the context of the filter, we can specify which strings are valid while filtering. This will prevent any typos when dealing with task filter type strings within our application.</span></p>
<p>Now, it's time to implement our filter functionality. Let's open the task list component file located at <kbd>src/app/tasks/task-list/task-list.component.ts</kbd> and apply some code changes. Again, changed parts of the code are highlighted, to make it easier for you to see the effective changes:</p>
<pre>import {Component, ViewEncapsulation} from '@angular/core';<br/>import {TaskService} from '../task.service';<br/>import {Task<strong>, TaskListFilterType</strong>} from '../../model';<br/><br/>@Component({<br/>  selector: 'mac-task-list',<br/>  templateUrl: './task-list.component.html',<br/>  encapsulation: ViewEncapsulation.None<br/>})<br/>export class TaskListComponent {<br/>  tasks: Task[];<br/>  <strong>filteredTasks: Task[];</strong><br/><strong>  taskFilterTypes: TaskListFilterType[] = ['all', 'open', 'done'];</strong><br/><strong>  activeTaskFilterType: TaskListFilterType = 'all';</strong><br/><br/>  constructor(private taskService: TaskService) {<br/>    this.tasks = taskService.getTasks();<br/><strong>    this.filterTasks();</strong><br/>  }<br/><br/>  <strong>activateFilterType(type: TaskListFilterType) {</strong><br/><strong>    this.activeTaskFilterType = type;</strong><br/><strong>    this.filterTasks();</strong><br/><strong>  }</strong><br/><br/>  <strong>filterTasks() {</strong><br/><strong>    this.filteredTasks = this.tasks</strong><br/><strong>      .filter((task: Task) =&gt; {</strong><br/><strong>        if (this.activeTaskFilterType === 'all') {</strong><br/><strong>          return true;</strong><br/><strong>        } else if (this.activeTaskFilterType === 'open') {</strong><br/><strong>          return !task.done;</strong><br/><strong>        } else {</strong><br/><strong>          return task.done;</strong><br/><strong>        }</strong><br/><strong>      });</strong><br/><strong>  }</strong><br/><br/>  addTask(title: string) {<br/>    const task: Task = {<br/>      title, done: false<br/>    };<br/>    this.taskService.addTask(task);<br/>    this.tasks = this.taskService.getTasks();<br/><strong>    this.filterTasks();</strong><br/>  }<br/><br/>  updateTask(task: Task) {<br/>    this.taskService.updateTask(task);<br/>    this.tasks = this.taskService.getTasks();<br/><strong>    this.filterTasks();</strong><br/>  }<br/>}</pre>
<p>Within the component, we want to store a list of types the task filter can have. This list will serve as input for our toggle button list. If you recall the input properties on our toggle button, we have a <kbd>buttonList</kbd> input that accepts a list of button labels. To store the currently selected filter type, we use an instance field called <kbd>activeTaskFilterType</kbd>.</p>
<p>The last piece that we need to add to our task list component is the actual filtering of tasks. For this, we're introducing a new member called <kbd>filteredTasks</kbd>, which will always be updated with the currently filtered subset of tasks. Within the <kbd>filterTasks</kbd> method, we are computing the subset of filtered tasks by evaluating the active filter criteria stored in <kbd><span>activeTaskFilterType</span></kbd>. The result of the filtering will be stored in our <kbd>filteredTasks</kbd> member.</p>
<p>We've also created a method, <kbd>activateFilterType</kbd>, which we can call to switch the active filter criteria. This method will then call the <kbd>filterTasks</kbd> method to update our filtered subset of tasks.</p>
<p>Okay, that's all we are going to change in our component class. We still need to change our view template, though. We need to render our toggle component and execute our filtering on filter criteria changes. Since we want to render the filtered subset of tasks instead of the whole task list, we also need to change the source for the <kbd>NgFor</kbd>, which repeats our tasks in the view. Let's open the template file <kbd>src/app/tasks/task-list/task-list.html</kbd> and modify it with the following changes:</p>
<pre><strong>&lt;mac-toggle [buttonList]="taskFilterTypes"</strong><br/><strong>            [activeButton]="activeTaskFilterType"</strong><br/><strong>            (outActivate)="activateFilterType($event)"&gt;</strong><br/><strong>&lt;/mac-toggle&gt;</strong><br/>&lt;mac-enter-task (outEnterTask)="addTask($event)"&gt;&lt;/mac-enter-task&gt;<br/>&lt;div class="tasks"&gt;<br/>  &lt;mac-task *ngFor="let task of <strong>filteredTasks</strong>"<br/>            [task]="task"<br/>            (outUpdateTask)="updateTask($event)"&gt;&lt;/mac-task&gt;<br/>&lt;/div&gt;</pre>
<p>Let's discuss the changes quickly. First, we are binding <span>the </span><kbd>taskFilterTypes</kbd><span> property where we store a list of possible filter types within the task list component class, to</span> the toggle component <kbd><span>buttonList</span></kbd> input property. This will make the toggle component render all filter types as toggle buttons.</p>
<p>We also bind <span>the </span><kbd>activeTaskFilterType</kbd><span> instance field of the task list to</span> the <kbd>activeButton</kbd> input property of the toggle component. This way, changes to the <kbd>activeTaskFilterType</kbd><span> </span>property will be reflected in the toggle component. At the same time, when a user changes the active toggle button inside the toggle component, we capture the <kbd>outActivate</kbd> output of the toggle component and call the <kbd>activateFilterType</kbd> method on the task list component.</p>
<p>That's it, congratulations! You've successfully added a filtering mechanism to your task list by using our newly created toggle component. Preview the changes in your browser; you should see a fully functional task list where you can mark tasks as done, add new tasks, and filter the list by activating our nice toggle buttons:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a36edc80-1201-4813-9f14-65d3daa984a1.png" style=""/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Screenshot of the task list with the newly added toggle button component for filtering the task state</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Recap</h1>
                </header>
            
            <article>
                
<p>In this section, we've built a filtering system into our task list component. We have also created an additional UI component to render toggle buttons, which we're presenting to the user for selecting the filter criteria:</p>
<ul>
<li>We created a new toggle component to render a set of toggle buttons</li>
<li>We used the<span> </span><kbd>@HostBinding</kbd><span> </span>decorator to create property bindings declaratively from within our component class</li>
<li>We learned about the Angular component life cycle and how we can use the<span> </span><kbd>OnInit</kbd><span> </span>life cycle hook to initialize the component after the input has been processed for the first time</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, you learned a lot of new concepts on building UI component-based applications with Angular. We also built the core component of our task management application, which is the task list itself. You learned about the concept of input and output properties and how to use them to establish proper component communication.</p>
<p>We also covered the basics of the Angular component life cycle and how to use life cycle hooks to execute post-initialization steps within the <kbd>OnInit</kbd> hook.</p>
<p>As the last step, we integrated a toggle button list component within our task list to filter the task states. We refactored our task list component to use a service in order to obtain task data. For this, we used Angular's dependency injection.</p>
<p>Within the next chapter, we're going to look at ways how to improve our handling of data and state. There are plenty of ways how to deal with application state and we're going to learn how to best tackle this issue.</p>


            </article>

            
        </section>
    </body></html>