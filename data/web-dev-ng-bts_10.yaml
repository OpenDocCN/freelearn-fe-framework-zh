- en: Working with Forms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理表单
- en: Let's start this chapter with a simple guessing game. Can you think of any web
    application that does not have any sort of form, such as, signing up, login, create,
    contact us, edit forms, and so on; the list is endless. (wrong answer—even the
    Google homepage has a search form.)
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的猜谜游戏开始这一章。你能想到任何没有任何形式的网页应用程序，比如注册、登录、创建、联系我们、编辑表单等等；列表是无穷无尽的。（错误答案-甚至Google主页上也有一个搜索表单。）
- en: 'Technically, it''s possible. I am 100% sure there are some websites that may
    not use forms at all, but I am also equally confident they will be static and
    won''t interact or engage with users dynamically, which brings us to the main
    context and focus of this chapter: implementing and using forms in our Angular
    application.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，这是可能的。我100%确定有一些网站根本不使用表单，但我同样确信它们将是静态的，不会与用户动态交互或互动，这就是本章的主要内容和重点：在我们的Angular应用程序中实现和使用表单。
- en: 'OK, let''s now take a look at what we''ll be covering in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在让我们来看看本章我们将涵盖的内容：
- en: Introduction to Bootstrap forms
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引导表单简介
- en: Bootstrap form classes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引导表单类
- en: Bootstrap form classes—extended
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引导表单类-扩展
- en: Angular forms
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角度形式
- en: Template-driven forms
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板驱动表单
- en: Reactive forms
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式表单
- en: Form validations
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单验证
- en: Submitting and processing form data
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交和处理表单数据
- en: Bootstrap forms
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引导表单
- en: We will learn to make use of the awesome Bootstrap library, which offers a rich
    set of classes and utilities for us to design and develop forms in our applications,
    making developers' and designers' life easy!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学会使用强大的Bootstrap库，它为我们设计和开发应用程序中的表单提供了丰富的类和实用程序，使开发人员和设计人员的生活变得轻松！
- en: What are forms?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是表单？
- en: Forms are sets, collections of input fields gathered together to enable us to
    collect data from the user through the keyboard, mouse, or touch input.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 表单是一组输入字段的集合，通过键盘、鼠标或触摸输入，使我们能够从用户那里收集数据。
- en: We will learn to stitch input elements together and build some sample forms,
    such as logging in, signing up, or for when the user forgets their password.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学会将输入元素组合在一起，并构建一些示例表单，比如登录、注册，或者当用户忘记密码时。
- en: 'Before we jump into creating the forms, here''s a quick list of available HTML
    input elements that we can use in our apps:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始创建表单之前，这里有一个我们可以在应用程序中使用的可用HTML输入元素的快速列表：
- en: Input (including text, radio, checkbox, or file)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入（包括文本、单选框、复选框或文件）
- en: Textarea
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本区
- en: Select
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择
- en: Button
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮
- en: Form
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 形式
- en: Fieldset
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字段集
- en: If you want a quick refresher tutorial on HTML tags and elements, you can visit [W3schools.com](https://www.w3schools.com/).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想快速复习HTML标签和元素，你可以访问[W3schools.com](https://www.w3schools.com/)。
- en: Armed with the knowledge about forms and the available HTML elements, it's hands-on
    time.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握了关于表单和可用的HTML元素的知识，现在是动手的时候了。
- en: Bootstrap form classes
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引导表单类
- en: In this section, we will learn about the available classes from the Bootstrap
    framework, which we can make use of while building our forms. Each form can consist
    of various input elements, such as textual form controls, file input controls,
    input checkboxes, and radio buttons. The `.form-group` class is an easy way to
    add structure to our forms. Using the `.form-group` class, we can easily group
    input elements, labels, and help text to ensure proper grouping of elements in
    the form. Inside the `.form-group` element, we will add input elements and assign
    them each the `.form-control` class.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习Bootstrap框架中可用的类，我们可以在构建表单时使用这些类。每个表单可以包含各种输入元素，如文本表单控件、文件输入控件、输入复选框和单选按钮。`.form-group`类是一种为我们的表单添加结构的简单方法。使用`.form-group`类，我们可以轻松地将输入元素、标签和帮助文本分组，以确保表单中元素的正确分组。在`.form-group`元素内，我们将添加输入元素，并为每个元素分配`.form-control`类。
- en: 'A sample of a grouping of elements using the `.form-group` class is as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`.form-group`类对元素进行分组的示例如下：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code, we are creating a form group consisting of label and
    input elements of type text.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们创建了一个包含标签和文本输入元素的表单组。
- en: 'On the same lines, we can easily add the textual input elements, such as `email`,
    `password`, and `textarea`. The following is the code to add the input element
    of type `email`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在同样的线上，我们可以轻松地添加文本输入元素，比如`email`，`password`和`textarea`。以下是添加类型为`email`的输入元素的代码：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Similarly, we can easily add an input element of type `password` as well. Again,
    notice that we are making use of `form-group` as a wrapper and adding `form-control`
    to the element:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们也可以轻松地添加类型为`password`的输入元素。再次注意，我们正在使用`form-group`作为包装，并将`form-control`添加到元素中：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Nice. We learned to use `form-group` and `form-control` classes on input elements.
    Now, let''s add the same classes to the `textarea` element. The following is the
    sample code for adding the classes to a `textarea` element:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 不错。我们学会了在输入元素上使用`form-group`和`form-control`类。现在，让我们将相同的类添加到`textarea`元素上。以下是为`textarea`元素添加类的示例代码：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You will notice that all of the preceding elements have the same structure and
    grouping. For `select` and `multiple` `select` input elements, it's also exactly
    the same.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到所有上述元素都具有相同的结构和分组。对于`select`和`multiple` `select`输入元素，也完全相同。
- en: 'In the following sample code, we are creating a `select` drop-down element
    and using the `form-control` class:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例代码中，我们创建了一个`select`下拉元素，并使用了`form-control`类：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We have added a `select` drop-down element and will allow the user to select
    only one option from the list. And just by adding an additional attribute, `multiple`,
    we can easily allow the user to select multiple options:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经添加了一个`select`下拉元素，并且将允许用户从列表中选择一个选项。只需添加一个额外的属性`multiple`，我们就可以轻松地允许用户选择多个选项：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: That was simple and straightforward. Let's keep rolling.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单明了。让我们继续前进。
- en: 'Now, let''s proceed to other important input elements: checkboxes and radio
    buttons. However, the classes are different for `checkbox` and `radio` elements.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续其他重要的输入元素：复选框和单选按钮。但是，`checkbox`和`radio`元素的类是不同的。
- en: 'There are three new classes that we will learn to implement for `checkbox`
    and `radio` elements:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个新的类，我们将学习如何为`checkbox`和`radio`元素实现：
- en: To wrap the element, we will use the `form-check` class
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了包装元素，我们将使用`form-check`类
- en: For the input type `checkbox` and the `radio` element, we will use `form-check-input`
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于输入类型为`checkbox`和`radio`的元素，我们将使用`form-check-input`
- en: 'For `checkbox` and `radio` elements, we will need to display labels, for which
    we will use the `form-check-label` class:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`checkbox`和`radio`元素，我们需要显示标签，为此我们将使用`form-check-label`类：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code, we are using the `.form-check` class, `.form-check-input`,
    and `.form-check-label` to our wrapper `div` and `label` elements.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们使用`.form-check`类，`.form-check-input`和`.form-check-label`来包装我们的`div`和`label`元素。
- en: 'Ditto, on similar lines, we will use the preceding classes to add to input
    `radio` elements:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在类似的线上，我们将使用上述类来添加到输入`radio`元素中：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, we are creating two radio buttons for the user to select
    their gender, and the user can make only one selection out of the two options.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们为用户创建了两个单选按钮，以选择他们的性别，并且用户只能在两个选项中选择一个。
- en: In most modern web applications, we will need a user to be able to upload files
    or assets to our applications. Bootstrap provides us class named "form-control-file", which
    we can associate to the file upload element.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数现代Web应用程序中，我们需要用户能够上传文件或资源到我们的应用程序。Bootstrap为我们提供了一个名为"form-control-file"的类，我们可以将其关联到文件上传元素。
- en: 'We will use the `form-control-file` class to our input type `file` element.
    The sample code for this is as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`form-control-file`类将其应用于我们的输入类型`file`元素。此示例代码如下：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Great. We have learned to put together all the elements with which we can create
    our beautiful and powerful forms.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。我们已经学会了如何组合所有元素，从而创建我们美丽而强大的表单。
- en: Bootstrap form classes – extended
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bootstrap表单类 - 扩展
- en: We have learned to create forms with input elements and add some of the available
    form classes in Bootstrap to group elements, as well as to improve our application.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了创建带有输入元素的表单，并在Bootstrap中添加了一些可用的表单类来对元素进行分组，以及改善我们的应用程序。
- en: 'In this section, we will look at other additional classes and attributes provided
    by the Bootstrap framework, which can be used to improve **user experience** (**UX**),
    as well as extend the behavior of the elements:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看Bootstrap框架提供的其他附加类和属性，这些类和属性可用于改善用户体验（UX），以及扩展元素的行为：
- en: Sizing
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大小
- en: Readonly
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只读
- en: Inline forms
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内联表单
- en: Forms using Bootstrap grid classes
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Bootstrap网格类的表单
- en: Disabled
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 禁用
- en: Help text
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助文本
- en: Plain text inside `form-group`
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`form-group`内的纯文本'
- en: We will go through each one of the aforementioned options and learn to implement
    them and see them in action.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐个讨论上述选项，并学会实现它们并看到它们的效果。
- en: Sizing
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大小
- en: We can set the size of the input elements in our form. We can control the height
    of the element using various classes for small, medium, and large resolutions.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以设置表单中输入元素的大小。我们可以使用各种类来控制元素的高度，适用于小、中和大分辨率。
- en: We have learned to use the `.form-control` class in the previous section and,
    by default, the medium size height with the `.form-control-md` class is applied.
    There are other classes available to set the height as large or small. We can
    use `.form-control-lg` and `.form-control-sm`, respectively.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在上一节中学会了使用`.form-control`类，默认情况下，使用`.form-control-md`类应用了中等大小的高度。还有其他类可用于设置高度为大或小。我们可以分别使用`.form-control-lg`和`.form-control-sm`。
- en: 'The following is the sample code, where we are setting the height of the email
    address element as large using the `.form-control-lg` class, and the password
    field with the `.form-control-sm` class:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是示例代码，我们将使用`.form-control-lg`类将电子邮件地址元素的高度设置为大，并使用`.form-control-sm`类将密码字段设置为小：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We have added the `form-control-lg` and `form-control-sm` classes to the form
    control's email address and password form elements, respectively.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将`form-control-lg`和`form-control-sm`类添加到表单控件的电子邮件地址和密码表单元素中，分别。
- en: 'When we run the application, the output of the preceding code is as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行应用程序时，上述代码的输出如下：
- en: '![](assets/3d8bbef5-a504-4b21-b76e-f3b1feb319b2.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3d8bbef5-a504-4b21-b76e-f3b1feb319b2.png)'
- en: In the preceding screenshot, notice the difference in heights of the input elements.
    The email address text field has increased in height and the password field is
    small.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的屏幕截图中，请注意输入元素高度的差异。电子邮件地址文本字段的高度增加了，密码字段很小。
- en: Readonly
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 只读
- en: We may come across a use case where we will need to disable a field and make
    it read-only. We can utilize the attribute `readonly`. By adding the Boolean `readonly` attribute
    to any form control element, we can disable that element.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会遇到一个使用情况，需要禁用字段并使其只读。我们可以利用属性`readonly`。通过向任何表单控件元素添加布尔`readonly`属性，我们可以禁用该元素。
- en: 'The sample code showing the usage of the `readonly` attribute on the username
    field is as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 显示在用户名字段上使用`readonly`属性的示例代码如下：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output of the preceding code is displayed as follows. Notice that email
    address field is disabled, and so the user will not be able to add/edit the element:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下所示。请注意，电子邮件地址字段已禁用，因此用户将无法添加/编辑该元素：
- en: '![](assets/62eecb1f-cbae-4243-aaa2-f676a93b5724.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/62eecb1f-cbae-4243-aaa2-f676a93b5724.png)
- en: Inline forms
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内联表单
- en: The design is also an equally important aspect of how we display the form. We
    may come across a use case where we have a requirement to place our form horizontally,
    instead of the regular vertical way.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 设计也是我们如何显示表单的同样重要的方面。我们可能会遇到这样的用例，我们需要将我们的表单水平放置，而不是常规的垂直方式。
- en: Bootstrap has the `.form-inline` class to support inline or horizontal forms.
    When the `.form-inline` class is used, the form elements automatically float horizontally.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap有`.form-inline`类来支持内联或水平表单。当使用`.form-inline`类时，表单元素会自动水平浮动。
- en: 'The following is some sample code, where we create the login form with an email
    address and password. We make it inline using the `form-inline` class :'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些示例代码，我们在其中使用电子邮件地址和密码创建登录表单。我们使用`form-inline`类使其成为内联表单：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code, the important thing to note is the usage of the `.form-inline` class.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，需要注意的重要事项是使用`.form-inline`类。
- en: 'The output of the preceding code is displayed as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](assets/2938203b-a18e-44d5-bd43-2958357e0bec.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/2938203b-a18e-44d5-bd43-2958357e0bec.png)
- en: By default, all forms designed using Bootstrap are vertical.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，使用Bootstrap设计的所有表单都是垂直的。
- en: Forms using Bootstrap grid classes
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Bootstrap网格类的表单
- en: Remember the Bootstrap grid classes we learned about in [Chapter 3](6694dd13-5500-4563-9688-74a21a06a9a9.xhtml),
    *Bootstrap – Grid Layout and Components*? Yes, rows, columns, and designing the
    layout of the screen.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们在[第3章](6694dd13-5500-4563-9688-74a21a06a9a9.xhtml)中学到的Bootstrap网格类吗，*Bootstrap-网格布局和组件*？是的，行、列和设计屏幕布局。
- en: In this section, we will learn to use the same row and column grid classes inside
    our forms, which is good news because using these classes, we can design a custom
    layout and update the look and feel of the form.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习在表单内部使用相同的行和列网格类，这是一个好消息，因为使用这些类，我们可以设计自定义布局并更新表单的外观。
- en: 'The sample code for this is as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例代码如下：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code, instead of using the `.form-group` class, we are making
    use of the `row` and `col` classes, which are mainly used for designing layout.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们不是使用`.form-group`类，而是使用`row`和`col`类，这些类主要用于设计布局。
- en: We make a single row with two columns, and in each column, we add input elements.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个具有两列的单行，并在每列中添加输入元素。
- en: 'The output of the preceding code is as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](assets/7c02ddc6-166a-4b89-ab2b-8db49242f727.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/7c02ddc6-166a-4b89-ab2b-8db49242f727.png)
- en: 'Here''s your homework now. Try out these fun use cases using grid classes with
    forms:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是你的作业。尝试使用表单和网格类进行这些有趣的用例：
- en: Add more input elements in the same row by adding more column div elements to
    the same row
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过向同一行添加更多列div元素，可以在同一行中添加更多输入元素
- en: Add multiple rows to the form
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向表单添加多行
- en: Assign a fixed width for some columns (column 4 or column 3)
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为某些列（第4列或第3列）分配固定宽度
- en: Disabled
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 禁用
- en: While developing web applications with critical and complex compliance requirements,
    it's very common that we will have to disable certain input elements based on
    user selections.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发具有关键和复杂合规要求的Web应用程序时，很常见的是我们将不得不根据用户选择禁用某些输入元素。
- en: A good use case is where some fields are not applicable to a specific country
    the user has selected, so we need to disable other dependent fields.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的用例是，某些字段不适用于用户选择的特定国家，因此我们需要禁用其他依赖字段。
- en: Using the `disabled` attribute which takes a Boolean value, we can either disable
    a form or a particular element.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`disabled`属性，该属性接受布尔值，我们可以禁用表单或特定元素。
- en: 'Let''s see the `disabled` attribute in action:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`disabled`属性的作用：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding code, we are using the `disabled` attribute. We can see in
    the following screenshot that the email address field is completely disabled:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们使用了`disabled`属性。我们可以在以下截图中看到，电子邮件地址字段完全被禁用：
- en: '![](assets/2c9b895e-8d4e-40eb-a13f-996cf8394c89.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2c9b895e-8d4e-40eb-a13f-996cf8394c89.png)'
- en: We can make any element disabled just by adding the `disabled` attribute to
    the element. This is good, but what if we want to disable the entire form in one
    go? We can do that as well.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过向元素添加`disabled`属性来使任何元素被禁用。这很好，但是如果我们想一次性禁用整个表单怎么办？我们也可以做到。
- en: 'Take a look at the following code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下代码：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We are adding the `fieldset` tag inside the form to wrap all the elements of
    the form together and apply the `disabled` attribute to the `fieldset` element,
    which will disable the entire form in one go.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在表单内部添加`fieldset`标签，将表单的所有元素包装在一起，并将`disabled`属性应用于`fieldset`元素，这将一次性禁用整个表单。
- en: 'The output of the preceding code is displayed as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下所示：
- en: '![](assets/cb30d38d-f476-4547-a2fc-023cba555368.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cb30d38d-f476-4547-a2fc-023cba555368.png)'
- en: Help text inside forms
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表单内的帮助文本
- en: Any good web application will have beautiful, yet powerful forms, which talk
    to users and create a good UX experience.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 任何优秀的Web应用程序都将拥有美观而强大的表单，这些表单可以与用户交流，并创造良好的用户体验。
- en: Help text is one of the options we have to notify the user about any errors,
    warnings, or mandatory fields in the form, so that the user can take necessary
    actions.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 帮助文本是我们通知用户有关表单中任何错误、警告或必填字段的选项之一，以便用户可以采取必要的行动。
- en: 'Take a look at the following code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下代码：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding code, we are adding text inside the `<small>` tag, and assigning
    the `.form-text` class and `.text-danger`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们在`<small>`标签内添加文本，并分配`.form-text`类和`.text-danger`。
- en: 'The output of the preceding code is as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](assets/245b42fa-42d2-4938-bdad-f1b4eae474d4.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/245b42fa-42d2-4938-bdad-f1b4eae474d4.png)'
- en: Displaying input elements as plain text
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将输入元素显示为纯文本
- en: We may come across a requirement where we need to display an input element as
    just text, and not as an input element.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会遇到这样的要求，我们需要将输入元素显示为纯文本，而不是输入元素。
- en: We can do this simply by customizing our style sheet, or just by using the `.form-control-plaintext` class
    inside the element with the `.form-group` class.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过自定义样式表来简单地实现这一点，或者只需在具有`.form-group`类的元素内使用`.form-control-plaintext`类。
- en: 'Take a look at the following code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下代码：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding code, we have added the `.form-control-plaintext` class to
    the input element.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们已经将`.form-control-plaintext`类添加到输入元素中。
- en: 'The output of the preceding code is as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](assets/1920ea3b-d4f6-4786-a2cc-93d0ee5417e5.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1920ea3b-d4f6-4786-a2cc-93d0ee5417e5.png)'
- en: In this section, we have learned about various classes and attributes that we
    can use to enhance and make our forms more interactive and powerful, and above
    all, add to better user design and experience.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经了解了各种类和属性，我们可以使用它们来增强和使我们的表单更具交互性和强大性，最重要的是，为更好的用户设计和体验增添内容。
- en: Angular forms
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular表单
- en: In this section comes the real action of forms in Angular applications. Forms
    are at the heart of any application and are the main building blocks to gather,
    view, capture, and process data provided by the users. We will continue to use
    the Bootstrap library to enhance the design of our forms in this section.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，Angular应用程序中的表单真正发挥作用。表单是任何应用程序的核心，也是收集、查看、捕获和处理用户提供的数据的主要构建块。在本节中，我们将继续使用Bootstrap库来增强我们表单的设计。
- en: Angular provides two different approaches to building forms inside our apps.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供了两种不同的方法来构建应用程序内的表单。
- en: 'The two approaches provided by Angular for building forms are as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供的构建表单的两种方法如下：
- en: 'Template-driven forms: HTML and data binding defined in template files'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板驱动表单：HTML和数据绑定在模板文件中定义
- en: Reactive or model-driven forms, using model and validation in the `Component`
    class files
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模型和验证在“Component”类文件中的响应式或模型驱动表单
- en: Although the form model is a commonality between template-driven forms and reactive
    forms, they are created differently.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管表单模型是模板驱动表单和响应式表单之间的共同点，但它们的创建方式不同。
- en: The main difference between reactive forms and template-driven forms, when it
    comes to the template, is in the data binding. In template-driven forms, we use
    two-way data binding to bind our data model directly to the form elements. On
    the other hand, with reactive forms, we bind our data model to the form itself
    (as opposed to its individual form elements).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到模板时，响应式表单和模板驱动表单的主要区别在于数据绑定。在模板驱动表单中，我们使用双向数据绑定将我们的数据模型直接绑定到表单元素。另一方面，使用响应式表单时，我们将我们的数据模型绑定到表单本身（而不是其各个表单元素）。
- en: We will explore each of these approaches in detail, learn about the pros and
    cons of the approaches, and finally, we will build some forms using both approaches.
    Let's roll.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将详细探讨这些方法，了解这些方法的利弊，最后，我们将使用这两种方法构建一些表单。让我们开始吧。
- en: Template-driven forms
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板驱动表单
- en: Template-driven forms, as the name suggests, involve all the heavy-duty work
    of forms being performed right inside the template of the component. The approach
    is good and is recommended when dealing with simple, straightforward forms, without
    much complex validation or rules.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 模板驱动表单，顾名思义，涉及表单的所有繁重工作都在组件模板中进行。这种方法很好，建议在处理简单、直接的表单时使用，而不涉及太多复杂的验证或规则。
- en: All the logic is in the template files, which essentially means that we will
    make use of HTML elements and attributes. With template-driven forms, we use HTML
    to create the form and the input elements and create validation rules as HTML
    attributes. Two-way data binding is the key part, so we can tie the form elements
    to the properties in the `Component` class.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 所有逻辑都在模板文件中，这基本上意味着我们将利用HTML元素和属性。在模板驱动的表单中，我们使用HTML来创建表单和输入元素，并将验证规则创建为HTML属性。双向数据绑定是关键部分，因此我们可以将表单元素与“Component”类中的属性绑定起来。
- en: Angular automatically tracks the form and input element states by generating
    the form model automatically for us to use. We can directly take the form as an
    object and process data easily.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Angular会自动生成表单模型，自动跟踪表单和输入元素的状态供我们使用。我们可以直接将表单作为对象并轻松处理数据。
- en: 'When using the template-driven approach, we first import the `FormsModule`,
    so we can have access to the following directives:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用模板驱动方法时，我们首先导入“FormsModule”，这样我们就可以访问以下指令：
- en: '`ngForm`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “ngForm”
- en: '`ngModel`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “ngModel”
- en: '`ngModelGroup`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “ngModelGroup”
- en: We need to import the `FormsModule` into our `app.module.ts` file.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将“FormsModule”导入到我们的“app.module.ts”文件中。
- en: Let's take a look at the pros and cons of using the template-driven form approach
    in our apps.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看在我们的应用程序中使用模板驱动表单方法的利弊。
- en: Template-driven forms – pros
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板驱动表单-优点
- en: 'Template-driven forms can be very useful and helpful if the forms in our application
    are simple and straight forward with less metadata and validations. In this section
    we will highlight the pros of using template-driven forms in our applications:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们应用程序中的表单简单直接，没有太多元数据和验证，模板驱动表单可以非常有用和有帮助。在本节中，我们将强调在我们的应用程序中使用模板驱动表单的优点：
- en: Template-driven forms are very easy to use
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板驱动表单非常容易使用
- en: Suitable for simple and straightforward use cases
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于简单和直接的用例
- en: Easy-to-use two-way data binding, so there is minimal code and complexity
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于使用的双向数据绑定，因此代码和复杂性很少
- en: Angular automatically tracks the form and input element state (you can disable
    the Submit button if the form's state is not complete)
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular自动跟踪表单和输入元素的状态（如果表单状态不完整，则可以禁用提交按钮）
- en: Not recommended if the form has complex form validations or require custom form
    validations
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果表单具有复杂的表单验证或需要自定义表单验证，则不建议使用
- en: Template-driven forms – cons
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于模板的表单 - 缺点
- en: 'In the previous section, we have learned about the advantages of using template-driven
    forms in our application and we have made a strong argument about the pros of
    using the template-driven form approach. In this section, we will learn about
    some of the cons of using template-driven forms in our applications:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们已经了解了在应用程序中使用基于模板的表单的优势，并且我们已经就使用基于模板的表单方法的优点进行了充分论证。在本节中，我们将了解在我们的应用程序中使用基于模板的表单的一些缺点：
- en: Not recommended or suitable where the requirements of the form are complex and
    comprise custom form validations
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不建议或适用于表单要求复杂且包括自定义表单验证的情况
- en: Unit testing cannot be fully covered to test all use cases
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法完全覆盖单元测试以测试所有用例
- en: Template-driven forms – important modules
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于模板的表单 - 重要模块
- en: 'Armed with knowledge about the pros and cons of using the template-driven approach,
    without wasting any time we will deep dive into learning how to implement the
    template-driven forms in our application. We will start by learning about the
    required modules and gradually progress to create forms in our application. As
    explained in the preceding sections, template-driven forms are mostly defined
    in the template file. Before we jump into creating examples of template-driven
    forms, we should understand some of the most important concepts related to forms,
    namely, `ngForm` and `ngModel`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握了使用基于模板的方法的优缺点的知识，我们将立即深入学习如何在我们的应用程序中实现基于模板的表单。我们将首先学习所需的模块，然后逐渐创建我们应用程序中的表单。如前所述，基于模板的表单大多在模板文件中定义。在我们开始创建基于模板的表单示例之前，我们应该了解与表单相关的一些最重要的概念，即`ngForm`和`ngModel`：
- en: '`ngForm`:This is the directive that helps to create the control groups inside
    the form directive'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngForm`：这是一个指令，用于在表单指令内部创建控件组'
- en: '`ngModel`:When `ngModel` is used on elements inside `ngForm`, all the elements
    and data get registered inside `ngForm`'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngModel`：当在`ngForm`内的元素上使用`ngModel`时，所有元素和数据都会在`ngForm`内注册。 '
- en: If the Angular form is using `ngForm` and `ngModel`, it means that the form
    is template-driven.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Angular表单使用`ngForm`和`ngModel`，这意味着该表单是基于模板的。
- en: Building our login form
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们的登录表单
- en: So far, we have a good high-level understanding of what template-driven forms
    are. In this section, we will put our knowledge to work by building a form. Let's
    put together a form using the classes we have learned in the preceding section.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们对基于模板的表单有了一个很好的高层次理解。在本节中，我们将把我们的知识付诸实践，通过构建一个表单来实现。让我们使用我们在前一节中学到的类来组合一个表单。
- en: 'The use case we will work on is the user login form for our application. First,
    we need to generate our login component. Run the following `ng` command to generate
    the login component:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将处理的用例是我们应用程序的用户登录表单。首先，我们需要生成我们的登录组件。运行以下`ng`命令以生成登录组件：
- en: '[PRE17]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output of the preceding command is displayed as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 前面命令的输出如下所示：
- en: We will need to add our route path in the `app-routing.module.ts` file in order
    to access the routes for `login` and `register`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`app-routing.module.ts`文件中添加我们的路由路径，以便访问`login`和`register`的路由。
- en: We are building our form using the template-driven approach, so we will need
    to do most of the work in our template file. Before we start modifying our template
    file, we will need to import a required module into our `app.module.ts` file.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用模板驱动方法构建我们的表单，因此我们需要在我们的模板文件中做大部分工作。在开始修改我们的模板文件之前，我们需要将一个必需的模块导入到我们的`app.module.ts`文件中。
- en: 'Open the `app.module.ts` file and add the following line of code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`app.module.ts`文件并添加以下代码行：
- en: '[PRE18]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Once we have imported `FormsModule` into our `app.module.ts` file, don't forget
    to add it to our list of imports inside `ngModule`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将`FormsModule`导入到我们的`app.module.ts`文件中，不要忘记将其添加到`ngModule`内的导入列表中。
- en: 'The updated `app.module.ts` file is displayed as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的`app.module.ts`文件显示如下：
- en: '![](assets/98682a79-39dc-4a24-a378-83d38e562d8c.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/98682a79-39dc-4a24-a378-83d38e562d8c.png)'
- en: 'Now, let''s open our login component template file and create our login form in
    the `login.component.html` file. The following is the code we will add to our
    template file:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们打开我们的登录组件模板文件，并在`login.component.html`文件中创建我们的登录表单。以下是我们将添加到模板文件中的代码：
- en: '[PRE19]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Let's analyze the preceding code in depth. We are creating a form using the
    HTML input elements and adding a username, password, and Submit button to the
    form. Important things to note are that for the form itself, we are telling the
    template that the form is `ngForm` and `ngForm` will group all the input elements
    of the form together into the `#loginForm` template variable. For the input elements,
    we have added the `ngModel` attribute and we specify the `name` attribute for
    the elements.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入分析上述代码。我们正在使用HTML输入元素创建一个表单，并向表单添加用户名、密码和提交按钮。需要注意的重要事项是，对于表单本身，我们告诉模板表单是`ngForm`，`ngForm`将把表单的所有输入元素组合到`#loginForm`模板变量中。对于输入元素，我们添加了`ngModel`属性，并为元素指定了`name`属性。
- en: 'Using `ngForm`, we can now easily retrieve the value of the elements inside
    the form. Since we have defined the local `#loginForm` template variable we can
    now use its properties easily. `loginForm` has the following properties:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ngForm`，我们现在可以轻松地检索表单内元素的值。由于我们已经定义了本地`#loginForm`模板变量，我们现在可以轻松地使用它的属性。`loginForm`具有以下属性：
- en: '`loginForm.value`:Returns the object containing all the values of the input
    elements inside the form'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loginForm.value`：返回包含表单内所有输入元素值的对象'
- en: '`loginForm.valid`: Returns if the form is valid or not, based on the HTML attribute
    validators applied in the template'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loginForm.valid`：根据模板中应用的HTML属性验证器返回表单是否有效'
- en: '`loginForm.touched`: Returns `true` or `false` depending on whether the form
    was touched/edited by the user or not'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loginForm.touched`：根据用户是否触摸/编辑表单返回`true`或`false`'
- en: In the preceding code, we are passing `loginForm.value` to the component. We
    can pass any of these value to the component for processing or validation. Notice
    that we are also calling a `login` method, which we need to implement in our `Component`
    class file.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们将`loginForm.value`传递给组件。我们可以将任何这些值传递给组件进行处理或验证。请注意，我们还调用了一个`login`方法，我们需要在我们的`Component`类文件中实现它。
- en: 'Now, let''s create a method in our `Component` class to capture the data coming
    in from our `loginForm`. We are collecting the value of the form and displaying
    it in the console:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在我们的`Component`类中创建一个方法来捕获来自我们的`loginForm`的数据。我们正在收集表单的值并在控制台中显示它：
- en: '[PRE20]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Run the app using the `ng serve` command, and we should see the output shown
    in the following screenshot:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ng serve`命令运行应用程序，我们应该看到以下截图中显示的输出：
- en: '![](assets/e298edd1-6fd2-426f-ba2e-e99c4e4c88d7.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e298edd1-6fd2-426f-ba2e-e99c4e4c88d7.png)'
- en: Remember that in typical server-side scripting, we used to write `action` and
    `method` attributes for forms. We do not need to define these anymore, since they
    are declared and used in the `Component` class.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在典型的服务器端脚本中，我们过去常常为表单编写`action`和`method`属性。现在我们不需要再定义这些，因为它们在`Component`类中已经声明和使用了。
- en: This is good stuff and good progress. We will continue to use the preceding
    login form and add validations shortly. Let's keep digging for more information.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这是很好的东西和很好的进展。我们将继续使用前面的登录表单，并很快添加验证。让我们继续深入了解更多信息。
- en: Model-driven forms, or reactive forms
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于模型驱动的表单，或者叫做响应式表单
- en: Reactive forms are also called model-driven forms. In model-driven forms, the
    model is created in the `Component` class file and is responsible for doing the
    form validation, processing data, and much more.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式表单也被称为基于模型驱动的表单。在基于模型驱动的表单中，模型是在`Component`类文件中创建的，并负责进行表单验证、处理数据等等。
- en: Angular internally builds a tree structure of the Angular form controls, which
    makes it much easier to push and manage data between the data models and the UI
    elements.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Angular在内部构建了Angular表单控件的树结构，这样更容易在数据模型和UI元素之间推送和管理数据。
- en: We need to build the form model in our `Component` class by creating the instances
    of the building blocks (that is, `FormControl` and `FormGroup`). Additionally,
    we write the validation rules and the validation error messages in the class as
    well. We even manage the properties (that is, the data model) in the class as
    opposed to using data binding in the HTML.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`Component`类中构建表单模型，通过创建构建块的实例（即`FormControl`和`FormGroup`）来实现。此外，我们还在类中编写验证规则和验证错误消息。我们甚至在类中管理属性（即数据模型），而不是在HTML中使用数据绑定。
- en: Template-driven forms put the responsibility for the forms on the template,
    whereas reactive forms shift the responsibility for validation to the `Component`
    class.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 模板驱动的表单将表单的责任放在模板上，而响应式表单将验证的责任转移到`Component`类上。
- en: 'In this chapter, we will use the both terms: model-driven forms and reactive
    forms, as both refer to the same thing.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将同时使用这两个术语：基于模型驱动的表单和响应式表单，因为它们都指代同一件事情。
- en: Model-driven forms – pros
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于模型驱动的表单 - 优点
- en: 'Reactive forms are very useful in creating, validating and applying custom
    form validations to our forms in our applications. We can easily trust the model
    driven approach to do all the heavy duty work that is usually associated with
    any complex forms. In this section, we will list and understand the pros of using
    model-driven forms in our applications:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式表单在我们的应用程序中创建、验证和应用自定义表单验证非常有用。我们可以轻松地信任基于模型驱动的方法来完成通常与任何复杂表单相关的繁重工作。在本节中，我们将列出并了解在我们的应用程序中使用基于模型驱动的表单的优点：
- en: Greater flexibility for more complicated validation scenarios and custom, complex
    form validations
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更灵活，适用于更复杂的验证场景和自定义复杂表单验证
- en: The data model is immutable
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据模型是不可变的
- en: Since the data model is immutable, no data binding is done
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于数据模型是不可变的，所以不进行数据绑定
- en: It's easier to add input elements dynamically (such as subtasks on a task form)
    using form arrays
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用表单数组动态添加输入元素更容易（例如，在任务表单上添加子任务）
- en: It's easy to bind various events to input elements using `HostListener` and
    `HostBindings`
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`HostListener`和`HostBindings`很容易将各种事件绑定到输入元素
- en: All the code for the form controls and validations is inside the component,
    which makes templates much simpler and easier to maintain
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有表单控件和验证的代码都在组件内部，这样模板会更简单、更易于维护
- en: It's easier to unit test
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更容易进行单元测试
- en: Model-driven forms – cons
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于模型驱动的表单 - 缺点
- en: 'All good things in life has some form of cons attached to them. Reactive forms
    are no different in nature. While the pros and advantages of using reactive forms
    can certainly outweight the cons but still it''s important to learn and understand
    the cons of using reactive forms in our applications. In this section, we will
    list the cons of using model-driven forms in our applications:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 生活中所有美好的事物都有一些缺点。响应式表单也不例外。虽然使用响应式表单的优点和优势肯定可以超过缺点，但学习和理解在应用程序中使用响应式表单的缺点仍然很重要。在本节中，我们将列出在应用程序中使用模型驱动表单的缺点：
- en: Immediate beginners may find the initial learning curve too high
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初学者可能会觉得初始学习曲线太高
- en: The developer is expected to have knowledge about the various modules required
    to work with model-driven forms, such as `ngvalidators`, and so on
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发人员应该了解与模型驱动表单一起使用所需的各种模块，比如`ngvalidators`等等
- en: Model-driven forms – important modules
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型驱动表单 - 重要模块
- en: 'We create the model using the two powerful classes provided by Angular—`formGroup`
    and `formControl`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Angular提供的两个强大类`formGroup`和`formControl`来创建模型：
- en: '`FormControl`: Tracks the value and state of individual form input elements'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FormControl`：跟踪单个表单输入元素的值和状态'
- en: '`FormGroup`: Tracks the value and state of a group of form controls'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FormGroup`：跟踪一组表单控件的值和状态'
- en: '`FormBuilder`: Helps us to develop forms with their initial value and their
    validations'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FormBuilder`：帮助我们使用它们的初始值和验证开发表单'
- en: Just as we imported `FormsModule` in to our template-driven forms, we will need
    to import `ReactiveFormsModule` in to our `app.module.ts` file.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在模板驱动表单中导入了`FormsModule`一样，我们需要在`app.module.ts`文件中导入`ReactiveFormsModule`。
- en: 'The updated `app.module.ts` file should look like the following screenshot:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的`app.module.ts`文件应该如下截图所示：
- en: '![](assets/34059900-9e37-43f3-8b5d-638d8585057b.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/34059900-9e37-43f3-8b5d-638d8585057b.png)'
- en: Armed with all the knowledge about the model-driven form approach, it's time
    for a hands-on example.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握了关于模型驱动表单方法的所有知识，现在是进行实际示例的时候了。
- en: Reactive forms – registration form example
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式表单 - 注册表单示例
- en: In the previous section while covering template-driven forms, we have created
    our login form for our application. It's time to do a hands-on exercise using
    the reactive forms. The fundamental idea behind implementing login and registration
    forms using different approaches is to show you the difference in implementation
    of each approach. There is no right or wrong approach, the decision is driven
    by the complexity and requirement of our forms in the applications.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们在讲解模板驱动表单时，为我们的应用程序创建了登录表单。现在是使用响应式表单进行实际练习的时候了。使用不同方法实现登录和注册表单的基本想法是向您展示每种方法的实现差异。没有正确或错误的方法，决定是由应用程序中表单的复杂性和要求驱动的。
- en: In this section, we will learn to implement our new user registration form using
    the model-driven approach.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习使用模型驱动方法实现我们的新用户注册表单。
- en: 'First, we will need to generate our `register` component. Run the following `ng`
    command to generate the `register` component:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要生成我们的`register`组件。运行以下`ng`命令来生成`register`组件：
- en: '[PRE21]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output of the preceding command is as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出如下：
- en: '![](assets/c044b603-8c86-4bd8-80e7-3012fdba4c7b.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c044b603-8c86-4bd8-80e7-3012fdba4c7b.png)'
- en: Since we are talking about model-driven forms, all the hard work had to be done
    in the `Component` class. We will still need to have a template for our reactive
    forms, but we won't be adding any validations or data binding into the template.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们正在谈论模型驱动表单，所有的辛苦工作都必须在`Component`类中完成。我们仍然需要为我们的响应式表单准备一个模板，但我们不会在模板中添加任何验证或数据绑定。
- en: We want our registration form to have four form elements—that is, fields for
    full names, email addresses, passwords, and terms and conditions.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的注册表单有四个表单元素，即全名、电子邮件地址、密码和条款与条件的字段。
- en: 'Let''s update our `Component` class in the `register.component.ts` file and
    create an instance of `formGroup`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新`register.component.ts`文件中的`Component`类，并创建一个`formGroup`实例：
- en: '[PRE22]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You will notice a lot of new stuff in the preceding code. Let's take it slowly, step
    by step. We are importing the required modules, `FormGroup` and `FormControl`,
    from the `angular/core`. Inside the `Component` class, we are creating an instance
    of the `FormGroup` class, `registerForm`. You will notice that we are now creating
    multiple `FormControl` instances, each one for a form element that we want to
    add to our form.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到在上面的代码中有很多新东西。让我们慢慢来，一步一步地。我们正在从`angular/core`中导入所需的模块`FormGroup`和`FormControl`。在`Component`类内部，我们正在创建`FormGroup`类的一个实例`registerForm`。您会注意到我们现在正在创建多个`FormControl`实例，每个实例都是我们想要添加到我们的表单中的一个表单元素。
- en: Is that all we need to do? For now, yes. Remember, as explained before, that
    reactive forms also need to have a basic template, but all the logic and validations
    will be inside the component, rather than the template file.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要做的全部吗？目前是的。请记住，如前所述，响应式表单也需要一个基本模板，但所有的逻辑和验证将在组件内部，而不是模板文件中。
- en: 'So now, let''s update our template file. In the `register.component.html` file,
    add the following code:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更新我们的模板文件。在`register.component.html`文件中，添加以下代码：
- en: '[PRE23]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding code, we are creating a dynamic reactive form. There are many
    important concepts that we need to understand in the preceding code. We are using
    the `FormGroup` attribute for model-driven forms. In the template-driven forms,
    we used `ngForm`. Notice carefully that for every form element, we mention the `FormControlName`
    attribute, and the value for this attribute has to be exactly the same as was
    mentioned in the `Component` class during the `FormControl` instance declaration.
    Take a pause and read the last few sentences again.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们正在创建一个动态的响应式表单。在上面的代码中，有许多重要的概念我们需要理解。我们在基于模型的表单中使用`FormGroup`属性。在基于模板的表单中，我们使用`ngForm`。请注意，对于每个表单元素，我们都提到了`FormControlName`属性，而此属性的值必须与在`FormControl`实例声明期间在`Component`类中提到的值完全相同。暂停一下，再读一遍最后几句话。
- en: We don't have to mention `ngModel` for elements anymore, since data binding
    is tightly coupled inside the `Component` class itself. We have also attached
    a `ngSubmit` event, which will call the method register implemented inside the
    component to print the form value on the console.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再需要为元素提及`ngModel`，因为数据绑定已经紧密耦合在`Component`类本身内。我们还附加了一个`ngSubmit`事件，它将调用组件内实现的`register`方法，以在控制台上打印表单值。
- en: 'Awesome. That''s it. Now serve your application using the `ng serve` command
    and we should see the output as displayed in the following screenshot:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了。就是这样。现在使用`ng serve`命令启动您的应用程序，我们应该看到如下截图中显示的输出：
- en: '![](assets/36bf4dd1-b7ec-4f94-baef-76a3565cc72e.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/36bf4dd1-b7ec-4f94-baef-76a3565cc72e.png)'
- en: Congrats on getting your forms up and running using the approaches provided
    by Angular. We have learned to build forms using template-driven and model-driven
    approaches. In the next sections, we will learn to extend them by adding validation
    and custom rules.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜您使用Angular提供的方法成功启动并运行您的表单。我们已经学会了使用基于模板和基于模型的方法构建表单。在接下来的部分，我们将学习通过添加验证和自定义规则来扩展它们。
- en: Angular form validations
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular表单验证
- en: By now, we understand how important and critical forms are to all our applications.
    Since we will be working on data we receive from users, it's very important to
    make sure that the data we receive from our users is correct and valid.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解到表单对于我们所有的应用程序是多么重要和关键。由于我们将处理来自用户的数据，确保我们接收到的数据是正确和有效的非常重要。
- en: For example, when we expect the user to enter an email address, we should not
    allow spaces or a few special characters in the email address. One more example,
    if we request the user to enter the phone number, it should not have more than
    10 digits (excluding country code of course).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当我们期望用户输入电子邮件地址时，我们不应该允许在电子邮件地址中输入空格或一些特殊字符。再举一个例子，如果我们要求用户输入电话号码，电话号码不应该超过10位数（当然不包括国家代码）。
- en: There can be many such custom valid checkpoints that we may want to have in
    our forms.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能希望在我们的表单中有许多这样的自定义有效检查点。
- en: In this section, we will continue to use both the login form and our registration
    form to learn how to add validations in both template-driven forms and model-driven
    forms.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将继续使用登录表单和注册表单，学习如何在模板驱动表单和模型驱动表单中添加验证。
- en: Template-driven form validation
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板驱动表单验证
- en: Bring up our login form that we developed using the template-driven approach.
    Remember, that in the template-driven forms, validation is done in the template
    itself using the HTML attributes.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 打开我们使用模板驱动方法开发的登录表单。请记住，在模板驱动表单中，验证是在模板本身使用HTML属性进行的。
- en: We can use any of the HTML attributes, such as required, `maxlength`, `minlength`,
    `size`, `email`, `number`, `length`, and so on, to put validation in forms. We
    can also make use of HTML pattern attributes to put regular expression checks
    in our form elements.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用任何HTML属性，例如required、`maxlength`、`minlength`、`size`、`email`、`number`、`length`等，在表单中进行验证。我们还可以利用HTML模式属性在我们的表单元素中进行正则表达式检查。
- en: 'There are various classes that we can make use of readily to implement validation
    in our forms:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用各种类来实现表单验证：
- en: '`ng-touched`: Input controls have been visited'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-touched`：输入控件已被访问'
- en: '`ng-untouched`: Input controls have not been visited'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-untouched`：输入控件尚未被访问'
- en: '`ng-dirty`: Input controls data was changed'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-dirty`：输入控件数据已更改'
- en: '`ng-pristine`: Input controls data has not been changed/updated'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-pristine`：输入控件数据尚未更改/更新'
- en: '`ng-valid`: Input control data is a valid set and makes the form valid'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-valid`：输入控件数据是有效的，并使表单有效'
- en: '`ng-invalid`: Input control data is not valid and hence the form is not valid'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-invalid`：输入控件数据无效，因此表单无效'
- en: 'In template-driven forms, Angular will automatically track the state of each
    input element and the state of the form as well. Hence, we can also use the preceding
    classes in our CSS/SCSS to style/design our error notifications, as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板驱动的表单中，Angular会自动跟踪每个输入元素的状态以及表单的状态。因此，我们也可以在我们的CSS/SCSS中使用上述类来设计我们的错误通知，例如：
- en: '[PRE24]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Alright, now that we know about validations in template-driven forms, it's time
    to update our login form component and make it jazzy. We are updating the `login.component.html`
    file by adding validations to the form elements.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在我们已经了解了模板驱动表单中的验证，是时候更新我们的登录表单组件并使其更加时尚。我们将通过向表单元素添加验证来更新`login.component.html`文件。
- en: '[PRE25]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Let's take a closer look at the preceding code. We have extended the login form
    we had created earlier. Notice that for the username form control, we have the
    HTML attribute `required`, which will be set on the form control. If the user
    does not enter any value for the field and steps out of the focus of the field,
    using the `ngIf` condition, we are checking if the field is touched by the user
    and is if the value is not valid, we are displaying the error message. For the
    `password` field, we are setting other HTML attributes, such as `required` and
    `minlength` validation checks. If the form control data is not valid, we should
    not enable the form, right? That's what we are doing by adding the `disabled`
    attribute to the Submit button.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看一下上面的代码。我们扩展了之前创建的登录表单。请注意，对于用户名表单控件，我们有HTML属性`required`，它将设置在表单控件上。如果用户没有为该字段输入任何值并且离开了该字段的焦点，使用`ngIf`条件，我们正在检查用户是否触摸了该字段，并且如果值无效，我们将显示错误消息。对于`password`字段，我们设置了其他HTML属性，如`required`和`minlength`验证检查。如果表单控件数据无效，我们不应该启用表单，对吧？这就是我们通过向提交按钮添加`disabled`属性来做的。
- en: 'Now let''s run the app using the `ng serve` command and we should see the output,
    as shown in the following screenshot:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用`ng serve`命令运行应用程序，我们应该看到输出，如下面的截图所示：
- en: '![](assets/fcbb84dd-9730-4111-9b1e-51c29bdaef9b.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/fcbb84dd-9730-4111-9b1e-51c29bdaef9b.png)'
- en: 'For your homework, please try out these use cases in template-driven forms:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 对于您的作业，请尝试在模板驱动表单中尝试这些用例：
- en: Add minimum and maximum length to the username form element
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为用户名表单元素添加最小和最大长度
- en: Add a new form element and add validation that it should be in an email format
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个新的表单元素，并添加验证，它应该是电子邮件格式
- en: Reactive form, or model-driven form, validations
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式表单或模型驱动表单验证
- en: So far all, the validations we have implemented are only in the template file
    using the basic HTML attributes. In this section, we will learn to implement the
    validations in the component using the model-driven forms.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们实现的所有验证都只是在模板文件中使用基本的HTML属性。在本节中，我们将学习如何在组件中使用模型驱动表单实现验证。
- en: In previous sections, we have learned to create a form using the `formControl`
    and `formGroup` classes in our `Component` class. We will continue to use the
    same registration form to extend and implement validations now.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们已经学会了在我们的`Component`类中使用`formControl`和`formGroup`类创建表单。我们将继续使用相同的注册表单来扩展和实现验证。
- en: 'We are adding the validation code in our component by adding validations in
    the `register.component.ts` file. Take a look at the code we will add in the file:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在`register.component.ts`文件中添加验证来为我们的组件添加验证代码。看一下我们将在文件中添加的代码：
- en: '[PRE26]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding code, you will notice that we have imported the required modules, `FormGroup`,
    `FormControl`, and `Validators` into our `Component` class. We had already imported
    and used `FormGroup` and `FormControl`. The `Validators` module is the only additional
    module that we have imported now. We are passing the validators as options to
    `FormControl`. For `fullname` we are adding the validators as `required` and `maxLength`.
    Note that we can pass multiple validators for each `FormControl`. Similarly, for
    email address form control, we are passing a validator pattern, which has a regular
    expression check on it. We have made all the required changes and validations
    in our component.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，您会注意到我们已经将所需的模块`FormGroup`、`FormControl`和`Validators`导入到我们的`Component`类中。我们已经导入并使用了`FormGroup`和`FormControl`。`Validators`模块是我们现在导入的唯一额外模块。我们将验证器作为选项传递给`FormControl`。对于`fullname`，我们将验证器添加为`required`和`maxLength`。请注意，我们可以为每个`FormControl`传递多个验证器。同样，对于电子邮件地址表单控件，我们正在传递一个验证器模式，其中包含正则表达式检查。我们已经在我们的组件中进行了所有必要的更改和验证。
- en: 'Now it''s time to update our template `register.component.html` file:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候更新我们的模板`register.component.html`文件了：
- en: '[PRE27]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The HTML template is the same as the one we had created earlier for our model-driven
    form. We have added some more functionality to the form. Notice that we have added
    the `disabled` attribute to the Submit button, which will disable the form if
    any form elements are empty or invalid.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: HTML模板与我们之前为我们的基于模型的表单创建的模板相同。我们为表单添加了一些功能。请注意，我们在提交按钮上添加了`disabled`属性，如果任何表单元素为空或无效，它将禁用表单。
- en: See, I told you, our template file will just be a placeholder and almost all
    of the action happens in our `Component` class.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 看，我告诉过你，我们的模板文件只是一个占位符，几乎所有的操作都发生在我们的`Component`类中。
- en: 'Now, let''s serve the app using the `ng serve` command and we should see the
    output, as shown in the following screenshot:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用`ng serve`命令来启动应用程序，我们应该看到输出，就像下面的截图中显示的那样：
- en: '![](assets/419a17df-99f3-4481-b97f-2cd8ebb1483a.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/419a17df-99f3-4481-b97f-2cd8ebb1483a.png)'
- en: If you see the preceding screenshot, jump on your desk. As we have now learned
    and implemented forms using both template-driven and model-driven approaches.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到了前面的截图，就跳到你的桌子上。因为我们现在已经学会并实现了使用模板驱动和基于模型的方法来创建表单。
- en: If you paid attention to the examples covered during the entire chapter, you
    will also notice that we have created methods to process the form data.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在整个章节中注意到了我们涵盖的示例，你也会注意到我们创建了处理表单数据的方法。
- en: In the next section, we focus exclusively on the same and learn some best practices
    to process form data.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将专门关注这一点，并学习一些处理表单数据的最佳实践。
- en: Submitting form data
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提交表单数据
- en: So far, we have learned to design and develop our forms in our applications.
    In this section, we will take things to downstream systems, which is to capture
    the data and process it.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学会了在我们的应用程序中设计和开发我们的表单。在本节中，我们将把事情带到下游系统，即捕获数据并处理数据。
- en: Angular generates a form model in both approaches, be it template-driven forms
    or reactive forms. The form model holds the data of the form elements and the
    state of the form elements.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: Angular在这两种方法中都生成了一个表单模型，无论是模板驱动表单还是响应式表单。表单模型保存了表单元素的数据和状态。
- en: In the previous sections, where we have implemented our forms, we have created
    a method to call on `ngSubmit`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们已经创建了一个方法来调用`ngSubmit`。
- en: 'For our template-driven login form, we added the following code to our `login.component.ts`
    file:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的模板驱动登录表单，我们在`login.component.ts`文件中添加了以下代码：
- en: '[PRE28]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We are passing the entire form object to the login method. Now the `loginForm`
    object will have all the details of the form controls, as well as the states.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将整个表单对象传递给登录方法。现在`loginForm`对象将包含表单控件的所有细节，以及状态。
- en: In our registration form, which is generated using a model-driven approach,
    we have used the instance of `formGroup` that we created in our `Component` class
    `register.component.ts` file.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的注册表单中，我们使用了基于模型驱动的方法生成的实例`formGroup`，这个实例是在我们的`Component`类`register.component.ts`文件中创建的。
- en: 'The following is the code we have added for capturing and processing the data:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们添加的用于捕获和处理数据的代码：
- en: '[PRE29]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If you notice, for reactive forms, we do not have to pass any form data, since
    we had created the `registerForm` instance of `FormGroup`, so it's available in
    our class using the `this` operator.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到，对于响应式表单，我们不需要传递任何表单数据，因为我们已经创建了`FormGroup`的`registerForm`实例，所以它可以在我们的类中使用`this`运算符来访问。
- en: Once we have captured the data provided to the user, based on the application
    requirements, we can now implement our custom logic inside the component.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们捕获了用户提供的数据，根据应用程序的要求，我们现在可以在组件内部实现我们的自定义逻辑。
- en: 'Some of the common activities we do once we capture data are the following:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们捕获数据，我们进行的一些常见活动如下：
- en: Securing data to make sure that we do not allow junk data into our system.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护数据，以确保我们不允许垃圾数据进入我们的系统。
- en: Processing/enhancing the data, such as converting the password into an encrypted
    value.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理/增强数据，例如将密码转换为加密值。
- en: Checking for any automated bots processing our applications.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查是否有任何自动化机器人处理我们的应用程序。
- en: Making HTTP calls to backend services using Angular services. We have an entire
    chapter dedicated to this particular topic: [Chapter 12](9610f27b-03db-4258-8a68-24eb3901117b.xhtml), *Integrating
    Backend Data Services. *
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Angular服务向后端服务发出HTTP调用。我们有一个专门讨论这个特定主题的章节：[第12章](9610f27b-03db-4258-8a68-24eb3901117b.xhtml)，*集成后端数据服务*。
- en: That concludes this chapter on Angular forms. We have covered a lot of ground
    and I am sure at this point you will be excited to create your own forms, write
    custom validations, and process the captured data.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了关于Angular表单的章节。我们涵盖了很多内容，我相信此时您一定会很兴奋地创建自己的表单，编写自定义验证并处理捕获的数据。
- en: Summary
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Forms are the very heart and soul of any good application. We started by learning
    the awesome classes and utilities provided by the Bootstrap library. We explored
    in detail the `form-group` and `form-control` classes. We learned and implemented
    various helper and additional attributes that we can use to make our form look
    and behave even better.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 表单是任何良好应用程序的核心和灵魂。我们首先学习了Bootstrap库提供的出色类和实用工具。我们详细探讨了`form-group`和`form-control`类。我们学习并实现了各种辅助和附加属性，以使我们的表单看起来和行为更好。
- en: We deep-dived into Angular forms by learning the two approaches Angular provides,
    namely template-driven forms and model-driven forms.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过学习Angular提供的两种方法，即基于模板的表单和基于模型的表单，深入研究了Angular表单。
- en: We learned in detail about each of the approaches, their pros and cons, and
    above all created our login and registration forms using each of the approaches.
    We also explored the various type of validations that we have used with template-driven
    forms and reactive forms.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们详细了解了每种方法的优缺点，并使用每种方法创建了我们的登录和注册表单。我们还探讨了我们在基于模板的表单和响应式表单中使用的各种类型的验证。
- en: Last, but not least, we learned about processing the form data that we receive
    from the forms. It's time to get wings and create your awesome forms.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，但同样重要的是，我们学习了如何处理我们从表单接收到的表单数据。现在是时候展翅飞翔，创建您自己的精彩表单了。
- en: While developing complex applications with multiple developers working on the
    same application, things can get out of hand. Luckily, Angular supports dependency
    injections and services, which enables us to create reusable services and define
    interface classes. We can define new data types and make sure all team members
    are pushing code without breaking each other's functionality. And how exactly
    will we achieve that? That's covered in the next chapter. Keep reading!
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发具有多个开发人员的复杂应用程序时，情况可能会失控。幸运的是，Angular支持依赖注入和服务，这使我们能够创建可重用的服务并定义接口类。我们可以定义新的数据类型，并确保所有团队成员在不破坏彼此功能的情况下推送代码。我们将如何实现这一点？这将在下一章中介绍。继续阅读！
