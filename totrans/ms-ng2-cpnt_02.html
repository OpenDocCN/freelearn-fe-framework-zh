<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Ready, Set, Go!" id="aid-J2B81"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Ready, Set, Go!</h1></div></div></div><p>In this chapter, we will start building our task management application. We'll jump right into the core of the application and create the initial components required to manage a simple task list. In the process of going through this chapter, you'll learn about the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Bootstrapping an Angular application using a main component</li><li class="listitem">Component input and output</li><li class="listitem">Host property binding</li><li class="listitem">Styling and view encapsulation</li><li class="listitem">Importing HTML templates using the SystemJS text loader</li><li class="listitem">Using <code class="literal">EventEmitter</code> to emit custom events</li><li class="listitem">Two-way data binding</li><li class="listitem">Component life cycle</li></ul></div><div class="section" title="Managing tasks"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Managing tasks</h1></div></div></div><p>After picking up the <a id="id89" class="indexterm"/>basics from the previous chapter, we will now go on and create a task management application together in the upcoming chapters. You'll learn about some concepts during the chapters and then use them with practical examples. You'll also learn how to structure an application using components. This begins with the folder structure and ends with setting up the interaction between components.</p><div class="section" title="Vision"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec15"/>Vision</h2></div></div></div><p>The task management <a id="id90" class="indexterm"/>application should enable users to manage tasks easily and help them organize small projects. Usability is the central aspect of any application; therefore, you'll need to design a modern and flexible user interface that will support the user.</p><div class="mediaobject"><img src="../Images/image00304.jpeg" alt="Vision"/><div class="caption"><p>A preview of the task management application we are going to build</p></div></div><p style="clear:both; height: 1em;"> </p><p>Our task management application will consist of components that will allow us to design a platform providing a great user experience for the purpose of managing tasks. Let's define the core features of our application:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Managing tasks within multiple projects and providing a project overview</li><li class="listitem">Simple scheduling as well as a time-and-effort-tracking mechanism</li><li class="listitem">Overviewing the dashboard using graphical charts</li><li class="listitem">Tracking activities and <a id="id91" class="indexterm"/>providing a visual audit log</li><li class="listitem">A simple commenting system that would work across different components</li></ul></div><p>The task management application is the main example in this book. Therefore, the building blocks within the book should only contain the code that is relevant to the theme of the book. Of course, other than components, an application needs other functionalities, such as visual design, data, session management, and other important parts, to work. While the required code for each chapter can be downloaded online, we'll only discuss the code relevant to the topics learned within the book.</p></div></div></div>
<div class="section" title="Starting from scratch"><div class="titlepage" id="aid-K0RQ2"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Starting from scratch</h1></div></div></div><p>Let's start out by creating a <a id="id92" class="indexterm"/>new folder called <code class="literal">angular-2-components</code> in order to create our application:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open a console window inside our newly created folder and run the following command to initialize a new Node.js project:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>npm init</strong></span>
</pre></div></li><li class="listitem">Finish the initialization wizard by confirming all the steps with the <span class="emphasis"><em>Enter</em></span> key (default settings).</li><li class="listitem">Since we're using JSPM to manage our dependencies, we need to install it as a project Node.js package:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>npm install jspm --save-dev</strong></span>
</pre></div></li><li class="listitem">Let's also initialize a new JSPM project within our project folder. Be sure to use the default settings (just hit the <span class="emphasis"><em>Enter</em></span> key) for all settings, except for the step where you are asked which transpiler you'd like to use. Enter TypeScript at this stage:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>jspm init</strong></span>
</pre></div></li><li class="listitem">We'll now use JSPM to install the relevant Angular 2 packages into our project as dependencies. We'll also install a SystemJS loader plugin to load text files as modules. We'll provide some details around this later on:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>jspm install npm:@angular/core npm:@angular/common npm:@angular/compiler npm:@angular/platform-browser-dynamic npm:rxjs text</strong></span>
</pre></div></li></ol><div style="height:10px; width: 1px"/></div><p>Let's examine what we've been <a id="id93" class="indexterm"/>creating so far by using the NPM and JSPM command-line tools.</p><p>The <code class="literal">package.json</code> file is our Node.js configuration file that we're using as the base to work with JSPM (the package manager) and SystemJS (the module loader with transpiler). If you check out the <code class="literal">package.json</code> file, you will see an additional section for JSPM dependencies:</p><div class="informalexample"><pre class="programlisting">  "jspm": {
    "dependencies": {
      "@angular/common": "npm:@angular/common@2.0.0-rc.1",
      "@angular/compiler": "npm:@angular/compiler@2.0.0-rc.1",
      "@angular/core": "npm:@angular/core@2.0.0-rc.1",
      "@angular/platform-browser-dynamic": "npm:@angular/platform-browser-dynamic@2.0.0-rc.1",
      "text": "github:SystemJS/plugin-text@0.0.7"
    },
    "devDependencies": {
      "typescript": "npm:typescript@1.8.10",
    }
  }</pre></div><p>Let's take a quick look at the dependencies we have installed using JSPM and their purpose:</p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><thead><tr><th valign="bottom">
<p>Package</p>
</th><th valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td valign="top">
<p><code class="literal">@angular/core</code></p>
</td><td valign="top">
<p>This is the core package of Angular 2, hosted on NPM. If you remember from <a class="link" title="Chapter 1. Component-Based User Interfaces" href="part0014.xhtml#aid-DB7S1">Chapter 1</a>, <span class="emphasis"><em>Component-Based User Interfaces</em></span>, JSPM is only a broker, and it delegates to other package repositories. The core package contains all Angular-core modules, such as the <code class="literal">@Component</code> decorator, change detection, dependency injection, and more.</p>
</td></tr><tr><td valign="top">
<p><code class="literal">@angular/common</code></p>
</td><td valign="top">
<p>The Angular <code class="literal">common</code> package provides us with base directives, such as <code class="literal">NgIf</code> and <code class="literal">NgFor</code>. It also contains all the base pipes and the directives that are used to control forms.</p>
</td></tr><tr><td valign="top">
<p><code class="literal">@angular/compiler</code></p>
</td><td valign="top">
<p>The compiler package contains all the artifacts required to compile view templates. Angular not only provides the ability to precompile templates to gain faster booting time, but it also uses the compiler at runtime to convert text templates into compiled templates. This package is required if we're compiling templates at runtime.</p>
</td></tr><tr><td valign="top">
<p><code class="literal">@angular/platform-browser-dynamic</code></p>
</td><td valign="top">
<p>This package includes the bootstrapping functionality that will help us start our application. The bootstrap initiated by the platform-browser-dynamic package is dynamic in the sense of compiling templates at runtime.</p>
</td></tr><tr><td valign="top">
<p><code class="literal">typescript</code></p>
</td><td valign="top">
<p>This development dependency is the TypeScript transpiler for SystemJS. It transpiles our ECMAScript 6 and TypeScript code to ECMAScript 5, from where it can run in the browser.</p>
</td></tr><tr><td valign="top">
<p><code class="literal">text</code></p>
</td><td valign="top">
<p>This SystemJS loader supports the loading of text files in the form of JavaScript strings. This is especially useful if you like to load HTML templates and avoid asynchronous requests.</p>
</td></tr></tbody></table></div><p>Our main entry point for displaying <a id="id94" class="indexterm"/>our application within the browser is our index site. The <code class="literal">index.html</code> file completes the following five actions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Loading ECMAScript 6 polyfill es6-shim from a CDN. This script is required to make sure the browser understands the latest ECMAScript 6 APIs.</li><li class="listitem">Loading the Angular 2 polyfills required by the framework. This includes various patches for the browser that are required to run an Angular 2 application. It's important to load these polyfills before we load any other code within our application.</li><li class="listitem">Loading SystemJS and the SystemJS <code class="literal">config.js</code> file that contains the mapping information generated by JSPM.</li><li class="listitem">Using the <code class="literal">System.import</code> function to load and execute the main entry point, which is our <code class="literal">boostrap.js</code> file.</li></ul></div><p>Let's create a new <code class="literal">index.html</code> file <a id="id95" class="indexterm"/>within the root folder of our project:</p><div class="informalexample"><pre class="programlisting">&lt;!doctype html&gt;
&lt;html&gt;
&lt;head lang="en"&gt;
  &lt;title&gt;Angular 2 Components&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

<span class="strong"><strong>&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/es6-shim/0.35.0/es6-shim.min.js"&gt;&lt;/script&gt;</strong></span>
<span class="strong"><strong>&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/2.0.0-beta.15/angular2-polyfills.js"&gt;&lt;/script&gt;</strong></span>
<span class="strong"><strong>&lt;script src="jspm_packages/system.js"&gt;&lt;/script&gt;</strong></span>
<span class="strong"><strong>&lt;script src="config.js"&gt;&lt;/script&gt;</strong></span>
&lt;script&gt;
<span class="strong"><strong>  System.import('lib/bootstrap.js');</strong></span>
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div><p>Let's move on to our application component. You can think of it as the outermost component of your application. It's the main component in that it represents your whole application. Every application needs one and just one main component. This is where your component tree has its roots.</p><p>We'll name our main component <code class="literal">App</code> because it represents our whole application. Let's go ahead and create the component within a new <code class="literal">lib</code> folder in our project folder. Create a file, <code class="literal">app.js</code>, with the following content:</p><div class="informalexample"><pre class="programlisting">// We need the Component annotation as well as the 
// ViewEncapsulation enumeration
import {Component, ViewEncapsulation} from '@angular/core';

// Using the text loader we can import our template
import template from './app.html!text';

// This creates our main application component
@Component({
  // Tells Angular to look for an element &lt;ngc-app&gt; to create this 
  // component
  selector: 'ngc-app',
  // Let's use the imported HTML template string
  template,
  // Tell Angular to ignore view encapsulation
  encapsulation: ViewEncapsulation.None
})
export class App {}</pre></div><p>There's nothing different here from what we already know about structuring a component, something that we learned in the previous chapter. However, there are two main differences here compared to how we created the components before. If you look at how we configured the <code class="literal">template</code> property, you could tell that we didn't write the HTML template directly within the <a id="id96" class="indexterm"/>JavaScript file inside the ECMAScript 6 template strings. Instead, we're going to load the template into a JavaScript string using the text loader plugin in SystemJS. We can just load any text file from the file system by appending <code class="literal">!text</code> to our regular ECMAScript 6 imports:</p><div class="informalexample"><pre class="programlisting">import template from './app.html!text';</pre></div><p>This will load the file, <code class="literal">app.html</code>, from the current directory and make a default export with its content as a string.</p><p>The second difference is that we're using <code class="literal">ViewEncapsulation</code> to specify how Angular should handle view encapsulation. Angular has three ways, to handle view encapsulation, which provides different levels of granularity and has their own pros and cons. They are as follows:</p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><thead><tr><th valign="bottom">
<p>Encapsulation type</p>
</th><th valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td valign="top">
<p><code class="literal">ViewEncapsulation.Emulated</code></p>
</td><td valign="top">
<p>If a component is set to emulated view encapsulation, it will emulate style encapsulation by attaching the generated attributes to the component element and modifying CSS selectors to include these attribute selectors. This will enable certain forms of encapsulation, although the outer styles can still leak into the component if there are other global styles.</p>
<p>This view encapsulation mode is the default mode, if not specified otherwise.</p>
</td></tr><tr><td valign="top">
<p><code class="literal">ViewEncapsulation.Native</code></p>
</td><td valign="top">
<p>Native view encapsulation is supposed to be the ultimate goal of the view encapsulation concept within Angular. It makes use of Shadow DOM, as described in the previous chapter, to create an isolated DOM for the whole component. This mode depends on the browser to support Shadow DOM natively, and therefore, can't always be used. It's also important to note that global styles will no longer be respected and local styles need to be placed within the component in inline style tags (or use the <code class="literal">styles</code> property on the component annotation).</p>
</td></tr><tr><td valign="top">
<p><code class="literal">ViewEncapsulation.None</code></p>
</td><td valign="top">
<p>This mode tells Angular not to provide any template or style encapsulation. Within our application, we mainly rely on styles coming from a global CSS; therefore, we use this mode for most of the components. Neither Shadow DOM, nor attributes will be used to create style encapsulation; we can simply use the classes specified within our global CSS file.</p>
</td></tr></tbody></table></div><p>As this component is now relying on a template to be loaded from the file system, we need to create the <code class="literal">app.html</code> file in the <code class="literal">lib</code> folder with some initial content:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&lt;div&gt;Hello World!&lt;/div&gt;</strong></span>
</pre></div><p>For the time being, that's everything <a id="id97" class="indexterm"/>we put in our template. Our directory should look similar to this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>angular-2-components</strong></span>
<span class="strong"><strong>├── node_modules/</strong></span>
<span class="strong"><strong>├── jspm_packages/</strong></span>
<span class="strong"><strong>├── config.js</strong></span>
<span class="strong"><strong>├── index.html</strong></span>
<span class="strong"><strong>├── lib</strong></span>
<span class="strong"><strong>│   ├── app.html</strong></span>
<span class="strong"><strong>│   └── app.js</strong></span>
<span class="strong"><strong>└── package.json</strong></span>
</pre></div><p>Now that we have created our main application component, we can add the component's host element to our <code class="literal">index.html</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head lang="en"&gt;
  &lt;title&gt;Angular 2 Components&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
<span class="strong"><strong>&lt;ngc-app&gt;&lt;/ngc-app&gt;</strong></span>
...</pre></div><div class="section" title="Bootstrapping"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec16"/>Bootstrapping</h2></div></div></div><p>The <code class="literal">index.html</code> file will <a id="id98" class="indexterm"/>load the <code class="literal">bootstrap.js</code> module using SystemJS in an inline <code class="literal">script</code> tag. It's a best practice to have a main entry point for your scripts when working with SystemJS. Our <code class="literal">bootstrap.js</code> file is responsible for loading all the necessary JavaScript dependencies for our application as well as bootstrapping the Angular framework.</p><p>We can go ahead and bootstrap our Angular application by providing our main application component, <code class="literal">App</code>. We need to import the <code class="literal">bootstrap</code> function from the <code class="literal">angular2</code> module. We can then import our <code class="literal">App</code> component and call the <code class="literal">bootstrap</code> function, passing it as parameter:</p><div class="informalexample"><pre class="programlisting">// Import Angular bootstrap function
<span class="strong"><strong>import {bootstrap} from '@angular/platform-browser-dynamic'; </strong></span>
// Import our main app component
<span class="strong"><strong>import {App} from './app';</strong></span>
// We are bootstrapping Angular using our main application
// component
<span class="strong"><strong>bootstrap(App);</strong></span>
</pre></div></div><div class="section" title="Running the application"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec17"/>Running the application</h2></div></div></div><p>The code we've <a id="id99" class="indexterm"/>produced so far should now be in a state where we can run it. Before we run our code using the live-server module, let's ensure we have all the files ready. At this stage, our directory should look something like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>angular-2-components</strong></span>
<span class="strong"><strong>├── jspm_packages/</strong></span>
<span class="strong"><strong>├── node_modules/</strong></span>
<span class="strong"><strong>├── config.js</strong></span>
<span class="strong"><strong>├── index.html</strong></span>
<span class="strong"><strong>├── lib</strong></span>
<span class="strong"><strong>│   ├── app.html</strong></span>
<span class="strong"><strong>│   ├── app.js</strong></span>
<span class="strong"><strong>│   └── bootstrap.js</strong></span>
<span class="strong"><strong>└── package.json</strong></span>
</pre></div><p>Now let's start live server to start a server and a browser with live reload. For this, we need to simply execute the following command on the command line within our project folder:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>live-server</strong></span>
</pre></div><p>If everything goes well, you <a id="id100" class="indexterm"/>will have an open web browser that shows <span class="strong"><strong>Hello World!</strong></span>.</p></div><div class="section" title="Recap"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec18"/>Recap</h2></div></div></div><p>Let's recap what we have <a id="id101" class="indexterm"/>done so far:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We initialized a new project using NPM and JSPM and installed the Angular dependencies using JSPM.</li><li class="listitem">We created our main application component in <code class="literal">app.js</code>.</li><li class="listitem">We also created a <code class="literal">bootstrap.js</code> script to include the Angular framework boot of our application.</li><li class="listitem">We added our component to the <code class="literal">index.html</code> file by including an element that matches our component selector property.</li><li class="listitem">Finally, we used live server to start a basic web server and launch a web browser.</li></ol><div style="height:10px; width: 1px"/></div></div></div>
<div class="section" title="Creating a task list" id="aid-KVCC1"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Creating a task list</h1></div></div></div><p>Now that we have <a id="id102" class="indexterm"/>our main application component set up, we can go on and flesh out our task application. The second component that we're going to create will be responsible for listing tasks. Following the concept of composition, we'll create a <code class="literal">task-list</code> component as a subcomponent of our main application component.</p><p>Let's create a folder within the <code class="literal">lib</code> folder called <code class="literal">task-list</code> and a new JavaScript file called <code class="literal">task-list.js</code>, where we will write our component code:</p><div class="informalexample"><pre class="programlisting">import {Component, ViewEncapsulation} from '@angular/core';
import template from './task-list.html!text';

@Component({
  selector: 'ngc-task-list',
  // The host property allows us to set some properties on the 
  // HTML element where our component is initialized
  host: {
    class: 'task-list'
  },
  template,
  encapsulation: ViewEncapsulation.None
})
export class TaskList {
  constructor() {
    this.tasks = [
      {title: 'Task 1', done: false},
      {title: 'Task 2', done: true}
    ];
  }
}</pre></div><p>We've created a very simple <code class="literal">task-list</code> component that has a list of tasks stored internally. This component will be attached to HTML elements that match the CSS element selector <code class="literal">ngc-task-list</code>.</p><p>Now let's create a view for this component to display the tasks. As you can see from the import within the component JavaScript file, we are looking for a file called <code class="literal">task-list.html</code>:</p><div class="informalexample"><pre class="programlisting">&lt;div *ngFor="let task of tasks" class="task"&gt;
  &lt;input type="checkbox" [checked]="task.done"&gt;
  &lt;div class="task__title"&gt;{{task.title}}&lt;/div&gt;
&lt;/div&gt;</pre></div><p>We use the <code class="literal">NgFor</code> <a id="id103" class="indexterm"/>directive to repeat the <code class="literal">&lt;div&gt;</code> element with the class task for as many tasks as we have in the task list of our component. The <code class="literal">NgFor</code> directive in Angular will create a template element from its underlying content and instantiate as many elements from the template as the expression evaluates to. We currently have two tasks in our <code class="literal">task-list</code> component, so this will create two instances of our template.</p><p>Your folder structure inside the <code class="literal">lib</code> folder should now look similar to this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>angular-2-components</strong></span>
<span class="strong"><strong>└── lib</strong></span>
<span class="strong"><strong>    ├── app.html</strong></span>
<span class="strong"><strong>    ├── app.js</strong></span>
<span class="strong"><strong>    ├── bootstrap.js</strong></span>
<span class="strong"><strong>    └── task-list</strong></span>
<span class="strong"><strong>        ├── task-list.html</strong></span>
<span class="strong"><strong>        └── task-list.js</strong></span>
</pre></div><p>All that's left to do in order to make our task list work is the inclusion of the <code class="literal">task-list</code> component within the main application component. We can go ahead and modify our <code class="literal">app.js</code> file and add the following line on top of it:</p><div class="informalexample"><pre class="programlisting">import {TaskList} from './task-list/task-list';</pre></div><p>As we want to add the <code class="literal">task-list</code> component to our main application view template, we also need to make sure that Angular knows about the component when compiling the view. For this, we need to add the <code class="literal">directives</code> property to our main application component within the <code class="literal">app.js</code> file and include our imported <code class="literal">TaskList</code> component class within the list of directives:</p><div class="informalexample"><pre class="programlisting">...
  // Tell Angular to ignore view encapsulation
  encapsulation: ViewEncapsulation.None,
<span class="strong"><strong>  directives: [TaskList]</strong></span>
})
...</pre></div><p>Finally, we need to include the host element of our <code class="literal">task-list</code> component in the template of the main application, which is located within the <code class="literal">app.html</code> file:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&lt;ngc-task-list&gt;&lt;/ngc-task-list&gt;</strong></span>
</pre></div><p>These were the last changes we needed to make in order to make our <code class="literal">task-list</code> component work. To view <a id="id104" class="indexterm"/>your changes, you can start the live server by executing the <code class="literal">live-server</code> command within your <code class="literal">angular-2-components</code> directory.</p><div class="section" title="Recap"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec19"/>Recap</h2></div></div></div><p>Let's look at what we have <a id="id105" class="indexterm"/>done in the previous building block. We achieved a simple listing of tasks within an encapsulated component by following these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We created the component JavaScript file that contains the logic of our component.</li><li class="listitem">We created the component's view within a separate HTML file.</li><li class="listitem">We included the component class within the configuration of our main application component.</li><li class="listitem">We included the component HTML element within our main application view template.</li></ol><div style="height:10px; width: 1px"/></div></div></div>
<div class="section" title="The right level of encapsulation"><div class="titlepage" id="aid-LTSU2"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>The right level of encapsulation</h1></div></div></div><p>Our task list is <a id="id106" class="indexterm"/>displayed correctly and the code we used to achieve this looks quite okay. However, if we want to follow a better approach for composition, we should rethink the design of our <code class="literal">task-list</code> component. If we draw a line at enlisting the task list responsibilities, we would come up with things such as listing tasks, adding new tasks to the list, and sorting and filtering the task list; however, operations are not performed on an individual task itself. Also, rendering the task itself falls outside of the responsibilities of the task list. The <code class="literal">task-list</code> component should only serve as a container for tasks.</p><p>If we look at our code again, we will see that we're violating the single responsibility principle and rendering the whole task body within our <code class="literal">task-list</code> component. Let's take a look at how we can fix this by increasing the granularity of the encapsulation.</p><p>The goal now is to do a code refactoring exercise, also known as extraction. We are pulling our task's relevant template out of the task list template and creating a new component that encapsulates the tasks.</p><p>For this, we need to <a id="id107" class="indexterm"/>create a new sub folder within the <code class="literal">task-list</code> folder called <code class="literal">task</code>. Within this folder, we will create a template file with the name <code class="literal">task.html</code>:</p><div class="informalexample"><pre class="programlisting">&lt;input type="checkbox" [checked]="<span class="strong"><strong>task</strong></span>.done"&gt;
&lt;div class="task__title"&gt;{{<span class="strong"><strong>task</strong></span>.title}}&lt;/div&gt;</pre></div><p>The content of our new <code class="literal">task.html</code> file is pretty much the same as what we already have within our <code class="literal">task-list.html</code> template. The only difference is that we will now refer to a new model called <code class="literal">task</code>.</p><p>Now, within the <code class="literal">task</code> folder, let's create the JavaScript file, <code class="literal">task.js</code>, which will contain the controller class of our component:</p><div class="informalexample"><pre class="programlisting">import {Component, <span class="strong"><strong>Input</strong></span>, ViewEncapsulation} from '@angular/core';
import template from './task.html!text';

@Component({
  selector: 'ngc-task',
  host: {
    class: 'task'
  },
  template,
  encapsulation: ViewEncapsulation.None
})
export class Task {
  // Our task model can be attached on the host within the view
  <span class="strong"><strong>@Input() task;</strong></span>
}</pre></div><p>In the previous chapter of this book, we spoke about encapsulation and the preconditions to establish a clean encapsulation for UI components. One of these preconditions is the possibility to design proper interfaces in and out of the component. Such input and output methods are necessary to make the component work within compositions. That's how a component will receive and publish information.</p><p>As you can see from our task component implementation, we are now building such an interface using the <code class="literal">@Input</code> annotation on a class instance field. In order to use this annotation, we will first need to import it from the angular core module.</p><p>Input properties in Angular allow us to bind the expressions in our templates to class instance fields on our components. This way, we can pass data from the outside of the component to the component inside, using the components template. This can be thought of as an example of one-way binding, from the view to the component.</p><p>If we're using property binding on a regular DOM property, Angular will create a binding of the expression directly to the element's DOM property. We're using such a type of binding to bind the task <a id="id108" class="indexterm"/>completed flag to the <code class="literal">checked</code> property of the checkbox's <code class="literal">input</code> element:</p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><thead><tr><th valign="bottom">
<p>Usage</p>
</th><th valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td valign="top">
<p><code class="literal">@Input() inputProp;</code></p>
</td><td valign="top">
<p>This allows us to bind the <code class="literal">inputProp</code> attribute to the component element within the parent component.</p>
<p>Angular assumes that the attribute of the element has the same name as that of the <code class="literal">input</code> property.</p>
</td></tr><tr><td valign="top">
<p><code class="literal">@Input('inp') inputProp;</code></p>
</td><td valign="top">
<p>You can also override the name of the attribute that should be mapped to this input. Here, the <code class="literal">inp</code> attribute of the component's HTML element is mapped to the component's input property, <code class="literal">inputProp</code>.</p>
</td></tr></tbody></table></div><p>The last missing piece to use our newly created task component is the modification of the existing template of the task list.</p><p>We include the task component within our task list template by using an <code class="literal">&lt;ngc-task&gt;</code> element, as specified in the selector within our task component. Also, we create a property binding on the task element. There, we pass the <code class="literal">task</code> object from the current <code class="literal">NgFor</code> iteration to the <code class="literal">task</code> input of the <code class="literal">task</code> component. We need to replace all the existing content in the <code class="literal">task.html</code> file with the following lines of code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&lt;ngc-task *ngFor="let task of tasks" </strong></span>
<span class="strong"><strong>          [task]="task"&gt;&lt;/ngc-task&gt;</strong></span>
</pre></div><p>In order to make our <code class="literal">task-list</code> component recognize the task component element, we need to add it to the <code class="literal">task-list</code> component's <code class="literal">directives</code> property within the <code class="literal">task-list.js</code> file:</p><div class="informalexample"><pre class="programlisting">...
<span class="strong"><strong>import {Task} from './task/task';</strong></span>

@Component({
  ...
<span class="strong"><strong>  directives: [Task]</strong></span>
})
...</pre></div><p>Congratulations! You've successfully refactored your task list by extracting the task into its own component and have established a clean encapsulation. Also, we can now say that our task list is a composition of tasks.</p><p>If you think about maintainability and reusability, this was actually a very important step in the process of building our application. You should constantly look out for such encapsulation opportunities, and if you feel something could be arranged into multiple subcomponents, you should probably go for it. Of course, you can also overdo this. There's simply no golden <a id="id109" class="indexterm"/>rule to determine what granularity of encapsulation is the right one.</p><div class="note" title="Note"><h3 class="title"><a id="tip07"/>Tip</h3><p>The right granularity of encapsulation for a component architecture always depends on the context. My personal tip here is to use known principles from OOP, such as single responsibility, to lay the groundwork for a good design of your component tree. Always make sure your components are only doing things that they are supposed to do as their names suggest. A task list has the responsibility of listing tasks and providing some filters or other controls for the list. The responsibility of operating on individual task data and rendering the necessary view clearly belongs to a task component and not the task list.</p></div><div class="section" title="Recap"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec20"/>Recap</h2></div></div></div><p>In this building block, we cleaned up our component tree and established clean encapsulation using subcomponents. Then, we set up the interfaces provided by Angular using input bindings. We <a id="id110" class="indexterm"/>performed these actions by following the ensuing steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We created a task subcomponent.</li><li class="listitem">We used the task subcomponent with the <code class="literal">task-list</code> component.</li><li class="listitem">We used input bindings and DOM element property bindings to establish one-way data binding in the task component.</li></ol><div style="height:10px; width: 1px"/></div></div></div>
<div class="section" title="Input generates output"><div class="titlepage" id="aid-MSDG2"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Input generates output</h1></div></div></div><p>Our task list looks <a id="id111" class="indexterm"/>nice already, but it would be quite useless if the user is unable to add new tasks to the list. Let's create a component for entering new tasks together. As this component belongs to the <code class="literal">task-list</code> component, we're going to create a new folder called <code class="literal">enter-task</code> within the <code class="literal">task-list</code> folder. The responsibilities of this component will be to handle all the UI logic necessary for entering a new task.</p><p>Using the same naming convention as with the rest of our components, let's create a file called <code class="literal">enter-task.html</code> to store the template of our component:</p><div class="informalexample"><pre class="programlisting">&lt;input type="text" class="enter-task__title-input"
       placeholder="Enter new task title..."
       #titleInput&gt;
&lt;button class="button" (click)="enterTask(titleInput)"&gt;
  Add Task
&lt;/button&gt;</pre></div><p>This template consists of an input field as well as a button to enter a new task. Here, we're making use of the so-called <a id="id112" class="indexterm"/>local view variables by specifying that our input field should have the reference name <code class="literal">#titleInput</code>. We can reference this variable within the current component view by the name <code class="literal">titleInput</code>.</p><p>In this case, we are <a id="id113" class="indexterm"/>actually using the variable to pass the input field DOM element to the <code class="literal">enterTask</code> function that we call on a click event on the <code class="literal">Add Task</code> button.</p><p>Let's take a look at the implementation of our <code class="literal">Component</code> class for entering a new task by using the following code in a newly-created <code class="literal">enter-task.js</code> file:</p><div class="informalexample"><pre class="programlisting">import {Component, Output, ViewEncapsulation, EventEmitter} from '@angular/core';
import template from './enter-task.html!text';

@Component({
  selector: 'ngc-enter-task',
  host: { class: 'enter-task' },
  template,
  encapsulation: ViewEncapsulation.None
})
export class EnterTask {
<span class="strong"><strong>  // Event emitter that gets fired once a task is entered.</strong></span>
<span class="strong"><strong>  @Output() taskEntered = new EventEmitter();</strong></span>
<span class="strong"><strong>  // This function will fire the taskEntered event emitter </strong></span>
<span class="strong"><strong>  // and reset the task title input field.</strong></span>
<span class="strong"><strong>  enterTask(titleInput) {</strong></span>
<span class="strong"><strong>    this.taskEntered.next(titleInput.value);</strong></span>
<span class="strong"><strong>    titleInput.value = ''; </strong></span>
<span class="strong"><strong>    titleInput.focus();</strong></span>
<span class="strong"><strong>  }</strong></span>
}</pre></div><p>For this component, we've chosen a design approach where we use a loose relation to our task list where the actual task will be created. Although this component is closely related to the task list, it's better to keep the components as loosely coupled as possible.</p><p>One of the simplest forms of inversion of control, a callback function or event listener is a great principle to establish loose coupling. In this component, we are using the <code class="literal">@Output</code> annotation to create an event emitter. The output properties need to be instance fields that hold an event emitter within the component. On the component's HTML element, we can then use event bindings to capture any events emitted. This gives us great flexibility that we can use to create a clean application design, where we glue components together through the binding within the view:</p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><thead><tr><th valign="bottom">
<p>Usage</p>
</th><th valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td valign="top">
<p><code class="literal">@Output() outputProp = new EventEmitter();</code></p>
</td><td valign="top">
<p>When <code class="literal">outputProp.next()</code> is called, a custom event with the name <code class="literal">outputProp</code> will be emitted on the component. Angular will look for event bindings on the component's HTML element (where the component is used) and execute them:</p>
<div class="informalexample"><pre class="programlisting">&lt;my-comp (output-prop)= "doSomething()"&gt;</pre></div>
<p>Within the expressions in event bindings, you will always have access to a synthetic variable called <code class="literal">$event</code>. This variable is a reference to the data emitted by <code class="literal">EventEmitter</code>.</p>
</td></tr><tr><td valign="top">
<p><code class="literal">@Output('out') outputProp = new EventEmitter();</code></p>
</td><td valign="top">
<p>Use this way of declaring your output properties if you'd want to name your events differently from what your property name is. In this example, a custom event with the name <code class="literal">out</code> will be fired when <code class="literal">outputProp.next()</code> is called:</p>
<div class="informalexample"><pre class="programlisting">&lt;my-comp (out)= "doSomething()"&gt;</pre></div>
</td></tr></tbody></table></div><p>Okay, let's use this newly created component to add new tasks within our <code class="literal">task-list</code> component. First, let's <a id="id114" class="indexterm"/>modify the existing template of the <code class="literal">task-list</code> component. Open the file, <code class="literal">task-list.html</code>, in the <code class="literal">task-list</code> component folder. We need to add the <code class="literal">EnterTask</code> component to the template and also handle the custom event that we're going to emit, once a new task is entered within the component:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&lt;ngc-enter-task (taskEntered)="addTask($event)"&gt;</strong></span>
<span class="strong"><strong>&lt;/ngc-enter-task&gt;</strong></span>
&lt;ngc-task *ngFor="let task of tasks" 
          [task]="task"&gt;&lt;/ngc-task&gt;</pre></div><p>Since the output property within the <code class="literal">enter-task</code> component is called <code class="literal">taskEntered</code>, we can bind it with the event binding attribute, <code class="literal">(taskEntered)=""</code>, on the host element.</p><p>Within the event binding expression, we then call a function on our <code class="literal">task-list</code> component called <code class="literal">addTask</code>. Also, we use the synthetic variable <code class="literal">$event</code>, which contains the task title emitted from the <code class="literal">enter-task</code> component. Now, whenever we push the button in our <code class="literal">enter-task</code> component and an event gets emitted from the component, we catch the event in our event binding and handle it within the <code class="literal">task-list</code> component.</p><p>We also need to make some minor changes to the <code class="literal">task-list</code> component's JavaScript file. Let's open <code class="literal">task-list.js</code> and modify it with the following changes:</p><div class="informalexample"><pre class="programlisting">...
<span class="strong"><strong>// The component for entering new tasks</strong></span>
<span class="strong"><strong>import {EnterTask} from './enter-task/enter-task';</strong></span>

@Component({
  ...
<span class="strong"><strong>  directives: [Task, EnterTask]</strong></span>
})
export class TaskList {
  ...
<span class="strong"><strong>  // Function to add a task from the view</strong></span>
<span class="strong"><strong>  addTask(title) {</strong></span>
<span class="strong"><strong>    this.tasks.push({</strong></span>
<span class="strong"><strong>      title, done: false</strong></span>
<span class="strong"><strong>    });</strong></span>
<span class="strong"><strong>  }</strong></span>
}</pre></div><p>The only thing we changed within the <code class="literal">task-list</code> component module is its ability to declare the <code class="literal">EnterTask</code> component in the directives property so that the compiler recognizes our <code class="literal">enter-task</code> component correctly.</p><p>We have also added a function, <code class="literal">addTask</code>, which will add a new task to our task list with a title that is passed to the <a id="id115" class="indexterm"/>function. Now the circle is closed and our event from the <code class="literal">enter-task</code> component is routed to this function within the view of the <code class="literal">task-list</code> component.</p><p>You can now start live server from your project directory in order to test the newly added functionality using the <code class="literal">live-server</code> command.</p><div class="section" title="Recap"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec21"/>Recap</h2></div></div></div><p>We have added a new <a id="id116" class="indexterm"/>subcomponent of the task list that is responsible for providing the UI logic to add new tasks. In other words, we have covered the following topics:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We created a subcomponent that is loosely coupled using output properties and event emitters.</li><li class="listitem">We learned about the <code class="literal">@Output</code> annotation and how to use it to create output properties.</li><li class="listitem">We used event <a id="id117" class="indexterm"/>bindings to link the behavior together, from the view of a component.</li></ol><div style="height:10px; width: 1px"/></div></div></div>
<div class="section" title="Custom UI elements"><div class="titlepage" id="aid-NQU22"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Custom UI elements</h1></div></div></div><p>The standard UI <a id="id118" class="indexterm"/>elements in the browser are great, but sometimes, modern web applications require more complex and intelligent input elements than the ones available within the browser.</p><p>We'll now create two specific custom UI elements that we'll use within our application going forward in order to provide a nice user experience:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Checkbox</strong></span>: There's already a native checkbox input in the browser, but sometimes, it's hard to <a id="id119" class="indexterm"/>fit it into the visual design of an application. Native checkboxes are limited in their styling possibilities, and therefore, it's hard to make them look great. Sometimes, it's those minor details that make an application look appealing.</li><li class="listitem"><span class="strong"><strong>Toggle buttons</strong></span>: This is a list of toggle buttons, where only one button can be toggled within the list. They could also be represented with a native radio button list. However, like with native checkboxes, radio buttons are sometimes not really the <a id="id120" class="indexterm"/>nicest visual solution to the problem. A list of toggle buttons that also represents a select-one-user input element is much more modern and provides the visual aspect that we are looking for. Besides, who does not like to push buttons?</li></ul></div><p>Let's create our custom checkbox UI element first. As we'll probably come up with a few custom UI elements, first let's create a new subfolder called <code class="literal">ui</code> within the <code class="literal">lib</code> folder.</p><p>Within the <code class="literal">ui</code> folder, we now create a folder with the name <code class="literal">checkbox</code> for our checkbox component. Starting with the template of our new component, we now create a file with the name <code class="literal">checkbox.html</code> within the <code class="literal">checkbox</code> folder:</p><div class="informalexample"><pre class="programlisting">&lt;input type="checkbox"
       <span class="strong"><strong>[checked]="checked"</strong></span>
<span class="strong"><strong>       (change)="onChecke</strong></span>
<span class="strong"><strong>dChange($event.target.checked)"</strong></span>&gt;
<span class="strong"><strong>  {{label}}</strong></span>
</pre></div><p>On the <code class="literal">checkbox</code> input, we have two bindings. First, we have a property binding for the <code class="literal">checked</code> property on the DOM element. We are binding the DOM property to the <code class="literal">checked</code> member field on our component, which we are going to create in a moment.</p><p>Also, we have an event binding on the input element where we listen for the checkbox change DOM event and call the method <code class="literal">onCheckedChange</code> on our component class. We use the synthetic variable <code class="literal">$event</code> to pass the <code class="literal">checked</code> property on the checkbox DOM element where the change event is originated.</p><p>Moving on to our <code class="literal">component</code> class implementation, we need to create a file with the name <code class="literal">checkbox.js</code> within the <code class="literal">checkbox</code> folder:</p><div class="informalexample"><pre class="programlisting">import {Component, Input, Output, ViewEncapsulation, EventEmitter} from '@angular/core';
import template from './checkbox.html!text';

@Component({
  selector: 'ngc-checkbox',
  host: { class: 'checkbox' },
  template,
  encapsulation: ViewEncapsulation.None
})
export class Checkbox {
  // An optional label can be set for the checkbox
  @Input() label;
<span class="strong"><strong>  // If the checkbox is checked or unchecked</strong></span>
<span class="strong"><strong>  @Input() checked;</strong></span>
<span class="strong"><strong>  // Event emitter when checked is changed using the convention </strong></span>
<span class="strong"><strong>  // for two way binding with [(checked)] syntax.</strong></span>
<span class="strong"><strong>  @Output() checkedChange = new EventEmitter();</strong></span>

<span class="strong"><strong>  // This function will trigger the checked event emitter</strong></span>
<span class="strong"><strong>  onCheckedChange(checked) {</strong></span>
<span class="strong"><strong>    this.checkedChange.next(checked);</strong></span>
<span class="strong"><strong>  }</strong></span>
}</pre></div><p>There's nothing special <a id="id121" class="indexterm"/>about this <code class="literal">component</code> class if we first look at it. It uses an input property to set the checked state from the outside, and it also has an output property with an event emitter that allows us to notify the outer component about the changes of the checked state using a custom event. However, there's a naming convention that makes this component a bit special. The convention of using an input property name also as an output property name but appending the word <span class="emphasis"><em>change</em></span> is actually enabling a developer who uses the component to make use of the two-way data binding template shorthand.</p><p>Angular does not come with two-way data binding out of the box. However, creating two-way binding is quite easy. Actually, two-way data binding is no different than combining a property binding with an event binding.</p><p>The following example creates a very simple two-way data binding process on an input field:</p><div class="informalexample"><pre class="programlisting">  &lt;input type="text" (input)="value = $event.target.value" 
                     [value]="value"&gt;</pre></div><p>The simplicity of Angular and the general approach of extending the native functionality of the browser makes implementing this mechanism a breeze.</p><p>Implementing two-way data binding between a component and its subcomponent isn't really too difficult. The only thing we need to take care about is that there are input and output properties of the <a id="id122" class="indexterm"/>subcomponent involved.</p><p>Please have a look at the following screenshot:</p><div class="mediaobject"><img src="../Images/image00305.jpeg" alt="Custom UI elements"/><div class="caption"><p>A two-way data binding between member variables of a component and a subcomponent</p></div></div><p style="clear:both; height: 1em;"> </p><p>Since two-way data binding was a highly requested feature in Angular, there's a handy shorthand to write it. Let's <a id="id123" class="indexterm"/>look at some examples on how to implement data bindings between a template of a component and its subcomponent:</p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><thead><tr><th valign="bottom">
<p>Subcomponent properties</p>
</th><th valign="bottom">
<p>Bindings in component template</p>
</th></tr></thead><tbody><tr><td valign="top">
<p><code class="literal">@Input() text;</code></p>
<p><code class="literal">@Output() textOut = new EventEmitter();</code></p>
</td><td valign="top">
<p>
</p><div class="informalexample"><pre class="programlisting">&lt;sc [text]="myText"
    (textOut)="myText = $event"&gt;</pre></div><p>
</p>
<p>We bind the component's <code class="literal">myText</code> property to the subcomponent's text input. Also, we capture the <code class="literal">textOut</code> event emitted from the subcomponent and update our <code class="literal">myText</code> property.</p>
</td></tr><tr><td valign="top">
<p><code class="literal">@Input() text;</code></p>
<p><code class="literal">@Output() textChange = new EventEmitter();</code></p>
</td><td valign="top">
<p>
</p><div class="informalexample"><pre class="programlisting">&lt;sc [(text)]="myText"&gt;</pre></div>
<p>We can simplify this two-way data binding by using the naming convention to append the word "change" to our event emitter identifier. This way, we can use the two-way data binding shorthand within our template using the <code class="literal">[(property)]</code> notation.</p>
</td></tr></tbody></table></div><p>If we look at our <code class="literal">checkbox</code> component implementation again, we will see that we are using the two-way data binding naming convention for the checked property of our component. This way, we enable the use of the template shorthand for two-way data binding wherever we use our custom checkbox UI component.</p><p>Let's integrate our <a id="id124" class="indexterm"/>checkbox in the task component to replace the native checkbox input we're currently using there. For this, we need to modify the <code class="literal">task.html</code> file within the <code class="literal">task-list/task</code> folder, by replacing the native input checkbox that we have in the <code class="literal">task.html</code> file with the following line of code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&lt;ngc-checkbox [(checked)]="task.done"&gt;&lt;/ngc-checkbox&gt;</strong></span>
</pre></div><p>As always, we also need to tell the task component that we'd like to use the component within the template. Let's change the code within the <code class="literal">task.js</code> file accordingly:</p><div class="informalexample"><pre class="programlisting">...
import {..., <span class="strong"><strong>HostBinding</strong></span>} from '@angular/core';
// Each task has a checkbox component for marking tasks as done.
<span class="strong"><strong>import {Checkbox} from '../../ui/checkbox/checkbox';</strong></span>

@Component({
  ...
  // We need to specify that this component relies on the Checkbox 
  // component within the view.
<span class="strong"><strong>  directives: [Checkbox]</strong></span>
})
export class Task {
  // Our task model can be attached on the host within the view
  @Input() task;

  <span class="strong"><strong>@HostBinding('class.task--done')</strong></span>
<span class="strong"><strong>  get done() {</strong></span>
<span class="strong"><strong>    return this.task &amp;&amp; this.task.done;</strong></span>
<span class="strong"><strong>  }</strong></span>
}</pre></div><p>We've already learned about the host property on components. It allows us to set property and event bindings on our component host element. The host element is the DOM element where our component is initialized within the parent component.</p><p>There's another way through which we can set properties on our component host element, which becomes handy when we want to set a property based on some data within our component.</p><p>Using the <code class="literal">@HostBinding</code> annotation, we can create property bindings on the component host element based on the members within our component. Let's use this annotation in order to create a binding that <a id="id125" class="indexterm"/>will conditionally set the <code class="literal">task--done</code> class on the component's HTML element. This is used to make some visual distinctions of finished tasks within our styles.</p><p>This was just the last step to integrate our custom checkbox UI component within the task component. You can now start <code class="literal">live-server</code> in order to view your changes and play around with these large new checkboxes in the task list. Isn't that much more fun to do than activating regular checkboxes? Don't underestimate the effect of a user interface that is pleasing to use. This can have a very positive impact on the usage of your product.</p><div class="mediaobject"><img src="../Images/image00306.jpeg" alt="Custom UI elements"/><div class="caption"><p>Our task list after adding our custom checkbox component</p></div></div><p style="clear:both; height: 1em;"> </p><p>Now that we've created our <code class="literal">checkbox</code> component, let's go ahead and create another UI component for toggle buttons that we'll use in the next topic. We need to create a folder named <code class="literal">toggle</code> within the <code class="literal">ui</code> folder and create a template called <code class="literal">toggle.html</code> within the <code class="literal">toggle</code> folder:</p><div class="informalexample"><pre class="programlisting">&lt;button class="button button--toggle"
        *ngFor="let button of buttonList"
        [class.button--active]="button === selectedButton"
        (click)="onButtonActivate(button)"&gt;{{button}}&lt;/button&gt;</pre></div><p>Nothing special here, really! We repeat a button by iterating over an instance field called <code class="literal">buttonList</code> using the <code class="literal">NgFor</code> <a id="id126" class="indexterm"/>directive. This button list will contain the labels of our toggle buttons. Conditionally, we set a class called <code class="literal">button--active</code> using a property binding and checking it against our current button within the iteration against an instance field called <code class="literal">selectedButton</code>. When the button is clicked, we call a method, <code class="literal">onButtonActivate</code>, on our component class and pass the current button label from the iteration.</p><p>Let's create <code class="literal">toggle.js</code> inside the <code class="literal">toggle</code> folder and implement the <code class="literal">component</code> class:</p><div class="informalexample"><pre class="programlisting">import {Component, Input, Output, ViewEncapsulation, EventEmitter} from '@angular/core';
import template from './toggle.html!text';

@Component({
  selector: 'ngc-toggle',
  host: {
    class: 'toggle'
  },
  template,
  encapsulation: ViewEncapsulation.None
})
export class Toggle {
  // A list of objects that will be used as button values.
  @Input() buttonList;
  // Input and state of which button is selected needs to refer to 
  // an object within buttonList
  @Input() selectedButton;
  // Event emitter when selectedButton is changed using the 
  // convention for two way binding with [(selected-button)] 
  // syntax.
  @Output() selectedButtonChange = new EventEmitter();

  // Callback within the component lifecycle that will be called 
  // after the constructor and inputs have been set.
  ngOnInit() {
    if (this.selectedButton === undefined) {
      this.selectedButton = this.buttonList[0];
    }
  }

  // Method to set selected button and trigger event emitter.
  onButtonActivate(button) {
    this.selectedButton = button;
    this.selectedButtonChange.next(button);
  }
}</pre></div><p>Within our <code class="literal">toggle</code> component, we rely on the <code class="literal">buttonList</code> member to be an array of objects, as we are using this array within our template on an <code class="literal">NgFor</code> directive. The <code class="literal">buttonList</code> member is annotated to be an input property; this way, we can pass the array into the component.</p><p>For the <code class="literal">selectedButton</code> member, which holds the object of the <code class="literal">buttonList</code> array that is currently selected, we use a two-way data binding approach. This way, we can not only set the toggled button from the <a id="id127" class="indexterm"/>outside of the component, but also get notified via the <code class="literal">toggle</code> component, when a button is toggled in the UI.</p><p>Within the <code class="literal">onButtonActivate</code> function, we are setting the <code class="literal">selectedButton</code> member as well as triggering the event emitter.</p><p>The <code class="literal">ngOnInit</code> method is actually called by Angular within the life cycle of directives and components. In the case where the <code class="literal">selectedButton</code> input property was not specified, we'll add a check and select the first button from the available button list. Since <code class="literal">selectedButton</code> as well as <code class="literal">buttonList</code> are instance fields that are also input properties at the same time, we need to wait for them to be initialized in order to execute this logic. It's important not to perform this initialization within the component constructor. The life cycle hook, <code class="literal">OnInit</code>, will be called after the directive input and output properties have been checked for the first time. It is invoked only once when the directive is constructed.</p><div class="note" title="Note"><h3 class="title"><a id="tip08"/>Tip</h3><p>Angular will call any life cycle hooks that have been implemented on your component automatically.</p></div><p>The next diagram illustrates the life cycle of an Angular component. Upon component construction, all the life cycle hooks will be called as per the order shown in the diagram, except the <code class="literal">OnDestroy</code> hook, which will be called upon component destruction.</p><p>Change detection will also start a subset of life cycle hooks, where there will be at least two cycles in the following order:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">doCheck</code></li><li class="listitem"><code class="literal">afterContentChecked</code></li><li class="listitem"><code class="literal">afterViewChecked</code></li><li class="listitem"><code class="literal">onChanges</code> (if any changes are detected)</li></ul></div><p>A detailed description <a id="id128" class="indexterm"/>of the life cycle hooks and their purpose is available <a id="id129" class="indexterm"/>on the Angular documentation website at <a class="ulink" href="https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html">https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html</a>.</p><div class="mediaobject"><img src="../Images/image00307.jpeg" alt="Custom UI elements"/><div class="caption"><p>An illustration of the life cycle of an Angular component</p></div></div><p style="clear:both; height: 1em;"> </p><div class="section" title="Recap"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec22"/>Recap</h2></div></div></div><p>In this block, you learned how to build custom UI components that are generic and loosely coupled so that <a id="id130" class="indexterm"/>they can be used in other components as subcomponents. We also completed the following tasks:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We created a subcomponent that is loosely coupled using output properties and event emitters.</li><li class="listitem">We learned what the <code class="literal">@Output</code> annotation is and how to use it to create output properties.</li><li class="listitem">We used the <code class="literal">@HostBinding</code> annotation to create property bindings declaratively from within our component class.</li><li class="listitem">We used event bindings to link the behavior together from the view of a component.</li><li class="listitem">We built two-way data binding using a binding shorthand.</li><li class="listitem">We learned about the working of the Angular component life cycle and how we can use the <code class="literal">OnInit</code> life cycle hook to initialize the component after the input and output have been processed for the first time.</li></ol><div style="height:10px; width: 1px"/></div></div></div>
<div class="section" title="Filtering tasks"><div class="titlepage" id="aid-OPEK2"><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Filtering tasks</h1></div></div></div><p>This is the last <a id="id131" class="indexterm"/>building block of this chapter. We have already learned a lot about building basic components and how to compose them together in order to form larger components. In the previous building block, we created generic UI components that could be used in other components. In this topic, we will use the toggle button component not only to create a filter for our task list, but also to improve the way we receive and store tasks by using data services.</p><p>Let's continue with another refactoring exercise. So far, we have stored our task list data directly within the <code class="literal">task-list</code> component, but let's change that here and use a service that will provide tasks for us.</p><p>Our service will still not use a database, but we'll get the task data out of our component. In order to use the service, we're making use of Angular's dependency injection for the first time.</p><p>Let's create a new file called <code class="literal">task-list-service.js</code> within the <code class="literal">lib/task-list</code> folder of our application:</p><div class="informalexample"><pre class="programlisting">// Classes which we'd like to provide for dependency injection 
// need to be annotated using this decorator
<span class="strong"><strong>import {Injectable} from '@angular/core';</strong></span>

<span class="strong"><strong>@Injectable()</strong></span>
export class TaskListService {
  constructor() {
    this.tasks = [
      {title: 'Task 1', done: false},
      {title: 'Task 2', done: false},
      {title: 'Task 3', done: true},
      {title: 'Task 4', done: false}
    ];
  }
}</pre></div><p>We've moved all our task data into the newly created service. In order to make our service class injectable, we need to decorate it with the <code class="literal">@Injectable</code> annotation.</p><p>Let's apply some <a id="id132" class="indexterm"/>changes to our <code class="literal">task-list</code> component and modify the <code class="literal">task-list.js</code> file within the <code class="literal">task-list</code> folder. The modified code in the file is highlighted in the following code excerpt:</p><div class="informalexample"><pre class="programlisting">import {..., <span class="strong"><strong>Inject</strong></span>} from '@angular/core';
// The dummy task service where we get our tasks from
<span class="strong"><strong>import {TaskListService} from './task-list-service';</strong></span>
...

// We also need a Toggle UI component to provide a filter
<span class="strong"><strong>import {Toggle} from '../ui/toggle/toggle';</strong></span>

@Component({
  ...
  // Set the TaskListService as host provider
<span class="strong"><strong>  providers: [TaskListService],</strong></span>
  // Specify all directives / components that are used in the view
  directives: [Task, EnterTask, Toggle]
})
export class TaskList {
  // Inject the TaskListService and set our filter data
<span class="strong"><strong>  constructor(@Inject(TaskListService) taskListService) {</strong></span>
<span class="strong"><strong>    this.taskListService = taskListService;</strong></span>
<span class="strong"><strong>    this.taskFilterList = ['all', 'open', 'done'];</strong></span>
<span class="strong"><strong>    this.selectedTaskFilter = 'all';</strong></span>
<span class="strong"><strong>  }</strong></span>
  // Method that returns a filtered list of tasks based on the 
  // selected task filter string.
<span class="strong"><strong>  getFilteredTasks() {</strong></span>
<span class="strong"><strong>    return this.taskListService.tasks ? this.taskListService.tasks.filter((task) =&gt; {</strong></span>
<span class="strong"><strong>      if (this.selectedTaskFilter === 'all') {</strong></span>
<span class="strong"><strong>        return true;</strong></span>
<span class="strong"><strong>      } else if (this.selectedTaskFilter === 'open') {</strong></span>
<span class="strong"><strong>        return !task.done;</strong></span>
<span class="strong"><strong>      } else {</strong></span>
<span class="strong"><strong>        return task.done;</strong></span>
<span class="strong"><strong>      }</strong></span>
<span class="strong"><strong>    }) : [];</strong></span>
<span class="strong"><strong>  }</strong></span>
  // Method to add a task from the view
  addTask(title) {
<span class="strong"><strong>    this.taskListService.tasks.push({</strong></span>
<span class="strong"><strong>      title,</strong></span>
<span class="strong"><strong>      done: false</strong></span>
<span class="strong"><strong>    });</strong></span>
  }
}</pre></div><p>In the import section of our module, we're going to import the task list service. We will use dependency injection to receive an instance of the <code class="literal">TaskListService</code> class within our component constructor. For this, we'll use a new annotation, which lets us specify the type we'd like to inject. The <code class="literal">Inject</code> decorator needs to be imported from the Angular core module in order to use the <code class="literal">@Inject</code> annotation. If you take a look at our constructor, you'll find that we're using the <code class="literal">@Inject</code> annotation there to specify what instance type we'd like to inject.</p><p>In addition to the <code class="literal">@Inject</code> annotation on the constructor, we need one last thing to make the injection work. We <a id="id133" class="indexterm"/>need to register <code class="literal">TaskListService</code> as a provider within the <code class="literal">providers</code> property of our <code class="literal">@Component</code> annotation.</p><p>Now we get the <code class="literal">TaskListService</code> injected when the directive is constructed, and we can store a reference to it inside an instance field.</p><p>Within the constructor of the component, we also want to store a list of states the task status filter can have. This list will also serve as input for our toggle button list. If you recall the input properties on our toggle button, we have a <code class="literal">buttonList</code> input that accepts a list of button labels. To store the currently selected filter type, we use an instance field called <code class="literal">selectedTaskFilter</code>.</p><p>The last piece that we need to add to our <code class="literal">task-list</code> component is the method, <code class="literal">getFilteredTasks</code>. We no longer need to store the task list directly within an instance field, and tasks should only be received within the component using this method. The logic inside the method checks the <code class="literal">selectedTaskFilter</code> property and returns a filtered list that meets this condition.</p><p>Since we want to use the toggle button component that we've created within the previous topic to create a filter button list, we will need to import the toggle component within the import section and also add the <code class="literal">Toggle</code> class to our <code class="literal">directives</code> property. Now we can use the toggle component within the template of our <code class="literal">task-list</code> component.</p><p>Okay, that's all we are going to change in our component implementation. We want to change our view template though to use the filtered task list coming from the data service and show a toggle button list to activate the different filter types. Let's open the template file, <code class="literal">task-list.html</code>, inside the <code class="literal">task-list</code> folder and modify it with the following content:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&lt;ngc-toggle [buttonList]="taskFilterList"</strong></span>
<span class="strong"><strong>            [(selectedButton)]="selectedTaskFilter"&gt;</strong></span>
<span class="strong"><strong>&lt;/ngc-toggle&gt;</strong></span>
&lt;ngc-enter-task (taskEntered)="addTask($event)"&gt;
&lt;/ngc-enter-task&gt;
<span class="strong"><strong>&lt;ngc-task *ngFor="let task of getFilteredTasks()" </strong></span>
<span class="strong"><strong>          [task]="task"&gt;&lt;/ngc-task&gt;</strong></span>
</pre></div><p>Since we've added the toggle component within the <code class="literal">directives</code> property of our <code class="literal">task-list</code> component, we <a id="id134" class="indexterm"/>can use it now within our view template. We bind the input property <code class="literal">buttonList</code> to <code class="literal">taskFilterList</code> that we store within our <code class="literal">task-list</code> component. Also, we're using two-way data binding to bind the <code class="literal">selectedButton</code> input property of the toggle button list to the <code class="literal">selectedTaskFilter</code> instance field of the task list. This way, we can not only update the selected task filer from our <code class="literal">task-list</code> component programmatically, but also allow a user to change the value using the toggle button list.</p><p>Now we only need to make a small change to the <code class="literal">NgFor</code> directive that repeats our task elements within the task list. Since we need to access the tasks of the <code class="literal">task-list</code> component with the <code class="literal">getFilteredTasks</code> method now, we also need to use that method within our repeater expression.</p><p>That's it already, congratulations! You've successfully added a filtering mechanism to your task list by reusing the toggle component that we created in the previous topic. You can now start your live server (using the <code class="literal">live-server</code> command) and should see a fully functional task list where you can enter new tasks and also filter the task list:</p><div class="mediaobject"><img src="../Images/image00308.jpeg" alt="Filtering tasks"/><div class="caption"><p>Screenshot of the task list with the newly added toggle button component for filtering the task state</p></div></div><p style="clear:both; height: 1em;"> </p></div>
<div class="section" title="Summary" id="aid-PNV61"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Summary</h1></div></div></div><p>In this chapter, you learned a lot of new concepts on building UI-component-based applications with Angular. Also, we built the core component of our task management application, which is the task list itself. You learned about the concept of input and output properties and how to use them to build two-way data binding.</p><p>We also covered the basics of the Angular component life cycle and how to use life cycle hooks to execute post initialization steps.</p><p>As the last step, we integrated a toggle button list component within our task list to filter the task states. We refactored our <code class="literal">task-list</code> component to use a service in order to obtain task data. For this, we used Angular's dependency injection.</p></div></body></html>