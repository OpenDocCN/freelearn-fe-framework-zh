- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building a Multiplatform Expense Tracker Using Quasar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ll iterate the topics and techniques we covered in [*Chapter
    6*](B19563_06.xhtml#_idTextAnchor162). We’ll build a similar app using Vue and
    rely on Supabase to store our data. In this chapter, however, we’ll focus on building
    an app that can be deployed on multiple platforms other than the web.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use Quasar ([https://quasar.dev/](https://quasar.dev/)) as our framework
    of choice since it allows us to choose multiple different types of platforms.
    For the sake of simplicity, we’ll focus on creating a desktop application based
    on Electron ([https://www.electronjs.org/](https://www.electronjs.org/)). Both
    Quasar and Electron are well-maintained open source projects with excellent documentation
    and active communities.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Solidifying what we learned previously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Familiarizing yourself with different frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the value of platform-agnostic development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a native app using web technologies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning the key differences between web and native
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ll be reusing most of the requirements from [*Chapter 6*](B19563_06.xhtml#_idTextAnchor162)
    since we’ll be building an application with similar capabilities. This will help
    you identify how the framework impacts the architecture of an app.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll be depending heavily on Quasar ([https://quasar.dev/](https://quasar.dev/))
    as our foundational framework. Since the framework also offers UI patterns ([https://quasar.dev/components](https://quasar.dev/components)),
    we don’t need Vuetify in this project. We will use Pinia ([https://pinia.vuejs.org/](https://pinia.vuejs.org/))
    to handle our application state. To store the data, we’ll create a new project
    in Supabase ([https://supabase.com/](https://supabase.com/)), an open source database
    provider with built-in authentication. For the database, I’ve prepared a script
    to create the databases and another one to add example data. We’ll cover those
    steps in the *Setting up the* *database* section.
  prefs: []
  type: TYPE_NORMAL
- en: The final product is located in this book’s GitHub repository at [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/tree/main/07.expenses](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/tree/main/07.expenses).
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ll start by fulfilling our database needs. We already have a free account
    (see [*Chapter 6*](B19563_06.xhtml#_idTextAnchor162)). We’ll create a new project
    called `expense-tracker`, set a strong database password, and assign a geographically
    close region.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll be redirected to a view that provides you with **Project URL** and **API
    Key** details, as shown in *Figure 7**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – API settings for our expense-tracker project](img/B19563_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – API settings for our expense-tracker project
  prefs: []
  type: TYPE_NORMAL
- en: Since our application isn’t ready, we need to note the URL and API key down
    in a safe place or simply revisit this page once we get to the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this project, I’ve prepared a script to create the required tables and
    settings for our database called `example-structure.sql`. Open the SQL Editor
    in Supabase, then paste and run the contents of the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Success message after running the example-structure.sql script](img/B19563_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – Success message after running the example-structure.sql script
  prefs: []
  type: TYPE_NORMAL
- en: 'Our expense tracker will be able to organize expenses into different categories,
    so I’ve also created a script to insert a set of example categories in the `example-categories.sql`
    file. You can paste the contents and run this file in the SQL Editor too:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Success message after running the example-categories.sql script](img/B19563_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – Success message after running the example-categories.sql script
  prefs: []
  type: TYPE_NORMAL
- en: Now that our database has been set up, we can start creating a new project.
  prefs: []
  type: TYPE_NORMAL
- en: Using Quasar to build a project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’re going to follow the default setup and installation guide at [https://quasar.dev/start/quick-start](https://quasar.dev/start/quick-start).
    In the CLI, we’ll run `npm init quasar` and select the configuration, as shown
    in *Figure 7**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Creating a new project using the Quasar CLI](img/B19563_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – Creating a new project using the Quasar CLI
  prefs: []
  type: TYPE_NORMAL
- en: 'This will install the project and its dependencies. Once the initialization
    is completed, we can navigate to the project folder and install the Supabase JavaScript
    client via the CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To conclude the initialization, we’ll create a `.env` file with the Supabase
    API keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can verify our installation by running the following command in the command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The example project will be installed, as shown in *Figure 7**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – The default project using Quasar](img/B19563_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – The default project using Quasar
  prefs: []
  type: TYPE_NORMAL
- en: 'Since our goal is to work on a desktop app, we can easily run a development
    command for that environment as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The first time this command is run, it will need to install some dependencies
    to run the environment. This will result in an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – Running Quasar in Electron development mode](img/B19563_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 – Running Quasar in Electron development mode
  prefs: []
  type: TYPE_NORMAL
- en: See how easy it is to target a different environment? Of course, Electron is
    very close to our browser environment, so it will behave very similarly. We are
    going to develop and debug our application in the browser. In virtually all cases,
    we can rely on this framework to deliver and compile our code to specific platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Targeting Android or iOS is a bit more complicated. It will make use of Capacitor
    to build a native-like shell that acts as a proxy between the operating system
    and the application. If you’re interested in mobile deployments, I highly recommend
    referring to the Quasar guide: [https://quasar.dev/quasar-cli-vite/developing-capacitor-apps/introduction](https://quasar.dev/quasar-cli-vite/developing-capacitor-apps/introduction).'
  prefs: []
  type: TYPE_NORMAL
- en: With our app running on the web and Electron, we have our starting point to
    build the expense tracker!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We’re using Quasar as a framework due to its bundling and building capabilities,
    but Quasar also offers a packed library of ready-to-use Vue components ([https://quasar.dev/components](https://quasar.dev/components)).
    In our example code, you will be able to recognize them by the *q-* prefixes in
    the component name. We won’t dive into how the component works, so I’d like to
    refer you to the official (and great) docs, which you can find at [https://quasar.dev/docs](https://quasar.dev/docs)
    and [https://quasar.dev/components](https://quasar.dev/components).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s have a look at how we can connect our Supabase instance with a frontend
    application, shall we?
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating with Supabase and Quasar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having an application rather than a website means that external hyperlinks,
    such as the OTP method of signing in via Supabase, will not work out of the box.
    Handling these issues is a bit too advanced for this chapter, so we’ll opt for
    signing in via email and password. To have Supabase and our Quasar application
    integrate nicely, I’m loosely basing our implementation on the following online
    resource: [https://dev.to/tvogel/getting-started-with-supabase-and-quasar-v2-kdo](https://dev.to/tvogel/getting-started-with-supabase-and-quasar-v2-kdo).'
  prefs: []
  type: TYPE_NORMAL
- en: The `src/boot` folder is meant for scripts that need to be executed before we
    initialize the Vue.js application ([https://quasar.dev/quasar-cli-vite/boot-files/](https://quasar.dev/quasar-cli-vite/boot-files/)).
    In our case, we need to utilize the boot files because we want to execute logic
    before we change a route, to see whether a user has access. This means we need
    to handle our authentication and Supabase client in scripts that are executed
    before the main scripts of our app.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll create the `src/boot/supabase.ts` file with the contents of the
    following file: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.1-supabase.ts](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.1-supabase.ts).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll use the `router-auth.ts` file as well and place it in the same folder:
    [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.2-router-auth.ts](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.2-router-auth.ts).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add these scripts to our `quasar.config.js` file by simply referencing
    the file on the `boot` property, which will then look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding configuration tells our app to run the given scripts before we
    initialize (or boot) the application.
  prefs: []
  type: TYPE_NORMAL
- en: With our basic boot scripts in place, we can look at our routes.
  prefs: []
  type: TYPE_NORMAL
- en: Routes and app structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we’ll add some routes so that we can build out our app and apply the `router-auth`
    scripts to the correct routes. Let’s remove all of the files from the `src/pages`
    folder, except the `ErrorNotFound.vue` page. We’ll add the following pages with
    the same structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AccountPage.vue`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Expenses Page.vue`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CategoriesPage.vue`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Replace the contents of `<h1 class="text-h1">Home</h1>` with a relevant title
    for every page using the following template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We’ll build the functionalities of each in the *Managing categories* and *Showing
    expenses and an overview* sections. But first, we need to integrate the authentication
    into our routes.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s look at the `src/router/index.ts` file: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.3-router-index.ts](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.3-router-index.ts).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll make two changes: we’ll import the `init` function of our Supabase boot
    script (*line 11*) and we’ll execute the function in the route function (*line
    23*). We can now define the routes that lead to the pages we’ve already created.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the `routes.ts` file: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.4-routes.ts](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.4-routes.ts).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The file contains familiar code but with a slight difference – for every route
    that requires the user to be logged in, we’ve added a `meta` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, the route for the `/auth` route (*lines 29–31*) is different: it doesn’t
    rely on the layout and directly imports the component. This is because the route
    will be the entry point of the app for non-authenticated users.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, if we look in our `src/boot/router-auth.ts` file, we will see that before
    each route change, we check if that meta field exists and then validate that the
    user `session` exists. If not, we redirect the user to the `fullPath` property,
    which translates to the home page.
  prefs: []
  type: TYPE_NORMAL
- en: It’s time to put these features into practice by building signup and login features
    for the app.
  prefs: []
  type: TYPE_NORMAL
- en: Signing up and logging in
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s work on offering users a way of both registering and signing in to our
    app. In our components folder, we’ll create a form for logging in called `FormLogin.vue`:
    [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.5-FormLogin.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.5-FormLogin.vue).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll also create a (very similar) file for signing up called `FormSignUp.vue`:
    [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.6-FormSignUp.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.6-FormSignUp.vue).'
  prefs: []
  type: TYPE_NORMAL
- en: The key difference between the two forms is the method we’re calling on submit,
    which is either the `supabase.auth.signInWithPassword` or `supabase.auth.signUp`
    method. We’re not interested in abstracting anything here. It’s not always the
    best approach to try and over-optimize everything that might be repetitive. In
    this case, we prefer readability and simplicity over similar code between the
    two files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s incorporate the two forms on a newly created `AuthPage.vue` page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we used the Quasar `tab` component to offer the two forms
    on the page. We should now be able to sign up for a new account. However, there’s
    a small catch.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default settings of Supabase require us to confirm email addresses on signup.
    For simplicity’s sake, we need to disable this feature. Log into your Supabase
    dashboard, navigate to **Authentication** | **Providers**, and then expand the
    **Email** panel. There, we need to disable the **Confirm Email** option, as shown
    in *Figure 7**.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – Disabling the Confirm email option in Supabase](img/B19563_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.7 – Disabling the Confirm email option in Supabase
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve saved this setting, we can register as a new user. You can keep the
    Supabase dashboard open and navigate to **Profiles** to verify your newly created
    account!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8 – Initial logged-in state in the web view](img/B19563_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.8 – Initial logged-in state in the web view
  prefs: []
  type: TYPE_NORMAL
- en: In the web app, we’ll be redirected to the (mostly empty) **Account** page,
    as shown in *Figure 7**.8*. Now we’re getting somewhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll slightly modify the existing `src/components/EssentialLink.vue`
    component: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.7-EssentialLink.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.7-EssentialLink.vue).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re replacing the link with a router link integration. The `<q-item />` component
    provides support so that we can use it as a router link entity out of the box!
    Let’s open `layouts/MainLayout.vue` so that we can change the default layout for
    our use case. You can modify the header any way you see fit, but let’s focus on
    `essentialLinks` constant to reflect the pages we’ve created and want to show
    in **Menu**. We’ll replace it with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You can, of course, see these changes in the app as soon as you save them!
  prefs: []
  type: TYPE_NORMAL
- en: We haven’t allowed our users to log out of their session in the app yet. In
    the next section, we’ll make sure our users can sign out as well.
  prefs: []
  type: TYPE_NORMAL
- en: Logging out
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s add a button to sign out as well. We’ll create a standalone component
    for this in the `components` folder called `ButtonSignOut.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We’re calling the Supabase method of signing out again and instructing the router
    to go to the first entry of its history table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can flip back to `MainLayout.vue`: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.8-MainLayout.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.8-MainLayout.vue).'
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the contents of the `<q-drawer>` component (*lines 20–39*), we
    will see the addition of a logout button (*lines 29–32, 48*). Feel free to add
    the sign-out button to, say, the **Account** page as well.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Since we’re creating new files as well as modifying existing starter files,
    we have mixed coding styles in our app. Sometimes, the code block precedes the
    template, and sometimes, the other way around. For our current implementation,
    this is not problematic, although when collaborating or working on large projects,
    it is highly recommended to use a consistent coding style and strictly keep to
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we’ve created the basic features for a user-centered app: signing up,
    logging in, and logging out. We’ve also applied the authorization to different
    parts of our app using routes. Now, we’ll focus on adding specific features to
    the app, such as expense tracking.'
  prefs: []
  type: TYPE_NORMAL
- en: Expense tracking features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A big part of tracking our future expenses is being able to organize them into
    different categories. We’ll start by adding a Pinia store to work with the category
    data in our app. This is very similar to the exercises we completed in [*Chapter
    6*](B19563_06.xhtml#_idTextAnchor162). Let’s create a `src/store/categories.ts`
    file: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.9-categories.ts](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.9-categories.ts).'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we’re using the `session` and `supabase` scripts from our `boot`
    scripts to interact with the logged-in user session and database connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'To show the categories, we’ll create a component in our components folder called
    `CategoryList.vue`: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.10-CategoryList.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.10-CategoryList.vue).'
  prefs: []
  type: TYPE_NORMAL
- en: Apart from showing the categories, the `removeOwnCategory` function (*lines
    29–39*) allows users to remove categories that they’ve added themselves. All of
    the actions are dispatched via the store we’ve created.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll create features to make the app a bit more personal,
    by allowing our users to manage categories for themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Managing categories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Having a function to remove categories means we have to build a component to
    add custom categories. So, we’ll create a new component called `CategoryAdd.vue`:
    [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.11-CategoryAdd.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.11-CategoryAdd.vue).'
  prefs: []
  type: TYPE_NORMAL
- en: This exposes a sticky **floating action button** (**FAB**) that’s tied to toggling
    a small form in a dialog that accepts name and color entries and upserts the entry
    in the database with the user’s profile ID. This is another good example of a
    component with a clear purpose that’s contained in a single file. This is how
    we build complex applications!
  prefs: []
  type: TYPE_NORMAL
- en: Having the feature of adding personal categories means we can show these individual
    categories together with the default categories.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete the categories functionality, we will import both components we’ve
    just created and list them on `CategoriesPage.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: With our categories in place, we can finalize the app by exposing the feature
    to add expenses!
  prefs: []
  type: TYPE_NORMAL
- en: Adding expenses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add expenses, we’ll start by creating a Pinia store. The store will contain
    an overview of expenses for our users and have some methods for retrieving and
    adding expenses. Let’s create a `src/store/expenses.ts` file: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.12-expenses.ts](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.12-expenses.ts).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important feature of our app is its ability to track expenses! Having
    our store in place, we can create a component specifically for that called `src/components/ExpenseAdd.vue`:
    [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.13-ExpenseAdd.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.13-ExpenseAdd.vue).'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this component has a lot of similarities with adding a category,
    although this form depends on categories to be present on the Vuetify Select component.
    Both are FAB components that toggle a dialog to facilitate this feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add our new `ExpenseAdd` component to `ExpensesPage.vue` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now, you should be able to add expenses. You can verify this by looking at the
    tables in the Supabase dashboard. For our users, we’ll have to start creating
    views in the app, so that will be our next step!
  prefs: []
  type: TYPE_NORMAL
- en: Showing expenses and an overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `src/components` folder, we’ll create a `CategoryOverview.vue` component
    that will aggregate the categories and expenses from the database into a combined
    view: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.14-CategoryOverview.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.14-CategoryOverview.vue).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the category overview, we have another overview of categories, but
    this one is displayed in a slightly different layout. This will serve as our new
    starting point. Let’s finalize `ExpensesPage.vue` by adding the `CategoryOverview`
    component as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run your app and navigate to the **Expenses** page, you should see something
    similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9 – First overview of the Expenses page](img/B19563_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.9 – First overview of the Expenses page
  prefs: []
  type: TYPE_NORMAL
- en: 'To add value to this page, we need to start showing our expenses here. We can
    create a specific component for this in the components folder, which we’ll call
    `ExpensesCategoryTotal.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a component that we can provide with a category ID, and it will grab
    and tally all the values of `amount` as the total amount for that category. Once
    we’ve done this, we can add the `ExpensesCategoryTotal` component to our overview
    of categories with ease:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Depending on what expenses you’ve inserted, you will now see an overview of
    the total expenses per category in the tiled overview we created. We’re almost
    there!
  prefs: []
  type: TYPE_NORMAL
- en: It would be nice if users could get some more insights into their expenses,
    right? So, let’s add a more detailed overview of the expenses in a certain category.
    Luckily, in our store, the functionality to query the database on expenses per
    category is already exposed. It is an extra call to Supabase, so we want to be
    a bit diligent with additional requests, which means we will only load the data
    when requested.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by adding the script to handle the request and store the data in
    the `CategoryOverview.vue` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the template, we’ll call `getExpensesByCategoryId` when clicking on
    a tile. So, let’s modify `<q-card>` and add an `onClick` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, as a sibling of the masonry style element, we’ll add dialog markup to
    show the expenses of the selected category:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We will need to feed the given collection of expenses into a new component.
    This will be our last component before we finalize our app!
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `components` folders, we’ll create an `ExpensesList.vue` component and
    have it receive `expenses` as a prop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can wrap the details of an expense and the categories together with
    `CategoryOverview.vue` by importing the `ExpensesList` component and using that
    list component instead of rendering the raw data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we have an app where a user can manage categories and add expenses,
    which are shown in an overview.
  prefs: []
  type: TYPE_NORMAL
- en: With this as our basis, it would be a good exercise to try and expand the app
    with different functionalities on your own if you like. How would you add a date
    filter to the expenses? At what level would you introduce them and what will they
    affect? Or how about removing expenses?
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll convert our web application into a desktop application.
    The conversion can be done for every improvement you make in the code, so feel
    free to continue and add some new features later!
  prefs: []
  type: TYPE_NORMAL
- en: Building the app with the Quasar CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Quasar CLI offers some commands to quickly build and publish an Electron
    app. It is important to realize that at this point, *the output of the default
    build script defaults to supporting only your current operating system and architecture*!
    That’s a good way to test the app, so let’s see what happens. We can generate
    our app code by running the following command in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This will take a bit longer to process than spinning up the development server:
    first, Quasar builds the files for the web and then uses that production-ready
    code with Electron to compile a native app. Once the processing is done, you can
    locate the build output files in the `/dist/electron` folder of your project.
    You should also be able to execute your app now!'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll improve the visual identity of the application by creating and providing
    our custom app icon.
  prefs: []
  type: TYPE_NORMAL
- en: A custom icon
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With any application, an icon is as important as its name. With our web apps,
    we have omitted that part since there are plenty of resources for adding a favorite
    icon to a website. For our desktop app, however, we’ll recreate the steps for
    adding an icon.
  prefs: []
  type: TYPE_NORMAL
- en: 'I downloaded a suitable icon from `src/assets` folder. Quasar offers a small
    tool called `npx`. We can generate the icon set with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `npx` command doesn’t work, you can try to install the node package
    globally using the following terminal command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the global installation is done, you can run the package from your projects’
    folder, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Once the script is done, you will find the output in the `src-electron/icons`
    folder. That’s all there is to it!
  prefs: []
  type: TYPE_NORMAL
- en: Our default output is only suited for the platform we’re developing with. What
    we’re interested in is building for different platforms as well. We’ll discover
    those options in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging for different targets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, Quasar uses **Electron Packager** ([https://electron.github.io/electron-packager/main/](https://electron.github.io/electron-packager/main/))
    under the hood to create the package for you. You could change it to **Electron
    Builder** ([https://www.electron.build/index.html](https://www.electron.build/index.html))
    as well, but for this example, we’ll use the default.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you open the `quasar.config.js` file, you can scroll to the `electron` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the default setup. Since we’re dealing with the Electron Packager,
    our configuration goes in the `packager` property. To build for additional platforms,
    we can add the target platforms we want to build for as properties (as documented
    in the guide at [https://electron.github.io/electron-packager/main/modules/electronpackager.html#officialplatform](https://electron.github.io/electron-packager/main/modules/electronpackager.html#officialplatform)),
    and for each property, we can add additional configuration. We’ll use the configuration
    properties and default presets to target specific architectures per platform.
    The following configuration will attempt to build the app for macOS (Darwin),
    Linux, and Windows (Win32) and target specific architectures as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, there are some caveats. If I run the preceding code on a Mac or Linux
    machine, I will need to install a Windows emulator to build for that platform.
    The good news is that if you run **HomeBrew** ([https://brew.sh/](https://brew.sh/)),
    you can install **Wine** fairly easily with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The Quasar CLI provides you with that instruction. For non-macOS users, the
    app that you build will be unsigned. This means that users will need to manually
    accept the gatekeeping security warning. It will also be impossible to publish
    to the app store.
  prefs: []
  type: TYPE_NORMAL
- en: With the flexibility that Quasar and Electron offer in terms of native app development,
    it is still a very viable way of delivering apps that need to run on multiple
    platforms. Also, bear in mind that these apps may not be as performant concerning
    applications that were developed specifically for and on a target platform. Development
    is often about tradeoffs. However, having the possibility to develop and deliver
    a web app to a native platform is very useful.
  prefs: []
  type: TYPE_NORMAL
- en: And remember, the basis of our app is a `-m electron` flag with `-m spa`. It
    will bundle and build our application so that it’s ready for the web.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we unlocked a powerful capability: we started with what we
    learned in [*Chapter 6*](B19563_06.xhtml#_idTextAnchor162) and built a web application.
    Using Quasar’s available features, we processed our code and deployed our web
    application as a standalone desktop application that’s suitable for multiple platforms.'
  prefs: []
  type: TYPE_NORMAL
- en: We also adopted another framework to build an app. Instead of Vuetify, we relied
    on the default components that Quasar offers. This way, we’ve seen and experienced
    slight differences in code styles in building applications, using frameworks and
    build tools. We also experienced similarities, for instance, in the usage of Pinia
    as a centralized store.
  prefs: []
  type: TYPE_NORMAL
- en: This way of app building is not always the most suitable. There are some limitations
    and tradeoffs. On the upside, you only have to build one application and can deploy
    it to multiple targets. The cost efficiency of this development method makes it
    a serious candidate for multi-platform strategies.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll work on something fun. We’ll connect multiple devices
    to a single server and build a real-time quiz!
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3: Advanced Applications'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This part of the book covers complex use cases, and you will learn how to break
    complexity down into individual parts and distribute responsibility accordingly.
    Also, you will learn the difference between, and use cases for, using Vue.Js as
    a frontend framework and adopting a meta-framework such as Nuxt to build server-side
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, you will experience the process of investigating by prototyping,
    building, and iterating with experimental frameworks and solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B19563_08.xhtml#_idTextAnchor233), *Building an Interactive Quiz
    App*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B19563_09.xhtml#_idTextAnchor281), *Experimental Object Recognition
    with TensorFlow*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
