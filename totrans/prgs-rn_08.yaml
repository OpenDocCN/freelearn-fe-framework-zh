- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript Engines and Hermes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React Native runs on JavaScript and, as mentioned in [*Chapter 2*](B16694_02.xhtml#_idTextAnchor030),
    *Understanding the Essentials of JavaScript and TypeScript*, JavaScript needs
    a JavaScript engine to interpret and/or transform the code into executable machine
    code. There is no exception to this for React Native.
  prefs: []
  type: TYPE_NORMAL
- en: While there are quite a lot of different JS engines out there, only a few are
    used in React Native projects. This is due to the quite complex process to change
    the JS engine as well as the new Hermes engine, which is an engine developed for
    React Native and is going to be the default soon. Nevertheless, it is important
    and helpful to understand the different possible engines with their strengths
    and weaknesses.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this theoretical chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding JavaScript engines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting to know the Hermes engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing key metrics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since this is a theoretical chapter, you don’t need to have anything set up.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding JavaScript engines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in the introduction to this chapter, a JavaScript engine is responsible
    for interpreting JavaScript and/or transforming it into machine code, so that
    the device can execute it.
  prefs: []
  type: TYPE_NORMAL
- en: The first JavaScript engines were simple interpreters that simply processed
    the statements and ensured the execution. The code was just executed like it was
    written. This has changed a lot.
  prefs: []
  type: TYPE_NORMAL
- en: Modern JS engines provide a lot of optimization features. The most discussed
    is **just-in-time** (**JIT**) compilation, which is implemented by all modern
    JS engines.
  prefs: []
  type: TYPE_NORMAL
- en: Compiled languages such as C are compiled before the execution of the code.
    In this compile step, the transformation to machine language is done as well as
    a lot of optimization steps. This creates an output that is extremely performant.
  prefs: []
  type: TYPE_NORMAL
- en: '*Just-in-time* compilation means that the code is compiled while it runs. This
    means the just-in-time compiler does not know all the code while it compiles.
    This makes code optimization a lot more difficult. The just-in-time compiler contains
    two components – the **profiler** and the **compiler**. While the JS code is executed
    by the interpreter, the profiler keeps an eye on how often the different statements
    are executed.'
  prefs: []
  type: TYPE_NORMAL
- en: The more often a statement is executed, the higher priority it gets from the
    profiler. When a certain threshold is hit, the profiler sends these statements
    of code to the compiler, which then compiles the statements to bytecode. When
    the statement shall be executed the next time, it is done via a highly optimized
    bytecode interpreter. This makes these sections run much faster.
  prefs: []
  type: TYPE_NORMAL
- en: There are some more optimizations that can be done during the compilation. This
    depends a lot on the implementation and every modern JS engine has its own just-in-time
    compiler implementation.
  prefs: []
  type: TYPE_NORMAL
- en: In general, just-in-time compilation works better for longer running code, because
    then the compiler has more time to learn how to optimize. Since a lot of JS code
    is executed while running a React Native app, just-in-time compilation works great.
  prefs: []
  type: TYPE_NORMAL
- en: The most widely known JS engines today are JavaScriptCore and V8\. Since both
    can be used in React Native, we’ll have a deeper look at them.
  prefs: []
  type: TYPE_NORMAL
- en: Using JavaScriptCore
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**JavaScriptCore** is the JS engine that powers the Safari browser. It is the
    default engine shipping with React Native. If you create a new blank project,
    JavaScriptCore will interpret and execute your JS code.'
  prefs: []
  type: TYPE_NORMAL
- en: Using V8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**V8** is an open source JS engine, heavily backed by Google. It is used by
    default when you are using the remote debugging feature of React Native. In this
    case, your JS code is executed in your Chrome browser, which is powered by V8.'
  prefs: []
  type: TYPE_NORMAL
- en: Important tip
  prefs: []
  type: TYPE_NORMAL
- en: Please always keep in mind that you are using different JS engines when having
    remote debugging on/off. Without remote debugging, your JS code runs on your device
    or simulator; with remote debugging activated, your JS code runs on your computer
    in Chrome and communicates with native via WebSockets. Even if the two engines
    should behave quite similarly, there are some inconsistencies. So always test
    without remote debugging before shipping your app.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also a project that provides support for V8 as the main JS engine
    for React Native. This is no big deal for Android since it just replaces the JavaScriptCore
    for Android JS engine with the V8 engine. It gets more complex on iOS since JavaScriptCore
    is available on iOS without having to include it in the app bundle. So instead
    of just using the available JS engine, you would have to bundle the V8 engine
    in your app. This increases your app bundle size by up to 7 MB depending on the
    version you use. You can find more information on this on the `react-native-v8`
    project: [https://bit.ly/prn-rn-v8](https://bit.ly/prn-rn-v8).'
  prefs: []
  type: TYPE_NORMAL
- en: While both engines work fine, Facebook started a project called **Hermes** to
    develop their own JS engine for React Native. The use case of React Native differs
    a lot from that of the browser engines as the code is available at build time
    and cannot change after shipping; hence, there is a lot more room for optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Getting to know the Hermes engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hermes was brought to the React Native community at the React Native EU conference
    in 2019\. Back then, it was already in production in Facebook’s apps for more
    than a year. It is completely built with mobile in mind, which changes the architectural
    approach completely. The following figure shows how a modern JS engine works.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Modern JS engine pipeline (inspired by Tsvetan Mikov)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16694_08_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.1 – Modern JS engine pipeline (inspired by Tsvetan Mikov)
  prefs: []
  type: TYPE_NORMAL
- en: When creating and building JavaScript code, usually there is some transcompiling
    done to backward-compatible JS code and some JS code minification. This minified
    JS bundle is then sent to a device and gets executed. JS engines such as JavaScriptCore
    or V8 try to optimize the execution using just-in-time compilation, which, as
    described before, is a quite complex process and may store and optimize the wrong
    code statements. Hermes changes the way this is done completely.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows how optimization and compilation are done in Hermes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Hermes pipeline (inspired by Tzvetan Mikov)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16694_08_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.2 – Hermes pipeline (inspired by Tzvetan Mikov)
  prefs: []
  type: TYPE_NORMAL
- en: Because we know all the code, we want to ship in our React Native app, it is
    possible to do the compilation and optimization during the build process. This
    means all optimization is done on your computer (or in your CI environment) and
    not on the users’ devices. Hermes uses a so-called internal code representation,
    which is highly optimized for the optimization of code.
  prefs: []
  type: TYPE_NORMAL
- en: After optimizing the code, it is compiled to optimized bytecode. So, when working
    with Hermes, you don’t ship JavaScript any longer, you ship optimized bytecode.
    This bytecode only has to be loaded and executed by the Hermes engine on the users’
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach brings a lot of benefits. The most important are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**No warmup**: We don’t need to spend time on just-in-time compiler warmup.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**No memory usage for just-in-time compiler output**: We don’t need any memory
    for the output of the just-in-time compiler. This reduces the memory footprint
    a lot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Startup optimizations**: Some operations that are done by JS engines at startup
    can be precomputed. This makes the start of the application a lot faster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Smaller bundle size**: The optimized bundle is smaller than minified JavaScript
    code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Due to the benefits of this approach, Hermes is pushed to become the default
    JS engine for React Native as soon as possible. At the point of writing, you still
    have to activate it, but it is quite simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '`android/app/build.gradle` file and change `enableHermes` from `false` to `true`.
    You have to clean and rebuild your application after that.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ios/Podfile` file and change `:hermes_enabled => false` to `:hermes_enabled
    => true`. Reinstall your pods with `cd ios && pod install`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please note that the remote debugging feature does work differently when using
    Hermes. Since the approach is completely different, there is no bundle that can
    be run directly in your Chrome browser. Nevertheless, Hermes does support debugging
    with the Chrome inspector protocol and the Chrome developer tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use remote debugging, you have to connect your Chrome browser to your running
    device via Metro. This is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to `chrome://inspect/#devices` in your Chrome browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the `Configure…` button and add the Metro server address (usually `localhost:8081`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, there is a `Hermes React Native` target, which you can inspect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For more information, please visit the Hermes documentation of React Native
    ([https://bit.ly/prn-hermes](https://bit.ly/prn-hermes)) or the documentation
    of the Hermes engine itself ([https://bit.ly/prn-hermes-engine](https://bit.ly/prn-hermes-engine)).
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, the Hermes approach brings a lot of benefits to React Native.
    This is also reflected in key metrics, which we are going to have a look at in
    the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing key metrics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to mobile apps, there are a few metrics you should have a look
    at when optimizing your application.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding important metrics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most important key metrics on mobile are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Time to interaction** (**TTI**): This is the time between the user clicking
    on your app icon and when the user can use your app. It is important to reduce
    the TTI as much as possible because mobile app users are very impatient. The longer
    the TTI is, the more users will leave your app without even using it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application size**: This is the size the user has to download from the store
    to install your application. The larger the application size is, the more users
    won’t download your app. This can have many reasons such as high transfer costs
    in some countries or disk space left on the user’s device. The fact is, the smaller
    your app is, the more users will download it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory utilization**: This metric describes how much memory your application
    consumes during execution. If your app is very memory-hungry, it can lead to problems,
    especially on older devices or during multitasking. Also, it can lead to the operating
    system closing your app. The less memory your app consumes, the better it is.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are some benchmark results publicly available when looking at these metrics.
    As JavaScriptCore and V8 deliver mostly similar results (V8 is a bit better in
    most tests), we’ll focus on the comparison of JavaScriptCore and Hermes used in
    a React Native application.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing JavaScriptCore and Hermes on Android
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following test compares the key metrics of JSC and Hermes on Android. The
    test was run by the Hermes team at Facebook with a very early version of Hermes:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | JSC | Hermes |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| Time to interaction | 4.30s | 2.01s | -2.29s | -53% |'
  prefs: []
  type: TYPE_TB
- en: '| Application size | 41MB | 22MB | -19MB | -46% |'
  prefs: []
  type: TYPE_TB
- en: '| Memory Utilization | 185MB | 136MB | -49MB | -26% |'
  prefs: []
  type: TYPE_TB
- en: Figure 8.3 – Facebook JSC/Hermes test on Android (https://bit.ly/prn-hermes-test-fb)
  prefs: []
  type: TYPE_NORMAL
- en: 'There was another test run by Kudo Chien, a well-respected member of the React
    Native community, that also included TTI. This test also worked with different
    bundle sizes:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | JSC | Hermes | *in ms |  |'
  prefs: []
  type: TYPE_TB
- en: '| TTI 3MB bundle | 400 | 240 | 160 | -40% |'
  prefs: []
  type: TYPE_TB
- en: '| TTI 10MB bundle | 584 | 305 | 279 | -48% |'
  prefs: []
  type: TYPE_TB
- en: '| TTI 15MB bundle | 694 | 342 | 352 | -51% |'
  prefs: []
  type: TYPE_TB
- en: Figure 8.4 – TTI test by Kudo Chien on Android (https://bit.ly/prn-hermes-test-kudo)
  prefs: []
  type: TYPE_NORMAL
- en: If you have a look at the test results, they are just remarkable on Android.
    The time to interaction was reduced by around 50% in all tests. This is a real
    game-changer. React Native apps used to open quite slowly compared to real native
    or Flutter apps. This is due to the need of initializing the JS engine before
    rendering their first screen. Hermes is a huge step in the right direction for
    React Native in this area.
  prefs: []
  type: TYPE_NORMAL
- en: When having a look at the Facebook test, the application size was also reduced
    by nearly 50%. This is partly because we don’t have to bundle the JavaScriptCore
    engine into our application anymore, so this effect will reduce on larger applications.
    But you can expect a saving in bundle size by around 30% even on larger apps.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s have a look at memory utilization. In Facebook’s test, Hermes achieved
    memory savings of around 25%. This is mostly because of the not needed just-in-time
    compilation and is also a huge achievement.
  prefs: []
  type: TYPE_NORMAL
- en: Again, these tests were run with very early versions of Hermes, so you can expect
    larger gains in the future.
  prefs: []
  type: TYPE_NORMAL
- en: While the results are very clear on Android, let’s proceed with tests on iOS.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing JSC and Hermes on iOS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On iOS, we have to keep in mind that JavaScriptCore is provided by the operating
    system. This means when using JSC, we don’t have to bundle any JavaScript engine
    into our application. Also, JavaScriptCore is optimized for iOS and Apple products.
    The implementation of Hermes on iOS was done by **Callstack**, a company that
    contributes a lot to React Native in general. After completing the implementation,
    the Callstack team also ran some tests to compare JSC and Hermes. These are the
    results:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | JSC | Hermes | *in ms |  |'
  prefs: []
  type: TYPE_TB
- en: '| Time to interaction | 920ms | 570ms | -350ms | -38% |'
  prefs: []
  type: TYPE_TB
- en: '| Application size | 10.6MB | 13MB | 2,4MB | 18% |'
  prefs: []
  type: TYPE_TB
- en: '| Memory utilization | 216MB | 178MB | -38MB | -18% |'
  prefs: []
  type: TYPE_TB
- en: Figure 8.5 – Callstack JSC/Hermes test on iOS (https://bit.ly/prn-hermes-test-ios)
  prefs: []
  type: TYPE_NORMAL
- en: As on Android, time to interaction and memory utilization improved a lot. The
    values are a little lower than on Android, but this can be explained due to the
    better optimization of JSC on iOS. The application size increased on iOS, which
    seems only logical, so we now have to add Hermes to our bundle, while JSC is provided
    by the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: But when the JavaScript bundle of your app grows, this effect will decrease
    due to the smaller bytecode of Hermes compared to the minified JS code shipped
    with the JSC-based bundle.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we had a look at JavaScript engines in general, learned about
    the special requirements React Native has for a JavaScript engine, the different
    engines we can use in React Native, and how to change the JS engine of our React
    Native project. We then had a look at Hermes, a JavaScript engine developed with
    mobile in general and React Native especially in mind.
  prefs: []
  type: TYPE_NORMAL
- en: After understanding the approach of Hermes and its benefits, we compared mobile
    app key metrics on apps running on JavaScriptCore, V8, and Hermes. While there
    is no big difference in using JSC or V8, Hermes brings a huge boost in terms of
    TTI and memory utilization to React Native.
  prefs: []
  type: TYPE_NORMAL
- en: After mastering JavaScript engines, we’ll have a look at useful tools when working
    with React Native in the next chapter.
  prefs: []
  type: TYPE_NORMAL
