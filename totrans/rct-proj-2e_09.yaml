- en: '*Chapter 9*: Building a Full-Stack Social Media Application with React Native
    and Expo'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第9章*：使用React Native和Expo构建全栈社交媒体应用程序'
- en: Most of the projects that you've created in this book focused on displaying
    data and making it possible to navigate between pages. When we created our first
    mobile application with React Native, animations were one of the focus points,
    which is a must-have when creating a mobile application. In this chapter, we'll
    be exploring a big advantage of mobile applications, namely the ability to use
    the camera (or camera roll) from the phone.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中您创建的大多数项目都集中在显示数据和在页面之间导航。当我们使用React Native创建第一个移动应用程序时，动画是其中一个重点，这在创建移动应用程序时是必不可少的。在本章中，我们将探讨移动应用程序的一个大优势，即能够使用手机上的相机（或相册）。
- en: The application we'll be creating in this chapter will follow the same patterns
    for data-heavy applications as in previous chapters. React techniques such as
    Context and Hooks are used to get data from a local API that also supports authentication,
    while React Navigation is used again to create a more advanced routing setup.
    Also, Expo is used to post images to a social feed by using the camera of the
    mobile device the application is running on.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们将创建的应用程序将遵循与之前章节相同的数据密集型应用程序模式。使用React技术，如Context和Hooks，从支持身份验证的本地API获取数据，同时再次使用React
    Navigation创建更高级的路由设置。此外，使用运行应用程序的移动设备的相机通过Expo将图片发布到社交动态。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Advanced routing with authentication
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有身份验证的高级路由
- en: Using the camera with React Native and Expo
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在React Native和Expo中使用相机
- en: Differences in styling for iOS and Android
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iOS和Android的样式差异
- en: Project overview
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: In this chapter, we will build a mobile social media application that is using
    a local API to request and add posts to the social feed, including using the camera
    on the mobile device. Advanced routing with authentication is added using the
    local API and React Navigation, while Expo is used for access to the camera (roll).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个使用本地API请求并添加帖子到社交动态的应用程序，包括使用移动设备上的相机。通过本地API和React Navigation添加了具有身份验证的高级路由，同时使用Expo来访问相机（滚动）。
- en: The build time is 2 hours.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 构建时间为2小时。
- en: Note
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This chapter is using React Native version 0.64.3 and Expo SDK version 44\.
    As React Native and Expo are updated frequently, make sure that you're working
    with these versions to ensure the patterns described in this chapter are behaving
    as expected.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用React Native版本0.64.3和Expo SDK版本44。由于React Native和Expo经常更新，请确保您使用这些版本以确保本章中描述的模式按预期运行。
- en: Getting started
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始
- en: 'The project that we''ll create in this chapter builds upon an initial version
    that you can find on GitHub: [https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter09-initial](https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter09-initial).
    The complete source code can also be found on GitHub: [https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter09](https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter09).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们将创建的项目基于您可以在GitHub上找到的初始版本：[https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter09-initial](https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter09-initial)。完整的源代码也可以在GitHub上找到：[https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter09](https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter09)。
- en: You need to have the Expo Go application installed on a mobile iOS or Android
    device to run the project on a physical device. Once you've downloaded the application,
    you need to create an Expo account to make the development process smoother. Make
    sure to store your account details somewhere safe, as you need these later on
    in this chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在iOS或Android移动设备上安装Expo Go应用程序，以便在物理设备上运行项目。一旦您下载了应用程序，您需要创建一个Expo账户以使开发过程更加顺畅。请确保将您的账户详细信息保存在安全的地方，因为您在本章的后续部分需要这些信息。
- en: 'Alternatively, you can install either Xcode or Android Studio on your computer
    to run the application on a virtual device:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以在计算机上安装Xcode或Android Studio来在虚拟设备上运行应用程序：
- en: '**For iOS**: Information on how to set up your local machine to run the iOS
    simulator can be found here: [https://docs.expo.io/workflow/ios-simulator/](https://docs.expo.io/workflow/ios-simulator/).'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于iOS**：有关如何设置本地机器以运行iOS模拟器的信息，请参阅此处：[https://docs.expo.io/workflow/ios-simulator/](https://docs.expo.io/workflow/ios-simulator/)。'
- en: '**For Android**: Information on how to set up your local machine to run the
    emulator from Android Studio can be found here: [https://docs.expo.io/workflow/android-studio-emulator/](https://docs.expo.io/workflow/android-studio-emulator/).'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于 Android**：有关如何设置你的本地机器以从 Android Studio 运行模拟器的信息，可以在此处找到：[https://docs.expo.io/workflow/android-studio-emulator/](https://docs.expo.io/workflow/android-studio-emulator/)。'
- en: Note
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: It's **highly recommended** to use the Expo client application to run the project
    from this chapter on a physical device. Receiving notifications is currently only
    supported on physical devices, and running the project on either the iOS simulator
    or Android Studio emulator will result in error messages.
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**强烈建议**使用 Expo 客户端应用程序在物理设备上运行本章中的项目。目前仅支持在物理设备上接收通知，在 iOS 模拟器或 Android Studio
    模拟器上运行项目将导致错误信息。'
- en: Checking out the initial project
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查初始项目
- en: 'For this chapter, an initial application has been created with Expo using their
    CLI, as you learned in the previous chapter. To get started, you''ll need to run
    the following command in this chapter''s directory to install all of the dependencies
    and start both the server and application:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，已经使用 Expo 的 CLI 创建了一个初始应用，正如你在上一章所学。要开始，你需要在本章目录下运行以下命令来安装所有依赖项并启动服务器和应用程序：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This command will start Expo after installing the dependencies, and it gives
    you the ability to start your project from either the terminal or your browser.
    In the terminal, you can now either use the QR code to open the application on
    your mobile device or open the application in a simulator. In the browser, the
    Expo DevTools will be opened, which also lets you scan the QR code with your phone
    using the camera or the Expo Go application.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装依赖项后，此命令将启动 Expo，并给你从终端或浏览器启动项目的权限。在终端中，你现在可以使用二维码在你的移动设备上打开应用程序，或者在模拟器中打开应用程序。在浏览器中，将打开
    Expo DevTools，这也允许你使用手机摄像头或 Expo Go 应用程序扫描二维码。
- en: 'The local API from which to get the data for our application was created using
    JSON Server. We''ve already used this library before, as we used the `db.json`
    file in this repository. For this project, we have a separate `db.json` file in
    the directory for this chapter, which is loaded by the `server.js` file to create
    a local API. The local API can be started by running the following command in
    a separate terminal tab or window:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为我们的应用程序获取数据的本地 API 是使用 JSON Server 创建的。我们之前已经使用过这个库，因为我们在这个存储库中使用了 `db.json`
    文件。对于这个项目，我们在本章的目录中有一个单独的 `db.json` 文件，它由 `server.js` 文件加载以创建本地 API。可以通过在单独的终端标签或窗口中运行以下命令来启动本地
    API：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This spins up a server at `http://localhost:3000/api/` with, for example, the
    `http://localhost:3000/api/posts` endpoint, which returns an array of posts. However,
    when building mobile applications, you cannot use a `localhost` address (or any
    other address without HTTPS) for security reasons. To be able to use this endpoint
    in the React Native application, you need to find the local IP address of your
    machine.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在 `http://localhost:3000/api/` 上启动一个服务器，例如，`http://localhost:3000/api/posts`
    端点，它返回一系列帖子。然而，在构建移动应用程序时，出于安全原因，你不能使用 `localhost` 地址（或任何没有 HTTPS 的其他地址）。为了能够在
    React Native 应用程序中使用此端点，你需要找到你机器的本地 IP 地址。
- en: 'To find your local IP address, you''ll need to do the following depending on
    your operating system:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到你的本地 IP 地址，你需要根据你的操作系统执行以下操作：
- en: '**For Windows**: Open the terminal (or Command Prompt) and run this command:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于 Windows**：打开终端（或命令提示符）并运行以下命令：'
- en: '[PRE2]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will return a list like the one you see in the following screenshot with
    data from your local machine. In this list, you need to look for the **IPv4 Address**
    field:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个类似于以下截图中的列表，其中包含你本地机器的数据。在这个列表中，你需要查找 **IPv4 地址** 字段：
- en: '![Figure 9.1 – Finding a local IP address in Windows'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.1 – 在 Windows 中查找本地 IP 地址'
- en: '](img/Figure_9.01_B17390.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.01_B17390.jpg)'
- en: Figure 9.1 – Finding a local IP address in Windows
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – 在 Windows 中查找本地 IP 地址
- en: '**For macOS**: Open the Terminal and run this command:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于 macOS**：打开终端并运行以下命令：'
- en: '[PRE3]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After running this command, the local IPv4 address of your machine gets returned,
    which looks like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，你的机器的本地 IPv4 地址将被返回，看起来像这样：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The local IP address can be used as an alternative for `localhost`, which you
    can try by visiting the following page: `http://192.168.1.107/api/posts`. Make
    sure to replace the IP address with your own.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 本地 IP 地址可以用作 `localhost` 的替代品，您可以通过访问以下页面来尝试：`http://192.168.1.107/api/posts`。请确保将
    IP 地址替换为您自己的。
- en: 'Our application for this chapter has already been set up and needs to know
    what URL to use for the local API. Configuration in Expo can be stored in `app.json`,
    but also in `app.config.js` if you want to store specific configuration environment
    variables. In this file, you can add the following configuration:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的应用程序已经设置好，需要知道用于本地 API 的 URL。在 Expo 中的配置可以存储在 `app.json` 中，但如果您想存储特定的配置环境变量，也可以存储在
    `app.config.js` 中。在此文件中，您可以添加以下配置：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding `app.config.js` file, you need to replace `LOCAL_IP_ADDRESS`
    with your own IP address that you acquired from your machine.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 `app.config.js` 文件中，您需要将 `LOCAL_IP_ADDRESS` 替换为您从您的机器上获取的自己的 IP 地址。
- en: 'To use this environment variable in our code, we use the `expo-constants` library.
    This has already been installed in the initial application for this chapter, and
    an example of how to get `apiUrl` from `app.config.js` can be seen in the `context/PostsContext.js`
    file:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的代码中使用此环境变量，我们使用 `expo-constants` 库。这已经在本章的初始应用程序中安装，如何从 `app.config.js`
    获取 `apiUrl` 的示例可以在 `context/PostsContext.js` 文件中看到：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `apiUrl` constant is now used to fetch the following local API. No matter
    whether you''ve opened the application from a virtual or physical device, the
    initial application at this point should look something like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`apiUrl` 常量现在用于获取以下本地 API。无论您是从虚拟设备还是物理设备打开的应用程序，此时初始应用程序应该看起来像这样：'
- en: '![Figure 9.2 – The initial application](img/Figure_9.02_B17390.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2 – 初始应用程序](img/Figure_9.02_B17390.jpg)'
- en: Figure 9.2 – The initial application
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – 初始应用程序
- en: The `screens` directory for the initial application consists of five screens,
    which are `Posts`, `PostDetail`, `PostForm`, `Profile`, and `Login`. The `Posts`
    screen will be the initial screen that is loaded and shows a list of posts on
    which you can tap to continue to the `PostDetail` screen. For now, the `PostForm`,
    `Profile`, and `Login` screens aren't visible yet, as we'll add advanced routing
    and authentication later on in this chapter.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 初始应用程序的 `screens` 目录包含五个屏幕，分别是 `Posts`、`PostDetail`、`PostForm`、`Profile` 和 `Login`。`Posts`
    屏幕将是加载的初始屏幕，显示您可以点击以继续到 `PostDetail` 屏幕的帖子列表。目前，`PostForm`、`Profile` 和 `Login`
    屏幕尚未可见，因为我们将在本章后面添加高级路由和身份验证。
- en: 'The project structure from this React Native app is as follows, where the structure
    is similar to the projects you''ve created before in this book:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个 React Native 应用程序的项目结构如下，其中结构与您在这本书中之前创建的项目类似：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the `assets` directory, you can find the images that are used as the application
    icon on the home screen once you've installed this application on your mobile
    device, and the image that will serve as the splash screen, which is displayed
    when you start the application. The `App.js` file is the actual entry point of
    your application and all of the components for this application are located in
    the `screens` and `components` directories. You can also find a directory called
    `context`. This directory has all the state management components for this application.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `assets` 目录中，您可以找到在您将此应用程序安装到移动设备上后用作主屏幕应用程序图标的图像，以及将作为启动屏幕显示的图像。`App.js`
    文件是您应用程序的实际入口点，所有此应用程序的组件都位于 `screens` 和 `components` 目录中。您还可以找到一个名为 `context`
    的目录。此目录包含此应用程序的所有状态管理组件。
- en: '**Note**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: If you get an error when loading the application on your local device or emulator
    stating `app.config.js`. Also, the server must be running in a separate terminal
    tab.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在您的本地设备或模拟器上加载应用程序时出现错误，显示 `app.config.js`。此外，服务器必须在单独的终端标签页中运行。
- en: Configurations for your application, for example, the App Store, are placed
    in `app.json`, while `babel.config.js` holds specific Babel configurations. As
    mentioned earlier, the `app.config.js` file holds the configuration for the URL
    to the local API. There are also two files that are needed to create the local
    API. These are `db.json` and `server.js`, as described previously in this section.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序的配置，例如 App Store，放置在 `app.json` 中，而 `babel.config.js` 包含特定的 Babel 配置。如前所述，`app.config.js`
    文件包含本地 API 的 URL 配置。还需要两个文件来创建本地 API。这些是前面在本节中描述的 `db.json` 和 `server.js` 文件。
- en: Building a full-stack social media application with React Native and Expo
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React Native和Expo构建全栈社交媒体应用程序
- en: The application that you're going to build in this chapter will use a local
    API to retrieve and mutate data that is available in the application. This application
    will display data from a social media feed, lets you add new posts containing
    images, and allows you to respond to these social media posts.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中将要构建的应用程序将使用本地API检索和修改应用程序中可用的数据。此应用程序将显示社交媒体源的数据，允许您添加包含图片的新帖子，并允许您对这些社交媒体帖子做出回应。
- en: Advanced routing with authentication
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有身份验证的高级路由
- en: We've already learned how to add routing to a React Native application using
    React Navigation. The routing we added was using a stack navigator, which doesn't
    have a way to display some sort of menu or navigation bar with all the routes.
    In this section, we'll be adding a tab navigator using React Navigation to display
    a tab bar at the bottom of the application. Later on, we'll also be adding an
    authentication flow.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何使用React Navigation向React Native应用程序添加路由。我们添加的路由是使用堆栈导航器，它没有显示所有路由的某种菜单或导航栏的方式。在本节中，我们将使用React
    Navigation添加标签导航器以在应用程序底部显示标签栏。稍后，我们还将添加身份验证流程。
- en: Adding bottom tabs
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加底部标签
- en: Bottom tabs are common on applications for iOS, but less popular on Android
    applications. In the final section of this chapter, we'll learn more about the
    styling differences between iOS and Android. But first, we'll focus on adding
    bottom tabs to our application.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 底部标签在iOS应用程序中很常见，但在Android应用程序中则不太受欢迎。在本章的最后部分，我们将了解iOS和Android之间在样式上的差异。但首先，我们将专注于向我们的应用程序添加底部标签。
- en: 'To add a tab navigator, we need to complete the following actions:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加标签导航器，我们需要完成以下操作：
- en: 'React Navigation has a separate library to create a tab navigator, which we
    need to install from npm:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React Navigation有一个用于创建标签导航器的单独库，我们需要从npm安装它：
- en: '[PRE8]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When the installation of `@react-navigation/bottom-tabs` is complete, make sure
    to restart Expo using the `npm start` command.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当`@react-navigation/bottom-tabs`的安装完成时，请确保使用`npm start`命令重新启动Expo。
- en: 'In the `App.js` file, all the routes for this application are listed, and we
    need to import the method to create a tab:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`App.js`文件中，列出此应用程序的所有路由，我们需要导入创建标签的方法：
- en: '[PRE9]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The tab navigator can be created using the `createBottomTabNavigator` method.
    These screens for the navigator must be created in a separate component inside
    the `App.js` file, where the `Posts`, `PostForm`, and `Profile` screens will be
    added to it. These screens will later become available in the bottom tabs. It''s
    important to pass the option to not show the header, as the title of the screen
    will be rendered by the parent navigator:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用`createBottomTabNavigator`方法创建标签导航器。这些导航器屏幕必须在`App.js`文件中的单独组件内创建，其中`Posts`、`PostForm`和`Profile`屏幕将被添加到其中。这些屏幕将后来在底部标签中可用。重要的是要传递不显示标题的选项，因为屏幕标题将由父导航器渲染：
- en: '[PRE10]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To render the navigator in the application, we need to add it to the `return`
    statement inside the `App` component:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在应用程序中渲染导航器，我们需要将其添加到`App`组件内的`return`语句中：
- en: '[PRE11]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When you now navigate to any of the screens using the tab navigator, you see
    that the title in the header is always `Home` component is rendered, that on its
    own end renders the different screens. We can force the header title to be that
    of the tab that is active by using `getFocusedRouteNameFromRoute` from React Navigation
    in the `options` prop for the home screen:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你现在使用标签导航器导航到任何屏幕时，你会看到标题栏中的标题始终是`Home`组件，它本身渲染不同的屏幕。我们可以通过使用React Navigation中的`getFocusedRouteNameFromRoute`在主页面的`options`属性中强制标题为活动标签的标题：
- en: '[PRE12]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The bottom tabs can also have an icon and a custom color when active. For this,
    we can alter the `screenOptions` and of the tab navigator. The icons for the tab
    can be imported from `@expo/vector-icons`, which is already included in Expo:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 底部标签也可以在激活时拥有一个图标和自定义颜色。为此，我们可以修改标签导航器的`screenOptions`。标签的图标可以从`@expo/vector-icons`导入，该图标已经包含在Expo中：
- en: '[PRE13]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, we can also change the labels of the tabs, for example, for the `PostForm`
    screen that displays the form to add a new post:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们还可以更改标签的标签，例如，对于显示添加新帖子表单的`PostForm`屏幕：
- en: '[PRE14]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With these changes, the application now has routing with both a stack navigator
    and a tab navigator, and should look something like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些更改，应用程序现在具有具有堆栈导航器和标签导航器的路由，看起来应该像这样：
- en: '![Figure 9.3 – The application with bottom tabs'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.3 – 带有底部标签的应用程序'
- en: '](img/Figure_9.03_B17390.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.03_B17390.jpg)'
- en: Figure 9.3 – The application with bottom tabs
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 带有底部标签的应用程序
- en: We're now able to reach almost all the screens, with only the `Login` screen
    still hidden. This screen is added to the stack navigator and should be displayed
    when the user isn't authenticated. In the next part of this section, we'll add
    the authentication flow to handle this.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们几乎可以到达所有屏幕，只有`Login`屏幕仍然隐藏。这个屏幕被添加到堆栈导航器中，并且当用户未认证时应显示。在本节的下一部分，我们将添加认证流程来处理这个问题。
- en: Authentication flow
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 认证流程
- en: For authentication in frontend applications, most of the time, **JSON Web Tokens**
    (**JWTs**) are used, which are encrypted tokens that can easily be used to share
    user information with a backend. The JWT will be returned by the backend when
    the user is successfully authenticated and often, this token will have an expiration
    date. With every request that the user should be authenticated for, the token
    should be sent so that the backend server can determine whether the user is authenticated
    and allowed to take this action. Although JWTs can be used for authentication
    since they're encrypted, no private information should be added to them since
    the tokens should only be used to authenticate the user. Private information can
    only be sent from the server when a document with the correct JWT has been sent.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在前端应用程序中进行身份验证时，大多数情况下使用的是**JSON Web Tokens**（JWTs），这是一种加密的令牌，可以轻松地与后端共享用户信息。当用户成功认证后，后端会返回JWT，通常这个令牌会有一个过期日期。对于用户需要认证的每个请求，都应该发送这个令牌，以便后端服务器可以确定用户是否已认证并且允许执行此操作。尽管JWT可以用于认证，因为它们是加密的，但不应向其中添加任何私人信息，因为令牌仅应用于认证用户。只有当发送了包含正确JWT的文档时，服务器才能发送私人信息。
- en: 'The mobile application we''re building in this chapter is only using `GET`
    requests to retrieve posts, but the local API also supports `POST` requests. But
    to send `POST` requests, we need to be authenticated, meaning we need to retrieve
    a token that we can send along with our request to the API. For this, we can use
    the `api/login` endpoint of the API:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们正在构建的移动应用程序仅使用`GET`请求检索帖子，但本地API也支持`POST`请求。但为了发送`POST`请求，我们需要进行认证，这意味着我们需要检索一个可以与我们的API请求一起发送的令牌。为此，我们可以使用API的`api/login`端点：
- en: 'The `Login` component can be used to log in but isn''t displayed at the moment.
    To display this component, we need to change the logic in the stack navigator
    in `App.js`. Instead of having the `App` component return the stack navigator,
    we need to create a new component in this file called `Navigator`:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Login`组件可以用于登录，但目前没有显示。要显示此组件，我们需要更改`App.js`中堆栈导航器的逻辑。我们需要在这个文件中创建一个新的组件，称为`Navigator`，而不是让`App`组件返回堆栈导航器：'
- en: '[PRE15]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding code block can be deleted from `App` and replaced by this new
    `Navigator` component:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述代码块可以从`App`中删除，并用这个新的`Navigator`组件替换：
- en: '[PRE16]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We also need to check the value for the token in the `Navigator` component,
    as we don''t want to include the home screen when there is no token provided.
    The logic to log in is already present in the `UserContext` in the `context/UserContext.js`
    file and from the `Navigator` component, you can get the `user` object from this
    context:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要检查`Navigator`组件中令牌的值，因为我们不希望在未提供令牌时包含主页。登录的逻辑已经存在于`context/UserContext.js`文件中的`UserContext`中，并且可以从`Navigator`组件中获取此上下文中的`user`对象：
- en: '[PRE17]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we can get the `user` object from the context and add the logic to return
    the `Login` screen only when no token is present:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以从上下文中获取`user`对象，并添加逻辑以在不存在令牌时仅返回`Login`屏幕：
- en: '[PRE18]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you now refresh the application, you can see the `Login` component being
    displayed. You can log in with a username and password combination, which is `test`
    for both values. After logging in, we want to navigate to the home screen, for
    which we need to make a change in `screens/Login.js`:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在刷新应用程序，你可以看到正在显示的`Login`组件。你可以使用用户名和密码组合登录，这两个值都是`test`。登录后，我们希望导航到主页，为此我们需要在`screens/Login.js`中做出更改：
- en: '[PRE19]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When the value for `token` in the `user` object in the context changes, the
    user will now be navigated to the home screen. This can be shown by logging in
    with a username and password combination, which is `test` for both values. If
    you put in an incorrect value, you''ll see an error message, as visible here:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当上下文中`user`对象的`token`值发生变化时，用户现在将被导航到主页。这可以通过使用用户名和密码组合登录来显示，这两个值都是`test`。如果你输入了错误值，你会看到错误信息，就像这里所显示的：
- en: '![Figure 9.4 – Handling authentication](img/Figure_9.04_B17390.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4 – 处理认证](img/Figure_9.04_B17390.jpg)'
- en: Figure 9.4 – Handling authentication
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – 处理认证
- en: The token, however, isn't persisted as the context gets restored when you reload
    the application. For web applications, we could have used `localStorage` or `sessionStorage`.
    But for mobile applications, you'd need to use the `AsyncStorage` library from
    React Native to have persistent storage on both iOS and Android. On iOS, it will
    use native code blocks to give you the global persistent storage that `AsyncStorage`
    offers, while on devices running Android, either RocksDB- or SQLite-based storage
    will be used.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于在重新加载应用程序时上下文会被恢复，令牌并没有被持久化。对于Web应用程序，我们可以使用`localStorage`或`sessionStorage`。但对于移动应用程序，你需要使用React
    Native的`AsyncStorage`库来在iOS和Android上实现持久化存储。在iOS上，它将使用原生代码块为你提供`AsyncStorage`提供的全局持久化存储，而在运行Android的设备上，将使用基于RocksDB或SQLite的存储。
- en: Note
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more complex usages, it's recommended to use an abstraction layer on top
    of `AsyncStorage` as encryption isn't supported out of the box. Also, the use
    of a key-value system can give you performance issues if you want to store a lot
    of information for your application using `AsyncStorage`. Both iOS and Android
    will have set limitations on the amount of storage each application can use.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的用法，建议在`AsyncStorage`之上使用抽象层，因为默认情况下不支持加密。此外，如果你想要使用`AsyncStorage`存储大量信息，键值系统可能会给你带来性能问题。iOS和Android都会对每个应用程序可以使用的存储量设置限制。
- en: 'To add the persistence of the user token, we need to install the correct library
    from Expo and make changes to the context:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加用户令牌的持久性，我们需要从Expo安装正确的库并对上下文进行修改：
- en: 'We can install `AsyncStorage` from Expo by running the following command:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过运行以下命令从Expo安装`AsyncStorage`：
- en: '[PRE20]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To persist, the `AsyncStorage` token can be imported in the `UserContext` in
    the `context/UserContext.js` file:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了持久化，可以在`context/UserContext.js`文件中的`UserContext`中导入`AsyncStorage`令牌：
- en: '[PRE21]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the same file, it can be used to store the token in `AsyncStorage` after
    adding it to the context:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件中，在将其添加到上下文后，可以使用`AsyncStorage`来存储令牌：
- en: '[PRE22]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now that the token is persisted after it''s retrieved from the local API, it
    can also be retrieved from `AsyncStorage`. Therefore, we need to create a new
    function that retrieves the token and adds it to the context:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在令牌从本地API检索后已持久化，也可以从`AsyncStorage`中检索。因此，我们需要创建一个新的函数来检索令牌并将其添加到上下文中：
- en: '[PRE23]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, this function needs to be called from `App.js` when the application
    first renders. That way, you''ll get the token once the application starts or
    is refreshed and the authentication is persisted:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，当应用程序首次渲染时，需要从`App.js`调用此函数。这样，当应用程序启动或刷新时，你将获得令牌，并且认证会被持久化：
- en: '[PRE24]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The token is now persisted after logging in once, the application will skip
    the `Login` screen when it''s loaded, and there is a token present in `AsyncStorage`.
    However, as the token is persisted, we also need a way to log out and remove the
    token. In the `context/UserContext.js` file, the `logoutUser` function must be
    altered:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录一次后，令牌现在已持久化，当应用程序加载时将跳过`Login`屏幕，并且`AsyncStorage`中存在令牌。然而，由于令牌已持久化，我们还需要一种注销并删除令牌的方法。在`context/UserContext.js`文件中，必须修改`logoutUser`函数：
- en: '[PRE25]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When you now go to the `Profile` screen and click the `AsyncStorage` and the
    application state, we need to navigate the user back to the `Login` screen. Navigating
    between different nested navigators is demonstrated in the next part of this section.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当你现在转到`Profile`屏幕并点击`AsyncStorage`和应用程序状态时，我们需要将用户导航回`Login`屏幕。在不同嵌套导航器之间导航的演示将在本节的下一部分进行。
- en: Note
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To reload the application in Expo Go, you can shake the device when you're using
    an iOS or Android phone. By shaking the device, a menu with an option to reload
    the application will appear. In this menu, you must also select to enable **Fast
    refresh** to refresh the application automatically when you make changes to the
    code.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 iOS 或 Android 手机时，要重新加载 Expo Go 中的应用程序，你可以摇晃设备。通过摇晃设备，会出现一个菜单，其中包含重新加载应用程序的选项。在这个菜单中，你还必须选择启用
    **快速刷新**，以便在修改代码时自动刷新应用程序。
- en: Navigating between nested routes
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在嵌套路由之间导航
- en: 'In React Navigation, we can nest different navigators, such as the stack navigator
    that renders when the application starts and shows either the `Login` screen or
    the tab navigator. From a nested navigator, it isn''t possible to navigate to
    the parent navigator directly, as the `navigation` object for parent navigators
    cannot be accessed. But luckily, we can use a `ref` to create a reference to the
    "highest" possible navigator. From this reference, we could then access the `navigation`
    object, which we otherwise would have accessed using the `useNavigation` Hook.
    To do this for our application, we need to change the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React Navigation 中，我们可以嵌套不同的导航器，例如在应用程序启动时渲染的堆栈导航器，显示 `Login` 屏幕或标签导航器。从嵌套导航器中，无法直接导航到父导航器，因为无法访问父导航器的
    `navigation` 对象。但幸运的是，我们可以使用一个 `ref` 来创建对“最高”导航器的引用。从这个引用，我们可以访问 `navigation`
    对象，否则我们会使用 `useNavigation` 钩子来访问。为了在我们的应用程序中实现这一点，我们需要更改以下内容：
- en: 'Create a new file called `routing.js` with the following content:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `routing.js` 的新文件，并包含以下内容：
- en: '[PRE26]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This `navigationRef` can be imported in `App.js` and attached to the `NavigationContainer`
    in the `App` component:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个 `navigationRef` 可以在 `App.js` 中导入，并将其附加到 `App` 组件中的 `NavigationContainer`：
- en: '[PRE27]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `navigation` object for the stack navigator that contains the `Login` screen
    can now be accessed using this `ref` from the `Profile` screen in `screens/Profile.js`.
    Using the `reset` method, we can reset the entire `navigation` object and navigate
    to the `Login` screen:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含 `Login` 屏幕的堆栈导航器的 `navigation` 对象现在可以通过 `screens/Profile.js` 中的 `Profile`
    屏幕的此 `ref` 访问。使用 `reset` 方法，我们可以重置整个 `navigation` 对象并导航到 `Login` 屏幕：
- en: '[PRE28]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: With the authentication of the user handled, we can continue to add the functionalities
    to create a new post with an image in the next section.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 用户认证处理完毕后，我们可以在下一节继续添加创建带有图片的新帖子的功能。
- en: Using the camera with React Native and Expo
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 React Native 和 Expo 的相机
- en: Next to displaying the posts that were already added to the local API, you can
    also add a post yourself using a `POST` request and send text and an image as
    variables. Uploading images to your React Native application can be done by either
    using the camera to take an image or selecting an image from your camera roll.
    For both use cases, there are APIs available from React Native and Expo, or numerous
    packages that are installable from npm. For this project, you'll use the `ImagePicker`
    API from Expo, which combines these functionalities into just one component.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 除了显示已添加到本地 API 的帖子外，您还可以使用 `POST` 请求添加帖子，并发送文本和图片作为变量。将图片上传到您的 React Native
    应用程序可以通过使用相机拍照或从相册中选择图片来实现。对于这两种用例，React Native 和 Expo 都提供了 API，或者可以从 npm 安装大量可安装的包。对于这个项目，您将使用来自
    Expo 的 `ImagePicker` API，它将这些功能合并到一个组件中。
- en: 'To add the feature to create new posts to your social media application, the
    following changes need to be made to create the new screen to add the post:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要将创建新帖子功能添加到您的社交媒体应用程序中，需要对创建添加帖子的新屏幕进行以下更改：
- en: 'We need to install a library from Expo that allows us to access the camera
    roll on any device:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要从 Expo 安装一个库，以便我们可以在任何设备上访问相册：
- en: '[PRE29]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To use the camera roll, we need to request the `CAMERA_ROLL` permissions from
    the device, using the `ImagePicker` library we import in the `screens/PostForm.js`
    file:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用相册，我们需要使用在 `screens/PostForm.js` 文件中导入的 `ImagePicker` 库请求 `CAMERA_ROLL` 权限：
- en: '[PRE30]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This `uploadImage` function must then be added to the `TouchableOpacity` component
    in this same file:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，需要将这个 `uploadImage` 函数添加到同一文件中的 `TouchableOpacity` 组件：
- en: '[PRE31]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When you now press the button to add the post on this screen, a popup asking
    to give Expo Go permission to access your camera roll will be displayed. Also,
    note that on this page, we're not using a `View` component to wrap the screen
    but a `KeyboardAvoidingView` component. This makes sure that the components on
    this screen won't be hidden behind the keyboard when you're typing something.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您现在按下此屏幕上添加帖子的按钮时，将显示一个弹出窗口，要求给予 Expo Go 访问相册的权限。此外，请注意，在此页面上，我们不是使用 `View`
    组件来包装屏幕，而是使用 `KeyboardAvoidingView` 组件。这确保了当您在输入时，此屏幕上的组件不会被键盘隐藏。
- en: Note
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: You can't ask the user for permission a second time; instead, you'd need to
    manually grant the permission to the camera roll. To set this permission again,
    you should go to the settings screen on iOS and select the Expo application. On
    the next screen, you're able to add permission to access the camera.
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您不能再次请求用户权限；相反，您需要手动授予相册权限。要再次设置此权限，您应该在 iOS 的设置屏幕上选择 Expo 应用程序。在下一屏幕上，您能够添加访问相册的权限。
- en: 'When the user has granted permission to access the camera roll, you can call
    the `ImagePicker` API from Expo to open the camera roll. This is again an asynchronous
    function that takes some configuration fields, such as the aspect ratio. If the
    user has selected an image, the `ImagePicker` API will return an object containing
    the field URI, which is the URL to the image on the user''s device:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户已授予访问相册的权限时，您可以使用来自 Expo 的 `ImagePicker` API 打开相册。这同样是一个异步函数，它接受一些配置字段，例如宽高比。如果用户已选择了一张图片，`ImagePicker`
    API 将返回一个包含字段 URI 的对象，这是用户设备上图片的 URL：
- en: '[PRE32]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As the URL to the image is now stored in the local state to the `imageUrl`
    constant, you can display this URL in an `Image` component. This `Image` component
    takes `imageUrl` as the value for the source and has been set to use a 100% `width`
    and `height`:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于图像的 URL 现在存储在本地状态中的 `imageUrl` 常量中，您可以在 `Image` 组件中显示此 URL。此 `Image` 组件将 `imageUrl`
    作为源值，并已设置为使用 100% 的 `width` 和 `height`：
- en: '[PRE33]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'With these changes, the `AddPost` screen should look something like the following
    screenshots, which were taken from a device running iOS. There might be slight
    differences in the appearance of this screen if you''re using the Android Studio
    emulator or a device that runs Android:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些更改，`AddPost` 屏幕应该看起来像以下截图，这些截图是从运行 iOS 的设备上拍摄的。如果您使用的是 Android Studio 模拟器或运行
    Android 的设备，此屏幕的外观可能会有细微差异：
- en: '![Figure 9.5 – Using the camera roll'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.5 – 使用相册'
- en: '](img/Figure_9.05_B17390.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_9.05_B17390.jpg]'
- en: Figure 9.5 – Using the camera roll
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 – 使用相册
- en: These changes will make it possible to select a photo from your camera roll,
    but your users should also be able to upload an entirely new photo by using their
    camera. With the `ImagePicker` API from Expo, you can handle both scenarios, as
    this component also has a `launchCameraAsync` method. This asynchronous function
    will launch the camera and return it the same way as it returns a URL to the image
    from the camera roll.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改将使您能够从相册中选择照片，但您的用户也应该能够通过使用他们的相机上传全新的照片。使用来自 Expo 的 `ImagePicker` API，您可以处理这两种情况，因为该组件还有一个
    `launchCameraAsync` 方法。这个异步函数将启动相机，并以相同的方式返回相机相册中的图片的 URL。
- en: 'To add the functionality to directly use the camera on the user''s device to
    upload an image, you can make the following changes:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加直接使用用户设备上的相机上传图片的功能，您可以进行以下更改：
- en: 'When the user clicks on the image placeholder, the image roll will be opened
    by default. But you also want to give the user the option to use their camera.
    Therefore, a selection must be made between using the camera or the camera roll
    for uploading the image, which is a perfect use case for implementing an `ActionSheet`
    component. React Native and Expo both have an `ActionSheet` component; it''s advisable
    to use the one from Expo as it will use the native `UIActionSheet` component on
    iOS and a JavaScript implementation for Android:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户点击图像占位符时，默认情况下将打开图片库。但您也希望给用户选择使用相机的选项。因此，必须在使用相机或相册上传图片之间做出选择，这是一个实现 `ActionSheet`
    组件的完美用例。React Native 和 Expo 都有一个 `ActionSheet` 组件；建议使用来自 Expo 的组件，因为它将在 iOS 上使用本地的
    `UIActionSheet` 组件，在 Android 上使用 JavaScript 实现：
- en: '[PRE34]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'After this, we need to import `ActionSheetProvider` from `@expo/react-native-action-sheet`
    in our `App.js` file:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此之后，我们需要在 `App.js` 文件中导入 `ActionSheetProvider` 从 `@expo/react-native-action-sheet`：
- en: '[PRE35]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We wrap the navigator that contains the `PostForm` screen in this same file
    so that we can use the Hook to create the action sheet in that screen component:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将包含`PostForm`屏幕的导航器包裹在这个相同的文件中，这样我们就可以在该屏幕组件中使用Hook创建操作表：
- en: '[PRE36]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the `screens/PostForm.js` file, we can now import the Hook to create the
    action sheet from `@expo/react-native-action-sheet`:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`screens/PostForm.js`文件中，我们现在可以导入Hook来从`@expo/react-native-action-sheet`创建操作表：
- en: '[PRE37]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To add the action sheet, a function to open this `ActionSheet` must be added,
    and by using the `showActionSheetWithOptions` prop and the options, `ActionSheet`
    should be constructed. The options are `Camera`, `Camera roll`, and `Cancel`,
    and based on the index of the button that gets pressed, a different function should
    be called:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加操作表，必须添加一个打开此`ActionSheet`的函数，并使用`showActionSheetWithOptions`属性和选项来构建`ActionSheet`。选项是`相机`、`相册`和`取消`，根据按下的按钮的索引，应调用不同的函数：
- en: '[PRE38]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'When the `buttonIndex` is 0, the function to ask for permission to access the
    camera roll and select an image from it is called, but we also need a function
    to ask for camera permission and use the camera:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`buttonIndex`为0时，将调用请求访问相册并从中选择图片的函数，但我们还需要一个请求相机权限并使用相机的函数：
- en: '[PRE39]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Finally, the `openActionSheet` function to open the action sheet must be attached
    to the `TouchableOpacity` component:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，必须将打开操作表的`openActionSheet`函数附加到`TouchableOpacity`组件：
- en: '[PRE40]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Pressing the image placeholder will now open up the action sheet to select
    whether you want to use the camera roll or the camera for the image:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 按压图像占位符现在将打开操作表以选择您是想使用相册还是相机来选择图像：
- en: '![Figure 9.6 – The action sheet on iOS](img/Figure_9.06_B17390.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图9.6 – iOS上的操作表](img/Figure_9.06_B17390.jpg)'
- en: Figure 9.6 – The action sheet on iOS
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – iOS上的操作表
- en: Your post and image will now be displayed at the top of the `Posts` screen,
    meaning you've added the post successfully. In the final section of this chapter,
    we'll be exploring differences in styling between iOS and Android for this application.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您的帖子及图片现在将显示在`帖子`屏幕的顶部，这意味着您已成功添加了帖子。在本章的最后部分，我们将探讨该应用在iOS和Android之间在样式上的差异。
- en: Differences in styling for iOS and Android
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: iOS和Android的样式差异
- en: When styling your application, you might want to have different styling rules
    for iOS and Android, for example, to match the styling of the Android operating
    system better. There are multiple ways to apply different styling rules to different
    platforms; one of them is by using the `Platform` module, which can be imported
    from React Native.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计您的应用时，您可能希望为iOS和Android设置不同的样式规则，例如，以更好地匹配Android操作系统的样式。有多种方法可以将不同的样式规则应用于不同的平台；其中之一是通过使用`Platform`模块，该模块可以从React
    Native导入。
- en: 'This module has already been used in parts of this application, but let''s
    have a closer look at its workings by adding different icons to the tabs in the
    navigator tab depending on the operating system of the device:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块已经在本应用的某些部分中使用，但让我们通过在导航器的标签中根据设备的操作系统添加不同的图标来更详细地了解其工作原理：
- en: 'In `App.js`, we''ve already imported the `FontAwesome` icons from Expo, but
    for Android, we want to import `MaterialIcons` so they can be displayed instead.
    Also, we need to import `Platform` from React Native:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`App.js`中，我们已经从Expo导入了`FontAwesome`图标，但对于Android，我们希望导入`MaterialIcons`以便它们可以显示。此外，我们还需要从React
    Native导入`Platform`：
- en: '[PRE41]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'With the `Platform` module, you can check whether your mobile device is running
    iOS or Android by checking whether the value of `Platform.OS` is `ios` or `android`.
    The module must be used in the tab navigator, where we can make the distinction
    between the two platforms:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Platform`模块，您可以通过检查`Platform.OS`的值是否为`ios`或`android`来检查您的移动设备是否正在运行iOS或Android。该模块必须在标签导航器中使用，这样我们就可以在这两个平台之间做出区分：
- en: '[PRE42]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This will replace the `FontAwesome` icons on Android with `MaterialIcons`.
    This icon library uses different names for the icons, so we also need to make
    the following change:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将用`MaterialIcons`替换Android上的`FontAwesome`图标。此图标库为图标使用不同的名称，因此我们还需要进行以下更改：
- en: '[PRE43]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: When you're running the application on a mobile device with Android, the navigator
    tab will display the icons based on Material Design. If you're using an Apple
    device, it will display different icons; you can change the `Platform.OS === 'ios'`
    condition to `Platform.OS === 'android'` to add the Material Design icons to iOS
    instead. If you don't see any changes yet, try reloading the application on your
    device.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在 Android 移动设备上运行应用程序时，导航标签将显示基于 Material Design 的图标。如果您使用的是苹果设备，它将显示不同的图标；您可以将
    `Platform.OS === 'ios'` 条件更改为 `Platform.OS === 'android'`，以将 Material Design 图标添加到
    iOS。如果您还没有看到任何变化，请尝试在您的设备上重新加载应用程序。
- en: 'We can also use the `Platform` module directly inside a `StyleSheet`, for example,
    to change the color of the `Button` component in our application. By default,
    our `Button` component has a blue background color, but let''s change it to purple
    on Android. In `components/Button.js`, we need to import the `Platform` module:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以直接在 `StyleSheet` 中使用 `Platform` 模块，例如，更改我们应用程序中 `Button` 组件的颜色。默认情况下，我们的
    `Button` 组件具有蓝色背景，但让我们将其在 Android 上更改为紫色。在 `components/Button.js` 中，我们需要导入 `Platform`
    模块：
- en: '[PRE44]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We use the `select` method inside the creation of `StyleSheet`:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在创建 `StyleSheet` 的过程中使用 `select` 方法：
- en: '[PRE45]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Another component that can be styled differently between iOS and Android is
    the `PostItem` component. As mentioned before, there are multiple ways to do this;
    besides using the `Platform` module, you can also use platform-specific file extensions.
    Any file that has the `*.ios.js` or `*.android.js` extension will only be rendered
    on the platform specified in the extension. You can not only apply different styling
    rules but also have changes in functionality on different platforms:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可以在 iOS 和 Android 之间以不同方式样式的组件是 `PostItem` 组件。如前所述，有多种方法可以做到这一点；除了使用 `Platform`
    模块外，您还可以使用平台特定的文件扩展名。任何具有 `*.ios.js` 或 `*.android.js` 扩展名的文件都只会在扩展名指定的平台上渲染。您不仅可以应用不同的样式规则，还可以在不同的平台上进行功能上的更改：
- en: 'Rename the current `components/PostItem.js` file `components/PostItem.android.js`,
    and create a new file called `components/PostItem.ios.js` with the following contents:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前的 `components/PostItem.js` 文件重命名为 `components/PostItem.android.js`，并创建一个名为
    `components/PostItem.ios.js` 的新文件，其内容如下：
- en: '[PRE46]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This will change the order of the title and the image of a post on iOS, showing
    the title above the image. Also, we need to add the following styling to the end
    of this file:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将改变 iOS 上帖子标题和图片的顺序，显示标题在图片上方。此外，我们还需要在文件末尾添加以下样式：
- en: '[PRE47]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Instead of a border around this component on iOS, we want to display a shadow.
    To add this shadow, we need to alter the styles for the component:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 iOS 上，我们希望显示一个阴影而不是围绕此组件的边框。为了添加此阴影，我们需要更改组件的样式：
- en: '[PRE48]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Finally, we also need to change the dimensions of the image as we added a margin
    to the `container` style:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们还需要更改图像的尺寸，因为我们已经向 `container` 样式添加了边距：
- en: '[PRE49]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This will have the following result on iOS and Android, where the border has
    been replaced by a shadow:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在 iOS 和 Android 上产生以下结果，其中边框已被阴影取代：
- en: '![Figure 9.7 – Differences in styling on iOS and Android](img/Figure_9.07_B17390.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.7 – iOS 和 Android 上的样式差异](img/Figure_9.07_B17390.jpg)'
- en: Figure 9.7 – Differences in styling on iOS and Android
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7 – iOS 和 Android 上的样式差异
- en: Depending on your type of phone you can also rename this file from `components/PostItem.ios.js`
    to `components/PostItem.android.js` to see the same changes on Android.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的手机类型，您也可以将此文件从 `components/PostItem.ios.js` 重命名为 `components/PostItem.android.js`，以在
    Android 上看到相同的更改。
- en: That's it. With these final changes, you've created a React Native application
    that will run on both Android and iOS devices and has differences in styling between
    these two platforms.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。通过这些最终更改，您已经创建了一个将在 Android 和 iOS 设备上运行的 React Native 应用程序，并且这两个平台之间存在样式差异。
- en: Summary
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you've created a mobile social media application with React
    Native and Expo that uses a local API to send and receive data as well for authentication.
    To handle authentication, multiple types of navigators are combined. We've learned
    how to use the camera and the camera roll of a mobile device, after getting the
    permissions to use them. Also, the differences in styling between iOS and Android
    were explained.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经使用 React Native 和 Expo 创建了一个移动社交媒体应用程序，该应用程序使用本地 API 发送和接收数据，同时也用于身份验证。为了处理身份验证，结合了多种类型的导航器。在获得使用权限后，我们学习了如何使用移动设备的相机和相册。同时，还解释了
    iOS 和 Android 之间在样式上的差异。
- en: In completing this social media application, you've completed the final React
    Native chapter of this book and are now ready to start the very last chapter.
    In the last chapter, you'll be exploring another use case of React, which is VR.
    By combining React with Three.js, you can create 360-degree 2D and 3D experiences
    by writing React components.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这个社交媒体应用后，你已经完成了本书的最后一章React Native章节，现在可以开始阅读最后一章了。在最后一章中，你将探索React的另一个用例，即VR。通过将React与Three.js结合，你可以通过编写React组件来创建360度的2D和3D体验。
- en: Further reading
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Expo camera: [https://docs.expo.io/versions/latest/sdk/camera/](https://docs.expo.io/versions/latest/sdk/camera/)'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Expo相机：[https://docs.expo.io/versions/latest/sdk/camera/](https://docs.expo.io/versions/latest/sdk/camera/)
- en: 'Platform-specific code: [https://reactnative.dev/docs/platform-specific-code](https://reactnative.dev/docs/platform-specific-code)'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平台特定代码：[https://reactnative.dev/docs/platform-specific-code](https://reactnative.dev/docs/platform-specific-code)
