<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Developing a Web-Based VR Game</h1>
                </header>
            
            <article>
                
<p>The advent of <strong>virtual reality</strong> (<strong>VR</strong>) and <strong>augmented reality</strong> (<strong>AR</strong>) technologies is transforming how users interact with software and, in turn, the world around them. The possible applications of VR and AR are innumerable, and though the gaming industry has been an early adopter, these rapidly developing technologies have the potential to shift paradigms across multiple disciplines and industries.</p>
<p>In order to demonstrate how the MERN stack paired with React 360 can easily add VR capabilities to any web application, we will discuss and develop a dynamic, web-based VR game in this and the next chapter. <span>In this chapter, we will focus on defining the features of the VR game. Additionally, we will go over the key 3D VR concepts that are relevant to implementing this VR game, before developing the game view using React 360.</span></p>
<p><span>In this chapter, we will build the VR game using React 360 by covering the following topics:</span></p>
<ul>
<li style="font-weight: 400">Introducing the MERN VR Game</li>
<li style="font-weight: 400">Getting started with React 360</li>
<li style="font-weight: 400">Key concepts for developing 3D VR applications</li>
<li style="font-weight: 400">Defining game details</li>
<li style="font-weight: 400">Building the game view in React 360</li>
<li style="font-weight: 400">Bundling the React 360 code to integrate with the MERN skeleton</li>
</ul>
<p>After going over these topics, you will be able to apply 3D VR concepts and use React 360 to start building your own VR-based applications. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing the MERN VR Game</h1>
                </header>
            
            <article>
                
<p>The MERN VR Game web application will be developed by extending the MERN skeleton and integrating VR capabilities using React 360. It will be a dynamic, web-based VR game application, in which registered users can make their own games, and any visitor to the application can play these games. The home page of this application will list the games on the platform, as shown in the following screenshot:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-910 image-border" src="assets/a3d1a186-03b5-4201-82d2-0dccbfa3446f.png" style="width:50.92em;height:17.50em;"/></div>
<div class="packt_tip"><span>The code to implement features of the VR game using React 360 is available on GitHub at</span> <a href="https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter13/MERNVR" target="_blank">https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter13/MERNVR</a><span>.</span><span> You can</span><span> clone this code and run the application as you go through the code explanations in the rest of this chapter. </span></div>
<p><span>The features of the game will be simple enough to reveal the capabilities of introducing VR into a MERN-based application, without delving too deeply into the advanced concepts of React 360 that may be used to implement more complex VR features. In the next section, we will briefly define the features of a game in this application.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Game features</h1>
                </header>
            
            <article>
                
<p>Each game in the MERN VR Game application will essentially be a different VR world, where users can interact with 3D objects placed at different locations in a 360-degree panoramic world.</p>
<p>The gameplay will be similar to that of a scavenger hunt, and to complete each game, users will have to find and collect the 3D objects that are relevant to the clue or description for each game. This means the game world will contain some VR objects that can be collected by the player and some VR objects that cannot be collected, but that may be placed by makers of the game as props or hints. Finally, the game will be won when all of the relevant 3D objects have been collected by the user.</p>
<p>In this chapter, we will build these game features using React 360, focusing primarily on VR and React 360 concepts that will be relevant to implementing the features defined here. Once the game features are ready, we will discuss how the React 360 code can be bundled and prepared for integration with the MERN application code developed in <a href="17bbfed7-9867-4c8b-99fd-42581044a906.xhtml">Chapter 14</a><span>,</span> <em>Making the VR Game Dynamic Using MERN</em>. Before diving into the implementation of the game features with React 360, we will first look at setting up and getting started with React 360 in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting started with React 360</h1>
                </header>
            
            <article>
                
<p>React 360 makes it possible to build VR experiences using the same declarative and component-based approach as in React. The underlying technology of React 360 makes use of the Three.js JavaScript 3D engine to render 3D graphics with WebGL within any compatible web browser and also provides us with access to VR headsets with the Web VR API.</p>
<p>Though React 360 builds on top of React and the apps run in the browser, React 360 has a lot in common with React Native, thus making <span>React 360 </span>apps cross-platform. This also means that some concepts of React Native are also applicable to React 360. Covering all of the React 360 concepts is outside the scope of this book; therefore, we will focus on the concepts that are required to build the game and integrate them with the MERN stack web application. In the following section, we will begin by setting up a React 360 project, which will be extended on later in the chapter in order to build the game features.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up a React 360 project</h1>
                </header>
            
            <article>
                
<p>React 360 provides developer tools that make it easy to start developing a new React 360 project. The steps to get started are detailed in the official React 360 documentation, so we will only summarize the steps here and point out the files that are relevant to developing the game.</p>
<p>Since we already have Node and Yarn installed for the MERN applications, we can start by installing the React 360 CLI tool by running the following command in the command line:</p>
<pre><strong>yarn global add react-360-cli</strong></pre>
<p>Then, use this React 360 CLI tool to create a new application, and install the required dependencies by running the following command from the command line:</p>
<pre><strong>react-360 init MERNVR</strong></pre>
<p>This will add the new React 360 application with all of the necessary files into a folder, named <kbd>MERNVR</kbd>, in the current directory. Finally, we can go into this folder in the command line, and run the application using the following command:</p>
<pre><strong>yarn start</strong></pre>
<p>This <kbd>start</kbd> command will initialize the local development server, and the default React 360 application can be viewed in the browser at <kbd>http://localhost:8081/index.html</kbd>.</p>
<p>To update this starter application and implement our game features, we will modify code mainly in the <kbd>index.js</kbd> file with some minor updates in the <kbd>client.js</kbd> file, which can be found in the <kbd>MERNVR</kbd> project folder.</p>
<p>The default code in <kbd>index.js</kbd> for the starter application generated by React 360 should be as follows. Note that it <span>renders a</span> <span class="packt_screen">Welcome to React 360</span><span> text in a 360-degree world in the browser:</span></p>
<pre>import React from 'react'<br/>import { AppRegistry, StyleSheet, Text, View } from 'react-360'<br/><br/>export default class MERNVR extends React.Component {<br/>  render() {<br/>    return (<br/>      &lt;View style={styles.panel}&gt;<br/>        &lt;View style={styles.greetingBox}&gt;<br/>          &lt;Text style={styles.greeting}&gt;<br/>            Welcome to React 360<br/>          &lt;/Text&gt;<br/>        &lt;/View&gt;<br/>      &lt;/View&gt;<br/>    )<br/>  }<br/>}<br/><br/>const styles = StyleSheet.create({<br/>  panel: {<br/>    // Fill the entire surface<br/>    width: 1000,<br/>    height: 600,<br/>    backgroundColor: 'rgba(255, 255, 255, 0.4)',<br/>    justifyContent: 'center',<br/>    alignItems: 'center',<br/>  },<br/>  greetingBox: {<br/>    padding: 20,<br/>    backgroundColor: '#000000',<br/>    borderColor: '#639dda',<br/>    borderWidth: 2,<br/>  },<br/>  greeting: {<br/>    fontSize: 30,<br/>  }<br/>})<br/><br/>AppRegistry.registerComponent('MERNVR', () =&gt; MERNVR)</pre>
<p>This <kbd>index.js</kbd> file contains the application's content and the main code, including <span>the view and style code</span>. The code in <kbd>client.js</kbd> contains the boilerplate that connects the browser to the React application in <kbd>index.js</kbd>. <span>The default <kbd>client.js</kbd> file in the starter project folder should look like this:</span></p>
<pre>import {ReactInstance} from 'react-360-web'<br/><br/>function init(bundle, parent, options = {}) {<br/>  const r360 = new ReactInstance(bundle, parent, {<br/>    // Add custom options here<br/>    fullScreen: true,<br/>    ...options,<br/>  })<br/><br/>  // Render your app content to the default cylinder surface<br/>  r360.renderToSurface(<br/>    r360.createRoot('MERNVR', { /* initial props */ }),<br/>    r360.getDefaultSurface()<br/>  )<br/><br/>  // Load the initial environment<br/>  r360.compositor.setBackground(r360.getAssetURL('360_world.jpg'))<br/>}<br/><br/>window.React360 = {init}</pre>
<p>This code executes the React code defined in <kbd>index.js</kbd>, essentially creating a new instance of React 360 and loading the React code by attaching it to the DOM. </p>
<p>With this, the default React 360 starter project is set up and ready for extension. Before modifying this code to implement the game, in the next section, we will first look at some of the key concepts related to developing 3D VR experiences, in the context of how these concepts are applied with React 360.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Key concepts for developing the VR game</h1>
                </header>
            
            <article>
                
<p>Before creating VR content and an interactive 360-degree experience for the game, we will highlight some of the relevant aspects of the virtual world, and how React 360 can be used to work with these VR concepts. Given the wide range of possibilities in the VR space and the various options available with React 360, we need to identify and explore the specific concepts that will enable us to implement the interactive VR features we defined for the game. In the following sections, we will discuss the images that will make up the 360-degree world of the game, the 3D positioning system, along with the React 360 components, APIs, and input events that will be utilized to implement the game.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Equirectangular panoramic images</h1>
                </header>
            
            <article>
                
<p>The VR world for the game will be composed of a panoramic image that is added to the React 360 environment as a background image.</p>
<p>Panorama images are generally 360-degree images or spherical panoramas projected onto a sphere that completely surrounds the viewer. A common and popular format for 360-degree panorama images is the equirectangular format. React 360 currently supports mono and stereo formats for equirectangular images.</p>
<div class="packt_infobox">To learn more about the 360 images and video support in React 360, refer to the React 360 documentation <span>at </span><a href="https://facebook.github.io/react-360/docs/setup.html">facebook.github.io/react-360/docs/setup.html</a>.</div>
<p><span>The</span> photograph <span>shown here is an example of an equirectangular, 360-degree panoramic image. To set the world background for a game in MERN VR Game, we will use this kind of image:</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-911 image-border" src="assets/c413a1ae-2ec4-4546-9026-1b8a8dd83eae.jpg" style="width:34.75em;height:16.17em;"/></div>
<div class="packt_infobox">An equirectangular panoramic image consists of a single image with an aspect ratio of 2:1, where the width is twice the height. These images are created with a special 360-degree camera. An excellent source of equirectangular images is Flickr; you just need to search for the <kbd>equirectangular</kbd> tag.</div>
<p>Creating the game world by setting the background scene using an equirectangular image in a React 360 environment will make the VR experience immersive and transport the user to a virtual location. To enhance this experience and add 3D objects in this VR world effectively, we need to learn more about the layout and coordinate system relevant to the 3D space, which is discussed next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">3D position – coordinates and transforms</h1>
                </header>
            
            <article>
                
<p>We need to understand positioning and orientation in the VR world space, in order to place 3D objects at the desired locations and to make the VR experience feel more real. In the following sections, we will review the 3D coordinate system to help us to determine the location of a virtual object in the 3D space, and the transform capabilities in React 360, which will allow us to position, orient, and scale objects as required.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">3D coordinate system</h1>
                </header>
            
            <article>
                
<p>For mapping in a 3D space, React 360 uses a three-dimensional meter-based coordinate system that is similar to the OpenGL® 3D coordinate system. This allows individual components to be transformed, moved, or rotated in 3D in relation to the layout in their parent component.</p>
<div class="packt_infobox">The 3D coordinate system used in React 360 is a right-handed system. This means the positive <em>x</em> axis is to the right, the positive <em>y</em> axis points upward, and the positive <em>z</em> axis is backward. This provides a better mapping with common coordinate systems of the world space in assets and 3D world modeling. </div>
<p>If we try to visualize the 3D space, the user starts out at the center of the <strong>x-y-z</strong> axes pictured in the following diagram:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-912 image-border" src="assets/ba726573-d550-4e4b-9d27-8df91a3868d6.png" style="width:17.00em;height:16.83em;"/></div>
<p>The <strong><em>z </em></strong>axis points forward toward the user and the user looks out at the <strong>-z </strong>axis direction. The <strong>y </strong>axis runs up and down, whereas the <strong>x </strong>axis runs from side to side. The curved arrow in the diagram shows the direction of the positive rotation values.</p>
<p>While deciding where and how to place 3D objects in the 360-degree world, we will have to set values according to this 3D coordinate system. In the next section, we will demonstrate how to place 3D objects using React 360 by setting values in transform properties.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Transforming 3D objects</h1>
                </header>
            
            <article>
                
<p>The position and orientation of a 3D object will be determined by its transform properties, which will have values corresponding to the 3D coordinate system. In the following<span> screenshot</span>, the same 3D book object is placed in two different positions and orientations by changing the <kbd>transform</kbd> properties in the style attribute of a React 360 <kbd>Entity</kbd> component that is rendering the 3D object:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/228b2a5e-9d0e-48c0-a64f-693a2961e5eb.png" style="width:34.50em;height:18.42em;"/></div>
<p><span>This transform feature is based on the transform style used in React, which React 360 extends to be fully 3D, considering the <strong>x-y-z</strong> axes. </span>The <kbd>transform</kbd> properties are added to the <kbd>Entity</kbd> components in the <kbd>style</kbd> attribute as an array of keys and values in the following form:</p>
<pre>style={{ ...<br/>          transform: [ <br/>            {TRANSFORM_COMMAND: TRANSFORM_VALUE},<br/>         ...<br/>    ] <br/>... }}</pre>
<p>The transform commands and values that are relevant to the 3D objects to be placed in our games are <kbd>translate [x, y, z]</kbd>, with values in meters; <kbd>rotate [x, y, z]</kbd>, with values in degrees; and <kbd>scale</kbd>, to determine the size of the object across all axes. We can also utilize the <kbd>matrix</kbd> command instead, which accepts an array of 16 numbers representing the translation, rotation, and scale values.</p>
<div class="packt_tip">To learn more about the React 360 3D coordinates and transforms, refer to the React 360 documentation at <a href="https://facebook.github.io/react-360/docs/setup.html">facebook.github.io/react-360/docs/setup.html</a>.<a href="https://facebook.github.io/react-360/docs/setup.html"/></div>
<p>We will utilize these transform properties to position and orient 3D objects according to the 3D coordinate system while placing objects in the game world built using React 360. In the next section, we will go over the React 360 components that will allow us to build the game world.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">React 360 components</h1>
                </header>
            
            <article>
                
<p>React 360 provides a range of components that can be used out of the box to create the VR user interface for the game. This range consists of basic components available from React Native and also VR-specific components that will allow you to incorporate the interactive 3D objects in the VR game. In the following sections, we will summarize the specific components that will be used to build the game view and features, including core components, such as <kbd>View</kbd> and <kbd>Text</kbd>, and VR-specific components, such as <kbd>Entity</kbd> and <kbd>VrButton</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Core components</h1>
                </header>
            
            <article>
                
<p>The core components in React 360 include two of React Native's built-in components <span>–</span> the <kbd>Text</kbd> and <kbd>View</kbd> components. In the game, we will use these two components to add content to the game world. In the following sections, we will discuss these two core components.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">View</h1>
                </header>
            
            <article>
                
<p>The <kbd>View</kbd> component is the most fundamental component for building a user interface in React Native, and it maps directly to the native view equivalent on whatever platform React Native is running on. In our case, since the application will render in the browser, it will map to a <kbd>&lt;div&gt;</kbd> element in the browser. The <kbd>View</kbd> component can be added as follows:</p>
<pre><strong>&lt;View&gt;</strong><br/>  &lt;Text&gt;Hello&lt;/Text&gt;<br/><strong>&lt;/View&gt;</strong></pre>
<p>The <kbd>View</kbd> component is typically used as a container for other components; it can be nested inside other views and can have zero-to-many children of any type.</p>
<p>We will use <kbd>View</kbd> components to hold the game world view and add 3D object entities and text to the game. Next, we will look at the <kbd>Text</kbd> component, which will allow us to add text to the view.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Text</h1>
                </header>
            
            <article>
                
<p>The <kbd>Text</kbd> component is a React Native component for displaying text, and we will use it to render strings in a 3D space by placing <kbd>Text</kbd> components inside <kbd>View</kbd> components, as shown in the following code:</p>
<pre>&lt;View&gt;<br/>      <strong>&lt;Text&gt;</strong>Welcome to the MERN VR Game<strong>&lt;/Text&gt;</strong><br/>&lt;/View&gt;</pre>
<p>We will compose the game world using these two React Native components, along with other React 360 components to integrate VR features into the game. In the next section, we will go over the React 360 components that will let us add interactive VR objects in the game world. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Components for the 3D VR experience</h1>
                </header>
            
            <article>
                
<p>React 360 provides a set of its own components to create the VR experience. Specifically, we will use the <kbd>Entity</kbd> component to add 3D objects and a <kbd>VrButton</kbd> component to capture clicks from the user. We will discuss the <kbd>Entity</kbd> and <kbd>VrButton</kbd> components in the following sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Entity</h1>
                </header>
            
            <article>
                
<p>In order to add 3D objects to the game world, we will use the <kbd>Entity</kbd> component, which allows us to render 3D objects in React 360. The <kbd>Entity</kbd> component can be added in the view as follows:</p>
<pre>&lt;Entity<br/>  source={{<br/>           obj: {uri: "http://linktoOBJfile.obj "},<br/>           mtl: {uri: "http://linktoMTLfile.obj "}<br/>        }}<br/>/&gt;</pre>
<p>Files containing the specific 3D object's information are added to the <kbd>Entity</kbd> component using a <kbd>source</kbd> attribute. The <kbd>source</kbd> attribute takes an object of key-value pairs to map resource file types to their locations. React 360 supports the Wavefront OBJ file format, which is a common representation for 3D models. So, in the <kbd>source</kbd> attribute, the <kbd>Entity</kbd> component supports the following keys:</p>
<ul>
<li style="font-weight: 400"><kbd>obj</kbd>: The location of an OBJ-formatted model</li>
<li style="font-weight: 400"><kbd>mtl</kbd>: The location of an MTL-formatted material (the companion to OBJ)</li>
</ul>
<p>The values for the <kbd>obj</kbd> and <kbd>mtl</kbd> properties point to the location of these files and can be static strings, <kbd>asset()</kbd> calls, <kbd>require()</kbd> statements, or URI strings.</p>
<div class="packt_infobox">OBJ (or .OBJ) is a geometry definition file format that was first developed by Wavefront Technologies. It is a simple data format that represents 3D geometry as a list of vertices and texture vertices. OBJ coordinates have no units, but OBJ files can contain scale information in a human-readable comment line. You can learn more about this format at <a href="http://paulbourke.net/dataformats/obj/">paulbourke.net/dataformats/obj/</a>.</div>
<div class="packt_infobox"><span>MTL (or .MTL)</span> are material library files that contains <span>one or more material definitions, each of which includes the color, texture, and reflection map of individual materials. These are applied to the surfaces and vertices of objects. You can learn more about this format at </span><a href="http://paulbourke.net/dataformats/mtl/"><span>paulbourke.net/dataformats/mtl/</span></a>.</div>
<p>The <kbd>Entity</kbd> component also takes <kbd>transform</kbd> property values in the <kbd>style</kbd> attribute, so the objects can be placed at the desired positions and orientations in the 3D world space. </p>
<p>In our MERN VR Game application, makers will add URLs pointing to the VR object files (both <kbd>.obj</kbd> and <kbd>.mtl</kbd>) for each of their <kbd>Entity</kbd> objects in a game, and also specify the <kbd>transform</kbd> property values to indicate where and how the 3D objects should be placed in the game world.</p>
<div class="packt_tip">A good source of 3D objects is <a href="https://clara.io/" target="_blank">https://clara.io/</a>, with multiple file formats available for download and use.</div>
<p>The <kbd>Entity</kbd> component will render 3D objects in the 3D world space. In order to make these objects interactive, we need to use the <kbd>VrButton</kbd> component, which is discussed in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">VrButton</h1>
                </header>
            
            <article>
                
<p>The <kbd>VrButton</kbd> component in React 360 will help us to implement a simple, button-style <kbd>onClick</kbd> behavior for the objects and <kbd>Text</kbd> buttons that will be added to the game. A <kbd>VrButton</kbd> component is not visible in the view by default and will only act as a wrapper to capture events, but it can be styled in the same way as a <kbd>View</kbd> component, as shown in the following code:</p>
<pre>&lt;<strong>VrButton</strong> onClick={this.clickHandler}&gt;<br/>        &lt;View&gt;<br/>            &lt;Text&gt;Click me to make something happen!&lt;/Text&gt;<br/>        &lt;/View&gt;<br/> &lt;/<strong>VrButton</strong>&gt;</pre>
<p>This component is a helper for managing click-type interactions from the user across different input devices. Input events that will trigger the click event include a spacebar press on the keyboard, a left-click on the mouse, and a touch on the screen.</p>
<p>The <kbd>Entity</kbd> and <kbd>VrButton</kbd> components from React 360 will allow us to render interactive 3D objects in the game world. To integrate other VR functionalities such as setting the background scene and playing audio in the game world, we will explore relevant options from the React 360 API in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The React 360 API</h1>
                </header>
            
            <article>
                
<p>Besides the React 360 components discussed in the previous section, we will utilize the APIs provided by React 360 to implement functionality such as setting the background scene, playing audio, dealing with external links, adding styles, capturing the current orientation of the user's view, and using static asset files. In the following sections, we will explore the <kbd>Environment</kbd> API, the <kbd>Audio</kbd> and <kbd>Location</kbd> native modules, the <kbd>StyleSheet</kbd> API, the <kbd>VrHeadModel</kbd> module, and the asset specification options. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Environment</h1>
                </header>
            
            <article>
                
<p>In the game, we will set the world or background scene with equirectangular panoramic images. We will use the <kbd>Environment</kbd> API from React 360 to change this background scene dynamically from the React code using its <kbd>setBackgroundImage</kbd> method. This method can be used as follows:</p>
<pre>Environment.setBackgroundImage( {uri: 'http://linktopanoramaimage.jpg' } )</pre>
<p>This method sets the current background image with the resource at the specified URL. When we integrate the React 360 game code with the MERN stack containing the game application backend, we can use this to set the game world image dynamically using image links provided by the user. In the next section, we will explore native modules that will allow us to play audio in this rendered scene in the browser, and provide access to the browser location.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Native modules</h1>
                </header>
            
            <article>
                
<p>Native modules in React 360 provide us with the ability to access functionality that is only available in the main browser environment. In the game, we will use <kbd>AudioModule</kbd> in <kbd>NativeModules</kbd>, to play sounds in response to user activity, and the <kbd>Location</kbd> module, to give us access to <kbd>window.location</kbd> in the browser to handle external links. These modules can be accessed in <kbd>index.js</kbd>, as follows:</p>
<pre>import {<br/>    ...<br/>  <strong>NativeModules</strong><br/>} from 'react-360'<br/><br/>const { <strong>AudioModule, Location</strong> } = <strong>NativeModules</strong></pre>
<p>We can use these imported modules in the code to manipulate the audio and location URL in the browser. In the following sections, we will explore how these modules can be used to implement the features of the game.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">AudioModule</h1>
                </header>
            
            <article>
                
<p>When the user interacts with the 3D objects in the game, we will play sounds based on whether the object can be collected or not, and also whether the game has been completed. The <kbd>AudioModule</kbd> in <kbd>NativeModules</kbd> allows us to add sound to the VR world as background environmental audio, one-off sound effects, and spatial audio. In our game, we will use environmental audio and one-off sound effects:</p>
<ul>
<li style="font-weight: 400"><strong>Environmental audio</strong>: To play audio on loop and set the mood when the game is successfully completed, we will use the <kbd>playEnvironmental</kbd> method, which takes an audio file path as the <kbd>source</kbd> attribute, and the <kbd>loop</kbd> option as a <kbd>playback</kbd> parameter, as shown in the following code:</li>
</ul>
<pre style="padding-left: 60px">AudioModule.playEnvironmental({<br/>    source: asset('happy-bot.mp3'),<br/>    loop: true<br/>})</pre>
<ul>
<li><strong>Sound effects</strong>: To play a single sound once when the user clicks on 3D objects, we will use the <kbd>playOneShot</kbd> method that takes an audio file path as the <kbd>source</kbd> attribute, as shown in the following code:</li>
</ul>
<pre style="padding-left: 60px">AudioModule.playOneShot({<br/>    source: asset('clog-up.mp3'),<br/>})</pre>
<p>The <kbd>source</kbd> attribute in the options passed to <kbd>playEnvironmental</kbd> and <kbd>playOneShot</kbd> takes a resource file location to load the audio. <span>It can be an</span> <kbd>asset()</kbd> <span>statement or a resource URL declaration in the form of </span><kbd>{uri: 'PATH'}</kbd><span>.</span></p>
<p>We will call these <kbd>AudioModule</kbd> methods to play specified audio files as needed from the game implementation code. In the next section, we will look at how we can use the <kbd>Location</kbd> module, which is another native module in React 360.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Location</h1>
                </header>
            
            <article>
                
<p>After we integrate the React 360 code containing the game with the MERN stack containing the game application backend, the VR game will be launched from the MERN server at a declared route containing the specific game's ID. Then, once a user completes a game, they will also have the option to leave the VR space and go to a URL containing a list of other games. To handle these incoming and outgoing app links in the React 360 code, we will utilize the <kbd>Location</kbd> module in <kbd>NativeModules</kbd>.</p>
<p>The <kbd>Location</kbd> module is essentially the <kbd>Location</kbd> object returned by the <span>read-only</span> <kbd>window.location</kbd> property in the browser. We will use the <kbd>replace</kbd> method and the <kbd>search</kbd> <span>property</span> in the <kbd>Location</kbd> object to implement features related to external links. We will handle outgoing and incoming links as follows:</p>
<ul>
<li><span><strong>Handling outgoing links</strong>: When we want to direct the user out of the VR application to another link, we can use the</span> <kbd>replace</kbd> <span>method in <kbd>Location</kbd>, as shown in the following code:</span></li>
</ul>
<pre style="padding-left: 60px"><strong>Location.replace</strong>(url)</pre>
<ul>
<li><strong>Handling incoming links</strong>: When the React 360 app is launched from an external URL and after the registered component mounts, we can access the URL and retrieve its query string part using the <kbd>search</kbd> property in <kbd>Location</kbd>, as shown in the following code.</li>
</ul>
<pre style="padding-left: 60px">componentDidMount = () =&gt; {<br/>   let queryString = <strong>Location.search</strong><br/>   let gameId = queryString.split('?id=')[1]<br/>}</pre>
<p>For the purpose of integrating this React 360 component with MERN VR Game, and dynamically loading game details, we will capture this initial URL to parse the game ID from a query parameter and then use it to make a read API call to the MERN application server. This implementation is elaborated further in <a href="17bbfed7-9867-4c8b-99fd-42581044a906.xhtml">Chapter 11</a>, <em>Making the VR Game Dynamic Using MERN</em>.</p>
<p>Besides using these native modules from the React 360 API, we will also use the StyleSheet API to add styling to the components rendered to make the game view. We will demonstrate how to use the StyleSheet API in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">StyleSheet</h1>
                </header>
            
            <article>
                
<p>The StyleSheet API from React Native can also be used in React 360 to define several styles in one place rather than adding styles to individual components. The styles can be defined using StyleSheet, as shown in the following code:</p>
<pre>const styles = StyleSheet.create({<br/>  subView: {<br/>    width: 10,<br/>    borderColor: '#d6d7da',<br/>  },<br/>  text: {<br/>    fontSize: '1em',<br/>    fontWeight: 'bold',<br/>  }<br/>})</pre>
<p>These style objects defined using <kbd>StyleSheet.create</kbd> can be added to components as required, as shown in the following code:</p>
<pre>&lt;View style={<strong>styles.subView</strong>}&gt;<br/>  &lt;Text style={<strong>styles.text</strong>}&gt;hello&lt;/Text&gt;<br/>&lt;/View&gt;</pre>
<p>This will apply the CSS styles to the <kbd>View</kbd> and <kbd>Text</kbd> components accordingly.</p>
<div class="packt_infobox">The default distance units for CSS properties, such as width and height, are in meters when mapping to 3D space in React 360, whereas the default distance units are in pixels for 2D interfaces in React Native.</div>
<p class="mce-root">We will use StyleSheet in this way to define styles for the components that will make up the game view. In the next section, we will discuss the <kbd>VrHeadModel</kbd> module in React 360, which will allow us to figure out where the user is currently looking. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">VrHeadModel</h1>
                </header>
            
            <article>
                
<p><kbd>VrHeadModel</kbd> is a utility module in React 360 that simplifies the process of obtaining the current orientation of the headset. Since the user is moving around in a VR space, when the desired feature requires that an object or piece of text should be placed in front of or with respect to the user's current orientation, it becomes necessary to know exactly <span>where </span>the user is currently gazing.</p>
<p>In MERN VR Game, we will use this to show the <span class="packt_screen">game completed</span> message to the user in front of their view, no matter where they end up turning to from their initial position. For example, the user may be looking up or down when collecting the final object, and the completed message should pop up wherever the user is gazing.</p>
<p><span>To implement this, we will retrieve the current head matrix as an array of numbers using </span><kbd>getHeadMatrix()</kbd> <span>from</span> <kbd>VrHeadModel</kbd><span>, and set it as a value for the</span> <kbd>transform</kbd> <span>property in the style attribute of the</span> <kbd>View</kbd> component <span>containing the game completed message.</span></p>
<p><span>This will render the message at the location where the user is currently gazing. We will see the usage of this <kbd>getHeadMatrix()</kbd></span> function <span>later in the chapter, </span><span>in the</span> <em>Building the game view in React 360 </em><span>section</span><span>. In the next section, we will discuss how static assets can be loaded in React 360. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Loading assets</h1>
                </header>
            
            <article>
                
<p>In order to load any static asset files such as image or audio files in the code, we can utilize the <kbd>asset</kbd> method in React 360. This <kbd>asset()</kbd> functionality in React 360 allows us to retrieve external resource files, including audio and image files.</p>
<p>For example, we will place the sound audio files for the game in the <kbd>static_assets</kbd> folder, to be retrieved using <kbd>asset()</kbd> for each audio added to the game, as shown in the following code:</p>
<pre>AudioModule.playOneShot({<br/>    source: <strong>asset('collect.mp3')</strong>,<br/>})</pre>
<p>This will load the audio file to be played in the call to <kbd>playOneShot</kbd>. </p>
<p>With these different APIs and modules available in React 360, we will integrate different features <span>for the VR game</span> such as setting the background scene, playing audio, adding styles, loading static files, and retrieving the user orientation. In the next section, we will look at some of the input events available in React 360 that will allow us to make the game interactive.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">React 360 input events</h1>
                </header>
            
            <article>
                
<p>In order to make the game interface interactive, we will utilize some of the input event handlers exposed in React 360. Input events are collected from mouse, keyboard, touch, and gamepad interactions, and also with the <kbd>gaze</kbd> button click on a VR headset.</p>
<p>The specific input events we will work with are the <kbd>onEnter</kbd>, <kbd>onExit</kbd>, and <kbd>onClick</kbd> events, as discussed in the following list:</p>
<ul>
<li><kbd>onEnter</kbd>: <span>This event is fired whenever the platform cursor begins intersecting with a component. We will capture this event for the VR objects in the game, so the objects can start rotating around the <em>y</em> axis when the platform cursor enters the specific object.</span></li>
<li><kbd>onExit</kbd>: <span>This event</span> is fired whenever t<span>he platform cursor stops intersecting with a component. It has the same properties as the <kbd>onEnter</kbd> event and we will use it to stop rotating the VR object just exited.</span></li>
<li><kbd>onClick</kbd>: <span>The <kbd>onClick</kbd> ev</span>ent is used wi<span>th the <kbd>VrButton</kbd> component, and is fired when there is click interaction with <kbd>VrButton</kbd>. We will use this to set click event handlers on the VR objects, and also on the game complete message to redirect the user out of the VR application to a link containing a list of games.</span></li>
</ul>
<p>These events will allow us to add actions to the game, which happens when the user does something.</p>
<p>While implementing the VR game, we will apply 3D world concepts to determine how to set the game world with equirectangular panoramic images, and position VR objects in this world based on the 3D coordinate system. We will use React 360 components such as <kbd>View</kbd>, <kbd>Text</kbd>, <kbd>Entity</kbd>, and <kbd>VrButton</kbd> to render the VR game view. We can also use available React 360 APIs to load audio and external URLs for the VR game in the browser environment. Finally, we can utilize available React 360 events that capture user interactions to make the VR game interactive. With the VR-related concepts, React 360 components, APIs, modules, and events discussed in this section, we are ready to define the specific game data details before we start implementing the complete VR game using these concepts. In the next section, we will go over the game data structure and details.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining game details</h1>
                </header>
            
            <article>
                
<p>Each game in MERN VR Game will be defined in a common data structure that the React 360 application will also adhere to when rendering the individual game details. In the following sections, we will discuss the data structure for capturing a game's details, and then highlight the difference between using static game data and dynamically loaded game data.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Game data structure</h1>
                </header>
            
            <article>
                
<p>The game data will consist of details such as the game's name, a URL pointing to the location of the equirectangular image for the game world, and two arrays containing details for each VR object to be added to the game world. The following list indicates the fields corresponding to the game data attributes:</p>
<ul>
<li style="font-weight: 400"><kbd>name</kbd>: A string representing the name of the game</li>
<li style="font-weight: 400"><kbd>world</kbd>: A string with the URL pointing to the equirectangular image either hosted on cloud storage, CDNs, or stored on MongoDB</li>
<li style="font-weight: 400"><kbd>answerObjects</kbd>: An array of JavaScript objects containing details of the VR objects that can be collected by the player</li>
<li style="font-weight: 400"><kbd>wrongObjects</kbd>: An array of<span> JavaScript</span> objects containing details of the other VR objects to be placed in the VR world that cannot be collected <span>by the player</span></li>
</ul>
<p>These details will define each game in the MERN VR Game application. The arrays containing the VR object details will store properties of each object to be added to the 3D world in the game. In the following section, we will go over the details representing a VR object in these arrays. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Details of VR objects</h1>
                </header>
            
            <article>
                
<p>The two arrays in the game data structure will store details of the VR objects to be added in the game world. The <kbd>answerObjects</kbd> array will contain details of the 3D objects that can be collected, and the <kbd>wrongObjects</kbd> array will contain details of 3D objects that cannot be collected. Each object will contain links to the 3D data resource files and <kbd>transform</kbd> style property values. In the following list, we will go over these specific details to be stored for each object:</p>
<ul>
<li><strong>OBJ and MTL links</strong>: The 3D data information resources for the VR objects will be added to the <kbd>objUrl</kbd> <span>and</span> <kbd>mtlUrl</kbd><span> attributes. These attributes will contain the following values:</span>
<ul>
<li><kbd>objUrl</kbd>: The link to the <kbd>.obj</kbd> file for the 3D object</li>
<li><kbd>mtlUrl</kbd>: The link to the accompanying <kbd>.mtl</kbd> file</li>
</ul>
</li>
</ul>
<p style="padding-left: 60px">The <kbd>objUrl</kbd> and <kbd>mtlUrl</kbd> links may point to files either hosted on cloud storage, CDNs, or stored on MongoDB. For MERN VR Game, we will assume that makers will add URLs to their own hosted OBJ, MTL, and <span>equirectangular</span> image files.</p>
<ul>
<li><strong>Translation values</strong>: The position of the VR object in the 3D space will be defined with the <kbd>translate</kbd> <span>values in the following attributes:</span>
<ul>
<li><kbd>translateX</kbd>: The translation value of the object along the <em>x</em> axis</li>
<li><kbd>translateY</kbd>: The translation value of the object along the <em>y</em> axis</li>
<li><kbd>translateZ</kbd>: The translation value of the object along the <em>z</em> axis</li>
</ul>
</li>
</ul>
<p style="padding-left: 60px">All translation values are numbers in meters.</p>
<ul>
<li><strong>Rotation values</strong>: The orientation of the 3D object will be defined with the <kbd>rotate</kbd> <span>values in the following keys:</span>
<ul>
<li><kbd>rotateX</kbd>: The rotation value of the object around the <em>x</em> axis; in other words, turning the object up or down</li>
<li><kbd>rotateY</kbd>: <span>The r</span>otation value of the object around the <em>y</em> axis that would turn the object left or right</li>
<li><kbd>rotateZ</kbd>: <span>The r</span>otation value of the object around the <em>z</em> axis, making the object tilt forward or backward</li>
</ul>
</li>
</ul>
<p style="padding-left: 60px">All rotation values are in numbers or string representations of a number in degrees.</p>
<ul>
<li><strong>Scale value</strong>: The <kbd>scale</kbd> <span>value will define the relative size and appearance of the 3D object in the 3D environment:</span>
<ul>
<li><kbd>scale</kbd>: A number value that defines uniform scale across all axes</li>
</ul>
</li>
<li><strong>Color</strong>: If the 3D object's material texture is not provided in an MTL file, a color value can be defined to set the default color of the object in the <kbd>color</kbd> <span>attribute:</span>
<ul>
<li><kbd>color</kbd>: A string value representing color values allowed in CSS</li>
</ul>
</li>
</ul>
<p>These attributes will define the details of each VR object to be added to the game.</p>
<p>With this game data structure capable of holding the details of the game and its VR objects, we can implement the game in React 360 accordingly with sample data values. In the next section, we will look at sample game data and distinguish between setting game data statically in contrast to loading it dynamically for different games.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Static data versus dynamic data</h1>
                </header>
            
            <article>
                
<p>While integrating the game developed using React 360 with the MERN-based application in the next chapter, we will update the React 360 code to fetch game data dynamically from the backend database. This will render the React 360 game view with different games stored in the database. For now, we will start developing the game features here with dummy game data that is set in component state. The sample game data will be set as follows, using the defined game data structure:</p>
<pre>game: {<br/>  name: 'Space Exploration',<br/>  world: 'https://s3.amazonaws.com/mernbook/vrGame/milkyway.jpg',<br/>  answerObjects: [<br/>    { <br/>      objUrl: 'https://s3.amazonaws.com/mernbook/vrGame/planet.obj',<br/>      mtlUrl: 'https://s3.amazonaws.com/mernbook/vrGame/planet.mtl',<br/>      translateX: -50,<br/>      translateY: 0,<br/>      translateZ: 30,<br/>      rotateX: 0,<br/>      rotateY: 0,<br/>      rotateZ: 0,<br/>      scale: 7,<br/>      color: 'white'<br/>    }<br/>  ],<br/>  wrongObjects: [<br/>    { <br/>      objUrl: 'https://s3.amazonaws.com/mernbook/vrGame/tardis.obj',<br/>      mtlUrl: 'https://s3.amazonaws.com/mernbook/vrGame/tardis.mtl',<br/>      translateX: 0,<br/>      translateY: 0,<br/>      translateZ: 90,<br/>      rotateX: 0,<br/>      rotateY: 20,<br/>      rotateZ: 0,<br/>      scale: 1,<br/>      color: 'white'<br/>    }<br/>  ]<br/>}</pre>
<p><span>This game object holds the details of a sample game including the name, a link to the 360 world image, and two object arrays with one 3D object detailed in each array. For initial development purposes, this sample game data can be set in state to be rendered in the game view. Using this game structure and data, in the next section, we will implement the game features in React 360.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building the game view in React 360</h1>
                </header>
            
            <article>
                
<p>We will apply the React 360 concepts and use the game data structure to implement the game features for each game in the MERN VR Game application. For these implementations, we will update the default starter code generated in the <kbd>index.js</kbd> and <kbd>client.js</kbd> files within the initiated React 360 project.</p>
<p>For a working version of the game, we will start with the <kbd>MERNVR</kbd> component's state that was initialized using the sample game data from the previous section.</p>
<p>The <kbd>MERNVR</kbd> component is defined in <kbd>index.js</kbd>, and the code will be updated with the game data in state, as shown in the following code:</p>
<p><kbd>/MERNVR/index.js</kbd></p>
<pre>export default class MERNVR extends React.Component {<br/><br/>    constructor() {<br/>        super()<br/>        this.state = {<br/>                <strong>game: sampleGameData</strong><br/>                ...<br/>            }<br/>    }<br/><br/>...<br/>}</pre>
<p>This will make the sample game's details available for building the rest of the game features. In the following sections, we will update the code in the <kbd>index.js</kbd> and <kbd>client.js</kbd> files to first mount the game world, <span>define the CSS styles,</span> and load the 360-degree environment for the game. Then, we will add the 3D VR objects to the game, make these objects interactive, and implement behavior that indicates the game is completed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating client.js and mounting to Location</h1>
                </header>
            
            <article>
                
<p>The default code in <kbd>client.js</kbd> attaches the mount point declared in <kbd>index.js</kbd> to the default <kbd>Surface</kbd> in the React 360 app, where <kbd>Surface</kbd> is a cylindrical layer that is used for placing a 2D user interface. In order to use the 3D meter-based coordinate system for a layout in 3D space, we need to mount to a <kbd>Location</kbd> object instead of a <kbd>Surface</kbd>. So, we will update <kbd>client.js</kbd> to replace the <kbd>renderToSurface</kbd> with a <kbd>renderToLocation</kbd>, as highlighted in the following code:</p>
<p><kbd><span>/MERNVR/client.js</span></kbd></p>
<pre>  r360.<strong>renderToLocation</strong>(<br/>    r360.createRoot('MERNVR', { /* initial props */ }),<br/>    <strong>r360.getDefaultLocation()</strong><br/>  )</pre>
<p>This will mount our game view to a React 360 <kbd>Location</kbd>.</p>
<div class="packt_tip">You can also customize the initial background scene by updating the <kbd>r360.compositor.setBackground(<strong>r360.getAssetURL('360_world.jpg')</strong>)</kbd> code in <kbd>client.js</kbd> to use your desired image.</div>
<p>With this update added in <kbd>client.js</kbd>, we can move on to updating the code in <kbd>index.js</kbd>, which will contain our game functionalities. In the next section, we will start by defining CSS styles for the elements to be rendered in the game view.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining styles with StyleSheet</h1>
                </header>
            
            <article>
                
<p>In <kbd>index.js</kbd>, we will update the default styles generated in the initial React 360 project to add our own CSS rules. In the <kbd>StyleSheet.create</kbd> call, we will define style objects to be used with the components in the game, as shown in the following code:</p>
<p><kbd><span>/MERNVR/index.js</span></kbd></p>
<pre>const styles = StyleSheet.create({<br/>                 completeMessage: {<br/>                      margin: 0.1,<br/>                      height: 1.5,<br/>                      backgroundColor: 'green',<br/>                      transform: [ {translate: [0, 0, -5] } ]<br/>                 },<br/>                 congratsText: {<br/>                      fontSize: 0.5,<br/>                      textAlign: 'center',<br/>                      marginTop: 0.2<br/>                 },<br/>                 collectedText: {<br/>                      fontSize: 0.2,<br/>                      textAlign: 'center'<br/>                 },<br/>                 button: {<br/>                      margin: 0.1,<br/>                      height: 0.5,<br/>                      backgroundColor: 'blue',<br/>                      transform: [ { translate: [0, 0, -5] } ]<br/>                 },<br/>                 buttonText: {<br/>                      fontSize: 0.3,<br/>                      textAlign: 'center'<br/>                 }<br/>              }) </pre>
<p>For the game features implemented in this book, we are keeping the styling simple with CSS declared for only the text and button to be displayed when the game is completed. In the next section, we will look at how to load the 360 panoramic image that will represent the 3D world for each game.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">World background</h1>
                </header>
            
            <article>
                
<p>In order to set the game's 360-degree world background, we will update the current background scene using the <kbd>setBackgroundImage</kbd> method from the <kbd>Environment</kbd> API. We will call this inside the <kbd>componentDidMount</kbd> of the <kbd>MERNVR</kbd> component defined in <kbd>index.js</kbd>, as shown in the following code:</p>
<p><kbd><span>/MERNVR/index.js</span></kbd></p>
<pre>componentDidMount = () =&gt; {<br/>    Environment.setBackgroundImage(<br/>      {uri: this.state.game.world}<br/>    )<br/>}</pre>
<p>This will replace the default 360-degree background in the starter React 360 project with our sample game's world image fetched from cloud storage. If you are editing the default React 360 application and have it running, refreshing the <kbd>http://localhost:8081/index.html</kbd> link in the browser should show an outer space background, which you can pan across using the mouse:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ee255992-346f-4421-97dd-0faf23675ac0.png" style="width:22.42em;height:10.75em;"/></div>
<p>To generate the preceding screenshot, the <kbd>View</kbd> and <kbd>Text</kbd> components in the default code were also updated with custom CSS rules to show this <span class="packt_screen">hello</span> text on the screen.</p>
<p>With this, we will have a 360-degree game world that can be explored by the user. In the next section, we will explore how to place 3D objects in this world. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding 3D VR objects</h1>
                </header>
            
            <article>
                
<p>We will add 3D objects to the game world using <kbd>Entity</kbd> components from React 360, along with the sample object details in the <kbd>answerObjects</kbd> and <kbd>wrongObjects</kbd> arrays that were defined for the game.</p>
<p>First, we will concatenate the <kbd>answerObjects</kbd> and <kbd>wrongObjects</kbd> arrays in <kbd>componentDidMount</kbd> to form a single array containing all of the VR objects, as shown in the following code:</p>
<p> <kbd><span>/MERNVR/index.js</span></kbd></p>
<pre>componentDidMount = () =&gt; {<br/>  let vrObjects = this.state.game.answerObjects.<strong>concat</strong>(this.state.game.wrongObjects)<br/>  this.setState({vrObjects: vrObjects}) <br/>    ...<br/>}</pre>
<p>This will give us a single array containing all of the VR objects for the game. Then, in the main view, we will iterate over this merged <kbd>vrObjects</kbd> array to render the <kbd>Entity</kbd> components with details of each object. The iteration code will be added using <kbd>map</kbd>, as shown in the following code:</p>
<p><kbd><span>/MERNVR/index.js</span></kbd></p>
<pre>{this.state.vrObjects.map((vrObject, i) =&gt; {<br/>     return (<br/>                &lt;Entity key={i} style={this.setModelStyles(vrObject, i)}<br/>                  source={{<br/>                    obj: {uri: vrObject.objUrl},<br/>                    mtl: {uri: vrObject.mtlUrl}<br/>                  }}<br/>                 /&gt;<br/>            )<br/>    })<br/>}</pre>
<p>The <kbd>obj</kbd> and <kbd>mtl</kbd> file links are added to the <kbd>source</kbd> prop in <kbd>Entity</kbd>, and the <kbd>transform</kbd> style details are applied in the <kbd>Entity</kbd> component's styles with the call to <kbd>setModelStyles</kbd>. The <kbd>setModelStyles</kbd> method constructs the styles for the specific VR object to be rendered, using values defined in the VR object's details. </p>
<p><span>The </span><kbd>setModelStyles</kbd><span> method is implemented as follows:</span></p>
<p><kbd><span>/MERNVR/index.js</span></kbd></p>
<pre>setModelStyles = (vrObject, index) =&gt; {<br/>    return {<br/>        display: this.state.collectedList[index] ? 'none' : 'flex',<br/>        color: vrObject.color,<br/>        transform: [<br/>          {<br/>            translateX: vrObject.translateX<br/>          }, { <br/>            translateY: vrObject.translateY<br/>          }, {<br/>            translateZ: vrObject.translateZ<br/>          }, {<br/>            scale: vrObject.scale<br/>          }, {<br/>            rotateY: vrObject.rotateY<br/>          }, {<br/>            rotateX: vrObject.rotateX<br/>          }, {<br/>            rotateZ: vrObject.rotateZ<br/>          }<br/>        ]<br/>      }<br/>  }</pre>
<p>The <kbd>display</kbd> property will allow us to show or hide an object based on whether it has already been collected by the player or not. The <kbd>translate</kbd> and <kbd>rotate</kbd> values will render the 3D objects in the desired positions and orientations across the VR world. Next, we will update the <kbd>Entity</kbd> code further to enable user interactions with these 3D objects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interacting with VR objects</h1>
                </header>
            
            <article>
                
<p>In order to make the VR game objects interactive, we will use the React 360 event handlers, such as <kbd>onEnter</kbd> and <kbd>onExit</kbd> with <kbd>Entity</kbd>, and <kbd>onClick</kbd> with <kbd>VrButton</kbd>, to add rotation animation and gameplay behavior. In the following sections, we will add the implementations for rotating a VR object when a user focuses on it, and for adding click behavior on the objects to allow a user to collect the correct objects in the game. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Rotating a VR object</h1>
                </header>
            
            <article>
                
<p>We want to add a feature that starts rotating a 3D object around its <em>y</em> axis whenever a player focuses on the 3D object, that is, when the platform cursor begins intersecting with the <kbd>Entity</kbd> component rendering the specific 3D object.</p>
<p>We will update the <kbd>Entity</kbd> component from the previous section to add the <kbd>onEnter</kbd> and <kbd>onExit</kbd> handlers, as shown in the following code:</p>
<p><kbd><span>/MERNVR/index.js</span></kbd></p>
<pre>&lt;Entity <br/>     ... <br/>    <strong>onEnter={this.rotate(i)}</strong><br/><strong>    onExit={this.stopRotate}</strong><br/>/&gt;</pre>
<p>The object rendered with this <kbd>Entity</kbd> component will start rotating on a cursor entry or focus on the object, and it will stop when the platform cursor exits the object and is no longer in the player's focus. In the following section, we will discuss the implementation of this rotation animation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Animation with requestAnimationFrame</h1>
                </header>
            
            <article>
                
<p>The rotation behavior for each 3D object is implemented in the event handlers added to the <kbd>Entity</kbd> component, which is rendering the 3D object. Specifically, in the <kbd>rotate(index)</kbd> and <kbd>stopRotate()</kbd> handler methods that are called when the <kbd>onEnter</kbd> and <kbd>onExit</kbd> events occur, we will implement rotation animation behavior using <kbd>requestAnimationFrame</kbd> for smooth animations in the browser.</p>
<div class="packt_infobox">The <kbd>window.requestAnimationFrame()</kbd> method asks the browser to call a specified callback function to update an animation before the next repaint. With <kbd>requestAnimationFrame</kbd>, the browser optimizes the animations to make them smoother and more resource-efficient.</div>
<p>Using the <kbd>rotate</kbd> method, we will update the <kbd>rotateY</kbd> transform value of the given object at a steady rate on a set time interval with <kbd>requestionAnimationFrame</kbd>, as shown in the following code:</p>
<p><kbd><span>/MERNVR/index.js</span></kbd></p>
<pre>this.lastUpdate = Date.now() <br/>rotate = index =&gt; event =&gt; {<br/>    const now = Date.now()<br/>    const diff = now - this.lastUpdate<br/>    const vrObjects = this.state.vrObjects<br/>    vrObjects[index].rotateY = vrObjects[index].rotateY + diff / 200<br/>    this.lastUpdate = now<br/>    this.setState({vrObjects: vrObjects})<br/>    this.requestID = requestAnimationFrame(this.rotate(index)) <br/>}</pre>
<p>The <kbd>requestAnimationFrame</kbd> method will take the <kbd>rotate</kbd> method as a recursive callback function, then execute it to redraw each frame of the rotation animation with the new values, and, in turn, update the animation on the screen.</p>
<p>The <kbd>requestAnimateFrame</kbd> method returns a <kbd>requestID</kbd>, which we will use in the call to <kbd>stopRotate</kbd>, so the animation gets canceled in the <kbd>stopRotate</kbd> method. This<span> </span><kbd>stopRotate</kbd><span> method is defined as follows:</span> </p>
<p><kbd><span>/MERNVR/index.js</span></kbd></p>
<pre>stopRotate = () =&gt; {<br/>  if (this.requestID) {<br/>    cancelAnimationFrame(this.requestID) <br/>    this.requestID = null <br/>  }<br/>}</pre>
<p>This will implement the functionality of animating the 3D object only when it is in the viewer's focus. As shown in the following screenshot, the 3D Rubik's cube rotates clockwise around its <em>y</em> axis while it is in focus:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d4e0594f-f0cf-4b75-a370-17cb575b375d.png" style="width:33.92em;height:19.33em;"/></div>
<div class="packt_tip">Though not covered here, it is also worth exploring the React 360 Animated library, which can be used to compose different types of animations. Core components can be animated natively with this library, and it is possible to animate other components using <kbd>createAnimatedComponent()</kbd>. This l<span>ibrary was originally implemented from React Native; to learn more, you can refer to the React Native documentation.</span></div>
<p class="mce-root">Now the users playing the game will observe motion when they focus on any of the VR objects placed in the game world. In the next section, we will add the functionality for capturing user clicks on these objects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Clicking on the 3D objects</h1>
                </header>
            
            <article>
                
<p>In order to register the click behavior on each 3D object added to the game, we need to wrap the <kbd>Entity</kbd> component with a <kbd>VrButton</kbd> component that can call the <kbd>onClick</kbd> handler.</p>
<p>We will update the <kbd>Entity</kbd> component added inside the <kbd>vrObjects</kbd> array iteration code, to wrap it with the <kbd>VrButton</kbd> component, as shown in the following code:</p>
<p><kbd><span>/MERNVR/index.js</span></kbd></p>
<pre><strong>&lt;VrButton onClick={this.collectItem(vrObject)} key={i}&gt;</strong><br/>    &lt;Entity … /&gt;<br/><strong>&lt;/VrButton&gt;</strong></pre>
<p><span>The </span><kbd>VrButton</kbd><span> component will call the </span><kbd>collectItem</kbd><span> method when clicked on, and pass it the current object's details. </span></p>
<p>When a 3D object is clicked on by a user, we need the <kbd>collectItem</kbd> method to perform the following actions with respect to the game features:</p>
<ul>
<li style="font-weight: 400">Check whether the clicked object is an <kbd>answerObject</kbd> or a <kbd>wrongObject</kbd>.</li>
<li style="font-weight: 400">Based on the object type, play the associated sound.</li>
<li style="font-weight: 400">If the object is an <kbd>answerObject</kbd>, it should be collected and removed from view, then added to a list of collected objects.</li>
<li style="font-weight: 400">Check whether all instances of <kbd>answerObject</kbd> were successfully collected with this click:
<ul>
<li style="font-weight: 400">If yes, show the game completed message to the player and play the sound for <span>game completed.</span></li>
</ul>
</li>
</ul>
<p>We will implement these actions in the <kbd>collectItem</kbd> method with the following structure and steps:</p>
<pre>collectItem = vrObject =&gt; event =&gt; {<br/>  if (vrObject is an answerObject) {<br/>     ... update collected list ...<br/>     ... play sound for correct object collected ...<br/>     if (all answer objects collected) {<br/>         ... show game completed message in front of user ...<br/>         ... play sound for game completed ...<br/>     }<br/>  } else {<br/>     ... play sound for wrong object clicked ...<br/>  }<br/>}</pre>
<p>Any time a VR object is clicked on by the user, in this method, we will first check the type of the object before taking the related actions. We will discuss the implementation of these steps and actions in detail in the following section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Collecting the correct object on click</h1>
                </header>
            
            <article>
                
<p>When a user clicks on a 3D object, we need to first check whether the clicked object is an answer object. If it is, this object will be <em>collected</em><span> and </span>hidden from view, and a list of collected objects will be updated along with the total number to keep track of the user's progress in the game.</p>
<p>To check whether the clicked VR object is an <kbd>answerObject</kbd>, we will use the <kbd>indexOf</kbd> method to find a match in the <kbd>answerObjects</kbd> array, as shown in the following code:</p>
<pre>let match = this.state.game.answerObjects.indexOf(vrObject) </pre>
<p>If the <kbd>vrObject</kbd> is an <kbd>answerObject</kbd>, <kbd>indexOf</kbd> will return the array index of the matched object; otherwise, it will return <kbd>-1</kbd> if no match is found.</p>
<p>To keep track of collected objects in the game, we will also maintain an array of Boolean values in <kbd>collectedList</kbd> at corresponding indices, and the total number of objects collected so far in <kbd>collectedNum</kbd>, as shown in the following code:</p>
<pre>let updateCollectedList = this.state.collectedList <br/>let updateCollectedNum = this.state.collectedNum + 1 <br/>updateCollectedList[match] = true <br/>this.setState({collectedList: updateCollectedList, <br/>                collectedNum: updateCollectedNum}) </pre>
<p>Using the <kbd>collectedList</kbd> array, we will also determine which <kbd>Entity</kbd> component should be hidden from the view because the associated object was collected. The <kbd>display</kbd> style property of the relevant <kbd>Entity</kbd> component will be set based on the Boolean value of the corresponding index in the <kbd>collectedList</kbd> array. We set this in the style for the <kbd>Entity</kbd> component using the <kbd>setModelStyles</kbd> method, as shown earlier in the <em>Adding 3D VR objects</em> section. This display style value is set conditionally with the following line of code:</p>
<pre>display: this.state.collectedList[index] ? 'none' : 'flex'</pre>
<p>Depending on whether the array index of the rendered VR object is set to true in the collected list of objects, we hide or show the <kbd>Entity</kbd> component in the view.</p>
<p>For example, in the following screenshot, the treasure chest can be clicked on to be collected as it is an <kbd>answerObject</kbd>, whereas the flower pot cannot be collected because it is a <kbd>wrongObject</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a6f20097-fa73-4e6d-bc13-42e071be5f90.png" style="width:21.83em;height:14.50em;"/></div>
<p>When the treasure chest is clicked on, it disappears from the view as the <kbd>collectedList</kbd> is updated, and we also play the sound effect for collection using <kbd>AudioModule.playOneShot</kbd> with the following code:</p>
<pre>AudioModule.playOneShot({<br/>    source: asset('collect.mp3'),<br/>}) </pre>
<p>However, when the flower pot is clicked on, and it is identified as a wrong object, we play another sound effect indicating it cannot be collected, as shown in the following code:</p>
<pre>AudioModule.playOneShot({<br/>     source: asset('clog-up.mp3'),<br/>})</pre>
<p>As the flower pot was identified to be a wrong object, the <kbd>collectedList</kbd> was not updated and it remains on the screen, whereas the treasure chest is gone, <span>as shown in the following screenshot</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d1a2710e-819b-48d2-84d6-57e71f478797.png" style="width:21.00em;height:13.83em;"/></div>
<p>The complete code in the <kbd>collectItem</kbd> method that executes all of these steps when an object is clicked on will be as follows.</p>
<p><kbd><span>/MERNVR/index.js</span></kbd>:</p>
<pre>  collectItem = vrObject =&gt; event =&gt; {<br/>    let match = this.state.game.answerObjects.indexOf(vrObject)<br/>    if (match != -1) {<br/>      let updateCollectedList = this.state.collectedList<br/>      let updateCollectedNum = this.state.collectedNum + 1<br/>      updateCollectedList[match] = true<br/>      <strong>this.checkGameCompleteStatus(updateCollectedNum)</strong><br/>          AudioModule.playOneShot({<br/>            source: asset('collect.mp3'),<br/>          })<br/>      this.setState({collectedList: updateCollectedList,<br/>          collectedNum: updateCollectedNum})<br/>    } else {<br/>      AudioModule.playOneShot({<br/>        source: asset('clog-up.mp3'),<br/>      })<br/>    }<br/>  }</pre>
<p>After a clicked object is collected using this method, we will also check whether all of the <kbd>answerObjects</kbd> have been collected and whether the game is complete with a call to the <kbd>checkGameCompleteStatus</kbd> method. We will take a look at the implementation of this method and the game completed functionality in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Game completed state</h1>
                </header>
            
            <article>
                
<p>Every time an <kbd>answerObject</kbd> is collected, we will check whether the total number of collected items is equal to the total number of objects in the <kbd>answerObjects</kbd> array to determine whether the game is complete. We will achieve this by calling the <kbd>checkGameCompleteStatus</kbd> method, which will perform this check, as shown in the following code:</p>
<p><kbd><span>/MERNVR/index.js</span></kbd></p>
<pre>checkGameCompleteStatus = (collectedTotal) =&gt; {<br/>    if (collectedTotal == this.state.game.answerObjects.length) {<br/>      AudioModule.playEnvironmental({<br/>        source: asset('happy-bot.mp3'),<br/>        loop: true<br/>      })<br/>      this.setState({hide: 'flex', hmMatrix: VrHeadModel.getHeadMatrix()})<br/>    }<br/>}</pre>
<p>In this method, we first confirm that the game is indeed complete, and then we perform the following actions:</p>
<ul>
<li style="font-weight: 400">Play the audio for game completed, using <kbd>AudioModule.playEnvironmental</kbd>.</li>
<li style="font-weight: 400">Fetch the current <kbd>headMatrix</kbd> value using <kbd>VrHeadModel</kbd> so that it can be set as the transform matrix value for the <kbd>View</kbd> component containing the game completion message.</li>
<li style="font-weight: 400">Set the <kbd>display</kbd> style property of the <kbd>View</kbd> message<span> </span>to <kbd>flex</kbd>, so the message renders to the viewer.</li>
</ul>
<p>The <kbd>View</kbd> component containing the message congratulating the player for completing the game will be added to the parent <kbd>View</kbd> component as follows:</p>
<p><kbd><span>/MERNVR/index.js</span></kbd></p>
<pre>&lt;View style={<strong>this.setGameCompletedStyle</strong>}&gt;<br/>   &lt;View style={this.styles.completeMessage}&gt;<br/>      &lt;Text style={this.styles.congratsText}&gt;Congratulations!&lt;/Text&gt;<br/>      &lt;Text style={this.styles.collectedText}&gt;<br/>            You have collected all items in {this.state.game.name}<br/>      &lt;/Text&gt;<br/>   &lt;/View&gt;<br/>   &lt;VrButton onClick={this.exitGame}&gt;<br/>      &lt;View style={this.styles.button}&gt;<br/>          &lt;Text style={this.styles.buttonText}&gt;Play another game&lt;/Text&gt;<br/>      &lt;/View&gt;<br/>   &lt;/VrButton&gt;<br/>&lt;/View&gt;</pre>
<p>The call to the <kbd>setGameCompletedStyle()</kbd> method will set the styles for the <kbd>View</kbd> message<span> </span>with the updated <kbd>display</kbd> value and the <kbd>transform</kbd> matrix value. <span>The </span><kbd>setGameCompletedStyle</kbd><span> method is defined as follows:</span></p>
<p><kbd><span>/MERNVR/index.js</span></kbd></p>
<pre>setGameCompletedStyle = () =&gt; {<br/>    return {<br/>        position: 'absolute',<br/>        display: <strong>this.state.hide</strong>,<br/>        layoutOrigin: [0.5, 0.5],<br/>        width: 6,<br/>        transform: [{translate: [0, 0, 0]}, {matrix: <strong>this.state.hmMatrix</strong>}]<br/>      }<br/>}</pre>
<p>These style values will render the <kbd>View</kbd> component with the completion message at the center of the user's current view, regardless of whether they are looking up, down, behind, or forward in the 360-degree VR world, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7c0f6b18-b1d5-42f9-8366-626522807d36.png" style="width:33.08em;height:18.08em;"/></div>
<p>The final text in the <kbd>View</kbd> message will act as a button, as we wrapped this <kbd>View</kbd> in a <kbd>VrButton</kbd> component that calls the <kbd>exitGame</kbd> method when clicked. The <kbd>exitGame</kbd><span> method is defined as follows:</span></p>
<p><kbd><span>/MERNVR/index.js</span></kbd></p>
<pre>exitGame = () =&gt; {<br/>    Location.replace('/') <br/>}</pre>
<p>The <kbd>exitGame</kbd> method will use the <kbd>Location.replace</kbd> method to redirect the user to an external URL that may contain a list of games.</p>
<p>The <kbd>replace</kbd> method can be passed any valid URL, and once this React 360 game code is integrated with the MERN VR Game application in <a href="17bbfed7-9867-4c8b-99fd-42581044a906.xhtml">Chapter 14</a><span>,</span> <em>Making the VR Game Dynamic Using MERN</em>, <kbd>replace('/')</kbd> will take the user to the home page of the whole application.</p>
<p>The VR game functionalities are complete with these updates to the React 360 project. It is now possible to set a 360-degree panoramic background as the game world and add interactive VR objects to this world. These 3D objects will rotate in place and can be collected based on user interaction if the game rules allow it. In the next section, we will demonstrate how to bundle this React 360 code so that the game can be integrated with a MERN-based web application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Bundling for production and integration with MERN</h1>
                </header>
            
            <article>
                
<p>Now that we have features of the VR game implemented and are functional with the sample game data, we can prepare it for production and add it to our MERN-based application to see how VR can be added to an existing web application. In the following sections, we will look at how to bundle the React 360 code, integrate it with a MERN application, and test the integration by running the game from the application. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Bundling React 360 files</h1>
                </header>
            
            <article>
                
<p><span>React 360 tools provide a script to bundle all of the React 360 application code into a few files that we can just place on the MERN web server and serve as content at a specified route. </span>To create the bundled files, we can run the following command in the React 360 project directory:</p>
<pre><strong>yarn bundle</strong></pre>
<p>This generates compiled versions of the React 360 application files in a folder called <kbd>build</kbd>. The compiled bundle files are <kbd>client.bundle.js</kbd> and <kbd>index.bundle.js</kbd>. These two files, in addition to the <kbd>index.html</kbd> file and the <kbd>static-assets/</kbd> folder, make up the production version of the whole React 360 application that was developed. The final production code will be in the following folder and files:</p>
<pre>-- static_assets/<br/><br/>-- index.html<br/><br/>-- index.bundle.js<br/><br/>-- client.bundle.js</pre>
<p>We will have to take these folders and files over to a MERN project directory to integrate the game with the MERN application, as discussed in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Integrating with a MERN application</h1>
                </header>
            
            <article>
                
<p>In order to integrate the game developed in React 360 with a MERN-based web application, we will first bring the React 360 production files discussed in the previous section to our MERN application project. Then, we will update the bundle file references in the generated <kbd>index.html</kbd> code to point to the new location of the bundle files, before loading the <kbd>index.html</kbd> code at a specified route in the Express app.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding the React 360 production files</h1>
                </header>
            
            <article>
                
<p>With consideration to the folder structure in the existing MERN skeleton application, we will add the <kbd>static_assets</kbd> folder and the bundle files from the React 360 production files to the <kbd>dist/</kbd> folder. This will keep our MERN code organized with all the bundles in the same location. The <kbd>index.html</kbd> file will be placed in a new folder, named <kbd>vr</kbd> in the <kbd>server</kbd> folder, as highlighted in the following folder structure:</p>
<pre>-- ... <br/>-- client/<br/>-- <strong>dist/</strong><br/>     --- <strong>static_assets/</strong><br/>     --- ...<br/>     --- <strong>client.bundle.js</strong><br/>     --- <strong>index.bundle.js</strong><br/>-- ...<br/>-- <strong>server/</strong><br/>     --- ...<br/>     --- <strong>vr/</strong><br/>          ---- <strong>index.html</strong><br/>-- ...</pre>
<p>This will bring the React 360 code over to the MERN application. However, to make it functional, we need to update the file references in the <kbd>index.html</kbd> code, as discussed in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating references in index.html</h1>
                </header>
            
            <article>
                
<p>The <kbd>index.html</kbd> file, which was generated after bundling the React 360 project, references the bundle files expecting these files to be in the same folder, as shown in the following code:</p>
<pre>&lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;title&gt;MERNVR&lt;/title&gt;<br/>    &lt;style&gt;body { margin: 0 }&lt;/style&gt;<br/>    &lt;meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;!-- Attachment point for your app --&gt;<br/>    &lt;div id="container"&gt;&lt;/div&gt;<br/>    &lt;script <strong>src="./client.bundle.js"</strong>&gt;&lt;/script&gt;<br/>    &lt;script&gt;<br/>      // Initialize the React 360 application<br/>      React360.init(<br/>        <strong>'index.bundle.js'</strong>,<br/>        document.getElementById('container'),<br/>        {<br/>          <strong>assetRoot: 'static_assets/'</strong>,<br/>        }<br/>      ) <br/>    &lt;/script&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</pre>
<p>We need to update this <kbd>index.html</kbd> code to refer to the correct location of the <kbd>client.bundle.js</kbd>, <kbd>index.bundle.js</kbd>, and <kbd>static_assets</kbd> folders.</p>
<p>First, update the reference to <kbd>client.bundle.js</kbd> as follows, to point to the file we placed in the <kbd>dist</kbd> folder:</p>
<pre>&lt;script src="<strong>/dist/client.bundle.js</strong>" type="text/javascript"&gt;&lt;/script&gt;</pre>
<p>Then, update the <kbd>React360.init</kbd> call with the correct reference to <kbd>index.bundle.js</kbd>, and <kbd>assetRoot</kbd> set to the correct location of the <kbd>static_assets</kbd> folder, as shown in the following code:</p>
<pre>React360.init(<br/><strong>        './../dist/index.bundle.js',</strong><br/>        document.getElementById('container'),<br/><strong>        { assetRoot: '/dist/static_assets/' }</strong><br/>    )</pre>
<p>The <kbd>assetRoot</kbd> specifies where to look for asset files when we use <kbd>asset()</kbd> to set resources in the <span>React 360 </span>components. </p>
<p>The game view implemented with React 360 is now available in the MERN application. In the next section, we will try out this integration by setting up a route to load the game from the web application. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Trying out the integration</h1>
                </header>
            
            <article>
                
<p><span>If we set up an Express route in the MERN application to return the </span><kbd>index.html</kbd><span> file in the response, then visiting the route in the browser will render the React 360 game. </span>To test out this integration, we can set up an example route, as follows:</p>
<pre>router.route('/game/play')<br/>   .get((req, res) =&gt; {<br/>      res.sendFile(process.cwd()+'/server/vr/index.html') <br/>}) </pre>
<p>This declares a <kbd>GET</kbd> route in the <kbd>'/game/play'</kbd> path, which will simply return the <kbd>index.html</kbd> file that we placed in the <kbd>vr</kbd> folder with the server code, in response to the requesting client.</p>
<p>Then, we can run the MERN server and open this route in the browser at <kbd>localhost:3000/game/play</kbd>. This should render the complete React 360 game implemented in this chapter from within the MERN-based web application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we <span>used React 360 to </span>develop a web-based VR game that can be easily integrated into MERN applications.</p>
<p>We began by defining simple VR features for the gameplay. Then, we set up React 360 for development and looked at key VR concepts, such as equirectangular panoramic images, 3D positions, and coordinate systems in the 360-degree VR world. We explored the React 360 components and APIs required to implement the game features, including components such as <kbd>View</kbd>, <kbd>Text</kbd>, <kbd>Entity</kbd>, and <kbd>VrButton</kbd>, along with the <kbd>Environment</kbd>, <kbd>VrHeadModel</kbd>, and <kbd>NativeModules</kbd> APIs.</p>
<p>Finally, we updated the code in the starter React 360 project to implement the game with sample game data, then we bundled the code files and discussed how to add these compiled files to an existing MERN application.</p>
<p>With these steps covered, you will now be able to build your own VR interfaces with React 360, which can be easily integrated with any MERN-based web application.</p>
<p>In the next chapter, we will develop the MERN VR Game application, complete with a game database and backend APIs. This is so that we can make the game developed in this chapter dynamic by fetching data from a game collection stored in MongoDB.</p>


            </article>

            
        </section>
    </body></html>