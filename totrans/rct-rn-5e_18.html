<html><head></head><body>
  <div id="_idContainer133" class="Basic-Text-Frame">
    <h1 class="chapterNumber">16</h1>
    <h1 id="_idParaDest-206" class="chapterTitle">React Native under the Hood</h1>
    <p class="normal">The previous chapter briefly touched on what React Native is and the differences that users experience between the React Native UI and mobile browsers.</p>
    <p class="normal">In this chapter, we will dig deeper into React Native, becoming well-versed on how it performs on mobile devices and what we should attain before commencing any efforts with this framework. We will also look at what options we can execute for the native functionality of JavaScript and what restrictions we will be up against. </p>
    <p class="normal">We will cover the following topics:</p>
    <ul>
      <li class="bulletList">Exploring the React Native architecture</li>
      <li class="bulletList">Explaining JavaScript and Native modules</li>
      <li class="bulletList">Exploring React Native components and APIs</li>
    </ul>
    <h1 id="_idParaDest-207" class="heading-1">Exploring the React Native architecture</h1>
    <p class="normal">Before <a id="_idIndexMarker575"/>understanding how React Native works, let’s revisit some historical points about the React architecture and the differences between web and native mobile apps. </p>
    <h2 id="_idParaDest-208" class="heading-2">The state of web and mobile apps in the past</h2>
    <p class="normal">Meta released <strong class="keyWord">React</strong> in 2013 as a <a id="_idIndexMarker576"/>monolith tool for creating apps, using a component <a id="_idIndexMarker577"/>approach <a id="_idIndexMarker578"/>and a <strong class="keyWord">virtual DOM</strong>. It <a id="_idIndexMarker579"/>gave us the opportunity to develop web applications without thinking about browser processes, such as parsing JS code, creating the DOM, and handling layers and rendering. We just had to create interfaces using state and props for data and CSS for styling, fetch data from the backend, save it in local storage, and so on. </p>
    <p class="normal">React, together with browsers, allowed us to create a performance application in less time. At that time, the architecture of React looked like this:</p>
    <figure class="mediaobject"> <img src="../Images/B19636_16_01.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 16.1: React architecture in 2013</p>
    <p class="normal">The new <a id="_idIndexMarker580"/>declarative approach to developing <a id="_idIndexMarker581"/>interfaces became more favorable because of the fast development and the low threshold for novices. Additionally, if your <a id="_idIndexMarker582"/>backend is built with <strong class="keyWord">Node.js</strong>, you can benefit from the ease of support and development of the entire project using just one programming language.</p>
    <p class="normal">At the same time, mobile apps require more complex techniques to create apps. For Android and iOS apps, companies should manage three different teams with unparalleled experience to support three major ecosystems:</p>
    <ul>
      <li class="bulletList">Web developers should know HTML, CSS, JS, and React.</li>
      <li class="bulletList"><strong class="keyWord">Java</strong> or <strong class="keyWord">Kotlin</strong> SDK experience is required for Android developers.</li>
      <li class="bulletList">The iOS developer should be familiar with <strong class="keyWord">Objective-C</strong> or <strong class="keyWord">Swift</strong> and <strong class="keyWord">CocoaPods</strong>.</li>
    </ul>
    <p class="normal">Every step of developing an application, from prototyping to release, requires unique skills. Web and mobile app development before cross-platform solutions looked like this:</p>
    <figure class="mediaobject"> <img src="../Images/B19636_16_02.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 16.2: The state of web and mobile apps </p>
    <p class="normal">Even if a <a id="_idIndexMarker583"/>corporation carries out a basic application, it can be faced with some major issues:</p>
    <ul>
      <li class="bulletList">Each of these teams implements the same business logic.</li>
      <li class="bulletList">There is no alternative to sharing code between teams.</li>
      <li class="bulletList">It is not conceivable to share resources between teams (Android developers can’t write code for iOS applications, and vice versa).</li>
    </ul>
    <p class="normal">As a result <a id="_idIndexMarker584"/>of these significant issues, we likewise have complications with having more testing resources, since there are more places to create bugs. The speed of development is also diverse because mobile apps take more time to deliver the same features. This all accumulates into a large, costly problem for the companies involved. Many of them came up with ideas on how to write a single code base or reuse a current one that can be used in multiple ecosystems. The simplest method would be to wrap a web app for mobile using a browser, but this has limitations in handling touch and gestures, as we explored in <em class="chapterRef">Chapter 15</em>, <em class="italic">Why React Native?</em>.</p>
    <p class="normal">In response to these issues, Meta started investing resources in developing a cross-platform framework <a id="_idIndexMarker585"/>and released the <strong class="keyWord">React Native library</strong> in 2015. Also, it divided React into two separate libraries. To render our app in the browser, we should <a id="_idIndexMarker586"/>now use the <strong class="keyWord">ReactDOM</strong> library. </p>
    <p class="normal">In <em class="italic">Figure 16.3</em>, we can see how <strong class="keyWord">React</strong> works together with <strong class="keyWord">ReactDOM</strong> and <strong class="keyWord">React Native</strong> to render our apps:</p>
    <figure class="mediaobject"> <img src="../Images/B19636_16_03.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 16.3: ReactDOM and React Native flow</p>
    <p class="normal">Now, React only works to manage the components tree. This approach encapsulates any rendering APIs and hides a lot of platform-specific methods from us. We can concentrate solely <a id="_idIndexMarker587"/>on developing interfaces and cease speculating about how they would be rendered. </p>
    <p class="normal">That’s why React is frequently claimed as a renderer-agnostic library. Also, for web apps, we use ReactDOM, which forms elements and applies them right to the browser DOM. For mobile apps, React Native renders our interface directly on the mobile screen.</p>
    <p class="normal">But how does React Native replace the whole browser API and allow us to write familiar code and run it on mobiles? </p>
    <h1 id="_idParaDest-209" class="heading-1">React Native current architecture</h1>
    <p class="normal">The React Native library allows you to create native applications with React and JS by utilizing native <a id="_idIndexMarker588"/>building blocks. For instance, the <code class="inlineCode">&lt;Image/&gt;</code> component represents two other native components, <code class="inlineCode">ImageView</code> on Android and <code class="inlineCode">UIImageView</code> on iOS. This is viable because of the architecture of React Native, which includes two dedicated layers, represented by <strong class="keyWord">JS</strong> and <strong class="keyWord">Native</strong> threads:</p>
    <figure class="mediaobject"><img src="../Images/B19636_16_04.png" alt="" role="presentation"/> </figure>
    <p class="packt_figref">Figure 16.4: React Native threads</p>
    <p class="normal">In the next <a id="_idIndexMarker589"/>sections, we will explore each thread and see how they can communicate, ensuring that JS is integrated into the native code.</p>
    <h2 id="_idParaDest-210" class="heading-2">JS as part of React Native</h2>
    <p class="normal">As the browser <a id="_idIndexMarker590"/>executes JS through <strong class="keyWord">JS engines</strong> such as <strong class="keyWord">V8</strong>, <strong class="keyWord">SpiderMonkey</strong>, and others, React <a id="_idIndexMarker591"/>Native also contains a <strong class="keyWord">JS virtual machine</strong>. There, our <a id="_idIndexMarker592"/>JS code is executed, API calls are made, touch events are processed, and many other processes occur.</p>
    <p class="normal">Initially, React Native only <a id="_idIndexMarker593"/>supported Apple’s <strong class="keyWord">JavaScriptCore</strong> virtual machine. With iOS devices, this virtual machine is built-in and available out of the box. In the case of Android, JavaScriptCore is bundled with React Native. This increases the size of the app. </p>
    <p class="normal">Therefore, the <em class="italic">Hello World</em> application of React Native would consume approximately 3 to 4 MB on Android. From the 0.60 version, React Native started using <a id="_idIndexMarker594"/>the new <strong class="keyWord">Hermes virtual machine</strong>, and from 0.64, provided support for iOS as well. </p>
    <p class="normal">The Hermes virtual machine introduced a lot of improvements for both platforms:</p>
    <ul>
      <li class="bulletList">Improvement of the app’s startup time</li>
      <li class="bulletList">A size reduction of the downloaded app</li>
      <li class="bulletList">Decreased memory usage</li>
      <li class="bulletList">Built-in proxy support, enabling <a id="_idIndexMarker595"/>the use of <strong class="keyWord">react-native-firebase</strong> and <strong class="keyWord">mobx</strong></li>
    </ul>
    <p class="normal">Understanding the comparative benefits between the old and new architectures is a relatively common topic in interviews. More information about Hermes <a id="_idIndexMarker596"/>can be found here: <a href="https://reactnative.dev/docs/hermes"><span class="url">https://reactnative.dev/docs/hermes</span></a>.</p>
    <p class="normal">JS in React Native, as in browsers, is implemented in a single thread. That thread is responsible for executing JS. The business logic we write is carried out in this thread. This means all our common code, such as components, state, Hooks, and REST API calls, will be handled in the JS part of the app.</p>
    <p class="normal">Our entire application structure is <a id="_idIndexMarker597"/>packaged into a single file using the <strong class="keyWord">Metro</strong> bundler. It is also responsible for transpiling JSX code into JS. If we want to use TypeScript, <strong class="keyWord">Babel</strong> can <a id="_idIndexMarker598"/>support it. It works right out of the box, so there’s no need to configure anything. In future chapters, we will learn how to start a ready-to-work project.</p>
    <h3 id="_idParaDest-211" class="heading-3">The “Native” part</h3>
    <p class="normal">Here is where native code is executed. React Native implements this part in native code for each platform: Java for Android and Objective-C for iOS. The <strong class="keyWord">Native </strong>layer is mainly composed of Native <a id="_idIndexMarker599"/>modules that communicate with the Android or iOS SDK and are supposed to provide native functionality for our apps, using a unified API. If we want to display an alert dialog, for instance, the <strong class="keyWord">Native</strong> layer presents a unified API for both platforms, which we will call from the JS thread using the single API.</p>
    <p class="normal">This thread interacts with the JS thread when you need to update the interface or call the native functions. There are two parts to this thread:</p>
    <ul>
      <li class="bulletList">The first, the <strong class="keyWord">React Native UI</strong>, is responsible <a id="_idIndexMarker600"/>for using native interface shaping tools. </li>
      <li class="bulletList">The second is <strong class="keyWord">Native Modules</strong>, which <a id="_idIndexMarker601"/>allow applications to access the specific capabilities of the platform on which they run.</li>
    </ul>
    <h3 id="_idParaDest-212" class="heading-3">Communication between threads</h3>
    <p class="normal">As previously mentioned, each React Native layer implements a unique API for every native and <a id="_idIndexMarker602"/>UI feature in an application. The communication between layers is accomplished through the bridge. The module is written in C ++ and is based on an asynchronous queue. When the bridge receives data from one of the parties, it serializes it, converts it to a <strong class="keyWord">JSON</strong> string, and passes it through the queue. After arriving at its destination, the data is deserialized.</p>
    <p class="normal">As shown in the alert example, the native part accepts the call from JS and displays the dialog. In reality, the JS method, upon being invoked, sends a message to the <strong class="keyWord">bridge</strong>, and upon receiving this message, the Native part executes the instruction. Native messages may <a id="_idIndexMarker603"/>also be forwarded to the <strong class="keyWord">JS</strong> layer. On clicking the button, for example, the <strong class="keyWord">Native </strong>layer sends a message to the <strong class="keyWord">JS</strong> one with an <code class="inlineCode">onClick</code> event. It can be imagined as follows:</p>
    <figure class="mediaobject"> <img src="../Images/B19636_16_05.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 16.5: The bridge</p>
    <p class="normal">JS and the Native part of this architecture, together with the bridge, resemble the server and client sides of web applications, where they communicate through the REST APIs. It does not matter to us in which language or how the Native part is implemented, since the code in JS is isolated. We simply send messages and receive responses from the bridge. This is both a significant advantage and a great disadvantage: first, it allows us to implement cross-platform apps with one code base, but it can be a bottleneck in our app when we have a lot of business logic in it. All events and actions in the application rely on asynchronous JSON-bridged messages. Each party sends these messages, expecting that sometime in the future, a response will be received from these messages (which is not guaranteed). With such a data exchange scheme, there is a risk of overloading the communication channel.</p>
    <p class="normal">Here is an example commonly used to illustrate how such a communication scheme can cause performance problems for an application. Suppose a user of an application scrolls through a huge list. When the <code class="inlineCode">onScroll</code> event occurs in the native environment, information is passed asynchronously to the JS environment. But native mechanisms do not wait until <a id="_idIndexMarker604"/>the JS part of the application does its job and reports to them about it. Because of this, there is a delay in the appearance of empty space in the list before displaying its contents. We can avoid a lot of usual problems using special approaches, such as using paginated <code class="inlineCode">FlatList</code> on limitless lists. We will look at the main tricks in future chapters, but it is important to remember the limitations of the current architecture. </p>
    <h3 id="_idParaDest-213" class="heading-3">Styling </h3>
    <p class="normal">As we already understand the cross-platform concept, we can assume that each platform has its <a id="_idIndexMarker605"/>own technologies for creating and styling interfaces. In order to unify this, React Native <a id="_idIndexMarker606"/>has a <strong class="keyWord">CSS-in-JS</strong> syntax to style an app. Using <strong class="keyWord">Flexbox</strong>, components <a id="_idIndexMarker607"/>are able to specify the layout of their children. This ensures a consistent layout across different screen sizes. It is usually similar to how CSS works on the web, except the names are written in camel case, such as <code class="inlineCode">backgroundColor</code> rather than <code class="inlineCode">background-color</code>.</p>
    <p class="normal">In JS, it is a plain object <a id="_idIndexMarker608"/>with style properties, and in native code, it is a separate thread called <strong class="keyWord">Shadow</strong>. It recalculates the layout of the application using the <strong class="keyWord">Yoga</strong> engine, which <a id="_idIndexMarker609"/>was developed by Meta. In this thread, the calculations related to the formation of the application interface are performed. The results of these calculations are sent to the Native UI thread responsible for displaying the interface.</p>
    <p class="normal">With all the parts coming together, the final architecture of React Native is illustrated in this figure:</p>
    <figure class="mediaobject"> <img src="../Images/B19636_16_06.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 16.6: The current React Native architecture</p>
    <p class="normal">The current architecture of React Native addresses major business problems: it is feasible to develop web and mobile applications within the same team, it is possible to reuse a large <a id="_idIndexMarker610"/>amount of business logic code, and even developers with no previous experience in mobile development can easily use React Native.</p>
    <p class="normal">However, the current architecture is not ideal. Over the past few years, the React Native team has been working on a bridge bottleneck solution. The new architecture is designed to address this issue.</p>
    <h2 id="_idParaDest-214" class="heading-2">React Native future architecture</h2>
    <p class="normal">A series of significant improvements have been introduced to React Native that will streamline <a id="_idIndexMarker611"/>the development process and make it more convenient for everyone.</p>
    <p class="normal">React Native’s re-architecture will gradually deprecate the bridge and replace it with a new component <a id="_idIndexMarker612"/>called the <strong class="keyWord">JS Interface</strong> (<strong class="keyWord">JSI</strong>). In addition, this element will enable new <code class="inlineCode">Fabric</code> components and <code class="inlineCode">TurboModules</code>.</p>
    <p class="normal">The use of the JSI opens up many possibilities for improvement. In <em class="italic">Figure 16.7</em>, you can see the major updates to the React Native architecture:</p>
    <figure class="mediaobject"> <img src="../Images/B19636_16_07.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 16.7: The new React Native architecture</p>
    <p class="normal">The first change is that the JS bundle is no longer dependent on a <strong class="keyWord">JavaScriptCore</strong> virtual machine. It is <a id="_idIndexMarker613"/>actually part of the current architecture because, now, we can enable the new <strong class="keyWord">Hermes JS engine</strong> on both platforms. In other words, the JavaScriptCore engine can now easily be replaced with something else, quite possibly with better performance.</p>
    <p class="normal">The second improvement is what lies at the heart of the new React Native architecture. The JSI allows JS to call native methods and functions directly. This was made possible by the <code class="inlineCode">HostObject</code> C++ object, which stores references to native methods and properties. <code class="inlineCode">HostObject</code> in JS binds native methods and props to a global object, so direct calls to JS functions will invoke Java or Objective-C APIs.</p>
    <p class="normal">Another benefit of the new React Native is the ability to fully control native modules called <code class="inlineCode">TurboModules</code>. Rather than starting them all at once, the application will only use them when they are needed.</p>
    <p class="normal"><strong class="keyWord">Fabric</strong> is the new UI <a id="_idIndexMarker614"/>manager, called <strong class="keyWord">Renderer</strong> in <em class="italic">Figure 16.7</em>, which is expected to transform the rendering layer by eliminating the need for bridges. It is now possible to create a <strong class="keyWord">Shadow Tree</strong> directly in C++, which increases speed and reduces the number of steps to render a particular element.</p>
    <p class="normal">In order to ensure smooth communication between React Native and Native parts, Meta is currently working <a id="_idIndexMarker615"/>on a tool called <strong class="keyWord">CodeGen</strong>. It is expected to automate the compatibility of strongly typed native code and dynamically typed JS to make them synchronize. With this upgrade, there will be no need to duplicate the code for both threads, thereby enabling smooth synchronization.</p>
    <p class="normal">The new architecture could open the way for the development of new designs that are capable of things that were not available in old React Native applications. The fact is that we now have at our disposal the power of C++. This means that with React Native, it will now be possible to create many more varieties of applications than before.</p>
    <p class="normal">Here, we discussed <a id="_idIndexMarker616"/>the fundamentals that explain how React Native works. It is important to understand the architecture of the tools we use. Having this knowledge allows you to avoid mistakes during planning and prototyping, as well as maximize the potential of your future applications. In the following section, we will briefly explore how to extend React Native with modules. </p>
    <h1 id="_idParaDest-215" class="heading-1">Explaining JS and Native modules</h1>
    <p class="normal">React Native does not cover all the native capabilities out of the box. It only provides the most common <a id="_idIndexMarker617"/>features that you will need in a basic application. Also, the Meta team itself has recently moved some functions into its own modules in an effort to reduce the size of the overall application. For example, <code class="inlineCode">AsyncStorage</code>, for storing data on a device, was moved into a separate package and must be installed if you plan to use it.</p>
    <p class="normal">However, React Native is <a id="_idIndexMarker618"/>an extendable framework. We can add our own native modules and expose the JS API using the same bridge or JSI. Our focus in this book will not be on developing native modules, since we need prior experience with Objective-C or Java. Also, it is not necessary, since the React community has created an enormous number of ready-to-use modules for all cases. We will learn how to install native packages in subsequent chapters.</p>
    <p class="normal">The following are a few of the most popular native modules, without which most projects couldn’t prosper.</p>
    <h2 id="_idParaDest-216" class="heading-2">React Navigation</h2>
    <p class="normal"><strong class="keyWord">React Navigation</strong> is one of <a id="_idIndexMarker619"/>the best React Native navigation libraries for <a id="_idIndexMarker620"/>creating navigation menus and screens for your app. It’s a good tool for beginners because it’s stable, fast, and less buggy. The documentation is really good, and it provides examples for all use cases. </p>
    <p class="normal">We’ll learn more about React Navigation in <em class="chapterRef">Chapter 19</em>, <em class="italic">Navigating between Screens.</em></p>
    <h2 id="_idParaDest-217" class="heading-2">UI component libraries</h2>
    <p class="normal">The UI component libraries enable you to quickly assemble an application layout without <a id="_idIndexMarker621"/>wasting time designing and coding atomic elements. In addition, such libraries are often more stable and consistent, which leads <a id="_idIndexMarker622"/>to better results both in terms of UI and UX. </p>
    <p class="normal">These are some of the most popular libraries (we will explore a few of them in greater detail in future chapters):</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">NativeBase</strong>: This is <a id="_idIndexMarker623"/>a component library that <a id="_idIndexMarker624"/>enables developers to build universal design systems. It is built on top of React Native, allowing you to develop apps for Android, iOS, and the web.</li>
      <li class="bulletList"><strong class="keyWord">React Native Element</strong>: This <a id="_idIndexMarker625"/>provides an <a id="_idIndexMarker626"/>all-in-one UI kit for creating apps in React Native.</li>
      <li class="bulletList"><strong class="keyWord">UI Kitten</strong>: This is a <a id="_idIndexMarker627"/>React Native implementation <a id="_idIndexMarker628"/>of the <strong class="keyWord">Eva Design System</strong>. The framework contains a <a id="_idIndexMarker629"/>set of general-purpose UI components styled in a similar way.</li>
      <li class="bulletList"><strong class="keyWord">React-native-paper</strong>: This <a id="_idIndexMarker630"/>is a collection <a id="_idIndexMarker631"/>of customizable and production-ready components for React Native, following Google’s Material Design guidelines.</li>
      <li class="bulletList"><strong class="keyWord">Tamagui</strong>: This UI kit <a id="_idIndexMarker632"/>provides components <a id="_idIndexMarker633"/>that can run on mobiles and the web. </li>
    </ul>
    <h2 id="_idParaDest-218" class="heading-2">Splash screen</h2>
    <p class="normal">Adding a splash <a id="_idIndexMarker634"/>screen to your mobile app can be a tedious task, since this <a id="_idIndexMarker635"/>screen should appear before the JS thread begins. The <strong class="keyWord">react-native-bootsplash</strong> package <a id="_idIndexMarker636"/>allows you to create a fancy splash screen from the command line. The package will do all the work for you if you provide it with an image and a background color.</p>
    <h2 id="_idParaDest-219" class="heading-2">Icons</h2>
    <p class="normal">Icons are <a id="_idIndexMarker637"/>an integral part of the visualization of interfaces. Different approaches <a id="_idIndexMarker638"/>are used to display icons and other vector graphics on each platform. React <a id="_idIndexMarker639"/>Native unifies this for us but only with additional <a id="_idIndexMarker640"/>libraries such as <strong class="keyWord">react-native-vector-icons</strong>. Using <strong class="keyWord">react-native-svg</strong>, you can <a id="_idIndexMarker641"/>also render <strong class="keyWord">scalable vector graphics</strong> (<strong class="keyWord">SVG</strong>s) in a React Native app.</p>
    <h2 id="_idParaDest-220" class="heading-2">Handling errors</h2>
    <p class="normal">Usually, when we develop a web application, we are able to handle errors without any difficulty, since they <a id="_idIndexMarker642"/>do not reach beyond the scope of JS. As a result, we have more control and stability in the event of critical bugs because if the <a id="_idIndexMarker643"/>application does not start at all, we can easily see the reason and open the logs in <strong class="keyWord">DevTools</strong>.</p>
    <p class="normal">There are even <a id="_idIndexMarker644"/>more complications with React Native applications, since we have a Native component in addition to the JS of the environment, which can also cause errors in application execution. Therefore, when an error occurs, our application will close immediately. It will be hard for us to figure out why.</p>
    <p class="normal"><code class="inlineCode">react-native-exception-handler</code> provides a simple technique for handling native and JS errors and providing feedback. To make it work, you need to install and link the module. Then, register your global handler for JS and native exceptions, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { setJSExceptionHandler, setNativeExceptionHandler }
  <span class="hljs-keyword">from</span> <span class="hljs-string">"react-native-exception-handler"</span>;
<span class="hljs-title">setJSExceptionHandler</span>(<span class="hljs-function">(</span><span class="hljs-params">error, isFatal</span><span class="hljs-function">) =&gt;</span> {
  <span class="hljs-comment">// …</span>
});
<span class="hljs-keyword">const</span> <span class="hljs-title">exceptionhandler</span> = (<span class="hljs-params">exceptionString</span>) =&gt; {
  <span class="hljs-comment">// your exception handler code here</span>
};
<span class="hljs-title">setNativeExceptionHandler</span>(
  exceptionhandler,
  forceAppQuit,
  executeDefaultHandler
);
</code></pre>
    <p class="normal">The <code class="inlineCode">setJSExceptionHandler</code> and <code class="inlineCode">setNativeExceptionHandler</code> methods are custom global error handlers. If a crash occurs, you can show an error message, use Google Analytics to track it, or use a custom API to inform the development team.</p>
    <h2 id="_idParaDest-221" class="heading-2">Push notifications</h2>
    <p class="normal">We live in a world where notifications are integral. We open dozens of apps every day just because <a id="_idIndexMarker645"/>we receive notifications from them.</p>
    <p class="normal">Push notifications <a id="_idIndexMarker646"/>are often connected to a gateway provider that sends messages to users’ devices. The following libraries can be used to add push notifications to your application:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">react-native-onesignal</code>: A OneSignal provider for push notifications, email, and SMS</li>
      <li class="bulletList"><code class="inlineCode">react-native-firebase</code>: Google Firebase</li>
      <li class="bulletList"><code class="inlineCode">@aws-amplify/pushnotification</code>: AWS Amplify</li>
    </ul>
    <h2 id="_idParaDest-222" class="heading-2">Over-the-air updates</h2>
    <p class="normal">As part of a normal application update, when you build a new version and upload it to the app store, you can <a id="_idIndexMarker647"/>replace the JS package <strong class="keyWord">over the air</strong> (<strong class="keyWord">OTA</strong>). As the bundle contains only one file, updating it is not complicated. You can update your <a id="_idIndexMarker648"/>application as often as you like without waiting for Apple or Google to verify your application. That is the real power of React Native.</p>
    <p class="normal">We can use it <a id="_idIndexMarker649"/>due to the <strong class="keyWord">CodePush</strong> service made by Microsoft. You can find more information about CodePush here: <a href="https://docs.microsoft.com/en-gb/appcenter/distribution/codepush/"><span class="url">https://docs.microsoft.com/en-gb/appcenter/distribution/codepush/</span></a>.</p>
    <p class="normal">Expo also supports OTA updates with the <code class="inlineCode">expo-updates</code> package. </p>
    <h2 id="_idParaDest-223" class="heading-2">JS libraries</h2>
    <p class="normal">As for JS (non-native) modules, we <a id="_idIndexMarker650"/>have almost no restrictions, except for libraries that use unsupported APIs, such as the DOM and Node.js. We can use any packages written in JS: <code class="inlineCode">Moment</code>, <code class="inlineCode">Lodash</code>, <code class="inlineCode">Axios</code>, <code class="inlineCode">Redux</code>, <code class="inlineCode">MobX</code>, and a thousand others.</p>
    <p class="normal">We have barely scratched the surface of the possibilities to extend an application with various modules in this section. Because React Native has thousands of libraries, it makes little sense to go through them all. In order to find the required package you need, there is a <a id="_idIndexMarker651"/>project called <strong class="keyWord">React Native Directory</strong> that has collected and rated a huge list of packages. The project can be found here: <a href="https://reactnative.directory/"><span class="url">https://reactnative.directory/</span></a>.</p>
    <p class="normal">We now know <a id="_idIndexMarker652"/>how React Native is organized internally and how we can expand its functionality. Our next step is to examine what API and components this framework offers.</p>
    <h1 id="_idParaDest-224" class="heading-1">Exploring React Native components and APIs</h1>
    <p class="normal">The main modules and components will be discussed in detail in each new chapter, but for now, let’s <a id="_idIndexMarker653"/>familiarize ourselves with them. A number of <a id="_idIndexMarker654"/>core components are available in the React Native framework for use in an app.</p>
    <p class="normal">Almost all apps use at least one of these components. These are the fundamental building blocks <a id="_idIndexMarker655"/>of React Native apps:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">View</code>: The main brick of any app. This is the equivalent of <code class="inlineCode">&lt;div&gt;</code>, and on mobiles, it is represented as <code class="inlineCode">UIView</code> or <code class="inlineCode">android.view</code>. Any <code class="inlineCode">&lt;View/&gt;</code> component can nest inside another <code class="inlineCode">&lt;View/&gt;</code> component and can have zero or many children of any type.</li>
      <li class="bulletList"><code class="inlineCode">Text</code>: This is a React component for displaying text. As with <code class="inlineCode">View</code>, <code class="inlineCode">&lt;Text/&gt;</code> supports nesting, styling, and touch handling.</li>
      <li class="bulletList"><code class="inlineCode">Image</code>: This displays images from a variety of sources, such as network images, static resources, temporary local images, and images from the camera roll.</li>
      <li class="bulletList"><code class="inlineCode">TextInput</code>: This allows users to input text using a keyboard. Props enable a variety of features that can be configured, including auto-correction, auto-capitalization, placeholder text, and different keyboard types, such as a numeric keypad.</li>
      <li class="bulletList"><code class="inlineCode">ScrollView</code>: This component is a generic container for scrolling multiple views and components. There can be both vertical and horizontal scrolling (by adjusting the horizontal property) for the scrollable items. If you need to render a huge or limitless list of items, you should use <code class="inlineCode">FlatList</code>. This supports a set of special props such as <strong class="keyWord">Pull to Refresh</strong> and <strong class="keyWord">Scroll loading</strong> (lazy-loading). If your list needs to be divided into sections, then there is also a special component for this: <code class="inlineCode">SectionList</code>.</li>
      <li class="bulletList"><code class="inlineCode">Button</code>: React Native has advanced components that can be used to create custom buttons and other touchable components, such as <code class="inlineCode">TouchableHighlight</code>, <code class="inlineCode">TouchableOpacity</code>, and <code class="inlineCode">TouchableWithoutFeedback</code>.</li>
      <li class="bulletList"><code class="inlineCode">Pressable</code>: This gives <a id="_idIndexMarker656"/>more precise touch control with React Native version 0.63. Basically, it is a wrapper for detecting touch. It is a well-defined component that can be used instead of touchable components such as <code class="inlineCode">TouchableOpacity</code> and <code class="inlineCode">Button</code>.</li>
      <li class="bulletList"><code class="inlineCode">Switch</code>: This component resembles a checkbox; however, it is presented in the form of a switch, which we are familiar with on mobile devices.</li>
    </ul>
    <p class="normal">In the <a id="_idIndexMarker657"/>following chapters, we will delve deeper into <a id="_idIndexMarker658"/>common components and their properties, as well as explore new components that are rarely used. We’ll also look at code examples that show how to combine components to create application interfaces. </p>
    <p class="normal">Detailed information about all the available components can be found at <a href="https://reactnative.dev/docs/components-and-apis"><span class="url">https://reactnative.dev/docs/components-and-apis</span></a>.</p>
    <h1 id="_idParaDest-225" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we looked at the history of the cross-platform framework React Native and what problems it solved for companies. With it, companies can use a single universal developer team to build one business logic and apply it to all platforms simultaneously, thus saving a lot of time and money. Considering, in detail, how React Native works under the hood allows us to identify potential issues at the planning stage and resolve them.</p>
    <p class="normal">Additionally, we started to examine React Native’s basic components, and with each new chapter, we will learn more about them.</p>
    <p class="normal">In the next chapter, you’ll learn how to get started with new React Native projects.</p>
  </div>
</body></html>