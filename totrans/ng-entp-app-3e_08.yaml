- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recipes – Reusability, Forms, and Caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the next two chapters, we will complete most of the implementation of LemonMart
    and round out our coverage of the router-first approach. In this chapter, I will
    reinforce the idea of a decoupled component architecture by creating a *reusable*
    and *routable* component that supports data binding. We will use **Angular directives**
    to reduce boilerplate code and leverage classes, interfaces, enums, validators,
    and pipes to maximize code reuse with TypeScript and ES features.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we will create a **multi-step form** that architecturally scales
    well and supports a responsive design. Then, we will differentiate between user
    controls and components by introducing a **lemon rater** and a reusable form part
    that encapsulates the name object.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter covers a lot of ground. It is organized in a recipe format, so
    you can quickly refer to a particular implementation when working on your projects.
    I will cover the implementations’ architecture, design, and major components.
    I will highlight important pieces of code to explain how the solution comes together.
    Leveraging what you’ve learned so far, I expect you to fill in routine implementation
    and configuration details. However, you can always refer to the GitHub project
    if you are stuck.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing CRUD services with caching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multi-step responsive forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reusing repeating template behavior with directives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculated properties and DatePicker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typeahead support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic form arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating shared components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reviewing and saving form data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scalable form architecture with reusable parts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input masking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom controls with `ControlValueAccessor`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Layouts using a grid list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restoring cached data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most up-to-date versions of the sample code for the book are on GitHub at
    the repository linked in the following steps. The repository contains the final
    and completed state of the code. You can verify your progress at the end of this
    chapter by looking at the end-of-chapter snapshot of the code under the `projects`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'For *Chapter 8*:'
  prefs: []
  type: TYPE_NORMAL
- en: Be sure that **lemon-mart-server** is up and running. Refer to *Chapter 7*,
    *Working with REST and GraphQL APIs*.
  prefs: []
  type: TYPE_NORMAL
- en: Clone the repo at [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute `npm install` in the root folder to install the dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The beginning state of the project is reflected at:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The end state of the project is reflected at:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the stage name to any `ng` command to act only on that stage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the `dist/stage11` folder at the root of the repository will contain
    the compiled result.
  prefs: []
  type: TYPE_NORMAL
- en: Beware that the source code provided in the book and the version on GitHub will
    likely differ. The ecosystem around these projects is ever-evolving. Between changes
    to how Angular CLI generates new code, bug fixes, new versions of libraries, or
    side-by-side implementations of multiple techniques, there’s a lot of variation
    impossible to account for. If you find errors or have questions, please create
    an issue or submit a pull request on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with implementing a user service to retrieve data and build a form
    to display and edit profile information. Later, we will refactor this form to
    abstract out its reusable parts.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing CRUD services with caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need a service that can perform CRUD operations on a user so that we can
    implement a user profile. However, the service must be robust enough to withstand
    common errors. After all, it is very bad UX when users unintentionally lose the
    data they typed. Form data can be reset due to circumstances outside of a user’s
    control, like a network or validation error, or user errors, like hitting the
    back or refresh button by mistake. We will create a user service leveraging the
    `CacheService` we built in *Chapter 5*, *Designing Authentication and Authorization*,
    so keep a copy of user data in `localStorage` while the server processes it. The
    service will implement the following interface and, as always, reference the abstract
    `IUser` interface over the concrete user implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Before creating the service, start **lemon-mart-server** and set your application’s
    `AuthMode` to `CustomServer`.
  prefs: []
  type: TYPE_NORMAL
- en: You can use `npm run start:backend` to start the database and the server.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will implement the `getUser` and `updateUser` functions.
    We will implement `getUsers` in *Chapter 9*, *Recipes – Master/Detail, Data Tables,
    and NgRx*, to support pagination with a data table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating the user service:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `UserService` under `src/app/user/user`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declare the `IUserService` interface from the preceding snippet, excluding the
    `getUsers` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure the `UserService` class implements `IUserService`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inject the `CacheService`, `HttpClient`, and `AuthService`, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `getUser` function, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We provide a `getUser` function that can load any user’s profile information.
    Note that the security for this function is provided in the server implementation
    with the authenticate middleware. The requestor can either get their profile or
    will need to be a manager. We use `getUser` with a resolve guard later in the
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the cache
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Implement `updateUser`, which accepts an object that implements the `IUser`
    interface so that data can be sent to a PUT endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note how the cache service is used with `setItem` to save user-entered data
    if the `put` call fails. When the call succeeds, we remove the cached data using
    `removeItem`. Also, note how we hydrate a user returned from the server as a `User`
    object with `map(User.Build)`, which calls the constructor of `class User`.
  prefs: []
  type: TYPE_NORMAL
- en: Hydrate is a common term for populating an object with data from a database
    or a network request. For example, the `User` JSON object we pass between components
    or receive from the server fits the `IUser` interface but is not the `class User`
    type. We serialize objects to JSON using the `toJSON` method. When we hydrate
    and instantiate a new object from JSON, we reverse and deserialize the data.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to highlight that you should always stick to interfaces, not
    concrete implementations like `User` when passing data around. This is the **D**
    in **SOLID** – the **Dependency Inversion Principle**. Referencing concrete implementations
    like `User` creates a lot of risk because they change a lot, whereas an abstraction
    such as `IUser` will seldom change. After all, you wouldn’t solder a lamp directly
    to the electrical wiring in the wall. Instead, you solder the lamp to a plug and
    then use the plug to get the electricity you need.
  prefs: []
  type: TYPE_NORMAL
- en: With this code completed, `UserService` can now be used for basic CRUD operations.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-step responsive forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overall, forms are a different beast than the rest of your application, and
    they require special architectural considerations. I don’t recommend over-engineering
    your form solution with dynamic templates or route-enabled components. By definition,
    the different parts of a form are tightly coupled. From the perspectives of maintainability
    and ease of implementation, creating one giant component is a better strategy
    than using some of the aforementioned strategies and over-engineering.
  prefs: []
  type: TYPE_NORMAL
- en: We will implement a multi-step input form to capture user profile information
    in a single component. I will be covering my recommended technique to split forms
    up into multiple components later in the chapter, in the *Reusable form parts
    and scalability* section.
  prefs: []
  type: TYPE_NORMAL
- en: Since the implementation of the form changes dramatically between this section
    and later in the chapter, you can find the code for the initial version on GitHub
    at `projects/stage11/src/app/user/profile/profile.initial.component.ts` and `projects/stage11/src/app/user/profile/profile.initial.component.html`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also make this multi-step form responsive for mobile devices using
    media queries:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by adding some helper data that will help us display an input form
    with options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add new validation rules to `common/validations.ts`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, implement `profile.component.ts` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Upon load, we request the current user from `authService`, but this might take
    a while, so we first build an empty form with `this.buildForm()` as the first
    statement. We also store the user’s ID in the `currentUserId` property, which
    we will need later when implementing the `save` functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we filter out `null` or `undefined` users so that we don’t try to
    build the form in an invalid state.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation above introduces a UX issue in the case where `authService.currentUser$`
    is retrieved from an API. If the API takes over half a second (really, 340 ms)
    to return the data, there’ll be a noticeable pop-up of new information on the
    form. This will overwrite any text the user may have already entered.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent this, we could disable and reenable the form once the information
    is received. However, this component isn’t aware of where the information comes
    from; it merely subscribes to `authService.currentUser$`, which may or may not
    ever return a value. Even if we could reliably tell that we are receiving data
    from an API, we would have to implement a bespoke solution in every component.
  prefs: []
  type: TYPE_NORMAL
- en: Using an `HttpInterceptor`, we can globally detect when API calls are triggered
    and completed; we can expose a `signal` where components can individually subscribe
    to display a loading spinner, or we can leverage the `UiService` to launch a global
    loading spinner to block the UI while data is retrieved from the server. In *Chapter
    9*, *Recipes – Master/Detail, Data Tables, and NgRx*, I cover how to implement
    a global spinner.
  prefs: []
  type: TYPE_NORMAL
- en: A global spinner is the ultimate 80–20 solution. However, you may find that
    a global spinner is a non-starter in large applications with dozens of components
    continuously retrieving data. Complex UI requires expensive UX solutions. In this
    case, you will indeed want to implement a component-level spinner. This is demonstrated
    in the *Data tables with pagination* section of *Chapter 9*, *Recipes – Master/Detail,
    Data Tables, and NgRx*.
  prefs: []
  type: TYPE_NORMAL
- en: Later in this chapter, we will implement a resolve guard to load a user based
    on their `userId`, provided on a route to increase the reusability of this component.
  prefs: []
  type: TYPE_NORMAL
- en: Form controls and form groups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you may recall, `FormControl` objects are the most elemental parts of a form,
    usually representing a single input field. We can use `FormGroup` to group together
    a collection of related `FormControl` objects, such as the individual first, middle,
    and last parts of a person’s name. `FormGroup` objects can also group together
    a mix of `FormControl`, `FormGroup`, and `FormArray` objects. The latter object
    allows us to have dynamically repeating elements. `FormArray` is covered later
    in the chapter in the *Dynamic form arrays* section.
  prefs: []
  type: TYPE_NORMAL
- en: Our form has many input fields, so we will use a `FormGroup` created by `this.formBuilder.group`
    to house our various `FormControl` objects. Additionally, children `FormGroup`
    objects will allow us to maintain the correct shape of the data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Since the implementation of the form changes dramatically between this section
    and later in the chapter, you can find the code for the initial version on GitHub
    at `projects/stage11/src/app/user/profile/profile.initial.component.ts` and `projects/stage11/src/app/user/profile/profile.initial.component.html`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start building the `buildForm` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`buildForm` optionally accepts an `IUser` to prefill the form. Otherwise, all
    fields are set to their default values. The `formGroup` property itself is the
    top-level `FormGroup`. Various `FormControls` are added to it, such as `email`,
    with validators attached to them as needed.'
  prefs: []
  type: TYPE_NORMAL
- en: Note how `name` and `address` are their own `FormGroup` objects. This parent-child
    relationship ensures the proper structure of the form data, when serialized to
    JSON, which fits the structure of `IUser` in a manner that the rest of our application
    and server-side code can utilize.
  prefs: []
  type: TYPE_NORMAL
- en: You will complete the implementation of the `formGroup` independently by following
    the sample code provided for the chapter. I will review sections of the code piece
    by piece over the next few sections to explain certain key capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Stepper and responsive layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Angular Material’s stepper ships with the `MatStepperModule`. The stepper allows
    form inputs to be broken up into multiple steps so that the user is not overwhelmed
    with processing dozens of input fields simultaneously. The user can still track
    their place in the process, and as a side effect, as the developer, we break up
    our `<form>` implementation and enforce validation rules on a step-by-step basis,
    or create optional workflows where certain steps can be skipped or required. As
    with all Material user controls, the stepper has been designed with a responsive
    UX. In the next few sections, we will implement three steps covering different
    form-input techniques in the process:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Account information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Input validation
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Responsive layout with media queries
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculated properties
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DatePicker`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Contact information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Typeahead support
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic form arrays
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Review:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read-only views
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving and clearing data
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s start by adding the Angular material dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the following Material modules in `profile.component.ts`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import other supporting modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement a horizontal stepper with a form containing the first step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, start implementing the `name` row of the `Account Information` step in
    place of the ellipses in the preceding step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Take your time understanding how the stepper and the form configuration work
    so far. You should see the first row render, pulling in data from the **lemon-mart-server**:![](img/B20960_08_01.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.1: Multi-step form – step 1'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Note that adding `fxLayout.lt-sm="column"` to a row with `fxLayout="row"` enables
    a responsive layout for the form, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B20960_08_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.2: Multi-step form on mobile'
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on to how to implement the **Date of Birth** ﬁeld, let’s reevaluate
    our strategy by implementing error messages.
  prefs: []
  type: TYPE_NORMAL
- en: Reusing repeating template behavior with directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we implemented a `mat-error` element for every validation
    error for every field part of the `name` object. This quickly adds up to seven
    elements for three fields. In *Chapter 5*, *Designing Authentication and Authorization*,
    we implemented `common/validations.ts` to reuse validation rules. We can reuse
    the behavior we implement within `mat-error`, or any other `div` for that matter,
    using an attribute directive.
  prefs: []
  type: TYPE_NORMAL
- en: Attribute directives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Chapter 1*, *Angular’s Architecture and Concepts*, I mentioned that Angular
    components represent the most basic unit of an Angular app. With components, we
    define custom HTML elements that can reuse features and functionality represented
    by a template and some TypeScript code. Conversely, a directive augments the capabilities
    of an existing element or component. In a sense, a component is a super directive
    that augments basic HTML capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this view in mind, we can define three kinds of directives:'
  prefs: []
  type: TYPE_NORMAL
- en: Components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structural directives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attribute directives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basically, components are directives with templates; this is the most common
    type of directive you will use. Structural directives modify the DOM by adding
    or removing elements, `*ngIf` and `*ngFor` being the canonical examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'As of Angular 17, you can use the `@`-syntax to implement control flow and
    deferrable views, replacing `*ngIf` and `*ngFor` in favor of `@if` or `@for`,
    respectively. See the code snippet below for an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Finally, attribute directives allow you to define new attributes to add to HTML
    elements or components, adding new behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement an attribute directive that can encapsulate field-level error
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Field error attribute directive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine using a directive to reduce repetitive elements to display field errors.
    Consider the following example using the first name field as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We have the standard layout structure for a Material form field, but only a
    single `mat-error` element exists. There are three new properties on `mat-error`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`input` binds to the HTML input element that was tagged with `#name`, using
    a template reference variable so that we can tap into the blur event of the input
    element and read the `placeholder`, `aria-label`, and `formControlName` properties.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`group` binds to the parent FormGroup object that contains the form control,
    so by using the `formControlName` property from input, we can retrieve the `formControl`
    object while avoiding extra code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`appFieldError` binds to an array of validation errors that must be checked
    against the `formControl` object, such as `required`, `minlength`, `maxlength`,
    and `invalid`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the preceding information, we can craft a directive that can render one
    or more lines of error messages inside the `mat-error` element, effectively replicating
    the verbose method we used in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go ahead and create an attribute directive named `FieldErrorDirective`:'
  prefs: []
  type: TYPE_NORMAL
- en: Create `FieldErrorDirective` under `src/app/user-controls`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define the directive’s selector as a bindable attribute named `appFieldError`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Outside of the directive, define two new types named `ValidationError` and
    `ValidationErrorTuple`, which define the kinds of error conditions we will deal
    with and a structure that will allow us to attach a custom error message to the
    error type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Like the way we grouped validations, let’s define two sets of commonly occurring
    error conditions so that we don’t have to type them out over and over again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let’s define the `@Input` targets for the directive:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that we already went over the purpose of the top three attributes. `fieldControl`
    and `fieldLabel` are optional attributes. If `input` and `group` are specified,
    the optional attributes can be auto-populated. Since they are class-wide variables,
    it made sense to expose them if the user wants to override the default behavior
    of the directive. This is an easy win to create flexible and reusable controls.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Import the element reference in the `constructor`, which can be later used
    by a `renderErrors` function to display error in the inner HTML of the `mat-error`
    element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement a function that can return canned error messages, depending on the
    error type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that we can dynamically extract the required `minlength` or `maxlength`
    from the `fieldControl`, greatly reducing the number of custom messages we need
    to generate.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement the algorithm that can loop through all the elements in `appFieldError`
    and the errors that need to be displayed in an array, using the `getStandardErrorMessage`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Ultimately, we can display the error messages using the `renderErrors` method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note the use of function delegates, a technique that allows functions to be
    passed around and used as variables. Since this code will execute hundreds of
    times a minute, it is important to avoid unnecessary invocations. Function delegates
    help organize our code better while deferring the execution of their logic unless
    absolutely necessary. This pattern of coding allows for memorization techniques
    to enhance performance further. Refer to the *Further reading* section for more
    details.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, initialize the `fieldControl` property, which represents a `formControl`.
    We will listen to the `valueChanges` events of the control, and if the validation
    status is invalid, then we execute our custom `updateErrorMessage` logic to display
    error messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that since we’re subscribing to `valueChanges`, we must also unsubscribe.
    We unsubscribe once with `ngOnDestroy` and again right before subscribing. This
    is because `initFieldControl` may be called multiple times. If we don’t clear
    the prior subscription, it will result in a memory leak and related performance
    issues.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Additionally, if we can’t bind to a `fieldControl`, we throw an error message,
    which usually points to a coding error.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we configure all major attributes with the `ngOnChanges` event, which
    triggers any time an `@Input` attribute is updated. This ensures that, in the
    case where form elements could be dynamically added or removed, we will always
    consider the newest values. We call `initFieldControl` to start listening to value
    changes, implement an `onblur` event handler that triggers `updateErrorMessage()`
    for the HTML input element, and assign the value of `fieldLabel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that if we can’t bind to an HTML `input` element, this usually means that
    the developer simply forgot to wire things up correctly. In this case, we throw
    a new `Error` object, which generates a helpful stack trace in the console, so
    you can pinpoint the location where the error occurs in the template.
  prefs: []
  type: TYPE_NORMAL
- en: 'This wraps up the implementation of the directive. Now, we need to package
    the directive in a module named `field-error.module.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, go ahead and use the directive in our existing forms:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the module in `app.module.ts` and `user.module.ts`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update `profile.component.html` with the new directive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update `login.component.html` with the new directive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Be sure to define `ErrorSets` as a public property variable in the `component`
    class so that you can use it in the template.
  prefs: []
  type: TYPE_NORMAL
- en: Test your forms to ensure that our validation messages are displayed as expected
    and there are no console errors.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You’ve learned how to inject new behavior into other elements
    and components using directives. By doing this, we can avoid a lot of repeated
    code and standardize error messages across our app.
  prefs: []
  type: TYPE_NORMAL
- en: Before moving on, finish implementing the form by looking at the implementation
    on GitHub. You can find the code for the form template at `projects/stage11/src/app/user/profile/profile.initial.component.html`
    and the `component` class at `projects/stage11/src/app/user/profile/profile.initial.component.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: Do not include the `app-lemon-rater` and `app-view-user` elements, and remove
    the `mask` attribute from the phone number, which we will implement later in the
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you can see the User Profile as it appears on LemonMart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B20960_08_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.3: Profile component in a mostly completed state'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will review the `profile` component and see how the **Date of Birth**
    ﬁeld works.
  prefs: []
  type: TYPE_NORMAL
- en: Calculated properties and DatePicker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can display calculated properties based on user input. For example, to display
    a person’s age based on their date of birth, introduce class properties that calculate
    the age and display it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The implementation for the `age` property getter is not the most performant
    option. To calculate the age, we call the `getFullYear()` function of `this.now`
    and `this.dateOfBirth`. As a property referenced in the template, Angular’s change
    detection algorithm will call `age` up to 60 times per second, mixed with other
    elements on the screen, which can lead to major performance issues. You can resolve
    this issue by creating a **pure custom pipe** so that Angular understands only
    to check the `age` property if one of its dependent values changes.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about pure pipes at [https://angular.dev/guide/pipes/change-detection](https://angular.dev/guide/pipes/change-detection).
  prefs: []
  type: TYPE_NORMAL
- en: Another option would be to use **computed signals**. Like calculated properties,
    computed signals are read-only signals that derive their value from other signals.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could rewrite the code above like below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We create `dateOfBirth` as a **signal** and `age` as a **computed signal**.
    With this setup, `age` will be updated if and only if `dateOfBirth` changes. As
    you can see, the implementation is straightforward, and Angular’s change detection
    algorithm will do the right thing by default.
  prefs: []
  type: TYPE_NORMAL
- en: Except for one wrinkle! Due to the absence of **signal-based components** and
    the requisite `FormGroup` support, we can’t readily use `dateOfBirth` or `age`
    in reactive forms.
  prefs: []
  type: TYPE_NORMAL
- en: This helps you appreciate how big a change signals are for Angular. Read more
    at [https://angular.dev/guide/signals#computed-signals](https://angular.dev/guide/signals#computed-signals).
  prefs: []
  type: TYPE_NORMAL
- en: 'To validate a date within the last hundred years, implement a `minDate` class
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The usage of the calculated properties in the template looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Refer to the highlighted `[min]` and `[max]` attributes in the preceding snippet
    to apply the hundred-year date range.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `DatePicker` in action appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B20960_08_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.4: Selecting a date with DatePicker'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that dates beyond April 26, 2020 are grayed out. After the date is selected,
    the calculated age is displayed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B20960_08_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.5: Calculated age property'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s move on to the next step, **Contact Information**, and see how we
    can enable a convenient way to display and input the state portion of the address
    field.
  prefs: []
  type: TYPE_NORMAL
- en: Typeahead support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In `buildForm`, we set a listener on `address.state` to support a typeahead
    filtering drop-down experience:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'On the template, implement `mat-autocomplete`, bound to the filtered states
    array with an `async` pipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s how it looks when a user enters the character `V`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B20960_08_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.6: Dropdown with typeahead support'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, let’s enable the input of multiple phone numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic form arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Note that the `phones` property is an array, potentially allowing for many
    inputs. We can implement this by building a `FormArray` with the `this.formBuilder.array`
    function. We also define several helper functions to make it easier to build the
    `FormArray`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`buildPhoneFormControl` helps to build `FormGroup` objects of individual entries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`buildPhoneArray` creates as many `FormGroup` objects as needed, or if the
    form is empty, it creates an empty entry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addPhone` adds a new empty `FromGroup` object to the `FormArray`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get phonesArray()` is a convenient property to get the `phones` control from
    the form.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s see how the implementation comes together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '`buildPhoneArray` supports the initialization of a form with a single phone
    input or by filling it with the existing data, working in tandem with `buildPhoneFormControl`.
    The latter function comes in handy when a user clicks on an **Add** button to
    create a new row for the entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `phonesArray` property getter is a common pattern that makes accessing
    certain form properties easier. However, in this case, it is also necessary because
    `get(''phones'')` must be typecast to `FormArray` so that we can access the `length`
    property on it on the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Note the highlighted `convertTypeToPhoneType` function, which converts a `string`
    to `enum PhoneType`.
  prefs: []
  type: TYPE_NORMAL
- en: Also highlighted in the preceding code block is how the `remove` function is
    implemented inline in the template, making it easier to read and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how the dynamic array should be working:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B20960_08_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.7: Multiple inputs using FormArray'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’re done inputting data, we can move on to the last step of the stepper,
    **Review**. However, as was mentioned earlier, the **Review** step uses the `<app-view-user>`
    directive to display its data. Let’s build that view first.
  prefs: []
  type: TYPE_NORMAL
- en: Creating shared components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here’s a minimal implementation of the `<app-view-user>` directive, a prerequisite
    for the **Review** step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `viewUser` component under the `user` folder structure, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The preceding component uses input binding with `@Input` to get user data compliant
    with the `IUser` interface from an outside component. We implement the `ngOnChanges`
    lifecycle hook, which fires whenever the bound data changes. In this event, we
    hydrate the simple JSON object stored in the `user` property as an instance of
    the `User` class with `User.Build`.
  prefs: []
  type: TYPE_NORMAL
- en: We then assign the `User` object to the property `this.currentUser`. Even if
    we wanted to, we couldn’t directly bind to the user property, because calculated
    properties such as `fullName` can only work if data is hydrated into an instance
    of the `User` class. Angular 17.1 introduces signal-based inputs in developer
    preview. We could define user like `user = input<IUser>()` and leverage effect
    and a computed signal to streamline our implementation. In the current state of
    our code, we incur a heavy change detection penalty given the number of properties
    we’re binding to. However in signal-based component there would be no such penalty.
    I look forward to refactoring this component, when signal-based components are
    released.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are ready to complete the multi-step form.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing and saving form data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On the last step of the multistep form, users should be able to review and
    then save the form data. As a good practice, a successful `POST` request will
    return the data that was saved back to the browser. We can then reload the form
    with the information received back from the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note that `updateUser` returns the saved value of the user. It is possible that
    the database returns a different version of `user` than what we had before, so
    we use `formGroup.patchValue` to update the data powering the form. The form automatically
    updates to reflect any changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'If there are errors when saving the data, they’ll be set to `userError` to
    be displayed on the form. Before saving the data, we present it in a compact format
    with the reusable `app-view-user` component, which we can bind the form data to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Note that we use `formGroup.getRawValue()` to extract the JSON of the form data.
    See how we bind `userError` to display error messages. Also, the **Reset** button
    uses `stepper.reset()`, which can conveniently reset all the user input.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how the final product should appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B20960_08_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.8: Review step'
  prefs: []
  type: TYPE_NORMAL
- en: Now that the user profile input is done, we are about halfway to our eventual
    goal of creating a master/detail view where a **Manager** can click on a user
    and view their profile details. We still have a lot more code to add, and along
    the way, we have fallen into a pattern of adding lots of boilerplate code to load
    the requisite data for a component.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s refactor our form to make our code reusable and scalable, so even
    if our form has dozens of fields, the code is still maintainable, and we don’t
    introduce an exponential cost increase to make changes.
  prefs: []
  type: TYPE_NORMAL
- en: Scalable form architecture with reusable parts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in the introduction to the *Multi-step responsive forms* section,
    forms are tightly coupled beasts that can grow large, and using the wrong architectural
    pattern to scale your implementation can cause significant issues when implementing
    new features or maintaining existing ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate how you can break up your form into multiple parts, we will
    refactor it to extract the highlighted section in the following screenshot, the
    name `FormGroup`, as its own component. The technique to accomplish this is the
    same as you’d use when you want to put each step of your form into a separate
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B20960_08_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.9: User profile’s name part highlighted'
  prefs: []
  type: TYPE_NORMAL
- en: By making the name `FormGroup` reusable, you will also learn about how you can
    reuse the business logic that you build into that `FormGroup` in other forms.
    We will extract the name `FormGroup` logic into a new component named `NameInputComponent`.
    In doing so, we also have an opportunity to extract some reusable form functionality
    to a `BaseFormComponent` as an `abstract` `class`.
  prefs: []
  type: TYPE_NORMAL
- en: There are going to be several components that are working together here, including
    `ProfileComponent`, `ViewUserComponent`, and `NameInputComponent`. We need all
    the values in these three components to be up to date as the user enters them.
  prefs: []
  type: TYPE_NORMAL
- en: '`ProfileComponent` will own the master form to which we’ll need to register
    any child form. Once we do this, all the form validation techniques you’ve learned
    so far will still apply.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a key way to make your form able to scale across many components and
    continue to be easy to work with, without introducing unnecessary validation overhead.
    Hence, it is useful to review the different interactions between these objects
    to solidify your understanding of the asynchronous and decoupled nature of their
    behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B20960_08_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.10: Form component interactions'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we combine many of the concepts you’ve learned throughout the
    book. Utilize the preceding diagram to understand how the various form components
    interact.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, properties in bold indicate data binding. Underlined
    function elements indicate event registrations. Arrows show the points of connection
    between the components.
  prefs: []
  type: TYPE_NORMAL
- en: The workflow begins with the instantiation of `ProfileComponent`. The `OnInit`
    event of the component begins building the `formGroup` object, while asynchronously
    loading any potential `initialData` that may need to be patched into the forms.
    Refer to the preceding diagram for a visual representation of `initialData` coming
    in from a service or cache.
  prefs: []
  type: TYPE_NORMAL
- en: '`NameInputComponent` is used in the `ProfileComponent` form as `<app-name-input>`.
    To synchronize `initialData` with the `NameInputComponent`, we bind a `nameInitialData$`
    subject using the `async` pipe, since `initialData` comes in asynchronously.'
  prefs: []
  type: TYPE_NORMAL
- en: '`NameInputComponent` implements the `OnChanges` lifecycle hook, so whenever
    `nameInitialData$` updates, its value is patched into the `NameInputComponent`
    form.'
  prefs: []
  type: TYPE_NORMAL
- en: Like `ProfileComponent`, `NameInputComponent` also implements the `OnInit` event
    to construct its `formGroup` object. Since this is an asynchronous event, `NameInputComponent`
    needs to expose a `formReady` event that `ProfileComponent` can subscribe to.
    Once the `formGroup` object is ready, we emit the event and the `registerForm`
    function on `ProfileComponent` triggers. `registerForm` adds the `formGroup` object
    of `NameInputComponent` as a child element to the parent `formGroup` on `ProfileComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: '`ViewUserComponent` is used in the `ProfileComponent` form as `<app-view-user>`.
    When the values in the parent form change, we need `<app-view-user>` to stay current.
    We bind to the `user` property on `ViewUserComponent`, which implements `OnChanges`
    to receive updates. Every time there is an update, the `User` object is hydrated
    from the `IUser` object, so calculated fields such as `fullName` can continue
    working. The updated `User` is then assigned to `currentUser`, bound to the template..'
  prefs: []
  type: TYPE_NORMAL
- en: We will begin by building a `BaseFormComponent`, which `NameInputComponent`
    and `ProfileComponent` will then implement.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract form component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can share common functionality and standardize the implementation of all
    components that implement a form by implementing a base abstract class. An abstract
    class cannot be instantiated on its own because it wouldn’t make sense to do so,
    since it will not have a template, making it useless on its own.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `BaseFormComponent` is just a `class` and not an Angular component.
  prefs: []
  type: TYPE_NORMAL
- en: '`BaseFormComponent` will standardize the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Input initialData` and `disable` as binding targets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@Output formReady` event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`formGroup`, and the `FormGroup` to be used in the template’s `buildForm` function
    to build the `formGroup`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With the preceding assumptions, the base class can provide some generic functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '`patchUpdatedData` can update the data (partially or fully) in the `formGroup`
    without rebuilding it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`registerForm` and `deregisterForm` can register or deregister child forms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deregisterAllForms` can automatically deregister any registered child form.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hasChanged` can determine whether `initialData` has changed, given a `SimpleChange`
    object provided by the `ngOnChange` event handler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`patchUpdatedDataIfChanged` leverages `hasChanged` and uses `patchUpdatedData`
    to update the data if, and only if, there has been an update to `initialData`
    and `formGroup` is already initialized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a new class, `BaseFormComponent`, under `src/common` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Let’s implement `NameInputComponent` using the `BaseFormComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a reusable form part
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start by identifying the name `FormGroup` in the `profile` component code and
    template files:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the name `FormGroup` implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that when we move these validation rules to a new component, we still want
    them to be in effect when determining the overall validation status of the parent
    form. We achieve this using the `registerForm` function we implemented in the
    previous section. Once our new `FormGroup` is registered with the existing one,
    they work the same way as before our refactor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next is the name `FormGroup` template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will be moving most of this code to the new component.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `NameInputComponent` under the `user` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extend the class from `BaseFormComponent`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inject `FormBuilder` into the `constructor`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For components with small or limited pieces of functionality, I prefer creating
    them with an inline template and styling so that it is easier to change the code
    from one place.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Remember that the base class already implements the `formGroup`, `initialData`,
    `disable`, and `formReady` properties, so you don’t need to redefine them.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we must implement the `buildForm` function, since it was defined as
    abstract. This is a great way to enforce standards across developers. Also, note
    that the implementing class can override any base function provided by simply
    redefining the function with the `override` keyword. You’ll see this in action
    when we refactor the `ProfileComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `buildForm` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the `name` property part of the `formGroup` in `ProfileComponent` to `null`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the template by bringing over the content from `ProfileComponent`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `ngOnInit` event handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Getting the `ngOnInit` event handler’s implementation right in every `BaseFormComponent`
    implementation is critical. The preceding example is fairly standard behavior
    for any `child` component you may implement.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the implementation in `ProfileComponent` will be a bit different.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `ngOnChanges` event handler, leveraging the base `patchUpdatedDataIfChanged`
    behavior:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that in `patchUpdatedDataIfChanged`, setting `onlySelf` to `false` will
    cause the parent form also to update. You can override the function if you’d like
    to optimize this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you have a fully implemented `NameInputComponent` that you can integrate
    into `ProfileComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: To verify your `ProfileComponent` code going forward, refer to `projects/stage11/src/app/user/profile/profile.component.ts`
    and `projects/stage11/src/app/user/profile/profile.component.html`.
  prefs: []
  type: TYPE_NORMAL
- en: Before you begin using `NameInputComponent`, perform the following refactors.
  prefs: []
  type: TYPE_NORMAL
- en: Refactor `ProfileComponent` to extend `BaseFormComponent` and conform to its
    default values as needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a readonly `nameInitialData$` property with the `BehaviorSubject<IName>`
    type, and initialize it with empty strings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the content in `ProfileComponent` with the new `<app-name-input>` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the base form component function, `registerForm`, is leveraged here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensure that your `ngOnInit` is implemented correctly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that some additional refactors are present on the updated `ProfileComponent`,
    such as the `patchUser` function seen in the following snippet. Don’t miss these
    updates when you update your component.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: It is important to update the current form’s data with `pathUpdatedData`, as
    well as `nameInitialData$`, when there’s an update to `initialData`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensure that `ngOnDestroy` is implemented correctly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can leverage the base class functionality to deregister from all child forms
    automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s learn about masking user input to increase our data quality.
  prefs: []
  type: TYPE_NORMAL
- en: Input masking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Masking user input is an input UX tool and also a data quality one. I’m a fan
    of the `ngx-mask` library, which makes it easy to implement input masking in Angular.
    We will demonstrate input masking by updating the phone number input field, ensuring
    that users input a valid phone number, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B20960_08_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.11: Phone number field with input masking'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set up your input masking as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Install the library via npm with `npm i ngx-mask`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Either use the environment provider, `provideEnvironmentNgxMask()`, in `app.config.ts`
    or `provideNgxMask()` in your feature module, `user.module.ts`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the `NgxMaskDirective` in `profile.component.html`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the `number` field in `ProfileComponent` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: And it’s that simple. You can learn more about the module and its capabilities
    on GitHub at [https://github.com/JsDaddy/ngx-mask](https://github.com/JsDaddy/ngx-mask).
  prefs: []
  type: TYPE_NORMAL
- en: Custom controls with ControlValueAccessor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we’ve learned about forms using standard form controls and input controls
    provided by Angular Material. However, it is possible for you to create custom
    user controls. If you implement the `ControlValueAccessor` interface, then your
    custom controls will play nicely with forms and the `ControlValueAccessor` interface’s
    validation engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be creating the custom rater control shown in the following screenshot
    and will place it as a control on the first step of `ProfileComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B20960_08_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.12: The lemon rater user control'
  prefs: []
  type: TYPE_NORMAL
- en: User controls are inherently highly reusable, tightly coupled, and customized
    components to enable rich user interactions. Let’s implement one.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a custom rating control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Lemon Rater will dynamically highlight the number of lemons selected as
    the user interacts with the control in real time. As such, creating a high-quality
    custom control is an expensive endeavor. However, it is entirely worthwhile to
    spend the effort on elements of your application that define your brand and/or
    make up the core of the UX.
  prefs: []
  type: TYPE_NORMAL
- en: The Lemon Rater is a modified version of Jennifer Wadella’s Galaxy Rating App
    sample found at [https://github.com/tehfedaykin/galaxy-rating-app](https://github.com/tehfedaykin/galaxy-rating-app).
    I highly recommend watching Jennifer’s Ng-Conf 2019 talk on `ControlValueAccessor`,
    linked in the *Further reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Set up your custom rating control as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Generate a new component called `LemonRater` under the `user-controls` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `LemonRater`, implement the `ControlValueAccess` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `NG_VALUE_ACCESSOR` provider with the `multi` property set to `true`.
    This will register our component with the form’s change events, so form values
    can be updated when the user interacts with the rater:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`forwardRef` allows us to refer to components not yet defined. There’s more
    at [https://angular.dev/api/core/forwardRef](https://angular.dev/api/core/forwardRef).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement a custom rating scheme with a function, allowing us to set the selected
    rating based on user input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that by using `@ViewChild`, we’re getting the HTML element named `#displayText`
    (highlighted in the following template). Using `setSelectText`, we replace the
    `textContent` of the element.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement the template, referring to the sample code for the contents of the
    `svg` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The three most important attributes in the template are `mouseover`, `mouseout`,
    and `click`. The `mouseover` attribute displays the text for the rating the user
    is currently hovering over, `mouseout` resets the display text to the selected
    value, and `click` calls the `setRating` method we implemented to record the user’s
    selection. However, the control can have even richer user interactivity by highlighting
    the number of lemons when the user hovers over a rating or selects it. We will
    accomplish this via some CSS magic.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement the CSS for the user control:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The most interesting bit is with `.lemons .lemon:hover~.lemon #fill-area`.
    Note that the operator `~` , or the general sibling combinator, selects a range
    of elements so that a dynamic number of lemons will be highlighted as the user
    hovers over them.'
  prefs: []
  type: TYPE_NORMAL
- en: '`#fill-area` refers to a `<path>` defined within the lemon .`svg`, allowing
    the lemon’s color to be adjusted dynamically. I had to manually inject this ID
    field into the .`svg` file.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s see how you can use this new user control in a form.
  prefs: []
  type: TYPE_NORMAL
- en: Using custom controls in forms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use the lemon rater in the `profile` component to capture the Limoncu
    level of the employee.
  prefs: []
  type: TYPE_NORMAL
- en: Limoncu is a Turkish word for a person who grows or sells lemons, and it is
    also LemonMart’s proprietary employee engagement and performance measurement system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s integrate the lemon rater:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by importing the `LemonRaterComponent` in `profile.component.ts`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Ensure that the level form control is initialized in `buildForm`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Insert the lemon rater as the last element of the first `mat-step`, inside
    the `form` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We integrate with the custom control by implementing `formControlName` like
    any other control.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You should have a working custom control that is integrated
    with your form.
  prefs: []
  type: TYPE_NORMAL
- en: Layouts using a grid list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Flex Layout library is great for laying out content using CSS Flexbox.
    Angular Material provides another mechanism to lay out content, using CSS Grid
    with its Grid List functionality. A good way to demonstrate this functionality
    is by implementing a helpful list of fake login information in the `LoginComponent`,
    demonstrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B20960_08_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.13: Login helper with the grid list'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement your list as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by defining a `roles` property that is an array of all the roles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Import `MatExpansionModule` and `MatGridListModule` in `login.component.ts`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement a new `mat-card-content` below the existing one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the new `mat-card-content`, put in a label to display the authentication
    mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Beneath the label, implement an expansion list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After `mat-expansion-panel-header`, in the area marked with ellipses in the
    preceding step, implement a table of roles and email addresses, along with some
    hint text regarding password length, using `mat-grid-list`, as shown in the following
    code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We use `colspan` to control the width of each row and cell. We leverage `fxLayoutAlign`
    to right-align the contents of the **E-mail** column. We use `@if; @else` control
    flow operators to selectively display content. Finally, a **Fill** button helps
    us to populate the login form with fake login information.
  prefs: []
  type: TYPE_NORMAL
- en: In your application, you can use an expansion panel to communicate password
    complexity requirements to your users.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about expansion panels at [https://material.angular.io/components/expansion](https://material.angular.io/components/expansion)
    and Grid List at [https://material.angular.io/components/grid-list/overview](https://material.angular.io/components/grid-list/overview).
  prefs: []
  type: TYPE_NORMAL
- en: Restoring cached data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the beginning of the chapter, when implementing the `updateUser` method
    in `UserService`, we cached the `user` object in case of any errors that may wipe
    out user-provided data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Consider a scenario where the user may be temporarily offline when they attempt
    to save their data. In this case, our `updateUser` function will save the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how we can restore this data in `ProfileComponent` when loading the
    user profile:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding functions named `loadFromCache` and `clearCache` to the `ProfileComponent`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After loading the data, we parse the data into a JSON object, using `JSON.parse`,
    and then hydrate the `User` object with `User.Build`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the template to call the `clearCache` function so that when the user
    resets the form, we also clear the cache:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update `ngOnInit` to conditionally load data from the cache or the latest `currentUser$`
    from `authService`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We leverage the `combineLatest` operator to combine the outputs of `loadFromCache`
    and `currentUser$`. We check that one of the streams returns a non-null value.
    If a cached user exists, it precedes the value received from `currentUser$`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can test your cache by setting the network status of your browser to offline,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B20960_08_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.14: Offline network status'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the network status of your browser to offline as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In Chrome DevTools, navigate to the **Network** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Offline** in the dropdown marked as **2** in the preceding screenshot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the form data, such as the name, and hit **Update**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You’ll see an error reading **An unknown error has occurred**, displayed at
    the bottom of the form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You’ll see that your PUT request has failed in the **Network** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, refresh your browser window, and observe that the new name you entered
    is still present.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Refer to the following screenshot, which shows the toast notification you get
    after loading data from the cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B20960_08_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.15: Data loaded from the cache'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a great caching UX is incredibly challenging. I provided a rudimentary
    method to show what is possible. However, many edge cases can impact how caching
    in your application works.
  prefs: []
  type: TYPE_NORMAL
- en: In my case, the cache stubbornly sticks around until we successfully save the
    data to the server. This may be frustrating for some users.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You’ve successfully implemented a sophisticated form to capture
    data from your users!
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Practice new concepts like signals and `@defer` in Angular by updating `UserService`
    and the multi-step `ProfileComponent` form:'
  prefs: []
  type: TYPE_NORMAL
- en: Update `UserService` and its related components to use `signal` instead of `BehaviorSubject`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `@defer` to delay the rendering of conditional views.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement an expansion panel in `LoginComponent` to communicate password complexity
    requirements to your users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered forms, directives, and user control-related functionality
    for LemonMart. Using data binding, we created reusable components that can be
    embedded within another component. We showed that you can use PUT to send data
    to a server and cache data input by a user. We also created a multi-step input
    form that is responsive to changing screen sizes. We removed the boilerplate code
    from our components by leveraging reusable form parts, a base form class to house
    common functionality, and an attribute directive to encapsulate field-level error
    behavior and messages.
  prefs: []
  type: TYPE_NORMAL
- en: We created dynamic form elements with a date picker, typeahead support, and
    form arrays. We implemented interactive controls with input masking and the lemon
    rater. Using the `ControlValueAccessor` interface, we integrated the lemon rater
    seamlessly with our form. We showed that we can scale the size and complexity
    of our forms linearly by extracting the name as its form section. Additionally,
    we covered building layouts using a grid list.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will further enhance our components to orchestrate them
    using the router. We will also implement a master/detail view and a data table
    and explore NgRx as an alternative to RxJS/BehaviorSubject.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Reactive forms*, 2024: [https://angular.dev/guide/forms/reactive-forms](https://angular.dev/guide/forms/reactive-forms)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Attribute directives*, 2024: [https://angular.dev/guide/directives/attribute-directives](https://angular.dev/guide/directives/attribute-directives)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Meet Angular’s New Control Flow*, 2023: [https://blog.angular.io/meet-angulars-new-control-flow-a02c6eee7843](https://blog.angular.io/meet-angulars-new-control-flow-a02c6eee7843
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*rxweb: Good way to show the error messages in Angular Reactive Forms*, Ajay
    Ojha, 2019: [https://medium.com/@oojhaajay/rxweb-good-way-to-show-the-error-messages-in-angular-reactive-forms-c27429f51278](https://medium.com/@oojhaajay/rxweb-good-way-to-show-the-error-messages-in-angular-reactive-forms-c27429f51278)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Control Value Accessor*, Jennifer Wadella, 2019: [https://www.youtube.com/watch?v=kVbLSN0AW-Y](https://www.youtube.com/watch?v=kVbLSN0AW-Y)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*CSS Combinators*, 2020: [https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors#Combinators](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors#Combinators
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Memoization in JavaScript*, Sumit Kumar Singh, 2023: [https://designtechworld.medium.com/memoization-in-javascript-282d5fad29c8](https://designtechworld.medium.com/memoization-in-javascript-282d5fad29c8
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Why you should never use function calls in Angular template expressions*,
    Jurgen Van de Moere, 2019: [https://medium.com/showpad-engineering/why-you-should-never-use-function-calls-in-angular-template-expressions-e1a50f9c0496](https://medium.com/showpad-engineering/why-you-should-never-use-function-calls-in-angular-template-expressions-e1a50f9c0496)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions as best as possible to ensure you’ve understood
    the key concepts from this chapter without googling anything. Do you know if you
    got all the answers right? Visit [https://angularforenterprise.com/self-assessment](https://angularforenterprise.com/self-assessment)
    for more:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between a component and a user control?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an attribute directive?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the `@`-syntax?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of the `ControlValueAccessor` interface?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is serialization, deserialization, and hydration?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does it mean to patch values on a form?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you associate two independent `FormGroup` objects with each other?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
