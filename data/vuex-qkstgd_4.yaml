- en: Coding the EveryNote App Using Vuex State Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Vuex 状态管理编写 EveryNote 应用程序代码
- en: In this chapter, we will develop an application to take notes, called *EveryNote*,
    from scratch. In the first part of the chapter we will analyze and design the
    application, as well as preparing the folder structure for the project.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从头开始开发一个名为 *EveryNote* 的记事应用程序。在章节的第一部分，我们将分析和设计应用程序，并为项目准备文件夹结构。
- en: After that, we will build the application incrementally through tests and code.
    This application will be developed while writing this chapter, providing a real-world
    Vuex development example.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将通过测试和代码逐步构建应用程序。这个应用程序将在编写本章的同时开发，提供一个现实世界的 Vuex 开发示例。
- en: The application can be downloaded by cloning the `https://github.com/PacktPublishing/-Vuex-Condensed`
    Git repository. Each section of this chapter has a corresponding Git tag that
    can be used to download the code that has been written for that section.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过克隆 `https://github.com/PacktPublishing/-Vuex-Condensed` Git 仓库来下载应用程序。本章的每个部分都有一个相应的
    Git 标签，可以用来下载为该部分编写的代码。
- en: 'While reading this chapter, you will learn how to do the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章时，您将学习以下内容：
- en: Design and develop an application exploiting Vuex features
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用 Vuex 功能设计和开发应用程序
- en: Use Vuex inside Vue components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Vue 组件中使用 Vuex
- en: Test Vue/Vuex components effectively
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效测试 Vue/Vuex 组件
- en: Use actions to handle asynchronous operations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用操作来处理异步操作
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will be required to have Node.js installed on a system. Finally, to use
    the Git repository of this book, the user needs to install Git.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在系统上安装 Node.js。最后，为了使用本书的 Git 仓库，用户需要安装 Git。
- en: 'The code files of this chapter can be found on GitHub:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在 GitHub 上找到：
- en: '[https://github.com/PacktPublishing/Vuex-Quick-Start-Guide/tree/master/chapter-4](https://github.com/PacktPublishing/Vuex-Quick-Start-Guide/tree/master/chapter-4)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Vuex-Quick-Start-Guide/tree/master/chapter-4](https://github.com/PacktPublishing/Vuex-Quick-Start-Guide/tree/master/chapter-4)'
- en: 'Check out the following video to see the code in action:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际运行情况：
- en: '[https://goo.gl/QaPP1Q](https://goo.gl/QaPP1Q)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://goo.gl/QaPP1Q](https://goo.gl/QaPP1Q)'
- en: Designing the EveryNote web app
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计 EveryNote 网络应用程序
- en: One way to start designing an application is by creating mock-ups of the user
    interfaces. This way, you can present your mock-ups to your stakeholders, discuss
    them, update your mock-ups accordingly, and resubmit them to stakeholders. This
    can be done before you start developing.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 设计应用程序的一种方法是通过创建用户界面的原型。这样，您可以向利益相关者展示您的原型，讨论它们，相应地更新您的原型，并将它们重新提交给利益相关者。这可以在您开始开发之前完成。
- en: 'The EveryNote app will look like the following mock-up:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: EveryNote 应用程序将看起来像以下原型：
- en: '![](img/dbfb3a8a-4524-4637-bd18-ef9729a75f07.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dbfb3a8a-4524-4637-bd18-ef9729a75f07.png)'
- en: 'Figure 3.2: EveryNote mock-up interface'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2：EveryNote 原型界面
- en: 'The application will have the following features:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将具有以下功能：
- en: Create new notes
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新笔记
- en: Show all notes
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示所有笔记
- en: Update an existing note
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新现有笔记
- en: Delete a note
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除笔记
- en: Save notes to `LocalStorage`
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将笔记保存到 `LocalStorage`
- en: 'After basic features are implemented, we will also add two more features:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本功能实现后，我们还将添加两个更多功能：
- en: Search among notes
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在笔记中搜索
- en: Pin a note
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁定笔记
- en: In a real-world application, you may need user stories to better define what
    the behaviors expected are and, thus, what programmers should code. These stories
    can be tested, and this type of test is called an acceptance test.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的应用程序中，您可能需要用户故事来更好地定义预期的行为，从而确定程序员应该编写的代码。这些故事可以接受测试，这种类型的测试称为验收测试。
- en: In this case, the EveryNote features are simple and well defined, so we can
    begin by picking a feature and starting to develop it.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，EveryNote 的功能简单且定义良好，因此我们可以先选择一个功能并开始开发。
- en: Application structure
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序结构
- en: 'Vuex proposes an application-generic structure, which we will adopt. The following
    is the folder structure:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Vuex 提出了一种通用的应用程序结构，我们将采用。以下是其文件夹结构：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We are now going to create the project scaffold by adding some files to the
    `notes-app` folder we created at the beginning of this chapter.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将通过向本章开头创建的 `notes-app` 文件夹中添加一些文件来创建项目框架。
- en: 'The first file to be created is `index.html`. As for any Vue.js application,
    we need to put the root container for the Vue/Vuex application inside the body
    as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首个要创建的文件是 `index.html`。对于任何 Vue.js 应用程序，我们需要将 Vue/Vuex 应用的根容器放在 body 中，如下所示：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The second file is `main.js`. It contains the code to startup the Vue.js part
    of the application:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个文件是`main.js`。它包含启动应用Vue.js部分的代码：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now that the Vue application is ready, we can add Vuex to it by creating `index.js`
    inside the `store` folder:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Vue应用已经准备好了，我们可以通过在`store`文件夹内创建`index.js`来向其中添加Vuex：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, we create the root Vue component of the *EveryNote* app as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们按照以下方式创建*EveryNote*应用的根Vue组件：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Clone the `book` repository and use `git checkout step-0_project-scaffold` to
    see all the project files for this step.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 克隆`book`仓库，并使用`git checkout step-0_project-scaffold`来查看此步骤的所有项目文件。
- en: Now that the project scaffold is ready, we can start coding the first feature.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在项目骨架已经准备好了，我们可以开始编写第一个功能了。
- en: Developing the EveryNote app
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发EveryNote应用
- en: In the following paragraphs, I will develop the application using test-driven
    development. You don't need to know TDD to understand what I will be doing. You
    will first be presented with a test asserting what the code should do as if it
    were already implemented, and then, just after, you will see the implementation.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的段落中，我将使用测试驱动开发来开发应用。你不需要了解TDD就能理解我将要做什么。你首先会看到一个断言代码应该做什么的测试，然后，紧接着，你会看到实现。
- en: But why use TDD in this book?
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么这本书要使用TDD（测试驱动开发）呢？
- en: One reason is that I think it is easier to understand what the code is supposed
    to do by reading assertions about its behavior inside the test code, rather than
    inferring its behavior from implementation code.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一个原因是，我认为通过阅读测试代码中对代码行为的断言来理解代码的意图比从实现代码中推断其行为要容易。
- en: Another reason is that it is easier to understand how to test a component while
    writing the component rather than having a (boring) chapter on testing components.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个原因是，在编写组件的同时测试组件比有一个（无聊的）关于测试组件的章节要容易理解。
- en: Using a to-do list to help the development process
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用待办事项列表来帮助开发过程
- en: I find that writing a to-do list in a file is useful for reminding me what needs
    to be done. I also find it helpful to note down doubts and simple notes on things
    I need to deal with.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现将待办事项列表写入文件对于提醒我需要做什么很有用。我还发现记录需要处理的事情的疑问和简单笔记很有帮助。
- en: This to-do list is a simple `.txt` file that changes over time, and will hopefully
    be empty when the app is finished. I also put this file under `Git revision`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这个待办事项列表是一个简单的`.txt`文件，随着时间的推移会发生变化，并希望当应用完成时它是空的。我还把这个文件放在`Git修订版`下。
- en: 'The initial `To-do` list looks like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 初始的`To-do`列表看起来像这样：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: I use the `*` symbol to mark the current feature under development.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用`*`符号来标记当前正在开发的功能。
- en: Displaying a list of notes
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示笔记列表
- en: I will start by displaying a list of notes because the other features depend
    on it. Another possible feature to start with is the ability to create a new note.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我将首先显示笔记列表，因为其他功能依赖于它。另一个可能的起始功能是创建新笔记的能力。
- en: In order to display a list of notes, we need to add that list to the application's
    `Vuex.Store`. Then we need a Vue component that uses the store to display the
    notes.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示笔记列表，我们需要将该列表添加到应用的`Vuex.Store`中。然后我们需要一个使用该存储来显示笔记的Vue组件。
- en: 'The first test is about defining a note list inside the application''s main
    store:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试是关于在应用的主存储中定义笔记列表：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, define the implementation:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义实现：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'From now on, you will first see a frame detailing a component''s tests, and,
    just after, a frame with the code implementation. You will be provided with a
    description of test-driven development later on in this chapter. For now, it is
    important that you understand that TDD has a pace: one test, one piece of production
    code, one test, one piece of production code, and so on.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，你将首先看到一个详细说明组件测试的框架，紧接着是一个带有代码实现的框架。你将在本章后面提供关于测试驱动开发的描述。现在，重要的是你要理解TDD有一个节奏：一个测试，一段生产代码，一个测试，一段生产代码，等等。
- en: 'This is also referred to as red, green, refactor:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这也被称为红、绿、重构：
- en: '**Red**: You write a small test and the result of executing it is a test failing—you''ll
    see red in the test console.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**红**：你编写一个小测试，执行它的结果是测试失败——你会在测试控制台中看到红色。'
- en: '**Green**: You make the test pass in the easiest way—you''ll see green in the
    test console. Duplicating code in this step is allowed.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绿色**：你以最简单的方式使测试通过——你会在测试控制台中看到绿色。在这个步骤中允许复制代码。'
- en: '**Refactor**: You remove code duplication and improve code quality if you feel
    it is necessary.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重构**：如果你觉得有必要，你会移除代码重复并提高代码质量。'
- en: The next step is creating a Vue component `noteList` to show the list of notes.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个 Vue 组件`noteList`来显示笔记列表。
- en: 'Test code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代码：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Application code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 应用代码：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Even though I put together all of these tests in one place for better readability,
    I didn't write the three tests and then the code. I wrote the first test, then
    the code, then the next test, and so on. Remember the red-green-refactor pattern!
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我把所有的这些测试放在一起以提高可读性，但我并不是先写三个测试，然后写代码。我是先写第一个测试，然后写代码，然后写下一个测试，以此类推。记住红绿重构模式！
- en: 'In order to write the `NoteList` code I needed three tests:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写`NoteList`代码，我需要三个测试：
- en: The first test checks that there is a computed property named `notes` that exposes
    `state.store.NoteList`
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个测试检查是否存在一个名为`notes`的计算属性，它暴露`state.store.NoteList`
- en: The second test ensures that each note inside `notes` is rendered in the template
    section
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个测试确保`notes`中的每个笔记都在模板部分被渲染
- en: Finally, the last test ensures that the note's title and content are rendered
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，最后一个测试确保笔记的标题和内容被渲染
- en: In addition, there is some code to set up the test environment in order to mock
    the store and create the component. Each item being tested should be isolated.
    This means that we cannot use the real store, and we need to provide a mocked
    one for each component being tested.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些代码用于设置测试环境，以便模拟商店并创建组件。每个要测试的项目都应该被隔离。这意味着我们不能使用真实的商店，我们需要为每个要测试的组件提供一个模拟的。
- en: There is a framework, `vue-test-utils`, that can be used to test Vue components.
    I decided not to use it for the sake of keeping the examples in this book simple.
    You may want to use it when writing your applications.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个框架，`vue-test-utils`，可以用来测试 Vue 组件。我决定不使用它，以便保持本书中的示例简单。你可能想在编写你的应用程序时使用它。
- en: We can now proceed to the next feature, but I would first like to see some notes
    actually shown in the browser before moving on. To achieve this, we can temporarily
    add two notes to the store and add the `NoteList` component to `App.vue`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以继续到下一个功能，但在继续之前，我首先想看到一些笔记实际上在浏览器中显示。为了实现这一点，我们可以暂时在商店中添加两个笔记，并将`NoteList`组件添加到`App.vue`中。
- en: 'Test code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代码：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Application code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 应用代码：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following is a screenshot of the result:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图是结果：
- en: '![](img/538f970e-6aad-49d0-8b8e-ac8a05d2e794.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/538f970e-6aad-49d0-8b8e-ac8a05d2e794.png)'
- en: 'Figure 3.3: List of notes'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3：笔记列表
- en: Right now, the result is ugly; I will add some CSS to make it much better looking
    after all the main features are implemented.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，结果看起来很丑；在所有主要功能实现后，我将添加一些 CSS 使其看起来更好。
- en: 'You can download the code at this stage by typing:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过输入以下命令来下载此阶段的代码：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Creating new notes
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新笔记
- en: 'At this point, the `To-do` list looks like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`待办事项`列表看起来是这样的：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The next feature I will implement is the ability to create new notes. For this
    feature, we need a `NoteEditor` component, a store property named `currentNote`,
    an action named `addNote`, and two mutations: `UPDATE_CURRENT_NOTE` and `ADD_NOTE`.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我将实现的新功能是创建新笔记的能力。为此功能，我们需要一个`NoteEditor`组件，一个名为`currentNote`的商店属性，一个名为`addNote`的操作，以及两个突变：`UPDATE_CURRENT_NOTE`和`ADD_NOTE`。
- en: The idea is that when a user writes in the note editor, the `currentNote` store
    property gets updated. When he taps on the Add note button, the `addNote` action
    is fired, resulting in the new note added to the note list. Let's add the `currentNote`
    property to the application store.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是，当用户在笔记编辑器中编写时，`currentNote`商店属性会更新。当他点击添加笔记按钮时，会触发`addNote`操作，导致新笔记被添加到笔记列表中。让我们将`currentNote`属性添加到应用商店中。
- en: 'Test code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代码：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Application code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 应用代码：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You may wonder why I added a test just to verify that the `currentNote` field
    is inside the app store. The idea here is that I am not writing tests to test
    that the application works properly—I am writing tests to write production code.
    In order to modify any line of the application code, I need a test to justify
    the fact that I am writing production code.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么我添加了一个测试只是为了验证`currentNote`字段是否在应用商店中。这里的想法是，我并不是在编写测试来测试应用程序是否正常工作——我是在编写测试来编写生产代码。为了修改应用代码的任何一行，我需要一个测试来证明我正在编写生产代码。
- en: 'This is the first of the three TDD rules (by Robert C. Martin, aka Uncle Bob):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这是罗伯特·C·马丁（Robert C. Martin，又称Uncle Bob）提出的三个 TDD 规则中的第一个：
- en: You are not allowed to write any production code unless it makes a failing unit
    test pass
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非它能让失败的单元测试通过，否则不允许编写任何生产代码
- en: 'The other two are as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个如下：
- en: You are not allowed to write any more of a unit test that is sufficient to fail,
    and compilation failures are failures
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不允许再编写任何足以失败的单元测试，编译失败也是失败
- en: You are not allowed to write any more production code that is sufficient to
    pass the one failing unit test
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不允许再编写任何更多足以通过一个失败的单元测试的生产代码
- en: So why didn't I write any tests when I added two fake notes to the store and
    modified `App.vue` to use the `NoteList` component? Because that is temporary
    code and not production code. I will remove those modifications before the app
    is completed.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 所以为什么我在向存储中添加两个假笔记并修改 `App.vue` 以使用 `NoteList` 组件时没有编写任何测试？因为那是临时代码，不是生产代码。在应用程序完成之前，我将删除这些修改。
- en: Now that `currentNote` is defined, I can write an `UPDATE_CURRENT_NOTE` mutation.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `currentNote` 已经定义，我可以编写一个 `UPDATE_CURRENT_NOTE` 突变。
- en: 'Test code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代码：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Application code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 应用代码：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Next, create the `NoteEditor` component.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建 `NoteEditor` 组件。
- en: 'Test code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代码：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Application code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 应用代码：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In order to code the `NoteEditor` component, I tested that the computed `content`
    and `title` properties were properly linked to `$store.state.currentNote`, and
    that these properties were used in the `template` section.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写 `NoteEditor` 组件，我测试了计算属性 `content` 和 `title` 是否正确链接到 `$store.state.currentNote`，以及这些属性是否在
    `template` 部分中使用。
- en: As with the tests for the `NoteList` component, the first part of the `test`
    file is just some code to create the component under `test`. I will avoid repeating
    that part from now on.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `NoteList` 组件的测试一样，`test` 文件的第一部分只是创建 `test` 下的组件的一些代码。从现在起，我将避免重复这部分代码。
- en: The next step is creating the `addNote` action and the corresponding mutation
    so that I can update `NoteEditor` to dispatch this action when a user presses
    the Add note button. Following is the `ADD_NOTE` mutation.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建 `addNote` 动作和相应的突变，以便我可以在用户按下添加笔记按钮时更新 `NoteEditor` 来分发此动作。以下是 `ADD_NOTE`
    突变。
- en: 'Test code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代码：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Application code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 应用代码：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Following is the `addNote` action tests:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 `addNote` 动作测试：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Following is the application code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是应用程序代码：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Finally, I can update `NoteEditor` to dispatch the `addNote` action and see
    that the note list gets updated. First, let's update `NoteEditor`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我可以更新 `NoteEditor` 来分发 `addNote` 动作，并看到笔记列表已更新。首先，让我们更新 `NoteEditor`。
- en: 'Test code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代码：
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Application code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 应用代码：
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now let''s add `actions` to the store:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们向存储中添加 `actions`：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: and `NoteEditor` to `App.vue`
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 并将 `NoteEditor` 添加到 `App.vue`
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'After having added some CSS to the components and restyling the application
    a bit, it now looks like the following figure:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在为组件添加了一些 CSS 并稍微重新设计应用程序之后，它现在看起来像以下图示：
- en: '![](img/831c78fb-1eda-4d3e-8e19-5f3d3626785a.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/831c78fb-1eda-4d3e-8e19-5f3d3626785a.png)'
- en: 'Figure 3.4: EveryNote restyled'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4：EveryNote 重新设计
- en: 'You can download the code at this stage by typing the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过输入以下内容在此阶段下载代码：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Deleting existing notes
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除现有笔记
- en: 'The next feature I am going to implement is the ability to delete notes. The
    following is the updated `To-do` list:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我接下来要实现的功能是删除笔记的能力。以下是被更新的 `待办` 列表：
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In order to let users delete notes, I need to update the note frame to have
    a delete button, add a `deleteNote` action, and add a `DELETE_NOTE` mutation.
    Finally, I will extract the note frame code from `NoteList` and create a `Note`
    component. Let's create the `DELETE_NOTE` mutation.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让用户能够删除笔记，我需要更新笔记框架以包含一个删除按钮，添加一个 `deleteNote` 动作，并添加一个 `DELETE_NOTE` 突变。最后，我将从
    `NoteList` 中提取笔记框架代码并创建一个 `Note` 组件。让我们创建 `DELETE_NOTE` 突变。
- en: 'Test code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代码：
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Application code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 应用代码：
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Then let's add `deleteNote` to the actions.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们将 `deleteNote` 添加到动作中。
- en: 'Test code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代码：
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Application code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 应用代码：
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now let''s refactor the `NoteList` component to use a new component named `Note`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们重构 `NoteList` 组件以使用一个名为 `Note` 的新组件：
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then we move the test of the note rendering from the `NoteList` to the `Note`
    component:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将笔记渲染的测试从 `NoteList` 移动到 `Note` 组件：
- en: '[PRE35]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, let''s write the new `Note` component:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们编写新的 `Note` 组件：
- en: '[PRE36]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Finally, we can add a delete button to the `Note` component, which will dispatch
    a `deleteNote` action upon being clicked:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在 `Note` 组件中添加一个删除按钮，当点击时将分发 `deleteNote` 动作：
- en: '[PRE37]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Following is the updated `Note.vue` code that will make the test pass:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是更新后的 `Note.vue` 代码，这将使测试通过：
- en: '[PRE38]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In order to run the preceding code, you need a `delete.svg` file. You can find
    it in the Git repository of this book, or you can use another image.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行前面的代码，你需要一个 `delete.svg` 文件。你可以在本书的 Git 仓库中找到它，或者你可以使用另一张图片。
- en: 'You can download the code at this stage by typing the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过输入以下内容在此阶段下载代码：
- en: '[PRE39]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Updating existing notes
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新现有笔记
- en: 'In order to edit an existing note, we could reuse the `NoteEditor` component.
    Right now, this component is linked to the `currentNote` property of the main
    store, but we could use a property to pass the note to be edited, thereby removing
    its dependency from the main store. This kind of generalization is common while
    developing Vuex applications, and often leads to two kinds of components:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编辑现有的笔记，我们可以重用 `NoteEditor` 组件。目前，这个组件与主存储的 `currentNote` 属性相关联，但我们可以使用一个属性来传递要编辑的笔记，从而消除其对主存储的依赖。这种泛化在开发
    Vuex 应用程序时很常见，通常会导致两种类型的组件：
- en: '**Dumb components**: These do not alter or handle application states; they
    just receive input through properties and dispatch events'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**“哑”组件**：这些不改变或处理应用程序状态；它们只是通过属性接收输入并派发事件'
- en: '**Smart components**: These serve as containers for the dumb components; they
    handle interactions between child components and are dependent on Vuex elements,
    such as application states and actions'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**智能组件**：这些作为“哑”组件的容器；它们处理子组件之间的交互，并依赖于 Vuex 元素，如应用程序状态和动作'
- en: A dumb component should be designed to be reusable, whereas a smart component
    should be designed to be application dependent.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: “哑”组件应该设计成可重用的，而“智能”组件应该设计成与应用程序依赖。
- en: '`NoteEditor` can be refactored into a `dumb` component, letting its parent
    link it to the application''s state.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`NoteEditor` 可以重构为一个“哑”组件，让它的父组件将其链接到应用程序的状态。'
- en: 'I noted down these considerations on the `To-do` list:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我将这些考虑记录在“待办”列表上：
- en: '[PRE40]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As you may have noticed, I am also considering transforming `NoteList` into
    a dumb component so that it can be used to show different lists of notes, such
    as the pinned notes or the notes that match certain search keywords.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我还在考虑将 `NoteList` 转换为“哑”组件，以便它可以用来显示不同的笔记列表，例如已固定笔记或匹配特定搜索关键字的笔记。
- en: 'Let''s start by refactoring `NoteEditor` into a `dumb` component:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从重构 `NoteEditor` 为一个“哑”组件开始：
- en: '[PRE41]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As you can see, the tests do not need to use Vuex anymore, and the tests regarding
    the `currentNote` state property will be moved to its container, which will be
    developed just after this component.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，测试不再需要使用 Vuex，关于 `currentNote` 状态属性的测试将移至其容器，该容器将在本组件开发之后进行。
- en: Also, I decided not to test the `<template>` part of `NoteEditor.vue` because
    the views change often, and I don't want the tests to slow me down when changing
    some part of the UI. In my opinion, it is better to reduce the number of unit
    tests regarding the UI to very few or none. Remember that TDD is about writing
    code, not about testing existing code. You can write automated tests on a piece
    of UI when that piece has settled down and is unlikely to change soon. If you
    agree with me on not testing the views, remember to avoid putting a lot of logic
    in the `<template>` part of a Vue component.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我决定不对 `NoteEditor.vue` 中的 `<template>` 部分进行测试，因为视图经常变化，我不想在更改 UI 的某个部分时让测试拖慢我的进度。在我看来，最好将关于
    UI 的单元测试数量减少到非常少或没有。记住，TDD 是关于编写代码，而不是测试现有代码。当某个 UI 部分稳定下来且不太可能很快发生变化时，你可以在该部分上编写自动化测试。如果你同意我不测试视图的观点，请记住避免在
    Vue 组件的 `<template>` 部分放置太多逻辑。
- en: 'The new `NoteEditor` implementation looks like the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `NoteEditor` 实现如下所示：
- en: '[PRE42]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We now need a container for this component, which is the `App.vue` component,
    plus the code that links `NoteEditor` to the `currentNote` state property:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要一个容器来容纳此组件，即 `App.vue` 组件，以及将 `NoteEditor` 连接到 `currentNote` 状态属性的代码：
- en: '[PRE43]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Following is the code that will make the test pass:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将测试通过的代码：
- en: '[PRE44]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Finally, we need the `editNote` and `updateNote` actions and the corresponding
    mutations. The first one will set the current note under editing and the last
    one will persist changes to the note we just edited.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要 `editNote` 和 `updateNote` 动作以及相应的突变。第一个将设置当前正在编辑的笔记，最后一个将持久化我们刚刚编辑的笔记的更改。
- en: 'Test code:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代码：
- en: '[PRE45]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Application code:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 应用代码：
- en: '[PRE46]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The tests are similar to the other action tests that we completed, so I will
    not repeat them.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 测试与其他我们已完成的行为测试类似，所以我不重复它们。
- en: 'The last step is to update the `Note` component to dispatch an `editNote` action
    when the user presses the edit icon of a note:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将 `Note` 组件更新为当用户点击笔记的编辑图标时触发 `editNote` 动作：
- en: '[PRE47]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'After that, we modify the `App` component to show the note to be edited when
    `editNote` is dispatched:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们修改 `App` 组件，以便在 `editNote` 被分发时显示要编辑的笔记：
- en: '[PRE48]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You can download the code at this stage by typing the following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过输入以下内容来下载此阶段的代码：
- en: '[PRE49]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Other features
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他功能
- en: 'Following is the updated `To-do` list that shows what we''ve done and what''s
    remaining:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是更新的 `待办` 列表，显示了我们已经完成的工作和剩余的工作：
- en: '[PRE50]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: I will not discuss the other features in this book because I think it is now
    clear how Vuex development works and how Vuex applications can be tested. You
    can find the complete application code in the book's repository at `https://github.com/PacktPublishing/-Vuex-Condensed`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会在本书中讨论其他功能，因为我认为现在已经很清楚 Vuex 的开发工作以及如何测试 Vuex 应用程序。你可以在本书的代码仓库中找到完整的应用程序代码，仓库地址为
    `https://github.com/PacktPublishing/-Vuex-Condensed`。
- en: When persisting notes to `localStorage`, instead of saving only the list of
    notes, we will use a Vuex plugin to save all the application states. You will
    read about this in the last chapter of this book, which will introduce you to
    `vuex-persistedstate`, a plugin to persist the Vuex application state with `localStorage`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当将笔记持久化到 `localStorage` 时，我们不仅会保存笔记列表，还会使用 Vuex 插件来保存所有应用程序状态。你将在本书的最后一章中了解到这一点，该章节将介绍
    `vuex-persistedstate` 插件，这是一个用于使用 `localStorage` 持久化 Vuex 应用程序状态的插件。
- en: Recap and some considerations
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述和注意事项
- en: We implemented the so-called CRUD functions, create, read, update, and delete.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了所谓的 CRUD 功能，即创建、读取、更新和删除。
- en: 'The EveryNote application, at this stage, looks like the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，EveryNote 应用看起来如下：
- en: '![](img/701b0ccc-04f1-4bfc-ae15-a33242d583b7.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/701b0ccc-04f1-4bfc-ae15-a33242d583b7.png)'
- en: 'Figure 3.5: EveryNote app with CRUD operations'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5：带有 CRUD 操作的 EveryNote 应用
- en: 'When tapping on the pencil icon, the note editor opens. The following is a
    screenshot of the application in editing mode:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当轻触铅笔图标时，笔记编辑器会打开。以下是在编辑模式下的应用程序截图：
- en: '![](img/dd40c9f4-9abf-4957-b93e-ebad593f2715.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dd40c9f4-9abf-4957-b93e-ebad593f2715.png)'
- en: 'Figure 3.6: EveryNote editing dialog'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6：EveryNote 编辑对话框
- en: 'In order to reach this stage of *EveryNote* development, we used a TDD approach
    and an incremental design and development process. As I promised in the introduction,
    I developed this application while writing this chapter. This means that I did
    not follow an optimal development path—in fact, I had to change some code and
    even delete some tests. That is normal while developing. At any rate, spend more
    time during the design phase in order to avoid architectural mistakes and save
    time during the development phase. In fact, a good design is fundamental, but
    it is also important not to go into too much detail while in this phase. Sometimes,
    people think that TDD bypasses design. That''s completely false—in fact, you will
    pay twice for a mistake: Once in the production code and once in the test code.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了达到这个阶段的 *EveryNote* 开发，我们使用了 TDD 方法以及增量设计和开发过程。正如我在引言中承诺的，我是在编写这一章的同时开发这个应用的。这意味着我没有遵循最优的开发路径——实际上，我不得不更改一些代码，甚至删除一些测试。这在开发过程中是正常的。无论如何，在设计阶段花更多的时间，以避免架构错误并在开发阶段节省时间。事实上，良好的设计是基础，但在这个阶段也不要过于详细。有时，人们认为
    TDD 跳过了设计。这完全错误——事实上，你会为错误付出双倍代价：一次在生产代码中，一次在测试代码中。
- en: Synchronizing with a remote server
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与远程服务器同步
- en: While developing the *EveryNote* application, I decided to write an action for
    each mutation. If an action only commits a mutation, you may avoid writing this
    action and commit the corresponding mutation inside the components. Like Google
    Keep, the *EveryNote* application can be empowered by persisting notes to a remote
    server so that a user can read his or her notes from any computer or mobile device.
    In that case, actions come in handy because they can perform asynchronous operations
    to keep the application state synchronized with a server.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发 *EveryNote* 应用时，我决定为每个突变编写一个操作。如果一个操作只提交一个突变，你可能避免编写这个操作，并在组件内部提交相应的突变。像
    Google Keep 一样，*EveryNote* 应用可以通过将笔记持久化到远程服务器来增强功能，这样用户就可以从任何电脑或移动设备上读取他的或她的笔记。在这种情况下，操作就派上用场，因为它们可以执行异步操作以保持应用程序状态与服务器同步。
- en: I will not implement the code to persist the application state with a remote
    server, but I would like to show you an example of how the list of notes can be
    fetched from a remote server when the app gets loaded.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会实现将应用程序状态持久化到远程服务器的代码，但我将向您展示当应用加载时如何从远程服务器获取笔记列表的示例。
- en: The idea is that when `App.vue` is loaded, we can fire a `loadNotesFromServer`
    action that will update the saved state into the `localStorage` with the list
    of notes from the server.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 策略是当`App.vue`加载时，我们可以触发一个`loadNotesFromServer`动作，该动作将保存的状态更新到`localStorage`中，并包含从服务器获取的笔记列表。
- en: 'Let''s start with the `loadNotesFromServer` action tests:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`loadNotesFromServer`动作测试开始：
- en: '[PRE51]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The action code is as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 动作代码如下：
- en: '[PRE52]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: It is a simplistic implementation—in a real case, you may need to merge the
    list of notes from the server with the notes saved in the `localStorage`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的实现——在实际情况下，你可能需要将服务器获取的笔记列表与保存在`localStorage`中的笔记合并。
- en: 'Then, we alter `App.vue` to dispatch the action:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们修改`App.vue`以分发动作：
- en: '[PRE53]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Finally, we create a mock implementation of the API, moving the two notes from
    the store to the mock API:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建了一个API的模拟实现，将两个笔记从存储移动到模拟API：
- en: '[PRE54]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'You can download the code at this stage by typing the following:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这一阶段通过输入以下内容下载代码：
- en: '[PRE55]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Summary
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we developed the *EveryNote* application, going through the
    Vuex concepts and looking at how to use Vuex in a real application's development.
    We also looked at the TDD basics and saw how Vue/Vuex elements can be tested.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开发了*EveryNote*应用程序，了解了Vuex的概念，并探讨了如何在真实应用程序的开发中使用Vuex。我们还学习了TDD的基础知识，并看到了Vue/Vuex元素如何进行测试。
- en: But what about debugging? Even with tests, a debug is sometimes needed. The
    next chapter will explain how web applications can be debugged using browser developer
    tools, as well as how to use `vue-devtools` to easily debug Vue/Vuex applications.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 但关于调试呢？即使有测试，有时也需要调试。下一章将解释如何使用浏览器开发者工具调试Web应用程序，以及如何使用`vue-devtools`轻松调试Vue/Vuex应用程序。
