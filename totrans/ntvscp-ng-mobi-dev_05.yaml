- en: Routing and Lazy Loading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Routing is essential to the solid usability flow of any app. Let's understand
    the key elements of routing configuration for a mobile app that takes advantage
    of all the flexibility Angular's router gives us.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Angular Router with a NativeScript app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lazy loading modules by route
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide NSModuleFactoryLoader for Angular's NgModuleFactoryLoader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding how to use router-outlet in conjunction with page-router-outlet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to share singleton services across multiple lazy loaded modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using auth guards to protect views that require valid authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about `NavigationButton` to customize back mobile navigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take advantage of our flexible routing setup by introducing late feature requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get your kicks on Route 66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we begin our journey down this highway full of adventure, let''s start with
    a pit stop at our local service shop to ensure our vehicle is in tip-top shape.
    Take a turn into the root directory of `app` to build a new add-on to our vehicle''s
    engine: the routing module.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new routing module, `app/app.routing.ts`, with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Defining the root `''''` path to redirect to a lazy loaded module provides
    a very flexible routing configuration, as you will see throughout this chapter.
    You will see a new module, `MixerModule`, which we will create momentarily. In
    fact, it will largely end up being what `AppComponent` is right now. Here''s a
    list of some advantages you gain with a route configuration similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: Keeps app startup time fast by eagerly loading only the bare minimum root module
    configuration, then rapidly loading the first route's module lazily
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides us with the ability to utilize `page-router-outlet` in conjunction
    with `router-outlet` for a combination of master/detail navigation as well as
    the `clearHistory` swap page navigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Isolates routing configuration responsibility to the modules it concerns which
    scales well over time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows us to target different **start pages** easily in the future if we decide
    to change the initial page our users are presented with
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This uses `NativeScriptRoutingModule.forRoot(routes)`, since this should be
    considered the root of our app's routing configuration.
  prefs: []
  type: TYPE_NORMAL
- en: We also export `NativeScriptRoutingModule`, since we will be importing this
    `AppRoutingModule` into our root `AppModule` in a moment. This makes the routing
    directives available to our root module's root component.
  prefs: []
  type: TYPE_NORMAL
- en: Providing NSModuleFactoryLoader for NgModuleFactoryLoader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, Angular's built-in module loader uses SystemJS; however, NativeScript provides
    an enhanced module loader called `NSModuleFactoryLoader`. Let's provide this in
    our main routing module to ensure all our modules are loaded with it instead of
    Angular's default module loader.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make the following modifications to `app/app.routing.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can use the standard Angular lazy loading syntax via `loadChildren`
    by specifying the default `NgModuleFactoryLoader` but should instead use NativeScript's
    enhanced `NSModuleFactoryLoader`. We won't go into what `NSModuleFactoryLoader`
    provides in detail, since it is explained very well here: [https://www.nativescript.org/blog/optimizing-app-loading-time-with-angular-2-lazy-loading](https://www.nativescript.org/blog/optimizing-app-loading-time-with-angular-2-lazy-loading),
    and we have a lot more we want to cover in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Excellent. With these upgrades in place, we can leave the service shop and continue
    on our journey down the highway. Let's move on to implementing our new routing
    setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `app/app.component.html`; cut its contents to the clipboard and replace
    them with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This will be the base of our view level implementation. `page-router-outlet`
    allows any Component to insert itself in its place, whether it be a single flat route
    or one with child views of its own. It also allows other Component views to push
    onto the mobile nav stack, allowing master/detail mobile navigation with back
    history.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for this `page-router-outlet` directive to work, we need our root
    `AppModule` to import our new `AppRoutingModule`. We will also take this opportunity
    to remove `PlayerModule`, which was imported here before. Open `app/app.module.ts`
    and make the following modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Creating MixerModule
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This module really won''t be anything new, as it will serve as a relocation
    of what was previously our root component''s view. However, it will introduce
    an extra nicety: the ability to define its own inner routes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `app/modules/mixer/components/mixer.component.html` and paste the contents
    from where we had cut from the  `app.component.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then create a matching `app/modules/mixer/components/mixer.component.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will create `BaseComponent`, which will serve as the placeholder for
    not only the preceding `MixerComponent` but also any other child view components we
    may want to present in its place. For example, our mixer may want to allow users
    to pop a single track out of the mixer and into an isolated view to work with
    audio effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `app/modules/mixer/components/base.component.ts` with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This provides a slot to insert any child routes our mixer configures, one of
    which is `MixerComponent` itself. Since the view is just a simple `router-outlet`,
    there's really no need to create a separate `templateUrl`, so we have just inlined
    it here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are ready to implement `MixerModule`; create `app/modules/mixer/mixer.module.ts`
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We have imported `PlayerModule` since the mixer uses components/widgets defined
    there (namely, `track-list` and `player-controls`). We are also utilizing the
    `NativeScriptRouterModule.forChild(routes)` method to indicate that these are
    specifically child routes. Our route configuration sets up the BaseComponent at
    the root `'' ''` path, which defines `''home''` as `MixerComponent`. If you recall,
    our app''s `AppRoutingModule` configured the root path of our app, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This will route directly to `MixerComponent` here, defined as `'home'`. We could
    easily direct the start page to a different view by pointing `redirectTo` at a
    different child view of our mixer if we wanted. Since `BaseComponent` is simply
    a `router-outlet`, any children defined underneath the root `' '` of our mixer's
    routes (seen by our the overall app's routes as `'/mixer'`) will insert directly
    in that view slot. If you were to run this right now, you should see the same
    start page we had before.
  prefs: []
  type: TYPE_NORMAL
- en: Congrats! Your app's start time is now fast and you have lazily loaded your
    first module!
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there''s a couple of surprising things to note:'
  prefs: []
  type: TYPE_NORMAL
- en: You may notice a quick white flash before the start page appears (on iOS at
    least)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You might notice the console log prints `` `Current user:` `` twice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will address each of these issues respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Remove the white flash after the splash screen before the start page displays.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is normal and is the result of the default Page background color which
    is white. To provide a seamless launch experience, open the `app/common.css` file
    and drop this global `Page` class definition to tint the background-color to the
    same as our `ActionBar` background-color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now, there will be no more white flash and the launch of the app will appear
    seamless.
  prefs: []
  type: TYPE_NORMAL
- en: The console log prints `` `Current user:` `` twice
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Angular's dependency injector is causing this due to lazy loading.
  prefs: []
  type: TYPE_NORMAL
- en: 'This comes from `app/modules/core/services/auth.service.ts`, where we had a
    private `init` method that was being called from the service''s constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Wait! What?! Does this mean `AuthService` is getting constructed twice??!!
  prefs: []
  type: TYPE_NORMAL
- en: Yes. It does. :(
  prefs: []
  type: TYPE_NORMAL
- en: I can hear the sound of the car's wheels squealing, as you veer off this highway
    adventure into a ditch right about now. ;)
  prefs: []
  type: TYPE_NORMAL
- en: This is most certainly a huge problem, as we absolutely intended for `AuthService`
    to be a globally shared Singleton that could be injected anywhere and shared to
    provide the current authenticated state of our app.
  prefs: []
  type: TYPE_NORMAL
- en: It is imperative we solve this right now, but let's first take a brief detour
    to understand why this is happening before looking at a solid solution.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Angular's Dependency Injector when lazy loading modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Instead of restating the details, we will paraphrase directly from Angular''s
    official documentation (`https://angular.io/guide/ngmodule-faq#!#q-why-child-injector`),
    which explains this perfectly:'
  prefs: []
  type: TYPE_NORMAL
- en: Angular adds `@NgModule.providers` to the application root injector unless the
    module is lazy loaded. For a lazy-loaded module, Angular creates a child injector
    and adds the module's providers to the child injector.
  prefs: []
  type: TYPE_NORMAL
- en: This means that a module behaves differently depending on whether it's loaded
    during application start or lazily loaded later. Neglecting that difference can
    lead to adverse consequences.
  prefs: []
  type: TYPE_NORMAL
- en: Why doesn't Angular add lazy-loaded providers to the app root injector as it
    does for eagerly loaded modules?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is grounded in a fundamental characteristic of the Angular dependency-injection
    system. An injector can add providers until it's first used. Once an injector
    starts creating and delivering services, its provider list is frozen; no new providers
    are allowed.
  prefs: []
  type: TYPE_NORMAL
- en: When an application starts, Angular first configures the root injector with
    the providers of all eagerly loaded modules before creating its first component
    and injecting any of the provided services. Once the application begins, the app
    root injector is closed to new providers.
  prefs: []
  type: TYPE_NORMAL
- en: Time passes and application logic triggers lazy loading of a module. Angular
    must add the lazy-loaded module's providers to an injector somewhere. It can't
    add them to the app root injector because that injector is closed to new providers.
    So Angular creates a new child injector for the lazy-loaded module context.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at our root `AppModule`, we can see it imports `CoreModule`, which
    provides `AuthService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If we then look at `PlayerModule`, we can see it also imports `CoreModule`,
    since the components of `PlayerModule` make use of the `OrderByPipe` it declares
    as well as several of the services it provides (that is, `AuthService`, `LogService`,
    and `DialogService`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`PlayerModule` is now lazily loaded along with `MixerModule` due to our fancy
    new routing configuration. This causes Angular''s dependency injector to register
    a new child injector for our lazily loaded `MixerModule`, which brings along 
    `PlayerModule`, which also brings along its import of `CoreModule`, which defines
    those providers, including `AuthService`, `LogService`, and so on. When Angular registers
    `MixerModule`, it will register all the providers defined throughout the new module,
    including its imported modules with the new child injector, giving rise to the
    new instances of those services being constructed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular''s docs also provide a recommended setup for modules to remedy this
    situation, so let''s paraphrase again from `https://angular.io/guide/ngmodule-faq#!#q-module-recommendations`:'
  prefs: []
  type: TYPE_NORMAL
- en: SharedModule
  prefs: []
  type: TYPE_NORMAL
- en: Create a `SharedModule` with the components, directives, and pipes that you
    use everywhere in your app. This module should consist entirely of declarations,
    most of them exported. The `SharedModule` may re-export other widget modules,
    such as `CommonModule`, `FormsModule`, and modules with the UI controls that you
    use most widely.The `SharedModule` should not have providers for reasons explained
    previously. Nor should any of its imported or re-exported modules have providers.
    If you deviate from this guideline, know what you're doing and why. Import the
    `SharedModule` in your feature modules, both those loaded when the app starts
    and those you lazily load later.
  prefs: []
  type: TYPE_NORMAL
- en: Create a `CoreModule` with providers for the singleton services you load when
    the application starts.
  prefs: []
  type: TYPE_NORMAL
- en: Import `CoreModule` in the root `AppModule` only. Never import `CoreModule`
    in any other module.
  prefs: []
  type: TYPE_NORMAL
- en: Consider making `CoreModule` a pure service module with no declarations.
  prefs: []
  type: TYPE_NORMAL
- en: 'OK wow! That is an excellent recommendation. Particularly worthy of note is
    that very last line:'
  prefs: []
  type: TYPE_NORMAL
- en: Consider making CoreModule a pure service module with no declarations.
  prefs: []
  type: TYPE_NORMAL
- en: So, we already have `CoreModule`, which is great news, but we will want to make
    it a *pure service module with no declarations*. We will also *Import CoreModule
    in the root AppModule only. Never import CoreModule in any other module. *Then,
    we can create a new `SharedModule` to provide just *...**the components, directives,
    and pipes that [we] use everywhere in [our] app*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create `app/modules/shared/shared.module.ts`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'For `PIPES`, we are just moving the pipes directory from `app/modules/core` to
    the `app/modules/shared` folder. Now,  `SharedModule` is the one we can be free
    to import across several different modules that need any pipes or future shared
    components/directives it may provide. It will not define any service providers
    as mentioned by this suggestion:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SharedModule` should not have providers for reasons explained previously,
    nor should any of its imported or re-exported modules have providers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then adjust `CoreModule` (located in `app/modules/core/core.module.ts`)
    as follows to be a pure service module with no declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This module now only defines providers as the collection containing `AuthService`,
    `DatabaseService`, `DialogService`, and `LogService`, all of which we created
    earlier in the book, and we want to ensure they are true Singletons used across
    our app, whether they are used in lazy loaded modules or not.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we use the `...PROVIDERS` spread notation instead of just assigning the
    collection directly?
  prefs: []
  type: TYPE_NORMAL
- en: For scalability reasons. In the future, if we need to add an additional provider
    or override a provider, we can do so simply by just adding to the collection right
    in the module. The same goes for imports and exports.
  prefs: []
  type: TYPE_NORMAL
- en: We also take this opportunity to import some additional modules that we want
    to ensure are also used globally throughout the app. `NativeScriptModule`, `NativeScriptFormsModule`,
    and `NativeScriptHttpModule` are all essential modules that override certain web
    APIs from Angular's various providers out-of-the-box to enhance our app with native
    APIs. For example, instead of the app using `XMLHttpRequest` (which is a web API),
    it will use native HTTP APIs made available on both iOS and Android for the ultimate
    networking performance. We ensure we export these as well so our root module no
    longer needs to import them and can instead just import this `CoreModule`.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we define a constructor that will help safeguard us in the future from accidentally
    importing this `CoreModule` into other lazily loaded modules.
  prefs: []
  type: TYPE_NORMAL
- en: We don't know yet if `PlayerService` provided by `PlayerModule` will be needed
    by `RecorderModule`, which also will be lazily loaded. If that comes up in the
    future, we can also refactor `PlayerService` into `CoreModule` to ensure it's
    a true Singleton shared across our entire app. For now, we will just leave it
    where it is as part of `PlayerModule`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now make our final adjustments to our other modules based on what we have
    done to tighten everything down.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `app/modules/player/player.module.ts` file should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `app/modules/recorder/recorder.module.ts` file should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Notice we now import `SharedModule` instead of `CoreModule`. This provides us
    with the ability to share directives, components, and pipes (essentially anything
    that would be in the declarations portion of the module) across the entire app
    by importing that `SharedModule`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our root `AppModule` at `app/app.module.ts` stays the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Any module (lazy loaded or not) can still inject any services that `CoreModule`
    provides, since the root `AppModule` now imports that `CoreModule`. This allows
    Angular's root injector to construct the services provided by `CoreModule` exactly
    once. Then, any time those services are injected anywhere (*in a lazily loaded
    module or not*), Angular will first ask the parent injector (in the case of a
    lazy loaded module, it would be the child injector) for that service and, if not
    found there, it will ask the next parent making its way to the root injector,
    eventually, where those Singletons are provided.
  prefs: []
  type: TYPE_NORMAL
- en: Well, we've had an amazing time in this desert of a town. Let's cruise on down
    the highway to the ultra secure Area 51, where modules can be locked away for
    years unless proper authorization is presented.
  prefs: []
  type: TYPE_NORMAL
- en: Creating AuthGuard for RecorderModule
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of our app's requirements is that recording features should be locked away
    and inaccessible until a user is authenticated. This provides us with the ability
    to have a user base and potentially introduce paid features down the road if we
    so desire.
  prefs: []
  type: TYPE_NORMAL
- en: Angular provides the ability to insert guards on our routes, which would only
    activate under certain conditions. This is exactly what we need to implement this
    feature requirement, since we have isolated the `'/record'` route to lazily load
    `RecorderModule`, which will contain all the recording features. We want to only
    allow access to that `'/record'` route if the user is authenticated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create `app/guards/auth-guard.service.ts` in a new folder for scalability,
    since we could grow and create other guards as necessary here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We are able to take advantage of `BehaviorSubject` of `AuthService` to grab
    the latest value using `this.authService.authenticated$.getValue()` to determine
    the auth state. We use this to immediately activate the route via the `canActivate`
    hook (or load the module via the `canLoad` hook) if the user is authenticated.
    Otherwise, we display the login prompt via the service's method, but this time
    we wrap it in a reprompt sequence, which will continue to prompt on failed attempts
    until a successful authentication, or ignore it if the user cancels the prompt.
  prefs: []
  type: TYPE_NORMAL
- en: For the book, we aren't wiring up to any backend service to do any real authentication
    with a service provider. We will leave that part up to you in your own app. We
    will just be persisting the e-mail and password you enter into the login prompt
    as a valid user after doing very simple validation on the input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that `AuthGuard` is an Injectable service like other services, so we
    will want to make sure it is added to the providers metadata of `AppRoutingModule`.
    We can now guard our route with the following highlighted modifications to `app/app.routing.ts`
    to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To try this out, we need to add child routes to our `RecorderModule`, since
    we have not done that yet. Open `app/modules/recorder/recorder.module.ts` and
    add the following highlighted sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We now have a proper child route configuration that will display the single
    `RecordComponent` when the user navigates to the `'/record'` path. We won't show
    the details of `RecordComponent`, as you can refer to the [Chapter 5](part0064.html#1T1400-289fe2426d594f99a90e4363b2c9c34d), *Routing
    and Lazy Loading* branch on the repo for the book. However, it is just a stubbed
    out component at this point inside `app/modules/recorder/components/record.component.html`,
    which just shows a simple label, so we can try this out.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we need a button that will route to our `'/record'` path. If we look
    back at our original sketch, we wanted a Record button to display in the top right
    corner of `ActionBar`, so let's implement that now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `app/modules/mixer/components/mixer.component.html` and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we were to run this in the iOS Simulator, we would notice that our
    Record button in `ActionBar` does not do anything! This is because `MixerModule`
    only imports the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `NativeScriptRouterModule.forChild(routes)` method just configures the routes
    but does not make various routing directives, such as `nsRouterLink`, available
    to our components.
  prefs: []
  type: TYPE_NORMAL
- en: Since you learned earlier that `SharedModule` should be used to declare various
    directives, components, and pipes you want to share throughout your modules (lazy
    loaded or not), this is a perfect opportunity to take advantage of that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `app/modules/shared/shared.module.ts` and make the following highlighted
    modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, back in `MixerModule`, we can adjust the imports to use `SharedModule`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This ensures all the directives exposed via `NativeScriptRouterModule` are now
    included and available for use in  `MixerModule` by utilizing our app-wide `SharedModule`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running our app again, we now see the login prompt when we tap the Record button
    in `ActionBar`. If we enter a properly formatted e-mail address and any password,
    it will persist the details, log us in, and display `RecordComponent` as follows
    on iOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00022.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You might notice something rather interesting. `ActionBar` changed from the
    background color we assigned via CSS and the button color now displays the default
    blue color. This is because `RecordComponent` does not define `ActionBar`; therefore,
    it is reverting to a default styled `ActionBar` with a default back button, which
    takes on the title of the page it just navigated from. The `'/record'` route is
    also using the ability of `page-router-outlet` to push components onto the mobile
    navigation stack. `RecordComponent` is animated into view while allowing the user
    to choose the top left button to navigate back (to pop the navigation history
    back one).
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix `ActionBar`, let''s just add `ActionBar` to the `RecordComponent` view
    with a custom `NavigationButton` (a `NativeScript` view component simulating a
    mobile device''s default back navigation button). We can make the adjustments
    to `app/modules/record/components/record.component.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, this looks a lot better:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00023.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we run this on Android and log in using any e-mail/password combo to persist
    a user, it will display the same `RecordComponent` view; however, you will notice
    another interesting detail. We have set up Android to display a standard back
    arrow system icon as `NavigationButton`, but when tapping that arrow, it does
    not do anything. Android''s default behavior relies on the device''s physical
    hardware back button next to the home button. However, we can provide a consistent
    experience by just adding a tap event to `NavigationButton`, so both iOS and Android
    react the same to tapping the back button. Make the following modification to
    the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can implement the `back()` method in `app/modules/recorder/components/record.component.ts`
    using `NativeScript` for Angular''s `RouterExtensions` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, Android''s back button can be tapped to navigate back in addition to the
    hardware back button. iOS simply ignores the tap event handler, since it uses
    the default native behavior for `NavigationButton`. Pretty nice. Here is how `RecordComponent`
    looks on Android:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00024.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We will implement a nice recording view in upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: We are surely cruising down Route 66 by now!
  prefs: []
  type: TYPE_NORMAL
- en: We have implemented lazily loaded routes, provided `AuthGuard` to protect unauthorized
    use of our app's recording features, and learned a ton in the process. *However,
    we've just realized we are missing a very important feature late in the game*.
    We need a way to work on several different mixes over time. By default, our app
    may launch the last opened mix, but we would like to create new mixes (let's consider them
    **compositions**) and record entirely new mixes of individual tracks as separate
    compositions. We need a new route to display these compositions that we can name
    appropriately, so we can jump back and forth and work on different material.
  prefs: []
  type: TYPE_NORMAL
- en: Handling late feature requirements – managing compositions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's time to deal with unexpected traffic along Route 66\. We have encountered
    a late feature requirement, realizing we need a way to manage any number of different
    mixes so we can work on different material over time. We could refer to each mix
    as a composition of audio tracks.
  prefs: []
  type: TYPE_NORMAL
- en: The good news is we have spent a reasonable amount of time engineering a scalable
    architecture and we are about to reap the fruits of our labor. Responding to late
    feature requirements now becomes a rather enjoyable Sunday stroll around the neighborhood.
    Let's show off the strengths of our app's architecture by taking a moment to work
    on this new feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by defining a new route for a new `MixListComponent` we will create.
    Open `app/modules/mixer/mixer.module.ts` and make the following highlighted modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We are switching up our initial strategy of presenting `MixerComponent` as the
    home start page, but instead we are going to create a new `MixListComponent` in
    a moment to represent the `'home'` start page, which will be a listing of all
    the compositions we are working on. We could still have the `MixListComponent`
    auto select the last selected composition on the app launch for convenience later.
    We have now defined `MixerComponent` as a parameterized route, since it will always
    represent one of our working compositions identified by the `':id'` param routes,
    which will resolve to a route looking like `'/mixer/1'` for example. We have also
    imported `PROVIDERS`, which we will create in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify `DatabaseService` provided by `CoreModule` to help provide a
    constant persistence key for our new data needs. We will want to persist user
    created compositions stored via this constant key name. Open `app/modules/core/services/database.service.ts`
    and make the following highlighted modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also create a new data model to represent our compositions. Create `app/modules/shared/models/composition.model.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, holding strong to our conventions, open `app/modules/shared/models/index.ts`
    and re-export this new model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use this new model and database key in a new data service on which
    to build this new feature. Create `app/modules/mixer/services/mixer.service.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We now have a service that will provide a list to bind our view to display the
    user's saved compositions. It also provides a way to add and edit compositions
    and seed the first app launch with a demo composition for a good first-time user
    experience (*we will add actual tracks to the demo later*).
  prefs: []
  type: TYPE_NORMAL
- en: 'In keeping with our conventions, let''s also add `app/modules/mixer/services/index.ts`,
    as follows, which we illustrated being imported in `MixerModule` a moment ago:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now create `app/modules/mixer/components/mix-list.component.ts` to consume
    and project our new data service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'And, for the view template, `app/modules/mixer/components/mix-list.component.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This will render our list of `MixerService` user-saved compositions to the
    view and, when we first launch the app, it will have been seeded with one sample
    **Demo** composition preloaded with two recordings, so the user can play around.
    Here is how things look on iOS upon first launch now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00025.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can create new compositions and edit the names of existing ones. We can
    also tap the composition''s name to view  `MixerComponent`; however, we need to
    adjust the component to grab the route `'':id''` param and wire its view into
    the selected composition. Open `app/modules/mixer/components/mixer.component.ts`
    and add the highlighted sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We can inject Angular''s `ActivatedRoute` to subscribe to the route''s params,
    which give us access to `id`. Because it will come in as a String by default,
    we use `+params[''id'']` to convert it to a number when we locate the composition
    in our service''s list. We assign a local reference to the selected `composition`,
    which now allows us to bind to it in the view. While we''re at it, we will also
    add a Button labeled `List` for now in `ActionBar` to navigate back to our compositions
    (*later, we will implement font icons to display in their place*). Open `app/modules/mixer/components/mixer.component.html`
    and make the following highlighted modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows us to display the selected composition''s name in the title of
    `ActionBar` as well as pass its tracks to `track-list`. We need to add `Input` to
    `track-list`, so it renders the composition''s tracks instead of the dummy data
    it''s bound to now. Let''s open `app/modules/player/components/track-list/track-list.component.ts`
    and add an `Input`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Previously, the `TrackListComponent` view was bound to `playerService.tracks`,
    so let's adjust the view template for the component at `app/modules/player/components/track-list/track-list.component.html`
    to bind to our new `Input`, which will now represent the tracks in the user's
    actual selected composition**:**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have the following sequence in our app to meet the needs of this late
    feature requirement and we did it in just a few pages of material here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00026.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: And it works exactly the same on Android while retaining its unique native characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00027.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You might notice, however, that `ActionBar` on Android defaults to all `ActionItem`
    on the right-hand side. One last trick we want to show you quickly is the ability
    for platform-specific view templates. Oh and don't worry about those ugly Android
    buttons; we will integrate font icons later for those.
  prefs: []
  type: TYPE_NORMAL
- en: Create platform-specific view templates wherever you see fit. Doing so will
    help you dial views for each platform where necessary and make them highly maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create `app/modules/mixer/components/action-bar/action-bar.component.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then create an iOS-specific view template: `app/modules/mixer/components/action-bar/action-bar.component.ios.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'And an Android-specific view template: `app/modules/mixer/components/action-bar/action-bar.component.android.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can use it in `app/modules/mixer/components/mixer.component.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Just ensure you add it to the `COMPONENTS` of `MixerModule`  in `app/modules/mixer/mixer.module.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Voila!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00028.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have arrived at the end of this amazing journey down Route 66 and hope you
    feel as exhilarated as we do. This chapter has presented some interesting Angular
    concepts, including route configuration with lazy loaded modules to keep the app
    startup time fast; building a custom module loader using native file handling
    APIs; combining the flexibility of `router-outlet` with NativeScript's `page-router-outlet`;
    gaining control and understanding of Singleton services with lazy loaded modules;
    guarding routes dependent on authorized access; and working on late feature requirements
    to show off our wonderfully scalable app design.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter rounds out the general usability flow of our app and, at this
    point, we are ready to venture into the core competency of our app: **Audio Handling
    via iOS and Android''s rich native APIs**.'
  prefs: []
  type: TYPE_NORMAL
- en: Before delving into the thick of things, in the next chapter we will take a
    brief moment to inspect NativeScript's various `tns` command-line arguments to
    run our app to lock in a thorough education of the tool belt we can now bring
    to work.
  prefs: []
  type: TYPE_NORMAL
