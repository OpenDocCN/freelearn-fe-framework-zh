- en: Building Our First App - 7 Minute Workout
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们的第一个应用程序 - 7 分钟锻炼
- en: We will be building a new app in Angular, and in the process, become more familiar
    with the framework. This app will also help us explore some new capabilities of
    Angular.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 Angular 中构建一个新的应用程序，并在此过程中更加熟悉该框架。此应用程序还将帮助我们探索 Angular 的一些新功能。
- en: 'The topics that we will cover in this chapter include the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '本章我们将涉及的主题包括以下内容:'
- en: '**7 Minute Workout problem description**: We detail the functionality of the
    app that we build in this chapter.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**7 分钟锻炼问题描述**: 我们详细描述了本章中我们构建的应用程序的功能。'
- en: '**Code organization**: For our first real app, we will try to explain how to
    organize code, specifically Angular code.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码组织**: 对于我们的第一个真正的应用程序，我们将尝试解释如何组织代码，特别是 Angular 代码。'
- en: '**Designing the model**: One of the building blocks of our app is its model.
    We design the app model based on the app''s requirements.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设计模型**: 我们应用程序的基本构建块之一是其模型。我们根据应用程序的需求设计应用程序模型。'
- en: '**Understanding the data binding infrastructure**: While building the *7 Minute
    Workout* view, we will look at the data binding capabilities of the framework,
    which include *property*, *attribute*, *class*, *style*, and *event* bindings.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理解数据绑定基础设施**: 在构建*7 分钟锻炼*视图时，我们将了解框架的数据绑定能力，其中包括*属性*、*属性*、*类*、*样式*和*事件*绑定。'
- en: '**Exploring the Angular platform directives**: Some of the directives that
    we will cover are `ngFor`, `ngIf`, `ngClass`, `ngStyle`, and `ngSwitch`.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**探索 Angular 平台指令**: 我们将涉及的一些指令有 `ngFor`、`ngIf`、`ngClass`、`ngStyle` 和 `ngSwitch`。'
- en: '**Cross-component communication with input properties**: As we build nested
    components, we learn how input properties can be used to pass data from the parent
    to its child components.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用输入属性进行跨组件通信**: 当我们构建嵌套组件时，我们学习了如何使用输入属性将数据从父组件传递给其子组件。'
- en: '**Cross-component communication with events**: Angular components can subscribe
    to and raise events. We get introduced to event binding support in Angular.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用事件进行跨组件通信**: Angular 组件可以订阅和触发事件。我们将介绍 Angular 中的事件绑定支持。'
- en: '**Angular pipes**: Angular pipes provide a mechanism to format view content.
    We explore some standard Angular pipes and build our own pipe to support conversions
    from seconds to hh:mm:ss.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Angular 管道**: Angular 管道提供了一种格式化视图内容的机制。我们将探索一些标准的 Angular 管道，并构建我们自己的管道以支持从秒数转换为
    hh:mm:ss 的转换。'
- en: Let's get started! The first thing we will do is to define our *7 Minute Workout*
    app.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！我们要做的第一件事是定义我们的*7 分钟锻炼*应用程序。
- en: What is 7 Minute Workout?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 7 分钟锻炼？
- en: We want everyone reading this book to be physically fit. Therefore, this book
    should serve a dual purpose; it should not only stimulate your grey matter but
    also urge you to look after your physical fitness. What better way to do it than
    to build an app that targets physical fitness!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望每个阅读本书的人都能保持身体健康。因此，本书应该具有双重目的；它不仅应该刺激您的大脑，还应该敦促您关注您的身体健康。有什么比构建一个针对身体健康的应用程序更好的方法呢!
- en: '*7 Minute Workout* is an exercise/workout app that requires us to perform a
    set of 12 exercises in quick succession within the seven-minute time span. *7
    Minute Workout* has become quite popular due to its bite-sized length and great
    benefits. We cannot confirm or refute the claims, but doing any form of strenuous
    physical activity is better than doing nothing at all. If you are interested to
    know more about the workout, then check out [http://well.blogs.nytimes.com/2013/05/09/the-scientific-7-minute-workout/](http://well.blogs.nytimes.com/2013/05/09/the-scientific-7-minute-workout/).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*7 分钟锻炼* 是一款在七分钟内快速连续进行一组 12 个练习的锻炼应用程序。*7 分钟锻炼* 因其短小而产生了巨大的好处而变得相当受欢迎。我们无法证实或否认这些说法，但进行任何形式的费力的体力活动比不做任何事情要好。如果您对这项锻炼感兴趣，那么请访问
    [http://well.blogs.nytimes.com/2013/05/09/the-scientific-7-minute-workout/](http://well.blogs.nytimes.com/2013/05/09/the-scientific-7-minute-workout/)
    了解更多信息。'
- en: The technicalities of the app include performing a set of 12 exercises, dedicating
    30 seconds for each of the exercises. This is followed by a brief rest period
    before starting the next exercise. For the app that we are building, we will be
    taking rest periods of 10 seconds each. So, the total duration comes out at a
    little more than seven minutes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 应用的技术细节包括完成一组 12 个练习，每个练习耗时 30 秒。在开始下一个练习之前，会有一个简短的休息时间。对于我们要构建的应用程序，我们将每次休息
    10 秒。因此，总时长略长于七分钟。
- en: 'At the end of the chapter, we will have the *7 Minute Workout* app ready, which
    will look something like the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们将准备好*7 分钟锻炼*应用程序，它看起来类似于以下内容：
- en: '![](img/8378988e-4540-482e-ac33-e91d1e49b659.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8378988e-4540-482e-ac33-e91d1e49b659.png)'
- en: The 7 Minute Workout app
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 7 分钟锻炼应用
- en: Downloading the code base
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载代码库
- en: The code for this app can be downloaded from the GitHub site ([https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample))
    dedicated to this book. Since we are building the app incrementally, we have created
    **multiple checkpoints** that map to **GitHub branches** such as `checkpoint2.1`,
    `checkpoint2.2`, and so on. During the narration, we will highlight the branch
    for reference. These branches will contain the work done on the app up until that
    point in time.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序的代码可以从专门为本书创建的 GitHub 站点（[https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample)）上下载。由于我们正在逐步构建该应用程序，我们已经创建了**多个检查点**，与**GitHub
    分支**如`checkpoint2.1`、`checkpoint2.2`等相对应。在叙述过程中，我们会强调用于参考的分支。这些分支将包含直到该时间点为止的应用程序完成的工作。
- en: The *7 Minute Workout* code is available in the repository folder named `trainer`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*7 分钟锻炼*的代码可以在名为`trainer`的存储库文件夹中找到。'
- en: So, let's get started!
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧！
- en: Setting up the build
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搭建构建环境
- en: Remember that we are building on a modern platform for which browsers still
    lack support. Therefore, directly referencing script files in HTML is out of the
    question (while common, it's a dated approach that we should avoid anyway). Browsers
    do not understand **TypeScript**; this implies that there has to be a process
    that converts code written in TypeScript into standard **JavaScript (ES5)**. Hence,
    having a build set up for any Angular app becomes imperative. And thanks to the
    growing popularity of Angular, we are never short of options.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们正在构建一个现代平台，浏览器仍然缺乏支持。因此，在 HTML 中直接引用脚本文件是行不通的（虽然常见，但这是一种应该避免的陈旧方法）。浏览器不理解**TypeScript**；这意味着必须有一个过程将使用
    TypeScript 编写的代码转换为标准的**JavaScript（ES5）**。因此，为任何 Angular 应用程序设置构建变得至关重要。由于 Angular
    的日益流行，我们永远不缺选项。
- en: If you are a frontend developer working on the web stack, you cannot avoid **Node.js**.
    This is the most widely used platform for web/JavaScript development. So, no prizes
    for guessing that most of the Angular build solutions out there are supported
    by Node. Packages such as **Grunt**, **Gulp**, **JSPM**, and **webpack** are the
    most common building blocks for any build system.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个在 web 技术栈上工作的前端开发人员，那么你无法避免使用**Node.js**。这是最广泛使用的用于 web/JavaScript 开发的平台。因此，可以想像到大多数
    Angular 构建解决方案都是由 Node 支持的。像**Grunt**、**Gulp**、**JSPM**和**webpack**这样的包是任何构建系统的常见构建模块。
- en: Since we too are building on the Node.js platform, install Node.js before starting.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在建立在 Node.js 平台上，所以请在开始之前安装 Node.js。
- en: For this book and this sample app, we endorse **Angular CLI** ([http://bit.ly/ng6be-angular-cli](http://bit.ly/ng6be-angular-cli)).
    A command line tool, it has a build system and a scaffolding tool that hugely
    simplifies Angular's development workflow. It is popular, easy to set up, easy
    to manage, and supports almost everything that a modern build system should have.
    More about it later.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书和这个示例应用程序，我们推荐使用**Angular CLI**（[http://bit.ly/ng6be-angular-cli](http://bit.ly/ng6be-angular-cli)）。作为一个命令行工具，它有一个构建系统和一个脚手架工具，极大简化了
    Angular 的开发工作流程。它受欢迎、易于设置、易于管理，并支持几乎所有现代构建系统应有的功能。关于它的更多内容稍后再说。
- en: 'As with any mature framework, Angular CLI is not the only option out there
    on the web. Some of the notable starter sites plus build setups created by the
    community are as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '与任何成熟的框架一样，Angular CLI 并不是 Web 上唯一的选择。社区创建的一些值得注意的起始站点加构建设置如下:'
- en: '| **Start site** | **Location** |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| **启动站点** | **位置** |'
- en: '| `angular2-webpack-starter` | [http://bit.ly/ng2webpack](http://bit.ly/ng2webpack)
    |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `angular2-webpack-starter` | [http://bit.ly/ng2webpack](http://bit.ly/ng2webpack)
    |'
- en: '| `angular-seed` | [https://github.com/mgechev/angular-seed](https://github.com/mgechev/angular-seed)
    |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `angular-seed` | [https://github.com/mgechev/angular-seed](https://github.com/mgechev/angular-seed)
    |'
- en: 'Let''s start with installing Angular CLI. On the command line, type the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们从安装 Angular CLI 开始。在命令行上输入以下内容:'
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once installed, Angular CLI adds a new command `ng` to our execution environment.
    To create a new Angular project from the command line, run the following command:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '安装后，Angular CLI 会向我们的执行环境添加一个名为`ng`的新命令。要从命令行创建一个新的 Angular 项目，请运行以下命令:'
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This generates a folder structure with a bunch of files, a boilerplate Angular
    application, and a preconfigured build system. To run the application from the
    command line, execute the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个文件夹结构，一堆文件，一个模板 Angular 应用程序和一个预配置的构建系统。要从命令行运行应用程序，请执行以下命令：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: And you can see a basic Angular application in action!
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你就能看到一个基本的 Angular 应用程序在运行！
- en: 'For our *7 Minute Workout* app, instead of starting from scratch, we are going
    to start from a version that is based on the project structure generated by `ng
    new` with minor modification. Start with the following steps:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的*7分钟锻炼*应用程序，我们不打算从零开始，而是打算从基于`ng new`生成的项目结构的版本进行一些微小的修改。按照以下步骤开始：
- en: Curious about what the default project includes? Go ahead and run `ng new PROJECT-NAME`.
    Look at the generated content structure and the Angular CLI documentation to get
    an idea of what's part of a default setup.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 想知道默认项目包含什么？试试运行`ng new PROJECT-NAME`命令。查看生成的内容结构和 Angular CLI 文档，了解默认设置包含了哪些内容。
- en: 'Download the base version of this app from [http://bit.ly/ngbe-base](http://bit.ly/ngbe-base)
    and unzip it to a location on your machine. If you are familiar with how Git works,
    you can just clone the repository and check out the`base` branch:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[http://bit.ly/ngbe-base](http://bit.ly/ngbe-base)下载这个应用程序的基础版本并解压到计算机上的某个位置。如果你熟悉
    Git 的工作原理，你可以直接克隆存储库并检出`base`分支：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This code serves as the starting point for our app.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码作为我们应用程序的起点。
- en: Navigate to the `trainer` folder from the command line and execute the command
    `npm install` from the command line to install the **package dependencies** for
    our application.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从命令行导航到`trainer`文件夹，并执行`npm install`命令来安装我们应用程序的**包依赖**。
- en: '**Packages** in the Node.js world are third-party libraries (such as Angular
    for our app) that are either used by the app or support the app''s building process.
    **npm** is a command-line tool for pulling these packages from a remote repository.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node.js 的世界中，**包**是第三方库（比如我们应用程序中的 Angular）或者支持应用程序构建过程的库。**npm** 是一个命令行工具，用于从远程存储库中拉取这些包。
- en: 'Once npm pulls the app dependencies from the npm store, we are ready to build
    and run the application. From the command line, enter the following command:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦 npm 从 npm 库中拉取了应用程序的依赖，我们就可以准备构建和运行应用程序了。从命令行输入以下命令：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This compiles and runs the app. If the build process goes fine, the default
    browser window/tab will open with a rudimentary app page (`http://localhost:4200/`).
    We are all set to begin developing our app in Angular!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这将编译并运行应用程序。如果构建过程正常进行，将会在默认的浏览器窗口/标签中打开一个基本的应用程序页面（`http://localhost:4200/`）。我们已经准备好开始在
    Angular 中开发我们的应用程序了！
- en: But before we do that, it would be interesting to know a bit more about Angular
    CLI and the customization that we have done on the default project template that
    Angular CLI generates.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 但在那之前，了解一下 Angular CLI 及我们对 Angular CLI 生成的默认项目模板进行的自定义会很有趣。
- en: Angular CLI
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular CLI
- en: '**Angular CLI** was created with the aim of standardizing and simplifying the development
    and deployment workflow for Angular apps. As the documentation suggests:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**Angular CLI** 的创建旨在规范化和简化 Angular 应用程序的开发和部署工作流程。正如文档所建议的：'
- en: '"The Angular CLI makes it easy to create an application that already works,
    right out of the box. It already follows our best practices!"'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '"Angular CLI 可以轻松创建一个应用程序，它已经可以直接使用。它已经遵循了我们的最佳实践！"'
- en: 'It incorporates:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 它包括：
- en: A build system based on **webpack**
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于**webpack**的构建系统
- en: A **scaffolding tool** to generate all standard Angular artifacts including
    modules, directives, components, and pipes
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于生成所有标准 Angular 组件的**脚手架工具**，包括模块、指令、组件和管道
- en: Adherence to **Angular style guide** ([http://bit.ly/ngbe-styleguide](http://bit.ly/ngbe-styleguide)),
    making sure we use community-driven standards for projects of every shape and
    size
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循**Angular样式指南**（[http://bit.ly/ngbe-styleguide](http://bit.ly/ngbe-styleguide)），确保我们在各种形状和大小的项目中使用社区驱动的标准
- en: You may have never heard the term style guide, or may not understand its significance.
    A style guide in any technology is a set of guidelines that help us organize and
    write code that is easy to develop, maintain, and extend. To understand and appreciate
    Angular's own style guide, some familiarity with the framework itself is desirable,
    and we have started that journey.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你从来没有听说过"样式指南"这个术语，或者不明白它的意义。在任何技术中，样式指南都是一组指导方针，帮助我们组织和编写易于开发、维护和扩展的代码。要理解和欣赏
    Angular 自己的样式指南，需要对框架本身有一定的了解，而我们已经开始了这个过程。
- en: A targeted **linter;** Angular CLI integrates with **codelyzer** ([http://bit.ly/ngbe-codelyzer](http://bit.ly/ngbe-codelyzer)),
    a **static code analysis tool** that validates our Angular code against a set
    of rules to make sure that the code we write adheres to standards laid down in
    the Angular style guide
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有针对性的**代码检查器；** Angular CLI集成了**codelyzer**（[http://bit.ly/ngbe-codelyzer](http://bit.ly/ngbe-codelyzer)），这是一个**静态代码分析工具**，用于验证我们的Angular代码是否符合规定的一组规则，以确保我们编写的代码符合Angular风格指南中制定的标准。
- en: Preconfigured **unit** and **end-to-end** (**e2e**) test framework
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预配置的**单元测试**和**端到端**（**e2e**）测试框架
- en: And much more!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多！
- en: Imagine if we had to do all this manually! The steep learning curve would quickly
    overwhelm us. Thankfully, we don't have to deal with it, Angular CLI does it for
    us.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果我们必须手动完成所有这些工作！陡峭的学习曲线会迅速让我们感到不知所措。幸运的是，我们不必处理它，Angular CLI会为我们完成。
- en: The Angular CLI build setup is based on webpack, but it does not expose the
    underlying webpack configuration; this is intentional. The Angular team wanted
    to shield developers from the complexities and internal workings of webpack. The
    ultimate aim of Angular CLI is to eliminate any entry level barriers and make
    setting up and running Angular code simple.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CLI构建设置基于webpack，但它不会公开底层webpack配置；这是有意的。Angular团队希望将开发人员与webpack的复杂性和内部工作隔离开来。Angular
    CLI的最终目标是消除任何入门障碍，使设置和运行Angular代码变得简单。
- en: It doesn't mean Angular CLI is not configurable. There is a *config file* (`angular.json`)
    that we can use to alter the build setup. We will not cover that here. Check the
    configuration file for 7 Minute Workout and read the documentation here: [http://bit.ly/ng6be-angular-cli-config](http://bit.ly/ng6be-angular-cli-config).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着Angular CLI不可配置。有一个*配置文件*（`angular.json`），我们可以用它来更改构建设置。我们将不在此处进行处理。查看7分钟锻炼的配置文件，并在这里阅读文档：[http://bit.ly/ng6be-angular-cli-config](http://bit.ly/ng6be-angular-cli-config)。
- en: 'The tweaks that we have done to the default generated project template are:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对默认生成的项目模板所做的调整包括：
- en: Referenced Bootstrap CSS in the `style.css` file.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`style.css`文件中引用了Bootstrap CSS。
- en: Upgraded some npm library versions.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 升级了一些npm库版本。
- en: Changed the prefix configuration for generated code to use `abe` (short for
    Angular By Example) from `app`. With this change, all our components and directive
    selectors will be prefixed by `abe` instead of `app`. Check `app.component.ts`;
    the `selector` is `abe-root` instead of `app-root`.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将生成代码的前缀配置更改为使用`abe`（Angular By Example的简称）而不是`app`。通过这种更改，我们所有的组件和指令选择器将以`abe`作为前缀，而不是`app`。查看`app.component.ts`；`selector`是`abe-root`，而不是`app-root`。
- en: While on the topic of Angular CLI and builds, there is something that we should
    understand before proceeding.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到Angular CLI和构建的话题，有一件事情我们在继续之前应该了解。
- en: '*What happens to the TypeScript code we write?*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们编写的TypeScript代码会怎样呢？*'
- en: Code transpiling
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码转译
- en: Browsers, as we all know, only work with JavaScript, they don't understand TypeScript.
    We hence need a mechanism to convert our TypeScript code into plain JavaScript
    (**ES5** is our safest bet). The **TypeScript compiler** does this job. The compiler
    takes the TypeScript code and converts it into JavaScript. This process is commonly
    referred to as **transpiling**, and since the TypeScript compiler does it, it's
    called a **transpiler**.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 众所周知，浏览器只能处理JavaScript，它们不理解TypeScript。因此，我们需要一种机制将我们的TypeScript代码转换为纯JavaScript（**ES5**是我们最安全的选择）。这个工作由**TypeScript编译器** 完成。编译器接收TypeScript代码并将其转换为JavaScript。这个过程通常被称为**转译**，而由于TypeScript编译器完成了这项工作，因此称为**转译器**。
- en: JavaScript as a language has evolved over the years with every new version adding
    new features/capabilities to the language. The latest avatar, ES2015, succeeds
    ES5 and is a major update to the language. While released in June 2015, some of
    the older browsers still lack support for the ES2015 flavor, of JavaScript making
    its adoption a challenge.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，JavaScript作为一种语言不断发展，每个新版本都为语言增加新的特性/功能。最新的版本，ES2015，继承自ES5，并对语言进行了重大更新。虽然发布于2015年6月，但一些较旧的浏览器仍然缺乏对JavaScript
    ES2015版本的支持，这使得其采用成为一项挑战。
- en: When transpiling code from TypeScript to JavaScript, we can specify the flavor
    of JavaScript to use. As mentioned earlier, ES5 is our safest bet, but if we plan
    to work with only the latest and greatest browsers, go for ES2015\. For 7 Minute
    Workout, our code to transpile to is ES5 format. We set this TypeScript compiler
    configuration in `tsconfig.json` (see the `target` property).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当将TypeScript代码转译为JavaScript时，我们可以指定要使用的JavaScript版本。如前所述，ES5是最安全的选择，但如果我们计划只使用最新和最好的浏览器，那就选择ES2015。对于7分钟锻炼应用程序，我们要转译的代码是ES5格式。我们在`tsconfig.json`中设置了这个TypeScript编译器的配置（参见`target`属性）。
- en: 'Interestingly, transpilation can happen at both build/compile time and at runtime:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，转译可以在构建/编译时和运行时都发生：
- en: '**Build-time transpilation**: Transpilation as part of the build process takes
    the script files (in our case, TypeScript `.ts` files) and compiles them into
    plain JavaScript. Angular CLI does build-time transpilation.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建时转译**：作为构建过程的一部分，将脚本文件（在我们的例子中，TypeScript的`.ts`文件）编译成普通的JavaScript。Angular
    CLI就是实现构建时转译的。'
- en: '**Runtime transpilation**: This happens in the browser at runtime. We directly
    reference the TypeScript files (`.ts` in our case), and the TypeScript compiler,
    which is loaded in the browser beforehand, compiles these script files on the
    fly. This is a workable setup only for small examples/code snippets, as there
    is an additional performance overhead involved in loading the transpiler and transpiling
    the code on the fly.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行时转译**：这发生在浏览器运行时。我们直接引用TypeScript文件（在我们的例子中是`.ts`文件），而浏览器中先加载的TypeScript编译器会即时编译这些脚本文件。这只适用于小范例/代码片段，因为加载转译器和即时转译代码会增加额外的性能开销。'
- en: The process of transpiling is not limited to TypeScript. Every language targeted
    towards the web, such as **CoffeeScript**, **ES2015**, (yes JavaScript itself!)
    or any other language that is not inherently understood by a browser needs transpilation.
    There are transpilers for most languages, and the prominent ones (other than TypeScript)
    are **tracuer** and **babel.**
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 转译的过程不仅局限于TypeScript。针对Web的每一种编程语言，比如**CoffeeScript**、**ES2015**（是的，JavaScript本身！）或者其他任何浏览器不本能理解的语言，都需要转译。大多数语言都有转译器，而最著名的（除了TypeScript）是**tracuer**和**babel**。
- en: The Angular CLI build system takes care of setting up the TypeScript compiler
    and sets up file watchers that recompile the code every time we make changes to
    our TypeScript file.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CLI的构建系统负责设置TypeScript编译器，并设置文件监视器，以便在我们每次对TypeScript文件进行更改时重新编译代码。
- en: If you are new to TypeScript, remember that TypeScript does not depend on Angular;
    in fact, Angular has been built on TypeScript. I highly recommend that you look
    at the official documentation on TypeScript ([https://www.typescriptlang.org/](https://www.typescriptlang.org/))
    and learn the language outside the realms of Angular.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对TypeScript还不熟悉，要记住TypeScript并不依赖Angular；实际上，Angular是建立在TypeScript之上的。我强烈推荐你查看官方的TypeScript文档（[https://www.typescriptlang.org/](https://www.typescriptlang.org/)），并在Angular的范畴之外学习这门语言。
- en: Let's get back to the app we are building and start exploring the code setup.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们正在构建的应用程序，开始探索代码设置。
- en: Organizing code
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码组织
- en: 'The advantage of Angular CLI is that is dictates a code organization structure
    that works for applications of all sizes. Here is how the current code organization
    looks:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CLI的优势在于它规定了适用于各种应用程序规模的代码组织结构。下面是当前的代码组织结构：
- en: '![](img/b1552b1b-0bd6-427a-b0f8-0fe6145d65ec.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b1552b1b-0bd6-427a-b0f8-0fe6145d65ec.png)'
- en: '`trainer` is the application root folder.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trainer`是应用程序的根文件夹。'
- en: The files inside `trainer` are configuration files and some standard files that
    are part of every standard node application.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trainer`文件夹内的文件是配置文件和一些标准文件，这些文件都是标准的节点应用程序的一部分。'
- en: The `e2e` folder will contain end to end tests for the app.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`e2e`文件夹将包含应用程序的端到端测试。'
- en: '`src` is the primary folder where all the development happens. All the application
    artifacts go into `src`.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src`是所有开发活动发生的主要文件夹。所有应用程序产物都放在`src`里。'
- en: The `assets` folder inside `src` hosts static content (such as images, CSS,
    audio files, and others).
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src`文件夹内的`assets`文件夹托管静态内容（比如图片、CSS、音频文件等）。'
- en: The `app` folder has the app's source code.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app`文件夹里包含了应用的源代码。'
- en: The `environments` folder is useful to set configurations for different deployment
    environments (such as *dev, qa, production*).
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`environments`文件夹对于设置不同部署环境（比如*dev, qa, production*）的配置非常有用。'
- en: To organize Angular code inside the `app` folder, we take a leaf from the Angular
    style guide ([http://bit.ly/ng6be-style-guide](http://bit.ly/ng6be-style-guide))
    released by the Angular team.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 Angular 代码组织在 `app` 文件夹内，我们参考了 Angular 团队发布的 Angular 风格指南 ([http://bit.ly/ng6be-style-guide](http://bit.ly/ng6be-style-guide))。
- en: Feature folders
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能文件夹
- en: The style guide recommends the use of **feature folders** to organize code.
    With feature folders, files linked to a single feature are placed together. If
    a feature grows, we break it down further into sub features and tuck the code
    into sub folders. Consider the `app` folder to be our first feature folder! As
    the application grows, `app` will add sub features for better code organization.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 风格指南建议使用 **功能文件夹** 来组织代码。使用功能文件夹，与单个功能相关的文件被放在一起。如果一个功能增长，我们将其进一步拆分为子功能，将代码存放在子文件夹中。考虑将
    `app` 文件夹作为我们的第一个功能文件夹！随着应用程序的增长，`app` 将添加子功能以更好地组织代码。
- en: Let's get straight into building the application. Our first focus area, the
    app's model!
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接开始构建应用程序。我们的第一个关注点是应用程序的模型！
- en: The 7 Minute Workout model
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7分钟训练模型
- en: 'Designing the model for this app requires us to first detail the functional
    aspects of the *7 Minute Workout* app, and then derive a model that satisfies
    those requirements. Based on the problem statement defined earlier, some of the
    obvious requirements are as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为这个应用程序设计模型需要我们首先详细描述 *7分钟训练* 应用程序的功能方面，然后推导出一个满足这些要求的模型。根据早些定义的问题陈述，一些明显的要求如下：
- en: Being able to start the workout.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够开始训练。
- en: 'Providing a visual clue about the current exercise and its progress. This includes
    the following:'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供关于当前练习及其进度的视觉线索。这包括以下内容：
- en: Providing a visual depiction of the current exercise
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供当前练习的视觉描述
- en: Providing step-by-step instructions on how to do a specific exercise
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供如何执行特定练习的逐步说明
- en: The time left for the current exercise
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前练习剩余时间
- en: Notifying the user when the workout ends.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当训练结束时通知用户。
- en: 'Some other valuable features that we will add to this app are as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加到这个应用程序的一些其他有价值的功能如下：
- en: The ability to pause the current workout.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暂停当前训练的能力。
- en: Providing information about the next exercise to follow.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供下一个要执行的练习的信息。
- en: 'Providing audio clues so that the user can perform the workout without constantly
    looking at the screen. This includes:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供音频线索，使用户可以在不断看屏幕的情况下执行训练。这包括：
- en: A timer click sound
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定时器点击声音
- en: Details about the next exercise
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个练习的详细信息
- en: Signaling that the exercise is about to start
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示即将开始的练习
- en: Showing related videos for the exercise in progress and the ability to play
    them.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示正在进行的练习的相关视频，并具备播放它们的能力。
- en: As we can see, the central themes for this app are **workout** and **exercise**.
    Here, a workout is a set of exercises performed in a specific order for a particular
    duration. So, let's go ahead and define the model for our workout and exercise.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这个应用程序的中心主题是 **训练** 和 **练习**。在这里，一个训练是按特定顺序在特定时间内进行的一组练习。因此，让我们继续为我们的训练和练习定义模型。
- en: 'Based on the requirements just mentioned, we will need the following details
    about an exercise:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 根据刚才提到的要求，我们将需要关于一个练习的以下详细信息：
- en: The name. This should be unique.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称。这应该是唯一的。
- en: The title. This is shown to the user.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标题。这将显示给用户。
- en: The description of the exercise.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习的描述。
- en: Instructions on how to perform the exercise.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何执行练习的说明。
- en: Images for the exercise.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习的图片。
- en: The name of the audio clip for the exercise.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习的音频片段名称。
- en: Related videos.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相关视频。
- en: With TypeScript, we can define the classes for our model.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 TypeScript，我们可以为我们的模型定义类。
- en: 'The `Exercise` class looks as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`Exercise` 类如下所示：'
- en: '[PRE5]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: TypeScript tips
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript技巧
- en: Declaring constructor parameters with `public` or `private` is a shorthand for
    creating and initializing class members at one go. The `?` suffix after `nameSound`,
    `procedure`, and `videos` implies that these are optional parameters.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `public` 或 `private` 声明构造函数参数是一种一次性创建和初始化类成员的简写方式。在 `nameSound`、`procedure`
    和 `videos` 后面的 `?` 后缀表示这些是可选参数。
- en: 'For the workout, we need to track the following properties:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于训练，我们需要跟踪以下属性：
- en: The name. This should be unique.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称。这应该是唯一的。
- en: The title. This is shown to the user.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标题。这将显示给用户。
- en: The exercises that are part of the workout.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 训练中包含的练习。
- en: The duration for each exercise.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个练习的持续时间。
- en: The rest duration between two exercises.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个练习之间的休息时间。
- en: 'The model class to track workout progress (`WorkoutPlan`) looks as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '用于跟踪workout进度的模型类(`WorkoutPlan`)如下所示:'
- en: '[PRE6]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `totalWorkoutDuration` function returns the total duration of the workout
    in seconds.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`totalWorkoutDuration`函数返回workout的总持续时间（以秒为单位）。'
- en: '`WorkoutPlan` has a reference to another class in the preceding definition,
    `ExercisePlan`. It tracks the exercise and the duration of the exercise in a workout,
    which is quite apparent once we look at the definition of `ExercisePlan`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutPlan`在前面的定义中有另一个类`ExercisePlan`的引用。它跟踪workout中的练习及其持续时间,这一点很明显,一旦我们查看`ExercisePlan`的定义:'
- en: '[PRE7]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Let me save you some typing and tell you where to get the model classes, but
    before that, we need to decide where to add them. We are ready for our first feature.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我为您节省一些输入时间,告诉您从哪里获取模型类,但在此之前,我们需要决定在哪里添加它们。我们已经准备好我们的第一个特性了。
- en: First feature module
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一个特性模块
- en: The primary feature of *7 Minute Workout* is to execute a predefined set of
    exercises. Hence we are going to create a feature module now and later add the
    feature implementation to this module. We call this module `workout-runner`. Let's
    initialize the feature with Angular CLI's scaffolding capabilities.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*7 Minute Workout*的主要功能是执行预定义的一组练习。因此，我们现在要创建一个特性模块，并稍后将特性实现添加到这个模块中。我们把这个模块称为`workout-runner`。让我们使用Angular
    CLI的脚手架功能初始化这个特性。'
- en: 'From the command line, navigate to the `trainer/src/app` folder and run the
    following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '从命令行导航到`trainer/src/app`文件夹,并运行以下命令:'
- en: '[PRE8]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Follow the console logs to know what files are generated. The command essentially:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '关注控制台日志,了解生成了哪些文件。该命令基本上是:'
- en: Creates a new Angular `WorkoutRunnerModule` module inside a new `workout-runner`
    folder
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个新的`workout-runner`文件夹内创建一个新的Angular `WorkoutRunnerModule`模块
- en: Imports the newly created module into the main application module app (`app.module.ts`)
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将新创建的模块导入到主应用程序模块`app（app.module.ts）`中。
- en: We now have a new **feature module**.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在拥有一个新的**特性模块**。
- en: Give every feature its own module.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 给每个特性一个自己的模块。
- en: Make special note of the conventions Angular CLI follows when scaffolding Angular
    artifacts. From the preceding example, the module name provided with the command
    line was `workout-runner`. While the generated folder and filenames use the same
    name, the class name for the generated module is `WorkoutRunnerModule` (pascal
    case with the `Module` suffix).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意Angular CLI在搭建Angular构件时遵循的约定。从前面的示例中,命令行提供的模块名称为`workout-runner`。虽然生成的文件夹和文件名使用相同的名称,但生成的模块的类名为`WorkoutRunnerModule`（帕斯卡大小写,带有`Module`后缀）。
- en: Open the newly generated module definition (`workout-runner.module.ts`) and
    look at the generated content. `WorkoutRunnerModule` imports `CommonModule`, a
    module with common Angular directives such as `ngIf` and `ngFor`, allowing us
    to use these common directives across any component/directive defined in `WorkoutRunnerModule`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 打开新生成的模块定义(`workout-runner.module.ts`)并查看生成的内容。`WorkoutRunnerModule`导入`CommonModule`，这是一个包含常用Angular指令（如`ngIf`和`ngFor`）的模块，允许我们在`WorkoutRunnerModule`中定义的任何组件/指令中使用这些常用指令。
- en: Modules are Angular's way of organizing code. We will touch upon Angular modules
    shortly.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是Angular组织代码的方式。我们将很快讨论Angular模块。
- en: Copy the `model.ts` file from [http://bit.ly/ng6be-2-1-model-ts](http://bit.ly/ng6be-2-1-model-ts) into
    the `workout-runner` folder. Shortly, we will see how these model classes are
    utilized.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 将`model.ts`文件从[http://bit.ly/ng6be-2-1-model-ts](http://bit.ly/ng6be-2-1-model-ts)复制到`workout-runner`文件夹。稍后,我们将看到如何利用这些模型类。
- en: Since we have started with a preconfigured Angular app, we just need to understand
    how the app starts.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经启动了一个预配置的Angular应用程序，我们只需要了解应用程序如何启动。
- en: App bootstrapping
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序引导
- en: 'The app bootstrapping process for *7 Minute Workout* can be carried out from
    the `src` folder. There is a `main.ts` file that bootstraps the application by
    calling the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*7 Minute Workout*的应用程序引导过程可以从`src`文件夹中进行。有一个`main.ts`文件通过调用以下命令来引导应用程序:'
- en: '[PRE9]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The heavy lifting is done by the Angular CLI, which compiles the application,
    includes the script and CSS reference into `index.html`, and runs the application.
    We don't need to configure anything. These configurations are part of the default
    Angular CLI configuration (`.angular-cli.json`).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 繁重的工作由Angular CLI完成，它编译应用程序，将脚本和CSS引用包含到`index.html`中，并运行应用程序。我们不需要配置任何东西。这些配置是Angular
    CLI默认配置（`.angular-cli.json`）的一部分。
- en: We have created a new module and added some model classes to the `module` folder.
    Before we go any further and start implementing the feature, let's talk a bit
    about **Angular modules**.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个新模块，并将一些模型类添加到`module`文件夹中。在进一步实现该功能并开始之前，让我们稍微谈一下**Angular 模块**。
- en: Exploring Angular modules
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Angular 模块
- en: As the *7 Minute Workout* app grows and we add new components/directives/pipes/other
    artifacts to it, a need arises to organize these items. Each of these items needs
    to be part of an Angular module.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 *7 分钟锻炼* 应用程序的增长，我们向其中添加新的组件/指令/管道/其他构件，需要组织这些项目。其中的每一项都需要成为 Angular 模块的一部分。
- en: A naïve approach would be to declare everything in our app's root module (`AppModule`),
    as we did with `WorkoutRunnerComponent`, but this defeats the whole purpose of
    Angular modules.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一个天真的方法是在我们应用的根模块（`AppModule`）中声明所有内容，就像我们对`WorkoutRunnerComponent`所做的那样，但这背离了
    Angular 模块的整体目的。
- en: To understand why a single-module approach is never a good idea, let's explore
    Angular modules.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解为什么单一模块方法永远不是一个好主意，请探索 Angular 模块。
- en: Comprehending Angular modules
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Angular 模块
- en: In Angular, **modules** are a way to organize code into chunks that belong together
    and work as a cohesive unit. Modules are Angular's way of grouping and organizing
    code.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 中，**模块**是一种将代码组织成属于一起并作为一个统一单元工作的方式。模块是 Angular 分组和组织代码的方式。
- en: 'An Angular module primarily defines:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 模块主要定义：
- en: The components/directives/pipes it owns
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它拥有的组件/指令/管道
- en: The components/directives/pipes it makes public for other modules to consume
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它向其他模块公开的组件/指令/管道
- en: Other modules that it depends on
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其依赖的其他模块
- en: Services that the module wants to make available application-wide
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块希望应用程序范围内提供的服务
- en: 'Any decent-sized Angular app will have modules interlinked with each other:
    some modules consuming artifacts from other, some providing artifacts to others,
    and some modules doing both.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 任何规模较大的 Angular 应用都将模块相互连接在一起：一些模块从其他模块消费构件，一些模块将构件提供给其他模块，一些模块都进行了两者。
- en: 'As a standard practice, module segregation is feature-based. One divides the
    app into features or subfeatures (for large features) and modules are created
    for each of the features. Even the framework adheres to this guideline as all
    of the framework constructs are divided across modules:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 作为标准做法，模块的分离是基于特性的。将应用程序划分成特性或子特性（对于大型特性），并为每个特性创建模块。即使框架也遵循此准则，因为所有框架构件都被分为各个模块：
- en: There is `CommonModule` that aggregates the standard framework constructs used
    in every browser-based Angular app
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有`CommonModule`，汇集了在每个基于浏览器的 Angular 应用中使用的标准框架构件
- en: There is `RouterModule` if we want to use the Angular routing framework
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果想要使用 Angular 路由框架，则有`RouterModule`。
- en: There is `HtppModule` if our app needs to communicate with the server over HTTP
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们的应用需要通过 HTTP 与服务器通信，有`HtppModule`。
- en: Angular modules are created by applying the `@NgModule` decorator to a TypeScript
    class. The decorator definition exposes enough metadata, allowing Angular to load
    everything the module refers to.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 模块是通过将 `@NgModule` 装饰器应用于 TypeScript 类来创建的。装饰器定义公开了足够的元数据，允许 Angular
    加载模块引用的一切。
- en: 'The decorator has multiple attributes that allow us to define:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器具有多个属性，允许我们定义：
- en: External dependencies (using `imports`).
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部依赖项（使用`imports`）。
- en: Module artifacts (using `declarations`).
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块构件（使用`declarations`）。
- en: Module exports (using `exports`).
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块输出（使用`exports`）。
- en: The services defined inside the module that need to be registered globally (using
    `providers`).
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模块内定义的需要全局注册的服务（使用`providers`）。
- en: The main application view, called the **root component**, which hosts all other
    app views. Only the root module should set this using the `bootstrap` property.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主应用视图，称为**根组件**，承载所有其他应用视图。只有根模块才应该使用`bootstrap`属性进行设置。
- en: 'This diagram highlights the internals of a module and how they link to each
    other:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此图表突出显示了模块内部及其相互链接的内容：
- en: '![](img/9596f561-ea75-4d83-b999-7d9853ab892e.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9596f561-ea75-4d83-b999-7d9853ab892e.jpg)'
- en: Modules defined in the context of Angular (using the `@NgModule` decorator)
    are different from modules we import using the `import` statement in our TypeScript
    file. Modules imported through the `import` statement are **JavaScript modules**,
    which can be in different formats adhering to *CommonJS*, *AMD*, or *ES2015* specifications,
    whereas Angular modules are constructs used by Angular to segregate and organize
    its artifacts. Unless the context of the discussion is specifically a JavaScript
    module, any reference to module implies an Angular module. We can learn more about
    this here: [http://bit.ly/ng2be6-module-vs-ngmodule](http://bit.ly/ng2be6-module-vs-ngmodule).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 上下文中定义的模块（使用 `@NgModule` 装饰器）和我们在 TypeScript 文件中使用 `import` 语句导入的模块是不同的。通过
    `import` 语句导入的模块是**JavaScript 模块**，可以采用*CommonJS*、*AMD*或*ES2015*规范的不同格式，而 Angular
    模块是 Angular 用来分隔和组织其构件的构造物。除非讨论的上下文明确是 JavaScript 模块，否则对模块的任何引用都意味着是一个 Angular
    模块。我们可以在这里了解更多信息：[http://bit.ly/ng2be6-module-vs-ngmodule](http://bit.ly/ng2be6-module-vs-ngmodule)。
- en: 'We hope one thing is clear from all this discussion: creating a single application-wide
    module is not the right use of Angular modules unless you are building something
    rudimentary.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望从所有这些讨论中有一件事是清楚的：除非您正在构建一些基本的东西，否则创建单一的应用程序范围模块并不是 Angular 模块的正确用法。
- en: It's time to get into the thick of the action; let's build our first component.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候投入行动了；让我们构建我们的第一个组件。
- en: Our first component - WorkoutRunnerComponent
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一个组件 - WorkoutRunnerComponent
- en: '`WorkoutRunnerComponent`, is the central piece of our *7 Minute Workout* app
    and it will contain the logic to execute the workout.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutRunnerComponent`是我们的*7分钟锻炼*应用的核心部分，它将包含执行锻炼的逻辑。'
- en: 'What we are going to do in the `WorkoutRunnerComponent` implementation is as
    follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`WorkoutRunnerComponent`实现中将要做的事情如下：
- en: Start the workout
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始锻炼。
- en: Show the workout in progress and show the progress indicator
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示正在进行的锻炼和显示进度指示器。
- en: After the time elapses for an exercise, show the next exercise
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 练习时间结束后，显示下一个练习。
- en: Repeat this process until all the exercises are over
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复这个过程，直到所有的练习都结束。
- en: We are ready to create (or scaffold) our component.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备创建（或脚手架）我们的组件。
- en: 'From the command line, navigate to the `src/app` folder and execute the following
    `ng` command:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行，进入`src/app`文件夹并执行以下`ng`命令：
- en: '[PRE10]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The generator generates a bunch of files (three) in the `workout-runner` folder
    and updates the module declaration in `WorkoutRunnerModule` to include the newly
    created `WorkoutRunnerComponent`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器在`workout-runner`文件夹中生成一堆文件（三个），并更新`WorkoutRunnerModule`中的模块声明以包括新创建的`WorkoutRunnerComponent`。
- en: The `-is` flag is used to stop generation of a separate CSS file for the component.
    Since we are using global styles, we do not need component-specific styles.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`-is`标志用于停止为组件生成单独的 CSS 文件。由于我们使用全局样式，我们不需要组件特定的样式。'
- en: Remember to run this command from the `src/app` folder and not from the `src/app/workout-runner`
    folder. If we run the preceding command from `src/app/workout-runner`, Angular
    CLI will create a new subfolder with the `workout-runner` component definition.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住从`src/app`文件夹而不是`src/app/workout-runner`文件夹运行此命令。如果我们从`src/app/workout-runner`运行前面的命令，Angular
    CLI 将创建一个新的子文件夹，并包含`workout-runner`组件定义。
- en: 'The preceding `ng generate` command for component generates these three files:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 用于组件的前述`ng generate`命令生成这三个文件：
- en: '`<component-name>.component.html`: This is the component''s view HTML.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<component-name>.component.html`：这是组件的视图 HTML。'
- en: '`<component-name>.component.spec.ts`: Test specification file used in unit
    testing.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<component-name>.component.spec.ts`：单元测试中使用的测试规范文件。'
- en: '`<component-name>.component.ts`: Main component file containing component implementation.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<component-name>.component.ts`：包含组件实现的主要组件文件。'
- en: Again, we will encourage you to have a look at the generated code to understand
    what gets generated. The Angular CLI component generator saves us some keystrokes
    and once generated, the boilerplate code can evolve as desired.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们鼓励你查看生成的代码，以了解生成了什么。Angular CLI 组件生成器节省了我们一些按键操作，一旦生成，样板代码可以根据需要进行修改。
- en: While we see only four decorator metadata properties (such as `templateUrl`),
    the component decorator supports some other useful properties too. Look at the
    Angular documentation for component to learn more about these properties and their
    application.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们只看到了四个装饰器元数据属性（比如 `templateUrl`），但是组件装饰器也支持一些其他有用的属性。查看 Angular 文档以了解更多关于这些属性及其应用的信息。
- en: An observant reader might have noticed that the generated `selector` property
    value has a prefix `abe`; this is intentional. Since we are extending the HTML
    **domain-specific language** (**DSL**) to incorporate a new element, the prefix
    `abe` helps us demarcate HTML extensions that we have developed. So instead of
    using `<workout-runner></workout-runner>` in HTML we use `<abe-workout-runner></abe-workout-runner>`.
    The prefix value has been configured in `angular.json`, see the `prefix` property.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 一个敏锐的读者可能会注意到生成的`selector`属性值具有前缀`abe`；这是有意为之。因为我们正在扩展HTML的**领域特定语言**（**DSL**）以包含一个新元素，前缀`abe`帮助我们划分了我们开发的HTML扩展。因此，我们在HTML中使用`<abe-workout-runner></abe-workout-runner>`而不是`<workout-runner></workout-runner>`。前缀值已在`angular.json`中配置，参见`prefix`属性。
- en: Always add a prefix to your component selector.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 请始终为您的组件选择器添加前缀。
- en: We now have the `WorkoutRunnerComponent` boilerplate; let's start adding the
    implementation, starting with adding the model reference.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了`WorkoutRunnerComponent`的样板；让我们开始添加实现，首先是添加模型引用。
- en: 'In `workout-runner.component.ts`, import all the workout models:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在`workout-runner.component.ts`中，导入所有训练模型：
- en: '[PRE11]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we need to set up the workout data. Let''s do that by adding some code
    in the generated `ngOnInit` function and related class properties to the `WorkoutRunnerComponent`
    class:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要设置训练数据。让我们通过在生成的`ngOnInit`函数和与`WorkoutRunnerComponent`类相关的类属性中添加一些代码来完成：
- en: '[PRE12]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`ngOnInit` is a special function that Angular calls when a component is initialized.
    We will talk about `ngOnInit` shortly.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngOnInit`是Angular在组件初始化时调用的特殊函数。我们即将讨论`ngOnInit`。'
- en: The `buildWorkout` on `WorkoutRunnerComponent` sets up the complete workout,
    as we will define shortly. We also initialize a `restExercise` variable to track
    even the rest periods as exercise (note that `restExercise` is an object of type
    `ExercisePlan`).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`buildWorkout`在`WorkoutRunnerComponent`上设置完成的训练计划，正如我们即将定义的那样。我们还初始化了一个`restExercise`变量，以跟踪甚至作为练习的休息时间（注意，`restExercise`是`ExercisePlan`类型的对象）。'
- en: 'The `buildWorkout` function is a lengthy function, so it''s better to copy
    the implementation from the workout runner''s implementation available in Git
    branch checkpoint2.1 ([http://bit.ly/ng6be-2-1-workout-runner-component-ts](http://bit.ly/ng6be-2-1-workout-runner-component-ts)).
    The `buildWorkout` code looks as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`buildWorkout`函数很长，最好从可在Git分支checkpoint2.1中获取的workout runner的实现中复制实现（[http://bit.ly/ng6be-2-1-workout-runner-component-ts](http://bit.ly/ng6be-2-1-workout-runner-component-ts)）。`buildWorkout`代码如下：'
- en: '[PRE13]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This code builds the `WorkoutPlan` object and pushes the exercise data into
    the `exercises` array (an array of `ExercisePlan` objects), returning the newly
    built workout.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码构建了`WorkoutPlan`对象，并将练习数据推入`exercises`数组（一组`ExercisePlan`对象），返回新构建的训练计划。
- en: 'The initialization is complete; now, it''s time to actually implement the *start*
    workout. Add a `start` function to the `WorkoutRunnerComponent` implementation,
    as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化工作完成；现在是时候实际实现*开始*训练了。将以下`start`函数添加到`WorkoutRunnerComponent`的实现中：
- en: '[PRE14]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then declare the new variables used in the function at the top, with other
    variable declarations:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在顶部声明在函数中使用的新变量，以及其他变量声明：
- en: '[PRE15]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `workoutTimeRemaining` variable tracks the total time remaining for the
    workout, and `currentExerciseIndex` tracks the currently executing exercise index.
    The call to `startExercise` actually starts an exercise. This is how the code
    for `startExercise` looks:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`workoutTimeRemaining`变量跟踪训练的剩余时间，`currentExerciseIndex`跟踪当前执行的练习索引。调用`startExercise`实际上开始了一项练习。以下是`startExercise`的代码：'
- en: '[PRE16]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We start by initializing `currentExercise` and `exerciseRunningDuration`. The
    `currentExercise` variable tracks the exercise in progress and `exerciseRunningDuration`
    tracks its duration. These two variables also need to be declared at the top:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先初始化`currentExercise`和`exerciseRunningDuration`。`currentExercise`变量跟踪正在进行的练习，而`exerciseRunningDuration`跟踪其持续时间。这两个变量也需要在顶部声明：
- en: '[PRE17]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We use the `setInterval` JavaScript function with a delay of one second (1,000
    milliseconds) to make progress. Inside the `setInterval` callback, `exerciseRunningDuration`
    is incremented with each passing second. The nested `clearInterval` call stops
    the timer once the exercise duration lapses.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`setInterval` JavaScript函数，延迟一秒（1,000毫秒），以取得进展。在`setInterval`回调内，`exerciseRunningDuration`会随着每过一秒而增加。嵌套的`clearInterval`调用将在运动持续时间结束时停止计时器。
- en: TypeScript arrow functions
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript箭头函数
- en: The callback parameter passed to `setInterval` (`()=>{...}`) is a lambda function
    (or an arrow function in ES 2015). Lambda functions are short-form representations
    of anonymous functions, with added benefits. You can learn more about them at
    [http://bit.ly/ng2be-ts-arrow-functions](http://bit.ly/ng2be-ts-arrow-functions).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`setInterval`的回调参数（`()=>{...}`）是一个lambda函数（或者是ES2015中的箭头函数）。Lambda函数是匿名函数的简写表示，带有额外的好处。您可以在
    [http://bit.ly/ng2be-ts-arrow-functions](http://bit.ly/ng2be-ts-arrow-functions)
    了解更多关于它们的知识。
- en: 'The first cut of the component is almost complete, except it currently has
    a static view (UI) and hence we cannot verify the implementation. We can quickly
    rectify this situation by adding a rudimentary view definition. Open `workout-runner.component.ts`,
    comment out the `templateUrl` property, and add an inline template property (`template`)
    and set it to the following:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的第一次切割几乎完成了，但是它目前有一个静态视图（UI），因此我们无法验证实现。我们可以通过添加一个初步的视图定义迅速纠正这种情况。打开`workout-runner.component.ts`，注释掉`templateUrl`属性，添加一个内联模板属性（`template`）并将其设置为以下内容：
- en: '[PRE18]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Strings enclosed in backticks (`` ``) are a new addition to ES2015\. Also called
    template literals, such string literals can be multiline and allow expressions
    to be embedded inside (not to be confused with Angular expressions). Look at the
    MDN article at [http://bit.ly/template-literals](http://bit.ly/template-literals)
    for more details.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 用反引号（`` ``）括起来的字符串是ES2015的一个新加入的特性。也被称为模板字面量，这样的字符串字面量可以是多行的，并且允许在其中嵌入表达式（不要与Angular表达式混淆）。在MDN的文章
    [http://bit.ly/template-literals](http://bit.ly/template-literals) 中查看更多细节。
- en: 'Inline versus external view templateThe preceding `template` property is an
    example of **inline component template**. This allows the component developer
    to specify the component template inline instead of using a separate HTML file.
    The inline template approach generally works for components with a trivial view.
    Inline templates have a disadvantage: formatting HTML becomes difficult and IDE
    support is very limited as the content is treated as a string literal. When we
    externalize HTML, we can develop a template as a normal HTML document. We recommend
    you use an **external template file** (specified using `templateUrl`) for elaborate
    views. Angular CLI by default generates an external template reference, but we
    can affect this behavior by passing the `--inline-template` flag to the `ng` component
    generation command, such as `--inline-template true`.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 内联与外部视图模板上面的`template`属性是**内联组件模板**的一个例子。这允许组件开发人员内联指定组件模板，而不是使用单独的HTML文件。内联模板方法通常适用于视图较为简单的组件。内联模板有一个缺点：HTML格式化变得困难，而且IDE支持非常有限，因为内容被视为字符串字面量。当我们将HTML外部化时，我们可以开发一个模板作为一个普通的HTML文档。我们建议您为复杂的视图使用**外部模板文件**（通过`templateUrl`指定）。Angular
    CLI默认生成外部模板引用，但我们可以通过向`ng`组件生成命令传递`--inline-template`标志来影响此行为，例如 `--inline-template
    true`。
- en: 'The preceding template HTML will render the raw `ExercisePlan` object and the
    exercise time remaining. It has an interesting expression inside the first interpolation:
    `currentExercise | json`. The `currentExercise` property is defined in `WorkoutRunnerComponent`,
    but what about the `|` symbol and what follows it (`json`)? In the Angular world,
    it is called a **pipe**. The sole purpose of a pipe is to transform/format template
    data.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的模板HTML将呈现原始的`ExercisePlan`对象以及剩余的练习时间。在第一个插值内有一个有趣的表达式：`currentExercise |
    json`。`currentExercise`属性在`WorkoutRunnerComponent`中定义，但是`|`符号及其后的内容（`json`）是什么？在Angular世界中，这被称为一个**管道**。管道的唯一目的是转换/格式化模板数据。
- en: The `json` pipe here does JSON data formatting. You will learn more about pipes
    later in this chapter, but to get a general sense of what the `json` pipe does,
    we can remove the `json` pipe plus the `|` symbol and render the template; we
    are going to do this next.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的`json`管道是对JSON数据进行格式化。您将在本章后面学到更多关于管道的知识，但为了大致了解`json`管道的作用，我们可以移除`json`管道和
    `|` 符号，然后呈现模板；我们将在下一步中执行此操作。
- en: 'To render the new `WorkoutRunnerComponent` implementation, it has to be added
    to the root component''s view. Modify `src/components/app/app.component.html`
    and replace the `h3` tag with the following code:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要呈现新的`WorkoutRunnerComponent`实现，它必须被添加到根组件的视图中。修改`src/components/app/app.component.html`，使用以下代码替换`h3`标签：
- en: '[PRE19]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: While the implementation may look complete, there is a crucial piece missing.
    Nowhere in the code do we actually start the workout. The workout should start
    as soon as we load the page.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然实现看起来可能已经完成，但是还缺少一个关键的部分。代码中实际上并没有启动练习。练习应该在页面加载时立即开始。
- en: Component lifecycle hooks are going to rescue us!
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的生命周期钩子将拯救我们！
- en: Component lifecycle hooks
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件的生命周期钩子
- en: 'The life of an Angular component is eventful. Components get created, change
    state during their lifetime, and finally, they are destroyed. Angular provides
    some **lifecycle hooks**/**functions** that the framework invokes (on the component)
    when such an event occurs. Consider these examples:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Angular组件的生命周期是充满事件的。组件被创建，在其生命周期内状态发生变化，最终被销毁。Angular提供了一些**生命周期钩子**/**函数**，当发生这样的事件时（在组件上）框架会调用它们。考虑以下示例：
- en: When a component is initialized, Angular invokes `ngOnInit`
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当组件被初始化时，Angular会调用`ngOnInit`
- en: When a component's data-bound properties change, Angular invokes `ngOnChanges`
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当组件的数据绑定属性发生变化时，Angular会调用`ngOnChanges`
- en: When a component is destroyed, Angular invokes `ngOnDestroy`
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当组件被销毁时，Angular会调用`ngOnDestroy`
- en: As developers, we can tap into these key moments and perform some custom logic
    inside the respective component.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发人员，我们可以利用这些关键时刻，并在相应的组件内执行一些自定义逻辑。
- en: The hook we are going to utilize here is `ngOnInit`. The `ngOnInit` function
    gets fired the first time the component's data-bound properties are initialized,
    but before the view initialization starts.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里使用的钩子是`ngOnInit`。`ngOnInit`函数在组件的数据绑定属性初始化完成后（但在视图初始化开始之前）首次触发。
- en: While `ngOnInit` and the class constructor seem to look similar, they have a
    different purpose. *A constructor* is a language feature and it is used to initialize
    class members. `ngOnInit`, on the other hand, is used to do some initialization
    stuff once the component is ready. Avoid use of a constructor for anything other
    than member initialization.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`ngOnInit`和类构造函数看起来类似，但它们有不同的用途。*构造函数*是一种语言特性，用于初始化类成员。另一方面，`ngOnInit`用于在组件准备就绪后执行一些初始化操作。避免使用构造函数来进行除成员初始化之外的任何操作。
- en: 'Update the `ngOnInit` function to the `WorkoutRunnerComponent` class with a
    call to start the workout:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`WorkoutRunnerComponent`类中的`ngOnInit`函数，以调用开始锻炼的代码：
- en: '[PRE20]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Angular CLI as part of component scaffolding already generates the signature
    for `ngOnInit`. The `ngOnInit` function is declared on the `OnInit` interface,
    which is part of the core Angular framework. We can confirm this by looking at
    the import section of `WorkoutRunnerComponent`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 作为组件脚手架的一部分，Angular CLI已经为`ngOnInit`生成了签名。`ngOnInit`函数声明在核心Angular框架的`OnInit`接口上。我们可以通过查看`WorkoutRunnerComponent`的导入部分来确认这一点：
- en: '[PRE21]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There are a number of other lifecycle hooks, including `ngOnDestroy`, `ngOnChanges`,
    and `ngAfterViewInit`, that components support, but we are not going to dwell
    on any of them here. Look at the developer guide ([https://angular.io/guide/lifecycle-hooks](https://angular.io/guide/lifecycle-hooks))
    on lifecycle hooks to learn more about other such hooks.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他生命周期钩子，包括`ngOnDestroy`，`ngOnChanges`和`ngAfterViewInit`，组件都支持，但我们在这里不打算深究其中任何一个。查看开发人员指南（[https://angular.io/guide/lifecycle-hooks](https://angular.io/guide/lifecycle-hooks)）上的生命周期钩子，了解更多关于其他钩子的信息。
- en: Implementing the interface (`OnInit` in the preceding example) is optional.
    These lifecycle hooks work as long as the function name matches. We still recommend
    you use interfaces to clearly communicate the intent.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 实现接口（前面的示例中的`OnInit`）是可选的。只要函数名匹配，这些生命周期钩子就可以起作用。我们仍然建议您使用接口来清晰地传达意图。
- en: 'Time to run our app! Open the command line, navigate to the `trainer` folder,
    and type this line:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候运行我们的应用程序了！打开命令行，导航到`trainer`文件夹，并输入以下命令：
- en: '[PRE22]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The code compiles, but no UI is rendered. What is failing us? Let's look at
    the browser console for errors.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 代码编译通过，但没有UI呈现。是什么让我们失败了？让我们查看浏览器控制台是否有错误。
- en: 'Open the browser''s dev tools (common keyboard shortcut `F12`) and look at
    the console tab for errors. There is a template parsing error. Angular is not
    able to locate the `abe-workout-runner` component. Let''s do some sanity checks
    to verify our setup:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 打开浏览器的开发工具（常见的键盘快捷键`F12`），并查看控制台标签页以查看错误。有一个模板解析错误。Angular 无法定位`abe-workout-runner`组件。让我们进行一些健全性检查以验证我们的设置：
- en: '`WorkoutRunnerComponent` implementation complete - *check*'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WorkoutRunnerComponent` 实现完成 - *检查*'
- en: Component declared in `WorkoutRunnerModule`- *check*
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`WorkoutRunnerModule`中声明了组件 - *检查*
- en: '`WorkoutRunnerModule` imported into `AppModule` - *check*'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WorkoutRunnerModule` 导入到`AppModule`中 - *检查*'
- en: Still, the `AppComponent` template cannot locate the `WorkoutRunnerComponent`.
    Is it because `WorkoutRunnerComponent` and `AppComponent` are in different modules?
    Indeed, that is the problem! While `WorkoutRunnerModule` has been imported into `AppModule`, `WorkoutRunnerModule`
    still does not export the new `WorkoutRunnerComponent` that will allow `AppComponent`
    to use it.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，`AppComponent`模板无法定位`WorkoutRunnerComponent`。这是因为`WorkoutRunnerComponent`和`AppComponent`在不同的模块中吗？的确，这就是问题所在！虽然`WorkoutRunnerModule`已经导入了`AppModule`，但`WorkoutRunnerModule`仍然没有导出新的`WorkoutRunnerComponent`，这将允许`AppComponent`使用它。
- en: Remember, adding a component/directive/pipe to the `declaration` section of
    a module makes them available inside the module. It's only after we export the
    component/directive/pipe that it becomes available to be used across modules.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，将组件/指令/管道添加到模块的`declaration`部分会使它们在模块内可用。只有在我们导出组件/指令/管道之后，它才可以在模块之间使用。
- en: 'Let''s export `WorkoutRunnerComponent` by updating the export array of the `WorkoutRunnerModule`
    declaration to the following:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更新`WorkoutRunnerModule`声明的导出数组，来导出`WorkoutRunnerComponent`：
- en: '[PRE23]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This time, we should see the following output:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们应该看到以下输出：
- en: '![](img/5e765f48-c0a6-43ce-ab18-b6f4a5d3a612.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5e765f48-c0a6-43ce-ab18-b6f4a5d3a612.png)'
- en: Always export artifacts defined inside an Angular module if you want them to
    be used across other modules.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果希望在其他模块中使用Angular模块内定义的组件，始终导出这些组件。
- en: The model data updates with every passing second! Now you'll understand why
    interpolations (`{{ }}`) are a great debugging tool.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 模型数据随着每秒的过去而更新！现在你会明白为什么插值表达式（`{{ }}`）是一个很好的调试工具。
- en: This will also be a good time to try rendering `currentExercise` without the
    `json` pipe and see what gets rendered.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是测试以不使用`json`管道渲染`currentExercise`的好时机，看看会渲染出什么。
- en: We are not done yet! Wait long enough on the page and we realize that the timer
    stops after 30 seconds. The app does not load the next exercise data. Time to
    fix it!
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成！在页面上等待足够长的时间，我们会发现计时器在30秒后停止。应该是时候修复它了！
- en: 'Update the code inside the `setInterval` function:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`setInterval`函数内的代码：
- en: '[PRE24]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `if` condition `if (this.exerciseRunningDuration >= this.currentExercise.duration)`
    is used to transition to the next exercise once the time duration of the current
    exercise lapses. We use `getNextExercise` to get the next exercise and call `startExercise`
    again to repeat the process. If no exercise is returned by the `getNextExercise`
    call, the workout is considered complete.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`条件`if (this.exerciseRunningDuration >= this.currentExercise.duration)`用于在当前练习的时间持续时间结束后切换到下一个练习。我们使用`getNextExercise`获取下一个练习，并再次调用`startExercise`来重复这个过程。如果`getNextExercise`调用没有返回任何练习，那么训练被认为已经完成。'
- en: During exercise transitioning, we increment `currentExerciseIndex` only if the
    next exercise is not a rest exercise. Remember that the original workout plan
    does not have a rest exercise. For the sake of consistency, we have created a
    rest exercise and are now swapping between rest and the standard exercises that
    are part of the workout plan. Therefore, `currentExerciseIndex` does not change
    when the next exercise is rest.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在练习过渡期间，只有下一个练习不是休息练习时，我们才会增加`currentExerciseIndex`。请记住，原始的训练计划没有休息练习。为了保持一致性，我们创建了一个休息练习，现在在休息和训练计划中的标准练习之间进行交换。因此，当下一个练习是休息时，`currentExerciseIndex`不会改变。
- en: 'Let''s quickly add the `getNextExercise` function too. Add the function to
    the `WorkoutRunnerComponent` class:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速添加`getNextExercise`函数。将函数添加到`WorkoutRunnerComponent`类中：
- en: '[PRE25]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `getNextExercise` function returns the next exercise that needs to be performed.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`getNextExercise`函数返回需要执行的下一个练习。'
- en: Note that the returned object for `getNextExercise` is an `ExercisePlan` object
    that internally contains the exercise details and the duration for which the exercise
    runs.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`getNextExercise`返回的对象是一个`ExercisePlan`对象，其中包含了练习细节和练习运行的持续时间。
- en: The implementation is quite self-explanatory. If the current exercise is rest,
    take the next exercise from the `workoutPlan.exercises` array (based on `currentExerciseIndex`);
    otherwise, the next exercise is rest, given that we are not on the last exercise
    (the `else if` condition check).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 实现方法非常易懂。如果当前练习是休息，就从`workoutPlan.exercises`数组中取下一个练习（基于`currentExerciseIndex`）；否则，下一个练习是休息，前提是我们不在最后一个练习（`else
    if`条件检查）。
- en: With this, we are ready to test our implementation. The exercises should flip
    after every 10 or 30 seconds. Great!
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们就可以测试我们的实现了。练习应该在每隔10或30秒后翻转。太棒了！
- en: The current build setup automatically compiles any changes made to the script
    files when the files are saved; it also refreshes the browser after these changes.
    But just in case the UI does not update or things do not work as expected, refresh
    the browser window. If you are having a problem with running the code, look at
    the Git branch `checkpoint2.1` for a working version of what we have done thus
    far. Or if you are not using Git, download the snapshot of Checkpoint 2.1 (a ZIP
    file) from [http://bit.ly/ng6be-checkpoint2-1](http://bit.ly/ng6be-checkpoint2-1).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的构建设置在保存文件时自动编译对脚本文件所做的任何更改；它还在这些更改后刷新浏览器。但是，如果UI没有更新或事情不像预期的那样工作，请刷新浏览器窗口。如果您在运行代码时遇到问题，请查看Git分支`checkpoint2.1`，了解我们目前所做的工作的可用版本。或者，如果您不使用Git，请从[http://bit.ly/ng6be-checkpoint2-1](http://bit.ly/ng6be-checkpoint2-1)下载Checkpoint
    2.1的快照（ZIP文件）。首次设置快照时，请参阅`trainer`文件夹中的`README.md`文件。
- en: We have done enough work on the component for now, let's build the view.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经对组件做了足够的工作，现在让我们构建视图。
- en: Building the 7 Minute Workout view
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建7分钟锻炼视图
- en: Most of the hard work has already been done while defining the model and implementing
    the component. Now, we just need to skin the HTML using the super-awesome data
    binding capabilities of Angular. It's going to be simple, sweet, and elegant!
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义模型和实现组件时，大部分工作已经完成。现在，我们只需要利用Angular的超赞数据绑定功能对HTML进行美化。这将简单、甜美且优雅！
- en: 'For the *7 Minute Workout* view, we need to show the exercise name, the exercise
    image, a progress indicator, and the time remaining. Replace the local content
    of the `workout-runner.component.html` file with the content of the file from
    the Git branch `checkpoint2.2`, (or download it from [http://bit.ly/ng6be-2-2-workout-runner-component-html](http://bit.ly/ng6be-2-2-workout-runner-component-html)).
    The view HTML looks as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*7分钟锻炼*视图，我们需要显示锻炼名称、锻炼图片、进度指示器和剩余时间。请用来自Git分支`checkpoint2.2`的文件内容替换`workout-runner.component.html`文件的本地内容（或者从[http://bit.ly/ng6be-2-2-workout-runner-component-html](http://bit.ly/ng6be-2-2-workout-runner-component-html)下载）。视图HTML如下所示：
- en: '[PRE26]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`WorkoutRunnerComponent` currently uses an inline template; instead, we need
    to revert back to using an external template. Update the `workout-runner.component.ts`
    file and get rid of the `template` property, then uncomment `templateUrl`, which
    we commented out earlier.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutRunnerComponent`当前使用内联模板；相反，我们需要恢复使用外部模板。更新`workout-runner.component.ts`文件，去掉`template`属性，然后取消注释我们先前注释掉的`templateUrl`。'
- en: 'Before we understand the Angular pieces in the view, let''s just run the app
    again. Save the changes in `workout-runner.component.html` and if everything went
    fine, we will see the workout app in its full glory:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们理解视图中的Angular部分之前，让我们再次运行应用程序。保存`workout-runner.component.html`中的更改，如果一切顺利，我们将看到完整版本的锻炼应用程序：
- en: '![](img/9734dbc5-314b-4653-b332-aea8bcd586e5.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9734dbc5-314b-4653-b332-aea8bcd586e5.png)'
- en: The basic app is now up and running. The exercise image and title show up, the
    progress indicator shows the progress, and exercise transitioning occurs when
    the exercise time lapses. This surely feels great!
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 基本应用程序现在已经启动并正在运行。锻炼图片和标题显示出来了，进度指示器显示了进度，并且当锻炼时间结束时发生了锻炼切换。这肯定感觉很棒！
- en: If you are having a problem with running the code, look at the Git branch `checkpoint2.2`
    for a working version of what we have done thus far. You can also download the
    snapshot of `checkpoint2.2` (a ZIP file) from this GitHub location: [http://bit.ly/ng6be-checkpoint-2-2](http://bit.ly/ng6be-checkpoint-2-2)
    . Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在运行代码时遇到问题，请查看Git分支`checkpoint2.2`，了解我们目前所做的工作的可用版本。您还可以从此GitHub位置下载`checkpoint2.2`的快照（ZIP文件）：[http://bit.ly/ng6be-checkpoint-2-2](http://bit.ly/ng6be-checkpoint-2-2)。首次设置快照时，请参阅`trainer`文件夹中的`README.md`文件。
- en: 'Looking at the view HTML, other than some Bootstrap styles, there are some
    interesting Angular pieces that need our attention. Before we dwell on these view
    constructs in detail, let''s break down these elements and provide a quick summary:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 查看视图的HTML时，除了一些Bootstrap样式外，还有一些有趣的Angular部分需要我们的关注。在我们详细研究这些视图构造之前，让我们先分解这些元素并提供一个快速摘要：
- en: '`<h1 ...>{{currentExercise.exercise.title}}</h1>`: Uses **interpolation**'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<h1 ...>{{currentExercise.exercise.title}}</h1>`：使用**插值**'
- en: '`<img ... [src]="''/assets/images/'' + currentExercise.exercise.image" .../>`:
    Uses **property binding** to bind the `src` property of the image to the component
    model property `currentExercise.exercise.image`'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<img ... [src]="''/assets/images/'' + currentExercise.exercise.image" .../>`：使用**属性绑定**将图像的`src`属性绑定到组件模型属性`currentExercise.exercise.image`'
- en: '`<div ... [attr.aria-valuenow]="exerciseRunningDuration" ... >`: Uses **attribute
    binding** to bind the aria attribute on *div* to `exerciseRunningDuration`'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<div ... [attr.aria-valuenow]="exerciseRunningDuration" ... >`：使用**属性绑定**将*div*上的aria属性绑定到`exerciseRunningDuration`'
- en: '`< div ... [ngStyle]="{''width'':(exerciseRunningDuration/currentExercise.duration)
    * 100 + ''%''}">`: Uses a **directive** `ngStyle` to bind the `style` property
    on the progress-bar `div` to an expression that evaluates the exercise progress'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`< div ... [ngStyle]="{''width'':(exerciseRunningDuration/currentExercise.duration)
    * 100 + ''%''}">`：使用**指令**`ngStyle`将进度条`div`上的`style`属性绑定到一个表达式，该表达式评估了运动进度'
- en: Phew! There is a lot of binding involved. Let's dig deeper into the binding
    infrastructure.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！牵扯到了很多绑定。让我们深入了解绑定基础设施。
- en: The Angular binding infrastructure
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular绑定基础设施
- en: Most modern JavaScript frameworks today come with strong model-view binding
    support, and Angular is no different. The primary aim of any binding infrastructure
    is to reduce the boilerplate code that a developer needs to write to keep the
    model and view in sync. A robust binding infrastructure is always declarative
    and terse.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代JavaScript框架如今都具有强大的模型-视图绑定支持，Angular也不例外。任何绑定基础设施的主要目标都是减少开发人员需要编写的样板代码，以保持模型和视图同步。强大的绑定基础设施总是声明性和简洁的。
- en: 'The Angular binding infrastructure allows us to transform template (raw) HTML
    into a live view that is bound to model data. Based on the binding constructs
    used, data can flow and be synced in both directions: from model to view and view
    to model.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: Angular绑定基础设施允许我们将模板（原始）HTML转换为与模型数据绑定的活动视图。根据使用的绑定构造，数据可以在模型到视图和视图到模型两个方向上流动并保持同步。
- en: The link between the component's model and its view is established using the
    `template` or `templateUrl` property of the `@Component` decorator. With the exception
    of the `script` tag, almost any piece of HTML can act as a template for the Angular
    binding infrastructure.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的模型与其视图之间的链接是通过`@Component`装饰器的`template`或`templateUrl`属性建立的。除了`script`标签以外，几乎任何HTML片段都可以作为Angular绑定基础设施的模板。
- en: To make this binding magic work, Angular needs to take the view template, compile
    it, link it to the model data, and keep it in sync with model updates without
    the need for any custom boilerplate synchronization code.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这种绑定魔法生效，Angular需要获取视图模板，编译它，将其与模型数据关联并使其与模型更新同步，而无需编写任何自定义样板同步代码。
- en: 'Based on the data flow direction, these bindings can be of three types:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 基于数据流方向，这些绑定可以分为三种类型：
- en: '**One-way binding from model to view**: In model-to-view binding, changes to
    the model are kept in sync with the view. Interpolations, property, attribute,
    class, and style bindings fall in this category.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一种从模型到视图的单向绑定**：在模型到视图绑定中，模型的变化与视图保持同步。插值、属性、属性、类和样式绑定属于这个类别。'
- en: '**One-way binding from view to model**: In this category, view changes flow
    towards the model. Event bindings fall in this category.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一种从视图到模型的单向绑定**：在这个类别中，视图变化流向模型。事件绑定属于这一类。'
- en: '**Two-way/bidirectional binding**: Two-way binding, as the name suggests, keeps
    the view and model in sync. There is a special binding construct used for two-way
    binding, `ngModel`, and some standard HTML data entry elements such as `input`
    and `select` support two-way binding.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**双向绑定**：双向绑定，顾名思义，保持视图和模型同步。用于双向绑定的特殊绑定构造是`ngModel`，一些标准的HTML数据输入元素如`input`和`select`支持双向绑定。'
- en: 'Let''s understand how to utilize the binding capabilities of Angular to support
    view templatization. Angular provides these binding constructs:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解如何利用Angular的绑定功能来支持视图模板化。Angular提供了这些绑定构造：
- en: Interpolations
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插值
- en: Property binding
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性绑定
- en: Attribute binding
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性绑定
- en: Class binding
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类绑定
- en: Style binding
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样式绑定
- en: Event binding
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件绑定
- en: This is a good time to learn about all these binding constructs. **Interpolation**
    is the first one.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '现在是学习所有这些绑定构造的好时机。**插值**是第一个。  '
- en: Interpolations
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插值
- en: '**Interpolations** are quite simple. The expression (commonly known as a **template
    expression**) inside the interpolation symbols (`{{ }}`) is evaluated in the context
    of the model (or the component class members), and the outcome of the evaluation
    (string) is embedded in HTML. A handy framework construct to display a component''s
    data/properties. We render the exercise title and the exercise time remaining
    using interpolation:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '**内插**非常简单。内插符号（`{{ }}`）中的表达式（通常称为**模板表达式**）在模型（或组件类成员）的上下文中进行评估，评估的结果（字符串）被嵌入到
    HTML 中。这是一个方便的框架构造，用于显示组件的数据/属性。我们使用内插渲染了练习标题和练习剩余时间：'
- en: '[PRE27]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Remember that interpolations synchronize model changes with the view. Interpolation
    is one way of binding from a model to a view.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，内插将模型变化与视图同步。内插是一种从模型到视图的单向绑定。
- en: View bindings in Angular are always evaluated in the context of the component's
    scope.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 中，视图绑定始终在组件作用域中进行评估。
- en: Interpolations, in fact, are a special case of property binding, which allows
    us to bind any HTML element/component properties to a model. We will shortly discuss
    how an interpolation can be written using property binding syntax. Consider interpolation
    as syntactical sugar over property binding.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，内插是属性绑定的一个特例，它允许我们将任何 HTML 元素/组件属性绑定到模型上。我们很快会讨论如何使用属性绑定语法来编写内插。认为内插是属性绑定的语法糖。
- en: Property binding
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性绑定
- en: Property bindings allow us to bind native HTML/component properties to the component's
    model and keep them in sync (from model->view). Let's look at property binding
    from a different context.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 属性绑定允许我们将本机 HTML/组件属性绑定到组件的模型并保持同步（从模型->视图）。让我们从不同的角度来看一下属性绑定。
- en: 'Look at this view excerpt from the 7 Minute Workout''s component view (`workout-runner.component.html`):'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下 7 分钟锻炼的组件视图（`workout-runner.component.html`）中的视图摘录：
- en: '[PRE28]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It seems that we are setting the `src` attribute of `img` to an expression that
    gets evaluated at runtime. But are we really binding to an attribute? Or is this
    a property? Are properties and attributes different?
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们在将 `img` 的 `src` 属性绑定到一个在运行时求值的表达式。但我们真的在绑定一个属性吗？还是这是一个属性？属性和属性之间的区别是什么？
- en: In Angular realms, while the preceding syntax looks like it is setting an HTML
    element's attribute, it is, in fact, doing **property binding**. Moreover, since
    many of us are not aware of the difference between an HTML element's properties
    and its attributes, this statement is very confusing. Therefore, before we look
    at how property bindings work, let's try to grasp the difference between an element's
    property and its attribute.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 领域中，虽然前面的语法看起来像是设置 HTML 元素的属性，实际上它是在进行**属性绑定**。此外，由于许多人不了解 HTML 元素的属性和其属性之间的区别，这个表达式令人非常困惑。因此，在我们了解属性绑定的工作原理之前，让我们试着理解一下元素的属性和属性之间的区别。
- en: Property versus attribute
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性与属性之间的区别
- en: 'Take any DOM element API and you will find attributes, properties, functions,
    and events. While events and functions are self-explanatory, it is difficult to
    understand the difference between properties and attributes. In daily use, we
    use these words interchangeably, which does not help much either. Take, for example,
    this line of code:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 拿起任何 DOM 元素的 API，你会发现属性、属性、函数和事件。虽然事件和函数是不言自明的，但很难理解属性和属性之间的区别。在日常使用中，我们互换使用这些词，这也不会有太大帮助。以这行代码为例：
- en: '[PRE29]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When the browser creates a DOM element (`HTMLInputElement` to be precise) for
    this input textbox, it uses the `value` attribute on `input` to set the initial
    state of the  `value` property of `input` to `Awesome Angular`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器为这个输入文本框创建一个 DOM 元素（确切地说是 `HTMLInputElement`）时，它使用 `input` 上的 `value` 属性来设置
    `input` 的 `value` 属性的初始状态为 `Awesome Angular`。
- en: After this initialization, any changes to the `value` property of `input` do
    not reflect on the `value` attribute; the attribute always has `Awesome Angular`
    (unless set explicitly again). This can be confirmed by querying the `input` state.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化之后，对 `input` 的 `value` 属性的任何更改都不会反映在 `value` 属性上；属性始终是`Awesome Angular`（除非明确地再次设置）。可以通过查询
    `input` 的状态来确认。
- en: 'Suppose we change the `input` data to `Angular rocks!` and query the `input`
    element state:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们将 `input` 的数据更改为 `Angular rocks!` 并查询 `input` 元素的状态：
- en: '[PRE30]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `value` property always returns the current input content, which is `Angular
    rocks!`. Whereas this DOM API function:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`value` 属性始终返回当前输入的内容，即 `Angular rocks!`。而这个 DOM API 函数：'
- en: '[PRE31]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Returns the `value` attribute, and is always the `Awesome Angular` that was
    set initially.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`value`属性，并始终是最初设置的`了不起的Angular`。
- en: The primary role of an element attribute is to initialize the state of the element
    when the corresponding DOM object is created.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 元素属性的主要作用是在创建相应的DOM对象时初始化元素的状态。
- en: 'There are a number of other nuances that add to this confusion. These include
    the following:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他细微差别会增加这种混乱。其中包括以下几点：
- en: Attribute and property synchronization is not consistent across properties.
    As we saw in the preceding example, changes to the `value` property on `input`
    do not affect the `value` attribute, but this is not true for all property-value
    pairs. The `src` property of an image element is a prime example of this; changes
    to property or attribute values are always kept in sync.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性和属性同步在不同属性上不一致。正如我们在上面的例子中看到的，对`input`的`value`属性的更改不会影响`value`属性，但这并不适用于所有属性-值对。图像元素的`src`属性就是一个典型的例子；对属性或属性值的更改始终保持同步。
- en: It's surprising to learn that the mapping between attributes and properties
    is also not one-to-one. There are a number of properties that do not have any
    backing attribute (such as `innerHTML`), and there are also attributes that do
    not have a corresponding property defined on the DOM (such as `colspan`).
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 令人惊讶的是，属性和属性之间的映射也不是一一对应的。有许多属性没有任何后备属性（如`innerHTML`），也有一些属性在DOM上没有定义相应的属性（如`colspan`）。
- en: 'Attribute and property mapping adds to this confusion too, as they do not follow
    a consistent pattern. An excellent example of this is available in the Angular
    developer''s guide, which we are going to reproduce here verbatim:'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性和属性映射也增加了这种混乱，因为它们没有遵循一致的模式。一个很好的例子是在Angular开发者指南中，我们将逐字重现的。
- en: The `disabled` attribute is another peculiar example. A button's `disabled`
    property is `false` by default so the button is enabled. When we add the disabled
    attribute, its presence alone initializes the button's `disabled` property to
    `true` so the button is disabled. Adding and removing the disabled attribute disables
    and enables the button. The value of the attribute is irrelevant, which is why
    we cannot enable a button by writing `<button disabled="false">Still Disabled</button>`.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`disabled`属性是另一个奇葩的例子。按钮的`disabled`属性默认为`false`，因此按钮是启用的。当我们添加disabled属性时，其存在单独将按钮的`disabled`属性初始化为`true`，因此按钮被禁用。添加和删除disabled属性会禁用和启用按钮。属性的值是无关紧要的，这就是为什么我们无法通过编写`<button
    disabled="false">仍然禁用</button>`来启用按钮。'
- en: The aim of this discussion is to make sure that we understand the difference
    between the properties and attributes of a DOM element. This new mental model
    will help us as we continue to explore the framework's property and attribute
    binding capabilities. Let's get back to our discussion on property binding.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 此讨论的目的是确保我们了解DOM元素的属性和属性之间的区别。这种新的思维模式将帮助我们继续探索框架的属性和属性绑定能力。让我们回到我们对属性绑定的讨论。
- en: Property binding continued...
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性绑定继续……
- en: 'Now that we understand the difference between a property and an attribute,
    let''s look at the binding example again:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了属性和属性之间的区别，让我们再次看一看绑定的例子：
- en: '[PRE32]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `[propertName]` square bracket syntax is used to bind the `img.src` property
    to an Angular expression.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`[propertName]`方括号语法用于将`img.src`属性绑定到Angular表达式。'
- en: 'The general syntax for property binding looks as follows:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 属性绑定的一般语法如下所示：
- en: '[PRE33]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the case of property binding, the `target` is a property on the DOM element
    or component. With property binding, we can literally bind to any property on
    the element's DOM. The `src` property on the `img` element is what we use; this
    binding works for any HTML element and every property on it.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在属性绑定的情况下，`目标`是DOM元素或组件上的属性。通过属性绑定，我们可以绑定到DOM元素上的任何属性。`img`元素上的`src`属性就是我们所使用的；这种绑定适用于任何HTML元素及其上的每个属性。
- en: Expression target can also be an event, as we will see shortly when we explore
    event binding.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式目标也可以是事件，我们很快会看到当我们探索事件绑定时。
- en: Binding source and targetIt is important to understand the difference between
    source and target in an Angular binding. The property appearing inside `[]` is
    a target, sometimes called **binding target**. The target is the consumer of the
    data and always refers to a property on the component/element. The **source**
    expression constitutes the data source that provides data to the target.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定的源和目标了解Angular绑定中源和目标的区别很重要。出现在`[]`内的属性是目标，有时也被称为**绑定目标**。目标是数据的消费者，并且总是指向组件/元素上的属性。**源**表达式构成了提供数据给目标的数据源。
- en: At runtime, the expression is evaluated in the context of the component's/element's
    property (the `WorkoutRunnerComponent.currentExercise.exercise.image` property
    in the preceding case).
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，表达式在组件/元素属性的上下文中进行评估（在前面的案例中为`WorkoutRunnerComponent.currentExercise.exercise.image`属性）。
- en: Always remember to add square brackets `[]` around the target. If we don't,
    Angular treats the expression as a string constant and the target is simply assigned
    the string value.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 记得始终在目标周围加上方括号`[]`。如果不这样做，Angular将会把表达式视为字符串常量，并且目标将简单地被分配字符串值。
- en: 'Property binding, event binding, and attribute binding do not use the interpolation
    symbol. The following is invalid: `[src]="{{''/static/images/'' + currentExercise.exercise.image}}".`'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 属性绑定、事件绑定和属性绑定不使用插值符号。以下是无效的：`[src]="{{'/static/images/' + currentExercise.exercise.image}}"`。
- en: If you have worked on AngularJS, property binding together with event binding
    allows Angular to get rid of a number of directives, such as `ng-disable`, `ng-src`,
    `ng-key*`, `ng-mouse*`, and a few others.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用过AngularJS，属性绑定和事件绑定一起使Angular能够摆脱多个指令，比如`ng-disable`、`ng-src`、`ng-key*`、`ng-mouse*`等一些指令。
- en: 'From a data binding perspective, Angular treats components in the same way
    as it treats native elements. Hence, property binding works on component properties
    too! Components can define **input** and **output properties** that can be bound
    to the view, such as this:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据绑定的角度来看，Angular对待组件和原生元素的方式是一样的。因此，属性绑定也适用于组件属性！组件可以定义**输入**和**输出属性**，这些属性可以绑定到视图，比如这样：
- en: '[PRE34]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This hypothetical snippet binds the `exerciseRestDuration` property on the `WorkoutRunnerComponent`
    class to the `restDuration` property defined on the container component (parent),
    allowing us to pass the rest duration as a parameter to the `WorkoutRunnerComponent`.
    As we enhance our app and develop new components, you will learn how to define
    custom properties and events on a component.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这个假设的代码片段将`WorkoutRunnerComponent`类上的`exerciseRestDuration`属性绑定到容器组件（父组件）上定义的`restDuration`属性，使我们可以将休息时长作为参数传递给`WorkoutRunnerComponent`。随着我们改进应用程序并开发新组件，你将学会如何在组件上定义自定义属性和事件。
- en: 'We can enable property binding using the `bind-` syntax, which is a canonical
    form of property binding. This implies that `[src]="''/assets/images/'' + currentExercise.exercise.image"` is
    equivalent to the following: `bind-src="img/'' + currentExercise.exercise.image"`.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`bind-`语法启用属性绑定，这是一种属性绑定的标准形式。这意味着`[src]="'/assets/images/' + currentExercise.exercise.image"`等同于以下内容：`bind-src="img/'
    + currentExercise.exercise.image"`.
- en: Property binding, like interpolation, is unidirectional, from the component/element
    source to the view. Changes to the model data are kept in sync with the view.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 属性绑定，就像插值一样，是单向的，从组件/元素源到视图。对模型数据的更改与视图保持同步。
- en: The template view that we just created has only one property binding (on `[src]`).
    The other bindings with square brackets aren't property bindings. We will cover
    them shortly.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建的模板视图只有一个属性绑定（在`[src]`上）。其他带方括号的绑定不属于属性绑定，我们马上会介绍它们。
- en: Interpolation syntactic sugar over property binding
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插值语法糖在属性绑定之上
- en: 'We concluded the section on interpolations by describing interpolation as syntactical
    sugar over property binding. The intent was to highlight how both can be used
    interchangeably. The interpolation syntax is terser than property binding and
    hence is very useful. This is how Angular interprets an interpolation:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过描述插值为属性绑定提供了一种语法糖来总结插值部分。我们的意图是强调两者如何可以互换使用。插值语法比属性绑定更为简洁，因此非常有用。这就是Angular如何解释插值的方式：
- en: '[PRE35]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Angular translates the interpolation in the first statement into the `textContent`
    property binding (second statement).
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: Angular将第一个语句中的插值转换为`textContent`属性绑定（第二个语句）。
- en: 'Interpolation can be used in more places than you can imagine. The following
    example contrasts the same binding using interpolation and property binding:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 内插法可以用在比你想象的更多地方。以下示例对比了使用内插和属性绑定的相同绑定：
- en: '[PRE36]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: While property binding (and interpolations) makes it easy for us to bind any
    expression to the target property, we should be careful with the expression we
    use. Angular's change detection system will evaluate your expression binding multiple
    times during the life cycle of the application, as long as our component is alive.
    Therefore, while binding an expression to a property target, keep these two guidelines
    in mind.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管属性绑定（和内插）让我们可以轻松将任何表达式绑定到目标属性，但我们应该谨慎选择所使用的表达式。只要我们的组件存活，Angular的变更检测系统将在应用程序的生命周期内多次评估您的表达式绑定。因此，在将表达式绑定到属性目标时，请牢记这两点指导原则。
- en: Quick expression evaluation
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速表达式评估
- en: 'A property binding expression should evaluate quickly. Slow expression evaluation
    can kill your app''s performance. This happens when a function performing CPU
    intensive work is part of an expression. Consider this binding:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 属性绑定表达式应该快速评估。慢速表达式评估可能会影响应用的性能。当执行CPU密集型工作的函数作为表达式的一部分时，就会发生这种情况。考虑这个绑定：
- en: '[PRE37]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Angular will evaluate the preceding `doLotsOfWork()` expression every time it
    performs a change detection run. These change detection runs happen more often
    than we imagine and are based on some internal heuristics, so it becomes imperative
    that the expressions we use evaluate quickly.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: Angular在执行变更检测时，将评估之前的`doLotsOfWork()`表达式。这些变更检测运行的频率比我们想象的要频繁，并且基于一些内部启发式算法，因此我们使用的表达式需要快速评估才是至关重要的。
- en: Side effect-free binding expressions
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无副作用的绑定表达式
- en: 'If a function is used in a binding expression, it should be side effect-free.
    Consider yet another binding:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在绑定表达式中使用了函数，它应该是无副作用的。考虑另一个绑定：
- en: '[PRE38]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And the underlying function, `getContent`:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 而底层函数`getContent`：
- en: '[PRE39]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `getContent` call changes the state of the component by updating the `timesContentRequested`
    property every time it is called. If this property is used in views such as:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '`getContent`调用通过每次调用更新`timesContentRequested`属性来改变组件的状态。如果这个属性在视图中使用，比如：'
- en: '[PRE40]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Angular throws errors such as:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: Angular会抛出诸如：
- en: '[PRE41]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The Angular framework works in two modes, dev and production. If we enable production
    mode in the application, the preceding error does not show up. Look at the framework
    documentation at [http://bit.ly/enableProdMode](http://bit.ly/enableProdMode)
    for more details.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: Angular框架以开发和生产两种模式工作。如果我们在应用中启用生产模式，则前述错误不会出现。阅读[http://bit.ly/enableProdMode](http://bit.ly/enableProdMode)获取更多框架文档详情。
- en: The bottom line is that your expression used inside property binding should
    be side effect-free.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 底线是，在属性绑定中使用的表达式应该是无副作用的。
- en: Let's now look at something interesting, `[ngStyle]`, which looks like a property
    binding, but it's not. The target specified in `[]` is not a component/element
    property (`div` does not have an `ngStyle` property), it's a directive.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看一些有趣的东西，`[ngStyle]`，看起来像是属性绑定，但实际上不是。方括号`[]`中指定的目标不是组件/元素的属性（`div`没有`ngStyle`属性），而是一个指令。
- en: Two new concepts need to be introduced, **target selection** and **directives**.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 需要引入两个新概念，**目标选择**和**指令**。
- en: Angular directives
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular指令
- en: 'As a framework, Angular tries to enhance the HTML **DSL** (short for **Domain-Specific
    Language**):'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个框架，Angular试图增强HTML的**DSL**（代表**领域特定语言**）：
- en: Components are referenced in HTML using custom tags such as `<abe-workout-runner></abe-workout-runner>`
    (not part of standard HTML constructs). This highlights the first extension point.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在HTML中，组件通过自定义标签引用，例如`<abe-workout-runner></abe-workout-runner>`（不是标准的HTML构造）。这突出了第一个扩展点。
- en: The use of `[]` and `()` for property and event binding defines the second.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于属性和事件绑定的`[]`和`()`定义了第二个扩展点。
- en: And then there are **directives**, the third extension point which are further
    classified into **attribute** and **structural directives**, and **components**
    (components are directive too!).
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后有**指令**，第三个扩展点，进一步分类为**属性**和**结构型指令**，以及**组件**（组件也是指令！）。
- en: While components come with their own view, attribute directives are there to
    enhance the appearance and/or behavior of existing elements/components.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管组件自带视图，但属性指令用于增强现有元素/组件的外观和/或行为。
- en: Structural directives do not have their own view too; they change the DOM layout
    of the elements on which they are applied. We will dedicate a complete section
    later in the chapter to understanding these structural directives.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 结构指令也没有自己的视图；它们改变了应用在其上的元素的DOM布局。我们将在本章后面专门讨论理解这些结构指令的完整部分。
- en: 'The `ngStyle` directive used in the `workout-runner` view is, in fact, an attribute
    directive:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在`workout-runner`视图中使用的`ngStyle`指令实际上是一个属性指令。
- en: '[PRE42]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `ngStyle` directive does not have its own view; instead, it allows us to
    set multiple styles (`width` in this case) on an HTML element using binding expressions.
    We will be covering a number of framework attribute directives later in this book.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngStyle`指令并没有自己的视图；相反，它允许我们使用绑定表达式在HTML元素上设置多个样式（在这种情况下是`width`）。我们将在本书的后面涵盖许多框架属性指令。'
- en: Directive nomenclature
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 指令名称
- en: Directives is an umbrella term used for component directives (also known as
    components), attribute directives, and structural directives. Throughout the book,
    when we use the term directive, we will be referring to either an attribute directive
    or a structural directive depending on the context. Component directives are always
    referred to as components.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 指令是一个用于组件指令（也称为组件）、属性指令和结构指令的总称。在本书中，当我们使用术语指令时，根据上下文我们将指的是属性指令或结构指令中的一个。组件指令总是被称为组件。
- en: With a basic understanding of the directive types that Angular has, we can comprehend
    the process of target selection for binding.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 有了对Angular具有的指令类型的基本理解，我们就能理解绑定的目标选择过程。
- en: Target selection for binding
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定的目标选择
- en: 'The target specified in `[]` is not limited to a component/element property.
    While the property name is a common target, the Angular templating engine actually
    does heuristics to decide the target type. Angular first searches the registered
    known directives (attribute or structural) that have matching selectors before
    looking for a property that matches the target expression. Consider this view
    fragment:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在`[]`中指定的目标不限于组件/元素属性。虽然属性名是一个常见的目标，但Angular模板引擎实际上进行启发式处理来决定目标类型。Angular首先搜索注册的已知指令（属性或结构），这些指令具有匹配的选择器，然后再寻找匹配目标表达式的属性。考虑这个视图片段：
- en: '[PRE43]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The search for a target starts with a framework looking at all internal and
    custom directives with a matching selector (`ngStyle`). Since Angular already
    has an `NgStyle` directive, it becomes the target (the directive class name is
    `NgStyle`, whereas the selector is `ngStyle`). If Angular did not have a built-in
    `NgStyle` directive, the binding engine would have looked for a property called
    `ngStyle` on the underlying component.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找目标的过程始于框架查找所有具有匹配选择器（`ngStyle`）的内置和自定义指令。由于Angular已经有一个`NgStyle`指令，它成为了目标（指令类名为`NgStyle`，而选择器是`ngStyle`）。如果Angular没有内置的`NgStyle`指令，绑定引擎将会在底层组件上寻找名为`ngStyle`的属性。
- en: If nothing matches the target expression, an unknown directive error is thrown*.*
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有匹配目标表达式，就会抛出未知指令错误。
- en: That completes our discussion on target selection. The next section is about
    attribute binding.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对目标选择的讨论。下一部分是关于属性绑定的。
- en: Attribute binding
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性绑定
- en: The only reason attribute binding exists in Angular is that there are HTML attributes
    that do not have a backing DOM property. The `colspan` and `aria` attributes are
    some good examples of attributes without backing properties. The progress bar
    div in our view uses attribute binding.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 属性绑定存在的唯一原因是Angular中存在一些没有相关DOM属性的HTML属性。`colspan`和`aria`属性就是一些没有相关属性的良好示例。我们的视图中的进度条div使用了属性绑定。
- en: If attribute directives are still playing your head, I cannot blame you, it
    can become a bit confusing. Fundamentally, they are different. Attribute directives
    (such as `[ngStyle]`) change the appearance or behavior of DOM elements and as
    the name suggests are directives. There is no attribute or property named `ngStyle`
    on any HTML element. Attribute binding, on the other hand, is all about binding
    to HTML attributes that do not have backing for a DOM property.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 如果属性指令仍然让你困惑，我可以理解，它可能变得有点混乱。基本上，它们是不同的。属性指令（例如`[ngStyle]`）改变了DOM元素的外观或行为，正如其名称所示，它们是指令。在任何HTML元素上没有名为`ngStyle`的属性或属性。另一方面，属性绑定是关于绑定到没有对应DOM属性的HTML属性。
- en: 'The *7 Minute Workout* uses attribute binding at two places, `[attr.aria-valuenow]`
    and `[attr.aria-valuemax]`. We may ask a question: can we use standard interpolation
    syntax to set an attribute? No, that does not work! Let''s try it: open `workout-runner.component.html`
    and replace the two aria attributes `attr.aria-valuenow` and `attr.aria-valuemax`
    enclosed in `[]` with this highlighted code:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '*7分钟锻炼*在两个地方使用了属性绑定，分别是`[attr.aria-valuenow]`和`[attr.aria-valuemax]`。我们可能会问一个问题：我们能否使用标准的插值语法来设置属性呢？不能，那是行不通的！让我们试试：打开`workout-runner.component.html`，将两个`[]`中的aria属性`attr.aria-valuenow`和`attr.aria-valuemax`替换为下划线代码：'
- en: '[PRE44]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Save the view and if the app is not running, run it. This error will pop up
    in the browser console:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '保存视图，如果应用程序未运行，请运行它。这个错误将在浏览器控制台中弹出:'
- en: '[PRE45]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Angular is trying to search for a property called `ariaValuenow` in the `div`
    that does not exist! Remember, interpolations are actually property bindings.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: Angular试图搜索在不存在的`div`中的`ariaValuenow`属性！记住，插值实际上是属性绑定。
- en: 'We hope that this gets the point across: to bind to an HTML attribute, use
    attribute binding.'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望这能传达要点：要绑定到HTML属性，使用属性绑定。
- en: Angular binds to properties by default and not to attributes.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: Angular默认绑定到属性而不是属性。
- en: 'To support attribute binding, Angular uses a prefix notation, `attr`, within
    `[]`. An attribute binding looks as follows:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '为了支持属性绑定，Angular使用了前缀表示法，在`[]`内使用`attr`。属性绑定如下所示:'
- en: '[PRE46]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Revert to the original aria setup to make attribute binding work:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 恢复原来的aria设置使属性绑定生效：
- en: '[PRE47]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Remember that unless an explicit `attr.` prefix is attached, attribute binding
    does not work.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果不附加显式的`attr.`前缀，属性绑定是不起作用的。
- en: While we have not used style and class-based binding in our workout view, these
    are some binding capabilities that can come in handy. Hence, they are worth exploring.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在训练视图中没有使用样式和类绑定，但这些是一些方便的绑定功能，可能会派上用场。因此，值得探索一下。
- en: Style and class binding
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 样式和类绑定
- en: 'We use **class binding** to set and remove a specific class based on the component
    state, as follows:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用**类绑定**根据组件状态设置或移除特定类，如下所示：
- en: '[PRE48]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This adds `class-name` when `expression` is `true` and removes it when it is
    `false`. A simple example can look as follows:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '当`expression`为`true`时，添加`class-name`，当`expression`为`false`时，移除它。一个简单的例子可能如下所示:'
- en: '[PRE49]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Use style bindings to set inline styles based on the component state:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '使用样式绑定根据组件状态设置内联样式:'
- en: '[PRE50]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'While we have used the `ngStyle` directive for the workout view, we could have
    easily used style binding as well, as we are dealing with a single style. With
    style binding, the same `ngStyle` expression would become the following:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '虽然在训练视图中我们使用了`ngStyle`指令，但我们也可以使用样式绑定，因为我们只涉及到单一样式。使用样式绑定后，同样的`ngStyle`表达式会变成下面这样:'
- en: '[PRE51]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '`width` is a style, and since it takes units too, we extend our target expression
    to include the `%` symbol.'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '`width`是一种样式，由于它还带有单位，我们扩展我们的目标表达式以包含`%`符号。'
- en: 'Remember that `style.` and `class.` are convenient bindings for setting a single
    class or style. For more flexibility, there are corresponding attribute directives:
    `ngClass` and `ngStyle`.'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`style.`和`class.`是方便的绑定方式，用于设置单一类或样式。为了更灵活，还有相应的属性指令：`ngClass`和`ngStyle`。
- en: Earlier in the chapter, we formally introduced directives and their classifications.
    One of the directives types, attribute directives (again, don't confuse them with
    attribute binding, which we introduced in the preceding section) are the focus
    of our attention in the next section.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章早些时候，我们正式介绍了指令及其分类。其中一个指令类型是属性指令（再次强调，不要将它们与我们在前一节介绍的属性绑定混淆）。在下一节中，我们将着重讲述属性指令。
- en: Attribute directives
  id: totrans-430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性指令
- en: Attribute directives are HTML extensions that change the look, feel or behavior
    of a component/element. As described in the section on Angular directives, these
    directives do not define their own view.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 属性指令是改变组件/元素外观、感觉或行为的HTML扩展。正如在Angular指令部分中描述的那样，这些指令不定义自己的视图。
- en: Other than `ngStyle` and `ngClass` directives, there are a few more attribute
    directives that are part of the core framework. `ngValue`, `ngModel`, `ngSelectOptions`,
    `ngControl`, and `ngFormControl` are some of the attribute directives that Angular
    provides.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`ngStyle`和`ngClass`指令外，核心框架还提供了一些其他属性指令。`ngValue`、`ngModel`、`ngSelectOptions`、`ngControl`和`ngFormControl`都是Angular提供的一些属性指令。
- en: Since *7 Minute Workout* uses the `ngStyle` directive, it would be wise to dwell
    more on this directive and its close associate `ngClass`.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 由于*7分钟锻炼*使用了`ngStyle`指令，更加深入地探究这个指令及其密切相关的`ngClass`是明智的选择。
- en: While the next section is dedicated to learning how to use the `ngClass` and
    `ngStyle` attribute directives, it is not until [Chapter 4](c3725f08-81b4-4bd5-a50f-6173510dd9c6.xhtml),
    *Angular Directives in Depth*, that we learn how to create our own attribute directives.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然下一节专门介绍了如何使用`ngClass`和`ngStyle`属性指令，但直到[第四章](c3725f08-81b4-4bd5-a50f-6173510dd9c6.xhtml)，*深入学习Angular指令*，我们才学习如何创建我们自己的属性指令。
- en: Styling HTML with ngClass and ngStyle
  id: totrans-435
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`ngClass`和`ngStyle`为HTML设置样式
- en: 'Angular has two excellent directives that allow us to dynamically set styles
    on any element and toggle CSS classes. For the bootstrap progress bar, we use
    the `ngStyle` directive to dynamically set the element''s style, `width`, as the
    exercise progresses:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: Angular有两个出色的指令，可以让我们在任何元素上动态设置样式并切换CSS类。对于Bootstrap进度条，我们使用`ngStyle`指令动态设置元素的`width`样式，随着练习的进行而变化：
- en: '[PRE52]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '`ngStyle` allows us to bind one or more styles to a component''s properties
    at once. It takes an object as a parameter. Each property name on the object is
    the style name, and the value is the Angular expression bound to that property,
    such as the following example:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngStyle`允许我们一次绑定一个或多个样式到组件的属性。它以对象作为参数。对象上的每个属性名称都是样式名称，值是绑定到该属性的Angular表达式，例如以下示例：'
- en: '[PRE53]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The styles can not only bind to component properties (`componentWidth` and `componentHeight`),
    but also be set to a constant value (`'larger'`). The expression parser also allows
    the use of the ternary operator (`?:`); check out `isRequired`.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 样式不仅可以绑定到组件属性（`componentWidth`和`componentHeight`），还可以设置为常量值（`'larger'`）。表达式解析器还允许使用三元运算符（`?:`）；查看`isRequired`。
- en: 'If styles become too unwieldy in HTML, we also have the option of writing in
    our component a function that returns the object hash, and setting that as an
    expression:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在HTML中样式变得过于复杂，我们也可以选择在我们的组件中编写一个返回对象哈希的函数，并将其设置为表达式：
- en: '[PRE54]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Moreover, `getStyles` on the component looks as follows:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，组件中的`getStyles`看起来如下所示：
- en: '[PRE55]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '`ngClass` works on the same lines too, except that it is used to toggle one
    or multiple classes. For example, check out the following code:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngClass`也是按照相同的原则工作，只是它用于切换一个或多个类。例如，看看以下代码：'
- en: '[PRE56]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `required` class is applied when `inputRequired` is `true` and is removed
    when it evaluates to `false`.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 当`inputRequired`为`true`时将应用`required`类，反之则将其移除。
- en: Directives (custom or platform) like any other Angular artifact, always belong
    to a module. To use them across modules, the module needs to be imported. Wondering
    where `ngStyle` is defined? `ngStyle` is part of the core framework module, `CommonModule,`,
    and has been imported in the workout runner module definition (`workout-runner.module.ts`).
    `CommonModule` defines a number of handy directives that are used across Angular.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 指令（自定义或平台）像任何其他Angular构件一样，始终属于一个模块。要跨模块使用它们，需要导入该模块。想知道`ngStyle`是在哪里定义的吗？`ngStyle`是核心框架模块`CommonModule`的一部分，并已在训练模块定义中（`workout-runner.module.ts`）导入。`CommonModule`定义了许多方便的指令，它们在整个Angular中被使用。
- en: Well! That covers everything we had to learn about our newly developed view.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 好了！这就涵盖了我们需要了解的有关我们新开发的视图的一切。
- en: And as described earlier, if you are having a problem with running the code,
    look at the Git branch `checkpoint2.2`. If not using Git, download the snapshot
    of `checkpoint2.2` (a ZIP file) from [http://bit.ly/ng2be-checkpoint2-2](http://bit.ly/ng2be-checkpoint2-2).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前所述，如果在运行代码时遇到问题，请查看Git分支`checkpoint2.2`。如果不使用Git，请从[http://bit.ly/ng2be-checkpoint2-2](http://bit.ly/ng2be-checkpoint2-2)下载`checkpoint2.2`的快照（ZIP文件）。在第一次设置快照时，请参考`trainer`文件夹中的`README.md`文件。
- en: Time to add some enhancements and learn a bit more about the framework!
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候添加一些增强功能并更多地了解这个框架了！
- en: Learning more about an exercise
  id: totrans-452
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多了解练习
- en: For people who are doing this workout for the first time, it will be good to
    detail the steps involved in each exercise. We can also add references to some
    YouTube videos for each exercise to help the user understand the exercise better.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一次进行这项锻炼的人来说，详细描述每个练习中涉及的步骤将是有益的。我们还可以为每个练习添加一些YouTube视频的引用，以帮助用户更好地理解练习。
- en: We are going to add the exercise description and instructions in the left panel
    and call it the **description panel**. We will also add references to YouTube
    videos in the right panel, which is the video player panel. To make things more
    modular and learn some new concepts, we are going to create independent components
    for each description panel and video panel.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在左侧面板中添加练习描述和说明，并将其称为**描述面板**。我们还将在右侧面板中添加对YouTube视频的引用，即视频播放器面板。为了使事情更加模块化并学习一些新概念，我们将为每个描述面板和视频面板创建独立的组件。
- en: The model data for this is already available. The `description` and `procedure`
    properties in the `Exercise` class (see `model.ts`) provide the necessary details
    about the exercise. The `videos` array contains some related YouTube video IDs,
    which will be used to fetch these videos.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 此模型数据已经可用。`Exercise`类的`description`和`procedure`属性（见`model.ts`）提供了有关练习的必要详细信息。`videos`数组包含一些相关的YouTube视频ID，将用于获取这些视频。
- en: Adding descriptions and video panels
  id: totrans-456
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加描述和视频面板
- en: 'An Angular app is nothing but a hierarchy of components, similar to a tree
    structure. As of now, *7 Minute Workout* has two components, the root component,
    `AppComponent`, and its child, `WorkoutRunnerComponent`, in line with the HTML
    component layout, which now looks as follows:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 应用程序实际上就是一组组件的层次结构，类似于树结构。截止目前，*7 Minute Workout* 有两个组件，根组件`AppComponent`和其子组件`WorkoutRunnerComponent`，与HTML组件布局一致，现在看起来如下：
- en: '[PRE57]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Run the app and do a view source to verify this hierarchy. As we all more components
    to implement new features in the application this component tree grows and branches
    out.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并查看源代码以验证此层次结构。随着我们在应用程序中添加更多组件以实现新功能，该组件树将不断增长并分支出。
- en: We are going to add two subcomponents to `WorkoutRunnerComponent`, one each
    to support the exercise description and exercise videos. While we could have added
    some HTML directly to the `WorkoutRunnerComponent` view, what we are hoping here
    is to learn a bit more about cross-component communication. Let's start with adding
    the description panel on the left and understand how a component can accept inputs.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向`WorkoutRunnerComponent`添加两个子组件，分别用于支持练习描述和练习视频。虽然我们可以直接向`WorkoutRunnerComponent`视图添加一些HTML，但我们希望在这里学习一些有关组件间通信的知识。让我们从在左侧添加描述面板开始，并了解组件如何接受输入。
- en: Component with inputs
  id: totrans-461
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有输入的组件
- en: 'Navigate to the `workour-runner` folder and generate a boilerplate exercise
    description component:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 转到`workour-runner`文件夹并生成一个样板练习描述组件：
- en: '[PRE58]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'To the generated `exercise-description.component.ts` file, add the highlighted
    code:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 向生成的`exercise-description.component.ts`文件添加突出显示的代码：
- en: '[PRE59]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `@Input` decorator signifies that the component property is available for
    data binding. Before we dig into the `@Input` decorator, let's complete the view
    and integrate it with `WorkoutRunnerComponent`.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Input`装饰器表示该组件属性可用于数据绑定。在我们深入研究`@Input`装饰器之前，让我们完成视图并将其与`WorkoutRunnerComponent`集成。'
- en: 'Copy the view definition for exercise description, `exercise-description.component.html`,
    from the Git branch `checkpoint2.3`, in the `workout-runner/exercise-description` folder.
    Look at the highlighted HTML for the exercise description:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 从`workout-runner/exercise-description`文件夹中的Git分支`checkpoint2.3`复制练习描述的视图定义，`exercise-description.component.html`。查看练习描述的突出显示的HTML：
- en: '[PRE60]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The preceding interpolation references the input properties of `ExerciseDescriptionComponent`:
    `description` and `steps`.'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的插值引用了`ExerciseDescriptionComponent`的输入属性：`description`和`steps`。
- en: The component definition is complete. Now, we just need to reference `ExerciseDescriptionComponent`
    in `WorkoutRunnerComponent` and provide values for `description` and `steps` for
    the `ExerciseDescriptionComponent` view to render correctly.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 组件定义完成。现在，我们只需在`WorkoutRunnerComponent`中引用`ExerciseDescriptionComponent`并为`ExerciseDescriptionComponent`的`description`和`steps`提供值，以便视图正确呈现。
- en: 'Open `workout-runner.component.html` and update the HTML fragments as highlighted
    in the following code. Add a new div called `description-panel` before the `exercise-pane`
    div and adjust some styles on the `exercise-pane` div, as follows:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`workout-runner.component.html`并根据以下代码中突出显示部分更新HTML片段。在`exercise-pane` div之前添加一个名为`description-panel`的新div，并调整`exercise-pane`
    div的一些样式，如下所示：
- en: '[PRE61]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: If the app is running, the description panel should show up on the left with
    the relevant exercise details.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用正在运行，则描述面板应显示在左侧，并显示相关的练习详情。
- en: '`WorkoutRunnerComponent` was able to use `ExerciseDescriptionComponent` because
    it has been declared on `WorkoutRunnerModule` (see the `workout-runner.module.ts` declaration
    property). The Angular CLI component generator does this work for us.'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutRunnerComponent`能够使用`ExerciseDescriptionComponent`是因为它已经在`WorkoutRunnerModule`上声明了（参见`workout-runner.module.ts`中的声明属性）。Angular
    CLI组件生成器为我们执行这项工作。'
- en: Look back at the `abe-exercise-description` declaration in the preceding view.
    We are referring to the `description` and `steps` properties in the same manner
    as we did with the HTML element properties earlier in the chapter (`<img [src]='expression'
    ...`). Simple, intuitive, and very elegant!
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾前面视图中的`abe-exercise-description`声明。我们以与本章前面对HTML元素属性的引用方式相同的方式引用`description`和`steps`属性。简单、直观且非常优雅！
- en: The Angular data binding infrastructure makes sure that whenever the `currentExercise.exercise.description`
    and `currentExercise.exercise.procedure` properties on `WorkoutRunnerComponent`
    change, the bound properties on `ExerciseDescriptionComponent`, `description`,
    and `steps` are also updated.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: Angular数据绑定基础设施确保当`WorkoutRunnerComponent`上的`currentExercise.exercise.description`和`currentExercise.exercise.procedure`属性发生变化时，`ExerciseDescriptionComponent`上绑定的属性`description`和`steps`也会被更新。
- en: 'The `@Input` decoration can take a property alias as a parameter, which means
    the following: consider a property declaration such as: `@Input("myAwesomeProperty")
    myProperty:string`. It can be referenced in the view as follows: `<my-component
    [myAwesomeProperty]="expression"....`'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Input`装饰符可以接受一个属性别名作为参数，这意味着以下内容：考虑一个属性声明，如：`@Input("myAwesomeProperty")
    myProperty:string`。它可以在视图中如下引用：`<my-component [myAwesomeProperty]="expression"....`'
- en: 'The power of the Angular binding infrastructure allows us to use any component
    property as a bindable property by attaching the `@Input` decorator (and `@Output`
    too) to it. We are not limited to basic data types such as `string`, `number`,
    and `boolean`; there can be complex objects too, which we will see next as we
    add the video player:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: Angular绑定基础设施的强大之处允许我们将任何组件属性作为可绑定属性，方法是将`@Input`装饰器（和`@Output`也是）附加到它上。我们不限于基本数据类型，如`string`、`number`和`boolean`；也可以是复杂对象，接下来我们将在添加视频播放器时看到：
- en: The `@Input` decorator can be applied to complex objects too.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Input`装饰器也可以应用于复杂对象。'
- en: 'Generate a new component in the `workout-runner` directory for the video player:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 在`workout-runner`目录下为视频播放器生成一个新组件：
- en: '[PRE62]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Update the generated boilerplate code by copying implementation from `video-player.component.ts`
    and `video-player.component.html` available in the Git branch `checkpoint2.3`
    in the `trainer/src/components/workout-runner/video-player` folder (GitHub location:
    [http://bit.ly/ng6be-2-3-video-player](http://bit.ly/ng6be-2-3-video-player)).'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从位于GitHub位置[http://bit.ly/ng6be-2-3-video-player](http://bit.ly/ng6be-2-3-video-player)的`trainer/src/components/workout-runner/video-player`目录下的`video-player.component.ts`和`video-player.component.html`复制实现，更新生成的样板代码（位于Git分支`checkpoint2.3`中）。
- en: 'Let''s look at the implementation for the video player. Open `video-player.component.ts`
    and check out the `VideoPlayerComponent` class:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看视频播放器的实现。打开`video-player.component.ts`并查看`VideoPlayerComponent`类：
- en: '[PRE63]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The `videos` input property here takes an array of strings (YouTube video codes).
    While we take the `videos` array as input, we do not use this array directly in
    video player view; instead, we transform the input array into a new array of `safeVideoUrls`
    and bind it. This can be confirmed by looking at the view implementation:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`videos`输入属性接受一个字符串数组（YouTube视频代码）。虽然我们将`videos`数组作为输入，但我们并不直接在视频播放器视图中使用该数组；相反，我们将输入数组转换成一个新的`safeVideoUrls`数组并进行绑定。这可以通过查看视图实现来确认：
- en: '[PRE64]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The view also uses a new Angular directive called `ngFor` to bind to the `safeVideoUrls`
    array. The `ngFor` directive belongs to a class of directives called **structural
    directives**. The directive's job is to take an HTML fragment and regenerate it
    based on the number of elements in the bound collection.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 视图还使用了一个名为`ngFor`的新的Angular指令来绑定`safeVideoUrls`数组。`ngFor`指令属于一类名为**结构指令**的指令。该指令的作用是根据绑定集合中的元素数量重新生成HTML片段。
- en: If you are confused about how the `ngFor` directive works with `safeVideoUrls`,
    and why we need to generate `safeVideoUrls` instead of using the `videos` input
    array, wait for a while as we are shortly going to address these queries. But,
    let's first complete the integration of `VideoPlayerComponent` with `WorkoutRunnerComponent`
    to see the final outcome.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对`ngFor`指令如何与`safeVideoUrls`一起使用以及为什么我们需要生成`safeVideoUrls`而不是使用`videos`输入数组感到困惑，稍等片刻，因为我们很快就要解决这些问题。但是，让我们先完成`VideoPlayerComponent`与`WorkoutRunnerComponent`的集成，以查看最终结果。
- en: 'Update the `WorkoutRunnerComponent` view by adding the component declaration
    after the `exercise-pane` div:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 在`exercise-pane` div后添加组件声明更新`WorkoutRunnerComponent`视图：
- en: '[PRE65]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The `VideoPlayerComponent`'s `videos` property binds to the exercise's videos
    collection.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '`VideoPlayerComponent`的`videos`属性绑定到运动的视频集合。'
- en: Start/refresh the app and the video thumbnails should show up on the right.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 启动/刷新应用程序，视频缩略图应显示在右侧。
- en: If you are having a problem with running the code, look at the Git branch `checkpoint2.3`
    for a working version of what we have done thus far. You can also download the
    snapshot of `checkpoint2.3` (a ZIP file) from [http://bit.ly/ng6be-checkpoint-2-3](http://bit.ly/ng6be-checkpoint-2-3).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在运行代码时遇到问题，请查看Git分支`checkpoint2.3`，以获取迄今为止我们所做内容的可工作版本。您还可以从[http://bit.ly/ng6be-checkpoint-2-3](http://bit.ly/ng6be-checkpoint-2-3)下载`checkpoint2.3`的快照（ZIP文件）。在首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。
- en: 'Now, it''s time to go back and look at the parts of the `VideoPlayerComponent`
    implementation. We specifically need to understand:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候回顾并了解`VideoPlayerComponent`实现的部分。我们特别需要理解：
- en: How the `ngFor` directive works
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngFor`指令的工作原理'
- en: Why there is a need to transform the input `videos` array into `safeVideoUrls`
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么需要将输入的`videos`数组转换为`safeVideoUrls`
- en: The significance of the Angular component life cycle event `OnChanges` (used
    in the video player)
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular组件生命周期事件`OnChanges`的重要性（在视频播放器中使用）
- en: 'To start with, it''s time to formally introduce `ngFor` and the class of directives
    it belongs to: structural directives.'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，是时候正式介绍`ngFor`和它所属的指令类别：结构指令。
- en: Structural directives
  id: totrans-499
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构指令
- en: The third categorization of directives, structural directives, work on the components/elements
    to manipulate their layout.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 指令的第三种分类，结构指令，用于操作其布局的组件/元素。
- en: 'The Angular documentation describes structural directives in a succinct manner:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: Angular文档简洁描述了结构指令：
- en: '"Instead of defining and controlling a view like a Component Directive, or
    modifying the appearance and behavior of an element like an Attribute Directive,
    the Structural Directive manipulates the layout by adding and removing entire
    element sub-trees."'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: “与定义和控制视图（如组件指令）或修改元素外观和行为（如属性指令）不同，结构指令通过添加和移除整个元素子树来操纵布局。”
- en: Since we have already touched upon component directives (such as `workout-runner`
    and `exercise-description`) and attribute directives (such as `ngClass` and `ngStyle`),
    we can very well contrast their behaviors with structural directives.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经涉及到组件指令（例如`workout-runner`和`exercise-description`）和属性指令（例如`ngClass`和`ngStyle`），我们可以很好地将它们的行为与结构指令进行对比。
- en: The `ngFor` directive belongs to this class. We can easily identify such directives
    by the `*` prefix. Other than `ngFor`, Angular comes with some other structural
    directives such as `ngIf` and `ngSwitch`.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngFor`指令属于这个类。我们可以通过`*`前缀轻松识别这类指令。除了`ngFor`，Angular还提供了一些其他结构指令，如`ngIf`和`ngSwitch`。'
- en: The ever-so-useful NgForOf
  id: totrans-505
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非常有用的`NgForOf`
- en: 'Every templating language has constructs that allow the templating engine to
    generate HTML (by repetition). Angular has `NgForOf`. The `NgForOf` directive
    is a super useful directive used to duplicate a piece of an HTML fragment n number
    of times. Let''s again look at how we have used `NgForOf` in the video player:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 每种模板语言都有构造，允许模板引擎通过重复生成HTML。Angular有`NgForOf`。`NgForOf`指令是一个非常有用的指令，用于将HTML片段的一部分复制n次。让我们再次看看我们如何在视频播放器中使用`NgForOf`：
- en: '[PRE66]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The directive selector for `NgForOf` is `{selector: ''[ngFor][ngForOf]''}`,
    so we can use either `ngFor` or `ngForOf` in the view template. We also at times
    refer to this directive as `ngFor`.'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '`NgForOf`的指令选择器为`{selector: ''[ngFor][ngForOf]''}`，因此我们可以在视图模板中使用`ngFor`或`ngForOf`。我们有时也将此指令称为`ngFor`。'
- en: 'The preceding code repeats the `div` fragment for each exercise video (using
    the `safeVideoUrls` array). The `let video of safeVideoUrls` string expression
    is interpreted as follows: take each video in the `safeVideoUrls` array and assign
    it to a template input variable, `video`.'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码为每个训练视频（使用`safeVideoUrls`数组）重复`div`片段。 字符串表达式`let video of safeVideoUrls`的解释如下：在`safeVideoUrls`数组中取每个视频，并将其分配给模板输入变量`video`。
- en: This input variable can now be referenced inside the `ngFor` template HTML,
    as we do when we set the `src` property binding.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以在`ngFor`模板HTML中引用此输入变量，就像我们设置`src`属性绑定时那样。
- en: Interestingly, the string assigned to the `ngFor` directive is not a typical
    Angular expression. Instead, it's a **microsyntax**—a micro language, which the
    Angular engine can parse.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，分配给`ngFor`指令的字符串并不是典型的Angular表达式。 相反，它是一种**微语法**—一种Angular引擎可以解析的微语言。
- en: You can learn more about microsyntax in Angular's developer guide: [http://bit.ly/ng6be-micro-syntax](http://bit.ly/ng6be-micro-syntax).
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Angular的开发者指南中了解有关微语法的更多信息：[http://bit.ly/ng6be-micro-syntax](http://bit.ly/ng6be-micro-syntax)。
- en: This microsyntax exposes a number of iteration context properties that we can
    assign to template input variables and use them inside the `ngFor` HTML block.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 这个微语法公开了一些迭代上下文属性，我们可以将它们分配给模板输入变量，并在`ngFor` HTML区块内使用它们。
- en: 'One such example is `index`. `index` increases from 0 to the length of the
    array for each iteration, something similar to a `for` loop, in any programming
    language. The following example shows how to capture it:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '`index`就是一个这样的例子。`index`在每次迭代时从0增加到数组的长度，类似于任何编程语言中的`for`循环。 以下示例显示了如何捕获它：'
- en: '[PRE67]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Other than `index`, there are some more iteration context variables; these
    include `first`, `last`, `even`, and `odd`. This context data allows us to do
    some nifty stuff. Consider this example:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 除`index`之外，还有一些迭代上下文变量；这些包括`first`、 `last`、 `even`和`odd`。 这些上下文数据允许我们做一些巧妙的事情。
    考虑这个例子：
- en: '[PRE68]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: It applies a `special` class to the first video `div`.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 它对第一个视频`div`应用了`special`类。
- en: 'The `NgForOf` directive can be applied to HTML elements as well as our custom
    components. This is a valid use of `NgForOf`:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '`NgForOf`指令可以应用于HTML元素以及我们的自定义组件。 这是`NgForOf`的有效用法：'
- en: '[PRE69]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Always remember to add an asterisk (`*`) before `ngFor` (and other structural
    directives). `*` has a significance.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '**始终记住在`ngFor`（和其他结构指令）之前加上星号（`*`）。** `*`有其重要性。'
- en: Asterisk (*) in structural directives
  id: totrans-522
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构指令中的星号（*）
- en: 'The `*` prefix is a terser format to represent a structural directive. Take,
    for example, the usage of `ngFor` by the video player. The `ngFor` template:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '`*`前缀是一种更简洁的格式，用于表示结构指令。 例如，视频播放器使用`ngFor`的用法。 `ngFor`模板：'
- en: '[PRE70]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Actually expands to the following:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上扩展为以下内容：
- en: '[PRE71]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The `ng-template` tag is an Angular element that has a declaration for `ngFor`,
    a template input variable (`video`), and a property (`ngForOf`) that points to
    the `safeVideoUrls` array. Both the preceding declarations are a valid usage of
    `ngFor`.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '`ng-template`标签是一个Angular元素，有一个对`ngFor`的声明，一个模板输入变量（`video`）和指向`safeVideoUrls`数组的属性（`ngForOf`）。
    前述两个声明都是`ngFor`的有效用法。'
- en: Not sure about you, but I prefer the terser first format for `ngFor`!
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 不知道你怎么看，但我更喜欢`ngFor`的更简洁的格式！
- en: NgForOf performance
  id: totrans-529
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`NgForOf`性能'
- en: 'Since `NgForOf` generates HTML based on collection elements, it is notorious
    for causing performance issues. But we cannot blame the directive. It does what
    it is supposed to do: iterate and generate elements! If the underlying collection
    is huge, UI rendering can take a performance hit, especially if the collection
    changes too often. The cost of continuously destroying and creating elements in
    response to a changing collection can quickly become prohibitive.'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`NgForOf`根据集合元素生成HTML，它因导致性能问题而声名狼藉。 但我们不能责怪指令。 它只是在应该做的事情：迭代和生成元素！ 如果底层集合很庞大，UI渲染可能会受到性能影响，特别是如果集合经常发生变化。
    持续销毁和创建元素以响应不断变化的集合的成本可以很快变得禁止。
- en: One of the performance tweaks for `NgForOf` allows us to alter the behavior
    of `ngForOf` when it comes to creating and destroying DOM elements (when the underlying
    collection elements are added or removed).
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`NgForOf`的性能调整之一允许我们在底层集合元素添加或删除时改变`ngForOf`的行为，从而创建和销毁DOM元素。
- en: Imagine a scenario where we frequently get an array of objects from the server
    and bind it to the view using `NgForOf`. The default behavior of `NgForOf` is
    to regenerate the DOM every time we refresh the list (since Angular does a standard
    object equality check). However, as developers, we may very well know not much
    has changed. Some new objects may have been added, some removed, and maybe some
    modified. But Angular just regenerates the complete DOM.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一种情况，我们经常从服务器获得一个对象数组，并使用`NgForOf`将其绑定到视图。`NgForOf`的默认行为是在每次刷新列表时重新生成 DOM（因为
    Angular 进行标准对象相等性检查）。然而，作为开发人员，我们可能很清楚并没有太多的变化。可能有一些新对象已经添加，一些删除，也许一些修改。但是 Angular
    只是重新生成整个 DOM。
- en: 'To alleviate this situation, Angular allows us to specify a custom **tracking
    function**, which lets Angular know when two objects being compared are equal.
    Have a look at the following function:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 为了缓解这种情况，Angular 允许我们指定一个自定义的**跟踪函数**，让 Angular 知道何时两个比较的对象是相等的。看看以下函数：
- en: '[PRE72]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: A function such as this can be used in the `NgForOf` template to tell Angular
    to compare the *user* object based on its `id` property instead of doing a reference
    equality check.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如这样的函数可以在`NgForOf`模板中用来告诉 Angular 基于它的`id`属性而不是进行引用相等性检查来比较 *user* 对象。
- en: 'This is how we then use the preceding function in the `NgForOf` template:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们如何在`NgForOf`模板中使用先前的函数：
- en: '[PRE73]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '`NgForOf` will now avoid recreating DOM for users with IDs already rendered.'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '`NgForOf` 现在将避免为已呈现的用户 ID 重新创建 DOM。'
- en: Remember, Angular may still update the existing DOM elements if the bound properties
    of a user have changed.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果用户的绑定属性发生了变化，Angular 仍然可能会更新现有的 DOM 元素。
- en: That's enough on the `ngFor` directive; let's move ahead.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 对`ngFor`指令就讲到这里，让我们继续吧。
- en: We still need to understand the role of the `safeVideoUrls` and the `OnChange`
    life cycle events in the `VideoPlayerComponent` implementation. Let's tackle the
    former first and understand the need for `safeVideoUrls`.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要了解`VideoPlayerComponent`实现中的`safeVideoUrls`和`OnChange`生命周期事件的作用。让我们首先解决前者，并了解对`safeVideoUrls`的需求。
- en: Angular security
  id: totrans-542
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 安全性
- en: 'The easiest way to understand why we need to bind to `safeVideoUrls` instead
    of the `videos` input property is by trying the `videos` array out. Replace the
    existing `ngFor` fragment HTML with the following:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 了解为什么我们需要绑定到`safeVideoUrls`而不是`videos`输入属性的最简单方法是尝试一下`videos`数组。用以下内容替换现有的`ngFor`片段
    HTML：
- en: '[PRE74]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'And look at the browser''s console log (a page refresh may be required). There
    are a bunch of errors thrown by the framework, such as:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下浏览器的控制台日志（可能需要刷新页面）。框架会抛出一堆错误，比如：
- en: '`Error: unsafe value used in a resource URL context (see http://g.co/ng/security#xss)`'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '`Error: unsafe value used in a resource URL context (see http://g.co/ng/security#xss)`'
- en: No prize for guessing what is happening! Angular is trying to safeguard our
    application against a **Cross-Site Scripting** (**XSS**) attack.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 猜猜发生了什么！Angular 正试图保护我们的应用免受**跨站脚本**（**XSS**）攻击。
- en: Such an attack enables the attacker to inject malicious code into our web pages.
    Once injected, the malicious code can read data from the current site context.
    This allows it to steal confidential data and also impersonate the logged-in user,
    hence gaining access to privileged resources.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 这种攻击使攻击者能够将恶意代码注入到我们的网页中。一旦注入，恶意代码可以从当前站点上下文读取数据。这允许它窃取机密信息，还可以冒充已登录用户，从而获得对特权资源的访问权限。
- en: Angular has been designed to block these attacks by sanitizing any external
    code/script that is injected into an Angular view. Remember, content can be injected
    into a view through a number of mechanisms, including property/attribute/style
    bindings or interpolation.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 已经设计成通过清理注入到 Angular 视图中的任何外部代码/脚本来阻止这些攻击。请记住，内容可以通过许多机制被注入到视图中，包括属性/属性/样式绑定或内插。
- en: 'Consider an example of binding HTML markup through a component model to the `innerHTML`
    property of an HTML element (property binding):'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑通过组件模型绑定 HTML 标记到 HTML 元素的`innerHTML`属性（属性绑定）的例子：
- en: '[PRE75]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: While the HTML content is emitted, any unsafe content (such as a *script*) if
    present is stripped.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 在发出 HTML 内容时，会剥离任何不安全的内容（比如 *脚本*）。
- en: But what about Iframes? In our preceding example, Angular is blocking property
    binding to Iframe's `src` property too. This is a warning against third-party
    content being embedded in our own site using Iframe. Angular prevents this too.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 那么 iframe 呢？在我们之前的例子中，Angular 也会阻止将属性绑定到 iframe 的 `src` 属性。这是针对使用 iframe 在我们自己的站点中嵌入第三方内容的警告。Angular
    也会阻止这样做。
- en: 'All in all, the framework defines four security contexts around content sanitization.
    These include:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，该框架围绕内容消毒定义了四个安全上下文。这包括：
- en: '**HTML content sanitization**, when HTML content is bound using the `innerHTML`
    property'
  id: totrans-555
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**HTML内容消毒**，当使用`innerHTML`属性绑定HTML内容时'
- en: '**Style sanitization**, when binding CSS into the `style` property'
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**样式消毒**，当将CSS绑定到`style`属性中时'
- en: '**URL sanitization**, when URLs are used with tags such as `anchor` and `img`'
  id: totrans-557
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**URL消毒**，当使用`anchor`和`img`等标签时使用URL'
- en: '**Resource sanitization**, when using `Iframes` or `script` tags; in this case,
    content cannot be sanitized and hence it is blocked by default'
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**资源消毒**，当使用`Iframes`或`script`标签时；在这种情况下，内容无法进行消毒，因此默认情况下会被阻止'
- en: Angular is trying its best to keep us out of danger. But at times, we know that
    the content is safe to render and hence want to circumvent the default sanitization
    behavior.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: Angular正在尽其所能地让我们远离危险。但有时，我们知道内容是安全的，因此希望规避默认的消毒行为。
- en: Trusting safe content
  id: totrans-560
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信任安全内容
- en: 'To let Angular know that the content being bound is safe, we use `DomSanitizer`
    and call the appropriate method based on the security contexts just described.
    The available functions are as follows:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让Angular知晓绑定的内容是安全的，我们使用`DomSanitizer`并根据刚刚描述的安全上下文调用适当的方法。可用的函数如下：
- en: '`bypassSecurityTrustHtml`'
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bypassSecurityTrustHtml`'
- en: '`bypassSecurityTrustScript`'
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bypassSecurityTrustScript`'
- en: '`bypassSecurityTrustStyle`'
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bypassSecurityTrustStyle`'
- en: '`bypassSecurityTrustUrl`'
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bypassSecurityTrustUrl`'
- en: '`bypassSecurityTrustResourceUrl`'
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bypassSecurityTrustResourceUrl`'
- en: 'In our video player implementation, we use `bypassSecurityTrustResourceUrl`;
    it converts the video URL into a trusted `SafeResourceUrl` object:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的视频播放器实现中，我们使用了`bypassSecurityTrustResourceUrl`；它将视频URL转换为一个受信任的`SafeResourceUrl`对象：
- en: '[PRE76]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The `map` method transforms the videos array into a collection of `SafeResourceUrl`
    objects and assigns it to `safeVideoUrls`.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`方法将videos数组转换为一组`SafeResourceUrl`对象并将其分配给`safeVideoUrls`。'
- en: Each of the methods listed previously takes a string parameter. This is the
    content we want Angular to know is safe. The return object, which could be any
    of `SafeStyle`, `SafeHtml`, `SafeScript`, `SafeUrl`, or `SafeResourceUrl`, can
    then be bound to the view.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 先前列出的每个方法都需要一个字符串参数。这是我们希望Angular知道是安全的内容。然后返回的对象，可能是`SafeStyle`、`SafeHtml`、`SafeScript`、`SafeUrl`或`SafeResourceUrl`，然后可以绑定到视图中。
- en: A comprehensive treatment of this topic is available in the framework security
    guide available at [http://bit.ly/ng6be-security](http://bit.ly/ng6be-security).
    A highly recommended read!
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 有关该主题的全面介绍可以在[http://bit.ly/ng6be-security](http://bit.ly/ng6be-security)的框架安全指南中找到。强烈推荐阅读！
- en: The last question to answer is why do this in the `OnChanges` Angular life cycle
    event?
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要回答的一个问题是为什么要在`OnChanges` Angular生命周期事件中进行这样的操作？
- en: OnChange life cycle event
  id: totrans-573
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OnChange生命周期事件
- en: The `OnChanges` life cycle event is triggered whenever the component's input(s)
    change. In the case of `VideoPlayerComponent`, it is the `videos` array input
    property that changes whenever a new exercise is loaded. We use this life cycle
    event to recreate the `safeVideoUrls` array and re-bind it to the view. Simple!
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 每当组件的输入发生变化时，都会触发`OnChanges`生命周期事件。对于`VideoPlayerComponent`来说，每当加载新的练习时，`videos`数组输入属性发生变化。我们利用这个生命周期事件来重新创建`safeVideoUrls`数组并重新绑定到视图。简单！
- en: Video panel implementation is now complete. Let's add a few more minor enhancements
    and explore it a bit more in Angular.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 视频面板实现现在已经完成。让我们添加一些小的增强措施，以及在Angular中进行更多的探索。
- en: Formatting exercise steps with innerHTML binding
  id: totrans-576
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用innerHTML绑定格式化练习步骤
- en: One of the sore points in the current app is the formatting of the exercise
    steps. It's a bit difficult to read these steps.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 目前应用程序中的一个痛点是练习步骤的格式。这些步骤有点难以阅读。
- en: 'The steps should either have a line break (`<br>`) or be formatted as an HTML
    `list` for easy readability. This seems to be a straightforward task, and we can
    just go ahead and change the data that is bound to the step interpolation, or
    write a pipe that can add some HTML formatting using the line delimiting convention
    (`.`). For a quick verification, let''s update the first exercise steps in `workout-runner.component.ts`
    by adding a break (`<br>`) after each line:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤应该要么有一个换行符（`<br>`），要么以HTML `list`的格式进行格式化以便易于阅读。这似乎是一项直接的任务，我们可以直接改变绑定到步骤插值的数据，或者编写一个管道，使用行分隔约定（`。`）来添加一些HTML格式化。为了快速验证，让我们在`workout-runner.component.ts`中更新第一个练习的步骤，每一行后面都添加一个换行符（`<br>`）：
- en: '[PRE77]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'As the workout restarts, look at the first exercise steps. The output does
    not match our expectations, as shown here:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 当锻炼重新开始时，看看第一个练习步骤。输出不符合我们的预期，如下所示：
- en: '![](img/a2dce051-39a3-4779-93c1-3b5695ab0e55.png)'
  id: totrans-581
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a2dce051-39a3-4779-93c1-3b5695ab0e55.png)'
- en: The break tags were literally rendered in the browser. Angular did not render
    the interpolation as HTML; instead, it escaped the HTML characters, and we know
    why, security!
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 换行标记在浏览器中被直接呈现。Angular 没有将插值呈现为 HTML；相反，它转义了 HTML 字符，并且我们知道原因是安全问题！
- en: How to fix it? Easy! Replace the interpolation with the property binding to
    bind step data to the element's `innerHTML` property (in `exercise-description.html`),
    and you are done!
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 如何修复它？很简单！用属性绑定替换插值，将步骤数据绑定到元素的`innerHTML`属性（在`exercise-description.html`中），就完成了！
- en: '[PRE78]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Refresh the workout page to confirm.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新锻炼页面以确认。
- en: Preventing Cross-Site Scripting Security (XSS) issues
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 防止跨站脚本攻击（XSS）问题
- en: By using `innerHTML`, we instruct Angular to not escape HTML, but Angular still
    sanitizes the input HTML as described in the security section earlier. It removes
    things such as `<script>` tags and other JavaScript to safeguard against XSS attacks.
    If you want to dynamically inject styles/scripts into HTML, use the `DomSanitizer`
    to bypass this sanitization check.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`innerHTML`，我们指示 Angular 不要转义 HTML，但 Angular 仍然会像早先的安全部分所描述的那样对输入的 HTML
    进行清理。它会删除诸如`<script>`标签和其他 JavaScript 之类的内容，以防止 XSS 攻击。如果你想要动态地向 HTML 注入样式/脚本，请使用`DomSanitizer`来绕过这个清理检查。
- en: Time for another enhancement! It's time to learn about Angular pipes.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候再次进行增强了！现在是学习 Angular 管道的时候了。
- en: Displaying the remaining workout duration using pipes
  id: totrans-589
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用管道显示剩余的锻炼持续时间
- en: It will be nice if we can tell the user the time left to complete the workout
    and not just the duration of the exercise in progress. We can add a countdown
    timer somewhere in the exercise pane to show the overall time remaining.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们可以告诉用户完成锻炼所剩下的时间，并不仅仅是进行中的练习的持续时间，那将会很好。我们可以在练习窗格的某个位置添加一个倒计时计时器，以显示整体剩余的时间。
- en: The approach that we are going to take here is to define a component property
    called `workoutTimeRemaining`. This property will be initialized with the total
    time at the start of the workout and will reduce with every passing second until
    it reaches zero. Since `workoutTimeRemaining` is a numeric value, but we want
    to display a timer in the `hh:mm:ss` format, we need to make a conversion between
    the seconds data and the time format. **Angular pipes** are a great option for
    implementing such a feature.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要采取的方法是定义一个名为`workoutTimeRemaining`的组件属性。该属性将在锻炼开始时初始化为总时间，并随着每秒的流逝而减少，直到达到零。由于`workoutTimeRemaining`是一个数值，但我们想以`hh:mm:ss`的格式显示计时器，所以我们需要在秒数数据和时间格式之间进行转换。**Angular
    管道**是实现这种功能的一个很好的选择。
- en: Angular pipes
  id: totrans-592
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 管道
- en: The primary aim of a pipe is to format the data displayed in the view. **Pipes**
    allow us to package this content transformation logic (formatting) as a reusable
    element. The framework itself comes with multiple predefined pipes, such as `date`,
    `currency`, `lowercase`, `uppercase`, `slice`, and others.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 管道的主要目的是格式化视图中显示的数据。**管道**允许我们将内容转换逻辑（格式化）打包为可重用的元素。框架本身带有多个预定义的管道，例如`date`、`currency`、`lowercase`、`uppercase`、`slice`等。
- en: 'This is how we use a pipe with a view:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何在视图中使用管道：
- en: '[PRE79]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'An expression is followed by the pipe symbol (`|`), which is followed by the
    pipe name and then an optional parameter (`inputParam1`) separated by a colon
    (`:`). If the pipe takes multiple inputs, they can be placed one after another
    separated by a colon, such as the inbuilt `slice` pipe, which can slice an array
    or string:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式后面跟着管道符号（`|`），后面跟着管道名称，然后是一个可选参数（`inputParam1`），用冒号（`:`）分隔。如果管道有多个输入，它们可以一个接一个地以冒号分隔显示，如内置的`slice`管道，它可以对数组或字符串进行切片：
- en: '[PRE80]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The parameter passed to the pipe can be a constant or a component property,
    which implies we can use template expressions with pipe parameter. See the following
    example:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给管道的参数可以是一个常数或组件属性，这意味着我们可以使用带有管道参数的模板表达式。请看下面的例子：
- en: '[PRE81]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Here are some examples of the use of the `date` pipe, as described in the Angular
    `date` documentation. Assume that `dateObj` is initialized to *June 15,* 2015
    *21:43:11* and locale is *en-US*:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些使用`date`管道的例子，如 Angular `date`文档中描述的。假设`dateObj`初始化为*2015年6月15日* *21:43:11*，区域设置为*en-US*：
- en: '[PRE82]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Some of the most commonly used pipes are the following:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 一些最常用的管道如下：
- en: '**date**: As we just saw, the date filter is used to format the date in a specific
    manner. This filter supports quite a number of formats and is locale-aware too.
    To know about the other formats supported by the date pipe, check out the framework
    documentation at [http://bit.ly/ng2-date](http://bit.ly/ng2-date).'
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**date:** 正如我们刚刚看到的，日期过滤器用于以特定方式格式化日期。该过滤器支持许多格式，而且还具有地域设置。要了解日期管道支持的其他格式，请查看[http://bit.ly/ng2-date](http://bit.ly/ng2-date)上的框架文档。'
- en: '**uppercase** and **lowercase**: These two pipes, as the name suggests, change
    the case of the string input.'
  id: totrans-604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**uppercase**和**lowercase:** 正如名称所示，这两个管道改变字符串输入的大小写。'
- en: '**decimal** and **percent**: `decimal` and `percent` pipes are there to format
    decimal and percentage values based on the current browser locale.'
  id: totrans-605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**decimal**和**percent:** `decimal`和`percent`管道用于根据当前浏览器地域设置格式化十进制和百分比数值。'
- en: '**currency**: This is used to format numeric values as a currency based on
    the current browser locale:'
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**currency:** 这用于根据当前浏览器地域设置将数值格式化为货币：'
- en: '[PRE83]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '**json**: This is a handy pipe for debugging that can transform any input into
    a string using `JSON.stringify`. We made good use of it at the start of this chapter
    to render the `WorkoutPlan` object (see the Checkpoint 2.1 code).'
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**json:** 这是一个方便的调试管道，可以使用`JSON.stringify`将任何输入转换为字符串。我们在本章的开始部分很好地利用了它来呈现`WorkoutPlan`对象（请参阅Checkpoint
    2.1代码）。'
- en: '**slice:** This pipe allows us to split a list or a string value to create
    a smaller trimmed down list/string. We saw an example in the preceding code.'
  id: totrans-609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**slice:** 这个管道允许我们将列表或字符串值拆分，创建一个更小的修剪列表/字符串。我们在前面的代码中看到了一个例子。'
- en: We are not going to cover the preceding pipes in detail. From a development
    perspective, as long as we know what pipes are there and what they are useful
    for, we can always refer to the platform documentation for exact usage instructions.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细介绍前面的管道。从开发的角度来看，只要我们知道有哪些管道以及它们有什么用处，我们总是可以参考平台文档来获得准确的使用说明。
- en: Pipe chaining
  id: totrans-611
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管道链接
- en: 'A really powerful feature of pipes is that they can be chained, where the output
    from one pipe can serve as the input to another pipe. Consider this example:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 管道的一个非常强大的特性是它们可以被链接在一起，其中一个管道的输出可以作为另一个管道的输入。考虑这个例子：
- en: '[PRE84]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The first pipe slices the first 20 characters of `fullName` and the second pipe
    transforms them to uppercase.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个管道切割`fullName`的前20个字符，第二个管道将它们转换为大写。
- en: 'Now that we have seen what pipes are and how to use them, why not implement
    one for the *7 Minute Workout* app: a **seconds to time** pipe?'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了管道是什么以及如何使用它们，为什么不为*7 Minute Workout*应用程序实现一个**秒转时间**管道呢？
- en: Implementing a custom pipe - SecondsToTimePipe
  id: totrans-616
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现自定义管道 - SecondsToTimePipe
- en: '`SecondsToTimePipe`, as the name suggests, should convert a numeric value into
    the `hh:mm:ss` format.'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: '`SecondsToTimePipe`，顾名思义，应该将数值转换为`hh:mm:ss`格式。'
- en: 'Create a folder `shared` in the `workout-runner` folder and from the shared
    folder invoke this CLI command to generate the pipe boilerplate:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `workout-runner` 文件夹中创建一个名为`shared`的文件夹，并从shared文件夹中调用此CLI命令来生成管道样板：
- en: '[PRE85]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The `shared` folder has been created to add common components/directives/pipes
    that can be used in the `workout-runner` module. It is a convention we follow
    to organize shared code at different levels. In the future, we can create a shared
    folder at the app module level, which has artifacts shared globally. In fact,
    if the second to time pipe needs to be used across other application modules,
    it can also be moved into the app module.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '`shared`文件夹已被创建，用于添加可以在`workout-runner`模块中使用的常用组件/指令/管道。这是我们在不同层次组织共享代码时遵循的约定。将来，我们可以在应用程序模块级别创建一个共享文件夹，其中包含全局共享的工件。实际上，如果需要在其他应用程序模块中使用second
    to time管道，它也可以移动到应用程序模块中。'
- en: 'Copy the following `transform` function implementation into `seconds-to-time.pipe.ts`(the
    definition can also be downloaded from the Git branch `checkpoint.2.4` on the
    GitHub site at [http://bit.ly/nng6be-2-4-seconds-to-time-pipe-ts](http://bit.ly/nng6be-2-4-seconds-to-time-pipe-ts)):'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下`transform`函数实现复制到`seconds-to-time.pipe.ts`（也可以从Git分支`checkpoint.2.4`上的GitHub网站[http://bit.ly/nng6be-2-4-seconds-to-time-pipe-ts](http://bit.ly/nng6be-2-4-seconds-to-time-pipe-ts)下载该定义）：
- en: '[PRE86]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: In an Angular pipe, the implementation logic goes into the `transform` function.
    Defined as part of the `PipeTransform` interface, the preceding `transform` function
    transforms the input seconds value into an *hh:mm:ss* string. The first parameter
    to the `transform` function is the pipe input. The subsequent parameters, if provided,
    are the arguments to the pipe, passed using a colon separator (`pipe:argument1:arugment2..`)
    from the view.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 管道中，实现逻辑放在 `transform` 函数中。作为 `PipeTransform` 接口的一部分，前面的 `transform`
    函数将输入的秒值转换为 *hh:mm:ss* 字符串。`transform` 函数的第一个参数是管道输入。如果提供了后续参数，那么这些参数会作为管道的参数，使用冒号分隔符
    (`pipe:argument1:arugment2..`) 从视图中传递过来。
- en: For `SecondsToTimePipe`, while Angular CLI generates a boilerplate argument
    (`args?:any`), we do not make use of any pipe argument as the implementation does
    not require it.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `SecondsToTimePipe`，虽然 Angular CLI 生成了一个样板参数 (`args?:any`)，但我们没有使用任何管道参数，因为实现并不需要它。
- en: The pipe implementation is quite straightforward, as we convert seconds into
    hours, minutes, and seconds. Then, we concatenate the result into a string value
    and return the value. The addition of 0 on the left for each of the `hours`, `minutes`,
    and `seconds` variables is done to format the value with a leading 0 in case the
    calculated value for hours, minutes, or seconds is less than 10.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 管道实现非常直接，因为我们将秒转换为小时、分钟和秒。然后，我们将结果连接成一个字符串值并返回该值。对于 `hours`、`minutes` 和 `seconds`
    变量，左边添加 0 是为了在小时、分钟或秒的计算值小于 10 的情况下，格式化该值为具有前导 0 的值。
- en: 'The pipe that we just created is just a standard TypeScript class. It''s the
    Pipe decorator (`@Pipe`) that instructs Angular to treat this class as a pipe:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建的管道只是一个标准的 TypeScript 类。正是 Pipe 装饰器 (`@Pipe`) 指示 Angular 将这个类视为管道：
- en: '[PRE87]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The pipe definition is complete, but to use the pipe in `WorkoutRunnerComponent`
    the pipe has to be declared on `WorkoutRunnerModule.` Angular CLI has already
    done this for us as part of the boilerplate generation (see the `declaration`
    section in `workout-runner.module.ts`).
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 管道定义完成，但是在 `WorkoutRunnerComponent` 中使用管道，该管道必须在 `WorkoutRunnerModule` 中声明。Angular
    CLI 在生成时已经为我们做好了这一点（请参阅 `workout-runner.module.ts` 中的 `declaration` 部分）。
- en: 'Now we just need to add the pipe in the view. Update `workout-runner.component.html`
    by adding the highlighted fragment:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要在视图中添加管道。通过添加下面突出显示的片段来更新 `workout-runner.component.html`：
- en: '[PRE88]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Surprisingly, the implementation is still not complete! There is one more step
    left. We have a pipe definition, and we have referenced it in the view, but `workoutTimeRemaining`
    needs to update with each passing second for `SecondsToTimePipe` to be effective.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，实现还没有完成！还有一步。我们已经定义了一个管道，并在视图中引用了它，但是 `workoutTimeRemaining` 需要在每秒钟更新一次才能让
    `SecondsToTimePipe` 生效。
- en: 'We have already initialized `WorkoutRunnerComponent`''s `workoutTimeRemaining`
    property in the `start` function with the total workout time:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 `start` 函数中用总的锻炼时间初始化了 `WorkoutRunnerComponent` 的 `workoutTimeRemaining`
    属性：
- en: '[PRE89]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Now the question is: how to update the `workoutTimeRemaining` variable with
    each passing second? Remember that we already have a `setInterval` set up that
    updates `exerciseRunningDuration`. While we can write another `setInterval` implementation
    for `workoutTimeRemaining`, it will be better if a single `setInterval` setup
    can take care of both the requirements.'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是：如何在每秒钟更新 `workoutTimeRemaining` 变量？记住我们已经设置了一个 `setInterval` 来更新 `exerciseRunningDuration`。虽然我们可以为
    `workoutTimeRemaining` 编写另一个 `setInterval` 实现，但如果一个单独的 `setInterval` 设置可以满足两个要求会更好。
- en: 'Add a function called `startExerciseTimeTracking` to `WorkoutRunnerComponent`;
    it looks as follows:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `WorkoutRunnerComponent` 中添加一个名为 `startExerciseTimeTracking` 的函数；它看起来是这样的：
- en: '[PRE90]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: As you can see, the primary purpose of the function is to track the exercise
    progress and flip the exercise once it is complete. However, it also tracks `workoutTimeRemaining`
    (it decrements this counter). The first `if` condition setup just makes sure that
    we clear the timer once all the exercises are done. The inner `if` conditions
    are used to keep `currentExerciseIndex` in sync with the running exercise.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这个函数的主要目的是跟踪锻炼的进度，并在完成后切换锻炼。然而，它还跟踪 `workoutTimeRemaining`（它会递减这个计数器）。第一个
    `if` 条件设置只是确保当所有锻炼完成时清除计时器。内部的 `if` 条件用于保持 `currentExerciseIndex` 与正在进行的锻炼保持同步。
- en: This function uses a numeric instance variable called `exerciseTrackingInterval`.
    Add it to the class declaration section. We are going to use this variable later
    to implement an exercise pausing behavior.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数使用一个名为 `exerciseTrackingInterval` 的数值实例变量。将其添加到类声明部分。我们稍后将使用此变量来实现练习暂停行为。
- en: 'Remove the complete `setInterval` setup from `startExercise` and replace it
    with a call to `this.startExerciseTimeTracking();`. We are all set to test our
    implementation. If required, refresh the browser and verify the implementation:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `startExercise` 中删除完整的 `setInterval` 设置，并用调用 `this.startExerciseTimeTracking();`
    替换它。我们已经准备好测试我们的实现了。如果需要的话，刷新浏览器并验证实现：
- en: '![](img/bcfb02e4-245e-42b8-86a1-2dc661c1b3b8.png)'
  id: totrans-640
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bcfb02e4-245e-42b8-86a1-2dc661c1b3b8.png)'
- en: The next section is about another inbuilt Angular directive, `ngIf`, and another
    small enhancement.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节介绍了另一个内置的 Angular 指令 `ngIf`，以及另一个小的增强。
- en: Adding the next exercise indicator using ngIf
  id: totrans-642
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `ngIf` 添加下一个练习指示器
- en: It will be nice for the user to be told what the next exercise is during the
    short rest period between exercises. This will help them prepare for the next
    exercise. So let's add it.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 用户在短暂的休息时间内被告知下一个练习是什么会很好。这将帮助他们为下一个练习做好准备。所以让我们添加上去。
- en: To implement this feature, we can simply output the title of the next exercise
    from the `workoutPlan.exercises` array. We show the title next to the `Time Remaining`
    countdown section.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一功能，我们可以简单地从 `workoutPlan.exercises` 数组中输出下一个练习的标题。我们将标题显示在 `Time Remaining`
    倒计时部分旁边。
- en: 'Change the workout div (`class="exercise-pane"`) to include the highlighted
    content, and remove existing `Time Remaining` `h1`:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 更改练习 div（`class="exercise-pane"`）以包含突出显示的内容，并移除现有的 `Time Remaining` `h1`：
- en: '[PRE91]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'We wrap the existing `Time Remaining h1` and add another `h3` tag to show the
    next exercise inside a new `div` with some style updates. Also, there is a new
    directive, `ngIf`, in the second `h3`. The `*` prefix implies that it belongs
    to the same set of directives that `ngFor` belongs: **structural directives**.
    Let''s talk a bit about `ngIf`.'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包裹现有的 `Time Remaining h1`，并在一个新的 `div` 中添加另一个 `h3` 标签，在其中显示下一个练习，并进行一些样式更新。此外，第二个
    `h3` 中有一个新的指令 `ngIf`。`*` 前缀意味着它属于 `ngFor` 所属的同一组指令：**结构指令**。让我们稍微谈谈 `ngIf`。
- en: 'The `ngIf` directive is used to add or remove a specific section of the DOM
    based on whether the expression provided to it returns `true` or `false`. The
    DOM element is added when the expression evaluates to `true` and is destroyed
    otherwise. Isolate the `ngIf` declaration from the preceding view:'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngIf` 指令用于根据提供给它的表达式是否返回 `true` 或 `false` 来添加或移除 DOM 的特定部分。当表达式评估为 `true`
    时，DOM 元素被添加，否则被销毁。将 `ngIf` 声明与之前的视图隔离开来:'
- en: '[PRE92]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The directive expression checks whether we are currently in the rest phase and
    accordingly shows or hides the linked `h3`.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令表达式检查我们当前是否处于休息阶段，并相应地显示或隐藏链接的 `h3`。
- en: Also in the same `h3`, we have an interpolation that shows the name of the exercise
    from the `workoutPlan.exercises` array.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 同样在相同的 `h3` 中，我们有一个插值，显示来自 `workoutPlan.exercises` 数组的练习名称。
- en: 'A word of caution here: `ngIf` adds and destroys the DOM element, and hence
    it is not similar to the visibility constructs that we employed to show and hide
    elements. While the end result of `style`, `display:none` is the same as that
    of `ngIf`, the mechanism is entirely different:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要注意：`ngIf` 添加和销毁 DOM 元素，因此它不同于我们用来显示和隐藏元素的可见性构造。虽然 `style`、`display:none`
    的最终结果与 `ngIf` 相同，但机制完全不同：
- en: '[PRE93]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Versus this line:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 与这行相比：
- en: '[PRE94]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'With `ngIf`, whenever the expression changes from `false` to `true`, a complete
    re-initialization of the content occurs. Recursively, new elements/components
    are created and data binding is set up, starting from the parent down to the children.
    The reverse happens when the expression changes from `true` to `false`: all of
    this is destroyed. Therefore, using `ngIf` can sometimes become an expensive operation
    if it wraps a large chunk of content and the expression attached to it changes
    very often. But otherwise, wrapping a view in `ngIf` is more performant than using
    CSS/style-based show or hide, as neither the DOM is created nor the data binding
    expressions are set up when the `ngIf` expression evaluates to `false`.'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ngIf`，每当表达式从`false`变为`true`时，内容会完全重新初始化。从父级到子级递归创建新元素/组件，并设置数据绑定。当表达式从`true`变为`false`时，所有这些都会被销毁。因此，如果`ngIf`包裹了大量内容并且附加到它的表达式经常更改，使用`ngIf`有时可能会变得很昂贵。但是，将视图包裹在`ngIf`中比使用基于CSS/样式的显示或隐藏更高效，因为当`ngIf`表达式求值为`false`时，既不会创建DOM，也不会设置数据绑定表达式。
- en: 'New version of Angular support branching constructs too. This allows us to
    implement the **if then else** flow in the view HTML. The following sample has
    been lifted directly from the platform documentation of `ngIf`:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: Angular的新版本也支持分支结构。这样我们就可以在视图HTML中实现**if then else**流程。以下示例直接摘自`ngIf`的平台文档：
- en: '[PRE95]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The `else` binding points to a `ng-template` with template variable `#elseBlock`.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '`else`绑定到一个具有模板变量`#elseBlock`的`ng-template`。'
- en: 'There is another directive that belongs in this league: `ngSwitch`. When defined
    on the parent HTML, it can swap the child HTML elements based on the `ngSwitch`
    expression. Consider this example:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个指令属于这类：`ngSwitch`。当定义在父HTML中时，它可以根据`ngSwitch`表达式交换子HTML元素。考虑这个例子：
- en: '[PRE96]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: We bind the `userType` expression to `ngSwitch`. Based on the value of `userType`
    (`admin`, `powerUser`, or any other `userType`), one of the inner div elements
    will be rendered. The `ngSwitchDefault` directive is a wildcard match/fallback
    match, and it gets rendered when `userType` is neither `admin` nor `powerUser`.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`userType`表达式绑定到`ngSwitch`。根据`userType`的值（`admin`，`powerUser`，或任何其他`userType`），将呈现一个内部div元素。`ngSwitchDefault`指令是通配符匹配/默认匹配，当`userType`既不是`admin`也不是`powerUser`时，它就会被呈现。
- en: 'If you have not realized it yet, note that there are three directives working
    together here to achieve switch-case-like behavior:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有意识到，注意这里有三个指令协同工作，以实现类似switch-case的行为：
- en: '`ngSwitch`'
  id: totrans-664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngSwitch`'
- en: '`ngSwitchCase`'
  id: totrans-665
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngSwitchCase`'
- en: '`ngSwitchDefault`'
  id: totrans-666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngSwitchDefault`'
- en: 'Coming back to our next exercise implementation, we are ready to verify the
    implementation, start the app, and wait for the rest period. There should be a
    mention of the next exercise during the rest phase, as shown here:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的下一个锻炼实现，我们已经准备好验证实现，启动应用程序，并等待休息时间。在休息期间应该提到下一个锻炼，如下所示：
- en: '![](img/576ca7a4-2fc2-4d11-81d0-a37470c878a6.png)'
  id: totrans-668
  prefs: []
  type: TYPE_IMG
  zh: '![](img/576ca7a4-2fc2-4d11-81d0-a37470c878a6.png)'
- en: The app is shaping up well. If you have used the app and done some physical
    workouts along with it, you will be missing the exercise pause functionality badly.
    The workout just does not stop until it reaches the end. We need to fix this behavior.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序正在不断完善。如果你用过这个应用程序并进行了一些体育锻炼，你会非常想念暂停功能。锻炼直到结束才停止。我们需要修复这个行为。
- en: Pausing an exercise
  id: totrans-670
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暂停一项锻炼
- en: To pause an exercise, we need to stop the timer. We also need to add a button
    somewhere in the view that allows us to pause and resume the workout. We plan
    to do this by drawing a button overlay over the exercise area in the center of
    the page. When clicked on, it will toggle the exercise state between paused and
    running. We will also add keyboard support to pause and resume the workout using
    the key binding `p` or `P`. Let's update the component.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 要暂停一项锻炼，我们需要停止计时器。我们还需要在视图中的某个位置添加一个按钮，让我们可以暂停和恢复锻炼。我们计划通过在页面中心的锻炼区域上绘制一个按钮覆盖层来实现这一点。点击它将在暂停和运行之间切换锻炼状态。我们还将通过按键绑定`p`或`P`来添加键盘支持以暂停和恢复锻炼。让我们更新组件。
- en: 'Update the `WorkoutRunnerComponent` class, add these three functions, and add
    a declaration for the `workoutPaused` variable:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`WorkoutRunnerComponent`类，添加这三个函数，并声明`workoutPaused`变量：
- en: '[PRE97]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The implementation for pausing is simple. The first thing we do is cancel the
    existing `setInterval` setup by calling `clearInterval(this.exerciseTrackingInterval);`.
    While resuming, we again call `startExerciseTimeTracking`, which again starts
    tracking the time from where we left off.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 暂停的实现很简单。我们首先要做的是通过调用`clearInterval(this.exerciseTrackingInterval);`来取消现有的`setInterval`设置。恢复时，我们再次调用`startExerciseTimeTracking`，再次从我们离开的地方开始跟踪时间。
- en: 'Now we just need to invoke the `pauseResumeToggle` function for the view. Add
    the following content to `workout-runner.html`:'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要为视图调用`pauseResumeToggle`函数。在`workout-runner.html`中添加以下内容：
- en: '[PRE98]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: The `click` event handler on the div toggles the workout running state, and
    the `ngClass` directive is used to toggle the class between `ion-md-pause` and
    `ion-md-play`- standard Angular stuff. What is missing now is the ability to pause
    and resume on a *P* key press.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: '`div`上的`click`事件处理程序切换了训练运行状态，而`ngClass`指令用于在`ion-md-pause`和`ion-md-play`之间切换类-标准的Angular东西。现在缺少的是能够在按下*P*键时暂停和恢复。'
- en: 'One approach could be to apply a `keyup` event handler on the div:'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是在`div`上应用`keyup`事件处理程序：
- en: '[PRE99]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'But there are some shortcomings to this approach:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 但这种方法存在一些缺点：
- en: The `div` element does not have a concept of focus, so we also need to add the
    `tabIndex` attribute on the div to make it work
  id: totrans-681
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`div`元素没有焦点的概念，因此我们还需要在`div`上添加`tabIndex`属性才能使其工作'
- en: Even then, it works only when we have clicked on the div at least once
  id: totrans-682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使这样，它只有在我们至少点击一次`div`时才会起作用
- en: 'There is a better way to implement this; attach the event handler to the global
    `window` event `keyup`. This is how the event binding should be applied on the
    `div`:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种更好的实现方式；将事件处理程序附加到全局`window`事件`keyup`上。这就是应该在`div`上应用事件绑定的方式：
- en: '[PRE100]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Make note of the special `window:` prefix before the `keyup` event. We can
    use this syntax to attach events to any global object, such as the `document`.
    A handy and very powerful feature of Angular binding infrastructure! The `onKeyPressed`
    event handler needs to be added to `WorkoutRunnerComponent`. Add this function
    to the class:'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在`keyup`事件之前的特殊`window:`前缀。我们可以使用这种语法来将事件附加到任何全局对象，比如`document`。这是Angular绑定基础设施的一个方便而非常强大的功能！`onKeyPressed`事件处理程序需要添加到`WorkoutRunnerComponent`。将这个函数添加到类中：
- en: '[PRE101]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'The `$event` object is the standard **DOM event object** that Angular makes
    available for manipulation. Since this is a keyboard event, the specialized class
    is `KeyboardEvent`. The `which` property is matched to ASCII values of `p` or
    `P`. Refresh the page and you should see the play/pause icon when your mouse hovers
    over the exercise image, as follows:'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: '`$event`对象是Angular可供操作的标准**DOM事件对象**。由于这是一个键盘事件，特殊的类是`KeyboardEvent`。`which`属性与`p`或`P`的ASCII值相匹配。刷新页面，当鼠标悬停在训练图像上时，您应该看到播放/暂停图标，如下所示：'
- en: '![](img/e98c6d82-9004-466e-8788-93534ad69cdf.png)'
  id: totrans-688
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e98c6d82-9004-466e-8788-93534ad69cdf.png)'
- en: While we are on the topic of **event binding**, it would be a good opportunity
    to explore Angular's event binding infrastructure
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论**事件绑定**时，这将是探索Angular事件绑定基础设施的好机会
- en: The Angular event binding infrastructure
  id: totrans-690
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular事件绑定基础设施
- en: Angular event binding allows a component to communicate with its parent through
    events.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: Angular事件绑定允许组件通过事件与其父组件进行通信。
- en: If we look back at the app implementation, what we have encountered thus far
    are the property/attribute bindings. Such bindings allow a component/element to
    take inputs from the outside world. The data flows into the component.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 如果回顾应用实现，到目前为止我们遇到的是属性/属性绑定。这种绑定允许组件/元素从外部世界获取输入。数据流入组件。
- en: Event bindings are the reverse of property bindings. They allow a component/element
    to inform the outside world about any state change.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 事件绑定是属性绑定的反向。它允许组件/元素通知外部世界有关任何状态变化。
- en: 'As we saw in the pause/resume implementation, event binding employs round brackets
    (`()`) to specify the target event:'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在暂停/恢复实现中看到的，事件绑定使用圆括号（`()`）来指定目标事件：
- en: '[PRE102]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: This attaches a `click` event handler to the `div` that invokes the expression
    `pauseResumeToggle()` when the `div` is clicked.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 这将`pauseResumeToggle()`表达式绑定到`div`上，当点击`div`时调用该表达式。
- en: 'Like properties, there is a canonical form for events too. Instead of using
    round brackets, the `on-` prefix can be used: `on-click="pauseResumeToggle()"`'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 像属性一样，事件也有一个规范形式。可以使用`on-`前缀，而不是使用圆括号：`on-click="pauseResumeToggle()"`
- en: 'Angular supports all types of events. Events related to keyboard inputs, mouse
    movements, button clicks, and touches. The framework even allows us to define
    our own event for the components we create, such as:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: Angular支持所有类型的事件。与键盘输入、鼠标移动、按钮点击和触摸有关的事件。该框架甚至允许我们为自己创建的组件定义自定义事件，比如：
- en: '[PRE103]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: It is expected that events have side effects; in other words, an event handler
    may change the state of the component, which in turn may trigger a chain reaction
    in which multiple components react to the state change and change their own state.
    This is unlike a property binding expression, which should be side-effect-free.
    Even in our implementation, clicking on the `div` element toggles the exercise
    run state.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 期望事件会产生副作用；换句话说，事件处理程序可能会改变组件的状态，进而可能触发一个连锁反应，导致多个组件对状态变化做出反应并改变它们自己的状态。这与属性绑定表达式不同，后者应该是无副作用的。即使在我们的实现中，点击`div`元素也会切换练习运行状态。
- en: Event bubbling
  id: totrans-701
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件冒泡
- en: 'When Angular attaches event handlers to standard HTML element events, the event
    propagation works in the same way as standard DOM event propagation works. This
    is also called **event bubbling**. Events on child elements are propagated upwards,
    and hence event binding is also possible on a parent element, as follows:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 当Angular将事件处理程序附加到标准HTML元素事件时，事件传播工作方式与标准DOM事件传播方式相同。这也称为**事件冒泡**。子元素上的事件向上传播，因此也可以在父元素上进行事件绑定，方式如下：
- en: '[PRE104]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Clicking on either of the divs results in the invocation of the `doWork` function
    on the parent `div`. Moreover, `$event.target` contains the reference to the `div`
    that dispatched the event.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 点击任一`div`都会调用父`div`上的`doWork`函数。此外，`$event.target`包含了派发事件的`div`的引用。
- en: Custom events created on Angular components do not support event bubbling.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular组件上创建的自定义事件不支持事件冒泡。
- en: 'Event bubbling stops if the expression assigned to the target evaluates to
    a `falsey` value (such as `void`, `false`). Therefore, to continue propagation,
    the expression should evaluate to `true`:'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标分配的表达式计算结果为`falsey`值（如`void`，`false`），那么事件冒泡会停止。因此，为了继续传播，表达式应该计算结果为`true`：
- en: '[PRE105]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Here too, the `$event` object deserves some special attention.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`$event`对象也值得特别关注。
- en: Event binding an $event object
  id: totrans-709
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定$event对象
- en: Angular makes an `$event` object available whenever the target event is triggered.
    This `$event` contains the details of the event that occurred.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: Angular在目标事件触发时提供了一个`$event`对象。这个`$event`包含了发生的事件的细节。
- en: The important thing to note here is that the shape of the `$event` object is
    decided based on the event type. For HTML elements, it is a DOM event object ([https://developer.mozilla.org/en-US/docs/Web/Events](https://developer.mozilla.org/en-US/docs/Web/Events)),
    which may vary based on the actual event.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的重要事情是，`$event`对象的形状是根据事件类型确定的。对于HTML元素，它是一个DOM事件对象（[https://developer.mozilla.org/en-US/docs/Web/Events](https://developer.mozilla.org/en-US/docs/Web/Events)），根据实际事件可能有所不同。
- en: But if it is a custom component event, what is passed in the `$event` object
    is decided by the component implementation.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果是自定义组件事件，传递给`$event`对象的内容由组件实现决定。
- en: We have now covered most of the data binding capabilities of Angular, with the
    exception of two-way binding. A quick introduction to the two-way binding constructs
    is warranted before we conclude the chapter.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经介绍了Angular的大多数数据绑定功能，只剩下双向绑定。在我们结束本章之前，有必要快速介绍一下双向绑定构造。
- en: Two-way binding with ngModel
  id: totrans-714
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ngModel进行双向绑定
- en: '**Two-way binding** helps us keep the model and view in sync. Changes to the
    model update the view and changes to the view update the model. The obvious area
    where two-way binding is applicable is form input. Let''s look at a simple example:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: '**双向绑定**帮助我们保持模型和视图同步。对模型的更改会更新视图，对视图的更改也会更新模型。双向绑定适用的明显领域是表单输入。让我们看一个简单的例子：'
- en: '[PRE106]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: The `ngModel` directive here sets a two-way binding between the `input`'s `value`
    property and the `workout.name` property on the underlying component. Anything
    that the user enters in the preceding  `input` is synced with `workout.name`,
    and any changes to `workout.name` are reflected back on the preceding `input`.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`ngModel`指令在`input`的`value`属性和底层组件的`workout.name`属性之间建立了双向绑定。用户在`input`中输入的任何内容都会与`workout.name`同步，`workout.name`的任何更改也会反映到前面的`input`上。
- en: 'Interestingly, we can achieve the same result without using the `ngModel` directive
    too, by combining both property and event binding syntax. Consider the next example;
    it works in the same way as `input` before:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，我们甚至可以在不使用`ngModel`指令的情况下，通过结合属性和事件绑定语法来实现相同的效果。考虑下一个例子；它的工作方式与之前的`input`一样：
- en: '[PRE107]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: There is a property binding set up on the `value` property and an event binding
    set up on the `input` event that make the bidirectional sync work.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 在`value`属性上设置了一个属性绑定，并在`input`事件上设置了一个事件绑定，使双向同步工作。
- en: We will get into more details on two-way binding in [Chapter 2](4b0ad450-2a56-4c24-b431-116d7225a57e.xhtml),* Personal
    Trainer*, where we build our own custom workouts.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第二章](4b0ad450-2a56-4c24-b431-116d7225a57e.xhtml)，*个人教练*，中更详细地介绍双向绑定，我们将在那里构建自定义的锻炼。
- en: 'We have created a diagram that summarizes the data flow patterns for all the
    bindings that we have discussed thus far. Here is a handy diagram to help you
    memorize each of the binding constructs and how data flows:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个总结到目前为止所有绑定的数据流模式的图表。这是一个方便的图表，可以帮助您记忆每个绑定构造以及数据流动的方式：
- en: '![](img/15166818-fb41-410a-8e11-a6843f5217a1.png)'
  id: totrans-723
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/15166818-fb41-410a-8e11-a6843f5217a1.png)'
- en: We now have a fully functional *7 Minute Workout*, with some bells and whistles
    too, and hopefully you had fun creating the app. It's time to conclude the chapter
    and summarize the lessons.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个功能齐全的*7分钟锻炼*，而且还有一些附加功能，希望您在创建应用程序时玩得开心。是时候来总结本章的教训了。
- en: If you are having a problem with running the code, look at the Git branch `checkpoint2.4`
    for a working version of what we have done thus far. You can also download a snapshot
    of `checkpoint2.4` (a ZIP file) from this GitHub location: [http://bit.ly/ng6be-checkpoint-2-4](http://bit.ly/ng6be-checkpoint-2-4).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在运行代码时遇到问题，请查看`checkpoint2.4`Git分支，以获取到目前为止我们所做的工作的可用版本。您也可以在这个GitHub位置下载`checkpoint2.4`的快照（一个ZIP文件）：[http://bit.ly/ng6be-checkpoint-2-4](http://bit.ly/ng6be-checkpoint-2-4)。首次设置快照时，请参阅`trainer`文件夹中的`README.md`文件。
- en: Cross-component communication using Angular events
  id: totrans-726
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Angular事件进行跨组件通信
- en: It's time now to look at eventing in more depth. Let's add audio support to *7-Minute
    Workout*.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候更深入地了解事件了。让我们为*7分钟锻炼*添加音频支持。
- en: Tracking exercise progress with audio
  id: totrans-728
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用音频跟踪锻炼进度
- en: For the *7-Minute Workout* app, adding sound support is vital. One cannot exercise
    while constantly staring at the screen. Audio clues help the user perform the
    workout effectively as they can just follow the audio instructions.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*7分钟锻炼*应用程序来说，添加声音支持是至关重要的。一个人不可能一直盯着屏幕运动。音频提示帮助用户有效地完成锻炼，他们可以只需跟随音频指示即可。
- en: 'Here is how we are going to support exercise tracking using audio clues:'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何利用音频提示来支持锻炼追踪：
- en: A ticking clock soundtrack progress during the exercise
  id: totrans-731
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在练习期间，会有一个滴答声的时钟声音
- en: A half-way indicator sounds, indicating that the exercise is halfway through
  id: totrans-732
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一半的指示器声音会响起，表示练习已经进行了一半
- en: An exercise-completion audio clip plays when the exercise is about to end
  id: totrans-733
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当练习即将结束时，会播放一个练习完成的音频剪辑
- en: An audio clip plays during the rest phase and informs users about the next exercise
  id: totrans-734
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在休息阶段，会播放一个音频剪辑，并通知用户接下来的练习是什么
- en: There will be an audio clip for each of these scenarios.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 每种情况下都会有一个音频剪辑。
- en: Modern browsers have good support for audio. The HTML5 `<audio>` tag provides
    a mechanism to embed audio clips into HTML content. We too will use the `<audio>` tag
    to play back our clips.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 现代浏览器对音频有很好的支持。HTML5的`<audio>`标签提供了将音频剪辑嵌入HTML内容中的机制。我们也将使用`<audio>`标签来播放我们的剪辑。
- en: Since the plan is to use the HTML `<audio>` element, we need to create a wrapper
    directive that allows us to control audio elements from Angular. Remember that
    directives are HTML extensions without a view.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 由于计划使用HTML的`<audio>`元素，我们需要创建一个包装指令，允许我们从Angular中控制音频元素。请记住，指令是没有视图的HTML扩展。
- en: The `checkpoint3.4` Git and the `trainer/static/audio` folder contain all the
    audio files used for playback; copy them first. If you are not using Git, a snapshot
    of the chapter code is available at [http://bit.ly/ng6be-checkpoint-3-4](http://bit.ly/ng6be-checkpoint-3-4).
    Download and unzip the contents and copy the audio files.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkpoint3.4` Git和`trainer/static/audio`文件夹包含了所有用于播放的音频文件；首先复制它们。如果您不使用Git，可以在[http://bit.ly/ng6be-checkpoint-3-4](http://bit.ly/ng6be-checkpoint-3-4)下载并解压章节代码的快照。下载并复制音频文件。'
- en: Building Angular directives to wrap HTML audio
  id: totrans-739
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 Angular 指令封装 HTML 音频
- en: If you have worked a lot with JavaScript and jQuery, you may have realized we have
    purposefully shied away from directly accessing the DOM for any of our component
    implementations. There has not been a need to do it. The Angular data-binding
    infrastructure, including property, attribute, and event binding, has helped us
    manipulate HTML without touching the DOM.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在使用 JavaScript 和 jQuery 时工作得很多，你可能会意识到，我们故意避免直接访问 DOM 来实现任何组件。其实我们并没有必要这样做。Angular
    中的数据绑定基础设施，包括属性、属性和事件绑定，帮助我们在不触碰 DOM 的情况下操作 HTML。
- en: For the audio element too, the access pattern should be Angularish. In Angular,
    the only place where direct DOM manipulation is acceptable and practiced is inside
    directives. Let's create a directive that wraps access to audio elements.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 对于音频元素，访问模式也应该符合 Angular 规范。在 Angular 中，唯一可以接受和实践直接 DOM 操作的地方就是指令内部。让我们创建一个指令来封装对音频元素的访问。
- en: 'Navigate to `trainer/src/app/shared` and run this command to generate a template
    directive:'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 转到 `trainer/src/app/shared` 并运行以下命令生成一个模板指令：
- en: '[PRE108]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Since it is the first time we are creating a directive, we encourage you to
    look at the generated code.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是我们第一次创建指令，我们鼓励你查看生成的代码。
- en: 'Since the directive is added to the shared module, it needs to be exported
    too. Add the `MyAudioDirective` reference in the `exports` array too (`shared.module.ts`).
    Then update the directive definition with the following code:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 由于指令被添加到了共享模块中，它也需要被导出。在 `exports` 数组中添加 `MyAudioDirective` 的引用（`shared.module.ts`）。然后更新指令定义与以下代码：
- en: '[PRE109]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: The `MyAudioDirective` class is decorated with `@Directive`. The `@Directive` decorator
    is similar to the `@Component` decorator except we cannot have an attached view.
    Therefore, no `template` or `templateUrl` is allowed!
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 类 `MyAudioDirective` 被装饰为 `@Directive`。 `@Directive` 装饰器类似于 `@Component` 装饰器，除了我们不能附加视图。因此，不允许使用 `template` 或 `templateUrl`！
- en: The preceding `selector` property allows the framework to identify where to
    apply the directive. We have replaced the generated `[abeMyAudioDirective]` attribute
    selector with just `audio`. Using `audio` as the selector makes our directive
    load for every `<audio>` tag used in HTML. The new selector works as an element
    selector.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `selector` 属性使框架能够识别要应用指令的位置。我们用 `audio` 替换了生成的 `[abeMyAudioDirective]` 属性选择器，使得我们的指令在
    HTML 中的每个 `<audio>` 标签上加载。新的选择器作为元素选择器。
- en: In a standard scenario, directive selectors are attribute-based (such as `[abeMyAudioDirective]` for
    the generated code), which helps us identify where the directive has been applied.
    We deviate from this norm and use an element selector for the `MyAudioDirective` directive.
    We want this directive to be loaded for every audio element, and it becomes cumbersome
    to go to each audio declaration and add a directive-specific attribute. Hence
    an element selector.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准场景中，指令选择器是基于属性的（例如生成的代码为 `[abeMyAudioDirective]`），这有助于我们识别指令被应用在哪里。我们偏离了这个规范，使用了元素选择器来创建 `MyAudioDirective` 指令。我们希望这个指令能够加载到每个音频元素上，并且不用为每个音频声明单独添加指令特定的属性。因此选择了元素选择器。
- en: The use of `exportAs` becomes clear when we use this directive in view templates.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图模板中使用这个指令时， `exportAs` 的使用变得清晰了。
- en: The `ElementRef` object injected in the constructor is the Angular element (`audio` in
    this case) for which the directive is loaded. Angular creates the `ElementRef` instance
    for every component and directive when it compiles and executes the HTML template.
    When requested in the constructor, the DI framework locates the corresponding `ElementRef` and
    injects it. We use `ElementRef` to get hold of the underlying audio element in
    the code (the instance of `HTMLAudioElement`). The `audioPlayer` property holds
    this reference.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数中注入的 `ElementRef` 对象是 Angular 元素（在这种情况下是 `audio`）的实例，加载了该指令。当 Angular 编译和执行
    HTML 模板时，为每个组件和指令创建 `ElementRef` 实例。在构造函数中请求时，DI 框架定位到对应的 `ElementRef` 并注入。我们使用 `ElementRef` 来在代码中获取底层的音频元素（`HTMLAudioElement` 的实例）。 `audioPlayer` 属性保存了这个引用。
- en: 'The directive now needs to expose an API to manipulate the audio player. Add
    these functions to the `MyAudioDirective` directive:'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 现在指令需要暴露一个 API 以便操作音频播放器。添加以下函数到 `MyAudioDirective` 指令中：
- en: '[PRE110]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The `MyAudioDirective` API has two functions (`start` and `stop`) and three
    getters (`currentTime`, `duration`, and a Boolean property called `playbackComplete`).
    The implementations for these functions and properties just wrap the audio element
    functions.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyAudioDirective`API有两个函数（`start`和`stop`）和三个getter（`currentTime`、`duration`，以及一个名为`playbackComplete`的布尔属性）。这些函数和属性的实现只是对音频元素函数进行了封装。'
- en: Learn about these audio functions from the MDN documentation here: [http://bit.ly/html-media-element](http://bit.ly/html-media-element).
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 从MDN文档中了解这些音频功能：[http://bit.ly/html-media-element](http://bit.ly/html-media-element)。
- en: To understand how we use the audio directive, let's create a new component that
    manages audio playback.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解我们如何使用音频指令，让我们创建一个新的组件来管理音频播放。
- en: Creating WorkoutAudioComponent for audio support
  id: totrans-757
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为音频支持创建WorkoutAudioComponent
- en: If we go back and look at the audio cues that are required, there are four distinct
    audio cues, and hence we are going to create a component with five embedded `<audio>` tags
    (two audio tags work together for next-up audio).
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回过头来看所需的音频提示，我们需要四个不同的音频提示，因此我们将创建一个包含五个嵌入式`<audio>`标签的组件（两个音频标签一起工作来产生下一个音频提示）。
- en: From the command line go to the `trainer/src/app/workout-runner` folder and
    add a new `WorkoutAudioComponent` component using Angular CLI.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行转到`trainer/src/app/workout-runner`文件夹，并使用Angular CLI添加一个新的`WorkoutAudioComponent`组件。
- en: 'Open `workout-audio.component.html` and replace the existing view template
    with this HTML snippet:'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`workout-audio.component.html`并用这段HTML代码替换现有视图模板：
- en: '[PRE111]'
  id: totrans-761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'There are five `<audio>` tags, one for each of the following:'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 有五个`<audio>`标签，每个用于以下内容：
- en: '**Ticking audio**: The first audio tag produces the ticking sound and is started as
    soon as the workout starts.'
  id: totrans-763
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ticking audio**: 第一个音频标签产生滴答声，并在练习开始时启动。'
- en: '**Next up audio and exercise audio**: There next two audio tags work together.
    The first tag produces the "Next up" sound. And the actual exercise audio is handled
    by the third tag (in the preceding code snippet).'
  id: totrans-764
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Next up audio and exercise audio**: 接下来的两个音频标签一起工作。第一个标签发出"下一个"声音。实际的练习音频由第三个标签处理（在前面的代码片段中）。'
- en: '**Halfway audio**: The fourth audio tag plays halfway through the exercise.'
  id: totrans-765
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Halfway audio**: 第四个音频标签在练习进行到一半时播放。'
- en: '**About to complete audio**: The final audio tag plays a piece to denote the
    completion of an exercise.'
  id: totrans-766
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**About to complete audio**: 最后一个音频标签播放一段音乐来表示练习的完成。'
- en: Did you notice the usage of the `#` symbol in each of the `audio` tags? There
    are some variable assignments prefixed with `#`. In the Angular world, these variables are
    known as **template reference variables** or at times **template variables**.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到每个`audio`标签中都使用了`#`符号了吗？在Angular世界中，这些带有`#`前缀的变量被称为**模板引用变量**或者有时候叫做**模板变量**。
- en: 'As the platform guide defines:'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 正如平台指南定义的那样：
- en: A template reference variable is often a reference to a DOM element or directive
    within a template.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 模板引用变量通常是模板中的一个DOM元素或指令的引用。
- en: Don't confuse them with the template input variables that we have used with
    the `ngFor` directive earlier, `*ngFor="let` video `of videos"`. The **template
    input variable's** (`video` in this case) scope is within the HTML fragment it
    is declared, whereas the template reference variable can be accessed across the
    entire template.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将它们与我们之前使用`ngFor`指令时使用的模板输入变量混淆，例如`*ngFor="let video of videos"`。**模板输入变量**（在这种情况下是`video`）的作用域仅限于它被声明的HTML片段内，而模板引用变量可以在整个模板中访问。
- en: 'Look at the last section where `MyAudioDirective` was defined. The `exportAs` metadata
    is set to `MyAudio`. We repeat that same `MyAudio` string while assigning the `template
    reference variable` for each audio tag:'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 看看最后一节，`MyAudioDirective`被定义了。`exportAs`元数据被设置为`MyAudio`。在为每个音频标签分配`模板引用变量`时我们重复了相同的`MyAudio`字符串：
- en: '[PRE112]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: The role of `exportAs` is to define the name that can be used in the view to
    assign this directive to a variable. Remember, a single element/component can
    have multiple directives applied to it. `exportAs` allows us to select which directive
    should be assigned to a template-reference variable based on what is on the right
    side of equals.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: '`exportAs`的作用是定义可以在视图中用来分配这个指令的变量的名称。记住，单个元素/组件可以应用多个指令。`exportAs`允许我们基于等号右侧的内容选择应该分配给模板引用变量的哪个指令。'
- en: Typically, template variables, once declared, give access to the view element/component
    they are attached to, to other parts of the view, something we will discuss shortly.
    But in our case, we will use template variables to refer to the multiple `MyAudioDirective` from
    the parent component's code. Let's understand how to use them.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 通常,一旦声明了模板变量,就可以访问它们所附加的视图元素/组件,并将其用于视图的其他部分,这是我们将很快讨论的。但在我们的例子中,我们将使用模板变量来引用来自父组件代码的多个`MyAudioDirective`。让我们了解如何使用它们。
- en: 'Update the generated `workout-audio.compnent.ts` with the following outline:'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: '使用以下大纲更新生成的`workout-audio.compnent.ts`:'
- en: '[PRE113]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: The interesting bit in this outline is the `@ViewChild` decorator against the
    five properties. The `@ViewChild` decorator allows us to inject a child component/directive/element
    reference into its parent. The parameter passed to the decorator is the template
    variable name, which helps DI match the element/directive to inject. When Angular
    instantiates the main `WorkoutAudioComponent`, it injects the corresponding audio
    directives based on the `@ViewChild` decorator and the template reference variable
    name passed. Let's complete the basic class implementation before we look at `@ViewChild` in
    detail.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 这个大纲中有趣的是五个属性上带有`@ViewChild`装饰器。`@ViewChild`装饰器允许我们将子组件/指令/元素引用注入到父组件中。传递给装饰器的参数是模板变量名,这有助于DI匹配要注入的元素/指令。当Angular实例化主`WorkoutAudioComponent`时,它会根据`@ViewChild`装饰器和传递的模板引用变量名注入相应的音频指令。在我们详细了解`@ViewChild`之前,让我们先完成基本类的实现。
- en: Without `exportAs` set on the `MyAudioDirective` directive, the `@ViewChild` injection
    injects the related `ElementRef` instance instead of the `MyAudioDirective` instance.
    We can confirm this by removing the `exportAs` attribute from `myAudioDirective` and
    then looking at the injected dependencies in `WorkoutAudioComponent`.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有在`MyAudioDirective`指令上设置`exportAs`,则`@ViewChild`注入会注入相关的`ElementRef`实例,而不是`MyAudioDirective`实例。我们可以通过从`myAudioDirective`中删除`exportAs`属性,然后查看`WorkoutAudioComponent`中注入的依赖项来确认这一点。
- en: 'The remaining task is to just play the correct audio component at the right
    time. Add these functions to `WorkoutAudioComponent`:'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: '剩下的任务就是在正确的时间播放正确的音频组件。将这些函数添加到`WorkoutAudioComponent`:'
- en: '[PRE114]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Having trouble writing these functions? They are available in the `checkpoint3.3` Git
    branch.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 写这些函数有困难吗?它们可以在`checkpoint3.3`Git分支中找到。
- en: 'There are two new model classes used in the preceding code. Add their declarations
    to `model.ts`, as follows (again available in `checkpoint3.3`):'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: '前面代码中使用了两个新的模型类。将它们的声明添加到`model.ts`中,如下所示(也可在`checkpoint3.3`中找到):'
- en: '[PRE115]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: These are model classes to track progress events. The `WorkoutAudioComponent` implementation
    consumes this data. Remember to import the reference for `ExerciseProgressEvent` and `ExerciseProgressEvent` in `workout-audio.component.ts`.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是用于跟踪进度事件的模型类。`WorkoutAudioComponent`实现使用这些数据。请记得在`workout-audio.component.ts`中导入`ExerciseProgressEvent`和`ExerciseProgressEvent`的引用。
- en: To reiterate, the audio component consumes the events by defining two event
    handlers: `onExerciseProgress` and `onExerciseChanged.` How the events are generated
    becomes clear as we move along.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 重申一下,音频组件通过定义两个事件处理程序`onExerciseProgress`和`onExerciseChanged`来使用事件。事件是如何生成的将随着我们的深入而变得更加清晰。
- en: The `start` and `resume` functions stop and resume audio whenever a workout
    starts, pauses, or completes. The extra complexity in the resume function it to
    tackle cases when the workout was paused during next up, about to complete, or
    half-way audio playback. We just want to continue from where we left off.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: '`start`和`resume`函数在workout开始、暂停或完成时停止和恢复音频播放。`resume`函数中的额外复杂性是为了处理workout在下一个、即将完成或中途暂停的情况。我们只想从之前停止的地方继续。'
- en: The `onExerciseProgress` function should be called to report the workout progress.
    It's used to play the halfway audio and about-to-complete audio based on the state
    of the workout. The parameter passed to it is an object that contains exercise
    progress data.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 应该调用`onExerciseProgress`函数来报告workout的进度。它用于根据workout的状态播放halfway音频和about-to-complete音频。传递给它的参数是一个包含exercise进度数据的对象。
- en: The `onExerciseChanged` function should be called when the exercise changes.
    The input parameter contains the current and next exercise in line and helps `WorkoutAudioComponent` to
    decide when to play the next up exercise audio.
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 当exercise改变时应该调用`onExerciseChanged`函数。输入参数包含当前和下一个exercise,帮助`WorkoutAudioComponent`决定何时播放下一个exercise的音频。
- en: 'We touched upon two new concepts in this section: template reference variables
    and injecting child elements/directives into the parent. It''s worth exploring
    these two concepts in more detail before we continue with the implementation.
    We''ll start with learning more about template reference variables.'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中我们提到了两个新概念：模板引用变量和将子元素/指令注入到父元素中。在继续实现之前，值得更详细地探讨这两个概念。我们将首先学习更多关于模板引用变量的知识。
- en: Understanding template reference variables
  id: totrans-790
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解模板引用变量
- en: '**Template reference variables** are created on the view template and are mostly
    consumed from the view. As you have already learned, these variables can be identified
    by the `#` prefix used to declare them.'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: '**模板引用变量**在视图模板上创建，并且大多数情况下从视图中使用。正如你已经学到的，这些变量可以通过`#`前缀声明来识别。'
- en: 'One of the greatest benefits of template variables is that they facilitate
    cross-component communication at the view template level. Once declared, such
    variables can be referenced by sibling elements/components and their children.
    Check out the following snippet:'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 模板变量最大的好处之一是它们便于在视图模板层面进行跨组件通信。一旦声明了这样的变量，它们就可以被同级元素/组件及其子元素引用。请查看以下代码片段：
- en: '[PRE116]'
  id: totrans-793
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: This snippet declares a template variable, `emailId`, and then references it
    in the interpolation and the button `click` expression.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段声明了一个模板变量`emailId`，然后在插值和按钮`click`表达式中引用它。
- en: The Angular templating engine assigns the DOM object for `input` (an instance
    of `HTMLInputElement`) to the `emailId` variable. Since the variable is available
    across siblings, we use it in a button's `click` expression.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: Angular模板引擎将`input`（`HTMLInputElement`的一个实例）的DOM对象分配给`emailId`变量。由于该变量在同级元素中可用，我们在按钮的`click`表达式中使用它。
- en: 'Template variables work with components too. We can easily do this:'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 模板变量也适用于组件。我们可以轻松地做到：
- en: '[PRE117]'
  id: totrans-797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: In this case, `runner` has a reference to the `WorkoutRunnerComponent` object,
    and the button is used to start the workout.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`runner`引用了`WorkoutRunnerComponent`对象，并且按钮用于启动锻炼。
- en: The `ref-` prefix is the canonical alternative to `#`. The `#runner` variable
    can also be declared as `ref-runner`.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: '`ref-`前缀是`#`的规范替代品。`#runner`变量也可以声明为`ref-runner`。'
- en: Template variable assignment
  id: totrans-800
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板变量赋值
- en: 'You may not have noticed but there is something interesting about the template variable
    assignments described in the last few sections. To recap, the three examples that
    we have used are:'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能没有注意到，但在最近几节介绍的模板变量赋值中有一些有趣的事情。简而言之，我们使用了三个示例：
- en: '[PRE118]'
  id: totrans-802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'What got assigned to the variable depends on where the variable was declared.
    This is governed by rules in Angular:'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 变量分配的内容取决于变量声明的位置。这受Angular规则的约束：
- en: If a directive is present on the element, such as `MyAudioDirective` in the
    first example shown previously, the directive sets the value. The `MyAudioDirective` directive
    sets the `ticks` variable to an instance of `MyAudioDirective`.
  id: totrans-804
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果指令存在于元素上，例如前面显示的第一个示例中的`MyAudioDirective`，则指令设置该值。`MyAudioDirective`指令将`ticks`变量设置为`MyAudioDirective`的一个实例。
- en: If there is no directive present, either the underlying HTML DOM element is
    assigned or a component object is assigned (as shown in the `input` and `workout-runner` examples).
  id: totrans-805
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有指令存在，变量分别分配给了底层HTML DOM元素或组件对象（如`input`和`workout-runner`示例中所示）。
- en: We will be employing this technique to implement the workout audio component
    integration with the workout runner component. This introduction gives us the
    head start that we need.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采用这种技术来实现训练音频组件与训练运行组件的集成。这个介绍给了我们需要的头部起步。
- en: The other new concept that we promised to cover is child element/directive injection
    using the `ViewChild` and `ViewChildren` decorators.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 我们答应要介绍的另一个新概念是使用`ViewChild`和`ViewChildren`装饰器进行子元素/指令注入。
- en: Using the @ViewChild decorator
  id: totrans-808
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用@ViewChild装饰器
- en: The `@ViewChild` decorator instructs the Angular DI framework to search for
    some specific child component/directive/element in the component tree and inject
    it into the parent. This allows the parent component to interact with child components/element
    using the reference to the child, a new communication pattern!
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ViewChild`装饰器指示Angular DI框架在组件树中搜索特定的子组件/指令/元素，并将其注入到父组件中。这允许父组件使用对子组件的引用来与子组件/元素进行交互，这是一种新的通信模式！'
- en: In the preceding code, the audio element directive (the `MyAudioDirective` class)
    is injected into the `WorkoutAudioComponent` code.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，音频元素指令（`MyAudioDirective`类）被注入到`WorkoutAudioComponent`中。
- en: 'To establish the context, let''s recheck a view fragment from `WorkoutAudioComponent`:'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 为了建立上下文，让我们重新检查`WorkoutAudioComponent`的视图片段：
- en: '[PRE119]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Angular injects the directive (`MyAudioDirective`) into the `WorkoutAudioComponent` property: `ticks`.
    The search is done based on the selector passed to the `@ViewChild` decorator.
    Let''s see the audio example again:'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: Angular会将指令（`MyAudioDirective`）注入到`WorkoutAudioComponent`的属性`ticks`中：搜索是基于传递给`@ViewChild`装饰器的选择器的。让我们再次看一下音频示例：
- en: '[PRE120]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: The selector parameter on `ViewChild` can be a string value, in which case Angular
    searches for a matching template variable, as before.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ViewChild`上的选择器参数可以是一个字符串值，此时Angular会搜索匹配的模板变量，就像之前一样。
- en: 'Or it can be a *type.* This is valid and should inject an instance of `MyAudioDirective`:'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 或者可以是*类型*。这是有效的，并应该注入一个`MyAudioDirective`的实例：
- en: '[PRE121]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: However, it does not work in our case. Why? Because there are multiple `MyAudioDirective` directives
    declared in the `WorkoutAudioComponent` view, one for each of the `<audio>` tags.
    In such a scenario, the first match is injected. Not very useful. Passing the
    type selector would have worked if there was only one `<audio>` tag in the view!
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在我们的情况下，它不起作用。为什么？因为在`WorkoutAudioComponent`视图中声明了多个`MyAudioDirective`指令，每一个都对应一个`<audio>`标签。在这种情况下，只有第一个匹配项被注入。并不是很有用。如果视图中只有一个`<audio>`标签，那么传递类型选择器就可以工作了！
- en: Properties decorated with `@ViewChild` are sure to be set before the `ngAfterViewInit` event
    hook on the component is called. This implies such properties are `null` if accessed
    inside the constructor.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@ViewChild`修饰的属性一定会在组件的`ngAfterViewInit`事件钩子被调用之前设置。这意味着如果在构造函数内部访问这些属性，它们会是`null`。
- en: Angular also has a decorator to locate and inject multiple child components/directives: `@ViewChildren`.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: Angular还有一个装饰器用于定位和注入多个子组件/指令：`@ViewChildren`。
- en: The @ViewChildren decorator
  id: totrans-821
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`@ViewChildren`装饰器'
- en: '`@ViewChildren` works similarly to `@ViewChild`, except it can be used to inject
    multiple child types into the parent. Again taking the previous audio component
    above as an example, using `@ViewChildren`, we can get all the `MyAudioDirective` directive
    instances in `WorkoutAudioComponent`, as shown here:'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ViewChildren`的工作原理类似于`@ViewChild`，只不过它可以把多个子类型注入到父级中。再次以上面的音频组件为例，在`WorkoutAudioComponent`中使用`@ViewChildren`，我们可以得到所有`MyAudioDirective`指令的实例，如下所示：'
- en: '[PRE122]'
  id: totrans-823
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Look carefully; `allAudios` is not a standard JavaScript array, but a custom
    class, `QueryList<Type>`. The `QueryList` class is an immutable collection that
    contains the reference to the components/directives that Angular was able to locate
    based on the filter criteria passed to the `@ViewChildren` decorator. The best
    thing about this list is that Angular will keep this list in sync with the state
    of the view. When directives/components get added/removed from the view dynamically,
    this list is updated too. Components/directives generated using `ng-for` are a
    prime example of this dynamic behavior. Consider the preceding `@ViewChildren` usage
    and this view template:'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看，`allAudios`不是标准的JavaScript数组，而是一个自定义类`QueryList<Type>`。`QueryList`类是一个不可变集合，其中包含了Angular基于传递给`@ViewChildren`装饰器的过滤条件所能定位的组件/指令的引用。这个列表的最好之处在于Angular会将这个列表与视图的状态保持同步。当动态地向视图中添加/移除指令/组件时，这个列表也会被更新。利用`ng-for`生成的组件/指令就是这种动态行为的一个典型例子。考虑上面的`@ViewChildren`使用和这个视图模板：
- en: '[PRE123]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: The number of `MyAudioDirective` directives created by Angular depends upon
    the number of `clips`. When `@ViewChildren` is used, Angular injects the correct
    number of `MyAudioDirective` instances into the `allAudio` property and keeps
    it in sync when items are added or removed from the `clips` array.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: Angular创建的`MyAudioDirective`指令的数量取决于`clips`的数量。使用`@ViewChildren`时，Angular会将正确数量的`MyAudioDirective`实例注入到`allAudio`属性中，并在从`clips`数组中添加或移除项时保持同步。
- en: While the usage of `@ViewChildren` allows us to get hold of all `MyAudioDirective` directives,
    it cannot be used to control the playback. You see, we need to get hold of individual `MyAudioDirective` instances
    as the audio playback timing varies. Hence the distinct `@ViewChild` implementation.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用`@ViewChildren`允许我们获取所有`MyAudioDirective`指令，但它不能用于控制播放。你看，我们需要获取单独的`MyAudioDirective`实例，因为音频播放的时间是变化的。因此，就有了独特的`@ViewChild`实现。
- en: Once we get hold of the `MyAudioDirective` directive attached to each audio
    element, it is just a matter of playing the audio tracks at the right time.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得了附加到每个音频元素的`MyAudioDirective`指令，只需按时播放音频轨道。
- en: Integrating WorkoutAudioComponent
  id: totrans-829
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整合WorkoutAudioComponent
- en: While we have componentized the audio playback functionality into `WorkoutAudioComponent`,
    it is and always will be tightly coupled to the `WorkoutRunnerComponent` implementation. `WorkoutAudioComponent` derives
    its operational intelligence from `WorkoutRunnerComponent`. Hence the two components
    need to interact. `WorkoutRunnerComponent` needs to provide the `WorkoutAudioComponent` state
    change data, including when the workout started, exercise progress, workout stopped,
    paused, and resumed.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经将音频播放功能组件化为`WorkoutAudioComponent`，但它始终紧密耦合到`WorkoutRunnerComponent`的实现中。`WorkoutAudioComponent`从`WorkoutRunnerComponent`获取其操作智能。因此，这两个组件需要交互。`WorkoutRunnerComponent`需要提供`WorkoutAudioComponent`的状态改变数据，包括锻炼开始时，锻炼进度，锻炼停止，暂停和恢复时等等。
- en: One way to achieve this integration would be to use the currently exposed `WorkoutAudioComponent` API
    (stop, resume, and other functions) from `WorkoutRunnerComponent`.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这种集成的一种方式是使用当前公开的`WorkoutAudioComponent` API（停止、恢复和其他功能）来自`WorkoutRunnerComponent`。
- en: Something can be done by injecting `WorkoutAudioComponent` into `WorkoutRunnerComponent`,
    as we did earlier when we injected `MyAudioDirective` into `WorkoutAudioComponent`.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过将`WorkoutAudioComponent`注入`WorkoutRunnerComponent`来完成某些操作，就像我们之前将`MyAudioDirective`注入`WorkoutAudioComponent`一样。
- en: 'Declare the `WorkoutAudioComponent` in the `WorkoutRunnerComponent''s` view,
    such as:'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 声明将`WorkoutAudioComponent`放在`WorkoutRunnerComponent`的视图中，例如：
- en: '[PRE124]'
  id: totrans-834
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Doing so gives us a reference to the `WorkoutAudioComponent` inside the `WorkoutRunnerComponent` implementation:'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做可以在`WorkoutRunnerComponent`的实现中给我们一个对`WorkoutAudioComponent`的引用：
- en: '[PRE125]'
  id: totrans-836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'The `WorkoutAudioComponent` functions can then be invoked from `WorkoutRunnerComponent` from
    different places in the code. For example, this is how `pause` would change:'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以在代码的不同位置从`WorkoutRunnerComponent`调用`WorkoutAudioComponent`的函数。例如，暂停会改变如下：
- en: '[PRE126]'
  id: totrans-838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'And to play the next-up audio, we would need to change parts of the `startExerciseTimeTracking` function:'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 而播放接下来的语音需要改变`startExerciseTimeTracking`函数的一部分：
- en: '[PRE127]'
  id: totrans-840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: This is a perfectly viable option where `WorkoutAudioComponent` becomes a dumb
    component controlled by `WorkoutRunnerComponent`. The only problem with this solution
    is that it adds some noise to the `WorkoutRunnerComponent` implementation. `WorkoutRunnerComponent` now
    needs to manage audio playback too.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常可行的选择，其中`WorkoutAudioComponent`成为`WorkoutRunnerComponent`控制的一个哑组件。这个解决方案的唯一问题是它给`WorkoutRunnerComponent`的实现增加了一些噪音。`WorkoutRunnerComponent`现在也需要管理音频播放。
- en: There is an alternative, however.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也有另一种选择。
- en: '`WorkoutRunnerComponent` can expose events that are triggered during different
    times of workout execution, such as workout started, exercise started, and workout
    paused. The advantage of having `WorkoutRunnerComponent` expose events is that
    it allows us to integrate other components/directives with `WorkoutRunnerComponent` using
    the same events. Be it the `WorkoutAudioComponent` or components we create in
    future.'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutRunnerComponent`可以暴露在锻炼执行不同时间触发的事件，例如锻炼开始，锻炼暂停等。`WorkoutRunnerComponent`暴露事件的优势在于，它允许我们使用相同的事件将其他组件/指令与`WorkoutRunnerComponent`集成。不管是`WorkoutAudioComponent`还是我们未来创建的组件。'
- en: Exposing WorkoutRunnerComponent events
  id: totrans-844
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暴露WorkoutRunnerComponent事件
- en: Till now we have only explored how to consume events. Angular allows us to raise
    events too. Angular components and directives can expose custom events using the `EventEmitter` class
    and the `@Output` decorator.
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只探讨了如何消费事件。Angular也允许我们触发事件。Angular组件和指令可以使用`EventEmitter`类和`@Output`修饰符来暴露自定义事件。
- en: 'Add these event declarations to `WorkoutRunnerComponent` at the end of the
    variable declaration section:'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些事件声明添加到`WorkoutRunnerComponent`的变量声明部分的末尾：
- en: '[PRE128]'
  id: totrans-847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: The names of the events are self-explanatory, and within our `WorkoutRunnerComponent` implementation,
    we need to raise them at the appropriate times.
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 事件的名称不言自明，在我们的`WorkoutRunnerComponent`实现中，我们需要在适当的时候触发它们。
- en: Remember to add the `ExerciseProgressEvent` and `ExerciseChangeEvent` imports
    to the `model` already declared on top. And add the `Output` and `EventEmitter` imports
    to `@angular/core`.
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 记得把`ExerciseProgressEvent`和`ExerciseChangeEvent`导入到顶部已声明的`model`中。并且将`Output`和`EventEmitter`导入到`@angular/core`中。
- en: Let's try to understand the role of the `@Output` decorator and the `EventEmitter` class.
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试理解`@Output`装饰器和`EventEmitter`类的作用。
- en: The @Output decorator
  id: totrans-851
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`@Output` 装饰器'
- en: We covered a decent amount of Angular eventing capabilities in this chapter. Specifically,
    we learned how we can consume any event on a component, directive, or DOM element
    using the `bracketed ()` syntax. How about raising our own events?
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了很多 Angular 事件处理的能力。我们具体学习了如何使用`[]`语法在组件、指令或 DOM 元素上消耗任何事件。那我们如何触发自己的事件呢？
- en: In Angular, we can create and raise our own events, events that signify something
    noteworthy has happened in our component/directive. Using the `@Output` decorator
    and the `EventEmitter` class, we can define and raise custom events.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 中，我们可以创建和触发自己的事件，这些事件表示在我们的组件/指令中发生了值得注意的事情。使用`@Output`装饰器和`EventEmitter`类，我们可以定义和触发自定义事件。
- en: It's also a good time to refresh what we learned about events.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是一个恰当的时机来回顾我们学到的有关事件的知识。
- en: 'Remember this: it is through events that components can communicate with the
    outside world. When we declare:'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：正是通过事件，组件才能与外部世界通信。当我们声明：
- en: '[PRE129]'
  id: totrans-856
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: It signifies that `WorkoutRunnerComponent` exposes an event, `exercisePaused` (raised
    when the workout is paused).
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示`WorkoutRunnerComponent`公开了一个名为`exercisePaused`的事件（在锻炼暂停时触发）。
- en: 'To subscribe to this event, we can do the following:'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 要订阅此事件，我们可以执行以下操作：
- en: '[PRE130]'
  id: totrans-859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'This looks absolutely similar to how we did the DOM event subscription in the
    workout runner template. See this sample stipped from the workout-runner''s view:'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来与我们在锻炼运行器模板中进行 DOM 事件订阅非常相似。看看从锻炼运行者视图中摘取的这个样本：
- en: '[PRE131]'
  id: totrans-861
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: The `@Output` decorator instructs Angular to make this event available for template
    binding. Events created without the `@Output` decorator cannot be referenced in
    HTML.
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Output` 装饰器指示 Angular 使该事件可用于模板绑定。没有使用`@Output` 装饰器创建的事件无法在 HTML 中引用。'
- en: 'The `@Output` decorator can also take a parameter, signifying the name of the
    event. If not provided, the decorator uses the property name: `@Output("workoutPaused")
    exercisePaused: EventEmitter<number> ...`. This declares a `workoutPaused` event
    instead of `exercisePaused`.'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Output` 装饰器也可以带有一个参数，表示事件的名称。如果没有提供，则装饰器使用属性名称：`@Output("workoutPaused")
    exercisePaused: EventEmitter<number> ...`。这声明了一个名为`workoutPaused`的事件，而不是`exercisePaused`。'
- en: Like any decorator, the `@Output` decorator is there just to provide metadata
    for the Angular framework to work with. The real heavy lifting is done by the `EventEmitter` class.
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 像任何装饰器一样，`@Output` 装饰器只是为了提供 Angular 框架所需的元数据。真正的工作由 `EventEmitter` 类完成。
- en: Eventing with EventEmitter
  id: totrans-865
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 EventEmitter 进行事件处理
- en: Angular embraces **reactive programming** (also dubbed **Rx**-style programming)
    to support asynchronous operations with events. If you are hearing this term for
    the first time or don't have much idea about what reactive programming is, you're
    not alone.
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: Angular支持基于事件的**响应式编程**（也被称为**Rx**风格的编程）来支持异步操作。如果您第一次听到这个词，或者对响应式编程不是很了解，那么您并不孤单。
- en: Reactive programming is all about programming against **asynchronous data streams**.
    Such a stream is nothing but a sequence of ongoing events ordered based on the
    time they occur. We can imagine a stream as a pipe generating data (in some manner)
    and pushing it to one or more subscribers. Since these events are captured asynchronously
    by subscribers, they are called asynchronous data streams.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程是关于针对**异步数据流**进行编程。这样的流实际上是根据它们发生的时间顺序排列的一系列正在进行的事件。我们可以想象流就像是生成数据的管道（以某种方式），并将其推送给一个或多个订阅者。由于这些事件被订阅者异步捕获，它们被称为异步数据流。
- en: The data can be anything, ranging from browser/DOM element events to user input
    to loading remote data using AJAX. With *Rx* style, we consume this data uniformly.
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可以是任何内容，从浏览器/DOM 元素事件到用户输入再到使用 AJAX 加载远程数据。使用 Rx 风格，我们统一消耗这些数据。
- en: In the Rx world, there are Observers and Observables, a concept derived from
    the very popular **Observer design pattern**. **Observables** are streams that
    emit data. **Observers**, on the other hand, subscribe to these events.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rx 世界中，有观察者和可观察对象，这是从非常流行的**观察者设计模式**派生出来的概念。**可观察对象**是发出数据的流。另一方面，**观察者**订阅这些事件。
- en: The `EventEmitter` class in Angular is primarily responsible for providing eventing
    support. It acts both as an *observer* and *observable*. We can fire events on
    it and it can also listen to events.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 中，`EventEmitter` 类主要负责提供事件支持。它既充当*观察者*又充当*可观察对象*。我们可以在其上触发事件，它也可以监听事件。
- en: 'There are two functions available on `EventEmitter` that are of interest to
    us:'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 在`EventEmitter`上有两个我们感兴趣的函数可用：
- en: '`emit`: As the name suggests, use this function to raise events. It takes a
    single argument that is the event data. `emit` *is the observable side*.'
  id: totrans-872
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emit`：顾名思义，使用这个函数来引发事件。它接受一个事件数据作为参数。`emit`*是可观察端*。'
- en: '`subscribe`: Use this function to subscribe to the events raised by `EventEmitter`. `subscribe` is
    the observer side.'
  id: totrans-873
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subscribe`：使用这个函数来订阅`EventEmitter`引发的事件。`subscribe`是观察者端。'
- en: Let's do some event publishing and subscriptions to understand how the preceding
    functions work.
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进行一些事件发布和订阅，以了解前面的函数是如何工作的。
- en: Raising events from WorkoutRunnerComponent
  id: totrans-875
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从WorkoutRunnerComponent中引发事件
- en: Look at the `EventEmitter` declaration. These have been declared with the `type` parameter.
    The `type` parameter on `EventEmitter` signifies the type of data emitted.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下`EventEmitter`的声明。这些已经用`type`参数声明了。`EventEmitter`上的`type`参数表示所发出数据的类型。
- en: Let's add the event implementation to `workout-runner.component.ts`, starting
    from the top of the file and moving down.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从文件顶部开始，逐步向下，在`workout-runner.component.ts`中添加事件实现。
- en: 'Add this statement to the end of the `start` function:'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 在`start`函数的末尾添加这个语句：
- en: '[PRE132]'
  id: totrans-879
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: We use the `emit` function of  `EventEmitter`  to raise a `workoutStarted` event
    with the current workout plan as an argument.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`EventEmitter`的`emit`函数来引发一个带有当前锻炼计划参数的`workoutStarted`事件。
- en: 'To `pause`, add this line to raise the `exercisePaused` event:'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 要暂停，将这行代码添加到引发`exercisePaused`事件的函数中：
- en: '[PRE133]'
  id: totrans-882
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'To `resume`, add the following line:'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 要恢复，添加以下行：
- en: '[PRE134]'
  id: totrans-884
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Each time, we pass the current exercise index as an argument to `emit` when
    raising the `exercisePaused` and `exerciseResumed` events.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 每次触发`exercisePaused`和`exerciseResumed`事件时，我们将当前练习索引作为参数传递给`emit`。
- en: 'Inside the `startExerciseTimeTracking` function, add the highlighted code after
    the call to `startExercise`:'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 在`startExerciseTimeTracking`函数中，在调用`startExercise`之后添加上面的代码：
- en: '[PRE135]'
  id: totrans-887
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: The argument passed contains the exercise that is going to start (`next`) and
    the next exercise in line (`this.getNextExercise()`).
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 传递的参数包含即将开始的练习（`next`）和下一个练习（`this.getNextExercise()`）。
- en: 'To the same function, add the highlighted code:'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个函数中，添加上面突出显示的代码：
- en: '[PRE136]'
  id: totrans-890
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: The event is raised when the workout is completed.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 当锻炼完成时，触发该事件。
- en: 'In the same function, we raise an event that communicates the workout progress.
    Add this statement:'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个函数中，我们会触发一个事件来传达锻炼的进度。添加这个语句：
- en: '[PRE137]'
  id: totrans-893
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: That completes our eventing implementation.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们的事件实现。
- en: As you may have guessed, `WorkoutAudioComponent` now needs to consume these
    events. The challenge here is how to organize these components so that they can
    communicate with each other with the minimum dependency on each other.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经猜到了，`WorkoutAudioComponent`现在需要消耗这些事件。这里的挑战是如何组织这些组件，以便它们能以最小的依赖关系互相通信。
- en: Component communication patterns
  id: totrans-896
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件通信模式
- en: 'As the implementation stands now, we have:'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 目前的实现中，我们有：
- en: A basic `WorkoutAudioComponent` implementation
  id: totrans-898
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个基本的`WorkoutAudioComponent`实现
- en: Augmented `WorkoutRunnerComponent` by exposing workout life cycle events
  id: totrans-899
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过公开锻炼生命周期事件扩展了`WorkoutRunnerComponent`
- en: These two components just need to talk to each other now.
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个组件现在只需要互相交流。
- en: 'If the parent needs to communicate with its children, it can do this by:'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 如果父组件需要与其子组件通信，可以通过以下方式完成：
- en: '**Property binding**: The parent component can set up a property binding on
    the child component to push data to the child component. For example, this property
    binding can stop the audio player when the workout is paused:'
  id: totrans-902
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性绑定**：父组件可以在子组件上建立属性绑定，向子组件推送数据。例如，当锻炼暂停时，这个属性绑定可以停止音频播放器：'
- en: '[PRE138]'
  id: totrans-903
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Property binding, in this case, works fine. When the workout is paused, the
    audio is stopped too. But not all scenarios can be handled using property bindings.
    Playing the next exercise audio or halfway audio requires a bit more control.
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 属性绑定，在这种情况下，完全正常。当锻炼暂停时，音频也会停止。但并非所有情况都可以使用属性绑定来处理。播放下一个练习音频或中途音频需要更多控制。
- en: '**Calling functions on child components**: The parent component can also call
    functions on the child component if it can get hold of the child component. We
    have already seen how to achieve this using the `@ViewChild` and `@ViewChildren` decorators
    in the `WorkoutAudioComponent` implementation. This approach and its shortcomings
    have also been discussed briefly in the *Integrating WorkoutAudioComponent* section.'
  id: totrans-905
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调用子组件的函数**：如果父组件可以获取到子组件，那么父组件也可以调用子组件的函数。我们已经看到了如何在`WorkoutAudioComponent`的实现中使用`@ViewChild`和`@ViewChildren`装饰器来实现这一点。这种方法及其缺点也已经在*集成WorkoutAudioComponent*部分中简要讨论过。'
- en: There is one more not-so-good option. Instead of the parent referencing the
    child component, the child references the parent component. This allows the child
    component to call the parent component's public functions or subscribe to parent
    component events.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种不太好的选项。而不是父引用子组件，子引用父组件。这允许子组件调用父组件的公共函数或订阅父组件的事件。
- en: We are going to try this approach and then scrap the implementation for a better
    one! A lot of learning can be derived from the not-so-optimal solution we plan
    to implement.
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试这种方法，然后放弃实现一个更好的方案！从我们计划实施的不太优化的解决方案中可以得到很多学习。
- en: Injecting a parent component into a child component
  id: totrans-908
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将父组件注入到子组件中
- en: 'Add the `WorkoutAudioComponent` to the `WorkoutRunnerComponent` view just before the
    last closing `div`:'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个闭合的`div`之前将`WorkoutAudioComponent`添加到`WorkoutRunnerComponent`的视图中：
- en: '[PRE139]'
  id: totrans-910
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Next, inject `WorkoutRunnerComponent` into `WorkoutAudioComponent`. Open `workout-audio.component.ts` and
    add the following declaration and update the constructor:'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将`WorkoutRunnerComponent`注入到`WorkoutAudioComponent`中。打开`workout-audio.component.ts`并添加以下声明并更新构造函数：
- en: '[PRE140]'
  id: totrans-912
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'And remember to add these imports:'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 记得添加这些导入：
- en: '[PRE141]'
  id: totrans-914
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Let's try to understand what we have done before running the app. There is some
    amount of trickery involved in the construction injection. If we directly try
    to inject `WorkoutRunnerComponent` into `WorkoutAudioComponent`, it fails with
    Angular complaining of not being able to find all the dependencies. Read the code
    and think carefully; there is a subtle dependency cycle issue lurking. `WorkoutRunnerComponent` is
    already dependent on `WorkoutAudioComponent`, as we have referenced `WorkoutAudioComponent` in
    the `WorkoutRunnerComponent` view. Now by injecting `WorkoutRunnerComponent` in `WorkoutAudioComponent`,
    we have created a dependency cycle.
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行应用程序之前，让我们试着理解我们之前做过的事情。在构造注入中涉及一些诡计。如果我们直接尝试将`WorkoutRunnerComponent`注入到`WorkoutAudioComponent`中，Angular会抱怨找不到所有的依赖关系。仔细阅读代码，并且认真思考；潜藏着一个微妙的循环依赖问题。`WorkoutRunnerComponent`已经依赖于`WorkoutAudioComponent`，因为我们在`WorkoutRunnerComponent`视图中引用了`WorkoutAudioComponent`。现在通过将`WorkoutRunnerComponent`注入到`WorkoutAudioComponent`中，我们创建了一个依赖循环。
- en: Cyclic dependencies are challenging for any DI framework. When creating a component
    with a cyclic dependency, the framework has to somehow resolve the cycle. In the
    preceding example, we resolve the circular dependency issue by using an `@Inject` decorator
    and passing in the token created using the `forwardRef()` global framework function.
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 循环依赖对于任何DI框架来说都是具有挑战性的。当创建具有循环依赖的组件时，框架必须以某种方式解决循环。在前面的例子中，我们使用`@Inject`装饰器并传递使用`forwardRef()`全局框架函数创建的令牌来解决循环依赖问题。
- en: Once the injection is done correctly, inside the constructor, we attach a handler
    to the `WorkoutRunnerComponent` events, using the `subscribe` function of `EventEmitter`.
    The arrow function passed to `subscribe` is called whenever the event occurs with
    a specific event argument. We collect all the subscriptions into a `subscription` array.
    This array comes in handy when we unsubscribe, which we need to, to avoid memory
    leaks.
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦正确进行了注入，在构造函数内部，我们使用`EventEmitter`的`subscribe`函数为`WorkoutRunnerComponent`事件绑定处理程序。传递给`subscribe`的箭头函数在特定的事件参数发生时被调用。我们将所有的订阅收集到一个`subscription`数组中。当我们需要取消订阅时，这个数组会很有用，以避免内存泄漏。
- en: 'A bit about `EventEmitter`: the `EventEmmiter` subscription (`subscribe` function)
    takes three arguments:'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`EventEmitter`的一点说明：`EventEmmiter`的订阅(`subscribe`函数)接受三个参数：
- en: '[PRE142]'
  id: totrans-919
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: The first argument is a callback, which is invoked whenever an event is emitted
  id: totrans-920
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数是一个回调函数，每当事件被触发时被调用
- en: The second argument is an error callback function, invoked when the observable
    (the part that is generating events) errors out
  id: totrans-921
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数是一个错误回调函数，在可观察对象（生成事件的部分）发生错误时被调用
- en: The final argument takes a callback function that is called when the observable
    is done publishing events
  id: totrans-922
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个参数接受一个回调函数，该函数在可观察对象完成发布事件时被调用。
- en: We have done enough to make audio integration work. Run the app and start the
    workout. Except for the ticking audio, all the `\` audio clips play at the right
    time. You may have to wait some time to hear the other audio clips. What is the
    problem?
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经做了足够的工作，使音频集成可以工作。运行应用程序并开始锻炼。除了滴答声音以外，所有的音频剪辑都在正确的时间播放。您可能需要等一段时间才能听到其他音频剪辑。问题在哪里？
- en: As it turns out, we never started the ticking audio clip at the start of the
    workout. We can fix it by either setting the `autoplay` attribute on the `ticks` audio
    element or using the component life cycle events to trigger the ticking sound.
    Let's take the second approach.
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，事实证明我们从未在锻炼开始时播放滴答声音。我们可以通过在`ticks`音频元素上设置`autoplay`属性或使用组件生命周期事件来触发滴答声音来修复它。我们采取第二种方法。
- en: Using component life cycle events
  id: totrans-925
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用组件生命周期事件
- en: 'The injected `MyAudioDirective` in `WorkoutAudioComponent`, shown as follows,
    is not available till the view is initialized:'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 注入到`WorkoutAudioComponent`中的`MyAudioDirective`在视图初始化之前是不可用的。
- en: '[PRE143]'
  id: totrans-927
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: We can verify it by accessing the `ticks` variable inside the constructor; it
    will be null. Angular has still not done its magic and we need to wait for the
    children of `WorkoutAudioComponent` to be initialized.
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过访问构造函数中的`ticks`变量来进行验证；它将为空。Angular仍然没有进行魔法，我们需要等待`WorkoutAudioComponent`的子组件初始化。
- en: The component's life cycle hooks can help us here. The `AfterViewInit` event
    hook is called once the component's view has been initialized and hence is a safe
    place from which to access the component's child directives/elements. Let's do
    it quickly.
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的生命周期钩子现在可以帮助我们了。`AfterViewInit`事件钩子在组件视图初始化后调用，因此是从中访问组件的子指令/元素的安全位置。让我们快点做吧。
- en: 'Update `WorkoutAudioComponent` by adding the interface implementation, and
    the necessary imports, as highlighted:'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加接口实现和必要的导入，更新`WorkoutAudioComponent`，如下所示：
- en: '[PRE144]'
  id: totrans-931
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Go ahead and test the app. The app has come to life with full-fledged audio
    feedback. Nice!
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 继续测试该应用程序。该应用程序已经具备了完整的音频反馈功能。很好！
- en: While everything looks fine and dandy on the surface, there is a memory leak
    in the application now. If, in the middle of the workout, we navigate away from
    the workout page (to the start or finish page) and again return to the workout
    page, multiple audio clips play at random times.
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管一切看起来都很美好，但是现在应用程序中存在一些内存泄漏。如果在锻炼过程中，我们从锻炼页面导航到开始或完成页面，然后再返回到锻炼页面，多个音频剪辑就会在随机时间播放。
- en: It seems that `WorkoutRunnerComponent` is not getting destroyed on route navigation,
    and due to this, none of the child components are destroyed, including `WorkoutAudioComponent`.
    The net result? A new `WorkoutRunnerComponent` is being created every time we
    navigate to the workout page but is never removed from the memory on navigating
    away.
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎`WorkoutRunnerComponent`在路由导航时没有被销毁，因此包括`WorkoutAudioComponent`在内的所有子组件都没有被销毁。结果呢？每次我们导航到锻炼页面时都会创建一个新的`WorkoutRunnerComponent`，但在导航离开时却不会从内存中删除。
- en: The primary reason for this memory leak is the event handlers we have added
    in `WorkoutAudioComponent`. We need to unsubscribe from these events when the
    audio component unloads, or else the `WorkoutRunnerComponent` reference will never
    be dereferenced.
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 此内存泄漏的主要原因是我们在`WorkoutAudioComponent`中添加的事件处理程序。当音频组件卸载时，我们需要取消订阅这些事件，否则`WorkoutRunnerComponent`的引用将永远不会被解除引用。
- en: 'Another component lifecycle event comes to our rescue here: `OnDestroy` Add
    this implementation to the `WorkoutAudioComponent` class:'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个组件生命周期事件在这里为我们解决问题：`OnDestroy`。将此实现添加到`WorkoutAudioComponent`类中：
- en: '[PRE145]'
  id: totrans-937
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: Also, remember to add references to the `OnDestroy` event interface as we did
    for `AfterViewInit`.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，记得像我们为`AfterViewInit`那样为`OnDestroy`事件接口添加引用。
- en: Hope the `subscription` array that we created during event subscription makes
    sense now. One-shot unsubscribe!
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 希望我们在事件订阅期间创建的`subscription`数组现在有意义了。一次性取消订阅！
- en: This audio integration is now complete. While this approach is not an awfully
    bad way of integrating the two components, we can do better. Child components
    referring to the parent component seems to be undesirable.
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 此音频集成现在已经完成。虽然这种方法不是集成这两个组件的办法，但我们可以做得更好。子组件引用父组件似乎是不可取的。
- en: Before proceeding, delete the code that we have added to `workout-audio.component.ts` from
    the *Injecting a parent component into a child component* section onward.
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，删除我们从*将父组件注入子组件*部分开始添加到`workout-audio.component.ts`的代码。
- en: Sibling component interaction using events and template variables
  id: totrans-942
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用事件和模板变量进行兄弟组件交互
- en: What if `WorkoutRunnerComponent` and `WorkoutAudioComponent` were organized
    as sibling components?
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`WorkoutRunnerComponent`和`WorkoutAudioComponent`组织为兄弟组件会怎样？
- en: 'If `WorkoutAudioComponent` and `WorkoutRunnerComponent` become siblings, we
    can make good use of Angular''s *eventing* and *template reference variables*.
    Confused? Well, to start with, this is how the components should be laid out:'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`WorkoutAudioComponent`和`WorkoutRunnerComponent`变成兄弟组件，我们可以充分利用Angular的*事件*和*模板引用变量*。
    糊涂了吗？ 好吧，首先，组件应该这样布局：
- en: '[PRE146]'
  id: totrans-945
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Does it ring any bells? Starting from this template, can you guess how the final
    HTML template would look? Think about it before you proceed further.
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 这有什么提示吗？ 从这个模板开始，你可以猜到最终的HTML模板会长什么样吗？ 在继续之前好好考虑一下。
- en: 'Still struggling? As soon as we make them sibling components, the power of
    the Angular templating engine comes to the fore. The following template code is
    enough to integrate `WorkoutRunnerComponent` and `WorkoutAudioComponent`:'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然在挣扎？ 一旦我们将它们设置为兄弟组件，Angular模板引擎的强大之处就展现出来了。 以下模板代码足以集成`WorkoutRunnerComponent`和`WorkoutAudioComponent`：
- en: '[PRE147]'
  id: totrans-948
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'The `WorkoutAudioComponent` template variable, `wa`, is being manipulated by
    referencing the variable in the event handler expressions on `WorkoutRunnerComponent`.
    Quite elegant! We still need to solve the biggest puzzle in this approach: Where
    does the preceding code go? Remember, `WorkoutRunnerComponent` is loaded as part
    of route loading. Nowhere in the code have we had a statement like this:'
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 对`WorkoutRunnerComponent`模板变量`wa`通过在`WorkoutRunnerComponent`上的事件处理器表达式中引用该变量进行操纵。
    相当优雅！ 我们仍然需要解决这种方法中最大的难题：前面的代码放在哪里？ 记住，`WorkoutRunnerComponent`作为路由加载的一部分加载。 在代码中，我们在没有这样的语句的地方：
- en: '[PRE148]'
  id: totrans-950
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: We need to reorganize the component tree and bring in a container component
    that can host `WorkoutRunnerComponent` and `WorkoutAudioComponent`. The router
    then loads this container component instead of `WorkoutRunnerComponent`. Let's
    do it.
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要重新组织组件树，并引入一个可以承载`WorkoutRunnerComponent`和`WorkoutAudioComponent`的容器组件。
    然后路由器加载此容器组件而不是`WorkoutRunnerComponent`。 让我们做吧。
- en: 'Generate a new component code from command line by navigating to `trainer/src/app/workout-runner` and
    executing:'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 通过导航到`trainer/src/app/workout-runner`并执行以下命令，从命令行生成新的组件代码：
- en: '[PRE149]'
  id: totrans-953
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: Copy the HTML code with the events described to the template file. The workout
    container component is ready.
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 复制描述事件的HTML代码到模板文件中。 运动容器组件已经准备好了。
- en: 'We just need to rewire the routing setup. Open `app-routing.module.ts`. Change
    the route for the workout runner and add the necessary import:'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要重构路由设置。 打开`app-routing.module.ts`。 更改运动员的路由并添加必要的导入：
- en: '[PRE150]'
  id: totrans-956
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: And we have a working audio integration that is clear, concise, and pleasing
    to the eye!
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有一个可以工作的音频集成，清晰、简洁，色彩搭配令人愉悦！
- en: It's time now to wrap up the chapter, but not before addressing the video player
    dialog glitch introduced in the earlier sections. The workout does not stop/pause
    when the video player dialog is open.
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候结束本章了，但在解决前几节介绍的视频播放器对话框故障之前还不要结束。 当视频播放器对话框打开时，运动不会停止/暂停。
- en: We are not going to detail the fix here, and urge the readers to give it a try
    without consulting the `checkpoint3.4` code.
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在这里详细说明修复的内容，并且敦促读者在不查阅`checkpoint3.4`代码的情况下尝试一下。
- en: Here is an obvious hint. Use the eventing infrastructure!
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个明显的提示。 使用事件基础设施！
- en: 'And another one: raise events from `VideoPlayerComponent`, one for each playback
    started and ended.'
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个：从`VideoPlayerComponent`触发事件，每个事件对应一个开始和结束的播放。
- en: 'And one last hint: the `open` function on the dialog service (`Modal`) returns
    a promise, which is resolved when the dialog is closed.'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个提示：对话框服务（`Modal`）上的`open`函数返回一个promise，在对话框关闭时解析。
- en: If you are having a problem with running the code, look at the `checkpoint3.4` Git
    branch for a working version of what we have done thus far. Or if you are not
    using Git, download the snapshot of `checkpoint3.4` (a ZIP file) from [http://bit.ly/ng6be-checkpoint-3-4](http://bit.ly/ng6be-checkpoint-3-4).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在运行代码时遇到问题，请查看到目前为止我们所做的工作的工作版本在 `checkpoint3.4` Git 分支中。或者，如果您没有使用 Git，请从
    [http://bit.ly/ng6be-checkpoint-3-4](http://bit.ly/ng6be-checkpoint-3-4) 下载 `checkpoint3.4`
    的快照（ZIP 文件）。第一次设置快照时，请参考 `trainer` 文件夹中的 `README.md` 文件。
- en: Summary
  id: totrans-964
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We started this chapter with the aim of creating a complex Angular app. The
    *7 Minute Workout* app fitted the bill, and you learned a lot about the Angular
    framework while building this app.
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始本章的目的是创建一个复杂的 Angular 应用程序。 *7分钟健身* 应用程序符合要求，在构建这个应用程序的过程中，你学到了很多关于 Angular
    框架的知识。
- en: To build the app, we started off by defining the model of the app. Once the
    model was in place, we started the actual implementation by building an **Angular
    component**. Angular components are nothing but classes that are decorated with
    a framework-specific decorator, `@Component`.
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建应用程序，我们首先定义了应用程序的模型。一旦模型就位，我们开始通过构建一个 **Angular 组件** 来执行实际的实现。Angular 组件只不过是用特定于框架的装饰器
    `@Component` 装饰的类。
- en: We also learned about **Angular modules** and how Angular uses them to organize
    code artifacts.
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了关于 **Angular 模块** 以及 Angular 如何使用它们来组织代码构件。
- en: Once we had a fully functional component, we created a supporting view for the
    app. We also explored the data binding capabilities of the framework, including
    **property**, **attribute**, **class**, **style,** and **event binding**. Plus,
    we highlighted how **interpolations** are a special case of property binding.
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了完全功能的组件，我们为应用程序创建了一个支持视图。我们还探究了框架的数据绑定能力，包括 **属性**，**属性**，**类**，**样式**
    和 **事件绑定**。此外，我们强调了 **插值** 是属性绑定的一个特例。
- en: Components are a special class of directives that have an attached view. We
    touched upon what directives are and the special classes of directives, including
    **attribute** and **structural directives**.
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是具有附加视图的指令的特殊类别。我们简要介绍了指令是什么以及指令的特殊类别，包括 **属性** 和 **结构性指令**。
- en: We learned how to perform cross-component communication using **input properties**.
    The two child components that we put together (`ExerciseDescriptionComponent`
    and `VideoPlayerComponent`) derived their inputs from the parent `WorkoutRunnerComponent`
    using input properties.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何使用 **输入属性** 进行跨组件通信。我们组合的两个子组件（`ExerciseDescriptionComponent` 和 `VideoPlayerComponent`）使用输入属性从父组件
    `WorkoutRunnerComponent` 获取它们的输入。
- en: We then covered another core construct in Angular, **pipes**. We saw how to
    use pipes such as the date pipe and how to create one of our own.
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们介绍了 Angular 中的另一个核心构件，**管道**。我们看到了如何使用管道，比如日期管道，以及如何创建我们自己的管道。
- en: 'Throughout the chapter, we touched upon a number of Angular directives, including
    the following:'
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个章节中，我们接触了许多 Angular 指令，包括以下内容：
- en: '`ngClass/ngStyle`: For applying multiple styles and classes using Angular binding
    capabilities'
  id: totrans-973
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngClass/ngStyle`: 用于使用 Angular 绑定能力应用多个样式和类'
- en: '`ngFor`: For generating dynamic HTML content using a looping construct'
  id: totrans-974
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngFor`: 用于使用循环结构生成动态 HTML 内容'
- en: '`ngIf`: For conditionally creating/destroying DOM elements'
  id: totrans-975
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngIf`: 用于有条件地创建/销毁 DOM 元素'
- en: '`ngSwitch`: For creating/destroying DOM elements using the switch-case construct'
  id: totrans-976
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngSwitch`: 用于使用 switch-case 结构创建/销毁 DOM 元素'
- en: We now have a basic *7 Minute Workout* app. For a better user experience, we
    have added a number of small enhancements to it too, but we are still missing
    some good-to-have features that would make our app more usable. From the framework
    perspective, we have purposefully ignored some core/advanced concepts such as
    **change detection**, **dependency injection**, **component** **routing**, and
    data flow patterns.
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个基本的 *7分钟健身* 应用程序。为了提供更好的用户体验，我们还添加了一些小的增强功能，但我们仍然缺少一些使我们的应用程序更易用的功能。
    从框架的角度来看，我们有意忽略了一些核心/高级概念，如 **变更检测**，**依赖注入**，**组件路由** 和数据流模式。
- en: 'Lastly, we touched upon an important topic: cross-component communication,
    primarily using Angular eventing. We detailed how to create custom events using
    the `@Output` decorator and `EventEmitter`.'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们接触了一个重要的话题：跨组件通信，主要使用 Angular 事件。我们详细介绍了如何使用 `@Output` 装饰器和 `EventEmitter`
    创建自定义事件。
- en: The `@ViewChild` and `@ViewChildren` decorators that we touched upon in this
    chapter helped us understand how a parent can get hold of a child component for
    use. Angular DI also allows injecting a parent component into a child.
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们提到的 `@ViewChild` 和 `@ViewChildren` 装饰器帮助我们理解了父组件如何获取子组件并进行使用。Angular
    DI 还允许将父组件注入到子组件中。
- en: We concluded this chapter by building a `WorkoutAudioComponent` and highlighted
    how sibling-component communication can happen using Angular events and template
    variables.
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过构建一个 `WorkoutAudioComponent` 来结束了本章，并突出了如何使用 Angular 事件和模板变量进行兄弟组件通信。
- en: What's next? We are going to build a new app, *Personal Trainer*. This app will
    allow us to build our own custom workouts. Once we can create our own workout,
    we are going to morph the *7-Minute Workout* app into a generic *Workout Runner* app
    that can run workouts that we build using *Personal Trainer*.
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来呢？我们将构建一个新的应用，*个人健身教练*。这个应用将允许我们构建自定义的训练。一旦我们能够创建自己的训练，我们将把 *7 分钟训练* 应用程序改造成通用的
    *训练运行器* 应用程序，可以运行我们使用 *个人健身教练* 构建的训练。
- en: For the next chapter, we'll showcase Angular's form capabilities while we build
    a UI that allows us to create, update, and view our own custom workouts/exercises.
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下一章，我们将展示 Angular 的表单功能，同时构建一个允许我们创建、更新和查看自定义训练/练习的 UI。
