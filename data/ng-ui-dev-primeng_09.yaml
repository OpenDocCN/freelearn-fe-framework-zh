- en: Miscellaneous Use Cases and Best Practices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 杂项用例和最佳实践
- en: Miscellaneous use cases and best practices introduce more interesting features
    of the PrimeNG library. You will learn about file uploading, drag-and-drop capabilities,
    displaying collection of images, practical CRUD implementation, deferred page
    loading, blocking page pieces, displaying confirmation dialog with guarded routes,
    and more. Despite a comprehensive set of components, users sometime have special
    requirements for existing components regarding their functionality or need new,
    custom components.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 杂项用例和最佳实践介绍了PrimeNG库的更多有趣功能。您将了解文件上传、拖放功能、显示图像集合、实际CRUD实现、推迟页面加载、阻止页面片段、显示带有受保护路由的确认对话框等。尽管组件集合全面，用户有时对现有组件的功能有特殊要求，或者需要新的自定义组件。
- en: The purpose of this chapter is also exclusively to facilitate the start of component
    development on top of the PrimeNG infrastructure. We will go through the complete
    process of building reusable components and develop a custom wizard component.
    The wizard can be used for workflows, which involve multiple steps to complete
    a task. Furthermore, after reading this chapter, readers will be aware of the
    state-of-the-art state management in Angular applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目的也是专门为了在PrimeNG基础架构之上方便组件开发的开始。我们将经历构建可重用组件和开发自定义向导组件的完整过程。该向导可用于涉及多个步骤完成任务的工作流。此外，在阅读本章后，读者将了解Angular应用程序中的最新状态管理。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: File uploading in all its glory
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件上传的全部功能
- en: Learning draggable and droppable directives
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习可拖放指令
- en: Displaying collection of images with Galleria
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Galleria显示图像集合
- en: CRUD sample implementation with DataTable
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有DataTable的CRUD示例实现
- en: Deferring mechanism to optimize page loading
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推迟机制以优化页面加载
- en: Blocking page pieces during long-running AJAX calls
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在长时间运行的AJAX调用期间阻止页面片段
- en: Process status indicator in action
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流程状态指示器的操作
- en: Selecting colors with ColorPicker
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ColorPicker选择颜色
- en: Displaying confirmation dialog with guarded routes
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示带有受保护路由的确认对话框
- en: Implementing custom wizard component with Steps
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用步骤实现自定义向导组件
- en: Introduction to state management with @ngrx/store
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍使用@ngrx/store进行状态管理
- en: File uploading in all its glory
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件上传的全部功能
- en: The FileUpload component provides a file upload mechanism with enhanced features
    compared to the basic HTML `<input type="file">` file upload definition. The component
    provides an HTML5-powered UI with capabilities such as drag and drop, uploading
    multiple files, progress tracking, validations, and more.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: FileUpload组件提供了一个文件上传机制，具有比基本的HTML `<input type="file">`文件上传定义更强大的功能。该组件提供了一个基于HTML5的UI，具有拖放、上传多个文件、进度跟踪、验证等功能。
- en: File uploading component works in all modern browsers as well as IE 10 and higher.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 文件上传组件在所有现代浏览器以及IE 10及更高版本中均可使用。
- en: Basic, multiple, and automatic file uploading
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本、多个和自动文件上传
- en: 'Two properties are required in order to be able to work with the file upload--the
    name of the request parameter to identify the uploaded files at backend and the
    remote URL to upload files. For example:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够使用文件上传，需要两个属性--用于在后端标识上传文件的请求参数的名称以及上传文件的远程URL。例如：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The component presents itself as a panel with three buttons: Choose, Upload,
    Cancel, and a content section with selected files. The Choose button displays
    a file dialog to select one or multiple files. Once selected, the files can be
    uploaded or canceled by the next two buttons, respectively. Filename and size
    are always shown by default. In addition, for images, you will see a preview as
    well:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件呈现为一个带有三个按钮的面板：Choose、Upload、Cancel，以及一个带有选定文件的内容部分。Choose按钮显示一个文件对话框，用于选择一个或多个文件。一旦选择，文件可以通过下面的两个按钮上传或取消。默认情况下始终显示文件名和大小。此外，对于图像，您还将看到预览：
- en: '![](assets/78ae9854-3b08-4ab8-ad72-3c6b316006e0.png)The width of the previewed
    image can be adjusted with the `previewWidth` attribute.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/78ae9854-3b08-4ab8-ad72-3c6b316006e0.png)预览图像的宽度可以通过`previewWidth`属性进行调整。'
- en: 'File upload also provides a simpler UI with just one button Choose and without
    the content section. You can activate this UI by setting the `mode` attribute
    to `"basic"`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 文件上传还提供了一个更简单的UI，只有一个按钮Choose，没有内容部分。您可以通过将`mode`属性设置为`"basic"`来激活此UI：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'By default, the only one file can be selected from the file dialog. Setting
    the `multiple` option to `true` allows selecting multiples files at once. Setting
    the `auto` option to `true` starts the uploading immediately without the need
    to press any buttons. The buttons Upload and Cancel buttons are hidden in the
    auto uploading mode:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，只能从文件对话框中选择一个文件。将`multiple`选项设置为`true`允许一次选择多个文件。将`auto`选项设置为`true`会立即开始上传，无需按任何按钮。在自动上传模式下，上传和取消按钮是隐藏的：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: File selection can also be done by dragging one or more files from the filesystem
    and dropping them onto the content section of the FileUpload component.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 文件选择也可以通过从文件系统中拖动一个或多个文件并将它们放到FileUpload组件的内容部分来完成。
- en: 'At the time of writing, the backend for the FileUpload component cannot be
    mocked with Angular''s mock API. In the demo application on GitHub, we use a simple
    local server `json-server` ([https://github.com/typicode/json-server](https://github.com/typicode/json-server))
    to fake the backend. Otherwise, you will face exceptions. After installation,
    the server can be started as using the following command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，FileUpload组件的后端无法使用Angular的模拟API进行模拟。在GitHub上的演示应用程序中，我们使用一个简单的本地服务器`json-server`（[https://github.com/typicode/json-server](https://github.com/typicode/json-server)）来伪造后端。否则，您将面临异常。安装后，可以使用以下命令启动服务器：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![](assets/a5560d89-9e9e-4c47-853f-62a86546fe3c.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a5560d89-9e9e-4c47-853f-62a86546fe3c.png)'
- en: 'The `db.json` file in the project root only has a definition of endpoint:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 项目根目录中的`db.json`文件只有一个端点的定义：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, you are able to use the faked remote URL without getting any exceptions:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用伪造的远程URL而不会出现任何异常：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The complete demo application with instructions is available on GitHub at
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的演示应用程序及说明可在GitHub上找到
- en: '[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/fileupload](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/fileupload).'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/fileupload](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/fileupload)。'
- en: Restrictions by file types and size
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件类型和大小限制
- en: 'By default, any file types can be uploaded. The file size is not limited either.
    You can restrict file types and size by setting the `accept` and `maxFileSize`
    options, respectively:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，可以上传任何文件类型。文件大小也没有限制。您可以通过分别设置`accept`和`maxFileSize`选项来限制文件类型和大小：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the example, only images with the maximum size `50000` bytes may be uploaded.
    Violation of those rules causes validation messages to appear in the content section.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，只有最大大小为`50000`字节的图像才能被上传。违反这些规则会导致验证消息出现在内容部分。
- en: '![](assets/b7b2e59f-1f93-46c0-8fa4-654a24b21359.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b7b2e59f-1f93-46c0-8fa4-654a24b21359.png)'
- en: 'Possible values of the `accept` property:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`accept`属性的可能值：'
- en: '| **Value** | **Description** |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| **值** | **描述** |'
- en: '| `<file extension>` | A file extension starting with dot, for example, `.gif`,
    `.png`, `.doc` and so many. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `<文件扩展名>` | 以点开头的文件扩展名，例如`.gif`、`.png`、`.doc`等。 |'
- en: '| `audio/*` | All sound files. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `audio/*` | 所有音频文件。 |'
- en: '| `video/*` | All video files. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `video/*` | 所有视频文件。 |'
- en: '| `image/*` | All image files. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `image/*` | 所有图像文件。 |'
- en: '| `<media type>` | A valid media type according to IANA Media Types ([http://www.iana.org/assignments/media-types/media-types.xhtml](http://www.iana.org/assignments/media-types/media-types.xhtml)).
    For example, `application/pdf`. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `<媒体类型>` | 根据IANA媒体类型（[http://www.iana.org/assignments/media-types/media-types.xhtml](http://www.iana.org/assignments/media-types/media-types.xhtml)）的有效媒体类型。例如，`application/pdf`。
    |'
- en: To specify more than one value, separate the values with a comma, for example,
    `accept="audio/*,video/*,image/*"`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定多个值，请使用逗号分隔值，例如，`accept="audio/*,video/*,image/*"`。
- en: Customizations
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义
- en: 'Validation messages can be customized using the following four options:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 验证消息可以使用以下四个选项进行自定义：
- en: '| **Property name** | **Description** | **Default value** |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| **属性名称** | **描述** | **默认值** |'
- en: '| `invalidFileSizeMessageSummary` | Summary message of the invalid file size.
    The placeholder `{0}` refers to the file name. | `{0}: Invalid file size,` |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `invalidFileSizeMessageSummary` | 无效文件大小的摘要消息。占位符`{0}`指的是文件名。 | `{0}：无效文件大小，`
    |'
- en: '| `invalidFileSizeMessageDetail` | Detail message of the invalid file size.
    The placeholder `{0}` refers to the file size. | `maximum upload size is {0}.`
    |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `invalidFileSizeMessageDetail` | 无效文件大小的详细消息。占位符`{0}`指的是文件大小。 | `最大上传大小为{0}。`
    |'
- en: '| `invalidFileTypeMessageSummary` | Summary message of the invalid file type.
    The placeholder `{0}` refers to the file type. | `{0}: Invalid file type,` |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `invalidFileTypeMessageSummary` | 无效文件类型的摘要消息。占位符`{0}`指的是文件类型。 | `{0}：无效文件类型，`
    |'
- en: '| `invalidFileTypeMessageDetail` | Detail message of the invalid file type.
    The placeholder `{0}` refers to the allowed file types. | `allowed file types:
    {0}` |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `invalidFileTypeMessageDetail` | 无效文件类型的详细消息。占位符`{0}`指的是允许的文件类型。 | `允许的文件类型：{0}`
    |'
- en: 'The next code snippet and screenshot demonstrate custom messages. They also
    show how you can set custom labels for buttons:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码片段和屏幕截图演示了自定义消息。它们还展示了如何为按钮设置自定义标签：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![](assets/4a0b5240-b316-4cf0-8c01-c5d79b20c19e.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4a0b5240-b316-4cf0-8c01-c5d79b20c19e.png)'
- en: 'The UI is fully customizable by three named `ng-template` tags. You can customize
    the toolbar, the content section, and the area with selected files. The next code
    snippet shows a fully customizable UI:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: UI可以通过三个命名的`ng-template`标签进行完全自定义。您可以自定义工具栏、内容部分和已选择文件的区域。下一个代码片段显示了一个完全可定制的UI：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The screenshot shows the initial UI state when no file was selected:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕截图显示了当没有选择文件时的初始UI状态：
- en: '![](assets/ee31c045-cea1-4256-bbba-fdf0e6382d30.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ee31c045-cea1-4256-bbba-fdf0e6382d30.png)'
- en: 'After selection from the file dialog, the UI looks like the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 从文件对话框中选择后，UI看起来如下：
- en: '![](assets/a5f74e9a-b298-4421-8c5a-a5e8f5c9dd14.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a5f74e9a-b298-4421-8c5a-a5e8f5c9dd14.png)'
- en: Note that only PDF files may be selected. The `ng-template` with `pTemplate="file`
    gets the `File` instance as an implicit variable. This instance has a property
    `name`, which we leverage in our custom UI.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，只能选择PDF文件。`ng-template`与`pTemplate="file"`一起使用时，会将`File`实例作为隐式变量。此实例具有`name`属性，我们在自定义UI中利用它。
- en: Refer to the official documentation to read more about `File` at [https://developer.mozilla.org/en-US/docs/Web/API/File](https://developer.mozilla.org/en-US/docs/Web/API/File).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅官方文档，了解有关`File`的更多信息，网址为[https://developer.mozilla.org/en-US/docs/Web/API/File](https://developer.mozilla.org/en-US/docs/Web/API/File)。
- en: 'The next level of customization is callback events, which are fired at a certain
    point of time. There are `onBeforeUpload`, `onBeforeSend`, `onUpload`, `onError`,
    `onClear`, `onSelect`, and `uploadHandler` events. The next code snippet demonstrates
    two of them:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 下一级别的定制是回调事件，它们在特定时间点触发。有`onBeforeUpload`、`onBeforeSend`、`onUpload`、`onError`、`onClear`、`onSelect`和`uploadHandler`事件。下一个代码片段演示了其中两个：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `onBeforeUpload` event is fired shortly before uploading. The registered
    callback gets an event object with two parameters:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`onBeforeUpload`事件在上传前不久触发。注册的回调会得到一个具有两个参数的事件对象：'
- en: '`xhr`: The `XMLHttpRequest` instance ([https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest](https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest)).'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xhr`：`XMLHttpRequest`实例（[https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest](https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest)）。'
- en: '`formData`: The `FormData` object ([https://developer.mozilla.org/en/docs/Web/API/FormData](https://developer.mozilla.org/en/docs/Web/API/FormData)).'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`formData`：`FormData`对象（[https://developer.mozilla.org/en/docs/Web/API/FormData](https://developer.mozilla.org/en/docs/Web/API/FormData)）。'
- en: 'We can use this callback to customize the request data such as post parameters
    or header information. For example, we could set a token `jwt` to send it to the
    server. Just write the following callback method in the component class:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用此回调来自定义请求数据，例如提交参数或标头信息。例如，我们可以设置一个令牌`jwt`并将其发送到服务器。只需在组件类中编写以下回调方法：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you see, the token has really been sent:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你看，令牌已经发送了：
- en: '![](assets/26e47c65-840a-45f4-a456-e92b49a2e667.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/26e47c65-840a-45f4-a456-e92b49a2e667.png)'
- en: 'The `onUpload` event is triggered when all selected files have finished uploading.
    They passed event object has the mentioned `XMLHttpRequest` instance and an array
    of objects of type `File`. We can iterate over files and gather them together
    for further processing:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有选定的文件都上传完成时，将触发`onUpload`事件。传递的事件对象具有上述`XMLHttpRequest`实例和类型为`File`的对象数组。我们可以遍历文件并将它们收集在一起进行进一步处理：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It is possible to provide a custom uploading implementation by setting `customUpload="true"`
    and defining a custom upload handler. An example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置`customUpload="true"`并定义自定义上传处理程序，可以提供自定义上传实现。例如：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It is up to you how to implement the `smartUploader` callback. The callback
    has an access to the `event.files`, which is an array of objects of type `File`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如何实现`smartUploader`回调取决于您。回调可以访问`event.files`，这是一个类型为`File`的对象数组。
- en: Learning draggable and droppable directives
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习可拖动和可放置指令
- en: Drag and drop is an action, which means grabbing an object to a different location.
    The components capable of being dragged and dropped enrich the web and make a
    solid base for modern UI patterns. The drag-and-drop utilities in PrimeNG allow
    us to create draggable and droppable user interfaces efficiently. They make it
    abstract for the developers to deal with the implementation details at the browser
    level.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 拖放是一种动作，意味着抓取一个对象并将其放到不同的位置。能够被拖放的组件丰富了网络，并为现代UI模式打下了坚实的基础。PrimeNG中的拖放实用程序允许我们高效地创建可拖放的用户界面。它们使开发人员在浏览器级别处理实现细节变得抽象。
- en: 'In this section, you will learn about the `pDraggable` and `pDroppable` directives.
    We will introduce a DataGrid component containing some imaginary documents and
    make these documents draggable in order to drop them onto a recycle bin. The recycle
    bin is implemented as a DataTable component, which shows properties of dropped
    documents. For the purpose of better understanding the developed code, a picture
    comes first:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将了解`pDraggable`和`pDroppable`指令。我们将介绍一个包含一些虚构文档的DataGrid组件，并使这些文档可拖动以便将它们放到回收站中。回收站实现为一个DataTable组件，显示放置文档的属性。为了更好地理解开发的代码，首先是一张图片：
- en: '![](assets/2e80f0fd-6adf-4d31-a4a1-ee8ff9990472.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2e80f0fd-6adf-4d31-a4a1-ee8ff9990472.png)'
- en: This picture shows what happens after dragging and dropping three documents.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图片展示了拖放三个文档后发生的情况。
- en: The complete demo application with instructions is available on GitHub at
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的演示应用程序及说明可在 GitHub 上找到
- en: '[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/dragdrop](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/dragdrop).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/dragdrop](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/dragdrop)。'
- en: Draggable
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可拖动
- en: '`pDraggable` is attached to an element to add a drag behavior. The value of
    the `pDraggable` attribute is required--it defines the scope to match draggables
    with droppables. By default, the whole element is draggable. We can restrict the
    draggable area by applying the `dragHandle` attribute. The value of `dragHandle`
    can be any CSS selector. In DataGrid, with available documents, we only made the
    panel''s header draggable:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`pDraggable` 附加到一个元素上以添加拖动行为。`pDraggable` 属性的值是必需的，它定义了与可放置元素匹配的范围。默认情况下，整个元素都是可拖动的。我们可以通过应用
    `dragHandle` 属性来限制可拖动的区域。`dragHandle` 的值可以是任何 CSS 选择器。在 DataGrid 中，我们只使面板的标题可拖动：'
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The draggable element can fire three events when the dragging process begins,
    proceeds, and ends. These are `onDragStart`, `onDrag`, and `onDragEnd`, respectively.
    In the component class, we buffer the dragged document at the beginning and reset
    it at the end of the dragging process. This task is done in two callbacks: `dragStart`
    and `dragEnd`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 可拖动元素在拖动过程开始、进行和结束时可以触发三个事件，分别是 `onDragStart`、`onDrag` 和 `onDragEnd`。在组件类中，我们在拖动过程开始时缓冲被拖动的文档，并在结束时重置它。这个任务在两个回调函数中完成：`dragStart`
    和 `dragEnd`。
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the shown code, we used the `Document` interface with the following properties:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在所示的代码中，我们使用了 `Document` 接口，具有以下属性：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the demo application, we set the cursor to `move` when the mouse is moved
    over any panel''s header. This trick provides a better visual feedback for the
    draggable area:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在演示应用程序中，当鼠标移动到任何面板的标题上时，我们将光标设置为 `move`。这个技巧为可拖动区域提供了更好的视觉反馈：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We can also set the `dragEffect` attribute to specify the effect that is allowed
    for a drag operation. Possible values are `none`, `copy`, `move`, `link`, `copyMove`,
    `copyLink`, `linkMove`, and `all`. Refer to the official documentation to read
    more details at [https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer/effectAllowed](https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer/effectAllowed).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以设置 `dragEffect` 属性来指定拖动操作允许的效果。可能的值有 `none`、`copy`、`move`、`link`、`copyMove`、`copyLink`、`linkMove`
    和 `all`。请参考官方文档以获取更多细节：[https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer/effectAllowed](https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer/effectAllowed)。
- en: Droppable
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可放置
- en: '`pDroppable` is attached to an element to add a drop behavior. The value of
    the `pDroppable` attribute should have the same scope as `pDraggable`.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`pDroppable` 附加到一个元素上以添加放置行为。`pDroppable` 属性的值应该与 `pDraggable` 的范围相同。'
- en: Droppable scope can also be an array to accept multiple droppables.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 放置区域的范围也可以是一个数组，以接受多个可放置元素。
- en: 'The droppable element can fire four events:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 可放置元素可以触发四个事件：
- en: '| **Event name** | **Description** |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| **事件名称** | **描述** |'
- en: '| `onDragEnter` | Invoked when a draggable element enters the drop area. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `onDragEnter` | 当可拖动元素进入放置区域时调用。 |'
- en: '| `onDragOver` | Invoked when a draggable element is being dragged over the
    drop area. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `onDragOver` | 当可拖动元素被拖动到放置区域时调用。 |'
- en: '| `onDrop` | Invoked when a draggable is dropped onto the drop area. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `onDrop` | 当可拖动元素放置到放置区域时调用。 |'
- en: '| `onDragLeave` | Invoked when a draggable element leaves the drop area. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `onDragLeave` | 当可拖动元素离开放置区域时调用。 |'
- en: 'In the demo application, the whole code of the droppable area looks as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在演示应用程序中，可放置区域的整个代码如下所示：
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Whenever a document is dragged and dropped into the recycle bin, the dropped
    document is removed from the list of all available documents and added to the
    list of deleted documents. This happens in the `onDrop` callback:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 每当将文档拖放到回收站时，被放置的文档将从所有可用文档列表中移除，并添加到已删除文档列表中。这发生在`onDrop`回调中：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Both available and deleted documents are updated by creating new arrays instead
    of manipulating existing arrays. This is necessary in data iteration components
    to force Angular run change detection. Manipulating existing arrays would not
    run change detection and the UI would not be updated.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 可用和已删除的文档都通过创建新数组来更新，而不是操作现有数组。这在数据迭代组件中是必要的，以强制Angular运行变更检测。操作现有数组不会运行变更检测，UI将不会更新。
- en: 'The Recycle Bin area gets a red border while dragging any panel with document.
    We achieved this highlighting by setting `ngClass` as `[ngClass]="{''dragged-doc'':
    draggedDoc}"`. The style class `dragged-doc` is enabled when the `draggedDoc`
    object is set. The style class is defined as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '拖动任何带有文档的面板时，回收站区域会变成红色边框。我们通过将`ngClass`设置为`[ngClass]="{''dragged-doc'': draggedDoc}"`来实现这种突出显示。当设置了`draggedDoc`对象时，样式类`dragged-doc`就会启用。样式类定义如下：'
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Displaying a collection of images with Galleria
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Galleria显示图像集合
- en: The Galleria component can be used to display a collection of images with a
    transition effect.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Galleria组件可用于显示具有过渡效果的图像集合。
- en: Get it up and running
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让它运行起来
- en: 'A collection of images is created programmatically--it is an array of objects
    with the following three attributes:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图像集合是以编程方式创建的--它是一个具有以下三个属性的对象数组：
- en: '`source`: The path of the image'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`source`：图片的路径'
- en: '`title`: The title text in the caption section'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`：标题部分的标题文本'
- en: '`alt`: A description in the caption section below the title'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alt`：标题下方的描述'
- en: 'Let''s create a `GalleriaComponent` class:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`GalleriaComponent`类：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the HTML code, the collection is referenced via the input property `images`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML代码中，集合通过输入属性`images`进行引用：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The developed UI looks as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 开发的UI如下所示：
- en: '![](assets/8606b121-9daa-4fe5-b66b-095bd94c7649.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8606b121-9daa-4fe5-b66b-095bd94c7649.png)'
- en: The width and height of the content panel can be customized with the `panelWidth`
    and `panelHeight` attributes. The `showCaption` attribute enables displaying titles
    and descriptions in the caption section.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 内容面板的宽度和高度可以通过`panelWidth`和`panelHeight`属性进行自定义。`showCaption`属性可以启用在标题部分显示标题和描述。
- en: At the bottom, there is an area with small images called **filmstrip**. The
    visibility of the filmstrip is enabled by default with the `showFilmstrip` attribute.
    You can disable it by setting the attribute to `false`. The width and height of
    the frames visualized in the filmstrip can be customized with the `frameWidth`
    and `frameHeight` attributes, respectively. All values should be provided in pixels.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 底部有一个名为**filmstrip**的小图像区域。通过`showFilmstrip`属性，默认情况下启用filmstrip的可见性。您可以通过将属性设置为`false`来禁用它。在filmstrip中可视化的帧的宽度和高度分别可以通过`frameWidth`和`frameHeight`属性进行自定义。所有值应以像素为单位提供。
- en: There is also the `activeIndex` attribute, which can be used to set the position
    of the displayed image. For example, if you want to display the second image on
    the initial page load, you can set `activeIndex="1"`. The default value is `0`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 还有`activeIndex`属性，可用于设置显示图像的位置。例如，如果您想在初始页面加载时显示第二张图像，可以设置`activeIndex="1"`。默认值为`0`。
- en: Auto play mode and effects
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动播放模式和效果
- en: The auto play mode turns a slideshow on. The auto play mode is enabled by default.
    In the example, we disabled the slideshow by setting `[autoPlay]="false"`. The
    transition between images in the auto play mode happens within `4000` milliseconds.
    This time interval can be customized with the `transitionInterval` attribute.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 自动播放模式可以打开幻灯片放映。自动播放模式默认情况下是启用的。在示例中，我们通过设置`[autoPlay]="false"`来禁用幻灯片放映。自动播放模式中图像之间的过渡在`4000`毫秒内完成。可以使用`transitionInterval`属性自定义此时间间隔。
- en: 'While iterating through the images, it is possible to apply transition effects.
    The `effect` attribute can have the values `blind`, `bounce`, `clip`, `drop`,
    `explode`, `fade` (the default), `fold`, `highlight`, `puff`, `pulsate`, `scale`,
    `shake`, `size`, `slide`, and `transfer`. The `effectDuration` attribute can also
    be used to decide on the duration of the transition. Its default value is `250`
    milliseconds:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在遍历图像时，可以应用过渡效果。`effect`属性可以取`blind`、`bounce`、`clip`、`drop`、`explode`、`fade`（默认值）、`fold`、`highlight`、`puff`、`pulsate`、`scale`、`shake`、`size`、`slide`和`transfer`这些值。`effectDuration`属性也可以用于决定过渡的持续时间。其默认值为`250`毫秒：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Events
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件
- en: 'There is only one event `onImageClicked`, which is fired when a displayed image
    is clicked on:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个事件`onImageClicked`，当点击显示的图像时触发：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The invoked callback gets an event object. Beside index of the clicked image
    and the native click event, the passed in event object keeps the entire image
    instance from the collection. We could access the source URL in the callback and
    open the image in a new browser tab:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 调用的回调会得到一个事件对象。除了点击图像的索引和原生点击事件之外，传入的事件对象还保留了集合中的整个图像实例。我们可以在回调中访问源URL并在新的浏览器标签中打开图像：
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The complete demo application with instructions is available on GitHub at
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 带有说明的完整演示应用程序可在GitHub上找到
- en: '[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/galleria](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/galleria).'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/galleria](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/galleria)。'
- en: CRUD sample implementation with DataTable
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有DataTable的CRUD示例实现
- en: PrimeNG was created for enterprise applications. Implementing a **CRUD** (**create,
    read, update**, and **delete**) scenario is easily done. The example in this section
    demonstrates such a scenario with employees that are taken as domain model objects.
    Employees can be fetched, created, updated, and deleted. All CRUD operations happens
    via Angular's HTTP service, which communicates with a mock backend. We will improve
    our CRUD implementation later on in the section *Introduction to state management
    with @ngrx/store*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: PrimeNG是为企业应用程序创建的。实现**CRUD**（**创建、读取、更新**和**删除**）场景很容易。本节中的示例演示了使用作为域模型对象的员工的这种场景。可以获取、创建、更新和删除员工。所有CRUD操作都是通过Angular的HTTP服务进行的，该服务与模拟后端进行通信。我们将在本节的*使用@ngrx/store进行状态管理介绍*中改进我们的CRUD实现。
- en: 'The domain model object `Employee` is defined using the following interface:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下接口定义了域模型对象`Employee`：
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The mock backend is not shown here because it is beyond the scope of this book.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟后端在此处未显示，因为它超出了本书的范围。
- en: The complete demo application with instructions is available on GitHub at
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 带有说明的完整演示应用程序可在GitHub上找到
- en: '[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/crud-datatable](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/crud-datatable).'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/crud-datatable](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/crud-datatable)。'
- en: 'The `EmployeeService` class with CRUD operations is worth to be listed here.
    It exposes four methods with `Observable` as return value so that the component
    class can invoke `subscribe()` to receive delivered data:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`EmployeeService`类具有CRUD操作，值得在这里列出。它公开了四种方法，返回值为`Observable`，以便组件类可以调用`subscribe()`来接收传递的数据：'
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Employees are presented in DataTable when they are fetched from the backend:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当从后端获取员工时，员工将显示在DataTable中：
- en: '![](assets/df796d51-9d45-47dc-8557-1337eeec05e8.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/df796d51-9d45-47dc-8557-1337eeec05e8.png)'
- en: As you can see, only the Add button is enabled when no employee is selected.
    The Add and Edit buttons trigger displaying a dialog box for employee's personal
    data. The Save button creates a new or updates an existing employee depending
    on what you have chosen before--the Add or the Edit button.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，当没有选择员工时，只有添加按钮是启用的。添加和编辑按钮触发显示员工个人数据的对话框。保存按钮根据之前选择的是添加还是编辑按钮，创建新员工或更新现有员工。
- en: '![](assets/bf3e848d-90ed-47da-9d43-9e6bf91bf104.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bf3e848d-90ed-47da-9d43-9e6bf91bf104.png)'
- en: 'Operations triggered by buttons fade in appropriate messages:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮触发的操作会淡入相应的消息：
- en: '![](assets/78029f0b-94a1-482c-868b-2bf49041a430.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/78029f0b-94a1-482c-868b-2bf49041a430.png)'
- en: 'The table is implemented with `p-dataTable` as shown here:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 表格是使用`p-dataTable`实现的，如下所示：
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The value of `p-dataTable` is bound to the array property `employees`. An employee
    can be selected by the click of a row and gets saved in the `selectedEmployee`
    property. The buttons Edit and Remove are disabled when `selectedEmployee` is
    not set. We will skip the code of the dialog for the sake of brevity. The most
    interesting part is the component class. The employees are fetched by means of
    `EmployeeService` in the `ngOnInit()` lifecycle callback:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`p-dataTable`的值绑定到数组属性`employees`。通过点击行选择员工，并保存在`selectedEmployee`属性中。当`selectedEmployee`未设置时，编辑和删除按钮将被禁用。为了简洁起见，我们将跳过对话框的代码。最有趣的部分是组件类。员工是通过`EmployeeService`在`ngOnInit()`生命周期回调中获取的：'
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Let's explore other CRUD methods in details. The `add()` method constructs an
    empty employee instance and the `edit()` method clones the selected employee.
    Both are used in the dialog. The property `displayDialog` is set to `true` to
    force displaying the dialog.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细探讨其他CRUD方法。`add()`方法构建一个空的员工实例，`edit()`方法克隆所选的员工。两者都在对话框中使用。属性`displayDialog`设置为`true`，强制显示对话框。
- en: This property is bound in the view to dialog's visibility as follows `[(visible)]="displayDialog"`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 该属性在视图中绑定到对话框的可见性，如下所示`[(visible)]="displayDialog"`。
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The Save button in the dialog invokes the `save()` method where we check if
    the employee exists with the help of `id`. Only employees that have been saved
    before contain `id` because `id` is assigned in the backend. An existing employee
    should be updated and the new one should be created:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 对话框中的保存按钮调用`save()`方法，其中我们通过`id`来检查员工是否存在。只有之前保存过的员工才包含`id`，因为`id`是在后端分配的。现有员工应该被更新，新员工应该被创建：
- en: '[PRE30]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The employee will be updated or created in the backend and the `employees`
    array:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 员工将在后端和`employees`数组中更新或创建：
- en: As you can see, a new instance of the `employees` array is created instead of
    manipulating the existing one. This is necessary in data iteration components
    to force Angular run change detection. Manipulating elements in the existing array
    don't update the array's reference. As a result, the change detection would not
    run and the UI would not be updated.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，创建了`employees`数组的新实例，而不是操作现有的数组。这在数据迭代组件中是必要的，以强制Angular运行变更检测。操作现有数组中的元素不会更新数组的引用。结果，变更检测不会运行，UI也不会更新。
- en: Note that `Observable` provides a `finally` method where we can reset values
    of properties.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Observable`提供了一个`finally`方法，我们可以在其中重置属性的值。
- en: The function passed in to the `finally` method as a parameter is invoked after
    the source observable sequence terminates gracefully or exceptionally.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 作为参数传递给`finally`方法的函数在源可观察序列正常或异常终止后被调用。
- en: 'The `remove()` method gets invoked by the Remove button:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove()`方法由删除按钮调用：'
- en: '[PRE31]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The sequence logic is similar to the other CRUD operations.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 序列逻辑与其他CRUD操作类似。
- en: Deferring mechanism to optimize page loading
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推迟机制以优化页面加载
- en: Large-scale applications always need best practices to improve the page loading
    time. It is not advisable to wait for the landing page to display until all contents
    in the page have been fully loaded. PrimeNG provided a defer directive which postpones
    the content loading until the component appears in the view port. The content
    will be lazily loaded when it becomes visible by the page scroll.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 大型应用程序总是需要最佳实践来提高页面加载时间。不建议等到所有页面内容完全加载后再显示登陆页面。PrimeNG提供了一个defer指令，可以推迟内容加载直到组件出现在视口中。当页面滚动时，内容将在变得可见时懒加载。
- en: 'The `pDefer` directive is applied to a container element and the content needs
    to be wrapped with `ng-template` directive as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`pDefer`指令应用于容器元素，内容需要用`ng-template`指令包装如下：'
- en: '[PRE32]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The defer directive is very helpful to lazily load huge datasets when you use
    data iteration components such as `p-dataTable`, `p-dataList`, `p-dataGrid`, and
    so on. The `onLoad` callback is used to query data from the data source on demand
    when the component becomes visible through page scrolling. The query is not initiated
    on page load so that the page is loaded quickly. A concrete example is implemented
    here:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用数据迭代组件（如`p-dataTable`，`p-dataList`，`p-dataGrid`等）时，defer指令非常有助于延迟加载大型数据集。`onLoad`回调用于在组件通过页面滚动变得可见时按需从数据源查询数据。查询不会在页面加载时启动，因此页面加载速度很快。这里实现了一个具体的例子：
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `loadData()` method fetches the employees:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadData()`方法获取员工信息：'
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Blocking page pieces during long-running AJAX calls
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在长时间运行的AJAX调用期间阻止页面片段
- en: The BlockUI component allows us to block any piece of a page, for example, during
    AJAX calls. The BlockUI component adds a layer over the target element and gives
    the appearance and behavior of blocking user interaction. It is very handy if
    you have, for example, a large DataTable component and CRUD operations take much
    time. You can block almost everything--even the whole page. In this section, we
    will demonstrate how to deal with BlockUI.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: BlockUI组件允许我们阻止页面的任何部分，例如在AJAX调用期间。BlockUI组件在目标元素上添加一个层，并提供阻止用户交互的外观和行为。如果您有一个大型的DataTable组件，并且CRUD操作需要很长时间，这将非常方便。您几乎可以阻止一切事物--甚至整个页面。在本节中，我们将演示如何处理BlockUI。
- en: 'The BlockUI component blocks a blockable *target* component. The `target` property
    points to a template reference variable of such target component. The visibility
    of BlockUI is controlled by the Boolean property `blocked`. For instance, the
    following BlockUI blocks the Panel component when the property `blocked` is set
    to `true` and unblocks it otherwise:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: BlockUI组件阻止一个可阻止的*目标*组件。`target`属性指向这样一个目标组件的模板引用变量。BlockUI的可见性由布尔属性`blocked`控制。例如，以下BlockUI在属性`blocked`设置为`true`时阻止Panel组件，并在其他情况下解除阻止：
- en: '[PRE35]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The default value of `target` is the `document` object. That means, if no `target`
    is provided, the whole page is blocked. As you can also see, it is possible to
    place any custom content within the `p-blockUI` tag. The custom content gets displayed
    on a semi-transparent layer.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`target`的默认值是`document`对象。这意味着，如果没有提供`target`，整个页面都会被阻塞。正如你所看到的，可以在`p-blockUI`标签中放置任何自定义内容。自定义内容会显示在半透明层上。'
- en: We will leverage the CRUD example from the previous section to demonstrate the
    BlockUI component in action. For the sake of brevity, only two buttons will be
    available--a Reload button, which performs data fetching, and a Remove button.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用上一节中的CRUD示例来演示BlockUI组件的工作原理。为了简洁起见，只有两个按钮可用--一个是重新加载按钮，用于执行数据获取，另一个是删除按钮。
- en: 'Let''s specify the blocking as--the Reload button should block the whole page
    and the Remove button should only block the table. Furthermore, we want to display
    a loading indicator and the text Loading... as shown in the picture:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们指定阻塞方式--重新加载按钮应该阻塞整个页面，删除按钮应该只阻塞表格。此外，我们希望显示一个加载指示器和文本Loading...，如图所示：
- en: '![](assets/feb94132-b48a-483a-b0bd-32f317c12a80.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/feb94132-b48a-483a-b0bd-32f317c12a80.png)'
- en: 'These acceptance criteria results in two BlockUI components:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这些验收标准导致了两个BlockUI组件：
- en: '[PRE36]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The properties `blockedTable` and `blockedPage` are set to `true` immediately
    on button clicks. After CRUD operations are done, the properties are set to `false`.
    This approach is outlined in the next code block:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`blockedTable`和`blockedPage`属性在按钮点击时立即设置为`true`。CRUD操作完成后，这些属性设置为`false`。这种方法在下面的代码块中概述：'
- en: '[PRE37]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The semi-transparent layer over blocked components can be customized as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 被阻塞组件上的半透明层可以按以下方式自定义：
- en: '`.ui-blockui.ui-widget-overlay {opacity: 0.5;}`The complete demo application
    with instructions is available on GitHub at'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`.ui-blockui.ui-widget-overlay {opacity: 0.5;}`完整的演示应用程序及说明可在GitHub上找到'
- en: '[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/blockui](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/blockui).'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/blockui](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/blockui).'
- en: Process status indicator in action
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程状态指示器在工作中
- en: 'The ProgressBar component indicates a status of some process, task, or whatever.
    It can deal with static as well as dynamic values. A dynamic value is a value
    changing in time. The next code snippet demonstrates two progress bars, with a
    static and dynamic value:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ProgressBar组件指示某个过程、任务或其他内容的状态。它可以处理静态值和动态值。动态值是随时间变化的值。下面的代码片段演示了两个进度条，一个是静态值，一个是动态值：
- en: '[PRE38]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The dynamic value gets produced every 800 milliseconds from 1 to 100 with the
    `Observable` methods as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 动态值每800毫秒从1到100产生，使用`Observable`方法如下：
- en: '[PRE39]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'At the end, a growl message with the text Process completed will be displayed.
    A snapshot picture is shown here:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将显示一个带有文本Process completed的growl消息。快照图片如下所示：
- en: '![](assets/50d4b3f1-76c9-44ec-ad9a-056f384d6574.png)The complete demo application
    with instructions is available on GitHub at'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/50d4b3f1-76c9-44ec-ad9a-056f384d6574.png)完整的演示应用程序及说明可在GitHub上找到'
- en: '[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/progressbar](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/progressbar).'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/progressbar](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/progressbar).'
- en: Selecting colors with ColorPicker
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ColorPicker选择颜色
- en: 'ColorPicker is a graphical user interface input widget used to select colors
    from a two-dimensional square box. The component uses the `ngModel` directive
    for two-way value binding. Basically, it supports three kinds of color formats
    such as hex, RGB, and HSB with a hex default type. The color format is denoted
    with the `format` attribute, for example, as `format="rgb"`. ColorPicker is an
    editable component and can be used in model-driven forms as well. A basic example
    would be as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ColorPicker是一个用于从二维方框中选择颜色的图形用户界面输入小部件。该组件使用`ngModel`指令进行双向值绑定。基本上，它支持三种颜色格式，如十六进制、RGB和HSB，其中十六进制是默认类型。颜色格式用`format`属性表示，例如，`format="rgb"`。ColorPicker是一个可编辑的组件，也可以在模型驱动的表单中使用。一个基本的例子如下：
- en: '[PRE40]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The component has to define the `string` type color property for default hex
    values, whereas the color property should be object type for RGB and HSB formats
    as shown here:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 组件必须为默认十六进制值定义`string`类型的颜色属性，而颜色属性应该是对象类型，用于RGB和HSB格式，如下所示：
- en: '[PRE41]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The color picker will display the selected color as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色选择器将显示所选颜色如下：
- en: '![](assets/6f08baae-7b66-4b76-9ad1-f9e8e5938237.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6f08baae-7b66-4b76-9ad1-f9e8e5938237.png)'
- en: 'By default, the color picker is displayed in overlay format, but this default
    behavior can be changed using the `inline` property, which allows a inline format
    by enabling the inline setting. The color picker component in the inline format
    would be written as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，颜色选择器以覆盖格式显示，但可以使用`inline`属性更改此默认行为，通过启用内联设置，可以启用内联格式。内联格式的颜色选择器组件将如下所示：
- en: '[PRE42]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This component also supports the `onChange` callback with an `event` object
    as argument. The `event` object holds the browser event and the selected color
    value to notify the changes as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件还支持带有`event`对象作为参数的`onChange`回调。`event`对象保存浏览器事件和所选颜色值，以通知更改如下：
- en: '[PRE43]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Like other input components, ColorPicker supports model-driven forms, disabled
    property to disable the user interactions, and so on.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 像其他输入组件一样，ColorPicker支持模型驱动的表单，禁用属性以禁用用户交互，等等。
- en: The complete demo application with instructions is available on GitHub at [https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/colorpicker](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/colorpicker).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的演示应用程序及说明可在GitHub上找到[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/colorpicker](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/colorpicker)。
- en: Displaying confirmation dialog with guarded routes
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示带有受保护路由的确认对话框
- en: 'In Angular 2+, you can protect routes with guards. The most likely used guard
    types are `CanActivate` and `CanDeactivate`. The first guard type decides if a
    route can be activated, and the second one decides if a route can be deactivated.
    In this section, we will discuss `CanDeactivate`. This is an interface having
    only one method `canDeactivate`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular 2+中，您可以使用守卫保护路由。最常用的守卫类型是`CanActivate`和`CanDeactivate`。第一个守卫类型决定是否可以激活路由，第二个守卫类型决定是否可以停用路由。在本节中，我们将讨论`CanDeactivate`。这是一个只有一个方法`canDeactivate`的接口。
- en: '[PRE44]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This method can return `Observable<boolean>`, `Promise<boolean>`, or `boolean`.
    If the value of `boolean` is `true`, the user can navigate away from the route.
    If the value of `boolean` is `false`, the user will stay on the same view. If
    you want to protect your route from navigating away under some circumstances,
    you have to do three steps:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法可以返回`Observable<boolean>`，`Promise<boolean>`或`boolean`。如果`boolean`的值为`true`，用户可以从路由中导航离开。如果`boolean`的值为`false`，用户将保持在相同的视图上。如果您想在某些情况下阻止路由导航离开，您必须执行三个步骤：
- en: Create a class that implements the `CanDeactivate` interface. The class acts
    as a guard, which will be checked by the router when navigating away from the
    current view. As you can see, the interface expects a generic component class.
    This is the current component rendered within the `<router-outlet>` tag.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个实现`CanDeactivate`接口的类。该类充当守卫，当从当前视图导航离开时，路由器将对其进行检查。正如你所看到的，该接口期望一个通用组件类。这是当前在`<router-outlet>`标签中呈现的组件。
- en: Register this guard as provider in a module annotated with `@NgModule`.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用`@NgModule`注释的模块中将此守卫注册为提供者。
- en: Add this guard to the router configuration. A router configuration has the `canDeactivate`
    property where such guards can be added multiple times.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此守卫添加到路由器配置中。路由器配置具有`canDeactivate`属性，可以在其中多次添加此类守卫。
- en: You might want to check out an example from the official Angular documentation
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想查看官方Angular文档中的示例
- en: '[https://angular.io/docs/ts/latest/api/router/index/CanDeactivate-interface.html](https://angular.io/docs/ts/latest/api/router/index/CanDeactivate-interface.html).'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://angular.io/docs/ts/latest/api/router/index/CanDeactivate-interface.html](https://angular.io/docs/ts/latest/api/router/index/CanDeactivate-interface.html)。'
- en: 'In this book, we would like to implement a typical use case where we will check
    if there are some unsaved input changes made by user. If the current view has
    unsaved input values and the user tries to navigate away to another view, a confirmation
    dialog should be shown. We will use ConfirmDialog from PrimeNG:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们想要实现一个典型的用例，即检查用户是否有一些未保存的输入更改。如果当前视图具有未保存的输入值，并且用户试图导航到另一个视图，应该显示一个确认对话框。我们将使用PrimeNG的ConfirmDialog：
- en: '![](assets/407c81bb-0838-45cf-9f48-359c6c51e854.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/407c81bb-0838-45cf-9f48-359c6c51e854.png)'
- en: 'Now, hitting the Yes button leads to navigating to another view:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击“是”按钮会导航到另一个视图：
- en: '![](assets/1f151ef4-5da8-4c08-b7e2-bf4f21e3f420.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1f151ef4-5da8-4c08-b7e2-bf4f21e3f420.png)'
- en: 'Hitting the No button prevents the the process of navigating from the current
    route. Let''s create the first view with an `input` element, a `submit` button,
    and the `<p-confirmDialog>` component:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“否”按钮会阻止从当前路由导航的过程。让我们创建第一个视图，其中包含一个`input`元素，一个`submit`按钮和`<p-confirmDialog>`组件：
- en: '[PRE45]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The corresponding component for this template keeps the `dirty` state of the
    form, which indicates that the form is being edited:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 该模板对应的组件保持表单的`dirty`状态，表示表单正在被编辑：
- en: '[PRE46]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We will not implement any sophisticated algorithms in order to check if the
    input value was really changed. We just check the form''s `dirty` state. If the
    form is not being edited, the navigation on submit should be fine. No need to
    ask the user about unsaved changes. Now, we have to inject the PrimeNG `ConfirmationService`
    into our guard implementation, which is required to display a confirmation dialog,
    and use it like this within the `canDeactivate` method:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会实现任何复杂的算法来检查输入值是否真的已更改。我们只检查表单的`dirty`状态。如果表单没有被编辑，提交时导航应该没问题。无需询问用户有关未保存的更改。现在，我们必须将PrimeNG的`ConfirmationService`注入到我们的守卫实现中，这是显示确认对话框所必需的，并在`canDeactivate`方法中像这样使用它：
- en: '[PRE47]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'But there is a problem. The `confirm` method doesn''t return required `Observable<boolean>`,
    `Promise<boolean>`, or `boolean`. The solution is to create and return an `Observable`
    object by invoking `Observable.create()`. The `create` method expects a callback
    with one parameter `observer: Observer<boolean>`. Now we need to do two steps:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '但是有一个问题。`confirm`方法没有返回所需的`Observable<boolean>`、`Promise<boolean>`或`boolean`。解决方案是通过调用`Observable.create()`创建并返回一个`Observable`对象。`create`方法期望一个带有一个参数`observer:
    Observer<boolean>`的回调。现在我们需要执行两个步骤：'
- en: Put the call `this.confirmationService.confirm()` into the callback's body.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将调用`this.confirmationService.confirm()`放入回调函数体中。
- en: Pass `true` or `false` to the subscriber by invoking `observer.next(true)` and
    `observer.next(false)` respectively. The subscriber is the PrimeNG's component
    `ConfirmDialog` which needs to be informed about user's choice.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用`observer.next(true)`和`observer.next(false)`将`true`或`false`传递给订阅者。订阅者是PrimeNG的组件`ConfirmDialog`，需要被告知用户的选择。
- en: 'The full implementation of the `UnsavedChangesGuard` is shown next:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 下面显示了`UnsavedChangesGuard`的完整实现：
- en: '[PRE48]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'As we already said, the guard is registered in the router configuration:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经说过的，该守卫已在路由配置中注册：
- en: '[PRE49]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If you prefer `Promise` instead of `Observable`, you can return `Promise` as
    follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢`Promise`而不是`Observable`，可以返回`Promise`如下：
- en: '[PRE50]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The complete demo application with instructions is available on GitHub at
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的演示应用程序及说明可在GitHub上找到
- en: '[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/guarded-routes](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/guarded-routes).'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/guarded-routes](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/guarded-routes)。'
- en: Implementing a custom wizard component with Steps
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Steps实现自定义向导组件
- en: 'PrimeNG has a component called Steps, which indicates the steps in a workflow.
    The usage is simple:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: PrimeNG有一个名为Steps的组件，用于指示工作流程中的步骤。使用方法很简单：
- en: '[PRE51]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `model` is a collection of objects of type `MenuItem` which we met in the
    [Chapter 7](26ecdd8d-1f1d-4a09-8f2e-c018120abc0b.xhtml), *Endless Menu Variations*.
    The property `activeIndex` points to an index of the active item (step) in the
    collection of items. The default value is `0` what means that the first item is
    selected by default. We can also make the items clickable by setting `[readonly]="false"`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`model`是`MenuItem`类型的对象集合，我们在[第7章](26ecdd8d-1f1d-4a09-8f2e-c018120abc0b.xhtml)中遇到过，*无尽菜单变化*。属性`activeIndex`指向项目集合中活动项目（步骤）的索引。默认值为`0`，表示默认选择第一个项目。我们还可以通过设置`[readonly]="false"`使项目可点击。'
- en: 'Refer to the PrimeNG showcase to see Steps in action:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考PrimeNG展示以查看步骤的操作：
- en: '[https://www.primefaces.org/primeng/#/steps](https://www.primefaces.org/primeng/#/steps)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.primefaces.org/primeng/#/steps](https://www.primefaces.org/primeng/#/steps)'
- en: 'On basis of `<p-steps>`, we will implement a wizard like behavior with two
    custom components named `<pe-steps>` and `<pe-step>`. The prefix `pe` should hint
    at "PrimeNG extensions". The component `<pe-steps>` acts as container for multiple
    steps. The basic structure:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 基于`<p-steps>`，我们将使用两个自定义组件`<pe-steps>`和`<pe-step>`来实现类似向导的行为。前缀`pe`应该提示"PrimeNG扩展"。组件`<pe-steps>`作为多个步骤的容器。基本结构：
- en: '[PRE52]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We can grasp this structure as wizard. The navigation between wizard''s steps
    happens by clicking on Breadcrumb items (clickable steps), navigation buttons,
    or setting step''s index (`activeIndex`) programmatically. The next screenshot
    shows how the wizard and the navigation could look like:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个结构理解为向导。在向导步骤之间的导航通过点击面包屑项目（可点击的步骤）、导航按钮或通过编程设置步骤索引（`activeIndex`）来实现。下一张截图显示了向导和导航的样子：
- en: '![](assets/389d35fa-c440-4ef3-a8f0-31315349667b.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/389d35fa-c440-4ef3-a8f0-31315349667b.png)'
- en: 'Before starting the implementation, let''s specify the API. The `<pe-step>`
    component has the following:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始实施之前，让我们先指定API。`<pe-step>`组件具有以下内容：
- en: '**Attributes**:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '**属性**：'
- en: '| **Name** | **Type** | **Default** | **Description** |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **类型** | **默认值** | **描述** |'
- en: '| `styleClass` | `string` | `null` | Style class of single Step component |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| `styleClass` | `string` | `null` | 单个Step组件的样式类 |'
- en: '| `label` | `string` | `null` | Label of this Step shown earlier |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| `label` | `string` | `null` | 显示此Step的标签 |'
- en: '**Styling**:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**样式**：'
- en: '| **Name** | **Element** |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **元素** |'
- en: '| `pe-step-container` | Container element of a single Step component |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| `pe-step-container` | 单个Step组件的容器元素 |'
- en: 'The `<pe-steps>` component has:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`<pe-steps>`组件具有：'
- en: '**Attributes**:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '**属性**：'
- en: '| **Name** | **Type** | **Default** | **Description** |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **类型** | **默认值** | **描述** |'
- en: '| `activeIndex` | `number` | `0` | Index of the active step (two way binding)
    |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| `activeIndex` | `number` | `0` | 活动步骤的索引（双向绑定） |'
- en: '| `styleClass` | `string` | `null` | Style class of wizard''s container element
    |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '- `styleClass` | `string` | `null` | 向导容器元素的样式类'
- en: '| `stepClass` | `string` | `null` | Style class of each Step component |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '- `stepClass` | `string` | `null` | 每个步骤组件的样式类'
- en: '**Events**:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件**：'
- en: '| **Name** | **Parameters** | **Description** |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **参数** | **描述** |'
- en: '| `change` | `label`: Label of currently shown step | Callback invoked when
    switching steps |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| `change` | `label`：当前显示步骤的标签 | 切换步骤时调用的回调函数 |'
- en: 'Equipped with this knowledge, we can implement `StepComponent` and `StepsComponent`.
    The first one has `ng-content` in the template to be able to put custom content.
    The component class has two specified inputs. Furthermore, there is a property
    `active`, which indicates whether the step is currently shown:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 具有这些知识，我们可以实现`StepComponent`和`StepsComponent`。第一个在模板中有`ng-content`，以便放置自定义内容。组件类有两个指定的输入。此外，还有一个`active`属性，指示当前是否显示该步骤：
- en: '[PRE53]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The second component is more complicated. It iterates over child components
    of the type `StepComponent` and creates items in the life cycle method `ngAfterContentInit()`.
    The property `active` of the child component is set to `true` if it matches `activeIndex`.
    Otherwise, it is set to `false`. This allows to display exactly one step in the
    workflow. The complete listing would go beyond the size of this book. We will
    only show an excerpt:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个组件更复杂。它遍历类型为`StepComponent`的子组件，并在生命周期方法`ngAfterContentInit()`中创建项目。如果子组件的`active`属性与`activeIndex`匹配，则将其设置为`true`。否则，将其设置为`false`。这允许在工作流程中显示一个步骤。完整的清单将超出本书的篇幅。我们只会展示一部分：
- en: '[PRE54]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The fully implemented and documented components are available on GitHub at
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 完全实现和文档化的组件可在GitHub上找到
- en: '[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/primeng-extensions-wizard](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/primeng-extensions-wizard).'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/primeng-extensions-wizard](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/primeng-extensions-wizard)。'
- en: 'To make the implemented wizard distributable, we need to create `WizardModule`:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 要使实现的向导可分发，我们需要创建`WizardModule`：
- en: '[PRE55]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `WizardModule` class can be imported in any PrimeNG application as usually
    with `imports` inside `@NgModule`. A concrete usage example to the shown picture
    looks like as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`WizardModule`类可以像通常在`@NgModule`内部的`imports`一样在任何PrimeNG应用程序中导入。显示图片的具体用法示例如下：'
- en: '[PRE56]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The corresponding component implements the `next()` and `ok()` methods, and
    the event callback `onChange()`. To go forwards, you can simple write `next()
    {this.activeIndex++;}`. Consult the GitHub project for more details.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的组件实现了`next()`和`ok()`方法，以及事件回调`onChange()`。要前进，只需编写`next() {this.activeIndex++;}`。有关更多详细信息，请参阅GitHub项目。
- en: The wizard component can be published to the `npm` repository with `npm run
    update`. There is no running demo app and no `npm start` command in the project
    on GitHub.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 向导组件可以使用`npm run update`发布到`npm`存储库。在GitHub项目中没有运行演示应用程序和`npm start`命令。
- en: Introduction to state management with @ngrx/store
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用@ngrx/store进行状态管理的介绍
- en: State management in large Angular applications was a weak point over the last
    few years. In AngularJS 1, the state management is often done as a mix of services,
    events, and `$rootScope`. In Angular 2+, the application state and data flow are
    cleaner but there is still no unified state management in Angular core. Developers
    often use *Redux--*a predictable state container for JavaScript applications ([http://redux.js.org](http://redux.js.org)).
    The Redux architecture is best known for its use with the *React* library ([https://facebook.github.io/react](https://facebook.github.io/react)),
    but it can be utilized with Angular too. One of the popular Redux-like state containers
    designed for Angular is *ngrx/store* ([https://github.com/ngrx/store](https://github.com/ngrx/store)).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，大型Angular应用程序中的状态管理是一个薄弱点。在AngularJS 1中，状态管理通常是作为服务、事件和`$rootScope`的混合来完成的。在Angular
    2+中，应用程序状态和数据流更清晰，但在Angular核心中仍然没有统一的状态管理。开发人员经常使用*Redux*--JavaScript应用程序的可预测状态容器（[http://redux.js.org](http://redux.js.org)）。Redux架构最为人所知的是与*React*库（[https://facebook.github.io/react](https://facebook.github.io/react)）一起使用，但它也可以与Angular一起使用。为Angular设计的一种流行的类似Redux的状态容器是*ngrx/store*（[https://github.com/ngrx/store](https://github.com/ngrx/store)）。
- en: Redux principles
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redux原则
- en: 'Redux follows three basic principles:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: Redux遵循三个基本原则：
- en: The whole state of the application is stored in a single immutable state tree
    called *store*. No state management is allowed outside the store. A central immutable
    store has a lot of benefits. You can improve the performance by using `ChangeDetectionStrategy.OnPush`
    because with immutable data, Angular only needs to check object references to
    detect changes. Furthermore, the undo/redo functionality is easy done.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序的整个状态存储在一个称为*store*的单个不可变状态树中。不允许在store之外进行状态管理。一个中心化的不可变存储有很多好处。您可以通过使用`ChangeDetectionStrategy.OnPush`来提高性能，因为使用不可变数据，Angular只需要检查对象引用来检测更改。此外，撤消/重做功能很容易实现。
- en: '*Actions* are used to send information from the application to the store. Only
    actions are source of information for the store. Actions are plain JavaScript
    objects having `type` and `payload` properties. The `type` property describes
    a kind of state change we want. The `payload` property is the data being sent
    to the store in order to update it.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Actions*用于将信息从应用程序发送到store。只有actions是store的信息来源。Actions是具有`type`和`payload`属性的普通JavaScript对象。`type`属性描述了我们想要的状态变化的类型。`payload`属性是要发送到store以更新它的数据。'
- en: State changes are made through pure functions called *reducers*. Pure functions
    are functions that don't mutate objects, but return brand new objects instead.
    We can grasp reducers as processing steps in the store that allow state transitions.
    The reducer operates on the current state and returns a new state.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态变化是通过称为*reducers*的纯函数进行的。纯函数是不会改变对象的函数，而是返回全新的对象。我们可以将reducers看作是存储中的处理步骤，允许状态转换。Reducer在当前状态上操作并返回一个新状态。
- en: In general, the data flow is bi-directional. User inputs in one component can
    affect other components and vice versa. The data flow in Redux applications is
    uni-directional. Changes in the view trigger actions. Actions are dispatched to
    the store. Reducers perform state changes in response to actions by taking the
    previous state with the dispatched action and returning the next state as a new
    object.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，数据流是双向的。一个组件中的用户输入可能会影响其他组件，反之亦然。Redux应用程序中的数据流是单向的。视图中的更改触发操作。操作被分派到store。Reducers根据操作执行状态更改，通过采用先前的状态和分派的操作返回下一个状态作为新对象。
- en: '`Object.assign()` and the `spread` operator can help in returning new objects
    ([http://redux.js.org/docs/recipes/UsingObjectSpreadOperator.html](http://redux.js.org/docs/recipes/UsingObjectSpreadOperator.html)).'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.assign()` 和 `spread` 运算符可以帮助返回新对象（[http://redux.js.org/docs/recipes/UsingObjectSpreadOperator.html](http://redux.js.org/docs/recipes/UsingObjectSpreadOperator.html)）。'
- en: 'Several components can subscribe to the store to observe state changes over
    time and propagate them to the view. The following diagram memorizes described
    Redux principles:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 多个组件可以订阅存储以观察随时间的状态变化并将其传播到视图。以下图表记忆了所述的 Redux 原则：
- en: '![](assets/303e29da-5ae2-4124-8a37-e878191e1794.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/303e29da-5ae2-4124-8a37-e878191e1794.png)'
- en: 'A classic Redux store provides two important APIs to:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的 Redux 存储提供了两个重要的 API：
- en: Dispatch actions using `store.dispatch(action)`
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `store.dispatch(action)` 分发操作
- en: Register listeners for change notification using `store.subscribe(callback)`
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `store.subscribe(callback)` 注册更改通知的监听器
- en: As you see, if you use a Redux store, you don't need to synchronize the state
    between components manually.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，如果您使用 Redux 存储，您不需要手动在组件之间同步状态。
- en: A predictable state management allows to debug applications with co, called
    time-travelling debugger. You need to install `store-devtools` ([https://github.com/ngrx/store-devtools](https://github.com/ngrx/store-devtools))
    with an appropriate Chrome extension.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 可预测的状态管理允许使用 co 调试应用程序，称为时间旅行调试器。您需要安装 `store-devtools`（[https://github.com/ngrx/store-devtools](https://github.com/ngrx/store-devtools)）以及适当的
    Chrome 扩展。
- en: CRUD application with @ngrx/store
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 @ngrx/store 的 CRUD 应用程序
- en: 'For a practical example, we will reuse the same CRUD sample implementation
    from the section *CRUD sample implementation with DataTable*. Start off by adding
    the `ngrx` dependencies for a Redux-based application:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个实际的例子，我们将重用“使用 DataTable 实现 CRUD 示例”部分中的相同 CRUD 示例实现。首先添加 Redux-based 应用程序的
    `ngrx` 依赖项：
- en: '[PRE57]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'First of all, we need to define a shape for the store. In real applications,
    most likely available employees and currently selected employee might be shared
    across several components. Hence the store could be defined as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要为存储定义一个形状。在实际应用中，最有可能可用的员工和当前选择的员工可能会在多个组件之间共享。因此，存储可以定义如下：
- en: '[PRE58]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Next, we need to define actions which consist of types and optional payloads.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义由类型和可选载荷组成的操作。
- en: 'The best practice is to create *Action Creator Services* encapsulating associated
    actions:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践是创建封装相关操作的 *Action Creator Services*：
- en: '[https://github.com/ngrx/ngrx.github.io/blob/master/store/recipes/actions/action_services.md](https://github.com/ngrx/ngrx.github.io/blob/master/store/recipes/actions/action_services.md)'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/ngrx/ngrx.github.io/blob/master/store/recipes/actions/action_services.md](https://github.com/ngrx/ngrx.github.io/blob/master/store/recipes/actions/action_services.md)'
- en: 'We will create the service `CrudActions` with four CRUD actions and associated
    action creators:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建名为 `CrudActions` 的服务，其中包含四个 CRUD 操作和相关的操作创建者：
- en: '[PRE59]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The core part is the reducer. The reducer function takes a state and an action
    and then uses a `switch` statement to return a new state depending on the action
    type. The current state will not be mutated:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 核心部分是 reducer。reducer 函数接受状态和操作，然后使用 `switch` 语句根据操作类型返回新状态。当前状态不会被改变：
- en: '[PRE60]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: As you can see, there is also a `default` switch statement which just returns
    the current state in case the provided action doesn't match any of the predefined
    actions.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，还有一个 `default` 开关语句，它只是在提供的操作不匹配任何预定义操作时返回当前状态。
- en: 'Now, we can configure `AppModule` with the `ngrx/store` module. It is done
    by importing the `StoreModule` that should call the `provideStore` method with
    the name of our reducer:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 `ngrx/store` 模块配置 `AppModule`。通过导入 `StoreModule`，应该调用 `provideStore`
    方法并提供我们的 reducer 的名称：
- en: '[PRE61]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Generally, you can provide multiple reducers as well. An example is shown here:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您也可以提供多个reducer。这里显示了一个示例：
- en: '[PRE62]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Internally, `@ngrx/store` uses the `combineReducers` method to create a *meta-reducer*
    which calls the specified reducers with the correct state slice.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，`@ngrx/store`使用`combineReducers`方法创建一个*meta-reducer*，该方法使用正确的状态片段调用指定的reducer。
- en: 'The last step is dispatching the actions and selecting the data. We can inject
    `CrudActions` into `EmployeeService` and create corresponding actions for every
    CRUD operation. Return values are of the type `Observable<Action>`:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是分派操作并选择数据。我们可以将`CrudActions`注入`EmployeeService`并为每个CRUD操作创建相应的操作。返回值的类型为`Observable<Action>`：
- en: '[PRE63]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'In the component class, we receive actions and dispatch them by calling `store.dispatch(action)`.
    Dispatching the actions will only be demonstrated for two CRUD operations: loading
    all employees and removing one employee:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件类中，我们通过调用`store.dispatch(action)`来接收操作并分派它们。操作的分派仅将演示两个CRUD操作：加载所有员工和删除一个员工：
- en: '[PRE64]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Selecting the data in `@ngrx/store` is achieved by calling `store.select()`.
    The `select` method expects a name of the reducer function to select slice(s)
    of state for displaying in view(s). The return value of the `select` method is
    `Observable`, which allows subscription to the store''s data. The next code snippet
    demonstrates such subscription:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在`@ngrx/store`中选择数据是通过调用`store.select()`来实现的。`select`方法期望选择要在视图中显示的状态片段的reducer函数的名称。`select`方法的返回值是`Observable`，它允许订阅存储的数据。下一个代码片段演示了这样的订阅：
- en: '[PRE65]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The lifecycle method `ngOnInit` is a good place for subscriptions.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期方法`ngOnInit`是订阅的好地方。
- en: The complete demo application with instructions is available on GitHub at
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的演示应用程序及说明可在GitHub上找到
- en: '[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/redux](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/redux).'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/redux](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/redux).'
- en: Summary
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you have learned more PrimeNG components and directives for
    various use cases. The chapter explained interesting features of FileUpload, Draggable,
    Droppable, Galleria, Defer, BlockUI, ProgressBar, and more. You have seen a real-world
    implementation of CRUD application with DataTable and mocked backend. A best practice
    with ConfirmationDialog and guarded routes was demonstrated as well. After reading
    this chapter, you are equipped with necessary knowledge to be able to create different
    custom components for the next few Angular and PrimeNG web applications. The Redux
    architecture is not a foreign concept anymore. You are best prepared for an advantageous
    state management in complex web applications.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经学习了更多用于各种用例的PrimeNG组件和指令。本章解释了FileUpload、Draggable、Droppable、Galleria、Defer、BlockUI、ProgressBar等有趣的功能。您已经看到了使用DataTable和模拟后端实现CRUD应用程序的实际示例。还演示了使用ConfirmationDialog和受保护的路由的最佳实践。阅读完本章后，您将具备必要的知识，能够为接下来的几个Angular和PrimeNG
    Web应用程序创建不同的自定义组件。Redux架构不再是一个陌生的概念。您已经为复杂的Web应用程序中有利的状态管理做好了准备。
- en: The next chapter gives an introduction to the unit and e2e testing with modern
    frameworks. You will learn how to test and debug Angular applications. Tips on
    test-driven development will not be missing either.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍使用现代框架进行单元测试和端到端测试。您将学习如何测试和调试Angular应用程序。测试驱动开发的技巧也不会缺席。
