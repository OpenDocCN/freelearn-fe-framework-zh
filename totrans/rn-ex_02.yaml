- en: Advanced Functionality and Styling the To-Do List App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having built an MVP for `Tasks`, our to-do list app, it''s time to delve into
    building out advanced functionality, and styling the application to make it look
    nice. This chapter will explore the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing the `NavigatorIOS` component to build an edit screen to add details
    to a task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking in a date and time for tasks to be due with `DatePickerIOS`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom collapsible component for our app and utilizing `LayoutAnimation`
    to give us fluid transitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a `Button` component for our UI to clear a to-do item's due date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving the data of an edited task and rendering a due date, if applicable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Porting the application over to Android, swapping out `DatePickerIOS` for `DatePickerAndroid`
    and `TimePickerAndroid` and `NavigatorIOS` for `Navigator`, and exploring the
    control flow in deciding which component is used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigator and NavigatorIOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing navigation in a mobile application helps us control how our users
    interact with and experience our apps. It lets us assign context to situations
    that would otherwise not have any--for example, in `Tasks`, it will not make sense
    to show a user an edit view for a task that they haven't selected; only showing
    this to the user when they select a task to edit builds situational context and
    awareness.
  prefs: []
  type: TYPE_NORMAL
- en: React Native's `Navigator` component handles the transitions between different
    views in your application. Glancing at the documentation, you may note that there's
    both a `Navigator` and `NavigatorIOS` component. `Navigator` is available on iOS
    and Android and implemented with JavaScript. On the other hand, `NavigatorIOS`
    is specifically available for iOS and is a wrapper around iOS's native `UINavigationController`,
    animating it and behaving the way you would expect from any iOS application.
  prefs: []
  type: TYPE_NORMAL
- en: Later in this chapter, we will take a closer look at the Navigator.
  prefs: []
  type: TYPE_NORMAL
- en: An important note about NavigatorIOS
  prefs: []
  type: TYPE_NORMAL
- en: While `NavigatorIOS` supports UIKit animations and is a great choice for building
    the iOS version of `Tasks`, one thing to keep in mind is that `NavigatorIOS` happens
    to be a community-driven component of the React Native SDK. Facebook has openly
    stated from the beginning that it utilizes `Navigator` heavily in its own applications,
    but all support for future improvements and additions to the `NavigatorIOS` component
    will come directly from open source contributions.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at NavigatorIOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `NavigatorIOS` component is set up at the top level of your React Native
    app. We''ll provide at least one object, identified as `routes`, in order to identify
    each view in our app. Additionally, `NavigatorIOS` looks for a `renderScene` method,
    which is responsible for rendering each scene in our app. Here''s an example of
    how you can render a basic scene with `NavigatorIOS`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is just a rudimentary example. All we''re doing is initializing the `NavigatorIOS`
    component and rendering it as a basic route with a simple `text` component. What
    we''re really interested in doing is switching between `routes` to edit a task.
    Let''s break down this goal into a number of subtasks that are easier to tackle:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `EditTask` component. It can start off as a simple screen with
    some filler info on it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up `NavigatorIOS` to route to `EditTask` when a task is long-pressed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build logic for `EditTask` to accept the exact task as a prop in the component
    to render task-specific data. Add appropriate input fields to allow this component
    to be marked as complete from the edit screen as well as for it to have the ability
    to set a due date and tag.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When edits are saved, add logic to save the edited data to `AsyncStorage`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll take some time to complete each step and go over them when necessary.
    Take a few minutes to build a simple `EditTask` component, and then refer to how
    I built mine.
  prefs: []
  type: TYPE_NORMAL
- en: A simple EditTasks component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In my application folder structure, my `EditTasks` component is nested as such:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a basic component just to have something appear on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code returns text to render to the screen for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now comes the fun part. Let''s set up `NavigatorIOS` to play nicely with `TasksList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we should modify `TasksList` so that it:'
  prefs: []
  type: TYPE_NORMAL
- en: Adds a function, called `_editTask`, to push the `EditTask` component to the
    Navigator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passes the `_editTask` function into `TasksListCell` as a prop, titled `onLongPress`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, we should modify `EditTask` so that the `TouchableHighlight` component
    in its `render` method calls this prop during its own `onLongPress` callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We added a Boolean set to disable the automatic adjustment of content insets.
    With this defaulting to `true`, we saw an inset of `~55px` between our `Input`
    and `ListView` components. In our styling for both this component and `EditTask`,
    we started importing the `Navigator` component.
  prefs: []
  type: TYPE_NORMAL
- en: This is so that we can set the `paddingTop` property of our container to take
    into consideration the height of the navigation bar so that content is not left
    tucked behind the navigation bar. The reason this happens is because the navigation
    bar is rendered over our components after they are done loading.
  prefs: []
  type: TYPE_NORMAL
- en: 'Call the `push` method of `NavigatorIOS`, rendering the `EditTask` component
    that we just imported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Assign `TasksListCell` a callback, titled `onLongPress`, that executes the
    `_editTask` method we just defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Setting the `paddingTop` property to the height of the Navigator solves the
    issue of our navigation bar hiding the content of our app behind it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Using DatePickerIOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A key feature in `Tasks` is the ability to set a reminder for when a task is
    due. Ideally, our users can set a day as well as a time for when a task should
    be completed so that they can be reminded of the due date. To accomplish this,
    we'll use an iOS component named `DatePickerIOS`. This is a component that renders
    a date and time selector that we can utilize in our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listed here are the two props that we will be using with our `DatePickerIOS`
    component. Other props exist in the React Native documentation in case you are
    interested:'
  prefs: []
  type: TYPE_NORMAL
- en: '`date`: This is one of the two required props that track the current selected
    date. Ideally, this information is stored within the state of the component that
    renders `DatePickerIOS`. The `date` should be an instance of the `Date` object
    in JavaScript.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onDateChange`: This is the other required prop and is fired when a user changes
    the `date` or `time` in the component. It accepts one argument, which is the `Date`
    object representing the new date and time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s how a simple `DatePicker` component looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: It creates a new instance of the JavaScript `Date` object and saves it to state.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This results in rendering a `DatePickerIOS` component using the `date` value
    in the component state as its prop of the same name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The callback to change the `date` in the component state when the user interacts
    with the `DatePickerIOS` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how the `DatePicker`, when rendered, will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_001-1.png)'
  prefs: []
  type: TYPE_IMG
- en: This leaves a lot to be desired. For one, the `DatePickerIOS` component is always
    visible! Normally, when we interact with this type of selector in iOS applications,
    it is collapsed and only expands when tapped on. What we want is to replicate
    that exact experience, that is, render a touchable row that either displays the
    current set due date or something along the lines of *No Due Date Set*, animating
    the expansion of `DatePickerIOS` when the row is tapped on.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a collapsible component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our collapsible component should accomplish the following goals:'
  prefs: []
  type: TYPE_NORMAL
- en: It should show and hide other components passed to it when tapped on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An animation will accompany this component, adding to the user experience of
    our app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The component should not make any assumptions about the type of data it is showing
    and hiding; it should not be strictly specific to `DatePickerIOS` in case we want
    to reuse the component for other purposes in the future
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll need to take advantage of React Native's fantastic `LayoutAnimation` API,
    which is designed to let us create fluid and meaningful animations.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, I''ve created an `ExpandableCell` component within the `components`
    folder of our project, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The LayoutAnimation API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our goal is to tap on the `date`/`time` component in `EditTask` and then have
    it expand downward to reveal the hidden `DatePickerIOS` component. React Native
    has an API, called `LayoutAnimation`, that allows us to create automatically animating
    layouts.
  prefs: []
  type: TYPE_NORMAL
- en: '`LayoutAnimation` comes with three methods representing default animation curves:
    `easeInEaseOut`, `linear`, and `spring`. These dictate how the animation behaves
    throughout its transition. You can simply call one of the three methods under
    the `componentWillUpdate` life cycle method and, should a change in your component''s
    state trigger a rerender, `LayoutAnimation` will add its animation to your changes.'
  prefs: []
  type: TYPE_NORMAL
- en: To hide and show the children components passed to `ExpandableCell`, I can manipulate
    its `maxHeight` style based on whether or not the component should be shown or
    hidden. Additionally, I can hide the component when not needed by setting its
    `overflow` property to `hidden`.
  prefs: []
  type: TYPE_NORMAL
- en: Take some time to hide the children components passed into `ExpandableCell`
    and set up some logic to show and hide this content as needed. When you're ready,
    look at my implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Basic ExpandableCell implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is how we can start building `ExpandableCell`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This sets the `title` as an expected string `PropTypes` for the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we track a Boolean named `expanded` in the component `state`. By default,
    our child components should not be visible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the `LayoutAnimation` style for whenever this component changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Wrap a `TouchableHighlight` component around the `Text` of the `ExpandableCell`.
    It calls `_onExpand` when pressed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a ternary operator to add a `maxHeight` property to the styling of this
    `View` in the event that the component is not expanded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This renders any children nested within the component itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a callback to toggle the `expanded` Boolean in the component
    state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the styling for `ExpandableCell`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'A basic implementation of this in `EditTask` will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Render an ExpandableCell component with a title:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Nest `DatePickerIOS` within `ExpandableCell` so that it initially stays hidden:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Ideally, this component will show one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The due date of the selected task, if it exists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A blank placeholder to select a date if a due date does not exist
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ll worry about things such as clearing the due date later but, for now,
    we should modify `EditTask` so that the `title` prop it passes to `ExpandableCell`
    is dependent on whether the task has a due date assigned to it or not. This is
    how the component should currently look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_002-1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is how I solved the problem. The only file changed since the last example
    is the `EditTask` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Set two strings to show the `title` prop for `ExpandableCell`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Use a ternary operator to decide which string to pass in to `ExpandableCell`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'I also imported `moment` from `npm` to use its powerful date formatting capabilities.
    Moment is a very popular, widely-used library that allows us to manipulate dates
    with JavaScript. Installing it was as simple as opening the Terminal to the project''s
    root folder and typing as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The MomentJS library is well documented and its main page, found at [https://
    momentjs.com](https://www.momentjs.com), will show you all the ways you can utilize
    it. For this file, I used Moment's the format method and set the formatting to
    show an abbreviated month name, followed by the day and year in numbers and the
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 'A sample Moment date formatted with the `''lll''` flag will appear like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: There are different ways to format your dates with Moment, and I would encourage
    you to play around with the library to find a date format that works best for
    you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Set `dateSelected` to `true` and add the Moment-formatted version of the date
    to state, which in turn fires the `render` method of this component again to update
    the `title` string passed into `ExpandableCell`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'By the end of this section, your app should look something like the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_003-1.png)'
  prefs: []
  type: TYPE_IMG
- en: Using onLayout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our preceding example, we don't need to specify the height of the `DatePickerIOS`
    component when expanded. However, there may be scenarios in which you may need
    to manually get the dimensions of a component.
  prefs: []
  type: TYPE_NORMAL
- en: 'To calculate a component''s height, we can utilize its `onLayout` property
    to fire a callback and then use that callback to save properties passed to the
    callback. The `onLayout` property is an event that is invoked on mount and layout
    changes, giving the event object a `nativeEvent` object that nests the component''s
    layout properties. Using `DatePickerIOS` as an example, you can pass a callback
    to its `onLayout` prop like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `event` from `onLayout` gives access to the following property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Button
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's build a *clear due date* button for the `EditTask` component and only
    selectively enable it if a due date has been selected for the to-do item. The
    `Button` component in React Native should help us render one quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Button` component accepts a couple of props; the following four will be
    used in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '`color`: This is a string (or stringified hex) that sets either the text color
    on iOS or the background color on Android'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`disabled`: This is a Boolean that disables the button if set to `true`; it
    defaults to `false`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onPress`: This is a callback that is fired when a button is pressed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`title`: This is the text to display within the button'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A sample `Button` component can be rendered like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify `EditTask` so that it has the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: It contains a Boolean, titled `expanded`, in its state to control the open/closed
    status of the `ExpandableCell`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It modifies the rendering of `ExpandableCell` to accept the `expanded` and `onPress`
    props. The `expanded` prop should point to the `expanded` Boolean in `EditTask's`
    state and the `onPress` prop should fire a method that flips the `expanded` Boolean.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add an `onLayout` callback to `DatePickerIOS` to calculate its height, saving
    it to state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Include a `Button` component with a `title` prop that prompts the user to clear
    the due date. Give it an `onPress` prop that will clear the `dateSelected` Boolean
    in state. Also, selectively disable it if the `dateSelected` Boolean is set to
    `false`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clearing due date example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s what I did to get the button to clear a selected date and expand/collapse
    our cells to play nicely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: I wrapped a new `View` around `ExpandableCell`. Its styling is modified based
    on the expanded `Boolean` in the state of `EditTask`. If the component is expanded,
    then its `maxHeight` property is set to the height of its child component. Otherwise,
    it is set to `40` pixels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, pass in the `expanded` and `onPress` props to this component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Call `_getDatePickerHeight` during the `onLayout` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Button` component is also encapsulated in its own `View`. This is so that
    the `Button` and `ExpandableCell` stack on top of each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the `dateSelected` Boolean in state to `false`, changing the `title` that
    `ExpandableCell` is passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This saves the width of the `DatePickerIOS` component to state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'I added a `clearDateButtonContainer` style to this component''s `StyleSheet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Let's continue working on this and build a couple more features into this screen.
    Next up, we should have a field to edit the name of the task at the very top followed
    by a `Switch` component to toggle a complete or an incomplete state for the task.
  prefs: []
  type: TYPE_NORMAL
- en: Switch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Switch is a component that renders a Boolean input and allows the user to toggle
    back and forth.
  prefs: []
  type: TYPE_NORMAL
- en: 'With `Switch`, these are the props that we will use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onValueChange`: This is a callback that is invoked with the new value of the
    switch when the value changes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value`: This is a Boolean that determines whether the switch is set to its
    ''on'' position or not; it defaults to `false`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A simple `Switch` component can look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'As stated earlier, `Switch` has two props that are required: its `value` and
    a callback to change its value when toggled.'
  prefs: []
  type: TYPE_NORMAL
- en: Using this knowledge, let's make changes to the `TasksList` component so that
    it passes the `completed`, `due`, `formattedDate`, and `text` properties of each
    row to the `EditTask` component for use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, make additions to the `EditTask` component so that it:'
  prefs: []
  type: TYPE_NORMAL
- en: Expects the `completed`, `due`, `formattedDate`, and `text` props as part of
    its `propTypes` declaration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contains a `TextInput` field that is preloaded with the name of the to-do list
    item and allows the user to edit the name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adds a `Switch` component that is preloaded with the completion status of the
    to-do list item. When toggled, its completion status should change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is the solution that I came up with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Pass in the four required fields for `EditTask` so that the view has access
    to rendering a to-do list item's existing details. If the row does not contain
    one or more of these fields, it will pass in `undefined`.
  prefs: []
  type: TYPE_NORMAL
- en: Declare the four `propTypes` that this component expects. Since `completed`
    and `text` are the only two that are set when a to-do list item is created by
    the app, they are marked as the required props.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Using `props` in state is considered an anti-pattern, but we have them here
    for good reason since we will be modifying these as part of the component.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will also create a Save button that lets us save the
    to-do item's updated details, and so we need a locally available copy of that
    data in state to reflect the `EditTask` component's changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Render a `TextInput` component to handle changing a to-do list item''s name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Render the `Switch` below `ExpandableCell` but above the clear due date `Button`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The following callback methods change the values of `TextInput` and `Switch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'A few styling additions for the new components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Save button
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will create a button in the upper-right corner of the navigation
    bar that is labeled as `Save`. When it is tapped on, the following two things
    must happen:'
  prefs: []
  type: TYPE_NORMAL
- en: The changes the user made to the to-do item (such as its name, completion status,
    and due date) must be saved to `AsyncStorage`, overwriting its previous details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `TasksList` must be updated so that the user visually sees the changes they
    made right away
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rendering the `Save` button is easy with React Native. The object that gets
    pushed to `NavigatorIOS` needs to receive the following two key/value pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`rightButtonTitle`: This is a string that renders the text shown in that area'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onRightButtonPress`: This is a callback that is fired when that button is
    pressed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At face value, this looks simple. However, we can't pass any information to
    the `onRightButtonPress` method of `NavigatorIOS` from a rendered child. Instead,
    we have to keep a copy of the changes we make inside our `TasksList` component
    as well, and update them as the `DatePickerIOS`, `TextInput`, and `Switch` components
    within `EditTask` are updated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This is no longer an asynchronous function. The part of the function that took
    advantage of `async`/`await` is broken off into `_saveAndUpdateSelectedTask`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the currently edited task object to state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an `onRightButtonPress` callback and string for the right button''s title:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Pass in four new functions to `EditTask` that deal with the item''s details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Add arguments for `_editTask` to accept:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the logic previously found in `componentDidMount`. It was broken into
    its own function since `_saveCurrentEditedTask` needs to call it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'To save the current edited task, we pass the object and `rowID` to `_saveAndUpdateSelectedtask`,
    and then call `pop` on the navigator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This function updates the `date` and `formattedDate` of the current edited
    task object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function accepts a key and value, creates a clone of `currentEditedTaskObject`
    with the new value, and sets it in state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The last two functions'' purpose is to update the `TasksList` local state copy
    of the object being edited. This is done for two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Any updates we make to `EditTask`, such as changing the name, completion status,
    and due date, currently do not propagate up to its parent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, we can't just point the values in `EditTask` to what gets passed
    in as props since the `EditTask` component does not rerender whenever the props
    being passed to it change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EditTask` gets a couple of changes including new `propTypes` for the component
    to expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The changes that `EditTask` receives involve calling the functions that are
    passed to it as props to update the parent component''s data for saving:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: TasksListCell modifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, we want to edit each row rendered by our `ListView` to display the
    due date, if one exists.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we will have to write some conditional logic to show the formatted
    date, if one is assigned to the to-do item we are rendering. This is also a good
    time to create a custom `styles` folder for this component as we will be needing
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spend some time creating your version of this feature. My solution is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: You might notice from the above import statement that `TasksListCell` now imports
    its `StyleSheet`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add `formattedDate` to `propTypes` as an optional string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Call `_getDueDate` to render a string for the due date, if it exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This component has been modified to support a second line of text to show a
    due date, but only if it exists.
  prefs: []
  type: TYPE_NORMAL
- en: The logic is set to only display the due date should the task not be marked
    as completed, so that a user won't be confused if they see a due date on a task
    they've already checked off.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, styling''s been added to make the two lines appear on the same
    row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a screenshot of how this looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_005-1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is a pretty neat application at this point, and you will be able to make
    more enhancements to it with the skills you''ll pick up in our next project. As
    we wind down this project, I want to turn your attention to a question I often
    receive:'
  prefs: []
  type: TYPE_NORMAL
- en: How would we do it on Android?
  prefs: []
  type: TYPE_NORMAL
- en: It's a great question and one that we will explore at the end of each project
    in this book. I will assume that you have already set up your development environment
    to work on Android apps in React Native. If not, go do that before proceeding
    further. If developing for Android is not of any interest to you, feel free to
    skip this portion and move on to the next chapter!
  prefs: []
  type: TYPE_NORMAL
- en: Modifying tasks for Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we need to point to the Android SDK directory in our app''s `Android`
    folder under a new `local.properties` file that you will create. Add the following
    line, where `USERNAME` is your machine''s username:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: If your Android SDK is installed in a different location from the preceding
    example, you will need to modify this file to point to the right place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, launch an **Android Virtual Device** (**AVD**) and execute the `react-native
    run-android` command in your project''s root folder. You will see the following
    screen, which looks just like the default template when we first built `Tasks`
    for iOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_006-1.png)'
  prefs: []
  type: TYPE_IMG
- en: When working in Android, press `RR` to reload the app and *Command* + *M* to
    enter the Developer menu.
  prefs: []
  type: TYPE_NORMAL
- en: You may find that, with remote JS debugging turned on, animations from simple
    things, such as `TouchableHighlight` shadows and navigation, can be painfully
    slow. At the time of writing, some technical solutions are being proposed to address
    this issue but, for the time being, it's strongly recommended that you enable
    and disable remote JS debugging as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Navigator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Navigator` component works a bit differently from its native iOS component,
    but it''s still very powerful to work with. One of the changes with using `Navigator`
    is that your routes should be explicitly defined. We can do this by setting up
    an array of routes and rendering a specific scene based on which route we''re
    accessing. Here''s a sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Create a `routes` array, as shown in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might notice that we are explicitly defining our routes from the beginning,
    setting up an initial route and then passing in props to each route''s component
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The route object passed in to `_renderScene` contains a `passProps` object,
    which we can set when pushing the navigator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of passing our component when pushing into the `Navigator`, we pass
    it an `index`; this is where the `_renderScene` method of `Navigator` identifies
    which scene to show the user. Here is how pushing to the `Navigator` looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how we would use the Navigator component to push different routes.
    Notice that instead of passing a component like in in `NavigatorIOS`, we are passing
    the index of the route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: If you're comparing this to how we rendered `EditTask` in iOS, you'll note that
    we're not setting up our navigation bar at all. Android apps typically handle
    navigation through a combination of `Drawer` and `ToolbarAndroid` components that
    we will address in a later project. This will help our app by making it look and
    feel the way any Android app should.
  prefs: []
  type: TYPE_NORMAL
- en: Navigator example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code is an example for Navigator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Again, establish routes for our app.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Import the `Navigator` component and render it for the user. It starts at `index:``0`,
    which returns the `TasksList` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'It returns `TasksList` if the index is `0`. This is the default `route`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'If the route index is 1, return `EditTask`. It will receive the aforementioned
    props via the `passProps` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: At this stage, without making further modifications, we can create new to-do
    items and mark them as completed. However, because the `Navigator` component's
    push method accepts different arguments than the push method of iOS, we will need
    to create some conditional logic in the `TasksList` file to accommodate it.
  prefs: []
  type: TYPE_NORMAL
- en: Platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When your files have such little variance in the differences between their iOS
    and Android functionalities, it's okay to use the same file. Utilizing the `Platform`
    API, we can identify the type of mobile device the user is on and conditionally
    send them down a specific path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `Platform` API along with the rest of your React Native components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Then call its `OS` property within a component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: This lets us control the path our app takes and allows for a little bit of code
    reuse.
  prefs: []
  type: TYPE_NORMAL
- en: Android-specific filesIf we need to create a file that is supposed to only run
    on Android devices, simply name it `<FILENAME>.android.js`, just like the two
    index files. React Native will know exactly which file to build with, and this
    lets us create components that are platform-specific when we need to add a lot
    of logic that one universal `index.js` file shouldn't handle. Name files `<FILENAME>.ios.js`
    to set iOS-specific files too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `Platform` API, we can create conditional logic to decide how the
    `Navigator` should push the next component depending on the user''s platform.
    Import the `Platform` API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify the styling of `TextInput` based on the user''s platform so that it
    has a design language that resonates with its platform. On Android, it is usually
    displayed as a single underline without any border; so, we eliminate the border
    in the Android-specific styling of this component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'I changed the `_editTask` function to run conditional logic. If our platform
    is iOS, we call `_renderIOSEditTaskComponent`; otherwise, our platform must be
    Android and we call `_renderAndroidEditTaskComponent` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code pushes the `index` of `EditTask` to the Navigator. It passes
    the same props that the iOS version of the app previously passed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The contents of `_renderIOSEditTaskComponent` are the same as those that `_editTask`
    previously contained:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code we added a custom Android style for `TextInput`, omitting
    the border:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: DatePickerAndroid and TimePickerAndroid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setting a time and date on Android is much different from iOS. With iOS, you
    have a `DatePickerIOS` component that includes both the date and time. On Android,
    this is split into two native modals, `DatePickerAndroid` for the date and `TimePickerAndroid`
    for the time. It's not a component to render either, it's an asynchronous function
    that opens the modal and waits for a natural conclusion before applying logic
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To open one of these, wrap an asynchronous function around it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Both the `DatePickerAndroid` and `TimePickerAndroid` components return an object,
    and we can grab the properties of each object by using ES6 destructuring assignment,
    as shown in the preceding snippet.
  prefs: []
  type: TYPE_NORMAL
- en: As these components will render as modals by default, we also don't have any
    use for the `ExpandableCell` component that we built for the iOS version of the
    app. To implement Android-specific date and time pickers, we should create an
    Android-specific `EditTask` component to handle it.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than an expanding cell, we should create another `Button` component to
    open and close the dialog boxes.
  prefs: []
  type: TYPE_NORMAL
- en: In the example given in the following section, I cloned the iOS `index.js` file
    for `EditTask` and renamed it `index.android.js` before making changes to it.
    Any code that has not changed from the iOS version has been omitted. Anything
    that has been deleted has also been noted.
  prefs: []
  type: TYPE_NORMAL
- en: DatePickerAndroid and TimePickerAndroid example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Remove `DatePickerIOS` and `ExpandableCell` from the import statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'I removed the `expanded` Boolean from state in this component''s `constructor`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'This new `Button` for `DatePicker` calls `_showAndroidDatePicker` when pressed.
    It is placed right below `TextInput` and replaces `ExpandableCell`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'There have been no changes to the clear due date `Button`, but its styling
    has changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'An asynchronous function that calls `open` on `DatePickerAndroid` extracts
    the `action`, `year`, `month`, and `day`, sets them to state, and then calls `_showAndroidTimePicker`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the same strategy we used with `_showAndroidDatePicker` before,
    but calls `_onDateChange` at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new instance of the `Date` object using the five combined values that
    `DatePickerAndroid` and `TimePickerAndroid` return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'I removed `_getDatePickerHeight` and `_onExpand` since they pertain to parts
    of `EditTask` that are not available in the `Android` version of the app. I added
    some styling changes to this component as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Saving updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we aren't using a navigation bar with the Android version of the app, we
    should create a Save button that handles the same save logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we should modify `index.android.js` to pass a `saveCurrentEditedTask`
    prop to `EditTask` from the `TasksList` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, modify `TasksList` to pass the `_saveCurrentEditedTask` method to `EditTask`
    in `_renderAndroidEditTaskComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, modify the Android version of `EditTask` to contain a new `Button`
    that calls its `saveCurrentEditedTask` when pressed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add some styling with a new `saveButton` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: BackAndroid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last thing we need to handle is the back button. A universal back button,
    either a hardware or software implementation, is found on each Android device.
    We will need to use the `BackAndroid` API to detect back button presses and set
    our own custom functionality. If we don't do this, the back button will automatically
    close the app each time it is pressed.
  prefs: []
  type: TYPE_NORMAL
- en: To use it, we can add an event listener during the `componentWillMount` life
    cycle event that will pop the navigator when a back button press is detected.
    We can also remove the listener when the component is unmounted.
  prefs: []
  type: TYPE_NORMAL
- en: 'During `componentWillMount`, add an event listener to the `BackAndroid` API
    for a `hardwareButtonPress` event, firing `_backButtonPress` when triggered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove the same listener if the component is unmounted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Call `pop` on the navigator with `_backButtonPress`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This was a long chapter! We accomplished a lot of things. First, we used `NavigatorIOS`
    to establish custom routes and created a component to edit a to-do item's details,
    including marking it as completed and adding a due date.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we built a custom, reusable component with fluid animations to expand
    and collapse a child component, allowing `DatePickerIOS` to expand and collapse
    as needed. Afterward, we implemented logic to save the changes we make to a task
    using the navigation bar.
  prefs: []
  type: TYPE_NORMAL
- en: We also ported our app to support the Android operating system! We started by
    swapping out `NavigatorIOS` for `Navigator`, using the `Platform` API to trigger
    conditional logic depending on the type of mobile device our user is on, and creating
    iOS-and Android-specific components by appending `.android` and `.ios` to each
    index file.
  prefs: []
  type: TYPE_NORMAL
- en: We finished up the port to Android by rendering date and time pickers on Android,
    which are two separate popups, and creating a save button within our Android-specific
    `EditTask` component so that our users can save the changes they made. Finally,
    listening for back button presses with the `BackAndroid` API allowed our users
    to go back from editing a to-do item to the to-do list screen instead of leaving
    the app entirely.
  prefs: []
  type: TYPE_NORMAL
