<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Testing and Debugging</h1>
                </header>
            
            <article>
                
<p>Testing is crucial to building production-ready applications. In unit tests, we test a component independent of external sources to make sure it works as expected. Angular 2 has testing capabilities bundled with it out of the box. In this chapter, we will take a look at performing unit test on the following elements:</p>
<ul>
<li>Components</li>
<li>Services</li>
<li>Pipes</li>
<li>Directives</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Angular 2 testing tools</h1>
                </header>
            
            <article>
                
<p>Some of the tools that aid testing in Angular 2 are as follows:</p>
<ul>
<li>Jasmine</li>
<li>Karma</li>
<li>Protractor</li>
<li>Angular 2 testing platform</li>
</ul>
<p>Let's take a deeper look at each one of them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Jasmine</h1>
                </header>
            
            <article>
                
<p>Jasmine is an open source testing framework. It uses behavior-driven notation that brings about improved testing.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Main concepts of Jasmine</h1>
                </header>
            
            <article>
                
<p>Before we dig into so practical testing cases, here are some Jasmine concepts you should know:</p>
<ul>
<li><strong>Suites</strong>: These are written in and described by the <kbd>describe</kbd> blocks. They appear in the form of functions.</li>
<li><strong>Spec definitions</strong>: <kbd>it (string, function)</kbd> functions. The body of this function holds the actual assertions.</li>
<li><strong>Expectations</strong>: These are assertions that evaluate to a Boolean value. This is used to see if an input is equal to the expected value.</li>
<li><strong>Matchers</strong>:  These are helpers for common assertions, for example, <kbd>toB0</kbd> (expected), <kbd>toEqual</kbd> (expected).</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Karma</h1>
                </header>
            
            <article>
                
<p>Karma is a JavaScript test runner created by the Angular team. Karma can be a part of the continuous integration processes for a project as well as a part of its development.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Protractor</h1>
                </header>
            
            <article>
                
<p>Protractor is an end-to-end test framework for Angular applications. With Protractor, you can set up expectations and test against our assumptions. As the name implies, end-to-end tests not only ensure that the system works by itself but also validates its functionality with external systems. They explore the application as the end user experiences it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Angular testing platform</h1>
                </header>
            
            <article>
                
<p>Angular testing platform is used to test the interaction of classes with Angular and the DOM. Angular testing platform gives us liberty to examine an instance of a class without any dependence on Angular or injected values.</p>
<p>In this chapter, we will be focusing on Jasmine and Karma for testing.</p>
<p>When a new project is created using Angular-CLI, the <kbd>e2e</kbd> folder containing the end-to-end tests using Protractor is also created, along with the <kbd>karma.conf.js</kbd> and <kbd>protractor.conf.js</kbd> files, which are the configuration files for Karma and Protractor tests.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using Karma (with Jasmine)</h1>
                </header>
            
            <article>
                
<p>With Karma, you can test your code while running your application because Karma creates a browser environment for testing. Besides your browser, you can also test your code in other devices, such as phones and tablets.</p>
<p>Jasmine is a behavior-driven development framework for testing the JavaScript code. Being dependency free, Jasmine doesn't require a DOM and is often used together with Karma. We will now proceed to create a new project and test its elements.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a new project</h1>
                </header>
            
            <article>
                
<p>We will create a new project named <kbd>Angular-test</kbd> with the following command:</p>
<pre><strong>ng new Angular-test</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing the Karma CLI</h1>
                </header>
            
            <article>
                
<p>To install the Karma CLI, enter the following command:</p>
<pre><strong>npm install -g karma-cli</strong></pre>
<p>Our test will be executed in a <kbd>.spec.ts</kbd> file. Create a new test file (<kbd>sampletest.spec.ts</kbd>) in the <kbd>./app/</kbd> folder and copy the following:</p>
<pre>// ./app/sampletest.spec.ts<br/>describe('Sample Test', () =&gt; {<br/> it('true is true', () =&gt; expect(true).toBe(true));<br/> });<br/> <br/> import {AppComponent} from './app.component';<br/> <br/> describe('AppComponent', () =&gt; {<br/> beforeEach(function() {<br/> this.app = new AppComponent();<br/> });<br/> <br/> it('should have hello property', function() {<br/> expect(this.app.hello).toBe('Hello, World!');<br/> });<br/> });</pre>
<p>In the preceding code, we first write a sample test to showcase the main concepts in Jamine. We create a test suite, define our test suite, and write the expectations. In the sample test, we do a simple check to see that <kbd>true</kbd> is the same as <kbd>true</kbd>.</p>
<p>We also write a simple test for <kbd>AppComponent</kbd>. We expect the component to have a <kbd>hello</kbd> property that is equal to <kbd>Hello, World</kbd>. Let's ensure that the test passes by updating <kbd>app.component.ts</kbd>:</p>
<pre>private hello: string = 'Hello, World!';</pre>
<p>We have satisfied Karma's configuration by creating the file with the <kbd>.spec.ts</kbd> extension.</p>
<p>You can test several components as well. For example, when you create new components through Angular CLI, it automatically creates the test files (<kbd>.spec.ts</kbd>) for the components, which do nothing but test whether the components are working correctly together with the other components. For Angular, the convention is to have a <kbd>.spec.ts</kbd> file for each <kbd>.ts</kbd> file. The files are run using the Jasmine JavaScript test framework through the Karma task runner when you use the <kbd>ng test</kbd> command.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring Karma</h1>
                </header>
            
            <article>
                
<p>In order to configure our Karma, we need to update the <kbd>karma.conf.js</kbd> file. The default one has the following content:</p>
<pre>// ./karma.conf.js.<br/>module.exports = function (config) {<br/> config.set({<br/> basePath: '',<br/> frameworks: ['jasmine', 'angular-cli'],<br/> plugins: [<br/> require('karma-jasmine'),<br/> require('karma-chrome-launcher'),<br/> require('karma-remap-istanbul'),<br/> require('angular-cli/plugins/karma')<br/> ],<br/> files: [<br/> { pattern: './src/test.ts', watched: false }<br/> ],<br/> preprocessors: {<br/> './src/test.ts': ['angular-cli']<br/> },<br/> remapIstanbulReporter: {<br/> reports: {<br/> html: 'coverage',<br/> lcovonly: './coverage/coverage.lcov'<br/> }<br/> },<br/> angularCli: {<br/> config: './angular-cli.json',<br/> environment: 'dev'<br/> },<br/> reporters: ['progress', 'karma-remap-istanbul'],<br/> port: 9876,<br/> colors: true,<br/> logLevel: config.LOG_INFO,<br/> autoWatch: true,<br/> browsers: ['PhantomJS'],<br/> singleRun: false<br/> });<br/> };</pre>
<p>Here, we are showing that the PhantomJS browser will be used; Jasmine testing framework and Webpack will be used for bundling the files.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing the components</h1>
                </header>
            
            <article>
                
<p>Components are the centerpiece of Angular. They are the nucleus around which the rest of the framework is built. We'll explore what a component is, why it is important, and how to test it.</p>
<p>Our testing strategy revolves around verifying the correctness of the properties and methods of the classes that make up the components.</p>
<p>When writing unit tests for components, we initialize the component and inject any dependencies manually rather than bootstrapping the application.</p>
<p>The <kbd>TestBed</kbd> function will be used for testing the component, which is the main entry to all of Angular's testing interface. It will enable us to create our components for use in running unit tests.</p>
<p><kbd>TestBed</kbd> is the primary API for writing unit tests for Angular applications and libraries.</p>
<p>Create a new component named <kbd>sample</kbd>:</p>
<pre><strong>ng generate component sample</strong></pre>
<p>This automatically generates the <kbd>.ts</kbd> and <kbd>.spec.ts</kbd> files. We will also add some tests to the generated <kbd>.spec.ts</kbd> file to get a hang of how the testing works:</p>
<pre>//sample.component.ts<br/>import { Component, OnInit } from '@angular/core';<br/> <br/> @Component({<br/> selector: 'app-sample',<br/> templateUrl: './sample.component.html',<br/> styleUrls: ['./sample.component.css']<br/> })<br/> export class SampleComponent implements OnInit {<br/> title = 'Test Sample Component';<br/> constructor() { }<br/> ngOnInit() {<br/> }<br/> }</pre>
<p>Here is the updated test spec:</p>
<pre>//sample.component.spec.ts<br/><span>import { ComponentFixture, TestBed } from '@angular/core/testing';</span><br/><span>import { By } from '@angular/platform-browser';</span><br/><span>import { DebugElement } from '@angular/core';</span><br/><span>import { SampleComponent } from './sample.component';</span><br/><span>describe('SampleComponent (inline template)', () =&gt; {</span><br/><span>let component: SampleComponent;</span><br/><span>let fixture: ComponentFixture&lt;SampleComponent&gt;;</span><br/><span>// For Debugging HTML Elements</span><br/><span>let debug: DebugElement;</span><br/><span>let htmlElem: HTMLElement;</span><br/><span>beforeEach(() =&gt; {</span><br/><span>TestBed.configureTestingModule({</span><br/><span>declarations: [ SampleComponent ], // Our Test sample component</span><br/><span>});</span><br/><span>// Get the ComponentFixture</span><br/><span>fixture = TestBed.createComponent(SampleComponent);</span><br/><span>component = fixture.componentInstance; // SampleComponent test instance</span><br/><span>// CSS Element selector</span><br/><span>debug = fixture.debugElement.query(By.css('h1'));</span><br/><span>htmlElem = debug.nativeElement;</span><br/><span>});</span><br/><span>it('don't show any title on DOM until we call `detectChanges`', () =&gt; {</span><br/><span>expect(htmlElem.textContent).toEqual('');</span><br/><span>});</span><br/><span>it('should display original title', () =&gt; {</span><br/><span>fixture.detectChanges();</span><br/><span>expect(htmlElem.textContent).toContain(component.title);</span><br/><span>});</span><br/><span>it('should display a different test title', () =&gt; {</span><br/><span>component.title = Different Test Title';</span><br/><span>fixture.detectChanges();</span><br/><span>expect(htmlElem.textContent).toContain('Different Test Title');</span><br/><span>});</span><br/><span>});</span></pre>
<p>The <kbd>createComponent</kbd> method in <kbd>TestBed</kbd> creates an instance of the component. These tests tell Angular when to perform change detection through <kbd>fixture.detectChanges()</kbd> (which we received from <kbd>createComponent</kbd>). <kbd>TestBed.createComponent</kbd>, by default, doesn't trigger the change detection. This is why specific parts in our test won't show the changes on the DOM.</p>
<p>Making use of <kbd>ComponentFixtureAutoDetect</kbd> from <kbd>@angular/core/testing</kbd> enables you to apply auto detection globally:</p>
<pre>TestBed.configureTestingModule({<br/> declarations: [ SampleComponent ],<br/> providers: [<br/> { provide: ComponentFixtureAutoDetect, useValue: true }<br/> ]<br/> })</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing services</h1>
                </header>
            
            <article>
                
<p>Let's create a sample service. Our service has only one method that returns an array of the available users for the application:</p>
<pre>//a simple service<br/>export class UsersService {<br/>get() {<br/>return ['Ken', 'Mark', 'Chris'];<br/>}<br/>}</pre>
<p>We instantiate the service using the <kbd>beforeEach</kbd> method. This is a good practice even if we only have one spec. We are checking each individual user and the total count:</p>
<pre>describe('Service: UsersService', () =&gt; {<br/>let service;<br/>beforeEach(() =&gt; TestBed.configureTestingModule({<br/>providers: [ UsersService ]<br/>}));<br/>beforeEach(inject([UsersService], s =&gt; {<br/>service = s;<br/>}));<br/>it('should return available users', () =&gt; {<br/>let users = service.get();<br/>expect(users).toContain('en');<br/>expect(users).toContain('es');<br/>expect(users).toContain('fr');<br/>expect(users.length).toEqual(3);<br/>});<br/>});</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing using HTTP</h1>
                </header>
            
            <article>
                
<p>Let's start by creating a <kbd>users.serviceHttp.ts</kbd> file:</p>
<pre>// users.serviceHttp.ts<br/>export class UsersServiceHttp {<br/>constructor(private http:Http) { }<br/>get(){<br/>return this.http.get('api/users.json')<br/>.map(response =&gt; response.json());<br/>}<br/>}</pre>
<p>In this case it uses <kbd>http.get()</kbd> to fetch the data from a JSON file. We then used <kbd>Observable.map()</kbd> to transform the response into the final result using <kbd>json()</kbd>.</p>
<p>The difference that exists between this test and the previous one is the use of an asynchronous test:</p>
<pre>//users.serviceHttp.spec.ts<br/>describe('Service: UsersServiceHttp', () =&gt; {<br/>let service;<br/>//setup<br/>beforeEach(() =&gt; TestBed.configureTestingModule({<br/>imports: [ HttpModule ],<br/>providers: [ UsersServiceHttp ]<br/>}));<br/>beforeEach(inject([UsersServiceHttp], s =&gt; {<br/>service = s;<br/>}));<br/>//specs<br/>it('should return available users', async(() =&gt; {<br/>service.get().subscribe(x =&gt; {<br/>expect(x).toContain('en');<br/>expect(x).toContain('es');<br/>expect(x).toContain('fr');<br/>expect(x.length).toEqual(3);<br/>});<br/>}));<br/>})</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing using MockBackend</h1>
                </header>
            
            <article>
                
<p>A more sensible approach is to replace HTTP calls with a MockBackend. For doing this, we can use the <kbd>beforeEach()</kbd> method. This will allow us to mock our responses and avoid hitting the real backend, thereby boosting our tests:</p>
<pre>//users.serviceHttp.spec.ts<br/>describe('MockBackend: UsersServiceHttp', () =&gt; {<br/>let mockbackend, service;<br/>//setup<br/>beforeEach(() =&gt; {<br/>TestBed.configureTestingModule({<br/>imports: [ HttpModule ],<br/>providers: [<br/>UsersServiceHttp,<br/>{ provide: XHRBackend, useClass: MockBackend }<br/>]<br/>})<br/>});<br/>beforeEach(inject([UsersServiceHttp, XHRBackend], (_service, _mockbackend) =&gt; {<br/>service = _service;<br/>mockbackend = _mockbackend;<br/>}));<br/>//specs<br/>it('should return mocked response (sync)', () =&gt; {     <br/>  let response = ["ru", "es"];     <br/>  mockbackend.connections.subscribe(connection =&gt; {         <br/>    connection.mockRespond(new Response(new ResponseOptions({             <br/>     body: JSON.stringify(response)         <br/>    })));         <br/>   service.get().subscribe(users =&gt; {             <br/>     expect(users).toContain('ru');             <br/>     expect(users).toContain('es');             <br/>     expect(users.length).toBe(2);         <br/>   });     <br/> }); <br/>}); </pre>
<p>We made our mocked response. So, when we finally make the call to our service, it gets the expected results.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing a directive</h1>
                </header>
            
            <article>
                
<p>The directive decorator in Angular is used to decorate a class that has the responsibility of extending components in the DOM, based on the defined methods and logic.</p>
<p>Take this directive that changes the background, for example:</p>
<pre>import { Directive, HostBinding, HostListener } from '@angular/core';<br/><br/>@Directive({<br/>  selector: '[appBackgroundChanger]'<br/>})<br/>export class BackgroundChangerDirective {<br/><br/>  @HostBinding('style.background-color') backgroundColor: string;<br/><br/>  @HostListener('mouseover') onHover() {<br/>    this.backgroundColor = 'red';<br/>  }<br/><br/>  @HostListener('mouseout') onLeave() {<br/>    this.backgroundColor = 'inherit';<br/>  }<br/><br/>}</pre>
<p>We will be making use of an attribute directive, <kbd>logClicks</kbd>, which logs the number of clicks on the host element.</p>
<p>Let's create a <kbd>container</kbd> component. This will be our host, reproducing the events emitted by our directive:</p>
<pre>@Component({<br/> selector: 'container',<br/> template: `&lt;div log-clicks (changes)="changed($event)"&gt;&lt;/div&gt;`,<br/> directives: [logClicks]<br/> })<br/> export class Container {<br/> @Output() changes = new EventEmitter();<br/> changed(value){<br/> this.changes.emit(value);<br/> }<br/> }</pre>
<p>Here is the test spec:</p>
<pre>describe('Directive: logClicks', () =&gt; {<br/>let fixture;<br/>let container;<br/>let element;<br/>//setup<br/>beforeEach(() =&gt; {<br/>TestBed.configureTestingModule({<br/>declarations: [ Container, logClicks ]<br/>});<br/>fixture = TestBed.createComponent(Container);<br/>container = fixture.componentInstance; // to access properties and methods<br/>element = fixture.nativeElement; // to access DOM element<br/>});<br/>//specs<br/>it('should increment counter', fakeAsync(() =&gt; {<br/>let div = element.querySelector('div');<br/>//set up subscriber<br/>container.changes.subscribe(x =&gt; {<br/>expect(x).toBe(1);<br/>});<br/>//trigger click on container<br/>div.click();<br/>//execute all pending asynchronous calls<br/>tick();<br/>}));<br/>})</pre>
<p>The <kbd>beforeEach</kbd> method is <span>used to separate the logic for creating the component from the tests. </span>DOM API is recommended and is used to trigger the click on the container.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing a pipe</h1>
                </header>
            
            <article>
                
<p>Pipes in Angular are functions that can transform input data into a user-readable format. Here is an example of a custom pipe called <kbd>capitalise</kbd> in our <kbd>src</kbd> folder, using the standard <kbd>String.toUpperCase()</kbd>. This is just an example; Angular already has its own pipe for capitalization:</p>
<pre>//capitalise.pipe.ts<br/>import {Pipe, PipeTransform} from '@angular/core';<br/>@Pipe({<br/>name: 'capitalise'<br/>})<br/>export class CapitalisePipe implements PipeTransform {<br/>transform(value: string): string {<br/>if (typeof value !== 'string') {<br/>throw new Error('Requires a String as input');<br/>}<br/>return value.toUpperCase();<br/>}<br/>}</pre>
<p>The <kbd>capitalise.pipe.spec.ts</kbd> file will be as follows:</p>
<pre>describe('Pipe: CapitalisePipe', () =&gt; {<br/>let pipe;<br/>//setup<br/>beforeEach(() =&gt; TestBed.configureTestingModule({<br/>providers: [ CapitalisePipe ]<br/>}));<br/>beforeEach(inject([CapitalisePipe], p =&gt; {<br/>pipe = p;<br/>}));<br/>//specs<br/>it('should work with empty string', () =&gt; {<br/>expect(pipe.transform('')).toEqual('');<br/>});<br/>it('should capitalise', () =&gt; {<br/>expect(pipe.transform('wow')).toEqual('WOW');<br/>});<br/>it('should throw with invalid values', () =&gt; {<br/>//must use arrow function for expect to capture exception<br/>expect(()=&gt;pipe.transform(undefined)).toThrow();<br/>expect(()=&gt;pipe.transform()).toThrow();<br/>expect(()=&gt;pipe.transform()).toThrowError('Requires a String as input');<br/>});<br/>})</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Debugging</h1>
                </header>
            
            <article>
                
<p>Augury is a Chrome extension for debugging Angular applications, just like Batarang was used for debugging Angular 1 apps. Once installed, the extension is seen as a dev tool plugin that has features for testing out your Angular app's behavior.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Augury</h1>
                </header>
            
            <article>
                
<p>Augury inspects and visualizes the component tree with different properties of one or more components. Install the Augury tools from the Augury Chrome extension page, (<a href="https://chrome.google.com/webstore/detail/augury/elgalmkoelokbchhkhacckoklkejnhcd">https://chrome.google.com/webstore/detail/augury/elgalmkoelokbchhkhacckoklkejnhcd</a>) and click on the <span class="packt_screen">ADD TO CHROME</span> button. Once the installation is completed, the following steps need to be taken in order to work with Augury:</p>
<ul>
<li>Use <em>Ctrl</em> + <em>Shift</em> + <em>I</em> to open the Chrome Developer Tools window.</li>
<li>Click on Augury to open the tool. It displays menu options such as <span class="packt_screen">Component Tree</span>, <span class="packt_screen">Router Tree</span>, and <span class="packt_screen">NgModules</span>. </li>
</ul>
<p>The Augury icon can be seen in the top-right corner of your browser once it is installed.</p>
<p>Open it and you will see a list of currently loaded components in your application, sorted by their hierarchy. You can also see where they are located in the DOM. Any change made to a component will also be shown.</p>
<p>With this, it becomes easier for developers to get an insight on how their apps are performing and where the problems and bugs could be originating from:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" height="191" src="assets/17bb4831-72e8-4616-a777-c4bb6fc873da.png" width="384"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Augury features</h1>
                </header>
            
            <article>
                
<p>Let's look at some of the Augury features in detail.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Component tree</h1>
                </header>
            
            <article>
                
<p>This is the first view that is visible, which shows the loaded components belonging to the application:</p>
<div class="CDPAlignCenter CDPAlign"><strong><img class=" image-border" src="assets/e58b5b39-947e-488f-ae74-58e24c697d4c.png"/></strong></div>
<p>The component tree displays a hierarchical relationship of the components. More information about a component can also be shown by selecting each component:</p>
<div class="CDPAlignCenter CDPAlign"><strong><img class=" image-border" src="assets/1ad9bd8c-856a-4eff-83d2-b40511d3c783.png"/></strong></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Router tree</h1>
                </header>
            
            <article>
                
<p>The router tree displays information on how every component in your application tree is routed. It does this in a hierarchical order:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/b88681df-420b-4e8e-ab85-bb7422aea80a.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Source map</h1>
                </header>
            
            <article>
                
<p>It is noteworthy that the TypeScript code will show whether a source map file exists. In production, if no source map is found, only the compiled JavaScript code will be displayed, which may also be minified and difficult to read.</p>
<p>Clicking on <span class="packt_screen">Inject Graph</span> will display the dependency of components and services:</p>
<div class="CDPAlignCenter CDPAlign"><strong><img class=" image-border" src="assets/f9aaa886-20ea-4461-9cba-d00607c8b449.png"/></strong></div>
<p>It should be noted that for the Augury debugging to work, the application has to be set to the development mode.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>It is important to do unit tests because they run faster and we'll be able to get feedback faster. A good advantage of testing is that it helps against regressions (the changes that break existing code).</p>
<p>Debugging helps us identify and remove errors from our code. With Augury, developers can have visuals of the application through component trees and visual debugging tools. This makes debugging easier.</p>


            </article>

            
        </section>
    </body></html>