- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Mastering Reactivity with Angular Signals
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掌握使用 Angular Signals 的反应性
- en: Modern web applications thrive on reactivity, where data changes automatically,
    thereby triggering updates in the UI. Angular Signals, introduced in version 17,
    streamlines this process by offering a powerful and concise way to manage reactive
    data within your Angular applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现代网络应用依赖于反应性，数据自动更改，从而触发 UI 的更新。Angular Signals 在版本 17 中引入，通过提供一种强大且简洁的方式来管理
    Angular 应用程序中的反应性数据，简化了这一过程。
- en: This chapter delves into the core concepts, API functionalities, advantages,
    and relationship of Signals with RxJS. We will also see how we can improve the
    reactivity of our Recipe app further using Angular Signals.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入探讨了核心概念、API 功能、优势以及 Signals 与 RxJS 之间的关系。我们还将看到如何使用 Angular Signals 进一步提高我们的食谱应用的反应性。
- en: 'So, in this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将涵盖以下主要主题：
- en: Understanding the motivation behind Signals
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Signals 背后的动机
- en: Unveiling the Signal API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 揭示 Signal API
- en: Unlocking the Power of RxJS and Angular Signals
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解锁 RxJS 和 Angular Signals 的力量
- en: Integrating Signals into our recipe app
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Signals 集成到我们的食谱应用中
- en: Reactive data binding with Signals
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Signals 进行反应性数据绑定
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The source code for this chapter is available at [https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition/tree/main/Chap08](https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition/tree/main/Chap08)
    (this only includes the code related to the recipe app).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可在[https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition/tree/main/Chap08](https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition/tree/main/Chap08)（这仅包括与食谱应用相关的代码）找到。
- en: Understanding the motivation behind Signals
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Signals 背后的动机
- en: The main goal behind the Angular team’s introduction of Signals is to add more
    fine-grained reactivity to the framework. This new Signal-based reactive system
    marks a significant leap forward in the framework’s ability to handle dynamic
    data and user interactions. It offers a fresh approach to detecting and triggering
    changes within the framework, replacing the traditional approach that relies on
    Zone.js.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 团队引入 Signals 的主要目标是向框架添加更多细粒度的反应性。这个基于 Signal 的反应性系统标志着框架在处理动态数据和用户交互方面的重大飞跃。它提供了一种全新的方法来检测和触发框架内的更改，取代了依赖于
    Zone.js 的传统方法。
- en: The traditional Zone.js approach
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传统 Zone.js 方法
- en: Angular’s traditional change detection mechanism assumes that any event handler
    can potentially change any bound data to the template. That’s why, whenever an
    event happens in your Angular application, the framework scans all components
    and their data bindings for any potential changes. This can be a bit heavy-handed,
    especially for complex applications. For this reason, a more optimized mode `OnPush`
    change detection was introduced. This mode leverages the concepts of immutability
    and Observables, allowing Angular to significantly reduce the number of components
    it needs to check for updates. This was explored in [*Chapter 3*](B21180_03.xhtml#_idTextAnchor047),
    *Fetching Data* *as Streams*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 的传统变更检测机制假设任何事件处理程序都可能更改绑定到模板的任何数据。这就是为什么，每当您的 Angular 应用程序中发生事件时，框架都会扫描所有组件及其数据绑定，以查找任何潜在的变化。这可能有点过于强硬，尤其是在复杂的应用程序中。因此，引入了更优化的模式
    `OnPush` 变更检测。此模式利用不可变性和 Observables 的概念，使 Angular 能够显著减少需要检查更新的组件数量。这在 [*第 3
    章*](B21180_03.xhtml#_idTextAnchor047)，*作为流获取数据* 中进行了探讨。
- en: Whether you use the default change detection or the more optimized `OnPush`
    mode, Angular still needs to stay informed when event handlers have finished running.
    This presents a challenge because the browser – not Angular itself – triggers
    these event handlers. This is where Zone.js steps in, essentially acting as a
    bridge. Zone.js can detect when an event handler has run, telling Angular, “Hey,
    there’s a new event; you can take care of any necessary updates now.”
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您使用默认的变更检测还是更优化的 `OnPush` 模式，Angular 仍需要在事件处理程序运行完毕后保持知情。这提出了一个挑战，因为浏览器——而不是
    Angular 本身——触发了这些事件处理程序。这就是 Zone.js 发挥作用的地方，它本质上充当了一个桥梁。Zone.js 可以检测到事件处理程序的运行，告诉
    Angular，“嘿，有一个新的事件；你现在可以处理任何必要的更新了。”
- en: 'While this approach has worked well in the past, it still comes with a few
    downsides: when changes are made, the whole component tree and all the expressions
    on every component are always checked. There is no way for Angular to directly
    identify changed components or to just update the changed parts of a component.
    That is why Angular cannot make any assumptions about what happened and needs
    to check everything!'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方法在过去一直表现良好，但它仍然存在一些缺点：当进行更改时，整个组件树以及每个组件上的所有表达式都会被检查。Angular无法直接识别已更改的组件或仅更新组件的更改部分。这就是为什么Angular无法对发生了什么做出任何假设，并需要检查一切的原因！
- en: The new Signals approach
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新的信号方法
- en: 'With Signals, Angular can easily detect when any part of the application data
    changes and update any dependencies automatically. Signals enable efficient change
    detection, smarter re-rendering when data changes, and facilitate fine-grained
    updates to the DOM, reducing the runtime required for Angular to check all components,
    even if their consumed data remains unchanged. Ultimately, this can eliminate
    the need for Zone.js in one of the future versions:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用信号，Angular可以轻松检测应用程序数据中的任何部分何时发生变化，并自动更新任何依赖项。信号使高效的变更检测成为可能，当数据发生变化时，智能地重新渲染，并促进对DOM的细粒度更新，减少Angular检查所有组件所需的运行时，即使它们消耗的数据保持不变。最终，这可能在未来的某个版本中消除对Zone.js的需求：
- en: '![Figure 8.1: Comparing the various change detection approaches](img/B21180_08_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1：比较各种变更检测方法](img/B21180_08_01.jpg)'
- en: 'Figure 8.1: Comparing the various change detection approaches'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：比较各种变更检测方法
- en: 'Apart from improving change detection, there are other advantages of using
    Signals:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 除了改进变更检测外，使用信号还有其他优点：
- en: It provides a more intuitive and declarative way to manage reactive data
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了一种更直观和声明式的方式来管理反应式数据
- en: The syntax aligns more closely with JavaScript, making code easier to read,
    understand, and maintain.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法与JavaScript更接近，使代码更容易阅读、理解和维护。
- en: The compiler performs better type narrowing for improved type safety within
    your reactive code.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器在您的反应式代码中执行更好的类型缩小，以改善类型安全性。
- en: As we progress through this chapter, you’ll gain a clearer understanding of
    Signals. Eager to discover more? Let’s continue.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '随着我们进入本章，您将更清楚地了解信号。渴望了解更多？让我们继续。 '
- en: Unveiling the Signal API
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 揭示信号API
- en: In this section, we’ll delve into the world of Signals, covering exactly what
    they are, how they work, and the revolutionary changes they bring to Angular.
    So, without further ado, let’s discover what a Signal is.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入信号的世界，详细介绍它们是什么，如何工作，以及它们给Angular带来的革命性变化。所以，无需多言，让我们来发现信号是什么。
- en: Defining Signals
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义信号
- en: A **Signal** is a reactive entity within Angular that encapsulates a value (serving
    as a container for a value) and automatically notifies consumers whenever that
    value changes. You can think of Angular’s Signals as a combination of a data value
    and a change notification mechanism, offering a streamlined approach to tracking
    changes and seamlessly updating the user interface in response to those changes.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**信号**是Angular中的一个反应式实体，它封装了一个值（作为值的容器）并在该值发生变化时自动通知消费者。您可以将Angular的信号视为数据值和变更通知机制的组合，提供了一种跟踪变更和无缝更新用户界面的简化方法。'
- en: While the concept of Signals is not novel and has existed in various forms across
    different frameworks for many years, their integration into Angular provides developers
    with a familiar yet powerful tool for managing reactive behavior within their
    applications. They act as wrappers around values, allowing you to efficiently
    track changes and react accordingly.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然信号的概念并不新颖，并且多年来以各种形式存在于不同的框架中，但它们集成到Angular中为开发者提供了一个熟悉且强大的工具，用于管理应用程序内的反应式行为。它们作为值的包装器，允许你高效地跟踪变化并相应地做出反应。
- en: Creating Signals using the constructor function
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用构造函数创建信号
- en: We can create a Signal using the `signal` constructor function available in
    the `@``angular/core` package.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`@angular/core`包中可用的`signal`构造函数创建信号。
- en: An initial value is always required as a Signal must always have a value. Signals
    can hold a wide range of values, including simple primitives, such as strings
    and numbers, as well as more complex data structures, such as arrays and objects.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 信号必须始终有一个初始值，因为信号必须始终具有值。信号可以持有广泛的价值，包括简单的原始数据类型，如字符串和数字，以及更复杂的数据结构，如数组和对象。
- en: 'Plus, the `signal` function provides type flexibility. You can either explicitly
    define the type of the Signal’s value or leverage type inference based on the
    initial value. For example, the following code creates and initializes a Signal
    with a value of `John Doe`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`signal`函数提供了类型灵活性。你可以显式定义信号值的类型，或者根据初始值利用类型推断。例如，以下代码创建并初始化了一个值为`John Doe`的信号：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, we didn’t define a type for our Signal’s value. If you don’t
    explicitly specify a type, the `signal` function can infer the type based on the
    initial value you provide. So, here, the type can be inferred from the initial
    value of `John Doe` as `string`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们没有为Signal的值定义类型。如果你没有明确指定类型，`signal`函数可以根据你提供的初始值推断类型。因此，在这里，类型可以从`John
    Doe`的初始值推断为`string`。
- en: 'But what if you want to be extra clear about the type? That’s perfectly possible!
    Here’s how you would explicitly define the type:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你想要更清晰地说明类型呢？这是完全可以的！以下是显式定义类型的示例：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, we added `<string>` after `signal` to explicitly state that
    the Signal will hold string values. While type inference works well in many cases,
    explicitly defining types can improve code readability and maintainability, especially
    for larger projects.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们在`signal`之后添加了`<string>`来明确指出信号将持有字符串值。虽然类型推断在许多情况下都很好用，但显式定义类型可以提高代码的可读性和可维护性，尤其是在大型项目中。
- en: 'Now, let’s look at an example of a Signal holding an array. Imagine that you
    want to define a Signal that represents an array of currencies:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一个持有数组的信号示例。想象一下，你想定义一个表示货币数组的信号：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, the initial value is an array of strings, so the type of the Signal will
    be inferred as an array of strings, `string[]`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，初始值是一个字符串数组，因此信号的类型将被推断为字符串数组，`string[]`。
- en: 'Now, thinking of our Recipe app, the `favouriteRecipe` Signal holds a `Recipe`
    object and is of the `Recipe` type:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑我们的Recipe应用，`favouriteRecipe`信号持有`Recipe`对象，并且是`Recipe`类型：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we explicitly defined the specific type of `Recipe`. If you’re working
    with a specific type throughout your code, explicit type definition provides clarity
    and prevents potential type mismatches. However, when the type is different from
    the initial value or may vary, you can avoid explicitly writing it, making your
    code cleaner and more concise.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们显式定义了特定的`Recipe`类型。如果你在代码中一直使用特定类型，显式类型定义可以提供清晰度并防止潜在的类型不匹配。然而，当类型与初始值不同或可能变化时，你可以避免显式编写它，使你的代码更简洁。
- en: Once we have a Signal, we often want to read it and retrieve its value. But
    how can we do that? We’ll find out in the next section.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了信号，我们通常想读取它并检索其值。但我们如何做到这一点？我们将在下一节中找到答案。
- en: Reading Signals
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取信号
- en: 'One way to read a Signal’s value is by using the Signal’s getter. Here’s an
    example that reads the value of the previously created Signals and logs it in
    the console:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 读取信号值的一种方法是通过使用信号获取器。以下是一个示例，它读取先前创建的信号值并在控制台中记录它：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can use this getter to read Signals in your Angular components, services,
    and directives.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这个getter在你的Angular组件、服务和指令中读取信号。
- en: 'You can also read Signals in your component template to display a value:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在你的组件模板中读取信号以显示值：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Reading a Signal in a template returns the current Signal’s value and registers
    the Signal as a dependency of the template. If the Signal changes, the portion
    of the template is re-rendered.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中读取信号返回当前信号值并将信号注册为模板的依赖项。如果信号发生变化，模板的部分将被重新渲染。
- en: Signals that are created using the signal creator function are *writable*. This
    means you can modify their values after their creation. We’ll learn how to modify
    the value of a Signal in the next section.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用信号创建函数创建的信号是可写的。这意味着你可以在创建后修改它们的值。我们将在下一节中学习如何修改信号值。
- en: Modifying a writable Signal
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改可写信号
- en: 'Signals that are created using the `creation` function are of the `WritableSignal`
    type and offer an API specifically for updating their values. There are two primary
    methods for modifying the stored value of a writable Signal:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`creation`函数创建的信号属于`WritableSignal`类型，并提供了一个专门用于更新其值的API。修改可写信号存储值的两种主要方法如下：
- en: Using the `set` method
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`set`方法
- en: Using the `update` method
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`update`方法
- en: Let’s look at them both.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这两个。
- en: Using the set method
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用set方法
- en: 'The `set` method lets you directly set a new value for the Signal. Here’s an
    example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`set`方法允许你直接为信号设置新值。以下是一个示例：'
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we used the `set` method to update the Signal’s value from `John Doe`
    to `Mary Jane`. This is a simple and effective way to assign a new value when
    you know how the value needs to be changed.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了`set`方法将信号值从`John Doe`更新为`Mary Jane`。这是一种简单而有效的方法，在你知道如何更改值时分配新值。
- en: Using the update method
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`update`方法
- en: 'The `update` method allows us to compute a new value from the previous one,
    like so:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`update`方法允许我们从上一个值计算出一个新值，如下所示：'
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the `update` method, we appended `Full Name:` to the old Signal’s value,
    `John Doe`. The Signal maintains a record of value changes over time. When the
    value changes, the Signal notifies subscribed components or logic, prompting necessary
    UI or data flow modifications. Every part of the Angular component that depends
    on the Signal will be automatically updated once the value changes.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在`update`方法中，我们在旧的信号值`John Doe`后面添加了`Full Name:`。信号会记录随时间变化的值变化记录。当值发生变化时，信号会通知已订阅的组件或逻辑，提示必要的UI或数据流修改。一旦值发生变化，依赖于该信号的Angular组件的每个部分都会自动更新。
- en: So far, so good! Now that you’re comfortable with the basics of Signals, what
    if you could create Signals that automatically react to changes in other Signals?
    In other words, what if you need Signals that depend on other Signals? Well, that’s
    where computed Signals come into play!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利！现在你已经熟悉了信号的基础知识，那么如果你能创建出能够自动对其他信号变化做出反应的信号怎么办？换句话说，如果你需要依赖于其他信号的信号怎么办？嗯，这就是计算信号发挥作用的地方！
- en: Computed Signals
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算信号
- en: 'Computed Signals deduce their value from other Signals, offering a declarative
    way to define relationships between Signals and ensure your data remains consistent.
    Let’s focus on a simple example to understand the behavior:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 计算信号从其他信号中推断其值，提供了一种声明式的方式来定义信号之间的关系，并确保你的数据保持一致性。让我们通过一个简单的例子来了解其行为：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this code block, the `fullName` computed Signal derives its value from both
    the `firstName` and `lastName` Signals. The `computed` function simply appends
    the `firstName` and `lastName` values. So, `fullName` depends on the `firstName`
    and `lastName` Signals, which means that whenever either `firstName` or `lastName`
    changes, the `fullName` Signal automatically updates, reflecting the complete
    name.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码块中，`fullName`计算信号从`firstName`和`lastName`信号中获取其值。`computed`函数只是简单地将`firstName`和`lastName`的值拼接在一起。因此，`fullName`依赖于`firstName`和`lastName`信号，这意味着每当`firstName`或`lastName`发生变化时，`fullName`信号会自动更新，反映完整的姓名。
- en: Note that the computed Signal is lazy evaluated and cached. This means that
    the `computed` function doesn’t execute to calculate its value until the first
    time you read the calculated Signal (`fullName`, in our case). The calculated
    value is then cached, and if you read `fullName` again, it will return the cached
    value without re-executing the calculation function. Then, if the value of `firstName`
    or `lastName` changes, Angular knows that the `fullName` cached value is no longer
    valid, and the next time you read `fullName`, its new value will be re-calculated.
    So, the calculation function will re-execute again.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，计算信号是惰性评估并缓存的。这意味着`computed`函数不会执行来计算其值，直到你第一次读取计算出的信号（在我们的例子中是`fullName`）。计算出的值随后被缓存，如果你再次读取`fullName`，它将返回缓存的值而不会重新执行计算函数。然后，如果`firstName`或`lastName`的值发生变化，Angular知道缓存的`fullName`值不再有效，下一次你读取`fullName`时，其新值将被重新计算。因此，计算函数将再次执行。
- en: Note
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Unlike `WritableSignals`, computed Signals are read-only, so you can’t change
    their values. Even trying to set a value will result in a compilation error.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 与`WritableSignals`不同，计算信号是只读的，因此你不能更改它们的值。即使尝试设置值也会导致编译错误。
- en: Now that we’ve looked at computed Signals, which automatically react to changes
    in other Signals, what if you need to perform actions beyond simply updating data,
    such as making API calls or interacting with other components? This is where Signal
    effects step in!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了计算信号，它们会自动对其他信号的变化做出反应，那么如果你需要执行超出简单更新数据之外的操作，比如进行API调用或与其他组件交互，怎么办？这就是信号效果介入的地方！
- en: Signal effects
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信号效果
- en: Signal effects are functions that execute in response to Signal changes. They
    provide us with a way to perform side effects, such as logging data, or manipulating
    the DOM to perform custom rendering or adding a custom behavior.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 信号效果是响应信号变化而执行的函数。它们为我们提供了执行副作用的方式，例如记录数据，或操作DOM以执行自定义渲染或添加自定义行为。
- en: 'Let’s look at an example. Here’s some code in the HTML template:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子。以下是在HTML模板中的代码：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And here’s some TypeScript code :'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些 TypeScript 代码：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This code creates a counter that starts at `0`. Then, clicking the created `1`,
    and `effect` logs the updated value to the console.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码创建了一个从 `0` 开始的计数器。然后，点击创建的 `1`，`effect` 将更新的值记录到控制台。
- en: Note that effects require an injection context to function properly, such as
    during the construction of a component or service. That’s why we called it inside
    the constructor in the previous example. This means it needs to be called within
    a specific environment where Angular’s dependency injection system is available.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，effects 需要一个注入上下文才能正常工作，例如在组件或服务的构建期间。这就是为什么我们在前面的例子中将其放在构造函数中的原因。这意味着它需要在
    Angular 的依赖注入系统可用的特定环境中调用。
- en: But why? Well, because Signal effects might internally rely on other Angular
    services or functionalities that are managed by the dependency injection system.
    So, we should ensure that all necessary dependencies are properly injected and
    accessible for effects to work as intended. Running it outside this context could
    lead to errors because these dependencies wouldn’t be available.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么？嗯，因为 Signal effects 可能内部依赖于其他由依赖注入系统管理的 Angular 服务或功能。因此，我们应该确保所有必要的依赖都得到适当注入且可供
    effects 正常工作。在当前环境之外运行可能会导致错误，因为这些依赖将不可用。
- en: Having explored the core functionalities and concepts of Signals, you might
    be wondering how they compare to RxJS. Both offer mechanisms for managing data
    streams, so how do they differ? And can they work together? These are crucial
    questions we’ll address in the next section.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索了 Signals 的核心功能和概念之后，你可能想知道它们与 RxJS 的比较。两者都提供了管理数据流的机制，那么它们有什么不同？它们可以一起工作吗？这些问题是我们将在下一节中解决的至关重要的问题。
- en: Unlocking the power of RxJS and Angular Signals
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解锁 RxJS 和 Angular Signals 的力量
- en: While Angular Signals serves as a lightweight wrapper for reactive data with
    a simplified API, RxJS offers a comprehensive library for handling asynchronous
    streams, thus remaining crucial for handling more complex reactive programming
    requirements.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Angular Signals 作为具有简化 API 的反应性数据轻量级包装器，但 RxJS 提供了一个用于处理异步流的综合库，因此对于处理更复杂的反应性编程需求至关重要。
- en: 'Here’s a concise comparison of Signals and RxJS Observables:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 Signals 和 RxJS Observables 的简要比较：
- en: '| **Feature** | **Signals** | **Observables** |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| **特性** | **Signals** | **Observables** |'
- en: '| **Value representation** | Hold a single value at a time. | Emit values over
    time. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| **值表示** | 一次只保留一个值。 | 随时间发射值。|'
- en: '| **Subscription** | Subscription is implicit. | Require explicit subscriptions.
    |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| **订阅** | 订阅是隐式的。 | 需要显式订阅。|'
- en: '| **Updates capability** | Updated by using the `set`/`update` method or using
    a computed Signal. | Updated by emitting new values. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| **更新能力** | 通过使用 `set`/`update` 方法或使用计算 Signal 来更新。 | 通过发射新值来更新。|'
- en: '| **Change detection** | Improve change detection performance. Angular can
    efficiently track changes and re-render when needed. | Using Observables might
    trigger inefficient change detection. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| **变化检测** | 提高变化检测性能。Angular 可以高效地跟踪变化并在需要时重新渲染。 | 使用 Observables 可能会触发低效的变化检测。|'
- en: '| **Providing notification** | Notify consumers when the hold data changes,
    facilitating value recalculation or template re-rendering. | Notify consumers
    when an event occurs or data is emitted, facilitating value recalculation or template
    re-rendering. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| **提供通知** | 当保留的数据发生变化时通知消费者，便于值重新计算或模板重新渲染。 | 当事件发生或数据被发射时通知消费者，便于值重新计算或模板重新渲染。|'
- en: '| **Reacting** **to notification** | React to notifications using effects.
    | React to notifications using callbacks. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| **对通知的反应** | 使用 effects 对通知做出反应。 | 使用回调对通知做出反应。|'
- en: 'Figure 8.2: Signals versus Observables'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2：Signals 与 Observables 的比较
- en: 'But when should you use each one? Well, RxJS shines in scenarios demanding
    complex reactive data flows. These include the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 但你何时应该使用哪一个呢？嗯，RxJS 在需要复杂反应性数据流的场景中表现出色。以下是一些例子：
- en: Managing multiple streams, often arising from asynchronous operations such as
    HTTP requests
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理多个流，通常由异步操作（如 HTTP 请求）引起
- en: Handling complex data manipulation such as combination, merging, transforming,
    and filtering
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理复杂的数据操作，如组合、合并、转换和过滤
- en: Reacting to each emission
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对每次发射做出反应
- en: 'On the other hand, Signals are good for the following aspects:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Signals 适用于以下方面：
- en: Simple reactive data management within components, side effects, and calculations
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在组件、副作用和计算中简单管理反应性数据
- en: Data binding scenarios where you want to track changes and trigger targeted
    UI updates
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在需要跟踪更改并触发目标UI更新的数据绑定场景
- en: Situations where a simpler syntax and potentially improved change detection
    performance are desired
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当希望有更简单的语法和可能改进的变更检测性能时的情况
- en: Signals and RxJS are not mutually exclusive; they can be complementary tools
    in your Angular development. Angular has several RxJS interop features that make
    Signals and Observables play nicely in the same app, meaning you can get the benefits
    of both for a more powerful way to manage your data. These RxJS interop features
    can be found under the `@angular/core/rxjs-interop` package and include the `toSignal()`
    and `toObservable()` functions. We’ll look at both of these now.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 信号和RxJS不是相互排斥的；它们可以是Angular开发的互补工具。Angular有几个RxJS互操作功能，使得信号和可观察者在同一应用程序中协同工作，这意味着您可以为更强大的数据管理方式同时获得两者的好处。这些RxJS互操作功能可以在`@angular/core/rxjs-interop`包下找到，包括`toSignal()`和`toObservable()`函数。我们现在将查看这两个函数。
- en: Understanding the behavior of toSignal()
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解`toSignal()`的行为
- en: The `toSignal()` function lets you create a Signal from an Observable. It provides
    synchronous access to the values that are emitted from the Observable, always
    containing the most recent emitted values by the Observable. But the coolest part
    is that `toSignal()` automatically subscribes to the defined Observable and unsubscribes
    when the component or service that calls `toSignal()` is destroyed.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`toSignal()`函数允许您从可观察者创建信号。它提供了对从可观察者发出的值的同步访问，始终包含可观察者发出的最新值。但最酷的部分是`toSignal()`会自动订阅定义的可观察者，并在调用`toSignal()`的组件或服务被销毁时取消订阅。'
- en: So, we don’t have to manage subscriptions. Doesn’t this concept remind you of
    the async pipe? Indeed; both Signals and the async pipe offer ways to display
    reactive data in Angular templates. However, Signals provide greater flexibility.
    Unlike the async pipe, which is primarily used with Observables in templates,
    Signals can be used anywhere in your application for efficient data management.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不需要管理订阅。这个概念是否让你想起了异步管道？确实如此；信号和异步管道都提供了在Angular模板中显示响应式数据的方法。然而，信号提供了更大的灵活性。与主要用于模板中的可观察者的异步管道不同，信号可以在应用程序的任何地方使用，以实现高效的数据管理。
- en: 'But wait – earlier, we learned that a Signal should always have a value while
    Observables may not emit a value right away. And that’s true. That’s why `toSignal`
    has the option to provide an initial value, which will represent the Signal’s
    value until the Observable emits. Here’s a simple example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等——之前我们了解到信号应该始终有一个值，而可观察者可能不会立即发出值。这是真的。这就是为什么`toSignal`有提供初始值的选项，这个值将代表信号直到可观察者发出。这里有一个简单的例子：
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In this example, we created a `value$` Observable using the `of()` creation
    function, which emits the `[{ name: ''EURO'', id: 1 }]` array. Then, we created
    a Signal named `valueAsSignal` using the `toSignal` function. We pass two arguments
    to the `toSignal` function:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个例子中，我们使用`of()`创建函数创建了一个名为`value$`的可观察者，它发出数组`[{ name: ''EURO'', id: 1 }]`。然后，我们使用`toSignal`函数创建了一个名为`valueAsSignal`的信号。我们向`toSignal`函数传递了两个参数：'
- en: '`this.value$`: The Observable you want to convert into a Signal.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`this.value$`: 您想要转换为信号的观察者。'
- en: '`{ initialValue: [] }`: An optional object that allows you to customize the
    Signal’s behavior. Here, we’re setting the `initialValue` property to an empty
    array (`[]`). This ensures that the Signal has a defined value even before the
    Observable emits its first item.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{ initialValue: [] }`: 这是一个可选对象，允许您自定义信号的行为。在这里，我们将`initialValue`属性设置为空数组（`[]`）。这确保了即使在可观察者发出第一个项目之前，信号也有一个已定义的值。'
- en: Finally, we registered an effect to log the Signal’s value in the console.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们注册了一个效果来在控制台记录信号值。
- en: Note that if you don’t mention an initial value in the `toSignal` function,
    the Signal will have `undefined` as the initial value. Be aware that using `undefined`
    as an initial value can always lead to many errors or inconsistencies, so it would
    be better to manage this when it’s created and provide an initial value.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果您在`toSignal`函数中没有提到初始值，信号将具有`undefined`作为初始值。请注意，使用`undefined`作为初始值可能会始终导致许多错误或不一致，因此最好在创建时管理它并提供初始值。
- en: 'With that clear, why is this different from using an Observable? Let’s focus
    on another example:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 明确这一点后，为什么这与使用可观察者不同？让我们关注另一个例子：
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we’re creating an Observable that uses the `of` creation function – we
    subscribe to it and log the values in the console. This Observable emits `10`,
    `20`, and `30`, respectively, and those values will get logged in the console.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个使用`of`创建函数的可观察对象——我们订阅它并在控制台记录值。这个可观察对象分别发出`10`、`20`和`30`，这些值将记录在控制台。
- en: 'Now, let’s convert this Observable into a Signal:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这个可观察对象转换为信号：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we used the same `values$` Observable and converted it into a Signal using
    `toSignal` while setting an initial value of `0`. Then, we defined an effect to
    log the value of the Signal. The console output is `30`. Yes, only `30`. Why?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了相同的`values$`可观察对象，并通过`toSignal`将其转换为信号，同时设置了一个初始值`0`。然后，我们定义了一个效果来记录信号值。控制台输出是`30`。是的，只有`30`。为什么？
- en: The `of()` creation function emits its values immediately upon subscription.
    So, when `toSignal` subscribes, all the values are immediately emitted. By the
    time the effect is scheduled to run, `30` is already in the Signal as the last
    value emitted and that’s what it is logged as to the Signal.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`of()`创建函数在订阅时立即发出其值。因此，当`toSignal`订阅时，所有值都会立即发出。当效果计划运行时，`30`已经是信号中最后一个发出的值，这就是它在信号中记录的内容。'
- en: 'Now, let’s delay the `values$` emission by 5 seconds using the `delay` operator:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用`delay`操作符将`values$`的发射延迟5秒：
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When you re-execute the code, you will see `10`, `20`, and `30` in the console.
    The effect now has the opportunity to run after each emission because we set up
    a delay of `5` seconds.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当你重新执行代码时，你将在控制台看到`10`、`20`和`30`。现在，效果有机会在每次发射后运行，因为我们设置了一个5秒的延迟。
- en: The point here is that when we create Signals, the Signal will not necessarily
    get notified of all emitted items; it depends on how the Observable is created
    and on its set of operators.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是，当我们创建信号时，信号并不一定会通知所有发出的项目；这取决于可观察对象是如何创建的以及它的操作符集合。
- en: Note
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Signals created through the `toSignal()` function are read-only – this makes
    sense as the Signal here is just a consumer of the values emitted by the Observable.
    Also, keep in mind that `toSignal()` creates a subscription – you should avoid
    calling it repeatedly for the same Observable, and instead reuse the Signal it
    returns.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`toSignal()`函数创建的信号是只读的——这是有道理的，因为这里的信号只是可观察对象发出的值的消费者。此外，请注意，`toSignal()`创建了一个订阅——你应该避免对同一个可观察对象重复调用它，而是重用它返回的信号。
- en: That is all you need to know about `toSignal()`. Now, let’s explore the `toObservable()`
    function.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`toSignal()`，你需要知道的就是这些。现在，让我们来探索`toObservable()`函数。
- en: Understanding the behavior of toObservable()
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解`toObservable()`的行为
- en: If you want to react to a Signal change and perform an async operation such
    as issuing an HTTP request, the `toObservable()` function is your friend!
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要对信号的变化做出反应并执行异步操作，如发起HTTP请求，`toObservable()`函数是你的好朋友！
- en: The `toObservable()` function allows you to convert a Signal into an Observable.
    Whenever the Signal’s value changes, the Observable automatically emits a notification
    with the new value. This allows you to easily trigger your async operation based
    on the updated Signal data. Under the hood, `toObservable()` uses effects to track
    the Signal’s value and emit the latest value to the Observable, as discussed earlier
    in this chapter.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`toObservable()`函数允许你将信号转换为可观察对象。每当信号值发生变化时，可观察对象会自动发出一个包含新值的通知。这允许你根据更新的信号数据轻松触发你的异步操作。在底层，`toObservable()`使用效果来跟踪信号值并向可观察对象发出最新值，正如本章前面所讨论的。'
- en: The `toObservable()` function might remind you of the `asObservable` function
    that’s available for subjects, something we explored in [*Chapter 7*](B21180_07.xhtml#_idTextAnchor107),
    *Sharing Data Between Angular Components*, but these functions don’t have the
    same behavior.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`toObservable()`函数可能会让你想起可用于主题的`asObservable`函数，这是我们曾在[*第7章*](B21180_07.xhtml#_idTextAnchor107)中探讨的，*在Angular组件之间共享数据*，但这两个函数的行为并不相同。'
- en: 'Let’s look at an example of the `asObservable` function first:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看`asObservable`函数的一个例子：
- en: '[PRE15]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When using `Subject` or `BehaviorSubject`, notifications are asynchronous. Here,
    we defined a `BehaviourSubject` subject called `value` with an initial value of
    `10`. Then, we extracted the `readonly` Observable part of the subject using the
    `asObservable()` function. Each emitted value is piped through a `tap` operator
    to log it in the console. Then, we subscribe to start receiving notifications.
    Finally, in `constructor`, we emit new values (`20` and `30`) using the `next`
    method.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`Subject`或`BehaviorSubject`时，通知是异步的。在这里，我们定义了一个初始值为`10`的`BehaviourSubject`主题`value`。然后，我们使用`asObservable()`函数提取主题的`readonly`可观察者部分。每个发出的值都通过一个`tap`操作符传递以在控制台记录。然后，我们订阅以开始接收通知。最后，在`constructor`中，我们使用`next`方法发出新的值（`20`和`30`）。
- en: 'However, `toObservable` operates differently. It uses an effect where Signal
    change notifications are scheduled rather than immediately processed, as Observable
    notifications are. Let’s modify the same example by using Signals and `toObservable`
    instead:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`toObservable`的行为不同。它使用一个效果，其中信号变化通知被安排而不是立即处理，就像可观察者（Observable）通知一样。让我们通过使用信号和`toObservable`来修改相同的示例：
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we defined a Signal instead of the `BehaviorSubject` subject named `value`
    with an initial value of `10`. Then, we called `toObservable(this.value)` to emit
    a notification when the Signal’s value changes. In the pipeline, we once again
    logged the emitted values and subscribed to the Observable to start receiving
    notifications. Finally, the value of the Signal was updated using the `set` method.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个名为`value`的信号（Signal），其初始值为`10`，而不是名为`BehaviorSubject`的主题。然后，我们调用`toObservable(this.value)`来在信号值变化时发出通知。在管道中，我们再次记录发出的值，并订阅可观察者以开始接收通知。最后，我们使用`set`方法更新信号值。
- en: 'However, look at the console output – that is, `The value is : 30` . This may
    not be what you expected, right? This is because the effect behind `toObservable`
    runs only after the Signal has settled values. The current value of the Signal
    at that time is the last emitted value, which is `30`.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，看看控制台输出——即`The value is : 30`。这可能不是你预期的，对吧？这是因为`toObservable`背后的效果仅在信号稳定了值之后才运行。当时信号的当前值是最后一个发出的值，即`30`。'
- en: Keep this behavior in mind when you decide to use a subject or a Signal – a
    subject will emit all the values from its source, while `toObservable` only emits
    the current value from the Signal.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当你决定使用主题（subject）或信号（Signal）时，请记住这种行为——主题将发出其来源的所有值，而`toObservable`只发出信号当前值。
- en: Note
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Please note that the `toObservable` and `toSignal` functions require an injection
    context to function properly.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`toObservable`和`toSignal`函数需要一个注入上下文才能正常工作。
- en: As we delved into the powerful capabilities of both `toSignal` and `toObservable`,
    you might have noticed the potential for synergy between RxJS and Signals. In
    the next section, we will learn how we can use both RxJS and Signals in our recipe
    app and get the best of both worlds.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们深入探讨了`toSignal`和`toObservable`的强大功能，你可能会注意到RxJS和信号之间的协同作用潜力。在下一节中，我们将学习如何在我们的食谱应用中使用RxJS和信号，并得到两者的最佳效果。
- en: Integrating Signals into our recipe app
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将信号集成到我们的食谱应用中
- en: In this section, we will level up the recipe app’s reactive patterns by integrating
    Signals. We’ll kick things off by revisiting the data fetching use case we implemented
    in [*Chapter 3*](B21180_03.xhtml#_idTextAnchor047), and then see how we can adjust
    the implementation by using Signals in the `RecipesListComponent` to maximize
    efficiency.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过集成信号（Signals）来提升食谱应用（recipe app）的响应式模式。我们将从回顾我们在[*第3章*](B21180_03.xhtml#_idTextAnchor047)中实现的数据获取用例开始，然后看看我们如何通过在`RecipesListComponent`中使用信号来调整实现，以最大化效率。
- en: Fetching data as streams using Signals
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用信号作为流来获取数据
- en: Let’s briefly review the code snippets we covered for implementing data fetching
    in `RecipesService` and `RecipesListComponent`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要回顾一下我们在`RecipesService`和`RecipesListComponent`中实现数据获取所涵盖的代码片段。
- en: 'In `recipes.service.ts`, we have the following code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在`recipes.service.ts`中，我们有以下代码：
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In `recipes-list.component.ts`, we have this code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在`recipes-list.component.ts`中，我们有以下代码：
- en: '[PRE18]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, in `recipes-list.component.html`, we have this code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`recipes-list.component.html`中，我们有以下代码：
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, `recipes$` is created in `RecipesService` and represents the Observable
    that holds the list of recipes. Then, `recipes$` is defined in `RecipesListComponent`
    and subscribed to in the template using the async pipe. This code snippet was
    explained in detail in [*Chapter 3*](B21180_03.xhtml#_idTextAnchor047).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`recipes$` 是在 `RecipesService` 中创建的，它代表包含食谱列表的可观察对象。然后，`recipes$` 在 `RecipesListComponent`
    中定义，并在模板中使用异步管道进行订阅。这段代码在第 [*第3章*](B21180_03.xhtml#_idTextAnchor047) 中进行了详细解释。
- en: Now, instead of exposing `recipes$` as an Observable in `RecipesListComponent`,
    we can consider using a Signal to bind it in the template. To achieve this, we
    will convert the `recipes$` Observable into a Signal named `recipes` using the
    `toSignal()` function.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不再将 `recipes$` 作为 `RecipesListComponent` 中的可观察对象（Observable）暴露，而是可以考虑在模板中使用信号（Signal）来绑定它。为了实现这一点，我们将使用
    `toSignal()` 函数将 `recipes$` 可观察对象转换为名为 `recipes` 的信号。
- en: 'First, to centralize data management in a single place, we will create the
    `recipes` Signal inside `RecipesService`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了在单个位置集中管理数据，我们将在 `RecipesService` 中创建 `recipes` 信号：
- en: '[PRE20]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here, the `recipes` Signal is created using the `toSignal` function, which
    takes two arguments:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`recipes` 信号是通过 `toSignal` 函数创建的，该函数接受两个参数：
- en: '`This.recipes$`: The Observable to be converted into a Signal.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`This.recipes$`：要转换为信号的观察对象。'
- en: '`{initialValue: [] as Recipe[]}`: This is an optional configuration object
    that specifies an initial value of an empty array, `[]`. This ensures the Signal
    always has a value, even before the Observable emits any data. We used the TypeScript
    `as` assertion to define the type of `Recipe[]`.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{initialValue: [] as Recipe[]}`：这是一个可选的配置对象，指定了一个空数组 `[]` 的初始值。这确保信号始终有一个值，即使在可观察对象发出任何数据之前也是如此。我们使用了
    TypeScript 的 `as` 断言来定义 `Recipe[]` 的类型。'
- en: Note
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'We can optimize the `RecipesService` code by deleting the `recipes$` property
    and including its result in the `recipes` property, as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过删除 `recipes$` 属性并将结果包含在 `recipes` 属性中来优化 `RecipesService` 代码，如下所示：
- en: '``recipes = toSignal(this.http.get<Recipe[]>(`${BASE_PATH}/recipes`), { initialValue:
    [] as`` `Recipe[] });`'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '``recipes = toSignal(this.http.get<Recipe[]>(`${BASE_PATH}/recipes`), { initialValue:
    [] as`` `Recipe[] });`'
- en: 'Next, in `RecipesListComponent`, we will define the Signal we created in `RecipesService`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `RecipesListComponent` 中，我们将定义在 `RecipesService` 中创建的信号：
- en: '[PRE21]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, as `toSignal` automatically subscribes to the `recipes$` Observable,
    we will change `recipes$ |async` to `recipes()` in the `RecipesListComponent`
    template so that it reads the Signal’s value:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于 `toSignal` 会自动订阅 `recipes$` 可观察对象，我们将 `RecipesListComponent` 模板中的 `recipes$
    |async` 更改为 `recipes()`，以便它读取信号值：
- en: '[PRE22]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: No other changes are required. If you go to the app, the list is displayed,
    and our app still works. By doing this, we kept the Observable-based logic in
    `RecipesService` for managing async operations using the HTTP client and then
    created a Signal from that Observable for use in the template. By doing this,
    we can improve change detection in the template.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要做其他任何更改。如果你访问应用，列表会显示出来，我们的应用仍然可以正常工作。通过这种方式，我们保留了 `RecipesService` 中的基于可观察对象的逻辑，用于通过
    HTTP 客户端管理异步操作，然后从该可观察对象创建一个信号用于模板。通过这样做，我们可以提高模板中的变更检测。
- en: Now, how do we handle errors in our Signals? If they are just simple containers
    of values, how can they generate an error?
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何在我们的信号中处理错误呢？如果它们只是简单的值容器，它们如何产生错误？
- en: 'In `RecipesService`, we handled the error using the `catchError` operator (discussed
    in [*Chapter 4*](B21180_04.xhtml#_idTextAnchor071), *Handling Errors Reactively*)
    and provided a replacement Observable:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `RecipesService` 中，我们使用 `catchError` 操作符（在第 [*第4章*](B21180_04.xhtml#_idTextAnchor071)，*反应式错误处理*
    中讨论）处理错误，并提供了替代的可观察对象：
- en: '[PRE23]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This code works fine when using `toSignal`. It is an option to handle errors
    at the Observable level so that when the Observable that’s used in `toSignal`
    throws an error, this is later caught using the `catchError` operator, and a replacement
    Observable is provided.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `toSignal` 时，这段代码运行正常。这是一个在可观察对象级别处理错误的选择，以便当在 `toSignal` 中使用的可观察对象抛出错误时，稍后使用
    `catchError` 操作符捕获该错误，并提供替代的可观察对象。
- en: However, if an Observable called in `toSignal` rethrows an error and doesn’t
    handle it (the catch and rethrow strategy detailed in [*Chapter 4*](B21180_04.xhtml#_idTextAnchor071)),
    then this error will be thrown each time the Signal is read. Consequently, if
    the Signal is read multiple times, the error will be thrown repeatedly.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果 `toSignal` 中调用的可观察对象重新抛出错误而没有处理它（在第 [*第4章*](B21180_04.xhtml#_idTextAnchor071)
    中详细说明的捕获和重新抛出策略），那么每次读取信号时都会抛出这个错误。因此，如果信号被读取多次，错误将反复抛出。
- en: 'Therefore, if you intend to rethrow the error and perform actions such as displaying
    a popup message in the UI, then it is highly recommended to catch the error at
    the Observable level and return an error object as a value. Here’s an example:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您打算重新抛出错误并在UI中显示弹出消息等操作，那么在Observable级别捕获错误并返回一个错误对象作为值是非常推荐的。以下是一个示例：
- en: '[PRE24]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, we have an Observable that catches errors of the `HttpErrorResponse` type
    and returns an object containing the status (indicating whether it’s an error
    or success) and the error description. At this point, you can register an effect
    to handle this error at the component level.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个捕获`HttpErrorResponse`类型错误的Observable，并返回一个包含状态（指示是错误还是成功）和错误描述的对象。在此阶段，您可以在组件级别注册一个效果来处理这个错误。
- en: 'Another option is to reject errors completely using the `rejectErrors` parameter
    of `toSignal`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是使用`toSignal`的`rejectErrors`参数完全拒绝错误：
- en: '[PRE25]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When enabled, errors are thrown back into the Observable and will become uncaught
    exceptions. You can imagine `toSignal` saying, “I don’t want your errors; take
    them back.” You can then register a global error handler to handle uncaught exceptions
    and perform your actions:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当启用时，错误会被抛回Observable，并成为未捕获的异常。你可以想象`toSignal`说，“我不想你的错误；把它们拿回去。”然后你可以注册一个全局错误处理器来处理未捕获的异常并执行你的操作：
- en: '[PRE26]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If an Observable that’s used in `toSignal` completes, the Signal continues to
    return the most recently emitted value before completion.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`toSignal`中使用的Observable完成，信号将继续返回完成前的最新发出的值。
- en: Now that we’ve used `toSignal` to improve our implementation and understood
    its behavior in handling errors, along with the various recommended options available,
    let’s circle back to the concept of filtering streams, a topic we explored in
    [*Chapter 5*](B21180_05.xhtml#_idTextAnchor083), *Combining Streams*. We will
    use computed Signals to meet the filtering requirement using RxJS and Signals.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使用`toSignal`改进了我们的实现，并理解了它在处理错误时的行为，以及可用的各种推荐选项，让我们回到过滤流的概念，这是我们曾在[*第五章*](B21180_05.xhtml#_idTextAnchor083)中探讨的，即*结合流*。我们将使用计算信号（computed
    Signals）来满足过滤需求，使用RxJS和信号（Signals）。
- en: Combining streams using Signals
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用信号结合流
- en: In the recipe app, we implemented filtering using `BehaviorSubjects`, which
    effectively notifies components when the filter changes to refine the results.
    However, Signals also offer a mechanism to react to value changes. They can trigger
    actions within effects or computed Signals.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在食谱应用中，我们使用`BehaviorSubjects`实现了过滤，这有效地在过滤更改时通知组件以细化结果。然而，信号（Signals）也提供了一种机制来响应值的变化。它们可以在效果或计算信号（computed
    Signals）中触发操作。
- en: This functionality overlaps somewhat with `BehaviorSubjects`, which begs the
    question, can we replace `BehaviorSubjects` with Signals to filter streams? Let’s
    refresh our memory on the code provided in [*Chapter 5*](B21180_05.xhtml#_idTextAnchor083).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能与`BehaviorSubjects`有些重叠，这引发了一个问题：我们能否用信号（Signals）来替换`BehaviorSubjects`以过滤流？让我们回顾一下在[*第五章*](B21180_05.xhtml#_idTextAnchor083)中提供的代码。
- en: 'In `recipes.service.ts`, we have the following code:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在`recipes.service.ts`中，我们有以下代码：
- en: '[PRE27]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In `recipes-list.component.ts`, we have this code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在`recipes-list.component.ts`中，我们有以下代码：
- en: '[PRE28]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, `filterRecipesAction$` is the Observable that holds the latest filter’s
    value. It’s defined in `RecipesService` and used in `RecipesListComponent` to
    refine the search. The filter’s value is updated through the `updateFilter` method
    by `RecipesFilterComponent`. `filteredRecipes$` represents the result of filtering;
    we subscribed to it in the `RecipesListComponent` template using the async pipe.
    This code snippet is explained in detail in [*Chapter 5*](B21180_05.xhtml#_idTextAnchor083).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`filterRecipesAction$`是包含最新过滤值的Observable。它在`RecipesService`中定义，并在`RecipesListComponent`中用于细化搜索。过滤值通过`RecipesFilterComponent`的`updateFilter`方法更新。`filteredRecipes$`代表过滤的结果；我们在`RecipesListComponent`模板中使用异步管道订阅了它。这段代码在[*第五章*](B21180_05.xhtml#_idTextAnchor083)中有详细解释。
- en: 'Now, using Signals, we can replace `BehaviorSubject` and the Observable we
    created in `RecipesService` with a single Signal named `filterRecipe` and initialize
    it with an empty value:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用信号（Signals），我们可以用单个名为`filterRecipe`的信号替换`BehaviorSubject`和我们在`RecipesService`中创建的Observable，并用空值初始化它：
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, we created the `filterRecipe` Signal and initialized it with an empty
    criteria. In the `updateFilter` method, which is used to notify the behavior subject
    of the change, we will simply update the value of the Signal using the `set` method.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了`filterRecipe` Signal并将其初始化为空标准。在`updateFilter`方法中，它用于通知行为主题的变化，我们将简单地使用`set`方法更新Signal的值。
- en: 'Then, in `RecipesListComponent`, instead of combining streams using `combineLatest`,
    we will create a computed Signal that will return an array of recipes based on
    the Signal’s filter and the Signal’s recipes list. Then, we will refine the recipes
    list given the filter value using the same filtering function:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`RecipesListComponent`中，我们不会使用`combineLatest`来组合流，而是创建一个计算出的Signal，该Signal将根据Signal的过滤器和Signal的食谱列表返回一个食谱数组。然后，我们将使用相同的过滤函数根据过滤值细化食谱列表：
- en: '[PRE30]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, in the `RecipesListComponent` template, we will be removing the async
    pipe and replacing it with the call to the `filteredRecipes` Signal, as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`RecipesListComponent`模板中，我们将移除异步管道，并用对`filteredRecipes` Signal的调用替换它，如下所示：
- en: '[PRE31]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This way, we have much cleaner code and an enhanced change detection mechanism.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就有更干净的代码和增强的变化检测机制。
- en: We used `BehaviorSubjects` in [*Chapter 7*](B21180_07.xhtml#_idTextAnchor107),
    to share the last selected recipe from `RecipesList` **Component** throughout
    the entire recipe app. Then, we consumed the last shared selected recipe and displayed
    its details in `RecipeDetailsComponent`. Let’s use Signals for the same purpose
    in this implementation.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第7章*](B21180_07.xhtml#_idTextAnchor107)中使用了`BehaviorSubjects`，以在整个食谱应用中从`RecipesList`组件共享最后选中的食谱。然后，我们消费了最后共享的选中食谱，并在`RecipeDetailsComponent`中显示了其详情。让我们在这个实现中使用Signal达到相同的目的。
- en: Sharing data using Signals
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Signal共享数据
- en: Before diving into using Signals, let’s review the steps that were covered in
    [*Chapter 7*](B21180_07.xhtml#_idTextAnchor107).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入使用Signal之前，让我们回顾一下[*第7章*](B21180_07.xhtml#_idTextAnchor107)中涵盖的步骤。
- en: 'In the `shared-data.service.ts` file, we have the following code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在`shared-data.service.ts`文件中，我们有以下代码：
- en: '[PRE32]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the `recipe-details.component.ts` file, we have this code:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在`recipe-details.component.ts`文件中，我们有以下代码：
- en: '[PRE33]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'And in the `recipe-details.component.html` file, we have this code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 并且在`recipe-details.component.html`文件中，我们有以下代码：
- en: '[PRE34]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`selectedRecipeAction$` is the Observable that holds the latest selected recipe.
    It’s defined in `SharedDataService` and used in `RecipeDetailsComponent` to display
    the details. The last selected recipe is updated through the `updateSelectedRecipe`
    method by `RecipeListComponent`. Then, we subscribed to `selectedRecipe$` in the
    template using the async pipe. This code snippet was explained in detail in [*Chapter
    7*](B21180_07.xhtml#_idTextAnchor107).'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`selectedRecipeAction$`是持有最新选中食谱的Observable。它在`SharedDataService`中定义，并在`RecipeDetailsComponent`中用于显示详情。最后选中的食谱通过`RecipeListComponent`的`updateSelectedRecipe`方法更新。然后，我们在模板中使用异步管道订阅了`selectedRecipe$`。这个代码片段在[*第7章*](B21180_07.xhtml#_idTextAnchor107)中有详细解释。'
- en: 'Now, we’ll switch from `BehaviorSubject` to Signals in `SharedDataService`.
    We’ll initialize the created Signal, `selectedRecipe`, with an empty object and
    change the `updateSelectedRecipe` method so that it updates the value stored in
    the `selectedRecipe` Signal using the `set` method:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将从`BehaviorSubject`切换到`SharedDataService`中的Signal。我们将初始化创建的Signal，`selectedRecipe`，为一个空对象，并更改`updateSelectedRecipe`方法，使其使用`set`方法更新存储在`selectedRecipe`
    Signal中的值：
- en: '[PRE35]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: So far, so good – we have a Signal that will always hold the last selected recipe.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利——我们有一个总是持有最后选中食谱的Signal。
- en: 'Next, let’s consume this Signal’s value in `RecipeDetailsComponent`. We will
    start by defining the Signal created in `SharedDataService`, as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在`RecipeDetailsComponent`中消费这个Signal的值。我们首先定义在`SharedDataService`中创建的Signal，如下所示：
- en: '[PRE36]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Then, in the template, replace `selectedRecipe$ | async` with `selectedRecipe()`
    to read the value of the Signal.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在模板中，将`selectedRecipe$ | async`替换为`selectedRecipe()`以读取Signal的值。
- en: And we’re done. When running this code, you’ll notice that the functionality
    remains intact. Each time a recipe is selected from the list, `RecipeDetailsComponent`
    will display its details. Now. let’s use Signals and `toObservable` to fetch a
    specific recipe from the server.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了。当运行此代码时，你会注意到功能保持不变。每次从列表中选择一个食谱时，`RecipeDetailsComponent`都会显示其详情。现在，让我们使用Signal和`toObservable`从服务器获取特定的食谱。
- en: Transforming streams using Signals
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Signal转换流
- en: Considering the previous example, the recipes array that’s displayed in `RecipesListComponent`
    already contains all the recipe objects, along with their details, so we simply
    used the client-side recipe object when clicking on a recipe from the list.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到前面的示例，显示在`RecipesListComponent`中的配方数组已经包含了所有配方对象及其详细信息，因此我们只需在列表中点击配方时使用客户端配方对象。
- en: Now, imagine that we need to dynamically fetch a recipe’s details based on its
    ID, from a backend service with the `/api/recipes/:recipeID` endpoint (this service
    is implemented in our `recipes-book-api` backend server; the code is available
    in this book’s GitHub repository). Here’s how we can adapt our previous implementation
    to handle this use case.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下，我们需要根据其ID动态地从后端服务（具有`/api/recipes/:recipeID`端点）获取配方详情。这个服务在我们的`recipes-book-api`后端服务器中实现；代码可在本书的GitHub仓库中找到。这是我们可以如何调整我们的先前实现以处理此用例的方法。
- en: 'We can keep using Signals to track the currently selected recipe’s ID. So,
    in `SharedDataService`, we’ll adjust our implementation as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续使用信号来跟踪当前选定的配方ID。因此，在`SharedDataService`中，我们将调整我们的实现如下：
- en: '[PRE37]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, we defined a Signal named `selectedRecipeId` that’s been initialized to
    `undefined` as we don’t have an initial selection.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个名为`selectedRecipeId`的信号，它被初始化为`undefined`，因为我们没有初始选择。
- en: The `updateSelectedRecipe` method now takes `recipeId` (either a number or undefined)
    as input and updates the `selectedRecipeId` Signal using the `set` method.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`updateSelectedRecipe`方法现在接受`recipeId`（可以是数字或未定义）作为输入，并使用`set`方法更新`selectedRecipeId`信号。'
- en: 'Now, in `RecipeListComponent`, we will update the `editRecipe` method so that
    it only sends the recipe’s identifier instead of the whole recipe object:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`RecipeListComponent`中，我们将更新`editRecipe`方法，使其只发送配方标识符而不是整个配方对象：
- en: '[PRE38]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, we need to issue an asynchronous HTTP request to fetch the recipe’s details
    whenever a recipe is selected from the list. Observables are ideal for this process!
    As we learned in [*Chapter 6*](B21180_06.xhtml#_idTextAnchor097), *Transforming
    Streams*, we need a higher-order mapping operator that does the following:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在从列表中选择配方时发出异步HTTP请求以获取配方详情。Observables非常适合这个过程！正如我们在[*第6章*](B21180_06.xhtml#_idTextAnchor097)中学习的，*转换流*，我们需要一个高阶映射运算符来完成以下操作：
- en: Transforms each emitted recipe’s identifier into a new Observable that issues
    an HTTP request
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将每个发出的配方标识符转换为一个新Observable，该Observable发出HTTP请求
- en: Cancels the previous HTTP request when a new recipe’s identifier arrives and
    switches to the newly created HTTP request for the latest ID
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当新的配方标识符到达时取消先前的HTTP请求，并切换到为最新ID创建的新HTTP请求
- en: You may have guessed already, but `switchMap` is the ideal operator to use here.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经猜到了，但`switchMap`是这里使用的理想运算符。
- en: 'But wait! We need two key streams involved in this situation:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等！我们需要两个关键流参与这种情况：
- en: '*A HTTP request stream*: This stream, which is created using ``this.http.get<Recipe>(`${BASE_PATH}/recipes/${id}`)``,
    represents the actual HTTP request to retrieve the recipe data based on the provided
    ID.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*HTTP请求流*：这个流是通过`this.http.get<Recipe>(`${BASE_PATH}/recipes/${id}`)`创建的，它代表了基于提供的ID检索配方数据的实际HTTP请求。'
- en: '*A selected recipe ID stream*: Currently, the selected recipe ID is stored
    in the `selectedRecipeId` Signal. Here, we can use the `toObservable` function
    to convert the `selectedRecipeId` Signal into an Observable stream that will emit
    a notification whenever the selected recipe ID changes in the Signal. It will
    look like this: `toObservable(this.selectedRecipeId)`.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*选定的配方ID流*：目前，选定的配方ID存储在`selectedRecipeId`信号中。在这里，我们可以使用`toObservable`函数将`selectedRecipeId`信号转换为Observable流，该流将在选定的配方ID在信号中发生变化时发出通知。它看起来像这样：`toObservable(this.selectedRecipeId)`。'
- en: 'Now, using the `switchMap` operator, we will define the `recipe$` stream in
    `SharedDataService`, as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用`switchMap`运算符，我们将在`SharedDataService`中定义`recipe$`流，如下所示：
- en: '[PRE39]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The resulting Observable, `recipe$`, represents a specific recipe object stream.
    It emits a new recipe whenever the selected recipe ID changes and a successful
    HTTP request is made.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的Observable，`recipe$`，代表一个特定的配方对象流。每当选定的配方ID发生变化并且成功发起HTTP请求时，它都会发出一个新的配方。
- en: 'Finally, within `RecipeDetailsComponent`, we can convert the `recipe$` Observable
    back into a signal using the `toSignal` function:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`RecipeDetailsComponent`内部，我们可以使用`toSignal`函数将`recipe$`Observable转换回信号：
- en: '[PRE40]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This allows us to bind the recipe’s data in the component’s template using Signals.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们使用信号在组件的模板中绑定配方数据。
- en: Awesome, right? This transformation pattern of using Signals is applicable for
    every similar use case where you need to combine or transform multiple data streams
    in your Angular applications!
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，对吧？这种使用信号的转换模式适用于每个需要在你Angular应用程序中组合或转换多个数据流的类似用例！
- en: By leveraging both Angular Signals and RxJS, you can achieve a well-balanced
    approach to reactive data management in your Angular applications. This harmonious
    blend allows you to build highly dynamic and responsive user interfaces. Now,
    let’s delve into some interesting new features regarding reactive data binding
    with Signals.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用Angular信号和RxJS，你可以在Angular应用程序中实现一种平衡的反应性数据管理方法。这种和谐的融合允许你构建高度动态和响应式的用户界面。现在，让我们深入了解一些关于信号反应性数据绑定的有趣新特性。
- en: Exploring reactive data binding with Signals
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索使用信号的反应性数据绑定
- en: Angular’s data binding capabilities have been steadily improving to support
    reactivity. Starting from version 17.1, Angular introduced some powerful features
    to leverage reactivity using Signals in component interaction and data binding,
    such as input Signals, model inputs (starting from 17.2), and support for content
    and view queries. To align with input Signals, version 17.3 provides a new output
    API.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Angular的数据绑定能力一直在稳步提升，以支持反应性。从版本17.1开始，Angular引入了一些强大的功能，利用信号在组件交互和数据绑定中实现反应性，例如输入信号、模型输入（从17.2版本开始）以及对内容和视图查询的支持。为了与输入信号保持一致，版本17.3提供了一个新的输出API。
- en: We will explore these new features in this section.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节中探讨这些新特性。
- en: Signal inputs
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信号输入
- en: The Angular `@Input` decorator is used to define an input property in a component,
    allowing data to be passed into the component from its parent component or template.
    It essentially creates a one-way data flow from the parent to the child component.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Angular的`@Input`装饰器用于在组件中定义一个输入属性，允许从父组件或模板传递数据到组件。它本质上创建了一个从父组件到子组件的单向数据流。
- en: 'Angular 17.1 introduces Signal inputs that allow input data to be passed as
    Signals. This adds a powerful twist to data binding between parent and child components
    in Angular, transforming traditional Angular inputs into a reactive data source.
    Here’s an example:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 17.1引入了信号输入，允许将输入数据作为信号传递。这为Angular中父组件和子组件之间的数据绑定增添了强大的功能，将传统的Angular输入转换成了反应性数据源。以下是一个示例：
- en: '[PRE41]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In this example, we defined three Signal inputs:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们定义了三个信号输入：
- en: '`addressLine2`: An optional input that can hold a string value or be undefined.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addressLine2`: 一个可选输入，可以存储字符串值或未定义。'
- en: '`identifier`: An optional input that holds a number and has a default value
    of 0.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`identifier`: 一个可选输入，存储一个数字，默认值为0。'
- en: '`AddressLine1`: A required input that holds a string value. It is declared
    using the `input.required` function, and by default, the inputs are optional (that’s
    why Signal inputs are type-safe). If not provided, a compilation error will be
    thrown, like so: **NG8008: Required input ‘ addressLine1’ from component ShippingComponent
    must** **be specified**.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddressLine1`: 一个必需输入，存储字符串值。它使用`input.required`函数声明，默认情况下，输入是可选的（这就是为什么信号输入是类型安全的）。如果没有提供，将抛出编译错误，如下所示：**NG8008：组件ShippingComponent必需输入‘addressLine1’必须**
    **指定**。'
- en: Note
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Required inputs cannot have a default value. Therefore, you can’t read their
    values before they’ve been bound, and Angular throws an exception. Consequently,
    you can’t access their values in the constructor. However, you can safely access
    the values within `ngOnInit`, `ngOnChanges`, `computed`, or `effects` as they
    are only triggered when the component has been initialized.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 必需输入不能有默认值。因此，在它们被绑定之前，你不能读取它们的值，Angular会抛出异常。因此，你无法在构造函数中访问它们的值。然而，你可以在`ngOnInit`、`ngOnChanges`、`computed`或`effects`中安全地访问值，因为它们只会在组件初始化后被触发。
- en: Note
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When referenced in templates, Signal inputs will automatically mark `OnPush`
    components as dirty.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 当在模板中引用时，信号输入将自动将`OnPush`组件标记为脏的。
- en: 'Now that we’ve got a handle on creating Signal inputs and understanding their
    syntax, you might be curious about how to use them. Signal inputs are read-only.
    You can access the value by calling the getter function in the template, as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了创建信号输入和理解它们的语法，你可能想知道如何使用它们。信号输入是只读的。你可以在模板中通过调用getter函数来访问值，如下所示：
- en: '[PRE42]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You can also bind to an input Signal like so:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以这样绑定到一个输入信号：
- en: '[PRE43]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In this example, we bound the Signal input property, `addressLine1`, to different
    values: a string named `2300 Vision Lane`, a component property named `addressProperty`,
    and a Signal’s value named `addressAsSignalProperty()`.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将信号输入属性 `addressLine1` 绑定到不同的值：一个名为 `2300 Vision Lane` 的字符串，一个组件属性名为
    `addressProperty`，以及一个名为 `addressAsSignalProperty()` 的信号值。
- en: 'Binding to Signals opens the door to a whole new level of dynamic data flow;
    any changes made to the input value in the parent component will be automatically
    reflected in the child component. This is where the real magic happens. In the
    following example, we’re using the Signal input property’s name to bind the values,
    but you can provide an alias to the input name using the following syntax:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 将绑定到信号打开了动态数据流全新水平的大门；父组件中对输入值所做的任何更改都将自动反映在子组件中。这就是真正的魔法所在。在下面的例子中，我们使用信号输入属性的名称来绑定值，但你可以使用以下语法提供一个输入名称的别名：
- en: '[PRE44]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This allows you to reference the input by using `<app-shipping [id]=50>` as
    the alias in the template while still using `this.identifier` as the property
    name inside your component.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许你使用 `<app-shipping [id]=50>` 作为模板中的别名来引用输入，同时在组件内部仍然使用 `this.identifier`
    作为属性名称。
- en: In addition to using signal inputs for value binding in templates, they can
    also be used within `effects` and `computed` functions. Are you wondering how
    to do that? Let’s look at some examples.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在模板中使用信号输入进行值绑定外，它们还可以在 `effects` 和 `computed` 函数中使用。你在想如何做到这一点吗？让我们看看一些例子。
- en: 'Here, we’re appending the values of `addressLine1` and `addressLine2` in the
    computed function to build `fullAddress`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将计算函数中 `addressLine1` 和 `addressLine2` 的值附加起来以构建 `fullAddress`：
- en: '[PRE45]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'It’s possible to track the Signal input changes using the `effect` function,
    like so:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `effect` 函数跟踪信号输入的变化，如下所示：
- en: '[PRE46]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In this example, the `console.log` function is invoked every time the identifier
    input changes. This is a new way to track value changes.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，每当标识符输入发生变化时，都会调用 `console.log` 函数。这是一种跟踪值变化的新方法。
- en: So, life cycle hooks such as `ngOnInit` and `ngOnChanges` can now be replaced
    with `computed` and `effect`, making value monitoring easier. Instead of implementing
    extra code inside `ngOnInit` or `ngOnChanges`, we can simply register `effect`
    to monitor values and use `computed` to perform automatic calculations.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，生命周期钩子如 `ngOnInit` 和 `ngOnChanges` 现在可以用 `computed` 和 `effect` 来替换，使值监控变得更容易。我们不需要在
    `ngOnInit` 或 `ngOnChanges` 中实现额外的代码，只需简单地注册 `effect` 来监控值，并使用 `computed` 来执行自动计算。
- en: With that, we’ve covered the essentials of Signal inputs, which enable one-way
    data binding. Next, we’ll explore how bidirectional data binding can be achieved
    using Signals.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就涵盖了信号输入的基本知识，它实现了一向数据绑定。接下来，我们将探讨如何使用信号实现双向数据绑定。
- en: Model inputs
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型输入
- en: Model inputs are similar to the previously explained Signal inputs, allowing
    you to bind a value into a property. However, model inputs allow the component
    to write values into the property, unlike other inputs, which are read-only. This
    enables two-way reactive data binding, allowing the child component to not only
    receive data changes from the parent but also notify the parent of any changes
    it makes to the data.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 模型输入与之前解释的信号输入类似，允许你将值绑定到一个属性中。然而，模型输入允许组件将值写入属性，而与其他只读的输入不同。这实现了双向响应式数据绑定，允许子组件不仅接收来自父组件的数据变化，还可以通知父组件其数据所做的任何更改。
- en: 'Let’s look at an example. Here’s some TypeScript code:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。这里有一些 TypeScript 代码：
- en: '[PRE47]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'And here’s some code in the HTML template:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 HTML 模板中的代码：
- en: '[PRE48]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In the TypeScript code, we converted the Signal input named `identifier` into
    a model input that initially contains a value of `0`. Then, in the constructor,
    we set up a timer that will update the value of the `identifier` input after `4`
    seconds.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 代码中，我们将名为 `identifier` 的信号输入转换为初始值为 `0` 的模型输入。然后，在构造函数中，我们设置了一个计时器，将在
    `4` 秒后更新 `identifier` 输入的值。
- en: Then, in the HTML template, we simply used the two-way data binding syntax to
    bind to a property called `counter` that we defined in the parent component and
    then display the `counter` value.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 HTML 模板中，我们简单地使用了双向数据绑定语法，将一个名为 `counter` 的属性绑定到父组件中定义的属性上，并显示 `counter`
    的值。
- en: When running this code, you will see that the model’s input value will get updated
    after 4 seconds to `000524` and the counter property will have `000524` as its
    value as well. The parent component is automatically notified.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行此代码时，您将看到模型输入值在4秒后更新为`000524`，计数器属性也将以`000524`为其值。父组件会自动接收通知。
- en: 'Another thing to note when defining a model input is that, under the hood,
    Angular generates an output for that model. The output’s name is just the model
    input’s name suffixed with `Change`:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义模型输入时，还有一点需要注意，即底层，Angular为该模型生成一个输出。输出的名称只是模型输入名称后缀为`Change`：
- en: '[PRE49]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Here, we called the `idChange` output and triggered the `updateMessagethat`
    method, which will display an alert when the model value changes. The `idChange`
    event will be emitted whenever you write a new value into the model input.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调用了`idChange`输出并触发了`updateMessagethat`方法，该方法将在模型值变化时显示一个警告。每当您将新值写入模型输入时，`idChange`事件都会被触发。
- en: Signal queries
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信号查询
- en: Signal queries present a reactive alternative to traditional queries declared
    with the `@ContentChild`, `@ContentChildren`, `@ViewChild`, or `@ViewChildren`
    decorators. Signal queries expose query results as Signals, which means that query
    results can be composed with other Signals (using `computed` or `effect`) and
    drive change detection.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 信号查询提供了使用`@ContentChild`、`@ContentChildren`、`@ViewChild`或`@ViewChildren`装饰器声明的传统查询的反应式替代方案。信号查询将查询结果公开为信号，这意味着查询结果可以与其他信号（使用`computed`或`effect`）组合，并驱动变更检测。
- en: 'For more details, you can check out the official documentation: [https://angular.dev/guide/signals/queries](https://angular.dev/guide/signals/queries).'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如需更多详细信息，您可以查看官方文档：[https://angular.dev/guide/signals/queries](https://angular.dev/guide/signals/queries)。
- en: Summary
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter took a deep dive into Angular Signals. We started by figuring out
    why Signals exist and how they help manage data reactively.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入探讨了Angular信号。我们首先弄清楚信号存在的原因以及它们如何帮助管理数据反应式。
- en: Then, we explored the Signals API, from creating and reading the current value
    to using computed Signals and effects when the value changes.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们探索了信号API，从创建和读取当前值到在值变化时使用计算信号和效果。
- en: Next, we compared Signals to RxJS Observables. We saw what each is good at and
    when you’d use one over the other. Angular even provides special interop functions
    that let Signals and Observables work together nicely, including `toObservable()`
    and `toSignals()`, both of which we discussed.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们比较了信号与RxJS的可观察对象。我们看到了每个的优点以及何时使用一个而不是另一个。Angular甚至提供了特殊的互操作函数，允许信号和可观察对象很好地协同工作，包括`toObservable()`和`toSignals()`，这两个我们都有所讨论。
- en: Finally, to put everything into practice, we used Signals in our recipe app
    to see how they work with RxJS in real-world scenarios. This hands-on experience
    helped us solidify what we learned about using Signals and RxJS together. We also
    walked through the newest improvements regarding reactive data binding and component
    interaction using Angular Signals.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了将所有内容付诸实践，我们在我们的食谱应用中使用了信号，以了解它们在实际场景中与RxJS是如何协同工作的。这种动手经验帮助我们巩固了关于如何一起使用信号和RxJS的知识。我们还探讨了有关使用Angular信号进行响应式数据绑定和组件交互的最新改进。
- en: By incorporating Angular Signals into your Angular applications, you can streamline
    data management, enhance code readability, and leverage the power of reactive
    programming. Remember, signals and RxJS work together to empower you to build
    dynamic and responsive user interfaces.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将Angular信号集成到您的Angular应用程序中，您可以简化数据管理，提高代码可读性，并利用响应式编程的力量。记住，信号和RxJS协同工作，让您能够构建动态和响应式的用户界面。
- en: In the next chapter, we’ll move on to the essentials of multicasting, which
    will be helpful in the following chapters.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续探讨多播的基本知识，这将在以下章节中很有帮助。
- en: 'Part 4: Multicasting Adventures'
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四部分：多播冒险
- en: In this part, we will understand the essentials of multicasting in RxJS, as
    well as the recommended reactive patterns in many real-world use cases, such as
    caching data, multiple asynchronous operations, and real-time features.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分中，我们将了解RxJS中多播的基本知识，以及许多实际用例中推荐的响应式模式，例如缓存数据、多个异步操作和实时功能。
- en: You will also delve into the best practices when using multicast operators,
    Subjects, and Behavior Subjects and learn the pitfalls to avoid specifically in
    the context of multicasting.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 您还将深入了解使用多播操作符、Subject和Behavior Subject的最佳实践，并学习在多播上下文中应避免的陷阱。
- en: 'This part includes the following chapters:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '[*Chapter 9*](B21180_09.xhtml#_idTextAnchor146), *Demystifying Multicasting*'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B21180_09.xhtml#_idTextAnchor146), *揭秘多播*'
- en: '[*Chapter 10*](B21180_10.xhtml#_idTextAnchor159), *Boosting Performance with
    Reactive Caching*'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B21180_10.xhtml#_idTextAnchor159), *使用响应式缓存提升性能*'
- en: '[*Chapter 11*](B21180_11.xhtml#_idTextAnchor170), *Performing Bulk Operations*'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B21180_11.xhtml#_idTextAnchor170), *执行批量操作*'
- en: '[*Chapter 12*](B21180_12.xhtml#_idTextAnchor180), *Processing Real-Time Updates*'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B21180_12.xhtml#_idTextAnchor180), *处理实时更新*'
