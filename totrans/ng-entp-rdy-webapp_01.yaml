- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Introduction to Angular and Its Concepts
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular及其概念的介绍
- en: At first, there was HTML, then DHTML. Technologists invented new technologies
    like Java, JavaScript, PHP, and many others to deliver interactive experiences
    over the browser. The holy grail of programming was writing a program once and
    running it everywhere. In a flash, the era of **Single-Page Applications** (**SPAs**)
    was born. SPAs tricked the browser into thinking that a single `index.html` could
    house entire applications containing many pages. Backbone.js, Knockout.js, and
    Angular.js all came and went. Everyone reeling from unmanaged complexity and JavaScript-framework-of-the-week
    syndrome looked for a savior. Then came React, Angular, and Vue. They promised
    to fix all problems, bring about universally reusable web components, and make
    it easier to learn, develop, and scale web applications. And, so they did! Some
    better than others. The adolescent history of the web has taught us a couple of
    essential lessons. First, change is inevitable, and second, the developer's happiness
    is a precious commodity that can make or break entire companies.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，有HTML，然后是DHTML。技术人员发明了新的技术，如Java、JavaScript、PHP等，以在浏览器上提供交互式体验。编程的圣杯是编写一次程序，在任何地方运行。一瞬间，**单页应用**（**SPAs**）的时代诞生了。SPAs欺骗浏览器认为单个`index.html`可以容纳包含许多页面的整个应用程序。Backbone.js、Knockout.js和Angular.js都来了又去。所有人都在未管理的复杂性和每周JavaScript框架综合症中挣扎，寻找救世主。然后出现了React、Angular和Vue。它们承诺解决所有问题，带来通用可重用Web组件，并使学习、开发和扩展Web应用变得更加容易。而且，它们确实做到了！有的比其他的好。网络发展的青少年历史教会了我们几个基本教训。首先，变化是不可避免的，其次，开发者的幸福是一种宝贵的商品，它可以成就或摧毁整个公司。
- en: 'This chapter covers:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖：
- en: The history of web frameworks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web框架的历史
- en: Angular and the philosophy behind it
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular及其背后的哲学
- en: The reactive development paradigm
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式开发范式
- en: Advanced Angular features, including state management
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级Angular特性，包括状态管理
- en: Major Angular releases and features
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要Angular版本和特性
- en: This first chapter is meant to give you a theoretical and historical background
    for the rest of the book. Feel free to use it as a reference as you go through
    the rest of the book. *Chapter 2*, *Setting Up Your Development Environment*,
    covers how you can configure your development environment for a great development
    experience. With *Chapter 3*, *Creating a Basic Angular App*, you begin implementing
    your first Angular application. If you're already experienced with Angular, you
    may start with *Chapter 7*, *Creating a Router-First Line-of-Business App*, to
    dive into creating scalable applications ready for the enterprise.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这第一章旨在为你提供本书其余部分的理论和历史背景。在阅读本书的其余部分时，请随时将其用作参考。*第二章*，*设置您的开发环境*，介绍了如何配置您的开发环境以获得出色的开发体验。在*第三章*，*创建一个基本的Angular应用*中，你开始实现您的第一个Angular应用程序。如果您已经熟悉Angular，您可以从*第七章*，*创建一个以路由为第一线的业务应用*开始，深入创建适合企业的可扩展应用程序。
- en: Each chapter in the book introduces you to new concepts and reinforces best
    practices while covering optimal ways of working with widely used and open source
    tools. Along the way, tips and information boxes cover the bases to close any knowledge
    gaps you may have about web and modern JavaScript development basics. As you go
    through the content, pay attention to numbered steps or bullet points as they
    describe actions you need to take. If you skip a section or a chapter, you may
    miss subtle changes in configuration or techniques that may confuse you later
    on.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的每一章都向您介绍新的概念，同时强化最佳实践，并涵盖使用广泛使用的开源工具的最佳工作方式。在这个过程中，提示和信息框涵盖了关于Web和现代JavaScript开发基础知识可能存在的任何知识差距。在您阅读内容时，请注意编号步骤或项目符号，因为它们描述了您需要采取的行动。如果您跳过某个部分或章节，您可能会错过配置或技术上的微妙变化，这可能会在以后让您感到困惑。
- en: The code samples provided in this book have been developed using Angular 9,
    which is planned to be in **Long-Term Support** (**LTS**) until August 2021\.
    The chances are that you are reading this book after new versions have superseded
    Angular 9\. However, worry not. This book adopts the Angular evergreen motto of
    always keeping the version of Angular up to date with the latest release. Keeping
    up to date is made possible by sticking to platform fundamentals and avoiding
    unnecessary third-party libraries. The example projects for the book were initially
    written for Angular 5 and updated over time without major rewrites by following
    a proactive and incremental Angular upgrade schedule. I anticipate these projects
    to survive with minor modifications for years to come. This reliability is a testament
    to the excellent compatibility work done by the Angular team.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本书提供的代码示例是使用Angular 9开发的，该版本计划在2021年8月之前提供**长期支持**（**LTS**）。您可能是在Angular 9之后的新版本发布后阅读这本书的。但是，请放心。本书采用了Angular的evergreen口号，即始终将Angular的版本与最新版本保持同步。通过坚持平台基础并避免不必要的第三方库，可以保持更新。本书的示例项目最初是为Angular
    5编写的，随着时间的推移，通过遵循积极的增量Angular升级计划，没有进行重大重写而进行了更新。我预计这些项目在未来几年中只需进行少量修改即可生存。这种可靠性是对Angular团队所做优秀兼容性工作的证明。
- en: 'The world of JavaScript, TypeScript, and Angular is constantly changing. It
    is normal for there to be some differences between code samples in the book and
    the code that is generated for you by the tools you use. For this reason, most
    of the best practices and configuration items recommended by this book are applied
    using tools that I created, so they can be updated. Below is a high-level overview
    of the collection of libraries, extensions, and open source projects that support
    the content of the book:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript、TypeScript和Angular的世界一直在不断变化。书中代码示例与您使用工具生成的代码之间存在一些差异是正常的。因此，本书推荐的大多数最佳实践和配置项都是使用我创建的工具应用的，以便它们可以更新。以下是支持本书内容的库、扩展和开源项目集合的高级概述：
- en: '![](img/B14094_01_01.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_01_01.png)'
- en: 'Figure 1.1: Code developed in support of this book'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1：支持本书开发的代码
- en: 'The preceding diagram is to give you a quick glance at some of the moving parts.
    Each component is detailed in the coming chapters. The most up-to-date versions
    of the sample code for the book are on GitHub, at the repositories linked below.
    These repositories contain the final and completed state of the code. To make
    it easier to verify your progress at the end of a chapter, the `projects` folder
    in each repository contains chapter-by-chapter snapshots reflecting the current
    state of the code:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表是为了让您快速了解一些动态部分。每个组件将在接下来的章节中详细介绍。本书示例代码的最新版本可在GitHub上找到，位于以下链接的仓库中。这些仓库包含代码的最终和完成状态。为了使您在章节结束时更容易验证进度，每个仓库中的`projects`文件夹包含反映代码当前状态的逐章快照：
- en: 'For *Chapters 2* to *6*, and *12*, LocalCast Weather: [https://github.com/duluca/local-weather-app](../Text/Chapter_1.xhtml)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '对于**第2章**到**第6章**，以及**第12章**，LocalCast Weather: [https://github.com/duluca/local-weather-app](../Text/Chapter_1.xhtml)'
- en: 'For *Chapters 7* to *14*, Lemon Mart: [https://github.com/duluca/lemon-mart](../Text/Chapter_1.xhtml)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '对于**第7章**到**第14章**，Lemon Mart: [https://github.com/duluca/lemon-mart](../Text/Chapter_1.xhtml)'
- en: 'For *Chapter 10*, Lemon Mart Server: [https://github.com/duluca/lemon-mart-server](../Text/Chapter_1.xhtml)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '对于**第10章**，Lemon Mart Server: [https://github.com/duluca/lemon-mart-server](../Text/Chapter_1.xhtml)'
- en: You may read more about updating Angular in *Appendix C*, *Keeping Angular and
    Tools Evergreen*. You can find this appendix online from [https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen.pdf](../Text/Chapter_1.xhtml)
    or at [https://expertlysimple.io/stay-evergreen](../Text/Chapter_1.xhtml).
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以在**附录C**、“保持Angular和工具evergreen”中了解更多关于更新Angular的信息。您可以从[https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen.pdf](../Text/Chapter_1.xhtml)或[https://expertlysimple.io/stay-evergreen](../Text/Chapter_1.xhtml)在线找到此附录。
- en: Let's take a look at the last 20 or so years of web development history, so
    you can contextualize how Angular came to be and evolved.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下过去20年左右的Web开发历史，这样您就可以了解Angular是如何产生并演变的。
- en: A brief history of web frameworks
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web框架简史
- en: It is essential to consider why we use frameworks such as Angular, React, or
    Vue in the first place. Web frameworks came to rise as JavaScript became more
    popular and capable in the browser. In 2004, the **Asynchronous JavaScript and
    XML** (**AJAX**) technique became very popular in creating websites that did not
    have to rely on full-page refreshes to create dynamic experiences utilizing standardized
    web technologies like HTML, JavaScript/ECMAScript, and CSS. Browser vendors are
    supposed to implement these technologies as defined by the **World Wide Web Consortium**
    (**W3C**).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们最初为什么要使用像Angular、React或Vue这样的框架，这是非常重要的。随着JavaScript在浏览器中变得更加流行和强大，网络框架开始兴起。在2004年，**异步JavaScript和XML（AJAX**）技术在创建不需要依赖完整页面刷新来创建动态体验的网站中变得非常流行，这些体验利用了标准化的网络技术，如HTML、JavaScript/ECMAScript和CSS。浏览器供应商应该按照**万维网联盟（W3C**）的定义来实现这些技术。
- en: '**Internet Explorer** (**IE**) was the browser that the vast majority of internet
    users relied on at the time. Microsoft used its market dominance to push proprietary
    technologies and APIs to secure IE''s edge as the go-to browser. Things started
    to get interesting when Mozilla''s Firefox challenged IE''s dominance, followed
    by Google''s Chrome browser. As both browsers successfully gained significant
    market share, the web development landscape became a mess. New browser versions
    appeared at breakneck speed. Competing corporate and technical interests led to
    the diverging implementation of web standards.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**互联网浏览器（IE**）是当时绝大多数互联网用户依赖的浏览器。微软利用其市场主导地位来推广专有技术和API，以确保IE作为首选浏览器的优势。当Mozilla的Firefox挑战IE的主导地位，随后是Google的Chrome浏览器出现时，事情开始变得有趣。随着这两个浏览器成功获得显著的市场份额，网络开发领域变得混乱。新的浏览器版本以惊人的速度出现。竞争的厂商和技术利益导致了网络标准的分歧实施。'
- en: This fracturing created an unsustainable environment for developers to deliver
    consistent experiences on the web. Differing qualities, versions, and names of
    implementations of various standards created an enormous challenge, which was
    successfully writing code that could manipulate the **Document Object Model**
    (**DOM**) of a browser consistently. Even the slightest difference in the APIs
    and capabilities of a browser would be enough to break a website.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这种碎片化为开发者创造了一个不可持续的环境，让他们在网络上提供一致的用户体验。各种标准的实现质量、版本和名称的差异创造了一个巨大的挑战，即成功编写能够一致操作浏览器**文档对象模型（DOM**）的代码。即使是浏览器API和功能的最微小差异也足以破坏一个网站。
- en: In 2006, jQuery was developed to smooth out the differences between APIs and
    capabilities for browsers. So instead of repeatedly writing code to check browser
    versions, you could use jQuery, and you were good to go. It hid away all the complexities
    of vendor-specific implementations and gracefully filled the gaps when there were
    missing features. For a good 5 to 6 years, jQuery became the web development framework.
    It was unimaginable to write an interactive website without using jQuery.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在2006年，jQuery被开发出来以平滑浏览器API和功能之间的差异。因此，你不必反复编写代码来检查浏览器版本，你可以使用jQuery，然后就可以顺利开始了。它隐藏了所有特定供应商实现的复杂性，并在缺少功能时优雅地填补了空白。在接下来的5到6年里，jQuery成为了网络开发框架。没有使用jQuery编写交互式网站是不可想象的。
- en: To create vibrant user experiences, however, jQuery alone was not enough. Native
    web applications ran all their code in the browser, which required fast computers
    to run the dynamically interpreted JavaScript and render web pages using the complicated
    object graphs. Back in the 2000s, many users ran outdated browsers on relatively
    slow computers, so the user experience wasn't great.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了创建充满活力的用户体验，仅使用jQuery是不够的。原生网络应用程序在其浏览器中运行所有代码，这需要快速的计算机来运行动态解释的JavaScript并使用复杂的对象图渲染网页。在2000年代，许多用户在相对较慢的计算机上运行过时的浏览器，因此用户体验并不好。
- en: 'Traditionally, software architecture is described in three primary layers,
    as shown in the diagram that follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，软件架构被描述为三个主要层，如下面的图所示：
- en: '![](img/B14094_01_02.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_01_02.png)'
- en: 'Figure 1.2: Three-tiered software architecture'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2：三层软件架构
- en: 'The presentation layer contains **user interface** (**UI**) related code, the
    business layer contains business logic, and the persistence layer contains code
    related to data storage. It is an overall design goal to aim for low coupling
    and high cohesion between the components of our architecture. Low coupling means
    that pieces of code across these layers shouldn''t depend on each other and should
    be independently replaceable. High cohesion means that pieces of code that are
    related to each other, like code regarding a particular domain of business logic,
    should remain together. For example, when building an app to manage a restaurant,
    the code for the reservation system should be together and not spread across other
    systems like inventory tracking or user management. Modern web development has more
    moving parts than a basic three-tiered application. The diagram that follows shows
    additional layers that fit around the presentation, business, and persistence
    layers:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 表示层包含与用户界面（UI）相关的代码，业务层包含业务逻辑，持久层包含与数据存储相关的代码。我们的整体设计目标是追求架构组件之间的低耦合和高内聚。低耦合意味着这些层之间的代码片段不应相互依赖，并且应该是可以独立替换的。高内聚意味着相互关联的代码片段，如特定业务逻辑领域的代码，应该保持在一起。例如，当构建一个用于管理餐厅的应用程序时，预订系统的代码应该在一起，而不是分散在其他系统如库存跟踪或用户管理中。现代网络开发比基本的三层应用有更多的组成部分。下面的图显示了围绕表示层、业务层和持久层的附加层：
- en: '![](img/B14094_01_03.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_01_03.png)'
- en: 'Figure 1.3: Modern web architecture'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3：现代网络架构
- en: In the preceding diagram, you can see an expanded architecture diagram that
    includes essential components of modern web development, which include an API
    layer that usually transforms data between the presentation and business layers,
    a tools and best practices layer that defines various methodologies used to develop
    the software, and an automated testing layer that is crucial in today's iterative
    and fast-moving development cycles.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，你可以看到一个扩展的架构图，它包括了现代网络开发的基本组件，这些组件包括一个通常在表示层和业务层之间转换数据的API层，一个定义了用于开发软件的各种方法的工具和最佳实践层，以及一个在当今迭代和快速发展的开发周期中至关重要的自动化测试层。
- en: 'In the 2000s, many internet companies relied on server-side rendered web pages.
    The server dynamically created all the HTML, CSS, and data needed to render a
    page. The browser acted as a glorified viewer that would display the result. The
    following is a diagram that shows a sample architectural overview of a server-side
    rendered web application in the ASP.NET MVC stack:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在2000年代，许多互联网公司依赖于服务器端渲染的网页。服务器动态创建渲染页面所需的全部HTML、CSS和数据。浏览器充当了一个被美化的查看器，用于显示结果。以下是一个显示ASP.NET
    MVC堆栈中服务器端渲染的Web应用程序的样本架构概述的图：
- en: '![](img/B14094_01_04.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_01_04.png)'
- en: 'Figure 1.4: Server-side rendered MVC architecture'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4：服务器端渲染的MVC架构
- en: '**Model-View-Controller** (**MVC**) is a typical pattern of code that has data
    manipulation logic in models, business logic in controllers, and presentation
    logic in views. In the case of ASP.NET MVC, the controller and model are coded
    using C#, and views are created using a templated version of HTML, JavaScript,
    and C#. The result is that the browser receives HTML, JavaScript, and data that
    is needed, and through jQuery and AJAX magic, web pages look to be interactive.
    Server-side rendering and MVC patterns are still popular and in use today. There
    are justified niche uses, such as Facebook.com. Facebook serves billions of devices
    that range from the very slow to the very fast. Without server-side rendering,
    it would be impossible for Facebook to guarantee a consistent **user experience**
    (**UX**) across its userbase. I find the combination of server-side rendering
    and MVC to be an intricate pattern to execute. To ensure the low coupling of components,
    every member of the engineering team must be very experienced. Teams with a high
    concentration of senior developers are hard to come by, and that would be an understatement.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型-视图-控制器**（**MVC**）是一种典型的代码模式，其中模型包含数据操作逻辑，控制器包含业务逻辑，视图包含表示逻辑。在ASP.NET MVC的情况下，控制器和模型使用C#编写，视图使用HTML、JavaScript和C#的模板版本创建。结果是浏览器接收到了所需的HTML、JavaScript和数据，通过jQuery和AJAX的魔法，网页看起来像是交互式的。服务器端渲染和MVC模式至今仍然流行并被使用。有一些合理的利基用途，例如Facebook.com。Facebook服务于从非常慢到非常快的数十亿设备。没有服务器端渲染，Facebook无法保证其用户群的一致的**用户体验**（**UX**）。我发现服务器端渲染和MVC的结合是一个复杂的模式来实现。为了确保组件的低耦合，工程团队中的每个成员都必须非常经验丰富。高比例高级开发者的团队很难找到，这还是一种轻描淡写。'
- en: Further complicating matters is that C# (or any other server-side language)
    cannot run natively in the browser. So, developers who work on server-side rendered
    applications must be equally skilled at using frontend and backend technologies.
    It is easy for inexperienced developers to co-mingle presentation and business
    logic in such implementations unintentionally. When this happens, the inevitable
    UI modernization of an otherwise well-functioning system becomes impossible. Put
    in other terms, to replace the sink in your kitchen with a new one, you must renovate
    your entire kitchen. Due to insufficient architecture, organizations routinely
    spend millions of dollars every 10 years writing and rewriting the same applications.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步复杂化问题的是，C#（或任何其他服务器端语言）不能在浏览器中本地运行。因此，从事服务器端渲染应用开发的开发者必须同样擅长使用前端和后端技术。在不经意间，缺乏经验的开发者很容易在实现中将表示层和业务逻辑混合在一起。当这种情况发生时，原本运行良好的系统的必然的UI现代化变得不可能。用另一种说法，如果你想更换厨房里的水槽，你必须翻新整个厨房。由于架构不足，组织通常每隔十年就要花费数百万美元来编写和重写相同的应用程序。
- en: During the 2000s, it was possible to build rich web applications that were decoupled
    from their server APIs using Java Applets, Flash, or Silverlight. However, these
    technologies relied on browser plugins that needed a separate installation. Most
    often, these plugins were out of date, created critical security vulnerabilities,
    and consumed too much power on mobile computers. Following the iPhone revolution
    in 2008, it was clear such plugins wouldn't run on mobile phones, despite best
    attempts by the Android OS. Besides, Apple CEO Steve Jobs' disdain for such inelegant
    solutions marked the beginning of the end for the support of such technologies
    in the browser.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在2000年代，使用Java Applets、Flash或Silverlight可以构建与服务器API解耦的丰富Web应用程序。然而，这些技术依赖于需要单独安装的浏览器插件。通常，这些插件过时了，创造了关键的安全漏洞，并且在移动计算机上消耗了过多的电力。2008年iPhone革命之后，很清楚这样的插件不会在手机上运行，尽管Android操作系统做出了最好的努力。此外，苹果公司CEO史蒂夫·乔布斯对这种不优雅的解决方案的厌恶标志着在浏览器中支持此类技术的终结的开始。
- en: In the early 2010s, frameworks like Backbone and AngularJS started showing up,
    demonstrating how to build rich web applications with a native feel and speed
    to them and do so in a seemingly cost-effective way. The diagram that follows
    shows a **Model-View-ViewModel** (**MVVM**) client with a **Representational State
    Transfer** (**REST**) API. When we decouple the client from the server via an
    API, then we can architecturally enforce the implementation of presentation and
    business logic separately. In theory, this RESTful web services pattern should
    allow us to replace the kitchen sink as often as we want to without having to
    remodel the entire kitchen.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2010 年代初，像 Backbone 和 AngularJS 这样的框架开始出现，展示了如何以原生感觉和速度构建丰富的 Web 应用程序，并以看似成本效益的方式实现。下述图展示了具有
    **模型-视图-视图模型**（**MVVM**）客户端和 **表示状态转换**（**REST**）API 的图。当我们通过 API 将客户端从服务器解耦时，我们可以在架构上强制实施展示逻辑和业务逻辑的分离实现。从理论上讲，这种
    RESTful Web 服务模式应该允许我们频繁地替换水槽，而无需重新设计整个厨房。
- en: '![](img/B14094_01_05.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_01_05.png)'
- en: 'Figure 1.5: Rich-client decoupled MVVM architecture'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5：富客户端解耦 MVVM 架构
- en: Observe the near doubling of boxes in the preceding diagram. Just because we
    separate the client from the server, we don't end up simplifying the architecture.
    If anything, the architecture surrounding the presentation logic becomes a lot
    more complicated. Both the client and server must implement their presentation/API,
    business, and persistence layers.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 观察前一个图中的框的数量几乎翻倍。仅仅因为我们把客户端和服务器分离开来，并不意味着我们最终简化了架构。实际上，围绕展示逻辑的架构变得更加复杂。客户端和服务器都必须实现它们的展示/API、业务和持久化层。
- en: Unfortunately, many early development efforts leveraging frameworks like Backbone
    and AngularJS collapsed under their own weight because they failed to implement
    the client-side architecture properly.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，许多利用 Backbone 和 AngularJS 等框架的早期开发工作因为未能正确实现客户端架构而失败。
- en: These early development efforts also suffered from ill-designed RESTful Web
    APIs. Most APIs didn't version their URIs, making it very difficult to introduce
    new functionality while supporting existing clients. Further, APIs often returned
    complicated data models exposing their internal relational data models to web
    apps. This design flaw creates a tight coupling between seemingly unrelated components/views
    written in HTML and models created in SQL. If you don't implement additional layers
    of code to translate or map the structure of data, then you create an unintentional
    and uncontrolled coupling between layers. Over time, dealing with such coupling
    becomes very expensive very quickly, in most cases necessitating significant rewrites.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这些早期的开发工作也受到了设计不良的 RESTful Web API 的影响。大多数 API 没有对它们的 URI 进行版本控制，这使得在支持现有客户端的同时引入新功能变得非常困难。此外，API
    通常返回复杂的数据模型，将它们的内部关系数据模型暴露给 Web 应用程序。这种设计缺陷在用 HTML 编写的看似无关的组件/视图和用 SQL 创建的模型之间创建了一个紧密的耦合。如果你不实现额外的代码层来转换或映射数据结构，那么你将在无意中创建一个层与层之间的非故意和不受控制的耦合。随着时间的推移，处理这种耦合会变得非常昂贵，在大多数情况下需要重大的重写。
- en: Today, we use the API layer to flatten the data model before sending it down
    to the client to avoid such problems. Newer technologies like GraphQL go a step
    further by exposing a well-defined data model and letting the consumer query for
    the exact data it needs. Using GraphQL, the number of HTTP requests and the amount
    of data transferred over-the-wire is optimal without the developers having to
    create many specialized APIs.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，我们使用 API 层在将其发送到客户端之前简化数据模型，以避免这些问题。像 GraphQL 这样的新技术更进一步，通过暴露一个定义良好的数据模型并让消费者查询所需的确切数据，从而优化了
    HTTP 请求的数量和通过线缆传输的数据量。使用 GraphQL，开发者无需创建许多专门的 API，就能实现最优的 HTTP 请求数量和数据传输量。
- en: Backbone and AngularJS proved that it was viable to create web applications
    that run natively in the browser. All SPA frameworks at the time relied on jQuery
    for DOM manipulation. Meanwhile, web standards continued to evolve, and evergreen
    browsers that support new standards started to become commonplace. However, change
    is constant, and the evolution of web technologies made it unsustainable to evolve
    this first generation of SPA frameworks gracefully.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone 和 AngularJS 证明了在浏览器中创建原生运行的 Web 应用程序是可行的。当时所有的 SPA 框架都依赖于 jQuery 进行
    DOM 操作。同时，Web 标准也在不断演进，支持新标准的永续浏览器开始变得普遍。然而，变化是永恒的，Web 技术的演进使得第一代 SPA 框架的优雅演进变得不可持续。
- en: The next generation of web frameworks needed to solve many problems; they needed
    to enforce good architecture; be designed to evolve with web standards; and be
    stable and scalable to enterprise needs without collapsing. Also, these new frameworks
    needed to gain acceptance from developers, who were burned out with too many rapid
    changes in the ecosystem. Remember, unhappy developers do not create successful
    businesses. Achieving these goals required a clean break from the past, so Angular
    and React emerged as platforms to address the problems of the past in different
    ways.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 新一代的 Web 框架需要解决许多问题；它们需要强制实施良好的架构；设计为与 Web 标准一起演进；并且稳定且可扩展以满足企业需求，而不会崩溃。此外，这些新框架需要获得开发者的认可，因为开发者对生态系统中的太多快速变化感到疲惫。记住，不快乐的开发者不会创造成功的业务。实现这些目标需要与过去彻底决裂，因此
    Angular 和 React 作为平台以不同的方式解决了过去的问题。
- en: Introduction to Angular
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 简介
- en: Angular is an open source project maintained by Google and a community of developers.
    The new Angular platform is vastly different from the legacy framework you may
    have used in the past. In collaboration with Microsoft, Google made TypeScript
    the default language for Angular. TypeScript is a superset of JavaScript that
    enables developers to target legacy browsers such as Internet Explorer 11, while
    allowing them to write modern JavaScript code that works in evergreen browsers
    such as Chrome, Firefox, and Edge. The legacy versions of Angular, versions in
    the 1.x.x range, are referred to as AngularJS. Version 2.0.0 and higher versions
    are called Angular. Where AngularJS is a monolithic JavaScript SPA framework,
    Angular is a platform that is capable of targeting browsers, hybrid-mobile frameworks,
    desktop applications, and server-side rendered views.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 是由 Google 和一群开发者维护的开源项目。新的 Angular 平台与您过去可能使用过的传统框架大相径庭。在与微软合作的过程中，Google
    将 TypeScript 定为 Angular 的默认语言。TypeScript 是 JavaScript 的超集，它使开发者能够针对旧版浏览器，如 Internet
    Explorer 11，同时允许他们编写在现代浏览器（如 Chrome、Firefox 和 Edge）上运行的现代 JavaScript 代码。Angular
    的旧版本，版本号在 1.x.x 范围内，被称为 AngularJS。2.0.0 版本及更高版本被称为 Angular。AngularJS 是一个单体 JavaScript
    单页应用（SPA）框架，而 Angular 是一个能够针对浏览器、混合移动框架、桌面应用程序和服务器端渲染视图的平台。
- en: Upgrading to the new AngularJS was risky and costly because even minor updates
    introduced new coding patterns and experimental features. Each update introduced
    deprecations or the refactoring of old features, which required rewriting large
    portions of code. Also, updates were delivered in uncertain intervals, making
    it impossible for a team to plan resources to upgrade to a new version. The release
    methodology eventually led to an unpredictable, ever-evolving framework with seemingly
    no guiding hand to carry code bases forward. If you used AngularJS, you likely
    were stuck on a particular version, because the specific architecture of your
    code base made it very difficult to move to a new version. In 2018, the Angular
    team released the last major update to AngularJS with version 1.7\. This release
    marked the beginning of the end for the legacy framework, with planned end-of-life
    in July 2021.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 升级到新的 AngularJS 是有风险且昂贵的，因为即使是微小的更新也引入了新的编码模式和实验性功能。每次更新都引入了弃用或旧功能的重构，这需要重写大量代码。此外，更新以不确定的间隔交付，使得团队无法规划资源以升级到新版本。发布方法最终导致了一个不可预测、不断演变的框架，似乎没有任何指导之手来推动代码库的发展。如果您使用了
    AngularJS，您可能被困在特定版本上，因为您的代码库的特定架构使得迁移到新版本非常困难。2018 年，Angular 团队发布了 AngularJS
    的最后一个主要更新，版本号为 1.7。这次发布标志着旧框架的终结的开始，预计在 2021 年 7 月停止使用。
- en: 'Angular improves upon AngularJS in every way imaginable. The platform follows
    semver, as defined at [https://semver.org/](../Text/Chapter_1.xhtml), where minor
    version increments denote new feature additions and potential deprecation notices
    for the second next major version, but no breaking changes. Furthermore, the Angular
    team at Google has committed to a deterministic release schedule with major versions
    released every 6 months. After this 6-month development window, starting with
    Angular 4, all major releases receive LTS with bug fixes and security patches
    for an additional 12 months. From release to end-of-life, each major version receives
    updates for 18 months. Refer to the following chart for the tentative release
    and support schedule for AngularJS and Angular:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Angular在各个方面都优于AngularJS。该平台遵循[https://semver.org/](../Text/Chapter_1.xhtml)中定义的semver规范，其中次要版本的增加表示新功能添加和为下一个主要版本的潜在弃用通知，但没有破坏性变更。此外，谷歌的Angular团队承诺采用确定性的发布计划，每6个月发布一个主要版本。在此6个月的开发窗口之后，从Angular
    4开始，所有主要版本都将获得LTS支持，包括额外的12个月的错误修复和安全补丁。从发布到生命周期的结束，每个主要版本都将接收为期18个月的更新。请参考以下图表，了解AngularJS和Angular的预期发布和支持计划：
- en: '![](img/B14094_01_06.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_01_06.png)'
- en: 'Figure 1.6: Tentative Angular release and support schedule'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6：Angular的预期发布和支持计划
- en: So, what does this mean for you? You can be confident that your Angular code
    is supported and backward compatible for an approximate time frame of 24 months,
    even if you make no changes to it. So, if you wrote an Angular app in version
    9 in February 2020, your code is runtime compatible with Angular 10 and will be
    supported until October 2021\. To upgrade your Angular 9 code to Angular 11, you
    need to ensure that you're not using any of the deprecated APIs that receive a deprecation
    notice in Angular 10.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这对你们意味着什么呢？你可以确信，即使你不对它做出任何更改，你的Angular代码在约24个月的时间内也将得到支持和向后兼容。所以，如果你在2020年2月编写了一个版本9的Angular应用，你的代码与Angular
    10具有运行时兼容性，并将得到支持直到2021年10月。要将你的Angular 9代码升级到Angular 11，你需要确保你没有使用Angular 10中收到弃用通知的任何弃用API。
- en: In practice, most deprecations are minor and are straightforward to refactor.
    Unless you are working with low-level APIs for highly specialized user experiences,
    the time and effort it takes to update your code base should be minimal. However,
    this is a promise made by Google and not a contract. The Angular team has a significant
    incentive to ensure backward compatibility because Google runs around 1,000+ Angular
    apps with a single version of Angular active at any one time throughout the organization.
    So, by the time you read this, all of Google's 1,000+ apps will be running on
    the latest version of Angular.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，大多数弃用都是微小的，并且重构起来很简单。除非你正在使用为高度专业化的用户体验的低级API，否则更新你的代码库所需的时间和精力应该是微不足道的。然而，这是谷歌做出的承诺，而不是合同。Angular团队有重大动力确保向后兼容性，因为谷歌在组织内部运行着大约1,000多个Angular应用，任何时候只有一个版本的Angular处于活跃状态。因此，在你阅读这篇文章的时候，谷歌的所有1,000多个应用都将运行在Angular的最新版本上。
- en: You may think Google has infinite resources to update thousands of app regularly.
    Like any organization, Google too has limited resources, and not every app is
    actively maintained by a dedicated team. So, the Angular team must ensure compatibility
    through automated tests and make it as painless as possible to move through major
    releases going forward. In Angular 6, the update process was made much simpler
    with the introduction of `ng update`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为谷歌有无限的资源来定期更新数千个应用。像任何组织一样，谷歌的资源也是有限的，并不是每个应用都有专门的团队进行积极维护。因此，Angular团队必须通过自动化测试确保兼容性，并尽可能使未来的主要版本升级过程变得无痛。在Angular
    6中，通过引入`ng update`，更新过程变得更加简单。
- en: The Angular team continually improves its release process with automated CLI
    tools to make upgrades of deprecated functionality a mostly automated, reasonable
    endeavor. The benefits of this strategy were demonstrated by Air France and KLM
    being able to reduce their upgrade times from 30 days in Angular 2 to 1 day in
    Angular 7.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Angular团队通过引入自动化的CLI工具不断改进其发布流程，使得弃用功能的升级基本上是自动化的、合理的努力。这种策略的好处由法国航空和荷兰皇家航空所证明，他们能够将Angular
    2中的升级时间从30天减少到Angular 7中的1天。
- en: 'A predictable and well-supported upgrade process is excellent news for developers
    and organizations alike. Instead of being perpetually stuck on a legacy version
    of Angular, you can plan and allocate the necessary resources to keep moving your
    application to the future without costly rewrites. As I wrote in a 2017 blog post,
    *The Best New Feature of Angular 4*, at `bit.ly/NgBestFeature`, the message is
    clear:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 可预测且得到良好支持的升级过程对开发者和组织来说都是好消息。你不必永远停留在 Angular 的遗留版本上，你可以计划和分配必要的资源，以保持你的应用程序向未来迁移，而无需昂贵的重写。正如我在
    2017 年的一篇博客文章中写的，《Angular 4 的最佳新特性》在 `bit.ly/NgBestFeature`，信息很明确：
- en: '**For Developers and Managers**: Angular is here to stay, so you should be
    investing your time, attention, and money in learning it – even if you''re currently
    in love with some other framework.'
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**对于开发者和管理者**：Angular 将会持续存在，因此你应该投入你的时间、注意力和金钱来学习它——即使你现在可能对其他框架情有独钟。'
- en: ''
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**For Decision Makers (CIOs, CTOs, and so on)**: Plan to begin your transition
    to Angular in the next 6 months. It''ll be an investment you''ll be able to explain
    to business-minded people, and your investment will pay dividends for many years
    to come, long after the initial LTS window expires, with graceful upgrade paths
    to Angular vNext and beyond.'
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**对于决策者（CIO、CTO 等等）**：计划在接下来的 6 个月内开始过渡到 Angular。这将是一项你可以向商业人士解释的投资，你的投资将在未来多年带来回报，即使是在初始
    LTS 窗口到期后，也有优雅的升级路径到 Angular vNext 以及更远。'
- en: 'So, why do Google (Angular) and Microsoft (TypeScript and Visual Studio Code)
    give away such technologies for free? There are multiple reasons:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么 Google（Angular）和 Microsoft（TypeScript 和 Visual Studio Code）会免费提供这样的技术？有多个原因：
- en: A sophisticated framework that makes it easy to develop web apps is a demonstration
    of technical prowess, which retains and attracts developer talent
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个使开发 Web 应用程序变得容易的复杂框架，是技术实力的展示，它保留并吸引开发者人才。
- en: An open source framework enables the proving and debugging of new ideas and
    tools with millions of developers at scale
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开源框架能够以规模的方式验证和调试新想法和工具，拥有数百万的开发者。
- en: Allowing developers to create great web experiences more quickly, ultimately
    drives more business for Google and Microsoft
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许开发者更快地创建出色的 Web 体验，最终为 Google 和 Microsoft 带来更多商业机会。
- en: I don't see any nefarious intent here and welcome open, mature, and high-quality
    tools that, if necessary, I can tinker with and bend to my own will. Not having
    to pay for a support contract for a proprietary piece of tech is a welcome bonus.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里看不到任何恶意意图，并欢迎开放、成熟和高品质的工具，如果需要，我可以对其进行调整以满足我的意愿。不必为专有技术的支持合同付费是一个受欢迎的额外好处。
- en: Beware, looking for Angular help on the web may be tricky. You'll note that
    sometimes Angular is referred to as Angular 2 or Angular 4\. At times, both Angular
    and AngularJS are referred to as AngularJS. This is incorrect. The documentation
    for Angular is at [angular.io](../Text/Chapter_1.xhtml). If you land on [angularjs.org](../Text/Chapter_1.xhtml),
    you'll be reading about the legacy AngularJS framework.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 小心，在网上寻找 Angular 帮助可能会很棘手。你会注意到，有时 Angular 被称为 Angular 2 或 Angular 4。有时，Angular
    和 AngularJS 都被称为 AngularJS。这是不正确的。Angular 的文档位于 [angular.io](https://angular.io/guide/releases)
    上。如果你访问了 [angularjs.org](https://angularjs.org)，你将阅读关于遗留的 AngularJS 框架的内容。
- en: For the latest updates on the upcoming Angular releases, view the official release
    schedule at [https://angular.io/guide/releases](../Text/Chapter_1.xhtml).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解即将发布的 Angular 版本的最新更新，请查看官方发布计划 [https://angular.io/guide/releases](https://angular.io/guide/releases)。
- en: Angular's philosophy
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular 的理念
- en: Your time is valuable, and your happiness is paramount, so you must be careful
    in choosing the technologies to invest your time in. With this in mind, we need
    to answer the question of why learn Angular, but not React, Vue, or some other
    framework? Angular is a great framework to start learning. The framework and the
    tooling help you get off the ground quickly and continue being successful with
    a vibrant community and high-quality UI libraries you can use to deliver exceptional
    web applications. React and Vue are great frameworks, with their strengths and
    weaknesses. Every tool has its place and purpose.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你的时间是宝贵的，你的幸福至关重要，因此你必须谨慎选择投入时间的科技。考虑到这一点，我们需要回答为什么学习 Angular，而不是 React、Vue
    或其他框架？Angular 是一个很好的框架开始学习。该框架和工具可以帮助你快速起步，并凭借充满活力的社区和高质量的 UI 库继续成功，这些库可以帮助你交付卓越的
    Web 应用程序。React 和 Vue 也是很好的框架，各有其优势和劣势。每个工具都有其位置和目的。
- en: In some cases, React is the right choice for a project, and in other cases,
    Vue is the right one. Regardless, becoming somewhat proficient in other web frameworks
    can only help further your understanding of Angular and make you a better developer
    overall. SPAs such as Backbone and AngularJS grabbed my full attention in 2012
    when I realized the importance of decoupling frontend and backend concerns. Server-side
    rendered templates are nearly impossible to maintain and are the root cause of
    many expensive rewrites of software systems. If you care about creating maintainable
    software, then you must abide by the prime directive; keep business logic implemented
    behind the API decoupled from presentation logic implemented in the UI.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，React 是项目的正确选择，而在其他情况下，Vue 才是正确的选择。无论如何，对其他 Web 框架的熟练掌握只能有助于进一步加深你对 Angular
    的理解，并使你成为一个更好的开发者。像 Backbone 和 AngularJS 这样的单页应用（SPAs）在 2012 年引起了我的极大关注，当时我意识到解耦前端和后端关注点的重要性。服务器端渲染的模板几乎无法维护，并且是许多昂贵的软件系统重写的根本原因。如果你关心创建可维护的软件，那么你必须遵守首要指令；将业务逻辑实现保持在
    API 解耦于 UI 中实现的表现逻辑之后。
- en: Angular neatly fits the Pareto principle or the 80-20 rule. It has become a
    mature and evolving platform, allowing you to achieve 80% of tasks with 20% of
    the effort. As mentioned in the previous section, every major release is supported
    for 18 months, creating a continuum of learning, staying up to date, and the deprecation
    of old features. From the perspective of a full-stack developer, this continuum
    is invaluable, since your skills and training will remain relevant and fresh for
    many years to come.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 优雅地符合帕累托原则或 80-20 规则。它已经成为一个成熟且不断发展的平台，让你只需付出 20% 的努力就能完成 80% 的工作。正如前文所述，每个主要版本都支持
    18 个月，创造了一个持续的学习、保持更新和废弃旧特性的连续体。从全栈开发者的角度来看，这个连续体是无价的，因为你的技能和培训将在未来许多年里保持相关和新鲜。
- en: The philosophy behind Angular is to err on the side of configuration over convention.
    Convention-based frameworks, although they may seem elegant from the outside,
    make it difficult for newcomers to pick up the framework. Configuration-based
    frameworks, however, aim to expose their inner workings through explicit configuration
    and hooks, where you can attach your custom behavior to the framework. In essence,
    where AngularJS had tons of magic, which can be confusing, unpredictable, and
    challenging to debug, Angular tries to be non-magical.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 的哲学是在配置和惯例之间偏向配置。基于惯例的框架，尽管从外表上看可能很优雅，但对于新手来说，学习框架会变得困难。然而，基于配置的框架旨在通过显式配置和钩子来揭示其内部工作原理，你可以将自定义行为附加到框架上。本质上，AngularJS
    有很多魔法，可能会让人困惑、不可预测，且难以调试，而 Angular 则试图避免这些魔法。
- en: 'Configuration over convention results in verbose coding. Verbosity is a good
    thing. Terse code is the enemy of maintainability, only benefiting the original
    author. As Andy Hunt and David Thomas put it in *The Pragmatic Programmer*:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 配置优于惯例导致代码冗长。冗长是好事。简洁的代码是可维护性的敌人，只对原始作者有利。正如 Andy Hunt 和 David Thomas 在《实用程序员》一书中所说：
- en: Remember that you (and others after you) will be reading the code many hundreds
    of times, but only writing it a few times.
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 记住，你（以及你之后的人）将多次阅读代码，但只编写它几次。
- en: 'Further, Andy Hunt''s *Law of Design* dictates:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Andy Hunt 的“设计法则”规定：
- en: If you can't rip every piece out easily, then the design sucks.
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你不能轻松地移除每一部分，那么设计就是失败的。
- en: Verbose, decoupled, cohesive, and encapsulated code is the key to future-proofing
    your code. Angular, through its various mechanisms, enables the proper execution
    of these concepts. It gets rid of many custom conventions invented in AngularJS,
    such as `ng-click`, and introduces a more natural language that builds on the
    existing HTML elements and properties. As a result, `ng-click` becomes `(click)`,
    extending HTML rather than replacing it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 冗长、解耦、凝聚和封装的代码是确保代码未来兼容性的关键。Angular 通过其各种机制，使这些概念得到适当的执行。它摒弃了许多 AngularJS 中发明的自定义惯例，如
    `ng-click`，并引入了一种更自然的语言，它建立在现有的 HTML 元素和属性之上。因此，`ng-click` 变成了 `(click)`，扩展了 HTML
    而不是取代它。
- en: Next, we'll go over Angular's evergreen mindset and the reactive programming
    paradigm, which are the latest extensions of Angular's initial philosophy.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍 Angular 的持续更新心态和响应式编程范式，这些都是 Angular 初始哲学的最新扩展。
- en: Angular Evergreen
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular 持续更新
- en: When you're learning Angular, you're not learning one specific version of Angular,
    but a platform that is continually evolving. Since the first drafts, I designed
    this book with the idea of deemphasizing the specific version of Angular you're
    using. The Angular team champions this idea. Over the years, I have had many conversations
    with the Angular team and thought leaders within the community and listened to
    many presentations. As a result, I can affirm that you can depend on Angular as
    a mature web development platform. Angular frequently receives updates with great
    attention to backward compatibility. Furthermore, any code that is made incompatible
    by a new version is brought forward with help from automated tools or explicit
    guidance on how to update your code via [update.angular.io](../Text/Chapter_1.xhtml),
    so you're never left guessing or scouring the internet for answers. The Angular
    team is committed to ensuring you – the developer – have the best web development
    experience possible.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在学习Angular时，你不仅仅是在学习Angular的一个特定版本，而是在学习一个不断发展的平台。自从最初的草案以来，我设计这本书时，就有一个想法，那就是淡化你所使用的Angular的具体版本。Angular团队支持这个想法。多年来，我与Angular团队和社区内的思想领袖进行了许多对话，并听了许多演讲。因此，我可以肯定地说，你可以依赖Angular作为一个成熟的Web开发平台。Angular经常更新，并非常关注向后兼容性。此外，任何由于新版本而变得不兼容的代码，都会在自动化工具的帮助下或通过[update.angular.io](../Text/Chapter_1.xhtml)上的明确指导来更新代码，这样你就不会感到困惑或在网上寻找答案。Angular团队致力于确保你——开发者——拥有最佳的Web开发体验。
- en: To bring this idea front and center with developers, several colleagues and
    I have developed and published a Visual Studio Code extension called Angular Evergreen.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这个想法突出给开发者，我和几位同事一起开发和发布了名为Angular Evergreen的Visual Studio Code扩展。
- en: '![](img/B14094_01_07.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_01_07.png)'
- en: 'Figure 1.7: Angular Evergreen VS Code extension'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7：Angular Evergreen VS Code扩展
- en: This extension detects your current version of Angular and compares it to the
    latest and next releases of Angular. Releases that are labeled next are meant
    for early adopters and for testing the compatibility of your code with an upcoming
    version of Angular. Do not use next-labeled releases for production deployments.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此扩展检测您当前的Angular版本，并将其与Angular的最新和下一个版本进行比较。标记为“下一个”的版本是为早期采用者和测试代码与即将推出的Angular版本兼容性而设计的。请不要在生产部署中使用标记为“下一个”的版本。
- en: Find more information, feature requests, and bug reports on the Angular Evergreen
    extension at [https://AngularEvergreen.com](../Text/Chapter_1.xhtml).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular Evergreen扩展中查找更多信息、功能请求和错误报告，请访问[https://AngularEvergreen.com](../Text/Chapter_1.xhtml)。
- en: One of the critical components of Angular that allows the platform to remain
    evergreen is TypeScript. TypeScript allows new features to be implemented efficiently
    while providing support for older browsers, so your code can reach the widest
    audience possible.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Angular的一个关键组件是TypeScript，它允许平台保持始终如一。TypeScript允许高效地实现新功能，同时为旧浏览器提供支持，这样你的代码就可以触及尽可能广泛的受众。
- en: TypeScript
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TypeScript
- en: Angular is coded using TypeScript. TypeScript was created by Anders Hejlsberg
    of Microsoft to address several major issues with applying JavaScript at the enterprise-scale.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Angular使用TypeScript进行编码。TypeScript是由微软的Anders Hejlsberg创建的，旨在解决在企业规模上应用JavaScript时遇到的一些主要问题。
- en: Anders Hejlsberg is the creator of Turbo Pascal and C#, and is the chief architect
    of Delphi. Anders designed C# to be a developer-friendly language built upon the
    familiar syntax of C and C++. As a result, C# became the language behind Microsoft's
    popular .NET Framework. TypeScript shares a similar pedigree with Turbo Pascal
    and C# and their ideals, which made them a great success.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Anders Hejlsberg是Turbo Pascal和C#的创造者，同时也是Delphi的首席架构师。Anders设计了C#，使其成为一个开发者友好的语言，它建立在C和C++熟悉的语法之上。因此，C#成为了微软流行的.NET
    Framework背后的语言。TypeScript与Turbo Pascal和C#有着相似的血统和理念，这使得它们取得了巨大的成功。
- en: JavaScript is a dynamically interpreted language, where the code you write is
    parsed and understood by the browser at runtime. Statically typed languages like
    Java or C# have an additional compilation step, where the compiler can catch programming
    and logic errors during compile time. It is much cheaper to detect and fix bugs
    at compile time versus runtime. TypeScript brings the benefits of statically typed
    languages to JavaScript by introducing types and generics to the language. However,
    TypeScript does not include a compilation step, but instead a transpilation step.
    A compiler builds code into machine language with C/C++ or **intermediary language**
    (**IL**) with Java or C#. A transpiler, however, merely translates code from one
    dialect to another. So, when TypeScript code is built, compiled, or transpiled,
    the result is pure JavaScript.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是一种动态解释语言，你编写的代码在运行时被浏览器解析和理解。像Java或C#这样的静态类型语言有一个额外的编译步骤，编译器可以在编译时捕获编程和逻辑错误。与运行时相比，在编译时检测和修复错误要便宜得多。TypeScript通过向语言引入类型和泛型，将静态类型语言的优点带到了JavaScript。然而，TypeScript不包括编译步骤，而是包括转译步骤。编译器将代码编译成机器语言（使用C/C++）或Java或C#的**中间语言**（**IL**）。然而，转译器只是将代码从一种方言翻译成另一种方言。因此，当TypeScript代码被构建、编译或转译时，结果是纯JavaScript。
- en: JavaScript's official name is ECMAScript. The feature set and the syntax of
    the language is maintained by the ECMA Technical Committee 39 or TC39 for short.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的官方名称是ECMAScript。该语言的功能集和语法由ECMA技术委员会39或简称TC39维护。
- en: 'Transpilation has another significant benefit. The same tooling that converts
    TypeScript to JavaScript can be used to rewrite JavaScript with a new syntax to an older
    version that older browsers can parse and execute. Between 1999 and 2009, the JavaScript
    language didn''t see any new features. ECMAScript abandoned version 4 due to various
    technical and political reasons. Starting with the introduction of ES5 and then
    ES2015 (also known as ES6), browser vendors have struggled to implement new JavaScript
    features within their browsers. As a result, user adoption of these new features
    has remained low. However, these new features meant developers could write code
    more productively. This created a gap known as the JavaScript Feature Gap, as
    demonstrated by the graphic that follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 转译还有一个重要的好处。将TypeScript转换为JavaScript的同一种工具可以用来用新的语法重写JavaScript，以便旧版浏览器可以解析和执行。在1999年至2009年之间，JavaScript语言没有看到任何新特性。由于各种技术和政治原因，ECMAScript放弃了版本4。从ES5的引入开始，然后是ES2015（也称为ES6），浏览器供应商一直在努力在其浏览器中实现新的JavaScript特性。因此，这些新特性的用户采用率一直很低。然而，这些新特性意味着开发者可以更高效地编写代码。这创造了一个被称为JavaScript特性差距的差距，如下面的图形所示：
- en: '![](img/B14094_01_08.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_01_08.png)'
- en: 'Figure 1.8: The JavaScript Feature Gap'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.8：JavaScript特性差距
- en: The JavaScript Feature Gap is a sliding one, as TC39 has committed to updating
    JavaScript every year going forward. As a result, TypeScript represents the past,
    present, and future of JavaScript. You can use future features of JavaScript today
    and still be able to target browsers of the past to maximize the audience you
    can reach.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript特性差距是一个滑动差距，因为TC39已经承诺每年更新JavaScript。因此，TypeScript代表了JavaScript的过去、现在和未来。你可以使用今天的JavaScript的未来特性，同时仍然能够针对旧版浏览器，以最大化你能够触及的受众。
- en: Now, let's go over Angular's underlying architecture.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来探讨Angular的底层架构。
- en: Basic Angular architecture
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本Angular架构
- en: 'Angular follows the MV* pattern, which is a hybrid of the MVC and MVVM patterns.
    Previously, we went over the MVC pattern. At a high-level, the architecture of
    both patterns is relatively similar, as shown in the diagram that follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Angular遵循MV*模式，这是MVC和MVVM模式的混合体。之前，我们讨论了MVC模式。从高层次来看，这两种模式的架构相对相似，如下面的图所示：
- en: '![](img/B14094_01_09.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_01_09.png)'
- en: 'Figure 1.9: MV* architecture'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.9：MV*架构
- en: The new concept here is the ViewModel, which represents the glue code that connects
    your view to your model or service. In Angular, this glue is known as binding.
    Whereas MVC frameworks like Backbone or React have to call a `render` method to
    process their HTML templates, in Angular, this process is seamless and transparent
    for the developer. Binding is what differentiates an MVC application from an MVVM
    one.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的新概念是ViewModel，它代表了连接你的视图到你的模型或服务的粘合代码。在Angular中，这种粘合被称为绑定。与像Backbone或React这样的MVC框架必须调用`render`方法来处理它们的HTML模板不同，在Angular中，这个过程对开发者来说是无缝且透明的。绑定是区分MVC应用程序和MVVM应用程序的关键。
- en: 'The most basic unit of an Angular app is a component. A component is the combination
    of a JavaScript class written in TypeScript and an Angular template written in
    HTML, CSS, and TypeScript. The class and the template fit together like a jigsaw
    puzzle through bindings, so that they can communicate with each other, as shown
    in the diagram that follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Angular应用的最基本单元是一个组件。组件是由TypeScript编写的JavaScript类和由HTML、CSS和TypeScript编写的Angular模板的组合。通过绑定，类和模板就像拼图一样相互匹配，从而可以相互通信，如下面的图所示：
- en: '![](img/B14094_01_10.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_01_10.png)'
- en: 'Figure 1.10: Anatomy of a component'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.10：组件的解剖结构
- en: Classes are an **Object-Oriented Programming** (**OOP**) construct. If you invest
    the time to dig deeper into the OOP paradigm, you are going to improve your understanding
    of how Angular works vastly. The OOP paradigm allows for the **dependency injection**
    (**DI**) of dependent services in your components, so you can make HTTP calls
    or trigger a toast message to be displayed to the user without pulling that logic
    into your component or duplicating your code. DI makes it very easy for developers
    to use many interdependent services without having to worry about the order of
    instantiation, initialization, or destruction of such objects from memory.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 类是面向对象编程（**OOP**）的结构。如果你投入时间去深入挖掘OOP范式，你将大大提高你对Angular工作原理的理解。OOP范式允许在组件中**依赖注入**（**DI**）依赖的服务，这样你就可以进行HTTP调用或触发显示给用户的提示消息，而无需将这种逻辑拉入你的组件或复制你的代码。DI使得开发者能够非常容易地使用许多相互依赖的服务，而无需担心这些对象从内存中实例化、初始化或销毁的顺序。
- en: Angular templates also allow similar reuse of code via directives, pipes, user
    controls, and other components. These are pieces of code that encapsulate highly
    interactive end user code. This kind of interactivity code is often complicated
    and convoluted and must be kept isolated from business logic or presentation logic
    to keep your code maintainable.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Angular模板还允许通过指令、管道、用户控件和其他组件实现类似的代码重用。这些代码片段封装了高度交互的最终用户代码。这类交互代码通常很复杂且错综复杂，必须与业务逻辑或展示逻辑保持隔离，以保持代码的可维护性。
- en: All Angular components, services, directives, pipes, and user controls are organized
    under modules. Each Angular app is bootstrapped by a root module that renders
    your first component and injects any services and prepares dependencies it may
    require. You may introduce children modules to enable capabilities like lazy loading
    so that you don't have to deliver all components of your web application to the
    browser all at once. For instance, there is no use sending code for the admin
    dashboard to a user without admin privileges.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 所有Angular组件、服务、指令、管道和用户控件都组织在模块下。每个Angular应用都通过一个根模块启动，该模块渲染你的第一个组件，并注入任何所需的服务，准备依赖项。你可以引入子模块以启用诸如懒加载等能力，这样你就不必一次性将你的Web应用的所有组件交付给浏览器。例如，没有管理员权限的用户发送管理员仪表板的代码是没有用的。
- en: Angular makes heavy use of the RxJS library, which introduces reactive development
    patterns to Angular, as opposed to more traditional imperative development patterns.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Angular大量使用了RxJS库，这为Angular引入了响应式开发模式，而不是更传统的命令式开发模式。
- en: The reactive development paradigm
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式开发范式
- en: Angular supports multiple styles of programming. The plurality of coding styles
    is one of the great reasons why it is approachable to programmers with varying
    backgrounds. Whether you come from an object-oriented programming background or
    you're a staunch believer of functional programming, you can build viable apps
    using Angular. In *Chapter 3*, *Creating a Basic Angular App*, you'll begin leveraging
    reactive programming concepts in building the LocalCast Weather app.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Angular支持多种编程风格。多种编程风格是它对具有不同背景的程序员友好的一大原因。无论你是来自面向对象编程的背景，还是你是一个坚定的函数式编程信徒，你都可以使用Angular构建可行的应用。在*第3章*，*创建基本的Angular应用*中，你将开始利用响应式编程概念来构建LocalCast天气应用。
- en: As a programmer, you are most likely used to imperative programming. Imperative
    programming is when you, as the programmer, write sequential code describing everything
    that must be done in the order that you've defined them and the state of your
    application depending on just the right variables to be set to function correctly.
    You write loops, conditionals, and call functions; you fire off events and expect
    them to be handled. Imperative and sequential logic is how you're used to coding.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，你很可能习惯于命令式编程。命令式编程是指作为程序员的你编写顺序代码，描述必须按你定义的顺序执行的所有操作，以及你的应用程序的状态取决于正确设置的变量以确保正确运行。你编写循环、条件语句并调用函数；你触发事件并期望它们被处理。命令式和顺序逻辑是你习惯的编码方式。
- en: Reactive programming is a subset of functional programming. In functional programming,
    you can't rely on variables you've set previously. Every function you write must
    stand on its own, receive its own set of inputs and return a result without being
    influenced by the state of an outer function or class. Functional programming
    supports **Test Driven Development** (**TDD**) very well because every function
    is a unit that can be tested in isolation. As such, every function you write becomes
    composable. So, you can mix, match, and combine any function you write with any
    other and construct a series of calls that yield the result you expect.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式编程是函数式编程的一个子集。在函数式编程中，你不能依赖你之前设置的变量。你写的每个函数都必须独立站立，接收它自己的输入集并返回一个结果，而不受外部函数或类状态的任何影响。函数式编程很好地支持**测试驱动开发**（**TDD**），因为每个函数都是一个可以独立测试的单元。因此，你写的每个函数都变得可组合。所以，你可以混合、匹配和组合你写的任何函数，构建一系列调用，以产生你期望的结果。
- en: Reactive programming adds a twist to functional programming. You no longer deal
    with pure logic, but an asynchronous data stream that you transform and mold into
    any shape you need with a composable set of functions. So, when you subscribe
    to an event in a reactive stream, then you're shifting your coding paradigm from
    reactive programming to imperative programming.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式编程给函数式编程增添了新意。你不再处理纯逻辑，而是处理一个异步数据流，你可以使用一组可组合的函数将其塑造成你需要的任何形状。因此，当你订阅反应流中的事件时，你将你的编码范式从反应式编程转变为命令式编程。
- en: Later in the book, when implementing the LocalCast Weather app, you'll leverage
    `subscribe` in action in two places, in the `CurrentWeather` and `CitySearch`
    components.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后期，当实现LocalCast天气应用时，你将在`CurrentWeather`和`CitySearch`组件中利用`subscribe`的实际操作。
- en: Consider the following example, aptly put by Mike Pearson in his presentation
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下例子，由迈克·皮尔逊在他的演示中恰如其分地提出
- en: '*Thinking Reactively: Most Difficult*, of providing instructions to get hot
    water from the faucet to help understand the differences between imperative and
    reactive programming:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*思考反应式编程：最难的部分*，提供从水龙头获取热水的指令，以帮助理解命令式编程和反应式编程之间的区别：'
- en: '| **Instructions to get hot water from the faucet** |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| **从水龙头获取热水的指令** |'
- en: '|  | **Imperative** | **Reactive** |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '|  | **命令式** | **反应式** |'
- en: '| 0 | Initial state: Water is off | Initial state: Water is off |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 初始状态：水是关闭的 | 初始状态：水是关闭的 |'
- en: '| 1 | Grab a hose | Turn on the faucet for hot water |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 拿起水管 | 打开热水龙头 |'
- en: '| 2 | Spray water into the heater |  |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 将水喷入加热器 |  |'
- en: '| 3 | Turn on the faucet for hot water |  |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 打开热水龙头 |  |'
- en: '| 4 | Send a text to the utility company to get gas |  |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 向公用事业公司发送短信以获取燃气 |  |'
- en: '| 5 | Wait for hot water |  |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 等待热水 |  |'
- en: '| 6 | Undo your steps to restore the initial state | Undo your steps to restore
    the initial state |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 撤销你的步骤以恢复初始状态 | 撤销你的步骤以恢复初始状态 |'
- en: As you can see, with imperative programming, you must define every step of the
    code execution. Every step depends on the previous step, which means you must
    consider the state of the environment to ensure a successful operation. In such
    an environment, it is easy to forget a step and very difficult to test the correctness
    of every individual step. In functional reactive programming, you work with asynchronous
    data streams resulting in a stateless workflow that is easy to compose with other
    actions.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在命令式编程中，您必须定义代码执行的每一步。每一步都依赖于前一步，这意味着您必须考虑环境的状态以确保操作成功。在这样的环境中，很容易忘记一个步骤，而且很难测试每个单独步骤的正确性。在函数式反应式编程中，您与异步数据流一起工作，从而产生一个无状态的流程，易于与其他操作组合。
- en: RxJS is the library that makes it possible to implement your code in the reactive
    paradigm.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: RxJS是使您能够在响应式范式下实现代码的库。
- en: RxJS
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RxJS
- en: RxJS stands for Reactive Extensions, which is a modular library that enables
    reactive programming, which itself is an asynchronous programming paradigm and
    allows the manipulation of data streams through transformation, filtering, and
    control functions. You can think of reactive programming as an evolution of event-based
    programming.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: RxJS代表响应式扩展，这是一个模块化库，它使响应式编程成为可能，响应式编程本身是一种异步编程范式，允许通过转换、过滤和控制函数来操作数据流。您可以将响应式编程视为基于事件编程的进化。
- en: Reactive data streams
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应式数据流
- en: In event-driven programming, you would define an event handler and attach it
    to an event source. In more concrete terms, if you had a **Save** button, which
    exposes an `onClick` event, you would implement a `confirmSave` function which,
    when triggered, would show a popup to ask the user **Are you sure?**. Look at
    the following diagram for a visualization of this process.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件驱动编程中，您会定义一个事件处理程序并将其附加到事件源。更具体地说，如果您有一个**保存**按钮，它公开了一个`onClick`事件，您将实现一个`confirmSave`函数，当它被触发时，会显示一个弹出窗口询问用户**您确定吗**？查看以下图表以了解此过程的可视化。
- en: '![](img/B14094_01_11.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_01_11.png)'
- en: 'Figure 1.11: Event-driven implementation'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.11：事件驱动实现
- en: In short, you would have an event firing once per user action. If the user clicks
    on the **Save** button many times, this pattern will gladly render as many popups
    as there are clicks, which doesn't make much sense.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，您会有一个事件在每次用户操作时触发。如果用户多次点击**保存**按钮，这个模式将乐意渲染与点击次数一样多的弹出窗口，这并没有太多意义。
- en: The publish-subscribe (pub/sub) pattern is a different type of event-driven
    programming. In this case, we can write multiple handlers to all act on the result
    of a given event simultaneously. Let's say that your app just received some updated
    data. The publisher goes through its list of subscribers and passes on the updated
    data to each of them.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 发布/订阅（pub/sub）模式是另一种类型的事件驱动编程。在这种情况下，我们可以为给定事件的每个结果编写多个处理程序，同时对其执行操作。假设您的应用程序刚刚接收了一些更新数据。发布者会遍历其订阅者列表，并将更新数据传递给每个订阅者。
- en: 'Refer to the following diagram on how the updated data event triggers multiple
    functions:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下图表了解更新数据事件如何触发多个函数：
- en: An `updateCache` function updates your local cache with new data
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`updateCache`函数使用新数据更新您的本地缓存
- en: A `fetchDetails` function retrieves further details about the data from the
    server
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`fetchDetails`函数从服务器检索有关数据的更多详细信息
- en: A `showToastMessage` function informs the user that the app just received new
    data
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`showToastMessage`函数通知用户应用程序刚刚接收了新数据
- en: '![](img/B14094_01_12.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_01_12.png)'
- en: 'Figure 1.12: Pub/sub pattern implementation'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.12：发布/订阅模式实现
- en: All these events can happen asynchronously; however, the `fetchDetails` and
    `showToastMessage` functions will be receiving more data than they need, and it
    can get convoluted to try to compose these events in different ways to modify
    application behavior.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些事件都可以异步发生；然而，`fetchDetails`和`showToastMessage`函数将接收比它们所需更多的数据，尝试以不同的方式组合这些事件来修改应用程序行为可能会变得复杂。
- en: In reactive programming, everything is treated as a stream. A stream will contain
    events that happen over time and these events can contain some data or no data.
    The following diagram visualizes a scenario where your app is listening for mouse
    clicks from the user. Uncontrolled streams of user clicks are meaningless. You
    exert some control over this stream by applying the `throttle` function to it,
    so you only get updates every 250 **milliseconds** (**ms**). If you subscribe
    to this new event, every 250 ms, you will receive a list of click events. You
    may try to extract some data from each click event, but in this case, you're only
    interested in the number of click events that happened. We can shape the raw event
    data into a number of clicks using the `map` function.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应式编程中，一切都被视为流。一个流将包含随时间发生的事件，这些事件可以包含一些数据或没有数据。以下图表展示了您的应用程序正在监听用户鼠标点击的场景。未经控制的用户点击流是没有意义的。您可以通过应用`throttle`函数来对此流施加一些控制，这样您每250毫秒（**ms**）才收到一次更新。如果您订阅这个新事件，每250毫秒，您将收到一个点击事件的列表。您可能试图从每个点击事件中提取一些数据，但在这个情况下，您只对发生的点击事件数量感兴趣。我们可以使用`map`函数将原始事件数据塑造成点击次数。
- en: Further down the stream, we may only be interested in listening for events with
    two or more clicks in it, so we can use the `filter` function to only act on what
    is essentially a double-click event. Every time our filter event fires, it means
    that the user intended to double-click, and you can act on that information by
    popping up an alert.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在流进一步下游的地方，我们可能只对监听包含两个或更多点击的事件感兴趣，因此我们可以使用 `filter` 函数只对本质上是一个双击事件进行操作。每次我们的过滤事件触发时，都意味着用户意图进行双击，你可以通过弹出警告来对此信息采取行动。
- en: The true power of streams comes from the fact that you can choose to act on
    the event at any time as it passes through various control, transformation, and
    filter functions. You can choose to display click data on an HTML list using `*ngFor`
    and Angular's `async` pipe, so the user can monitor the types of click data being
    captured every 250 ms.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 流的真正力量在于你可以选择在任何时候对事件进行操作，当它通过各种控制、转换和过滤函数时。你可以选择使用 `*ngFor` 和 Angular 的 `async`
    管道在 HTML 列表中显示点击数据，这样用户就可以每 250 毫秒监控被捕获的点击数据类型。
- en: '![](img/B14094_01_13.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_01_13.png)'
- en: 'Figure 1.13: A reactive data stream implementation'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.13：响应式数据流实现
- en: Now let's consider some more advanced Angular architectural patterns.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑一些更高级的 Angular 架构模式。
- en: Advanced Angular architecture
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级 Angular 架构
- en: 'As mentioned earlier, in the *Basic Angular architecture* section, Angular
    components, services, and dependencies are organized into modules. Angular apps
    are bootstrapped via their root module, as shown in the diagram that follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在 *基本 Angular 架构* 部分，Angular 组件、服务和依赖项被组织到模块中。Angular 应用程序通过其根模块启动，如下面的图所示：
- en: '![](img/B14094_01_14.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_01_14.png)'
- en: 'Figure 1.14: Angular Bootstrap process showing major architectural elements'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.14：显示主要架构元素的 Angular 启动过程
- en: The root module can import other modules and also declare components and provide
    services. As your application grows, you need to create sub-modules that contain
    their components and services. Organizing your application in this manner allows
    you to implement lazy loading, allowing you to control which parts of your application
    get delivered to the browser and when. As you add more features to your application,
    you import modules from other libraries, like Angular Material or NgRx. You implement
    the router to enable rich navigational experiences between your components, allowing
    your routing configuration to orchestrate the creation of components.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 根模块可以导入其他模块，并声明组件和提供服务。随着你的应用程序增长，你需要创建包含其组件和服务的子模块。以这种方式组织你的应用程序允许你实现懒加载，这样你可以控制应用程序的哪些部分被发送到浏览器以及何时发送。随着你向应用程序添加更多功能，你会从其他库（如
    Angular Material 或 NgRx）导入模块。你实现路由器以在组件之间提供丰富的导航体验，允许你的路由配置编排组件的创建。
- en: '*Chapter 7*, *Creating a Router-First Line-of-Business App*, introduces router-first
    architecture, where I encourage you to start the development of your application
    by creating all your routes ahead of time.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*第七章*，*创建以路由器为第一线的业务应用程序*，介绍了以路由器为第一线的架构，我鼓励你通过提前创建所有路由来开始你的应用程序开发。'
- en: In Angular, services are provided as singletons to a module by default. You'll
    quickly get used to this behavior. However, you must keep in mind that if you
    provide the same service across multiple modules, then each module has its own
    instance of the provided service. In the case of an authentication service, where
    we wish to have only one instance across our entire application, you must be careful
    to only provide that instance of the authentication service at the root module
    level. Any service, component, or module provided at the root level of your application
    becomes available in the feature module.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 中，服务默认以单例的形式提供给模块。你会很快习惯这种行为。然而，你必须记住，如果你在多个模块中提供相同的服务，那么每个模块都有自己的服务实例。在认证服务的情况下，我们希望在整个应用程序中只有一个实例，你必须小心只在该根模块级别提供认证服务的实例。你应用程序根级别提供的任何服务、组件或模块都将在功能模块中可用。
- en: Beyond modules, the router is the next most powerful technology you must master
    in Angular.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 除了模块之外，路由器是你在 Angular 中必须掌握的下一个最强大的技术。
- en: The Angular Router
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular 路由器
- en: The Angular Router, shipped in the `@angular/router` package, is a central and
    critical part of building **single-page applications** (**SPAs**) that act and
    behave like regular websites that are easy to navigate using browser controls
    or the zoom or micro zoom controls.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`@angular/router` 包中提供的 Angular Router 是构建**单页应用**（**SPAs**）的核心和关键部分，这些应用的行为和表现就像易于使用浏览器控件或缩放或微缩控件导航的常规网站。'
- en: The Angular Router has advanced features such as lazy loading, router outlets,
    auxiliary routes, smart active link tracking, and the ability to be expressed
    as an `href`, which enables a highly flexible Router-first app architecture leveraging
    stateless data-driven components using RxJS `BehaviorSubject`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Angular Router 具有诸如懒加载、路由出口、辅助路由、智能活动链接跟踪以及能够以 `href` 的形式表达等高级功能，这使能够利用无状态的、数据驱动的组件的
    Router-first 应用架构变得高度灵活，这些组件使用 RxJS 的 `BehaviorSubject`。
- en: 'Large teams can work against a single code base, with each team responsible
    for a module''s development, without stepping on each other''s toes, while enabling
    easy continuous integration. Google, with its billions of lines of code, works
    against a single code base for a very good reason: integration after the fact
    is very expensive.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 大型团队可以在单个代码库上工作，每个团队负责一个模块的开发，而不会相互干扰，同时实现易于的持续集成。谷歌拥有数亿行代码，之所以在单个代码库上工作，是因为事后集成成本非常高。
- en: Small teams can remix their UI layouts on the fly to quickly respond to changes
    without having to rearchitect their code. It is easy to underestimate the amount
    of time wasted due to late game changes in layout or navigation. Such changes
    are easier to absorb by larger teams but a costly endeavor for small teams.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 小型团队可以即时混搭他们的UI布局以快速响应变化，而无需重构他们的代码。很容易低估由于布局或导航的后期更改而浪费的时间。对于大型团队来说，这些变化更容易吸收，但对于小型团队来说，这是一项代价高昂的努力。
- en: Consider the diagram that follows, where `app.ts` contains the module. It has
    a `rootRouter`; components `a`, `master`, `detail`, and `c`; `services`; `pipes`;
    and `directives` provided and declared for it. All of these components will be
    parsed and eagerly loaded by the browser when a user first navigates to your application.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下图表，其中 `app.ts` 包含模块。它有一个 `rootRouter`；组件 `a`、`master`、`detail` 和 `c`；`services`；`pipes`；以及为其提供和声明的
    `directives`。当用户首次导航到您的应用时，所有这些组件都将被浏览器解析和急切加载。
- en: '![](img/B14094_01_15.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_01_15.png)'
- en: 'Figure 1.15: Angular architecture'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.15：Angular架构
- en: If you were to implement a lazily loaded route `/b`, you would need to create
    a feature module named `b`, which would have its own `childRouter`; components
    `d`, `e`, and `f`; `services`; `pipes`; and `directives` provided and declared
    for it. During transpile-time, Angular will package these components into a separate
    file or bundle and this bundle will only be downloaded, parsed, and loaded if
    the user ever navigates to a path under `/b`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您要实现一个懒加载的路由 `/b`，您需要创建一个名为 `b` 的功能模块，它将有自己的 `childRouter`；组件 `d`、`e` 和 `f`；`services`；`pipes`；以及为其提供和声明的
    `directives`。在编译时，Angular 将将这些组件打包到单独的文件或包中，并且这个包只有在用户导航到 `/b` 下的路径时才会被下载、解析和加载。
- en: Let's look into lazy loading in more detail.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地了解一下懒加载。
- en: Lazy loading
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 懒加载
- en: The dashed line connecting `/b/...` to `rootRouter` demonstrates how lazy loading
    works. Lazy loading allows developers to achieve a sub-second first meaningful
    paint quickly. By deferring the loading of additional modules, we can keep the
    bundle size delivered to the browser to a minimum. The size of a module impacts
    download and loading speeds, because the more a browser has to do, the longer
    it takes for a user to see the first screen of the app. By defining lazily loaded
    modules, each module is packaged as separate files, which can be downloaded and
    loaded individually and on demand.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 连接 `/b/...` 到 `rootRouter` 的虚线线表示了懒加载的工作原理。懒加载允许开发者快速实现亚秒级的首次有意义的绘制。通过延迟加载额外的模块，我们可以将发送到浏览器的包大小保持在最小。模块的大小影响下载和加载速度，因为浏览器需要执行的操作越多，用户看到应用首屏的时间就越长。通过定义懒加载的模块，每个模块都作为单独的文件打包，可以单独下载和按需加载。
- en: The Angular Router provides smart active link tracking, which results in a superior
    developer and user experience, making it very easy to implement highlighting features
    to indicate to the user the current tab or portion of the app that is currently
    active. Auxiliary routes maximize the reuse of components and help pull off complicated
    state transitions with ease. With auxiliary routes, you can render multiple master
    and detail views using only a single outer template. You can also control how
    the route is displayed to the user in the browser's URL bar and compose routes
    using `routerLink`, in templates, and `Router.navigate`, in code, driving complicated
    scenarios.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Angular Router提供了智能活动链接跟踪，这导致了更优越的开发者和用户体验，使得实现高亮功能以指示用户当前活动标签或应用程序部分变得非常容易。辅助路由最大化了组件的重用，并有助于轻松完成复杂的状态转换。使用辅助路由，您可以使用单个外部模板渲染多个主视图和详细视图。您还可以控制路由在浏览器URL栏中的显示方式，并在模板中使用`routerLink`，在代码中使用`Router.navigate`来驱动复杂的场景。
- en: In *Chapter 7*, *Creating a Router-First Line-of-Business App*, I cover implementing
    router basics, and advanced recipes are covered in *Chapter 11*, *Recipes – Reusability,
    Routing, and Caching*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第7章*，*创建以路由为第一线的业务应用程序*中，我介绍了实现路由基础，而高级食谱则在*第11章*，*食谱 – 可重用性、路由和缓存*中介绍。
- en: Beyond routing, state management is another crucial concept to master if you
    would like to build sophisticated Angular applications.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 除了路由之外，如果你想要构建复杂的Angular应用程序，掌握状态管理是另一个关键概念。
- en: State management
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态管理
- en: A class backs every component and service in Angular. When instantiated, a class
    becomes an object in memory. As you work with an object, if you store values in
    object properties, then you're introducing state to your Angular application.
    If unmanaged, the state becomes a significant liability to the success and maintainability
    of your application.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Angular组件和服务都有一个类作为后盾。当实例化时，类成为内存中的对象。当你与对象一起工作时，如果你在对象属性中存储值，那么你就在你的Angular应用程序中引入了状态。如果未管理，状态就会成为应用程序成功和可维护性的重大负担。
- en: I'm a fan of stateless design both in the backend and frontend. From my perspective,
    state is evil, and you should pay careful attention not to introduce state into
    your code. Earlier, we discussed how services in Angular are singletons by default.
    This is a terrible opportunity to introduce state into your application. You must
    avoid storing information in your services. In *Chapter 7*, *Creating a Router-First
    Line-of-Business App*, I introduce you to BehaviorSubjects, which act as data-anchors
    for your application. In this case, we store these anchors in services, so they
    can be shared across components to synchronize data.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我既喜欢后端也喜欢前端的无状态设计。从我的角度来看，状态是邪恶的，你应该仔细注意不要将状态引入你的代码中。之前，我们讨论了Angular中的服务默认是单例的。这是一个引入状态到应用程序的糟糕机会。你必须避免在服务中存储信息。在*第7章*，*创建以路由为第一线的业务应用程序*中，我向您介绍了BehaviorSubjects，它们作为应用程序的数据锚点。在这种情况下，我们将这些锚点存储在服务中，以便它们可以在组件之间共享以同步数据。
- en: In Angular components, the class is a ViewModel acting as the glue code between
    your code and the template. Compared to services, components are relatively short-lived,
    and it is okay to use object properties in this context.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular组件中，类是一个ViewModel，充当你的代码和模板之间的粘合代码。与服务相比，组件相对较短命，在这种情况下使用对象属性是可以的。
- en: However, beyond design, there are specific use cases for introducing robust
    mechanisms to maintain complicated data models in the state of your application.
    Progressive web applications and mobile applications are one use case where connectivity
    is not guaranteed. In these cases, being able to save and resume the entire state
    of your application is a must to provide a great **user experience** (**UX**)
    for your end user.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，除了设计之外，还有特定的用例需要引入鲁棒机制来维护应用程序中的复杂数据模型状态。渐进式Web应用程序和移动应用程序就是其中一种用例，在这些用例中，连接性无法保证。在这些情况下，能够保存和恢复应用程序的整个状态是提供出色的**用户体验**（UX）的必要条件。
- en: The NgRx library for Angular leverages the Flux pattern to enable sophisticated
    state management for your applications. In *Chapter 6*, *Forms, Observables, and
    Subjects* and *Chapter 12*, *Recipes – Master/Detail, Data Tables, and NgRx*,
    I provide alternative implementations for various features using NgRx to demonstrate
    the differences in implementation between more lightweight methods.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 的 NgRx 库利用 Flux 模式来实现应用的高级状态管理。在 *第 6 章*，*表单、可观察对象和主题* 和 *第 12 章*，*食谱
    – 主/详细、数据表和 NgRx* 中，我提供了使用 NgRx 的各种功能的替代实现，以展示与更轻量级方法之间的实现差异。
- en: The Flux pattern
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Flux 模式
- en: Flux is the application architecture that was created by Facebook to assist
    in building client-side web applications. The Flux pattern defines a series of
    components that manage a store that stores the state of your application via dispatchers
    that trigger/handle actions and view functions that read values from the store.
    Using the Flux pattern, you keep the state of your application in a store where
    access to the store is only possible through well-defined and decoupled functions,
    resulting in architecture that scales well because, in isolation, decoupled functions
    are easy to reason with and write automated unit tests for.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Flux 是由 Facebook 创建的应用架构，用于帮助构建客户端 Web 应用。Flux 模式定义了一系列组件，这些组件通过触发/处理动作的派发器和从存储中读取值的视图函数来管理存储应用程序的状态。使用
    Flux 模式，你将应用程序的状态保存在存储中，存储的访问只能通过定义良好且解耦的函数进行，从而实现了一种可扩展的架构，因为解耦的函数在隔离状态下易于推理和编写自动单元测试。
- en: 'Consider the diagram that follows to understand the flow of information between
    these components:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下图表来理解这些组件之间的信息流：
- en: '![](img/B14094_01_16.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.16](img/B14094_01_16.png)'
- en: 'Figure 1.16: NgRx data flow'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.16：NgRx 数据流
- en: NgRx implements the Flux pattern in Angular using RxJS.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: NgRx 使用 RxJS 在 Angular 中实现 Flux 模式。
- en: NgRx
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NgRx
- en: The NgRx library brings Redux-like (a popular React.js library) reactive state
    management to Angular based on RxJS. State management with NgRx allows developers
    to write atomic, self-contained, and composable pieces of code creating actions,
    reducers, and selectors. This kind of reactive programming allows side-effects
    in state changes to be isolated and feels right at home with the general coding
    patterns of React.js. NgRx ends up creating an abstraction layer over already complex
    and sophisticated tooling like RxJS.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: NgRx 库将基于 RxJS 的类似 Redux（一个流行的 React.js 库）的响应式状态管理引入 Angular。使用 NgRx 进行状态管理允许开发者编写原子化、自包含且可组合的代码片段，创建动作、还原器和选择器。这种响应式编程允许在状态变化中隔离副作用，并且与
    React.js 的一般编码模式感觉非常契合。NgRx 最终在 RxJS 等复杂和高级工具之上创建了一个抽象层。
- en: 'There are excellent reasons to use NgRx, like if you deal with 3+ input streams
    into your application. In such a scenario, the overhead of dealing with so many
    events makes it worthwhile to introduce a new coding paradigm to your project.
    However, most applications only have two input streams: REST APIs and user input.
    To a lesser extent, NgRx may make sense if you are writing offline-first **Progressive
    Web Apps** (**PWAs**), where you may have to persist complicated state information,
    or architecting a niche enterprise app with similar needs.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多使用 NgRx 的优秀理由，例如，如果你处理应用中的 3+ 个输入流。在这种情况下，处理这么多事件的负担使得引入新的编码范式到你的项目中变得值得。然而，大多数应用只有两个输入流：REST
    API 和用户输入。在更小的程度上，如果你正在编写离线优先的 **渐进式 Web 应用**（**PWAs**），你可能需要持久化复杂的状态信息，或者设计具有类似需求的专业企业应用，那么
    NgRx 可能是有意义的。
- en: 'Here''s an architectural overview of NgRx:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 NgRx 的架构概述：
- en: '![](img/B14094_01_17.png)Figure 1.17: NgRx architectural overview'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.17：NgRx 架构概述](img/B14094_01_17.png)'
- en: Consider the very top of the diagram as an observable action stream, where actions
    can be dispatched and acted upon as denoted by the circles. Effects and components
    can dispatch an action. Reducers and effects can act upon these actions to either
    store values in the store or trigger an interaction with the server. Selectors
    are leveraged by components to read values from the store.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 将图表的顶部视为可观察的动作流，动作可以像圆圈所示那样被分发和执行。效果和组件可以分发动作。还原器和效果可以对这些动作进行操作，要么将值存储在存储中，要么触发与服务器的交互。选择器被组件用来从存储中读取值。
- en: Given my positive attitude toward minimal tooling and a lack of definite necessity
    for NgRx beyond the niche audiences previously mentioned, I do not recommend NgRx
    as a default choice. RxJS/BehaviorSubjects are powerful and capable enough to
    unlock sophisticated and scalable patterns to help you build great Angular applications,
    as is demonstrated in the chapters that lead up to *Chapter 12*, *Recipes – Master/Detail,
    Data Tables, and NgRx*.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我对于最小化工具的积极态度，以及对NgRx在之前提到的利基受众之外没有明确必要性的看法，我不建议将NgRx作为默认选择。RxJS/BehaviorSubjects功能强大且足够，可以解锁复杂和可扩展的模式，帮助你构建出色的Angular应用程序，正如在通向*第12章*、*食谱
    – 主/详细、数据表和NgRx*的章节中所展示的那样。
- en: You can read more about NgRx at [https://ngrx.io](../Text/Chapter_1.xhtml).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://ngrx.io](../Text/Chapter_1.xhtml)了解更多关于NgRx的信息。
- en: React.js architecture
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React.js架构
- en: In contrast to Angular, React.js, as a whole, implements the Flux pattern. Following
    is a router-centric view of a React application, where components/containers and
    providers are represented in a strict tree-like manner.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 与Angular不同，React.js作为一个整体实现了Flux模式。以下是一个以路由为中心的React应用程序视图，其中组件/容器和提供者以严格的树状结构表示。
- en: '![](img/B14094_01_18.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_01_18.png)'
- en: 'Figure 1.18: React.js architectural overview'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.18：React.js架构概述
- en: In the initial releases of React, one had to laboriously pass values up/down
    the inheritance tree of every component for even the most basic functionality
    to work. Later on, react-redux was introduced, so each component can read/write
    values directly to the store without having to traverse the tree.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在React的早期版本中，为了使最基本的功能正常工作，必须费力地将值在组件的继承树中上下传递。后来，引入了react-redux，因此每个组件都可以直接读取/写入值到存储中，而无需遍历整个树。
- en: This basic overview should give you a sense of the significant architectural
    differences between Angular and React. However, keep in mind that just like Angular,
    React, its community, patterns, and practices are continually evolving and getting
    better over time.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基本的概述应该能让你对Angular和React之间的重要架构差异有一个大致的了解。然而，请记住，就像Angular一样，React、其社区、模式和最佳实践都在不断发展和完善。
- en: You can learn more about React at [https://reactjs.org](../Text/Chapter_1.xhtml).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://reactjs.org](../Text/Chapter_1.xhtml)了解更多关于React的信息。
- en: Notable Angular features
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重要的Angular特性
- en: Specific Angular versions introduce noteworthy changes to advance the philosophy
    of the platform and make it more seamless and comprehensive. I recommend checking
    out the unique changes that these seminal releases have introduced.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 特定的Angular版本引入了值得注意的变更，以推进平台的哲学思想，使其更加无缝和全面。我建议查看这些开创性发布所引入的独特变更。
- en: Angular 6
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular 6
- en: 'Most, if not all, of the content, patterns, and practices in this book are
    compatible with Angular 4 and up. However, Angular 6 was a seminal release of
    Angular, which brought a lot of under-the-covers improvements to the platform
    and the overall stability and cohesion across the ecosystem. The development experience
    is vastly improved with additional CLI tools that make it easier to update versions
    of packages and faster build times to improve your code-build-view feedback cycle.
    With Angular 6, all platform tools are version synced to 6.0, making it easier
    to reason about the ecosystem. In the following table, you can see how this makes
    it easier to communicate tooling compatibility:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的大部分内容、模式和最佳实践都与Angular 4及以上版本兼容。然而，Angular 6是Angular的一个开创性发布，为平台带来了许多底层改进，以及整个生态系统在稳定性和凝聚力方面的提升。开发体验得到了极大的改善，额外的CLI工具使得更新包版本和加快构建时间变得更容易，从而改善了代码-构建-视图反馈周期。在Angular
    6中，所有平台工具的版本都同步到6.0，这使得理解生态系统变得更加容易。在下表中，你可以看到这如何使工具兼容性沟通变得更加容易：
- en: '|  | **Previously** | **With v6** |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '|  | **之前** | **v6版本** |'
- en: '| CLI | 1.7 | 6.0 |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| CLI | 1.7 | 6.0 |'
- en: '| Angular | 5.2.10 | 6.0 |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| Angular | 5.2.10 | 6.0 |'
- en: '| Material | 5.2.4 | 6.0 |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| Material | 5.2.4 | 6.0 |'
- en: Angular CLI 6.0 comes with major new capabilities, such as `ng update` and `ng
    add` commands; `ng update` makes it much easier to update your version of Angular, npm
    dependencies, RxJS, and Angular Material, including some deterministic code rewriting
    capabilities to apply name changes to APIs or functions. The topic of updating
    your version of Angular is covered in depth in *Appendix C*, *Keeping Angular
    and Tools Evergreen*. You can find this appendix online from [https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen.pdf](../Text/Chapter_1.xhtml)
    or at [https://expertlysimple.io/stay-evergreen](../Text/Chapter_1.xhtml). `ng
    add` brings schematics support to the Angular CLI. With schematics, you can write
    custom code to add new capabilities to an Angular app, adding any dependencies,
    boilerplate configuration code, or scaffolding. A great example is to be able
    to add Angular Material to your project by executing `ng add @angular/material`.
    The topic of adding Angular Material to your project is covered in depth in *Chapter
    5*, *Delivering High-Quality UX with Material*. A standalone Material Update tool
    aims to make Angular Material updates less painful, found at [Github.com/angular/material-update-tool](../Text/Chapter_1.xhtml),
    but expect this functionality to be merged into `ng update`. Further schematics
    can bring their own `generate` commands to CLI, making your life easier and your
    code base more consistent over time. In addition, version 4 of webpack is configured
    to build your Angular application into smaller modules with scope hosting, shortening
    the first-paint time of your app.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CLI 6.0 带来了许多重大新功能，例如 `ng update` 和 `ng add` 命令；`ng update` 使得更新你的 Angular
    版本、npm 依赖、RxJS 和 Angular Material 变得更加容易，包括一些确定性的代码重写能力，以将名称更改应用于 API 或函数。关于更新
    Angular 版本的内容在 *附录 C*，*保持 Angular 和工具常青* 中进行了深入探讨。您可以从 [https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen.pdf](../Text/Chapter_1.xhtml)
    或 [https://expertlysimple.io/stay-evergreen](../Text/Chapter_1.xhtml) 在线找到这个附录。`ng
    add` 将方案支持引入到 Angular CLI 中。有了方案，你可以编写自定义代码来向 Angular 应用添加新功能，包括添加任何依赖项、样板配置代码或脚手架。一个很好的例子是通过执行
    `ng add @angular/material` 来将 Angular Material 添加到你的项目中。关于将 Angular Material 添加到你的项目的内容在
    *第五章*，*使用 Material 提供高质量 UX* 中进行了深入探讨。一个独立的 Material 更新工具旨在使 Angular Material
    更新不那么痛苦，可以在 [Github.com/angular/material-update-tool](../Text/Chapter_1.xhtml)
    找到，但请期待这个功能将合并到 `ng update` 中。进一步的方案可以为自己的 CLI 带来自己的 `generate` 命令，使你的生活更轻松，随着时间的推移，你的代码库更加一致。此外，webpack
    的第 4 版被配置为将你的 Angular 应用程序构建成具有范围托管的小模块，缩短了应用程序的首次绘制时间。
- en: The major theme of Angular 6 is under-the-hood performance improvements and
    Custom Elements support. Version 6 improves upon v5 in terms of the base bundle
    size by 12% at 65 KB, which improves load times by a whopping 21-40% from fast
    3G to fiber connections. As your applications grow, Angular takes advantage of
    a better tree-shaking technique to further prune unused code out of your final
    deliverable. Speed is a UX feature in Angular 6\. This is accomplished with better
    support for the Angular **Component Development Ki**t (**CDK**), Angular Material,
    Animations, and i18n. Angular Universal allows for server-side assisted fast startup
    times, and Angular PWA support takes advantage of native platform features such
    as caching and offline storage, so in subsequent visits, your app remains fast.
    RxJS 6 support allows the tree-shakeable pipe command, reducing bundle sizes more
    often, and fixes the behavior of `throttle` as I caution you in *Chapter 6*, *Forms,
    Observables, and Subjects*, among numerous bug fixes and performance improvements.
    TypeScript 2.7 brings in better support for importing different types of JavaScript
    packages and more advanced features to catch coding errors during build time.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 6 的主要主题是底层的性能改进和自定义元素支持。第 6 版在基础包大小方面比 v5 版本提高了 12%，达到 65 KB，从快速的 3G
    连接到光纤连接，将加载时间提高了惊人的 21-40%。随着你的应用程序的增长，Angular 利用更好的摇树技术进一步修剪最终交付物中的未使用代码。速度是
    Angular 6 的一个 UX 特性。这是通过更好的 Angular **组件开发工具包**（**CDK**）、Angular Material、动画和
    i18n 的支持来实现的。Angular Universal 允许服务器端辅助快速启动时间，Angular PWA 支持利用本地平台功能，如缓存和离线存储，因此，在后续访问中，你的应用程序保持快速。RxJS
    6 的支持允许可摇动的管道命令，更频繁地减少包大小，并修复了我在 *第六章*，*表单、可观察对象和主题* 中警告你的 `throttle` 的行为，以及众多错误修复和性能改进。TypeScript
    2.7 带来了更好的 JavaScript 包类型导入支持，以及在构建时捕获编码错误的更高级功能。
- en: Angular Material 6 added new user controls such as tree and badge while making
    the library a lot more stable with a slew of bug fixes, completeness of functionality,
    and theming in existing components. Angular Flex Layout 6 brought in polyfills,
    enabling Internet Explorer 11 to support CSS Flexbox. This makes Angular apps
    using Material and Flex Layout fully compatible with the last major legacy browser
    technology that still persists in enterprises and governments despite leaving
    mainstream support in January 2018 alongside Windows 8.1 and being superseded
    18 times by Microsoft Edge. Angular 6 itself can be configured to be compatible
    down to IE9 using polyfills. This is great for developers who must support such
    legacy browsers and still be able to use modern technologies to build their solutions.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Angular Material 6添加了新的用户控件，如树形控件和徽章，同时通过一系列错误修复、功能完整性和现有组件的主题化，使库变得更加稳定。Angular
    Flex Layout 6引入了polyfills，使Internet Explorer 11能够支持CSS Flexbox。这使得使用Material和Flex
    Layout的Angular应用程序完全兼容最后一个主要遗留浏览器技术，尽管它在2018年1月与Windows 8.1一起停止了主流支持，并被Microsoft
    Edge取代了18次。Angular 6本身可以通过polyfills配置为向下兼容到IE9。这对于必须支持此类遗留浏览器并且仍然能够使用现代技术构建解决方案的开发者来说是个好消息。
- en: Some exciting, new ancillary tooling was also released to enable high-frequency,
    high-performance, or large enterprise use cases. The Angular ecosystem welcomed
    the NgRx library, bringing Redux-like reactive state management to Angular based
    on RxJS. The Nx CLI tool, built by former Angular team members, brings an opinionated
    development environment setup to Angular, suitable for consultants and large organizations
    that must ensure a consistent environment. This book follows a similar pattern
    and aims to educate you in establishing a consistent architecture and design pattern
    to apply across your applications. Google's Bazel build tool enables incremental
    builds, so portions of your application that haven't changed don't need to be
    rebuilt, vastly improving build times for large projects and allowing the packaging
    of libraries to be shared between Angular applications.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 一些令人兴奋的新辅助工具也被发布，以支持高频、高性能或大型企业用例。Angular生态系统欢迎NgRx库的加入，它基于RxJS将Redux-like的响应式状态管理引入Angular。由前Angular团队成员开发的Nx
    CLI工具为Angular带来了有观点的开发环境设置，适合需要确保环境一致性的顾问和大型组织。本书遵循类似的模式，旨在教育您建立一致的建筑和设计模式，以便应用于您的应用程序。Google的Bazel构建工具支持增量构建，因此您的应用程序中未更改的部分不需要重新构建，大大提高了大型项目的构建时间，并允许Angular应用程序之间共享库的打包。
- en: Angular 8
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular 8
- en: As mentioned in the *Preface* of this book, this book has been designed to be
    effective with any new version of Angular. This is an idea that is championed
    by the Angular team, who wishes to deemphasize the specific version of Angular
    you're currently using, instead of focusing and investing in continually staying
    up to date with every minor and major release of Angular. The Angular team is
    spending considerable energy and effort to ensure that as much of the code you
    have written remains compatible, as the performance and feature set of Angular
    improve over time. Any breaking change is either supported by automated tools,
    helping you rewrite portions of your code, or planned deprecations, giving you
    ample time to phase out unsupported code.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如本书**前言**中所述，本书旨在与任何新的Angular版本有效。这是Angular团队所倡导的理念，他们希望淡化您当前使用的Angular特定版本，而不是专注于并投资于持续保持Angular每个小版本和主要版本的更新。Angular团队投入了大量的精力和努力，以确保您编写的尽可能多的代码在Angular的性能和功能集随时间改进后仍然兼容。任何破坏性变更都由自动化工具支持，帮助您重写代码的部分，或者计划弃用，给您充足的时间逐步淘汰不受支持的代码。
- en: Angular 7 brought performance, accessibility, and dependency updates for TypeScript,
    RxJS, and Node, along with a significant update and the expansion of Angular Material
    controls; Angular 8 continuous these trends. Angular 8 introduces differential
    loading and support for minimal polyfills for evergreen browsers, saving somewhere
    between 7-20% of the payload delivered to the client.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 7为TypeScript、RxJS和Node带来了性能、可访问性和依赖性更新，以及Angular Material控件的重大更新和扩展；Angular
    8延续了这一趋势。Angular 8引入了差异加载和对于evergreen浏览器的最小polyfills支持，节省了发送到客户端的负载的7-20%。
- en: Angular 9
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular 9
- en: Angular 9 and its subsequent 9.1 update brings some of the most significant
    updates to the framework to date by delivering the Ivy rendering engine and TypeScript
    3.8 support. This update tackles a lot of tech debt removal, brings 100 bug fixes
    and features, and greatly expands automated test coverage of the framework. The
    Ivy rendering engine results in smaller package sizes and faster load times for
    your apps. In addition, Angular 9.1 brings 40% faster build times, 40-50% improved
    unit test run-times, and better debugging capabilities with simpler stack traces
    and template binding. TypeScript 3.8 brings in new syntactical benefits like optional
    chaining and the nullish operator to make it dramatically easier to deal with
    null or undefined values in Angular's strict mode.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 9 及其随后的 9.1 更新通过提供 Ivy 渲染引擎和 TypeScript 3.8 支持，为框架带来了迄今为止最重要的更新。这次更新解决了大量技术债务，带来了
    100 个错误修复和功能，并大大扩展了框架的自动化测试覆盖率。Ivy 渲染引擎使得应用程序的包大小更小，加载速度更快。此外，Angular 9.1 带来了
    40% 的更快构建时间，40-50% 的改进单元测试运行时间，以及更好的调试能力，具有更简单的堆栈跟踪和模板绑定。TypeScript 3.8 带来了新的语法优势，如可选链和空值合并运算符，这使得在
    Angular 的严格模式下处理 null 或 undefined 值变得更加容易。
- en: The full benefits of the Ivy rendering engine will be felt with future updates.
    Ivy will allow the creation of tiny and lean Angular applications. Prior to Ivy,
    the metadata needed to describe an Angular component was stored within a module.
    With Ivy, components implement the locality principle, so they can be self-describing.
    This allows Ivy to lazily load individual components and creation of standalone
    components. Imagine an Angular library that can render components with a single
    function call and only be a few kilobytes in size. This miniaturization makes
    it feasible to implement Angular Elements using the Custom Elements, part of the
    Web Components spec.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Ivy 渲染引擎的全部优势将在未来的更新中体现出来。Ivy 将允许创建小巧且精简的 Angular 应用程序。在 Ivy 之前，描述 Angular 组件所需的元数据存储在模块中。使用
    Ivy，组件实现了局部性原则，因此可以自我描述。这允许 Ivy 惰性加载单个组件和创建独立组件。想象一下，一个 Angular 库可以通过单次函数调用渲染组件，并且其大小只有几千字节。这种小型化使得使用自定义元素（Custom
    Elements）实现 Angular Elements 成为可能，这是 Web Components 规范的一部分。
- en: Angular Elements, introduced in version 6, allows you to code an Angular component
    and reuse that component in any other web application using any web technology,
    in essence declaring your very own custom HTML element. These Custom Elements
    are cross-compatible with any HTML-based tool-chain, including other web application
    libraries or frameworks. To make this work, the entire Angular framework needs
    to be packaged alongside your new custom element. This was not feasible in Angular
    6, because that meant tacking on at least 65 KB each time you created a new user
    control.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在版本 6 中引入的 Angular Elements 允许你编写一个 Angular 组件，并在任何其他使用任何 Web 技术的 Web 应用程序中重用该组件，本质上是在声明你自己的自定义
    HTML 元素。这些自定义元素与任何基于 HTML 的工具链兼容，包括其他 Web 应用程序库或框架。为了使这一切工作，整个 Angular 框架需要与你的新自定义元素一起打包。在
    Angular 6 中，这并不可行，因为这意味着每次创建新的用户控件时，至少需要附加 65 KB。
- en: In early 2020, Chrome, Edge, and Firefox support Custom Elements natively, a
    significant change from the status quo in early 2018\. Angular 9 enables the Ivy
    rendering engine by default, and future updates to Angular should drive base bundle
    sizes to be as small as 2.7 KB, so wide-spread use of Angular-based Custom Elements
    could soon become reality. In 2020, all major browsers natively support Custom
    Elements, leaving Safari the last browser implement the standard.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 到 2020 年初，Chrome、Edge 和 Firefox 原生支持自定义元素，这与 2018 年初的现状相比是一个重大变化。Angular 9 默认启用
    Ivy 渲染引擎，并且 Angular 的未来更新应将基本包的大小降至 2.7 KB，因此基于 Angular 的自定义元素的大规模使用很快将成为现实。在
    2020 年，所有主要浏览器都原生支持自定义元素，只剩下 Safari 是最后一个实现该标准的浏览器。
- en: Always check [https://caniuse.com](../Text/Chapter_1.xhtml) before getting too
    excited about a new web technology to ensure that you are indeed able to use that
    feature in browsers that you must support.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在对新的 Web 技术过于兴奋之前，请始终检查 [https://caniuse.com](../Text/Chapter_1.xhtml)，以确保你确实能够在必须支持的浏览器中使用该功能。
- en: '[Angular.io](../Text/Chapter_1.xhtml) leverages Custom Elements to demonstrate
    the feasibility of the technology. The documentation site attracts 1 million+
    unique visitors per month, so it should help work out some of the kinks as it
    matures. Custom Elements are great for hosting interactive code samples alongside
    static content. For example, in early 2018, [Angular.io](../Text/Chapter_1.xhtml)
    started using [StackBlitz.io](../Text/Chapter_1.xhtml) for interactive code samples.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '[Angular.io](../Text/Chapter_1.xhtml) 利用自定义元素来展示该技术的可行性。该文档网站每月吸引超过100万独立访客，因此随着其成熟，它应该有助于解决一些问题。自定义元素非常适合在静态内容旁边托管交互式代码示例。例如，在2018年初，[Angular.io](../Text/Chapter_1.xhtml)
    开始使用 [StackBlitz.io](../Text/Chapter_1.xhtml) 来托管交互式代码示例。'
- en: '[StackBlitz.io](../Text/Chapter_1.xhtml) is an amazing tool, a rich IDE right
    in the browser, so you can experiment with different ideas or run GitHub repositories
    without needing to pull or execute any code locally.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[StackBlitz.io](../Text/Chapter_1.xhtml) 是一个惊人的工具，一个直接在浏览器中的丰富IDE，因此你可以实验不同的想法或运行GitHub仓库，而无需在本地拉取或执行任何代码。'
- en: Other significant updates include the differential loading of JavaScript bundles
    to improve loading times and **time-to-interactive** (**TTI**) for modern browsers.
    Angular Router adds backward compatibility to make it feasible to perform piecemeal
    upgrades of legacy AngularJS projects.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 其他重要更新包括对JavaScript包的按需加载，以改善加载时间和现代浏览器的**首次交互时间**（TTI）。Angular Router 添加了向后兼容性，使得对遗留的AngularJS项目进行分阶段升级成为可能。
- en: Google mandates that the 2000+ Angular projects they have must all be on the
    same version of Angular. This means that every new update to Angular is well tested
    and there are no backward compatibility surprises.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌要求他们拥有的2000多个Angular项目都必须使用Angular的同一版本。这意味着Angular的每个新更新都经过了良好的测试，并且没有向后兼容性的惊喜。
- en: With all the groundwork laid in version 9, we can expect a more agile and capable
    framework with Angular 10\. I hope you are as excited as I am about Angular and
    the future possibilities it unlocks. Buckle up your seatbelt Dorothy, 'cause Kansas
    is going bye-bye.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在版本9中打下了所有基础后，我们可以期待Angular 10将带来更加敏捷和强大的框架。我希望你对Angular和它解锁的未来可能性和我一样兴奋。系好你的安全带，多萝西，因为堪萨斯州即将离你而去。
- en: Summary
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In summary, web technologies have evolved to a point where it is possible to
    create rich, fast, and native web applications that can run well on the vast majority
    of desktop and mobile browsers that are deployed today. Angular has evolved to
    become a mature and stable platform, applying lessons learned from the past. It
    enables sophisticated development methodologies that enable developers to create
    maintainable, interactive, and fast applications. Technologies like TypeScript,
    RxJS, and NgRx enabled patterns from object-oriented programming, reactive programming,
    and the Flux pattern.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，网络技术已经发展到可以创建丰富、快速和本地的网络应用程序，这些应用程序可以在今天部署的大多数桌面和移动浏览器上良好运行。Angular已经发展到成为一个成熟和稳定的平台，应用了从过去学到的经验教训。它使开发者能够采用复杂的方法论，从而创建可维护、交互式和快速的应用程序。像TypeScript、RxJS和NgRx这样的技术使得面向对象编程、响应式编程和Flux模式中的模式成为可能。
- en: Angular is engineered to be reactive through and through and, therefore, you
    must adjust your programming style to fit this pattern. In addition, Angular is
    meant to be consumed in an evergreen manner, so it is a great idea always to keep
    your Angular up to date.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 从头到尾都是设计成响应式的，因此你必须调整你的编程风格以适应这种模式。此外，Angular 意在以持续更新的方式被消费，因此始终保持Angular的最新状态是个好主意。
- en: Leveraging promises in an Angular app, instead of observables and the async
    pipe, is equivalent to disregarding all the advice and documentation that the
    Angular team and thought leaders in the community have communicated. It is easy
    to fall into bad practices and habits following shallow or wildly out-of-context
    advice you may glean from self-help sites or blog posts written with an experimental
    mindset. The official documentation should be your bible, found at [https://angular.io/docs](../Text/Chapter_1.xhtml).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular应用中利用承诺（promises），而不是观察者（observables）和异步管道（async pipe），等同于忽视了Angular团队和社区中的思想领袖所传达的所有建议和文档。很容易因为从自我帮助网站或以实验心态撰写的博客文章中汲取的浅显或极端脱离上下文的建议而陷入不良的实践和习惯。官方文档应该是你的圣经，可以在
    [https://angular.io/docs](../Text/Chapter_1.xhtml) 找到。
- en: In the next chapter, you will be configuring your development environment to
    optimize it for a great and consistent Angular development experience across macOS
    and Windows operating systems. In the following chapters, you will learn how to
    create a basic Angular app, deploy it on the internet, then learn about advanced
    architectural patterns to create scalable applications, learn how to create a
    full-stack TypeScript application using Minimal MEAN, and leverage advanced DevOps
    and Continuous Integration techniques. The book wraps up by introducing you to Amazon
    Web Services and Google Analytics.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将配置你的开发环境，以优化 macOS 和 Windows 操作系统上的出色且一致的 Angular 开发体验。在接下来的章节中，你将学习如何创建一个基本的
    Angular 应用，将其部署到互联网上，然后了解如何创建可扩展的应用程序的高级架构模式，学习如何使用 Minimal MEAN 创建全栈 TypeScript
    应用程序，并利用高级 DevOps 和持续集成技术。本书通过介绍 Amazon Web Services 和 Google Analytics 来结束。
- en: Further reading
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Design Patterns: Elements of Reusable Object-Oriented Software*, Erich Gamma,
    Richard Helm, Ralph Johnson, John Vlissides, 1994, Addison Wesley, ISBN 0-201-63361-2.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设计模式：可重用面向对象软件的元素，Erich Gamma、Richard Helm、Ralph Johnson、John Vlissides*，1994，Addison
    Wesley，ISBN 0-201-63361-2。'
- en: Human JavaScript, Henrik Joreteg, 2013, [http://read.humanjavascript.com](../Text/Chapter_1.xhtml).
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人类 JavaScript，Henrik Joreteg，2013，[http://read.humanjavascript.com](../Text/Chapter_1.xhtml)。
- en: What's new in TypeScript x MS Build 2017, Anders Hejlsberg, 2017, [https://www.youtube.com/watch?v=0sMZJ02rs2c](../Text/Chapter_1.xhtml).
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript x MS Build 2017 的新功能，Anders Hejlsberg，2017，[https://www.youtube.com/watch?v=0sMZJ02rs2c](../Text/Chapter_1.xhtml)。
- en: '*The Pragmatic Programmer, 20th Anniversary Edition*, David Thomas and Andrew
    Hunt, 2019, Addison Wesley, ISBN 978-0135957059.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实用程序员，20 周年纪念版，David Thomas 和 Andrew Hunt*，2019，Addison Wesley，ISBN 978-0135957059。'
- en: '*Thinking Reactively: Most Difficult*, Mike Pearson, 2019, [https://www.youtube.com/watch?v=-4cwkHNguXE](../Text/Chapter_1.xhtml).'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*反应式思维：最困难的部分，Mike Pearson*，2019，[https://www.youtube.com/watch?v=-4cwkHNguXE](../Text/Chapter_1.xhtml)。'
- en: '*Data Composition with RxJS, Deborah Kurata*, 2019, [https://www.youtube.com/watch?v=Z76QlSpYcck](../Text/Chapter_1.xhtml).'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 RxJS 进行数据组合，Deborah Kurata*，2019，[https://www.youtube.com/watch?v=Z76QlSpYcck](../Text/Chapter_1.xhtml)。'
- en: Flux Pattern In-Depth Overview, Facebook, 2019, [https://facebook.github.io/flux/docs/in-depth-overview](../Text/Chapter_1.xhtml).
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flux 模式深入概述，Facebook，2019，[https://facebook.github.io/flux/docs/in-depth-overview](../Text/Chapter_1.xhtml)。
- en: Questions
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Answer the following questions as best as you can to ensure that you've understood
    the key concepts from this chapter without Googling. Do you need help answering
    the questions? See *Appendix D*, *Self-Assessment Answers* online at [https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf](../Text/Chapter_1.xhtml)
    or visit [https://expertlysimple.io/angular-self-assessment](../Text/Chapter_1.xhtml).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能好地回答以下问题，以确保你已理解本章的关键概念，而无需使用 Google。你需要帮助回答这些问题吗？请参阅 *附录 D*，*自我评估答案*，在线位于
    [https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf](../Text/Chapter_1.xhtml)
    或访问 [https://expertlysimple.io/angular-self-assessment](../Text/Chapter_1.xhtml)。
- en: What is the concept behind Angular Evergreen?
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Angular Evergreen 的概念是什么？
- en: 'Using the double-click example for reactive streams, implement the following
    steps using RxJS: Listen to click events from an HTML target with the `fromEvent`
    function. Determine if the mouse was double-clicked within a 250ms timeframe using
    `throttleTime`, `asyncScheduler`, `buffer`, and `filter` operators. If a double-click
    is detected, display an alert in the browser. Hint: Use [https://stackblitz.com](../Text/Chapter_1.xhtml)
    or implement your code and use [https://rxjs.dev/](../Text/Chapter_1.xhtml) for
    help.'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用双击示例实现反应式流，使用 RxJS 执行以下步骤：使用 `fromEvent` 函数监听 HTML 目标的点击事件。使用 `throttleTime`、`asyncScheduler`、`buffer`
    和 `filter` 操作符确定鼠标是否在 250ms 时间内双击。如果检测到双击，则在浏览器中显示一个警告。提示：使用 [https://stackblitz.com](../Text/Chapter_1.xhtml)
    或实现你的代码并使用 [https://rxjs.dev/](../Text/Chapter_1.xhtml) 获取帮助。
- en: What is NgRx, and what role does it play in an Angular application?
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: NgRx 是什么，它在 Angular 应用中扮演什么角色？
- en: What is the difference between a module, a component, and a service in Angular?
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Angular 中，模块、组件和服务之间的区别是什么？
