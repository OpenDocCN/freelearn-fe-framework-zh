- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Building an Application Component
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建应用程序组件
- en: 'The components you’ve built so far have been built in isolation: they don’t
    fit together, and there’s no workflow for the user to follow when they load the
    application. Up to this point, we’ve been manually testing our components by swapping
    them in and out of our index file, `src/index.js`.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 您迄今为止构建的组件都是独立构建的：它们不能很好地结合在一起，用户在加载应用程序时没有遵循的工作流程。到目前为止，我们通过在`src/index.js`文件中替换组件来手动测试我们的组件。
- en: In this chapter, we’ll tie all those components into a functioning system by
    creating a root application component, `App`, that displays each of these components
    in turn.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过创建一个根应用程序组件`App`，将所有这些组件整合到一个功能系统中，该组件将依次显示这些组件。
- en: 'You have now seen almost all the TDD techniques you’ll need for test-driving
    React applications. This chapter covers one final technique: testing callback
    props.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经看到了几乎所有的测试驱动开发（TDD）技术，这些技术对于测试驱动React应用程序都是必需的。本章将介绍最后一个技术：测试回调属性。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Formulating a plan
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制定计划
- en: Using state to control the active view
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用状态来控制活动视图
- en: Test-driving callback props
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试驱动回调属性
- en: Making use of callback values
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用回调值
- en: By the end of this chapter, you’ll have learned how to use mocks to test the
    root component of your application, and you’ll have a working application that
    ties together all the components you’ve worked on in *Part 1* of this book.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将学会如何使用模拟来测试应用程序的根组件，并且您将拥有一个将本书*第一部分*中您所工作的所有组件连接在一起的工作应用程序。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code files for this chapter can be found here: [https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter08](https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter08)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在以下位置找到：[https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter08](https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter08)
- en: Formulating a plan
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制定计划
- en: Before we jump into the code for the `App` component, let’s do a little up-front
    design so that we know what we’re building.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入到`App`组件的代码之前，让我们先进行一点前期设计，以便我们知道我们要构建什么。
- en: 'The following diagram shows all the components you’ve built and how `App` will
    connect them:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了您所构建的所有组件以及`App`如何将它们连接起来：
- en: '![Figure 8.1 – The component hierarchy ](img/Figure_8.01_B18423.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 – 组件层次结构](img/Figure_8.01_B18423.jpg)'
- en: Figure 8.1 – The component hierarchy
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 组件层次结构
- en: 'Here’s how it’ll work:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的工作方式：
- en: When the user first loads the app, they will see a list of today’s appointments
    using the `AppointmentsDayView` component, which will have its appointment data
    populated by its container `AppointmentsDayViewLoader` component.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户首次加载应用程序时，他们将使用`AppointmentsDayView`组件看到今天的预约列表，该组件的预约数据将由其容器`AppointmentsDayViewLoader`组件填充。
- en: At the top of the screen, the user will see a button labeled `AppointmentsDayView`
    disappear and `CustomerForm` appear.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕顶部，用户将看到一个标签为`AppointmentsDayView`的按钮消失，并出现`CustomerForm`。
- en: When the form is filled out and the submit button is clicked, the user is shown
    `AppointmentForm` and can add a new appointment for that customer.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当表单填写完毕并点击提交按钮时，用户将看到`AppointmentForm`，并可以为该客户添加一个新的预约。
- en: Once they’ve added the appointment, they’ll be taken back to `AppointmentsDayView`.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦他们添加了预约，他们将被带回到`AppointmentsDayView`。
- en: 'This first step is shown in the following screenshot. Here, you can see the
    new button in the top-left corner. The `App` component will render this button
    and then orchestrate this workflow:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步如下截图所示。在这里，您可以看到右上角的新按钮。`App`组件将渲染此按钮，然后协调此工作流程：
- en: '![Figure 8.2 –  The app showing the new button in the top-left corner ](img/Figure_8.02_B18423.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2 – 显示右上角新按钮的应用程序](img/Figure_8.02_B18423.jpg)'
- en: Figure 8.2 – The app showing the new button in the top-left corner
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 显示在右上角的新按钮的应用程序
- en: 'This is a very simple workflow that supports just a single use case: adding
    a new customer and an appointment at the same time. Later in this book, we’ll
    add support for creating appointments for existing customers.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的流程，仅支持单一用例：同时添加新客户和预约。在本书的后面部分，我们将添加对为现有客户创建预约的支持。
- en: With that, we’re ready to build the new `App` component.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们已经准备好构建新的`App`组件。
- en: Using state to control the active view
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用状态来控制活动视图
- en: In this section, we’ll start building a new `App` component, in the usual way.
    First, we’ll display an `AppointmentsDayViewLoader` component. Because this child
    component makes a network request when mounted, we’ll mock it out. Then, we’ll
    add a button inside a `menu` element, at the top of the page. When this button
    is clicked, we switch out the `AppointmentsDayViewLoader` component for a `CustomerForm`
    component.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将以通常的方式开始构建一个新的`App`组件。首先，我们将显示`AppointmentsDayViewLoader`组件。因为这个子组件在挂载时进行网络请求，所以我们将模拟它。然后，我们将在页面的顶部添加一个按钮，位于`menu`元素内。当这个按钮被点击时，我们将用`CustomerForm`组件替换`AppointmentsDayViewLoader`组件。
- en: We will introduce a state variable named `view` that defines which component
    is currently displayed. Initially, it will be set to `dayView`. When the button
    is clicked, it will change to `addCustomer`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将引入一个名为`view`的状态变量，它定义了当前显示哪个组件。最初，它将设置为`dayView`。当按钮被点击时，它将更改为`addCustomer`。
- en: The JSX constructs will initially use a ternary to switch between these two
    views. Later, we’ll add a third value called `addAppointment`. When we do that,
    we’ll “upgrade” our ternary expression to a `switch` statement.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: JSX构建将最初使用三元运算符在这两个视图之间切换。稍后，我们将添加一个名为`addAppointment`的第三个值。当我们这样做时，我们将“升级”我们的三元表达式为`switch`语句。
- en: 'To get started, follow these steps:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请按照以下步骤操作：
- en: 'Create a new file, `test/App.test.js`, with the following imports for the new
    `App` component:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件`test/App.test.js`，为新`App`组件添加以下导入：
- en: '[PRE0]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, import `AppointmentsDayViewLoader` and mock its implementation:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，导入`AppointmentsDayViewLoader`并模拟其实现：
- en: '[PRE1]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, let’s add our first test, which checks that `AppointmentsDayViewLoader`
    has been rendered:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加我们的第一个测试，该测试检查`AppointmentsDayViewLoader`是否已渲染：
- en: '[PRE2]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Make that pass by adding the following code to a new file, `src/App.js`:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过向新文件`src/App.js`中添加以下代码来使该测试通过：
- en: '[PRE3]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For the second test, we’ll add a menu to the top of the page. For this, we’ll
    need the element matcher, so add that to your test suite imports:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于第二个测试，我们将在页面的顶部添加一个菜单。为此，我们需要元素匹配器，所以将其添加到测试套件的导入中：
- en: '[PRE4]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add the second test:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加第二个测试：
- en: '[PRE5]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To make that pass, change the `App` component so that it includes a `menu`
    element above the loader component:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使该测试通过，将`App`组件更改为包括位于加载组件之上的`menu`元素：
- en: '[PRE6]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we want to display a button in the menu that, when clicked, will switch
    to `CustomerForm`. Add the following test, which asserts that the button appears
    on the page, using a CSS selector to find the rendered button element. This uses
    the `:first-of-type` pseudoclass to ensure we find the first button (later in
    this book, we’ll add a second button to the menu):'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们希望在菜单中显示一个按钮，点击后可以切换到`CustomerForm`。添加以下测试，它断言按钮出现在页面上，使用CSS选择器找到渲染的按钮元素。这使用了`:first-of-type`伪类来确保我们找到第一个按钮（在本书的后面部分，我们将向菜单中添加第二个按钮）：
- en: '[PRE7]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To make that pass, change the menu in the `App` component to the following:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使该测试通过，将`App`组件中的菜单更改为以下内容：
- en: '[PRE8]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For the next test, we must check that clicking the button renders `CustomerForm`.
    We must also mock this component out. To do that, we’ll need the component that’s
    been imported into the test suite. Add the following line to `test/App.test.js`:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于下一个测试，我们必须检查点击按钮是否渲染`CustomerForm`。我们必须模拟此组件。为此，我们需要已导入到测试套件中的组件。将以下行添加到`test/App.test.js`中：
- en: '[PRE9]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Just below that, add the following mock definition, which is our standard mock
    definition:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此代码下方，添加以下模拟定义，这是我们的标准模拟定义：
- en: '[PRE10]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Why mock a component that has no effects on mount?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要模拟一个在挂载时没有影响的组件？
- en: This component already has a test suite so that we can use a test double and
    verify the right props to avoid re-testing functionality we’ve tested elsewhere.
    For example, the `CustomerForm` test suite has a test to check that the submit
    button calls the `onSave` prop with the saved customer object. So, rather than
    extending the test surface area of `App` so that it includes that submit functionality,
    we can mock out the component and call `onSave` directly instead. We’ll do that
    in the next section.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件已经有一个测试套件，这样我们就可以使用测试替身并验证正确的属性，以避免重新测试我们在其他地方已经测试过的功能。例如，`CustomerForm`测试套件有一个测试来检查提交按钮是否调用`onSave`属性并传递保存的客户对象。因此，而不是扩展`App`的测试范围以包括该提交功能，我们可以模拟该组件并直接调用`onSave`。我们将在下一节中这样做。
- en: 'To click the button, we’ll need our click helper. Bring that in now:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要点击按钮，我们需要我们的点击助手。现在将其引入：
- en: '[PRE11]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, add the test. This introduces a helper function, `beginAddingCustomerAndAppointment`,
    which finds the button and clicks it. We’ll pull that out now because we’ll be
    using it in most of the remaining tests:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加测试。这引入了一个辅助函数 `beginAddingCustomerAndAppointment`，它找到按钮并点击它。我们现在将其提取出来，因为我们将在大多数剩余的测试中使用它：
- en: '[PRE12]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Making this pass involves adding a component state to track that we’ve clicked
    the button. In `src/App.js`, import the two hooks we’ll need, `useState` and `useCallback`,
    and import `CustomerForm` too:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使其通过需要添加一个组件状态来跟踪我们是否点击了按钮。在 `src/App.js` 中，导入我们需要的两个钩子 `useState` 和 `useCallback`，以及导入
    `CustomerForm`：
- en: '[PRE13]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the `App` component, define the new view state variable and initialize it
    to the `dayView` string, which we’ll use to represent `AppointmentsDayViewLoader`:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `App` 组件中，定义新的视图状态变量并将其初始化为 `dayView` 字符串，我们将用它来表示 `AppointmentsDayViewLoader`：
- en: '[PRE14]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Just below that, add a new callback named `transitionToAddCustomer`, which
    we’ll attach to the button’s `onClick` handler in the next step. This callback
    updates the view state variable so that it points to the second page, which we’ll
    call `addCustomer`:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在那下面，添加一个新的回调函数 `transitionToAddCustomer`，我们将在下一步将其附加到按钮的 `onClick` 处理程序。这个回调更新视图状态变量，使其指向第二页，我们将称之为
    `addCustomer`：
- en: '[PRE15]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Plug that into the `onClick` prop of the button:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其连接到按钮的 `onClick` 属性：
- en: '[PRE16]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, all that’s left is to modify our JSX to ensure the `CustomerForm` component
    is rendered when the `view` state variable is set to `addCustomer`. Notice how
    the test doesn’t force us to hide `AppointmentsDayViewLoader`. That will come
    in a later test. For now, we just need the simplest code that will make our test
    pass. Update your JSX, as shown here:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们只剩下修改我们的 JSX，以确保当 `view` 状态变量设置为 `addCustomer` 时，`CustomerForm` 组件会被渲染。注意，测试并没有强迫我们隐藏
    `AppointmentsDayViewLoader`。这一点将在后续的测试中体现。目前，我们只需要最简单的代码来使测试通过。按照以下所示更新你的 JSX：
- en: '[PRE17]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Testing for the presence of a new component
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 测试新组件的存在
- en: Strictly speaking, this *isn’t* the simplest way to make the test pass. We could
    make it pass by *always* rendering a `CustomerForm` component, regardless of the
    value of `view`. Then, we’d need to triangulate with a second test that proves
    the component is not initially rendered. I’m skipping this step for brevity, but
    feel free to add it in if you prefer.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，这**不是**使测试通过的最简单方法。我们可以通过**总是**渲染一个 `CustomerForm` 组件来使测试通过，无论 `view` 的值如何。然后，我们需要通过第二个测试来三角定位，以证明组件最初并没有被渲染。我跳过这一步以节省篇幅，但如果你愿意，可以添加它。
- en: 'We need to ensure that we pass an `original` prop to `CustomerForm`. In this
    workflow, we’re creating a new customer so that we can give it a blank customer
    object, just like the one we used in the `CustomerForm` test suite. Add the following
    test below it. We’ll define `blankCustomer` in the next step:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要确保向 `CustomerForm` 传递一个 `original` 属性。在这个工作流程中，我们正在创建一个新的客户，以便我们可以给它一个空白客户对象，就像我们在
    `CustomerForm` 测试套件中使用的那样。在下面添加以下测试。我们将在下一步定义 `blankCustomer`：
- en: '[PRE18]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create a new file, `test/builders/customer.js`, and add a definition for `blankCustomer`:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件，`test/builders/customer.js`，并添加 `blankCustomer` 的定义：
- en: '[PRE19]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Import that new definition into your `App` test suite:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个新定义导入到你的 `App` 测试套件中：
- en: '[PRE20]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Value builders versus function builders
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 值构建函数与函数构建函数
- en: We’ve defined `blankCustomer` as a constant value, rather than a function. We
    can do this because all the code we’ve written treats variables as immutable objects.
    If that wasn’t the case, we may prefer to use a function, `blankCustomer()`, that
    generates new values each time it is called. That way, we can be sure that one
    test doesn’t accidentally modify the setup for any subsequent tests.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `blankCustomer` 定义为一个常量值，而不是一个函数。我们可以这样做，因为我们编写的所有代码都将变量视为不可变对象。如果不是这样，我们可能更喜欢使用一个函数
    `blankCustomer()`，它在每次被调用时都会生成新的值。这样，我们可以确保一个测试不会意外地修改后续测试的设置。
- en: 'Let’s make that test pass. First, define `blankCustomer` at the top of `src/App.js`:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使那个测试通过。首先，在 `src/App.js` 的顶部定义 `blankCustomer`：
- en: '[PRE21]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Using builder functions in both production and test code
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产代码和测试代码中使用构建函数
- en: You now have the same `blankCustomer` definition in both your production and
    test code. This kind of duplication is usually okay, especially since the object
    is so simple. But for non-trivial builder functions, you should consider test-driving
    the implementation and then making good use of it within your test suite.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你的生产代码和测试代码中都有相同的 `blankCustomer` 定义。这种重复通常是可行的，特别是考虑到这个对象如此简单。但对于非平凡的构建函数，你应该考虑先进行测试驱动实现，然后在测试套件中充分利用它。
- en: 'Then, simply reference that value by setting it as an `original` prop of `CustomerForm`.
    After making this change, your test should be passing:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，只需通过将其设置为 `CustomerForm` 的 `original` 属性来引用该值。进行此更改后，您的测试应该会通过：
- en: '[PRE22]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, add the following test to hide `AppointmentsDayViewLoader` when a customer
    is being added:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加以下测试以在添加客户时隐藏 `AppointmentsDayViewLoader`：
- en: '[PRE23]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To make that pass, we need to move `AppointmentsDayViewLoader` into the ternary
    expression, in place of the null:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使测试通过，我们需要将 `AppointmentsDayViewLoader` 移动到三元表达式中，以替换 null：
- en: '[PRE24]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let’s hide the button bar, too:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们也将按钮栏隐藏：
- en: '[PRE25]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To solve this, we need to lift the ternary out of the JSX entirely, as shown
    in the following code. This is messy, but we’ll improve its implementation in
    the next section:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要将三元表达式从 JSX 中完全提取出来，如下面的代码所示。这很混乱，但我们在下一节中会改进其实现：
- en: '[PRE26]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: With that, you have implemented the initial step in the workflow – that is changing
    the screen from an `AppointmentsDayViewLoader` component to a `CustomerForm` component.
    You did this by changing the `view` state variable from `dayView` to `addCustomer`.
    For the next step, we’ll use the `onSave` prop of `CustomerForm` to alert us when
    it’s time to update `view` to `addAppointment`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，您已经实现了工作流程中的第一步——即将屏幕从 `AppointmentsDayViewLoader` 组件更改为 `CustomerForm` 组件。您通过将
    `view` 状态变量从 `dayView` 更改为 `addCustomer` 来完成此操作。对于下一步，我们将使用 `CustomerForm` 的 `onSave`
    属性来提醒我们何时将 `view` 更新为 `addAppointment`。
- en: Test-driving callback props
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动回调属性
- en: In this section, we’ll introduce a new extension function, `propsOf`, that reaches
    into a mocked child component and returns the props that were passed to it. We’ll
    use this to get hold of the `onSave` callback prop value and invoke it from our
    test, mimicking what would happen if the real `CustomerForm` had been submitted.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍一个新的扩展函数 `propsOf`，它深入模拟的子组件并返回传递给它的属性。我们将使用它来获取 `onSave` 回调属性值，并在测试中调用它，模拟如果真实的
    `CustomerForm` 已被提交会发生的情况。
- en: It’s worth revisiting why this is something we’d like to do. Reaching into a
    component and calling the prop directly seems complicated. However, the alternative
    is *more* complicated and *more* brittle.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 值得重新审视我们为什么想这样做。直接深入组件并调用属性似乎很复杂。然而，替代方案更复杂，也更脆弱。
- en: 'The test we want to write next is the one that asserts that the `AppointmentFormLoader`
    component is shown after `CustomerForm` has been submitted and a new customer
    has been saved:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要编写的测试是断言在 `CustomerForm` 提交并保存新客户后，`AppointmentFormLoader` 组件被显示：
- en: '[PRE27]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, imagine that we wanted to test this without a mocked `CustomerForm`. We
    would need to fill in the real `CustomerForm` form fields and hit the submit button.
    That may seem reasonable, but we’d be increasing the surface area of our `App`
    test suite to include the `CustomerForm` component. Any changes to the `CustomerForm`
    component would require not only the `CustomerForm` tests to be updated but also
    now the `App` tests. This is the exact scenario we’ll see in [*Chapter 9*](B18423_09.xhtml#_idTextAnchor159),
    *Form Validation*, when we update `CustomerForm` so that it includes field validation.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想在没有模拟的 `CustomerForm` 的情况下测试这个功能。我们需要填写真实的 `CustomerForm` 表单字段并点击提交按钮。这可能看起来很合理，但我们会增加
    `App` 测试套件的表面积，包括 `CustomerForm` 组件。任何对 `CustomerForm` 组件的更改不仅需要更新 `CustomerForm`
    测试，现在还需要更新 `App` 测试。这正是我们将在 [*第9章*](B18423_09.xhtml#_idTextAnchor159) 中看到的场景，*表单验证*，当我们更新
    `CustomerForm` 以包括字段验证时。
- en: By mocking the child component, we can reduce the surface area and reduce the
    likelihood of breaking tests when child components change.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通过模拟子组件，我们可以减少表面积并降低子组件更改时破坏测试的可能性。
- en: Mocked components require care
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟组件需要小心处理
- en: Even with mocked components, our parent component test suite can still be affected
    by child component changes. This can happen if the meaning of the props changes.
    For example, if we updated the `onSave` prop on `CustomerForm` to return a different
    value, we’d need to update the `App` tests to reflect that.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是模拟组件，我们的父组件测试套件仍然可能受到子组件更改的影响。这可能发生在属性的含义发生变化时。例如，如果我们更新了 `CustomerForm`
    上的 `onSave` 属性以返回不同的值，我们需要更新 `App` 测试以反映这一点。
- en: 'Here’s what we’ve got to do. First, we must define a `propsOf` function in
    our extensions module. Then, we must write tests that mimic the submission of
    a `CustomerForm` component and transfer the user to an `AppointmentFormLoader`
    component. We’ll do that by introducing a new `addAppointment` value for the view
    state variable. Follow these steps:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要做的事情。首先，我们必须在我们的扩展模块中定义一个`propsOf`函数。然后，我们必须编写模拟提交`CustomerForm`组件并将用户转移到`AppointmentFormLoader`组件的测试。我们将通过为视图状态变量引入一个新的`addAppointment`值来实现这一点。按照以下步骤操作：
- en: 'In `test/reactTestExtensions.js`, add the following definition of `propsOf`.
    It looks up the last call to the mocked component and returns its props:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`test/reactTestExtensions.js`中，添加以下`propsOf`的定义。它查找对模拟组件的最后调用，并返回其属性：
- en: '[PRE28]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Back in `test/App.test.js`, update the extensions import so that it includes
    `propsOf`:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`test/App.test.js`中，更新扩展导入，使其包括`propsOf`：
- en: '[PRE29]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You also need to import the `act` function from React’s test utils. Our test
    will wrap its invocation of the callback prop to ensure that any setters are run
    before the call returns:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还需要从React的测试工具中导入`act`函数。我们的测试将包装对回调属性的调用，以确保在调用返回之前运行任何设置器：
- en: '[PRE30]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'There’s one more import to add – the import for `AppointmentFormLoader`:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还有一个导入需要添加——`AppointmentFormLoader`的导入：
- en: '[PRE31]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Just below that, define its mock using the standard component mock definition:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在那下面，使用标准的组件模拟定义定义它的模拟：
- en: '[PRE32]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We’re almost ready for our test. First, though, let’s define a helper function,
    `saveCustomer`. This is the key part of the code that invokes the prop. Note that
    this sets a default customer object of `exampleCustomer`. We’ll use this default
    value to avoid having to specify the customer in each test where the value doesn’t
    matter:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们几乎准备好进行测试了。不过，首先让我们定义一个辅助函数`saveCustomer`。这是代码中调用属性的关键部分。注意，这设置了默认客户对象`exampleCustomer`。我们将使用这个默认值来避免在每个测试中指定客户，因为那里的值并不重要：
- en: '[PRE33]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Using act within the test suite
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试套件中使用act
- en: 'This is the first occasion that we’ve willingly left a reference to act within
    our test suite. In every other use case, we managed to hide calls to `act` within
    our extensions module. Unfortunately, that’s just not possible here – at least,
    it’s not possible with the way we wrote `propsOf`. An alternative approach would
    be to write an extension function named `invokeProp` that takes the name of a
    prop and invokes it for us:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一次自愿在我们的测试套件中留下对act的引用。在其他所有用例中，我们设法在我们的扩展模块中隐藏了对`act`的调用。不幸的是，这在这里是不可能的——至少，按照我们编写`propsOf`的方式是不可能的。另一种方法是将一个名为`invokeProp`的扩展函数写出来，它接受属性的名称并为我们调用它：
- en: '`invokeProp(CustomerForm, "onSave", customer);`'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`invokeProp(CustomerForm, "onSave", customer);`'
- en: The downside of this approach is that you’ve now downgraded `onSave` from an
    object property to a string. So, we’ll ignore this approach for now and just live
    with `act` usage in our test suite.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是，你现在已经将`onSave`从对象属性降级为字符串。所以，我们现在将忽略这种方法，并忍受在我们的测试套件中使用`act`。
- en: 'Let’s write our test. We want to assert that `AppointmentsFormLoader` is displayed
    once `CustomerForm` has been submitted:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编写我们的测试。我们想要断言，一旦`CustomerForm`被提交，`AppointmentsFormLoader`就会显示一次：
- en: '[PRE34]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Making this pass will involve adding a new value to the view state variable,
    `addAppointment`. With this third value, the ternary expression is no longer fit
    for purpose because it can only handle two possible values of view. So, before
    we continue making this pass, let’s refactor that ternary so that it uses a `switch`
    statement. Skip the test you just wrote using `it.skip`.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使这个通过将涉及向视图状态变量`addAppointment`添加一个新值。有了这个第三个值，三元表达式就不再适合用途，因为它只能处理视图的两个可能值。所以，在我们继续使这个通过之前，让我们重构那个三元表达式，使其使用`switch`语句。跳过你刚刚编写的测试，使用`it.skip`。
- en: 'Replace the return statement of your component with the following:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下代码替换组件的返回语句：
- en: '[PRE35]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Once you’ve verified that your tests still pass, un-skip your latest test by
    changing `it.skip` back to `it`.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你验证了你的测试仍然通过，将你最新的测试从`it.skip`改回`it`。
- en: 'The component should update the view to `addAppointment` whenever the `onSave`
    prop of `CustomerForm` is called. Let’s do that with a new callback handler. Add
    the following code just below the definition of `transitionToAddCustomer`:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`CustomerForm`的`onSave`属性被调用时，组件应该更新视图到`addAppointment`。让我们用一个新的回调处理程序来实现这一点。在`transitionToAddCustomer`定义下面添加以下代码：
- en: '[PRE36]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Modify the `CustomerForm` render expression so that it takes this as a prop:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`CustomerForm`渲染表达式，使其接受这个作为属性：
- en: '[PRE37]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Hook up the new `addAppointment` value by adding the following `case` statement
    to the switch. After making this change, your test should be passing:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加以下 `case` 语句将新的 `addAppointment` 值连接起来。在做出这个更改后，你的测试应该会通过：
- en: '[PRE38]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'For the next test, we need to pass a value for the `original` prop, this time
    to `AppointmentFormLoader`. Note the double use of `expect.objectContaining`.
    This is necessary because our appointment is not going to be a simple blank appointment
    object. This time, the appointment will have a customer ID passed to it. That
    customer ID is the ID of the customer we’ve just added – we’ll write a test for
    that next:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于下一个测试，我们需要为 `original` 属性传递一个值，这次是传递给 `AppointmentFormLoader`。注意 `expect.objectContaining`
    的双重使用。这是必要的，因为我们的预约不会是一个简单的空白预约对象。这次，预约将传递一个客户 ID。这个客户 ID 是我们刚刚添加的客户 ID - 我们将在下一个测试中为它编写测试：
- en: '[PRE39]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We need a builder function, just like with `blankCustomer`. Create a new file,
    `test/builders/appointment.js`, and add the following definition:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个构建函数，就像 `blankCustomer` 一样。创建一个新的文件，`test/builders/appointment.js`，并添加以下定义：
- en: '[PRE40]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Update the test code to import that:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新测试代码以导入它：
- en: '[PRE41]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then, create the same thing in `src/App.js`:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在 `src/App.js` 中创建相同的内容：
- en: '[PRE42]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Finally, you can make the test pass by setting the `original` prop, as shown
    here:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你可以通过设置 `original` 属性来使测试通过，如下所示：
- en: '[PRE43]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We’re almost done with the display of `AppointmentFormLoader`, but not quite:
    we still need to take the customer ID we receive from the `onSave` callback and
    pass it into `AppointmentFormLoader`, by way of the `original` prop value, so
    that `AppointmentForm` knows which customer we’re creating an appointment for.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了 `AppointmentFormLoader` 的显示，但还不完全：我们仍然需要从 `onSave` 回调中接收客户 ID，并通过 `original`
    属性值传递给它，这样 `AppointmentForm` 就知道我们正在为哪个客户创建预约。
- en: Making use of callback values
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用回调值
- en: In this section, we’ll introduce a new state variable, `customer`, that will
    be set when `CustomerForm` receives the `onSave` callback. After that, we’ll do
    the final transition in our workflow, from `addAppointment` back to `dayView`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍一个新的状态变量 `customer`，它将在 `CustomerForm` 接收到 `onSave` 回调时设置。之后，我们将在我们的工作流程中进行最后的转换，从
    `addAppointment` 返回到 `dayView`。
- en: 'Follow these steps:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: 'This time, we’ll check that the new customer ID is passed to `AppointmentFormLoader`.
    Remember in the previous section how we gave `saveCustomer` a customer parameter?
    We’ll make use of that in this test:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次，我们将检查新的客户 ID 是否传递给了 `AppointmentFormLoader`。记得在上一节中我们如何给 `saveCustomer` 提供一个客户参数？我们将在本测试中使用它：
- en: '[PRE44]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'For this to work, we’ll need to add a state variable for the customer. Add
    the following at the top of the `App` component:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们需要为客户添加一个状态变量。在 `App` 组件的顶部添加以下内容：
- en: '[PRE45]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'When we built the `onSave` prop of `CustomerForm` back in [*Chapter 6*](B18423_06.xhtml#_idTextAnchor099),
    *Exploring Test Doubles*, we passed it the updated customer object. Update the
    `transitiontoAddAppointment` handler so that it takes this parameter value and
    saves it using the `setCustomer` setter:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们在 [*第 6 章*](B18423_06.xhtml#_idTextAnchor099) 中构建 `CustomerForm` 的 `onSave`
    属性时，*探索测试替身*，我们传递了更新后的客户对象。更新 `transitiontoAddAppointment` 处理程序，使其接受此参数值并使用 `setCustomer`
    设置器保存它：
- en: '[PRE46]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Pass that through to `AppointmentFormLoader` by creating a new `original` object
    value that merges the customer ID into `blankAppointment`:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个新的 `original` 对象值，将客户 ID 合并到 `blankAppointment` 中，将其传递给 `AppointmentFormLoader`：
- en: '[PRE47]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'It’s time for the final test for this component. We complete the user workflow
    by asserting that once the appointment is saved, the view updates back to `dayView`:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候对这个组件进行最后的测试了。我们通过断言一旦预约保存，视图就会更新回 `dayView` 来完成用户工作流程：
- en: '[PRE48]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Define a new function to set the state back to `dayView`:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个新的函数来将状态重置回 `dayView`：
- en: '[PRE49]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Pass this function to `AppointmentsFormLoader` to ensure it’s called when the
    appointment is saved. After this, your tests should be complete and passing:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此函数传递给 `AppointmentsFormLoader` 以确保在预约保存时调用它。在此之后，你的测试应该完成并通过：
- en: '[PRE50]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We’re done!
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了！
- en: 'Now, all that’s left is to update `src/index.js` to render the `App` component.
    Then, you can manually test this to check out your handiwork:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，剩下的就是更新 `src/index.js` 以渲染 `App` 组件。然后，你可以手动测试以检查你的成果：
- en: '[PRE51]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: To run the application, use the `npm run serve` command. For more information
    see the *Technical requirements* section in [*Chapter 6*](B18423_06.xhtml#_idTextAnchor099)*,
    Exploring Test Doubles*, or consult the `README.md` file in the repository.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行应用程序，请使用`npm run serve`命令。有关更多信息，请参阅[*第6章*](B18423_06.xhtml#_idTextAnchor099)*，探索测试替身*部分中的*技术要求*部分，或查阅存储库中的`README.md`文件。
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covered the final TDD technique for you to learn – mocked component
    callback props. You learned how to get a reference to a component callback using
    the `propsOf` extension, as well as how to use a state variable to manage the
    transitions between different parts of a workflow.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了你将要学习的最终TDD技术——模拟组件回调属性。你学习了如何使用`propsOf`扩展获取组件回调的引用，以及如何使用状态变量来管理工作流程不同部分之间的转换。
- en: You will have noticed how *all* the child components in `App` were mocked out.
    This is often the case with top-level components, where each child component is
    a relatively complex, self-contained unit.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到`App`中的所有子组件都被模拟了。这种情况通常发生在顶级组件中，其中每个子组件都是一个相对复杂、自包含的单元。
- en: In the next part of this book, we’ll apply everything we’ve learned to more
    complex scenarios. We’ll start by introducing field validation into our `CustomerForm`
    component.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的下一部分，我们将把所学的一切应用到更复杂的场景中。我们将首先将字段验证引入到我们的`CustomerForm`组件中。
- en: Exercises
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'The following are some exercises for you to try out:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些供你尝试的练习：
- en: Update your `CustomerForm` and `AppointmentForm` tests to use the new builders
    you’ve created.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新你的`CustomerForm`和`AppointmentForm`测试，以使用你创建的新构建器。
- en: Add a test to `AppointmentForm` that ensures that the customer ID is submitted
    when the form is submitted.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`AppointmentForm`添加一个测试，确保在表单提交时提交客户ID。
- en: Part 2 – Building Application Features
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2部分 – 构建应用程序功能
- en: 'This part builds on the basic techniques you’ve learned in *Part 1* by applying
    them to real-world problems that you’ll encounter in your work, and introduces
    libraries that many React developers use: React Router, Redux, and Relay (GraphQL).
    The goal is to show you how the TDD workflow can be used even for large applications.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分基于你在*第1部分*中学到的基本技术，通过将它们应用于你在工作中会遇到的真实世界问题来应用它们，并介绍了许多React开发者使用的库：React
    Router、Redux和Relay（GraphQL）。目标是向你展示TDD工作流程甚至可以用于大型应用程序。
- en: 'This part includes the following chapters:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '[*Chapter 9*](B18423_09.xhtml#_idTextAnchor159), *Form Validation*'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B18423_09.xhtml#_idTextAnchor159)，*表单验证*'
- en: '[*Chapter 10*](B18423_10.xhtml#_idTextAnchor183), *Filtering and Searching
    Data*'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B18423_10.xhtml#_idTextAnchor183)，*过滤和搜索数据*'
- en: '[*Chapter 11*](B18423_11.xhtml#_idTextAnchor207), *Test-Driving React Router*'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B18423_11.xhtml#_idTextAnchor207)，*测试驱动React Router*'
- en: '[*Chapter 12*](B18423_12.xhtml#_idTextAnchor231), *Test-Driving Redux*'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B18423_12.xhtml#_idTextAnchor231)，*测试驱动Redux*'
- en: '[*Chapter 13*](B18423_13.xhtml#_idTextAnchor258), *Test-Driving GraphQL*'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B18423_13.xhtml#_idTextAnchor258)，*测试驱动GraphQL*'
