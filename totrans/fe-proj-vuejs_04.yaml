- en: 4\. Nesting Components (Modularity)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4. 组件嵌套（模块化）
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you will discover how to modularize a Vue.js application using
    component hierarchies and nesting. This chapter introduces concepts such as props,
    events, prop validation, and slots. You will learn how to contrast them and identify
    which concept should be applied based on the situation. You will then practice
    implementing a component that encapsulates direct DOM manipulation using refs.
    You will also learn how to identify component composition scenarios where slots,
    named slots, and scoped slots can be used. You will then identify when to abstract
    functionality into filters.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将发现如何使用组件层次结构和嵌套来模块化 Vue.js 应用程序。本章介绍了 props、events、prop 验证和 slots 等概念。你将学习如何对比它们并根据情况确定应该应用哪个概念。然后，你将练习实现一个使用
    refs 封装直接 DOM 操作的组件。你还将学习如何识别可以使用 slots、命名 slots 和作用域 slots 的组件组合场景。然后，你将确定何时将功能抽象为过滤器。
- en: By the end of this chapter, you will be able to define communication interfaces
    between components using props, events, and validators. You will be exposed to
    refs to wrap JavaScript libraries as Vue.js components and identify the pitfalls
    of the Vue.js context when using components.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够使用 props、events 和验证器定义组件之间的通信接口。你将接触到如何将 JavaScript 库作为 Vue.js 组件封装以及在使用组件时
    Vue.js 上下文的潜在问题。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, we learned how to initialize, build, and debug a simple
    Vue.js application. In this chapter, we will have a closer look at how to leverage
    component composition to enable code re-usability.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何初始化、构建和调试一个简单的 Vue.js 应用程序。在本章中，我们将更深入地了解如何利用组件组合来实现代码重用。
- en: Reusable and extensible components are core to building products around a component
    library. A component library allows a team to build a project with high velocity
    and high consistency.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 可重用和可扩展的组件是围绕组件库构建产品的核心。组件库允许团队以高速度和高一致性构建项目。
- en: If a component library in Vue.js does not expose the right extension points,
    what often happens is that the component from the library is copied over into
    the application's code base. This leads to duplicated code and reduced cohesion
    from a design point of view.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Vue.js 中的组件库没有暴露正确的扩展点，通常会发生的情况是将库中的组件复制到应用程序的代码库中。这导致了代码的重复和从设计角度的凝聚力降低。
- en: In *Chapter 3*, *Vue CLI*, we learned how to create simple components in Vue.
    Components are Vue instances that can be instantiated and rendered multiple times.
    Since there can only be one root component, most components in an application
    are rendered by another component. For parent components to communicate with their
    children, we use props and prop passing.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 3 章*，*Vue CLI* 中，我们学习了如何在 Vue 中创建简单组件。组件是 Vue 实例，可以被实例化和渲染多次。由于只能有一个根组件，应用程序中的大多数组件都是由另一个组件渲染的。为了使父组件与其子组件通信，我们使用
    props 和 prop 传递。
- en: Passing Props
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传递 Props
- en: '`this`) and in the component''s `template`.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`this`) 并在组件的 `template` 中。'
- en: The value of a prop depends on what the parent passes in its `template` to the
    child component at render time.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: prop 的值取决于父组件在渲染时传递给子组件的 `template` 中的内容。
- en: Defining a Simple Component That Takes Props
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义一个接受 Props 的简单组件
- en: Let's look at a simple `Hello` single-file component. This can be found in a
    `./src/components/Hello.vue` file (in a *Vue CLI-generated* project). Note how
    the `who` value is set in the `props` array and that it is interpolated as a value
    using `{{ who }}`. The `props` property of a Vue.js component can be an array
    of strings or an object literal.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的 `Hello` 单文件组件。这可以在 `./src/components/Hello.vue` 文件中找到（在一个 *Vue CLI
    生成的* 项目中）。注意 `who` 值是如何在 `props` 数组中设置的，并且它是通过使用 `{{ who }}` 作为值进行插值的。Vue.js 组件的
    `props` 属性可以是字符串数组或对象字面量。
- en: 'When a value is defined in `props`, it is then accessible as an instance variable
    in the `template` section of the Vue.js component:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 `props` 中定义一个值时，它随后在 Vue.js 组件的 `template` 部分作为一个实例变量可访问：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We will now learn how to render a component using props.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将学习如何使用 props 渲染组件。
- en: Rendering a Component with Props
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Props 渲染组件
- en: What follows is a demonstration of how to use the `Hello` component in our Vue.js
    application.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个如何在我们 Vue.js 应用程序中使用 `Hello` 组件的演示。
- en: First, we need to import and then set it in the `components` property of the
    Vue.js component that wants to render this imported component.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要导入，然后将其设置在想要渲染此导入组件的 Vue.js 组件的 `components` 属性中。
- en: 'Then, in the `template` section, we need to render `<Hello>` with the `who`
    attribute set to `"Vue.js"`, as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`template`部分，我们需要将`<Hello>`渲染出来，并将`who`属性设置为`"Vue.js"`，如下所示：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will render the following on the page:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在页面上渲染以下内容：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We have now seen how to use a component and pass it with props in a Vue.js application.
    This is useful for code reuse and for abstracting application behavior into component-sized
    chunks.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了如何在Vue.js应用程序中使用组件并通过props传递它。这对于代码重用和将应用程序行为抽象为组件大小的块非常有用。
- en: Next, we will learn how to work with registered components.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何与已注册的组件一起工作。
- en: Component Registration Tricks
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件注册技巧
- en: There are a few things to note with regard to the `components` property.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`components`属性，有几个需要注意的事项。
- en: 'Registered components are available both as `CamelCaseName` and as `kebab-case-name`,
    so if we changed the template section shown in the previous example to use `<hello
    />` instead of `<Hello />`, it would work without any issues:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 已注册的组件既可以用`CamelCaseName`格式，也可以用`kebab-case-name`格式，因此如果我们把前一个示例中的模板部分改为使用`<hello
    />`而不是`<Hello />`，它将无任何问题地工作：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The updated template renders the same in the browser, as shown in the following output:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 更新的模板在浏览器中渲染相同的内容，如下所示输出：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `components` property tends to leverage ES6 shorthand property syntax.
    Shorthand property syntax means that instead of writing `{ Hello: Hello }`, we
    can write `{ Hello }`. We can see it in action in the following example, which
    registers the `Hello` component:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`components`属性倾向于使用ES6简写属性语法。简写属性语法意味着我们不需要写`{ Hello: Hello }`，而是可以写`{ Hello
    }`。我们可以在以下示例中看到它的实际应用，该示例注册了`Hello`组件：'
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Vue''s `components` declaration is not aware of the component name. It uses
    the key in the `components` object to register it against both the camelCase and
    kebab-case names:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Vue的`components`声明不知道组件的名称。它使用`components`对象中的键来注册，无论是驼峰式还是短横线命名法：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding code will generate the following output:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将生成以下输出：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We have now learned how to register components in Vue.js using the `components`
    property and ES6 shorthand object property syntax.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经学会了如何在Vue.js中使用`components`属性和ES6简写对象属性语法来注册组件。
- en: Next, we will look at a practical example of a `Greeting` component.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看一个`Greeting`组件的实际示例。
- en: 'Exercise 4.01: Implementing a Greeting Component'
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.01：实现问候组件
- en: Using our knowledge of how props can be passed from a parent component to a
    child component, we will create a component that lets you customize both the greeting
    (for example, `Hello`, `Hey`, or `Hola`) and who is addressed (for example, `World`,
    `Vue.js`, or `JavaScript developers`).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 利用我们对如何从父组件向子组件传递props的知识，我们将创建一个组件，允许你自定义问候语（例如，`Hello`、`Hey`或`Hola`）以及被称呼的对象（例如，`World`、`Vue.js`或`JavaScript开发者`）。
- en: To access the code files for this exercise, refer to [https://packt.live/35jGd7B](https://packt.live/35jGd7B).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅[https://packt.live/35jGd7B](https://packt.live/35jGd7B)。
- en: 'Follow these steps to complete this exercise:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成这个练习：
- en: Create a new file named `Greeting.vue` in the `./src/components` directory.
    This will be our single-file component.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`./src/components`目录下创建一个名为`Greeting.vue`的新文件。这将是我们单文件组件。
- en: 'Start by scaffolding the component with empty `template` and `script` tags:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，用空的`template`和`script`标签搭建组件的框架：
- en: '[PRE8]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we need to tell Vue.js that our component expects props. For this, we
    will add a `props` property to our component definition (the object that''s set
    to `export default` in the `script` section) and add a `greeting` and `who` prop
    to it:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要告诉Vue.js我们的组件期望props。为此，我们将在组件定义（在`script`部分的`export default`设置的object）中添加一个`props`属性，并向其中添加一个`greeting`和`who`属性：
- en: '[PRE9]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we want to render `greeting` and `who`. As we have seen, when values are
    defined in `props`, they are available at the top level of `template`:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们想要渲染`greeting`和`who`。正如我们所见，当在`props`中定义值时，它们在`template`的最高级别中可用：
- en: '[PRE10]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We can now render the `Greeting` component from `App.vue`.
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在可以渲染`App.vue`中的`Greeting`组件。
- en: 'Open the `src/App.vue` file and import the `Greeting` component from `./src/components/Greeting.vue`
    into the `script` section:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`src/App.vue`文件，并将`Greeting`组件从`./src/components/Greeting.vue`导入到`script`部分：
- en: '[PRE11]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, register the `Greeting` component in `components`:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`components`中注册`Greeting`组件：
- en: '[PRE12]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now that the component has been registered, we can render it in `template`:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在组件已经注册，我们可以在`template`中渲染它：
- en: '[PRE13]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You will see the following in your browser (make sure you have run `npm install`
    and `npm run serve` in the `Exercise4.01` directory):'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将在浏览器中看到以下内容（确保你在 `Exercise4.01` 目录中运行了 `npm install` 和 `npm run serve`）：
- en: '[PRE14]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Modify the `greeting` and `who` prop using the attribute values in `template`:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `template` 中的属性值修改 `greeting` 和 `who` 属性：
- en: '[PRE15]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Upon running the preceding code, you should see an output similar to the following
    in your browser (make sure you have run `npm install`, followed by `npm run serve`,
    in the `Exercise4.01` directory):'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行前面的代码后，你应该在浏览器中看到以下类似的输出（确保你在 `Exercise4.01` 目录中运行了 `npm install`，然后运行 `npm
    run serve`）：
- en: '[PRE16]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this exercise, we have learned how props and prop passing can be used to
    increase reuse scenarios of a component by generalizing it. Instead of the component rendering
    static data, its parent passes it the data to render.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们学习了如何使用属性和属性传递来通过泛化组件来增加组件的重用场景。组件不是渲染静态数据，而是其父组件传递数据以进行渲染。
- en: In the next section, we will learn how to set prop values dynamically.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何动态设置属性值。
- en: Dynamic Props with Data Binding
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态属性与数据绑定
- en: The examples we have seen up to now have used hard-coded attribute values as
    props. But what if we want to pass parent instance data from the parent to child?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止看到的示例都使用了硬编码的属性值作为属性。但如果我们想从父组件传递实例数据到子组件怎么办？
- en: This is where `v-bind:`, but you can use `:` for shorthand; they are equivalent.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 `v-bind:` 的用法，但你也可以使用 `:` 作为缩写；它们是等价的。
- en: 'The `who` prop of `Greeting` is bound to the `appWho` app component''s instance property:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`Greeting` 组件的 `who` 属性绑定到 `appWho` 应用组件的实例属性：'
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In shorthand, `template` would look as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 简写形式下，`template` 将如下所示：
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Both versions will output the following view to the browser:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 两种版本都将输出以下视图到浏览器：
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`v-bind:prop-name` and `:prop-name` have a striking similarity since the delimiter
    between `v-bind` and `prop-name` is `:` (a semicolon). In Vue.js single-file components,
    since templates are compiled at build time, they are functionally equivalent.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`v-bind:prop-name` 和 `:prop-name` 有惊人的相似之处，因为 `v-bind` 和 `prop-name` 之间的分隔符是
    `:`（一个分号）。在 Vue.js 单文件组件中，由于模板在构建时编译，它们在功能上是等价的。'
- en: An example to showcase that the values have been `App`) to the child (`Hello`)
    is as follows, with two buttons that change the audience of the `Hello` message.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，展示如何将值从父组件（`App`）传递到子组件（`Hello`），其中包含两个按钮，用于更改 `Hello` 消息的受众。
- en: 'The buttons call a component method called `setWho` with `setWho` function
    updates the `appWho` instance property:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮调用一个名为 `setWho` 的组件方法，`setWho` 函数更新 `appWho` 实例属性：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The initial output to the browser displays `Hello Vue.js`, as shown in the
    following screenshot:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 初始输出到浏览器的显示为 `Hello Vue.js`，如下面的截图所示：
- en: '![Figure 4.1: Initial Hello Vue.js output in the browser'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.1：浏览器中初始的Hello Vue.js输出'
- en: '](img/B15218_04_01.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_04_01.jpg)'
- en: 'Figure 4.1: Initial Hello Vue.js output in the browser'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1：浏览器中初始的Hello Vue.js输出
- en: 'When clicking the `JavaScript` button, the `appWho` variable updates, as does
    the bound `Hello` component''s `who` prop. Thus, `Hello JavaScript` is displayed,
    as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击 `JavaScript` 按钮，`appWho` 变量更新，绑定的 `Hello` 组件的 `who` 属性也会更新。因此，显示为 `Hello
    JavaScript`，如下所示：
- en: '![Figure 4.2: Hello JavaScript after clicking the JavaScript button'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.2：点击 JavaScript 按钮后的 Hello JavaScript'
- en: '](img/B15218_04_02.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_04_02.jpg)'
- en: 'Figure 4.2: Hello JavaScript after clicking the JavaScript button'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：点击 JavaScript 按钮后的 Hello JavaScript
- en: 'When clicking the `Everyone` button, the `appWho` variable updates, as does
    the bound `Hello` component''s `who` prop. Thus, `Hello Everyone` is displayed,
    as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击 `Everyone` 按钮，`appWho` 变量更新，绑定的 `Hello` 组件的 `who` 属性也会更新。因此，显示为 `Hello Everyone`，如下所示：
- en: '![Figure 4.3: Hello Everyone after clicking the Everyone button'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.3：点击 Everyone 按钮后的 Hello Everyone'
- en: '](img/B15218_04_03.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_04_03.jpg)'
- en: 'Figure 4.3: Hello Everyone after clicking the Everyone button'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3：点击 Everyone 按钮后的 Hello Everyone
- en: We have now seen how to bind props to values so that they are kept in sync.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了如何将属性绑定到值，以便它们保持同步。
- en: The majority of Vue.js applications leverage components beyond modularizing
    the rendered components (as we did with the `Greeting` and `Hello` components).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Vue.js 应用程序利用组件不仅用于模块化渲染组件（正如我们在 `Greeting` 和 `Hello` 组件中所做的那样），还用于其他方面。
- en: As we have seen, we are able to bind props so that any update that's made to
    a value in the parent will cause an update in the child component.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们能够绑定属性，以便对父组件中任何值的更新都会导致子组件的更新。
- en: 'Exercise 4.02: Passing Props That Change Over Time'
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`Greeting`组件渲染当前的`greeting`和`who`：
- en: To know which greeting to use, we will implement a **greeter** app that has
    multiple greetings and cycles through them.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，应用程序在浏览器中应显示相同的问候语，如下面的输出所示：
- en: To access the code files for this exercise, refer to [https://packt.live/3kovKfo](https://packt.live/3kovKfo).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅[https://packt.live/3kovKfo](https://packt.live/3kovKfo)。
- en: 'Follow these steps to complete this exercise:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重构`data`方法，使其只存储默认索引并创建查找索引以生成基于当前索引的`greeting`和`who`的计算属性（使用中间的`currentGreeting`计算属性）：
- en: 'Create a `./src/components/Greeting.vue` component and initialize it with our
    previously implemented `Greeting` component. This is how we''ll display the greetings:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览器将显示一条消息，如下所示（确保你在`Exercise4.02`目录中运行了`npm install`和`npm run serve`）：
- en: '[PRE21]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the `./src/App.vue` component, import `./src/components/Greeting.vue` as
    a `Greeting` and register it as a component so that you can render it:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`./src/App.vue`组件中，将`./src/components/Greeting.vue`导入为`Greeting`组件，并注册为组件，以便你可以渲染它：
- en: '[PRE22]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the `script` section, create a `data` top-level method that returns an initial
    `greeting` and `who`:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`script`部分，创建一个返回初始`greeting`和`who`的顶级`data`方法：
- en: '[PRE23]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Render the current `greeting` and `who` using the `Greeting` component:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 图4.5：在3n + 1次按钮点击后“嘿，大家好”
- en: '[PRE24]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Your browser will display a message, as follows (make sure you have run `npm
    install` and `npm run serve` in the `Exercise4.02` directory):'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要知道使用哪个问候语，我们将实现一个具有多个问候语并遍历它们的**greeter**应用程序。
- en: Note
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在初始加载和点击`New Greeting`按钮的`3n`次之后，应用程序显示`Hello Vue.js`，如下面的截图所示：
- en: The following code requires that you have knowledge of computed properties,
    which we covered in *Chapter 2*, *Working with Data*. Please go back to that chapter
    now if you need a refresher.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图4.4：在3n次按钮点击后“你好，Vue.js”]'
- en: 'We will now add some `greeting/who` pairings as an array to the `script` section:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意
- en: '[PRE25]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s refactor the `data` method so that it only stores the default index
    and creates computed properties that look up the index to generate a `greeting`
    and `who` based on the current index (with an intermediary `currentGreeting` computed
    property):'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于计算属性可以清理代码，我们不需要更新我们的模板。相反，我们用同名的计算属性替换了`greeting`和`who`实例属性。
- en: '[PRE26]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'At this point, the application should still display the same greeting in the
    browser, as shown in the following output:'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.4：在3n次按钮点击后“你好，Vue.js”
- en: '[PRE27]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图4.6：在3n + 2次按钮点击后“嗨，JavaScript”]'
- en: As computed properties clean the code up, we did not need to update our template.
    Instead, we have replaced the `greeting` and `who` instance properties with computed
    properties of the same name.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在需要在`script`部分实现`newGreeting`。`newGreeting`应该移动到下一个问候语（通过增加`currentIndex`）。或者，如果我们已经到达了`possibleGreetings`数组的末尾，它应该重置`currentIndex`：
- en: 'Let''s add a way to cycle through these `greetings`. This will involve a button
    that, upon being clicked, will call a `newGreeting` function in our `template`:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一种遍历这些`问候语`的方法。这需要有一个按钮，点击后会在我们的`template`中调用一个`newGreeting`函数：
- en: '[PRE28]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, we need to implement `newGreeting` in `script`. `newGreeting` should
    move to the next greeting (by incrementing `currentIndex`). Alternatively, if
    we have already reached the end of the `possibleGreetings` array, it should reset
    `currentIndex`:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意
- en: '[PRE29]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'On initial load and after `3n` clicks of the `New Greeting` button, the application
    displays `Hello Vue.js`, as shown in the following screenshot:'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建一个`./src/components/Greeting.vue`组件，并用我们之前实现的`Greeting`组件初始化它。这就是我们将显示问候语的方式：
- en: '![Figure 4.4: Hello Vue.js after 3n button clicks'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: '](img/B15218_04_04.jpg)'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下代码需要你了解我们已在*第2章*，*与数据一起工作*中介绍的计算属性。如果你需要复习，现在请回到那一章。
- en: 'Figure 4.4: Hello Vue.js after 3n button clicks'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 练习4.02：传递随时间变化的属性
- en: 'After the first click and after `3n + 1` clicks of the `New Greeting` button,
    the application displays `Hey Everyone`, as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次点击和点击`New Greeting`按钮的`3n + 1`次之后，应用程序显示`Hey Everyone`，如下所示：
- en: '![Figure 4.5: Hey Everyone after 3n + 1 button clicks'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.5：在3n + 1次按钮点击后“嘿，大家好”]'
- en: '](img/B15218_04_05.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.4：在3n次按钮点击后“你好，Vue.js”]'
- en: 'Figure 4.5: Hey Everyone after 3n + 1 button clicks'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此练习：
- en: 'After the second click and after `3n + 2` clicks of the `New Greeting` button,
    the application displays `Hi JavaScript`, as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二次点击和点击`New Greeting`按钮的`3n + 2`次之后，应用程序显示`Hi JavaScript`，如下所示：
- en: '![Figure 4.6: Hi JavaScript after 3n + 2 button clicks'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将一些`greeting/who`配对作为数组添加到`script`部分：
- en: '](img/B15218_04_06.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.6：在3n + 2次按钮点击后“嗨，JavaScript”]'
- en: 'Figure 4.6: Hi JavaScript after 3n + 2 button clicks'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6：在3n + 2次按钮点击后说“Hi JavaScript”
- en: Note
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This code can be improved further; for example, `possibleGreetings.length -
    1` is constant since we never add or remove greetings. Instead of computing on
    every `newGreeting` call, we could compute it once, outside of the `newGreeting`
    method. Reading the length of an array and simple arithmetic (`-1`) is not too
    costly but this is a good refresher on thinking in terms of mutable versus constant
    values.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以进一步改进；例如，`possibleGreetings.length - 1`是常量，因为我们从未添加或删除问候语。我们可以在`newGreeting`方法之外，仅计算一次，而不是在每次`newGreeting`调用时计算。读取数组的长度和简单的算术（`-1`）并不太昂贵，但这是对可变值与常量值思考方式的好复习。
- en: With that, we have seen how props and prop binding can be used to communicate
    about changing data from parent components to child components they render. To
    scale a code base or share code widely, it is helpful to give hints to the consumer
    of the code when they are using it incorrectly.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经看到了如何使用属性和属性绑定来从父组件向它们渲染的子组件传递变化的数据。为了扩展代码库或广泛共享代码，当用户使用代码不正确时，给出提示是有帮助的。
- en: Next, we will learn how to add type hints to our component's props to ensure
    they are used correctly.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何为组件的属性添加类型提示以确保它们被正确使用。
- en: Prop Typing and Validation
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性类型和验证
- en: '**Props** define the interface of Vue.js components. As JavaScript is a dynamically
    typed language, Vue.js provides a tool we can use to validate the shape and types
    of props.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**属性**定义了Vue.js组件的接口。由于JavaScript是一种动态类型语言，Vue.js提供了一个我们可以用来验证属性形状和类型的工具。'
- en: To validate prop types, the `props` component property in its object literal
    form should be used (as opposed to the simpler array form).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证属性类型，应使用其对象字面量形式的`props`组件属性（而不是更简单的数组形式）。
- en: Primitive Prop Validation
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原始属性验证
- en: 'Say we want a `Repeat.vue` component that takes a `times` prop, as well as
    a `content` prop. We can define the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要一个`Repeat.vue`组件，它接受一个`times`属性，以及一个`content`属性。我们可以定义以下内容：
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Our `Repeat` component would be consumed as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Repeat`组件可以这样使用：
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The preceding code will lead to the following output in the browser:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将在浏览器中产生以下输出：
- en: '![Figure 4.7: Output of the repeat example in action (no clicks)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.7：重复示例动作输出（无点击）]'
- en: '](img/B15218_04_07.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15218_04_07.jpg](img/B15218_04_07.jpg)'
- en: 'Figure 4.7: Output of the repeat example in action (no clicks)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7：重复示例动作输出（无点击）
- en: 'After clicking the `Repeat` button a few times, the `Repeat` component will
    repeat an additional time for every click generating an output, as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 点击`Repeat`按钮几次后，`Repeat`组件将每次点击额外重复一次，生成如下输出：
- en: '![Figure 4.8: Output of the repeat example after five clicks'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.8：重复示例在点击五次后的输出]'
- en: '](img/B15218_04_08.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15218_04_08.jpg](img/B15218_04_08.jpg)'
- en: 'Figure 4.8: Output of the repeat example after five clicks'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8：重复示例在点击五次后的输出
- en: For this component to work properly, we need `times` to be a `Number`, and ideally
    `content` to be a `String`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使该组件正常工作，我们需要`times`是一个`Number`类型，理想情况下`content`是一个`String`类型。
- en: Note
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Now is a good time to remind students of the JavaScript primitive types: `String`,
    `Number`, `Boolean`, `Array`, `Object`, `Date`, `Function`, and `Symbol`.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是提醒学生JavaScript原始类型的好时机：`String`、`Number`、`Boolean`、`Array`、`Object`、`Date`、`Function`和`Symbol`。
- en: Vue.js supports all the JavaScript primitive type constructors as type hints
    in the `props` field.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js支持在`props`字段中使用所有JavaScript原始类型构造函数作为类型提示。
- en: 'In this instance, we are defining the `times` prop as a `Number` and the `content`
    props as a `String`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将`times`属性定义为`Number`类型，将`content`属性定义为`String`类型：
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To consume this component, we can update the `script` section as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此组件，我们可以更新`script`部分如下：
- en: '[PRE33]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The component still behaves the same in the `times` and `content` are a `Number`
    and a `String`, respectively.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当`times`和`content`分别是`Number`和`String`类型时，组件的行为仍然相同。
- en: If we update `App` so that it wilfully passes props of the wrong type. In this
    case, `times` is a `String` and `content` is a `Number`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们更新`App`使其故意传递错误类型的属性。在这种情况下，`times`是一个`String`类型，而`content`是一个`Number`类型。
- en: '[PRE34]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here, the `Repeat` component will fail to render, and the following errors
    will be logged to the console:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Repeat`组件将无法渲染，以下错误将被记录到控制台：
- en: '![Figure 4.9: Mistyping Vue.js prop errors'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.9：Vue.js属性输入错误示例]'
- en: '](img/B15218_04_09.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15218_04_09.jpg](img/B15218_04_09.jpg)'
- en: 'Figure 4.9: Mistyping Vue.js prop errors'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9：Vue.js属性输入错误示例
- en: 'The `times` prop check fails with a message that explains that we passed a
    `String` as a prop that was supposed to be a `Number`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`times` 属性检查失败，消息解释说我们传递了一个本应为 `Number` 的 `String` 属性：'
- en: '[PRE35]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `content` prop check fails with a message that explains that we passed
    a `Number` as a prop that was supposed to be a `String`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`content` 属性检查失败，消息解释说我们传递了一个本应为 `String` 的 `Number` 属性：'
- en: '[PRE36]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As per the Vue.js documentation, *null and undefined values will pass any type
    validation*, which means that the type validations are not foolproof and that
    it can make sense to add custom validation to a component.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Vue.js文档，*null 和 undefined 值将通过任何类型验证*，这意味着类型验证并不是万无一失的，因此为组件添加自定义验证是有意义的。
- en: Union and Custom Prop Types
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 联合和自定义属性类型
- en: In the previous example, we were just rendering the content, so it didn't matter
    what type it was.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们只是渲染了内容，所以类型是什么并不重要。
- en: Vue.js supports union types. A union type is a type that can be one of many
    other types. For example, `String` or `Number` is a `union` type.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js 支持联合类型。联合类型是一种可以是许多其他类型之一的类型。例如，`String` 或 `Number` 是联合类型。
- en: 'Union types in Vue.js are represented using an array for the prop''s `type`
    property, for example, to support numbers and strings as `content`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vue.js 中，联合类型使用数组来表示属性 `type` 属性，例如，为了支持 `content` 作为数字和字符串：
- en: '[PRE37]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In this case, we can consume the `RepeatTyped` component as follows without errors:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以无错误地消费 `RepeatTyped` 组件，如下所示：
- en: '[PRE38]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This displays `55` three times. Here, `55` was passed as a `Number`, which
    our component now supports. This can be seen in the following output:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这会显示 `55` 三次。在这里，`55` 被作为 `Number` 传递，而我们的组件现在支持这一点。这可以在以下输出中看到：
- en: '[PRE39]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Any valid constructor can be used as the prop type. For example, `Promise`
    or a `custom User` constructor can be used. In the following example, we are defining
    a `TodoList` component prop interface:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 任何有效的构造函数都可以用作属性类型。例如，`Promise` 或自定义的 `User` 构造函数可以用来。在以下示例中，我们定义了一个 `TodoList`
    组件属性接口：
- en: '[PRE40]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The prop interface that''s exposed by this component can be used as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件公开的属性接口可以如下使用：
- en: '[PRE41]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We have now seen how to use the `union` and `custom` types to validate Vue.js
    props.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用 `union` 和 `custom` 类型来验证 Vue.js 属性。
- en: Note
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Vue.js uses `instanceof` internally, so make sure any custom types are instantiated
    using the relevant constructor.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js 在内部使用 `instanceof`，所以请确保任何自定义类型都是使用相关构造函数实例化的。
- en: Passing `null` or `undefined` will fail the `instanceof` check for `Array` and
    `Object`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 传递 `null` 或 `undefined` 将会失败 `instanceof` 对 `Array` 和 `Object` 的检查。
- en: Passing an array will pass the `instanceof` check for `Object` since, in JavaScript,
    `Array` instances are also `Object` instances.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 传递一个数组将通过 `instanceof` 对 `Object` 的检查，因为在 JavaScript 中，`Array` 实例也是 `Object`
    实例。
- en: Custom Validation of Arrays, Object Shapes, and More with Validators
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用验证器进行数组的自定义验证、对象形状等
- en: Vue.js allows custom validators to be used as props using the `validator` property.
    This allows us to implement deep checks regarding object and array shape as custom
    logic for primitive types.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js 允许使用 `validator` 属性将自定义验证器用作属性。这允许我们实现有关对象和数组形状的深度检查，作为原始类型的自定义逻辑。
- en: To illustrate this, let's look at a `CustomSelect` component. On a basic level,
    the prop interface for a `select` comprises an array of `options` and a `selected`
    option. Each option should have a `label` that represents what is displayed in
    the select and a `value` that corresponds to the value passed to an API. For example,
    the `selected` option can be empty or should correspond to the `value` field for
    one of our `options`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们看看一个 `CustomSelect` 组件。在基本层面上，`select` 的属性接口包括一个 `options` 数组和一个
    `selected` 选项。每个选项应该有一个 `label`，表示在选择中显示的内容，以及一个 `value`，它对应于传递给 API 的值。例如，`selected`
    选项可以是空的，或者应该对应于 `options` 中的一个 `value` 字段。
- en: 'Our `CustomSelect` can be implemented as follows in a naive way (no validation
    of the inputs):'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 `CustomSelect` 以以下简单方式实现（不验证输入）：
- en: '[PRE42]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`CustomSelect` can then be used to display a list of `src/App.vue`):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`CustomSelect` 可以用来显示 `src/App.vue` 中的列表）：
- en: '[PRE43]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The preceding application outputs a select where `Salt & Vinegar` is the default
    selected option, as shown in the following screenshot:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的应用程序输出了一个选择，其中 `Salt & Vinegar` 是默认选中选项，如下面的截图所示：
- en: '![Figure 4.10: Collapsed CustomSelect with Salt & Vinegar selected'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.10：折叠的 CustomSelect，选择了 Salt & Vinegar]'
- en: '](img/B15218_04_10.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15218_04_10.jpg](img/B15218_04_10.jpg)'
- en: 'Figure 4.10: Collapsed CustomSelect with Salt & Vinegar selected'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10：折叠的 CustomSelect，选择了 Salt & Vinegar
- en: 'The following screenshot displays three flavor options, out of which one is
    selected:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了三种口味选项，其中一个是被选中的：
- en: '![Figure 4.11: Open CustomSelect with flavor options and Salt & Vinegar selected'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.11：打开带有口味选项和盐味芥末的CustomSelect'
- en: '](img/B15218_04_11.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_04_11.jpg)'
- en: 'Figure 4.11: Open CustomSelect with flavor options and Salt & Vinegar selected'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11：打开带有口味选项和盐味芥末的CustomSelect
- en: 'To further validate our business logic around what shape options are, we can
    implement the following prop validator:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步验证我们关于形状选项的业务逻辑，我们可以实现以下属性验证器：
- en: '[PRE44]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If we pass an option with a missing `value` or `label`, we will get the following
    message in the console:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们传递一个缺少`value`或`label`的选项，我们将在控制台得到以下消息：
- en: '![Figure 4.12: Vue.js warning when a custom validator fails'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.12：当自定义验证器失败时Vue.js的警告'
- en: '](img/B15218_04_12.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_04_12.jpg)'
- en: 'Figure 4.12: Vue.js warning when a custom validator fails'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.12：当自定义验证器失败时Vue.js的警告
- en: With that, we have learned how to use a custom Vue.js validator to do in-depth
    checks of complex props. Next, we will learn how the `required` prop type property works.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些，我们已经学习了如何使用自定义Vue.js验证器对复杂属性进行深入检查。接下来，我们将学习`required`属性类型属性是如何工作的。
- en: Required Props
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 必需属性
- en: To mark a Vue.js prop as required, we can use the `required` prop type property.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 要将Vue.js属性标记为必需，我们可以使用`required`属性类型属性。
- en: In the `CustomSelect` example, we can make `selected` a required prop.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CustomSelect`示例中，我们可以将`selected`属性标记为必需。
- en: 'To do this, we need to amend the prop definition so that it includes `required:
    true`, as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '要做到这一点，我们需要修改属性定义，使其包括`required: true`，如下所示：'
- en: '[PRE45]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, if we amend the consumer of `CustomSelect` so that it does *not* pass
    a `selected` prop, we will see the following error:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们修改`CustomSelect`的消费者，使其不传递`selected`属性，我们将看到以下错误：
- en: '![Figure 4.13: Vue.js warning when the selected required prop is missing'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.13：当选定的必需属性缺失时Vue.js的警告'
- en: '](img/B15218_04_13.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_04_13.jpg)'
- en: 'Figure 4.13: Vue.js warning when the selected required prop is missing'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.13：当选定的必需属性缺失时Vue.js的警告
- en: With that, we have learned how to mark Vue.js props as required and what happens
    when a required prop is not passed. Next, we will learn how defaulting a prop
    can be the best choice.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些，我们已经学习了如何标记Vue.js属性为必需，以及当不传递必需属性时会发生什么。接下来，我们将学习将属性默认为最佳选择。
- en: Defaulting Props
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认属性
- en: There are situations where defaulting a prop is the best interface for a component.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，将属性默认为最佳组件接口。
- en: An example of this is a `PaginatedList` component that takes a list and displays
    a subset of this list based on the `limit` and `offset` parameters. In this scenario,
    instead of making `limit` and `offset`, it might be better to default `limit`
    to something such as `25` and `offset` to `0` (by default, we show the first page,
    which contains `25` results).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这的一个例子是一个`PaginatedList`组件，它接受一个列表并根据`limit`和`offset`参数显示该列表的子集。在这种情况下，我们可能最好将`limit`默认为`25`，将`offset`默认为`0`（默认情况下，我们显示第一页，包含`25`个结果）。
- en: 'This is how we would implement such a `PaginatedList` component without defaults:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何实现没有默认值的`PaginatedList`组件的示例：
- en: '[PRE46]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We can consume this using the following code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码来使用它：
- en: '[PRE47]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'By incrementing the limit to 3, we can display the whole list, as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将限制增加到3，我们可以显示整个列表，如下所示：
- en: '[PRE48]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then, by incrementing the offset, we can skip the first *X* elements in the
    list. The following screenshot shows `PaginatedList`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过增加偏移量，我们可以跳过列表中的前*X*个元素。以下截图显示了`PaginatedList`：
- en: '![Figure 4.14: PaginatedList with limit 3 and offset 1'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.14：带有限制3和偏移1的PaginatedList'
- en: '](img/B15218_04_14.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_04_14.jpg)'
- en: 'Figure 4.14: PaginatedList with limit 3 and offset 1'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.14：带有限制3和偏移1的PaginatedList
- en: 'Now, to make our `PaginatedList` is resilient, we will default `limit` to `25`
    and `offset` to `0`. To do so, we can set the `default` property for the relevant
    props:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了使我们的`PaginatedList`具有弹性，我们将默认`limit`为`25`，将`offset`默认为`0`。为此，我们可以设置相关属性的`default`属性：
- en: '[PRE49]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: With these defaults, we will show `25` items from the start of the list by default.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些默认值，我们将默认从列表开头显示`25`个条目。
- en: There is a gotcha with `default` in the case of arrays and objects (for example,
    if we wanted to default `items`), as per the Vue.js documentation; that is, *"Object
    or array defaults must be returned from a factory function"*.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在数组或对象的情况下，`default`存在一个问题（例如，如果我们想将`items`默认），根据Vue.js文档；即，“对象或数组默认必须从工厂函数返回”。
- en: '`factory function` is a function—in this case, called `default`—that returns
    the default value we want.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`factory function` 是一个函数——在这种情况下，称为 `default`——它返回我们想要的默认值。'
- en: 'In the case of `items`, we can write the following:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `items` 的情况下，我们可以编写以下内容：
- en: '[PRE50]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: With that, we have learned how to default Vue.js component props. This can be
    helpful when we wish to provide values for optional parameters so that the Vue.js
    component implementation does not need to handle defaulting prop values.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经学习了如何设置 Vue.js 组件属性的默认值。当我们希望为可选参数提供值，以便 Vue.js 组件实现不需要处理默认属性值时，这很有帮助。
- en: 'Exercise 4.03: Validating an Object Property'
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 4.03：验证对象属性
- en: In this exercise, we will rewrite the `Repeat` component so that it supports
    a single `config` prop for passing `times`, which is a `Number`, and `content`,
    which is a `String`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将重写 `Repeat` 组件，使其支持单个 `config` 属性，用于传递 `times`（一个数字）和 `content`（一个字符串）。
- en: We will have to write a custom validator to make sure `times` and `content`
    exist and are of the correct type.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不得不编写一个自定义验证器来确保 `times` 和 `content` 存在且类型正确。
- en: To access the code files for this exercise, refer to [https://packt.live/2Ui1hVU](https://packt.live/2Ui1hVU).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅 [https://packt.live/2Ui1hVU](https://packt.live/2Ui1hVU)。
- en: 'Follow these steps to complete this exercise:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此练习：
- en: 'We will want our `src/components/Repeat.vue` component to support a `config`
    prop. This will be an `Object` that yields the following `<script>`:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望我们的 `src/components/Repeat.vue` 组件支持一个 `config` 属性。这将是一个 `Object`，它产生以下
    `<script>`：
- en: '[PRE51]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Next, we want something to render when `config` is passed. To do this, we will
    create an array to `v-for` over a computer property. The array length will be
    based on the value of `config.times`:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们希望当传递 `config` 时渲染某些内容。为此，我们将创建一个数组，通过 `v-for` 遍历一个计算机属性。数组的长度将基于 `config.times`
    的值：
- en: '[PRE52]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The next step is to set up `<template>` so that it renders `config.content`
    for each of the `repetitions` items:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是设置 `<template>` 以渲染 `config.content`，对于每个 `repetitions` 项目：
- en: '[PRE53]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Currently, we are ensuring that `content` and `times` have been set and are
    of the correct type. To do so, we will implement `typeof` checks in the config
    prop''s `validator`:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，我们正在确保 `content` 和 `times` 已设置且类型正确。为此，我们将在配置属性 `validator` 中实现 `typeof`
    检查：
- en: '[PRE54]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Finally, we can consume `Repeat` from `src/App.vue`. We need to import it,
    register it (in `script`), and render it in `template`:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以在 `src/App.vue` 中消耗 `Repeat`。我们需要导入它，在 `script` 中注册它，并在 `template` 中渲染它：
- en: '[PRE55]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This will unfortunately not render anything since `config` is an empty object.
    You will observe a warning, as follows:'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 很遗憾，这不会渲染任何内容，因为 `config` 是一个空对象。你将观察到以下警告：
- en: '![Figure 4.15: Vue.js warning due to the config prop''s custom validator check
    failing'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 4.15：由于配置属性的定制验证器检查失败而导致的 Vue.js 警告'
- en: '](img/B15218_04_15.jpg)'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_04_15.jpg)'
- en: 'Figure 4.15: Vue.js warning due to the config prop''s custom validator check
    failing'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.15：由于配置属性的定制验证器检查失败而导致的 Vue.js 警告
- en: 'We will see this same error in the following cases:'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在以下情况下看到相同的错误：
- en: 'a) We only add a `times` property; that is, `<Repeat :config="{ times: 3 }"
    />`.'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'a) 我们只添加一个 `times` 属性；即 `<Repeat :config="{ times: 3 }" />`。'
- en: 'b) We only add a `content` property; that is, `<Repeat :config="{ content:
    ''Repeat me.'' }" />`.'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'b) 我们只添加一个 `content` 属性；即 `<Repeat :config="{ content: ''Repeat me.'' }" />`。'
- en: 'c) `times` is of the wrong type; that is, `<Repeat :config="{ times: ''3'',
    content: ''Repeat me.'' }" />`.'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'c) `times` 的类型不正确；即 `<Repeat :config="{ times: ''3'', content: ''Repeat me.''
    }" />`。'
- en: 'd) `content` is of the wrong type property; that is, `<Repeat :config="{ times:
    3, content: 42 }" />`.'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'd) `content` 属性的类型不正确；即 `<Repeat :config="{ times: 3, content: 42 }" />`。'
- en: 'For `Repeat` to work correctly, we can amend the line consuming it in `template`
    to the following:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使 `Repeat` 正确工作，我们可以修改在 `template` 中消耗它的行，如下所示：
- en: '[PRE56]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This shows no errors in the console and renders `Repeat me.` three times, as follows:'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这在控制台中没有显示错误，并渲染 `Repeat me.` 三次，如下所示：
- en: '[PRE57]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: With that, we've shown how we might go about validating props to better define
    the interface of a Vue.js component.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经展示了如何验证属性以更好地定义 Vue.js 组件的接口。
- en: What follows is a deep dive into slots, a mechanism we can use to compose our
    components by deferring template logic.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是对 `slots` 的深入探讨，这是一种机制，我们可以通过延迟模板逻辑来组合我们的组件。
- en: Slots, Named Slots, and Scoped Slots
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插槽、命名插槽和作用域插槽
- en: Another component composition pattern that enables reusability in Vue.js is
    `slots`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个在 Vue.js 中实现可重用性的组件组合模式是 `slots`。
- en: '**Slots** are sections of a component where the template/rendering is delegated
    back to the consumer of the component.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '**插槽**是组件中的部分，其中模板/渲染被委托回组件的消费者。'
- en: Here, props can be thought of as data that is passed from a parent to a child
    for said child to run some logic or to render it.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，props 可以被视为从父组件传递给子组件的数据，以便子组件执行某些逻辑或进行渲染。
- en: Slots can be thought of as templates or markup that's passed from a parent to
    a child for said child to render.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 插槽可以被视为从父组件传递给子组件以进行渲染的模板或标记。
- en: Passing Markup to Be Rendered in a Child Component
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将标记传递给子组件进行渲染
- en: The simplest type of slot is the default `child` slot.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的插槽类型是默认的 `child` 插槽。
- en: 'We can define a `Box` component with a slot as follows. Note that this `Box`
    component does very little:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个具有插槽的 `Box` 组件如下。请注意，这个 `Box` 组件做得很少：
- en: '[PRE58]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The following markup is for the parent component (`src/App.vue`):'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 以下标记用于父组件（`src/App.vue`）：
- en: '[PRE59]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The preceding code will look as follows in the browser:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，前面的代码将如下所示：
- en: '[PRE60]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The `template` section in the Vue Single File Component for the scope is compiled
    with the parent component's scope.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: Vue 单文件组件的作用域中的 `template` 部分，是用父组件的作用域编译的。
- en: 'Consider the following example:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE61]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The preceding code will render `count` as per its value in the parent component.
    It does not have access to the `Box` instance data or props and will generate
    the following output:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将根据父组件中的 `count` 值渲染 `count`。它无法访问 `Box` 实例数据或 props，并将生成以下输出：
- en: '![Figure 4.16: Initial h3 with a count of 0, as per the initial data in the
    parent component'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.16：初始的 h3，计数为 0，根据父组件的初始数据'
- en: '](img/B15218_04_16.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_04_16.jpg)'
- en: 'Figure 4.16: Initial h3 with a count of 0, as per the initial data in the parent
    component'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.16：初始的 h3，计数为 0，根据父组件的初始数据
- en: 'Incrementing the count does indeed update the template, as we would expect
    if the variable in the template was bound to data on the parent. This will generate
    the following output:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 增加计数确实会更新模板，正如我们预期的那样，如果模板中的变量绑定到父组件上的数据。这将生成以下输出：
- en: '![Figure 4.17: h3 with a count of 5 after five increments of the count in the
    parent component''s scope'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.17：在父组件的作用域中计数增加五次后的 h3，计数为 5'
- en: '](img/B15218_04_17.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_04_17.jpg)'
- en: 'Figure 4.17: h3 with a count of 5 after five increments of the count in the
    parent component''s scope'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.17：在父组件的作用域中计数增加五次后的 h3，计数为 5
- en: Slots are a way to delegate rendering a section of a child component to the
    parent component. Any references to instance properties, data, or methods will
    use the parent component instance. This type of slot does not have access to the
    child component's properties, props, or data.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 插槽是将子组件的一部分渲染委托给父组件的方式。任何对实例属性、数据或方法的引用都将使用父组件实例。这种类型的插槽无法访问子组件的属性、props 或数据。
- en: In the next section, we will look at how to use named slots to render multiple
    sections.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何使用命名插槽来渲染多个部分。
- en: Using Named Slots to Delegate Rendering of Multiple Sections
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用命名插槽来委托多个部分的渲染
- en: '**Named slots** are used when the child component needs to be able to delegate
    the template of multiple sections to the parent.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**命名插槽**用于当子组件需要能够将多个部分的模板委托给父组件时。'
- en: For example, an `Article` component might delegate rendering of `header` and
    `excerpt` to its parent.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个 `Article` 组件可能会将 `header` 和 `excerpt` 的渲染委托给其父组件。
- en: 'In this case, this would look as follows in the `Article.vue` file. Named slots
    are `slot` entries with `name` attributes that denote the slot''s name:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，这将在 `Article.vue` 文件中如下所示。命名插槽是具有 `name` 属性的 `slot` 条目，表示插槽的名称：
- en: '[PRE62]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: By doing this, you can consume this component in another component.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，您可以在另一个组件中消费此组件。
- en: For passing the slot's contents, we use the `v-slot:name` directive (where `name`
    should be replaced with the slot's name).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 为了传递插槽的内容，我们使用 `v-slot:name` 指令（其中 `name` 应替换为插槽的名称）。
- en: 'For example, for the slot named `title`, we will use `v-slot:title`, while
    for the `excerpt` slot, we will use `v-slot:excerpt`:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于名为 `title` 的插槽，我们将使用 `v-slot:title`，而对于 `excerpt` 插槽，我们将使用 `v-slot:excerpt`：
- en: '[PRE63]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'When the preceding application is seen in the browser, it will look as follows:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 当在浏览器中看到前面的应用程序时，它将如下所示：
- en: '![Figure 4.18: Article using named slots rendering templates defined by the
    parent'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.18：使用命名插槽渲染由父组件定义的模板'
- en: '](img/B15218_04_18.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_04_18.jpg)'
- en: 'Figure 4.18: Article using named slots rendering templates defined by the parent'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.18：使用命名插槽渲染父组件定义的模板
- en: As you can see, the named slots do indeed render the expected content.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，命名插槽确实渲染了预期的内容。
- en: 'The shorthand syntax for `v-slot:slot-name` is `#slot-name`. We could refactor
    our template that consumes `Article` as follows:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`v-slot:slot-name` 的简写语法是 `#slot-name`。我们可以重构我们的模板，以消费 `Article` 如下：'
- en: '[PRE64]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '`v-slot` cannot be used with native elements. It can only use `template` and
    components. For example, the following `<template>` section attempts to set a
    `v-slot` on a `h3` element:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`v-slot` 不能与原生元素一起使用。它只能使用 `template` 和组件。例如，以下 `<template>` 部分尝试在 `h3` 元素上设置
    `v-slot`：'
- en: '[PRE65]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This template will fail with a compilation error of `v-slot can only be used
    on components or <template>`, as shown in the following screenshot:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板将因为 `v-slot` 只能在组件或 `<template>` 上使用而失败，如下面的截图所示：
- en: '![Figure 4.19: v-slot on a native element – compilation error'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.19：原生元素上的 v-slot – 编译错误'
- en: '](img/B15218_04_19.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_04_19.jpg)'
- en: 'Figure 4.19: v-slot on a native element – compilation error'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.19：原生元素上的 v-slot – 编译错误
- en: Earlier versions of Vue.js allowed an alternative syntax to be used for denoting
    named slot contents (this was deprecated in Vue 2.6.0+). Instead of the `v-slot:slot-name`
    directive style, `slot="slot-name"` was used. The `slot` syntax was allowed on
    native elements, as well as on templates and components.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js 的早期版本允许使用另一种语法来表示命名插槽的内容（这在 Vue 2.6.0+ 中已被弃用）。而不是使用 `v-slot:slot-name`
    指令样式，使用了 `slot="slot-name"`。`slot` 语法被允许在原生元素、模板和组件上使用。
- en: Note
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Everything that applies to the default slot applies to named slots. In fact,
    the default slot is a named slot called `default`. This means that named slots
    also have access to the parent instance but not the child instance.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 适用于默认插槽的一切也适用于命名插槽。事实上，默认插槽是一个名为 `default` 的命名插槽。这意味着命名插槽也可以访问父实例，但不能访问子实例。
- en: The default slot is just a slot named `default` and gets special treatment by
    Vue.js as it is used by default in a `slot` with no `name`.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 默认插槽只是一个名为 `default` 的插槽，并且由于在没有任何 `name` 的 `slot` 中默认使用，Vue.js 对其进行了特殊处理。
- en: 'The `default` slot is implicitly inferred as follows:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 默认插槽隐式推断如下：
- en: '[PRE66]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The default slot can be denoted with shorthand slot notation.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 默认插槽可以用简写槽表示法表示。
- en: '[PRE67]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We have now seen how named slots allow components to delegate templating of
    certain sections to a consumer, as well as how these named slots can have a default
    template to cater for cases where a named slot is optional.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，命名插槽允许组件将某些部分的模板委托给消费者，以及这些命名插槽如何有一个默认模板来处理命名插槽可选的情况。
- en: In the next section, we will learn how scoped slots are used to wrap prop passing logic.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何使用作用域插槽来封装属性传递逻辑。
- en: Using Scoped Slots to Wrap Prop Passing Logic
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用作用域插槽封装属性传递逻辑
- en: The types of slots we have explored so far only have access to the component
    instance in which they are declared.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止探索的插槽类型只能访问它们声明的组件实例。
- en: Sometimes, it is useful to let the parent component dictate the rendering while
    letting the child component transform the data in some way. This is what scoped
    slots are used for.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，让父组件决定渲染，同时让子组件以某种方式转换数据是有用的。这就是作用域插槽的用途。
- en: A `slot` element has some attributes bound to it via the use of `v-bind` or
    the shorthand, `:`.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `slot` 元素通过使用 `v-bind` 或简写 `:` 绑定了一些属性。
- en: 'In this case, `item` is bound to `el`. `el` is an element of the `items` prop
    that has been passed to this `PaginatedList` component:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`item` 被绑定到 `el`。`el` 是传递给此 `PaginatedList` 组件的 `items` 属性的一个元素：
- en: '[PRE68]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: On the consumer side (the parent component), we can think of the slot template
    as being called with an object containing all the data bound to the slot in the
    child component. Hence, these slots are referred to as `scoped`; they are passed
    through a `scope` object, as defined by the child component.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在消费者端（父组件），我们可以将槽模板视为带有所有绑定到子组件槽中的数据的对象被调用。因此，这些槽被称为 `scoped`；它们通过子组件定义的 `scope`
    对象传递。
- en: 'In this case, we can consume `PaginatedList` as follows:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以这样消费 `PaginatedList`：
- en: '[PRE69]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '`#default="{ item }"` is the shorthand notation for the default scoped slot
    and allows us to destructure the slot''s scope into `item`.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`#default="{ item }"` 是默认作用域插槽的简写表示法，允许我们将槽的作用域解构为 `item`。'
- en: 'The longhand version of the slot''s template definition is as follows:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 槽的模板定义的长版本如下：
- en: '[PRE70]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '`item` is then used to render `{{ item.content }}`. The `script` section (with
    snacks to render) will be as follows:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`item`随后用于渲染`{{ item.content }}`。带有要渲染的零食的`script`部分如下：'
- en: '[PRE71]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We get the following output in the browser:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，我们得到以下输出：
- en: '![Figure 4.20: Snacks displayed using a scoped slot, meaning the rendering
    logic is in the parent component'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.20：使用作用域插槽显示的零食，意味着渲染逻辑在父组件中](img/B15218_04_20.jpg)'
- en: '](img/B15218_04_20.jpg)'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_04_20.jpg)'
- en: 'Figure 4.20: Snacks displayed using a scoped slot, meaning the rendering logic
    is in the parent component'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.20：使用作用域插槽显示的零食，意味着渲染逻辑在父组件中
- en: With that, we have learned how scoped slots give components increased flexibility
    to delegate templating logic to consumers.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经学会了作用域插槽如何使组件具有更大的灵活性，可以将模板逻辑委托给消费者。
- en: Note
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Scoped slots also have a deprecated (as of Vue.js 2.6.0+) `slot-scope` syntax.
    The deprecated equivalent of `v-slot:name="slotProps"` would be `slot="name" slot-scope="slotProps"`.
    For more information, see the Vue.js documentation: [https://vuejs.org/v2/guide/components-slots.html#Scoped-Slots-with-the-slot-scope-Attribute](https://vuejs.org/v2/guide/components-slots.html#Scoped-Slots-with-the-slot-scope-Attribute).'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 作用域插槽还有一个已弃用的（自Vue.js 2.6.0+起）`slot-scope`语法。`v-slot:name="slotProps"`的弃用等效语法是`slot="name"
    slot-scope="slotProps"`。有关更多信息，请参阅Vue.js文档：[https://vuejs.org/v2/guide/components-slots.html#Scoped-Slots-with-the-slot-scope-Attribute](https://vuejs.org/v2/guide/components-slots.html#Scoped-Slots-with-the-slot-scope-Attribute)。
- en: Now, let's learn how to implement a card component with the help of these named slots.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何借助这些命名插槽实现卡片组件。
- en: 'Exercise 4.04: Implementing a Card Component Using Named Slots'
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 4.04：使用命名插槽实现卡片组件
- en: In this exercise, we will implement a card component using named slots. The
    card will have a title, image, and description sections. We will use slots to
    allow `title`, `image`, and `description` to be defined by a parent component.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用命名插槽实现一个卡片组件。卡片将包含标题、图片和描述部分。我们将使用插槽允许父组件定义`title`、`image`和`description`。
- en: To access the code files for this exercise, refer to [https://packt.live/2UhLxlK](https://packt.live/2UhLxlK).
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅[https://packt.live/2UhLxlK](https://packt.live/2UhLxlK)。
- en: 'Follow these steps to complete this exercise:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此练习：
- en: 'We will start by creating a new `src/components/Card.vue` component that has
    a template that supports three slots – `title`, `image`, and `description`:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先创建一个新的`src/components/Card.vue`组件，该组件有一个支持三个插槽的模板——`title`、`image`和`description`：
- en: '[PRE72]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We will then import our `Card.vue` component into the `script` section of a
    new `src/App.vue` file:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将`Card.vue`组件导入到新`src/App.vue`文件的`script`部分：
- en: '[PRE73]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We can now use `Card` in our `template`:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以在`template`中使用`Card`：
- en: '[PRE74]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now, we can fire up the `vue-cli dev` server using `npm run serve` and see
    the `Card` component in action. The output will be as follows:'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`npm run serve`启动`vue-cli dev`服务器，并查看`Card`组件的实际效果。输出将如下所示：
- en: '![Figure 4.21: Card component with image, title, and description'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 4.21：带有图片、标题和描述的卡片组件](img/B15218_04_21.jpg)'
- en: '](img/B15218_04_21.jpg)'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_04_21.jpg)'
- en: 'Figure 4.21: Card component with image, title, and description'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.21：带有图片、标题和描述的卡片组件
- en: With that, we have learned how different types of slots can help to create more
    generic components. Slots allow child components to defer the rendering of certain
    parts of themselves to their parent component (`consumer`).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经学会了不同类型的插槽如何帮助创建更通用的组件。插槽允许子组件将自身某些部分的渲染推迟到父组件（消费者）。
- en: To reuse functionality within a single template, we can use filters. We'll learn
    how to use them in the next section.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 要在单个模板中重用功能，我们可以使用过滤器。我们将在下一节学习如何使用它们。
- en: Template Logic Sharing with Filters
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用过滤器共享模板逻辑
- en: To share template logic, Vue.js has **filters**.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js使用**过滤器**来共享模板逻辑。
- en: Filters can be used in mustache interpolations (`{{ interpolatingSomething }}`)
    or in expressions (for example, when binding a value). `filter` is a function
    that takes a value and outputs something that can be rendered (usually a `String`
    or a `Number`).
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器可以在mustache插值（`{{ interpolatingSomething }}`）或表达式中使用（例如，在绑定值时）。`filter`是一个函数，它接受一个值并输出可以渲染的内容（通常是`String`或`Number`）。
- en: 'So, an example filter called `truncate` would be used in a template as follows
    (here, we have put some long placeholder text):'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个名为`truncate`的示例过滤器可以在模板中使用，如下所示（这里我们放置了一些长占位文本）：
- en: '[PRE75]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '`truncate` could also be used in a Vue.js bind expression. For example, `<MessageComponent
    :msg="message | truncate">` would bind the truncated output of `message` to `msg`.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '`truncate`也可以在Vue.js绑定表达式中使用。例如，`<MessageComponent :msg="message | truncate">`将`message`的截断输出绑定到`msg`。'
- en: To define the `truncate` filter, we can define it in a component's `filters`
    property in the `script` section.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义`truncate`过滤器，我们可以在组件的`script`部分的`filters`属性中定义它。
- en: '`truncate` filter will truncate the text down to `120` characters:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '`truncate`过滤器将文本截断到`120`个字符：'
- en: '[PRE76]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Without the truncation filter, we get `446` characters of *lorem ipsum*, as
    follows:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 没有截断过滤器，我们得到`446`个字符的*Lorem ipsum*，如下所示：
- en: '![Figure 4.22: Lorem ipsum without truncation'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.22：未截断的Lorem ipsum]'
- en: '](img/B15218_04_22.jpg)'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15218_04_22.jpg]'
- en: 'Figure 4.22: Lorem ipsum without truncation'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.22：未截断的Lorem ipsum
- en: 'With the `truncate` filter, we are down to `120` characters, as shown in the
    following screenshot:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`truncate`过滤器，我们减少到`120`个字符，如下所示 截图：
- en: '![Figure 4.23: Lorem ipsum with the truncate filter'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.23：使用`truncate`过滤器的Lorem ipsum]'
- en: '](img/B15218_04_23.jpg)'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15218_04_23.jpg]'
- en: 'Figure 4.23: Lorem ipsum with the truncate filter'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.23：使用`truncate`过滤器的Lorem ipsum
- en: 'The more defensive way to write this `truncate` filter would be to do an early
    return if `val` is false, then `toString` it (this will convert numbers into strings,
    for example) before doing the output of `.slice`:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 编写这个`truncate`过滤器的更防御性的方式是，如果`val`为假，则提前返回，然后`toString`它（这将把数字转换为字符串，例如）然后再进行`.slice`的输出：
- en: '[PRE77]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: With that, we have learned how to register and implement Vue.js filters for
    a component. We have also learned how to use filters in the component's template
    with the interpolation expression's pipe syntax.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经学会了如何为组件注册和实现Vue.js过滤器。我们还学会了如何在组件的模板中使用管道语法在插值表达式中使用过滤器。
- en: In the following exercise, we will learn how to implement an ellipsis filter.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的练习中，我们将学习如何实现省略号过滤器。
- en: 'Exercise 4.05: Implementing an Ellipsis Filter'
  id: totrans-393
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.05：实现省略号过滤器
- en: Filters are excellent for repeated text processing tasks. In this exercise,
    we will implement an `ellipsis` filter that works as follows.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器非常适合重复的文本处理任务。在这个练习中，我们将实现一个按如下方式工作的`ellipsis`过滤器。
- en: If the passed text is more than `14` characters, it should be truncated down
    to `11` characters and an ellipsis (`…`) should be added to the end of the text.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传递的文本超过`14`个字符，则应将其截断到`11`个字符，并在文本末尾添加省略号（`…`）。
- en: When the passed text is empty or not a `String`, we should be quite permissive
    and either return nothing or convert it into a `String` before doing our processing.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 当传递的文本为空或不是`String`时，我们应该相当宽容，要么返回空值，要么在我们处理之前将其转换为`String`。
- en: To access the code files for this exercise, refer to [https://packt.live/2IsZyuv](https://packt.live/2IsZyuv).
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅[https://packt.live/2IsZyuv](https://packt.live/2IsZyuv)。
- en: 'Follow these steps to complete this exercise:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此练习：
- en: 'First, we need to set up the template so that it will pipe *a string less than
    14 characters*, *a string with 14 characters*, and *a string with more than 14
    characters* through `ellipsis` to check if it works as expected under all possible
    conditions (we''ll do this in `src/App.vue`, as per the standard Vue CLI setup).
    We should also pipe a number and an empty value (`null`) through `ellipsis`:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要设置模板，以便它将*少于14个字符的字符串*、*14个字符的字符串*和*多于14个字符的字符串*通过`ellipsis`传递，以检查在所有可能的条件下是否按预期工作（我们将按照标准的Vue
    CLI设置，在`src/App.vue`中这样做）。我们还应该将数字和一个空值（`null`）通过`ellipsis`传递：
- en: '[PRE78]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'At this stage, the application should just display the text in the console.
    There should be some warnings that the `ellipsis` filter has not defined, as shown
    in the following screenshot:'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个阶段，应用程序应该只显示控制台中的文本。应该有一些警告表明`ellipsis`过滤器尚未定义，如下所示截图：
- en: '![Figure 4.24: Application displaying unchanged text'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图4.24：显示未更改文本的应用程序]'
- en: '](img/B15218_04_24.jpg)'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15218_04_24.jpg]'
- en: 'Figure 4.24: Application displaying unchanged text'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.24：显示未更改文本的应用程序
- en: 'The following screenshot shows the warning:'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图显示了警告：
- en: '![Figure 4.25: Vue.js warning that the ellipsis filter is missing'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图4.25：Vue.js警告缺少省略号过滤器]'
- en: '](img/B15218_04_25.jpg)'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15218_04_25.jpg]'
- en: 'Figure 4.25: Vue.js warning that the ellipsis filter is missing'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图4.25：Vue.js警告缺少省略号过滤器]'
- en: 'Next, we will implement an initial version of the filter in the `script` section
    of the component. This will check the length of the passed value, truncate it
    to `11`, and add `…` if it is longer than `14` characters:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在组件的`script`部分实现过滤器的初始版本。这将检查传入值的长度，如果它超过14个字符，则将其截断到`11`并添加`…`：
- en: '[PRE79]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'At this stage, the component fails to render and Vue.js logs an error since
    `Cannot read property ''length'' of null`, as shown in the following screenshot:'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个阶段，组件无法渲染，Vue.js记录了一个错误，显示为`Cannot read property 'length' of null`，如下面的截图所示：
- en: '![Figure 4.26: null piped into the application'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图4.26：null被导入到应用中'
- en: '](img/B15218_04_26.jpg)'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_04_26.jpg)'
- en: 'Figure 4.26: null piped into the application'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.26：null被导入到应用中
- en: 'Next, we need to amend the `ellipsis` implementation so that it short-circuits
    when the passed value is `false` (to avoid the issue with `null`):'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要修改`ellipsis`实现，以便在传入的值为`false`时短路（以避免`null`的问题）：
- en: '[PRE80]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'We now have the `ellipsis` filter working; it works for all the test cases
    we have included. The output will be as follows:'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在有了`ellipsis`过滤器正在工作；它适用于我们包含的所有测试用例。输出将如下所示：
- en: '![Figure 4.27: Ellipsis filter working for given inputs'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图4.27：省略号过滤器对给定输入的工作情况'
- en: '](img/B15218_04_27.jpg)'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_04_27.jpg)'
- en: 'Figure 4.27: Ellipsis filter working for given inputs'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.27：省略号过滤器对给定输入的工作情况
- en: Filters are useful for sharing simple text processing logic in components. A
    filter is a Vue.js primitive that keeps templating and formatting concerns in
    the template, such as truncating content and adding an ellipsis.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器对于在组件中共享简单的文本处理逻辑很有用。过滤器是Vue.js的一个原始操作，它将模板和格式化关注点保留在模板中，例如截断内容和添加省略号。
- en: Vue.js provides an abstraction over the DOM Web API. However, when it becomes
    necessary to access the DOM directly, such as to integrate a DOM library, Vue.js
    provides a first-class way to do so with refs. We will learn about Vue.js references
    in the next section.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js在DOM Web API之上提供了一个抽象层。然而，当需要直接访问DOM时，例如集成DOM库，Vue.js通过refs提供了一种一等的方式来这样做。我们将在下一节学习Vue.js的refs。
- en: Vue.js refs
  id: totrans-423
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue.js refs
- en: In Vue.js, **refs** are references to DOM elements or other components. This
    occurs programmatically.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vue.js中，**refs**是对DOM元素或其他组件的引用。这是程序化发生的。
- en: A large use case for refs is direct DOM manipulation and integration with DOM-based
    libraries (that usually take a DOM node they should mount to).
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: Refs的一个大用途是直接DOM操作和与基于DOM的库（通常需要一个它们应该挂载到的DOM节点）的集成。
- en: 'Refs are defined using `ref="name"` on a native element or child component
    in the template. In the following instance, the input will be stored in a `theInput`
    ref:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: Refs在模板中的原生元素或子组件上使用`ref="name"`定义。在以下示例中，输入将被存储在`theInput` refs中：
- en: '[PRE81]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Refs can be accessed from the Vue.js component instance through `this.$refs[name]`.
    So, in the previous example, where we had a ref defined as `ref="theInput"`, we
    can access it through `this.$refs.theInput`.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: Refs可以通过Vue.js组件实例通过`this.$refs[name]`访问。因此，在前面的示例中，我们有一个定义为`ref="theInput"`的refs，我们可以通过`this.$refs.theInput`来访问它。
- en: 'To focus the input when a button is clicked, we could write the following:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 要在按钮点击时聚焦输入，我们可以编写以下代码：
- en: '[PRE82]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'When clicking the `Focus Input` button, the input will be focused, as shown
    in the following screenshot:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击“聚焦输入”按钮时，输入将被聚焦，如下面的截图所示：
- en: '![Figure 4.28: Input focused on a button click'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.28：按钮点击时聚焦输入'
- en: '](img/B15218_04_28.jpg)'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_04_28.jpg)'
- en: 'Figure 4.28: Input focused on a button click'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.28：按钮点击时聚焦输入
- en: With that, we have learned how to use `$refs` to abstract DOM manipulation logic
    in a Vue.js component. Where it makes sense to select a DOM node directly in Vue.js,
    it is recommended to use a `ref` instead of using the DOM selection API (`querySelector`/`querySelectorAll`).
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经学习了如何在Vue.js组件中使用`$refs`来抽象DOM操作逻辑。在Vue.js中直接选择DOM节点合理的地方，建议使用`ref`而不是使用DOM选择API（`querySelector`/`querySelectorAll`）。
- en: In the following exercise, we will learn how the `Countable` library helps increase
    the interactivity in a project.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下练习中，我们将学习`Countable`库如何帮助提高项目的交互性。
- en: 'Exercise 4.06: Wrapping Countable.js with Vue.js'
  id: totrans-437
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.06：使用Vue.js包装Countable.js
- en: '`Countable` is a library that, given an element (usually an HTML `textarea`
    or input), will add live counts of paragraphs, words, and characters. Live metrics
    on the text being captured can be quite useful to increase interactivity in a
    project where editing text is a core concern.'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '`Countable` 是一个库，给定一个元素（通常是 HTML `textarea` 或输入），将为段落、单词和字符添加实时计数。在捕获的文本上的实时度量可以非常有用，可以增加编辑文本为核心关注点的项目中交互性。'
- en: One of the large use cases for using refs in Vue.js is to be able to integrate
    with libraries that act directly on the DOM.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vue.js 中使用 refs 的一个大型用例是能够与直接作用于 DOM 的库集成。
- en: In this exercise, we will create a component with paragraph/word/character counting
    for content in a `textarea` by using `Countable.js` and Vue.js refs.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将通过使用 `Countable.js` 和 Vue.js refs 创建一个具有段落/单词/字符计数的 `textarea` 组件。
- en: To access the code files for this exercise, refer to [https://packt.live/36oOuGz](https://packt.live/36oOuGz).
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅 [https://packt.live/36oOuGz](https://packt.live/36oOuGz)。
- en: 'Follow these steps to complete this exercise:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此练习：
- en: Install `countable` from `npm`. We will run `npm install --save countable` here,
    which will add it to our dependencies
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `npm` 安装 `countable`。在这里，我们将运行 `npm install --save countable`，这将将其添加到我们的依赖项中
- en: 'Next, we will create a new `src/components/TextEditorWithCount.vue` component
    with a `textarea` that we will have a `ref` to:'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个新的 `src/components/TextEditorWithCount.vue` 组件，其中包含一个我们将有 `ref` 的
    `textarea`：
- en: '[PRE83]'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Next, we will import and render the component in `src/App.vue`:'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将导入并渲染 `src/App.vue` 中的组件：
- en: '[PRE84]'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The application renders a `textarea`, as follows:'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应用程序渲染了一个 `textarea`，如下所示：
- en: '![Figure 4.29: A bare textarea, as rendered by the application'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 4.29：应用程序渲染的裸文本区域]'
- en: '](img/B15218_04_29.jpg)'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B15218_04_29.jpg]'
- en: 'Figure 4.29: A bare textarea, as rendered by the application'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.29：应用程序渲染的裸文本区域
- en: 'We now need to integrate `Countable`. We will import it and initialize it with
    `this.$refs.textArea`. We will also store the counts on the instance as `this.count`:'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在需要集成 `Countable`。我们将导入它，并用 `this.$refs.textArea` 初始化它。我们还将把计数存储在实例上作为 `this.count`：
- en: '[PRE85]'
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'With a small update to the `template`, we can display the counts we care about:'
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过对 `template` 的小更新，我们可以显示我们关心的计数：
- en: '[PRE86]'
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Now, we can see the counts set to `0` when `textarea` is empty, as follows:'
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们可以看到当 `textarea` 为空时，计数设置为 `0`，如下所示：
- en: '![Figure 4.30: Textarea with counts set to 0 when empty'
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 4.30：当文本区域为空时，计数设置为 0]'
- en: '](img/B15218_04_30.jpg)'
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B15218_04_30.jpg]'
- en: 'Figure 4.30: Textarea with counts set to 0 when empty'
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.30：当文本区域为空时，计数设置为 0
- en: 'If we drop some *Lorem ipsum* into our `textarea`, the counts will update accordingly,
    as follows:'
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们在 `textarea` 中放入一些 *Lorem ipsum*，计数将相应更新，如下所示：
- en: '![Figure 4.31: Textarea with counts updated when filled'
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 4.31：当填充时更新的计数文本区域]'
- en: '](img/B15218_04_31.jpg)'
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B15218_04_31.jpg]'
- en: 'Figure 4.31: Textarea with counts updated when filled'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.31：当填充时更新的计数文本区域
- en: 'One last thing we need to do is remove the `Countable` event listener when
    the component is destroyed:'
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们最后需要做的一件事是在组件销毁时移除 `Countable` 事件监听器：
- en: '[PRE87]'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Note
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: We have achieved this with programmatic listeners, though we could have achieved
    the same with the `beforeDestroy` life cycle method.
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经通过程序性监听器实现了这一点，尽管我们也可以通过 `beforeDestroy` 生命周期方法实现相同的效果。
- en: This integration of a JavaScript/DOM library inside of Vue.js is a key application
    of Vue.js refs. Refs allow us to pick from the existing ecosystem of libraries
    and wrap or integrate them into a component.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vue.js 中将 JavaScript/DOM 库集成到应用中是 Vue.js refs 的关键应用。Refs 允许我们从现有的库生态系统中选择，并将它们包装或集成到组件中。
- en: Vue.js refs are useful for integrating DOM libraries or for accessing DOM APIs
    directly.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js refs 对于集成 DOM 库或直接访问 DOM API 非常有用。
- en: To round off our learning of component composition, we need to know how to pass
    data from child components to parent components.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束我们对组件组合的学习，我们需要知道如何从子组件向父组件传递数据。
- en: Vue.js Events for Child-Parent Communication
  id: totrans-471
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue.js 子父组件通信事件
- en: We have already seen that props are used to pass data from a parent component
    to a child component.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，props 用于从父组件传递数据到子组件。
- en: To pass data from a child component back to a parent component, Vue.js has custom events.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 要从子组件将数据传递回父组件，Vue.js 有自定义事件。
- en: In a component, an event can be emitted using the `$emit` instance method. It
    can be used from within the `script` section using `this.$emit('eventName', /*
    payload */)`, but it is also exposed within the `template` section as `$emit`.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件中，可以使用`$emit`实例方法来触发一个事件。它可以在`script`部分使用`this.$emit('eventName', /* payload
    */)`来使用，但也可以在`template`部分作为`$emit`暴露。
- en: 'Assuming we have got a reactive instance property, `this.message`, we could
    emit a `send` event with the `message` value in the `script` section using `this.$emit`.
    This could be the basis for a `MessageEditor` component:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个响应式实例属性`this.message`，我们可以在`script`部分使用`this.$emit`来发出一个带有`message`值的`send`事件。这可以作为一个`MessageEditor`组件的基础：
- en: '[PRE88]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'In the same scenario, we could trigger a `send` event from the `template` section:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 在相同的场景中，我们可以从`template`部分触发一个`send`事件：
- en: '[PRE89]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: From a parent component, we can use `v-on:event-name` or the shorthand `@event-name`.
    `event-name` must match the name passed to `$emit`; `eventName` and `event-name`
    are not equivalent.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 从父组件中，我们可以使用`v-on:event-name`或简写的`@event-name`。`event-name`必须与传递给`$emit`的名称匹配；`eventName`和`event-name`不等同。
- en: 'For example, a parent component would be how we listen to the `send` event
    using `@send` and save the event payload contained in the `$event` magic value.
    To use the event payload in a method call, we can use `@eventName="methodToCall($event)"`:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，父组件会是如何使用`@send`监听`send`事件并保存包含在`$event`魔法值中的事件负载。要在方法调用中使用事件负载，我们可以使用`@eventName="methodToCall($event)"`：
- en: '[PRE90]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Using the inline and method versions of `$emit` yields the same result. The
    full `MessageEditor` app should look as follows:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内联和方法版本的`$emit`会产生相同的结果。完整的`MessageEditor`应用应如下所示：
- en: '![Figure 4.32: Hello World! message being emitted from child-parent'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.32：Hello World！从子组件到父组件发出的消息]'
- en: '](img/B15218_04_32.jpg)'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15218_04_32.jpg](img/B15218_04_32.jpg)'
- en: 'Figure 4.32: Hello World! message being emitted from child-parent'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.32：Hello World！从子组件到父组件发出的消息
- en: Vue.js custom events support passing any JavaScript type as the payload. The
    event name, however, must be a `String`.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js自定义事件支持将任何JavaScript类型作为负载传递。然而，事件名称必须是一个`String`。
- en: Note
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Binding a listener to Vue.js custom events is very similar to binding to native
    events such as `click`.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 将监听器绑定到Vue.js自定义事件与绑定到原生事件（如`click`）非常相似。
- en: Now, let's complete an activity based on what we've learned about so far.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们根据我们迄今为止所学的内容完成一个活动。
- en: 'Activity 4.01: A Local Message View with Reusable Components'
  id: totrans-490
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动4.01：具有可重用组件的本地消息视图
- en: This activity aims to leverage components, props, events, and refs to render
    a **chat** interface where the user can add messages and they are displayed.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动旨在利用组件、属性、事件和refs来渲染一个**聊天**界面，用户可以添加消息，并且它们会被显示。
- en: 'Follow these steps to complete this activity:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此活动：
- en: Create a `MessageEditor` component (in `src/components/MessageEditor.vue`) that
    displays a `textarea` to the user.
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`MessageEditor`组件（在`src/components/MessageEditor.vue`），向用户显示一个`textarea`。
- en: Add a `message` reactive instance variable to `MessageEditor`, defaulted to
    `''`.
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`MessageEditor`添加一个`message`响应式实例变量，默认值为`''`。
- en: Listen to `change` events for `textarea` and set the value of `message` to the
    value of the content of `textarea` (it is exposed as the value of the event).
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 监听`textarea`的`change`事件，并将`message`的值设置为`textarea`内容（它作为事件的值暴露）。
- en: Add a `Send` button that, on `click`, emits a `send` event with `message` as
    the payload.
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`Send`按钮，当点击时，会发出一个带有`message`作为负载的`send`事件。
- en: Add a `main` `App` component to `src/App.vue` that renders `MessageEditor`.
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/App.vue`中添加一个`main` `App`组件，渲染`MessageEditor`。
- en: In `App`, listen to `send` events from `MessageEditor` and store each message
    in a `messages` reactive instance variable (`messages` is an array).
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`App`中监听来自`MessageEditor`的`send`事件，并将每条消息存储在`messages`响应式实例变量中（`messages`是一个数组）。
- en: Create a `MessageFeed` (in `src/components/MessageFeed.vue`) that has a required
    `messages` prop, which is an `Array`.
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`MessageFeed`（在`src/components/MessageFeed.vue`），它有一个必需的`messages`属性，它是一个数组。
- en: In `MessageFeed`, render each passed message from the `messages` prop in a paragraph
    (the `p` element).
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MessageFeed`中，将`messages`属性中传递的每条消息渲染为一个段落（`p`元素）。
- en: Import and render `MessageFeed` into `App`, binding the `messages` app instance
    variable as the `messages` prop of `MessageFeed`.
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MessageFeed`导入到`App`中，并将`messages`应用实例变量绑定为`MessageFeed`的`messages`属性。
- en: Improve `MessageEditor` so that the message is reset when it is sent. To do
    this, we will need to set `textarea.value` using a Vue.js ref and reset the `message`
    instance variable.
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 改进`MessageEditor`，以便在发送消息时重置消息。为此，我们需要使用Vue.js的ref设置`textarea.value`并重置`message`实例变量。
- en: Note
  id: totrans-503
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The easier way to reset `textarea` would have been to use `v-model="message"`
    in the first place instead of binding `@change` and manually syncing `textarea.value`
    to `message`.
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重置`textarea`的更简单的方法本来是直接使用`v-model="message"`，而不是绑定`@change`并手动同步`textarea.value`到`message`。
- en: 'The expected output is as follows:'
  id: totrans-505
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期的输出如下：
- en: '![Figure 4.33: Message app with Hello World! and Hello JavaScript sent'
  id: totrans-506
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 4.33：发送了Hello World!和Hello JavaScript的消息应用]'
- en: '](img/B15218_04_33.jpg)'
  id: totrans-507
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B15218_04_33.jpg]'
- en: 'Figure 4.33: Message app with Hello World! and Hello JavaScript sent'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.33：发送了Hello World!和Hello JavaScript的消息应用
- en: Note
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found via [this link](B15218_Solution_Final_SZ_ePub.xhtml#_idTextAnchor387).
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 该活动的解决方案可以通过[此链接](B15218_Solution_Final_SZ_ePub.xhtml#_idTextAnchor387)找到。
- en: Summary
  id: totrans-511
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Throughout this chapter, we have looked at Vue.js primitives that allow us to
    build components in such a way that they can be composed efficiently.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了Vue.js的基本功能，这些功能使我们能够以高效的方式构建组件。
- en: Props and slots are used to defer behavior within a component to whichever parent
    component is rendering them. Props, with their ability to be validated, are great
    for passing data into nested components. Slots are geared toward yielding control
    of rendering back to the parent component. Events enable child components to send
    data back to their parent, thus completing the parent-child communication cycle
    (props down, events up).
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: Props和slots用于将组件内的行为延迟到渲染它们的父组件。具有验证能力的Props非常适合将数据传递到嵌套组件中。slots旨在将渲染控制权交还给父组件。事件使子组件能够将数据发送回父组件，从而完成父子通信周期（props向下，events向上）。
- en: Global templating helpers can be encapsulated in filters to reduce boilerplate
    and increase code reuse. Refs unlock integration opportunities with third-party
    JavaScript or DOM libraries by allowing us to access DOM elements directly.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 全局模板辅助函数可以被封装在过滤器中，以减少样板代码并增加代码复用。通过允许我们直接访问DOM元素，Refs可以解锁与第三方JavaScript或DOM库的集成机会。
- en: We're now able to compose and create components that clearly define their interfaces
    with inputs (props and slots) and outputs (rendered templates and events), while
    also visiting commonly faced use cases (wrapping a DOM library, abstracting templating
    concerns in a filter, and so on).
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在能够组合和创建组件，这些组件通过输入（props和slots）和输出（渲染模板和事件）清楚地定义了它们的接口，同时访问常见的用例（包装DOM库、在过滤器中抽象模板关注点等）。
- en: In the next chapter, we'll look at advanced component composition patterns and
    techniques that enable better code reuse.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨高级组件组合模式和技巧，这些模式和技巧能够实现更好的代码复用。
