- en: Chapter 8. Infinite Scrolling with jQuery
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章。使用 jQuery 进行无限滚动
- en: Infinite scrolling is a technique employed by a lot of popular sites that minimizes
    the amount of data loaded on a page initially, and then incrementally loads more
    data when the user has scrolled to the bottom of the page. You can see this effect
    on the Facebook or Twitter timelines among others.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 无限滚动是许多热门网站采用的一种技术，它最小化了页面最初加载的数据量，然后在用户滚动到页面底部时逐步加载更多数据。你可以在 Facebook 或 Twitter
    的时间线上看到这种效果，等等。
- en: Mission Briefing
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务简报
- en: In this project we'll build an infinite scrolling system using jQuery that mimics
    the effect seen on sites such as those mentioned earlier. We'll make a request
    for some data and display it on the page. Once the user has scrolled to the bottom
    of the page, we'll make another request for the next page of data, and so on and
    so forth as the user continues scrolling.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本项目中，我们将使用 jQuery 构建一个无限滚动系统，模仿前述网站上看到的效果。我们将请求一些数据并在页面上显示它。一旦用户滚动到页面底部，我们将请求下一页的数据，依此类推，直到用户继续滚动。
- en: 'Once we''ve built our infinite scrolling system, we should end up with something
    similar to the following screenshot:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们建立了无限滚动系统，我们应该得到类似以下截图的结果：
- en: '![Mission Briefing](img/9106OS_08_01.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![任务简报](img/9106OS_08_01.jpg)'
- en: Why Is It Awesome?
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么很棒？
- en: If you have a lot of data to display and it can easily be arranged in reverse-chronological
    order, using the infinite scrolling technique is an easy way to maximize the user
    experience of the page with progressive disclosure – showing incrementally more
    to the user.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有大量数据要显示，并且它可以轻松按照时间顺序排列，那么使用无限滚动技术是最大程度地提高页面用户体验的简单方法，通过渐进式披露向用户逐渐展示更多内容。
- en: A small subset of the data, which will make the page load quicker, as well as
    prevent your visitor being overwhelmed with data, can be displayed at first, which
    gradually increases following user interaction.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 首先可以显示一小部分数据，这样可以加快页面加载速度，同时防止您的访问者被大量数据所压倒，随着用户交互逐渐增加。
- en: The data that we'll consume in this project will be a list of videos uploaded
    to the TEDTalks channel on YouTube, in JSON format.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目将要消费的数据是 YouTube 上 TEDTalks 频道上传的视频列表，以 JSON 格式提供。
- en: Note
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember, JSON is a lightweight, text-based data format perfect for transportation
    across networks. For more information on JSON, see [http://www.json.org/](http://www.json.org/).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，JSON 是一种轻量级的基于文本的数据格式，非常适合在网络上进行传输。有关 JSON 的更多信息，请参阅 [http://www.json.org/](http://www.json.org/)。
- en: There are thousands of videos that can be found on this channel, so it makes
    a good test bed for our project. Data that can be sorted into a time-based order
    makes a great basis for an infinite scroller.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在该频道上可以找到数千个视频，因此它是我们项目的一个很好的测试基础。按时间顺序排序的数据是一个无限滚动的绝佳基础。
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The TEDTalks channel can be viewed directly on the YouTube website at [http://www.youtube.com/user/tedtalksdirector](http://www.youtube.com/user/tedtalksdirector).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: TEDTalks 频道可以直接在 YouTube 网站上查看，网址是 [http://www.youtube.com/user/tedtalksdirector](http://www.youtube.com/user/tedtalksdirector)。
- en: Your Hotshot Objectives
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 您的热门目标
- en: 'This project will be broken down into the following tasks:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目将分解为以下任务：
- en: Preparing the underlying page
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备基础页面
- en: Getting the initial feeds
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取初始供稿
- en: Displaying the initial set of results
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示初始结果集
- en: Handling scrolling to the bottom of the page
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理滚动到页面底部
- en: Mission Checklist
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务清单
- en: We can link to the hosted version of JsRender like we did in some of our previous
    examples, but in this project we're going to make use of a handy little jQuery
    plugin called imagesLoaded, which allows us to fire a callback function when all
    the images with a selected container have finished loading.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像在之前的一些示例中那样链接到 JsRender 的托管版本，但在这个项目中，我们将使用一个称为 imagesLoaded 的便捷小型 jQuery
    插件，它允许我们在所选容器中的所有图像加载完成时触发回调函数。
- en: The imagesLoaded plugin can be downloaded from [https://github.com/desandro/imagesloaded](https://github.com/desandro/imagesloaded)
    and should be saved in our project's `js` directory.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: imagesLoaded 插件可以从 [https://github.com/desandro/imagesloaded](https://github.com/desandro/imagesloaded)
    下载，并应保存在我们项目的 `js` 目录中。
- en: Preparing the underlying page
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备基础页面
- en: In this task we'll set up the files that we're going to use throughout this
    project and prepare the underlying page that our infinite scroller will reside
    on.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在此任务中，我们将设置我们在整个项目中要使用的文件，并准备我们的无限滚动页面的基础。
- en: Prepare for Lift Off
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备起飞
- en: As usual we'll be using a custom style sheet for this project and a custom script
    file, so let's add them first. Create a new JavaScript file called `infinite-scroller.js`
    and save it in the `js` directory. Then create a new style sheet called `infinite-scoller.css`
    and save it in the `css` directory. Lastly, save a copy of the `template.html`
    file in the root project folder and call it `infinite-scroller.html`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们将为此项目使用自定义样式表和自定义脚本文件，所以让我们首先添加它们。创建一个名为`infinite-scroller.js`的新 JavaScript
    文件，并将其保存在`js`目录中。然后创建一个名为`infinite-scoller.css`的新样式表，并将其保存在`css`目录中。最后，将`template.html`文件的副本保存在根项目文件夹中，并将其命名为`infinite-scroller.html`。
- en: Engage Thrusters
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: The underlying markup used by the example page will be minimal – a lot of the
    elements that we'll be working with will be generated dynamically by our template,
    which we can also add in this task.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 示例页面使用的底层标记将是最小的 - 我们将使用的许多元素将由我们的模板动态生成，我们也可以在此任务中添加它们。
- en: 'First of all we should add references to our new files to the HTML page. Start
    by adding a `<link>` element for the style sheet to the `<head>` of `infinite-scroller.html`,
    directly after the link to `common.css`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该将对新文件的引用添加到 HTML 页面中。首先，在`infinite-scroller.html`的`<head>`中，直接在对`common.css`的链接之后添加一个`<link>`元素：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next we can link to the two new JavaScript files. Add the following `<script>`
    elements directly after jQuery:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以链接到两个新的 JavaScript 文件。在 jQuery 之后直接添加以下`<script>`元素：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We also need to add a simple container to render our data into. Add the following
    code to the `<body>` of the page:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要添加一个简单的容器来渲染我们的数据。将以下代码添加到页面的`<body>`中：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now we can add the templates we'll use. In this project we'll use two templates
    – one to render the outer container and user data, which will be rendered once,
    and one to render the list of videos, which we can use repeatedly as required.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以添加我们将要使用的模板了。在这个项目中，我们将使用两个模板 - 一个用于呈现外部容器和用户数据，它将被呈现一次，另一个用于呈现视频列表，我们可以根据需要重复使用。
- en: 'As before, they will sit inside the `<script>` elements in the `<body>` of
    the page. Before the existing `<script>` elements, add following new templates:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，它们将位于页面`<body>`中的`<script>`元素内。在现有的`<script>`元素之前，添加以下新模板：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now for the video template:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在轮到视频模板了：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can also add the styling for these elements now as well. In `infinite-scroller.css`,
    add the following selectors and rules:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们也可以为这些元素添加样式了。在`infinite-scroller.css`中，添加以下选择器和规则：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `ajax-loader.gif` image used in this project can be found in the accompanying
    code download for this book.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此项目中使用的`ajax-loader.gif`图像可以在本书的附带代码下载中找到。
- en: Objective Complete - Mini Debriefing
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 小结
- en: So practically the entire page is built from the templates we added to the `<body>`
    of the page, except for an empty `<div>` that will give us a container to render
    the data into. The template contains the markup used not just for the list of
    videos, but also information about the user whose videos we're displaying.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，实际上整个页面都是由我们添加到页面`<body>`中的模板构建的，除了一个空的`<div>`，它将为我们提供一个容器来渲染数据。该模板包含了用于视频列表的标记，以及用于显示视频作者信息的标记。
- en: In the first template, the outer container for the data is a `<section>` element.
    Within this is a `<header>` which displays information about the user, including
    his/her profile picture, name, and bio.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个模板中，数据的外部容器是一个`<section>`元素。在其中是一个`<header>`，显示有关用户的信息，包括他/她的个人资料图片、姓名和简介。
- en: The actual bio returned by YouTube for a specified user can be quite long, so
    we'll use the JavaScript `substring()` function to return a shortened version
    of this summary. This function is passed two arguments; the first is the character
    to start copying from and the second is the character to end on.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: YouTube 返回的实际简介可能相当长，因此我们将使用 JavaScript 的`substring()`函数返回此摘要的缩短版本。该函数传递两个参数；第一个是从哪个字符开始复制，第二个是结束字符。
- en: In the second template the actual list of videos will be displayed in the`<ul>`
    element added in the first template, with each video occupying an `<li>`. Within
    each `<li>`, we have an `<article>` element, which is an appropriate container
    for an independent unit of content.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个模板中，实际的视频列表将显示在第一个模板中添加的`<ul>`元素中，每个视频占据一个`<li>`。在每个`<li>`内，我们有一个`<article>`元素，这是一个适当的独立内容单元的容器。
- en: Within the `<article>`, we have a `<header>` containing some of the key information
    about the video such as its title and a thumbnail. Following the `<header>`we
    display a short summary of the video in a `<p>`, element. We also use our shortening
    helper function `Truncate()`, starting at character 12.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<article>`中，我们有一个包含视频的一些关键信息的`<header>`，如标题和缩略图。在`<header>`之后，我们显示视频的简短摘要在`<p>`元素中。我们还使用我们的缩短帮助函数`Truncate()`，从第12个字符开始。
- en: Lastly we display some meta-information about the video such as the number of
    plays, the number of likes, and the video's duration, using a `<dl>`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`<dl>`显示关于视频的一些元信息，例如播放次数、点赞次数和视频的持续时间。
- en: We use another helper function to display the duration in the video, `FormatTime()`.
    YouTube returns the length of the video in seconds, so we can convert this into
    a nicely formatted time string instead.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用另一个辅助函数来显示视频中的持续时间，`FormatTime()`。YouTube 返回视频的长度（以秒为单位），所以我们可以将其转换为一个格式良好的时间字符串。
- en: We used the `>` character to HTML-encode any data we insert into the page. It's
    always best to do this as a security measure.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`>`字符来 HTML 编码我们插入到页面中的任何数据。这样做是为了安全考虑，始终是最佳选择。
- en: The CSS that was added was purely presentational; merely used to lay out the
    page in a list format, and make it look slightly interesting and presentable.
    Feel free to change any aspect of how the layout is styled, or the elements are
    themed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 添加的 CSS 纯粹是用于表现的；仅用于以列表格式布局页面，并使其看起来略有趣味和可呈现。请随意更改布局样式的任何方面，或者元素的主题。
- en: Classified Intel
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 机密情报
- en: The SEO-conscious among you will realize that a page that is built almost entirely
    from AJAX delivered content is unlikely to be well placed in search results. Traditionally,
    this would almost certainly have been true, but now we can use the awesome `pushState()`
    method of the HTML History API to deliver a dynamic website that is completely
    indexable by search engines.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你们中注重 SEO 的人会意识到，一个几乎完全由 AJAX 传递的内容构建的页面不太可能在搜索结果中得到很好的位置。传统上，这几乎肯定是正确的，但现在我们可以使用
    HTML History API 中令人惊叹的`pushState()`方法来提供一个完全可由搜索引擎索引的动态网站。
- en: A complete description of `pushState()`is beyond the scope of this book, but
    there are plenty of great examples and tutorials out there. Considered by many
    to be the definitive guide to the History API is the documentation on Mozilla's
    Developer Network, which includes a section on `pushState()`. You can see the
    documentation at [https://developer.mozilla.org/en-US/docs/DOM/Manipulating_the_browser_history](https://developer.mozilla.org/en-US/docs/DOM/Manipulating_the_browser_history).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`pushState()`的完整描述超出了本书的范围，但有很多很好的示例和教程。被许多人认为是 History API 的权威指南的是 Mozilla
    开发者网络上关于`pushState()`的文档，其中包括关于`pushState()`的部分。你可以在 [https://developer.mozilla.org/en-US/docs/DOM/Manipulating_the_browser_history](https://developer.mozilla.org/en-US/docs/DOM/Manipulating_the_browser_history)
    上查看文档。'
- en: Getting the initial feeds
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取初始饲料
- en: In this task we'll focus on getting the initial set of data in order to create
    the page when it first loads. We need to write our code so that the function for
    getting the first page of data is reusable for any page of data so that we can
    make use of it later on in the project.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们将专注于获取初始数据集，以便在页面首次加载时创建页面。我们需要编写我们的代码，使得获取第一页数据的函数对于任何数据页都是可重用的，以便我们稍后在项目中可以使用它。
- en: Prepare for Lift Off
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备起飞
- en: 'We can use the standard `document ready` shortcut provided by jQuery, just
    like we have in a number of previous projects. We can get ready by adding the
    following code to the `infinite-scroller.js` file that we create earlier:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 jQuery 提供的标准`document ready`快捷方式，就像我们在许多之前的项目中所做的那样。我们可以通过将以下代码添加到我们之前创建的`infinite-scroller.js`文件中来做好准备：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Engage Thrusters
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'First of all we can add the code that retrieves the data from YouTube. Replace
    the comment in the preceding snippet of code with the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以添加从 YouTube 检索数据的代码。用以下内容替换前面代码段中的注释：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next we need to process the response a little. We can use the following code
    to execute a callback function once both of the AJAX requests have completed,
    which should be added directly after the code we added a moment ago:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要稍微处理一下响应。我们可以使用以下代码，在我们之前添加的代码之后直接添加，以执行回调函数，一旦两个 AJAX 请求都完成，就会执行该回调函数：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Objective Complete - Mini Debriefing
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 迷你总结
- en: We started out by defining a couple of variables. The first is an empty object
    that we'll populate with the results of our AJAX requests. The second is an integer
    that represents the index number of the first video we wish to get. YouTube videos
    are not zero-based like regular JavaScript arrays, so we initially define the
    variable with a value of `1`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义了几个变量。第一个是一个空对象，我们将用我们的 AJAX 请求的结果填充它。第二个是一个整数，表示我们希望获取的第一个视频的索引号。YouTube
    视频不像常规的 JavaScript 数组那样从零开始，所以我们最初将变量定义为`1`。
- en: Next we added our two functions that we'll use to get our data. The first is
    the request to get the profile data of the user whose feed we're going to be displaying.
    We're only going to be using this function once, when the page initially loads,
    but you'll see why it's important that we define the function as a variable in
    this way in just a moment.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加了我们将用于获取数据的两个函数。第一个是请求获取我们将要显示其 Feed 的用户的个人资料数据。我们只会在页面最初加载时使用此函数一次，但您将会看到为什么重要的是我们以这种方式将函数定义为变量。
- en: The second function will be reused, so storing it in a variable is a great way
    to store it ready to be invoked whenever we wish to get a new page of video data.
    It's important that these functions both return the `jqXHR` objects returned by
    the `getJSON()` method.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个函数将被重用，因此将其存储在一个变量中是一个很好的方法，可以随时调用它以获取新的视频数据页面。重要的是这两个函数都返回`getJSON()`方法返回的`jqXHR`对象。
- en: Both of the requests use jQuery's `getJSON()` method to make the requests. In
    the user request we only need to set the `v` and `alt` query parameters, which
    are set in the object passed to `getJSON()` as the second argument. The user whose
    profile data we want actually forms part of the URL we are making the request
    to.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个请求都使用 jQuery 的`getJSON()`方法进行请求。在用户请求中，我们只需要设置`v`和`alt`查询参数，这些参数设置在传递给`getJSON()`的第二个参数中的对象中。我们想要获取其个人资料数据的用户实际上是我们正在进行请求的
    URL 的一部分。
- en: The callback function for this request simply adds the contents of the `user.entry`
    object received from the request to the `userdata` property of our `data` object.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此请求的回调函数简单地将从请求接收到的`user.entry`对象的内容添加到我们的`data`对象的`userdata`属性中。
- en: The second request requires slightly more configuration. We still set the API
    version we want to use with the `v` parameter, but this time we set the format
    of the response to be `jsonc` instead of `json`. In the callback function for
    this request we store the array of videos in the `videodata` property of our `data`
    object.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个请求需要稍微更多的配置。我们仍然使用`v`参数设置我们要使用的 API 版本，但这次我们将响应格式设置为`jsonc`而不是`json`。在此请求的回调函数中，我们将视频数组存储在我们的`data`对象的`videodata`属性中。
- en: '**JSON-C** stands for json-in-script and is a format that Google can respond
    with for some requests. Data returned in JSON-C format is generally more lightweight
    and more efficient to process than the same response in JSON due to how Google''s
    API has been engineered.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSON-C** 代表 json-in-script，是 Google 可以针对某些请求进行响应的格式。以 JSON-C 格式返回的数据通常比以
    JSON 格式返回的相同响应更轻量级，更高效，这是由于 Google 的 API 已经进行了工程化。'
- en: The properties that we need to use are only returned when this format is used.
    The only reason we don't use it when requesting the user data is because there
    is not a JSON-C response for that particular query.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用这种格式时，我们需要使用的属性只有在返回时才会返回。我们在请求用户数据时不使用它的唯一原因是因为该特定查询没有 JSON-C 响应。
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: For more information on JSON-C responses from Google's APIs, see the documentation
    at [https://developers.google.com/youtube/2.0/developers_guide_jsonc](https://developers.google.com/youtube/2.0/developers_guide_jsonc).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有关从 Google 的 API 返回的 JSON-C 响应的更多信息，请参阅 [https://developers.google.com/youtube/2.0/developers_guide_jsonc](https://developers.google.com/youtube/2.0/developers_guide_jsonc)
    上的文档。
- en: Next we make use of jQuery's `when()`method to initiate both of our requests,
    and then use the `done()` method to execute a callback function once both of the
    `jqXHR` objects have been resolved. This is why it was important that the single-use
    `getUser()` function is structured in the same way as the reusable `getData()`
    function.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们使用 jQuery 的`when()`方法来启动我们的两个请求，然后使用`done()`方法在两个`jqXHR`对象都已解析后执行回调函数。这就是为什么单独使用的`getUser()`函数以与可重用的`getData()`函数相同的方式结构化很重要的原因。
- en: Inside the callback function for `done()`, we first increment the `startIndex`
    variable by 25 so that when we make another request we get the next "page" of
    25 videos. As we have the first page of data now, when we use the `getData()`
    function later on, we'll automatically get the "next" page of results.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在`done()`的回调函数内部，我们首先将`startIndex`变量增加25，这样当我们发出另一个请求时，我们就会获得下一个包含25个视频的“页面”。现在我们已经有了第一页的数据，当我们稍后使用`getData()`函数时，我们将自动获得“下一页”的结果。
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `when()` and `done()` methods are the preferred way of handling asynchronous
    operations since jQuery 1.5.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`when()`和`done()`方法是自jQuery 1.5以来处理异步操作的首选方法。'
- en: At this point we just need to do a little processing of our `userdata` object.
    There's a whole bunch of data we don't need to use, and some of the data we do
    need to use is buried within nested objects, so we simply create a new object
    called `clean` and set just the data we need on this object directly.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们只需要对我们的`userdata`对象进行一点处理。有一大堆我们不需要使用的数据，而我们需要使用的一些数据被埋在嵌套对象中，所以我们简单地创建一个名为`clean`的新对象，并直接在这个对象上设置我们需要的数据。
- en: Once this has been done we can save our clean object back to our `data` object,
    overwriting the original `userdata` object. This should make the object easier
    to process in our template.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成了这个操作，我们就可以将我们的干净对象保存回我们的`data`对象，覆盖原始的`userdata`对象。这样做可以使对象在我们的模板中更容易处理。
- en: Displaying the initial set of results
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示初始结果集
- en: Now that we have data being returned by YouTube's API, we can render our template.
    However, in order to render our template, we need to add helper functions used
    to format some of the data. In this task we can add those helper functions and
    then render the template.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经从YouTube的API返回数据，我们可以渲染我们的模板了。然而，为了渲染我们的模板，我们需要添加用于格式化部分数据的辅助函数。在此任务中，我们可以添加这些辅助函数，然后渲染模板。
- en: Engage Thrusters
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'The template helpers don''t need to reside within the `$.done()`callback function.
    We can add them directly before this code in `infinite-scroller.js`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 模板辅助函数不需要驻留在`$.done()`回调函数内部。我们可以直接在`infinite-scroller.js`中的此代码之前添加它们：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next we just need to register the helper functions. Directly after the previous
    code add the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们只需要注册这些辅助函数。在上一段代码后面直接添加以下内容：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Lastly we can render our template. We want a function that we can call from
    anywhere in our code, ready for when we make further requests later on. Add the
    following code after registering the helper functions:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以渲染我们的模板。我们希望一个可以从代码的任何位置调用的函数，以备将来进行进一步的请求。在注册辅助函数后添加以下代码：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now we just need to call this function at the end of our `$.done()` callback
    function:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要在我们的`$.done()`回调函数的末尾调用这个函数：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Objective Complete - Mini Debriefing
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 小结
- en: Our first helper function, `truncate()` is ultra-simple. We simply return a
    shortened version of the string that the function receives as an argument. The
    `substring()` function takes two arguments; the first is the position in the string
    to begin copying at, and the second argument is the number of characters to copy,
    which we fix at `200`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '我们的第一个辅助函数，`truncate()`非常简单。我们只是返回该函数作为参数接收的字符串的缩短版本。`substring()`函数接受两个参数；第一个是在字符串中开始复制的位置，第二个参数是要复制的字符数，我们固定在`200`。  '
- en: To show that the string has been shortened, we also append an ellipsis to the
    end of the returned string, which is why we use a helper function here, instead
    of using a substring in the template directly as we did earlier.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示字符串已经被缩短，我们还在返回的字符串末尾附加了一个省略号，这就是我们在这里使用辅助函数的原因，而不是像之前直接在模板中使用子字符串一样。
- en: The `formatTime()` helper function is a little more complex, but still relatively
    straightforward. This function will receive a time in seconds, which we want to
    format into a slightly nicer string that shows the hours, if there are any, the
    minutes, and seconds.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`formatTime()`辅助函数稍微复杂一些，但仍然相对简单。这个函数将接收以秒为单位的时间，我们希望将其格式化为稍微漂亮一些的字符串，显示小时（如果有的话）、分钟和秒。'
- en: We first create an empty array to store the different components of the string.
    We then create a number of variables to hold the hours, minutes, and seconds portions
    of the time string we're going to create.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个空数组来存储字符串的不同组成部分。然后，我们创建一些变量来保存我们将要创建的时间字符串的小时、分钟和秒部分。
- en: The hours are calculated by dividing the total number of seconds by 3600 (the
    number of seconds in an hour). We use `Math.floor()`on it so that we only get
    a whole number result. We need to calculate the minutes slightly differently because
    we need to take into account the hours if there are any.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 小时数通过将总秒数除以3600（一小时的秒数）来计算。我们对其使用`Math.floor()`，以便只得到一个整数结果。我们需要稍微不同地计算分钟，因为我们需要考虑小时数。
- en: We use the modulus operator (`%`) here to remove any hours first and then divide
    the remainder by `60`, which will tell us either the total number of minutes or
    the remaining minutes after the hours have been accounted for. To work out the
    number of seconds, we just need to use the modulus operator again and the value
    `60`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们使用模数运算符（`%`）首先去除任何小时，然后将余数除以`60`，这将告诉我们总分钟数或在考虑小时后剩余的分钟数。要计算秒数，我们只需要再次使用模数运算符和值`60`。
- en: We then use a series of conditionals to determine which of the variables to
    add to the array. If there are any hours (which is unlikely given the nature of
    the videos) we push them into the array.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用一系列条件语句来确定要添加到数组中的变量。如果有任何小时数（这在视频的性质上是不太可能的），我们将它们推入数组中。
- en: If there are less than `10` minutes, we add `0` to the minutes figure and then
    push it into the array. If there are more than `10` minutes we just push the `mins`
    variable into the array. The same logic is applied to the `secs` variable before
    it is pushed into the array.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果分钟数少于`10`，我们在分钟数前添加`0`，然后将其推入数组中。如果分钟数超过`10`，我们只需将`mins`变量推入数组中。在将其推入数组之前，对`secs`变量应用相同的逻辑。
- en: This function returns a nicely formatted time by joining the items in our array
    and using a colon as the separator. The string will be in the format `H:MM:SS`
    or `MM:SS` depending on the length of the video. Then we registered the helper
    functions with the template using JsRender's `helpers` object, which is itself
    nested within the `views` object, which is added to jQuery by the templating library.
    The helper functions we wish to add are set as the values in an object literal,
    where the keys match the function calls in our template.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数通过将数组中的项目连接起来并使用冒号作为分隔符来返回一个格式良好的时间。字符串将以`H:MM:SS`或`MM:SS`的格式呈现，具体取决于视频的长度。然后，我们使用JsRender的`helpers`对象向模板注册辅助函数，该对象本身嵌套在由模板库添加到jQuery的`views`对象中。我们希望添加的辅助函数被设置为对象文字中的值，其中键与模板中的函数调用匹配。
- en: Next we added a function that we can call in order to render our template. The
    `renderer()` function takes a single argument, which is a Boolean specifying whether
    to render both the container template and video template, or just the video template.
    Inside the function we first cache a reference to the outer container of the video
    list.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加了一个函数，我们可以调用该函数来呈现我们的模板。`renderer()`函数接受一个布尔值参数，指定是否同时呈现容器模板和视频模板，或只呈现视频模板。在函数内部，我们首先缓存对视频列表的外部容器的引用。
- en: If the `renderOuter` argument has a truthy value (that is if it specifically
    holds the value `true`), we render the `containerTemplate` and append it to the
    empty `<div>` we added to the `<body>` of the page. We then render the `videoTemplate`,
    appending the rendered HTML to the `<ul>` that is added by the `containerTemplate`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`renderOuter`参数具有真值（也就是说，如果它具体保留了值`true`），我们就呈现`containerTemplate`并将其附加到页面的空`<div>`中。然后，我们呈现`videoTemplate`，将呈现的HTML附加到由`containerTemplate`添加的`<ul>`中。
- en: Lastly we called our `renderer()` function for the first time, passing `true`
    as the argument to render both the containers and the initial list of videos.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们第一次调用我们的`renderer()`函数，将`true`作为参数传递，以同时呈现容器和初始视频列表。
- en: Handling scrolling to the bottom of the page
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理滚动到页面底部
- en: Now that we've got the first page of videos, we want to add a handler that monitors
    the window for scroll events and detects when the page has been scrolled right
    to the bottom.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经得到了第一页的视频，我们想添加一个处理程序，监视窗口的滚动事件，并检测页面是否已经滚动到底部。
- en: Engage Thrusters
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'First of all we need to add a couple of new variables. Change the very first
    set of variables near the top of the file so that they appear as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要添加一些新的变量。修改文件顶部附近的第一组变量，使其显示如下：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now we need to update our `renderer()` function so that when the templates
    have been rendered we update the new `listHeight` variable. Add the following
    code after where we render the `videoTemplate`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要更新我们的`renderer()`函数，以便在模板被渲染后更新新的`listHeight`变量。在我们渲染`videoTemplate`后添加以下代码：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next we can add a handler for the scroll event. Directly after the `when()`
    method in `infinite-scroller.js`, add the following code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以为滚动事件添加一个处理程序。在`infinite-scroller.js`中的`when()`方法后面，添加以下代码：
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We''re using a spinner to show the user that more data is being retrieved.
    We need a few extra styles to handle the position of the spinner, so we can also
    add the following code to the bottom of our `infinite-scroller.css` style sheet:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用一个旋转器来向用户显示正在检索更多数据的信息。我们需要一些额外的样式来处理旋转器的位置，所以我们也可以将以下代码添加到我们的`infinite-scroller.css`样式表的底部：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Objective Complete - Mini Debriefing
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 迷你总结
- en: We attach a handler to the window using our cached `win` object and the `on()`
    method. The event type is specified as `scroll`. Inside the callback function
    we first check whether the current `scrollTop` property of the `window`, plus
    the `height` of the viewport is greater than or equal to the `height` of our `videolist`
    container. We need to do this to know when the page has been scrolled to the bottom.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用我们缓存的`win`对象和`on()`方法将处理程序附加到窗口。事件类型被指定为`scroll`。在回调函数内部，我们首先检查当前窗口的`scrollTop`属性加上视口的`height`是否大于或等于我们的`videolist`容器的`height`。我们需要这样做来知道页面何时滚动到底部。
- en: If the heights are equal, we create a temporary loader to provide visual feedback
    to the user that something is happening. We append a new `<li>` element to the
    `<ul>` containing the videos and give it a class name of `loading` so that we
    can easily target it with some CSS. We set a `<span>` element as the content of
    the new list item.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个高度相等，我们创建一个临时加载器，向用户提供视觉反馈，表明正在发生某些事情。我们将一个新的`<li>`元素附加到包含视频的`<ul>`中，并给它一个类名为`loading`，以便我们可以轻松地用一些CSS来定位它。我们将一个`<span>`元素设置为新列表项的内容。
- en: We can get the current value of the `scrollTop` property using jQuery's `scrollTop()`
    method. We're using a cached value for the window's `height`. Our scroll handler
    will be fairly intensive as it will be invoked every time the user scrolls, so
    using a cached value for the window `height` makes this process slightly more
    efficient.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用jQuery的`scrollTop()`方法获取`scrollTop`属性的当前值。我们正在使用窗口`height`的缓存值。我们的滚动处理程序将相当密集，因为它将在用户滚动时被调用，因此使用窗口`height`的缓存值会使这个过程稍微更有效率一些。
- en: It does mean however that if the window is resized, this value will no longer
    be accurate. We fix this by adding a resize handler for the window which recalculates
    this value every time the window is resized. This is done by chaining another
    call to the `on()`method after the scroll handler, which looks for the resize
    event of the `window` object and updates the `winHeight` variable accordingly.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 但这意味着如果窗口被调整大小，这个值将不再准确。我们通过为窗口添加一个调整大小处理程序来解决这个问题，每当窗口调整大小时重新计算这个值。这是通过在滚动处理程序之后链接另一个对`on()`方法的调用来完成的，该方法查找`window`对象的调整大小事件，并相应地更新`winHeight`变量。
- en: We then use jQuery's `when()` method once again, which invokes our `getData()`
    function to retrieve the next 25 videos. We also use the `done()` method again
    to execute a callback function once the request has completed.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们再次使用jQuery的`when()`方法，调用我们的`getData()`函数来检索下一个25个视频。我们还再次使用`done()`方法来在请求完成后执行回调函数。
- en: Within this callback function we increment our `startIndex` variable by `25`
    again, ready to request the next set of videos. The `getData()` function will
    populate our `data` object with the new video data so all we need to do is call
    our `renderer()` function to display the new videos, and then remove the temporary
    loader.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个回调函数中，我们再次将我们的`startIndex`变量增加`25`，准备请求下一组视频。`getData()`函数将填充我们的`data`对象，新的视频数据，所以我们只需调用我们的`renderer()`函数来显示新的视频，然后移除临时加载器。
- en: 'At this point we should have a fully functional infinite loader that loads
    more videos when the user scrolls to the bottom of the page. We should be able
    to run the page and see something like the following when we scroll to the bottom:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们应该有一个完全功能的无限加载器，当用户滚动到页面底部时加载更多视频。当我们滚动到底部时，我们应该能够运行页面并看到类似以下的内容：
- en: '![Objective Complete - Mini Debriefing](img/9106OS_08_02.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![目标完成 - 迷你总结](img/9106OS_08_02.jpg)'
- en: Mission Accomplished
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务完成
- en: A lot of the code we've written in this project has been concerned with getting
    the data we want to display. Actually adding the infinite scroll feature itself
    requires only a minimal amount of code – a single handler that watches for the
    scroll event and triggers a new request for more data when the document is scrolled
    to the bottom.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们编写的大部分代码都是关于获取我们想要显示的数据。实际上，添加无限滚动功能本身只需要一小部分代码 - 一个监视滚动事件并在文档滚动到底部时触发新数据请求的单个处理程序。
- en: As you can see this is a feature that would be easy to retrofit to existing
    functionality as an additional layer. This technique is best suited to data that
    can easily be arranged in reverse-chronological order, with new items appearing
    at the top and older items appearing at the bottom.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这是一个非常容易作为附加层来修改现有功能的功能。这种技术最适合能够轻松按时间顺序排列的数据，新项目出现在顶部，旧项目出现在底部。
- en: It's not necessarily a complete replacement for paged data, but certainly makes
    sense when dealing with things such as news stories, blog posts, tweets, or status
    updates. It works very well with social data.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不一定是分页数据的完全替代，但在处理诸如新闻故事、博客文章、推文或状态更新等内容时，肯定是有意义的。它与社交数据配合得非常好。
- en: You Ready To Go Gung HO? A Hotshot Challenge
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你准备好大干一场了吗？一个高手挑战。
- en: In this project we're simply providing links back to a full-screen video player
    for each video on the YouTube site. So when the visitor clicks on a video thumbnail
    or title, they'll be sent off to YouTube to actually watch the video.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们只是为每个 YouTube 视频提供了回到全屏视频播放器的链接。所以，当访问者点击视频缩略图或标题时，他们将被送到 YouTube 实际观看视频。
- en: While there's nothing inherently wrong in doing this, a much cooler thing to
    do would be to open up a lightbox containing a video player embedded in an `<iframe>`.
    This would let the visitor view the video without ever leaving your site. The
    response from YouTube for the videos contains a link that can be used as the `src`
    attribute of an `<iframe>`, so why not see if you can hook this up yourself?
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这样做并没有什么本质上的错，但更酷的做法是打开一个包含在`<iframe>`中嵌入的视频播放器的灯箱。这样访问者就可以在不离开您的网站的情况下观看视频。来自
    YouTube 视频的响应包含一个可以用作`<iframe>`的`src`属性的链接，那为什么不试试自己连接一下呢？
- en: You'll notice that if you scroll to the bottom of the page, but then carry on
    scrolling down immediately, the same set of videos are requested multiple times.
    As an alternative task, see if you can prevent this from happening by only requesting
    more data if there is not currently a request in progress.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，如果你滚动到页面底部，然后立即继续向下滚动，同一组视频将被多次请求。作为另一个任务，看看你是否可以通过仅在当前没有请求正在进行时才请求更多数据来防止这种情况发生。
- en: This should be very easy to set up and simply involves setting a flag when the
    request begins, and removing the flag when it ends. We can then only make requests
    if the flag is not set.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该非常容易设置，只需在请求开始时设置一个标志，结束时删除标志。然后，只有在标志未被设置时才能发出请求。
