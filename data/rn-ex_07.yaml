- en: Redux
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redux
- en: 'Now that we have had a chance to get our feet wet with React Native, it''s
    time to dive into some serious architecture. One of the things that you might
    have encountered with our previous apps is that our components ended up encapsulating
    a large amount of logic in them and that some files ran several hundred lines.
    In this chapter, we''re going to introduce a new architecture for our apps to
    reduce bloat in our components. In this chapter, we will do the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有机会尝试 React Native，是时候深入研究一些严肃的架构了。你可能会遇到我们之前应用程序的一些问题是，我们的组件最终封装了大量的逻辑，有些文件运行了数百行。在本章中，我们将介绍一种新的应用程序架构，以减少组件中的冗余。在本章中，我们将做以下几件事：
- en: Learn about Redux, the architecture that will help manage our React Native apps'
    state and data flow
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 Redux，该架构将帮助我们管理 React Native 应用程序的状态和数据流
- en: Install the dependencies for Redux in our application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的应用程序中安装 Redux 的依赖项
- en: Refactor `Tasks`, our to-do list app, to use Redux
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构 `Tasks`，我们的待办事项列表应用程序，以使用 Redux
- en: Introducing Redux
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Redux
- en: Redux is a very popular library that many developers use to help write their
    React applications. On its GitHub repo, Redux bills itself as *a predictable state
    container for JavaScript apps*. Rather than having each component manage its own
    independent state, Redux proposes that your entire React application is governed
    by one single state. This single state is then proliferated through each component
    and allows the majority of your app's logic to live in reusable functions.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Redux 是一个非常受欢迎的库，许多开发者使用它来帮助编写他们的 React 应用程序。在其 GitHub 仓库中，Redux 将自己定位为 *JavaScript
    应用的可预测状态容器*。而不是让每个组件管理自己的独立状态，Redux 建议整个 React 应用程序由一个单一的状态来管理。这个单一的状态随后通过每个组件传播，并允许大多数应用程序的逻辑存在于可重用的函数中。
- en: The three principles of Redux
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redux 的三个原则
- en: 'You can describe Redux by referring to three key principles regarding the state:
    it needs to be the single source of truth for your application, be read-only,
    and be modifiable only by pure functions.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过引用关于状态的三个关键原则来描述 Redux：它需要成为你应用程序的唯一真相来源，它是只读的，并且只能由纯函数修改。
- en: Single state tree
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单一状态树
- en: 'In Redux, rather than having each component manage its own state, we deal with
    one single-state tree that contains all the logic in our application. For example,
    for the `Tasks` app we built in the first two chapters, you can visualize it as
    follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Redux 中，而不是让每个组件管理自己的状态，我们处理一个包含我们应用程序中所有逻辑的单个状态树。例如，对于我们在前两章中构建的 `Tasks`
    应用程序，你可以将其可视化如下：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This helps make our app a lot easier to debug, since we're only dealing with
    one object tree when looking at the information it contains.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这有助于使我们的应用程序更容易调试，因为我们只处理一个对象树，当我们查看它包含的信息时。
- en: State is read-only
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态是只读的
- en: The application state should never be modified directly. Instead, it should
    only be modified as the result of actions being dispatched and reducers interacting
    with it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的状态永远不应该被直接修改。相反，它应该只作为动作分发和还原器与之交互的结果进行修改。
- en: Changes are made with pure functions
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用纯函数进行更改
- en: 'The idea of a pure function comes from functional programming, and can be summarized
    as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数的概念来自函数式编程，可以总结如下：
- en: Given the same arguments, a pure function always returns the same result
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定相同的参数，纯函数总是返回相同的结果
- en: Regardless of our application state, a pure function is able to execute
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论我们的应用状态如何，纯函数都能够执行
- en: Variables outside of a pure function's scope cannot be modified by it
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯函数作用域之外的外部变量不能被它修改
- en: 'These three principles correlate with three major parts of the Redux ecosystem:
    actions, reducers, and store.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个原则与 Redux 生态系统的三个主要部分相关联：actions（动作）、reducers（还原器）和 store（存储）。
- en: Actions are how we can indirectly modify our read-only state. Reducers are the
    pure functions that perform that modification. The single store in Redux is where
    our state exists.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Actions（动作）是我们间接修改只读状态的方式。Reducers（还原器）是执行这种修改的纯函数。Redux 中的单一 store（存储）是我们状态存在的地方。
- en: Actions
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Actions（动作）
- en: Actions are simple objects containing information that sends data from your
    app over to the app's store. All the logic that your app handles will pass through
    the action - your store never receives any data from sources that aren't actions.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Actions（动作）是包含信息的简单对象，它将数据从你的应用程序发送到应用程序的存储。你应用程序处理的所有逻辑都将通过动作传递 - 你的存储永远不会从不是动作的来源接收任何数据。
- en: 'An action requires a `type` property, which defines the type of user action
    that has occurred. Types of actions are represented in a stringified form. They
    can be hardcoded into the object itself or passed in as a constant. For example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一个动作需要一个`type`属性，它定义了已发生的用户动作的类型。动作类型以字符串形式表示。它们可以硬编码到对象本身中，或作为常量传入。例如：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These functions will be made available as props to all the components in your
    application and can be called at any time. When an action is called, the store
    then dispatches the action to every reducer in your application. Only the right
    reducer, chosen with conditional logic, will fire at this time, and will execute
    code that changes your application's state.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数将作为属性提供给你的应用程序中的所有组件，并且可以在任何时候调用。当调用一个动作时，商店会将该动作分发给应用程序中的每个减少器。只有正确选择的减少器，通过条件逻辑选择，此时才会触发，并执行更改应用程序状态的代码。
- en: Reducers
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少器
- en: In Vanilla JavaScript, there's an array prototype method called `reduce`. The
    purpose of this native reduce function is to return one single reduced value after
    running a callback and initial value through an entire array's contents.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯JavaScript中，有一个名为`reduce`的数组原型方法。这个本地减少函数的目的是在运行回调和初始值通过整个数组的所有内容后返回一个单一减少值。
- en: In Redux, a reducer is a function that takes in your application's state and
    relevant information passed to it from an action, and then returns one single
    reduced value for your application's state after executing the code.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在Redux中，减少器是一个函数，它接收你的应用程序状态以及从动作传递给它的相关信息，然后在执行代码后返回一个单一减少值作为你应用程序的状态。
- en: Reducers should, as a good practice, be restricted to one reducer per file,
    for clarity.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 作为良好实践，减少器应该限制在每个文件中只有一个，以保持清晰。
- en: 'There are two really important things we need to know about reducers with Redux:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Redux中的减少器，我们需要了解两个非常重要的事情：
- en: Your application state is never mutated. Instead, a copy is returned with any
    changed values.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序状态永远不会被修改。相反，返回一个带有任何更改值的副本。
- en: Since each reducer will fire when an action happens in order to decide if that
    action is relevant to it, we have to return the previous application state in
    the event that any unknown (to that specific reducer) actions are fired.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于每个减少器在动作发生时都会触发，以决定该动作是否与其相关，因此如果发生任何未知（对该特定减少器）的动作，我们必须返回前一个应用程序状态。
- en: 'Working from the preceding example, this is how a reducer would look for an
    `ADD_TASK` action:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的示例来看，这是一个`ADD_TASK`动作的减少器看起来：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Using ES6''s default arguments syntax to give us an empty array if a state
    does not exist, the `action` object is passed in from the action creator:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ES6的默认参数语法，如果状态不存在，则提供一个空数组，`action`对象由动作创建者传入：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Stores
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储
- en: 'A store is an object that brings actions and reducers together. It does the
    following things for us:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 商店是一个将动作和减少器结合在一起的对象。它为我们做以下事情：
- en: Contains the application state
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含应用程序状态
- en: Gives access to that state, via a method called `getState`
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过名为`getState`的方法提供对状态的访问
- en: Dispatches actions, which reducers then use to modify that state
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分发动作，然后减少器使用这些动作来修改该状态
- en: One thing to be aware of with Redux is that, in a given application, you will
    only ever have one store. In the event that we want to split our logic into multiple
    handlers, we'll actually split the reducers instead, through a method called **reducer
    composition** this is something we'll take a look at once we need it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Redux需要注意的一点是，在给定应用程序中，你将只有一个商店。如果我们想将逻辑拆分成多个处理程序，实际上我们会通过名为**减少器组合**的方法来拆分减少器，这是我们一旦需要就会查看的内容。
- en: 'Here''s how a sample store in Redux looks. Let''s assume we have the task reducer
    from before, and another one as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个Redux中示例商店的样貌。假设我们之前有任务减少器，还有一个如下所示：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'These are examples of actions:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是动作的示例：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'These are where we would have our reducers:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们放置减少器的地方：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Within a component, we can simply call an action within a component as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个组件内部，我们可以简单地按照以下方式调用一个动作：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: But wait, how do our components know that this action is available? Just where
    do we expose our props? We do it using a library called `React-Redux`, which contains
    two things we want to utilize.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 但是等等，我们的组件如何知道这个动作是可用的？我们究竟在哪里暴露属性？我们使用一个名为`React-Redux`的库来完成这个任务，它包含我们想要利用的两个东西。
- en: The first is the `connect` method, which connects our React Native application
    to the Redux store. The two arguments we're interested in passing to connect are
    `mapStateToProps` and `mapDispatchToProps`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是 `connect` 方法，它将我们的 React Native 应用程序连接到 Redux 存储。我们感兴趣传递给 `connect` 的两个参数是
    `mapStateToProps` 和 `mapDispatchToProps`。
- en: '`mapStateToProps`, if specified, is a function that subscribes to updates to
    the state tree. Any time the state tree updates, `mapStateToProps` will be called
    and merges its return value into your component''s props. The return value needs
    to be an object. Here''s a quick example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指定了 `mapStateToProps`，它是一个订阅状态树更新的函数。每当状态树更新时，`mapStateToProps` 都会被调用，并将它的返回值合并到组件的
    props 中。返回值需要是一个对象。下面是一个快速示例：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`mapDispatchToProps` will map our dispatch methods to our components'' props.
    As a function, we can call `bindActionCreators` to it and pass in our action creators,
    as well as a dispatch call, so they can be invoked directly. Here''s how it looks:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`mapDispatchToProps` 将我们的 dispatch 方法映射到组件的 props。作为一个函数，我们可以调用 `bindActionCreators`
    并传入我们的 action creators 以及一个 dispatch 调用，这样它们就可以直接被调用。下面是它的样子：'
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, assuming `Main` as the entry point for our app, we''ll use `connect`
    to bring them together:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，假设 `Main` 是我们应用程序的入口点，我们将使用 `connect` 将它们组合起来：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In order to propagate our store (and all of the actions and reducers associated
    with it), we''ll use the `Provider` from `React-Redux` to wrap our application
    and pass it our store as a prop. This allows the components in our React app to
    inherit these props naturally. It happens at the root level, as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了传播我们的存储（以及与之相关的所有 actions 和 reducers），我们将使用 `React-Redux` 的 `Provider` 来包装我们的应用程序，并将我们的存储作为
    props 传递给它。这允许我们的 React 应用程序中的组件自然地继承这些 props。它发生在根级别，如下所示：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is a good amount of setup, and, if you''re having some doubts about its
    effectiveness, I would urge you to power through the rest of this chapter: Redux
    is incredibly useful, because it''s going to let us write cleaner components that
    are a lot easier to maintain, and will help future contributors understand our
    code base better.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当多的设置，如果你对其有效性有所怀疑，我强烈建议你继续阅读本章的其余部分：Redux 非常有用，因为它将让我们编写更干净、更容易维护的组件，并有助于未来的贡献者更好地理解我们的代码库。
- en: Our next step is to install Redux, so let's get started.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步是安装 Redux，让我们开始吧。
- en: Installing Redux
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Redux
- en: 'We''ll use `npm` to install Redux. There are also a couple of dependencies
    it needs, and we''re going to install all of them at once. Make sure you''re at
    the root directory of your project folder, and do the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `npm` 来安装 Redux。它还需要一些依赖项，我们将一次性安装所有这些依赖项。确保你位于项目文件夹的根目录中，然后执行以下操作：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here''s a brief overview of the three packages we''re installing into our project:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们将要安装到项目中的三个包的简要概述：
- en: '`Redux`: This is the library itself.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Redux`：这是库本身。'
- en: '`React-Redux`: This is a library that provides bindings for React. Redux isn''t
    specifically tied to React, and this library will let us access the `Provider`
    component to pass down our props at the parent level with ease.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`React-Redux`：这是一个提供 React 绑定的库。Redux 并非专门绑定到 React，这个库将使我们能够轻松地访问 `Provider`
    组件，在父级传递我们的 props。'
- en: '`Redux-Thunk`: This is middleware that will help us make asynchronous calls
    with our actions, and is useful because we will be making calls to `AsyncStorage`.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Redux-Thunk`：这是一个中间件，它将帮助我们使用 actions 进行异步调用，并且由于我们将调用 `AsyncStorage`，因此它非常有用。'
- en: Now that we have the three packages installed, it's time to start setting up
    our architecture.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了这三个包，是时候开始设置我们的架构了。
- en: Redux architecture
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redux 架构
- en: 'The architecture of our application when using Redux will be slightly modified
    from what we had before. At present, this is how the `app` directory in our project
    looks:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 Redux 时，我们应用程序的架构将与之前略有不同。目前，我们的项目中的 `app` 目录看起来是这样的：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Redux requires us to think differently about how we approach our app''s architecture,
    and we''ll be adding some new folders into the `app` directory:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Redux 要求我们以不同的方式思考我们如何接近应用程序的架构，我们将在 `app` 目录中添加一些新的文件夹：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Containers in Redux
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redux 中的容器
- en: Containers are where we're going to map the dispatch methods and application
    state that connect to both the component and Redux. The `components` folder will
    still exist, but we are going to refactor what's inside to not rely on a component-based
    state.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是我们将要映射 dispatch 方法以及与应用程序状态连接的方法，这些方法连接到组件和 Redux。`components` 文件夹仍然存在，但我们将重构其中的内容，使其不依赖于基于组件的状态。
- en: From now on, every time we would usually render a component, we instead render
    its container.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，每次我们通常渲染一个组件时，我们都会渲染其容器。
- en: Remaining folder structure
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 剩余的文件夹结构
- en: The `reducers` folder is going to contain a single reducer file, which handles
    all the logic that modifies our application state.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`reducers`文件夹将包含一个单独的reducer文件，它处理所有修改我们应用程序状态的逻辑。'
- en: The `index.js` file found within the app folder will handle our Redux setup
    and be rendered by the root index files for both iOS and Android.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 应用文件夹中找到的`index.js`文件将处理我们的Redux设置，并由iOS和Android的根`index`文件渲染。
- en: 'What you''ll have at our root `index.ios.js` and `index.android.js` files are
    the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的根`index.ios.js`和`index.android.js`文件中，你将看到以下内容：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Planning the Redux conversion
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规划Redux转换
- en: 'The approach we will take in converting our app to Redux will involve multiple
    steps:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采取的将我们的应用转换为Redux的方法将涉及多个步骤：
- en: First, we should begin by scaffolding a Redux project by creating a store, wrapping
    the `AppContainer` around a `Provider`, and creating some basic actions and reducers
    to handle very basic functionality--we can worry about persistent storage later.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们应该开始搭建一个Redux项目，创建一个store，将`AppContainer`包裹在一个`Provider`中，并创建一些基本的操作和reducer来处理非常基本的功能--我们可以稍后考虑持久化存储。
- en: Then, we will begin converting the `TasksList` component to Redux by creating
    a `TasksListContainer` and mapping our actions and state tree to the `TasksList`
    component. Any other components from when we built `Tasks` in [Chapter 1](d99b3309-3285-4c98-accc-0a3785a8d3be.xhtml), *First
    Project - Creating a Basic To-Do List App*, and [Chapter 2](ca59eac5-a24f-4ac1-8b42-f1c28d149d74.xhtml),
    *Advanced Functionality and Styling the To-Do List App*, will remain untouched
    for the time being.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将开始将`TasksList`组件转换为Redux，通过创建`TasksListContainer`并将我们的操作和状态树映射到`TasksList`组件。在我们[第1章](d99b3309-3285-4c98-accc-0a3785a8d3be.xhtml)，“第一个项目
    - 创建基本待办事项应用”和[第2章](ca59eac5-a24f-4ac1-8b42-f1c28d149d74.xhtml)，“高级功能与美化待办事项应用”中构建的`Tasks`组件的其他组件将暂时保持不变。
- en: Afterwards, we will modify the `TasksList` component to take advantage of its
    container by removing all component-unspecific logic from it.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们将修改`TasksList`组件，利用其容器，通过从中移除所有组件无关的逻辑来实现。
- en: We will repeat this series of steps for the `EditTask` component.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将对`EditTask`组件重复这一系列步骤。
- en: Finally, we should address the asynchronous calls to the `AsyncStorage` API.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们应该解决对`AsyncStorage` API的异步调用问题。
- en: Along the way, we should take every opportunity to make changes to the Android
    version of `Tasks` to convert it to a Redux architecture.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在旅途中，我们应该抓住每一个机会对`Tasks`的Android版本进行修改，将其转换为Redux架构。
- en: Creating the entry point
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建入口点
- en: 'The `index` file found at `app/index.js` will serve as the entry point into
    our application. Both the iOS and Android versions of `Tasks` will call upon it,
    and it''s going to set up our Redux architecture. First, we''ll import all the
    necessary dependencies. Don''t worry if we haven''t created any applicable files
    or folders for these items yet; we''ll do so very shortly:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 位于`app/index.js`的`index`文件将作为我们应用的入口点。iOS和Android版本的`Tasks`都将调用它，它将设置我们的Redux架构。首先，我们将导入所有必要的依赖项。如果我们还没有为这些项目创建任何适用的文件或文件夹，不要担心；我们很快就会这样做：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Next, let's set up our store.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们设置我们的store。
- en: Setting up our store
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们的store
- en: 'To set up our store, we will need to use Redux''s `createStore` method and
    then pass it a reducer. Here''s how it looks on a high level:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置我们的store，我们需要使用Redux的`createStore`方法，然后传递一个reducer。从高层次来看，它看起来是这样的：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Additionally, since we know we'll be dealing with asynchronous calls in our
    application, we should also set up `Redux-Thunk` to support it.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于我们知道我们将在应用中处理异步调用，我们还应该设置`Redux-Thunk`以支持它。
- en: 'To do so, pass the `applyMiddleware` function as the second argument to `createStore`.
    Pass `thunk` as an argument for `applyMiddleware`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，将`applyMiddleware`函数作为`createStore`的第二个参数传递。将`thunk`作为`applyMiddleware`的参数传递：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, we''ll export a stateless function that returns our app container
    wrapped around the `Provider`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将导出一个无状态的函数，该函数返回被`Provider`包裹的应用容器：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In total, here''s how our `index.js` file will look at the end of the setup:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置完成后，我们的`index.js`文件将看起来如下：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now that we have created this file, let's build the app container. If you haven't
    already, create a `containers` folder within the `app` folder and then create
    separate `AppContainer` files for Android and iOS.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了此文件，让我们构建应用容器。如果您还没有创建，请在`app`文件夹内创建一个`containers`文件夹，然后为Android和iOS创建单独的`AppContainer`文件。
- en: Building the app container
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建应用容器
- en: 'The app container is going to provide a base `NavigatorIOS` route that renders
    our `TasksList` container. It looks similar to what we previously had in our root
    index files:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 应用容器将提供一个基本的`NavigatorIOS`路由，渲染我们的`TasksList`容器。它看起来与我们之前在根索引文件中的类似：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The major difference between the `AppContainer` and the root index file is that
    it does not call `AppRegistry.registerComponent`. That part is still handled by
    the root index file.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppContainer`和根索引文件之间的主要区别是它没有调用`AppRegistry.registerComponent`。这部分仍然由根索引文件处理。'
- en: 'Import the two routes we will use for `Navigator`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 导入我们将用于`Navigator`的两个路由：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Set the `routes` array:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`routes`数组：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This function handles the logic for rendering different routes:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数处理渲染不同路由的逻辑：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Next we will move onto creating actions and reducers in anticipation of building
    the `TasksList` container.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将开始创建动作和reducers，以期待构建`TasksList`容器。
- en: Creating actions
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建动作
- en: 'Let''s create some actions that will help us with our application. In the `Tasks`
    app, we had functionality for the following actions:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一些有助于我们应用程序的动作。在`Tasks`应用程序中，我们有以下动作的功能：
- en: Fetching tasks from `AsyncStorage`
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`AsyncStorage`获取任务
- en: Creating a new task
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新任务
- en: Editing a task's name
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑任务名称
- en: Marking/unmarking a task as complete
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记/取消标记任务为完成
- en: Showing/hiding the expandable component
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示/隐藏可展开组件
- en: Saving changes to a task
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存对任务的更改
- en: Clearing changes to a task
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清除对任务的更改
- en: Adding a due date
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加截止日期
- en: Removing a due date
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除截止日期
- en: 'Here''s an example of how an action for editing a task''s name can look:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个编辑任务名称的动作示例：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When naming an action, we want to correlate the type of action with exactly
    what has happened as a result of a user interaction. In this case, the user edited
    the task name. This action will also pass our reducer a `title` and `index`, so
    the reducer can then search the state for the task with the provided `index`,
    and edit its `title`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当命名一个动作时，我们希望将动作类型与用户交互导致的确切事件相关联。在这种情况下，用户编辑了任务名称。此动作还将传递给我们的reducer一个`title`和`index`，以便reducer可以搜索状态以找到提供的`index`的任务，并编辑其`title`。
- en: 'Initially, we have three actions we want to make sure work in `TasksList`:
    adding a task, changing its completion status, and modifying the value of `TextInput`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，我们有三项动作我们想要确保在`TasksList`中工作：添加任务，更改其完成状态，以及修改`TextInput`的值：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Each action is an exported function that returns an object with the action
    type as well as any other key-value pairs that contain data for our reducers to
    interact with:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 每个动作都是一个导出的函数，它返回一个对象，其中包含动作类型以及任何其他键值对，这些键值对包含我们reducers交互的数据：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: These will do for now - we'll slowly build in the other actions as we convert
    more and more of our application to support Redux. Next up, let's build the reducers
    for these three actions.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这些现在就足够了——随着我们将越来越多的应用程序转换为支持Redux，我们将逐步构建其他动作。接下来，让我们为这三个动作构建reducers。
- en: Building reducers
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建reducers
- en: Let's look at how we would build reducers to handle creating a new task and
    saving it into our list of tasks.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何构建reducers来处理创建新任务并将其保存到我们的任务列表中。
- en: 'Assuming we''re working with the following state tree:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在处理以下状态树：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the interest of writing a pure function, we want to make sure that we're
    not mutating the state and instead re-assigning our state to contain the updated
    changes.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写一个纯函数，我们想要确保我们不是修改状态，而是重新分配我们的状态以包含更新的更改。
- en: 'In an impure function, we would simply do something like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个不纯的函数中，我们可能会这样做：
- en: Don't do this!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 不要这样做！
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'What we''re doing here is mutating our state tree''s tasks array to push a
    new task into it. This can lead to problems when debugging later. Instead, what
    we want to do can be broken into a series of actionable steps:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是修改我们状态树的tasks数组，将其中的新任务推入。这可能导致后续调试时出现问题。相反，我们想要做的事情可以分解成一系列可执行步骤：
- en: Create a copy of the current state.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建当前状态的副本。
- en: Create a copy of the task's property of our copied state.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建我们复制的状态的任务的副本。
- en: Add our new task to the end of this copy.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的新任务添加到这个副本的末尾。
- en: Assign this copied array as the new task's value of our copied state.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此复制的数组分配为新任务的复制的状态值。
- en: Assign the copied state as our new current state.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将复制的状态分配为我们的新当前状态。
- en: 'The `singleTask` reducer handles logic that affects just one single task in
    the list. The results of this reducer are immediately accessed by the main `listOfTasks`
    reducer:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`singleTask` 减少器处理影响列表中单个任务的逻辑。此减少器的结果立即被主 `listOfTasks` 减少器访问：'
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this event, we return an object containing a new task's details.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在此事件中，我们返回一个包含新任务详情的对象。
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `singleTask` reducer is called during iteration in the `listOfTasks` reducer.
    Here, if the index of the individual task matches up with the index we want to
    interact with, we return the existing object using a spread operator and switch
    its completed status:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`singleTask` 减少器在 `listOfTasks` 减少器中的迭代期间被调用。在这里，如果单个任务的索引与我们要交互的索引相匹配，我们使用扩展运算符返回现有对象，并切换其完成状态：'
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This sets a default state to pass over to `listOfTasks`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这设置了一个默认状态，将其传递给 `listOfTasks`：
- en: '[PRE33]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `listOfTasks` reducer is where all actions first end up firing through.
    It then uses a switch statement to figure out which action type is being called
    and returns a new state object based on that action type:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`listOfTasks` 减少器是所有动作首先触发的地方。然后它使用 `switch` 语句来确定正在调用的动作类型，并根据该动作类型返回一个新的状态对象：'
- en: '[PRE34]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If we want to add a task, return the state object through a spread operator
    containing an updated `listOfTasks` array that is built using the spread operator,
    calling the `singleTask` reducer with an empty object and the action object that
    is initially passed there:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要添加一个任务，通过包含使用扩展运算符构建的更新后的 `listOfTasks` 数组的扩展运算符返回状态对象，调用 `singleTask`
    减少器并传递一个空对象和最初传递给那里的动作对象：
- en: '[PRE35]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If we change a task''s completion status, we call map on the `listOfTasks`
    array in the state and then call `singleTask` on each element in the task, passing
    the current task object and the action object to it:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们更改任务的完成状态，我们在状态中的 `listOfTasks` 数组上调用 map，然后对任务中的每个元素调用 `singleTask`，传递当前任务对象和动作对象给它：
- en: '[PRE36]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Update the `text` property of our state tree for `TextInput` components:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 更新状态树中 `TextInput` 组件的 `text` 属性：
- en: '[PRE37]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: To summarize, `listOfTasks` is our parent reducer and handles the overall logic
    of our app, while `singleTask` handles the pertinent information for one single
    item in our list.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`listOfTasks` 是我们的父级减少器，处理我们应用程序的整体逻辑，而 `singleTask` 处理列表中单个项目的相关信息。
- en: Creating the TasksList container
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 `TasksList` 容器
- en: Now that we've got our actions and reducers, we'll create the container that
    connects our dispatch methods and state to the `TasksList` component.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了动作和减少器，我们将创建一个容器，将我们的分发方法和状态连接到 `TasksList` 组件。
- en: 'First, we''ll import the `connect` module from `react-redux`, alongside any
    actions we intend to dispatch in `TasksList`, as well as the `TasksList` component
    itself:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从 `react-redux` 中导入 `connect` 模块，以及我们在 `TasksList` 中打算分发的任何动作，以及 `TasksList`
    组件本身：
- en: '[PRE38]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then we''ll create three methods that will result in dispatching functions
    to our state tree using `mapDispatchToProps`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将创建三个方法，这些方法将导致使用 `mapDispatchToProps` 向我们的状态树分发函数：
- en: '[PRE39]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Afterwards, we''ll map the state we intend to pass into TasksList''s prop,
    including the `Navigator` that we already have from the top level:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将映射我们打算传递给 `TasksList` 的 prop 的状态，包括我们从顶级中已有的 `Navigator`：
- en: '[PRE40]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, we will `connect` the `mapStateToProps` and `mapDispatchToProps` functions
    to the `TasksList` component and export it:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将 `mapStateToProps` 和 `mapDispatchToProps` 函数连接到 `TasksList` 组件并导出它：
- en: '[PRE41]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now, let's look at how we refactor the `TasksList` component.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何重构 `TasksList` 组件。
- en: Redux-connected TasksList component
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redux 连接的 `TasksList` 组件
- en: 'Components in Redux will retain their JSX markup, but any logic that isn''t
    specific to that exact component is kept by our state tree and modified through
    actions and reducers:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Redux 中，组件将保留其 JSX 标记，但任何不属于该特定组件的逻辑都由我们的状态树保持，并通过动作和减少器进行修改：
- en: '[PRE42]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: React Native APIs and components such as `AsyncStorage` have been removed from
    this component, since any calls to any storage methods will be handled by our
    actions and reducers in the future.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 由于未来任何对存储方法的调用都将由我们的动作和减少器处理，因此已从该组件中移除了 React Native API 和组件，如 `AsyncStorage`。
- en: 'Create a new `ListView.DataSource` instance, since it is specific to this component:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 `ListView.DataSource` 实例，因为它特定于该组件：
- en: '[PRE43]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Create the `dataSource` constant for our `ListView` with the `listOfTasks`
    array in our state tree:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为我们状态树中的 `ListView` 创建 `dataSource` 常量，包含 `listOfTasks` 数组：
- en: '[PRE44]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Callbacks such as `onChangeText` and `onSubmitEditing` now call actions that
    have been mapped to the `TasksListContainer`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`onChangeText` 和 `onSubmitEditing` 等回调现在调用映射到 `TasksListContainer` 的动作：'
- en: '[PRE45]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This passes `TasksListCell''s` required `onLongPress` callback a placeholder:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这将传递 `TasksListCell` 所需的 `onLongPress` 回调一个占位符：
- en: '[PRE46]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Converting EditTasks to Redux
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 EditTasks 转换为 Redux
- en: 'With `EditTasks`, we are introducing some new actions and reducers into the
    mix. These include:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `EditTasks` 中，我们引入了一些新的动作和减少器。这些包括：
- en: Setting the currently selected task to one that was pressed on in `TasksList`
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将当前所选任务设置为在 `TasksList` 中按下的任务
- en: Handling a change when the Cancel or Save buttons are pressed in the `EditTask`
    screen
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理在 `EditTask` 屏幕中按下取消或保存按钮时的更改
- en: Toggling the selected task as completed
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切换所选任务为完成状态
- en: Changing the name of the selected task
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改所选任务的名字
- en: Adding, modifying, and removing the due date
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加、修改和删除截止日期
- en: Expanding the expandable cell that shows and hides the `DatePicker` component
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展开可展开的单元格以显示和隐藏 `DatePicker` 组件
- en: For the first two bullet points, those modifications will come in the form of
    three new actions placed in the `TasksList` container, since that's the component
    where these events will either happen or be defined and passed to EditTask's navigator.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前两个项目，这些修改将以三种新动作的形式出现，放置在 `TasksList` 容器中，因为这是这些事件将发生或定义并传递给 EditTask 导航器的组件。
- en: 'Our state tree will also need to hold the following new properties:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的状态树还需要包含以下新属性：
- en: The formatted and unformatted dates from the DatePicker component that point
    to the selected task
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DatePicker 组件中格式化和未格式化的日期，指向所选的任务
- en: An object pertaining to the currently selected task in the `EditTask` screen
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个与 `EditTask` 屏幕中当前所选任务相关的对象
- en: An indication whether the `ExpandableCell` is visible or not
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指示 `ExpandableCell` 是否可见的指示
- en: An indication whether a date has been selected in the EditScreen view
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 EditScreen 视图中选择日期的指示
- en: With this in mind, let's start the conversion with our actions!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个想法，让我们从我们的行动开始转换！
- en: Adding actions for EditTask
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 `EditTask` 添加动作
- en: 'Here are the additions to the actions file to accommodate `EditTask`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是针对 `EditTask` 的动作文件中的新增内容：
- en: '[PRE47]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: These are new constants that describe the different actions that the `EditTask`
    component will bring to the app.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是新常量，描述了 `EditTask` 组件将带给应用的不同的动作。
- en: 'These functions are straightforward, since they pass the desired action type
    between zero and two values for our reducers to handle:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数很简单，因为它们在零到两个值之间传递所需的动作类型，以便我们的减少器处理：
- en: '[PRE48]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `saveSelectedTaskDetails` action is more complex than the rest. It takes
    an object from the `EditTask` component and then breaks it into different properties
    for our reducer to work with.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`saveSelectedTaskDetails` 动作比其他动作更复杂。它从 `EditTask` 组件中获取一个对象，然后将其分解为不同的属性，以便我们的减少器可以处理。'
- en: '[PRE49]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Reducers for EditTask
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`EditTask` 的减少器'
- en: 'We should also update our reducers to handle these newly introduced actions.
    We should do the following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该更新我们的减少器以处理这些新引入的动作。我们应该做以下事情：
- en: Expand the `defaultState` object, including the `date`, `dateSelected`, `expanded`,
    `formattedDate`, and `selectedTaskObject` properties
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展 `defaultState` 对象，包括 `date`、`dateSelected`、`expanded`、`formattedDate` 和 `selectedTaskObject`
    属性
- en: Add a helper function to format a date with MomentJS
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个辅助函数以使用 MomentJS 格式化日期
- en: Create a new switch case for the `singleTask` reducer to handle the `SAVE_SELECTED_TASK_DETAILS`
    action
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 `singleTask` 减少器创建一个新的 switch 情况以处理 `SAVE_SELECTED_TASK_DETAILS` 动作
- en: Build a new `selectedTask` reducer for temporarily storing and modifying the
    `selectedTaskObject` being edited by the user
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为用户正在编辑的 `selectedTaskObject` 建立一个新的 `selectedTask` 减少器以临时存储和修改
- en: Extend the `listOfTasks` reducer to handle each of the new actions, delegating
    them to either the `singleTask` or `selectedTask` reducers when necessary
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展 `listOfTasks` 减少器以处理每个新动作，在必要时将其委派给 `singleTask` 或 `selectedTask` 减少器
- en: 'The `defaultState` object has gotten larger to accommodate new information
    that `EditTask` will be using, such as the `expanded` status of `ExpandableCell`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`defaultState` 对象已扩大以容纳 `EditTask` 将使用的新信息，例如 `ExpandableCell` 的 `expanded`
    状态：'
- en: '[PRE50]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Format the date with MomentJS:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 MomentJS 格式化日期：
- en: '[PRE51]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'No changes were made to these two methods:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个方法没有进行任何更改：
- en: '[PRE52]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This is specifically to save details for a task that has been selected for
    editing by the user:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了保存用户已选用于编辑的任务的详细信息：
- en: '[PRE53]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This is a new reducer created to address the task object currently being edited
    by the user:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个新创建的红ucer，用于处理用户当前正在编辑的任务对象：
- en: '[PRE54]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Our Redux state stores the object being edited by the user because at any given
    point, the user can simply decide to cancel any changes. Keeping changes in a
    temporary object and only saving them to the state once the user has pressed on
    the Save button saves us the hassle of undoing any changes the user has made:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Redux 状态存储用户正在编辑的对象，因为用户在任何时候都可以简单地决定取消任何更改。将更改保存在临时对象中，只有在用户按下保存按钮后才会将它们保存到状态中，这样我们就可以避免撤销用户所做的任何更改：
- en: '[PRE55]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Similar to the `singleTask` reducer, `selectedTask` is accessed by the main
    `listOfTasks` reducer:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `singleTask` 红ucer 类似，`selectedTask` 通过主 `listOfTasks` 红ucer 访问：
- en: '[PRE56]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: No changes were made to the following two cases.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个情况没有进行更改。
- en: '[PRE57]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This is the code for setting the `selectedTaskObject` property in our Redux
    state. It also sets the date, `dateSelected`, and `formattedDate` properties for
    the `DatePicker` component.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这是设置我们 Redux 状态中的 `selectedTaskObject` 属性的代码。它还设置了 `DatePicker` 组件的日期、`dateSelected`
    和 `formattedDate` 属性。
- en: 'No changes to this case either:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 此情况也没有更改：
- en: '[PRE58]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This is the first time we call the `selectedTask` reducer from `listOfTasks`.
    It changes the completion status of the task currently being edited:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一次从 `listOfTasks` 调用 `selectedTask` 红ucer。它更改了当前正在编辑的任务的完成状态：
- en: '[PRE59]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This case changes the due date of the selected task, as well as the `date`,
    `dateSelected`, and `formattedDate` properties:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 此情况更改了所选任务的截止日期，以及 `date`、`dateSelected` 和 `formattedDate` 属性：
- en: '[PRE60]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Change the name of the selected task:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 更改所选任务的名字：
- en: '[PRE61]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Handle the `expanded` property of `ExpandableCell`:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 处理 `ExpandableCell` 的 `expanded` 属性：
- en: '[PRE62]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This is what gets executed if the user presses `Cancel` in the `EditTask` screen:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在 `EditTask` 屏幕上按下 `Cancel`，则会执行以下操作：
- en: '[PRE63]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Remove the due date from the selected task:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 从所选任务中移除截止日期：
- en: '[PRE64]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Finally, this saves the selected task permanently into the `listOfTasks` array:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这会将所选任务永久保存到 `listOfTasks` 数组中：
- en: '[PRE65]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Updating TasksListContainer to accommodate EditTask
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新 TasksListContainer 以适应 EditTask
- en: 'Now we should update the `TasksListContainer` and `TasksList` component. First,
    `TasksListContainer` should do the following:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该更新 `TasksListContainer` 和 `TasksList` 组件。首先，`TasksListContainer` 应该执行以下操作：
- en: Import the `changeCurrentlyEditedTask`, `resetSelectedTask`, and `saveSelectedTaskDetails`
    actions and add them to the `mapDispatchToProps` method
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入 `changeCurrentlyEditedTask`、`resetSelectedTask` 和 `saveSelectedTaskDetails`
    动作并将它们添加到 `mapDispatchToProps` 方法。
- en: Import the `date`, `formattedDate`, and `selectedTaskObject` properties of our
    Redux state and add them to the `mapStateToProps` method
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Redux 状态中的 `date`、`formattedDate` 和 `selectedTaskObject` 属性导入并添加到 `mapStateToProps`
    方法。
- en: 'Take a look at the following code:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下代码：
- en: '[PRE66]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Above, I imported three new actions.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，我导入了三个新动作。
- en: '[PRE67]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Mapping the three new actions to the dispatch methods of `TasksList`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 将三个新动作映射到 `TasksList` 的调度方法。
- en: '[PRE68]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Mapping three new values in the Redux state to the props of `TasksList`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Redux 状态中的三个新值映射到 `TasksList` 的 props。
- en: Updating the TasksList component
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新 TasksList 组件
- en: 'Next, let''s make changes to `TasksList` so that it supports `EditTask`. It
    should do the following:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们对 `TasksList` 进行修改，以便它支持 `EditTask`。它应该执行以下操作：
- en: Import the `EditTaskContainer` for us to push to the navigator.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们导入 `EditTaskContainer` 以推送到导航器。
- en: Add the `Platform` API to support Android devices.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `Platform` API 以支持 Android 设备。
- en: Modify the `onLongPress` callback for `TasksListCell` to call a function that
    first adds the currently selected task to the Redux state and then navigate the
    user to the `EditTaskContainer`. It should contain a `Cancel` and `Save` button.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `TasksListCell` 的 `onLongPress` 回调以调用一个函数，该函数首先将当前选定的任务添加到 Redux 状态，然后导航用户到
    `EditTaskContainer`。它应包含一个 `Cancel` 和 `Save` 按钮。
- en: The `Cancel` button should fire a function that `pops` the navigator and resets
    the `selectedTaskObject` value in your Redux state.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Cancel` 按钮应触发一个函数，该函数 `pops` 导航器并重置 Redux 状态中的 `selectedTaskObject` 值。'
- en: The `Save` button should fire a function that `pops` the navigator and saves
    the `selectedTaskObject` into the `listOfTasks` array in your Redux state.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Save` 按钮应触发一个函数，该函数 `pops` 导航器并将 `selectedTaskObject` 保存到 Redux 状态中的 `listOfTasks`
    数组。'
- en: 'Here are my changes to the `TasksList` component:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我的对 `TasksList` 组件的修改：
- en: '[PRE69]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The following code adds the `_cancelEditingTask` function to call `pop` on
    the navigator and then the `resetSelectedTask` action:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将 `_cancelEditingTask` 函数添加到在导航器上调用 `pop` 并然后触发 `resetSelectedTask` 动作：
- en: '[PRE70]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Change the `onLongPress` callback for `TasksListCell` to call the following
    `_onLongPress` function:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `TasksListCell` 的 `onLongPress` 回调函数改为调用以下 `_onLongPress` 函数：
- en: '[PRE71]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'If the user is on an iOS device, `push` the `EditTaskContainer` to the navigator
    and pass it a string for the left and right buttons, and give them callbacks that
    fire when they are pressed:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户使用的是 iOS 设备，将 `EditTaskContainer` `push` 到导航器，并传递一个字符串给左右按钮，并给它们按下时触发的回调：
- en: '[PRE72]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'On an Android device, just `push` the index of the route specified in `AppContainer.android.js`:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 设备上，只需 `push` `AppContainer.android.js` 中指定的路由索引：
- en: '[PRE73]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'When saving the edited task, first `pop` the navigator and then dispatch the
    `saveSelectedTaskDetails` action:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 保存编辑后的任务时，首先 `pop` 导航器，然后触发 `saveSelectedTaskDetails` 动作：
- en: '[PRE74]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Creating the EditTask container
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 EditTask 容器
- en: 'The `EditTaskContainer` will be composed the same way as TasksListContainer.
    It will do the following:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`EditTaskContainer` 将以与 TasksListContainer 相同的方式组合。它将执行以下操作：'
- en: Import actions relevant to the `EditTask` component from your actions file.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从你的动作文件中导入与 `EditTask` 组件相关的动作：
- en: Import the `EditTask` and `connect` module.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `EditTask` 和 `connect` 模块。
- en: Contain a `mapDispatchToProps` method to map the actions you imported.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含一个 `mapDispatchToProps` 方法来映射你导入的动作。
- en: Call `mapStateToProps` on any parts of the Redux state you wish `EditTask` to
    have access to.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Redux 状态的任何部分调用 `mapStateToProps`，以便 `EditTask` 可以访问：
- en: Call `connect` on `mapDispatchToProps`, `mapStateToProps`, and the `EditTask`
    component.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `mapDispatchToProps`、`mapStateToProps` 和 `EditTask` 组件上调用 `connect`：
- en: 'These are the actions that `EditTask` will be utilizing:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 `EditTask` 将要使用的动作：
- en: '[PRE75]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The `resetSelectedTask` and `saveSelectedTaskDetails` actions are mapped to
    `EditTaskContainer` specifically for the Android version of this app:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`resetSelectedTask` 和 `saveSelectedTaskDetails` 动作专门映射到 Android 版本应用的 `EditTaskContainer`：'
- en: '[PRE76]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '`EditTask` should have access to the following data from the state tree:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`EditTask` 应该能够从状态树访问以下数据：'
- en: '[PRE77]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Finally, `connect` everything together:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将所有东西连接起来：
- en: '[PRE78]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Modifying the EditTask component for iOS
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改 iOS 版本的 EditTask 组件
- en: 'Next, we will modify the `EditTask` component. It should:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将修改 `EditTask` 组件。它应该：
- en: Be nearly identical to the `EditTask` component we had at the end of [Chapter
    2](ca59eac5-a24f-4ac1-8b42-f1c28d149d74.xhtml), *Advanced Functionality and Styling
    the To-Do List App*, with both an Android- and iOS-specific version
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几乎与我们在 [第 2 章](ca59eac5-a24f-4ac1-8b42-f1c28d149d74.xhtml) 的 *高级功能与美化待办事项应用*
    末尾所拥有的 `EditTask` 组件相同，具有 Android 和 iOS 特定版本：
- en: Replace any methods that manipulate data with the actions that we can dispatch
    to the state tree
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用我们可以向状态树分发的动作替换任何操作数据的方法：
- en: 'Since `datePickerHeight` is set during the `onLayout` event of `DatePickerIOS`,
    we will keep it in the local state:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `datePickerHeight` 是在 `DatePickerIOS` 的 `onLayout` 事件中设置的，我们将将其保留在本地状态中：
- en: '[PRE79]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The `TextInput` dispatches the `changeTextInputValue` action when text is changed,
    and gets its value from the `selectedTaskObject` of our state tree:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextInput` 在文本改变时触发 `changeTextInputValue` 动作，并从我们状态树中的 `selectedTaskObject`
    获取其值：'
- en: '[PRE80]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The `ExpandableCell` component remains the same here, but delegates its `expanded`
    Boolean and `title` determination logic to our Redux state and dispatches the
    `onExpand`  action when pressed:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`ExpandableCell` 组件保持不变，但它将 `expanded` 布尔值和 `title` 确定逻辑委托给我们的 Redux 状态，并在按下时触发
    `onExpand` 动作：
- en: '[PRE81]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'As you can see, the only remaining component-based logic is with `_getDatePickerHeight`.
    All other functions are dispatched for the state tree to handle:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，唯一剩余的基于组件的逻辑是与 `_getDatePickerHeight` 相关。所有其他函数都由状态树处理：
- en: '[PRE82]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Modifying the EditTask component for Android
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改 Android 版本的 EditTask 组件
- en: It's easiest for us to take the Android `EditTask` component from [Chapter 2](ca59eac5-a24f-4ac1-8b42-f1c28d149d74.xhtml), *Advanced
    Functionality and Styling the To-Do List App*, and make changes to it. Additionally,
    referencing the updated iOS version of this component during these changes can
    also help.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们来说，从 [第 2 章](ca59eac5-a24f-4ac1-8b42-f1c28d149d74.xhtml) 的 `EditTask` 组件，即
    *高级功能与美化待办事项应用*，取来并对其进行修改最为简单。此外，在修改过程中参考此组件更新的 iOS 版本也可以有所帮助。
- en: 'Specifically, for the Android version of `EditTask`, we want to do the following:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 特别地，对于 Android 版本的 `EditTask`，我们想要做以下操作：
- en: Swap out any references to the local state with the state tree made available
    via `props`
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用通过 `props` 提供的状态树替换任何对本地状态的引用
- en: Replace any unnecessary calls to the local methods, dispatching actions instead
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替换任何不必要的本地方法调用，改为分发动作
- en: Keep the local methods for saving a task and opening both the date and time
    pickers
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持本地方法以保存任务和打开日期和时间选择器
- en: Update the callback that pressing the back button triggers, resetting the `selectedTaskObject`
    in addition to calling `pop` on the navigator
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新按返回按钮触发的回调，除了在导航器上调用 `pop` 外，还重置 `selectedTaskObject`
- en: The modifications that I made show the differences between `EditTask/index.android.js`
    and `EditTask/index.ios.js`.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我所做的修改显示了 `EditTask/index.android.js` 和 `EditTask/index.ios.js` 之间的差异。
- en: 'I removed `ExpandableCell` from my import statements:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我从导入语句中移除了 `ExpandableCell`：
- en: '[PRE83]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'I removed the `datePickerHeight` value in the state, since the Android component
    does not deal with `ExpandableCell`:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我从状态中移除了 `datePickerHeight` 值，因为 Android 组件不处理 `ExpandableCell`：
- en: '[PRE84]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Adding and removing event listeners for the Android back button is unchanged
    from [Chapter 2](ca59eac5-a24f-4ac1-8b42-f1c28d149d74.xhtml), *Advanced Functionality
    and Styling the To-Do List App*:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 添加和删除 Android 返回按钮的事件监听器与第 2 章 [Chapter 2](ca59eac5-a24f-4ac1-8b42-f1c28d149d74.xhtml)，*高级功能与美化待办事项应用*
    相同：
- en: '[PRE85]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: No changes were made to the `TextInput` component.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `TextInput` 组件没有进行任何更改。
- en: '[PRE86]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The `Button` to open `DatePickerAndroid` is modified to reference the `selectedTaskObject`
    due property to determine the text to render:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `DatePickerAndroid` 的 `Button` 被修改为引用 `selectedTaskObject` 的 due 属性以确定要渲染的文本：
- en: '[PRE87]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'No changes were made to the `Switch` component, Clear Date `Button`, or Save
    `Button`. The Save `Button` is exclusive to the Android version of this app, since
    the logic to save the edited task is handled in the navigation bar on iOS:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `Switch` 组件、清除日期 `Button` 或保存 `Button` 没有进行任何更改。保存 `Button` 专属于此应用的 Android
    版本，因为保存编辑任务的逻辑在 iOS 的导航栏中处理：
- en: '[PRE88]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Modify the `_backButtonPress` to also dispatch the `resetSelectedTask` action:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 `_backButtonPress` 方法，使其也分发 `resetSelectedTask` 动作：
- en: '[PRE89]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'I also modified `_saveSelectedTaskDetails` to dispatch the `saveSelectedTasks`
    action:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我还修改了 `_saveSelectedTaskDetails` 方法，以分发 `saveSelectedTasks` 动作：
- en: '[PRE90]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Change `_showAndroidDatePicker` to not keep the `day`, `month`, and `year`
    values in the state. Instead, it passes the data directly to `_showAndroidTimePicker`
    for immediate use:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `_showAndroidDatePicker` 修改为不在状态中保留 `day`、`month` 和 `year` 值。相反，它直接将数据传递给
    `_showAndroidTimePicker` 以立即使用：
- en: '[PRE91]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Likewise, `_showAndroidTimePicker` is changed to accept those `day`, `month`,
    and `year` values. Then it creates a new `Date` object immediately with those
    three values, along with the `hour` and `minute` that `TimePickerAndroid` returns,
    and dispatches the `onDateChange` action with the new `Date` object:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`_showAndroidTimePicker` 被修改为接受那些 `day`、`month` 和 `year` 值。然后它立即使用这三个值以及
    `TimePickerAndroid` 返回的 `hour` 和 `minute` 创建一个新的 `Date` 对象，并分发带有新 `Date` 对象的 `onDateChange`
    动作：
- en: '[PRE92]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: At this point, we have almost completed our port to Redux! The only thing that
    remains is persisting our list of tasks as before.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们几乎完成了对 Redux 的迁移！唯一剩下的是像以前一样持久化我们的任务列表。
- en: Creating a StorageMethods file for asynchronous saving
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个用于异步保存的 `StorageMethods` 文件
- en: Right now, any refresh or exiting of the application will wipe our list of tasks
    clean. That doesn't make for a very useful app, so we're now going to modify our
    actions to store and retrieve our list of tasks from `AsyncStorage`.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，任何刷新或退出应用程序都会清除我们的任务列表。这并不适合一个非常有用的应用程序，因此我们现在将修改我们的动作以从 `AsyncStorage` 存储和检索我们的任务列表。
- en: 'Let''s create a `utils` folder within `app`, and then create a file titled
    `storageMethods.js` within `utils`:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `app` 中创建一个 `utils` 文件夹，然后在 `utils` 中创建一个名为 `storageMethods.js` 的文件：
- en: '![](img/image_07_001.png)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_07_001.png)'
- en: 'This file will contain two functions:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件将包含两个函数：
- en: '`getAsyncStorage`: This gets the `listOfTasks` item in `AsyncStorage` and returns
    it'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getAsyncStorage`：此方法从 `AsyncStorage` 中获取 `listOfTasks` 项目并返回它'
- en: '`saveAsyncStorage`: This accepts an array and saves it into `AsyncStorage`
    under the `listOfTasks` key'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`saveAsyncStorage`：接受一个数组并将其保存到 `AsyncStorage` 中的 `listOfTasks` 键下'
- en: 'If you worked on the previous projects in this book, this part will be very
    familiar to you:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这本书的前几个项目中工作过，这部分对你来说会很熟悉：
- en: '[PRE93]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: This uses asynchronous functions for readability, grabbing the `listOfTasks`
    value in `AsyncStorage`, parsing it to transform it back to an array, and then
    returning it.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用了异步函数以提高可读性，从 `AsyncStorage` 中获取 `listOfTasks` 的值，将其解析以将其转换回数组，然后返回它。
- en: '[PRE94]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Likewise, accept an array and then set the `listOfTasks` key in `AsyncStorage`
    to the stringified version of the array.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，接受一个数组，然后将`AsyncStorage`中的`listOfTasks`键设置为该数组的字符串化版本。
- en: Subscribing the store to changes
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 订阅存储的变化。
- en: To update the `listOfTasks` key in `AsyncStorage` whenever a change is made
    to the state tree, we will call the `subscribe` method of our store. This creates
    a change listener to be called whenever an action has been dispatched and the
    state tree may have been changed.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在状态树发生变化时更新`AsyncStorage`中的`listOfTasks`键，我们将调用存储的`subscribe`方法。这创建了一个变化监听器，在每次分派动作并且状态树可能发生变化时被调用。
- en: It accepts a callback as its argument, and within that argument we can call
    the `getState` method of the store to access the state tree and retrieve any values
    we want from it.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受一个回调作为其参数，并且在这个参数内部，我们可以调用存储的`getState`方法来访问状态树并从中检索我们想要的任何值。
- en: 'Let''s modify the index file found in the app folder so that it subscribes
    to changes to the store, firing a callback that calls `saveAsyncStorage` and passes
    it the most recent version of the `listOfTasks` array in our state tree:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改应用文件夹中找到的索引文件，以便它订阅存储的变化，触发一个回调，该回调调用`saveAsyncStorage`并传递我们状态树中最新的`listOfTasks`数组版本：
- en: '[PRE95]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Since the rest of our application state does not have a need for persistence,
    `listOfTasks` is the only item being saved into `AsyncStorage`.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用程序状态的其他部分没有持久化的需求，`listOfTasks`是唯一被保存到`AsyncStorage`中的项。
- en: Creating a thunk
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个thunk。
- en: The `Redux-Thunk` library is a wrapper around your action creators, allowing
    them to perform asynchronous tasks before dispatching their intended action to
    the Redux store for a reducer to handle.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`Redux-Thunk`库是围绕你的动作创建器的包装器，允许它们在将预期的动作分派到Redux存储以由还原器处理之前执行异步任务。'
- en: 'Here''s how we will create a thunk: in the file where we create actions, we
    will export a function that returns a custom, asynchronous function within it,
    passing it the existing `dispatch` method. In this custom function, we will grab
    the results of a call to our `getAsyncStorage` method.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们创建thunk的方式：在创建动作的文件中，我们将导出一个函数，该函数返回一个自定义的异步函数，并将现有的`dispatch`方法传递给它。在这个自定义函数中，我们将获取对`getAsyncStorage`方法的调用结果。
- en: 'Then, within the same method, we will dispatch a private function, which we
    also create in the same file. That private function will return the action type,
    along with any parameters we wish to pass:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在同一个方法内部，我们将分派一个私有函数，我们也在同一个文件中创建这个私有函数。这个私有函数将返回动作类型，以及我们希望传递的任何参数：
- en: '[PRE96]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: I removed the `currentIndex` variable from this file, since we will no longer
    rely on a hardcoded number to set the index of our tasks.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经从该文件中移除了`currentIndex`变量，因为我们不再依赖于硬编码的数字来设置任务的索引。
- en: 'First, create a constant for the action to set the list of tasks and index:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个用于设置任务列表和索引的动作常量：
- en: '[PRE97]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Create the `getListOfTasksAndIndex` action.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`getListOfTasksAndIndex`动作。
- en: '[PRE98]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'This `setListOfTasksAndIndex` function is not exported, since it is only being
    called by `getListOfTasksAndIndex`. We are using the length of the array to set
    the index for a newly added task:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`setListOfTasksAndIndex`函数没有被导出，因为它只被`getListOfTasksAndIndex`调用。我们使用数组的长度来为新添加的任务设置索引：
- en: '[PRE99]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Modifying our reducers
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改我们的还原器。
- en: 'We need to modify our reducers file so that it does the following:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要修改我们的还原器文件，以便它执行以下操作：
- en: Adds the `currentIndex` property to its `defaultState` object
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`currentIndex`属性添加到其`defaultState`对象中。
- en: Sets the `index` of a task when it is added to our state tree
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当任务被添加到我们的状态树时设置任务的`index`。
- en: Increases the `currentIndex` property of our state tree by one when adding a
    new task
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在添加新任务时增加我们状态树中`currentIndex`属性的值。
- en: Contains a switch case for the `SET_LIST_OF_TASKS_AND_INDEX` action, setting
    the `currentIndex` and `listOfTasks` properties of our state tree to the results
    of our `getListOfTasksAndIndex` thunk
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含一个用于`SET_LIST_OF_TASKS_AND_INDEX`动作的switch情况，将我们的状态树中的`currentIndex`和`listOfTasks`属性设置为我们的`getListOfTasksAndIndex`thunk的结果。
- en: '[PRE100]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: The `ADD_TASK` case in the `singleTask` sub-reducer sets the index of the added
    task.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在`singleTask`子还原器中的`ADD_TASK`情况设置了添加的任务的索引。
- en: No changes are made to the `selectedTask` sub-reducer.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 对`selectedTask`子还原器没有进行任何更改。
- en: '[PRE101]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: In the preceding code, the `ADD_TASK` case in the `listOfTasks` reducer increments
    the `currentIndex` of the state tree by one and sets it as the new `currentIndex`.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`listOfTasks`还原器中的`ADD_TASK`情况将状态树的`currentIndex`增加一个，并将其设置为新的`currentIndex`。
- en: '[PRE102]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: In the preceding code, the `SET_LIST_OF_TASKS_AND_INDEX` case sets the `currentIndex`
    and `listOfTasks` properties in our state tree with the results of calling `getAsyncStorage`
    back in our `getListOfTasksAndIndex` thunk.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`SET_LIST_OF_TASKS_AND_INDEX`情况将`currentIndex`和`listOfTasks`属性设置在我们的状态树中，这些属性是通过在`getListOfTasksAndIndex`thunk中调用`getAsyncStorage`返回的结果。
- en: Updating the TasksListContainer
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新TasksListContainer
- en: 'Next, we need to update the `TasksListContainer` so that it does the following:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新`TasksListContainer`，使其执行以下操作：
- en: Maps the `getListOfTasksAndIndex` action and `currentIndex` value to its props
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`getListOfTasksAndIndex`操作和`currentIndex`值映射到其属性
- en: Modifies the `addTask` action to expect and send an `index` argument
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改`addTask`操作以期望和发送一个`index`参数
- en: 'These are the changes I ended up with:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我最终得到的更改：
- en: '[PRE103]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Modifying the TasksList component
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改TasksList组件
- en: 'Finally, we will edit `TasksList` so that it does the following:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将编辑`TasksList`，使其执行以下操作：
- en: Dispatches the `getListOfTasksAndIndex` action during the `componentWillMount`
    life cycle event
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`componentWillMount`生命周期事件期间派发`getListOfTasksAndIndex`操作
- en: Passes in the `currentIndex` of the state tree to the `TextInput's``onSubmitEditing`
    callback as a second argument
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将状态树的`currentIndex`传递给`TextInput`的`onSubmitEditing`回调作为第二个参数
- en: 'Call `getListOfTasksAndIndex` during `componentWillMount`, making sure that
    `TasksList` has the most up-to-date version of the `listOftasks` array as the
    user opens the app:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在`componentWillMount`生命周期事件期间调用`getListOfTasksAndIndex`，确保当用户打开应用时`TasksList`具有最新的`listOfTasks`数组版本：
- en: '[PRE104]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Add `this.props.currentIndex` as the second argument to calling the `addTask`
    method, so that we explicitly give each task a unique index:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 将`this.props.currentIndex`作为调用`addTask`方法的第二个参数添加，这样我们就可以明确地为每个任务提供一个唯一的索引：
- en: '[PRE105]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: And there you have it! We've successfully converted `Tasks`, our to-do list
    app, to support Redux.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们已经成功地将我们的待办事项列表应用`Tasks`转换为支持Redux。
- en: Summary
  id: totrans-399
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned the fundamentals of React development with Redux!
    We started by creating actions, which dispatch intent to our Redux store. Then,
    we wrote reducers to handle that intent and update our state tree. We also built
    a store that consolidated our reducers and middleware.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了使用Redux的React开发基础！我们首先创建操作，将意图分发给我们的Redux存储。然后，我们编写了减少器来处理那个意图并更新我们的状态树。我们还构建了一个存储，它整合了我们的减少器和中间件。
- en: Afterwards, we used the Connect method to wrap a container around a React component,
    giving it access to any actions and parts of the state tree of our choosing.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们使用Connect方法将一个容器包裹在React组件周围，使其能够访问我们选择的任何操作和状态树的部分。
- en: We also converted the existing `EditTask` and `TasksList` components to be less
    reliant on the local state and use its logic from the state tree.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将现有的`EditTask`和`TasksList`组件转换为更少依赖于本地状态，并使用状态树中的逻辑。
- en: Later in the chapter, we discovered how to temporarily delay the dispatching
    of actions to perform necessary asynchronous calls first by using `Redux-Thunk`.
    This, in conjunction with subscribing our store to any updates, allowed us to
    have a fully persistent app that used `AsyncStorage` to keep its data.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们发现了如何通过使用`Redux-Thunk`暂时延迟动作的派发，首先执行必要的异步调用。这，结合订阅我们的存储以获取任何更新，使我们能够拥有一个完全持久的应用，该应用使用`AsyncStorage`来保持其数据。
- en: Finally, we made sure that every step along the way kept the Android support
    we started the chapter with.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们确保了每一步都保留了我们在本章开始时引入的Android支持。
- en: In the next chapter, we are going to change things a bit. We have spent all
    this time building applications, but no time on how to share them with the world.
    In the next chapter, we will learn just how to get these apps you have made onto
    the Apple App Store and Google Play Store.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将做一些改变。我们花了所有这些时间构建应用程序，但没有时间考虑如何将它们分享给世界。在下一章中，我们将学习如何将你制作的应用程序上传到Apple
    App Store和Google Play Store。
