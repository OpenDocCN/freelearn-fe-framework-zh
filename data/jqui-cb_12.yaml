- en: Chapter 12. Widgets and More!
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 12 章。小部件和更多！
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下配方：
- en: Accordions to tabs, and back again
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从折叠到标签，再返回
- en: Building a custom widget from scratch
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从头开始构建自定义小部件
- en: Building an observer widget
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个观察者小部件
- en: Using widgets with Backbone applications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Backbone 应用程序的小部件
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Until now, each chapter in this book has focused on working with a specific
    widget that ships with jQuery UI. In this chapter, we're more interested in the
    grand scheme of things. After all, you're building an application, and not a demonstration.
    So, it's important that developers using jQuery UI be conscious not only about
    how each individual widget works on their own, but also about how they behave
    in their environment, and how they interact with other widgets and frameworks.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书中的每一章都专注于使用 jQuery UI 附带的特定小部件进行工作。在本章中，我们更感兴趣的是大局观。毕竟，您正在构建一个应用程序，而不是一个演示。因此，对于使用
    jQuery UI 的开发人员来说，重要的是不仅要意识到每个单独小部件在其自身上的工作方式，还要意识到它们在其环境中的行为方式，以及它们如何与其他小部件和框架交互。
- en: We'll also address the nuts-and-bolts of the framework in this chapter by building
    a widget from the ground up, with the help of the widget factory. With the generic
    widget machinery at your disposal, you could write a handful of widgets that have
    nothing to do with the default widgets. Although these custom widgets don't inherit
    much functionality, they behave like jQuery UI widgets, and that alone is worth
    the effort—cementing a layer of consistency into your application.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将通过使用小部件工厂从头开始构建一个小部件来解决框架的基本知识。通过通用小部件机制，您可以编写一些与默认小部件无关的小部件。尽管这些自定义小部件没有继承太多功能，但它们的行为类似于
    jQuery UI 小部件，仅这一点就值得付出努力——将一层一致性固化到您的应用程序中。
- en: Accordions to tabs, and back again
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从折叠到标签，再返回
- en: Both the accordion and the tabs widgets are containers. That is, their typical
    use inside the context of an application is to organize subcomponents. These subcomponents
    might be other widgets, or any other HTML element for that matter. So, both widgets
    fit the generic description of a container, that is, a widget with different sections.
    There are obviously subtleties to that description; for example, accordions don't
    support remote Ajax content. Also, the way users traverse the sections are quite
    different. Yet, they're essentially interchangeable. Why not introduce the ability
    to switch between the two widgets, especially during run time where the users
    can set their own preference and toggle between the two containers? It turns out
    that we can implement something like this. Let's look at how we would go about
    doing this. We need a bidirectional conversion between the two widgets. That way,
    the tabs widget can be transformed into an accordion widget, and vice-versa.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 折叠和标签小部件都是容器。也就是说，它们在应用程序的上下文中的典型用途是组织子组件。这些子组件可能是其他小部件，或者任何其他 HTML 元素。因此，这两个小部件符合容器的通用描述，即具有不同部分的小部件。显然，这个描述有一些微妙之处；例如，折叠不支持远程
    Ajax 内容。此外，用户遍历部分的方式也大不相同。但它们本质上是可以互换的。为什么不在两个小部件之间引入切换的能力，特别是在运行时，用户可以设置自己的偏好并在两个容器之间切换的情况下？事实证明，我们可以实现这样的东西。让我们看看我们将如何做到这一点。我们需要两个小部件之间的双向转换。这样，标签小部件可以转换为折叠小部件，反之亦然。
- en: How to do it...
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To implement the kind of transformation between two different widgets we''re
    talking about here, we''ll have to extend both the accordion and the tabs widget.
    We''ll add a new method to each of the widgets that converts the widget to its
    counterpart. Here is the HTML structure we''ll need to make this example happen:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现我们在这里讨论的两种不同小部件之间的转换，我们将不得不扩展折叠和标签小部件。我们将为每个小部件添加一个新方法，将小部件转换为其对应的小部件。这是我们需要使此示例发生的
    HTML 结构：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, we have two toggle buttons, an accordion `div` and a tabs `div`. The
    toggle buttons will morph their corresponding container widget, into another widget
    type. Here is the JavaScript code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有两个切换按钮，一个折叠 `div` 和一个标签 `div`。切换按钮将使其对应的容器小部件变形为另一种小部件类型。以下是 JavaScript
    代码：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'When the page first loads and all the DOM elements are ready, we create the
    toggle button widgets, an accordion widget, and a tabs widget. This is illustrated
    in the following screenshot:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当页面首次加载并且所有 DOM 元素都准备就绪时，我们创建切换按钮小部件、折叠小部件和标签小部件。如下截图所示：
- en: '![How it works...](img/2186OS_12_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![它的工作原理...](img/2186OS_12_01.jpg)'
- en: 'Now, clicking on the top toggle button will transform the accordion widget
    into a tabs widget. Also, the second toggle button will transform the tabs widget
    into an accordion. Here is the result of clicking on each of the toggle buttons
    once:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击顶部的切换按钮将把手风琴部件转换为标签部件。另外，第二个切换按钮将标签部件转换为手风琴。点击每个切换按钮一次的结果如下：
- en: '![How it works...](img/2186OS_12_02.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![它的运行原理...](img/2186OS_12_02.jpg)'
- en: The toggle buttons work by using jQuery's `next()`function to grab the next
    widget, either `#accordion` or `#tabs`, depending on the button clicked. This
    is then stored in the `$widget` variable because we access it several times. Firstly,
    we check if the widget is an accordion, and if so, we call the `tabs()` method
    on the accordion. Likewise, if `$widget` is tabs, we call the `accordion()` method
    to transform it. Notice that we're using the built-in widget selector that the
    widget factory creates for each widget in order to determine what kind of widget
    the element is. Also, notice that the namespace is `ab`, not `ui`, which is the
    recommended practice when writing your own widgets, or customizing existing widgets,
    as is the case here. Here, I've chosen my initials as the namespace. In practice,
    this would be a standard convention that somehow relates to the application.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 切换按钮的工作原理是使用jQuery的`next()`函数来获取下一个部件，无论是`#accordion`还是`#tabs`，具体取决于所点击的按钮。然后将其存储在`$widget`变量中，因为我们会多次访问它。首先，我们检查部件是否是手风琴，如果是，我们在手风琴上调用`tabs()`方法。同样地，如果`$widget`是标签，我们调用`accordion()`方法来转换它。请注意，我们正在使用内置的部件选择器，部件工厂为每个部件创建，以确定元素是什么类型的部件。另外，请注意，命名空间是`ab`，而不是`ui`，这是编写自己的部件或自定义现有部件时的推荐做法，就像这里一样。在这里，我选择了我的缩写作为命名空间。在实践中，这将是一个与应用程序相关的标准约定。
- en: Let's now turn our attention to the `tabs()` method we've added to the accordion
    widget. The essential job of this new method is to destroy the accordion widget,
    manipulate the DOM elements so as to take on a form that the tabs widget will
    recognize, and then to instantiate the tabs widget. So, this is what we do, we
    call the `destroy()` method first. Notice, however, that we still have access
    to some of the attributes of the accordion widget, such as `headers`. Destroying
    a widget is mainly concerned with removing any adornments introduced into the
    DOM as a result of creating the widget in the first place, in addition to removing
    the event handlers. It doesn't, at the JavaScript level, care much about destroying
    the widget object that we're working with here.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们把注意力转向我们已经添加到手风琴部件的`tabs()`方法。这个新方法的基本工作是销毁手风琴部件，操作DOM元素，使其呈现出标签部件将识别的形式，然后实例化标签部件。所以，我们首先调用`destroy()`方法。然而，请注意，我们仍然可以访问手风琴部件的一些属性，比如`headers`。销毁部件主要涉及删除任何由于首次创建部件而引入到DOM中的装饰，以及删除事件处理程序。在JavaScript级别上，销毁我们在这里使用的部件对象并不太关心。
- en: At this point, we have the `oldHeaders` variable, which points to the original
    accordion's `h3` elements. Next, we have `newHeaders`, which is an empty `ul`
    element. The `newHeaders` element is the starting point for the new elements the
    tab widget expects to find. Next, we have to build the `li` elements that point
    to the content panels of the tabs. For each header, we add a link to the `newHeaders`
    `ul`. But, we also have to update the panel ID with an `id` that the header links
    to. We first build an ID string using the position of the tab as well as the `uuid`
    of the widget itself. The uuid isn't strictly necessary; however, it's a good
    idea nonetheless to ensure unique tab IDs.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们有一个`oldHeaders`变量，它指向原始手风琴的`h3`元素。接下来，我们有`newHeaders`，它是一个空的`ul`元素。`newHeaders`元素是标签部件期望找到的新元素的起点。接下来，我们必须构建指向标签的内容面板的`li`元素。对于每个标题，我们向`newHeaders`
    `ul`添加一个链接。但是，我们还必须使用将标题链接到的`id`更新面板ID。我们首先使用选项卡的位置以及部件本身的`uuid`构建一个ID字符串。虽然uuid并不是必需的；然而，确保唯一的选项卡ID仍然是一个好主意。
- en: Lastly, we add the new headers to the element, and remove the old headers. At
    this point, we have enough to instantiate a tabs widget. And that's just what
    we do. Notice that we return the newly-created object, so that if it is referenced
    elsewhere in the code, it can be replaced by this method, for example, `myTabs
    = myAccordion.accordion( "tabs" )`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将新的标题添加到元素中，并删除旧的标题。此时，我们有足够的内容来实例化标签部件。而且我们确实这样做了。请注意，我们返回了新创建的对象，以便如果在代码的其他地方引用它，可以用此方法替换它，例如，`myTabs
    = myAccordion.accordion( "tabs" )`。
- en: The `accordion()` method we've added to the tabs widget follows the same principles
    applied in the `tabs()` method described above—we want to destroy the widget,
    manipulate the DOM, and create the accordion widget. To make this happen, we need
    to insert the `h3` header element before the corresponding content panel. We then
    remove the `tablist` element, and the tabs `ul`, followed by a call to instantiate
    and return the accordion widget.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加到标签小部件的 `accordion()` 方法遵循了上述 `tabs()` 方法中应用的相同原则——我们想要销毁小部件，操作 DOM，并创建折叠小部件。为了实现这一点，我们需要在相应的内容面板之前插入
    `h3` 标题元素。然后，我们删除 `tablist` 元素和标签 `ul`，然后调用实例化并返回折叠小部件。
- en: Building a custom widget from scratch
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从头开始构建自定义小部件
- en: The most powerful aspect of jQuery UI isn't the prebuilt widgets that ship with
    it, but rather, the machinery used to build those widgets. Each widget shares
    a common infrastructure called the widget factory, and this is exposed to developers
    using the framework. The widget factory provides a means for developers to define
    their own widgets. We've already glimpsed the widget factory in action throughout
    this book. We've been using it to extend the capabilities of any given widget.
    The focus of this section takes on a different perspective of the widget factory.
    That is, how can we use it to build our own widgets from the ground up?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery UI 最强大的部分并不是随附的预构建小部件，而是用于构建这些小部件的机制。每个小部件都共享一个称为小部件工厂的公共基础设施，并且该基础设施对开发人员使用该框架是可见的。小部件工厂提供了一种让开发人员定义自己的小部件的方式。我们在本书中已经多次看到小部件工厂的实际应用。我们一直在使用它来扩展任何给定小部件的功能。本节的重点是以不同的角度来看待小部件工厂。也就是说，我们如何利用它从零开始构建自己的小部件？
- en: 'Well, we don''t want to start with nothing, as that would defeat the whole
    purpose of the widget factory. Instead, the aim when building any widget is to
    utilize the generic capabilities that the base widget class makes available. In
    addition, there are some basic design principles that developers should try to
    stick with when they''re creating widgets. For example, your widget should perform
    clean up when destroyed, removing attributes, event handlers, and essentially
    leaving the element as you found it. Widgets should also provide a simple API,
    and it should be clear to the developers using your widget what it does, and more
    importantly, what it does not do. Let''s touch on some principles to keep in mind
    before you start, and while designing your widget:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，我们不想从零开始，因为那样会违背小部件工厂的整个目的。相反，构建任何小部件的目标是利用基础小部件类提供的通用功能。此外，开发人员在创建小部件时应该尽量遵循一些基本的设计原则。例如，您的小部件在销毁时应该进行清理，删除属性、事件处理程序，并基本上将元素恢复到原始状态。小部件还应该提供简单的
    API，并且对于使用您的小部件的开发人员来说，它应该清楚该小部件做什么，更重要的是，它不做什么。在开始之前和设计小部件时，请记住一些原则：
- en: '**Keep it simple**: With the latest version of jQuery UI, a number of the standard
    widgets have undergone major refactoring work in an effort to simplify their interfaces.
    Borrow from this lesson when designing your widgets and keep their responsibilities
    to a minimum. It can be tempting, during the implementation phase of the widget,
    to decide that you need to add another method to the API, perhaps several. Think
    long and hard before doing this, because making the API larger generally leads
    to a widget that is difficult to maintain and keep stable. And that is the whole
    idea behind widgets, a small modular component that is reliable, and can be used
    in a variety of contexts without blowing up. With that said, a widget that doesn''t
    meet the needs of the application isn''t of any value either.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保持简单**：随着 jQuery UI 的最新版本，一些标准小部件经历了重大的重构工作，以简化其界面。在设计您的小部件时，借鉴这个教训，并将其责任最小化。在实现小部件的过程中，可能会有添加另一个
    API 方法的冲动，甚至可能有几个。在这样做之前，请认真考虑，因为扩展 API 通常会导致难以维护和保持稳定的小部件。而这正是小部件背后的整个理念，一个小而可靠的模块化组件，可以在各种上下文中使用而不会出现问题。话虽如此，一个不满足应用程序需求的小部件也毫无价值。'
- en: '**Design for extensibility**: Building on the keep it simple principle is that
    of extensibility. Again, as we''ve seen throughout this book, extensibility is
    often key in giving the widget extra capabilities the application needs to do
    its job. These can be simple customizations, or a complete re-write of a method.
    Regardless, assume that your widget will be modified, and that it will have observers
    listening for events. In other words, a good widget will provide a reasonable
    level of granularity with regards to how functionality is distributed among the
    methods that realize it. Each method is an entry point for specialization, and
    so the potential entry points should be a conscious concern. Events triggered
    by the widget communicate the state of the widget to the outside world. So when
    the state of your widget changes, be sure to let everyone else know about it.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性设计**：在简洁保持原则的基础上构建的是可扩展性。同样，正如我们在本书中所见，可扩展性通常是赋予小部件额外功能以执行其工作所需的关键。这些可以是简单的自定义，也可以是方法的完全重写。无论如何，假设您的小部件将被修改，并且它将有观察者监听事件。换句话说，一个好的小部件将以合理的粒度提供功能在实现它的方法之间的分布。每个方法都是专门化的入口点，因此潜在的入口点应该是一个有意识的关注点。小部件触发的事件将小部件的状态传达给外界。因此，当您的小部件的状态发生变化时，请务必让其他人知道。'
- en: How to do it...
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Enough talk already—now, let's build a checklist widget. It really is as simple
    as it sounds. We'll base the widget on a `ul` element, which will transform each
    `li` element into a checklist item. The checklist won't just sit there by itself
    though; we'll add a few external components to interact with our widget. We'll
    want a button that adds a new checklist item, a button that removes an item, and
    a progressbar for tracking the progress of our list. The main user interaction
    with the widget itself is centered on checking and unchecking items.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 足够的说了，现在，让我们来构建一个检查表小部件。它真的就像听起来的那么简单。我们将基于一个`ul`元素构建小部件，该元素将每个`li`元素转换为检查表项。但是，检查表不会孤立存在；我们将添加一些外部组件来与我们的小部件进行交互。我们将需要一个按钮来添加新的检查表项，一个按钮来删除一个项目，以及一个用于跟踪我们列表进度的进度条。用户与小部件本身的主要交互集中在检查和取消检查项目上。
- en: 'Here is the HTML we''ll use in this example:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在本示例中将使用的HTML：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next, we'll add the CSS required by our checklist widget.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加我们的检查表小部件所需的CSS。
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Finally, we'll add our widget definition using the following JavaScript code.
    This code also creates the two button widgets and the progressbar widget used
    in this example.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用以下JavaScript代码添加我们的小部件定义。此代码还创建了本示例中使用的两个按钮小部件和进度条小部件。
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When you first load the page, the checklist widget, along with the other components
    on the page, should look something like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当您首次加载页面时，检查表组件以及页面上的其他组件应该看起来像这样：
- en: '![How to do it...](img/2186OS_12_03.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/2186OS_12_03.jpg)'
- en: You can see that these are the default checklist items as specified in the HTML
    structure. The hover state works as expected, but the progressbar is at 0\. This
    is because the checklist doesn't have any selected items. Let's check some items
    off, and add some more.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，这些是HTML结构中指定的默认检查表项。悬停状态按预期工作，但进度条为0。这是因为检查表没有任何选定的项目。让我们勾选一些项目，并添加一些项目。
- en: '![How to do it...](img/2186OS_12_04.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/2186OS_12_04.jpg)'
- en: You can see that the progress bar is updated each time an item is added or removed
    from the checklist, as well as when an individual item is checked or unchecked.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，每次添加或删除检查表项以及单独检查或取消检查一个项目时，进度条都会更新。
- en: How it works...
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Let's first discuss the HTML structure of the checklist widget along with the
    new CSS required to display it. We'll then divide the definition and instantiation
    of the widget into sections and conquer those. The HTML used in this example is
    divided into three main container `div` elements. The first element holds our
    add and remove item buttons. The second one is for the checklist widget, and the
    last one is for the progressbar. That is the general layout.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先讨论检查表小部件的HTML结构以及显示它所需的新CSS。然后，我们将将小部件的定义和实例化分成几个部分，并解决这些部分。此示例中使用的HTML分为三个主要容器`div`元素。第一个元素保存我们的添加和删除项目按钮。第二个是检查表小部件，最后一个是进度条。这是一般布局。
- en: The most important aspect of the HTML structure is the `#container` element,
    which is the foundation of our checklist widget. Each item is stored inside an
    `li` element. Notice that the text of the item is wrapped in an `a` element as
    well. This makes dealing with focusing the individual items, when the user is
    tabbing through the page elements, much simpler to deal with. The main styles
    of the checklist are controlled by the `ui-checklist` class. This class gets applied
    to the element when the widget is first created, and it performs some standard
    style manipulations for lists, like removing the bulleted images. Another thing
    we need to handle is the border spacing, which becomes relevant when the user
    hovers over an item, and `ui-state-hover` is added and removed. The `a` elements,
    wrapping the item text, don't need any text decoration since we're not using them
    as standard links. Finally, the `ui-checklist-checked` class is relevant to the
    state of an individual checklist item and visually marks the item as checked.
    It also serves as a query helper when we need to collect all checked items.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 结构的最重要方面是`#container`元素，它是我们清单小部件的基础。每个项目都存储在一个`li`元素内。请注意，项目的文本也包装在一个`a`元素中。这使得在用户通过页面元素时处理单个项目的焦点变得更加简单。清单的主要样式由`ui-checklist`类控制。这个类在小部件第一次创建时被应用于元素，并对列表执行一些标准样式操作，比如移除项目符号图片。我们需要处理的另一件事是边框间距，当用户悬停在项目上时，`ui-state-hover`被添加和移除。包装项目文本的`a`元素不需要任何文本装饰，因为我们不将它们用作标准链接。最后，`ui-checklist-checked`类与单个清单项目的状态相关，并在视觉上标记项目为已选中。它还在我们需要收集所有已选中项目时作为查询辅助工具。
- en: Let's now turn our attention to the widget definition, and how we're instantiating
    and using it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们把注意力转向小部件的定义，以及我们是如何实例化和使用它的。
- en: '**The options**: The first thing our widget defines are its options, each with
    a default value. Always make sure that any option you add to a widget has a default
    value, as we can never rely on one being supplied during the time of creation.
    The options we define here for our checklist widget are fairly simple, and will
    rarely be changed by the developer. For example, the items we look up will generally
    always be `li` elements. And, the classes we''ve defined here, that get applied
    to the widget itself, probably will never change. However, they need to be declared
    somewhere, and so we can hard code it, or put them somewhere the developer has
    access to. Think of options as attributes, or properties of the widget object.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选项**: 我们的小部件首先定义的是它的选项，每个选项都有一个默认值。始终确保您向小部件添加的任何选项都有一个默认值，因为我们永远不能指望在创建时提供一个选项。我们在这里为我们的清单小部件定义的选项非常简单，很少会被开发人员更改。例如，我们查找的项目通常总是`li`元素。而且，我们在这里定义的类，应用于小部件本身，可能永远不会更改。然而，它们需要在某个地方声明，所以我们可以硬编码它，或者将它们放在开发人员可以访问的地方。把选项想象成小部件对象的属性或属性。'
- en: '**The private methods**: By convention, the private methods, or methods that
    don''t make up part of the API visible to the user, are prefixed with an underscore.
    Our first private method is the `_getCreateEventData()` method. This is called
    internally by the base widget class when the create event for the widget is triggered.
    This method is a hook for allowing us to supply custom data to the create event
    handlers. All we''re doing here is passing an object that has the number of items
    stored in the items attribute, and the number of checked items stored in the checked
    attribute.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**私有方法**: 按照惯例，私有方法或不构成对用户可见的 API 的方法以下划线作为前缀。我们的第一个私有方法是`_getCreateEventData()`方法。当小部件的创建事件被触发时，此方法会被基础小部件类在内部调用。这个方法是一个钩子，允许我们向创建事件处理程序提供自定义数据。我们在这里做的一切就是传递一个对象，该对象具有存储在项目属性中的项目数，以及存储在已检查属性中的已检查项目数。'
- en: '**The create method**: The `_create()` method is probably the most common method
    for any widget, since it''s called by the widget factory as the widgets constructor.
    We''re using the `_super()` utility method to call the base widget constructor
    for us, which performs some boilerplate initialization work for us. Next, we apply
    the relevant widget CSS classes to the element using the `widgetClasses` option.
    Next, we use the `_on()` method to setup an event handler for the click event.
    Notice that we''re passing in a delegate selector after the event name`.ui-checklist-item`.
    The reason we''re doing this is because items can be added, and items can be removed
    from the checklist, and so it makes sense to use this approach rather than manually
    managing the click events for each item.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**create方法**：`_create()`方法可能是任何小部件的最常见方法，因为它是由小部件工厂作为小部件构造函数调用的。我们使用`_super()`实用方法为我们调用基础小部件构造函数，它为我们执行一些样板初始化工作。接下来，我们使用`widgetClasses`选项将相关的小部件CSS类应用于元素。然后，我们使用`_on()`方法为点击事件设置事件处理程序。请注意，在事件名后面我们传递了一个委托选择器`.ui-checklist-item`。我们这样做的原因是因为可以向清单中添加项目，也可以从清单中删除项目，因此使用这种方法比手动管理每个项目的点击事件更合理。'
- en: '**The destroy method**: The `_destroy()` method is essential, as previously
    mentioned, to performing clean up tasks. We use `_super()` here to call the base
    widget `_destroy()` method which will clean up any event handlers we''ve created
    using `_on()`. Then, we just need to remove any classes and attributes that we''ve
    added throughout the lifespan of the widget. The last of the private methods is
    the `_click()` method, the even handler bound to the click event when the widget
    was first created. The job of this method is to change the state of the clicked
    item, and we do this by calling the `check()` method, part of the API exposed
    to developers. We also want to prevent the default action of the link clicks here,
    because they have the potential to reload the page.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**destroy方法**：`_destroy()`方法是必不可少的，如前所述，用于执行清理任务。我们在这里使用`_super()`调用基础小部件`_destroy()`方法，该方法将清理我们使用`_on()`创建的任何事件处理程序。然后，我们只需要删除我们在小部件的生命周期中添加的任何类和属性。最后一个私有方法是`_click()`方法，这是当小部件首次创建时绑定到点击事件的事件处理程序。此方法的工作是更改所点击项目的状态，我们通过调用`check()`方法来实现这一点，该方法是向开发人员公开的API的一部分。我们还希望在这里阻止链接点击的默认操作，因为它们有可能重新加载页面。'
- en: '**The API**: In the spirit of keeping our widget simple, the exposed API consists
    of only two methods. The first one is the `refresh()` method, which is responsible
    for locating the items that make up our checklist. These are stored in the `items`
    attribute of the widget object, which is an example of something that isn''t exposed
    through the API. The `items` attribute is only used internally; however, if a
    developer were to extend our widget, their custom methods would be accessible,
    and perhaps even useful. The `refresh()` method changes the state of the widget
    when new items are found, and this is why it triggers the refreshed event. However,
    there is a corner case during which we don''t want to trigger this event, and
    that is when the widget is being instantiated for the first time. This is tracked
    in the `trigger` variable (if we haven''t stored any items yet, then it''s safe
    to assume that we''re creating, and not refreshing it). The reason we don''t want
    to collide with the create event is that this is very misleading for developers
    using the widget. We''re also using the `_hoverable()`, and `_focusable()` methods
    on each newly-found item. This is a standard widget pattern for items within a
    widget that the user interacts with.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API**：秉承保持小部件简单的精神，暴露的API仅包括两种方法。第一个是`refresh()`方法，它负责定位构成我们清单的项目。这些项目存储在小部件对象的`items`属性中，这是一个不通过API公开的示例。`items`属性仅在内部使用；然而，如果开发人员要扩展我们的小部件，他们的自定义方法将是可访问的，甚至可能很有用。`refresh()`方法在发现新项目时更改小部件的状态，这就是为什么它会触发刷新事件的原因。但是，在某些情况下，我们不希望触发此事件，即当第一次实例化小部件时。这在`trigger`变量中进行跟踪（如果我们尚未存储任何项目，则可以安全地假定我们正在创建而不是刷新）。我们不希望与创建事件冲突的原因是，这对使用小部件的开发人员非常具有误导性。我们还在每个新发现的项目上使用了`_hoverable()`和`_focusable()`方法。这是小部件内用户与之交互的项目的标准模式。'
- en: '**The check method**: The `check()` method is the other half of the checklist
    API, and it too changes the state of the widget. It fires a changed event, which
    includes data about the item count and the checked count, same as the created
    event data. You''ll notice that this method ensures the handling of the appropriate
    `aria` attributes, as do the standard jQuery UI widgets. The `aria` standard promotes
    accessibility, which is why the jQuery UI framework uses it, and our widget shouldn''t
    be any different. Finally, it is the job of this method to toggle the class of
    this item, using the value stored in the `checkedClass` option.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**check方法**：`check()`方法是检查清单API的另一半，它也会更改小部件的状态。它触发一个changed事件，其中包含有关项目计数和已检查计数的数据，与创建事件数据相同。您会注意到，此方法确保处理适当的`aria`属性，就像标准的jQuery
    UI小部件一样。`aria`标准促进了可访问性，这就是为什么jQuery UI框架使用它的原因，而我们的小部件也不应该有所不同。最后，该方法的工作是使用存储在`checkedClass`选项中的值切换此项目的类。'
- en: '**The main application**: When the page loads, the first thing we do is create
    our two button widgets: `#add` and `#remove`. The `#add` button, when clicked,
    adds a new item DOM element to the checklist. It then uses the `refresh()` method
    to update the state of the widget, as well as trigger any events. Likewise, the
    `#remove` button removes a DOM element, and calls the `refresh()` method, triggering
    any state change behavior. The progressbar widget is instantiated without any
    options, as it knows nothing about our checklist widget.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主要应用程序**：页面加载时，我们首先做的是创建两个按钮小部件：`#add`和`#remove`。点击`#add`按钮时，会将新项目的DOM元素添加到检查清单中。然后，它使用`refresh()`方法更新小部件的状态，并触发任何事件。同样，`#remove`按钮会移除一个DOM元素，并调用`refresh()`方法，触发任何状态更改行为。进度条小部件在不包含任何选项的情况下实例化，因为它对我们的检查清单小部件一无所知。'
- en: Lastly, our checklist widget is created with three options. These are all event
    handlers, and they all share the same responsibility—update the `#progressbar`
    widget. For example, the widget is first created, and the progressbar is updated
    with the items found in the DOM (nothing has been checked yet). The `refreshed`
    event is triggered when new items are added or removed from the list; we want
    to update the progressbar here too. The `checked` event handler fires anytime
    the user checks or unchecks an item, and here, we're only interested in updating
    the value for the progressbar since the total number of items is the same.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的检查清单小部件是用三个选项创建的。这些都是事件处理程序，它们都承担着相同的责任——更新`#progressbar`小部件。例如，小部件首先被创建，然后进度条根据在DOM中找到的项目进行更新（尚未检查任何项目）。当从列表中添加或删除新项目时，将触发`refreshed`事件；我们也希望在这里更新进度条。每当用户选中或取消选中项目时，都会触发`checked`事件处理程序，在这里，我们只关心更新进度条的值，因为项目的总数是相同的。
- en: Building an observer widget
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建观察者小部件
- en: The typical approach to dealing with events triggered by jQuery UI widgets is
    to bind an event handler to that event name, passed directly into the constructor.
    It's the typical approach because it's easy to do, and it generally solves a specific
    problem we're having. For example, suppose that when a section of our accordion
    widget is expanded, we would like to update another DOM element. To do this, assign
    an event handler function to the activate event when the accordion is constructed.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 处理由jQuery UI小部件触发的事件的典型方法是将事件处理程序绑定到该事件名称，直接传递到构造函数中。这是典型的方法，因为它易于做到，并且通常解决了我们遇到的特定问题。例如，假设当我们的手风琴小部件的某个部分展开时，我们希望更新另一个DOM元素。为此，在构造手风琴时将事件处理程序函数分配给激活事件。
- en: This approach works well for small, single purpose jobs that apply to a single
    instance of a given widget. However, most meaningful applications have many widgets,
    all triggering their own events. The widget factory prefixes each event with the
    name of the widget, which generally means that even outside of the widget context
    we know what we're working with. This is especially helpful when we want to bind
    event handlers to widget events, long after the widget has been created.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法非常适用于小型、单一用途的作业，适用于给定小部件的单个实例。然而，大多数有意义的应用程序有许多小部件，都触发着自己的事件。小部件工厂用小部件的名称前缀每个事件，这通常意味着即使在小部件上下文之外，我们也知道我们在处理什么。当我们想要将事件处理程序绑定到小部件事件时，长时间之后，小部件已经被创建了，这一点尤其有帮助。
- en: Let's build an **observer** widget that will help us visualize all the potential
    widget events taking place in an application. The observer widget is capable of
    binding to a single widget, to a group of widgets, or the entire document. We'll
    look at the latter case, where the observer will even pick up events for widgets
    created in the future.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个**观察者**小部件，帮助我们可视化应用程序中发生的所有潜在小部件事件。观察者小部件能够绑定到单个小部件、一组小部件或整个文档。我们将看看后一种情况，在那里观察者甚至会捕获未来创建的小部件的事件。
- en: How to do it...
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s take a look at the CSS styles used by the observer widget first:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下观察者小部件使用的 CSS 样式：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, let's look at the HTML used to create a basic page with a few sample widgets
    on it. These widgets will trigger the events we're trying to pick up with our
    observer.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下用于创建一个基本页面和几个示例小部件的 HTML。这些小部件将触发我们试图用观察者捕获的事件。
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, here is what the implementation of the widget looks like, along with
    the four widget instances used on this page:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是小部件的实现方式，以及在此页面上使用的四个小部件实例：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Looking at this page in the browser, the basic widget layout looks something
    along the lines of the following screenshot:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中查看此页面时，基本小部件布局如下截图所示：
- en: '![How to do it...](img/2186OS_12_05.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/2186OS_12_05.jpg)'
- en: Even simply creating these widgets will trigger events. For example, when the
    page first loads, you'll see that the dialog created by the observer widget is
    already populated with events.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至只是创建这些小部件也会触发事件。例如，当页面首次加载时，您会看到观察者小部件创建的对话框已经填充了事件。
- en: '![How to do it...](img/2186OS_12_06.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/2186OS_12_06.jpg)'
- en: How it works...
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The observable widget, in this example, is applied to the `document` element.
    This means that it will pick up any widget events that bubble up to that level.
    The observable widget defines an `observables` option, an array of widgets whose
    events we'd like to listen to. In this case, for the sake of brevity, we're only
    including three widgets. This can always be extended, as needed by the application,
    since it is an option.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，可观察小部件应用于`document`元素。这意味着它将捕获冒泡到该级别的任何小部件事件。可观察小部件定义了一个`observables`选项，一个我们想要监听其事件的小部件数组。在这种情况下，为了简洁起见，我们只包括了三个小部件。这可以根据应用程序的需要随时扩展，因为它是一个选项。
- en: The purpose of the `_getEvents()` method is to read the `observables` option
    and to build an object that we can use to bind these events to the `_event()`
    method. Notice that we're automatically adding the widget prefix value to the
    event name here—this is available in the `widgetEventPrefix` property of the widget
    prototype. The job of the `_create()` method is to insert a `div` element into
    the `body` element, which then becomes a dialog widget. We position it in the
    top-right of the page so as to get out of the user's way. Finally, we start listening
    for events using the object returned by `_getEvents()` using the `_on()` method.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`_getEvents()` 方法的目的是读取`observables`选项并构建一个我们可以使用它来将这些事件绑定到`_event()`方法的对象。请注意，我们在这里自动将小部件前缀值添加到事件名称——这在小部件原型的`widgetEventPrefix`属性中是可用的。`_create()`方法的工作是将`div`元素插入到`body`元素中，然后它成为一个对话框小部件。我们将其定位在页面的右上角，以便不妨碍用户。最后，我们使用由`_getEvents()`返回的对象使用`_on()`方法开始监听事件。'
- en: The `_event()` method is the single callback used anytime one of the widget
    events we're listening to is fired. It simply logs the event to the observer dialog.
    It also logs the time of the event; so, this tool is useful for experimenting
    with any jQuery UI application, large or small, since it can highlight which events
    actually take place, along with their orderings. The widget also takes care to
    destroy the dialog widget it created earlier too.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`_event()` 方法是我们监听的任何小部件事件触发时使用的单个回调函数。它简单地将事件记录到观察者对话框中。它还记录事件的时间；因此，这个工具对于尝试任何
    jQuery UI 应用程序都是有用的，无论是大还是小，因为它可以突出显示实际发生的事件以及它们的顺序。该小部件还负责销毁它之前创建的对话框小部件。'
- en: Using widgets with Backbone applications
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Backbone 应用程序中使用小部件
- en: With the seemingly endless variations of JavaScript environments you may find
    yourself working in, it's best to embrace the fact that not everything is done
    the jQuery UI way. If you find yourself on a project where you're just itching
    to use jQuery UI widgets, because the use cases are plentiful, you'll have to
    take the time necessary in understanding the consequences of jQuery UI mingling
    with another framework.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 JavaScript 环境的变化多端，您可能会发现自己在不同的环境中工作，最好接受这一事实，不是所有事情都是按照 jQuery UI 的方式完成的。如果您发现自己在一个项目中渴望使用
    jQuery UI 小部件，因为使用案例很多，那么您将不得不花费必要的时间来理解 jQuery UI 与另一个框架混合的后果。
- en: It's generally ill-advised for any developer to mix completely different widget
    frameworks together, so hopefully that is something easily avoided. You'll of
    course have to work other homebrew HTML and CSS concoctions, but this is typical.
    It is not so bad, as you can control it (not easily done with other open source
    frameworks). So, if not other widget frameworks, what other frameworks might we
    have to consider working with?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何开发人员来说，将完全不同的小部件框架混合在一起通常是不明智的，因此希望这是可以轻松避免的事情。当然，您必须处理其他自制的 HTML 和 CSS
    组合，但这很正常。这并不是太糟糕，因为您可以控制它（其他开源框架很难做到）。那么，如果不是其他小部件框架，我们可能要考虑使用哪些其他框架？
- en: '**Backbone** is a general framework that builds on the lower-level `underscore.js`
    utility library, for adding structure to web application clients. You''ll find
    concepts such as models, collections, and views in a Backbone application. A full
    treatment of the Backbone library is way beyond the scope of this book. But, it''s
    helpful to think of Backbone as the application scaffolding, the part that doesn''t
    change. It''ll run just the same with or without jQuery UI widgets. But, since
    jQuery UI is what we''re interested in working with, let''s build ourselves a
    little Backbone application that uses jQuery UI widgets.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**Backbone** 是一个通用框架，它基于较低级别的 `underscore.js` 实用库，用于为 Web 应用程序客户端添加结构。在 Backbone
    应用程序中，您会找到模型、集合和视图等概念。对 Backbone 库的全面介绍远远超出了本书的范围。但是，将 Backbone 视为应用程序的脚手架很有帮助，这部分不会改变。无论是否使用
    jQuery UI 小部件，它都会以相同的方式运行。但是，由于我们感兴趣的是使用 jQuery UI，让我们构建一个使用 jQuery UI 小部件的小型
    Backbone 应用程序。'
- en: How to do it...
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: The goal of the application is to display an autocomplete widget, where the
    user can filter programming language names. When a selection is made, some details
    about the language are displayed, including a delete button, which deletes the
    language from the collection. Simple, right? Let's get into it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的目标是显示一个自动完成小部件，用户可以过滤编程语言名称。当进行选择时，会显示有关该语言的一些详细信息，包括一个删除按钮，该按钮从集合中删除语言。简单吧？让我们开始吧。
- en: In the page header, we'll be doing something different—including a template.
    Templates are just strings of text, rendered by Backbone views. We'll give it
    a type of `text/template`, so the browser will not try to interpret it as something
    other than a template (JavaScript code, for instance). It has an `id`, so we can
    reference the template text later when it's time to render the template.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面页眉中，我们将做一些不同的事情——包括一个模板。模板只是一串文本，由 Backbone 视图渲染。我们将其类型设为 `text/template`，这样浏览器就不会将其解释为模板之外的东西（比如
    JavaScript 代码）。它有一个 `id`，这样在渲染模板时我们可以稍后引用模板文本。
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Next, the minimal CSS used by this UI—simple font and layout adjustments.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，是此 UI 使用的最小 CSS——简单的字体和布局调整。
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Next, we have the actual markup used by the user interface. Notice how minimal
    the `detail` class `div` is. That's because it's simply a holder for the template,
    rendered by the view, as we'll see in a moment.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有用户界面使用的实际标记。请注意 `detail` 类 `div` 是多么简洁。这是因为它只是一个模板的容器，由视图渲染，我们马上就会看到。
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Finally, we have the actual Backbone application that uses the autocomplete
    and button jQuery UI widgets.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有实际使用自动完成和按钮 jQuery UI 小部件的 Backbone 应用程序。
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For brevity, we're cutting out the bulk of the code listing here, trying to
    just show the essentials. The fully-operational Backbone code is available for
    download, along with all the other samples in this book.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，在此处我们将削减代码清单的大部分内容，试图只显示必需的内容。完全运作的 Backbone 代码可供下载，以及本书中的所有其他示例。
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Running this example will present the user with an autocomplete `input` element.
    The details of the chosen language are shown in the following screenshot:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此示例将向用户显示一个自动完成 `input` 元素。所选语言的详细信息如下截图所示：
- en: '![How to do it...](img/2186OS_12_07.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/2186OS_12_07.jpg)'
- en: How it works...
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Our entire Backbone application is declared within the document ready callback
    function. Once that is done, everything is event-based. Let''s step through the
    application components. The first thing you''ll notice is that we''ve declared
    our variables up top, and given them brief categorical explanations. This is often
    helpful when we''re sharing the same namespace with more than a handful of variables.
    The categories are as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们整个 Backbone 应用程序都在文档就绪的回调函数中声明。一旦完成，一切都是基于事件的。让我们逐步了解应用程序组件。您将注意到的第一件事是，我们在顶部声明了变量，并为它们提供了简要的分类解释。当我们与超过一小撮的变量共享相同的命名空间时，这通常是有帮助的。类别如下：
- en: '**Model and collection classes**: The classes used by our application to define
    the data model.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型和集合类**：我们应用程序中用于定义数据模型的类。'
- en: '**View classes**: Classes used by our application to provide the user with
    different views of the data model.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图类**：我们应用程序中用于为用户提供数据模型不同视图的类。'
- en: '**Application router**: A single controller-like class that manipulates the
    browser address, and executes relevant functionality when the path changes.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序路由器**：一个类似于控制器的单个类，用于操作浏览器地址，并在路径更改时执行相关功能。'
- en: '**Collection instance**: A collection instance represents the application data
    – a collection of model instances.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集合实例**：集合实例代表应用程序数据 - 一组模型实例。'
- en: '**Application and view instances**: The single application, along with the
    various views used by that application to present data.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序和视图实例**：单个应用程序以及该应用程序用于呈现数据的各种视图。'
- en: With that in mind, let's now dive into the specifics of how each Backbone class
    works. The application has only one model class, `Language`. We can see here that
    the `Language` declaration defines some default values for the attributes once
    instantiated. Next, the `LanguageCollection` class is an extension of the Backbone
    Collection class. This is where all our `Language` instances go. Notice that we're
    specifying the model property to point to the `Language` class. Since we have
    no RESTful API, we have to tell the collection that any synchronization actions
    should be carried out locally. We have to include the local storage plugin for
    Backbone in order to make this happen. This is actually an ideal way to bootstrap
    UI development before the real backend is completely fleshed out.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于此，请让我们现在深入了解每个 Backbone 类的工作原理。应用程序只有一个模型类，即`Language`。我们在这里可以看到，`Language`声明在实例化时为属性定义了一些默认值。接下来，`LanguageCollection`类是
    Backbone Collection 类的扩展。这是所有我们的`Language`实例的地方。请注意，我们正在指定模型属性指向`Language`类。由于我们没有
    RESTful API，我们必须告诉集合，任何同步操作都应在本地执行。我们必须在 Backbone 中包含本地存储插件，以使此操作生效。这实际上是在真正的后端完全成形之前启动
    UI 开发的理想方式。
- en: Next, we have our first view class, `AutocompleteView`, which is specific to
    the autocomplete jQuery UI widget. We've named it as such because we've done our
    best here to make it generic enough that it could be used with another autocomplete
    widget. We do have some language specifics hard-coded in the view class, but these
    are trivial to improve upon should the need arise. The first property defined
    in this class is the `events` object. These are mostly related to the autocomplete
    widget events. Each callback event handler is defined as a view method below.
    The `initialize()` method is the view constructor, and it is here that we call
    `delegateEvents()` to activate our events handlers for current elements, as well
    as future elements. The constructor then creates the autocomplete widget, and
    listens to its connection for destroy events.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有我们的第一个视图类，`AutocompleteView`，它专门针对自动完成 jQuery UI 小部件。我们将其命名为这样是因为我们在这里尽力使其足够通用，以便与另一个自动完成小部件一起使用。我们在视图类中有一些语言特定的硬编码内容，但这些内容如果有需要的话可以轻松改进。在这个类中定义的第一个属性是`events`对象。这些大多与自动完成小部件事件相关。每个回调事件处理程序在下面被定义为一个视图方法。`initialize()`方法是视图构造函数，在这里我们调用`delegateEvents()`来为当前元素以及未来元素激活我们的事件处理程序。然后构造函数创建自动完成小部件，并监听其连接以获取销毁事件。
- en: The `autocompleteCreate()` method is fired after the autocomplete widget is
    created, and assigns the `source` option of the widget. This is a proxy to the
    `autocompleteSource` method of this view. The `autocompleteSelect` method fires
    when the user selects an item, and navigates to the appropriate route. The `autocompleteChange()`
    method is fired when the autocomplete widget loses focus and the item is different.
    We do this to update the path if the user has removed his/her previous selection.
    The `keyup()` handler exists to handle the route change when the user has removed
    their selection, but hasn't yet blurred the autocomplete focus. Lastly, the `autocompleteSearch()`
    method is how the autocomplete widget is populated with items when the user starts
    typing. First, we perform a filter, using the underscore `filter()` method on
    the collection, then we map using the underscore `map()` method on the collection.
    The mapping is necessary to return a format the autocomplete widget expects.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`autocompleteCreate()`方法在创建自动完成小部件后触发，并将小部件的`source`选项分配给小部件。这是对此视图的`autocompleteSource`方法的代理。`autocompleteSelect`方法在用户选择项目并导航到适当路由时触发。`autocompleteChange()`方法在自动完成小部件失去焦点并且项目不同的情况下触发。我们这样做是为了在用户删除其先前选择但尚未模糊自动完成焦点时更新路径。最后，`autocompleteSearch()`方法是用户开始输入时自动完成小部件填充项目的方法。首先，我们使用集合上的underscore
    `filter()`方法执行过滤，然后我们使用集合上的underscore `map()`方法进行映射。映射是必要的以返回自动完成小部件期望的格式。'
- en: The next crucial piece of our application is the `LanguageView` class, responsible
    for rendering the programming language details. Like the previous view, this one
    sets up event handlers using the `events` property. We're also using the `#template-detail`
    text mentioned earlier, to compile the template rendered by this view using the
    underscore template machinery. In the constructor, we're listing some events on
    the collection of this view. One event to take note of is the `change:selected`
    event. This will only fire when the `selected` attribute changes, which is good,
    because that's all we're interested in.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的下一个关键部分是`LanguageView`类，负责渲染编程语言的详细信息。和之前的视图一样，这个视图使用`events`属性设置事件处理程序。我们还在构造函数中列出了该视图的集合上的一些事件。需要注意的一个事件是`change:selected`事件。这只有在`selected`属性更改时才会触发，这很好，因为这是我们感兴趣的。
- en: The `render()` method is responsible for rendering the template, but only if
    the model in question is actually selected. Once rendered, we can instantiate
    the button widget used by this view. However, take note that the event handler
    isn't bound again for the click event since that was delegated when the view was
    first created.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`render()`方法负责渲染模板，但仅在实际选择了相应的模型时才执行。一旦渲染完成，我们就可以实例化此视图使用的按钮小部件。但是，请注意，由于在首次创建视图时已经委托了单击事件处理程序，因此不会再次绑定事件处理程序。'
- en: The `AppRouter` class is the application controller in that it is responsible
    for reacting to changes in the URL path. The `routeLang()` method responds to
    a specific language and marks it as selected. The `routeDefault()` method handles
    all other requests. Its only job is to make sure that no languages are marked
    as selected, and as a side effect, any previously-selected languages will be removed
    from the UI since `LanguageView` is listening for changes in the `selected` attribute.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppRouter`类是应用程序控制器，因为它负责对URL路径的更改做出反应。`routeLang()`方法响应特定语言并将其标记为选定。`routeDefault()`方法处理所有其他请求。它的唯一工作是确保没有语言被标记为选定，并且作为副作用，任何先前选定的语言都将从UI中移除，因为`LanguageView`正在监听`selected`属性的更改。'
- en: Finally, we create instances of our model in the collection instance, and then,
    our views and the application router.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在集合实例中创建我们模型的实例，然后创建我们的视图和应用程序路由器。
