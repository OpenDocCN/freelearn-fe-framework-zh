- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: React Hooks
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React Hooks
- en: React Hooks have revolutionized the way we write React applications, allowing
    us to use functional components instead of class components, and making coding
    faster and more efficient. Since their introduction in React 16.8, Hooks have
    become an essential part of React development and have greatly improved the performance
    of our applications. With Hooks, we can manage the state, handle side effects,
    and reuse code in a more concise and readable way. In the next chapter, we will
    explore the different types of Hooks and how to use them to enhance our React
    applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: React Hooks 已经彻底改变了我们编写 React 应用程序的方式，允许我们使用函数组件而不是类组件，使编码更快、更高效。自从它们在 React
    16.8 中引入以来，Hooks 已经成为 React 开发的一个基本组成部分，并且大大提高了我们应用程序的性能。使用 Hooks，我们可以以更简洁、更易读的方式管理状态、处理副作用和重用代码。在下一章中，我们将探讨不同类型的
    Hooks 以及如何使用它们来增强我们的 React 应用程序。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The new React Hooks and how to use them
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的 React Hooks 及其使用方法
- en: The rules of the Hooks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hooks 的规则
- en: How to migrate a class component to React Hooks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将类组件迁移到 React Hooks
- en: Understanding the component life cycle with Hooks and effects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Hooks 和 effects 理解组件生命周期
- en: How to fetch data with Hooks
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Hooks 获取数据
- en: How to memoize components, values, and functions with `memo`, `useMemo`, and
    `useCallback`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 `memo`、`useMemo` 和 `useCallback` 来缓存组件、值和函数
- en: How to implement `useReducer`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现 `useReducer`
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete this chapter, you will require the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章，你需要以下内容：
- en: Node.js 19+
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 19+
- en: Visual Studio Code
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code
- en: You can find the code for this chapter in the book’s GitHub repository at [https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter08](https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter08).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的 GitHub 仓库中找到本章的代码：[https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter08](https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter08)。
- en: Introducing React Hooks
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 React Hooks
- en: React Hooks are a new addition to **React 16.8**. They let you use state and
    other React features without writing a React class component. React Hooks are
    also backward-compatible, which means they do not contain any breaking changes
    or not replace your knowledge of React concepts. Over the course of this chapter,
    we will see an overview of Hooks for experienced React users, and we are also
    going to learn about some of the most common React Hooks such as `useState`, `useEffect`,
    `useMemo`, `useCallback`, and `memo`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: React Hooks 是 React 16.8 的新增功能。它们允许你使用状态和其他 React 功能，而无需编写 React 类组件。React Hooks
    也是向后兼容的，这意味着它们不包含任何破坏性变更，也不会取代你对 React 概念的了解。在本章的整个过程中，我们将为经验丰富的 React 用户概述 Hooks，同时我们还将学习一些最常用的
    React Hooks，例如 `useState`、`useEffect`、`useMemo`、`useCallback` 和 `memo`。
- en: No breaking changes
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 没有破坏性变更
- en: In the context of React development, it’s a common misconception that the introduction
    of React Hooks has made class components obsolete. However, this is not true,
    as there are no plans to remove classes from React. The Hooks API does not replace
    your understanding of React concepts, but rather offers a more streamlined approach
    to working with those concepts, such as props, states, context, refs, and life
    cycles, which you are already familiar with.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 开发的背景下，一个常见的误解是 React Hooks 的引入使得类组件变得过时。然而，这并不正确，因为 React 没有计划从 React
    中移除类。Hooks API 并没有取代你对 React 概念的理解，而是提供了一个更流畅的方式来处理这些概念，例如 props、states、context、refs
    和生命周期，这些你已经是熟悉的。
- en: Using the State Hook
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 State Hook
- en: In old React code, we used `this.setState` to use the component state. Now we
    will use the `useState` hook to do this.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧的 React 代码中，我们使用 `this.setState` 来使用组件状态。现在我们将使用 `useState` Hook 来完成这项工作。
- en: 'First, you need to extract the `useState` Hook from React:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要从 React 中提取 `useState` Hook：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Since React 17, the `React` object is no longer required to render JSX code.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 自 React 17 以来，不再需要 `React` 对象来渲染 JSX 代码。
- en: 'Then, you need to declare the state you want to use by defining the state and
    the setter for this specific state:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你需要通过定义状态和该特定状态的设置器来声明你想要使用的状态：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, we are declaring the counter state with the `setCounter` setter
    and we are specifying that we will only accept numbers, and finally, we are setting
    the initial value to zero.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们使用 `setCounter` 设置器声明了计数器状态，并指定我们只接受数字，最后，我们将初始值设置为零。
- en: 'In order to test our state, we need to create a method that will be triggered
    by the `onClick` event:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的状态，我们需要创建一个方法，该方法将由`onClick`事件触发：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, we can render the `counter` state and some buttons to increase or
    decrease the counter state:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以渲染`counter`状态和一些按钮来增加或减少计数器状态：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you click on the **+ Add** button once, you should see **1** for **Counter**:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击**+ 添加**按钮一次，你应该看到**1**个**计数器**：
- en: '![](img/B18414_08_01.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18414_08_01.png)'
- en: 'Figure 8.1: Counter 1'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：计数器1
- en: 'And if you click the **- Subtract** button twice, then you should see **-1**
    for **Counter**:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击**- 减少两次**按钮，那么你应该看到**-1**个**计数器**：
- en: '![](img/B18414_08_02.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18414_08_02.png)'
- en: 'Figure 8.2: Counter -1'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：计数器-1
- en: As you can see, the `useState` Hook is a game changer in React and makes it
    very easy to handle the state in a functional component.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`useState` Hook是React的一个变革者，使得在函数组件中处理状态变得非常容易。
- en: After appreciating how the `useState` Hook has revolutionized state management
    in functional components within React, we are now ready to delve deeper into the
    nuances of Hooks. The following section will discuss the essential *rules of Hooks*
    that govern their usage in React applications.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在欣赏了`useState` Hook如何彻底改变了React中函数组件的状态管理之后，我们现在准备深入了解Hooks的细微差别。下一节将讨论控制React应用程序中Hooks使用的必要*Hooks规则*。
- en: Rules of Hooks
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hooks规则
- en: 'React Hooks are basically JavaScript functions, but there are two rules that
    you need to follow in order to use them. React provides a linter plugin to enforce
    those rules for you, which you can install by running the following command:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: React Hooks基本上是JavaScript函数，但你需要遵循两条规则才能使用它们。React提供了一个linter插件来自动执行这些规则，你可以通过运行以下命令来安装：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Let’s look at these two rules.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这两条规则。
- en: 'Rule 1: Only call Hooks at the top level'
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 规则1：只从顶层调用Hooks
- en: To ensure the proper functioning of React Hooks, it is important to avoid calling
    them inside loops, conditions, or nested functions. Instead, it is recommended
    to always use Hooks at the top level of your React function. This practice ensures
    that Hooks are called in the same order every time a component is rendered, allowing
    React to correctly preserve the state of Hooks between multiple `useState` and
    `useEffect` calls. Following this rule will help you write more efficient and
    maintainable code with React Hooks.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保React Hooks的正常工作，重要的是避免在循环、条件或嵌套函数中调用它们。相反，建议始终在React函数的最高级别使用Hooks。这种做法确保每次组件渲染时Hooks的调用顺序相同，从而使React能够正确地保留多个`useState`和`useEffect`调用之间的Hooks状态。遵循此规则将帮助你用React
    Hooks编写更高效、更易于维护的代码。
- en: 'Rule 2: Only call Hooks from React functions'
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 规则2：只从React函数中调用Hooks
- en: To ensure that all stateful logic in a component is clearly visible from its
    source code, avoid calling Hooks from regular JavaScript functions. Instead, use
    Hooks in React function components or custom Hooks (which we’ll learn about in
    the next section). By following this practice, you can ensure that all stateful
    logic is centralized and easily understandable.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保组件中所有有状态逻辑在源代码中清晰可见，避免从常规JavaScript函数中调用Hooks。相反，在React函数组件或自定义Hooks（我们将在下一节中学习）中使用Hooks。通过遵循这种做法，你可以确保所有有状态逻辑都集中且易于理解。
- en: In the next section, we will learn how to migrate a class component to use the
    new React Hooks.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何将类组件迁移到使用新的React Hooks。
- en: Migrating a class component to React Hooks
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将类组件迁移到React Hooks
- en: Let’s transform code that is currently using class components and is also using
    some life cycle methods. In this example, we are fetching the issues from a GitHub
    repository and listing them.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将当前使用类组件并使用一些生命周期方法的代码进行转换。在这个例子中，我们从GitHub仓库获取问题并列出它们。
- en: 'For this example, you will need to install `axios` to perform the fetch:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，你需要安装`axios`来执行获取操作：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is the class component version:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是类组件版本：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you render this component, you should see something like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你渲染这个组件，你应该看到类似以下的内容：
- en: '![](img/B18414_08_03.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18414_08_03.png)'
- en: 'Figure 8.3: ContentPI Issues'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：ContentPI问题
- en: 'Now, let’s transform our code into a functional component using React Hooks.
    The first thing we need to do is to import some React functions and types:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用React Hooks将我们的代码转换成一个函数组件。我们需要做的第一件事是导入一些React函数和类型：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now we can remove the `Props` and `State` types we created previously and just
    leave the `Issue` type:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以移除之前创建的`Props`和`State`类型，只留下`Issue`类型：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After this, you can change the class definition to use a functional component:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以将类定义更改为使用函数组件：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `FC` type is used to define a **functional component** in React. If you
    need to pass some props to the component, you can pass them like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`FC` 类型用于在 React 中定义 **函数组件**。如果你需要向组件传递一些属性，你可以这样传递：'
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The next thing we need to do is to replace our constructor and our state definition
    by using the `useState` Hook:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要用 `useState` Hook 来替换我们的构造函数和状态定义：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We have used the life cycle method called `componentDidMount` before, which
    is executed when the component is mounted and is going to run just once. The new
    React Hook, called `useEffect`, will now handle all the life cycle methods using
    different syntax for each one, but for now, let’s see how we can get the same
    *effect* of `componentDidMount` in our new functional component:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前使用过名为 `componentDidMount` 的生命周期方法，它在组件挂载时执行，并且只运行一次。新的 React Hook，称为 `useEffect`，现在将使用不同的语法处理所有生命周期方法，但让我们现在看看我们如何在新的函数组件中实现与
    `componentDidMount` 相同的 *effect*：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And finally, we just render our JSX code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们只需渲染我们的 JSX 代码：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, the new Hooks help us to simplify our code a lot and makes more
    sense. Also, we reduced our code by 10 lines (the class component code has 53
    lines, and the functional component has 43 lines).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，新的 Hooks 有助于我们极大地简化代码，并且更有意义。此外，我们还减少了 10 行代码（类组件代码有 53 行，函数组件有 43 行）。
- en: Now that we have seen the transformative power of new Hooks in streamlining
    our code and reducing verbosity, let’s shift our focus to another foundational
    concept in React. In the next section, we will delve into the differences between
    component life cycle methods used in class components and the innovative React
    effects.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了新的 Hooks 在简化我们的代码和减少冗余方面的变革力量，让我们将注意力转向 React 中的另一个基础概念。在下一节中，我们将深入了解在类组件中使用的组件生命周期方法和创新
    React effects 之间的区别。
- en: Understanding React effects
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 React 的 effects
- en: In this section, we will learn the difference between the component life cycle
    methods that we used in class components and the new React effects. Even if you
    have read in other places that they are the same, just with a different syntax,
    this is not correct.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习我们在类组件中使用的组件生命周期方法和新的 React effects 之间的区别。即使你在其他地方读到它们是相同的，只是语法不同，这也是不正确的。
- en: Understanding useEffect
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 useEffect
- en: 'When you work with `useEffect`, you need to *think in terms of effects*. If
    you want to perform the equivalent method of `componentDidMount` using `useEffect`,
    you can do the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `useEffect` 时，你需要 *从 effects 的角度思考*。如果你想使用 `useEffect` 来执行与 `componentDidMount`
    相当的方法，你可以这样做：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first parameter is the callback of the effect that you want to execute,
    and the second parameter is the dependencies array. If you pass an empty array
    (`[]`) to the dependencies, the state and props will have their original initial
    values.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是你想要执行的效果的回调函数，第二个参数是依赖项数组。如果你传递一个空数组 (`[]`) 到依赖项中，状态和属性将保留它们的原始初始值。
- en: However, it is important to mention that even though this is the closest equivalent
    to `componentDidMount`, it does not have the same behavior. Unlike `componentDidMount`
    and `componentDidUpdate`, the function that we pass to `useEffect` fires after
    layout and paint, during a deferred event. This normally works for many common
    side effects, such as setting up subscriptions and event handlers, because most
    types of work shouldn’t block the browser from updating the screen.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，重要的是要提到，尽管这是与 `componentDidMount` 最接近的等价物，但它并不具有相同的行为。与 `componentDidMount`
    和 `componentDidUpdate` 不同，我们传递给 `useEffect` 的函数在布局和绘制之后、在延迟事件期间触发。这通常适用于许多常见的副作用，例如设置订阅和事件处理器，因为大多数类型的工作不应该阻止浏览器更新屏幕。
- en: However, not all effects can be deferred. For example, you will get a blink
    if you need to mutate the **Document Object Model** (**DOM**). This is the reason
    why you must fire the event synchronously before the next paint. React provides
    one Hook called `useLayoutEffect`, which works in the exact same way as `useEffect`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非所有 effects 都可以延迟。例如，如果你需要修改 **文档对象模型** (**DOM**)，你将看到一个闪烁。这就是为什么你必须在下一次绘制之前同步触发事件的原因。React
    提供了一个名为 `useLayoutEffect` 的 Hook，它的工作方式与 `useEffect` 完全相同。
- en: Firing an effect conditionally
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有条件地触发 effects
- en: 'If you need to fire an effect conditionally, then you should add a dependency
    to the array of dependencies; otherwise, you will execute the effect multiple
    times and this may cause an infinite loop. If you pass an array of dependencies,
    the `useEffect` Hook will only run if one of those dependencies changes:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要有条件地触发一个影响（副作用），那么你应该将一个依赖项添加到依赖项数组中；否则，你将多次执行影响，这可能会导致无限循环。如果你传递一个依赖项数组，`useEffect`
    Hook 将仅在其中一个依赖项发生变化时运行：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If you understand how the React class life cycle methods work, basically, `useEffect`
    behaves in the same way as `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount`
    combined.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你理解了 React 类生命周期方法的工作原理，基本上，`useEffect` 的行为与 `componentDidMount`、`componentDidUpdate`
    和 `componentWillUnmount` 结合在一起。
- en: The effects are very important, but let’s also explore some other important
    new Hooks, including `useCallback`, `useMemo`, and `memo`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 影响（副作用）非常重要，但让我们也探索一些其他重要的新 Hooks，包括 `useCallback`、`useMemo` 和 `memo`。
- en: Understanding useCallback, useMemo, and memo
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 `useCallback`、`useMemo` 和 `memo`
- en: 'In order to understand the difference between `useCallback`, `useMemo`, and
    `memo`, we will do a to-do list example. You can create a basic application by
    using `create-react-app` and Typescript as a template:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解 `useCallback`、`useMemo` 和 `memo` 之间的区别，我们将通过待办事项列表的示例来进行。你可以通过使用 `create-react-app`
    和 Typescript 作为模板来创建一个基本的应用程序：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Right after that, you can remove all the extra files (`App.css, App.test.ts`,
    `index.css`, `logo.svg`, `reportWebVitals.ts`, and `setupTests.ts`). You just
    need to keep the `App.tsx` file, which will contain the following code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在那之后，你可以移除所有额外的文件（`App.css`、`App.test.ts`、`index.css`、`logo.svg`、`reportWebVitals.ts`
    和 `setupTests.ts`）。你只需要保留 `App.tsx` 文件，它将包含以下代码：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Basically, we are defining some initial tasks and creating the `todoList` state,
    which we will pass to the `List` component. Then, you need to create the `List.tsx`
    file with the following code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们定义了一些初始任务并创建了 `todoList` 状态，我们将将其传递给 `List` 组件。然后，你需要创建 `List.tsx` 文件，并使用以下代码：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, we are rendering each task of the `todoList` array by using
    the `Task` component and we pass the task as a prop. I also added a `useEffect`
    Hook to see how many renders we are performing.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们通过使用 `Task` 组件渲染 `todoList` 数组中的每个任务，并将任务作为属性传递。我还添加了一个 `useEffect` Hook
    来查看我们执行了多少次渲染。
- en: 'Finally, we create our `Task.tsx` file with the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用以下代码创建我们的 `Task.tsx` 文件：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is how we should see the to-do list:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们应该如何看待待办事项列表的方式：
- en: '![](img/B18414_08_04.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片 B18414_08_04.png]'
- en: 'Figure 8.4: To-do list'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4：待办事项列表
- en: As you can see, when we render our to-do list, by default, we are performing
    two renders of the `Task` component, one render for `List`, and the other for
    the `App` component.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，当我们渲染我们的待办事项列表时，默认情况下，我们正在执行两个 `Task` 组件的渲染，一个用于 `List`，另一个用于 `App` 组件。
- en: 'Now, if we try to write a new task in the input, we can see that for each letter
    we write, we will again see all of those renders:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们尝试在输入中写入一个新的任务，我们可以看到，对于每个我们写的字母，我们都会再次看到所有的那些渲染：
- en: '![Graphical user interface, text  Description automatically generated](img/B18414_08_05.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本描述自动生成](img/B18414_08_05.png)'
- en: 'Figure 8.5: Searching in the to-do list'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5：在待办事项列表中搜索
- en: As you can see, by just writing `Go`, we have two new batches of renders, so
    we can determine that this component does not have good performance, and this
    is where `memo` can help us to improve performance. In the next sections, we are
    going to learn how to implement `memo`, `useMemo`, and `useCallback` to memoize
    a component, a value, and a function.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，仅仅通过写入 `Go`，我们就有了两批新的渲染，因此我们可以确定这个组件的性能不佳，这就是 `memo` 可以帮助我们提高性能的地方。在接下来的章节中，我们将学习如何实现
    `memo`、`useMemo` 和 `useCallback` 来记忆化组件、值和函数。
- en: Memoizing a component with memo
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `memo` 记忆化组件
- en: The `memo` **High-Order Component** (**HOC**) is similar to `PureComponent`
    for a React class because it performs a shallow comparison of the props (meaning
    a superficial check), so if we try to render a component with the same props all
    the time, the component will render just once and will memoize. The only way to
    re-render the component is when a prop changes its value.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`memo` 高阶组件（**HOC**）与 React 类中的 `PureComponent` 类似，因为它执行了属性的浅比较（意味着表面检查），所以如果我们尝试始终使用相同的属性渲染组件，组件将只渲染一次并且会进行记忆。唯一重新渲染组件的方法是当属性值发生变化时。'
- en: In order to fix our components to avoid multiple renders when we write in the
    input, we need to wrap our components in the `memo` **HOC**.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在输入时将我们的组件固定，避免多次渲染，我们需要将我们的组件包裹在`memo` **高阶组件**中。
- en: 'The first component we will fix is our `List` component, and you just need
    to affect `import memo` and wrap the component in `export default`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将修复的组件是`List`组件，你只需要在`import memo`和`export default`中包裹组件：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, you need to do the same with the `Task` component:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你需要对`Task`组件做同样的处理：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, when we try to write `Go` again in the input, let’s see how many renders
    we get this time:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们再次在输入中尝试编写`Go`时，让我们看看这次我们会得到多少次渲染：
- en: '![](img/B18414_08_06.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18414_08_06.png)'
- en: 'Figure 8.6: Evaluating how many renders our to-do list is performing'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6：评估我们的待办事项列表执行了多少次渲染
- en: Now, we just get the first batch of renders the first time, and then, when we
    write `Go`, we just get two more renders of the `App` component, which is totally
    fine because the task state (input value) that we are changing is actually part
    of the `App` component.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们第一次只得到第一批渲染，然后，当我们编写`Go`时，我们只得到`App`组件的两次更多渲染，这是完全可以接受的，因为我们要改变的任务状态（输入值）实际上是`App`组件的一部分。
- en: 'Also, we can see how many renders we are performing when we create a new task
    by clicking on the **Create** button:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以看到当我们点击**创建**按钮创建新任务时，我们执行了多少次渲染：
- en: '![Graphical user interface, text  Description automatically generated](img/B18414_08_07.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本自动生成描述](img/B18414_08_07.png)'
- en: 'Figure 8.7: Improving performance'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7：提高性能
- en: If you see, the first 16 renders are the word counting of the `Go to the doctor`
    string, and then, when you click on the **Create** button, you should see one
    render of the `Task` component, one render of `List`, and one render of the `App`
    component. As you can see, we have improved performance a lot, and we are just
    performing the exact need that it renders.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到，前16次渲染是`Go to the doctor`字符串的单词计数，然后，当你点击**创建**按钮时，你应该看到`Task`组件的一次渲染，`List`组件的一次渲染，以及`App`组件的一次渲染。正如你所见，我们大大提高了性能，我们只是执行了确切的渲染需求。
- en: At this point, you’re probably thinking that the correct thing is to always
    add `memo` to our components, or maybe you’re thinking, why React doesn’t do this
    by default for us?
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能认为正确的事情是始终将`memo`添加到我们的组件中，或者你可能认为，为什么React不默认为我们做这件事？
- en: The reason is *performance*, which means *it is not a good idea to add* `memo`
    *to all our components unless it is totally necessary*; otherwise, the process
    of shallow comparisons and memorization will have inferior performance than if
    we don’t use it.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是**性能**，这意味着**除非绝对必要，否则不建议将** `memo` **添加到所有我们的组件中**；否则，浅比较和记忆化的过程将比不使用它时的性能更差。
- en: 'I have a rule when it comes to establishing whether it is a good idea to use
    `memo`, and this rule is straightforward: **just don’t use it**. Normally, when
    we have small components or basic logic, we don’t need this *unless you’re working
    with large data from some API, your component needs to perform a lot of renders
    (normally huge lists), or when you notice that your app is going slow*. Only in
    that case would I recommend using `memo`.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定是否使用`memo`时，我有一个规则，这个规则很简单：**尽量不要使用它**。通常，当我们处理小型组件或基本逻辑时，我们不需要这个功能，除非你正在处理来自某些API的大量数据，你的组件需要执行大量渲染（通常是巨大的列表），或者当你注意到你的应用运行缓慢时。只有在那种情况下，我才会推荐使用`memo`。
- en: Memoizing a value with useMemo
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`useMemo`缓存值
- en: 'Let’s suppose that we now want to implement a search feature in our to-do list.
    The first thing we need to do is to add a new state called `term` to the `App`
    component:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们现在想在我们的待办事项列表中实现一个搜索功能。我们首先需要做的是在`App`组件中添加一个新的状态`term`：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, we need to create a function called `handleSearch`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要创建一个名为`handleSearch`的函数：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Right before the return, we will create `filterTodoList`, which will filter
    the to-dos based on the task, and we will add a console there to see how many
    times it is being rendered:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在返回之前，我们将创建`filterTodoList`，它将根据任务过滤待办事项，我们将在那里添加一个控制台来查看它被渲染了多少次：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, we need to add a new button next to the **Create** button that already
    exists:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在已经存在的**创建**按钮旁边添加一个新按钮：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'At this point, I recommend that you remove or comment `console.log` in the
    `List` and `Task` components so that we can focus on the performance of filtering:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我建议你删除或注释掉`List`和`Task`组件中的`console.log`，这样我们就可以专注于过滤的性能：
- en: '![](img/B18414_08_08.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18414_08_08.png)'
- en: 'Figure 8.8: Reviewing filtering performance'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8：审查过滤性能
- en: When you run the application again, you will see that filtering is being executed
    twice, and then the `App` component as well, and everything looks good here, but
    what’s the problem with this?
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当你再次运行应用程序时，你会看到过滤正在执行两次，然后是`App`组件，这里看起来一切正常，但问题是什么？
- en: 'Try to write `Go to the doctor` again in the input and let’s see how many counts
    of `Rendering…` and `Filtering…` you get:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 再次在输入中尝试写`Go to the doctor`，让我们看看你得到多少次`Rendering…`和`Filtering…`的计数：
- en: '![Graphical user interface, text  Description automatically generated](img/B18414_08_09.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本  自动生成的描述](img/B18414_08_09.png)'
- en: 'Figure 8.9: Bad performance on filtering'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9：过滤性能不佳
- en: As you can see, for each letter you write, you will get two filtering calls
    and one `App` render. You don’t need to be a genius to see that this is bad performance;
    not to mention that if you are working with a large data array, this will be worse,
    so how can we fix this issue?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，对于你输入的每个字母，你将得到两次过滤调用和一次`App`渲染。你不需要是天才就能看出这是性能不佳；更不用说如果你正在处理一个大的数据数组，这会更糟，那么我们如何解决这个问题呢？
- en: 'The `useMemo` Hook is our hero in this situation, and basically, we need to
    move our filter inside `useMemo`, but first, let’s see the syntax:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`useMemo` Hook是我们的英雄，基本上，我们需要将我们的过滤移动到`useMemo`内部，但首先，让我们看看语法：
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `useMemo` Hook will memoize the result (value) of a function and will have
    some dependencies to listen to. Let’s see how we can implement it:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`useMemo` Hook将记忆化函数的结果（值）并有一些依赖项需要监听。让我们看看我们如何实现它：'
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, if you write something again in the input, you will see that filtering
    won’t be executed all the time, as was the case previously:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你再次在输入中写些东西，你会看到过滤不会像之前那样一直执行：
- en: '![Graphical user interface, text  Description automatically generated](img/B18414_08_10.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本  自动生成的描述](img/B18414_08_10.png)'
- en: 'Figure 8.10: Improving the performance of filtering'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10：提高过滤性能
- en: This is great, but there is still one small problem. If you try to click on
    the **Search** button, it won’t filter, and this is because we missed the dependencies.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但还有一个小问题。如果你尝试点击**搜索**按钮，它不会过滤，这是因为我们遗漏了依赖项。
- en: 'Actually, if you see the console warnings, you will see this warning:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果你查看控制台警告，你会看到这个警告：
- en: '![Text  Description automatically generated](img/B18414_08_11.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![文本  自动生成的描述](img/B18414_08_11.png)'
- en: 'Figure 8.11: react-hooks/exhaustive-deps'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11：react-hooks/exhaustive-deps
- en: 'You need to add the `term` and `todoList` dependencies to the array:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要将`term`和`todoList`依赖项添加到数组中：
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'It should now work if you write `Go` and click on the **Search** button:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你输入`Go`并点击**搜索**按钮，它现在应该可以工作：
- en: '![Graphical user interface, text  Description automatically generated](img/B18414_08_12.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本  自动生成的描述](img/B18414_08_12.png)'
- en: 'Figure 8.12: After fixing the warning'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12：修复警告后的情况
- en: Here, we have to use the same rule that we used for `memo`; *just don’t use
    it until absolutely necessary*.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们必须使用与`memo`相同的规则；*除非绝对必要，否则不要使用它*。
- en: Memoizing a function definition with useCallback
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`useCallback`记忆化函数定义
- en: 'Now we will add a delete task feature to learn how `useCallback` works. The
    first thing we need to do is to create a new function called `handleDelete` in
    our `App` component:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将添加一个删除任务功能来学习`useCallback`是如何工作的。我们首先需要做的是在我们的`App`组件中创建一个新的函数，称为`handleDelete`：
- en: '[PRE29]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And then you need to pass this function to the `List` component as a prop:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你需要将这个函数作为prop传递给`List`组件：
- en: '[PRE30]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, in our `List` component, you need to add the prop to the `Props` interface:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的`List`组件中，你需要将prop添加到`Props`接口：
- en: '[PRE31]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, you need to pull it from the props and pass it down to the `Task` component:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要从props中提取它，并将其传递到`Task`组件：
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the `Task` component, you need to create a button that will execute `handleDelete`
    `onClick`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Task`组件中，你需要创建一个按钮，该按钮将执行`handleDelete` `onClick`：
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'At this point, I recommend that you remove or comment `console.log` in the
    `List` and `Task` components so that we can focus on the performance of filtering.
    Now you should see the **X** button next to the task:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我建议你从`List`和`Task`组件中删除或注释掉`console.log`，这样我们就可以专注于过滤的性能。现在你应该能看到任务旁边的**X**按钮：
- en: '![Graphical user interface, text  Description automatically generated](img/B18414_08_13.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本  自动生成的描述](img/B18414_08_13.png)'
- en: 'Figure 8.13: Let’s delete a task'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13：让我们删除一个任务
- en: 'If you click on the **X** for `Go shopping`, you should be able to remove it:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您点击 `Go shopping` 的 **X**，您应该能够删除它：
- en: '![Graphical user interface, text  Description automatically generated](img/B18414_08_14.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本描述自动生成](img/B18414_08_14.png)'
- en: 'Figure 8.14: Deleting a task'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.14：删除任务
- en: 'So far, so good, right? But again, we have a little issue with this implementation.
    If you now try to write something in the input, such as `Go to the doctor`, let’s
    see what happens:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切都很顺利，对吧？但同样，我们在这个实现中又遇到了一点小问题。如果您现在尝试在输入框中输入一些内容，比如 `Go to the doctor`，让我们看看会发生什么：
- en: '![Graphical user interface, text  Description automatically generated](img/B18414_08_15.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本描述自动生成](img/B18414_08_15.png)'
- en: 'Figure 8.15: Bad performance'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.15：性能不佳
- en: As you can see, we are performing `71` renders of all the components again.
    At this point, you are probably thinking about, *what is going on if we have already
    implemented the memo HOC to memoize the components?* But the problem now is that
    our `handleDelete` function is being passed to two components, from `App` to `List`
    and `Task`, and the issue is that this function is regenerated every time we have
    a new re-render, in this case, every time we write something. So how do we fix
    this problem?
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们再次对所有组件进行了 `71` 次渲染。此时，您可能正在想，如果我们已经实现了记忆 HOC 来记忆组件，会发生什么？但现在的问题是，我们的
    `handleDelete` 函数被传递到两个组件中，从 `App` 到 `List` 和 `Task`，问题在于这个函数每次重新渲染时都会被重新生成，在这种情况下，每次我们写入某些内容时。那么我们如何解决这个问题呢？
- en: 'The `useCallback` Hook is the hero in this case and is very similar to `useMemo`
    in the syntax, but the main difference is that instead of memorizing the result
    value of a function, as `useMemo` does, it is memorizing the **function definition**
    instead:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`useCallback` 钩子是英雄，其语法与 `useMemo` 非常相似，但主要区别在于，`useCallback` 不是像 `useMemo`
    那样记忆函数的结果值，而是记忆**函数定义**：
- en: '[PRE34]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Our `handleDelete` function should be like this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `handleDelete` 函数应该是这样的：
- en: '[PRE35]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, it should work just fine if we write `Go to the doctor` again:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们再次写下 `Go to the doctor`，它应该可以正常工作：
- en: '![Graphical user interface, text  Description automatically generated](img/B18414_08_16.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本描述自动生成](img/B18414_08_16.png)'
- en: 'Figure 8.16: Improving performance'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.16：提高性能
- en: 'Now, instead of `71` renders, we just have `23`, which is normal, and we are
    also able to delete tasks:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不再有 `71` 次渲染，而是只有 `23` 次，这是正常的，我们也能够删除任务：
- en: '![Graphical user interface, text  Description automatically generated](img/B18414_08_17.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本描述自动生成](img/B18414_08_17.png)'
- en: 'Figure 8.17: Deleting tasks'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.17：删除任务
- en: As you can see, the `useCallback` Hook helps us to improve performance significantly.
    In the next section, you will learn how to memoize a function passed as an argument
    in the `useEffect` Hook.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`useCallback` 钩子帮助我们显著提高性能。在下一节中，您将学习如何在 `useEffect` 钩子中记忆作为参数传递的函数。
- en: Memoizing a function passed as an argument in effect
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在效果中记忆作为参数传递的函数
- en: 'There is a special case where we will need to use the `useCallback` Hook, and
    this is when we pass a function as an argument in a `useEffect` Hook, for example,
    in our `App` component. Let’s create a new `useEffect` block:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种特殊情况，我们需要使用 `useCallback` 钩子，那就是当我们在一个 `useEffect` 钩子中传递一个函数作为参数时，例如在我们的
    `App` 组件中。让我们创建一个新的 `useEffect` 块：
- en: '[PRE36]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In this case, we are listening for changes to the `todoList` state. If you
    run this code and you create or remove a task, it will work just fine (remember
    to remove all the other consoles first):'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们正在监听 `todoList` 状态的变化。如果您运行此代码并创建或删除一个任务，它将正常工作（记得先删除所有其他控制台输出）：
- en: '![Graphical user interface  Description automatically generated](img/B18414_08_18.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面描述自动生成](img/B18414_08_18.png)'
- en: 'Figure 8.18: Changing the to-do list'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.18：更改待办事项列表
- en: 'Everything works fine, but let’s add `todoList` to the console:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都正常，但让我们将 `todoList` 添加到控制台：
- en: '[PRE37]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If you’re using Visual Studio Code, you will get the following warning:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用 Visual Studio Code，您将得到以下警告：
- en: '![Graphical user interface, text  Description automatically generated](img/B18414_08_19.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本描述自动生成](img/B18414_08_19.png)'
- en: 'Figure 8.19: react-hooks/exhaustive-deps'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.19：react-hooks/exhaustive-deps
- en: 'Basically, it is asking us to add the `printTodoList` function to the dependencies:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，它是在要求我们添加 `printTodoList` 函数到依赖项中：
- en: '[PRE38]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'But now, after we do that, we get another warning:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在，在我们这样做之后，我们得到了另一个警告：
- en: '![Text  Description automatically generated](img/B18414_08_20.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成](img/B18414_08_20.png)'
- en: 'Figure 8.20: useCallback warning'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.20：useCallback警告
- en: 'The reason why we get this warning is that we are now manipulating the state
    (consoling the state), which is why we need to add a `useCallback` Hook to this
    function to fix this issue:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到这个警告的原因是我们现在正在操作状态（控制台输出状态），这就是为什么我们需要在这个函数中添加一个 `useCallback` 钩子来解决这个问题：
- en: '[PRE39]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, when we delete a task, we can see that `todoList` updated correctly:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们删除一个任务时，我们可以看到 `todoList` 正确更新了：
- en: '![Text  Description automatically generated](img/B18414_08_21.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成](img/B18414_08_21.png)'
- en: 'Figure 8.21: Changing to-do list data'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.21：更改待办事项列表数据
- en: 'At this point, this may be information overload for you, so let’s have a quick
    recap:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这对你来说可能信息量过大，所以让我们快速回顾一下：
- en: '`memo`:'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`memo`:'
- en: Memoizes a **component**
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记忆一个**组件**
- en: Re-memoizes when props change
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当属性改变时重新记忆
- en: Avoids re-renders
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免重新渲染
- en: '`useMemo`:'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useMemo`:'
- en: Memoizes a calculated value
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记忆一个计算值
- en: For computed properties
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于计算属性
- en: For heavy processes
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于重型过程
- en: '`useCallback`:'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useCallback`:'
- en: Memoizes a **function definition** to avoid redefining it on each render
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记忆一个**函数定义**以避免在每次渲染时重新定义它
- en: Use it whenever a function is passed as an effect argument
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个函数作为效果参数传递时使用它
- en: Use it whenever a function is passed by props to a memoized component
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个函数作为属性传递给记忆组件时使用它
- en: 'And finally, do not forget the golden rule: *Do not use them until absolutely
    necessary*.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，别忘了黄金法则：*除非绝对必要，否则不要使用它们*。
- en: In the next section, we are going to learn how to use the new `useReducer` Hook.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节，我们将学习如何使用新的 `useReducer` 钩子。
- en: Understanding the useReducer Hook
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 useReducer 钩子
- en: 'You probably have some experience using Redux (`react-redux`) with class components,
    and if that is the case, then you will understand how `useReducer` works. The
    concepts are basically the same: actions, reducers, dispatch, store, and state.
    Even if, in general, it seems very similar to react-redux, they have some differences.
    The main difference is that react-redux provides middleware and wrappers such
    as **thunk**, **sagas**, and many more besides, while `useReducer` just gives
    you a `dispatch` method that you can use to dispatch plain objects as actions.
    Also, `useReducer` does not have a store by default; instead, you can create one
    using `useContext`, but this is just reinventing the wheel.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能有一些使用 Redux (`react-redux`) 与类组件的经验，如果是这样，那么你会理解 `useReducer` 的工作原理。概念基本上是相同的：动作、还原器、分发、存储和状态。尽管在一般情况下它们看起来非常相似，但它们有一些区别。主要区别是
    react-redux 提供了中间件和包装器，如 **thunk**、**sagas** 以及更多，而 `useReducer` 只提供了你可以用来分发普通对象的
    `dispatch` 方法。此外，`useReducer` 默认没有存储；相反，你可以使用 `useContext` 创建一个，但这只是重新发明轮子。
- en: 'Let’s create a basic application to understand how `useReducer` works. You
    can start by creating a new React app:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个基本的应用程序来理解 `useReducer` 的工作原理。你可以从创建一个新的 React 应用程序开始：
- en: '[PRE40]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Then, as always, you can delete all files in your `src` folder except `App.tsx`
    and `index.tsx` to start a brand-new application.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，像往常一样，你可以删除你的 `src` 文件夹中的所有文件，除了 `App.tsx` 和 `index.tsx` 以外，以启动一个全新的应用程序。
- en: 'We will create a basic `Notes` application where we can `list`, `delete`, `create`,
    or `update` our notes using `useReducer`. The first thing you need to do is import
    the `Notes` component, which we will create later, into your `App` component:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个基本的 `Notes` 应用程序，我们可以使用 `useReducer` 来 `list`、`delete`、`create` 或 `update`
    我们笔记。你需要做的第一件事是将我们稍后创建的 `Notes` 组件导入到你的 `App` 组件中：
- en: '[PRE41]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, in our `Notes` component, you first need to import `useReducer` and `useState`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的 `Notes` 组件中，你首先需要导入 `useReducer` 和 `useState`：
- en: '[PRE42]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then we need to define some TypeScript types that we need to use for our `Note`
    object, the `Redux` action, and the **action types**:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要定义一些 TypeScript 类型，这些类型是我们需要用于我们的 `Note` 对象、`Redux` 动作和 **动作类型**：
- en: '[PRE43]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'After this, we need to create `initialNotes` (also known as `initialState`)
    with some dummy notes:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要创建一些初始的 `initialNotes`（也称为 `initialState`）来模拟一些笔记：
- en: '[PRE44]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If you remember how the reducers work, then this will seem very similar to
    how we handle the reducer using a `switch` statement, so as to perform basic operations
    such as `ADD`, `DELETE`, and `UPDATE`:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得如何使用 `reducers`，那么这将会非常类似于我们使用 `switch` 语句处理 `reducers` 的方式，以便执行基本的操作，如
    `ADD`、`DELETE` 和 `UPDATE`：
- en: '[PRE45]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Finally, the component is very straightforward. Basically, you get the notes
    and the dispatch method from the `useReducer` Hook (similar to `useState`), and
    you need to pass the `reducer` function and `initialNotes` `(initialState`):'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，组件非常直接。基本上，你从`useReducer` Hook（类似于`useState`）获取笔记和分发方法，你需要传递`reducer`函数和`initialNotes`（`initialState`）：
- en: '[PRE46]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then, we have a `handleSubmit` function to create a new note when we write
    something in the input. Then, we press *Enter*:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有一个`handleSubmit`函数，当我们输入一些内容时创建一个新的笔记。然后，我们按下*Enter*：
- en: '[PRE47]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finally, we render our `Notes` list with `map`, and we also create two buttons,
    one for `delete` and one for `update`, and then the input should be wrapped into
    a `<form>` tag:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`map`渲染我们的`Notes`列表，我们还创建了两个按钮，一个用于`delete`，一个用于`update`，然后输入应该被包裹在一个`<form>`标签中：
- en: '[PRE48]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If you run the application, you should see the following output:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行应用程序，你应该看到以下输出：
- en: '![Graphical user interface, text  Description automatically generated](img/B18414_08_22.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本描述自动生成](img/B18414_08_22.png)'
- en: 'Figure 8.22: React DevTools'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.22：React DevTools
- en: As you can see in the **React DevTools**, the `Reducer` object contains the
    two notes that we have defined as our initial state.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在**React DevTools**中看到的，`Reducer`对象包含了我们定义为我们初始状态的两个笔记。
- en: 'Now, if you write something in the input and you press *Enter*, you should
    be able to create a new note:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你在输入框中写下一些内容并按下*Enter*，你应该能够创建一个新的笔记：
- en: '![Graphical user interface, text  Description automatically generated](img/B18414_08_23.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本描述自动生成](img/B18414_08_23.png)'
- en: 'Figure 8.23: Creating a new note'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.23：创建新笔记
- en: 'Then, if you want to delete a note, you just need to click on the **X** button.
    Let’s remove **Note 2**:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果你想删除一个笔记，你只需点击**X**按钮。让我们删除**笔记2**：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B18414_08_24.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序描述自动生成](img/B18414_08_24.png)'
- en: 'Figure 8.24: Deleting a note'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.24：删除笔记
- en: 'Finally, you can write anything you want in the input, and if you click on
    the **Update** button, you will change the note value:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以在输入框中写下任何你想要的内容，如果你点击**更新**按钮，你将改变笔记的值：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B18414_08_25.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序描述自动生成](img/B18414_08_25.png)'
- en: 'Figure 8.25: Updating a note'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.25：更新笔记
- en: Nice, huh? As you can see, the `useReducer` Hook is pretty much the same as
    `redux` in terms of the dispatch method, actions, and reducers, but the main difference
    is that this is limited just to the context of your component and its child, so
    if you need a global store to be accessible from your entire application, then
    you should use `react-redux` instead.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，对吧？如您所见，`useReducer` Hook在分发方法、动作和reducer方面与`redux`几乎相同，但主要区别在于这仅限于组件及其子组件的上下文，所以如果你需要一个可以从整个应用程序访问的全局存储，那么你应该使用`react-redux`。
- en: Summary
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: I hope you enjoyed reading this chapter, which is full of very good information
    pertaining to the new React Hooks. So far, you have learned how the new React
    Hooks work; how to fetch data with Hooks; how to migrate a class component to
    **React Hooks**; how the effects work, the difference between `memo`, `useMemo`,
    and `useCallback`; and finally, you learned how the `useReducer` Hook works and
    the main difference compared with `react-redux`. This will help you to improve
    the performance of your React components.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你喜欢阅读这一章，它充满了关于新React Hooks的非常棒的信息。到目前为止，你已经学习了新React Hooks的工作原理；如何使用Hooks获取数据；如何将类组件迁移到**React
    Hooks**；效果的工作原理，`memo`、`useMemo`和`useCallback`之间的区别；最后，你学习了`useReducer` Hook的工作原理以及与`react-redux`相比的主要区别。这将帮助你提高React组件的性能。
- en: In the next chapter, we will learn about React Router v6 and how to implement
    it in our projects.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习React Router v6以及如何在我们的项目中实现它。
