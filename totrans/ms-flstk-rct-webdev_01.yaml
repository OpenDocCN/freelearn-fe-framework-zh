- en: Configuring Full-Stack with Node.js, Express.js, MongoDB, Mongoose, Falcor,
    and Redux
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置使用Node.js、Express.js、MongoDB、Mongoose、Falcor和Redux的全栈开发环境
- en: 'Welcome to *Mastering Full-Stack React Web Development*. In this book, you
    will create a universal full-stack application in JavaScript. The application
    that we are going to build is a publishing platform similar to those that are
    currently popular on the market, for example:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到*精通全栈React Web开发*。在这本书中，你将使用JavaScript创建一个通用全栈应用程序。我们将要构建的应用程序是一个类似于市场上目前流行的发布平台，例如：
- en: Medium ([https://medium.com/](https://medium.com/))
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Medium ([https://medium.com/](https://medium.com/))
- en: WordPress ([https://wordpress.com/](https://wordpress.com/))
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WordPress ([https://wordpress.com/](https://wordpress.com/))
- en: issuu ([https://issuu.com/](https://issuu.com/))
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: issuu ([https://issuu.com/](https://issuu.com/))
- en: There are many smaller publishing platforms, and, of course, our application
    will have fewer features than the ones listed in the aforementioned list because
    we will only focus on the main features, such as publishing an article, editing
    an article, or deleting an article (the core features that you can use to implement
    your own ideas). Besides that, we will focus on building a robust application
    that can be built on because one of the most important things about these kinds
    of applications is scalability. Sometimes, a single article gets much more web
    traffic than the whole site put together (10,000 percent times more traffic is
    normal in the industry because, for instance, a single article could gain insane
    traction through social media).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多较小的发布平台，当然，我们的应用程序将比上述列表中的功能要少，因为我们只会关注主要功能，如发布文章、编辑文章或删除文章（你可以用来实现自己想法的核心功能）。除此之外，我们还将专注于构建一个健壮的应用程序，因为它可以构建，因为这些类型的应用程序最重要的特点是可扩展性。有时，一篇文章的网页流量会比整个网站的流量还要多（在行业中，一篇文章的流量可能是整个网站的10,000倍，因为例如，一篇文章可能通过社交媒体获得疯狂的关注）。
- en: The first chapter of this book is all about setting up the project's main dependencies.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的第一章全部关于设置项目的主要依赖项。
- en: 'Our focus for this chapter will include the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点将包括以下主题：
- en: Installation of **Node Version Manager** (**NVM**) for easier Node management
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装**Node版本管理器**（**NVM**）以简化Node管理
- en: Installation of Node and NPM
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Node和NPM
- en: Preparing MongoDB in our local environment
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的本地环境中准备MongoDB
- en: Robomongo for Mongo's GUI
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Robomongo作为Mongo的GUI
- en: Express.js setup
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Express.js配置
- en: Mongoose installation and configuration
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mongoose的安装和配置
- en: Initial React Redux structure for our client-side app
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端应用程序的初始React Redux结构
- en: Netflix Falcor on the backend and frontend as a glue and replacement for the
    old RESTful approach
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在后端和前端使用Netflix Falcor作为旧RESTful方法的粘合剂和替代品
- en: We will use very modern app stacks that gained a lot of traction in 2015 and
    2016--I am sure that the stack that you are going to learn throughout the book
    will be even more popular in years to come, as we in our company, *MobileWebPro.pl*,
    see huge spikes of interest in the technologies that are listed in the previous
    bullets. You will gain a lot from this book, and will catch up with the newest
    approaches to building robust, full-stack applications.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用在2015年和2016年获得了大量关注的非常现代的应用程序栈--我确信你在本书中将要学习的栈在未来几年将会更加流行，因为我们公司*MobileWebPro.pl*对之前提到的技术产生了巨大的兴趣。你将从这本书中获得很多收获，并能够跟上构建健壮、全栈应用程序的最新方法。
- en: More about our technical stack
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多关于我们的技术栈
- en: In this book, we assume that you are familiar with JavaScript (ES5 and ES6)
    and we will also introduce you to some mechanisms from ES7 and ES8.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们假设你已经熟悉JavaScript（ES5和ES6），我们还将向你介绍一些ES7和ES8的机制。
- en: For the client side, you will use React.js, which you must already be familiar
    with, so we won't discuss React's API in detail.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于客户端，你将使用React.js，这你应该已经很熟悉了，所以我们不会详细讨论React的API。
- en: For data management on the client side, we will use Redux. We will also show
    you how to set up the server-side rendering with Redux.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于客户端的数据管理，我们将使用Redux。我们还将向您展示如何使用Redux设置服务器端渲染。
- en: For the database, you will learn how to use MongoDB alongside Mongoose. The
    second one is an object data modeling library that provides a rigorous modeling
    environment for your data. It enforces a structure, and at the same time it also
    allows you to keep the flexibility that makes MongoDB so powerful.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据库，你将学习如何使用MongoDB和Mongoose。后者是一个对象数据建模库，为你的数据提供了一个严格的建模环境。它强制执行结构，同时它也允许你保持使MongoDB如此强大的灵活性。
- en: Node.js and Express.js are standard choices for a frontend developer to start
    a full-stack development. Express's framework has the best support for the innovative
    client backend data fetching mechanism created by **Netflix**-**Falcor.js**. We
    believe you will love Falcor because of its simplicity and the fact that it will
    save you so much time when doing full-stack development. We will explain in detail
    later in the book why it is so efficient to use this data fetching library instead
    of the standard process of building a RESTful API.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js和Express.js是前端开发者开始全栈开发的标准化选择。Express的框架对**Netflix**-**Falcor.js**创建的创新客户端后端数据获取机制提供了最佳支持。我们相信你会喜欢Falcor，因为它简单，并且在做全栈开发时能为你节省大量时间。我们将在本书的后面详细解释为什么使用这个数据获取库比构建RESTful
    API的标准流程更有效率。
- en: Generally, we will use an object notation (JSON) pretty much everywhere--with
    React as the library, JSON is heavily used for diffing the Virtual DOM (under
    the hood). Redux uses a JSON tree for its single state tree container as well.
    Netflix Falcor's library also uses an advanced concept called a virtual JSON graph
    (we will describe it in detail later). Finally, MongoDB is also a document-based
    database.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们几乎会在所有地方使用对象表示法（JSON）--使用React作为库，JSON被大量用于比较Virtual DOM（底层）。Redux使用JSON树作为其单一状态树容器。Netflix
    Falcor的库也使用一个高级概念，称为虚拟JSON图（我们将在后面详细描述）。最后，MongoDB也是一个基于文档的数据库。
- en: JSON everywhere--this setup will improve our productivity drastically, mainly
    because of Falcor, which is binding everything together.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: JSON无处不在--这个设置将极大地提高我们的生产力，主要是因为Falcor将所有东西绑定在一起。
- en: Environment preparation
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环境准备
- en: 'For starting up, you''re going to need the following tools installed on your
    operating system:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启动，你需要在你的操作系统上安装以下工具：
- en: MongoDB
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MongoDB
- en: Node.js
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js
- en: NPM--installed automatically with Node.js
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NPM--与Node.js自动安装
- en: We strongly recommend using either Linux or OS X for development. For Windows
    users, we'd recommend setting up a virtual machine and doing the development part
    within it. For doing so, you can either use **Vagrant** ([https://www.vagrantup.com/](https://www.vagrantup.com/)),
    which creates a virtual env process in the background with development taking
    place almost natively on Windows, or you can use Oracle's **VirtualBox** ([https://www.virtualbox.org/](https://www.virtualbox.org/))
    directly, and work within a virtual desktop, however the performance here is significantly
    lower than working native.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强烈建议使用Linux或OS X进行开发。对于Windows用户，我们建议设置一个虚拟机，并在其中进行开发。为此，你可以使用**Vagrant**
    ([https://www.vagrantup.com/](https://www.vagrantup.com/))，它会在后台创建一个虚拟环境，几乎以原生方式在Windows上进行开发，或者你可以直接使用Oracle的**VirtualBox**
    ([https://www.virtualbox.org/](https://www.virtualbox.org/))，并在虚拟桌面上工作，然而这里的性能比原生工作要低得多。
- en: NVM and Node installation
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NVM和Node安装
- en: NVM is a very handy tool for keeping different Node versions on your machine
    during development. Go to [https://github.com/creationix/nvm](https://github.com/creationix/nvm)
    for instructions if you don't have NVM installed on your system yet.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: NVM是一个在开发过程中保持不同Node版本在机器上的非常实用的工具。如果你还没有在你的系统上安装NVM，请访问[https://github.com/creationix/nvm](https://github.com/creationix/nvm)获取说明。
- en: 'After you have NVM on your system, you can type the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的系统上安装了NVM之后，你可以输入以下内容：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This command lists all possible Node versions that are available. We will use
    Node v4.0.0 in our case, so you need to type the following in your terminal:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令列出了所有可用的Node版本。在我们的例子中，我们将使用Node v4.0.0，因此你需要在你的终端中输入以下内容：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'These commands will install Node version 4.0.0\. and set it as default. We
    use NPM 2.14.23 during the book so you can check your version with the following
    command:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令将安装Node版本4.0.0并设置为默认。本书中使用NPM 2.14.23，你可以使用以下命令检查你的版本：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After you have the same versions of Node and NPM on your local machine, then
    we can start to set up the rest of the tools that we are going to use.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在你本地机器上安装了相同版本的Node和NPM之后，我们就可以开始设置我们将要使用的其余工具了。
- en: MongoDB installation
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB安装
- en: You can find all the MongoDB instructions at [https://docs.mongodb.org/manual/installation/](https://docs.mongodb.org/manual/installation/)
    under the Tutorials section.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在教程部分下的 [https://docs.mongodb.org/manual/installation/](https://docs.mongodb.org/manual/installation/)
    找到所有 MongoDB 指令。
- en: 'The following is a screenshot from the MongoDB website:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从 MongoDB 网站截取的屏幕截图：
- en: '![](img/00005.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00005.jpeg)'
- en: The instructions and prepared packages for installing Node.js can be found at
    [https://nodejs.org](https://nodejs.org).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Node.js 的说明和准备好的软件包可以在 [https://nodejs.org](https://nodejs.org) 找到。
- en: Robomongo GUI for MongoDB
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Robomongo GUI for MongoDB
- en: '**Robomongo** is a cross-platform desktop client that may be compared to MySQL
    or PostgreSQL for SQL databases.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**Robomongo** 是一个跨平台的桌面客户端，可以与 SQL 数据库中的 MySQL 或 PostgreSQL 相比。'
- en: When developing an app, it's good to have a GUI and be able to quickly review
    collections in our database. This is an optional step if you feel familiar with
    using shell for DB management, but it's helpful if it's your first step in working
    with databases.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发应用程序时，拥有一个 GUI 并能够快速查看数据库中的集合是很有帮助的。如果您熟悉使用 shell 进行数据库管理，这是一个可选步骤，但如果这是您与数据库打交道的第一步，那么它将非常有帮助。
- en: To obtain Robomongo (for all operating systems), visit [https://robomongo.org/](https://robomongo.org/)
    and install one on your machine.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取 Robomongo（适用于所有操作系统），请访问 [https://robomongo.org/](https://robomongo.org/)
    并在您的机器上安装一个。
- en: In our case, we will use version 0.9.0 RC4 of Robomongo.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们将使用 Robomongo 的 0.9.0 RC4 版本。
- en: Running MongoDB and viewing our collections in the Robomongo GUI
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行 MongoDB 并在 Robomongo GUI 中查看我们的集合
- en: 'After you have installed MongoDB and Robomongo on your machine, you need to
    run its daemon process, which listens to connections and delegates them to the
    database. To run the Mongo daemon process in your terminal, use the following
    command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的机器上安装 MongoDB 和 Robomongo 后，您需要运行其守护进程，该进程监听连接并将它们委托给数据库。要在终端中运行 Mongo 守护进程，请使用以下命令：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then perform the following steps:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后执行以下步骤：
- en: 'Open Robomongo''s client--the following screen will appear:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Robomongo 的客户端--以下屏幕将出现：
- en: '![](img/00006.jpeg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00006.jpeg)'
- en: 'Create a connection with defaults by clicking the Create link:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击创建链接创建一个默认连接：
- en: '![](img/00007.jpeg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00007.jpeg)'
- en: Pick a name for your connection and use port `27017`, which is the default for
    databases, and click on Save.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的连接选择一个名称并使用默认的端口 `27017`，然后点击保存。
- en: At this point, you have a localhost database setup finished, and you can preview
    its content using the GUI client.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经完成了本地数据库的设置，并且可以使用 GUI 客户端预览其内容。
- en: Importing the first example collection into the database
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将第一个示例集合导入数据库
- en: 'In the project''s directory, create a file called `initData.js`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的目录下，创建一个名为 `initData.js` 的文件：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In our case, we are building the publishing app so it will be a list of articles.
    In the following code, we have an example collection of two articles in a JSON
    format:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们正在构建发布应用程序，因此它将是一个文章列表。在以下代码中，我们有一个包含两个文章的 JSON 格式的示例集合：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In general, we start from a mocked collection of articles--later we will add
    a feature to add more articles into MongoDB's collection, but for now we will
    stick with only two articles for the sake of brevity.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们从模拟的文章集合开始--稍后我们将添加一个功能来将更多文章添加到 MongoDB 的集合中，但现在我们将只保留两个文章以保持简洁。
- en: 'To list your localhost databases, open the Mongo shell by typing:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出您本地的数据库，通过输入以下命令打开 Mongo shell：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'While in the Mongo shell, type:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mongo shell 中，输入以下命令：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'See the following for a full example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个完整示例：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In our example, it shows that we have one database in the localhost called `local`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，它显示在本地主机中有一个名为 `local` 的数据库。
- en: Importing the articles to MongoDB
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将文章导入 MongoDB
- en: 'In the following, we will use Terminal (the command prompt) in order to import
    the articles into the database. Alternatively, you can use Robomongo to do it
    via the GUI as well:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下内容中，我们将使用终端（命令提示符）来将文章导入数据库。您也可以使用 Robomongo 通过 GUI 来完成此操作：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Remember that you need a new tab in your Terminal and `mongo import` will work
    while you are in the Mongo shell (Don't confuse it with the `mongod` process).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您需要在终端中打开一个新标签页，并且当您在 Mongo shell 中时，`mongo import` 将会工作（不要与 `mongod` 进程混淆）。
- en: 'Then you shall see the following information in your terminal:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然后您将在终端中看到以下信息：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In case you get the error `Failed: error connecting to db server: no reachable
    servers`, then make sure you have `mongod` running on the given host IP (`127.0.0.1`).'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '如果您收到错误 `Failed: error connecting to db server: no reachable servers`，请确保在指定的主机
    IP (`127.0.0.1`) 上运行了 `mongod`。'
- en: 'After importing those articles via the command line, you will also see this
    reflected in Robomongo:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通过命令行导入这些文章后，你也会在 Robomongo 中看到这一点：
- en: '![](img/00008.jpeg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00008.jpeg)'
- en: Server setup with Node.js and Express.js
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Node.js 和 Express.js 设置服务器
- en: Once we have our article collection in MongoDB, we can start working on our
    Express.js server in order to work on the collection.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在 MongoDB 中有了我们的文章集合，我们就可以开始在我们的 Express.js 服务器上工作，以便处理这个集合。
- en: 'First, we need an NPM project in our directory:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在我们的目录中创建一个 NPM 项目：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `--yes` flag means that we will use the default settings for `package.json`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`--yes` 标志意味着我们将使用 `package.json` 的默认设置。'
- en: 'Next, let''s create an `index.js` file in the `server` directory:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在 `server` 目录中创建一个 `index.js` 文件：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In `index.js`, we need to add a Babel/register in order to get better coverage
    of the ECMAScript 2015 and 2016 specification. This will enable us to support
    such structures as `async` and `generator` functions, which are not available
    in the current version of Node.js by default.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `index.js` 中，我们需要添加一个 Babel/register 以获得更好的 ECMAScript 2015 和 2016 规范的覆盖。这将使我们能够支持如
    `async` 和 `generator` 函数这样的结构，这些在 Node.js 的当前版本中默认不可用。
- en: 'See the following for the `index.js` file content (we will install Babel''s
    `dev` dependencies later):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为 `index.js` 文件的内容（我们将在稍后安装 Babel 的 `dev` 依赖项）：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Installing `express` and other initial dependencies:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 `express` 和其他初始依赖项：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the command, you can see `@4.13.4` after `express` and others. These are
    the versions of the libraries we're going to install, and we've picked it intentionally
    to make sure that it works well along side Falcor, but most probably you can skip
    these, and newer versions should work just as well.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令中，你可以在 `express` 和其他库后面看到 `@4.13.4`。这些是我们将要安装的库的版本，我们有意选择这些版本以确保它们与 Falcor
    一起工作良好，但很可能你可以跳过这些版本，新版本也应该同样有效。
- en: 'We also need to install `dev` dependencies (we have spilled all `npm install`
    commands into separate for better readability):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要安装 `dev` 依赖项（我们将所有 `npm install` 命令分散到单独的文件中以提高可读性）：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We need the `babel-preset-stage-0` is for ES7 features. The `babel-preset-es2015`
    and `babel-preset-react` are required for JSX and ES6 support.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的 `babel-preset-stage-0` 是用于 ES7 特性的。`babel-preset-es2015` 和 `babel-preset-react`
    是用于 JSX 和 ES6 支持的必需品。
- en: 'Also, note that we install Babel to give our Node''s server the ability to
    use ES6 features. We need to add the `.babelrc` file, so create the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，我们安装 Babel 以使我们的 Node 服务器能够使用 ES6 特性。我们需要添加 `.babelrc` 文件，因此创建以下内容：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then open the `.babelrc` file and fill it with the following content:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后打开 `.babelrc` 文件，并填充以下内容：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Remember that the `.babelrc` is a hidden file. Probably the best way to edit
    the `.babelrc` is to open the whole project in a text editor such as Sublime Text.
    Then you should be able to see all hidden files.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`.babelrc` 是一个隐藏文件。可能最好的编辑 `.babelrc` 的方式是在文本编辑器（如 Sublime Text）中打开整个项目。然后你应该能够看到所有隐藏文件。
- en: 'We also need the following libraries:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要以下库：
- en: '`babel` and `babel-core/register`: This is the library for transpiling new
    ECMAScript functions into the existing version'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`babel` 和 `babel-core/register`：这是一个将新的 ECMAScript 函数转换为现有版本的库'
- en: '`cors`: This module is responsible for creating cross-origin requests to our
    domain in an easy way'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cors`：这个模块负责以简单的方式创建对我们域的跨源请求'
- en: '`body-parser`: This is the middleware for parsing the request''s body'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`body-parser`：这是解析请求体的中间件'
- en: 'After this, your project''s file structure should look like the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，你的项目文件结构应该看起来像以下这样：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `***` is a wildcard, which means that there are files required for our project,
    but we don't list them here as it would be too long.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`***` 是一个通配符，这意味着有一些文件是我们项目所需的，但我们没有在这里列出，因为这会太长。'
- en: Working on our server (server.js)
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的服务器上工作（server.js）
- en: 'We will start working on the `server/server.js` file, which is new to our project,
    so we need to create it first with the following commands, in the `server` directory
    of your project:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始处理我们的 `server/server.js` 文件，这是我们的项目中的新文件，因此我们需要首先在项目的 `server` 目录中使用以下命令创建它：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The content for the `server/server.js` file is as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`server/server.js` 文件的内容如下：'
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: These files use the `babel/register` library so that we can use ES6 syntax in
    our code. In the `index.js` file, we have an `http` module which comes from Node.js
    ([https://nodejs.org/api/http.html#http_http](https://nodejs.org/api/http.html#http_http)).
    Next, we have `express`, `cors`, and `body-parser`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件使用`babel/register`库，这样我们就可以在我们的代码中使用ES6语法。在`index.js`文件中，我们有一个来自Node.js的`http`模块（[https://nodejs.org/api/http.html#http_http](https://nodejs.org/api/http.html#http_http)）。接下来，我们有`express`、`cors`和`body-parser`。
- en: Cors is middleware for dynamically or statically enabling **cross-origin resource
    sharing** (**CORS**) in Express applications--it will be useful in our development
    environment (we will delete it later for our production server).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Cors是用于在Express应用程序中动态或静态启用**跨源资源共享**（**CORS**）的中间件 - 它将在我们的开发环境中很有用（我们将在生产服务器上删除它）。
- en: Body-parser is middleware for HTTP's body parsing. It has some fancy settings
    that help us build the app faster.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Body-parser是HTTP体解析的中间件。它有一些花哨的设置，可以帮助我们更快地构建应用。
- en: 'This how our app looks at this stage of our development:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开发的这个阶段，我们的应用看起来是这样的：
- en: '![](img/00009.jpeg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00009.jpeg)'
- en: Mongoose and Express.js
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mongoose和Express.js
- en: 'At the moment, we have a simple working Express.js server. Now we have to add
    Mongoose to our project:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们有一个简单的Express.js服务器。现在我们必须将Mongoose添加到我们的项目中：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Once we have installed Mongoose and a running MongoDB database in the background,
    we can import it to our `server.js` file and do the coding:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们安装了Mongoose并在后台运行了MongoDB数据库，我们就可以将其导入到`server.js`文件中并进行编码：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: A summary of how to run the project
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行项目的总结
- en: 'Make sure that you have MongoDB running in the background on your machine using
    the following command:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你使用以下命令在你的机器上后台运行MongoDB：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After you run the `mongod` command in your terminal (or PowerShell on Windows),
    then you should see something like the following in your console:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的终端（或在Windows上的PowerShell）中运行`mongod`命令后，你应该在你的控制台中看到以下类似的内容：
- en: '![](img/00010.jpeg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00010.jpeg)'
- en: 'Before you run the server, make sure the `devDependencies` in your `package.json`
    file look like the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行服务器之前，请确保你的`package.json`文件中的`devDependencies`看起来像以下这样：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Before you run the server, make sure that the dependencies in your `package.json`
    look like the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行服务器之前，请确保你的`package.json`文件中的依赖项看起来像以下这样：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the main directory, run Node with the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在主目录下，使用以下命令运行Node：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'After that, your terminal should show something like the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你的终端应该显示以下类似的内容：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '![](img/00011.jpeg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00011.jpeg)'
- en: Redux basic concepts
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redux基本概念
- en: In this section, we will cover only the most basic concepts of Redux that will
    help us make our simple publishing app. The app will only be in *read-only* mode
    for this chapter; later in the book we will add more functionality such as adding/editing
    an article. You will discover all the important rules and principles about Redux
    in the later chapters.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将仅涵盖Redux的最基本概念，这将帮助我们制作简单的发布应用。在本章中，应用将只处于*只读*模式；在本书的后面部分，我们将添加更多功能，例如添加/编辑文章。你将在后面的章节中了解到关于Redux的所有重要规则和原则。
- en: 'Basic topics covered are:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 涵盖的基本主题包括：
- en: What is a state tree?
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是状态树？
- en: How immutability works in Redux
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux中不可变性的工作原理
- en: The concept and basic use of reducers
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Reducers的概念和基本用法
- en: Let's start with the basics.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基础知识开始。
- en: The single immutable state tree
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单个不可变状态树
- en: The most important principle of Redux is that you are going to represent the
    whole state of your application as a single JavaScript object.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Redux最重要的原则是，你将用单个JavaScript对象来表示你应用程序的整个状态。
- en: All changes (actions) in Redux are explicit, so you can track a history of all
    your actions through the application with a dev tool.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Redux中的所有更改（动作）都是显式的，因此你可以通过开发工具跟踪应用程序中的所有动作的历史。
- en: '![](img/00012.jpeg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00012.jpeg)'
- en: The preceding screenshot is a simple, example dev tool use case that you will
    use in your development environment. It will help you to track the changes of
    state in your app. The example shows how we have incremented the counter value
    in our state by *+1*, three times. Of course, our publishing app structure will
    be much more complicated than this example. You will learn more about that dev
    tool later in the book.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图是一个简单的、示例开发工具使用案例，你将在你的开发环境中使用它。它将帮助你跟踪应用中状态的变化。示例显示了如何通过在状态中三次增加计数器值*+1*。当然，我们的发布应用结构将比这个例子复杂得多。你将在本书的后面部分了解更多关于这个开发工具的内容。
- en: Immutability - actions and state tree are read-only
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变性 - 动作和状态树是只读的
- en: As Redux bases its concepts on functional programming paradigms, you cannot
    modify/mutate the values in your state tree in the same way that you can for Facebook's
    (and other) FLUX implementations.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Redux基于函数式编程范式，你不能像在Facebook的（和其他）FLUX实现中那样修改/突变你的状态树中的值。
- en: 'As with other FLUX implementations, an action is a plain object that describes
    the change--like adding an article (in the following code we mock the payload
    for the sake of brevity):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他FLUX实现一样，一个动作是一个描述变化的普通对象--比如添加一篇文章（在下面的代码中，我们为了简洁起见模拟了有效载荷）：
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: An action is a minimal representation of the change for our app state tree.
    Let's prepare actions for our publishing app.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一个动作是我们应用状态树变化的最小表示。让我们为我们的发布应用准备动作。
- en: Pure and impure functions
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纯函数和不纯函数
- en: A** pure function** is a function that doesn't have any side effects, such as
    for example, I/O (reading a file or an HTTP request). **Impure functions** have
    side effects so, for example, if you make a call to the HTTP request, it can return
    different values for exactly the same arguments *Y,Z (function(X,Y))* because
    an endpoint is returning us a random value, or could be down because of a server
    error.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**纯函数**是一个没有副作用的功能，例如，例如I/O（读取文件或HTTP请求）。**不纯函数**有副作用，所以，例如，如果你调用HTTP请求，它可以为完全相同的参数*Y,Z（函数(X,Y)*）返回不同的值，因为端点返回给我们一个随机值，或者可能因为服务器错误而宕机。
- en: Pure functions are always predictable for the same *X,Y* arguments. In Redux,
    we use only pure functions in reducers and actions (otherwise Redux's `lib` won't
    work properly).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数对于相同的*X,Y*参数总是可预测的。在Redux中，我们只在reducer和动作中使用纯函数（否则Redux的`lib`将无法正常工作）。
- en: In this book, you will learn the whole structure and where to make API calls.
    So if you follow the book, then you won't have to worry too much about that principle
    in Redux.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，你将学习整个结构和在哪里进行API调用。所以如果你遵循这本书，那么你就不必太担心Redux中的那个原则。
- en: The reducer function
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Reducer函数
- en: Reducers from Redux can be compared to a single store from Facebook's Flux.
    What is important is that a reducer always takes a previous state and returns
    a new reference to a new object (with the use of `Object.assign` and others like
    that), so we can have immutable JS helping us to build a more predictable state
    of our application in comparison to older Flux implementations that mutate variables
    in the store.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Redux的reducer可以与Facebook的Flux的单个store进行比较。重要的是，reducer始终接受一个先前的状态并返回对新对象的新的引用（使用`Object.assign`和其他类似方法），这样我们就可以使用不可变JS帮助我们构建比旧Flux实现更可预测的应用状态。
- en: Thus, creating a new reference is optimal because Redux uses old references
    to values from reducers that didn't change. This means that even if each action
    creates a whole new object via a reducer then the values that don't change have
    a previous reference in the memory so we don't overuse the computation power of
    the machine. Everything is fast.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，创建一个新的引用是最优的，因为Redux使用旧引用来访问未更改的reducer中的值。这意味着即使每个动作通过reducer创建了一个全新的对象，那些未更改的值在内存中仍然有之前的引用，所以我们不会过度使用机器的计算能力。一切都很快速。
- en: In our app, we will have an article reducer that will help us to list, add,
    edit, and delete our articles from the view layer.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用中，我们将有一个文章reducer，它将帮助我们从视图层列出、添加、编辑和删除文章。
- en: First reducer and webpack config
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一个reducer和webpack配置
- en: 'First, let''s create a reducer for our publication app:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们为我们的发布应用创建一个reducer：
- en: '[PRE29]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'So, our first reducer''s location is `src/reducers/article.js` and the content
    of our `reducers/article.js` is as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的第一个reducer的位置是`src/reducers/article.js`，我们的`reducers/article.js`的内容如下：
- en: '[PRE30]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding code, we have our `articleMock` kept in the browser memory
    (it's the same as in `initData.js`)--later, we will fetch this data from our backend
    database.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有`articleMock`保存在浏览器内存中（它与`initData.js`中的相同）--稍后，我们将从我们的后端数据库中获取这些数据。
- en: The arrow function, `const article` is getting `action.type` which will come
    from constants (we will create them later) in the same way that Facebook's FLUX
    implementation works.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数`const article`正在获取`action.type`，它将来自常数（我们稍后会创建它们），就像Facebook的FLUX实现一样工作。
- en: For the default `return` in the `switch` statement, we provide the state from
    `state = articleMock` (return state; part above). This will return the initial
    state of our publishing app at first startup before any other action occurs. To
    be exact, the default in our case will do exactly the same as the `RETURN_ALL_ARTICLES`
    action before we start fetching data from the backend (after the articles' fetching
    mechanism from backend is implemented; then the default will return an empty object).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `switch` 语句中的默认 `return`，我们提供 `state = articleMock` 的状态（上面的 `return state;`
    部分）。这将返回我们发布应用程序在首次启动时的初始状态，在发生任何其他动作之前。更确切地说，在我们的情况下，默认将与我们开始从后端获取数据之前的 `RETURN_ALL_ARTICLES`
    动作完全相同（在实现后端文章获取机制之后；然后默认将返回一个空对象）。
- en: 'Because of our webpack configuration (described here), we need `index.html`
    in `dist`. Let''s create a `dist/index.html` file:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的 webpack 配置（在此描述），我们需要在 `dist` 中 `index.html`。让我们创建一个 `dist/index.html`
    文件：
- en: '[PRE31]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `dist/index.html` file''s content is as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`dist/index.html` 文件的内容如下：'
- en: '[PRE32]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We have an article `reducer` and `dist/index.html`, but before we start building
    our Redux's publishing app, we need to configure webpack for our built automation.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个文章 `reducer` 和 `dist/index.html`，但在我们开始构建 Redux 的发布应用程序之前，我们需要为我们的构建自动化配置
    webpack。
- en: 'Install webpack first (you may need `sudo` root access for it):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 首先安装 webpack（你可能需要 `sudo` 根权限）：
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, in the main directory next to the `package.json` and `initData.js` files,
    input the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `package.json` 和 `initData.js` 文件旁边的主目录中，输入以下内容：
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then create webpack configs:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然后创建 webpack 配置：
- en: '[PRE35]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Simply, webpack config says that the entry of the CommonJS module is at entry `''./src/app.js''`.
    webpack builds a whole app following all imports from the `app.js` and the final
    output is located at path `''./dist''`. Our app that is located at `contentBase:
    ''./dist''` will live at port `3000`. We also configure the use of ES2015 and
    React so that webpack will compile ES2015 into ES5 and React''s JSX into JavaScript
    for us. If you are interested in webpack''s configuration options, then read its
    documentation.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '简单来说，webpack 配置说明 CommonJS 模块的入口在 `entry ''./src/app.js''`。webpack 会根据 `app.js`
    中的所有导入构建整个应用程序，最终输出位于路径 `''./dist''`。我们位于 `contentBase: ''./dist''` 的应用程序将运行在端口
    `3000`。我们还配置了使用 ES2015 和 React，以便 webpack 会将 ES2015 编译成 ES5，并将 React 的 JSX 编译成
    JavaScript。如果你对 webpack 的配置选项感兴趣，那么请阅读其文档。'
- en: The rest of the important dependencies installation and npm dev script
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其余的重要依赖安装和 npm 开发脚本
- en: 'Install the Babel tools that are used by webpack (check the config file):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 webpack 所使用的 Babel 工具（检查配置文件）：
- en: '[PRE36]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We also need to update our `package.json` file (add `scripts`):'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更新我们的 `package.json` 文件（添加 `scripts`）：
- en: '[PRE37]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Our complete `package.json` should look like the following, with all frontend
    dependencies:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完整的 `package.json` 应该如下所示，包含所有前端依赖：
- en: '[PRE38]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As you may realize, the mentioned `package.json` doesn''t have the `^` signs
    as we want to use the exact versions of each package in order to make sure that
    all our packages are installed with the correct and exact version given in the
    package. Otherwise, you may have some difficulties, for example, if you add `"mongoose":
    "4.4.5"`, with the `^` then it will install a newer version that causes some additional
    warnings in the console. Let''s stick to the versions mentioned in the book in
    order to avoid unnecessary problems with the app that we are building. We want
    to avoid NPM dependencies hell at all cost.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '如你所意识到的那样，提到的 `package.json` 中没有我们想要的 `^` 符号，因为我们想使用每个包的确切版本，以确保所有我们的包都安装了在
    `package` 中给出的正确且确切的版本。否则，你可能会有一些困难，例如，如果你添加 `"mongoose": "4.4.5"`，带有 `^` 符号，那么它将安装一个较新的版本，这会在控制台产生一些额外的警告。让我们坚持书中提到的版本，以避免我们正在构建的应用程序出现不必要的麻烦。我们无论如何都要避免
    NPM 依赖地狱。'
- en: Working on src/app.js and src/layouts/PublishingApp.js
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在处理 src/app.js 和 src/layouts/PublishingApp.js
- en: 'Let''s create our `app.js` file, where the main part of our app will live at
    `src/app.js`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的 `app.js` 文件，我们应用程序的主要部分将位于 `src/app.js`：
- en: '[PRE39]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The content of our new `src/app.js` file is the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们新的 `src/app.js` 文件的内容如下：
- en: '[PRE40]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The new part is the `store = createStore(article)` part--this utility from Redux
    lets you keep an application state object, dispatch an action, and allows you
    to give a reducer as an argument that tells you how the app is updated with actions.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 新的部分是 `store = createStore(article)` 部分--这个来自 Redux 的实用工具让你可以保持一个应用程序状态对象，分发一个动作，并允许你提供一个作为参数的
    reducer，它告诉你应用程序如何通过动作更新。
- en: 'The `react-redux` is a useful binding of Redux into React (so we will write
    less code and be more productive):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`react-redux` 是将 Redux 绑定到 React 中的一个有用的绑定（因此我们将编写更少的代码，并更有效率）：'
- en: '[PRE41]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `Provider store` helps us to make the Redux store available to the `connect()`
    calls in the child components (as shown here):'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`Provider store` 帮助我们将 Redux store 传递给子组件中的 `connect()` 调用（如下所示）：'
- en: '[PRE42]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`connect` will be used in any component that has to listen to the reducer''s
    changes in our app. You will see how to use it later in this chapter.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`connect` 将用于任何必须监听我们应用程序中 reducer 变化的组件。你将在本章后面看到如何使用它。'
- en: 'For the store, we use `const store = createStore(article)`--just for the sake
    of brevity, I will mention that there are several methods in the store that we
    will use in the next steps of building our app from scratch:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于存储，我们使用 `const store = createStore(article)`--仅为了简洁，我将提到在构建我们应用程序的下一个步骤中，我们将使用存储中的几个方法：
- en: '[PRE43]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `getState` function gives you the current state of the application:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`getState` 函数会给你当前应用程序的状态：'
- en: '[PRE44]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `dispatch` function can help you change the state of your app:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`dispatch` 函数可以帮助你更改应用程序的状态：'
- en: '[PRE45]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Subscribe allows you register a callback that Redux will call each time an action
    has been dispatched, so the view layer can learn about the change in the application
    state and refresh its view.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅允许你注册一个回调，每当分发了一个动作时，Redux 都会调用它，这样视图层就可以了解应用程序状态的变化并刷新其视图。
- en: Wrapping up React-Redux application
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结 React-Redux 应用程序
- en: 'Let''s finish our first React-Redux app. For a summary, let''s see our current
    directory structure:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们完成我们的第一个 React-Redux 应用程序。为了总结，让我们看看我们当前的目录结构：
- en: '[PRE46]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now we need to create the main view of our app. We will put this into the layout
    directory in our first version:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要创建我们应用程序的主视图。在我们的第一个版本中，我们将将其放入布局目录：
- en: '[PRE47]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The content of `PublishingApp.js` is:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`PublishingApp.js` 的内容是：'
- en: '[PRE48]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The preceding introduces the ES7 syntax `...` next to `...`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 前面介绍了 `...` 旁边的 ES7 语法 `...`：
- en: '[PRE49]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '`...` is a spread operator that is well described in Mozilla''s documentation
    as; *an expression to be expanded in places where multiple arguments (for function
    calls) or multiple elements (for array literals) are expected*. In our case, this
     `...` operator spreads one object state into a second one (in our case, empty
    object `{ }`). It''s written like this here because, in future, we will specify
    multiple reducers that have to be mapped from our app''s state into the `this.props`
    component.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`...` 是一个扩展操作符，在 Mozilla 的文档中有很好的描述，作为；*一个表达式，在需要多个参数（函数调用）或多个元素（数组字面量）的地方进行扩展*。在我们的案例中，这个
    `...` 操作符将一个对象状态扩展到第二个（在我们的案例中，空对象 `{ }`）。它在这里是这样写的，因为，在未来，我们将指定多个必须从我们的应用程序状态映射到
    `this.props` 组件的 reducer。'
- en: Finishing our first static publishing app
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成我们的第一个静态发布应用程序
- en: The last thing to do in our static app is to render the articles that come from
    `this.props`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的静态应用程序中最后要做的就是在 `this.props` 中渲染文章。
- en: 'Thanks to Redux, the object mocked in the reducer is available, so if you check
    `console.log(this.props)` in the render function of `PublishingApp.js`, then you
    will be able to access our `articles` object:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了 Redux，reducer 中模拟的对象现在是可用的，所以如果你在 `PublishingApp.js` 的渲染函数中检查 `console.log(this.props)`，那么你将能够访问我们的
    `articles` 对象：
- en: '[PRE50]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In our case, we need to change the React''s render function, as follows (in
    `src/layouts/PublishingApp.js`):'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们需要更改 React 的渲染函数，如下所示（在 `src/layouts/PublishingApp.js`）：
- en: '[PRE51]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This comment will start your project on port `3000`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这个注释将在端口 `3000` 上启动你的项目：
- en: '[PRE53]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'After you check `localhost:3000`, the new static Redux app should look as shown
    in the following screenshot:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在你检查 `localhost:3000` 之后，新的静态 Redux 应用程序应该看起来如下所示：
- en: '![](img/00013.jpeg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00013.jpeg)'
- en: Great, so we have a static app in Redux! It's time to fetch data from our MongoDB
    database using Falcor.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，我们已经在 Redux 中创建了一个静态应用！现在是时候使用 Falcor 从我们的 MongoDB 数据库中获取数据了。
- en: Falcor's basic concepts
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Falcor 的基本概念
- en: 'Falcor is like a glue between:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Falcor 就像是一种粘合剂，介于：
- en: Backend and its database structure (remember importing `initData.js` into MongoDB)
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后端及其数据库结构（记住将 `initData.js` 导入 MongoDB）
- en: Frontend Redux single state tree container
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端 Redux 单个状态树容器
- en: It glues the pieces in a way that is much more effective than building an old-fashioned
    REST API for a single-page application.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 它以一种比为单页应用程序构建老式的 REST API 更有效的方式将各个部分粘合在一起。
- en: Like the *Redux basic concepts* section, in this one we will learn only the
    most basic concepts of Falcor and they will help us build a simple full-stack
    application in *read-only* mode. Later in the book, you will learn how to make
    an add/edit article with Falcor.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 就像“Redux基本概念”部分一样，在这一部分中，我们将只学习Falcor的最基本概念，它们将帮助我们以只读模式构建一个简单的全栈应用。在本书的后面部分，您将学习如何使用Falcor添加/编辑文章。
- en: 'We will focus on the most important aspects:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将关注最重要的方面：
- en: What is Falcor's model?
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Falcor的模型是什么？
- en: Retrieving values from Falcor (frontend and backend)
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Falcor（前端和后端）检索值
- en: Concepts and basic use of JSON graphs
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON图的概念和基本用法
- en: Concepts and basic use of sentinels
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理概念和基本用法
- en: How to retrieve data from the backend
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何从后端检索数据
- en: How to configure our first route with middleware for Express.js called
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Express.js的中间件配置我们的第一个路由
- en: '`falcor-router`'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`falcor-router`'
- en: What is Falcor and why do we need it in our full-stack publishing app?
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Falcor以及为什么我们需要在我们的全栈发布应用中使用它？
- en: 'Let''s first consider what the difference is between web pages and web applications:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先考虑网页和Web应用之间的区别：
- en: When the **World Wide Web** (**WWW**) was invented, web pages served small amounts
    of large resources (such as HTML, PDF, and PNG files). For example, you could
    request a PDF, video, or text file from a server.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当**万维网**（**WWW**）被发明时，网页服务于少量的大型资源（如HTML、PDF和PNG文件）。例如，您可以从服务器请求PDF、视频或文本文件。
- en: Since *circa 2008*, the development of web apps has been getting more and more
    popular. Web applications serve large amounts of small resources. What does it
    mean for us? You have a lot of small REST API calls to the server using AJAX calls.
    The old approach of many API requests creates latency, which slows down the mobile/web
    app.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自从大约2008年以来，Web应用的开发变得越来越流行。Web应用服务于大量的小型资源。这对我们意味着什么？您需要使用AJAX调用向服务器发送大量的小型REST
    API请求。旧的许多API请求方法会导致延迟，从而减慢移动/Web应用的运行速度。
- en: Why do we use old REST API requests (as we did in 2005) in apps written in 2016
    and later? This is where Falcor shines; it solves the problem of latency and tight
    coupling of backend to frontend.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们在2016年及以后的APP中使用旧的REST API请求（就像我们在2005年做的那样）？这正是Falcor大放异彩的地方；它解决了后端与前端之间延迟和紧密耦合的问题。
- en: Tight coupling and latency versus one model everywhere
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 紧密耦合和延迟与无处不在的单个模型
- en: 'If you are familiar with frontend development, you know how to make requests
    to an API. This old way of doing things always forces you to tight-couple the
    backend API with frontend API utilities. It''s always like that:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉前端开发，您知道如何向API发起请求。这种旧的方法总是迫使您将后端API与前端API工具紧密耦合。它总是这样：
- en: You make an API endpoint like [https://applicationDomain.com/api/recordDetails?id=92](https://applicationDomain.com/api/recordDetails?id=92).
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您创建一个API端点，例如[https://applicationDomain.com/api/recordDetails?id=92](https://applicationDomain.com/api/recordDetails?id=92)。
- en: 'You consume the data with HTTP API requests on the frontend:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您在前端使用HTTP API请求来获取数据：
- en: '[PRE54]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In large applications, it's hard to maintain real DRY RESTful APIs, and this
    problem causes plenty of endpoints that are not optimized, so the frontend sometimes
    has to do many round trips in order to fetch the data required for a certain view
    (and sometimes it fetches much more than it needs, which causes even more latency
    for the end user of our application).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型应用中，维护真正的DRY RESTful API很困难，这个问题导致了很多未优化的端点，因此前端有时不得不进行多次往返才能获取特定视图所需的数据（有时获取的数据远多于所需，这甚至给应用最终用户带来了更多的延迟）。
- en: Imagine that you have a large application with over 50 different API endpoints.
    After the first version of your application is finished, your client or boss finds
    a better way to structure the user flow in the app. What does this mean? That
    you have to work on changing both frontend and backend endpoints in order to satisfy
    the changes in the user interface layer. This is called tight coupling between
    frontend and backend.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您有一个拥有超过50个不同API端点的庞大应用。当您的应用的第一版完成后，您的客户或老板发现了一种更好的方法来结构化应用中的用户流程。这意味着什么？这意味着您必须修改前端和后端端点以满足用户界面层的更改。这被称为前端和后端之间的紧密耦合。
- en: What does Falcor bring to this situation to improve on those two areas that
    cause the inefficiency in working with RESTful APIs? The answer is one model everywhere.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Falcor为这种情况带来了什么，以改善导致使用RESTful API效率低下的两个领域？答案是无处不在的单个模型。
- en: It would be super easy to build your web applications if all your data was accessible
    in memory, on the client.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有数据都在客户端的内存中可访问，构建您的Web应用程序将会非常简单。
- en: Falcor provides utilities that help you feel that all your data is at your fingertips
    without coding backend API endpoints and client-side consuming utilities.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Falcor提供了帮助您感觉所有数据都在指尖的实用工具，而无需编写后端API端点和客户端消费工具。
- en: No more tight coupling on client and server side
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端和服务器端不再紧密耦合。
- en: Falcor helps you represent all of your app's data as one virtual JSON model
    on the server.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Falcor帮助您在服务器上表示所有应用程序的数据作为一个虚拟的JSON模型。
- en: When programming client side, Falcor makes you feel as if the whole JSON model
    of your application is reachable locally, and allows you to read data the same
    way as you would from an in-memory JSON--you will learn it very soon!
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当进行客户端编程时，Falcor让您感觉整个应用程序的JSON模型都可以在本地访问，并允许您以与从内存中的JSON相同的方式读取数据——您很快就会学会这一点！
- en: Because of Falcor's library for browsers and the `falcor-express` middleware,
    you can retrieve your data from the model on-demand, from the cloud.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Falcor浏览器库和`falcor-express`中间件，您可以从云端的模型中按需检索数据。
- en: Falcor transparently handles all the network communication and keeps your client-side
    app in sync with the server and databases.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Falcor透明地处理所有网络通信，并保持您的客户端应用程序与服务器和数据库同步。
- en: In this chapter, we will also learn how to use `falcor-router`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们还将学习如何使用`falcor-router`。
- en: Client-side Falcor
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端Falcor
- en: 'Let''s install Falcor from NPM first:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从NPM安装Falcor：
- en: '[PRE55]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `falcor-http-datasource` helps us to retrieve data from server to client
    side, out-of-the-box (without worrying about HTTP API requests)--we will use this
    later when moving the client-side model to the backend.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`falcor-http-datasource`帮助我们从服务器检索数据到客户端，开箱即用（无需担心HTTP API请求）——我们将在将客户端模型移动到后端时使用它。'
- en: 'Let''s create our app''s Falcor model on the client side:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在客户端创建我们的应用程序Falcor模型：
- en: '[PRE56]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Then the content of the `falcorModel.js` will be as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 然后`falcorModel.js`的内容将如下所示：
- en: '[PRE57]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In this code, you can find a well-known, brief, and readable model of our publishing
    application with two articles in it.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，您可以找到一个包含两篇文章的我们发布应用的知名、简洁且易于阅读的模型。
- en: Now we will fetch that data from the frontend Falcor's model in our `src/layouts/PublishingApp.js`
    React component, we will add a new function called `_fetch()` which will be responsible
    for fetching all articles on our application start.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将从我们的`src/layouts/PublishingApp.js` React组件的前端Falcor模型中检索数据，我们将添加一个名为`_fetch()`的新函数，该函数将负责在应用程序启动时检索所有文章。
- en: 'We need to import our Falcor model first, so at the top of the `PublishingApp.js`
    file, we need to add the following:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要首先导入我们的Falcor模型，因此需要在`PublishingApp.js`文件的顶部添加以下内容：
- en: '[PRE58]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In our `PublishingApp` class, we need to add the following two functions; `componentWillMount`
    and `_fetch` (more explanation follows):'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`PublishingApp`类中，我们需要添加以下两个函数；`componentWillMount`和`_fetch`（更多解释随后）：
- en: '[PRE59]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Here, you see the asynchronous function called `_fetch`. This is a special syntax
    that allows you to use the `await` keyword like we do when using `let articlesLength
    = await falcorModel` and `let articles = await falcorModel`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，您可以看到名为`_fetch`的异步函数。这是一种特殊语法，允许您像使用`let articlesLength = await falcorModel`和`let
    articles = await falcorModel`一样使用`await`关键字。
- en: Using `async await` over Promises means our code is more readable and avoids
    callback hell situations where nesting multiple callbacks one after the other
    makes code very hard to read and extend.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`async await`代替Promise意味着我们的代码更易于阅读，并避免了回调地狱的情况，其中多个回调嵌套在一起使得代码难以阅读和扩展。
- en: The `async`/`await` feature is taken from ECMAScript 7 inspired by C#. It allows
    you to write functions that appear to be blocked at each asynchronous operation
    that is waiting for the result before continuing to the next operation.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`async`/`await`特性是从受C#启发的ECMAScript 7中提取的。它允许您编写在等待异步操作结果之前在每个异步操作上看似阻塞的函数，然后继续执行下一个操作。'
- en: 'In our example, the code will execute as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，代码将按以下方式执行：
- en: 'First it will call Falcor''s mode for an article count with the following:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先它将调用Falcor的模型以获取文章数量，如下所示：
- en: '[PRE60]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In the article's `Length` variable, we will have a count of `articles.length`
    from our model (in our case it will be number two).
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文章的`Length`变量中，我们将从我们的模型中获得`articles.length`的计数（在我们的例子中将是数字二）。
- en: 'After we know that we have two articles in our model, then the next block of
    code executes the following:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们知道我们的模型中有两篇文章之后，接下来的代码块执行以下操作：
- en: '[PRE61]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The `get` method on `falcorModel.get([''articles'', {from: 0, to: articlesLength-1},
    [''id'',''articleTitle'', ''articleContent'']]).` is also an asynchronous operation
    (in the same way as `http request`). In the `get` method''s parameter, we provide
    the location of our articles in our model (in `src/falcorModel.js`), so we are
    providing the following path:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`falcorModel.get([''articles'', {from: 0, to: articlesLength-1}, [''id'',''articleTitle'',
    ''articleContent'']]).` 上的 `get` 方法也是一个异步操作（与 `http 请求` 类似）。在 `get` 方法的参数中，我们提供了我们模型中文章的位置（在
    `src/falcorModel.js` 中），因此我们提供了以下路径：'
- en: '[PRE62]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The explanation of the preceding Falcor path is based on our model. Let''s
    call it again:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 上述Falcor路径的解释基于我们的模型。让我们再次调用它：
- en: '[PRE63]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'What we are saying to Falcor:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对Falcor所说的：
- en: 'First we want to get data from `articles` within our object using:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们想要使用以下方式从我们的对象中的`articles`获取数据：
- en: '[PRE64]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Next from `articles` collection select subset of all the articles it has with
    a range `{from: 0, to: articlesLength-1}` (the `articlesLength` we have fetched
    earlier) with the following path:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '接下来，从 `articles` 集合中选择所有文章的子集，范围是 `{from: 0, to: articlesLength-1}`（我们之前获取的
    `articlesLength`），路径如下：'
- en: '[PRE65]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The last step explains to Falcor, which properties from the object you want
    to fetch from our model. So the complete path in that `falcorModel.get` query
    is the following:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是向Falcor解释，你想要从对象中获取哪些属性。所以 `falcorModel.get` 查询中的完整路径如下：
- en: '[PRE66]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The array of `['id','articleTitle', 'articleContent']` says that you want those
    three properties out of every article.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`[''id'',''articleTitle'', ''articleContent'']` 数组表示你想要从每篇文章中获取这三个属性。'
- en: 'In the end, we receive an array of article objects from Falcor:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们从Falcor接收一个文章对象的数组：
- en: '![](img/00014.jpeg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00014.jpeg)'
- en: After we have fetched the data from our Falcor model, we need to dispatch an
    action that will change the article's reducer accordingly and ultimately re-render
    our list of articles from our Falcor model from the `const articleMock` (in `src/reducers/article.js`)
    instead.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们从Falcor模型获取数据之后，我们需要分发一个动作，该动作将相应地更改文章的reducer，并最终从 `const articleMock`（在
    `src/reducers/article.js` 中）重新渲染我们的文章列表。
- en: 'But before we will be able to dispatch an action, we need to do the following:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们能够分发一个动作之前，我们需要做以下事情：
- en: 'Create the `actions` directory with `article.js`:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `actions` 目录并包含 `article.js`：
- en: '[PRE67]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Create the content for our `src/actions/article.js` file as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式为我们的 `src/actions/article.js` 文件创建内容：
- en: '[PRE68]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: There isn't too much in that `actions/article.js` file `.` If you are familiar
    with FLUX already then it's very similar. One important rule for actions in Redux
    is that it has to be a pure function. For now, we will hardcode a constant called
    `ARTICLES_LIST_ADD` into `actions/article.js`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个 `actions/article.js` 文件中并没有太多内容 `.`。如果你已经熟悉FLUX，那么它非常相似。对于Redux中的动作，一个重要的规则是它必须是一个纯函数。现在，我们将一个名为
    `ARTICLES_LIST_ADD` 的常量硬编码到 `actions/article.js` 中。
- en: 'In the `src/layouts/PublishingApp.js` file we need to add a new import code
    at the top of the file:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `src/layouts/PublishingApp.js` 文件中，我们需要在文件顶部添加一个新的导入代码：
- en: '[PRE69]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'When you have added the preceding two in our `PublishingApp`, then modify our
    existing function in the same file from the following:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 `PublishingApp` 中添加了上述两个文件后，然后修改同一文件中现有的函数如下：
- en: '[PRE70]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Add `articleActions: bindActionCreators(articleActions, dispatch)` so that
    we are able to bind the articles'' actions into our `this.props` component:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '添加 `articleActions: bindActionCreators(articleActions, dispatch)` 以便我们能够将文章的动作绑定到我们的
    `this.props` 组件：'
- en: '[PRE71]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Thanks to the mentioned changes `(articleActions: bindActionCreators(articleActions,
    dispatch))` in our component, we will be able to dispatch an action from props
    because now, when you use `this.props.articleActions.articlesList(articles)` then
    the `articles` object fetched from Falcor will be available in our reducer (and
    from there, there is only one step to make our app fetch data work).'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '多亏了在组件中提到的这些更改 `(articleActions: bindActionCreators(articleActions, dispatch))`，我们现在将能够从props中分发一个动作，因为现在，当你使用
    `this.props.articleActions.articlesList(articles)` 时，从Falcor获取的 `articles` 对象将可用于我们的reducer（并且从那里，只需一步就可以让我们的应用程序获取数据工作）。'
- en: 'Now, after you are done with these changes, add an action into our component
    in the `_fetch` function:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在你完成这些更改之后，将一个动作添加到我们的组件的 `_fetch` 函数中：
- en: '[PRE72]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Our whole function for fetching will look as follows:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们整个获取函数看起来如下：
- en: '[PRE73]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Also, don''t forget about calling `_fetch` from `ComponentWillMount`:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，别忘了从 `ComponentWillMount` 中调用 `_fetch`：
- en: '[PRE74]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'At this point, we shall be able to receive an action in our Redux''s reducer.
    Let''s improve our `src/reducers/article.js` file:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，我们应当能够接收到Redux的reducer中的动作。让我们改进我们的 `src/reducers/article.js` 文件：
- en: '[PRE75]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: As you can see, we don't need `articleMock` anymore, so we have deleted it from
    the `src/reducers/article.js`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们不再需要`articleMock`，所以我们已经从`src/reducers/article.js`中删除了它。
- en: 'We have added a new case, `ARTICLES_LIST_ADD`:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个新的情况，`ARTICLES_LIST_ADD`：
- en: '[PRE76]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: It returns a new `articlesList` object (with a new reference in the memory,
    thanks to `Object.assign`).
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回一个新的`articlesList`对象（由于`Object.assign`，在内存中有新的引用）。
- en: 'Don''t confuse the two files with the same name and other locations, such as:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 不要混淆两个文件，它们具有相同的名称和其他位置，例如：
- en: '`reducers/article.js`'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`reducers/article.js`'
- en: '`actions/article.js`'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`actions/article.js`'
- en: You need to make sure that you are editing the correct file, otherwise the app
    won't work.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要确保你正在编辑正确的文件，否则应用程序将无法工作。
- en: A summary of client-side Falcor + Redux
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端Falcor + Redux的概述
- en: 'If you run `http://localhost:3000/index.html`, you will see that, currently
    we have two separate applications:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行`http://localhost:3000/index.html`，你会看到，目前我们有两个独立的应用程序：
- en: One at the frontend using Redux and client-side Falcor
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个在前端使用Redux和客户端Falcor
- en: One at the backend using MongoDB, Mongoose, and Express
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个在MongoDB、Mongoose和Express使用的后端
- en: We need to stick both together so we have one source of state for our applications
    (that comes from MongoDB).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将它们放在一起，以便我们有应用程序的一个状态源（来自MongoDB）。
- en: Moving Falcor's model to the backend
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Falcor模型移到后端
- en: 'We also need to update our `package.json` file:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更新我们的`package.json`文件：
- en: '[PRE77]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Because we are starting the full-stack development part, we need to add `npm
    start` to our scripts in `package.json`--this will help compile client side, put
    them into the `dist` folder (generated via webpack), and create static files in
    `dist`, and then use this folder as the source of static files (check `server/server.js`
    for `app.use(express.static('dist'));`).
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们要开始全栈开发部分，所以需要在`package.json`中的脚本中添加`npm start`--这将帮助编译客户端代码，将它们放入`dist`文件夹（通过webpack生成），并在`dist`中创建静态文件，然后使用此文件夹作为静态文件的源（检查`server/server.js`中的`app.use(express.static('dist'));`）。
- en: 'The next important thing is to install new dependencies that are required for
    Falcor on the backend:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个重要的事情是在后端安装Falcor所需的新依赖项：
- en: '[PRE78]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'When you have finally installed new dependencies and configured the basic scripts
    for running the backend and frontend on the same port, then edit the `server/server.js`
    as follows:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 当你最终安装了新依赖项并配置了在相同端口上运行后端和前端的基本脚本后，然后按照以下方式编辑`server/server.js`：
- en: 'On top of our file, import new libraries in the `server/server.js`:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的文件顶部，导入新的库到`server/server.js`：
- en: '[PRE79]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Then between the following two:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后在以下两个之间：
- en: '[PRE80]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Add new code for managing Falcor at the backend:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在后端添加管理Falcor的新代码：
- en: '[PRE81]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The preceding code is almost the same as the one in the `src/falcorModel.js`
    file. The only difference is that now Falcor will fetch data from the backend's
    mocked object, called `cache` in `server.js`.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述代码几乎与`src/falcorModel.js`文件中的代码相同。唯一的区别是现在Falcor将从后端的模拟对象中获取数据，在`server.js`中称为`cache`。
- en: 'The second part is to change our data source on the frontend, so in the `src/falcorModel.js`
    file, you change the following old code:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二部分是在前端更改我们的数据源，因此需要在`src/falcorModel.js`文件中更改以下旧代码：
- en: '[PRE82]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Change it to the following updated code:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改为以下更新后的代码：
- en: '[PRE83]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Run your app with the following:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行你的应用程序：
- en: '[PRE84]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'You will see in your browser''s dev tools a new HTTP request made by Falcor--for
    example, in our case:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将在浏览器开发工具中看到Falcor发起的新HTTP请求--例如，在我们的案例中：
- en: '![](img/00015.jpeg)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00015.jpeg)'
- en: 'If you follow all the instructions correctly, then you can also make a request
    to your server directly from your browser by executing this:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正确地遵循所有指示，那么你也可以通过执行以下操作直接从你的浏览器向你的服务器发送请求：
- en: '[PRE85]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Then you shall see a `jsonGraph` in the response:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你将看到响应中的`jsonGraph`：
- en: '![](img/00016.jpeg)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00016.jpeg)'
- en: You don't have to worry about those preceding two screenshots. They are just
    an example of how Falcor is communicating between the backend and frontend in
    Falcor's language. You don't have to worry anymore about exposing API endpoints
    and programming frontend to understand what data the backend is providing. Falcor
    is doing all of this out-of-the-box and you will learn more details while making
    this publishing application.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必担心前面的两个截图。它们只是Falcor在Falcor语言中如何在后端和前端之间通信的一个示例。你不必再担心暴露API端点和编程前端来理解后端提供的数据了。Falcor会自动完成所有这些，你将在制作此发布应用程序的过程中了解更多细节。
- en: Configuring Falcor's router (Express.js)
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Falcor的路由（Express.js）
- en: Currently, our model on the backend is hardcoded, so that it stays in the RAM
    memory of a server. We need to add the ability to read the data from our MongoDB's
    articles collection--this is where the `falcor-router` comes in handy.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，后端上的我们的模型是硬编码的，所以它保持在服务器的 RAM 内存中。我们需要添加从我们的 MongoDB 的文章集合中读取数据的能力--这就是 `falcor-router`
    发挥作用的地方。
- en: 'We need to create our routes definition files that will be consumed by `falcor-router`
    lib:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建我们的路由定义文件，这些文件将被 `falcor-router` 库消费：
- en: '[PRE86]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'We have created the `server/routes.js` file; the content for that router will
    be as follows:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了 `server/routes.js` 文件；该路由的内容如下：
- en: '[PRE87]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: As you can see, we have created our first route that will match the `articles.length`
    from our `_fetch` function (in `layouts/PublishingApp.js`).
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们已经创建了一条路由，它将匹配 `_fetch` 函数（在 `layouts/PublishingApp.js` 中）的 `articles.length`。
- en: We have hardcoded the number two in `articlesCountInDB`, later we will make
    a query to our database there.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `articlesCountInDB` 中硬编码了数字二，稍后我们将在这里进行数据库查询。
- en: 'The new stuff here is `route: ''articles.length''`, this is simply a route
    for matching by Falcor.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '这里新的是 `route: ''articles.length''`，这是一个简单的路由，用于通过 Falcor 匹配。'
- en: 'To be more precise, the Falcor routes'' paths are exactly the same stuff that
    you have provided in your `src/layouts/PublishingApp.js (_fetch function)` for
    example, to match this frontend call:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 更准确地说，Falcor 路由的路径与你提供的完全相同的东西，例如在 `src/layouts/PublishingApp.js (_fetch 函数)`
    中，用于匹配这个前端调用：
- en: '[PRE88]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '`path: [''articles'', ''length'']`: This property tells us Falcor''s path (it''s
    consumed by Falcor at the backend and frontend). We need to provide that because
    sometimes, one route can return many different objects as server articles (you
    will see it in the next route we create).'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path: [''articles'', ''length'']`：这个属性告诉我们 Falcor 的路径（它在后端和前端被 Falcor 消费）。我们需要提供这个，因为有时，一个路由可以返回许多不同的对象作为服务器文章（你将在我们创建的下一条路由中看到）。'
- en: '`value: articlesCountInDB`: This is a return value. In this case, it is an
    integer number, but it can also be an object with several properties, as you will
    learn later.'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value: articlesCountInDB`：这是一个返回值。在这种情况下，它是一个整数，但它也可以是一个具有多个属性的对象，正如你稍后将要了解到的。'
- en: Second route for returning our two articles from the backend
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二条路由用于从后端返回我们的两个文章
- en: 'Our second route (and last one in this chapter) will be the following:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二条路由（也是本章的最后一个）将是以下内容：
- en: '[PRE89]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The new thing in the second route is `pathSet`, if you log that into the console,
    then you will see, in our case (when trying to run our full-stack app) the following:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 第二条路由中的新内容是 `pathSet`，如果你将其输出到控制台，那么你将看到，在我们的情况下（当我们尝试运行我们的全栈应用时），以下内容：
- en: '[PRE90]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '`pathSet` tells us what indexes are requested from the client side (`[ 0, 1
    ]`, in our example).'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '`pathSet` 告诉我们客户端请求了哪些索引（在我们的例子中是 `[ 0, 1 ]`）。'
- en: 'Because, in this case, we are returning an array of articles (multiple articles),
    we need to create a result variable:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 因为，在这种情况下，我们正在返回一个文章数组（多个文章），我们需要创建一个结果变量：
- en: '[PRE91]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Iterate over the requested indexes:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历请求的索引：
- en: '[PRE92]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Return that array of articles:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 返回该文章数组：
- en: '[PRE93]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '`console.info` will show us what has been returned by that path:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.info` 将显示该路径返回的内容：'
- en: '[PRE94]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Final touch to make full-stack Falcor run
  id: totrans-393
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最后的润色，使全栈 Falcor 运行
- en: Currently, we still have mocked data in our routes, but before we start making
    calls to MongoDB, we need to wrap up the current setup so you will be able to
    see it running in your browser.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们还在路由中使用模拟数据，但在我们开始调用 MongoDB 之前，我们需要整理当前设置，这样你就可以在你的浏览器中看到它运行。
- en: 'Open your `server/server.js` and make sure you import the following two things:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的 `server/server.js` 并确保你导入以下两个内容：
- en: '[PRE95]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Now that we have imported our `falcor-router` and `routes.js`--we need to use
    them, so modify this old code:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经导入了我们的 `falcor-router` 和 `routes.js`--我们需要使用它们，所以修改以下旧代码：
- en: '[PRE96]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Replace the preceding code with:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的代码替换为：
- en: '[PRE97]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: This will work only when the `falcor-router` has been already installed and
    imported in the `server.js` file. This is a library for `DataSource` that creates
    a virtual JSON graph document on your app server. As you can see in `server.js`
    so far we have `DataSource` provided by our hardcoded model, `return model.asDataSource();`.
    The router here will make the same, but now you will be able to match routes based
    on your app requirements.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 这只会在 `falcor-router` 已经在 `server.js` 文件中安装并导入时工作。这是一个 `DataSource` 库，它在你应用服务器上创建一个虚拟的
    JSON 图文档。正如你在 `server.js` 中迄今为止所看到的，我们有一个由我们硬编码的模型提供的 `DataSource`，`return model.asDataSource();`。这里的路由器将做同样的事情，但现在你将能够根据你的应用需求匹配路由。
- en: Also, as you can see, the new `falcorRouter` takes an argument of our routes `return
    new falcorRouter(routes);`.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，正如你所看到的，新的 `falcorRouter` 接受我们的路由参数 `return new falcorRouter(routes);`。
- en: 'If you have followed the instructions correctly, you will be able to run the
    project:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正确地遵循了指示，你将能够运行项目：
- en: '[PRE98]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'On port `3000`, you will see the following:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在端口 `3000` 上，你会看到以下内容：
- en: '![](img/00017.jpeg)'
  id: totrans-406
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00017.jpeg)'
- en: Adding MongoDB/Mongoose calls based on Falcor's routes
  id: totrans-407
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根据 Falcor 的路由添加 MongoDB/Mongoose 调用
- en: 'Let''s get back to our `server/routes.js` file. We need to move over (delete
    from `server.js` and move into `routes.js`) this following code:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的 `server/routes.js` 文件。我们需要移动（从 `server.js` 删除并移动到 `routes.js`）以下代码：
- en: '[PRE99]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'In the first route `articles.length`, you need to replace the mocked number
    two (the articles count) into Mongoose''s `count` method:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个路由 `articles.length` 中，你需要将模拟的数字二（文章数量）替换为 Mongoose 的 `count` 方法：
- en: '[PRE100]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: We are returning a Promise in `get` (Mongoose, by its asynchronous nature, always
    returns a Promise while making any database's request, as in the example, `Article.count`).
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `get` 中返回一个 Promise（由于 Mongoose 的异步性质，在执行任何数据库请求时，它总是返回一个 Promise，如示例中的
    `Article.count`）。
- en: The method `Article.count` simply retrieves the integer number of articles'
    count from our *Article* model (that was prepared at the beginning of this book
    in `MongoDB/Mongoose sub-chapter`).
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 `Article.count` 简单地从我们的 *Article* 模型（本书开头在 `MongoDB/Mongoose 子章节` 中准备）中检索文章数量的整数。
- en: 'The second route `route: ''articles[{integers}]["id","articleTitle","articleContent"]''`,
    has to be changed as follows:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '第二个路由 `route: ''articles[{integers}]["id","articleTitle","articleContent"]''`
    需要按照以下方式更改：'
- en: '[PRE101]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: We return a Promise again with `Article.find`. Also, we have deleted the mocked
    response from the database and instead we are using the `Article.find` method.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用 `Article.find` 返回一个 Promise。同时，我们已经从数据库中删除了模拟的响应，而是使用 `Article.find`
    方法。
- en: The array of articles is returned in `}).then ((articlesArrayFromDB) => {` and
    next we simply iterate and create a results array.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 文章数组通过 `}).then ((articlesArrayFromDB) => {` 返回，接下来我们只需迭代并创建一个结果数组。
- en: Note that on `const singleArticleObject = articlesArrayFromDB[index].toObject();`
    we use a method `.toObject`. This is very important for making this work.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 `const singleArticleObject = articlesArrayFromDB[index].toObject();` 我们使用了
    `.toObject` 方法。这对于使这个工作非常重要。
- en: Double-check with the server/routes.js and package.json
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 server/routes.js 和 package.json 进行双重检查
- en: 'In order to save you time in case the app doesn''t run, we can double-check
    that the backend''s Falcor routes are prepared correctly:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在应用没有运行的情况下节省你的时间，我们可以再次检查后端的 Falcor 路由是否正确准备：
- en: '[PRE102]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Check that your `server/routes.js` file looks similar to the preceding code
    and the other code elements that you have used.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的 `server/routes.js` 文件看起来与前面的代码以及你使用的其他代码元素相似。
- en: 'Also, check that your `package.json` look likes the following one:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，检查你的 `package.json` 看起来如下所示：
- en: '[PRE103]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'The important thing to notice about `package.json` is that we have removed
    the `^` from `"mongoose": "4.4.5"`. We did this because if NPM installs any higher
    version than `4.4.5`, then we get a warning in the bash/command line.'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '关于 `package.json` 的重要事项是，我们已经从 `"mongoose": "4.4.5"` 中移除了 `^`。我们这样做是因为如果 NPM
    安装了高于 `4.4.5` 的任何版本，那么我们会在 bash/命令行中得到一个警告。'
- en: Our first working full-stack app
  id: totrans-426
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一个工作全栈应用
- en: 'After that, you should have a complete full-stack version of the app working:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你应该有一个完整的全栈版本的应用程序正在运行：
- en: '![](img/00018.jpeg)'
  id: totrans-428
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00018.jpeg)'
- en: 'At almost every step, the UI part of our app is identical. The preceding screenshot
    is the publishing app, which does the following:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎在每一步，我们应用的 UI 部分都是相同的。前面的截图是发布应用，它执行以下操作：
- en: Fetches data from the DB using `Falcor-Express` and `Falcor-Router`.
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Falcor-Express` 和 `Falcor-Router` 从数据库获取数据。
- en: The data moves from the backend (the source is MongoDB) to the frontend. We
    populate Redux's `src/reducers/article.js` state tree.
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据从后端（源为 MongoDB）移动到前端。我们填充 Redux 的 `src/reducers/article.js` 状态树。
- en: We render the DOM elements based on our single state tree.
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们根据我们的单个状态树渲染 DOM 元素。
- en: All these steps allow us to take all of the full-stack app's data from the database,
    to the user's browser (so a user can see an article).
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有这些步骤使我们能够将全栈应用的所有数据从数据库传输到用户的浏览器（因此用户可以看到文章）。
- en: Summary
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We haven't started to work on the app design, but in our book, we will use the
    Material Design CSS for React ([http://material-ui.com](http://material-ui.com)).
    In the next chapter, we will start using it for user registration and login. After
    that, we will re-style the main page of our application using Material Design's
    components.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有开始设计应用界面，但在我们的书中，我们将使用为React设计的Material Design CSS（[http://material-ui.com](http://material-ui.com)）。在下一章中，我们将开始使用它来处理用户注册和登录。之后，我们将使用Material
    Design的组件重新设计我们应用的主页。
- en: 'In order to give you a teaser of the goal (while working through the book),
    here is a screenshot of the app and how the publishing app will improve in the
    following chapters:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在你阅读本书的过程中给你一个目标预览，这里有一张应用截图以及接下来章节中出版应用将如何改进：
- en: '![](img/00019.jpeg)'
  id: totrans-437
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00019.jpeg)'
- en: In the preceding screenshot, there is an example article from our application.
    We are using several Material Design components in order to make our work easier
    and the publishing app look more professional. You will learn it later.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中有我们应用的一个示例文章。我们正在使用几个Material Design组件来简化我们的工作并使出版应用看起来更加专业。你将在稍后学习到这些内容。
- en: Are you ready to work on the full-stack login and registration for our publishing
    app in the next chapter? Let's continue the fun.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 你准备好在下一章中为我们的出版应用全栈登录和注册功能工作了么？让我们继续享受乐趣。
