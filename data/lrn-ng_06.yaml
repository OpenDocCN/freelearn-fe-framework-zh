- en: Building an Application with Angular Components
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Angular组件构建应用程序
- en: We have reached a point in our journey where we can successfully develop more
    complex applications by nesting components within other components, in a sort
    of component tree. However, bundling all our component logic in a unique file
    is definitely not the way to go. Our application might become unmaintainable very
    soon and, as we will see later in the chapter, we would be missing the advantages
    that Angular's dependency management mechanism can bring to the game.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经达到了一个阶段，在这个阶段，我们可以通过在其他组件中嵌套组件来成功开发更复杂的应用程序，形成一种组件树。然而，将所有组件逻辑捆绑在一个唯一的文件中绝对不是正确的方法。我们的应用程序很快可能变得难以维护，并且正如我们将在本章后面看到的那样，我们将错过Angular的依赖管理机制可以为游戏带来的优势。
- en: In this chapter, we will see how to build application architectures based on
    trees of components, and how the new Angular dependency injection mechanism will
    help us to declare and consume our dependencies across the application with minimum
    effort and optimal results.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到如何基于组件树构建应用程序架构，以及新的Angular依赖注入机制如何帮助我们以最小的工作量和最佳结果声明和使用应用程序中的依赖项。
- en: 'In this chapter, we will cover these topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Best practices for directory structures and naming conventions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目录结构和命名约定的最佳实践
- en: Different approaches to dependency injection
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入的不同方法
- en: Injecting dependencies into our custom types
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将依赖项注入到我们的自定义类型中
- en: Overriding global dependencies throughout the component tree
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在整个组件树中覆盖全局依赖项
- en: Interacting with the host component
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与宿主组件交互
- en: Overviewing the directive lifecycle
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概述指令生命周期
- en: Overviewing the component lifecycle
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概述组件生命周期
- en: Introducing the component tree
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍组件树
- en: Modern web applications based on web component architectures often conform to
    a sort of tree hierarchy, wherein the top main component (usually dropped somewhere
    in the main HTML index file) acts as a global placeholder where child components
    turn into hosts for other nested child components, and so on and so forth.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Web组件架构的现代Web应用程序通常符合一种树形层次结构，其中顶层主要组件（通常放置在主HTML索引文件的某个位置）充当全局占位符，子组件成为其他嵌套子组件的宿主，依此类推。
- en: There are obvious advantages to this approach. On one hand, reusability does
    not get compromised and we can reuse components throughout the component tree
    with little effort. Secondly, the resulting granularity reduces the burden required
    for envisioning, designing, and maintaining bigger applications. We can simply
    focus on a single piece of UI and then wrap its functionality around new layers
    of abstraction until we wrap up a full-blown application from the ground up.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有明显的优势。一方面，可重用性不会受到损害，我们可以轻松地在组件树中重用组件。其次，由此产生的细粒度减少了构想、设计和维护更大型应用程序所需的负担。我们可以简单地专注于单个UI部分，然后将其功能包装在新的抽象层周围，直到我们从头开始包装一个完整的应用程序。
- en: 'Alternatively, we can approach our web application the other way around, and
    start from a more generic functionality just to end up breaking down the app into
    smaller pieces of UI and functionality, which become our web components. The latter
    has become the most common approach when building component-based architectures.
    We will stick to it for the rest of the book, undertaking architectures as the
    one depicted here:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以从另一个角度来处理我们的Web应用程序，从更通用的功能开始，最终将应用程序拆分为更小的UI和功能部分，这些部分成为我们的Web组件。后者已成为构建基于组件的架构时最常见的方法。我们将在本书的其余部分坚持这一方法，将架构视为下图所示的架构：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For the sake of clarity, this chapter will just borrow the code we wrote in
    the previous chapters, and we will deconstruct it into a component hierarchy.
    We will also allocate some room in the resulting application for all the supporting
    classes and models required to give shape to our Pomodoro tool. This will turn
    into a perfect opportunity to learn the intricacies of the dependency injection
    machinery baked into Angular, as we will see later in this chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，本章将借用我们在前几章中编写的代码，并将其拆分为组件层次结构。我们还将为最终应用程序中所有支持类和模型分配一些空间，以塑造我们的番茄工具。这将成为学习Angular中内置的依赖注入机制的绝佳机会，我们将在本章后面看到。
- en: Common conventions for scalable applications
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可扩展应用程序的通用约定
- en: In all fairness, we have already tackled a good number of the common concerns
    that modern web developers confront when building applications, small and large
    alike, nowadays. Therefore, it makes sense to define an architecture that will
    separate the aforementioned concerns into separate domain folders, catering to
    media assets and shared code units.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 公平地说，我们已经解决了现代网页开发人员在构建应用程序时所面临的许多常见问题，无论是小型还是大型应用程序。因此，定义一个架构来将上述问题分离成单独的领域文件夹，满足媒体资产和共享代码单元的需求是有意义的。
- en: Angular's approach to separating the code and assets into logical units is by
    organizing them into different folders, but also by introducing the concept of
    an Angular module. It is in these modules that the constructs are registered.
    By introducing modules, a lot of the noise have disappeared from our components
    and our components are free to use the other constructs of the same module and,
    in some cases, constructs from other modules, given that their containing module
    is imported first.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Angular将代码和资产分离的方法是通过将它们组织到不同的文件夹中，同时引入Angular模块的概念。在这些模块中注册构造。通过引入模块，我们的组件中的许多噪音已经消失，我们的组件可以自由地使用同一模块中的其他构造，有时甚至可以使用其他模块中的构造，前提是导入其所在的模块。
- en: It's worth emphasizing that when we are talking about Angular modules, we mean
    the `@NgModule` decorator and when we otherwise talk about modules, we mean the
    ES2015 construct.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 值得强调的是，当我们谈论Angular模块时，我们指的是`@NgModule`装饰器，当我们谈论模块时，我们指的是ES2015构造。
- en: Sometimes, two contexts may require sharing the same entities, and that is fine
    (as long as it does not become a common thing in our project, which would denote
    a serious design issue). Also worth emphasizing is that we use the word *context*
    to describe a logical boundary of constructs. A context is best kept within an
    Angular module. So, every time the word *context* is used, think that it will
    in code translate to an Angular module.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，两个上下文可能需要共享相同的实体，这是可以接受的（只要在我们的项目中不成为常见情况，这将表示严重的设计问题）。还值得强调的是，我们使用“上下文”一词来描述构造的逻辑边界。上下文最好保留在一个Angular模块中。因此，每当使用“上下文”一词时，都要考虑在代码中将其转换为一个Angular模块。
- en: 'The following example, applied to our previous work on Pomodoro components,
    depicts this scheme, essentially making out our entire application of contexts
    and different constructs:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例应用于我们之前在番茄工作法组件上的工作，基本上构成了我们整个应用程序的上下文和不同构造。
- en: 'Task context:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务上下文：
- en: Task module
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务模块
- en: Task model
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务模型
- en: Tasks service
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务服务
- en: Task table component
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务表组件
- en: Task pomodoros component
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务番茄钟组件
- en: Task tooltip directive
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务工具提示指令
- en: 'Timer context:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计时器上下文：
- en: Timer module
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计时器模块
- en: Timer feature
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计时器功能
- en: Timer component
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计时器组件
- en: 'Admin context:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理员上下文：
- en: Admin module
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理员模块
- en: Authentication service
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证服务
- en: Login component
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录组件
- en: Editor component
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑器组件
- en: 'Shared context:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享上下文：
- en: Shared module
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享模块
- en: Components shared across features
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨功能共享的组件
- en: Pipes shared across features
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨功能共享的管道
- en: Directives shared across features
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨功能共享的指令
- en: Global models and services
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局模型和服务
- en: Shared media assets
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享媒体资产
- en: As we can see, the first step is to define the different features our application
    needs, keeping in mind that each one should make sense on its own in isolation
    from the others. Once we define the set of features required, we will create a
    module for each one. Each module will then be filled with the components, directives,
    pipes, models, and services that shape the feature it represents. Always remember
    the principles of encapsulation and reusability when defining your features set.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，第一步是定义应用程序需要的不同功能，要记住的是，每个功能在与其他功能隔离时应该是有意义的。一旦我们定义了所需的功能集，我们将为每个功能创建一个模块。然后，每个模块将填充代表其特征的组件、指令、管道、模型和服务。在定义功能集时，请始终记住封装和可重用性的原则。
- en: 'Initially, when starting your project, you should name your constructs after
    what they are, so say we have the `Admin` context, it should look something like
    this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，在启动项目时，您应该根据它们的名称命名您的构造，所以说我们有`Admin`上下文，它应该看起来像这样：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'With a quick glance, you should be able to see what the construct contains,
    so use a naming standard that looks like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通过快速浏览，您应该能够看到构造包含的内容，因此使用类似于以下的命名标准：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This is not the only way to do it, of course. There is another perfectly acceptable
    way of doing it, namely to create subdirectories for each type, so your preceding `admin`
    directory could look like this instead:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这不是唯一的方法。还有另一种完全可以接受的方法，即为每种类型创建子目录，因此您之前的`admin`目录可能看起来像这样：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It is worth noting that you should keep the type in the filename for clarity
    in debugging. Otherwise, when looking for a specific file to set a breakpoint
    in your browser, let''s say the login service, it might be quite confusing if
    you start typing `login.ts` and you are presented with:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，为了便于调试，您应该在文件名中保留类型。否则，当在浏览器中寻找特定文件以设置断点时，比如登录服务，如果您开始输入`login.ts`，然后出现以下情况可能会相当令人困惑：
- en: '`components/login.ts`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`components/login.ts`'
- en: '`services/login.ts`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`services/login.ts`'
- en: '`pipes/login.ts`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pipes/login.ts`'
- en: There is an official style guide in place for how you should organize your code
    and how to name your constructs. There are definitely benefits to following a
    guide; it's easy for newcomers, the code looks more consistent, and so on. You
    can read more here; [https://angular.io/guide/styleguide](https://angular.io/guide/styleguide).
    Remember that whether you choose to follow this style guide in its entirety or
    not, consistency is key as it will make it easier to maintain the code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个官方的样式指南，告诉您应该如何组织代码以及如何命名您的构造。遵循指南肯定有好处；对新手来说很容易，代码看起来更一致等等。您可以在这里阅读更多信息；[https://angular.io/guide/styleguide](https://angular.io/guide/styleguide)。请记住，无论您选择是否完全遵循此样式指南，一致性都很重要，因为这将使维护代码变得更容易。
- en: File and ES6 module naming conventions
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件和ES6模块命名约定
- en: Each one of our feature folders will host a wide range of files, so we need
    a consistent naming convention to prevent filename collisions while we ensure
    that the different code units are easy to locate.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的每个功能文件夹将托管各种文件，因此我们需要一致的命名约定，以防止文件名冲突，同时确保不同的代码单元易于定位。
- en: 'The following list summarizes the current conventions enforced by the community:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表总结了社区强制执行的当前约定：
- en: Each file should contain a single code unit. Simply put, each component, directive,
    service, pipe, and so on should live in its own file. This way, we contribute
    to a better organization of code.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个文件应包含一个代码单元。简而言之，每个组件、指令、服务、管道等都应该存在于自己的文件中。这样，我们有助于更好地组织代码。
- en: Files and directories are named in lower-kebab-case.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件和目录以小写kebab-case命名。
- en: 'Files representing components, directives, pipes, and services should append
    a type suffix to their name: `video-player.ts` will become `video-player.component.ts`.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示组件、指令、管道和服务的文件应该在它们的名称后面添加一个类型后缀：`video-player.ts`将变成`video-player.component.ts`。
- en: Any component's external HTML template or CSS style sheet filename will match
    the component filename, including the suffix. Our `video-player.component.ts`
    might be accompanied by `video-player.component.css` and `video-player.component.html`.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何组件的外部HTML模板或CSS样式表文件名都将与组件文件名匹配，包括后缀。例如，我们的`video-player.component.ts`可能会有`video-player.component.css`和`video-player.component.html`。
- en: Directive selectors and pipe names are camelCased, while component selectors
    are lower-kebab-cased. Plus, it is strongly advised to add a custom prefix of
    our choice to prevent name collisions with other component libraries. For example,
    following up our video player component, it may be represented as `<vp-video-player>`,
    where `vp-` (which stands for video-player) is our custom prefix.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指令选择器和管道名称采用驼峰式命名，而组件选择器采用小写kebab-case命名。此外，强烈建议添加我们选择的自定义前缀，以防止与其他组件库发生名称冲突。例如，跟随我们的视频播放器组件，它可以表示为`<vp-video-player>`，其中`vp-`（代表video-player）是我们的自定义前缀。
- en: Modules are named by following the rule of taking a PascalCased
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块的命名遵循PascalCased规则
- en: self-descriptive name, plus the type it represents. For example, if we see a
    module named `VideoPlayerComponent`, we can easily tell it is a component. The
    custom prefix in use for selectors (`vp-`, in our example) should not be part
    of the module name.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 自描述名称，以及它所代表的类型。例如，如果我们看到一个名为`VideoPlayerComponent`的模块，我们可以轻松地知道它是一个组件。在选择器中使用的自定义前缀（在我们的示例中为`vp-`）不应该成为模块名称的一部分。
- en: Models and interfaces require special attention, though. Depending on your application
    architecture, model types will feature more or less relevance. Architectures such
    as MVC, MVVM, Flux, or Redux tackle models from different standpoints and grades
    of importance. Ultimately, it will be up to you and your architectural design
    pattern of choice to approach models and their naming convention in one way or
    another. This book will not be opinionated in that sense, although we do enforce
    interface models in our example application and will create modules for them.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型和接口需要特别注意。根据您的应用程序架构，模型类型的相关性会更多或更少。诸如MVC、MVVM、Flux或Redux的架构从不同的角度和重要性等级处理模型。最终，您和您选择的架构设计模式将决定以一种方式或另一种方式处理模型和它们的命名约定。本书在这方面不会表达观点，尽管我们在示例应用程序中强制执行接口模型，并将为它们创建模块。
- en: Each component and shared context of business logic in our application is intended
    to integrate with the other pieces of the puzzle in a simple and straightforward
    way. Clients of each subdomain are not concerned about the internal structure
    of the subdomain itself. If our timer feature, for example, evolves to the point
    of having two dozen components and directives that need to be reorganized into
    different folder levels, external consumers of its functionalities should remain
    unaffected.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应用程序中的每个业务逻辑组件和共享上下文都旨在以简单直接的方式与其他部分集成。每个子域的客户端都不关心子域本身的内部结构。例如，如果我们的定时器功能发展到需要重新组织成不同的文件夹层次结构，其功能的外部消费者应该保持不受影响。
- en: From facades/barrels to NgModule
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从facade/barrel到NgModule
- en: 'There comes a need to group your constructs into logical groups as your application
    grows. As the application grows, you also realize that not all constructs should
    be able to talk to each other, so you also need to think about restricting this.
    Before `@NgModule` was added to the framework, the natural course of action was
    to think of facade modules, which essentially meant that we created a specific
    file with the sole purpose of deciding what would get exported to the outside
    world. This could look like the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序的增长，有必要将构造分组为逻辑组。随着应用程序的增长，您还意识到并非所有构造都应该能够相互通信，因此您还需要考虑限制这一点。在框架中添加`@NgModule`之前，自然的做法是考虑外观模块，这基本上意味着我们创建了一个具有决定将被导出到外部世界的唯一目的的特定文件。这可能看起来像下面这样：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Everything else not explicitly exported would be considered as private or internal
    to the feature. Using one of the exported constructs would be as easy as typing:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一切未明确导出的内容都将被视为私有或内部特性。使用其中一个导出的构造将像输入一样简单：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This was a valid way of dealing with grouping as well as restricting access.
    We keep these two features in mind as we delve deeper into `@NgModule` in the
    next subsection.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种处理分组和限制访问的有效方式。当我们深入研究下一小节中的`@NgModule`时，我们将牢记这两个特性。
- en: Using NgModule
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NgModule
- en: 'With the arrival of `@NgModule`, we suddenly had a more logical way of grouping
    our constructs and also a natural way of deciding what got to be exported or not.
    The following piece of code corresponds to the preceding facade code, but it uses `@NgModule` 
     instead:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 随着`@NgModule`的到来，我们突然有了一种更合乎逻辑的方式来分组我们的构造，并且也有了一种自然的方式来决定什么可以被导出或不导出。以下代码对应于前面的外观代码，但它使用了`@NgModule`：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This would create the same effect and the construct is called a feature module.
    The `exports`keyword is what says what is publicly accessible or not. Getting
    access to what is publicly exposed looks a bit different though. Instead of typing:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建相同的效果，该构造称为特性模块。`exports`关键字表示了什么是公开访问的或不是。然而，获取公开访问的内容看起来有点不同。而不是输入：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We would need to import our feature module into our root module. This means
    our root module would look like the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将我们的特性模块导入到我们的根模块中。这意味着我们的根模块将如下所示：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This would now give us access to the exported components in the template markup.
    So in your upcoming app building, think about what belongs in a root module, what
    is part of a feature, and what is more common and used everywhere in the app.
    This is how you need to break apart your app, first in modules and then in proper
    constructs like components, directives, pipes, and so on.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们能够在模板标记中访问导出的组件。因此，在您即将构建的应用程序中，请考虑什么属于根模块，什么是特性的一部分，以及什么是更常见的并且在整个应用程序中都使用。这是您需要拆分应用程序的方式，首先是模块，然后是适当的构造，如组件、指令、管道等。
- en: How dependency injection works in Angular
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Angular中依赖注入是如何工作的
- en: As our applications grow and evolves, each one of our code entities will internally
    require instances of other objects, which are better known as dependencies in
    the world of software engineering. The action of passing such dependencies to
    the dependent client is known as injection, and it also entails the participation
    of another code entity, named the injector. The injector will take responsibility
    for instantiating and bootstrapping the required dependencies so they are ready
    for use from the very moment they are successfully injected in the client. This
    is very important since the client knows nothing about how to instantiate its
    own dependencies and is only aware of the interface they implement in order to
    use them.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的应用程序的增长和发展，我们的每一个代码实体在内部都需要其他对象的实例，这在软件工程领域更为常见的称为依赖关系。将这些依赖关系传递给依赖客户端的行为称为注入，它还涉及另一个名为注入器的代码实体的参与。注入器将负责实例化和引导所需的依赖关系，以便在成功注入客户端后立即可以使用。这非常重要，因为客户端对如何实例化自己的依赖关系一无所知，只知道它们实现的接口以便使用它们。
- en: Angular features a top-notch dependency injection mechanism to ease the task
    of exposing required dependencies to any entity that might exist in an Angular
    application, regardless of whether it is a component, a directive, a pipe, or
    any other custom service or provider object. In fact, as we will see later in
    this chapter, any entity can take advantage of dependency injection (usually referred
    to as DI) in an Angular application. Before delving deeper into the subject, let's
    look at the problem that Angular's DI is trying to address.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Angular具有一流的依赖注入机制，可以轻松地将所需的依赖关系暴露给Angular应用程序中可能存在的任何实体，无论是组件、指令、管道还是任何其他自定义服务或提供者对象。事实上，正如我们将在本章后面看到的，任何实体都可以利用Angular应用程序中的依赖注入（通常称为DI）。在深入讨论这个主题之前，让我们先看看Angular的DI试图解决的问题。
- en: 'Let''s figure out if we have a music player component that relies on a `playlist`
    object to broadcast music to its users:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们是否有一个音乐播放器组件，它依赖于一个“播放列表”对象来向用户播放音乐：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `Playlist`type could be a generic class that returns in its API a random
    list of songs or whatever. That is not relevant now, since the only thing that
    matters is that our `MusicPlayerComponent`entity does need it to deliver its functionality.
    Unfortunately, the previous implementation means that both types are tightly coupled,
    since the component instantiates the playlist within its own constructor. This
    prevents us from altering, overriding, or mocking up in a neat way the `Playlist`class
    if required. It also entails that a new `Playlist` object is created every time
    we instantiate a `MusicPlayerComponent`. This might be not desired in certain
    scenarios, especially if we expect a singleton to be used across the application
    and thus keep track of the playlist's state.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: “播放列表”类型可能是一个通用类，在其API中返回一个随机的歌曲列表或其他内容。现在这并不重要，因为唯一重要的是我们的“MusicPlayerComponent”实体确实需要它来提供功能。不幸的是，先前的实现意味着这两种类型紧密耦合，因为组件在自己的构造函数中实例化了播放列表。这意味着如果需要，我们无法以整洁的方式更改、覆盖或模拟“播放列表”类。这也意味着每次我们实例化一个“MusicPlayerComponent”时都会创建一个新的“播放列表”对象。在某些情况下，这可能是不希望的，特别是如果我们希望在整个应用程序中使用单例并因此跟踪播放列表的状态。
- en: 'Dependency injection systems try to solve these issues by proposing several
    patterns, and the constructor injection pattern is the one enforced by Angular.
    The previous piece of code could be rethought like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入系统试图通过提出几种模式来解决这些问题，而构造函数注入模式是Angular强制执行的模式。前面的代码片段可以重新思考如下：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, the `Playlist`is instantiated outside our component. On the other hand,
    the `MusicPlayerComponent`expects such an object to be already available before
    the component is instantiated so it can be injected through its constructor. This
    approach gives us the opportunity to override it or mock it up if we wish.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Playlist`是在我们的组件外部实例化的。另一方面，`MusicPlayerComponent`期望在组件实例化之前已经有这样一个对象可用，以便通过其构造函数注入。这种方法使我们有机会覆盖它或者模拟它。
- en: Basically, this is how dependency injection, and more specifically the constructor
    injection pattern, works. However, what has this got to do with Angular? Does
    Angular's dependency injection machinery work by instantiating types by hand and
    injecting them through the constructor? Obviously not, mostly because we do not
    instantiate components by hand either (except when writing unit tests). Angular
    features its own dependency injection framework, which can be used as a standalone
    framework by other applications, by the way.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这就是依赖注入的工作原理，更具体地说是构造函数注入模式。但是，这与Angular有什么关系呢？Angular的依赖注入机制是通过手动实例化类型并通过构造函数注入它们吗？显然不是，主要是因为我们也不会手动实例化组件（除非编写单元测试时）。Angular具有自己的依赖注入框架，顺便说一句，这个框架可以作为其他应用程序的独立框架使用。
- en: The framework offers an actual injector that can introspect the tokens used
    to annotate the parameters in the constructor and return a singleton instance
    of the type represented by each dependency, so we can use it straight away in
    the implementation of our class, as in the previous example. The injector ignores
    how to create an instance of each dependency, so it relies on the list of providers
    registered upon bootstrapping the application. Each one of those providers actually
    provides mappings over the types marked as application dependencies. Whenever
    an entity (let's say a component, a directive, or a service) defines a token in
    its constructor, the injector searches for a type matching that token in the pool
    of registered providers for that component. If no match is found, it will then
    delegate the search on the parent component's provider, and will keep conducting
    the provider's lookup upwards until a provider resolves with a matching type or
    the top component is reached. Should the provider lookup finish with no match,
    Angular will throw an exception.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 该框架提供了一个实际的注入器，可以审视构造函数中用于注释参数的标记，并返回每个依赖类型的单例实例，因此我们可以立即在类的实现中使用它，就像前面的例子一样。注入器不知道如何创建每个依赖项的实例，因此它依赖于在应用程序引导时注册的提供者列表。这些提供者实际上提供了对标记为应用程序依赖项的类型的映射。每当一个实体（比如一个组件、一个指令或一个服务）在其构造函数中定义一个标记时，注入器会在该组件的已注册提供者池中搜索与该标记匹配的类型。如果找不到匹配项，它将委托给父组件的提供者进行搜索，并将继续向上进行提供者的查找，直到找到与匹配类型的提供者或者达到顶层组件。如果提供者查找完成后没有找到匹配项，Angular将抛出异常。
- en: The latter is not exactly true, since we can mark dependencies in the constructor
    with the `@Optional` parameter decorator, in which case Angular will not throw
    any exception and the dependency parameter will be injected as null if no provider
    is found.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 后者并不完全正确，因为我们可以使用`@Optional`参数装饰器在构造函数中标记依赖项，这种情况下，如果找不到提供者，Angular将不会抛出任何异常，并且依赖参数将被注入为null。
- en: Whenever a provider resolves with a type matching that token, it will return
    such type as a singleton, which will be therefore injected by the injector as
    a dependency. In fairness, the provider is not just a collection of key/value
    pairs coupling tokens with previously registered types, but a factory that instantiates
    these types and also instantiates each dependency's very own dependencies as well,
    in a sort of recursive dependency instantiation.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 每当提供程序解析为与该令牌匹配的类型时，它将返回此类型作为单例，因此将被注入器作为依赖项注入。公平地说，提供程序不仅仅是将令牌与先前注册的类型进行配对的键/值对集合，而且还是一个工厂，它实例化这些类型，并且也实例化每个依赖项自己的依赖项，以一种递归依赖项实例化的方式。
- en: 'So, instead of instantiating the `Playlist` object manually, we could do this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以这样做，而不是手动实例化`Playlist`对象：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `providers` property of the `@Component`decorator is the place where we
    can register dependencies on a component level. From that moment onwards, these
    types will be immediately available for injection at the constructor of that component
    and, as we will see next, at its own child components as well.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Component`装饰器的`providers`属性是我们可以在组件级别注册依赖项的地方。从那时起，这些类型将立即可用于该组件的构造函数注入，并且，正如我们将在接下来看到的，也可用于其子组件。'
- en: A note on providers
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于提供程序的说明
- en: 'Before `@NgModule`was introduced, Angular applications and especially components
    were thought to be responsible for what they needed. Therefore, it was commonplace
    for a component to ask for what dependencies it needed in order to be instantiated
    correctly. In the example of the previous section, the `MusicPlayerComponent` asks
    for a `Playlist`dependency. While this is still technically possible to do, we
    should use our new `@NgModule`concept and provide constructs on a module level
    instead. This means that the previously mentioned example would instead register
    its dependencies in a module, like so:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在引入`@NgModule`之前，Angular应用程序，特别是组件，被认为是负责其所需内容的。因此，组件通常会要求其需要的依赖项以正确实例化。在上一节的示例中，`MusicPlayerComponent`请求一个`Playlist`依赖项。虽然这在技术上仍然是可能的，但我们应该使用我们的新`@NgModule`概念，而不是在模块级别提供构造。这意味着先前提到的示例将在模块中注册其依赖项，如下所示：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we can see that `Playlist` and `SomeOtherService`would be available for
    injection, for all constructs declared in the declarations property. As you can
    see, the responsibility of where to provide a service has shifted somewhat. As
    mentioned before, this does not mean we can't provide constructs on a per component
    level, there exist use cases where this makes sense. We want to stress however
    that the normal case is to place your services or other constructs, which need
    injecting, in the `providers` property of the module rather than the component.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到`Playlist`和`SomeOtherService`将可用于注入，对于在declarations属性中声明的所有构造。正如你所看到的，提供服务的责任在某种程度上已经转移。正如之前提到的，这并不意味着我们不能在每个组件级别上提供构造，存在这样做有意义的用例。然而，我们想强调的是，通常情况是将需要注入的服务或其他构造放在模块的`providers`属性中，而不是组件中。
- en: Injecting dependencies across the component tree
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨组件树注入依赖项
- en: 'We have seen that the provider lookup is performed upwards until a match is
    found. A more visual example might help, so let''s figure out that we have a music
    app component that hosts in its directives property (and hence its template) a
    music library component with a collection of all our downloaded tunes that also
    hosts, in its own directives property and template, a music player component so
    we can playback any of the tunes in our library:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，provider查找是向上执行的，直到找到匹配项。一个更直观的例子可能会有所帮助，所以让我们假设我们有一个音乐应用程序组件，在其指令属性（因此也在其模板中）中托管着一个音乐库组件，其中包含我们下载的所有曲目的集合，还托管着一个音乐播放器组件，因此我们可以在我们的库中播放任何曲目：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Our music player component requires an instance of the `Playlist` object we
    mentioned before, so we declare it as a constructor parameter, conveniently annotated
    with the `Playlist` token:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的音乐播放器组件需要我们之前提到的`Playlist`对象的一个实例，因此我们将其声明为构造函数参数，并方便地用`Playlist`标记进行注释：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When the `MusicPlayerComponent` entity is instantiated, the Angular DI mechanism
    will go through the parameters in the component constructor with special attention
    to their type annotations. Then, it will check if that type has been registered
    in the component''s provider property of the component decorator configuration.
    The code is as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当`MusicPlayerComponent`实体被实例化时，Angular DI机制将会遍历组件构造函数中的参数，并特别关注它们的类型注解。然后，它将检查该类型是否已在组件装饰器配置的provider属性中注册。代码如下：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: But, what if we want to reuse the `Playlist`type in other components throughout
    the same component tree? Maybe the `Playlist` type contains functionalities in
    its API that are required by different components at once across the application.
    Do we have to declare the token in the provider's property for each one? Fortunately
    not, since Angular anticipates that necessity and brings transversal dependency
    injection through the component tree.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们想在同一组件树中的其他组件中重用`Playlist`类型呢？也许`Playlist`类型在其API中包含了一些不同组件在应用程序中同时需要的功能。我们需要为每个组件在provider属性中声明令牌吗？幸运的是不需要，因为Angular预见到了这种必要性，并通过组件树带来了横向依赖注入。
- en: In the previous section, we mentioned that components conduct a provider lookup
    upwards. This is because each component has its own built-in injector, which is
    specific to it. Nevertheless, that injector is in reality a child instance of
    the parent's component injector (and so on and so forth), so it is fair to say
    that an Angular application has not a single injector, but many instances of the
    same injector, so to say.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们提到组件向上进行provider查找。这是因为每个组件都有自己的内置注入器，它是特定于它的。然而，该注入器实际上是父组件注入器的子实例（依此类推），因此可以说Angular应用程序不是一个单一的注入器，而是同一个注入器的许多实例。
- en: 'We need to extend the injection of the `Playlist`object to other components
    in the component tree in a quick and reusable fashion. Knowing beforehand that
    components perform a provider lookup starting from itself and then passing up
    the request to its parent component''s injectors, we can then address the issue
    by registering the provider in the parent component, or even the top parent component,
    so the dependency will be available for injection for each and every child component
    found underneath it. In this sense, we could register the `Playlist` object straight
    at `MusicAppComponent`, regardless to whether it might not need it for its own
    implementation:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要以一种快速且可重用的方式扩展`Playlist`对象在组件树中的注入。事先知道组件从自身开始执行提供者查找，然后将请求传递给其父组件的注入器，我们可以通过在父组件中注册提供者，甚至是顶级父组件中注册提供者来解决这个问题，这样依赖项将可用于每个子组件的注入。在这种情况下，我们可以直接在`MusicAppComponent`中注册`Playlist`对象，而不管它是否需要它进行自己的实现：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The immediate child component might not require the dependency for its own
    implementation either. Since it has been already registered in its parent `MusicAppComponent` component,
    there is no need to register it there again:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 即使直接子组件可能也不需要依赖项进行自己的实现。由于它已经在其父`MusicAppComponent`组件中注册，因此无需再次在那里注册：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We finally reach our music player component, but now it no longer features
    the `Playlist` type as a registered token in its `providers` property. In fact,
    our component does not feature a providers property at all. It no longer requires
    this, since the type has been already registered somewhere above the component''s
    hierarchy, being immediately available for all child components, no matter where
    they are:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们到达了我们的音乐播放器组件，但现在它的`providers`属性中不再包含`Playlist`类型作为注册令牌。实际上，我们的组件根本没有`providers`属性。它不再需要这个，因为该类型已经在组件层次结构的某个地方注册，立即可用于所有子组件，无论它们在哪里：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, we see how dependencies are injected down the component hierarchy and how
    the provider lookup is performed by components just by checking their own registered
    providers and bubbling up the request upwards in the component tree. However,
    what if we want to constrain such injection or lookup actions?
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们看到依赖项如何向下注入组件层次结构，以及组件如何执行提供者查找，只需检查其自己注册的提供者并将请求向上冒泡到组件树中。但是，如果我们想限制这种注入或查找操作呢？
- en: Restricting dependency injection down the component tree
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制依赖项向下注入组件树
- en: 'In our previous example, we saw how the music app component registered the
    Playlist token in its providers collection, making it immediately available for
    all child components. Sometimes, we might need to constrain the injection of dependencies
    to reach only those directives (and components) that are immediately next to a
    specific component in the hierarchy. We can do that by registering the type token
    in the `viewProvider`s property of the component decorator, instead of using the
    providers property we''ve seen already. In our previous example, we can restrain
    the downwards injection of `Playlist` one level only:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，我们看到音乐应用组件在其提供者集合中注册了播放列表令牌，使其立即可用于所有子组件。有时，我们可能需要限制依赖项的注入，仅限于层次结构中特定组件旁边的那些指令（和组件）。我们可以通过在组件装饰器的`viewProviders`属性中注册类型令牌来实现这一点，而不是使用我们已经看到的providers属性。在我们之前的例子中，我们可以仅限制`Playlist`的向下注入一级：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We are informing Angular that the `Playlist` provider should only be accessible
    by the injectors of the directives and components located in the `MusicAppComponent`view,
    but not for the children of such components. The use of this technique is exclusive
    of components, since only they feature views.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在告知Angular，`Playlist`提供程序只能被位于`MusicAppComponent`视图中的指令和组件的注入器访问，而不是这些组件的子级。这种技术的使用是组件的专属，因为只有它们具有视图。
- en: Restricting provider lookup
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制提供程序查找
- en: 'Just like we can restrict dependency injection, we can constrain dependency
    lookup to the immediate upper level only. To do so, we just need to apply the `@Host()` decorator
    to those dependency parameters whose provider lookup we want to restrict:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们可以限制依赖注入一样，我们可以将依赖查找限制在仅限于直接上一级。为此，我们只需要将`@Host()`装饰器应用于那些我们想要限制提供程序查找的依赖参数：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: According to the preceding example, the `MusicPlayerComponent` injector will
    look up a`Playlist` type at its parent component's providers collection (`MusicLibraryComponent`,
    in our example) and will stop there, throwing an exception because `Playlist` has
    not been returned by the parent's injector (unless we also decorate it with the `@Optional()` parameter
    decorator).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的例子，`MusicPlayerComponent`注入器将在其父组件的提供程序集合（在我们的例子中是`MusicLibraryComponent`）中查找`Playlist`类型，并在那里停止，抛出异常，因为`Playlist`没有被父级注入器返回（除非我们还用`@Optional()`参数装饰器装饰它）。
- en: 'To clarify this functionality, let''s do another example:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了澄清这个功能，让我们做另一个例子：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this case, we would get an error as the `Child`component only looks one level
    up, to try and find the service. As it is two levels up, it does not find it.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们会得到一个错误，因为`Child`组件只会向上查找一级，尝试找到服务。由于它向上两级，所以找不到。
- en: Overriding providers in the injector hierarchy
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在注入器层次结构中覆盖提供程序
- en: We've seen so far how Angular's DI framework uses the dependency token to introspect
    the type required and return it right from any of the provider sets available
    along the component hierarchy. However, we might need to override the class instance
    corresponding to that token in certain cases where a more specialized type is
    required to do the job. Angular provides special tools to override the providers
    or even implement factories that will return a class instance for a given token,
    not necessarily matching the original type.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了Angular的DI框架如何使用依赖标记来内省所需的类型，并从组件层次结构中可用的任何提供程序集中返回它。然而，在某些情况下，我们可能需要覆盖与该标记对应的类实例，以便需要更专业的类型来完成工作。Angular提供了特殊工具来覆盖提供程序，甚至实现工厂，该工厂将返回给定标记的类实例，不一定匹配原始类型。
- en: 'We will not cover all the use cases in detail here, but let''s look at a simple
    example. In our example, we assumed that the `Playlist` object was meant to be
    available across the component tree for use in different entities of the application.
    What if our `MusicAppComponent`directive hosts another component whose child directives
    require a more specialized version of the `Playlist` object? Let''s rethink our
    example:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不会详细涵盖所有用例，但让我们看一个简单的例子。在我们的例子中，我们假设`Playlist`对象应该在组件树中的不同实体中可用。如果我们的`MusicAppComponent`指令托管另一个组件，其子指令需要`Playlist`对象的更专业版本，该怎么办？让我们重新思考我们的例子：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This is a bit of a contrived example, but it will definitely help us to understand
    the point of overriding dependencies. The `Playlist`instance object is available
    right from the top component downwards. The `MusicChartsComponent` directive is
    a specialized component that caters only for music featured in the top seller''s
    charts and hence its player must playback big hits only, regardless of the fact
    it uses the same component as `MusicLibraryComponent`. We need to ensure that
    each player component gets the proper playlist object, and this can be done at
    the `MusicChartsComponent` level by overriding the object instance corresponding
    to the `Playlist`token. The following example depicts this scenario, leveraging
    the use of the `provide` function:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有点牵强的例子，但它肯定会帮助我们理解覆盖依赖项的要点。 “Playlist”实例对象从顶部组件向下都是可用的。 “MusicChartsComponent”指令是一个专门为畅销榜中的音乐提供服务的组件，因此其播放器必须仅播放热门歌曲，而不管它是否使用与“MusicLibraryComponent”相同的组件。我们需要确保每个播放器组件都获得适当的播放列表对象，这可以在“MusicChartsComponent”级别通过覆盖与“Playlist”标记对应的对象实例来完成。以下示例描述了这种情况，利用了“provide”函数的使用：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `provide` keyword creates a provider mapped to the token specified in the
    first argument (`Playlist`, in this example) and the property `useClass` essentially
    overwrites the playlist with `TopHitsPlaylist` from this component and downstream.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: “provide”关键字创建了一个与第一个参数中指定的标记（在本例中为“Playlist”）映射的提供程序，而“useClass”属性本质上是用来从该组件和下游重写播放列表为“TopHitsPlaylist”。
- en: 'We could refactor the block of code to use `viewProviders` instead, so we ensure
    that (if required) the child entities still receive an instance of`Playlist` instead
    of `TopHitsPlaylist`. Alternatively, we can go the extra mile and use a factory
    to return the specific object instance we need, depending on other requirements.
    The following example will return a different object instance for the `Playlist`token,
    depending on the evaluation of a Boolean condition variable:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重构代码块以使用“viewProviders”，以确保（如果需要）子实体仍然接收“Playlist”的实例，而不是“TopHitsPlaylist”。或者，我们可以走额外的路线，并使用工厂根据其他要求返回我们需要的特定对象实例。以下示例将根据布尔条件变量的评估返回“Playlist”标记的不同对象实例：
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: So, you can see how powerful this is. We could, for example, make sure that
    our data service suddenly would be replaced by a mock data service when testing.
    The point is it is really easy to tell the DI mechanism to change its behavior
    based on a condition.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你可以看到这有多强大。例如，我们可以确保在测试时，我们的数据服务突然被模拟数据服务替换。关键是很容易告诉DI机制根据条件改变其行为。
- en: Extending injector support to custom entities
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展注入器支持到自定义实体
- en: Directives and components require dependencies to be introspected, resolved,
    and injected. Other entities such as service classes often require such functionality
    too. In our example, our `Playlist` class might rely on a dependency on a HTTP
    client to communicate with a third party to fetch the songs. The action of injecting
    such dependency should be as easy as declaring the annotated dependencies in the
    class constructor and have an injector ready to fetch the object instance by inspecting
    the class provider or any other provider available somewhere.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 指令和组件需要依赖项进行内省、解析和注入。其他实体，如服务类，通常也需要这样的功能。在我们的示例中，我们的“Playlist”类可能依赖于与第三方通信的HTTP客户端的依赖项，以获取歌曲。注入这种依赖的操作应该像在类构造函数中声明带注释的依赖项一样简单，并且有一个注入器准备好通过检查类提供程序或任何其他提供程序来获取对象实例。
- en: 'It is only when we think hard about the latter that we realize there is a gap
    in this idea: custom classes and services do not belong to the component tree.
    Hence, they do not benefit from anything such as a built-in injector or a parent
    injector. We cannot even declare a providers property, since we do not decorate
    these types of class with a `@Component` or `@Directive` decorator. Let''s take
    a look at an example:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当我们认真思考后者时，我们才意识到这个想法存在一个漏洞：自定义类和服务不属于组件树。因此，它们不会从任何内置的注入器或父注入器中受益。我们甚至无法声明提供者属性，因为我们没有用`@Component`或`@Directive`装饰器修饰这些类型的类。让我们看一个例子：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We might try this in the hope of having Angular''s DI mechanism introspecting
    the `songsService`parameter of the `Playlist` class constructor when instantiating
    this class in order to inject it into `MusicPlayerComponent`. Unfortunately, the
    only thing we will eventually get is an exception like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会尝试这样做，希望当实例化这个类以将其注入到`MusicPlayerComponent`中时，Angular 的 DI 机制会内省`Playlist`类构造函数的`songsService`参数。不幸的是，我们最终得到的只是这样的异常：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This is kind of misleading, since all constructor parameters in `Playlist`
    have been properly annotated, right? As we said before, the Angular DI machinery
    resolves dependencies by introspecting the types of the constructor parameters.
    To do so, it needs some metadata to be created beforehand. Each and every Angular
    entity class decorated with a decorator features this metadata as a by-product
    of the way TypeScript compiles the decorator configuration details. However, dependencies
    that also require other dependencies have no decorator whatsoever and no metadata
    is then created for them. This can be easily fixed thanks to the `@Injectable()`
    decorator, which will give visibility to these service classes for the DI mechanism:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点误导，因为`Playlist`中的所有构造函数参数都已经被正确注释了，对吧？正如我们之前所说，Angular DI 机制通过内省构造函数参数的类型来解析依赖关系。为了做到这一点，需要预先创建一些元数据。每个被装饰器修饰的
    Angular 实体类都具有这些元数据，这是 TypeScript 编译装饰器配置细节的副产品。然而，还需要其他依赖项的依赖项没有装饰器，因此也没有为它们创建元数据。这可以通过`@Injectable()`装饰器轻松解决，它将为这些服务类提供
    DI 机制的可见性。
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You will get used to introducing that decorator in your service classes, since
    they will quite often rely on other dependencies not related to the component
    tree in order to deliver the functionality.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你会习惯在你的服务类中引入装饰器，因为它们经常依赖于与组件树无关的其他依赖项，以便提供功能。
- en: It is actually a good practice to decorate all your service classes with the `@Injectable()`decorator,
    irrespective of whether its constructor functions have dependencies or not. This
    way, we prevent errors and exceptions because of skipping this requirement once
    the service class grows, and it requires more dependencies in the future.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，无论构造函数是否具有依赖关系，都将所有服务类装饰为`@Injectable()`是一个很好的做法。这样，我们可以避免因为忽略这一要求而导致的错误和异常，一旦服务类增长，并且在将来需要更多的依赖关系。
- en: Initializing applications with bootstrapModule()
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`bootstrapModule()`初始化应用程序
- en: 'As we have seen in this chapter, the dependency lookup bubbles up until the
    first component at the top. This is not exactly true, since there is an additional
    step that the DI mechanism will check on: the `bootstrapModule()` function.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章中所看到的，依赖查找一直冒泡直到顶部的第一个组件。这并不完全正确，因为 DI 机制还会检查`bootstrapModule()`函数的额外步骤。
- en: As far as we know, we use the `bootstrapModule()` function to kickstart our
    application by declaring in its first argument the root module, that in turn points
    out the root component, that initiates the application's component tree.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 据我们所知，我们使用 `bootstrapModule()` 函数来通过在其第一个参数中声明根模块来启动我们的应用程序，然后指出根组件，从而启动应用程序的组件树。
- en: 'A typical bootstrap will look like the following in the file `main.ts`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件 `main.ts` 中，典型的引导看起来像下面这样：
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The takeaway from the preceding code is that Angular has changed how it bootstraps
    things. With the addition of `@NgModule`, we now bootstrap a root module rather
    than a root component. However, the root module still needs to point to an entry
    point where the application starts. Let''s have a look at the root module to see
    how this is done:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述代码中可以得出的结论是，Angular 已经改变了引导的方式。通过添加 `@NgModule`，我们现在引导一个根模块而不是一个根组件。然而，根模块仍然需要指向一个应用程序启动的入口点。让我们来看看根模块是如何做到这一点的：
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note the existence of the `bootstrap`key, how we point out the root component
    `AppComponent`. Also, note how the `bootstrap`property is an array. This means
    we can have multiple root components. Each one of these root components will feature
    its own set of injectors and service singletons, with no relationship whatsoever
    among them. Next up, let's talk about the different modes we can alter in-between.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `bootstrap` 键的存在，我们如何指出根组件 `AppComponent`。还要注意 `bootstrap` 属性是一个数组。这意味着我们可以有多个根组件。每个根组件都将具有自己的注入器和服务单例集，彼此之间没有任何关系。接下来，让我们谈谈我们可以在其中进行修改的不同模式。
- en: Switching between development and production modes
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在开发和生产模式之间切换
- en: 'Angular applications are bootstrapped and initialized by default in development
    mode. In the development mode, the Angular runtime will throw warning messages
    and assertions to the browser console. While this is quite useful for debugging
    our application, we do not want those messages to be displayed when the application
    is in production. The good news is that the development mode can be disabled in
    favor of the more silent production mode. This action is usually performed before
    bootstrapping our application:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 应用程序默认在开发模式下引导和初始化。在开发模式下，Angular 运行时会向浏览器控制台抛出警告消息和断言。虽然这对于调试我们的应用程序非常有用，但当应用程序处于生产状态时，我们不希望显示这些消息。好消息是，可以禁用开发模式，转而使用更为安静的生产模式。这个操作通常是在引导我们的应用程序之前执行的：
- en: '[PRE30]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: What we can see here is that the call to `enableProdMode()` is what enables
    production mode.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，调用 `enableProdMode()` 是启用生产模式的方法。
- en: Different modes in Angular CLI
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular CLI 中的不同模式
- en: 'It is worth noting that it''s a good idea to keep different environment configurations
    in different files, as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，将不同的环境配置保存在不同的文件中是一个好主意，如下所示：
- en: '[PRE31]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The environments directory consists of two different files:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: environments 目录包括两个不同的文件：
- en: '`environment.ts`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`environment.ts`'
- en: '`environment.prod.ts`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`environment.prod.ts`'
- en: 'With the first file looking like this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个文件看起来像这样：
- en: '[PRE32]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'And the second looking like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个文件看起来像这样：
- en: '[PRE33]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Depending on how we call the `ng build` command, one of the two files will
    be used:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们调用 `ng build` 命令的方式，将使用其中的一个文件：
- en: '[PRE34]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To find out which files map to which environment, you should have a look at
    the `angular-cli.json` file:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出哪些文件映射到哪个环境，您应该查看 `angular-cli.json` 文件：
- en: '[PRE35]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Introducing the app directory structure
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍应用程序目录结构
- en: In the previous chapters and sections in this chapter, we have seen different
    approaches and good practices for laying out Angular applications. These guidelines
    encompassed from naming conventions to pointers about how to organize files and
    folders. From this point onwards, we are going to put all this knowledge to practice
    by refactoring all the different interfaces, components, directives, pipes, and
    services in an actual Angular architecture, conforming to the most commonly agreed
    community conventions.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章和本章的各个部分中，我们已经看到了布局Angular应用程序的不同方法和良好实践。这些准则涵盖了从命名约定到如何组织文件和文件夹的指针。从现在开始，我们将通过重构所有不同的接口、组件、指令、管道和服务，将所有这些知识付诸实践，使其符合最常见的社区约定。
- en: 'By the end of this chapter, we will have a final application layout that wraps
    everything we have seen so far in the following site architecture:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将拥有一个最终的应用程序布局，将我们迄今所见的一切都包含在以下站点架构中：
- en: '[PRE36]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'It is easy to understand the whole rationale of the project. Now, we will put
    together an application that features two main contexts: a timer feature and tasks
    listing feature. Each feature can encompass a different range of components, pipes,
    directives, or services. The inner implementation of each feature is opaque to
    the other features or contexts. Each feature context exposes an Angular module
    that exports the pieces of functionality (that is, the component, one or many)
    that each context delivers to the upper-level context or application. All the
    other pieces of functionality (inner directives and components) are concealed
    from the rest of the application.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易理解项目的整体原理。现在，我们将组合一个应用程序，其中包含两个主要上下文：计时器功能和任务列表功能。每个功能可以包含不同范围的组件、管道、指令或服务。每个功能的内部实现对其他功能或上下文是不透明的。每个功能上下文都公开了一个Angular模块，该模块导出了每个上下文提供给上层上下文或应用程序的功能部分（即组件，一个或多个）。所有其他功能部分（内部指令和组件）对应用程序的其余部分是隐藏的。
- en: It is fair to say that it is difficult to draw a line in the sand differentiating
    what belongs to a specific context or another. Sometimes, we build pieces of functionality,
    such as certain directives or pipes, which can be reused throughout the application.
    So, locking them down to a specific context does not make much sense. For those
    cases, we do have the shared context, where we store any code unit that is meant
    to be reusable at an application level, apart from media files such as style sheets
    or bitmap images that are component-agnostic.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说很难划清界限，区分哪些属于特定上下文，哪些属于另一个上下文。有时，我们构建功能部分，比如某些指令或管道，可以在整个应用程序中重用。因此，将它们锁定到特定上下文并没有太多意义。对于这些情况，我们确实有共享上下文，其中存储着任何旨在在应用程序级别可重用的代码单元，而不是与组件无关的媒体文件，如样式表或位图图像。
- en: The main `app.component.ts` file contains and exports the application root component,
    which declares and registers in its own injector the dependencies required by
    its child components. As you know already, all Angular applications must have
    at least one root module and one root component, initialized by the `bootstrapModule()`
    function. This operation is actually performed in the `main.ts` file, which is
    fired by the `index.html` file.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 主`app.component.ts`文件包含并导出应用程序根组件，该组件声明并在其自己的注入器中注册其子组件所需的依赖项。正如您已经知道的，所有Angular应用程序必须至少有一个根模块和一个根组件，由`bootstrapModule()`函数初始化。这个操作实际上是在`main.ts`文件中执行的，该文件由`index.html`文件触发。
- en: Defining a component or a group of related components within a context like
    this improves reusability and encapsulation. The only component that is tightly
    coupled with the application is the top root component, whose functionality is
    usually pretty limited and entails basically rendering the other child components
    in its template view or acting as a router component, as we will see in further
    chapters.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的上下文中定义一个组件或一组相关组件可以提高可重用性和封装性。唯一与应用程序紧密耦合的组件是顶级根组件，其功能通常非常有限，基本上是在其模板视图中呈现其他子组件或作为路由器组件，正如我们将在后续章节中看到的那样。
- en: The last bit of the puzzle is the JSON files that contain the TypeScript compiler,
    typings, and `npm` configuration. Since versioning on the Angular framework keeps
    evolving, we will not look at the actual content of these files here. You are
    supposed to know their purpose, but some specifics such as the peer dependency
    versions change quite often, so you'd better refer to the book's GitHub repository
    for the latest up-to-date version of each one. The `package.json` file requires
    a special mention though. There are a few common industry conventions and popular
    seed projects, like the one provided by the Angular official site itself. We have
    provided several `npm` commands to ease the overall installation process and the
    development endeavor.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分是包含 TypeScript 编译器、类型和`npm`配置的 JSON 文件。由于 Angular 框架的版本不断发展，我们不会在这里查看这些文件的实际内容。你应该知道它们的目的，但一些具体内容，比如对等依赖版本，经常会发生变化，所以最好参考本书的
    GitHub 仓库获取每个文件的最新版本。不过，`package.json`文件需要特别提及。有一些常见的行业惯例和流行的种子项目，比如 Angular 官方网站提供的项目。我们提供了几个`npm`命令来简化整个安装过程和开发工作。
- en: Refactoring our application the Angular way
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按照 Angular 的方式重构我们的应用程序
- en: In this section, we will split the code we created in earlier chapters into
    code units, following the single responsibility principle. So, do not expect many
    changes in the code, apart from allocating each module in its own dedicated file.
    This is why we will focus more on how to split things rather than explaining each
    module, whose purpose you should know already. In any event, we will take a minute
    to discuss changes if required.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将把我们在前几章中创建的代码分割成代码单元，遵循单一职责原则。因此，除了将每个模块分配到其自己的专用文件中之外，不要期望代码有太多变化。这就是为什么我们将更多地关注如何分割事物，而不是解释每个模块的目的，你应该已经知道了。无论如何，如果需要，我们将花一分钟讨论变化。
- en: Let's begin by creating in your work folder the same directory structure we
    saw in the previous section. We will populate each folder with files on the go.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在你的工作文件夹中创建与前一节中看到的相同的目录结构开始。我们将在路上为每个文件夹填充文件。
- en: The shared context or store it all in a common module
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享上下文或将所有内容存储在一个公共模块中
- en: The shared context is where we store any construct whose functionality is meant
    to be used by not one, but many contexts at once, as it is agnostic to those contexts
    as well. A good example is the Pomodoro bitmap we've been using to decorate our
    components, which should be stored in the `app/shared/assets/img` path (please
    do save it there, by the way).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 共享上下文是我们存储任何构造的地方，其功能旨在一次被多个上下文使用，因为它对这些上下文也是不可知的。一个很好的例子是我们一直在用来装饰我们组件的番茄钟位图，它应该存储在`app/shared/assets/img`路径下（顺便说一句，请确实将它保存在那里）。
- en: 'Another good example is the interfaces that model data, mostly when their schema
    can be reused across a different context of functionality. For instance, when
    we defined the `QueuedOnlyPipe` in [Chapter 4](41335dde-9066-4998-a0a9-3c42f97cdd9e.xhtml),
    *Implementing Properties and Events in Our Components*, we actioned only over
    the queued property of items in the recordset. We can then seriously consider
    implementing a Queued interface that we can use later on to provide type-checking
    for modules that feature that property. This will make our pipes more reusable
    and model-agnostic. The code is as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个很好的例子是对模型数据建模的接口，特别是当它们的模式可以在不同功能上下文中重复使用时。例如，当我们在[第4章](41335dde-9066-4998-a0a9-3c42f97cdd9e.xhtml)中定义了`QueuedOnlyPipe`时，我们只对记录集中项目的排队属性进行了操作。然后，我们可以认真考虑实现一个`Queued`接口，以便以后在具有该属性的模块中提供类型检查。这将使我们的管道更具重用性和模型无关性。代码如下：
- en: '[PRE37]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Pay attention to this workflow: first, we define the module corresponding to
    this code unit, and then we export it, flagging it as default so we can import
    it by name from elsewhere. Interfaces need to be exported this way, but for the
    rest of the book we will usually declare the module and export it in the same
    statement.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意这个工作流程：首先，我们定义与这个代码单元对应的模块，然后导出它，并将其标记为默认，这样我们就可以从其他地方按名称导入它。接口需要以这种方式导出，但在本书的其余部分，我们通常会在同一语句中声明并导出模块。
- en: 'With this interface in place, we can now safely refactor the `QueuedOnlyPipe` to
    make it fully agnostic from the `Task` interface so that it is fully reusable
    in any context where a recordset, featuring items implementing the `Queueable`interface,
    needs to be filtered, regardless of what they represent. The code is as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个接口，我们现在可以安全地重构`QueuedOnlyPipe`，使其完全不依赖于`Task`接口，以便在任何需要过滤记录集的上下文中完全重用，无论它们代表什么。代码如下：
- en: '[PRE38]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As you can see, each code unit contains a single module. This code unit conforms
    to the naming conventions set for Angular filenames, clearly stating the module
    name in camel case, plus the type suffix (`.pipe`, in this case). The implementation
    does not change either, apart from the fact that we have annotated all queue-able
    items with the `Queuable`type, instead of the Task annotation we had earlier.
    Now, our pipe can be reused wherever a model implementing the `Queueable` interface
    is present.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，每个代码单元都包含一个单一的模块。这个代码单元符合 Angular 文件名的命名约定，清楚地以驼峰命名法陈述了模块名称，再加上类型后缀（在这种情况下是`.pipe`）。实现也没有改变，除了我们用`Queuable`类型注释了所有可排队的项目，而不是之前的任务注释。现在，我们的管道可以在任何实现`Queueable`接口的模型存在的地方重复使用。
- en: 'However, there is something that should draw your attention: we''re not importing
    the `Queuable`interface from its source location, but from a file named `shared.ts`
    located in the upper level. This is the facade file for the shared context, and
    we will expose all public shared modules from that file, not only to the clients
    consuming the shared context modules, but to those inside the shared context as
    well. There is a case for this: if any module within the shared context changes
    its location, we need to update the facade so that any other element referring
    to that module within the same context remains unaffected since it consumes it
    through the facade. This is actually a good moment to start introducing our shared
    module that before `@NgModule` would have been a facade file:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一件事情需要引起您的注意：我们不是从源位置导入`Queuable`接口，而是从一个名为`shared.ts`的文件中导入，该文件位于上一级目录。这是共享上下文的门面文件，我们将从该文件公开所有公共共享模块，不仅供消费共享上下文模块的客户端使用，还供共享上下文内部的模块使用。这是一个情况：如果共享上下文内的任何模块更改其位置，我们需要更新门面，以便任何其他引用该模块的元素在同一上下文中保持不受影响，因为它通过门面来消费它。现在是一个很好的时机来介绍我们的共享模块，以前它将是一个门面文件：
- en: '[PRE39]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The main difference from a facade file is that we can add all sorts of business
    logic to our `SharedModule`by adding methods and injecting services and so on
    to `SharedModule`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 与门面文件的主要区别在于，我们可以通过向`SharedModule`添加方法和注入服务等方式向其添加各种业务逻辑。
- en: 'This far we have only exposed pipes, directives, and components through the
    exports property of our `SharedModule`, but what about other things such as classes
    and interfaces? Well, we can require them directly when we need them, like so:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只通过`SharedModule`的exports属性公开了管道、指令和组件，但是其他东西如类和接口呢？嗯，我们可以在需要时直接要求它们，就像这样：
- en: '[PRE40]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now that we have a working `Queuable` interface and a `SharedModule`, we can
    create the other interface we will require throughout the book, corresponding
    to the `Task` entity, along with the other pipe we required:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个可工作的`Queuable`接口和一个`SharedModule`，我们可以创建其他接口，这些接口将在整本书中使用，对应于`Task`实体，以及我们需要的其他管道：
- en: '[PRE41]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We implement an interface onto another interface in TypeScript by using extends
    (instead of implements). Now, for the `FormattedTimePipe`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用extends（而不是implements）在TypeScript中将一个接口实现到另一个接口上。现在，对于`FormattedTimePipe`：
- en: '[PRE42]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Finally, we need to update our `SharedModule`to contain this `Pipe` as well:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要更新我们的`SharedModule`，以包含这个`Pipe`：
- en: '[PRE43]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: To sum up what we did here, we created two interfaces, `Task` and `Queueable`.
    We also created two pipes, `QueuedOnlyPipe` and `FormattedTimePipe`. We added
    the latter to the declarations keyword for our `@NgModule`, and as for the interfaces,
    we will pull them into the application as we need them, using the `import` keyword.
    There is no need to expose them through a facade file anymore.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下我们在这里做的事情，我们创建了两个接口，`Task`和`Queueable`。我们还创建了两个管道，`QueuedOnlyPipe`和`FormattedTimePipe`。我们将后者添加到我们的`@NgModule`的declarations关键字中，至于接口，我们将使用`import`关键字根据需要将它们引入应用程序。不再需要通过门面文件公开它们。
- en: Services in the shared context
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享上下文中的服务
- en: 'Let''s talk about what the impact of having services in a shared context and
    what the addition of `@NgModule`has brought to the table. There are two types
    of services we need to care about:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈在共享上下文中拥有服务的影响，以及`@NgModule`的添加带来了什么。我们需要关心两种类型的服务：
- en: A transient service; this service creates a new copy of itself and may or may
    not contain an inner state; for each copy created it has its own state
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个瞬态服务；这个服务创建自己的新副本，可能包含内部状态，对于每个创建的副本，它都有自己的状态
- en: A singleton, there can only be one of this service and if it has a state, we
    need to ensure that there is only a copy of this service in our entire application
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个单例，只能有一个此服务，如果它有状态，我们需要确保在整个应用程序中只有一个此服务的副本
- en: 'Using dependency injection in Angular, placing services in the providers of
    the modules will ensure they end up on on the root injector and thereby there
    will be only one copy of them created if we have this situation:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中使用依赖注入，将服务放在模块的提供者中将确保它们最终出现在根注入器上，因此如果我们有这种情况，它们将只创建一个副本：
- en: '[PRE44]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Earlier, we had a declaration of a `TaskModule` in which we provided the `TaskService`.
    Let''s look at defining another module:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候，我们在`TaskModule`中声明了一个`TaskService`。让我们来定义另一个模块：
- en: '[PRE45]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Providing we import both of these modules in the root module, like so:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们在根模块中导入这两个模块，就像这样：
- en: '[PRE46]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We have now created a situation where `ProductsService` and `TaskService` can
    be injected in the constructor of`ProductsComponent` or `TaskComponent`, thanks
    to `ProductsModule` and `TaskModule` both being imported into the `AppModule`.
    So far, we don''t have an issue. However, were we to start using lazy loading,
    we have an issue on our hands. In lazy loading, the user navigates to a certain
    route and our module, together with its constructs, which are loaded into the
    bundle. If the lazy loaded module, or one of its constructs, actually injects,
    let''s say `ProductsService`, it would not be the same `ProductsService` instance
    that `TaskModule` or `ProductsModule`is using and this might become a problem,
    especially if the state is shared. The way to solve this is to create a core module,
    a module that is imported by the `AppModule`; this would ensure that services
    is never subjected to the risk of being instantiated again, by mistake. So, if `ProductsService`is
    used in more than one module, especially in a lazy loaded module, it is advisable
    to move it to a core module. So essentially, we go from doing this:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经创建了一个情况，`ProductsService`和`TaskService`可以被注入到`ProductsComponent`或`TaskComponent`的构造函数中，这要归功于`ProductsModule`和`TaskModule`都被导入到`AppModule`中。到目前为止，我们还没有问题。然而，如果我们开始使用延迟加载，我们就会遇到问题。在延迟加载中，用户导航到某个路由，我们的模块与其构造一起被加载到包中。如果延迟加载的模块或其构造之一实际上注入了，比如`ProductsService`，那么它将不是`TaskModule`或`ProductsModule`正在使用的相同`ProductsService`实例，这可能会成为一个问题，特别是如果状态是共享的。解决这个问题的方法是创建一个核心模块，一个被`AppModule`导入的模块；这将确保服务永远不会因错误而被再次实例化。因此，如果`ProductsService`在多个模块中使用，特别是在延迟加载的模块中使用，建议将其移动到核心模块。因此，我们从这样做：
- en: '[PRE47]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To moving our `ProductService` to a core module:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的`ProductService`移动到核心模块：
- en: '[PRE48]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'And of course, we need to add the newly created `CoreModule` to our root module,
    like so:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们需要将新创建的`CoreModule`添加到我们的根模块中，就像这样：
- en: '[PRE49]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: One can argue that if our application is small enough, creating a core module
    early on might be seen as somewhat of an overkill. An argument against that is
    that the Angular framework has a mobile first approach and that you as a developer
    should lazy load most of your modules, unless there is a good reason not to. This
    means that when you deal with services which might be shared, you should move
    them to a core module.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 有人可能会认为，如果我们的应用程序足够小，早期创建一个核心模块可能被视为有点过度。反对这一观点的是，Angular框架采用移动优先的方法，作为开发人员，你应该延迟加载大部分模块，除非有充分的理由不这样做。这意味着当你处理可能被共享的服务时，你应该将它们移动到一个核心模块中。
- en: 'We built a data service in the previous chapter to serve a tasks dataset to
    populate our data table with. As we will see later in this book, the data service
    will be consumed by other contexts of the application. So, we will allocate it
    in the shared context, exposing it through our shared module:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们构建了一个数据服务来为我们的数据表填充任务数据集。正如我们将在本书后面看到的那样，数据服务将被应用程序的其他上下文所使用。因此，我们将其分配到共享上下文中，并通过我们的共享模块进行暴露：
- en: '[PRE50]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Please pay attention to how we imported the `Injectable()` decorator and implemented
    it on our service. It does not require any dependency in its constructor, so other
    modules depending on this service will not have any issues anyway when declaring
    it in its constructors. The reason is simple: it is actually a good practice to
    apply the `@Injectable()` decorator in our services by default to ensure they
    keep being injected seamlessly as long as they begin depending on other providers,
    just in case we forget to decorate them.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们如何导入`Injectable()`装饰器并在我们的服务上实现它。它在构造函数中不需要任何依赖项，因此依赖于此服务的其他模块在声明构造函数时不会有任何问题。原因很简单：在我们的服务中默认应用`@Injectable()`装饰器实际上是一个很好的做法，以确保它们在开始依赖其他提供者时仍然能够无缝注入，以防我们忘记对它们进行装饰。
- en: Configuring application settings from a central service
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从中央服务配置应用程序设置
- en: 'In the previous chapters, we hardcoded a lot of stuff in our components: labels,
    durations, plural mappings, and so on. Sometimes, our contexts are meant to have
    a high level of specificity and it''s fine to have that information there. At
    other times, we might require more flexibility and a more convenient way to update
    these settings application-wide.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们在我们的组件中硬编码了很多东西：标签、持续时间、复数映射等等。有时，我们的上下文意味着具有高度的特定性，并且在那里拥有这些信息是可以接受的。但是，有时我们可能需要更灵活和更方便的方式来全局更新这些设置。
- en: For this example, we will make all the `l18n` pipes mappings and settings available
    from a central service located in the shared context and exposed, as usual, from
    the `shared.ts` facade.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将使所有`l18n`管道映射和设置都可以从共享上下文中的一个中央服务中获得，并像往常一样从`shared.ts`门面暴露出来。
- en: 'The following code describes a `SettingsService` that will hold all the configuration
    for the application:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码描述了一个将保存应用程序所有配置的`SettingsService`：
- en: '[PRE51]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Please note how we expose context-agnostic mapping properties, which are actually
    namespaced, to better group the different mappings by context.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们如何将与上下文无关的映射属性暴露出来，这些属性实际上是有命名空间的，以更好地按上下文分组不同的映射。
- en: It would be perfectly fine to split this service into two specific services,
    one per context, and locate them inside their respective context folders, at least
    with regard to the `l18n` mappings. Keep in mind that data such as the time duration
    will be used across different contexts, though, as we will see later in this chapter.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 将此服务分成两个特定的服务并将它们放置在各自的上下文文件夹中，至少就`l18n`映射而言，这是完全可以的。请记住，诸如时间持续等数据将在不同的上下文中使用，正如我们将在本章后面看到的那样。
- en: Putting it all together in our shared module
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的共享模块中将所有内容整合在一起
- en: 'With all the latest changes, our `shared.module.ts` should look like this:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 通过所有最新的更改，我们的`shared.module.ts`应该是这样的：
- en: '[PRE52]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Our `SharedModule` exposes `FormattedTimePipe` and `QueuedOnlyPipe`from before,
    but there are some new additions; namely, we added things to the `provider` keyword.
    We added our services, `SettingsService` and `TaskService`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`SharedModule`从前面暴露了`FormattedTimePipe`和`QueuedOnlyPipe`，但是有一些新的添加；即，我们添加了`provider`关键字的内容。我们添加了我们的服务，`SettingsService`和`TaskService`。
- en: 'Now, an interesting thing happens when this module is consumed by another module;
    so, let''s take a look at such a scenario in the following code:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当这个模块被另一个模块消耗时，会发生一件有趣的事情；所以，让我们在下面的代码中看看这样的情景：
- en: '[PRE53]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The effect of importing another module is partly known from before. We know
    that everything included in the `export` keyword from`SharedModule` is now readily
    available in the `AppModule`, but there is more. Anything mentioned in the `provider`
    keyword of`SharedModule` is ready to be injected. So, let''s say we have the following
    `app.component.ts` file:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面部分部分知道了导入另一个模块的影响。我们知道`SharedModule`中包含的所有内容现在都可以在`AppModule`中使用，但还有更多。`SharedModule`中`provider`关键字中提到的任何内容都可以被注入。所以，假设我们有以下`app.component.ts`文件：
- en: '[PRE54]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'As you can see, we can now freely inject services from other modules as long
    as they are:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，现在我们可以自由地注入来自其他模块的服务，只要它们是：
- en: Mentioned in the `provider`s keyword for their module
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在其模块的`provider`关键字中提到
- en: The module they reside in gets imported by another module
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们所在的模块被另一个模块导入
- en: To sum up, so far, we have learned how to add components as well as services
    to a shared module and we have also learned that we need to register components
    in declarations and `export` keywords, and for services, we need to place them
    in the `provider` keyword. Lastly, we need to `import` the module they reside
    in and all your shared constructs are ready for use in your application.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，到目前为止，我们已经学会了如何将组件和服务添加到共享模块中，还学会了我们需要在声明和`export`关键字中注册组件，对于服务，我们需要将它们放在`provider`关键字中。最后，我们需要`import`它们所在的模块，你的共享构件就可以在应用程序中使用了。
- en: Creating our components
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的组件
- en: 'With our shared context sorted out, the time has come to cater to our other
    two contexts: timer and tasks. Their names are self-descriptive enough of the
    scope of their functionalities. Each context folder will allocate the component,
    HTML view template, CSS, and directive files required to deliver their functionality,
    plus a facade file that exports the public components of this feature.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们共享的上下文，现在是时候满足我们的另外两个上下文了：定时器和任务。它们的名称足够描述它们的功能范围。每个上下文文件夹将分配组件、HTML视图模板、CSS和指令文件，以提供它们的功能，还有一个外观文件，导出此功能的公共组件。
- en: Introduction to life cycle hooks
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生命周期钩子简介
- en: Life cycle hooks are your ability to spy on stages in the life cycle of a directive
    or component. The hooks themselves are completely optional to use, but might be
    of valuable help if you understand how to use them. Some hooks are considered
    best practice to use, while other hooks help with debugging and understanding
    what happens in your app. A hook comes with an interface that defines a method
    you need to implement. The Angular framework makes sure the hook is called, provided
    you have added the interface to the component or directive and fulfilled the contract
    by implementing the methods the interface specifies. As we are just starting to
    learn how to build your app, it might not make sense to use certain hooks yet.
    So, we will have a reason to return to this topic in later chapters.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期钩子是你在指令或组件的生命周期中监视阶段的能力。这些钩子本身是完全可选的，但如果你了解如何使用它们，它们可能会有很大的帮助。有些钩子被认为是最佳实践，而其他钩子则有助于调试和理解应用程序中发生的情况。一个钩子带有一个定义你需要实现的方法的接口。Angular框架确保调用钩子，只要你将接口添加到组件或指令中，并通过实现接口指定的方法来履行合同。因为我们刚刚开始学习如何构建你的应用程序，现在可能还没有理由使用某些钩子。所以，我们将有理由在后面的章节中返回这个主题。
- en: 'The hooks you can use are as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用的钩子如下：
- en: '`OnInit`'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnInit`'
- en: '`OnDestroy`'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnDestroy`'
- en: '`OnChanges`'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnChanges`'
- en: '`DoCheck`'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DoCheck`'
- en: '`AfterContentInit`'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AfterContentInit`'
- en: '`AfterContentChecked`'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AfterContentChecked`'
- en: '`AfterViewInit`'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AfterViewInit`'
- en: '`AfterViewChecked`'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AfterViewChecked`'
- en: In this section, we will cover the top three ones in this chapter as the rest
    are touching on more complex topics. We will revisit the remaining five hooks
    in later chapters in the book.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将涵盖本章中的前三个钩子，因为其余的涉及到更复杂的主题。我们将在本书的后续章节中重新讨论剩下的五个钩子。
- en: OnInit - the beginning of it all
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OnInit - 一切开始的地方
- en: 'Using this hook is as easy as adding the `OnInit` interface and implementing
    the `ngOnInit()` method:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个钩子就像添加`OnInit`接口并实现`ngOnInit()`方法一样简单：
- en: '[PRE55]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Let's talk about why this hook exists though. Constructors should be relatively
    empty and devoid of logic other than setting initial variables. There should be
    no surprises when constructing an object because sometimes you construct an object
    meant for business use and sometimes it is created in unit testing scenarios.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，让我们谈谈为什么存在这个钩子。构造函数应该相对空，并且除了设置初始变量之外不应包含逻辑。在构造对象时不应该有任何意外，因为有时您构造的是用于业务使用的对象，有时它是在单元测试场景中创建的。
- en: 'The following is an example of suitable things to carry out in the constructor
    of the class. Here, we are showing assignment of the class''s member variables:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在类的构造函数中执行的适当操作的示例。在这里，我们展示了对类成员变量的赋值：
- en: '[PRE56]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The following example shows what NOT to do. In the code, we are subscribing
    to an Observable in the constructor. This can be acceptable in some scenarios,
    but it is usually a better idea to place this kind of code inside an `ngOnInit()` method:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了不应该做的事情。在代码中，我们在构造函数中订阅了一个Observable。在某些情况下，这是可以接受的，但通常更好的做法是将这种代码放在`ngOnInit()`方法中：
- en: '[PRE57]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: It's better to set up subscription, as shown previously with the `ngOnInit()` method
    provided by the `OnInit` interface.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 最好建立订阅，如之前使用`OnInit`接口提供的`ngOnInit()`方法所示。
- en: 'This is, of course, a recommendation and not a law. If you are not using this
    hook, then obviously you need to use the constructor or similar to perform the
    preceding HTTP call. Other than just saying that the constructor should be empty
    for aesthetic reasons and when dealing with testing, there is another aspect,
    namely that of binding of input values. An input variable won''t be set immediately,
    so relying on the input value to be there when in the constructor will lead to
    a runtime error. Let''s illustrate the mentioned scenario:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是一个建议，而不是一项法律。如果您没有使用这个钩子，那么显然您需要使用构造函数或类似的方法来执行前面的HTTP调用。除了仅仅说构造函数应该为空以美观和处理测试时，还有另一个方面，即输入值的绑定。输入变量不会立即设置，因此依赖于构造函数中的输入值会导致运行时错误。让我们举例说明上述情景：
- en: '[PRE58]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: At this stage, you can make sure that all bindings have been properly set and
    you can safely use the value of prop. If you are familiar with jQuery, then `ngOnInit`
    acts much like a`$(document).ready()` like construct, the bottom line is that
    the ceremony that happens when a component is being set up has happened at this
    point.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，您可以确保所有绑定已经正确设置，并且可以安全地使用prop的值。如果您熟悉jQuery，那么`ngOnInit`的作用很像`$(document).ready()`的构造，总的来说，当组件设置完成时发生的仪式在这一点上已经发生。
- en: OnDestroy - called when a component is removed from a DOM tree
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OnDestroy - 当组件从DOM树中移除时调用
- en: The typical use case for this is to do some custom clean up when the component
    is about to leave the DOM tree. It consists of the interface `OnDestroy`and the
    `ngOnDestroy()` method.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这种典型用例是在组件即将离开DOM树时进行一些自定义清理。它由`OnDestroy`接口和`ngOnDestroy()`方法组成。
- en: 'To demonstrate its use, let''s look at the following code snippet where we
    implement the `OnDestroy` interface:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示其用法，让我们看一下下面的代码片段，我们在其中实现了`OnDestroy`接口：
- en: '[PRE59]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Our preceding snippet tries to highlight when an instance of `TodoComponent`gets
    removed from the DOM tree. The `TodosComponent` renders a list of `TodoComponents`and
    when the `remove()` method is invoked, the targeted `TodoComponent`is removed,
    thereby triggering the `ngOnDestroy()` method on the `TodoComponent`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的片段试图突出显示当`TodoComponent`的一个实例从DOM树中移除时。`TodosComponent`渲染了一个`TodoComponents`列表，当调用`remove()`方法时，目标`TodoComponent`被移除，从而触发`TodoComponent`上的`ngOnDestroy()`方法。
- en: OK, great, so we have a way to capture that exact moment in time when our component
    is being disposed... so what?
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，很好，所以我们有一种方法来捕获组件被销毁的确切时刻...那又怎样呢？
- en: 'This is where we do a clean up of resources; by clean up, we mean:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们清理资源的地方；通过清理，我们的意思是：
- en: Timeout, interval should be unsubscribed to here
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超时，间隔应该在这里被取消订阅
- en: Observable streams should be unsubscribed to
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可观察流应该被取消订阅
- en: Other clean up
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他清理
- en: Essentially, anything that causes a footprint should be cleaned up here.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，任何导致印记的东西都应该在这里清理。
- en: OnChanges - a change has occurred
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OnChanges - 发生了变化
- en: 'This hook is used in the following way:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这个钩子的使用方式如下：
- en: '[PRE60]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Note how our method takes an input parameter `changes`. This is an object with
    all properties that changed as keys on the `changes`object. Each key points to
    an object with the previous value and the current value, like so:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们的方法如何接受一个名为`changes`的输入参数。这是一个对象，其中所有已更改的属性作为`changes`对象的键。每个键指向一个对象，其中包含先前值和当前值，如下所示：
- en: '[PRE61]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The preceding code assumes we have a class with a `prop` field, like so:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码假设我们有一个带有`prop`字段的类，如下所示：
- en: '[PRE62]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'So, what causes things to change? Well, it''s a change in the binding, that
    is, we have the `@Input` property set up, like so:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，是什么导致事物发生变化？嗯，这是绑定的变化，也就是说，我们设置了`@Input`属性，如下所示：
- en: '[PRE63]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'A little heads up worth noting here is that what we are tracking are reference
    changes, not property changes on an object. If, for example, we have the following
    code:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这里值得注意的一点是，我们跟踪的是引用的变化，而不是对象的属性变化。例如，如果我们有以下代码：
- en: '[PRE64]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'And the name property on the `todoItem` changed so that `todoItem.name` is
    `code` instead of `coding`, this would not lead to a change being reported. However,
    if the whole item is replaced, as in the following code:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`todoItem`上的name属性发生了变化，使得`todoItem.name`变为`code`而不是`coding`，这不会导致报告变化。然而，如果整个项目被替换，就像下面的代码一样：
- en: '[PRE65]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Then this would lead to a change event being emitted as the `todoItem`now points
    to a completely new reference. I hope this clears it up a bit.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这将导致一个变化事件被发出，因为`todoItem`现在指向一个全新的引用。希望这能稍微澄清一点。
- en: The timer feature
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计时器功能
- en: 'Our first feature is the one belonging to the timer functionality, which happens
    to be the simpler one as well. It comprises of a unique component with the countdown
    timer we built in the previous chapters:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个功能是属于计时器功能的，这也是最简单的功能。它包括一个独特的组件，其中包含我们在前几章中构建的倒计时计时器：
- en: '[PRE66]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: As you can see, the implementation is pretty much the same to what we saw already
    back in [Chapter 1](17474bca-f7f9-41ec-ab4c-5f7ac741c0c9.xhtml), *Creating Our
    Very First Component in Angular*, with the exception of initializing the component
    at the init lifecycle stage through the `OnInit` interface hook. We leverage the `l18nSelect` pipe
    to better handle the different labels required for each state of the timer, consuming
    the label information from the `SettingsService`, which is injected in the constructor.
    Later on in this chapter, we will see where to register that provider. The duration
    in minutes is also consumed from the service, once the latter is bound to a class
    field.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，实现方式与我们在[第1章](17474bca-f7f9-41ec-ab4c-5f7ac741c0c9.xhtml)中已经看到的*在Angular中创建我们的第一个组件*基本相同，唯一的区别是通过`OnInit`接口钩子在init生命周期阶段初始化组件。我们利用`l18nSelect`管道更好地处理定时器每个状态所需的不同标签，从`SettingsService`中消耗标签信息，该服务在构造函数中注入。在本章的后面部分，我们将看到在哪里注册该提供程序。分钟数也是从服务中获取的，一旦后者绑定到类字段。
- en: 'The component is exported publicly through the `TimerModule`file `timer.module.ts`
    by us adding it to the`declarations` keyword as well as the `exported` keyword,
    the latter to enable outside access:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们将其添加到`declarations`关键字以及`exported`关键字，后者用于启用外部访问，该组件通过`TimerModule`文件`timer.module.ts`公开导出：
- en: '[PRE67]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'And we also need to remember to import our newly created module to the root
    module in `app.module.ts`:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要记住将我们新创建的模块导入到`app.module.ts`中的根模块中：
- en: '[PRE68]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: At this point, we have created a nice structure before we create more constructs
    for the timer feature.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经创建了一个很好的结构，然后我们将为定时器功能创建更多构造。
- en: The tasks feature
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务功能
- en: 'The tasks feature encompasses some more logic since it entails two components
    and a directive. Let''s begin by creating the core unit required by `TaskTooltipDirective`:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 任务功能包含了一些更多的逻辑，因为它涉及两个组件和一个指令。让我们从创建`TaskTooltipDirective`所需的核心单元开始：
- en: '[PRE69]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The directive keeps all the original functionality in place and just imports
    the Angular core types and task-typing it requires. Let''s look at the `TaskIconsComponent` now:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 指令保留了所有原始功能，并只导入了Angular核心类型和所需的任务类型。现在让我们来看一下`TaskIconsComponent`：
- en: '[PRE70]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'So far so good. Now, let''s jump to `TasksComponent`. This will consist of:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利。现在，让我们转到`TasksComponent`。这将包括：
- en: The component file `tasks.component.ts`, where the logic is described in TypeScript
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件文件`tasks.component.ts`，其中用TypeScript描述了逻辑
- en: The CSS file `tasks.component.css`, where the styles are defined
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSS文件`tasks.component.css`，其中定义了样式
- en: The template file `tasks.component.html`, where the markup is defined
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板文件`tasks.component.html`，其中定义了标记
- en: 'Starting with the CSS file, it will look like this:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 从CSS文件开始，它将如下所示：
- en: '[PRE71]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Continuing on with the HTML markup:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 继续HTML标记：
- en: '[PRE72]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Please take a moment to check out the naming convention applied to the external
    component files, whose filename matches the component''s own to identify which
    file belongs to what in flat structures inside a context folder. Also, please
    note how we removed the main bitmap from the template and replaced the hardcoded
    time durations with a variable named `timerMinutes`in the binding expression that
    computes the time estimation to accomplish all queued tasks. We will see how that
    variable is populated in the following component class:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 请花一点时间查看应用于外部组件文件的命名约定，文件名与组件自身匹配，以便在上下文文件夹内的扁平结构中识别哪个文件属于什么。还请注意我们如何从模板中移除了主位图，并用名为`timerMinutes`的变量替换了硬编码的时间持续。这个变量在绑定表达式中计算完成所有排队任务的时间估计。我们将看到这个变量是如何在以下组件类中填充的：
- en: '[PRE73]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Several aspects of the `TasksComponent`implementation are worth highlighting.
    Firstly, we can inject the `TaskService` and `SettingsService`in the component,
    leveraging Angular's DI system. The dependencies are injected with accessors right
    from the constructor, becoming private class members on the spot. The tasks dataset
    and the time duration are then populated from the bound services.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`TasksComponent`的实现有几个值得强调的方面。首先，我们可以在组件中注入`TaskService`和`SettingsService`，利用Angular的DI系统。这些依赖项可以直接从构造函数中注入访问器，立即成为私有类成员。然后从绑定的服务中填充任务数据集和时间持续时间。'
- en: 'Let''s now add all these constructs to the `TaskModule`, that is, the file
    `task.module.ts` and export everything that is either a directive or a component.
    It is worth noting, however, that we do this because we think all these constructs
    may need to be referred to somewhere else in the app. I urge you to strongly consider
    what to put in the `exports`keyword and what not to put there. Your default stance
    should be to put as little as possible for exporting:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将所有这些构造添加到`TaskModule`中，也就是文件`task.module.ts`，并导出所有指令或组件。然而，值得注意的是，我们这样做是因为我们认为所有这些构造可能需要在应用的其他地方引用。我强烈建议您认真考虑在`exports`关键字中放什么，不要放什么。您的默认立场应该是尽量少地进行导出：
- en: '[PRE74]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: We have now added the constructs to the `declarations`keyword so that the module
    is aware of them and also the `exports` keyword so that other modules importing
    our`TaskModule`are able to use them. The next task is to set up our `AppComponent`,
    or root component, as it is also known as.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经将构造添加到`declarations`关键字中，以便模块知道它们，还有`exports`关键字，以便导入我们的`TaskModule`的其他模块能够使用它们。下一个任务是设置我们的`AppComponent`，或者也称为根组件。
- en: Defining the top root component
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义顶级根组件
- en: With all our feature contexts ready, the time has come to define the top root
    component, which will kickstart the whole application as a cluster of components
    laid out in a tree hierarchy. The root component usually has a minimum implementation.
    The main child components will eventually evolve into branches of child components.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好所有功能上下文后，现在是时候定义顶级根组件了，它将作为整个应用程序的启动组件，以树形层次结构的一簇组件展开。根组件通常具有最少的实现。主要子组件最终会演变成子组件的分支。
- en: 'The following is an example of the template of the root component. This is
    the main visual component that your app is going to live in. Here, it makes sense
    to define application headers, menus, or viewports for routing:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是根组件模板的示例。这是您的应用程序将驻留在其中的主要可视组件。在这里，定义应用程序标题、菜单或用于路由的视口是有意义的。
- en: '[PRE75]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'It has been mentioned before, but it is worth repeating. Any constructs that
    we use in the `app.component.ts` file that do not belong to the `AppModule` need
    to be imported. Technically, it is the module these constructs belong to that
    is being imported. You also need to ensure that the constructs are properly exposed
    by being mentioned in said modules `exports`keyword. With the preceding root component,
    we can see that we use two different components in the template for `app.component.ts`,
    the `<timer-widget>`   and `<pomodoro-tasks>`.  These belong to different modules
    with the first component belonging to the `TimerModule` and the second belonging
    to the `TaskModule`. This means that the `AppModule`needs to import both of these
    modules for the preceding to compile. The `app.module.ts` should, therefore, look
    like this:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 之前已经提到过，但值得重复。我们在`app.component.ts`文件中使用的任何构造都不属于`AppModule`，都需要被导入。从技术上讲，被导入的是这些构造所属的模块。您还需要确保这些构造通过在所述模块的`exports`关键字中提到而得到适当的暴露。通过前面的根组件，我们可以看到在`app.component.ts`的模板中使用了两个不同的组件，即`<timer-widget>`和`<pomodoro-tasks>`。这两个组件属于不同的模块，第一个组件属于`TimerModule`，第二个组件属于`TaskModule`。这意味着`AppModule`需要导入这两个模块才能编译。因此，`app.module.ts`应该如下所示：
- en: '[PRE76]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Summary
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter has definitely set the foundation for all the great applications
    that you will be building on top of Angular from now on. The Angular dependency
    management implementation is in fact one of the gems of this framework and a time
    saver. Application architectures based on component trees are not rocket science
    anymore, and we have followed this pattern to some extent while building web software
    in other frameworks such as AngularJS and React.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 本章确实为您从现在开始将在Angular上构建的所有优秀应用奠定了基础。实际上，Angular依赖管理的实现是这个框架的一大亮点，也是一个节省时间的工具。基于组件树的应用架构不再是什么高深的技术，我们在构建其他框架（如AngularJS和React）中的Web软件时在某种程度上也遵循了这种模式。
- en: This chapter concludes our trip through the core of Angular and its application
    architecture, setting up the standards that we will follow from now on while building
    applications on top of this new and exciting framework.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束了我们对Angular核心及其应用架构的探索，建立了我们在这个新的令人兴奋的框架上构建应用时将遵循的标准。
- en: In the following chapters, we will focus on very specific tools and modules
    that we can use to solve everyday problems when crafting our web projects. We
    will see how to develop better HTTP networking clients with Angular.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将专注于非常具体的工具和模块，这些工具和模块可以帮助我们解决日常问题，从而打造我们的Web项目。我们将看到如何使用Angular开发更好的HTTP网络客户端。
