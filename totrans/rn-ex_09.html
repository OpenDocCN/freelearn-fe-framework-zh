<html><head></head><body>
        <section>

            <header>
                <h1 class="header-title">Additional React Native Components</h1>
            </header>

            <article>
                
<p>Throughout the book, we touched on a lot of React Native SDKs. However, there were some components where their additions didn't fit with the apps we built.</p>
<p>In this chapter, we will cover some of them so that you will gain some extended practice with the React Native framework. You will learn to do the following things:</p>
<ul>
<li>Write a playground application where we will add components and parts of the React Native API that we did not get to work with in the prior projects</li>
<li>Use the Fetch API to make network calls to a third-party resource</li>
<li>Utilize the Vibration API to physically vibrate the user's phone</li>
<li>Make use of the Linking API have your app open a third-party app with a registered link</li>
<li>Build a slider that can slide around to set a value between a defined minimum and maximum number</li>
<li>Learn how to use the Action sheet and Share sheet in iOS to share details from your app</li>
<li>Obtain a user's location data with the Geolocation polyfill</li>
</ul>
<p>Additionally, the end of this chapter includes a tutorial on how we would build <kbd>Expenses</kbd> in <a href="94aea5f2-1fde-4cb4-b28e-8b3c6354a298.xhtml">Chapter 4</a>, <em>Advanced Functionality with the Expenses App</em> for Android.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Setting up a boilerplate project</h1>
            </header>

            <article>
                
<p>Using the React Native command-line tools, I created a project titled <kbd>AdditionalComponents</kbd>. In it, the structure is a lot more simplified than our previous projects.</p>
<p>In each platform-specific index file at the root of the project, it imports an <kbd>App</kbd> component from our <kbd>app</kbd> folder and registers it to <kbd>AppRegistry</kbd>:</p>
<pre>
// AdditionalComponents/index.ios.js 

import App from './app'; 
import { AppRegistry } from 'react-native'; 
AppRegistry.registerComponent('AdditionalComponents', () =&gt; App); 
</pre>
<p>We will be using the <kbd>index.js</kbd> file found in the <kbd>app</kbd> folder to contain the code for the examples that we'll be building.</p>
<p>At the end of this step, we have an <kbd>index.js</kbd> file:</p>
<pre>
// AdditionalComponents/app/index.js 

import React, { Component } from 'react'; 
 import { 
  Text, 
  View 
} from 'react-native'; 
import styles from './styles'; 
export default class App extends Component { 
  render () { 
    return ( 
      &lt;View style={ styles.container }&gt; 
        &lt;Text style={ styles.text }&gt; 
          Hello from React Native! 
        &lt;/Text&gt; 
      &lt;/View&gt; 
    ) 
  } 
} 
</pre>
<p>Also, we have a file that holds our styling:</p>
<pre>
// AdditionalComponents/app/styles.js 

import { StyleSheet } from 'react-native'; 
export const styles = StyleSheet.create({ 
  container: { 
    flex: 1, 
    backgroundColor: '#fafafa' 
  }, 
  text: { 
    alignSelf: 'center', 
    color: '#365899', 
    marginTop: 50 
  } 
}); 
export default styles; 
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Making Fetch happen</h1>
            </header>

            <article>
                
<p>The first thing we will do is make a request to a third-party API during the <kbd>componentDidMount</kbd> life cycle. Our intention is to grab a set of JSON data from that API and use it to populate the <kbd>Picker</kbd> component that we'll be creating in the next section.</p>
<p>The third-party API that I will be using is a nifty one that produces JSON placeholder data--<span class="URLPACKT"><a href="https://jsonplaceholder.typicode.com">https://jsonplaceholder.typicode.com</a>.</span></p>
<p>To grab data from this third-party API, we'll be using the <kbd>fetch</kbd> API. <kbd>fetch</kbd> is a JavaScript API that does not need to be specifically imported into our file. It returns a promise that contains a response. If we want to use promises, we can call <kbd>fetch</kbd> like this:</p>
<pre>
fetch(endpoint, object) 
  .then((response) =&gt; { 
    return response.json(); 
  }) 
  .then((result) =&gt; { 
    return result; 
  }) 
</pre>
<p>We can also call <kbd>fetch</kbd> using the <kbd>async</kbd>/<kbd>await</kbd> keywords:</p>
<pre>
async fetchAndReturnData (endpoint, object) { 
  const response = await fetch(endpoint, object); 
  const data = await response.json(); 
  return data; 
} 
</pre>
<p> </p>
<p>The first argument that <kbd>fetch</kbd> accepts is the API <kbd>endpoint</kbd>. The second is an optional <kbd>object</kbd>. By default, <kbd>fetch</kbd> assumes that you are making a <kbd>GET</kbd> request. In order to make a <kbd>POST</kbd>, you will have to pass in this object with the <kbd>POST</kbd> property as a string to a key titled <kbd>method</kbd>. This object can also accept any headers you wish to include along with all other parameters to be sent in your request.</p>
<p>For example, an object can look like this:</p>
<pre>
const obj = { 
  method: 'POST', 
  headers: { 
    'Accept': 'application/json', 
    'Content-Type': 'application/json', 
    'Origin': '', 
    'Host': 'api.test.com' 
  }, 
  body: JSON.stringify({ 
    'client_id': apiKey, 
    'client_secret': apiSecret, 
    'grant_type': grantType 
  }) 
}  
</pre>
<p>In your <kbd>App</kbd> component, let's create a <kbd>componentDidMount</kbd> life cycle event to fetch data from our <kbd>JSONPlaceholder</kbd> API using the following <kbd>endpoint</kbd>:</p>
<pre>
https://jsonplaceholder.typicode.com/json
</pre>
<p>When data is fetched, go ahead and save it to your component's <kbd>state</kbd> and log it in the <kbd>console</kbd> to show that it's been populated. The code you write may end up looking like the following:</p>
<pre>
// AdditionalComponents/app/index.js 

... 
export default class App extends Component { 
  constructor (props) { 
    super (props); 
    this.state = { 
      data: [] 
    } 
  } 
 async componentDidMount () { 
    const endpoint = 'https://jsonplaceholder.typicode.com/users'; 
    const response = await fetch(endpoint); 
    const data = await response.json(); 
 
    this.setState({ 
      data 
    }); 
 console.log(this.state.data); 
  } 
  ... 
} 
</pre>
<p>This is all you need to do to make a <kbd>GET</kbd> request from an <kbd>endpoint</kbd> using <kbd>fetch</kbd> in your React Native apps! Next up, we will use the <kbd>Vibration</kbd> API to send a vibration to the user's device whenever our <kbd>fetch</kbd> function successfully resolves.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Vibration</h1>
            </header>

            <article>
                
<p>The <kbd>Vibration</kbd> API allows us to tap into the vibration motor for our user's mobile devices and send a vibration to it.</p>
<p>This demo will require the use of actual hardware to test, but it is worth the setup if you have one to play with. On devices that don't support vibration, including the simulator, there will be no effect.</p>
<div class="packt_infobox">
<p>There are a couple of caveats to using the Vibration API that you should be aware of.</p>
<p>From a user experience standpoint, the use of vibration in your apps should be as a feedback mechanism to let your users know that some sort of interaction has occurred.</p>
<p>Additionally, extended use of the vibration motor on a user's phone will lead to larger stress on their device's battery performance.</p>
<p>It's very easy to abuse this API and include vibrations on all aspects of your app, but I would heavily recommend that this feature is reserved to acknowledge key interactions that a user may have with your app.</p>
</div>
<p>It also has access to two methods:</p>
<ul>
<li>The first method is <kbd>Vibration.vibrate()</kbd>, which accepts two arguments:
<ul>
<li>The first is either a number or an array of numbers. The number (or numbers) is considered the pattern for which vibrations occur.</li>
<li>If a number is passed, an Android device will behave by vibrating for that number of milliseconds. On iOS, it will always result in a 1 vibration.</li>
<li>If an array of numbers is passed to this function, the vibration motor will follow a different pattern. An Android device will wait the number of milliseconds equal to the first index, and then vibrate a number of milliseconds equal to the second index. This pattern where the vibration motor switches between wait and vibrate continues for the length of the array.</li>
<li>For example, an array of <kbd>[100, 200, 300, 400]</kbd> means that the Android device will wait for <kbd>100</kbd> milliseconds, then vibrate for <kbd>200</kbd> milliseconds, followed by waiting <kbd>300</kbd> milliseconds before finally vibrating for <kbd>400</kbd> milliseconds.</li>
<li>The vibration motor's behavior on iOS is different. Rather than alternating between waiting and vibrating based on each index, the iOS functionality will always vibrate for a fixed one-second interval and wait between vibrations based on the next number in the array. Additionally, iOS ignores the first index of the array if it is set to zero.</li>
<li>For example, an array of <kbd>[0, 100, 200, 300]</kbd> means that the iOS device will skip that first index and vibrate for 1 second, then wait <kbd>100</kbd> milliseconds before vibrating for another second. After that, it waits <kbd>200</kbd> milliseconds and then vibrates for 1 second again. Finally, it waits <kbd>300</kbd> milliseconds after that vibration and then vibrates one final time for 1 second.</li>
<li>The second argument that <kbd>Vibration.vibrate()</kbd> accepts is a Boolean that tells the motor whether to restart the vibration pattern once it completes (indefinitely) or to stop after one iteration.</li>
</ul>
</li>
<li>The second method is <kbd>Vibration.cancel()</kbd>, which cancels the vibration that is currently in place. This is important to build in if you're setting the repeat Boolean to <kbd>true</kbd> in your <kbd>vibrate</kbd> method.</li>
</ul>
<p>Additionally, for Android devices, you will need to add the following line to your <kbd>AndroidManifest.xml</kbd> file:</p>
<pre>
&lt;uses-permission android:name="android.permission.VIBRATE"/&gt; 
</pre>
<p>In this section, let's create a callback that is fired when data becomes available for the <kbd>Picker</kbd> to access and vibrates the device a few times. This is the code that I came up with; yours may be similar:</p>
<pre>
// AdditionalComponents/app/index.js 

... 
import { 
  ... 
  Vibration 
} from 'react-native'; 
... 
export default class App extends Component { 
  ... 
  async componentDidMount () { 
    const endpoint = 'https://jsonplaceholder.typicode.com/users'; 
    const response = await fetch(endpoint); 
    const data = await response.json(); 
 
    this.setState({ 
      data 
    }); 
 
    this._onDataAvailable(); 
     } 
  ... 
   
  _onDataAvailable () { 
    Vibration.vibrate([1000, 2000, 1000, 2000], false); 
  } 
} 
</pre>
<p>It is simple and straightforward! In the next section, we will look at how to open a link to another installed app on the device.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Linking apps with a button</h1>
            </header>

            <article>
                
<p>Deep linking allows us to interact with incoming and outgoing links to and from other apps. By creating a deep link for your app, you can enable other apps to talk to it directly and pass arguments to it, if desired.</p>
<p>You can also access other apps' deep links, opening them with custom arguments. In this chapter, we will learn how to access other apps using their deep links.</p>
<p>We will create a <kbd>Button</kbd> component that, on press, finds out whether Facebook is installed on the user's device and if it is, launches the app and tells it to open the Notifications page. If Facebook is not installed, it will open the React Native documentation on the device's default browser.</p>
<div class="packt_infobox">It's important to note that you can call Linking as part of any callback you wish. It does not have to be tied to the <kbd>Button</kbd> component at all!</div>
<p>Here are the two methods that we will use with <kbd>Linking</kbd>:</p>
<ul>
<li><kbd>canOpenURL</kbd>: This is a function that accepts a URL as an argument. It returns a promise containing a Boolean as its result, stating whether or not the URL you provided can be opened. This URL can either be a deep link to another application or a web-based URL to open a web page.</li>
<li><kbd>openURL</kbd>: This is a method that also accepts a URL as an argument and attempts to open it with an installed app. This method fails if your user's device does not know how to open the URL passed, which is why it's best to use <kbd>canOpenURL</kbd> to first check for the ability to open it.</li>
</ul>
<p>On iOS devices, we need to tweak the Xcode project file a bit to allow <kbd>Linking</kbd> to open custom URL schemes. First, we need to link the React Native <kbd>Linking</kbd> binary with our project. Open your project in Xcode and then, in the left-hand navigator, expand the <kbd>Libraries</kbd> folder, then <kbd>RCTLinking.xcodeproj</kbd> within it, followed by the <kbd>Products</kbd> folder within that:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1454 image-border" height="322" src="assets/image_09_001-1.png" width="197"/></div>
<p>Go back to the root project file for <kbd>AdditionalComponents</kbd>, into <span class="packt_screen">Build Phases</span>, and drag the <span class="packt_screen">libRCTLinking.a</span> file under <span class="packt_screen">Link Binary With Libraries</span>:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1455 image-border" height="367" src="assets/image_09_002-1.png" width="773"/></div>
<p>Afterward, head over to the <span class="packt_screen">Build Settings</span> tab and add an entry to the <span class="packt_screen">Header Search Paths</span> array pointing to the <kbd>Linking</kbd> library. For this specific project, the path is <kbd>$(SRCROOT)/../node_modules/react-native/Linking</kbd>.</p>
<p>You can keep the search non-recursive:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="103" src="assets/image_09_003.png" width="669"/></div>
<p>There's one last step to perform. As of iOS 9, we have to register our intent to access Facebook's URL scheme within the app.</p>
<p>Open up the <kbd>Info.plist</kbd> file in the sidebar and create an array entry called <kbd>LSApplicationQueriesSchemes</kbd>. Add a string to this array with the value of the URL scheme you wish to access. Facebook's URL scheme is simply <kbd>fb</kbd>:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="281" src="assets/image_09_004.png" width="487"/></div>
<p>Once you have completed this, your app should be linked to iOS!</p>
<p>On Android, no further action is necessary; you should already have access to other URL schemes by default.</p>
<p>Using this knowledge, let's create a <kbd>Button</kbd> component that launches either the Facebook app, if installed, or links to the React Native documentation on the user's device, if it isn't. Here's how I wrote it:</p>
<pre>
// AdditionalComponents/app/index.js 

... 
import { 
  Button, 
  Linking, 
  ... 
} from 'react-native'; 
... 
export default class App extends Component { 
  ... 
  render () { 
    return ( 
      &lt;View style={ styles.container }&gt; 
        ... 
        &lt;Button 
          color={ '#365899' } 
          onPress={ () =&gt; this._onButtonPress() } 
          title={ 'Open Link' } 
        /&gt; 
      &lt;/View&gt; 
    ) 
  } 
 
  async _onButtonPress () { 
    const facebookURL = 'fb://notifications'; 
    const canOpenLink = await Linking.canOpenURL(facebookURL); 
 
    if (canOpenLink) { 
      Linking.openURL(facebookURL); 
      return; 
    } 
 
    Linking.openURL('https://facebook.github.io/react-native'); 
  } 
  ... 
} 
</pre>
<p>The <kbd>Button</kbd> component in our <kbd>render</kbd> method fires the <kbd>_onButtonPress</kbd> callback when pressed. It checks the <kbd>Linking</kbd> API to check whether the Facebook app can be opened on the device, and if so, opens it. If not, it will open a link to the React Native documentation website in the device's default browser.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Slider</h1>
            </header>

            <article>
                
<p>Sliders are common UI components found on the Web. In this section, you will see how easy it is to create one in your React Native applications.</p>
<p>While <kbd>Slider</kbd> has access to at least nine different props, we will use just the following:</p>
<ul>
<li><kbd>maximumValue</kbd>: This is a number that sets the starting maximum value of the <kbd>Slider</kbd>. It defaults to <kbd>1</kbd>.</li>
<li><kbd>minimumValue</kbd>: This is a number that sets the starting minimum value of the <kbd>Slider</kbd>. It defaults to <kbd>0</kbd>.</li>
<li><kbd>onSlidingComplete</kbd>: This is a callback that is fired when the user finishes interacting with the <kbd>Slider</kbd>.</li>
<li><kbd>onValueChange</kbd>: This is a callback that is fired continuously as the user is dragging the <kbd>Slider</kbd>.</li>
<li><kbd>step</kbd>: This is a number that sets the step value of the slider. Each tick of the <kbd>Slider</kbd> moves it by this number of steps. It defaults to <kbd>0</kbd> and ranges between <kbd>0</kbd> and the difference between the maximum value and minimum value.</li>
</ul>
<p>Take a moment to create a <kbd>Slider</kbd> component. Give it any minimum and maximum values you like, any step count, and create some text that shows the current value of the slider whenever either movement happens or interaction stops. This is how I implemented it:</p>
<pre>
// AdditionalComponents/app/index.js 

... 
import { 
  ... 
  Slider, 
} from 'react-native'; 
... 
export default class App extends Component { 
  ... 
  constructor (props) { 
    ... 
    this.state = { 
      ... 
      sliderValue: undefined 
    } 
  } 
  ... 
  render () { 
    return ( 
      &lt;View style={ styles.container }&gt; 
        ... 
        &lt;Text style={ styles.sliderSelectionText } &gt; 
          Your Slider Value is: { this.state.sliderValue } 
        &lt;/Text&gt; 
        &lt;Slider 
          maximumValue={ 100 } 
          minimumValue={ 0 } 
          onSlidingComplete={ (value) =&gt; 
          this._onSliderValueChange(value) } 
          onValueChange={ (value) =&gt; this._onSliderValueChange(value) } 
          step={ 3 }  
        /&gt; 
      &lt;/View&gt; 
    ) 
  } 
</pre>
<p>This renders a new <kbd>Slider</kbd> component on the page with a value range from <kbd>0</kbd> to <kbd>100</kbd>. It changes the value of the <kbd>Slider</kbd> whenever the user is either in the process of dragging the slider or has completed the dragging action. Each movement of the slider increases the value by <kbd>3</kbd>.</p>
<p>This callback handles setting the <kbd>sliderValue</kbd> property in state. The code for the <kbd>sliderValue</kbd> property is as follows:</p>
<pre>
  ... 
  _onSliderValueChange (sliderValue) { 
    this.setState({ 
      sliderValue 
    }); 
  } 
} 
</pre>
<pre>
// AdditionalComponents/app/styles.js 

... 
const styles = StyleSheet.create({ 
  sliderSelectionText: { 
    alignSelf: 'center', 
    color: '#365899', 
    marginTop: 20 
  }, 
  ... 
}); 
... 
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Using ActionSheetIOS</h1>
            </header>

            <article>
                
<p>The <kbd>ActionSheetIOS</kbd> API lets us display either an action sheet or share sheet for the user to interact with.</p>
<p>The action sheet is an overlay of options that the user can interact with in the app.</p>
<p>The Share sheet allows the user to share almost anything, anywhere, using the built-in sharing system. This could mean sending content in the form of a text message, e-mail, or to a third-party app.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Creating an action sheet</h1>
            </header>

            <article>
                
<p>The two methods that <kbd>ActionSheetIOS</kbd> makes available are <kbd>showActionSheetWithOptions</kbd> and <kbd>showShareActionSheetWithOptions</kbd>.</p>
<p>The first method, <kbd>showActionSheetWithOptions</kbd>, accepts two arguments: an <kbd>options</kbd> object and a <kbd>callback</kbd> function.</p>
<p>The <kbd>options</kbd> object must contain at least one of the following properties. We use all five in this example:</p>
<ul>
<li><kbd>options</kbd>: This is an array of strings that map to the multiple options that appear in the overlay.</li>
<li><kbd>cancelButtonIndex</kbd>: This is a number that points to the <kbd>index</kbd> where the <span class="packt_screen">Cancel</span> button, if it exists, is located in the <kbd>options</kbd> array. This sends the <span class="packt_screen">Cancel</span> button to the very bottom of the overlay.</li>
<li><kbd>destructiveButtonIndex</kbd>: This is a number that points to the <kbd>index</kbd> where a destructive button, if it exists, is located in the <kbd>options</kbd> array. This turns the color of the destructive option's text to red.</li>
<li><kbd>title</kbd>: This is a string that shows above the action sheet.</li>
<li><kbd>message</kbd>: This is a string that shows right below the title.</li>
</ul>
<p>The callback that <kbd>showActionSheetWithOptions</kbd> takes in will have one argument passed to it, which is the index of the option that is selected by the user when the action sheet is interacted with. If the user taps outside the action sheet in order to hide it, it has the exact same effect as if the <span class="packt_screen">Cancel</span> button's index were selected:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="216" src="assets/image_09_005.png" width="205"/></div>
<p>Try creating an action sheet of your own. Have some sort of interaction to toggle it, followed by any sort of interaction you can think of when an index is selected. Make sure to give your action sheet a <kbd>title</kbd>, <kbd>message</kbd>, some <kbd>options</kbd>, a <kbd>cancel</kbd> index, and a <kbd>destructive</kbd> index.</p>
<p>This is the code I came up with. Call a function to render the <kbd>ActionSheetIOS</kbd> and <kbd>ShareSheetIOS</kbd> components. I added the reference to <kbd>ShareSheetIOS</kbd> in the function name in anticipation of the next section:</p>
<pre>
// AdditionalComponents/app/index.js 

... 
import { 
  ActionSheetIOS, 
  ... 
} from 'react-native'; 
... 
export default class App extends Component { 
  ... 
  render () { 
    return ( 
      &lt;View style={ styles.container }&gt; 
        ... 
        { this._renderActionAndShareSheets() } 
      &lt;/View&gt; 
    ) 
  } 
</pre>
<p>Alert the selected index of the <kbd>ActionSheetIOS</kbd> component to the user:</p>
<pre>
  _onActionSheetOptionSelected (index) { 
    alert('The index you selected is: ' + index) 
  } 
</pre>
<p>Open <kbd>ActionSheetIOS</kbd> and add the following code: </p>
<pre>
  ... 
  _openActionSheet () { 
    const options = ['One', 'Two', 'Three', 'Cancel', 'Destroy']; 
    ActionSheetIOS.showActionSheetWithOptions({ 
      options: options, 
      cancelButtonIndex: 3, 
      destructiveButtonIndex: 4, 
      title: 'Action Sheet Options', 
      message: 'Please select from the following options' 
    }, (index) =&gt; this._onActionSheetOptionSelected(index)) 
  } 
</pre>
<p>Don't render anything if the user is on an Android device, since these components are iOS-exclusive:</p>
<pre>
  _renderActionAndShareSheets () { 
    if (Platform.OS === 'android') { 
      return; 
    } 
</pre>
<p>Return a <kbd>Button</kbd> that calls <kbd>_openActionSheet</kbd> when pressed:</p>
<pre>
    return ( 
      &lt;View&gt; 
        &lt;Button 
          color={ '#365899' } 
          onPress={ () =&gt; this._openActionSheet() } 
          title={ 'Open Action Sheet' }  
        /&gt; 
      &lt;/View&gt; 
    ) 
  } 
} 
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Sharing content with ShareSheetIOS</h1>
            </header>

            <article>
                
<p>The share sheet, on the other hand, is a different type of interaction. As I mentioned earlier, the Share sheet lets our app share content with it. To open it, we call <kbd>showShareActionSheetWithOptions</kbd>. It accepts three arguments: an <kbd>options</kbd> object, a <kbd>failureCallback</kbd> function, and a <kbd>successCallback</kbd> function.</p>
<p>The Share sheet's <kbd>options</kbd> object is different from the one that the action sheet accepted. It can contain the following properties:</p>
<ul>
<li><kbd>url</kbd>: This is a stringified URL to share. The <kbd>url</kbd> property is required if the message property is not available. The url can point to a local file or base-64 encoded <kbd>url</kbd>; it can share images, videos, PDFs, and other types of files this way.</li>
<li><kbd>message</kbd>: This is a string that contains a message for the user to share. The message property is required if the <kbd>url</kbd> property is not available.</li>
<li><kbd>subject</kbd>: This is a string that contains a subject for the message.</li>
</ul>
<p>The <kbd>failureCallback</kbd> is fired when a Share sheet action fails or is canceled by the user, while the <kbd>successCallback</kbd> is fired when a Share sheet action is successfully carried through by the user.</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="150" src="assets/image_09_006.png" width="222"/></div>
<p>Let's modify the index file to do the following:</p>
<ul>
<li>Modify <kbd>_renderActionAndShareSheets</kbd> to return a second button, directly underneath the first, that will open the ShareSheet when tapped on</li>
<li>Create a function, called <kbd>_openShareSheet</kbd>, to handle the opening of that Share sheet</li>
</ul>
<p>This is how my version came about. Call the <kbd>showShareActionSheetWithOptions</kbd> method of <kbd>ActionSheetIOS</kbd>, giving it a link to open and a message to share, along with a <kbd>subject</kbd> and <kbd>error</kbd>/<kbd>success</kbd> callbacks:</p>
<pre>
// AdditionalComponents/app/index.js 

... 
export default class App extends Component { 
  ... 
  _openShareSheet () { 
    ActionSheetIOS.showShareActionSheetWithOptions({ 
      url: 'https://facebook.github.io/react-native', 
      message: 'Check out the React Native documentation here,
      it's really helpful!', 
      subject: 'Link to React Native docs' 
    }, (error) =&gt; alert(error), 
    (success) =&gt; { 
      alert(success); 
    }) 
  } 
</pre>
<p>Take a look at the following code:</p>
<pre>
  _renderActionAndShareSheets () { 
    ... 
    return ( 
      &lt;View&gt; 
        ... 
        &lt;Button 
          color={ '#365899' } 
          onPress={ () =&gt; this._openShareSheet() } 
          title={ 'Open Share Sheet' } 
        /&gt; 
      &lt;/View&gt; 
    ) 
  } 
} 
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Grabbing user geolocation data</h1>
            </header>

            <article>
                
<p>The <kbd>Geolocation</kbd> API for React Native is an extension of the <kbd>Web Geolocation</kbd> API. It's available by calling <kbd>navigator.geolocation</kbd> and does not need to be imported.</p>
<div class="packt_infobox">
<p>Location data is a very important part of the mobile experience and as a best practice, this data should not be requested from your users until there is an explicit benefit for the user to provide the said information.</p>
<p>As location data is private until the user consents to share it with you, treat the sharing of this information as a bond of trust between the user and your app.</p>
<p>Always make the assumption that your users will select <span class="packt_screen">No</span> when asked to share their location, and devise a strategy for how to handle that rejection when it inevitably happens.</p>
</div>
<p>On iOS, if you created your project using React Native in it, Geolocation will be enabled by default. If not, you will need to go to your <kbd>Info.plist</kbd> file and add the <kbd>NSLocationWhenInUsageDescription</kbd> key to it.</p>
<p>On Android devices, you will need to add the following line to the <kbd>AndroidManifest.xml</kbd> file:</p>
<pre>
&lt;uses-permission android:name=
"android.permission.ACCESS_FINE_LOCATION" /&gt; 
</pre>
<p>The <kbd>Geolocation</kbd> API has access to four different methods. These are the three we will be covering in our example:</p>
<ul>
<li><kbd>getCurrentPosition</kbd>: This is a function that gets the current location of the device. It accepts up to three arguments:
<ul>
<li>The first, a <kbd>success</kbd> callback, is mandatory and is called with the current location information.</li>
<li>The second, an <kbd>error</kbd> callback, is optional.</li>
<li>The third is an optional options array that can contain the following supported options: <kbd>timeout</kbd> (in milliseconds), <kbd>maximumAge</kbd> (in milliseconds), and <kbd>enableHighAccuracy</kbd> (a Boolean).</li>
</ul>
</li>
<li><kbd>watchPosition</kbd>: This is a function that watches the device's location and returns a watch ID number. It accepts up to three arguments:
<ul>
<li>The first is a mandatory <kbd>success</kbd> callback that is fired whenever the location changes.</li>
<li>The second is an optional callback to handle errors.</li>
<li>The third is another optional options object that can contain the <kbd>timeout</kbd>, <kbd>maximumAge</kbd>, and <kbd>enableHighAccuracy</kbd> properties with the same types as the options object of <kbd>getCurrentPosition</kbd> as well as a <kbd>distanceFilter</kbd> property that accepts a number in meters.</li>
</ul>
</li>
<li><kbd>clearWatch</kbd>: This is a function that accepts a watch ID number and stops watching that position.</li>
</ul>
<p>Here is a sample of the current location object that the <kbd>Geolocation</kbd> API returns:</p>
<pre>
{ 
  coords: { 
    accuracy: 5, 
    altitude: 0, 
    altitudeAccuracy: -1, 
    heading: -1, 
    latitude: 37.785834, 
    longitude: -122.406417, 
    speed: -1 
  }, 
  timestamp: 1483251248689.033 
} 
</pre>
<p>Using the <kbd>Geolocation</kbd> API, let's modify the index file so that we can do the following things:</p>
<ul>
<li>Grab the user's location during the <kbd>componentDidMount</kbd> life cycle</li>
<li>Show their latitude and longitude on the screen</li>
<li>Additionally, create a button that watches the device's location and updates it whenever it changes on press</li>
<li>Then, create a button that clears it</li>
</ul>
<p>Here is the code that I wrote for this section. Make a call to the <kbd>getCurrentPosition</kbd> method of the <kbd>Geolocation</kbd> API during the <kbd>componentDidMount</kbd> life cycle, saving the location to state:</p>
<pre>
// AdditionalComponents/app/index.js 

... 
export default class App extends Component { 
  ... 
  async componentDidMount () { 
    ... 
    navigator.geolocation.getCurrentPosition((location) =&gt; { 
      this.setState({ 
        location 
      }); 
    }); 
  } 
</pre>
<p>Render the latitude and longitude of the user in <kbd>Text</kbd> components:</p>
<pre>
  render () { 
    return ( 
      &lt;View style={ styles.container }&gt; 
        ... 
        &lt;Text style={ styles.latLongText }&gt; 
          Your Latitude is: { this.state.location ? 
          this.state.location.coords.latitude : 'undefiend' } 
        &lt;/Text&gt; 
        &lt;Text style={ styles.latLongText }&gt; 
          Your Longitude is: { this.state.location ? 
          this.state.location.coords.longitude : 'undefined' } 
        &lt;/Text&gt; 
</pre>
<p>Render one button to start and another to stop the watch process:</p>
<pre>
        &lt;Button 
          color={ '#80B546' } 
          onPress={ () =&gt; this._onBeginWatchPositionButtonPress() } 
          title={ 'Start Watching Position' } 
        /&gt; 
        &lt;Button 
          color={ '#80B546' } 
          disabled={ this.state.watchID !== undefined ? false : true } 
          onPress={ () =&gt; this._onCancelWatchPositionButtonPress() } 
          title={ 'Cancel Watching Position' } 
        /&gt; 
      &lt;/View&gt; 
    ) 
  } 
</pre>
<p>Set the location of the user when they begin watching their position:</p>
<pre>
  ... 
  _onBeginWatchPositionButtonPress () { 
    const watchID = navigator.geolocation.watchPosition((watchSuccess)   
    =&gt; { 
      this.setState({ 
        location: watchSuccess 
      }); 
    }); 
</pre>
<p>Save the ID of the <kbd>watchPosition</kbd> call to state:</p>
<pre>
    this.setState({ 
      watchID 
    }); 
  }
</pre>
<p>Call <kbd>clearWatch</kbd> when the user presses the <span class="packt_screen">Cancel Watching Position</span> button and erase the <kbd>watchID</kbd> in state:</p>
<pre>
   _onCancelWatchPositionButtonPress () { 
    navigator.geolocation.clearWatch(this.state.watchID); 
 
    this.setState({ 
      watchID: undefined 
    }); 
  } 
  ... 
} 
</pre>
<p>Great job! You finished the playground section of this chapter. In the next section, we will switch gears and revisit the <kbd>Expenses</kbd> app from <a href="94aea5f2-1fde-4cb4-b28e-8b3c6354a298.xhtml">Chapter 4</a>, <em>Advanced Functionality with the Expenses App</em>.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Expenses for Android</h1>
            </header>

            <article>
                
<p>In <a href="94aea5f2-1fde-4cb4-b28e-8b3c6354a298.xhtml"><em>Chapter 4</em></a>, <em>Advanced Functionality with the Expenses App</em>, we completed building the iOS version of Expenses, our budget tracking application. Due to the page count of the chapter, I thought it would be best to place the Android portion at the end of this chapter instead.</p>
<p>This section picks up immediately from where we left off at the end of <a href="94aea5f2-1fde-4cb4-b28e-8b3c6354a298.xhtml"><em>Chapter 4</em></a>, <em>Advanced Functionality with the Expenses App</em>.</p>
<div class="packt_infobox">An example code for the Android version of Expenses can still be found in the code repository for <a href="94aea5f2-1fde-4cb4-b28e-8b3c6354a298.xhtml"><em>Chapter 4</em></a>, <em>Advanced Functionality with the Expenses App</em>.</div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Android modifications</h1>
            </header>

            <article>
                
<p>For Android support, we want to do the following things to our code base:</p>
<ul>
<li>Import the <kbd>react-native-vector-icons</kbd> library via Gradle</li>
<li>Swap out the <kbd>TabBarIOS</kbd> component for an Android-based solution using the <kbd>DrawerLayoutAndroid</kbd> and <kbd>ToolbarAndroid</kbd> components to create a navigation bar that contains a drawer that slides out to toggle between the current and previous months' expenses</li>
<li>Replace any <kbd>NavigatorIOS</kbd> instances with <kbd>Navigator</kbd></li>
<li>Remove <kbd>ProgressViewIOS</kbd></li>
<li>Remove the <kbd>ExpandableCell</kbd> components in <kbd>AddExpensesModal</kbd> and replace <kbd>DatePickerIOS</kbd> with <kbd>DatePickerAndroid</kbd></li>
<li>Add any Android-specific files to components that require them</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Installing the vector icon library</h1>
            </header>

            <article>
                
<p>You should not need to do anything extra to have the <kbd>react-native-vector-icons</kbd> library installed for Android since React Native link should have taken care of the entire process for you.</p>
<p>However, if you decided to link the library manually for iOS, the readme file for <kbd>react-native-vector-icons</kbd> has the latest, up-to-date instructions for importing the library manually for Android devices. As these instructions can change with newer releases to the library, I heavily recommend you follow them directly from the <kbd>README</kbd> file.</p>
<p>If you already have the package installed in your project's <kbd>node_modules</kbd> folder, you can read the instructions from there without requiring further Internet access.</p>
<p>The instructions on importing with Gradle are very straightforward. You will also want to follow the instructions for integrating the library for <kbd>getImageSource</kbd> and <kbd>ToolbarAndroid</kbd> support.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">ToolbarAndroid</h1>
            </header>

            <article>
                
<p>On Android, the preferred way to navigate the UI is through its top-placement toolbar. This differs from the iOS experience because rather than having all the available tabs at the bottom of the screen, navigation is hidden inside a drawer that the user taps to expose.</p>
<p><kbd>ToolbarAndroid</kbd> is a React Native, Android-specific component that wraps around the Android SDK's native toolbar widget. Like <kbd>TabBarIOS</kbd>, we have access to a <kbd>react-native-vector-icons</kbd>-specific version of the component that we render by calling <kbd>&lt;Icon.ToolbarAndroid /&gt;</kbd>. We will be using the following props when using <kbd>Icon.ToolbarAndroid</kbd> in our app:</p>
<ul>
<li><kbd>title</kbd>: This is a string that is displayed at the top of the toolbar showing the name of the app</li>
<li><kbd>titleColor</kbd>: This sets the color of the <kbd>title</kbd> string</li>
<li><kbd>navIconName</kbd>: This is a string that sets the icon of the navigation menu in the toolbar</li>
<li><kbd>height</kbd>: This is a number to set the height of the toolbar</li>
<li><kbd>backgroundColor</kbd>: This sets the background color of the toolbar</li>
<li><kbd>onIconClicked</kbd>: This is a callback that is executed when the navigation icon is tapped on by the user</li>
</ul>
<p>However, you may have noted that there's no room for the actual <kbd>Navigation</kbd> drawer that this Navigation icon traditionally opens. That's because we will use <kbd>Icon.ToolbarAndroid</kbd> in conjunction with <kbd>DrawerLayoutAndroid</kbd>, the component that handles the actual navigation drawer.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">DrawerLayoutAndroid</h1>
            </header>

            <article>
                
<p>This component is typically used for navigation. Think of this as the place where the tabs in TabBarIOS will be made available.</p>
<p>The <kbd>DrawerLayoutAndroid</kbd> component has access to the <kbd>openDrawer</kbd> and <kbd>closeDrawer</kbd> methods responsible for its visibility. To use it, pass a ref to the component and use it to call either method.</p>
<p>While this component has many props available to it, we will be using just the following:</p>
<ul>
<li><kbd>drawerLockMode</kbd>: This is one of the three strings that determine whether the drawer responds to touch gestures, such as sliding the drawer open/closed. This does not disable the toolbar's navigation icon from opening and closing the drawer:
<ul>
<li><kbd>unlocked</kbd>: the drawer responds to touch gestures</li>
<li><kbd>locked-closed</kbd>: the drawer stays closed and does not respond to touch gestures</li>
<li><kbd>locked-open</kbd>: the drawer stays open and does not respond to touch gestures</li>
</ul>
</li>
<li><kbd>ref</kbd>: This is a reference string to pass to the drawer. This is so that we can reference the drawer within its child components, which will be necessary to open and close it.</li>
<li><kbd>renderNavigationView</kbd>: This is a function responsible for the rendering of your drawer.</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Connecting ToolbarAndroid and DrawerLayoutAndroid</h1>
            </header>

            <article>
                
<p>The way we connect these two components together is to start by writing an <kbd>Icon.ToolbarAndroid</kbd> component:</p>
<pre>
&lt;Icon.ToolbarAndroid 
  title={ 'Expense' } 
  titleColor={ '#7D878D' } 
  navIconName={ 'menu' } 
  height={ 56 } 
  backgroundColor={ '#4E92B5' } 
  onIconClicked={ () =&gt; this._openDrawer(); } 
/&gt; 
</pre>
<p>Then, create a <kbd>DrawerLayoutAndroid</kbd> component and wrap it around two children: the <kbd>Icon.ToolbarAndroid</kbd> component you just created along with the <kbd>Navigator</kbd> following it:</p>
<pre>
&lt;DrawerLayoutAndroid 
  drawerLockMode={ 'unlocked' } 
  ref={ 'drawer' } 
  renderNavigationView={ () =&gt; this._renderDrawerLayout() } 
&gt; 
  // Insert Toolbar here 
  &lt;Navigator 
  initialRoute={{ index: 0 }} 
  ref={ 'navigator' } 
  renderScene={ (routes, navigator) =&gt; this._renderScene(routes, navigator) } 
  /&gt; 
&lt;/DrawerLayoutAndroid&gt; 
</pre>
<p>When integrating the three components, we want to ensure that the following is always true:</p>
<ul>
<li><kbd>DrawerLayoutAndroid</kbd> is always positioned above everything else so that the drawer doesn't get tucked underneath <kbd>Icon.ToolbarAndroid</kbd></li>
<li>When using the options of <kbd>DrawerLayoutAndroid</kbd> to navigate from one view to another, the same instance of <kbd>Icon.ToolbarAndroid</kbd> should be present so that we are not rendering a whole new <kbd>Icon.ToolbarAndroid</kbd> component every single time, nor will it contain an animation of the said toolbar ever <em>leaving</em> the screen to be replaced by <em>another</em></li>
</ul>
<p>What we'll do here is nest <kbd>Icon.ToolbarAndroid</kbd> and <kbd>Navigator</kbd> within <kbd>DrawerLayoutAndroid</kbd>, and set a <kbd>ref</kbd> for <kbd>Navigator</kbd> so that we can use that <kbd>Navigator</kbd> to push new scenes into the app, as needed within our root file.</p>
<p>Once you have implemented both the <kbd>Icon.ToolbarAndroid</kbd> and <kbd>DrawerLayoutAndroid</kbd> components, you will be able to have in-app navigation that looks like this:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1456 image-border" height="337" src="assets/image_09_007-1.png" width="184"/></div>
<p>Here is how the big picture looks:</p>
<pre>
// Expenses/index.android.js 

import React, { Component } from 'react'; 
import { 
  AppRegistry, 
  DrawerLayoutAndroid, 
  Navigator, 
  StyleSheet, 
  View 
} from 'react-native'; 
 
import App from './app/App'; 
import CurrentMonthExpenses from './app/components/CurrentMonthExpenses';
import Drawer from './app/components/Drawer'; 
import EnterBudget from './app/components/EnterBudget'; 
import PreviousMonthsList from './app/components/PreviousMonthsList'; 
</pre>
<p>These are the four components that this index file will work with. The <kbd>App</kbd>, <kbd>EnterBudget</kbd>, and <kbd>PreviousMonthsList</kbd> components will be part of our navigation routes. The <kbd>Drawer</kbd> component is used to render the navigation view for <kbd>DrawerLayoutAndroid</kbd>.</p>
<p>As Android software has a different design language from iOS apps, I imported the <kbd>MaterialIcons</kbd> pack instead of <kbd>FontAwesome</kbd> since it's built with Google's Material Design guidelines in mind:</p>
<pre>
import Icon from 'react-native-vector-icons/MaterialIcons'; 
</pre>
<p>A property titled <kbd>expenses</kbd> is set to be undefined. This is to pass over to <kbd>PreviousMonthsList</kbd> since it expects the list of expenses as a prop.</p>
<p>Visible routes are passed to the <kbd>Drawer</kbd> component. I purposefully omit the route that handles entering a budget for the month because it isn't one that the user should be able to manually navigate to.</p>
<p>In the <kbd>WillMount</kbd> component life cycle, I call the <kbd>_updateExpenses</kbd> method to set the <kbd>expenses</kbd> key in state to the expenses object. Check out the code for the explanation given here:</p>
<pre>
class Expense extends Component { 
  constructor (props) { 
    super (props); 
    this.state = { 
      expenses: undefined, 
      visibleRoutes: [ 
        { title: 'This Month', index: 0 }, 
        { title: 'Past Months', index: 2 } 
      ] 
    } 
  } 
 
  componentWillMount () { 
    this._updateExpenses(); 
  } 

  render() { 
    const routes = [ 
      { title: 'Expense', index: 0 }, 
      { title: 'Enter Your Budget', index: 1 }, 
      { title: 'Previous Month List', index: 2 }, 
      { title: 'Past Expenses', index: 3}
    ]; 
    return ( 
      &lt;View style={ styles.container }&gt; 
        &lt;DrawerLayoutAndroid 
          drawerLockMode={ 'unlocked' } 
          ref={ 'drawer' } 
          renderNavigationView={ () =&gt; this._renderDrawerLayout()        
            } 
        &gt; 
</pre>
<p>Within the <kbd>DrawerLayoutAndroid</kbd> component, I am nesting both <kbd>Icon.ToolbarAndroid</kbd> and <kbd>Navigator</kbd>. Like I mentioned earlier, this is to physically place the drawer on a layer above the rest of the app. Check out the following code:</p>
<pre>
          &lt;Icon.ToolbarAndroid 
             
            titleColor="white" 
            navIconName="menu" 
            height={ 56 } 
            backgroundColor="blue" 
            onIconClicked={ () =&gt; this._openDrawer() } 
          /&gt; 
          &lt;Navigator 
            initialRoute={{ index: 0 }} 
            ref={ 'navigator' } 
            renderScene={ (routes, navigator) =&gt;  
              this._renderScene(routes, navigator) } 
          /&gt; 
        &lt;/DrawerLayoutAndroid&gt; 
      &lt;/View&gt; 
    ); 
  } 
 
  _openDrawer () { 
    this.refs['drawer'].openDrawer(); 
  } 
</pre>
<p>Having given <kbd>DrawerLayoutAndroid</kbd> a ref of <kbd>drawer</kbd> earlier, I can use it to open the drawer when the navigation icon is tapped on by the user. I also gave <kbd>Navigator</kbd> a ref of <kbd>navigator</kbd> so that I can push to it at the root <kbd>index.android.js</kbd> level.</p>
<p>The <kbd>DrawerLayoutAndroid</kbd> component's <kbd>render</kbd> method returns this <kbd>Drawer</kbd> component that I import from a custom component I wrote. I pass it a callback under the prop name of <kbd>navigateTo</kbd>, whose function pushes the index of the <kbd>navigator</kbd> and closes <kbd>DrawerLayoutAndroid</kbd>:</p>
<pre>
  _navigateTo (index) { 
    this.refs['navigator'].push({ 
      index: index 
    }); 
    this.refs['drawer'].closeDrawer(); 
  } 
 
  _renderDrawerLayout () { 
    return ( 
      &lt;Drawer 
        navigateTo={ (index) =&gt; this._navigateTo(index) } 
        routes={ this.state.visibleRoutes } 
      /&gt; 
    ) 
  } 
</pre>
<p>The rendering of <kbd>PreviousMonthsList</kbd> with <kbd>_renderScene</kbd> is configured to pass in the <kbd>expenses</kbd> object and <kbd>updateExpenses</kbd> function.</p>
<p> </p>
<pre>
  _renderScene (route, navigator) { 
    if (route.index === 0) { 
      return ( 
        &lt;App 
          title={ route.title } 
          navigator={ navigator } 
        /&gt; 
      ) 
    } 
 
    if (route.index === 1) { 
      return ( 
        &lt;EnterBudget 
          title={ route.title } 
          navigator={ navigator } 
          { ...route.passProps } 
        /&gt; 
      ) 
    } 
 
    if (route.index === 2) { 
      return ( 
        &lt;PreviousMonthsList 
          title={ route.title } 
          navigator={ navigator } 
          expenses={ this.state.expenses } 
          updateExpenses={ () =&gt; this._updateExpenses() } 
        /&gt; 
      ) 
    } 
    if (route.index === 3) { 
      return ( 
        &lt;CurrentMonthExpenses 
          title={ route.title } 
          navigator={ navigator } 
          { ...route.passProps } 
        /&gt; 
      ) 
    } 
  }
</pre>
<p>The <kbd>_updateExpenses</kbd> function passed into <kbd>PreviousMonthsList</kbd> as the prop titled <kbd>updateExpenses</kbd> is a modified version of the <kbd>_updateExpenses</kbd> function found in the <kbd>App</kbd> component. We only care about the <kbd>expenses</kbd> object in this component, so we will not bother setting any other data:</p>
<pre>
  async _updateExpenses () { 
 
    let response = await storageMethods.getAsyncStorage(); 
 
    if (response) { 
      this.setState({ 
        expenses: response 
      }); 
    } 
  } 
} 

const styles = StyleSheet.create({ 
  container: { 
    flex: 1 
  } 
}) 
 
AppRegistry.registerComponent('Expense', () =&gt; Expense); 
</pre>
<p>Then, I built the <kbd>Drawer</kbd> component:</p>
<pre>
// Expenses/app/components/Drawer/index.android.js 

import React, { Component, PropTypes } from 'react'; 
 
import { 
  ListView, 
  Text, 
  TouchableHighlight, 
  View 
} from 'react-native'; 
 
import DrawerRow from '../DrawerRow'; 
import styles from './styles'; 
</pre>
<p>The <kbd>DrawerRow</kbd> component that <kbd>Drawer</kbd> imports is responsible for rendering individual rows of data for the <kbd>ListView</kbd> component of  <kbd>Drawer</kbd>.</p>
<pre>
export default class Drawer extends Component { 
  static propTypes = { 
    navigateTo: PropTypes.func.isRequired, 
    routes: PropTypes.array.isRequired 
  } 
 
  constructor (props) { 
    super (props); 
    this.state = { 
      ds: new ListView.DataSource({ 
        rowHasChanged: (r1, r2) =&gt; r1 !== r2 
      }) 
    } 
  } 
 
  render () { 
    const dataSource = this.state.ds.cloneWithRows(this.props.routes); 
 
    return ( 
      &lt;View style={ styles.container }&gt; 
        &lt;ListView 
          automaticallyAdjustContentInsets={ false } 
          dataSource={ dataSource } 
          enableEmptySections={ true } 
          renderRow={ (rowData, sectionID, rowID) =&gt; 
          this._renderDrawerRow(rowData, sectionID, rowID) } 
          renderSeparator={ (sectionID, rowID) =&gt; 
            &lt;View 
              key={ rowID } 
              style={ styles.separator } 
            /&gt; 
          } 
        /&gt; 
      &lt;/View&gt; 
    ) 
  } 
</pre>
<p> </p>
<p>The <kbd>render</kbd> method of <kbd>Drawer</kbd> returns a simple <kbd>ListView</kbd> that uses the routes array passed to it as a prop to generate each row of data.</p>
<pre>
_renderDrawerRow (rowData, sectionID, rowID) { 
    return ( 
      &lt;View&gt; 
        &lt;TouchableHighlight 
          style={ styles.row } 
          onPress={ () =&gt; this.props.navigateTo(rowData.index) } 
        &gt; 
          &lt;DrawerRow routeName={ rowData.title } /&gt; 
          &lt;/TouchableHighlight&gt; 
      &lt;/View&gt; 
    ) 
  } 
} 
</pre>
<p>Then, I created a basic <kbd>StyleSheet</kbd> for this component:</p>
<pre>
// Expenses/App/components/Drawer/styles.js 

import { StyleSheet } from 'react-native'; 
 
const styles = StyleSheet.create({ 
  container: { 
    flex: 1 
  }, 
  separator: { 
    height: StyleSheet.hairlineWidth, 
    marginLeft: 10, 
    marginRight: 10, 
    backgroundColor: '#E5F2FD' 
  } 
}); 
 
export default styles; 
</pre>
<p>After that, I wrote the <kbd>DrawerRow</kbd> component:</p>
<pre>
// Expenses/app/components/DrawerRow/index.android.js  

import React, { Component } from 'react'; 
 
import { 
  Text, 
  View 
} from 'react-native'; 
 
import styles from './styles'; 
 
export default class DrawerRow extends Component { 
 
  setNativeProps (props) { 
    this._root.setNativeProps(props) 
  } 
</pre>
<p>Since <kbd>DrawerRow</kbd> is a custom component and the <kbd>TouchableHighlight</kbd> component that wraps around it from the <kbd>_renderDrawerRow</kbd> method of the <kbd>Drawer</kbd> component does not call <kbd>setNativeProps</kbd> for user-created components automatically, I manually called it:</p>
<pre>
  render () { 
    return ( 
      &lt;View 
        style={ styles.container } 
        ref={ component =&gt; this._root = component } 
        { ...this.props } 
      &gt; 
        &lt;Text style={ styles.rowTitle }&gt; 
          { this.props.routeName } 
        &lt;/Text&gt; 
      &lt;/View&gt; 
    ) 
  } 
} 
</pre>
<p>The <kbd>DrawerRow</kbd> component also has its own <kbd>StyleSheet</kbd>:</p>
<pre>
// Expenses/app/components/DrawerRow/styles.js 

import { StyleSheet } from 'react-native'; 
 
const styles = StyleSheet.create({ 
  container: { 
    flex: 1, 
    height: 40, 
    padding: 10 
  }, 
  rowTitle: { 
    fontSize: 20, 
    textAlign: 'left' 
  } 
}); 
 
export default styles; 
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Android-specific app component</h1>
            </header>

            <article>
                
<p>Next, I created an Android-specific version of <kbd>App.js</kbd>, renaming the original <kbd>App.ios.js</kbd>. Only two components are imported to <kbd>App.android.js</kbd> because any components being navigated to are handled in the root <kbd>index.android.js</kbd> file:</p>
<pre>
// Expenses/app/App.android.js 

import React, { Component } from 'react'; 
 
import { 
  Text, 
  View 
} from 'react-native'; 
 
import styles from './styles'; 
 
import * as dateMethods from './utils/dateMethods'; 
import * as storageMethods from './utils/storageMethods'; 
 
import AddExpenses from './components/AddExpenses'; 
import CurrentMonthExpenses from './components/CurrentMonthExpenses'; 
</pre>
<p>The state of the <kbd>App</kbd> component does not need a <kbd>selectedTab</kbd> property since we are not using tabbed navigation on Android:</p>
<pre>
export default class App extends Component { 
  constructor (props) { 
    super(); 
 
    this.state = { 
      budget: '', 
      expenses: {}, 
    } 
  } 
</pre>
<p>There are no changes to <kbd>componentWillMount</kbd> from its iOS counterpart:</p>
<pre>
  componentWillMount () { 
    ... 
  } 
</pre>
<p>As a result of removing tabbed navigation, the <kbd>render</kbd> method of this component has been simplified to just render the <kbd>CurrentMonthExpenses</kbd> and <kbd>AddExpenses</kbd> components:</p>
<pre>
  render () { 
    return ( 
      &lt;View style={ styles.androidContainer }&gt; 
        { this._renderCurrentMonthExpenses() } 
      &lt;/View&gt; 
    ) 
  } 
</pre>
<p>Like <kbd>componentWillMount</kbd>, <kbd>_renderCurrentMonthExpenses</kbd> has retained the exact same logic from the iOS version of the <kbd>App</kbd> component:</p>
<pre>
  _renderCurrentMonthExpenses () { 
    return ( 
      &lt;View style={ styles.androidContainer }&gt; 
        &lt;CurrentMonthExpenses 
          ... 
        /&gt; 
        &lt;AddExpenses 
          ... 
        /&gt; 
      &lt;/View&gt; 
    ) 
  } 
</pre>
<p>The <kbd>_renderEditBudgetComponent</kbd> method has been changed to account for how <kbd>Navigator</kbd> handles its <kbd>push</kbd> method differently from the <kbd>push</kbd> method of <kbd>NavigatorIOS</kbd> as mentioned in the following code:</p>
<pre>
  _renderEnterBudgetComponent () { 
    this.props.navigator.push({ 
      index: 1, 
      passProps: { 
        monthString: dateMethods.getMonthString(this.state.month), 
        saveAndUpdateBudget: (budget) =&gt; this._saveAndUpdateBudget(budget), 
        updateExpenses: () =&gt; this._updateExpenses() 
      } 
    }); 
  } 
</pre>
<p>While the iOS App component's <kbd>_renderPreviousMonthsList</kbd> method has been removed on Android, the logic for <kbd>_saveAndUpdateBudget</kbd>, <kbd>_updateBudget</kbd>, and <kbd>_updateExpenses</kbd> remains the same, as mentioned in the following code:</p>
<pre>
  async _saveAndUpdateBudget (budget) { 
    ... 
  } 
 
  async _updateBudget () { 
    ... 
  } 
 
  async _updateExpenses () { 
    ... 
  } 
} 
</pre>
<p>Finally, I added a simple <kbd>flex</kbd> container style for the <kbd>App</kbd> component:</p>
<pre>
// Expenses/app/styles.js 

... 
const styles = StyleSheet.create({ 
  androidContainer: { 
    flex: 1 
  }, 
  ... 
}); 
 
export default styles; 
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">EnterBudget styling changes</h1>
            </header>

            <article>
                
<p>Since Android text fields normally do not contain a border, I used some conditional logic with the <kbd>Platform</kbd> API to remove it:</p>
<pre>
// Expenses/app/components/EnterBudget/index.js 

... 
import { 
  Platform, 
  ... 
} from 'react-native'; 
... 
export default class EnterBudget extends Component { 
  ... 
  render () { 
    ... 
    return ( 
      &lt;View style={ styles.enterBudgetContainer }&gt; 
        ... 
        &lt;TextInput 
          style={ Platform.OS === 'ios' ? styles.textInput :
          styles.androidTextInput } 
          ... 
        /&gt; 
        ... 
      &lt;/View&gt; 
    ) 
  } 
  ... 
} 
</pre>
<p>The styling for the <kbd>TextInput</kbd> component in the <kbd>render</kbd> method of <kbd>EnterBudget</kbd> now checks to see whether the user's operating system is iOS or Android. If it is iOS, it keeps the original <kbd>textInput</kbd> style from before; if it is Android, it sets it to a new <kbd>androidTextInput</kbd> style.</p>
<pre>
// Expenses/app/components/EnterBudget/styles.js 

... 
const styles = StyleSheet.create({ 
  androidTextInput: { 
    color: '#3D4A53', 
    margin: 10, 
    padding: 10, 
    textAlign: 'center' 
  }, 
  ... 
}); 
 
export default styles; 
</pre>
<p>Next up, we will make some changes to <kbd>CurrentMonthExpenses</kbd>.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">CurrentMonthExpenses for Android</h1>
            </header>

            <article>
                
<p>In the <kbd>CurrentMonthExpenses</kbd> component, I am rendering a <kbd>ProgressViewIOS</kbd> component that visually tracks the amount spent by the user using a colored, horizontal bar.</p>
<p>The React Native SDK for Android has a similar component, <kbd>ProgressBarAndroid</kbd>, and we will swap out <kbd>ProgressViewIOS</kbd> for it.</p>
<p>Additionally, we want to add a back button event listener for this component that is only fired when the user navigates to <kbd>CurrentMonthExpenses</kbd> by way of <kbd>PreviousMonthsList</kbd> with <kbd>BackAndroid</kbd>.</p>
<p> </p>
<p>The <kbd>ProgressBarAndroid</kbd> component is similar to <kbd>ProgressViewIOS</kbd>. I'm using the following props in mine:</p>
<ul>
<li><kbd>color</kbd>: This determines the color of <kbd>ProgressBarAndroid</kbd>.</li>
<li><kbd>indeterminate</kbd>: This is a Boolean that, when set to true, keeps the progress bar animated indefinitely.</li>
<li><kbd>progress</kbd>: Just like <kbd>ProgressViewIOS</kbd>, this determines how far along the progress bar should move.</li>
<li><kbd>styleAttr</kbd>: This is a string to tell how <kbd>ProgressBarAndroid</kbd> should be rendered. For mine, I used <kbd>horizontal</kbd>.</li>
</ul>
<p>The <kbd>render</kbd> method for <kbd>CurrentMonthExpenses</kbd> now calls a <kbd>_renderProgressIndicator</kbd> method to determine which progress indicator to render: <kbd>ProgressViewIOS</kbd> is to be rendered for iOS devices, and <kbd>ProgressBarAndroid</kbd> for Android ones.</p>
<p>The <kbd>ListView</kbd> is now wrapped around a <kbd>View</kbd> to give it some separation from the progress indicator:</p>
<pre>
// Expenses/app/components/CurrentMonthExpenses/index.js 

... 
import { 
  ... 
  BackAndroid, 
  Platform, 
  ... 
} from 'react-native'; 
... 
export default class CurrentMonthExpenses extends Component { 
  ... 
  componentWillMount () { 
    BackAndroid.addEventListener('hardwareButtonPress', () =&gt;
    this._backButtonPress()); 
  } 
 
  componentWillUnmount () { 
    BackAndroid.removeEventListener('hardwareButtonPress', () =&gt; 
    this._backButtonPress()) 
  } 
 
  render () { 
    ... 
    return ( 
      &lt;View style={ ... }&gt; 
        &lt;View style={ styles.currentMonthExpensesHeader }&gt; 
          ... 
          { this._renderProgressIndicator() } 
        &lt;/View&gt; 
        &lt;View style={ styles.listViewContainer }&gt; 
          &lt;ListView 
          ... 
          /&gt; 
        &lt;/View&gt; 
      &lt;/View&gt; 
    ) 
  } 
</pre>
<p>I am only calling <kbd>pop</kbd> on the <kbd>navigator</kbd> if it is a previous month's data the user is looking at. Otherwise, they will run into an error when attempting to call <kbd>pop</kbd> without any other routes visited:</p>
<pre>
  _backButtonPress () { 
    if (this.props.isPreviousMonth) { 
      this.props.navigator.pop(); 
      return true; 
    } 
  } 
</pre>
<p>There have been no changes to the iOS progress indicator logic:</p>
<pre>
  ... 
  _renderProgressIndicator () { 
    if (Platform.OS === 'ios') { 
      return ( 
        &lt;ProgressViewIOS 
          progress={ this._getProgressViewAmount() } 
          progressTintColor={ '#A3E75A' } 
          style={ styles.progressView } 
        /&gt; 
      ) 
    } 
</pre>
<p>The Android progress indicator is returned at the end of the function. I am reusing the <kbd>_getProgressViewAmount</kbd> method here:</p>
<pre>
    return ( 
      &lt;View style={ styles.progressView }&gt; 
        &lt;ProgressBarAndroid 
          color={ '#A3E75A' } 
          indeterminate={ false } 
          progress={ this._getProgressViewAmount() } 
          styleAttr={ 'Horizontal' } 
        /&gt; 
      &lt;/View&gt; 
    ) 
  } 
  ... 
}; 
</pre>
<p>No other code for this component was changed, and its Android-specific version was not necessary because of the minimal changes.</p>
<p>The styling for <kbd>CurrentMonthExpenses</kbd> has been changed to add the <kbd>listViewContainer</kbd> property:</p>
<pre>
// Expenses/app/components/CurrentMonthExpenses/styles.js 

... 
const styles = StyleSheet.create({ 
  ... 
  listViewContainer: { 
    flex: 1, 
    marginTop: 20 
  }, 
  ... 
}); 
 
export default styles; 
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Removing ExpandableCell from AddExpensesModal</h1>
            </header>

            <article>
                
<p>As the <kbd>DatePickerAndroid</kbd> and <kbd>Picker</kbd> components render as a modal on an Android device, I made some modifications to the <kbd>AddExpensesModal</kbd> component to remove the instances of <kbd>ExpandableCell</kbd>.</p>
<p>This resulted in a new Android-specific file because of the large number of changes. I removed the <kbd>categoryPickerExpanded</kbd> and <kbd>datePickerExpanded</kbd> properties in state, as well as the importing of <kbd>DatePickerIOS</kbd> and <kbd>ExpandableCell</kbd>:</p>
<pre>
// .../app/components/AddExpensesModal/index.android.js  

... 
import { 
  DatePickerAndroid, 
  ... 
} from 'react-native'; 
... 
export default class AddExpensesModal extends Component { 
  ... 
  constructor (props) { 
    super (props); 
 
    this.state = { 
      amount: '', 
      category: undefined, 
      date: new Date(), 
      description: '', 
    } 
  } 
</pre>
<p>These two constants previously started with the prefix of <kbd>expandableCell</kbd>, but that prefix has been removed since the <kbd>ExpandableCell</kbd> component is not being used in the Android version of this component:</p>
<pre>
  render () { 
    const datePickerButtonTitle = ... 
    const categoryPickerButtonTitle = ... 
</pre>
<p>The <kbd>onRequestClose</kbd> callback is a required prop for <kbd>Modal</kbd> components on Android. The callback is executed when the user presses the back button on an Android device while the modal is open. In this case, I perform the same action as if the user pressed the <span class="packt_screen">Cancel</span> button:</p>
<pre>
    return ( 
      &lt;Modal 
        ... 
        onRequestClose={ () =&gt; this._clearFieldsAndCloseModal() }
      &gt; 
</pre>
<p>Android-specific styles for the two <kbd>TextInput</kbd> components were made to accommodate stylistic differences between Android and iOS applications:</p>
<pre>
        &lt;ScrollView style={ styles.modalContainer }&gt; 
          &lt;View style={ styles.amountRow }&gt; 
            ... 
            &lt;TextInput 
              ... 
              style={ styles.androidAmountInput } 
            /&gt; 
          &lt;/View&gt; 
          &lt;Text style={ styles.descriptionText }&gt; 
            ... 
          &lt;/Text&gt; 
</pre>
<p>The <kbd>View</kbd> that was previously styled to <kbd>expandableCellContainer</kbd> have been changed to <kbd>androidPickerContainers</kbd>. The preceding <kbd>Button</kbd> component calls <kbd>_renderDatePicker</kbd> when pressed, which handles the rendering of <kbd>DatePickerAndroid</kbd>:</p>
<pre>
          &lt;TextInput 
            ... 
            style={ styles.androidDescriptionInput } 
          /&gt; 
          &lt;View style={ styles.androidPickerContainers }&gt; 
            &lt;Button 
              color={ '#86B2CA' } 
              onPress={ () =&gt; this._renderDatePicker() } 
              title={ datePickerButtonTitle } 
            /&gt; 
          &lt;/View&gt; 
</pre>
<p>Since the regular <kbd>Picker</kbd> component is not opened with an asynchronous function like <kbd>DatePickerAndroid</kbd>, I kept its logic intact:</p>
<pre>
          &lt;View style={ styles.androidPickerContainers }&gt; 
            &lt;View style={ styles.categoryIcon }&gt; 
              { this.state.category &amp;&amp; 
              iconMethods.getIconComponent(this.state.category) } 
            &lt;/View&gt; 
              &lt;Picker 
                ... 
                prompt={ categoryPickerButtonTitle } 
              &gt; 
              { this._renderCategoryPicker() } 
            &lt;/Picker&gt; 
          &lt;/View&gt; 
          ... 
        &lt;/ScrollView&gt; 
      &lt;/Modal&gt; 
    ) 
  } 
</pre>
<p>The <kbd>_clearFieldsAndCloseModal</kbd> method was modified to remove the setting of the now-removed <kbd>ExpandableCell</kbd>-specific properties in state:</p>
<pre>
... 
_clearFieldsAndCloseModal () { 
    this.setState({ 
      amount: '', 
      category: undefined, 
      date: new Date(), 
      description: '' 
    }); 
 
    this.props.toggleModal() 
  } 
... 
</pre>
<p>Finally, <kbd>_renderDatePicker</kbd> was created to handle the asynchronous nature of the <kbd>DatePickerAndroid</kbd> component.</p>
<p>In the Android version of the <kbd>AddExpensesModal</kbd> component, none of the iOS version's methods were removed:</p>
<pre>
  async _renderDatePicker () { 
    const options = { 
      date: this.state.date 
    }; 
 
    const { action, year, month, day } = await 
    DatePickerAndroid.open(options); 
 
    if (action === DatePickerAndroid.dismissedAction) { 
      return; 
    } 
 
    this.setState({ 
      day, 
      month, 
      year 
    }); 
 
    this._onDateChange(); 
  } 
  ... 
} 
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Modifying Navigation for PreviousMonthsList</h1>
            </header>

            <article>
                
<p>The next thing to do is modify the <kbd>push</kbd> method of <kbd>navigator</kbd> for Android:</p>
<pre>
// Expenses/app/components/PreviousMonthsList/index.js 

... 
import { 
  Platform, 
  ... 
} from 'react-native'; 
... 
export default class PreviousMonthsList extends Component { 
  ... 
  render () { 
   &lt;View style={ Platform.OS === 'ios' ? styles.previousMonthsListContainer : {}    }&gt;
...
   &lt;/View&gt; 
  } 
  ... 
</pre>
<p>I made a styling adjustment for the <kbd>View</kbd> container that wraps around the rest of <kbd>PreviousMonthsList</kbd> for Android devices to keep the <kbd>ListView</kbd> just below the navigation bar on Android.</p>
<p>There have been no changes to the original rendering method if on iOS:</p>
<pre>
  _renderSelectedMonth (rowData, sectionID, rowID) { 
    if (Platform.OS === 'ios') { 
      ... 
    } 
</pre>
<p>The Android method pushes to an <kbd>index</kbd> instead of a component, and the props passed to it are the exact same ones:</p>
<pre>
    if (Platform.OS === 'android') { 
      this.props.navigator.push({ 
        index: 3, 
        passProps: { 
          ... 
        } 
      }); 
    } 
  } 
} 
</pre>
<p>After this section, we have successfully converted <kbd>Expenses</kbd> into an Android app that looks, feels, and behaves just like one!</p>
<p> </p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Summary</h1>
            </header>

            <article>
                
<p>Congratulations! You've finished the final chapter of <em>React Native by Example</em>. In this chapter, you learned to use more of the React Native library by working on components and APIs that we did not fit into previous apps in the book.</p>
<p>Specifically, you built a playground app where you learned how to use the <kbd>fetch</kbd> API to make requests to external resources for data and gained control of the <kbd>Vibration</kbd> API to control the vibration motor of a user's device.</p>
<p>Afterward, you used the <kbd>Linking</kbd> API to open third-party applications on both iOS and Android, which allowed your app to talk to others. Then, you built a <kbd>Slider</kbd> component that lets users select a value between two predetermined ones.</p>
<p>Finishing the playground app, you created <kbd>Buttons</kbd> to open an <kbd>ActionSheetIOS</kbd> overlay that presents options for your users to interact with and allowed your users to share content from your app using the Share sheet. As a finishing touch, you made use of the <kbd>Geolocation</kbd> API to grab your user's location data.</p>
<p>In the last section, we converted the app to Android. We started by ensuring that the vector icon library was imported via Gradle, swapped out the iOS-specific tabbed navigation for Android's drawer and toolbar combination, replaced <kbd>NavigatorIOS</kbd>-specific logic with <kbd>Navigator</kbd>, replaced the progress indicator with an Android-specific one, and then tweaked the rest of our components to have the look and feel of an Android app.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </body></html>