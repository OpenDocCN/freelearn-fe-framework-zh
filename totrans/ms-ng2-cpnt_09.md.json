["```js\nconst chart = new Chartist.Line('#chart', {\nlabels: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri'],\nseries: [\n    [10, 7, 2, 8, 5]\n  ]\n});\n```", "```js\n<body>\n<div id=\"chart\" class=\"ct-golden-section\"></div>\n</body>\n```", "```js\nconst chart = new Chartist.Line('#chart', {\nlabels: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri'],\nseries: [\n    [10, 7, 2, 8, 5]\n  ]\n}, {\nshowPoint: true,\nshowLine: true\n}, [\n ['screen and (min-width: 400px)', {\nshowPoint: false\n }],\n ['screen and (min-width: 800px)', {\nlineSmooth: false\n }]\n]);\n```", "```js\nimport {Component, ViewEncapsulation, Inject} from '@angular/core';\nimport template from './projects-dashboard.html!text';\nimport {ProjectService} from '../project/project-service/project-service';\n\n@Component({\nselector: 'ngc-projects-dashboard',\nhost: {class: 'projects-dashboard'},\ntemplate,\nencapsulation: ViewEncapsulation.None\n})\nexport class ProjectsDashboard {\nconstructor(@Inject(ProjectService) projectService) {\nthis.projects = projectService.change;\n  }\n}\n```", "```js\n<div class=\"projects-dashboard__l-header\">\n<h2 class=\"projects-dashboard__title\">Dashboard</h2>\n</div>\n<div class=\"projects-dashboard__l-main\">\n<h3 class=\"projects-dashboard__sub-title\">Projects</h3>\n<ul class=\"projects-dashboard__list\">\n<li *ngFor=\"let project of projects | async\">\n<div>{{project.title}}</div>\n<div>{{project.description}}</div>\n</li>\n</ul>\n</div>\n```", "```js\n...\nimport{FormatEffortsPipe} from '../../pipes/format-efforts';\nimport{EffortsTimeline} from '../../efforts/efforts-timeline/efforts-timeline';\nimport template from './project-summary.html!text';\n\n@Component({\nselector: 'ngc-project-summary',\nhost: { class: 'project-summary' },\ntemplate,\ndirectives: [EffortsTimeline],\npipes: [FormatEffortsPipe],\nencapsulation: ViewEncapsulation.None\n})\nexport class ProjectSummary {\n@Input() project;\n\nngOnChanges(changes) {\nif (this.project) {\nthis.totalEfforts = this.project.tasks.reduce(\n (totalEfforts, task) => {\nif (task.efforts) {\ntotalEfforts.estimated += task.efforts.estimated || 0;\ntotalEfforts.effective += task.efforts.effective || 0;\n }\n\nreturntotalEfforts;\n }, {\nestimated: 0,\neffective: 0\n });\n       }\n  }\n}\n```", "```js\n<div class=\"project-summary__title\">{{project?.title}}</div>\n<div class=\"project-summary__description\">\n{{project?.description}}\n</div>\n<div class=\"project-summary__label\">Total Efforts</div>\n<ngc-efforts-timeline [estimated]=\"totalEfforts?.estimated\"\n [effective]=\"totalEfforts?.effective\"\nheight=\"10\"></ngc-efforts-timeline>\n<p>{{totalEfforts | formatEfforts}}</p>\n\n```", "```js\n...\n<li *ngFor=\"let project of projects | async\">\n<ngc-project-summary \n [project]=\"project\"\n [routerLink]=\"['/projects', project._id]\">\n</ngc-project-summary>\n</li>\n...\n```", "```js\n...\nimport {ROUTER_DIRECTIVES} from '@angular/router';\nimport{ProjectSummary} from './project-summary/project-summary';\n...\n@Component({\nselector: 'ngc-projects-dashboard',\ndirectives: [ProjectSummary, ROUTER_DIRECTIVES],\n  ...\n})\nexport class ProjectsDashboard {\n  ...\n}\n```", "```js\nfunction rasterize(timeData, timeFrame, quantity, now, fill = 0) {\n  // Floor to a given time frame\nnow = Math.floor(now / timeFrame) * timeFrame;\nreturntimeData.reduce((out, timeData) => {\n    // Calculating the designated index in the rasterized output\nconst index = Math.ceil((now - timeData.time) / timeFrame);\n    // If the index is larger or equal to the designed rasterized \n    // array length, we can skip the value\nif (index < quantity) {\nout[index] = (out[index] || 0) + timeData.weight;\n }\nreturn out;\n  }, Array.from({length: quantity}).fill(fill)).reverse();\n}\n```", "```js\n<div #chartContainer></div>\n```", "```js\n...\nimport Chartist from 'chartist';\nimport {rasterize, UNITS} from '../../../utilities/time-utilities';\n\n@Component({\nselector: 'ngc-activity-chart',\n  ...\n})\nexport class ActivityChart {\n@Input() activities;\n@ViewChild('chartContainer') chartContainer;\n\nngOnChanges() {\nthis.createOrUpdateChart();\n  }\n\nngAfterViewInit() {\nthis.createOrUpdateChart();\n  }\n  ...\n}\n```", "```js\njspm install chartist\n\n```", "```js\ncreateOrUpdateChart() {\nif (!this.activities || !this.chartContainer) {\nreturn;\n }\n\nconsttimeData = this.activities.map((activity) => {\nreturn {\ntime: activity.time,\nweight: 1\n };\n });\n\nconst series = [\nrasterize(\ntimeData,\nUNITS.find((unit) => unit.short === 'h').milliseconds,\n 24, \n +new Date())\n ];\n\nif (this.chart) {\nthis.chart.update({ series });\n  } else {\nthis.chart = new Chartist.Bar(this.chartContainer.nativeElement, {\nseries\n }, {\nwidth: '100%',\nheight: 60,\naxisY: {\nonlyInteger: true,\nshowGrid: false,\nshowLabel: false,\noffset: 0\n },\naxisX: {\nshowGrid: false,\nshowLabel: false,\noffset: 0\n },\nchartPadding: 0\n });\n  }\n}\n```", "```js\n...\nimport {ActivityService} from '../../activities/activity-service/activity-service';\nimport {ActivityChart} from './activity-chart/activity-chart';\n\n@Component({\nselector: 'ngc-project-summary',\n  ...\ndirectives: [EffortsTimeline, ActivityChart],\n  ...\n})\nexport class ProjectSummary {\n  ...\nconstructor(@Inject(ActivityService) activityService) {\nthis.activityService = activityService;\n }\n\nngOnChanges() {\nif (this.project) {\n      ...\n\nthis.activities = this.activityService.change\n .map((activities) => activities.filter((activity) => activity.subject === this.project._id));\n    }\n  }\n}\n```", "```js\n...\n<div class=\"project-summary__label\">Activity last 24 hours</div>\n<ngc-activity-chart [activities]=\"activities | async\">\n</ngc-activity-chart>\n\n```", "```js\nexport function rasterize(timeData, timeFrame, quantity, \nnow = +new Date(), fill = 0, \naccumulate = false) {\n  // Floor to a given time frame\nnow = Math.floor(now / timeFrame) * timeFrame;\n // Accumulation value used for accumulation mode to keep track \n // of current value\nlet accumulatedValue = 0;\n\n // In accumulation mode we need to be sure that the time data \n // is ordered\nif (accumulate) {\ntimeData = timeData.slice().sort(\n (a, b) => a.time < b.time ? -1 : a.time > b.time ? 1 : 0);\n }\n\nreturn timeData.reduce((rasterized, timeData) => {\n // Increase the accumulated value, in case we need it\naccumulatedValue += timeData.weight;\n    // Calculating the designated index in the rasterized output \n    // array\nconst index = Math.ceil((now - timeData.time) / timeFrame);\n    // If the index is larger or equal to the designed rasterized \n    // array length, we can skip the value\nif (index < quantity) {\nrasterized[index] = accumulate ? \naccumulatedValue :\n (rasterized[index] || 0) + timeData.weight;\n    }\nreturn rasterized;\n  }, Array.from({length: quantity}).fill(fill)).reverse();\n}\n```", "```js\n...\nimport Chartist from 'chartist';\nimport Moment from 'moment';\n\nimport {rasterize} from '../../utilities/time-utilities';\n\n@Component({\nselector: 'ngc-tasks-chart',\n  ...\n})\nexport class TasksChart {\n@Input() projects;\n@ViewChild('chartContainer') chartContainer;\n\nngOnChanges() {\nthis.createOrUpdateChart();\n  }\n\nngAfterViewInit() {\nthis.createOrUpdateChart();\n  }\n     ...\n}\n```", "```js\ncreateOrUpdateChart() {\nif (!this.projects || !this.chartContainer) {\nreturn;\n  }\n\n  // Create a series array that contains one data series for each \n  // project\nconst series = this.projects.map((project) => {\n // First we need to reduces all tasks into one timeData list\nconst timeData = project.tasks.reduce((timeData, task) => {\n // The created time of the task generates a timeData with \n // weight 1\ntimeData.push({\ntime: task.created,\nweight: 1\n });\n // If this task is done, we're also generating a timeData\n // object with weight -1\nif (task.done) {\ntimeData.push({\ntime: task.done,\nweight: -1\n });\n }\nreturn timeData;\n }, []);\n\n    // Using the rasterize function in accumulation mode, we can \n    // create the required data array that represents our series \n    // data\nreturn rasterize(timeData, 600000, 144, +new Date(), \nnull, true);\n });\n\nconst now = +new Date();\n // Creating labels for all the timeframes we're displaying\nconst labels = Array.from({\nlength: 144\n }).map((e, index) => now - index * 600000).reverse();\n\nif (this.chart) {\n    // If we already have a valid chart object, we can simply \n    // update the series data and labels\nthis.chart.update({\nseries,\nlabels\n    });\n  } else {\n    // Creating a new line chart using the chartContainer element \n    // as container\nthis.chart = new Chartist.Line(this.chartContainer.nativeElement, {\nseries,\n      labels\n    }, {\n      width: '100%',\nheight: 300,\n      // Using step interpolation, we can cause the chart to \n      // render in steps instead of directly connected points\nlineSmooth: Chartist.Interpolation.step({\n // The fill holes setting on the interpolation will cause \n // null values to be skipped and makes our line to \n // connect to the next valid value\nfillHoles: true\n }),\naxisY: {\nonlyInteger: true,\nlow: 0,\noffset: 70,\n        // We're using the label interpolation function for \n        // formatting our open tasks count\nlabelInterpolationFnc: (value) => `${value} tasks`\n      },\naxisX: {\n // We're only displaying two x-axis labels and grid lines\nlabelInterpolationFnc: (value, index, array) => index % (144 / 4) === 0 ? Moment(value).calendar() : null\n      }\n    });\n  }\n}\n```", "```js\n<div #chartContainer class=\"tasks-chart__container\"></div>\n```", "```js\n...\nexport class TasksChart {\n  ...\nngOnChanges() {\nif (this.projects) {\n // On changes of the projects input, we need to update the \n // legend\nthis.legend = this.projects.map((project, index) => {\nreturn {\nname: project.title,\nclass: `tasks-chart__series--series-${index + 1}`\n };\n });\n }\n\nthis.createOrUpdateChart();\n  }\n  ...\n}\n```", "```js\n<ul class=\"tasks-chart__series-list\">\n<li *ngFor=\"let series of legend\"\nclass=\"tasks-chart__series {{series.class}}\">\n {{series.name}}\n</li>\n</ul>\n<div #chartContainer class=\"tasks-chart__container\"></div>\n```", "```js\n...\nimport {Toggle} from '../../ui/toggle/toggle';\n\n@Component({\n  ...\ndirectives: [Toggle]\n})\nexport class TasksChart {\n  ...\nconstructor() {\n    // Define the available time frames within the chart provided \n    // to the user for selection\nthis.timeFrames = [{\nname: 'day',\ntimeFrame: 600000,\namount: 144\n }, {\nname: 'week',\ntimeFrame: 3600000,\namount: 168\n }, {\nname: 'year',\ntimeFrame: 86400000,\namount: 360\n }];\n    // From the available time frames, we're generating a list of \n    // names for later use within the Toggle component\nthis.timeFrameNames\n = this.timeFrames.map((timeFrame) => timeFrame.name);\n    // The currently selected timeframe is set to the first \n    // available one\nthis.selectedTimeFrame = this.timeFrames[0];\n  }\n  ...\ncreateOrUpdateChart() {\n    ...\nconst series = this.projects.map((project) => {\n      ...\nreturn rasterize(timeData, \nthis.selectedTimeFrame.timeFrame, \nthis.selectedTimeFrame.amount, \n                       +new Date(), null, true);\n    });\n\nconst now = +new Date();\nconst labels = Array.from({\nlength: this.selectedTimeFrame.amount\n    }).map((e, index) => now - index * this.selectedTimeFrame.timeFrame).reverse();\n  ...\n  }\n  ...\n  // Called from the Toggle component if a new timeframe was \n  // selected\nonSelectedTimeFrameChange(timeFrameName) {\n    // Set the selected time frame to the available timeframe with \n    // the name selected in the Toggle component\nthis.selectedTimeFrame = \nthis.timeFrames.find((timeFrame) =>\ntimeFrame.name === timeFrameName);\nthis.createOrUpdateChart();\n }\n}\n```", "```js\n<ngc-toggle \n [buttonList]=\"timeFrameNames\"\n [selectedButton]=\"selectedTimeFrame.name\"\n (selectedButtonChange)=\"onSelectedTimeFrameChange($event)\">\n</ngc-toggle>\n...\n<div #chartContainer class=\"tasks-chart__container\"></div>\n```", "```js\n...\n<div class=\"projects-dashboard__l-main\">\n<h3 class=\"projects-dashboard__sub-title\">Tasks Overview</h3>\n<div class=\"projects-dashboard__tasks\">\n<ngc-tasks-chart [projects]=\"projects | async\">\n</ngc-tasks-chart>\n</div>\n  ...\n</div>\n```"]