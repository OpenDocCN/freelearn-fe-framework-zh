- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Implementing Role-Based Navigation
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现基于角色的导航
- en: In *Chapter 5*, *Designing Authorization and Authentication*, we covered how
    designing an effective authentication and authorization system is challenging
    but crucial for user satisfaction. Users expect a high standard from web authentication
    systems, and any errors should be clearly communicated. As applications grow,
    their authentication backbone should be easily maintainable and extensible to
    ensure a seamless user experience.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在**第五章**，*设计授权和认证*中，我们讨论了设计一个有效的认证和授权系统虽然具有挑战性但对于用户满意度至关重要。用户对网络认证系统有很高的期望，任何错误都应该明确传达。随着应用程序的增长，它们的认证核心应该易于维护和扩展，以确保无缝的用户体验。
- en: In this chapter, we will discuss the challenges of creating a great auth UX
    and implementing a solid baseline experience. We will continue the router-first
    approach to designing SPAs by implementing the auth experience of LemonMart. In
    *Chapter 4*, *Creating a Router-First Line-of-Business App*, we defined user roles,
    finished our build-out of all major routing, and completed a rough walking-skeleton
    navigation experience of LemonMart. This means we are well prepared to implement
    a role-based conditional navigation experience that captures the nuances of a
    seamless auth experience. We will supplement this with an auth provider using
    the Google Firebase auth service, which you can leverage in real-world applications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论创建出色的认证用户体验和实现坚实基础体验的挑战。我们将继续采用以路由器为起点的方法来设计单页应用（SPAs），通过实现LemonMart的认证体验。在**第四章**，*创建以路由器为起点的业务应用*中，我们定义了用户角色，完成了所有主要路由的构建，并完成了LemonMart的粗略导航体验。这意味着我们已经为实施基于角色的条件导航体验做好了充分准备，该体验能够捕捉无缝认证体验的细微差别。我们将使用Google
    Firebase认证服务作为认证提供者来补充这一点，您可以在实际应用中利用它。
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解以下主题：
- en: Dynamic UI components and navigation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态UI组件和导航
- en: Role-based routing using guards
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用守卫实现基于角色的路由
- en: A Firebase authentication recipe
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Firebase认证配方
- en: Providing a service using a factory
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用工厂提供服务
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The most up-to-date versions of the sample code for the book are on GitHub at
    the following linked repository. The repository contains the final and completed
    state of the code. You can verify your progress at the end of this chapter by
    looking for the end-of-chapter snapshot of code under the `projects` folder.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 书中示例代码的最新版本可在以下链接存储库中找到。该存储库包含代码的最终和完成状态。您可以在本章结束时通过查找`projects`文件夹下的章节结束代码快照来验证您的进度。
- en: 'For *Chapter 6*:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**第六章**：
- en: Clone the repository [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart).
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆[https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)存储库。
- en: Execute `npm install` on the root folder to install dependencies.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根目录中执行`npm install`以安装依赖项。
- en: 'You will continue building on `stage8` from the last chapter:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将继续从上一章的`stage8`构建：
- en: '[PRE0]'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The end state of the project is reflected at:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目的最终状态反映在：
- en: '[PRE1]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the stage name to any `ng` command to act only on that stage:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将舞台名称添加到任何`ng`命令中，使其仅在该阶段生效：
- en: '[PRE2]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that the `dist/stage8` folder at the root of the repository will contain
    the compiled result.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，存储库根目录中的`dist/stage8`文件夹将包含编译结果。
- en: Beware that the source code provided in the book and the version on GitHub are
    likely to be different. The ecosystem around these projects is ever-evolving.
    Between changes to how Angular CLI generates new code, bug fixes, new versions
    of libraries, and side-by-side implementations of multiple techniques, there’s
    a lot of variation that is impossible to account for. If you find errors or have
    questions, please create an issue or submit a pull request on GitHub.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，书中提供的源代码和GitHub上的版本可能不同。这些项目周围的生态系统一直在不断发展。由于Angular CLI生成新代码的方式的变化、错误修复、库的新版本以及多种技术的并行实现，存在许多难以预料的差异。如果您发现错误或有疑问，请在GitHub上创建问题或提交拉取请求。
- en: With the in-memory auth provider in place, let’s take advantage of all the supporting
    code we have written with dynamic UI components and a conditional navigation system
    for a role-based UX.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存中的认证提供者就位后，让我们利用我们为动态UI组件和基于角色的条件导航系统编写的所有支持代码。
- en: Dynamic UI components and navigation
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态UI组件和导航
- en: '`AuthService` provides asynchronous auth status and user information, including
    a user’s name and role. We can use all this information to create a friendly and
    personalized user experience. In this next section, we will implement the `LoginComponent`
    so that users can enter their username and password information and attempt a
    login.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`AuthService` 提供异步的认证状态和用户信息，包括用户的姓名和角色。我们可以使用所有这些信息来创建一个友好且个性化的用户体验。在下一节中，我们将实现
    `LoginComponent`，以便用户可以输入他们的用户名和密码信息并尝试登录。'
- en: Implementing the login component
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现登录组件
- en: The `LoginComponent` leverages the `AuthService` we created and implements validation
    errors using reactive forms.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoginComponent` 利用我们创建的 `AuthService` 并使用响应式表单实现验证错误。'
- en: Remember that in `app.config.ts`, we provided `AuthService` using the class
    `InMemoryAuthService`. So, during runtime, when `AuthService` is injected into
    the `LoginComponent`, the in-memory service will be used.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在 `app.config.ts` 中，我们使用 `InMemoryAuthService` 类提供了 `AuthService`。因此，在运行时，当
    `AuthService` 注入到 `LoginComponent` 中时，将使用内存服务。
- en: The `LoginComponent` should be designed to be rendered independently of any
    other component because, during a routing event, if we discover that the user
    is not properly authenticated or authorized, we will navigate them to this component.
    We can capture this origination URL as a `redirectUrl` so that once a user logs
    in successfully, we can navigate them back to it.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoginComponent` 应该设计成可以独立于任何其他组件渲染，因为在路由事件期间，如果我们发现用户没有正确认证或授权，我们将导航他们到这个组件。我们可以捕获这个原始
    URL 作为 `redirectUrl`，这样一旦用户成功登录，我们就可以将他们导航回该 URL。'
- en: 'Let’s begin:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始：
- en: Create a new component named `login` in the root of your application with inline
    styles.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序的根目录下创建一个名为 `login` 的新组件，并使用内联样式。
- en: 'Let’s start by implementing the routes to the `LoginComponent`:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先实现到 `LoginComponent` 的路由：
- en: '[PRE3]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Remember that the `'**'` path must be the last one defined.
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记住，`'**'` 路径必须是最后一个定义的。
- en: 'Using a similar `login` logic to the one we implemented in `HomeComponent`,
    implement the `LoginComponent` with some styles:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用与我们在 `HomeComponent` 中实现的类似 `login` 逻辑，使用一些样式实现 `LoginComponent`：
- en: Don’t forget to import the requisite dependent modules into your Angular application
    for the upcoming steps. This is intentionally left as an exercise for you to locate
    and import the missing modules.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不要忘记为即将进行的步骤将所需的依赖模块导入到你的 Angular 应用程序中。这有意留作练习，让你找到并导入缺失的模块。
- en: '[PRE4]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We are using the `first` operator to manage the subscription. We ensure that
    we are logged out when `ngOnInit` is called. We build the reactive form in a standard
    manner. Finally, the `login` method calls `this.authService.login` to initiate
    the login process.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用 `first` 操作符来管理订阅。我们确保在调用 `ngOnInit` 时我们已注销。我们以标准方式构建响应式表单。最后，`login` 方法调用
    `this.authService.login` 来启动登录过程。
- en: We listen to the `authStatus$` and `currentUser$` data streams simultaneously
    using `combineLatest`. Every time there’s a change in each stream, our pipe gets
    executed. We filter out unsuccessful login attempts. As the result of a successful
    login attempt, we leverage the router to navigate an authenticated user to their
    profile. In the case of an error sent from the server via the service, we assign
    that error to `loginError`.
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用 `combineLatest` 同时监听 `authStatus$` 和 `currentUser$` 数据流。每当每个流中发生更改时，我们的管道都会执行。我们过滤掉不成功的登录尝试。作为成功登录尝试的结果，我们利用路由将认证用户导航到其个人资料。在服务器通过服务发送错误的情况下，我们将该错误分配给
    `loginError`。
- en: 'Here’s an implementation for a login form to capture and validate a user’s
    `email` and `password` and, if there are any server errors, display them:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是一个登录表单的实现，用于捕获和验证用户的 `email` 和 `password`，并在出现任何服务器错误时显示它们：
- en: Don’t forget to import `ReactiveFormsModule` in `app.modules.ts`.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不要忘记在 `app.modules.ts` 中导入 `ReactiveFormsModule`。
- en: '[PRE5]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The **Login** button is disabled until the email and password meet client site
    validation rules. Additionally, `<mat-form-field>` will only display one `mat-error`
    at a time, unless you create more space for more errors, so be sure to place your
    error conditions in the correct order.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**登录** 按钮在电子邮件和密码满足客户端验证规则之前是禁用的。此外，`<mat-form-field>` 一次只会显示一个 `mat-error`，除非你为更多错误创建更多空间，所以请确保将错误条件按正确顺序放置。'
- en: Once you’re done implementing the `LoginComponent`, you can update the home
    screen to conditionally display or hide the new component we created.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成实现 `LoginComponent` 后，你可以更新主屏幕以有条件地显示或隐藏我们创建的新组件。
- en: 'Update the `HomeComponent` to clean up the code we added previously so that
    we can display the `LoginComponent` when users land on the home page of the app:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`HomeComponent`以清理我们之前添加的代码，以便在用户访问应用程序的主页时显示`LoginComponent`：
- en: '[PRE6]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Your application should look like the following screenshot:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序应类似于以下截图：
- en: '![](img/B20960_06_01.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B20960_06_01.png)'
- en: 'Figure 6.1: LemonMart with login'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：LemonMart登录界面
- en: There’s still some work to be done in terms of implementing and showing/hiding
    the `sidenav` menu, profile, and logout icons, given the user’s authentication
    status.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 根据用户的认证状态，我们还需要做一些工作来实现和显示/隐藏`sidenav`菜单、个人资料和注销图标。
- en: Conditional navigation
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件导航
- en: Conditional navigation is necessary to create a frustration-free UX. By selectively
    showing the elements the user has access to and hiding the ones they don’t, we
    allow the user to confidently navigate through the application.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 条件导航对于创建无烦恼的用户体验是必要的。通过选择性地显示用户可以访问的元素并隐藏他们无法访问的元素，我们使用户能够自信地导航应用程序。
- en: 'Let’s start by hiding the `LoginComponent` after a user logs into the application:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从隐藏用户登录应用程序后的`LoginComponent`开始：
- en: 'On the `HomeComponent`, inject the `AuthService` into the constructor as a
    `public` variable:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`HomeComponent`中，将`AuthService`注入构造函数作为`public`变量：
- en: '[PRE7]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Remove the local variable `displayLogin` because we can directly tap into the
    auth status in the template using the `async` pipe.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除局部变量`displayLogin`，因为我们可以直接在模板中使用`async`管道访问认证状态。
- en: 'Implement a new template using the control flow syntax, along with the `async`
    pipe, as shown here:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用控制流语法和`async`管道，实现一个新的模板，如下所示：
- en: '[PRE8]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Using the `async` pipe avoids errors like `Error: ExpressionChangedAfterItHasBeenCheckedError:
    Expression has changed after it was checked`. Whenever you see this error, stop
    using local variables and, instead, use the `async` pipe. It is the reactive thing
    to do!'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '使用`async`管道可以避免像`Error: ExpressionChangedAfterItHasBeenCheckedError: Expression
    has changed after it was checked`这样的错误。每当您看到这个错误时，请停止使用局部变量，而应使用`async`管道。这是反应式操作的正确做法！'
- en: 'On the `AppComponent`, we will follow a similar pattern by injecting `AuthService`
    as a `public` variable:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AppComponent`中，我们将通过注入`AuthService`作为`public`变量来遵循类似的模式：
- en: '[PRE9]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Update `mat-toolbar` in the template so that we monitor both `authStatus$`
    and `currentUser$` using the `async` pipe:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模板中更新`mat-toolbar`，以便我们使用`async`管道监控`authStatus$`和`currentUser$`：
- en: '[PRE10]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Use `@if` to hide all buttons meant for logged-in users:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`@if`来隐藏所有针对已登录用户的按钮：
- en: '[PRE11]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, when a user is logged out, your toolbar should look clean, with no buttons,
    as shown here:'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，当用户注销时，您的工具栏应该看起来很干净，没有按钮，如图所示：
- en: '![](img/B20960_06_02.png)'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B20960_06_02.png)'
- en: 'Figure 6.2: The LemonMart toolbar before a user logs in'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.2：用户登录前的LemonMart工具栏
- en: 'We can also swap out the generic `account_circle` icon in the `profile` button
    if the user has a picture:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户有图片，我们还可以在`profile`按钮中替换通用的`account_circle`图标：
- en: '[PRE12]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note the use of the `ngSrc` attribute within the `img` tag, which activates
    the `NgOptimizedImage` directive. This directive makes it easy to adopt performance
    best practices for loading images. It has rich features to prioritize or delay
    the loading of certain images to assist in fast **First Contentful Paint** (**FCP**)
    scenarios, allow the use of CDNs, and enforce the use of `width` and `height`
    attributes to prevent layout shifts that can occur when an image loads.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在`img`标签中使用`ngSrc`属性，这会激活`NgOptimizedImage`指令。此指令使得采用性能最佳实践来加载图片变得容易。它具有丰富的功能，可以优先或延迟加载某些图片，以帮助在快速**首次内容绘制**（**FCP**）场景中，允许使用CDN，并强制使用`width`和`height`属性以防止在图片加载时可能发生的布局偏移。
- en: Read more about `NgOptimizedImage` at [https://angular.dev/guide/image-optimization](https://angular.dev/guide/image-optimization).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://angular.dev/guide/image-optimization](https://angular.dev/guide/image-optimization)了解更多关于`NgOptimizedImage`的信息。
- en: We now have a highly functional toolbar that reacts to the auth status of the
    application and can also display information that belongs to the logged-in user.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个高度功能化的工具栏，它能够响应应用程序的认证状态，并且还可以显示属于已登录用户的信息。
- en: Common validations for forms
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表单的常见验证
- en: 'Before we move on, we need to refactor the validations for `LoginComponent`.
    As we implement more forms in *Chapter 8*, *Recipes – Reusability, Forms, and
    Caching*, you will realize that it gets tedious very quickly to repeatedly type
    out form validations in either template or reactive forms. Part of the allure
    of reactive forms is that they are driven by code, so we can easily extract the
    validations to a shared class and unit test and reuse them, as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们需要重构 `LoginComponent` 的验证。随着我们在 *第 8 章* 中实现更多表单，*食谱 - 可重用性、表单和缓存*，你会发现反复在模板或响应式表单中键入表单验证非常快就会变得繁琐。响应式表单的魅力之一是它们由代码驱动，因此我们可以轻松地将验证提取到一个共享类中，并进行单元测试和重用，如下所示：
- en: Create a `validations.ts` file under the `common` folder.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `common` 文件夹下创建一个名为 `validations.ts` 的文件。
- en: 'Implement the email and password validations:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现电子邮件和密码验证：
- en: '[PRE13]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Depending on your password validation needs, you can use a `RegEx` pattern with
    the `Validations.pattern()` function to enforce password complexity rules or leverage
    the OWASP `npm` package, `owasp-password-strength-test`, to enable passphrases,
    as well as set more flexible password requirements. See the link to the OWASP
    authentication general guidelines in the *Further reading* section.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据您的密码验证需求，您可以使用 `Validations.pattern()` 函数配合 `RegEx` 模式来强制执行密码复杂度规则，或者利用 OWASP
    的 `npm` 包 `owasp-password-strength-test` 来启用密码短语，以及设置更灵活的密码要求。请参阅 *进一步阅读* 部分的
    OWASP 认证通用指南链接。
- en: 'Update the `LoginComponent` with the new validations:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用新的验证更新 `LoginComponent`：
- en: '[PRE14]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Next, let’s encapsulate some common UI behavior in an Angular service.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将一些常见的 UI 行为封装到一个 Angular 服务中。
- en: UI service using environment provider
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用环境提供者的 UI 服务
- en: As we start dealing with complicated workflows, such as the auth workflow, it
    is important to be able to programmatically display a toast notification for the
    user. In other cases, we may want to ask for confirmation before executing a destructive
    action with a more intrusive pop-up notification.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始处理复杂的流程，如认证流程时，能够以编程方式向用户显示 toast 通知非常重要。在其他情况下，我们可能希望在执行具有更侵入性弹出通知的破坏性操作之前请求确认。
- en: No matter what component library you use, it gets tedious to recode the same
    boilerplate just to display a quick notification. A UI service can neatly encapsulate
    a default implementation that can be customized.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您使用什么组件库，重复编写相同的样板代码来显示快速通知都会变得很繁琐。UI 服务可以整洁地封装一个默认实现，该实现可以自定义。
- en: In the UI service, we will implement `showToast` and `showDialog` functions
    that can trigger notifications or prompt users for a decision, allowing us to
    use them within the code implementing the business logic.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在 UI 服务中，我们将实现 `showToast` 和 `showDialog` 函数，这些函数可以触发通知或提示用户做出决定，使我们能够在实现业务逻辑的代码中使用它们。
- en: 'Let’s get started:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: Create a new service named `ui` under `common`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `common` 下创建一个名为 `ui` 的新服务。
- en: 'Implement a `showToast` function using `MatSnackBar`:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `MatSnackBar` 实现一个 `showToast` 函数：
- en: Check out the documentation for `MatSnackBar` at [https://material.angular.io](https://material.angular.io).
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 查阅 [https://material.angular.io](https://material.angular.io) 上的 `MatSnackBar`
    文档。
- en: Since this service could be used by any service, component, or feature module,
    we can’t declare this service in a module context. Since our project is a standalone
    project, we instead need to implement an **environment provider** so that we can
    provide the service in the app context defined in `app.config.ts`.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于此服务可以被任何服务、组件或功能模块使用，我们无法在模块上下文中声明此服务。由于我们的项目是一个独立项目，我们因此需要实现一个 **环境提供者**，以便我们可以在
    `app.config.ts` 中定义的应用程序上下文中提供该服务。
- en: '[PRE15]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For a `showDialog` function using `MatDialog`, we must implement a basic `dialog`
    component.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于使用 `MatDialog` 的 `showDialog` 函数，我们必须实现一个基本的 `dialog` 组件。
- en: Check out the documentation for `MatDialog` at [https://material.angular.io](https://material.angular.io).
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 查阅 [https://material.angular.io](https://material.angular.io) 上的 `MatDialog`
    文档。
- en: 'Add a new component named `simpleDialog` under the `common` folder with inline
    templates and styling, skip testing, and a flat folder structure:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `common` 文件夹下添加一个名为 `simpleDialog` 的新组件，包含内联模板和样式，跳过测试，并保持扁平的文件夹结构：
- en: '[PRE16]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`SimpleDialogComponent` should not have an application selector like `selector:
    ''app-simple-dialog''`, since we only plan to use it with `UiService`. If auto-generated,
    remove this property from your component.'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`SimpleDialogComponent` 不应具有 `selector: ''app-simple-dialog''` 这样的应用程序选择器，因为我们只计划与
    `UiService` 一起使用它。如果自动生成，请从您的组件中删除此属性。'
- en: 'Now, implement a `showDialog` function using `MatDialog` to display the `SimpleDialogComponent`:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`MatDialog`实现一个`showDialog`函数来显示`SimpleDialogComponent`：
- en: '[PRE17]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`ShowDialog` returns an `Observable<boolean>`, so you can implement a follow-on
    action depending on what selection the user makes. Clicking on **OK** will return
    `true`, and **Cancel** will return `false`.'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ShowDialog`返回一个`Observable<boolean>`，因此你可以根据用户所做的选择实现后续操作。点击**确定**将返回`true`，点击**取消**将返回`false`。'
- en: In `SimpleDialogComponent`, using `@Inject`, we can use all variables sent by
    `showDialog` to customize the content of the dialog.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`SimpleDialogComponent`中，使用`@Inject`，我们可以使用`showDialog`发送的所有变量来自定义对话框的内容。
- en: 'Add a function named `provideUiService` as an environment provider at the bottom
    of `UiService`:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`UiService`的底部添加一个名为`provideUiService`的环境提供者：
- en: '[PRE18]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`makeEnvironmentProviders` allows us to wrap the dependencies of `Service`
    in an encapsulated object. This way, we don’t expose these dependencies to the
    component using the service. This helps us enforce a decoupled architecture.'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`makeEnvironmentProviders`允许我们将`Service`的依赖项封装在一个对象中。这样，我们不会将这些依赖项暴露给使用服务的组件。这有助于我们强制执行解耦架构。'
- en: 'In `app.config.ts`, add `provideUiService()` to the `providers` array:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app.config.ts`中，将`provideUiService()`添加到`providers`数组中：
- en: '[PRE19]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Update the `login()` function on the `LoginComponent` to display a toast message
    after login:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`LoginComponent`中的`login()`函数，在登录后显示一个吐司消息：
- en: '[PRE20]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, a toast message will appear after a user has logged in, as shown here:'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，当用户登录后，将显示一个吐司消息，如图所示：
- en: '![](img/B20960_06_03.png)'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B20960_06_03.png)'
- en: 'Figure 6.3: Material snackbar'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.3：Material snackBar
- en: The `snackBar` will either take up the full width of the screen or a portion,
    depending on the size of the browser.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`snackBar`将根据浏览器的大小占据整个屏幕宽度或部分宽度。'
- en: 'Experiment with displaying a dialog instead:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试显示一个对话框代替：
- en: '[PRE21]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now that you’ve verified that both `showToast` and `showDialog` work, which
    do you prefer?
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经验证了`showToast`和`showDialog`都工作正常，你更喜欢哪一个？
- en: My rule of thumb between choosing a toast message or a dialog box is that unless
    the user is about to take an irreversible action, you should choose toast messages
    over dialogs so that you don’t interrupt the user’s workflow.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我在选择吐司消息或对话框时的经验法则是，除非用户即将采取不可逆的操作，否则你应该选择吐司消息而不是对话框，这样就不会打断用户的操作流程。
- en: Next, let’s implement an application-wide side navigation experience as an alternative
    to the toolbar-based navigation we already have so that users can switch between
    modules with ease.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们实现一个全局侧导航体验，作为我们已有的基于工具栏导航的替代方案，以便用户可以轻松地在模块之间切换。
- en: Side navigation
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 侧导航
- en: 'To enhance the user experience, it is essential to enable mobile-first workflows
    and offer an intuitive navigation mechanism that allows users to access their
    desired functionality quickly. A side navigation (`SideNav`) bar serves mobile
    and desktop users equally well. On mobile screens, it can be activated by a triple
    dash (hamburger) menu, and on a large screen, it can be locked open. To further
    optimize the experience, we should only show the links a user is authorized to
    view. We can do this by utilizing the `AuthenticationService` based on the user’s
    current role. We will implement the side navigation mock-up as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提升用户体验，启用以移动端优先的工作流程并提供直观的导航机制，使用户能够快速访问所需的功能至关重要。侧导航栏（`SideNav`）对移动端和桌面用户都同样适用。在移动屏幕上，可以通过三横线（汉堡）菜单激活，在大屏幕上可以锁定打开。为了进一步优化体验，我们应该只显示用户有权查看的链接。我们可以通过根据用户的当前角色利用`AuthenticationService`来实现这一点。我们将按照以下方式实现侧导航模拟图：
- en: '![](img/B20960_06_04.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B20960_06_04.png)'
- en: 'Figure 6.4: Side navigation mock-up'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4：侧导航模拟图
- en: 'Let’s implement the code for the side navigation as a separate component so
    that it is easier to maintain:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将侧导航的代码作为一个单独的组件来实现，这样更容易维护：
- en: In the application’s root, create a `NavigationMenu` component with inline templates
    and styles.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序的根目录中创建一个带有内联模板和样式的`NavigationMenu`组件。
- en: The side navigation isn’t technically required until after a user is logged
    in. However, to be able to launch the side navigation menu from the toolbar, we
    need to be able to trigger it from `AppComponent`. Since this component will be
    simple, we will eagerly load it. To do this lazily, Angular does have a Dynamic
    Component Loader pattern, which has a high implementation overhead that will only
    make sense if multi-hundred-KB savings are made.
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 侧导航在用户登录后技术上不是必需的。然而，为了能够从工具栏启动侧导航菜单，我们需要能够从 `AppComponent` 触发它。由于这个组件将是简单的，我们将急切地加载它。为了实现懒加载，Angular
    确实有一个动态组件加载模式，但这将产生较高的实现开销，只有在节省了数百万字节的情况下才有意义。
- en: '`SideNav` will be triggered from the toolbar, and it comes with a `<mat-sidenav-container>`
    parent container that hosts the `SideNav` itself and the application’s content.
    So we must render all application content by placing the `<router-outlet>` inside
    `<mat-sidenav-content>`.'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`SideNav` 将从工具栏触发，并附带一个 `<mat-sidenav-container>` 父容器，该容器本身托管 `SideNav` 以及应用程序的内容。因此，我们必须通过将
    `<router-outlet>` 放置在 `<mat-sidenav-content>` 内部来渲染所有应用程序内容。'
- en: 'In `AppComponent`, define some styles that will ensure that the web application
    will expand to fill the entire page and remain properly scrollable for desktop
    and mobile scenarios:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `AppComponent` 中，定义一些样式以确保网络应用程序将扩展以填充整个页面，并在桌面和移动场景中保持适当的可滚动性：
- en: '[PRE22]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Inject the `MediaObserver` service from Angular Flex Layout in `AppComponent`.
    Also, implement `OnInit`, inject `DestroyRef`, and add a Boolean property named
    `opened`:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `AppComponent` 中注入 Angular Flex Layout 的 `MediaObserver` 服务。同时实现 `OnInit`，注入
    `DestroyRef`，并添加一个名为 `opened` 的布尔属性：
- en: '[PRE23]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: To automatically determine the open/closed status of the side navigation, we
    need to monitor the media observer and the auth status. When the user logs in,
    we would like to show the side navigation and hide it when the user logs out.
    We can do this by assigning `opened` to the value of `authStatus$.isAuthenticated`.
    However, if we only consider `isAuthenticated`, and the user is on a mobile device,
    we will create a less-than-ideal UX. Watching for the media observer’s `mediaValue`,
    we can check whether the screen size is set to extra small or `xs`; if so, we
    can keep the side navigation closed.
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了自动确定侧导航的打开/关闭状态，我们需要监控媒体观察器和认证状态。当用户登录时，我们希望显示侧导航，当用户注销时隐藏它。我们可以通过将 `opened`
    赋值为 `authStatus$.isAuthenticated` 的值来实现这一点。然而，如果我们只考虑 `isAuthenticated`，并且用户在移动设备上，我们将创建一个不太理想的用户体验。通过监控媒体观察器的
    `mediaValue`，我们可以检查屏幕尺寸是否设置为超小或 `xs`；如果是这样，我们可以保持侧导航关闭。
- en: 'Update `ngOnInit` to implement the dynamic side navigation open/closed logic:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `ngOnInit` 以实现动态侧导航的打开/关闭逻辑：
- en: '[PRE24]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: By monitoring the media and `authStatus$` streams, we can consider unauthenticated
    scenarios where the side navigation should not be opened even if there’s enough
    screen space. We also use `takeUntilDestroyed` so that our resources can be cleaned
    up.
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过监控媒体和 `authStatus$` 流，我们可以考虑未经认证的场景，即使有足够的屏幕空间，侧导航也不应该打开。我们还使用 `takeUntilDestroyed`
    以便清理我们的资源。
- en: 'Update the template with a responsive `SideNav` that will slide over the content
    in mobile or push the content aside in desktop scenarios:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新模板，以实现响应式的 `SideNav`，在移动场景中滑过内容，在桌面场景中将内容推到一边：
- en: '[PRE25]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding template leverages the media observer in `@ngbracket/ngx-layout`,
    a community clone of the deprecated Angular Flex Layout library. We injected `ngx-layout`
    earlier for a responsive implementation.
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述模板利用了 `@ngbracket/ngx-layout` 中的媒体观察器，这是已弃用的 Angular Flex Layout 库的社区克隆版。我们之前注入
    `ngx-layout` 是为了实现响应式布局。
- en: You can use the `// prettier-ignore` directive above your template to prevent
    Prettier from breaking up your template into too many lines, which can hurt readability
    in certain conditions like this one.
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以在模板上方使用 `// prettier-ignore` 指令来防止 Prettier 将您的模板拆分成太多行，这在某些条件下（如本例）可能会损害可读性。
- en: We will implement navigational links in `NavigationMenuComponent`. The number
    of links in our application will likely grow over time and be subject to various
    role-based business rules. Therefore, if we were to implement these links in `app.component.ts`,
    we would risk that file getting too large. In addition, we don’t want `app.component.ts`
    to change very often since changes made there can impact the entire application.
    It is a good practice to implement the links in a separate component.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在 `NavigationMenuComponent` 中实现导航链接。随着时间的推移，我们应用程序中的链接数量可能会增加，并受到各种基于角色的业务规则的影响。因此，如果我们将这些链接实现到
    `app.component.ts` 中，我们可能会使该文件变得过大。此外，我们不想让 `app.component.ts` 频繁更改，因为那里的更改可能会影响整个应用程序。将链接实现为单独的组件是一种良好的实践。
- en: 'Implement navigational links in `NavigationMenuComponent`:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `NavigationMenuComponent` 中实现导航链接：
- en: '[PRE26]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`<mat-nav-list>` is functionally equivalent to `<mat-list>`, so you can use
    the documentation of `MatList` for layout purposes. Observe the `subheaders` for
    **Manager**, **Inventory**, and **Clerk** here:'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<mat-nav-list>` 在功能上等同于 `<mat-list>`，因此你可以使用 `MatList` 的文档进行布局。在此观察**经理**、**库存**和**职员**的子标题：'
- en: '![](img/B20960_06_05.png)'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B20960_06_05.png)'
- en: 'Figure 6.5: The Manager dashboard showing Receipt Lookup on a desktop'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.5：桌面上的经理仪表板显示收据查找
- en: '`routerLinkActive="active-link"` highlights the selected **Receipts** route,
    as shown in the preceding screenshot.'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`routerLinkActive="active-link"` 突出了选中的**收据**路由，如图中所示。'
- en: Angular Router keeps track of the state of navigation in the app. Based on which
    link is active, it automatically assigns the appropriate CSS so it can be highlighted
    as the active one.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Angular Router 跟踪应用程序中的导航状态。根据哪个链接是活动的，它会自动分配适当的 CSS，以便将其突出显示为活动链接。
- en: You can read more about the router at [https://angular.dev/guide/routing/router-reference](https://angular.dev/guide/routing/router-reference).
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在 [https://angular.dev/guide/routing/router-reference](https://angular.dev/guide/routing/router-reference)
    上了解更多关于路由的信息。
- en: 'Additionally, you can see the difference in appearance and behavior on mobile
    devices as follows:'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，你可以看到在移动设备上的外观和行为差异如下：
- en: '![](img/B20960_06_06.png)'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B20960_06_06.png)'
- en: 'Figure 6.6: The Manager dashboard showing Receipt Lookup on a mobile'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.6：移动设备上的经理仪表板显示收据查找
- en: Next, let’s implement role-based routing.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们实现基于角色的路由。
- en: Role-based routing using guards
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于角色的路由使用守卫
- en: This is the most elemental and important part of your application. With lazy
    loading, we have ensured that only the bare minimum number of assets will be loaded
    to enable a user to log in.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您应用程序最基本且最重要的部分。通过懒加载，我们确保只加载最基本数量的资源，以便用户能够登录。
- en: Once a user logs in, they should be routed to the appropriate landing screen
    as per their user role, so they’re not guessing how they need to use the application.
    For example, a cashier only needs access to the **point of sale (POS)** screen
    so that they can check out customers. In this case, cashiers can automatically
    be routed to that screen.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户登录，他们应该根据用户角色被路由到适当的登录屏幕，这样他们就不会猜测如何使用应用程序。例如，收银员只需要访问**销售点（POS）**屏幕，以便他们可以结账客户。在这种情况下，收银员可以自动被路由到该屏幕。
- en: 'The following is a mock-up of the POS screen:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的 POS 屏幕是一个原型：
- en: '![](img/B20960_06_07.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B20960_06_07.png)'
- en: 'Figure 6.7: A POS screen mock-up'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7：POS 屏幕原型
- en: Let’s ensure users get routed to the appropriate page after logging in by updating
    the `LoginComponent`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更新 `LoginComponent` 确保用户登录后能够被路由到适当的页面。
- en: 'Update the `login` logic to each route per role in the function named `homeRoutePerRole`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在名为 `homeRoutePerRole` 的函数中更新每个角色的路由 `login` 逻辑：
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Similarly, clerks and managers are routed to their landing screens to access
    the features they need to accomplish their tasks, as shown earlier. Since we have
    implemented a default manager role, the corresponding landing experience will
    be launched automatically.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，职员和经理将被路由到他们的登录屏幕以访问他们完成任务所需的功能，如前所述。由于我们已经实现了默认的管理员角色，相应的登录体验将自动启动。
- en: In the next section, you will learn about route guards, which help check for
    user authentication and can even load requisite data before a form is rendered.
    This is crucial in preventing unintentional access to routes that users should
    not have access to and deterring intentional attempts to breach these restrictions.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将了解路由守卫，它有助于检查用户身份验证，甚至可以在表单渲染之前加载数据。这在防止用户意外访问他们不应访问的路由以及阻止有意尝试突破这些限制方面至关重要。
- en: Route guards
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由守卫
- en: Route guards enable the further decoupling and reuse of logic and greater control
    over the component life cycle.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 路由守卫使逻辑的进一步解耦和重用成为可能，并提供了对组件生命周期的更多控制。
- en: 'Here are the four major guards you will most likely use:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是您最可能使用的四个主要守卫：
- en: '`canActivate` and `canActivateChild`: Used for checking auth access to a route'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`canActivate`和`canActivateChild`：用于检查路由的认证访问'
- en: '`canDeactivate`: Used to ask permission before navigating away from a route'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`canDeactivate`：用于在离开路由之前请求权限'
- en: '`Resolve`: Allows the pre-fetching of data from route parameters'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Resolve`：允许从路由参数中预取数据'
- en: '`CanLoad`: Allows custom logic to execute before loading feature module assets'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CanLoad`：允许在加载功能模块资源之前执行自定义逻辑'
- en: Refer to the following sections to discover how to leverage `canActivate` and
    `canLoad`. The `Resolve` guard will be covered in *Chapter 8*, *Recipes – Reusability,
    Forms, and Caching*.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅以下部分以了解如何利用`canActivate`和`canLoad`。`Resolve`守卫将在*第8章*，*食谱 – 可重用性、表单和缓存*中介绍。
- en: Auth guards
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 身份验证守卫
- en: Auth guards enable a good UX by allowing or disallowing accidental navigation
    to a feature module or a component before the module has loaded, or before any
    improper data requests have been made to the server. For example, when a manager
    logs in, they’re automatically routed to the `/manager/home` path. The browser
    will cache this URL, and it would be completely plausible for a clerk to accidentally
    navigate to the same URL. Angular doesn’t know whether a particular route is accessible
    to a user. Without an `authGuard`, it will happily render the manager’s home page
    and trigger server requests that will fail.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证守卫通过允许或禁止在模块加载之前或在进行任何不适当的数据请求之前意外导航到功能模块或组件，从而提供良好的用户体验。例如，当管理员登录时，他们将被自动路由到`/manager/home`路径。浏览器将缓存此URL，因此文书人员意外导航到相同的URL是完全可能的。Angular不知道特定路由是否对用户可访问。如果没有`authGuard`，它将愉快地渲染管理员的首页并触发将失败的服务器请求。
- en: Regardless of the robustness of your frontend implementation, every REST or
    GraphQL API you implement should also be properly secured with **Role-based Access
    Control** (**RBAC**) on the server side.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 不论您的前端实现多么健壮，您实现的每个REST或GraphQL API都应该在服务器端使用基于角色的访问控制（**RBAC**）进行适当的保护。
- en: 'Let’s update the router so that `ProfileComponent` can’t be activated without
    an authenticated user, and the `ManagerModule` won’t load unless a manager logs
    in using an `authGuard`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新路由器，以便在没有经过身份验证的用户的情况下无法激活`ProfileComponent`，并且`ManagerModule`只有在管理员使用`authGuard`登录时才会加载：
- en: 'Implement a functional `AuthGuard`:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个功能性的`AuthGuard`：
- en: '[PRE28]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note that all dependencies are being injected inline, using the inject function,
    which allows dependency injection outside of just the constructor of an `@Injectable`
    class, in this case, a function.
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，所有依赖项都是通过注入函数内联注入的，这允许在`@Injectable`类的构造函数之外进行依赖注入，在这种情况下是一个函数。
- en: '[PRE29]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Use the `c``anLoad` guard to prevent the loading of a lazily loaded module,
    such as the `manager''s` module:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`canLoad`守卫防止加载懒加载的模块，例如`manager`模块：
- en: '[PRE30]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this instance, when the `ManagerModule` is loaded, `authGuard` will be called
    during the `canLoad` event, and the `checkLogin` function will verify the authentication
    status of the user. If the guard returns `false`, the module will not be loaded.
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，当`ManagerModule`加载时，`authGuard`将在`canLoad`事件期间被调用，`checkLogin`函数将验证用户的身份验证状态。如果守卫返回`false`，则模块将不会加载。
- en: We can go further and provide additional metadata in the route definition, like
    `expectedRole`, which will be passed into the `checkLogin` function by the `canActivate`
    event. If a user is authenticated, but their role doesn’t match `Role.Manager`,
    `authGuard` will again return `false,` and the module will not be loaded.
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以更进一步，在路由定义中提供额外的元数据，如`expectedRole`，它将通过`canActivate`事件传递给`checkLogin`函数。如果用户已通过身份验证，但他们的角色不匹配`Role.Manager`，则`authGuard`将再次返回`false`，模块将不会加载。
- en: 'Use the `canActivate` guard to prevent the activation of individual components,
    such as the user’s `profile`:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`canActivate`守卫防止激活单个组件，例如用户的`profile`：
- en: '[PRE31]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the case of `user-routing.module.ts`, `authGuard` is called during the `canActivate`
    event, and the `checkLogin` function controls where this route can be navigated.
    Since the user is viewing their own profile, there’s no need to check the user’s
    role here.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`user-routing.module.ts`的情况下，`authGuard`在`canActivate`事件期间被调用，`checkLogin`函数控制此路由可以导航的位置。由于用户正在查看自己的个人资料，因此在这里不需要检查用户的角色。
- en: 'Use `canActivate` or `canActivateChild` with an `expectedRole` property to
    prevent the activation of components by other users, such as `ManagerHomeComponent`:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用具有 `expectedRole` 属性的 `canActivate` 或 `canActivateChild` 来防止其他用户激活组件，例如 `ManagerHomeComponent`：
- en: '[PRE32]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Inside `ManagerModule`, we can verify whether the user can access a particular
    route. We can once again define some metadata, like `expectedRole`, so if a role
    doesn’t match `Role.Manager`, `authGuard` will return `false,` and the navigation
    will be prevented.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ManagerModule` 中，我们可以验证用户是否可以访问特定的路由。我们再次定义一些元数据，如 `expectedRole`，如果角色不匹配
    `Role.Manager`，则 `authGuard` 将返回 `false`，从而阻止导航。
- en: Next, we will review some techniques to implement unit tests to isolate dependencies.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将回顾一些实现单元测试以隔离依赖的技术。
- en: Auth service fake and common testing providers
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认证服务模拟和通用测试提供者
- en: We need to provide mocked versions of services like `AuthService` or `UiService`
    using the `commonTestingProviders` function in `common.testing.ts`, using a pattern
    similar to `commonTestingModules`, which was mentioned in *Chapter 4*, *Creating
    a Router-First Line-of-Business App*. This way, we won’t have to mock the same
    objects repeatedly.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用 `common.testing.ts` 中的 `commonTestingProviders` 函数提供 `AuthService` 或
    `UiService` 等服务的模拟版本，使用与在 *第 4 章* 中提到的 `commonTestingModules` 相似的模式。这样，我们就不会反复模拟相同的对象。
- en: 'Let’s create the spy objects using the `autoSpyObj` function from `angular-unit-test-helper`
    and go over some less obvious changes we need to implement to get our tests passing:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用来自 `angular-unit-test-helper` 的 `autoSpyObj` 函数创建间谍对象，并回顾一些不那么明显的更改，以使我们的测试通过：
- en: 'Update `commonTestingProviders` in `common.testing.ts`:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `common.testing.ts` 中更新 `commonTestingProviders`：
- en: '[PRE33]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Observe the test double provided for the `MediaObserver` in `app.component.spec.ts`
    and update it to use `commonTestingModules`:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察在 `app.component.spec.ts` 中为 `MediaObserver` 提供的测试双例，并将其更新为使用 `commonTestingModules`：
- en: '[PRE34]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note how we use the spread syntax, `...`, to expand the `commonTestingModules`
    within another array. This way, when you need to add more items to the array,
    it is convenient to do so by just adding a `common` and another element next to
    it.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们如何使用扩展语法 `...` 在另一个数组中展开 `commonTestingModules`。这样，当你需要向数组中添加更多项时，只需在旁边添加一个
    `common` 和另一个元素就非常方便。
- en: Don’t confuse the spread syntax, `…`, with this book’s use of ellipses, also
    `…`, to represent the existence of surrounding code in the snippets shared.
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不要将扩展语法 `…` 与本书中用于表示代码片段中周围代码存在的省略号 `…` 混淆。
- en: 'Update the `spec` file for `LoginComponent` to leverage `commonTestingModules`
    and `commonTestingProviders`:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `LoginComponent` 的 `spec` 文件以利用 `commonTestingModules` 和 `commonTestingProviders`：
- en: '[PRE35]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Go ahead and apply this technique to all `spec` files that have a dependency
    on `AuthService` and `UiService`.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将此技术应用于所有依赖于 `AuthService` 和 `UiService` 的 `spec` 文件。
- en: 'The notable exception is services, as in `auth.service.spec.ts`, where you
    do *not* want to use a test double. Since `AuthService` is the class under test,
    make sure it is configured as follows:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 值得注意的是，对于服务，例如在 `auth.service.spec.ts` 中，你**不**想使用测试双例。由于 `AuthService` 是被测试的类，请确保它按以下方式配置：
- en: '[PRE36]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Update `ui.service.spec.ts` with similar considerations.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用类似考虑更新 `ui.service.spec.ts`。
- en: Remember, don’t move on until all your tests pass!
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，直到所有测试通过，不要继续前进！
- en: A Firebase authentication recipe
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Firebase 认证配方
- en: 'We can leverage our current authentication setup and integrate it with a real
    authentication service. For this section, you need a free Google and Firebase
    account. Firebase is Google’s comprehensive mobile development platform: [https://firebase.google.com](https://firebase.google.com).
    You can create a free account to host your application and leverage the Firebase
    authentication system.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用当前的认证设置并将其与真实的认证服务集成。对于本节，你需要一个免费的 Google 和 Firebase 账户。Firebase 是 Google
    的综合移动开发平台：[https://firebase.google.com](https://firebase.google.com)。你可以创建一个免费账户来托管你的应用程序并利用
    Firebase 认证系统。
- en: The Firebase console, found at [https://console.firebase.google.com](https://console.firebase.google.com),
    allows you to manage users and send a password reset email without implementing
    a backend for your application. Later, you can leverage Firebase functions to
    implement APIs in a serverless manner.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase 控制台，位于 [https://console.firebase.google.com](https://console.firebase.google.com)，允许你管理用户并发送密码重置电子邮件，而无需为你的应用程序实现后端。稍后，你可以利用
    Firebase 函数以无服务器的方式实现 API。
- en: 'Start by adding your project to Firebase using the Firebase console:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用 Firebase 控制台将你的项目添加到 Firebase：
- en: '![A screenshot of a blue screen  Description automatically generated](img/B20960_06_08.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![蓝色屏幕的截图 自动生成的描述](img/B20960_06_08.png)'
- en: 'Figure 6.8: The Firebase console'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8：Firebase控制台
- en: Click on **Add project**.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加项目**。
- en: Provide your project name.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供您的项目名称。
- en: Enable Google Analytics for your project.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的项目启用Google Analytics。
- en: 'It helps to create a Google Analytics account before attempting this, but it
    should still work. Once your project is created, you should see your project dashboard:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试此操作之前创建一个Google Analytics账户可能会有所帮助，但它仍然应该可以工作。一旦您的项目创建完成，您应该看到您的项目仪表板：
- en: '![A screenshot of a computer  Description automatically generated](img/B20960_06_09.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![计算机的截图 自动生成的描述](img/B20960_06_09.png)'
- en: 'Figure 6.9: The Firebase project overview'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9：Firebase项目概览
- en: On the left-hand side, marked with **1**, you can see a menu of tools and services
    that you can add to your project. At the top, marked with **2**, you can quickly
    jump between your projects. Before doing so, you need to add an application to
    your project.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧，标记为**1**的地方，您可以看到可以添加到项目中的工具和服务菜单。在顶部，标记为**2**的地方，您可以快速在项目之间切换。在这样做之前，您需要向项目中添加一个应用程序。
- en: Create a Firebase application
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建Firebase应用程序
- en: Your project can include multiple distributions of your application, like web,
    iOS, and Android versions. In this chapter, we’re only interested in adding a
    web application.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 您的项目可以包含您应用程序的多个分发版本，如Web、iOS和Android版本。在本章中，我们只对添加Web应用程序感兴趣。
- en: 'Let’s get started:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: On your project dashboard, click on the web application button to add an application,
    which is marked with **3** in *Figure 6.9*.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的项目仪表板上，点击Web应用程序按钮以添加应用程序，这在*图6.9*中标记为**3**。
- en: Provide an application nickname.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供一个应用程序昵称。
- en: Select the option to set up **Firebase Hosting**.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择设置**Firebase托管**的选项。
- en: Continue by hitting the **Register app** button.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**注册应用**按钮继续。
- en: Skip over the **Add Firebase SDK** section.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跳过**添加Firebase SDK**部分。
- en: 'Install the Firebase CLI as instructed:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照说明安装Firebase CLI：
- en: '[PRE37]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Sign in:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录：
- en: '[PRE38]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Make sure your current directory is your project’s root folder.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您的当前目录是您的项目根文件夹。
- en: 'Initialize your project:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化您的项目：
- en: '[PRE39]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Select the **Hosting** option. Don’t worry; you can add more features later.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**托管**选项。不用担心，您稍后可以添加更多功能。
- en: Select the project you created as the default, that is, **lemon-mart-007**.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择您创建的项目作为默认项目，即**lemon-mart-007**。
- en: Say yes to “Detected an existing Angular codebase in the current directory,
    should we use this?”
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回答“检测到当前目录中存在现有的Angular代码库，我们应该使用这个吗？”时说“是”。
- en: 'This will create two new files: `firebase.json` and `.firebaserc`.'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将创建两个新的文件：`firebase.json`和`.firebaserc`。
- en: 'Build your project for production:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为生产构建您的项目：
- en: '[PRE40]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: or
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE41]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, you can deploy your Angular application by executing the following command:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以通过执行以下命令来部署您的Angular应用程序：
- en: '[PRE42]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Your website should be available on a URL similar to [https://lemon-mart-007.firebaseapp.com](https://lemon-mart-007.firebaseapp.com),
    as shown in the terminal.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 您的网站应该在类似[https://lemon-mart-007.firebaseapp.com](https://lemon-mart-007.firebaseapp.com)的URL上可用，如终端中所示。
- en: Add the `.firebase` folder to `.gitignore` so that you don’t check in your cache
    files. The other two files, `firebase.json` and `.firebaserc`, are safe to commit.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 将`.firebase`文件夹添加到`.gitignore`中，这样您就不会提交您的缓存文件。其他两个文件，`firebase.json`和`.firebaserc`，可以安全提交。
- en: Optionally, connect a custom domain name that you own to the account using the
    Firebase console.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，使用Firebase控制台将您拥有的自定义域名连接到账户。
- en: Configuring Firebase authentication
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置Firebase身份验证
- en: Now, let’s configure authentication.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们配置身份验证。
- en: 'In the Firebase console:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在Firebase控制台中：
- en: Expand the **Build** menu and select **Authentication** from the side navigation:![A
    screenshot of a login page  Description automatically generated](img/B20960_06_10.png)
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开**构建**菜单，并从侧边导航中选择**身份验证**：![登录页面的截图 自动生成的描述](img/B20960_06_10.png)
- en: 'Figure 6.10: The Firebase Authentication page'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.10：Firebase身份验证页面
- en: Add a sign-in method; select **Email/Password** as the provider.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个登录方法；选择**电子邮件/密码**作为提供者。
- en: Enable it.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用它。
- en: Do not enable the email link.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要启用电子邮件链接。
- en: Save your configuration.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存您的配置。
- en: 'You can now see the user management console:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以看到用户管理控制台：
- en: '![A screenshot of a computer  Description automatically generated](img/B20960_06_11.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![计算机的截图 自动生成的描述](img/B20960_06_11.png)'
- en: 'Figure 6.11: The Firebase user management console'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11：Firebase用户管理控制台
- en: It is straightforward and intuitive to operate, so I will leave the configuration
    of it as an exercise for you.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 它的操作简单直观，所以我将把它作为练习留给你。
- en: Adding a Firebase auth provider to Angular
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将Firebase认证提供者添加到Angular中
- en: 'Let’s start by adding Angular Fire, the official Firebase library for Angular,
    to our application:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从添加Angular Fire开始，这是Angular的官方Firebase库到我们的应用程序中：
- en: '[PRE43]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Follow Angular Fire’s quick start guide to finish setting up the library with
    your Angular project, which you can find linked from the `README` file on GitHub
    at [https://github.com/angular/angularfire](https://github.com/angular/angularfire).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 按照Angular Fire的快速入门指南完成设置库与您的Angular项目的配置，您可以在GitHub上的`README`文件中找到链接：[https://github.com/angular/angularfire](https://github.com/angular/angularfire)。
- en: Ensure Firebase modules are provided in `app.config.ts` as per the documentation.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保Firebase模块按照文档在`app.config.ts`中提供。
- en: Copy your Firebase `config` object to all of your `environment.ts` files.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的Firebase `config`对象复制到所有的`environment.ts`文件中。
- en: 'Note that any information provided in `environment.ts` is public information.
    So when you place your Firebase API key in this file, it will be publicly available.
    There’s a small chance that another developer could abuse your API key and run
    up your bill. To protect yourself from any such attack, check out this blog post
    by Paachu: *How to secure your Firebase project even when your API key is publicly
    available* at [https://medium.com/@impaachu/how-to-secure-your-firebase-project-even-when-your-api-key-is-publicly-available-a462a2a58843](https://medium.com/@impaachu/how-to-secure-your-firebase-project-even-when-your-api-key-is-publicly-available-a462a2a58843).'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，`environment.ts`中提供的任何信息都是公开信息。因此，当您将Firebase API密钥放在此文件中时，它将是公开可用的。有很小的可能性，其他开发者可能会滥用您的API密钥并增加您的账单。为了保护自己免受此类攻击，请查看Paachu的这篇博客文章：*即使API密钥公开可用，如何保护您的Firebase项目*，链接为[https://medium.com/@impaachu/how-to-secure-your-firebase-project-even-when-your-api-key-is-publicly-available-a462a2a58843](https://medium.com/@impaachu/how-to-secure-your-firebase-project-even-when-your-api-key-is-publicly-available-a462a2a58843)。
- en: 'Create a new `FirebaseAuthService`:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`FirebaseAuthService`：
- en: '[PRE44]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Rename the service file `auth.firebase.service.ts`.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重命名服务文件`auth.firebase.service.ts`。
- en: 'Be sure to remove `{ providedIn: ''root'' }`.'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '一定要删除`{ providedIn: ''root'' }`。'
- en: 'Implement Firebase auth by extending the abstract auth service:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过扩展抽象认证服务实现Firebase认证：
- en: '[PRE45]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As you can see, we only had to implement the delta between our already established
    authentication code and Firebase’s authentication methods. We didn’t have to duplicate
    any code, and we had to transform a Firebase `user` object into our application’s
    internal user object.
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，我们只需实现我们已建立的认证代码与 Firebase 认证方法之间的差异。我们不需要复制任何代码，并且需要将 Firebase 的 `user`
    对象转换为我们应用程序的内部用户对象。
- en: 'Note that in `transformFirebaseUser`, we set `role: Role.None` because Firebase
    authentication doesn’t implement the concept of a user role by default. To make
    the Firebase integration fully functional, you’d have to implement Firebase functions
    and a Firestore database so that you can store rich user profiles and perform
    CRUD operations on it. In this case, after authentication, you’d make another
    call to retrieve the role information. In *Chapter 7*, *Working with REST and
    GraphQL APIs*, we cover how to implement this within your custom API.'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '注意，在`transformFirebaseUser`中，我们设置`role: Role.None`，因为Firebase认证默认不实现用户角色的概念。为了使Firebase集成完全功能，您需要实现Firebase函数和Firestore数据库，以便您可以存储丰富的用户配置文件并在其上执行CRUD操作。在这种情况下，在认证后，您将再次调用以检索角色信息。在*第7章*，*与REST和GraphQL
    API一起工作*中，我们介绍了如何在您的自定义API中实现这一点。'
- en: 'To use Firebase authentication instead of in-memory authentication, update
    the `AuthService` provider in `app.config.ts`:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用Firebase认证而不是内存认证，更新`app.config.ts`中的`AuthService`提供者：
- en: '[PRE46]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Once you’ve completed the steps, add a new user from the Firebase authentication
    console, and you should be able to log in using real authentication.
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成步骤后，从 Firebase 认证控制台添加新用户，您应该能够使用真实认证进行登录。
- en: Always make sure that you’re using HTTPS when transmitting any kind of **Personally
    Identifiable Information** (**PII**) or sensitive information (like passwords)
    over the internet. Otherwise, your information will be logged on to third-party
    servers or captured by bad actors.
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 总是确保在互联网上传输任何类型的**个人身份信息**（**PII**）或敏感信息（如密码）时使用HTTPS。否则，您的信息将被记录在第三方服务器上或被恶意行为者捕获。
- en: 'Once again, be sure to update your unit tests before moving on:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次提醒，在继续之前，务必更新您的单元测试：
- en: '[PRE47]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Stop! Remove the `fake-jwt-sign` package from your project before deploying
    a real authentication method.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 停止！在部署真实认证方法之前，从你的项目中移除`fake-jwt-sign`包。
- en: Congratulations! Your application is integrated with Firebase! Next, let’s cover
    service factories, which can help you to switch the providers of your abstract
    classes dynamically.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你的应用程序已与Firebase集成！接下来，让我们来了解服务工厂，这可以帮助你动态切换抽象类的提供者。
- en: Providing a service using a factory
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用工厂提供服务
- en: You can dynamically choose providers during load time, so instead of changing
    code to switch between authentication methods, you can parametrize environment
    variables so that different kinds of builds can have different authentication
    methods. This is especially useful when writing automated UI tests against your
    application, where real authentication can be difficult, if not impossible, to
    deal with.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在加载时动态选择提供商，因此，你不需要更改代码来在认证方法之间切换，而是可以通过参数化环境变量来让不同类型的构建使用不同的认证方法。这在编写针对你的应用程序的自动化UI测试时特别有用，因为在实际环境中处理真实的认证可能很困难，甚至不可能。
- en: First, we will create an `enum` in `environment.ts` to help define our options,
    and then we will use that `enum` to choose an auth provider during our application’s
    bootstrap process.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在`environment.ts`中创建一个`enum`来帮助我们定义选项，然后我们将使用该`enum`在我们应用程序的引导过程中选择认证提供者。
- en: 'Let’s get started:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: 'Create a new `enum` called `AuthMode`:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`AuthMode`的新`enum`：
- en: '[PRE48]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Add an `authMode` property in `environment.ts`:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`environment.ts`中添加一个`authMode`属性：
- en: '[PRE49]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Create an `authFactory` function in a new file under `auth/auth.factory.ts`:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`auth/auth.factory.ts`的新文件中创建一个`authFactory`函数：
- en: '[PRE50]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Note that the factory must import any dependent service, as shown above.
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，工厂必须导入任何依赖的服务，如上所示。
- en: 'Update the `AuthService` provider in `app.config.ts` to use the factory instead:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`app.config.ts`中的`AuthService`提供者更新为使用工厂：
- en: '[PRE51]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note that you can remove imports of `InMemoryAuthService` and `FirebaseAuthService`
    from `app.config.ts`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你可以从`app.config.ts`中移除`InMemoryAuthService`和`FirebaseAuthService`的导入。
- en: With this configuration in place, whenever you build your application in development
    configuration, you will use the in-memory auth service, and production (prod)
    builds will use the Firebase auth service.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此配置，每次你在开发配置中构建应用程序时，你将使用内存中的认证服务，而生产（prod）构建将使用Firebase认证服务。
- en: Summary
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You should now be familiar with how to create high-quality auth experiences.
    In this chapter, we designed a great conditional navigation experience that you
    can use in your own applications, by copying the base elements to your project
    and implementing your own auth provider. We created a reusable UI service so that
    you can conveniently show alerts in the flow-control logic of your application.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该熟悉了如何创建高质量的认证体验。在本章中，我们设计了一个很好的条件导航体验，你可以通过将基本元素复制到你的项目中并实现自己的认证提供者来在你的应用程序中使用。我们创建了一个可重用的UI服务，这样你就可以方便地在应用程序的流程控制逻辑中显示警告。
- en: We covered route guards to prevent users from stumbling onto screens they are
    not authorized to use, and we reaffirmed the point that the real security of your
    application should be implemented on the server side. You saw how you can use
    a factory to dynamically provide different auth providers for different environments.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了路由守卫，以防止用户误入未经授权使用的屏幕，并重申了你的应用程序的真实安全性应该在服务器端实现的观点。你看到了如何使用工厂在不同的环境中动态提供不同的认证提供者。
- en: Finally, we implemented a real auth provider with Firebase. In *Chapter 7*,
    *Working with REST and GraphQL APIs*, we will review LemonMart Server, a full-stack
    implementation using the minimal MEAN stack with REST and GraphQL APIs. We will
    complete our authentication journey by learning how to implement a custom auth
    provider and implement RBAC for both the REST and GraphQL endpoints.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用Firebase实现了真实的认证提供者。在*第7章*，*与REST和GraphQL API一起工作*中，我们将回顾LemonMart服务器，这是一个使用REST和GraphQL
    API的最小MEAN堆栈的全栈实现。我们将通过学习如何实现自定义认证提供者和为REST和GraphQL端点实现RBAC来完成我们的认证之旅。
- en: Further reading
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Angular @if block*: [https://angular.dev/api/core/@if](https://angular.dev/api/core/@if)'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Angular @if 块*: [https://angular.dev/api/core/@if](https://angular.dev/api/core/@if)'
- en: Angular. *CanActivate*. Angular. Retrieved from [https://angular.io/api/router/CanActivate](https://angular.io/api/router/CanActivate)
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular. *CanActivate*. Angular. 来自 [https://angular.io/api/router/CanActivate](https://angular.io/api/router/CanActivate)
- en: Angular. *CanLoad*. Angular. Retrieved from [https://angular.io/api/router/CanLoad](https://angular.io/api/router/CanLoad)
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular. *CanLoad*. Angular. 从[https://angular.io/api/router/CanLoad](https://angular.io/api/router/CanLoad)检索。
- en: 'Vasconcelos, V. (2019, October 10). *Angular Router Guards: A Complete Guide*.
    Angular University. Retrieved from [https://blog.angular-university.io/angular-router-guards/](https://blog.angular-university.io/angular-router-guards/)'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vasconcelos, V. (2019, October 10). *Angular路由守卫：完整指南*. Angular University.
    从[https://blog.angular-university.io/angular-router-guards/](https://blog.angular-university.io/angular-router-guards/)检索。
- en: AngularFire. *Getting started with AngularFire authentication*. GitHub. Retrieved
    from [https://github.com/angular/angularfire/blob/master/docs/auth/getting-started.md](https://blog.angular-university.io/angular-router-guards/)
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AngularFire. *AngularFire认证入门*. GitHub. 从[https://github.com/angular/angularfire/blob/master/docs/auth/getting-started.md](https://blog.angular-university.io/angular-router-guards/)检索。
- en: Davis, J. (2021, April 12). *Role-Based Authorization in Angular with Firebase*.
    InDepth. Retrieved from [https://indepth.dev/posts/1305/role-based-firebase-authentication-with-angular-8](https://indepth.dev/posts/1305/role-based-firebase-authentication-with-angular-8
    )
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Davis, J. (2021, April 12). *基于角色的Angular与Firebase授权*. InDepth. 从[https://indepth.dev/posts/1305/role-based-firebase-authentication-with-angular-8](https://indepth.dev/posts/1305/role-based-firebase-authentication-with-angular-8)检索。
- en: Questions
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions as best as possible to ensure you’ve understood
    the key concepts from this chapter without googling anything. Do you know if you
    got all the answers right? Visit [https://angularforenterprise.com/self-assessment](https://angularforenterprise.com/self-assessment)
    for more:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能地回答以下问题，以确保你理解了本章的关键概念，而无需使用谷歌搜索。你知道你是否正确回答了所有问题吗？请访问[https://angularforenterprise.com/self-assessment](https://angularforenterprise.com/self-assessment)获取更多信息：
- en: What is the difference between RxJS’s `combineLatest` and `merge` operators?
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RxJS的`combineLatest`和`merge`操作符之间有什么区别？
- en: Explain the difference between `canActivate` and `canLoad` in the context of
    Angular route guards.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Angular路由守卫的上下文中，解释`canActivate`和`canLoad`之间的区别。
- en: How does dynamic UI rendering improve the user experience in role-based navigation
    systems?
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动态UI渲染如何提高基于角色的导航系统中的用户体验？
- en: What are the benefits and potential drawbacks of using a service like Firebase
    Authentication for user management in a web application?
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用类似Firebase Authentication这样的服务进行Web应用程序的用户管理有哪些好处和潜在缺点？
- en: Describe a scenario where a service factory can be particularly useful in an
    Angular application.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述一个场景，其中服务工厂在Angular应用程序中特别有用。
