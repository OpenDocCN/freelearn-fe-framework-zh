- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing User Authentication and Global Notifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we configured the pages, created mocked APIs, and
    made the API calls from our application. However, the application still relies
    on test data when it comes to the authentication of the users in the admin dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will build the application’s authentication system, allowing
    users to authenticate and access protected resources in the admin dashboard. We
    will also be creating a toast notification system to provide feedback to users
    if an action happens that we want to notify them about.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the authentication system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing notifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, we will have learned how to authenticate users in
    our application and also how to handle the global application state with Zustand.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we get started, we need to set up the project. To be able to develop
    the project, you will need the following things installed on your computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Node.js** version 16 or above and **npm** version 8 or above.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are multiple ways to install Node.js and npm. Here is a great article
    that goes into more detail: [https://www.nodejsdesignpatterns.com/blog/5-ways-to-install-node-js](https://www.nodejsdesignpatterns.com/blog/5-ways-to-install-node-js).'
  prefs: []
  type: TYPE_NORMAL
- en: '**VSCode** (optional) is currently the most popular editor/IDE for JavaScript/TypeScript,
    so we will be using it. It is open source, has great integration with TypeScript,
    and you can extend its features via extensions. It can be downloaded from here:
    [https://code.visualstudio.com/](https://code.visualstudio.com/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code files for this chapter can be found here: [https://github.com/PacktPublishing/React-Application-Architecture-for-Production](https://github.com/PacktPublishing/React-Application-Architecture-for-Production).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The repository can be cloned locally with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the repository is cloned, we need to install the application’s dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can provide the environment variables using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the dependencies have been installed, we need to select the right stage
    of the code base that matches this chapter. We can do that by executing the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will prompt us with a list of stages for each chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is the seventh chapter, so you can select `chapter-07-start` if you want
    to follow along, or `chapter-07` to see the final results of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Once the chapter has been selected, all files required to follow along with
    the chapter will appear.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the setup details, check out the `README.md` file.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the authentication system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authentication is the process of identifying who the user on a platform is.
    In our application, we need to identify users when they access the admin dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: Before implementing the system, we should look closely at how it will work.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication system overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to authenticate the users with a token-based authentication system.
    That means the API will expect the user to send their authentication token with
    the request to access protected resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the following diagram and the subsequent steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Authentication system overview ](img/B17297_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – Authentication system overview
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding diagram is explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The user submits the login form with the credentials by creating a request to
    the `/``auth/login` endpoint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the user exists and the credentials are valid, a response with the user data
    returns. In addition to the response data, we are also attaching an `httpOnly`
    cookie, which will be used from this point onward for authenticated requests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Whenever the user authenticates, we will store the user object from the response
    in react-query’s cache and make it available to the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since the authentication is cookie-based with `httpOnly` cookies, we do not
    need to handle the authentication token on the frontend. Any subsequent requests
    will include the token automatically.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Persisting user data on page refreshes will be handled by calling the `/auth/me`
    endpoint, which will fetch the user data and store it in the same react-query
    cache.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To implement this system, we need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Auth features (login, logout, and accessing the authenticated user)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protect resources that require the user to be authenticated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building authentication features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To build the authentication features, we already have the endpoints implemented..
    We created them in [*Chapter 5*](B17297_05.xhtml#_idTextAnchor084), *Mocking the
    API*. Now we need to consume them in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Logging in
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To allow users to log in to the dashboard, we’ll require them to enter their
    email and password and submit the form.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the login feature, we will need to make an API call to the login
    endpoint on the server. Let’s create the `src/features/auth/api/login.ts` file
    and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We are defining the API request and the API mutation hook, allowing us to call
    the API from our application.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we can update the login form to make the API call. Let’s modify `src/features/auth/components/login-form/login-form.tsx`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s import the `useLogin` hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, inside the `LoginForm` component body, we want to initialize the login
    mutation and submit it in the submit handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We should also indicate that the action is being submitted by disabling the
    **Submit** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When the form is submitted, it will call the login endpoint, which will authenticate
    the user if the credentials are valid.
  prefs: []
  type: TYPE_NORMAL
- en: Logging out
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To implement the logout feature, we need to call the logout endpoint, which
    will clear the auth cookie. Let’s create the `src/features/auth/api/logout.ts`
    file and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We are defining the logout API request and the logout mutation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can expose that from the auth feature by re-exporting it from the
    `src/features/auth/index.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to use it when the user clicks the `src/layouts/dashboard-layout.tsx`
    file and import additional dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `Navbar` component, let’s use the `useLogout` hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we redirect the user to the login page when the logout action succeeds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s finally wire the action to the logout button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, when the user clicks the **Log Out** button, the logout endpoint will be
    called, and then the user will be taken to the login page.
  prefs: []
  type: TYPE_NORMAL
- en: Getting an authenticated user
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To get started, let’s create the `src/features/auth/api/get-auth-user.ts` file
    and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This endpoint will return information about the user currently logged in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we want to export it from the `src/features/auth/index.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Back to the `src/layouts/dashboard-layout.tsx` file, we need the user data there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s replace the `useUser` hook from the test data with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Another place where we need the user data is the dashboard jobs page. Let’s
    open `src/pages/dashboard/jobs/index.tsx` and import the `useUser` hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Protecting resources that require the user to be authenticated
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What should happen if an unauthenticated user tries to view a protected resource?
    We want to ensure that any such attempt will redirect the user to the login page.
    To do that, we want to create a component that will wrap protected resources and
    let users view protected content only if they are authenticated.
  prefs: []
  type: TYPE_NORMAL
- en: The `Protected` component will fetch the user from the `/auth/me` endpoint,
    and if the user exists, it will allow the content to be shown. Otherwise, it will
    redirect the user to the login page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The component has already been defined in the `src/features/auth/components/protected/protected.tsx`
    file, but it isn’t doing much right now. Let’s modify the file to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The component accepts children as props, meaning it will wrap nested content
    and decide whether it should be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: We are accessing the user from the same `useUser` hook. Initially, while the
    data is being fetched, the component renders the `Loading` component. Once the
    data is fetched, we check in `useEffect` to see whether the user exists, and if
    it doesn’t, we will redirect to the login page. Otherwise, we can render children
    as usual.
  prefs: []
  type: TYPE_NORMAL
- en: The `Protected` component is meant to be used in the dashboard. Since we already
    have a reusable layout for the dashboard, rather than wrapping every page with
    `Protected`, we can do that only once in the dashboard layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s open `src/layouts/dashboard-layout.tsx` and import the `Protected` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the JSX of the `DashboardLayout` component, let’s wrap everything
    with `Protected` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If you try to visit the `http://localhost:3000/dashboard/jobs` page, you will
    be redirected to the login page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and try to log in with the existing credentials (email: user1@test.com;
    password: password). If everything is successful, you can access the dashboard
    with the data that belongs to the given user organization.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing notifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever something happens in the application, such as a successful form submission
    or a failed API request, we want to notify our users about it.
  prefs: []
  type: TYPE_NORMAL
- en: We will need to create a global store that will keep track of all notifications.
    We want it to be global because we want to show these notifications from anywhere
    in the application.
  prefs: []
  type: TYPE_NORMAL
- en: For handling global states, we will be using Zustand, a state management library
    that is lightweight and very simple to use.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s open the `src/stores/notifications/notifications.ts` file and import
    the dependencies we will use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let’s declare the notification types for the store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The store will keep track of active notifications in an array. To show a notification,
    we need to call the `showNotification` method, and to dismiss it, we will call
    `dismissNotification`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create the store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: To create the store, we use `createStore` from `zustand/vanilla` to make it
    more portable and testable. The function provides us with the `set` and `get`
    helpers, which allow us to modify and access the store, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we created the store using the vanilla approach, we need to make it compatible
    with React. We do that by exposing the store with the `useStore` hook provided
    by Zustand as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: And that’s the notification store. As you can see, it is very simple with minimal
    boilerplate.
  prefs: []
  type: TYPE_NORMAL
- en: Any time we need to access the store inside React components or hooks, we can
    use the `useNotifications` hook. Alternatively, if we want to access the store
    from a plain JavaScript function outside React, we can use `notificationStore`
    directly.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the UI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have the notifications store, we need to build a UI to display those
    notifications when active.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s open the `src/components/notifications/notifications.tsx` file and import
    the required dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let’s create the `Notifications` component, which will display the notifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We are accessing the notifications via the `useNotifications` hook, which provides
    us with access to the store.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we are mapping through the active notifications. We render
    the `NotificationToast` component for each active notification and pass the notification
    object and the dismiss handler as props. Let’s implement it by describing the
    variants and prop types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, implement the `NotificationToast` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the notifications store and the UI created, it is time to integrate
    them into the application.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating and using notifications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To integrate notifications into the application, let’s open the `src/providers/app.tsx`
    file and import the `Notifications` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let’s render the component in `AppProvider`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Perfect! Now we are ready to start showing some notifications.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, we can use the store both in the React world and outside it.
  prefs: []
  type: TYPE_NORMAL
- en: We will need to use it in a React component from the page for creating jobs.
    Any time we create a job successfully, we want to let the user know.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s open the `src/pages/dashboard/jobs/create.tsx` file and import the `useNotifications`
    hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let’s initialize the hook inside the `DashboardCreateJobPage` component
    body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can call `showNotification` in the `onSuccess` handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We are showing a new success notification that will disappear after 5 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see it in action, let’s open [http://localhost:3000/dashboard/jobs/create](http://localhost:3000/dashboard/jobs/create)
    and submit the form. If the submission is successful, we should see something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Notifications in action ](img/B17297_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – Notifications in action
  prefs: []
  type: TYPE_NORMAL
- en: Perfect! Any time a job is created, the user will be notified about it.
  prefs: []
  type: TYPE_NORMAL
- en: Another place that we can utilize notifications is in API error handling. Whenever
    an API error happens, we want to let the user know something went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: We can handle it on the API client level. Since Axios supports interceptors,
    and we already have them configured, we just need to modify the response error
    interceptor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s open `src/lib/api-client.ts` and import the store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the response error interceptor, let’s locate the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll replace it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: To access values and methods on a vanilla Zustand store, we need to call the
    `getState` method.
  prefs: []
  type: TYPE_NORMAL
- en: Any time an error on the API happens, an error notification will be shown to
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth mentioning that Chakra UI has its own toast notification system out
    of the box, which is very simple to use and would fit our needs, but we made our
    own to learn how to manage the global application state in a nice and simple way.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to handle authentication and manage the global
    state of the application.
  prefs: []
  type: TYPE_NORMAL
- en: We started with an overview of the authentication system and how it works. Then,
    we implemented authentication features such as login, logout, and getting the
    authenticated user info. We also built the `Protected` component, which controls
    whether the user is allowed to see a page based on their authentication status.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we built a toast notification system where the user can trigger and display
    notifications from anywhere in the application. The main goal of building it was
    to introduce Zustand, a very simple and easy-to-use state management library for
    handling global application state.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to approach testing the application with
    unit, integration, and end-to-end tests.
  prefs: []
  type: TYPE_NORMAL
