- en: Chapter 3. Saving and Communicating Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章：保存和通信数据
- en: In the previous chapter, we created complex component hierarchies. We created
    a list of pages and a way to edit those pages. Yet we stopped short of saving
    and reading any of that data to some kind of storage.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建了复杂的组件层次结构。我们创建了一个页面列表以及编辑这些页面的方法。然而，我们并没有停止在某种存储中保存和读取这些数据。
- en: We could, for instance, send an edit through an Ajax request to be saved in
    a database server. In fact, that's what often happens in the applications we use
    these days. They always save our interactions, irrespective of whether we expect
    them to or not.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以通过Ajax请求发送一个编辑操作以保存到数据库服务器。实际上，这是我们今天使用的应用程序中经常发生的事情。它们总是保存我们的交互，无论我们是否期望它们这样做。
- en: In this chapter, you will learn about local data stores and communicating with
    them. You'll also learn about event-based architecture and how it promotes the
    unidirectional flow of data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解本地数据存储以及如何与它们通信。您还将了解基于事件的架构以及它是如何促进数据单向流动的。
- en: There are many ways to save data. It's a rich and interesting topic that could
    fill scores of books. I could go so far as to say it is at the core of how businesses
    and applications work.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 存储数据有许多方法。这是一个丰富且有趣的话题，可以填满几十本书。我甚至可以说，它是商业和应用程序工作的核心。
- en: Furthermore, how data is communicated can often be different in a maintainable
    application and an unmaintainable application. It's up to us to figure out elegant
    ways of persisting data so that our applications remain maintainable.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在可维护的应用程序和不可维护的应用程序中，数据通信的方式可能经常不同。取决于我们如何找到优雅的方式来持久化数据，以使我们的应用程序保持可维护性。
- en: We will only explore local storage in this chapter. You'll be able to see your
    stored data beyond page reloads, but nobody else will. You cannot build a practical
    website based on this chapter alone. You will have to wait until we explore React
    on the server.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中只将探索本地存储。您将能够在页面重新加载后看到您存储的数据，但其他人则看不到。仅凭本章内容，您无法构建一个实用的网站。您将不得不等待我们探索服务器上的React。
- en: Validating properties
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证属性
- en: Before we look at storing data, there is another habit I'd like to share with
    you. The components we created in the last chapter work well together, but our
    aim is to make each component self-contained. We want others to be able to reuse
    our components, but they will encounter problems if they don't know which properties
    our components expect.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看存储数据之前，我还有一个习惯想与您分享。我们在上一章中创建的组件可以很好地协同工作，但我们的目标是使每个组件都是自包含的。我们希望其他人能够重用我们的组件，但如果他们不知道我们的组件期望哪些属性，他们将会遇到问题。
- en: 'Consider what would happen if we used `PageAdmin` like this:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑如果我们这样使用`PageAdmin`会发生什么：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Faced with this component, and no documentation, it might be tempting to substitute
    a `Backend` object with some other configuration data. This looks reasonable to
    someone unfamiliar with the component. And, without a careful study of all our
    components, we can't expect others to know what those properties should be.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 面对这样的组件，如果没有文档，可能会诱使我们用一些其他配置数据替换`Backend`对象。这对不熟悉该组件的人来说似乎是合理的。而且，如果我们没有仔细研究我们所有的组件，我们也不能期望其他人知道这些属性应该是什么。
- en: 'We can protect against this situation by adding property validation. Let''s
    add some validation to `PageEd` `itor`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加属性验证来防止这种情况。让我们给`PageEd` `itor`添加一些验证：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We have already imported the `React` object, which exposes a `PropTypes` object.
    This contains some validators. When we specify a few on `PageEditor.propTypes`,
    React checks the types of properties given to the component as it is rendered.
    If we give the incorrect property types or omit required properties, React will
    emit a warning.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经导入了`React`对象，它暴露了一个`PropTypes`对象。这个对象包含一些验证器。当我们对`PageEditor.propTypes`指定一些验证器时，React会在组件渲染时检查属性的类型。如果我们提供了错误的属性类型或省略了必需的属性，React将发出警告。
- en: 'The warnings look like this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 警告看起来是这样的：
- en: '![Validating properties](img/5268_03_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![验证属性](img/5268_03_01.jpg)'
- en: 'There are many types to choose from, the simple ones being the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多类型可供选择，其中简单的一些如下：
- en: '`React.PropTypes.array`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`React.PropTypes.array`'
- en: '`React.PropTypes.bool`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`React.PropTypes.bool`'
- en: '`React.PropTypes.func`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`React.PropTypes.func`'
- en: '`React.PropTypes.number`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`React.PropTypes.number`'
- en: '`React.PropTypes.object`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`React.PropTypes.object`'
- en: '`React.PropTypes.string`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`React.PropTypes.string`'
- en: 'If you need a property to be required (which is likely in most cases) then
    you can add `.isRequired` at the end. Let''s follow this up with validators for
    `PageView`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一个属性是必需的（这在大多数情况下可能是这样），你可以在末尾添加`.isRequired`。让我们用`PageView`的验证器来继续：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This is even simpler, given that `PageView` uses fewer properties than `PageEditor`.
    Also, `Page` is relatively simple:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这甚至更简单，因为`PageView`使用的属性比`PageEditor`少。此外，`Page`相对简单：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We don't need to validate properties passed straight through components. For
    instance, `PageEditor` uses `onUpdate`. It's passed through `Page`, but `Page`
    doesn't use it, `PageEditor` does, so that's where we use validators for it.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要验证直接通过组件传递的属性。例如，`PageEditor`使用`onUpdate`。它通过`Page`传递，但`Page`不使用它，`PageEditor`使用，所以我们就在那里使用验证器。
- en: 'However, what if we want to validate nested structures or more complex types?
    We can try the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们想要验证嵌套结构或更复杂的数据类型呢？我们可以尝试以下方法：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We expect the `backend` property to be an instance of the `Backend` class.
    If it is anything else, we return an `Error` describing why the property is invalid.
    We can also use `shape` to validate nested properties:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望`backend`属性是`Backend`类的一个实例。如果它不是，我们返回一个`Error`来描述为什么属性无效。我们还可以使用`shape`来验证嵌套属性：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The more specific we are about properties, the less chance there is for bad
    properties to break the interface. So, it's good to get in the habit of defining
    them all the time.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对属性越具体，坏属性破坏接口的机会就越小。因此，养成总是定义它们的习惯是好的。
- en: Storing cookies
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储cookies
- en: 'You must have heard of cookies before. They''re a browser-based storage mechanism
    as old as the Internet, and they are often comically described in movies. Here''s
    how we use them:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你一定听说过cookies。它们是一种与互联网一样古老的基于浏览器的存储机制，在电影中经常被滑稽地描述。以下是我们的使用方法：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `document.cookie` parameter works as a temporary string store. You can keep
    adding new strings, where the key and value are separated by `=`, and they will
    be stored beyond a page reload, that is, until you reach the limit of how many
    cookies your browser will store per domain. If you set `document.cookie` multiple
    times, multiple cookies will be set.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`document.cookie`参数作为一个临时的字符串存储。你可以继续添加新的字符串，其中键和值通过`=`分隔，并且它们将在页面重新加载后存储，也就是说，直到你达到浏览器每个域名可以存储的cookies数量限制。如果你多次设置`document.cookie`，将会设置多个cookies。'
- en: 'You can read the cookies back again, with a function like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用这样的函数再次读取cookies：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The whole cookie string is read and split using semicolons. Then, each cookie
    is split into equals, leaving the key and value. These are stored in the local
    `cookies` object. Future requests just read the key from the local object. The
    `cookies` object can be inspected at any point to see the cookies that have been
    set.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 整个cookie字符串通过分号读取并分割。然后，每个cookie被分割成等号，留下键和值。这些被存储在本地`cookies`对象中。未来的请求只需从本地对象中读取键。可以在任何时刻检查`cookies`对象以查看已设置的cookies。
- en: Try [http://browsercookielimits.squawky.net](http://browsercookielimits.squawky.net)
    to test what your browser can handle. I'm running a modern version of Chrome,
    and I can probably store 180 cookies per domain, totaling 4096 bytes. 4096 bytes
    doesn't sound like a lot...
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试[http://browsercookielimits.squawky.net](http://browsercookielimits.squawky.net)来测试你的浏览器可以处理什么。我正在运行一个现代版本的Chrome，我可能每个域名可以存储180个cookies，总共4096字节。4096字节听起来并不多...
- en: Cookies aren't typically used for the kinds of data we want to store. We'll
    have to look elsewhere.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Cookies通常不用于我们想要存储的数据类型。我们不得不在其他地方寻找。
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to learn more about how to use cookies, head over to [https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie](https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要了解更多关于如何使用cookies的信息，请访问[https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie](https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie)。
- en: Using local storage
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用本地存储
- en: 'The next type of storage we will look at is a relatively recent addition to
    the browser toolset. It''s called *local storage*, and it''s been around for a
    while. You can add items to it as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的下一类存储是浏览器工具集的一个相对较新的添加。它被称为*本地存储*，它已经存在了一段时间。你可以按照以下方式向其中添加项：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It''s simpler than cookies to read items from:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 从中读取项比cookies简单：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will persist the data beyond page reloads or the browser closing. You can
    store considerably more data than in cookies (anywhere from 3 MB to 10 MB, by
    default), and the interface is easier to use.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在页面重新加载或浏览器关闭后持久化数据。你可以存储比cookies多得多的数据（默认情况下，从3MB到10MB），并且接口更容易使用。
- en: 'So, how can we use this to store our pages? Let''s abstract local storage a
    bit:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何使用它来存储我们的页面？让我们对本地存储进行一些抽象：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For once, we're exporting an object instead of a class. This object has a couple
    of methods both of which access `window.localStorage`. It's not ideal to reference
    this directly, but if we use this abstraction everywhere else, then I think it's
    OK.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一次，我们导出的是一个对象而不是一个类。这个对象有几个方法，它们都访问`window.localStorage`。直接引用它并不理想，但如果我们在其他地方都使用这种抽象，那么我认为这是可以接受的。
- en: The `get` method pulls a string value out of local storage and parses it as
    a JSON string. If the value parses to any non-false value, we return it, or else
    we return a default value.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`get`方法从本地存储中拉出一个字符串值，并将其解析为JSON字符串。如果该值解析为任何非假值，我们就返回它，否则返回默认值。'
- en: The `set` method encodes a value as JSON, and stores it.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`set`方法将值编码为JSON，并存储它。'
- en: 'Then, we can use the following abstraction in the `Backend` class:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在`Backend`类中使用以下抽象：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We begin with a constructor that fetches any stored pages from `localStorage`.
    We provide a default empty array in case the `pages` key is missing in `localStorage`.
    We store that in `this.pages` so we can fetch and modify it later.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个构造函数开始，它从`localStorage`获取任何存储的页面。我们提供了一个默认的空数组，以防`localStorage`中缺少`pages`键。我们将其存储在`this.pages`中，以便我们稍后可以获取和修改它。
- en: The `getAll` method is much simpler this time around. All it does is returns
    `this.pages`. The `update` and `delete` methods become more interesting though.
    The `update` method uses the `Array.map` method to apply updates to the affected
    page objects. We have to store the updated `pages` array back in local storage
    so that the changes are persisted.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`getAll`方法这次要简单得多。它只是返回`this.pages`。而`update`和`delete`方法则更有趣。`update`方法使用`Array.map`方法来应用对受影响页面对象的更新。我们必须将更新后的`pages`数组存储回本地存储，以便持久化更改。'
- en: 'Similarly, `delete` modifies the `pages` array (this time with a short function
    syntax) and stores the modified array back in local storage. We have to see local
    storage with some initial data. You can do this in a developer console:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`delete`修改了`pages`数组（这次使用简短的功能语法）并将修改后的数组存储回本地存储。我们必须用一些初始数据查看本地存储。你可以在开发者控制台中这样做：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you've made these changes, and you refresh the page, you should see the new
    backend code in action!
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经做了这些更改，并且刷新了页面，你应该能看到新的后端代码在起作用！
- en: Using event emitters
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用事件发射器
- en: Until now, our components have communicated with the backend through method
    calls. That's OK for tiny applications, but when things start to scale, we will
    forget to make some of those method calls.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的组件通过方法调用与后端进行通信。这对小型应用来说是可以的，但当事情开始扩展时，我们可能会忘记做一些方法调用。
- en: 'Look at `onUpdate`, for instance:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 看看`onUpdate`，例如：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Every time we change the state of a page, we have to fetch an updated list of
    pages from the backend. What if multiple components send updates to the backend?
    How will our `PageAdmin` component know when to fetch a new list of pages?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们更改页面的状态时，我们都必须从后端获取更新后的页面列表。如果有多个组件向后端发送更新，我们的`PageAdmin`组件将如何知道何时获取新的页面列表？
- en: We can turn to event-based architecture to solve this problem. We've already
    encountered and used events! Recollect what we did when we created the page edit
    form. There, we connected to input events so we could update pages when input
    values changed.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以转向基于事件的架构来解决这个问题。我们已经遇到过并使用过事件！回想一下我们创建页面编辑表单时做了什么。在那里，我们连接到输入事件，以便在输入值更改时更新页面。
- en: This kind of architecture moves us closer to a unidirectional flow of data.
    We can imagine our entire application like a tree of components, beginning with
    a single root component. When a component needs to update some application's state,
    we don't need to code the state change in relation to where that component is.
    In the past, we may have had to reference specific CSS selectors, or depend on
    the position of sibling elements, when updating state.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构使我们更接近单向数据流。我们可以想象我们的整个应用就像一个组件树，从单个根组件开始。当一个组件需要更新应用的状态时，我们不需要在组件的位置上编码状态更改。在过去，我们可能不得不引用特定的CSS选择器，或者在更新状态时依赖于兄弟元素的定位。
- en: When we start to use events, then any component can trigger a change in the
    application. Also, multiple components can trigger the same kind of change. We'll
    explore this idea in more detail in later chapters.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始使用事件时，任何组件都可以触发应用中的更改。多个组件也可以触发同一种类型的更改。我们将在后面的章节中更详细地探讨这个想法。
- en: 'We can use that same idea to notify components when the data changes. To begin
    with, we need to download an event emitter class:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用同样的想法来通知组件数据发生变化。首先，我们需要下载一个事件发射器类：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, `Backend` can extend this, providing the event functionality that we are
    after:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Backend`可以扩展这个功能，提供我们想要的的事件功能：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As each page is updated or deleted, the backend will emit an event on itself.
    This does nothing until we listen for these events in `PageAdmin`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 随着每个页面的更新或删除，后端将在自身上发出事件。在我们没有在`PageAdmin`中监听这些事件之前，这什么也不做：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now we can remove the numerous calls to `this.setState` and replace them with
    a single event listener in the `constructor`. We are also doing something interesting
    with the `setState` call. It's called *object destructuring*, and it allows `{pages}`
    to become `{"pages":pages}`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以移除对`this.setState`的多次调用，并在`constructor`中使用单个事件监听器来替换它们。我们还在`setState`调用上做了一些有趣的事情。这被称为*对象解构*，它允许`{pages}`变成`{"pages":pages}`。
- en: Now we can begin to use this backend for many different parts of the interface,
    and they'll all have accurate, real-time data. Open the page up in a few different
    windows and watch them all update at once!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始使用这个后端来处理界面的许多不同部分，并且它们都将拥有准确、实时的数据。在几个不同的窗口中打开页面，并观察它们同时更新！
- en: Summary
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at how to protect our components from faulty properties.
    We also saw how easy it was to use cookies, although they are limited for what
    we need. Fortunately, we can use local storage and work it into our existing backend
    and components.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何保护我们的组件免受错误属性的影响。我们还看到使用cookie是多么容易，尽管它们在我们需要的方面有限。幸运的是，我们可以使用本地存储并将其整合到现有的后端和组件中。
- en: Finally, we explored using events to push state changes out to all interested
    components.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探索了使用事件将状态变化推送到所有感兴趣的组件。
- en: In the next chapter, we will start prettying up our components. We'll look at
    ways to style and animate them, bringing our interface to life!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始美化我们的组件。我们将探讨如何对它们进行样式化和动画处理，使我们的界面生动起来！
