<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Implementing Flux Architecture with Vuex</h1>
                </header>
            
            <article>
                
<p class="mce-root">With the Flux concepts clear in our minds, we will now explore the Vuex framework, understand how it works, and, with the help of some examples, see how you can use Vuex inside your Vue applications.</p>
<p class="mce-root">This chapter will cover the following topics:</p>
<ul>
<li>Vuex at a glance</li>
<li>The boilerplate code that will be used to run the examples</li>
<li>The Vue.js reactivity system explained</li>
<li>Understanding the core concepts of Vuex</li>
<li>Enabling strict mode while developing to prevent accidental direct state modifications</li>
<li>Restrictions in form handling when using Vuex</li>
<li>Simple counter: all the Vuex concepts in a very simple example</li>
</ul>
<p><span>The first section </span><span>introduces you to Vuex, focusing on the concepts behind the framework.</span></p>
<p>In the second section, you will be presented with a minimal HTML code to run the examples in this chapter.</p>
<p>In the third section, the Vue reactivity system is examined in detail. This is useful because Vuex exploits this reactivity system to plug itself seemlessly into the Vue application's architecture.</p>
<p>In the fourth section, all Vuex core concepts are thoroughly examined, and, with the help of code snippets, you will see that Vuex is both powerful and simple to use.</p>
<p>The fifth and sixth sections will explain some concepts to keep in mind when using Vuex inside your applications.</p>
<p>Finally, in the last part of this chapter, a simple example will show you most of the Vuex concepts put together in a single HTML file, helping you to understand the whole picture.</p>
<p>Once you have read this chapter, you will have a clear understanding of the Vuex framework, and you will be ready to start using it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>You will be required to have Node.js installed on a system. <span>Finally, to use the Git repository of this book, the user needs to install Git.</span></p>
<p>The code files of this chapter can be found on GitHub:<br/>
<a href="https://github.com/PacktPublishing/Vuex-Quick-Start-Guide/tree/master/chapter-2" target="_blank">https://github.com/PacktPublishing/Vuex-Quick-Start-Guide/tree/master/chapter-2</a></p>
<p>Check out the following video to see the code in action:<br/>
<a href="https://goo.gl/2zXEav" target="_blank">https://goo.gl/2zXEav</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Vuex at a glance</h1>
                </header>
            
            <article>
                
<p>In <a href="7f46d03c-2f58-4773-ad55-985fa1e74b56.xhtml" target="_blank">Chapter 1</a>, <em>Rethinking User Interfaces with Flux, Vue and Vuex</em>, we defined Vuex as <em>a state management pattern + library for Vue.js applications. It serves as a centralized store for all the components in an application, with rules ensuring that the state can only be mutated in a predictable fashion</em>.</p>
<p>Although I think that, having read <a href="7f46d03c-2f58-4773-ad55-985fa1e74b56.xhtml" target="_blank">Chapter 1</a><span>, </span><em>Rethinking User Interfaces with Flux, Vue and</em> definition should sound clear enough to you, it is still a bit obscure. Let's list down the three concepts contained in the preceding sentences:</p>
<ul>
<li>The centralized store</li>
<li>The fact that the state can only be mutated in a predictable way</li>
<li>The Vue reactivity system</li>
</ul>
<p>If you look back to <em>Figure 1.6</em> in <span><em>Flux architecture summarized</em> section in </span><a href="7f46d03c-2f58-4773-ad55-985fa1e74b56.xhtml">Chapter 1</a>, <em>Rethinking User Interfaces with Flux, Vue and Vuex</em>, you will see that the Flux architecture has one dispatcher that dispatches actions to every store. Having only one store means that the dispatcher can be inside the store and you can dispatch actions using the centralized store. In <span>Vuex, we have a single store and its state i</span>s called <strong>single state tree</strong>.</p>
<p>One fundamental rule in Flux and Vuex is that the state can be mutated only because of an action. No component, class, or piece of code should modify the state. Only the code that is linked to an action can actually change the state values. <span>t</span><span>his by using mutations that can only be executed by actions. In this, Vuex differs from Flux. In Flux, actions are just data objects containing the information about the action to be performed. In Vuex, actions can execute code that </span><span>will </span><span>eventually end by committing one or more mutations that will change the state. You will read about mutations and actions later in this chapter.</span></p>
<p>Finally, after an action has been dispatched and the state has been updated, it must notify the views of the application of the fact that has changed. This is done by taking advantage of the Vue reactivity system, which is the topic of the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Boilerplate code for the examples</h1>
                </header>
            
            <article>
                
<p>In the next few pages, you will be provided with some examples. In order to execute these examples, you need to create an HTML file as follows:</p>
<pre>&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;<br/>&lt;head&gt;<br/>  &lt;meta charset="UTF-8"&gt;<br/>  &lt;title&gt;Vuex condensed example&lt;/title&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>&lt;div id="app"&gt;&lt;/div&gt;<br/>&lt;script src="https://unpkg.com/vuex@3.0.1/dist/vuex.min.js"&gt;&lt;/script&gt;<br/>&lt;script src="https://unpkg.com/vue@2.5.13/dist/vue.min.js"&gt;&lt;/script&gt;<br/>&lt;script&gt;<br/>  Vue.use(Vuex);<br/>  <br/> // Add code from examples here<br/>  <br/>&lt;/script&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</pre>
<p>By copying the example code inside the <kbd>&lt;script&gt;</kbd> tag, you can run it and see the results. Almost every example code can be found in the Git repository of this book, under the <kbd>/chapter-2/</kbd> folder.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Vue.js reactivity system explained</h1>
                </header>
            
            <article>
                
<p>One of the powerful features of Vue is its reactivity system. It is an <span>unobtrusive way to detect changes to the components model. A component model is just a plain JavaScript object. When it changes, Vue detects the changes and updates the corresponding views.</span> In Vuex, the single state tree is reactive, like the <kbd>data</kbd> part of a Vue component.</p>
<p>It is important to understand how the reactivity system works to avoid some common mistakes.</p>
<p>There are two ways to detect whether a value inside a JavaScript object has changed:</p>
<ul>
<li>By using the <kbd>Proxy</kbd> feature, which is defined in ECMAScript 2015 (6th Edition, ECMA-262)</li>
<li>By using <kbd>Object.defineProperty</kbd>, which is defined in ECMAScript 2011 (5.1 Edition, ECMA-262)</li>
</ul>
<p>For compatibility reasons, Vue decided to use <span><kbd>Object.defineProperty</kbd>, which means that there are some limitations.</span></p>
<p>When you create a component, Vue will walk through all the properties of the <kbd>data</kbd> part and use <kbd><span>Object.defineProperty</span></kbd> to convert them into <kbd>getter</kbd>/<kbd>setter</kbd> methods. For this reason, Vue can only detect changes to properties that have been defined in the <kbd>data</kbd> part of a component. Let's see an example:</p>
<pre><strong>// Bugged example of counter</strong><br/>Vue.use(Vuex);<br/>const CounterComponent = {<br/>  template: `<br/>  &lt;div&gt;<br/>   &lt;p&gt;I will count from 1 to {{end}}.&lt;/p&gt;<br/>   &lt;button @click="beginCounting"&gt;Begin!&lt;/button&gt;<br/>   &lt;p&gt;{{counter}}&lt;/p&gt;<br/>  &lt;/div&gt;<br/>  `,<br/>  created() {<br/>    this.counter = 0;<br/>  },<br/>  data() {<br/>    return {<br/>      end: 3,<br/>      // you should add counter property here<br/>    };<br/>  },<br/>  methods: {<br/>    beginCounting() {<br/>      this.counter = 0;<br/>      const increaseCounter = () =&gt; {<br/>        this.counter++;<br/>        if (this.counter &lt; this.end) {<br/>          setTimeout(increaseCounter, 1000);<br/>        }<br/>      };<br/>      increaseCounter();<br/>    },<br/>  },<br/>};<br/><br/>new Vue({<br/>  el: '#app',<br/>  template: '&lt;counter&gt;&lt;/counter&gt;',<br/>  components: {<br/>    counter: CounterComponent,<br/>  },<br/>});</pre>
<p>In this example, the <kbd>counter</kbd> <span>property</span> <span>is not declared in the <kbd>data</kbd> section of the component. This prevents Vue from detecting that</span> <kbd>counter</kbd> <span>has been changed, and so, when a user clicks on the button</span> <span class="packt_screen">Begin!</span><span>, they will not see the counter increasing.</span></p>
<p>This can be easily fixed by adding <kbd>counter</kbd> to the <kbd>data</kbd> section and removing it from the <kbd>created()</kbd> method. Look at the following code:</p>
<pre>data() {<br/>  return {<br/>      end: 3,<br/>      <strong>counter: 0</strong><br/>  };<br/>},</pre>
<p>You can find the code for the preceding example in the Git repository of this book, inside the file <kbd>chapter-2/counterTo3/counter.html</kbd>.</p>
<p>When using <kbd>Arrays</kbd>, Vue cannot detect the following changes:</p>
<ul>
<li>Setting a value directly using the index—for example, <kbd>this.items[indexOfItem] = newItem</kbd></li>
<li>Changing the array length—for example, <kbd><span>this.items.length = newLength</span></kbd></li>
</ul>
<p>To avoid these problems, you could either create a new array and assign it to the corresponding data property, or use array methods, such as <kbd>push()</kbd> or <kbd>splice()</kbd>. The following are different ways to update an array observed by Vue:</p>
<pre>// <strong>Replacing the array</strong><br/>this.items[1] = updatedItem;<br/>this.items = this.items.slice();<br/><br/>// <strong>Using splice to change element at index 1</strong><br/>this.items.splice(1,1,updatedItem);<br/><br/>// <strong>Adding a new item</strong><br/>this.items.push(newItem);</pre>
<p>We now understood that every time we properly change something inside a component model or inside the single state tree, Vue detects it and updates the corresponding views accordingly. But what about performance? Isn't it bad to update the views on each modification? In fact, Vue exploits how the JavaScript event loop works to queue all the updates to the views. To understand this concept, let's focus on the following example:</p>
<pre>console.log('start');<br/>Promise.resolve().then(() =&gt; console.log('promise'));<br/>setTimeout(() =&gt; console.log('timeout'), 0);<br/>console.log('end')</pre>
<p>The expected output (which may vary on different browsers) is:</p>
<pre>start<br/>end<br/>promise<br/>timeout</pre>
<p>First, the JavaScript virtual machine executes the synchronous code that prints <kbd>start</kbd> and <kbd>end</kbd>, then it executes all the jobs queued during the execution, printing <kbd>promise</kbd> and <kbd>timeout</kbd>.</p>
<p>Vue uses <kbd>Promise</kbd> if it is available on the user browser; otherwise, it tries to find the best scheduling function, with a fallback to <kbd>setTimeout</kbd> in case no other supported scheduling function has been found. Today, <kbd>Promise</kbd> is supported in almost every browser, mobile, and desktop.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the core concepts of Vuex</h1>
                </header>
            
            <article>
                
<p>It is now time to introduce the Vuex architecture, which consists of five core concepts:</p>
<ul>
<li>Single state tree</li>
<li>Getters</li>
<li>Mutations</li>
<li>Actions</li>
<li>Modules</li>
</ul>
<p>Each concept will be discussed in detail, with some pieces of code that will help to make it clear. Once you have read the following pages, you will have a clear understanding of Vuex architecture.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the Vuex store</h1>
                </header>
            
            <article>
                
<p>Vuex implements Flux stores using a single state tree. In this, it differs from Flux because in Flux there could be more than one store. You may think that a single store/state is not good for modularity. Later, we will see how to split the single state tree into modules.</p>
<p>Having <span>only</span> one store has some benefits:</p>
<ul>
<li>It is available in every component</li>
<li>It is easier to debug since all the application state is there</li>
<li>You can write unobstructive plugins that watch the state and perform an action, such as persisting the state for later retrieval</li>
</ul>
<p>The single state tree contains all the application-level data—it represents the application domain model.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Accessing the single state tree inside components</h1>
                </header>
            
            <article>
                
<p>Let's now see how to use this single state tree inside a <kbd>Vue</kbd> component using an example. Say that we want to show the number of unread messages in a chat session. Somewhere in the application, this number gets updated and the <kbd>NumUnreadMessages</kbd> component shows this number. The following is an example of how the component could be coded:</p>
<pre><span>const </span>NumUnreadMessages = {<br/>  <span>template</span>: <span>`&lt;div&gt;Unread: {{ unreadCounter }}&lt;/div&gt;`</span><span>,<br/></span><span>  </span><span>computed</span>: {<br/>    <span>unreadCounter</span>() {<br/>      <span>return <strong>this</strong></span><strong>.$store.state.unreadCounter</strong><span>;<br/></span><span>    </span>}<span>,<br/></span><span>  </span>}<span>,<br/></span>}<span>;</span></pre>
<p>As you can see, it is straightforward—you just need to use <kbd>this.$store.state</kbd> to access the application state. In order to have <span><kbd>this.$store</kbd> available inside Vue <kbd>components</kbd>, you need to add the store to the <kbd>Vue</kbd> application:</span></p>
<pre>Vue.<span>use</span>(<span>Vuex</span>)<span>;<br/></span><strong>const store = new Vuex.Store({</strong><br/><strong>  state: {</strong><br/><strong>    unreadCounter: 1,<br/>  },<br/>})</strong><span><strong>;</strong><br/></span><span><br/></span><span>const </span>NumUnreadMessages = {<br/>  <span>template</span>: <span>`&lt;div&gt;Unread: {{ unreadCounter }}&lt;/div&gt;`</span><span>,<br/></span><span>  </span><span>computed</span>: {<br/>    <span>unreadCounter</span>() {<br/>      <span>return this</span>.$store.<span>state</span>.<span>unreadCounter</span><span>;<br/></span><span>    </span>}<span>,<br/></span><span>  </span>}<span>,<br/></span>}<span>;<br/></span><span><br/></span><span>const </span>app = <span>new </span>Vue({<br/>  <span>el</span>: <span>'#app'</span><span>,</span><span><br/></span><span>  </span><strong>store</strong><span><strong>,</strong><br/></span><span>  </span><span>components</span>: {NumUnreadMessages}<span>,<br/></span><span>  </span><span>template</span>: <span>`<br/></span><span>  &lt;div class="app"&gt;<br/></span><span>    &lt;num-unread-messages&gt;&lt;/num-unread-messages&gt;<br/></span><span>  &lt;/div&gt;<br/></span><span>`</span><span>,<br/></span>})<span>;</span></pre>
<p><span>You can find the code for this example in the Git repository of this book, inside the file <kbd>chapter-2/unread-messages/unread.html</kbd>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The mapState helper</h1>
                </header>
            
            <article>
                
<p>Creating a computed property every time we want to access the state could be tedious and verbose, especially if a component needs more than one state property.</p>
<p>Fortunately, Vuex provides a handy tool called <kbd>mapState</kbd>:</p>
<pre>const NumUnreadMessages = {<br/>  // ...<br/>  computed: Vuex.mapState({<br/>      unreadCounter: state =&gt; state.unreadCounter,<br/>  })<br/>}</pre>
<p>In the preceding code, the computed property <kbd>unreadCounter</kbd> is mapped to <kbd>this.$store.state.unreadCounter</kbd>. Since <kbd>mapState</kbd> is not well documented, I am going to explain all the ways that you can use it.</p>
<ul>
<li>You can use functions, as shown in the following code:</li>
</ul>
<pre>   // Using functions with mapState<br/>    const NumUnreadMessages = {<br/>     data() {<br/>       return {label:' unread messages'};<br/>     },<br/>     computed: mapState({<br/>       unreadCounter: state =&gt; state.unreadCounter,<br/>       unreadCounterPlusLabel(state) {<br/>         // Here you can use <em>this</em> keyword to access<br/>         // the local state of the component.<br/>         return state.unreadCounter + this.label;<br/>       }<br/>     })<br/>   }</pre>
<p><kbd>unreadCounter</kbd> is an arrow function, whereas <kbd>unreadCounterAlias</kbd> is a normal function. If you want to access the local state of the component, you must use a function and not an arrow function; otherwise, you cannot use the <kbd>this</kbd> keyword inside the arrow function.</p>
<ul>
<li>You can use <kbd>strings</kbd>, as shown in the following code snippet:</li>
</ul>
<pre>   // Using strings<br/>   computed: mapState({<br/>     // Equivalent to unreadCounter: state =&gt; state.unreadCounter<br/>     unreadCounter: 'unreadCounter'<br/>   })</pre>
<ul>
<li>Finally, there is a much more concise way that can be used if the name of the <kbd>state</kbd> property and the name of the <kbd>computed</kbd> property are the same:</li>
</ul>
<pre>   // Using string array<br/>   computed: mapState([<br/>     // map this.unreadCounter to store.state.unreadCounter<br/>     'unreadCounter'<br/>   ])</pre>
<p>In this case, you just need to pass <span>an array of strings</span> <span>to</span> <kbd>mapState</kbd><span>, where each string is the name of the <kbd>state</kbd> property you want to map.</span></p>
<p>You may wonder how you can mix local computed properties with the ones coming from <kbd>mapState.</kbd> Here is an example using the ECMAScript 6 object spread operator:</p>
<pre>  computed: {<br/>   localComputed () {<br/>     // returning localProperty declared into data section<br/>     return this.localProperty;<br/>    },<br/>   <strong>...mapState</strong>([<br/>     'unreadCounter'<br/>   ])<br/> }</pre>
<p>The use of the ES6 object spread operator <kbd>...</kbd> is not yet commonly known among programmers, especially when used with objects. See the following example if this operator sounds new to you:</p>
<pre>  const obj = {b:'b', c:'c'};<br/>  console.log({a:'a', ...obj , d:'d'});<br/>  // prints {a: "a", b: "b", c: "c", d: "d"}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Components' local state</h1>
                </header>
            
            <article>
                
<p>Even if there is a global single state tree, it doesn't mean that components cannot have a local state. What is in the global state is application-wide and should not be polluted with the component's private state. For example, text parts of a component are likely to be used only inside the component, and for this reason, they should not be put into the application state.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Computing a derived state with getters</h1>
                </header>
            
            <article>
                
<p>Sometimes two or more components need a derived state based on the values inside the state. You could compute the derived state inside every component, but this means duplicating code, which is not acceptable. To avoid this, you could create an external function or utility class to compute the derived state, which is better than duplicating the code. However, Vuex provides getter functions so that we can write derived state code inside the application store, avoiding all these unnecessary steps.</p>
<p>For example, say that the app state contains a list of messages, and, when a new message is added to that list, it gets marked as <kbd>unread</kbd>. We could then write a <kbd>getter</kbd> function that returns all the unread messages:</p>
<pre><span>const </span>store = <span>new </span><span>Vuex</span>.Store({<br/>  <span>state</span>: {<br/>    <span>messages</span>: [<br/>      { <span>id</span>: <span>1</span><span>, </span><span>text</span>: <span>'First message'</span><span>, </span><span>read</span>: <span>true </span>}<span>,<br/></span><span>      </span>{ <span>id</span>: <span>2</span><span>, </span><span>text</span>: <span>'Second message'</span><span>, </span><span>read</span>: <span>false </span>}<span>,<br/></span><span>    </span>]<span>,<br/></span><span>  </span>}<span>,<br/></span><span>  </span><strong>getters</strong>: {<br/>    <strong>unreadMessages</strong>(state) {<br/>      <span>return </span>state.<span>messages</span>.<span>filter</span>(message =&gt; !message.<span>read</span>)<span>;<br/></span><span>    </span>}<span>,</span><span><br/></span><span>  </span>}<span>,<br/></span>})<span>;</span></pre>
<p>A <kbd>getter</kbd> function <span>also</span> <span>receives all the <kbd>getters</kbd> as the second argument:</span></p>
<pre>getters: {<br/>  // ...<br/>  <strong>unreadCounter</strong>(state, <strong>getters</strong>) =&gt; {<br/>    return getters.unreadMessages.length;<br/>  }<br/>}</pre>
<p>We can now update the unread messages example using <kbd>getter</kbd> functions:</p>
<pre>Vue.use(Vuex);<br/>const store = new Vuex.Store({<br/>  state: {<br/>    messages: [<br/>      { id: 1, text: 'First message', read: true },<br/>      { id: 2, text: 'Second message', read: false },<br/>    ],<br/>  },<br/>  getters: {<br/>    <strong>unreadMessages</strong>(state) {<br/>      return state.messages.filter(message =&gt; !message.read);<br/>    },<br/>    <strong>unreadCounter</strong>(state, getters) {<br/>      return getters.unreadMessages.length;<br/>    },<br/>  },<br/>});<br/><br/>const NumUnreadMessages = {<br/>  template: `&lt;div&gt;Unread: {{ unreadCounter }}&lt;/div&gt;`,<br/>  computed: {<br/>    unreadCounter() {<br/>      return <strong>this.$store.getters.unreadCounter</strong>;<br/>    },<br/>  },<br/>};<br/><br/>new Vue({<br/>  el: '#app',<br/>  store,<br/>  components: { NumUnreadMessages },<br/>  template: `<br/>  &lt;div class="app"&gt;<br/>    &lt;num-unread-messages&gt;&lt;/num-unread-messages&gt;<br/>  &lt;/div&gt;<br/>`,<br/>});</pre>
<p><span>You will find the code for the following example in the Git repository of this book, inside the file named</span> <kbd>chapter-2/unread-messages/unread-with-getters.html</kbd>.</p>
<p><kbd>Getter</kbd> functions can also receive parameters, making them useful when executing queries regarding the state. To receive parameters, the <kbd>getter</kbd> functions must return a function that receives the parameters. Look at the following example:</p>
<pre>getters: {<br/>  // ...<br/>  getMessageById(state) {<br/>    <strong>return (id) =&gt; {</strong><br/><strong>      return state.messages.find(msg =&gt; msg.id === id);</strong><br/><strong>    }</strong><br/>  }<br/>}</pre>
<p>As for the state, there is a <kbd>mapState</kbd> helper. For getters, there is a <kbd>mapGetters</kbd> helper.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The mapGetters helper</h1>
                </header>
            
            <article>
                
<p>The <kbd>mapGetters</kbd> helper simply maps store <kbd>getters</kbd> to local computed properties. :</p>
<pre>const NumUnreadMessages = {<br/>  template: `&lt;div&gt;Unread: {{ unreadCounter }}&lt;/div&gt;`,<br/>  computed: <strong>Vuex.mapGetters(['unreadCounter'])</strong>,<br/>};</pre>
<p>As for <kbd>mapState</kbd>, we can use an array to list all the <kbd>getters</kbd> properties we want to map to a corresponding computed property.</p>
<p>If the name of the computed property is different from the <kbd>getter</kbd> name, you can use an object instead of an array:</p>
<pre>...mapGetters({<br/>  // map `this.numUnread` to `store.getters.unreadCounter`<br/>  numUnread: 'unreadCounter'</pre>
<p>You will find the code for this updated example of unread messages in the Git repository of this book, inside the file named <kbd>chapter-2/unread-messages/unread-with-getters-and-mapgetters.html</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Changing the application state with mutations</h1>
                </header>
            
            <article>
                
<p>Until now, we have only seen how the app state can be retrieved. It is time to introduce mutations. Using mutations is the only way you can change the state. If you remember, Flux only <span>allows</span> <span>actions to mutate the state. In Vuex, actions are split into actions and mutations. We will introduce actions later—here, we will focus on mutations and how we can</span> <span>change</span> <span>the state using Vuex.</span></p>
<p>In order to change the state, you need to commit a mutation. A mutation is similar to an event: you declare the mutation, which is a kind of event type, and link the mutation to a piece of code, which is like an event handler. From this point of view, Vuex can be seen as an evolution of the <kbd>EventBus</kbd> pattern, which was discussed in <a href="7f46d03c-2f58-4773-ad55-985fa1e74b56.xhtml" target="_blank">Chapter 1</a>, <em>Rethinking User Interfaces with Flux, Vue and Vuex</em>, as a possible solution to let MVC components communicate with each other.</p>
<p>Mutations are declared in the <kbd>mutations</kbd> section of the <kbd>config</kbd> object provided to the <kbd>Vuex.Store(...)</kbd> function:</p>
<pre>const store = new Vuex.Store({<br/>  state: {<br/>    messages: []<br/>  },<br/>  <strong>mutations</strong>: {<br/>    addNewMessage (state, msgText) {<br/>      // mutating the state<br/>      state.messages.push({text: msgText, read: false});<br/>    }<br/>  }<br/>})</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Commiting a mutation</h1>
                </header>
            
            <article>
                
<p class="mce-root">You cannot call a mutation handler directly. Instead, you can commit the mutation using <kbd>store.commit(mutationName, payload)</kbd>. For example:</p>
<pre class="mce-root">store.commit('addNewMessage', 'A message');</pre>
<p class="mce-root">This will add a message to the <kbd>messages</kbd> array of the application state.</p>
<p>The <kbd>payload</kbd> parameter can be a primitive type or an object with all the properties that the mutation needs.</p>
<p>You can also use an object-style commit, as shown in the following example:</p>
<pre>store.commit({<br/>  type: 'addNewMessage',<br/>  content: 'A message'<br/>});</pre>
<p>Since with a mutation you change the state that is reactive, it is recommended that you follow some best practices:</p>
<ul>
<li>Initialize all the properties of the state so that they represent the initial state of the application</li>
<li>Ensure that when you modify or add a new property to the state, <kbd>Vue</kbd> will detect the modification, as discussed in the reactivity section of this chapter</li>
</ul>
<p>The following is a complete example where a user can add a message and see the message list:</p>
<pre>Vue.<span>use</span>(<span>Vuex</span>)<span>;<br/></span><span>const </span>store = <span>new </span><span>Vuex</span>.Store({<br/>  <span>state</span>: {<br/>    <span>messages</span>: []<span>,<br/></span><span>  </span>}<span>,<br/></span><span>  </span><span>mutations</span>: {<br/>    <strong>addNewMessage</strong>(state<span>, </span>msgText) {<br/>      state.<span>messages</span>.<span>push</span>({ <span>text</span>: msgText<span>, </span><span>read</span>: <span>false </span>})<span>;<br/></span><span>    </span>}<span>,<br/></span><span>  </span>}<span>,<br/></span>})<span>;<br/></span><span><br/></span><span>const </span>MessageList = {<br/>  <span>template</span>: <span>`&lt;ul&gt;<br/></span><span>      &lt;li v-for="message in messages"&gt;{{message.text}}&lt;/li&gt;<br/></span><span>    &lt;/ul&gt;<br/></span><span>  `</span><span>,<br/></span><span>  </span><span>computed</span>: <span>Vuex</span>.mapState([<span>'messages'</span>])<span>,<br/></span>}<span>;<br/></span><span><br/></span><span>const </span>MessageEditor = {<br/>  <span>template</span>: <span>`&lt;div&gt;<br/></span><span>    &lt;input type="text" v-model="message"&gt;<br/></span><span>    &lt;button @click="addMessage"&gt;Add message&lt;/button&gt;<br/></span><span>  &lt;/div&gt;<br/></span><span>  `</span><span>,<br/></span><span>  </span><span>data</span>() {<br/>    <span>return </span>{<br/>      <span>message</span>: <span>''</span><span>,<br/></span><span>    </span>}<span>;<br/></span><span>  </span>}<span>,<br/></span><span>  </span><span>methods</span>: {<br/>    addMessage() {<br/>      <strong>this.$store.commit('addNewMessage', this.message)</strong><span><strong>;</strong><br/></span><span>    </span>}<span>,<br/></span><span>  </span>}<span>,<br/></span>}<span>;<br/></span><span><br/></span><span>new </span>Vue({<br/>  <span>el</span>: <span>'#app'</span><span>,</span><span><br/></span><span>  </span>store<span>,<br/></span><span>  </span><span>components</span>: { MessageList<span>, </span>MessageEditor }<span>,<br/></span><span>  </span><span>template</span>: <span>`<br/></span><span>  &lt;div class="app"&gt;<br/></span><span>    &lt;message-editor&gt;&lt;/message-editor&gt;<br/></span><span>    &lt;message-list&gt;&lt;/message-list&gt;<br/></span><span>  &lt;/div&gt;<br/></span><span>`</span><span>,<br/></span>})<span>;</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enumerating mutation types using constant strings</h1>
                </header>
            
            <article>
                
<p>Every time you want to commit a mutation, you need to write the type of mutation you want to perform. Scattering strings among the code is considered bad practice and has the following drawbacks:</p>
<ul>
<li>It is error-prone: typos or wrong casing could occur when typing the mutation type</li>
<li>It is hard to rename a type, since you have to search for all the occurrences <span>of that string</span> in the code</li>
<li>It is not clear which module that mutation comes from</li>
</ul>
<p>For these reasons, it is better to use constant strings to define all the mutation types. Using uppercase will prevent wrong casing, and using constants variables will allow most editors to highlight occurrences. In addition, editors usually provide a way to rename variables, such as string constants, making it easy to rename a mutation.</p>
<p>Mutation types should be defined inside a file with all the possible mutations of the application, or of the module if the application is split into modules. In this way, it is easier to understand all the changes the application state can be subjected to. In fact, if you remember, Vuex promises that the state will be changed in a predictable fashion. Say that a new programmer participates in your project. You could sit next to them and start explaining what the application does. You will soon find out that they can understand what happens when a user performs an action without your help. In fact, they just need to follow the flow from the action fired inside a <kbd>Vue</kbd> component to the corresponding state mutation.</p>
<p>The following is an example illustrating how to use constant mutation types:</p>
<pre>// mutation-types.js<br/>export const ADD_NEW_MESSAGE = 'addNewMessage';<br/><br/>// store.js<br/>import Vuex from 'vuex';<br/>import { ADD_NEW_MESSAGE } from './mutation-types';<br/><br/>const store = new Vuex.Store({<br/>  state: { ... },<br/>  mutations: {<br/>    [ADD_NEW_MESSAGE] (state, msgText) {<br/>      state.messages.push({text: msgText, read: false});<br/>    }<br/>  }<br/>});</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mutations must be synchronous</h1>
                </header>
            
            <article>
                
<p>One important rule when using Vuex is that <em>mutation handler functions must be synchronous</em>. Unfortunately, this cannot be enforced through JavaScript language, so Vuex cannot ensure that you follow this rule. This means that this rule is a best practice that must be followed when coding your application.</p>
<p>The following is an example that shows this rule being violated:</p>
<pre>// Violation of rule "mutations handlers must be synchronous"<br/>mutations: {<br/>  updateBookDetailsById(state, partialBookData) {<br/>    state.currentBook = partialBookData;<br/>    const {bookId} = partialBookData;<br/>    api.getBookDetailsById(bookId, (bookDetails) =&gt; {<br/>      state.currentBook = bookDetails;<br/>    });<br/>  }<br/>}</pre>
<p>In this example, first <kbd>state.currentBook</kbd> is set with some partial data from the book, then, when the server provides the requested book details, the <span><kbd>state.currentBook</kbd></span> <span>state</span> <span>gets updated with all the book details.</span></p>
<p><span>Showing book data as soon as possible is a good idea. We don't want the user to see a blank page until the server provides all the requested information. But asynchronicity must be dealt with somewhere else—more precisely, inside an <kbd>action</kbd>.</span></p>
<p>But <span>what could happen</span> <span>in the preceding example? In the best case scenario, the book's partial data is displayed and a few moments later, all the book details are shown. But</span> <kbd>api.getBookDetailsById(...)</kbd> <span>could take longer than expected, or it can even fail. In these last cases, the result will be an incoherent application state. What if</span> <kbd>state.currentBook</kbd> <span>gets modified by the user before the server provides the book details?</span></p>
<p>To avoid these problems, when a mutation is committed, the application state must move from a well-defined state to another well-defined state in a synchronous manner.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The mapMutations helper</h1>
                </header>
            
            <article>
                
<p><span>As for the state and getters, there is a helper to save us some keystrokes.</span></p>
<p>The example, where a user can add a message, can be refactored using the <kbd>mapMutations</kbd> helper, as follows:</p>
<pre>const MessageEditor = {<br/>  template: `&lt;div&gt;<br/>    &lt;input type="text" v-model="message"&gt;<br/>    &lt;button @click="<strong>addNewMessage(message)</strong>"&gt;Add message&lt;/button&gt;<br/>  &lt;/div&gt;<br/>  `,<br/>  data() {<br/>    return {<br/>      message: '',<br/>    };<br/>  },<br/>  methods: <strong>Vuex.mapMutations</strong>([<br/>    // Payload is also supported<br/>    'addNewMessage'<br/>  ]),<br/>};</pre>
<p>In this case, <kbd>mapMutations(...)</kbd> <span>creates an <kbd>addNewMessage</kbd></span> <span>method</span> <span>that calls</span> <kbd>this.$store.commit(ADD_NEW_MESSAGE, payload)</kbd> <span>when executed.</span></p>
<p>You will find the code for the preceding example with and without <kbd>mapMutations</kbd> <span>inside the</span> <span><kbd>chapter-2/add-message</kbd></span> <span>folder</span><span>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Committing mutations within actions</h1>
                </header>
            
            <article>
                
<p><span>As introduced earlier, Vuex splits Flux actions into mutations and actions. Mutations must be synchronous, so actions are where asynchronous code can be written. The idea is that mutations are well-defined state modifications and actions commit mutations to change the application state. For example, an action could request</span> <span>some data</span> <span>from the server, and when the server responds, commit a mutation using the</span> <span>data it</span> <span>just obtained.</span></p>
<p>In short, actions can change the state by committing mutations and can perform asynchronous operations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Action declaration</h1>
                </header>
            
            <article>
                
<p>Let's see how actions are declared inside a <kbd>Vuex</kbd> store:</p>
<pre><span>const </span>store = <span>new </span><span>Vuex</span>.Store({<br/>  <span>state</span>: {<br/>    <span>messages</span>: []<span>,<br/></span><span>  </span>}<span>,<br/></span><span>  </span><span>mutations</span>: {<br/>    <span>addNewMessage</span>(state<span>, </span>msgText) {<br/>      state.<span>messages</span>.<span>push</span>({ <span>text</span>: msgText<span>, </span><span>read</span>: <span>false </span>})<span>;<br/></span><span>    </span>}<span>,<br/></span><span>  </span>}<span>,<br/></span><span>  </span><strong>actions</strong>: {<br/>    <span>addMessage</span>(context<span>, </span>msgText) {<br/>      API.<span>addMessage</span>(msgText).<span>then</span>(() =&gt; {<br/>        <strong>context.commit('addNewMessage', msgText)</strong><span><strong>;</strong><br/></span><span>      </span>})<span>;<br/></span><span>    </span>}<span>,<br/></span><span>  </span>}<span>,<br/></span>})<span>;</span></pre>
<p>In a similar way as that used for mutations, to declare an action, you write the action method inside the <kbd>actions</kbd> section of the <kbd>config</kbd> object provided to the <kbd>Vuex</kbd> store.</p>
<p>The action receives a <kbd>context</kbd> object and the action payload. The <kbd>context</kbd> object contains a <kbd>commit(...)</kbd> method and the <kbd>state</kbd> <span>property,</span> <span>which is the application state.</span></p>
<p>In the preceding example, the <kbd>addMessage(...)</kbd> action sends the message text to a hypothetical server and, after the server response, it commits the corresponding mutation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dispatching an action</h1>
                </header>
            
            <article>
                
<p>If you remember, Flux has a single dispatcher that dispatches actions to every store. I<span>t is the same i</span><span>n Vuex, except that there is only a single store, which is also a dispatcher. This means that actions can be dispatched using the store, as shown in the code below:</span></p>
<pre>store.dispatch('addNewMessage', 'A message');</pre>
<p>In the following code, I updated the <kbd>add message</kbd> example to use the <kbd>addMessage</kbd> action instead of <span>directly</span> <span>using the</span> <kbd>addNewMessage</kbd> <span>mutation:</span></p>
<pre>Vue.use(Vuex);<br/><br/>// Server API mock<br/>const API = {<br/>  addMessage: () =&gt; Promise.resolve()<br/>};<br/><br/>const store = new Vuex.Store({<br/>  state: {<br/>    messages: [],<br/>  },<br/>  mutations: {<br/>    addNewMessage(state, msgText) {<br/>      state.messages.push({ text: msgText, read: false });<br/>    },<br/>  },<br/>  <strong>actions</strong>: {<br/>    <strong>addMessage(context, msgText)</strong> {<br/>      API.addMessage(msgText).then(() =&gt; {<br/>        context.commit('addNewMessage', msgText);<br/>      });<br/>    },<br/>  },<br/>});<br/><br/>const MessageList = {<br/> // ...<br/>};<br/><br/>const MessageEditor = {<br/>  template: `&lt;div&gt;<br/>    &lt;input type="text" v-model="message"&gt;<br/>    &lt;button @click="addMessage"&gt;Add message&lt;/button&gt;<br/>  &lt;/div&gt;<br/>  `,<br/>  data() {<br/>    return {<br/>      message: '',<br/>    };<br/>  },<br/>  methods: {<br/>   <strong> addMessage() {</strong><br/><strong>      this.$store.dispatch('addMessage', this.message);</strong><br/><strong>    },</strong><br/>  },<br/>};<br/><br/>new Vue({<br/> // ...<br/>});</pre>
<p>You are <span>probably</span> now thinking that there must be some helper to dispatch actions... in fact, there is!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The mapActions helper</h1>
                </header>
            
            <article>
                
<p>Similar to the other helpers, the <kbd>mapActions</kbd> helper can be used inside the <kbd>methods</kbd> section of a <kbd>Vue</kbd> component. The syntax is the same as that of the other helpers:</p>
<pre>const MessageEditor = {<br/>  template: `&lt;div&gt;<br/>    &lt;input type="text" v-model="message"&gt;<br/>    &lt;button @click="addMessage(message)"&gt;<br/>      Add message<br/>    &lt;/button&gt;<br/>  &lt;/div&gt;<br/>  `,<br/>  data() {<br/>    return {<br/>      message: '',<br/>    };<br/>  },<br/>  methods: <strong>Vuex.mapActions(['addMessage'])</strong>,<br/>  // Or you can use the Object syntax<br/>  // methods: Vuex.mapActions({ addMessage: 'addMessage' }),<br/>};</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using modules for better scalability</h1>
                </header>
            
            <article>
                
<p>Vuex's single state tree can be divided into modules. This is useful when the application grows larger and you want to split the app into groups of features. Doing so also lets you only load core features when the page loads, and allows you to load the other functionalities later. This way, you can reduce loading times <span>drastically</span>, especially if the connection is slow or the application is run inside a low-end mobile phone. It takes time for the JavaScript virtual machine to parse all the JavaScript code, thus providing only a single huge file with all the application code will take seconds to be parsed, giving a mobile user the impression that the application is slow and heavy.</p>
<p>A good tool to use in combination with Vue/Vuex is webpack, which lets you split your application into bundles. A webpack bundle can contain one or more Vuex modules, and a module can be loaded after another module. You can find more information about webpack at <a href="https://webpack.js.org/">https://webpack.js.org/</a>.</p>
<p>The application state tree can be split into modules, and each module into submodules. Let's see how this can be coded:</p>
<pre>const subModule = {<br/>  state: { ... },<br/>  mutations: { ... },<br/>  actions: { ... }<br/>};<br/><br/>const moduleA = {<br/>  state: { ... },<br/>  mutations: { ... },<br/>  actions: { ... },<br/>  getters: { ... },<br/>  modules: {<br/>    sub: subModule<br/>  }<br/>};<br/><br/>const moduleB = {<br/>  state: { ... },<br/>  mutations: { ... },<br/>  actions: { ... }<br/>};<br/><br/>const store = new Vuex.Store({<br/>  modules: {<br/>    a: moduleA,<br/>    b: moduleB<br/>  }<br/>});<br/><br/>store.state.a // -&gt; `moduleA`'s state<br/>store.state.a.sub // -&gt; `subModule`'s state<br/>store.state.b // -&gt; `moduleB`'s state</pre>
<p>As you can see, the object passed to <kbd>new Vuex.store({})</kbd> is just the root module of your app, and inside the root module, or any other module, you can declare other modules.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Module local state</h1>
                </header>
            
            <article>
                
<p>The state object passed to <kbd>mutations</kbd>, <kbd>actions</kbd>, and <kbd>getters</kbd> is the local module state. In this way, a submodule doesn't need to know it is inside another module.</p>
<p>But what if a submodule wants to access a parent module? The <kbd>rootState</kbd> is provided inside <kbd>actions</kbd> and <kbd>getters</kbd> so that <span>you can navigate down to the desired module</span> <span>from the</span> <kbd>rootState</kbd><span>. Let's see how:</span></p>
<pre>const moduleA = {<br/>  // ...<br/>  actions: {<br/>    incrementIfOddOnRootSum ({ state, commit, <strong>rootState</strong> }) {<br/>      if ((state.count + rootState.count) % 2 === 1) {<br/>        commit('increment');<br/>      }<br/>    }<br/>  },<br/>  getters: {<br/>    sumWithRootCount (state, getters, <strong>rootState</strong>) {<br/>      return state.count + rootState.count;<br/>    }<br/>  }<br/>}</pre>
<p>It is important to note that inside an action, the <kbd>rootState</kbd> is a property of the parameter <kbd>context</kbd> that is passed to the action, whereas inside a <kbd>getter</kbd>, the <kbd>rootState</kbd> is passed as the third parameter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Module with namespace</h1>
                </header>
            
            <article>
                
<p>There may be collisions between the names among different modules. To avoid this, and to create <kbd>reusable</kbd> modules, you can set <span>the module's</span> <kbd>namespaced</kbd> <span>property</span> <span>to</span> <kbd>true</kbd><span>. The following is an example of a <kbd>namespaced</kbd> module:</span></p>
<pre>modules: {<br/> auth: {<br/>  <strong>namespaced: true</strong>,<br/>  state: { ... }, // Already nested, not affected by namespace<br/>  mutations: {<br/>    setLogged() {...} //<span> -&gt; commit('auth.setLogged')</span><br/>  },<br/>  actions: {<br/>    login(){...} // -&gt; dispatch('auth/login')<br/>  },<br/>  getters: {<br/>    logged() {...} // -&gt; getters['auth/logged']<br/>  }<br/>};</pre>
<p>The code inside a module doesn't change when the <kbd>namespaced</kbd> property is set to <kbd>true</kbd>. What changes is the code that wants to use another <kbd>namespace</kbd> module. Look at the following example:</p>
<pre>modules: {<br/>  foo: {<br/>    <strong>namespaced: true</strong>,<br/>    getters: {<br/>      someGetter (state, getters, rootState,<strong> rootGetters</strong>) {<br/>        getters.someOtherGetter // -&gt; 'foo/someOtherGetter'<br/>        rootGetters.someOtherGetter // -&gt; 'someOtherGetter'<br/>      },<br/>      someOtherGetter: state =&gt; { ... }<br/>    },<br/>    actions: {<br/>      someAction ({dispatch, commit, getters,<strong> rootGetters</strong>}) {<br/>        getters.someGetter // -&gt; 'foo/someGetter'<br/>        rootGetters.someGetter // -&gt; 'someGetter'<br/><br/>        dispatch('someOtherAction'); //-&gt;'foo/someOtherAction'<br/><br/>        // -&gt; 'someOtherAction'<br/>        <strong>dispatch('someOtherAction', null, { root: true });</strong><br/><br/>        commit('someMutation') // -&gt; 'foo/someMutation'<br/><br/>        // -&gt; 'someMutation'<br/>        <strong>commit('someMutation', null, { root: true })</strong> <br/>      },<br/>      someOtherAction (ctx, payload) { ... }<br/>    }<br/>  }<br/>}</pre>
<p>To commit a mutation or dispatch an action of another module, you need to add <kbd>{ root: true }</kbd> as the third parameter. There is also a <kbd>rootGetters</kbd> <span>parameter</span> <span>that is provided to the</span> <kbd>actions</kbd> <span>handlers or</span> <kbd>getters</kbd> <span>functions.</span></p>
<p>Finally, when using Vuex helpers, you need to specify the namespace as follows:</p>
<pre>computed: {<br/>  <strong>...mapState('some/nested/module', {</strong><br/>    a: state =&gt; state.a,<br/>    b: state =&gt; state.b<br/>  })<br/>},<br/>methods: {<br/>  <strong>...mapActions('some/nested/module', [</strong><br/>    'foo',<br/>    'bar'<br/>  ])<br/>}</pre>
<p>Or you can create namespaced helpers using the function <kbd>createNamespacedHelpers(nameSpace)</kbd> which returns all the helpers inside an object. These helpers are bound to the namespace you provided as the first argument. The following is an example of how to use <span><kbd>createNamespacedHelpers</kbd>:</span></p>
<pre>const { mapState, mapActions } = <br/>    Vuex.<strong>createNamespacedHelpers('some/nested/module')</strong>;<br/><br/>export default {<br/>  computed: {<br/>    // look up in `some/nested/module`<br/>    ...mapState({<br/>      a: state =&gt; state.a,<br/>      b: state =&gt; state.b<br/>    })<br/>  },<br/>  methods: {<br/>    // look up in `some/nested/module`<br/>    ...mapActions([<br/>      'foo',<br/>      'bar'<br/>    ])<br/>  }<br/>};</pre>
<p>At the end of this chapter, you will find an example of two modules with the <kbd>namespace</kbd> parameter set to <kbd>true</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dynamic module registration</h1>
                </header>
            
            <article>
                
<p>It is possible to register a module after a Vuex store has been created using the <kbd>store.registerModule(...)</kbd> method. The following is an example of how a module can be registered:</p>
<pre>// register a module `myModule`<br/>store.registerModule('myModule', {<br/>  // ...<br/>})<br/><br/>// register a nested module `nested/myModule`<br/>store.registerModule(['nested', 'myModule'], {<br/>  // ...<br/>})</pre>
<p>This is particularly useful when modules are loaded asynchronously:</p>
<pre>// Loading module asynchronously<br/>// index.js<br/>Vue.use(Vuex);<br/><br/>const store = new Vuex.Store({<br/>  state: {<br/>    currentView: 'initial'<br/>  },<br/>});<br/><br/>Vue.component('initial', {<br/>  template: '&lt;div&gt;initial&lt;/div&gt;',<br/>});<br/><br/>import ('./loaded-later-moudle.js').then((module) =&gt; {<br/>  module.default(store);<br/>});<br/><br/>new Vue({<br/>  el: '#app',<br/>  template: '&lt;component :is="$store.state.currentView"/&gt;',<br/>  store,<br/>});</pre>
<p>Following is <kbd>loaded-later-moudle.js</kbd> file code, which gets loaded inside <kbd>index.js</kbd>:</p>
<pre>// loaded-later-moudle.js<br/>export default function moduleFactory(store) {<br/>  Vue.component('later', {<br/>    template: '&lt;div&gt;later&lt;/div&gt;',<br/>  });<br/><br/>  store.registerModule('loadedLater', {});<br/><br/>  setTimeout(() =&gt; {<br/>    store.state.currentView = 'later';<br/>  }, 500);<br/>}</pre>
<p>In the preceding example, the root module defines a <kbd>currentView</kbd> property that points to the <kbd>initial</kbd> component. With the dynamic import syntax, we import the <kbd>loaded-later-moudle.js</kbd> file, and after it has been loaded we execute the module code that replaces the <kbd>currentView</kbd> <span>value, causing the <kbd>later</kbd> component to be displayed.</span></p>
<p>The preceding example works inside a browser that supports dynamic import syntax, or you can use webpack to build it.</p>
<p>You can also unregister a dynamic loaded module by using <kbd>store.unregisterModule(moduleName)</kbd> . Static loaded modules cannot be unregistered.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Module reuse</h1>
                </header>
            
            <article>
                
<p>As with Vue <kbd>components</kbd>, in order to reuse a module, the state declaration needs to be a function returning the state instead of a plain object. Otherwise, the state object is shared among all the module users. There are two cases where this may happen:</p>
<ul>
<li>Where multiple stores are using the same module</li>
<li>Where the same module has been registered more than once in the same store</li>
</ul>
<p>The first case is unlikely to happen because Vuex uses a single store. Besides, you can always create more than one store, even though you can register only one store per Vue instance.</p>
<p>The second case is likely to happen if the module is general purpose and depends on some parameters. In the same way that classes can have constructor parameters, a module could be created using a factory method with parameters. For example, say that you have two similar RESTful APIs and you created a generic API module so that the module can be used for both the APIs. In this case, you will use two instances of the same module, one for each API.</p>
<p>The following is an example of how to create a <kbd>reusable</kbd> module:</p>
<pre>const ReusableModule = {<br/>  state () {<br/>    <strong>return </strong>{<br/>      foo: 'bar'<br/>    }<br/>  },<br/>  // mutations, actions, getters...<br/>};</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enabling strict mode while developing</h1>
                </header>
            
            <article>
                
<p>When <kbd>Vuex</kbd> is in strict mode, it will throw an error if the single state tree is mutated outside mutation handlers. This is useful when developing to prevent accidental modifications to the state. To enable strict mode, you just need to add <kbd>strict: true</kbd> to the store configuration object:</p>
<pre>const store = new Vuex.Store({<br/>  // ...<br/>  <strong>strict: true</strong><br/>});</pre>
<p><em>Strict mode should not be used in production</em>. Strict mode runs a synchronous deep watcher on the state tree for detecting inappropriate mutations, and this can slow down the application. To avoid changing strict to <kbd>false</kbd> each time you want to create a production bundle, you should use a build tool that makes the strict value <kbd>false</kbd> when creating the production bundle. For example, you could use the following snippet in conjunction with webpack:</p>
<pre>const store = new Vuex.Store({<br/>  // ...<br/>  strict: <strong>process.env.NODE_ENV !== 'production'</strong><br/>})</pre>
<p>In <a href="bf5c8728-bcfd-4db0-abe4-6ef1fe22185c.xhtml">Chapter 3</a>, <em>Implementing Notes App Using</em> <em>Vuex State Management,</em> you will be shown how to use webpack to enable/disable strict mode.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Form handling restrictions when using Vuex</h1>
                </header>
            
            <article>
                
<p>Using Vue's <kbd>v-model</kbd> <span>feature</span> <span>with the Vuex state results in a direct modification of the state, which is forbidden.</span></p>
<p>Take a look at the following example:</p>
<pre>&lt;input v-model="$store.state.message"&gt;</pre>
<p>In this example, <kbd>$store.state</kbd> is mutated directly by <kbd>v-model</kbd>, and if strict mode is enabled, it will result in an error being thrown.</p>
<p>There is more than one way to solve this problem, and I will show you the one that, in my opinion, is better: You can use a mutable computed property that accesses <span>the <kbd>state</kbd> property when read and</span> commits a mutation when set:</p>
<pre>&lt;input v-model="message"&gt;<br/>// ...<br/>computed: {<br/>  message: {<br/>    get () {<br/>      return this.$store.state.obj.message;<br/>    },<br/>    set (value) {<br/>      this.$store.commit('updateMessage', value);<br/>    }<br/>  }<br/>}</pre>
<p>Using a mutable computed property also allows you to add some validation before committing the corresponding mutation.</p>
<p>The following is a possible code for the mutation that gets committed:</p>
<pre>// ...<br/>mutations: {<br/>  updateMessage (state, message) {<br/>    state.obj.message = message;<br/>  }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A simple counter example</h1>
                </header>
            
            <article>
                
<p>The following is a very simple example of a counter that summarizes the <span>core concepts of</span> <span>Vuex in a self-contained HTML file:</span></p>
<pre><span>&lt;!DOCTYPE </span><span>html</span><span>&gt;<br/></span><span>&lt;html </span><span>lang=</span><span>"en"</span><span>&gt;<br/></span><span>&lt;head&gt;<br/></span><span>  &lt;meta </span><span>charset=</span><span>"UTF-8"</span><span>&gt;<br/></span><span>  &lt;title&gt;</span>Simple counter example<span>&lt;/title&gt;<br/></span><span>&lt;/head&gt;<br/></span><span>&lt;body&gt;<br/></span><span>&lt;div </span><span>id=</span><span>"app"</span><span>&gt;&lt;/div&gt;<br/></span><span>&lt;script </span><span>src=</span><span>"https://unpkg.com/vuex@3.0.1/dist/vuex.min.js"</span><span>&gt;&lt;/script&gt;<br/></span><span>&lt;script </span><span>src=</span><span>"https://unpkg.com/vue@2.5.13/dist/vue.min.js"</span><span>&gt;&lt;/script&gt;<br/></span><span>&lt;script&gt;<br/></span><span>  </span>Vue.<span>use</span>(<span>Vuex</span>)<span>;<br/></span><span><br/></span><span>  </span><span>// <strong>Sequential module</strong><br/></span><span>  </span><span>const </span>sequential = {<br/>    <span>namespaced</span>: <span>true</span><span>,<br/></span><span>    </span><span>state</span>() {<br/>      <span>return </span>{<br/>        <span>count</span>: <span>1</span><span>,<br/></span><span>      </span>}<span>;<br/></span><span>    </span>}<span>,<br/></span><span>    </span><span>mutations</span>: {<br/>      <span>increment</span>: state =&gt; state.<span>count</span>++<span>,<br/></span><span>      </span><span>decrement</span>: state =&gt; state.<span>count</span>--<br/>    }<span>,<br/></span><span>    </span><span>actions</span>: {<br/>      <span>increment</span>: ({ commit }) =&gt; commit(<span>'increment'</span>)<span>,<br/></span><span>      </span><span>decrement</span>: ({ commit }) =&gt; commit(<span>'decrement'</span>)<span>,<br/></span><span>    </span>}<span>,<br/></span><span>    </span><span>getters</span>: {<br/>      <span>name</span>: () =&gt; <span>'Sequential'</span><span>,<br/></span><span>      </span><span>currentCount</span>: state =&gt; state.<span>count</span><span>,<br/></span><span>    </span>}<span>,<br/></span><span>  </span>}<span>;<br/></span><span><br/></span><span>  </span><span>// <strong>FizzBuzz module</strong> that extends sequential module<br/></span><span>  // and redefine some functions.<br/></span><span>  </span><span>const </span>fizzBuzz = Object.<span>assign</span>({}<span>, </span>sequential<span>, </span>{<br/>    <span>getters</span>: {<br/>      <span>name</span>: () =&gt; <span>'FizzBuzz'</span><span>,<br/></span><span>      </span><span>currentCount</span>: state =&gt; {<br/>        <span>const </span>{ count } = state<span>;<br/></span><span>        </span><span>let </span>msg = <span>''</span><span>;<br/></span><span>        </span><span>if </span>(count % <span>3 </span>=== <span>0</span>) msg += <span>"Fizz"</span><span>;<br/></span><span>        </span><span>if </span>(count % <span>5 </span>=== <span>0</span>) msg += <span>"Buzz"</span><span>;<br/></span><span>        </span><span>return </span><span>`</span>${count} ${msg}<span>`</span><span>;<br/></span><span>      </span>}<span>,<br/></span><span>    </span>}<span>,<br/></span><span>  </span>})<span>;<br/></span><span><br/></span><span>  </span><span>// <strong>Application store</strong> with the two modules<br/></span><span>  </span><span>const </span>store = <span>new </span><span>Vuex</span>.Store({<br/>    <span>modules</span>: {<br/>      sequential<span>,<br/></span><span>      </span>fizzBuzz<span>,<br/></span><span>    </span>}<span>,<br/></span><span>  </span>})<span>;<br/></span><span><br/></span><span>  </span><span>// <strong>HTML template</strong> to show the result<br/></span><span>  </span><span>const </span>template = <span>`<br/></span><span>  &lt;div&gt;<br/></span><span>    &lt;button @click="increment"&gt;+&lt;/button&gt;<br/></span><span>    &lt;button @click="decrement"&gt;-&lt;/button&gt;<br/></span><span>    &lt;span&gt;{{name}} value: {{currentCount}}&lt;/span&gt;<br/></span><span>  &lt;/div&gt;<br/></span><span>`</span><span>;<br/></span><span><br/></span><span>  </span><span>// <strong>counter component</strong><br/></span><span>  </span><span>const </span>counter = {<br/>    template<span>,<br/></span><span>    </span><span>computed</span>: <span>Vuex</span>.mapGetters(<span>'sequential'</span><span>, </span>[<br/>      <span>'name'</span><span>,<br/></span><span>      </span><span>'currentCount'</span><span>,<br/></span><span>    </span>])<span>,<br/></span><span>    </span><span>methods</span>: <span>Vuex</span>.mapActions(<span>'sequential'</span><span>, </span>[<br/>      <span>'increment'</span><span>,<br/></span><span>      </span><span>'decrement'</span><span>,<br/></span><span>    </span>])<span>,<br/></span><span>  </span>}<span>;<br/></span><span><br/></span><span>  </span><span>// <strong>fizzBuzzCounter component</strong><br/></span><span>  </span><span>const </span>fizzBuzzCounter = {<br/>    template<span>,<br/></span><span>    </span><span>computed</span>: <span>Vuex</span>.mapGetters(<span>'fizzBuzz'</span><span>, </span>[<br/>      <span>'name'</span><span>,<br/></span><span>      </span><span>'currentCount'</span><span>,<br/></span><span>    </span>])<span>,<br/></span><span>    </span><span>methods</span>: <span>Vuex</span>.mapActions(<span>'fizzBuzz'</span><span>, </span>[<br/>      <span>'increment'</span><span>,<br/></span><span>      </span><span>'decrement'</span><span>,<br/></span><span>    </span>])<span>,<br/></span><span>  </span>}<span>;<br/></span><span><br/></span><span>  </span><span>// <strong>Vue instance with the store and the components</strong><br/></span><span>  </span><span>new </span>Vue({<br/>    <span>el</span>: <span>'#app'</span><span>,<br/></span><span>    </span>store<span>,<br/></span><span>    </span><span>template</span>: <span>'&lt;div&gt;&lt;counter&gt;&lt;/counter&gt;' </span>+<br/>    <span>'&lt;fizzBuzzCounter&gt;&lt;/fizzBuzzCounter&gt;&lt;/div&gt;'</span><span>,<br/></span><span>    </span><span>components</span>: {<br/>      counter<span>,<br/></span><span>      </span>fizzBuzzCounter<span>,<br/></span><span>    </span>}<span>,<br/></span><span>  </span>})<span>;<br/></span><span>&lt;/script&gt;<br/></span><span>&lt;/body&gt;<br/></span><span>&lt;/html&gt;</span></pre>
<p>The preceding example shows two counters. The first one just increments or decrements the current value. The second one, <span class="packt_screen">FizzBuzz</span>, shows <em>Fizz</em> if the counter is divisible by <kbd>3</kbd>, <em>Buzz</em> if it is divisible by <kbd>5</kbd>, and <span class="packt_screen">FizzBuzz</span> when it is both divisible by <kbd>3</kbd> and <kbd>5</kbd>, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/962ea5a9-c923-46f3-8733-630cb1944b91.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure</span> <span>2.2: FizzBuzz counter</span></div>
<p>In this example, I created two modules and two components that use these modules: one for the <kbd>sequential</kbd> counter and the other for the <kbd>fizzBuzz</kbd> counter.</p>
<p>After that, I created a new instance of <kbd>Vue</kbd> and added the two modules and components to it. The aim of this example is to show you how to use <kbd>namespaced</kbd> modules, as well as to serve as a full but simple example of Vue and Vuex combined together.</p>
<p>You can find the example source code inside the GitHub repository of this book in the <kbd>chapter-2/fizzbuzz-counter</kbd> <span>folder</span> <span>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we studied the Vuex framework. We went through its core concepts and saw how Vuex can be integrated into a Vue application. At the end, a simple counter example helped us to get the whole picture.</p>
<p>It is now time to move from a simple example to real application development using Vuex. That is the topic of <a href="bf5c8728-bcfd-4db0-abe4-6ef1fe22185c.xhtml" target="_blank">Chapter 3</a>, <em>Implementing the Notes App Using Vuex State Management</em>, developing an application that takes notes in a similar way to Google Keep or Evernote.</p>


            </article>

            
        </section>
    </body></html>