- en: '*Chapter 3*: Next.js Basics and Built-In Components'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第3章*：Next.js基础和内置组件'
- en: Next.js is not only about server-side rendering. It provides some incredibly
    useful built-in components and functions that we can use to create performant,
    dynamic, and modern websites.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js不仅关于服务器端渲染。它提供了一些非常实用的内置组件和函数，我们可以使用它们来创建性能良好、动态和现代的网站。
- en: In this chapter, we're going to take a look at some concepts at the core of
    Next.js, such as routing systems, client-side navigation, serving optimized images,
    handling metadata, and more. These notions will be very beneficial once we move
    on to building some real-world applications with this framework.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Next.js核心的一些概念，例如路由系统、客户端导航、服务优化图像、处理元数据等。一旦我们开始使用这个框架构建一些实际的应用程序，这些概念将非常有用。
- en: We will also take a closer look at the `_app.js` and `_document.js` pages, which
    will allow us to customize our web app behavior in several ways.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将更深入地研究`_app.js`和`_document.js`页面，这将使我们能够以多种方式自定义我们的Web应用行为。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: How the routing system works, both on the client and server sides
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由系统如何在客户端和服务器端工作
- en: How to optimize navigation between pages
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何优化页面间的导航
- en: How Next.js serves static assets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Next.js如何服务静态资源
- en: How to optimize image serving via automatic image optimization and the new `Image`
    component
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过自动图像优化和新的`Image`组件优化图像服务
- en: How to dynamically handle HTML metadata from any component
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何动态处理来自任何组件的HTML元数据
- en: What are the `_app.js` and `_document.js` files and how can they be customized?
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_app.js`和`_document.js`文件是什么，以及如何自定义它们？'
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To run the code examples in this chapter, you need to have both Node.js and
    npm installed on your local machine.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本章中的代码示例，您需要在您的本地机器上安装Node.js和npm。
- en: If you prefer, you can use an online IDE such as [https://repl.it](https://repl.it)
    or [https://codesandbox.io](https://codesandbox.io); they both support Next.js,
    and you don't need to install any dependency on your computer.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您喜欢，可以使用在线IDE，例如[https://repl.it](https://repl.it)或[https://codesandbox.io](https://codesandbox.io)；它们都支持Next.js，您不需要在您的电脑上安装任何依赖。
- en: 'You can find the code for this chapter on the GitHub repository: [https://github.com/PacktPublishing/Real-World-Next.js](https://github.com/PacktPublishing/Real-World-Next.js).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub仓库中找到本章的代码：[https://github.com/PacktPublishing/Real-World-Next.js](https://github.com/PacktPublishing/Real-World-Next.js)。
- en: Routing system
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由系统
- en: If you're coming from client-side React, you might be familiar with libraries
    such as *React Router*, *Reach Router*, or *Wouter*. They allow you to create
    client-side routes only, meaning that all the pages will be created and rendered
    on the client side; no server-side rendering is involved.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您来自客户端React，您可能熟悉像*React Router*、*Reach Router*或*Wouter*这样的库。它们允许您仅创建客户端路由，这意味着所有页面都将创建并在客户端渲染；不涉及服务器端渲染。
- en: 'Next.js uses a different approach: filesystem-based pages and routes. As seen
    in Chapter 2, *Exploring Different Rendering Strategies*, a default Next.js project
    ships with a `pages/` directory. Every file inside that folder represents a new
    page/route for your application.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js采用不同的方法：基于文件系统的页面和路由。如第2章中所述，*探索不同的渲染策略*，一个默认的Next.js项目包含一个`pages/`目录。该文件夹内的每个文件都代表您应用程序的一个新页面/路由。
- en: Therefore, when talking about a page, we refer to a React component exported
    from any of the `.js`, `.jsx`, `.ts`, or `.tsx` files inside the `pages/` folder.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们谈论一个页面时，我们指的是从`pages/`文件夹内的`.js`、`.jsx`、`.ts`或`.tsx`文件中导出的React组件。
- en: 'To make things a bit clearer, let''s say that we want to create a simple website
    with just two pages; the first one will be the home page, while the second one
    will be a simple contact page. To do that, we will only need to create two new
    files inside our `pages/` folder: `index.js` and `contacts.js`. Both files will
    need to export a function returning some JSX content; it will be rendered on the
    server side and sent to the browser as standard HTML.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让事情更清晰，让我们假设我们只想创建一个包含两个页面的简单网站；第一个将是主页，而第二个将是一个简单的联系页面。为此，我们只需要在我们的`pages/`文件夹内创建两个新文件：`index.js`和`contacts.js`。这两个文件都需要导出一个返回一些JSX内容的函数；它将在服务器端渲染并发送到浏览器作为标准HTML。
- en: 'As we''ve just seen, a page must return valid JSX code, so let''s make a very
    simple and concise `index.js` page:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才看到的，一个页面必须返回有效的JSX代码，所以让我们创建一个非常简单和简洁的`index.js`页面：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If we run `yarn dev` or `npm run dev` in our terminal, then move to [http://localhost:3000](http://localhost:3000)
    in our browser, we will only see the **This is the homepage** message appear on
    the screen. We've just made our first page!
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在终端中运行`yarn dev`或`npm run dev`，然后在我们的浏览器中转到[http://localhost:3000](http://localhost:3000)，我们将在屏幕上只看到**这是主页**的消息。我们刚刚制作了我们的第一个页面！
- en: 'We can do the same with our contact page:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以用我们的联系页面做同样的事情：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Given that we've called our contact page `contacts.js`, we can navigate to http://localhost:3000/contacts
    and see the contacts list displayed on the browser. If we want to move that page
    to http://localhost:3000/contact-us, we can just rename our `contacts.js` file
    to `contact-us.js`, and Next.js will automatically rebuild the page using the
    new route name for us.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已将我们的联系页面命名为`contacts.js`，我们可以导航到http://localhost:3000/contacts并在浏览器上看到显示的联系人列表。如果我们想要将该页面移动到http://localhost:3000/contact-us，我们只需将我们的`contacts.js`文件重命名为`contact-us.js`，Next.js将自动使用新的路由名称为我们重建页面。
- en: Now, let's try to make things a bit harder. We're building a blog, so we want
    to create a route for each post. We also want to create a `/posts` page that will
    show every post present on the website.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试使事情变得稍微复杂一些。我们正在构建一个博客，因此我们想要为每篇文章创建一个路由。我们还想要创建一个`/posts`页面，该页面将显示网站上所有的文章。
- en: 'To do that, we will use a dynamic route as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们将使用以下动态路由：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We haven't mentioned yet that we can create nested routes using folders inside
    our `pages/` directory. If we want to make a `/posts` route, we can create a new
    `index.js` file inside the `pages/posts/` folder, export a function containing
    some JSX code, and visit http://localhost:3000/posts.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有提到，我们可以使用`pages/`目录内的文件夹创建嵌套路由。如果我们想要创建一个`/posts`路由，我们可以在`pages/posts/`文件夹内创建一个新的`index.js`文件，导出一个包含一些
    JSX 代码的函数，并访问http://localhost:3000/posts。
- en: We then want to create a dynamic route for every blog post so that we don't
    have to manually create a new page every time we want to publish an article on
    our website. To do that, we can create a new file inside the `pages/posts/` folder,
    `pages/posts/[slug].js`, where `[slug]` identifies a route variable that can contain
    any value, depending on what the user types in the browser's address bar. In that
    case, we're creating a route containing a variable called `slug`, which can vary
    for every blog post. We can export a simple function returning some JSX code from
    that file and then browse to http://localhost:3000/posts/my-firstpost, http://localhost:3000/posts/foo-bar-baz,
    or any other http://localhost:3000/posts/* route. Whatever route you browse to,
    it will always render the same JSX code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们想要为每篇博客文章创建一个动态路由，这样我们就不必每次想要在网站上发布文章时手动创建一个新页面。要做到这一点，我们可以在`pages/posts/`文件夹内创建一个新文件，`pages/posts/[slug].js`，其中`[slug]`标识一个可以包含任何值的路由变量，这取决于用户在浏览器地址栏中输入的内容。在这种情况下，我们正在创建一个包含名为`slug`的变量的路由，该变量可以针对每篇博客文章而变化。我们可以从这个文件中导出一个简单的函数，返回一些
    JSX 代码，然后浏览到http://localhost:3000/posts/my-firstpost、http://localhost:3000/posts/foo-bar-baz或任何其他http://localhost:3000/posts/*路由。无论你浏览到哪个路由，它都会始终渲染相同的
    JSX 代码。
- en: 'We can also nest multiple dynamic routes inside the `pages/` folder; let''s
    say that we want our post page structure to be as follows: `/posts/[date]/[slug]`.
    We can just add a new folder called `[date]` inside our `pages/` directory and
    move the `slug.js` file inside it:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在`pages/`文件夹内嵌套多个动态路由；假设我们想要我们的文章页面结构如下：`/posts/[date]/[slug]`。我们只需在我们的`pages/`目录内添加一个新的名为`[date]`的文件夹，并将`slug.js`文件移入其中：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can now visit [http://localhost:3000/posts/2021-01-01/my-first-post](http://localhost:3000/posts/2021-01-01/my-first-post)
    and see the JSX content we've created previously. Once again, both the `[date]`and
    `[slug]` variables can represent whatever you want, so feel free to experiment
    by calling different routes on the browser.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以访问[http://localhost:3000/posts/2021-01-01/my-first-post](http://localhost:3000/posts/2021-01-01/my-first-post)并查看我们之前创建的
    JSX 内容。再次强调，`[date]`和`[slug]`变量可以代表任何你想要的内容，所以请随意通过在浏览器中调用不同的路由进行实验。
- en: Until now, we have always used route variables to render the same page, but
    these variables are mainly meant for creating highly dynamic pages with different
    content depending on the route variables we're using. Let's see how to render
    different content depending on the variables in the next sections.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直使用路由变量来渲染相同的页面，但这些变量主要用于创建高度动态的页面，其内容根据我们使用的路由变量而有所不同。让我们在下一节中看看如何根据变量渲染不同的内容。
- en: Using route variables inside our pages
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在我们的页面中使用路由变量
- en: Route variables are incredibly useful for creating very dynamic page content.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 路由变量对于创建非常动态的页面内容非常有用。
- en: 'Let''s take an easy example: a greetings page. Inside the project used in the
    previous section, let''s create the following file: `pages/greet/[name].js`. We''re
    going to use Next.js'' built-in `getServerSideProps` function to dynamically get
    the `[name]` variable from the URL and greet the user:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个简单的例子来说明：一个问候页面。在上一节中使用的项目中，让我们创建以下文件：`pages/greet/[name].js`。我们将使用 Next.js
    内置的 `getServerSideProps` 函数动态地从 URL 获取 `[name]` 变量并向用户问候：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, open your favorite browser and go to http://localhost:3000/greet/Mitch;
    you should see a "`name` variable, so feel free to try with some different names!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开您最喜欢的浏览器并转到 http://localhost:3000/greet/Mitch；您应该看到一个 "`name` 变量，所以请随意尝试一些不同的名字！
- en: Important Note
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: When using both the `getServerSideProps` and `getStaticProps` functions, remember
    that they *must* return an object. Also, if you want to pass any prop from one
    of those two functions to your page, make sure to pass them inside the returning
    object's `props` property.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当同时使用 `getServerSideProps` 和 `getStaticProps` 函数时，请记住它们 *必须* 返回一个对象。另外，如果你想从这两个函数之一传递任何属性到你的页面，确保在返回对象的
    `props` 属性中传递它们。
- en: Being able to get data from the URL is fundamental for many reasons. In the
    previous code example, we made a simple greetings page, but we could have used
    the `[name]` variable for other purposes, such as getting that user data from
    a database to show their profile. We will take a closer look at data fetching
    in [*Chapter 4*](B16985_04_Final_SB_epub.xhtml#_idTextAnchor053), *Organizing
    the Code Base and Fetching Data in Next.js*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 能够从 URL 获取数据对于许多原因来说都是基本的。在之前的代码示例中，我们创建了一个简单的问候页面，但我们可以使用 `[name]` 变量用于其他目的，例如从数据库获取用户数据以显示他们的个人资料。我们将在
    [*第 4 章*](B16985_04_Final_SB_epub.xhtml#_idTextAnchor053) 中更详细地了解数据获取，*Next.js
    中的代码库组织和数据获取*。
- en: There are times when you need to fetch route variables from your components
    rather than your pages. Next.js makes this effortless thanks to a React hook that
    we'll see in the next section.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你需要从你的组件而不是你的页面中获取路由变量。Next.js 通过我们将在下一节中看到的 React 钩子使这一切变得轻松。
- en: Using route variables inside components
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在组件中使用路由变量
- en: In the previous section, we have learned how to use route variables inside our
    pages. Next.js does not allow us to use both `getServerSideProps` and `getStaticProps`
    functions outside of our pages, so how are we supposed to use them inside other
    components?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何在页面中使用路由变量。Next.js 不允许我们在页面之外使用 `getServerSideProps` 和 `getStaticProps`
    函数，那么我们如何在其他组件中使用它们呢？
- en: 'Next.js makes this effortless thanks to the `useRouter` hook; we can import
    it from the `next/router` file:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js 通过 `useRouter` 钩子使这一切变得轻松；我们可以从 `next/router` 文件中导入它：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It works just like any other React hook (a function that lets you interact
    with the React state and life cycle in function components), and we can instantiate
    it inside any component. Let''s refactor the previous greetings page as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作方式就像任何其他 React 钩子（一个让你在函数组件中与 React 状态和生命周期交互的函数）一样，我们可以在任何组件中实例化它。让我们按照以下方式重构之前的问候页面：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, we are extracting the `query` parameter from the `useRouter`
    hook. It contains both our route variables (in this case, it only contains the
    `name` variable) and the parsed query string parameters.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们正在从 `useRouter` 钩子中提取 `query` 参数。它包含我们的路由变量（在这个例子中，它只包含 `name` 变量）和解析后的查询字符串参数。
- en: 'We can observe how Next.js passes both route variables and query strings via
    the `useRouter` hook by trying to append any query parameter to our URL and log
    the `query` variable inside our component:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过尝试将任何查询参数附加到我们的 URL 并在组件中记录 `query` 变量来观察 Next.js 如何通过 `useRouter` 钩子传递路由变量和查询字符串：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If we now try to call the following URL, http://localhost:3000/greet/Mitch?learning_nextjs=true,
    we will see the following object logged inside our terminal:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在尝试调用以下 URL，http://localhost:3000/greet/Mitch?learning_nextjs=true，我们将在我们的终端中看到以下对象：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Important Note
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Next.js does not throw any error if you try to append a query parameter with
    the same key as your routing variable. You can easily try that by calling the
    following URL: http://localhost:3000/greet/Mitch?name=Christine. You will notice
    that Next.js will give precedence to your route variable, such that you will see
    **Hello, Mitch!** displayed on the page.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试附加与您的路由变量具有相同键的查询参数，Next.js 不会抛出任何错误。您可以通过调用以下 URL 来轻松尝试：http://localhost:3000/greet/Mitch?name=Christine。您将注意到
    Next.js 将优先考虑您的路由变量，因此您将在页面上看到 **Hello, Mitch!** 的显示。
- en: Client-side navigation
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端导航
- en: As we have already seen so far, Next.js is not only about rendering React on
    the server. It provides several ways to optimize your website's performance, and
    one of these optimizations is how it handles client-side navigation.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Next.js 不仅关乎在服务器上渲染 React。它提供了多种方式来优化您网站的性能，其中之一就是它处理客户端导航的方式。
- en: 'In fact, it supports the HTML standard `<a>` tags for linking pages, but it
    also provides a more optimized way for navigating between different routes: the
    `Link` component.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，它支持 HTML 标准 `<a>` 标签用于链接页面，但它还提供了一种更优化的方式在各个路由之间导航：`Link` 组件。
- en: 'We can import it as a standard React component and use it for linking different
    pages or sections of our website. Let''s look at an easy example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其作为标准 React 组件导入，并用于链接我们网站的不同页面或部分。让我们看看一个简单的例子：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: By default, Next.js will preload every single `Link` found on the viewport,
    meaning that once we click on one of the links, the browser will already have
    all the data needed to render the page.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Next.js 会预加载视口中找到的每一个 `Link`，这意味着一旦我们点击其中一个链接，浏览器就已经拥有了渲染页面所需的所有数据。
- en: 'You can disable this feature by passing the `preload={false}` prop to the `Link`
    component:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将 `preload={false}` 属性传递给 `Link` 组件来禁用此功能：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Starting with Next.js 10, we're also able to link pages with dynamic route variables
    with ease.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Next.js 10 版本开始，我们也可以轻松地使用动态路由变量链接页面。
- en: 'Let''s say that we want to link the following page: `/blog/[date]/[slug].js`.
    With previous versions of Next.js, we needed to add two different props:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要链接以下页面：`/blog/[date]/[slug].js`。在使用 Next.js 的早期版本时，我们需要添加两个不同的属性：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `href` prop tells Next.js which page we want to render, and the `as` prop
    will tell how we want to display it in the browser's address bar.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`href` 属性告诉 Next.js 我们想要渲染哪个页面，而 `as` 属性将告诉我们在浏览器地址栏中如何显示它。'
- en: 'Thanks to the enhancements introduced in Next.js 10, we no longer need to use
    the `as` prop as the `href` prop is enough for setting both the page we want to
    render and the URL displayed in the browser''s address bar. For instance, we can
    now write our links as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了 Next.js 10 中引入的增强功能，我们不再需要使用 `as` 属性，因为 `href` 属性足以设置我们想要渲染的页面以及浏览器地址栏中显示的
    URL。例如，我们现在可以这样编写我们的链接：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Important Note
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Although the legacy method for linking dynamic pages using the `Link` component
    is still working in Next.js >10, the framework's newest version makes it way easier.
    If you have some experience with previous Next.js versions or you're willing to
    upgrade to version >10, keep that new feature in mind as it will simplify the
    development of components, including dynamic links.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用 `Link` 组件链接动态页面的传统方法在 Next.js >10 中仍然有效，但框架的最新版本使它变得更加简单。如果您有使用先前 Next.js
    版本的经验，或者您愿意升级到版本 >10，请记住这个新功能，因为它将简化组件的开发，包括动态链接。
- en: 'If we are building complex URLs, we can also pass an object to the `href` prop:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在构建复杂的 URL，我们也可以将一个对象传递给 `href` 属性：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once the user clicks that link, Next.js will redirect the browser to the following
    URL: http://localhost:3000/blog/2020-01-01/happy-new-year?foo=bar.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户点击该链接，Next.js 将将浏览器重定向到以下 URL：http://localhost:3000/blog/2020-01-01/happy-new-year?foo=bar。
- en: Using the router.push method
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 router.push 方法
- en: 'There is another way to move between your Next.js website pages: by using the
    `useRouter` hook.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Next.js 网站页面之间移动的另一种方法是使用 `useRouter` 钩子。
- en: 'Let''s pretend that we want to give access to a given page only to logged-in
    users, and we already have a `useAuth` hook for that. We can use the `useRouter`
    hook to dynamically redirect a user if, in this case, they''re not logged in:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们只想让登录用户访问特定页面，并且我们已经有一个 `useAuth` 钩子来实现这一点。我们可以使用 `useRouter` 钩子动态地将用户重定向，如果在这种情况下他们未登录：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, we're using the `useEffect` hook to run the code on the client
    side only. In that case, if the user isn't logged in, we use the `router.push`
    method to redirect them to the login page.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用`useEffect`钩子在客户端仅运行代码。在这种情况下，如果用户未登录，我们使用`router.push`方法将他们重定向到登录页面。
- en: 'Just like with the `Link` component, we can create more complex page routes
    by passing an object to the `push` method:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`Link`组件一样，我们可以通过传递一个对象到`push`方法来创建更复杂的页面路由：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Once the `router.push` function has been called, the browser will be redirected
    to http://localhost:3000/blog/2020-01-01/happy-new-year?foo=bar.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦调用`router.push`函数，浏览器将被重定向到http://localhost:3000/blog/2020-01-01/happy-new-year?foo=bar。
- en: Important Note
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Next.js won't be able to prefetch all the linked pages as it does with the `Link`
    component.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js无法像使用`Link`组件那样预取所有链接的页面。
- en: Using the `router.push` method is handy when you need to redirect a user on
    the client side after a certain action occurs, but it's not recommended to be
    used as a default way for handling client-side navigation.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要在某些动作发生后在客户端重定向用户时，使用`router.push`方法很方便，但不建议将其用作处理客户端导航的默认方式。
- en: So far, we've seen how Next.js handles navigation through static and dynamic
    routes and how to force redirection and navigation on both the client and server
    sides programmatically.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了Next.js如何处理静态和动态路由的导航，以及如何在客户端和服务器端程序化地强制重定向和导航。
- en: In the next section, we're going to look at how Next.js helps us to serve static
    assets and optimize images on the fly for improved performance and SEO scores.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨Next.js如何帮助我们提供静态资源并即时优化图片以提高性能和SEO评分。
- en: Serving static assets
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供静态资源
- en: Using the term **static asset**, we refer to all of those non-dynamic files,
    such as images, fonts, icons, compiled CSS, and JS files.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用术语**静态资源**，我们指的是所有那些非动态文件，例如图片、字体、图标、编译后的CSS和JS文件。
- en: 'The easiest way to serve those assets is by using the default `/public` folder
    provided by Next.js. In fact, every file inside this folder will be considered
    and served as a static asset. We can prove that by creating a new file called
    `index.txt` and putting it inside the `/public` folder:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 提供这些资源的最简单方法是通过Next.js提供的默认`/public`文件夹。实际上，这个文件夹中的每个文件都将被视为静态资源。我们可以通过创建一个名为`index.txt`的新文件并将其放入`/public`文件夹来证明这一点：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If we now try to launch the server, when we go to [http://localhost:3000/index.txt](http://localhost:3000/index.txt),
    we will see the text **Hello, world!** displayed in the browser.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在尝试启动服务器，当我们访问[http://localhost:3000/index.txt](http://localhost:3000/index.txt)时，我们将在浏览器中看到文本**Hello,
    world!**显示。
- en: In [*Chapter 4*](B16985_04_Final_SB_epub.xhtml#_idTextAnchor053), *Organizing
    the Code Base and Fetching Data in Next.js*, we will take a closer look at organizing
    the public folder for serving common CSS and JS files, images, icons, and all
    the other types of static files.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第4章*](B16985_04_Final_SB_epub.xhtml#_idTextAnchor053) *Next.js中的代码库组织和数据获取*中，我们将更详细地探讨组织公共文件夹以提供常见的CSS和JS文件、图片、图标以及其他类型的静态文件。
- en: 'Serving static assets is relatively easy. However, a specific type of file
    can critically affect your website performance (and SEO): the image file.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 提供静态资源相对简单。然而，特定类型的文件可能会严重影响您的网站性能（以及SEO）：图片文件。
- en: 'Most of the time, serving non-optimized images will worsen your user experience,
    as they may take some time to load, and once they do, they''ll move part of the
    layout after the rendering, which can cause many problems in terms of UX. When
    this occurs, we''re talking about **Cumulative Layout Shift (CLS)**. Here is a
    simple representation of how CLS works:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，提供未优化的图片会降低用户体验，因为它们可能需要一些时间来加载，一旦加载，它们会在渲染后移动布局的一部分，这可能会在用户体验方面引起许多问题。当这种情况发生时，我们谈论的是**累积布局偏移（CLS）**。以下是如何工作的简单表示：
- en: '![Figure 3.1 – Representation of how CLS works'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.1 – CLS工作表示'
- en: '](img/B16985_03_01.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16985_03_01.jpg)'
- en: Figure 3.1 – Representation of how CLS works
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – CLS工作表示
- en: In the first browser tab, the image has not been loaded yet, so the two text
    areas look quite close to each other. After the image loads, it shifts the second
    text area down. If the user were reading the second text area, they would easily
    miss the mark.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个浏览器标签中，图片尚未加载，因此两个文本区域看起来非常接近。图片加载后，它会将第二个文本区域向下移动。如果用户正在阅读第二个文本区域，他们很容易错过标记。
- en: Important Note
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'If you want to learn more about CLS, I''d recommend the following article:
    [https://web.dev/cls](https://web.dev/cls).'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于CLS的信息，我推荐以下文章：[https://web.dev/cls](https://web.dev/cls)。
- en: Of course, Next.js makes it easy to avoid CLS, and it does so with a new built-in
    `Image` component. We will take a look at this in the next section.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Next.js通过一个新的内置`Image`组件使得避免CLS变得简单。我们将在下一节中探讨这一点。
- en: Next.js' automatic image optimization
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Next.js的自动图片优化
- en: Starting with Next.js 10, the framework introduced a new helpful `Image` component
    and automatic image optimization.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 从Next.js 10版本开始，该框架引入了一个新的有用`Image`组件和自动图片优化功能。
- en: Before Next.js introduced these two new features, we had to optimize every image
    using an external tool and then write down a complex `srcset` property for every
    HTML `<img>` tag to set responsive images for different screen sizes.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在Next.js引入这两个新功能之前，我们必须使用外部工具对每个图片进行优化，然后为每个HTML `<img>`标签编写复杂的`srcset`属性，以设置不同屏幕尺寸的响应式图片。
- en: Indeed, automatic image optimization will take care of serving your images using
    modern formats (such as **WebP**) to all those browsers that support it. But it
    will also be able to fall back on older image formats, such as *png* or *jpg*,
    in case the browser you're using doesn't support it. It also resizes your images
    to avoid serving heavy pictures to the client as it would negatively affect the
    asset's download speed.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，自动图片优化将负责使用现代格式（如**WebP**）为所有支持这些格式的浏览器提供服务。但如果有浏览器不支持，它也能回退到较旧的图片格式，如*png*或*jpg*。它还会调整图片大小，以避免向客户端发送重量级的图片，因为这会负面影响资产的下载速度。
- en: One great thing to keep in mind is that automatic image optimization works on-demand,
    as it optimizes, resizes, and renders the image only when the browser has requested
    it. This is important as it will work with any external data source (any CMS or
    image service, such as Unsplash or Pexels), and it won't slow down the build phase.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一个值得记住的伟大之处在于，自动图片优化是按需工作的，因为它仅在浏览器请求图片时才进行优化、调整大小和渲染。这很重要，因为它将与任何外部数据源（任何CMS或图片服务，如Unsplash或Pexels）一起工作，并且不会减慢构建阶段。
- en: 'We can try this feature on our local machine in a few minutes to see in person
    how it works. Let''s say that we want to serve the following image:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在几分钟内在本地机器上尝试这个功能，亲自看看它是如何工作的。假设我们想要提供以下图片：
- en: '![Figure 3.2 – Picture by Łukasz Rawa on Unsplash (https://unsplash.com/@lukasz_rawa)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.2 – 由Łukasz Rawa在Unsplash上的图片 (https://unsplash.com/@lukasz_rawa)'
- en: '](img/B16985_03_02.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16985_03_02.jpg)'
- en: Figure 3.2 – Picture by Łukasz Rawa on Unsplash ([https://unsplash.com/@lukasz_rawa](https://unsplash.com/@lukasz_rawa))
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 由Łukasz Rawa在Unsplash上的图片 ([https://unsplash.com/@lukasz_rawa](https://unsplash.com/@lukasz_rawa))
- en: 'Using standard HTML tags, we could just do the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标准的HTML标签，我们可以这样做：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: However, we may also want to use the `srcset` property for responsive images,
    so we'll actually need to optimize the picture for different screen resolutions,
    which involves some extra steps for serving our assets.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们也可能想要使用`srcset`属性来为响应式图片，因此我们实际上需要为不同的屏幕分辨率优化图片，这涉及到为我们的资产提供服务的一些额外步骤。
- en: 'Next.js makes it very easy by just configuring the `next.config.js` file and
    using the `Image` component. We just said that we want to serve images coming
    from Unsplash, so let''s add that service hostname to our `next.config.js` file,
    under the `images` property:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js通过仅配置`next.config.js`文件和使用`Image`组件，使得这个过程变得非常简单。我们之前提到过，我们想要提供来自Unsplash的图片，所以让我们将这个服务主机名添加到我们的`next.config.js`文件中的`images`属性下：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: That way, every time we use an image coming from that hostname inside an `Image`
    component, Next.js will automatically optimize it for us.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，每次我们在`Image`组件中使用来自该主机名的图片时，Next.js都会自动为我们优化它。
- en: 'Now, let''s try to import that image inside a page:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试在页面中导入这张图片：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Opening the browser, you will notice that the image is stretched to fit both
    the `width` and `height` props specified in your `Image` component.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 打开浏览器，你会注意到图片被拉伸以适应你在`Image`组件中指定的`width`和`height`属性。
- en: '![Figure 3.3 – Representation of the image component we just created'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.3 – 我们刚刚创建的图片组件的表示'
- en: '](img/B16985_03_03.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16985_03_03.jpg)'
- en: Figure 3.3 – Representation of the image component we just created
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – 我们刚刚创建的图片组件的表示
- en: 'We can crop our image to fit the desired dimensions using the optional `layout`
    prop. It accepts four different values: `fixed`, `intrinsic`, `responsive`, and
    `fill`. Let''s look at these in more detail:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用可选的 `layout` 属性裁剪图像以适应所需的尺寸。它接受四个不同的值：`fixed`、`intrinsic`、`responsive`
    和 `fill`。让我们更详细地看看这些：
- en: '`fixed` works just like the `img` HTML tag. If we change the viewport size,
    it will keep the same size, meaning that it won''t provide a responsive image
    for smaller (or bigger) screens.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fixed` 与 `img` HTML 标签的工作方式相同。如果我们更改视口大小，它将保持相同的大小，这意味着它不会为较小（或较大）的屏幕提供响应式图像。'
- en: '`responsive` works in the opposite way to `fixed`; as we resize our viewport,
    it will serve differently optimized images for our screen size.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`响应式`与`固定`相反；当我们调整视口大小时，它会为我们的屏幕尺寸提供不同优化的图片。'
- en: '`intrinsic` is halfway between `fixed` and `responsive`; it will serve different
    image sizes as we resize down our viewport, but it will leave the largest image
    untouched on bigger screens.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`固有`介于 `固定` 和 `响应式` 之间；当我们调整视口大小时，它会提供不同的图像大小，但在大屏幕上会保留最大的图像不变。'
- en: '`fill` will stretch the image according to its parent element''s width and
    height; however, we can''t use `fill` alongside the `width` and `height` props.
    You can use `fill` *or* `width` and `height`).'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fill` 会根据其父元素的宽度和高度拉伸图像；然而，我们不能同时使用 `fill` 和 `width`、`height` 属性。您可以使用 `fill`
    或 `width` 和 `height`）。'
- en: 'So now, if we want to fix our English Setter image to display it properly on
    our screen, we can refactor our `Image` component as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想将我们的英语设定器图像固定显示在我们的屏幕上，我们可以按照以下方式重构我们的 `Image` 组件：
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, we wrapped the `Image` component with a fixed size `div` and
    the CSS `position` property set to `relative`. We also removed both the `width`
    and `height` props from our `Image` component, as it will stretch following its
    parent `div` sizes.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们用固定大小的 `div` 和设置为 `relative` 的 CSS `position` 属性包裹了 `Image` 组件。我们还从我们的
    `Image` 组件中移除了 `width` 和 `height` 属性，因为它们会根据其父 `div` 的大小进行拉伸。
- en: We also added the `objectFit` prop set to `cover` so that it will crop the image
    according to its parent `div` size, and that's the final result.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了设置为 `cover` 的 `objectFit` 属性，以便根据其父 `div` 的大小裁剪图像，这就是最终的结果。
- en: '![Figure 3.4 – Representation of the image component with the layout prop set
    to "fill"'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.4 – 使用布局属性设置为 "fill" 的图像组件表示'
- en: '](img/B16985_03_04.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16985_03_04.jpg)'
- en: Figure 3.4 – Representation of the image component with the layout prop set
    to "fill"
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – 使用布局属性设置为 "fill" 的图像组件表示
- en: 'If we now try to inspect the resulting HTML on the browser, we will see that
    the `Image` component generated many different image sizes, which will be served
    using the `srcset` property of a standard `img` HTML tag:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在尝试在浏览器中检查生成的 HTML，我们将看到 `Image` 组件生成了许多不同的图像大小，这些大小将通过标准 `img` HTML 标签的
    `srcset` 属性提供：
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: One last thing worth mentioning is that if we inspect the image format on Google
    Chrome or Firefox, we will see that it has been served as `WebP`, even if the
    original image served from Unsplash was a `jpeg`. If we now try to render the
    same page on iOS with Safari, Next.js will serve the original `jpeg` format, as
    (at the time of writing) that iOS browser does not yet support the `WebP` format.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后值得一提的是，如果我们使用 Google Chrome 或 Firefox 检查图像格式，我们会看到它已经被作为 `WebP` 提供服务，即使从 Unsplash
    提供的原始图像是 `jpeg`。如果我们现在尝试使用 iOS 上的 Safari 渲染相同的页面，Next.js 将提供原始的 `jpeg` 格式，因为（在撰写本文时）该
    iOS 浏览器尚未支持 `WebP` 格式。
- en: As said at the beginning of this section, Next.js runs automatic image optimization
    on-demand, meaning that if a given image is never requested, it will never be
    optimized.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如本节开头所述，Next.js 会根据需要自动进行图像优化，这意味着如果某个图像从未被请求，它将不会被优化。
- en: The whole optimization phase occurs on the server where Next.js is running.
    If you're running a web app containing tons of images, it could affect your server
    performance. In the next section, we'll see how to delegate the optimization phase
    to external services.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 整个优化阶段都在 Next.js 运行的服务器上完成。如果您正在运行包含大量图像的 Web 应用程序，它可能会影响您的服务器性能。在下一节中，我们将看到如何将优化阶段委托给外部服务。
- en: Running automatic image optimization on external services
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在外部服务上运行自动图像优化
- en: 'By default, automatic image optimization runs on the same server as Next.js.
    Of course, if you''re running your website on a small server with low resources,
    this could potentially affect its performance. For that reason, Next.js allows
    you to run automatic image optimization on external services by setting the `loader`
    option inside your `next.config.js` file:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，自动图像优化是在与 Next.js 相同的服务器上运行的。当然，如果你在一个资源较少的小型服务器上运行你的网站，这可能会影响其性能。因此，Next.js
    允许你通过在 `next.config.js` 文件中设置 `loader` 选项来在外部服务上运行自动图像优化：
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you''re deploying your web app to Vercel, you don''t actually need to set
    up any loader in your `next.config.js` file as Vercel will take care of optimizing
    and serving the image files for you. Otherwise, you can use the following external
    services:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将你的网络应用程序部署到 Vercel，你实际上不需要在 `next.config.js` 文件中设置任何加载器，因为 Vercel 会为你优化和提供图像文件。否则，你可以使用以下外部服务：
- en: 'Akamai: [https://www.akamai.com](https://www.akamai.com)'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Akamai: [https://www.akamai.com](https://www.akamai.com)'
- en: 'Imgix: [https://www.imgix.com](https://www.imgix.com)'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Imgix: [https://www.imgix.com](https://www.imgix.com)'
- en: 'Cloudinary: [https://cloudinary.com](https://cloudinary.com)'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Cloudinary: [https://cloudinary.com](https://cloudinary.com)'
- en: 'If you don''t want to use any of these services, or you want to use your custom
    image optimization server, you can use the `loader` prop directly inside your
    component:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想使用这些服务中的任何一个，或者你想使用你自己的自定义图像优化服务器，你可以在组件内部直接使用 `loader` 属性：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This way, you'll be able to serve images coming from any external service and
    this allows you to take advantage of custom image optimization servers or free,
    open source projects such as *Imgproxy* ([https://github.com/imgproxy/imgproxy](https://github.com/imgproxy/imgproxy))
    or *Thumbor* (https://github.com/thumbor/thumbor).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你将能够提供来自任何外部服务的图像，这让你能够利用自定义图像优化服务器或免费、开源项目，如 *Imgproxy* ([https://github.com/imgproxy/imgproxy](https://github.com/imgproxy/imgproxy))
    或 *Thumbor* (https://github.com/thumbor/thumbor)。
- en: Important Note
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'When you''re using custom loaders, keep in mind that every service has its
    own APIs for resizing and serving images. For instance, to serve an image from
    *Imgproxy*, you would need to call it with the following URL: https://imgproxy.example.com/<auth-key>/fill/500/500/sm/0/plain/https://example.com/images/myImage.jpg.
    With *Thumbor*, you''d need to call it with a different URL schema: [https://thumbor.example.com/500x500/smart/example.com/images/myImage.jpg](https://thumbor.example.com/500x500/smart/example.com/images/myImage.jpg).'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用自定义加载器时，请记住，每个服务都有自己的 API 用于调整图像大小和提供图像。例如，要从 *Imgproxy* 提供图像，你需要使用以下 URL
    调用它：https://imgproxy.example.com/<auth-key>/fill/500/500/sm/0/plain/https://example.com/images/myImage.jpg。对于
    *Thumbor*，你需要使用不同的 URL 架构：[https://thumbor.example.com/500x500/smart/example.com/images/myImage.jpg](https://thumbor.example.com/500x500/smart/example.com/images/myImage.jpg)。
- en: Before creating a custom loader, read the documentation of your image optimization
    server.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建自定义加载器之前，请阅读你的图像优化服务器的文档。
- en: Correctly serving images has become more and more complex during the last years,
    but it is worth spending some time fine-tuning that process as it can affect our
    user experience in many critical ways. Thankfully, Next.js makes it quite effortless
    thanks to its built-in components and optimizations.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，正确提供图像的过程变得越来越复杂，但花些时间微调这个过程是值得的，因为它可以从许多关键方面影响我们的用户体验。幸运的是，Next.js 通过其内置组件和优化使这个过程变得相当简单。
- en: However, we should also think of web scrapers, bots, and web spiders when we're
    building a web app! I'm referring to web technologies that will look at our web
    page's metadata for taking actions such as indexing, linking, and evaluation.
    We'll see how to handle metadata in the next section.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们构建网络应用程序时，我们也应该考虑网络爬虫、机器人和网络蜘蛛！我指的是那些将查看我们网页的元数据以执行索引、链接和评估等操作的网络技术。我们将在下一节中看到如何处理元数据。
- en: Handling metadata
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理元数据
- en: 'Correctly handling metadata is a crucial part of modern web development. To
    keep it simple, let''s think about when we share a link on Facebook or Twitter.
    If we share the React website ([https://reactjs.org](https://reactjs.org)) on
    Facebook, we will see the following card appear inside our post:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 正确处理元数据是现代网络开发的关键部分。为了简化，让我们考虑一下我们在 Facebook 或 Twitter 上分享链接的情况。如果我们把 React
    网站 ([https://reactjs.org](https://reactjs.org)) 分享到 Facebook，我们将在我们的帖子中看到以下卡片：
- en: '![Figure 3.5 – Open Graph data of https://reactjs.org'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.5 – https://reactjs.org 的 Open Graph 数据'
- en: '](img/B16985_03_05.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16985_03_05.jpg)'
- en: Figure 3.5 – Open Graph data of [https://reactjs.org](https://reactjs.org
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – https://reactjs.org 的 Open Graph 数据
- en: )
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: To know which data should be displayed inside the card, Facebook uses a protocol
    called **Open Graph** ([https://ogp.me](https://ogp.me)). In order to give that
    information to any social network or website, we need to add some metadata to
    our pages.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了知道应该显示在卡片内的哪些数据，Facebook 使用了一个名为 **Open Graph** 的协议（[https://ogp.me](https://ogp.me)）。为了将此信息提供给任何社交网络或网站，我们需要在我们的页面上添加一些元数据。
- en: So far, we haven't yet talked about how to set open graph data, HTML titles,
    or HTML meta tags dynamically. While a website could technically work even without
    that data, search engines would penalize your pages, as they would miss important
    information. The user experience could also be negatively affected as these meta
    tags would help the browser create an optimized experience for our users.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有讨论过如何动态设置开放图数据、HTML 标题或 HTML 元数据。虽然一个网站在技术上可以不使用这些数据而工作，但搜索引擎会惩罚你的页面，因为它们会错过重要信息。用户体验也可能受到负面影响，因为这些元标签会帮助浏览器为我们的用户创建优化的体验。
- en: 'Once again, Next.js provides a great way of solving these problems: the built-in
    `Head` component. Indeed, this component allows us to update the `<head>` section
    of our HTML page from any component, meaning that we can dynamically change, add,
    or delete any metadata, link, or script at runtime depending on our user''s navigation.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，Next.js 提供了一种解决这些问题的绝佳方法：内置的 `Head` 组件。确实，这个组件允许我们从任何组件更新我们 HTML 页面的 `<head>`
    部分，这意味着我们可以根据用户的导航动态更改、添加或删除任何元数据、链接或脚本。
- en: 'We can start with one of the most common dynamic parts of our metadata: the
    HTML `<title>` tag. Let''s set up a new Next.js project and then create two new
    pages.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从我们元数据中最常见的动态部分开始：HTML `<title>` 标签。让我们设置一个新的 Next.js 项目，然后创建两个新的页面。
- en: 'The first page we will create is `index.js`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建的第一个页面是 `index.js`：
- en: '[PRE24]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The second page is `about.js`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个页面是 `about.js`：
- en: '[PRE25]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Running the server, you will be able to navigate between those two pages and
    see that the `<title>` content changes depending on the route you're visiting.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 运行服务器后，您可以在这两个页面之间导航，并看到 `<title>` 内容会根据您访问的路由而变化。
- en: Now, let's make things a bit more complex. We want to create a new component
    that only displays a button. Once we click on it, our page title will change depending
    on the page we're currently on; we can always roll back to the original title
    by clicking on the button again.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使事情变得稍微复杂一些。我们想要创建一个新的组件，它只显示一个按钮。一旦我们点击它，我们当前所在的页面标题将改变；我们可以通过再次点击按钮来始终恢复到原始标题。
- en: 'Let''s create a new folder, `components/`, in your project root and a new file,
    `components/Widget.js`, inside it:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在项目根目录中创建一个新的文件夹 `components/`，并在其中创建一个新的文件 `components/Widget.js`：
- en: '[PRE26]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Great! Now let's edit both our `index.js` and `about.js` pages to include that
    component.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在让我们编辑我们的 `index.js` 和 `about.js` 页面，以包含该组件。
- en: 'We''ll start by opening the `index.js` file and importing the `Widget` component
    and then we''re going to render it inside a new `<div>`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先打开 `index.js` 文件，导入 `Widget` 组件，然后我们将将其渲染在一个新的 `<div>` 中：
- en: '[PRE27]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s do the same thing with the `about.js` page:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对 `about.js` 页面做同样的事情：
- en: '[PRE28]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: After this title is refactored, every time we click on `<title>` element.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个标题重构之后，每次我们点击 `<title>` 元素。
- en: Important Note
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'If multiple components are trying to update the same meta tag, Next.js occasionally
    will duplicate the same tag but with different content. For instance, if we have
    two components editing the `<title>` tag, we could end up having two distinct
    `<title>` tags inside our `<head>`. We can avoid that by adding the `key` prop
    to our HTML tags:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多个组件试图更新同一个元标签，Next.js 有时会重复相同的标签，但内容不同。例如，如果我们有两个组件正在编辑 `<title>` 标签，我们最终可能会在我们的
    `<head>` 中有两个不同的 `<title>` 标签。我们可以通过向我们的 HTML 标签添加 `key` 属性来避免这种情况：
- en: '`<title key=''htmlTitle''>some content</title>`. This way, Next.js will look
    for every HTML tag with that specific key and update it instead of adding a new
    one.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`<title key=''htmlTitle''>some content</title>`。这样，Next.js 将寻找带有该特定键的每个 HTML
    标签，并更新它而不是添加一个新的。'
- en: So far, we've seen how to handle metadata inside our pages and components, but
    there are cases where you want to use the same meta tags on different components.
    In those cases, you may not want to rewrite all the metadata from scratch for
    each component, so here comes the concept of grouping metadata by creating a whole
    component just for handling that kind of HTML tag. We'll take a closer look at
    this approach in the next section.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何在页面和组件中处理元数据，但在某些情况下，您可能希望在不同的组件上使用相同的元标签。在这些情况下，您可能不想为每个组件从头开始重写所有元数据，因此出现了通过创建一个专门用于处理这种HTML标签的整个组件来分组元数据的概念。我们将在下一节中更详细地探讨这种方法。
- en: Grouping common meta tags
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将常见的元标签分组
- en: At this point, we may want to add many other meta tags to our website to improve
    its SEO performance. The problem is that we could easily end up creating huge
    page components containing basically the same tags. For that reason, it is common
    practice to create one or more components (depending on your needs) to handle
    most of the common `head` meta tags.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可能想要向我们的网站添加许多其他元标签以提高其SEO性能。问题是，我们很容易就创建出包含基本上相同标签的大型页面组件。因此，创建一个或多个组件（根据您的需求而定）来处理大多数常见的
    `head` 元标签是一种常见的做法。
- en: Let's say that we want to add a blog section to our website. We may want to
    add support for open graph data, Twitter cards, and other metadata for our blog
    posts, so we could easily group all this common data inside a `PostHead` component.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想在网站上添加一个博客部分。我们可能希望为我们的博客帖子添加对开放图数据、Twitter卡片和其他元数据的支持，这样我们就可以轻松地将所有这些常见数据组合在一个
    `PostHead` 组件中。
- en: 'Let''s create a new file, `components/PostHead.js`, and add the following script:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的文件，`components/PostHead.js`，并添加以下脚本：
- en: '[PRE29]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, let''s create a mock for our posts. We will create a new folder called
    `data` and a file called `posts.js` inside it:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为我们的帖子创建一个模拟。我们将在 `data` 文件夹中创建一个新的文件夹，并创建一个名为 `posts.js` 的文件：
- en: '[PRE30]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Great! Now we only need to create a `[slug]` page to display our posts. The
    full route will be `/blog/[slug]`, so let''s create a new file called `[slug].js`
    inside `pages/blog/` and add the following content:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在我们只需要创建一个 `[slug]` 页面来显示我们的帖子。完整的路由将是 `/blog/[slug]`，所以让我们在 `pages/blog/`
    中创建一个名为 `[slug].js` 的新文件，并添加以下内容：
- en: '[PRE31]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If we now go to http://localhost:3000/blog/dog-of-the-day-the-english-setter
    and inspect the resulting HTML, we will see the following tags:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在访问 http://localhost:3000/blog/dog-of-the-day-the-english-setter 并检查生成的HTML，我们将看到以下标签：
- en: '[PRE32]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, try to browse other blog posts and see how the HTML content changes for
    each one of them.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试浏览其他博客帖子，看看每个帖子的HTML内容是如何变化的。
- en: This approach is not mandatory, but it allows you to logically separate head-related
    components from other components, leading to a more organized code base.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法不是强制性的，但它允许您逻辑上分离与头部相关的组件和其他组件，从而使得代码库更加有序。
- en: But what if we need the same meta tags (or, at least, some common basic data)
    on every page? We don't actually need to rewrite every single tag or import a
    common component on each page. We'll see in the next section how to avoid that
    by customizing our `_app.js` file.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们需要在每个页面上都有相同的元标签（或者至少是一些常见的基本数据）怎么办？我们实际上不需要在每个页面上重写每个标签或导入一个通用组件。我们将在下一节中看到如何通过自定义我们的
    `_app.js` 文件来避免这种情况。
- en: Customizing _app.js and _document.js pages
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义 `_app.js` 和 `_document.js` 页面
- en: There are certain cases where you need to take control over page initialization,
    so that every time we render a page, Next.js will need to run certain operations
    before sending the resulting HTML to the client. To do that, the framework allows
    us to create two new files, called `_app.js` and `_document.js`, inside our `pages/`
    directory.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您需要控制页面初始化，以便每次渲染页面时，Next.js都需要在向客户端发送结果HTML之前运行某些操作。为此，该框架允许我们在 `pages/`
    目录中创建两个新文件，分别称为 `_app.js` 和 `_document.js`。
- en: The _app.js page
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`_app.js` 页面'
- en: 'By default, Next.js ships with the following [pages/_app.js](http://pages/_app.js)
    file:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Next.js附带以下[pages/_app.js](http://pages/_app.js)文件：
- en: '[PRE33]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see, the function is just returning the Next.js page component (the
    `Component` prop) and its props (`pageProps`).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，该函数只是返回Next.js页面组件（`Component`属性）及其属性（`pageProps`）。
- en: 'But now, let''s say that we want to share a navigation bar between all the
    pages without manually importing that component on each page. We can start by
    creating the navbar inside `components/Navbar.js`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在，假设我们想在所有页面上共享一个导航栏，而不需要在每个页面上手动导入该组件。我们可以从在 `components/Navbar.js` 中创建导航栏开始：
- en: '[PRE34]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: That is a really simple navigation bar with just three links that will allow
    us to navigate our website.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 那是一个非常简单的导航栏，只有三个链接，这将允许我们在网站上导航。
- en: 'Now, we need to import it inside our `_app.js` page as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在 `_app.js` 页面中导入它，如下所示：
- en: '[PRE35]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If we now create two more pages (`about.js` and `contacts.js`), we will see
    that the navbar component will be rendered on any page.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在再创建两个页面（`about.js` 和 `contacts.js`），我们会看到导航栏组件将在任何页面上渲染。
- en: Now, let's make it a bit more complex by adding support for both dark and light
    themes. We'll do that by creating a React context and wrapping the `<Component
    />` component inside our `_app.js` file.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过添加对暗色和亮色主题的支持使其变得更加复杂。我们将通过创建一个 React 上下文并在我们的 `_app.js` 文件中包裹 `<Component
    />` 组件来实现这一点。
- en: 'Let''s start by creating a context in `components/themeContext.js`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在 `components/themeContext.js` 中创建一个上下文开始：
- en: '[PRE36]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now let''s go back to our `_app.js` file and create the theme state, inline
    CSS styles, and wrap the page component in a context provider:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到我们的 `_app.js` 文件，创建主题状态，内联 CSS 样式，并将页面组件包裹在一个上下文提供者中：
- en: '[PRE37]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Last but not least, we need to add a button for toggling dark/light themes.
    We''re going to add it to our navigation bar, so let''s open the `components/Navbar.js`
    file and add the following code:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们需要添加一个按钮来切换暗色/亮色主题。我们将将其添加到导航栏中，所以让我们打开 `components/Navbar.js` 文件并添加以下代码：
- en: '[PRE38]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If you try to toggle the dark theme, and then navigate between all the website
    pages using the navigation bar, you will see that Next.js keeps the theme state
    consistent between every route.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试切换暗色主题，然后使用导航栏在所有网站页面之间导航，你会看到 Next.js 在每个路由之间保持主题状态的一致性。
- en: One important thing to remember when customizing the `_app.js` page is that
    it is not meant for running data fetching using `getServerSideProps` or `getStaticProps`,
    as other pages do. Its main use cases are maintaining state between pages during
    navigation (dark/light themes, items in a cart, and so on), adding global styles,
    handling page layouts, or adding additional data to the page props.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在自定义 `_app.js` 页面时，有一件重要的事情需要记住，它不是为了使用 `getServerSideProps` 或 `getStaticProps`
    运行数据获取而设计的，就像其他页面那样。它的主要用例是在导航期间在页面之间维护状态（暗色/亮色主题、购物车中的项目等）、添加全局样式、处理页面布局或向页面
    props 添加附加数据。
- en: If, for some reason, you absolutely need to fetch data on the server side every
    time you want to render a page, you can still use the built-in `getInitialProps`
    function, but it has a cost. You'll lose automatic static optimization in dynamic
    pages, as Next.js will need to perform server-side rendering for every single
    page.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出于某种原因，你绝对需要在每次渲染页面时在服务器端获取数据，你仍然可以使用内置的 `getInitialProps` 函数，但这样做是有代价的。你将失去动态页面中的自动静态优化，因为
    Next.js 将需要为每个页面执行服务器端渲染。
- en: 'If that cost is acceptable for your web app, you can easily use that built-in
    method as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个代价对你的 Web 应用来说是可接受的，你可以很容易地按照以下方式使用那个内置方法：
- en: '[PRE39]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: While a custom `_app.js` file allows us to customize the way we render page
    components, there might be cases where it cannot help; for example, when we need
    to customize HTML tags such as `<html>` or `<body>`. We will learn how to do that
    right in the next section.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个自定义 `_app.js` 文件允许我们自定义渲染页面组件的方式时，可能会有一些情况它无法帮助；例如，当我们需要自定义 HTML 标签，如 `<html>`
    或 `<body>` 时。我们将在下一节中学习如何做到这一点。
- en: The _document.js page
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`_document.js` 页面'
- en: When we're writing Next.js page components, we don't need to define fundamental
    HTML tags, such as `<head>`, `<html>`, or `<body>`. We've already seen how to
    customize the `<head>` tag using the `Head` component, but we will need a change
    of approach for both `<html>` and `<body>`tags.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写 Next.js 页面组件时，我们不需要定义基本的 HTML 标签，如 `<head>`、`<html>` 或 `<body>`。我们已经看到如何使用
    `Head` 组件来自定义 `<head>` 标签，但我们需要对 `<html>` 和 `<body>` 标签采取不同的方法。
- en: 'In order to render those two essential tags, Next.js uses a built-in class
    called `Document`, and it allows us to extend it by creating a new file called
    `_document.js` inside our `pages/` directory, just like we do for our `_app.js`
    file:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 为了渲染这两个基本标签，Next.js 使用一个名为 `Document` 的内置类，它允许我们通过在 `pages/` 目录中创建一个名为 `_document.js`
    的新文件来扩展它，就像我们对 `_app.js` 文件所做的那样：
- en: '[PRE40]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let''s break down the `_document.js` page we''ve just created. First, we start
    by importing the `Document` class, which we''re going to extend to add our custom
    scripts. We then import four mandatory components in order for our Next.js application
    to work:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下我们刚刚创建的 `_document.js` 页面。首先，我们通过导入 `Document` 类开始，我们将扩展这个类来添加我们的自定义脚本。然后，我们导入四个强制组件，以便我们的
    Next.js 应用程序能够正常工作：
- en: '`Html`: The `<html>` tag for our Next.js application. We can pass any standard
    HTML property (such as `lang`) to it as a prop.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Html`: 这是我们的Next.js应用的`<html>`标签。我们可以将其任何标准HTML属性（如`lang`）作为属性传递给它。'
- en: '`Head`: We can use this component for all the tags common to all the application
    pages. This is *not* the `Head` component we''ve seen in the previous chapter.
    They behave similarly, but we should use it only for code that is common to all
    the website pages.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Head`: 我们可以使用这个组件来处理所有应用页面共有的标签。这**不是**我们在上一章中看到的`Head`组件。它们的行为相似，但我们应该只将其用于所有网站页面共有的代码。'
- en: '`Main`: This will be the place where Next.js renders our page components. The
    browser won''t initialize every component outside `<Main>`, so if we need to share
    common components between our pages, we should place them inside the `_app.js`
    file.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Main`: 这将是Next.js渲染我们页面组件的地方。浏览器不会初始化`<Main>`之外的所有组件，所以如果我们需要在页面之间共享通用组件，我们应该将它们放在`_app.js`文件中。'
- en: '`NextScript`: If you''ve tried to inspect an HTML page generated by Next.js,
    you may have noticed that it adds some custom JavaScript scripts to your markup.
    Inside those scripts, we can find all the code required to run client-side logic,
    React hydration, and so on.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NextScript`: 如果你尝试检查由Next.js生成的HTML页面，你可能已经注意到它添加了一些自定义JavaScript脚本到你的标记中。在这些脚本内部，我们可以找到运行客户端逻辑、React
    hydration等所需的所有代码。'
- en: Removing any of the preceding four components will break our Next.js application,
    so make sure to import them before editing your `_document.js` page.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 移除前面提到的任何四个组件都会破坏我们的Next.js应用，所以在编辑`_document.js`页面之前，请确保导入它们。
- en: Just like `_app.js`, `_document.js` does not support server-side data fetching
    methods such as `getServerSideProps` and `getStaticProps`. We still get access
    to the `getInitialProps` method, but we should avoid putting data fetching functions
    inside it as this would disable automatic site optimization, forcing the server
    to server-side render the page on each request.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`_app.js`一样，`_document.js`不支持服务器端数据获取方法，如`getServerSideProps`和`getStaticProps`。我们仍然可以访问`getInitialProps`方法，但我们应该避免在其中放置数据获取函数，因为这会禁用自动站点优化，迫使服务器在每次请求时都进行服务器端渲染页面。
- en: Summary
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've covered many important concepts that make Next.js a great
    framework to work with. We now know how to serve images correctly and with minimum
    effort, navigate between pages by pre-fetching the destination page, dynamically
    create and delete custom metadata, and create dynamic routes to make the user
    experience even more dynamic. We've also taken a look at customizing the `_app.js`
    and `_document.js` files, which will allow us to keep our user interface consistent
    between all the application pages with minimum effort.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了许多使Next.js成为一个出色的框架的重要概念。我们现在知道如何以最少的努力正确地提供图像，通过预取目标页面在页面之间导航，动态创建和删除自定义元数据，以及创建动态路由以使用户体验更加动态。我们还查看了对`_app.js`和`_document.js`文件的定制，这将使我们能够以最少的努力在所有应用页面之间保持用户界面的一致性。
- en: So far, we've always avoided calling external REST APIs, as it introduces an
    extra layer of complexity for our application. We will cover this topic in the
    next chapter, understanding how to integrate *REST* and *GraphQL* APIs on both
    the client and server sides.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直避免调用外部REST API，因为这给我们的应用引入了额外的复杂性。我们将在下一章中介绍这个主题，了解如何在客户端和服务器端集成*REST*和*GraphQL*
    API。
