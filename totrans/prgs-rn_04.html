<html><head></head><body>
		<div id="_idContainer020">
			<h1 id="_idParaDest-61" class="chapter-number"><a id="_idTextAnchor079"/>4</h1>
			<h1 id="_idParaDest-62"><a id="_idTextAnchor080"/>Styling, Storage, and Navigation in React Native</h1>
			<p>Now that you know the general concepts behind React Native, it’s time to have a deeper look at the most common areas of React Native.</p>
			<p>This chapter covers different areas, all of which are important when working with React Native. When creating a large app with React Native, you always have to have a good understanding of how the styling of your app works to create a beautiful product. Besides styling, there is another thing that decides if users will like your app from an aesthetic point of view – <strong class="bold">animation</strong>. However, this will be covered in <a href="B16694_06.xhtml#_idTextAnchor130"><em class="italic">Chapter 6</em></a>, <em class="italic">Working with Animations</em>.</p>
			<p>Another thing we will focus on in this chapter is how to store data locally on users’ devices. Every platform works differently. While Android and iOS are quite similar and you can get access to the device’s storage with huge capacity, this is completely different when working with the web, where capacity is very limited.</p>
			<p>The last thing we’ll cover is how to navigate between screens in your React Native app. Again, this can differ from platform to platform, but you’ll get a good overview of the different navigation concepts.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Understanding how to style a React Native app</li>
				<li><a id="_idTextAnchor081"/><a id="_idTextAnchor082"/>Using local storage solutions in React Native</li>
				<li>Understanding navigation in React Native</li>
			</ul>
			<h1 id="_idParaDest-63"><a id="_idTextAnchor083"/>Technical requirements</h1>
			<p>To be able to run the code in this chapter, you must set up the following:</p>
			<ul>
				<li>A working React Native environment (<a href="https://reactnative.dev/docs/environment-setup">https://reactnative.dev/docs/environment-setup</a> – React Native CLI Quickstart)</li>
				<li>While most of this chapter should also work on Windows, I recommend working on a Mac</li>
			</ul>
			<h1 id="_idParaDest-64"><a id="_idTextAnchor084"/>Understanding how to style a React Native app</h1>
			<p>You can choose from different solutions to handle styling in your React Native app. But before we take a <a id="_idIndexMarker226"/>look at the most common ones, you must understand the underlying concepts. The first thing we’ll cover in this chapter is what all these solutions try to achieve.</p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor085"/>Make styling maintainable</h2>
			<p>Styling is often handled very poorly when a project starts because it does not interfere with the business logic, so it isn’t likely to introduce bugs. So, most of the time, when thinking about the architecture of an application, most developers think of state management, data flow, component structure, and more, but not about styling. This always takes its toll when a project grows. It starts to take more and more time to keep a consistent design and making changes to your UI becomes a real pain.</p>
			<p>Therefore, you should think about how to handle styling in your application right at the beginning. No matter <a id="_idIndexMarker227"/>what solution or library you use, you should always stick to the following concepts:</p>
			<ul>
				<li><strong class="bold">Use a central file for colors, fonts, and sizes</strong>: This should either be a single file or one file for colors, one for fonts, and one for sizes such as margins, paddings, and border radiuses. I prefer to use a single file.</li>
				<li><strong class="bold">Never hardcode values in your components/CSS files</strong>: You should never use fixed values inside your component. Always use the values you define in your central file. This guarantees that your UI stays consistent and that you can easily change the values if you have to adapt.</li>
				<li><strong class="bold">Never duplicate code</strong>: When you catch yourself copying the styling of parts of a component because it’s easier, faster, or more convenient, always keep in mind that it isn’t in the long run. Duplicate code always leads to inconsistencies in the UI and <a id="_idIndexMarker228"/>makes you have to touch multiple files when you want to change something later. So, instead of copying and pasting your code, extract it to a component or styles file. You will learn more about these options later.</li>
			</ul>
			<p>When we come back to our example project with these concepts, we will have to refactor it because, at the <a id="_idIndexMarker229"/>moment, we violate all of these concepts. We have no central file; we have hardcoded values everywhere and we have a <strong class="source-inline">backButton</strong> style defined in multiple files.</p>
			<p>First, let’s create a central file to store our values. This could look like this:</p>
			<pre class="source-code">
import {Appearance} from 'react-native';
const isDarkMode = Appearance.getColorScheme() === 'dark';
const FontConstants = {
  familyRegular: 'sans-serif',
  sizeTitle: 18,
  sizeRegular: 14,
  weightBold: 'bold',
};
const ColorConstants = {
  background: isDarkMode ? '#333333' : '#efefef',
  backgroundMedium: isDarkMode ? '#666666' : '#dddddd',
  font: isDarkMode ? '#eeeeee' : '#222222',
};
const SizeConstants = {
  paddingSmall: 2,
  paddingRegular: 8,
  paddingLarge: 16,
  borderRadius: 8,
};
export {FontConstants, ColorConstants, SizeConstants};</pre>
			<p>As you can see, we have all our values in one single place. If you take a deeper look, we also introduced dark mode to our app, which was a 3-minute task with our central color store. We only have to get the information about the device appearance settings and deliver the colors accordingly.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can test your app in dark mode very easily on the iOS Simulator. Go to <strong class="bold">Settings</strong>, scroll to the bottom, and choose <strong class="bold">Developer</strong>. The <strong class="bold">Developer</strong> screen will open; the first toggle activates <strong class="bold">Dark Appearance</strong>. If you support dark mode with our app, you should always test on two simulators – one in the dark mode and one in the light mode.</p>
			<p>Now that we <a id="_idIndexMarker230"/>have our central store, let’s create a <strong class="source-inline">&lt;BackButton /&gt;</strong> component to get rid of the duplicated style definitions. This can look like this:</p>
			<pre class="source-code">
interface BackButtonProps{
  text: string;
  onPress: () =&gt; void;
}
const BackButton = (props: BackButtonProps) =&gt; {
  return (
    &lt;Pressable onPress={props.onPress}
      style={styles.backButton}&gt;
      &lt;Text&gt;{props.text}&lt;/Text&gt;
    &lt;/Pressable&gt;
  );
};
const styles = StyleSheet.create({
  backButton: {
    padding: SizeConstants.paddingLarge,
    marginBottom: SizeConstants.paddingLarge,
    backgroundColor: ColorConstants.backgroundMedium,
  },
});</pre>
			<p>In our newly created component, we don’t use fixed values anymore, but we are referencing the values in our central store.</p>
			<p>Lastly, we have to go through our app, replace the <strong class="source-inline">backButton</strong> pressables with our new component, and replace the fixed values with references to our central store. With that, we have complied with the concepts.</p>
			<p>These concepts are the core of different libraries or solutions. To choose the right solution for your <a id="_idIndexMarker231"/>project, one of the most important decisions is which platform to deploy to. The following subsection will cover the most common solutions, including information about which platform the solution works best on.</p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor086"/>Choosing the right styling solution</h2>
			<p>In this subsection, we’ll <a id="_idIndexMarker232"/>have a look at inline styling, React Native StyleSheets, CSS modules, and styled-components. All four solutions work well and have their benefits and drawbacks. We’ll start with inline styles.</p>
			<h3>Using React Native inline styles</h3>
			<p>To understand inline styles, let’s <a id="_idIndexMarker233"/>have a look at a code example. The following code shows the <strong class="source-inline">&lt;Header /&gt;</strong> component from our example project from the previous chapter but it uses inline styles to style the <strong class="source-inline">Text</strong> component:</p>
			<pre class="source-code">
const Header = (props: HeaderProps) =&gt; {
  return &lt;Text style={{
          fontSize: 18,
          fontWeight: 'bold',
          marginBottom: 16}
        }&gt;
            {props.text}
        &lt;/Text&gt;;
};</pre>
			<p>As you can see, we can just create an object with the styling rules. This works and has a big advantage. Not only can you use fixed values, but you can also use any static or dynamic value you can access in your component. This can be very useful, especially when you are working with user-defined themes. But this approach also comes with multiple disadvantages.</p>
			<p>First, the code gets quite confusing when the project grows – at least, I think the code is hard to read when styling, components, and data are mixed in that way. So, I would always prefer to separate this as much as possible.</p>
			<p>Next, you cannot reuse any styling. You must copy your styles every time you need them again. Now, you <a id="_idIndexMarker234"/>could argue that you wouldn’t have to copy the styles because you can simply extract the component that includes the style into a custom component. Although this is correct, there are some cases where you don’t want to do this. We’ll have a deeper look at these scenarios in the next subsection.</p>
			<p>Next, we must think about performance. Inline style objects will be recreated at every render, which can negatively impact the performance and memory usage of your app.</p>
			<p>Last, we’ll have a look at the different platforms. This inline style approach has very little room for optimization on build time for the different platforms. While this may be no real problem on Android, iOS, Windows, and macOS, it can become a real pain for the web because it makes your bundle size a lot larger.</p>
			<p>On the web, you must think about load times a lot because the user has no installed version of your application. Also, search engines such as Google care a lot about load times, and it will <a id="_idIndexMarker235"/>affect your ranking positively or negatively. So, your styling code must be optimized during the build process, which is not possible with inline styles.</p>
			<p>To take advantage of optimization, you’ll have to use StyleSheets. We’ll have a look at them next.</p>
			<h3>Using React Native StyleSheets</h3>
			<p>We used StyleSheets in <a id="_idIndexMarker236"/>our example app in the previous chapter, but we’ll have a look at them again here to truly understand their benefits. Not only do they make the code more readable and support a good separation of styling and business logic, but they also make it possible to use a lot of performance optimization at the build time and runtime of your app.</p>
			<p>The following code is for the <strong class="source-inline">&lt;Header /&gt;</strong> component from our example app. It uses React Native StyleSheets for styling:</p>
			<pre class="source-code">
const Header = (props: HeaderProps) =&gt; {
  return &lt;Text style={styles.title}&gt;{props.text}&lt;/Text&gt;;
};
const styles = StyleSheet.create({
  title: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 16,
  },
});</pre>
			<p>There are multiple things you should realize when looking at this code:</p>
			<ul>
				<li>First, it is much clearer and better separated.</li>
				<li>Second, <strong class="source-inline">StyleSheet</strong> is defined outside of the component, which makes it persist between rerenders. This is better in terms of performance and memory usage.</li>
				<li>Third, <strong class="source-inline">StyleSheet.create</strong> will create errors in your simulator when you are using styles that can’t be interpreted. This can be very useful for catching bugs at a very early stage.</li>
			</ul>
			<p>But the biggest benefit of StyleSheets is the possibility to optimize your styling code for the web. The open source <a id="_idIndexMarker237"/>web library known as react-native-web does a great job of splitting all the StyleSheets of your application into classes and adding the needed class names to your components. This makes your code small and optimized and improves your load time a lot.</p>
			<p>Besides all these benefits, there <a id="_idIndexMarker238"/>is one problem with StyleSheets. Since <a id="_idIndexMarker239"/>they are declared outside of your component, you cannot access your component variables, such as state and props. This means that if you want to use a user-generated value in your styling, you have to combine your StyleSheet values with inline styles, like this:</p>
			<pre class="source-code">
&lt;Text style={[styles.title, {color:props.color}]}&gt;{props.text}&lt;/Text&gt;</pre>
			<p>This code would use the <strong class="source-inline">title</strong> style from the StyleSheet and add a user-defined color to the <strong class="source-inline">&lt;Text /&gt;</strong> component. This combined approach can also be used when working with animations. You can read more about this in <a href="B16694_06.xhtml#_idTextAnchor130"><em class="italic">Chapter 6</em></a>, <em class="italic">Working with Animations</em>.</p>
			<p>Last, we’ll have a look at another benefit of StyleSheets. You can use a style multiple times in your component. Again, if you stick to my recommendations, you will never have to do that because you will be creating a custom component in these scenarios. But for daily work, there are circumstances where it is faster to not create a component and where it also does not hurt.</p>
			<p>For example, if you have a simple component with two lines of text, you can either create a <strong class="source-inline">&lt;TextLine /&gt;</strong> component and use it two times, or simply use two <strong class="source-inline">&lt;Text /&gt;</strong> components with the same style reference in a StyleSheet.</p>
			<p>This first approach with the <strong class="source-inline">&lt;TextLine /&gt;</strong> component is the cleaner one, but the second approach will save you some time and does not create problems in the long run. So, in this case, StyleSheets have another benefit versus inline styles.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Always be careful when you use the same style multiple times. While it can be useful, in many cases, you duplicate code that should be extracted into a custom component.</p>
			<p>Now that <a id="_idIndexMarker240"/>we understand this built-in solution, let’s look at two solutions that need external libraries.</p>
			<h3>Styling with CSS modules</h3>
			<p>CSS modules are <a id="_idIndexMarker241"/>very popular on the web. You <a id="_idIndexMarker242"/>use CSS, Sass, or Less to style your components. In most cases, you would end up having one additional style file per component. Experts often argue if that’s good or bad.</p>
			<p>You have an additional file, but you have a clear separation between styling and components. I do like the separation, but if you manage to split your application into small components, adding the style directly to the component is fine from my point of view.</p>
			<p>Using CSS modules in React Native needs some additional configuration. Since React Native does not have a built-in CSS processor, you must transform your CSS code into JavaScript styles before it can be displayed. This can be done with the babel transformer.</p>
			<p>CSS modules can be a great choice if you share your styles between React (the web) and React Native projects, without using react-native-web to generate the web part. This is especially true when you are building an app for an existing web application.</p>
			<p>One very important problem with this approach is that you can’t use your JavaScript variables in your CSS modules. Even though you can create and use CSS variables, this does not enable you to use user-generated values in your styles.</p>
			<p>If you start a green field project for Android, iOS, Windows, or Mac, I wouldn’t recommend using CSS modules since, for these platforms, the CSS module approach has no benefits over StyleSheets. Again, the only scenario where I would recommend using CSS modules is when you build an app for an existing web application that is based on CSS modules.</p>
			<p>There is also <a id="_idIndexMarker243"/>another solution that is very popular for <a id="_idIndexMarker244"/>React web projects that <a id="_idIndexMarker245"/>can be used in React Native. It’s called <strong class="bold">styled-components</strong> and you’ll learn about it in the next subsection.</p>
			<h3>Understanding styled-components</h3>
			<p><strong class="bold">styled-components</strong> is a very <a id="_idIndexMarker246"/>popular library for styling React web <a id="_idIndexMarker247"/>applications. It also has very good support for React Native and can be a good choice in some cases. The styled-component approach uses the component approach through to the end. Instead of styling the primitive components such as <strong class="source-inline">View</strong> and <strong class="source-inline">Text</strong>, you enhance them with tagged template literals to create new components, called styled-components.</p>
			<p>The following code shows the <strong class="source-inline">&lt;Header /&gt;</strong> component in our example project but styled with styled-components:</p>
			<pre class="source-code">
import styled from 'style<a id="_idTextAnchor087"/><a id="_idTextAnchor088"/>d-components/native';
const Header = (props: HeaderProps) =&gt; {
  return &lt;StyledText&gt;{props.text}&lt;/StyledText&gt;;
};
const StyledText = styled.Text`
  font-size: ${FontConstants.sizeTitle};
  font-weight: ${FontConstants.weightBold};
  margin-bottom: ${SizeConstants.paddingLarge};
  color: ${ColorConstants.font};
`;</pre>
			<p>As you can see, we create the <strong class="source-inline">StyledText</strong> component by using <strong class="source-inline">styled</strong> from styled-components and add a template literal to the React Native <strong class="source-inline">Text</strong> component. Inside this literal, we can write plain CSS. The cool thing here is that we can also use JavaScript variables and we can even pass props to our styled-component. This would look like this:</p>
			<pre class="source-code">
&lt;StyledText primary&gt;{props.text}&lt;/StyledText&gt;;</pre>
			<p>This is how we would pass a property to our <strong class="source-inline">StyledText</strong> component. Now, we can use this property inside our template literal:</p>
			<pre class="source-code">
const StyledText = styled.Text`
  font-size: ${props =&gt; props.primary ?
                          FontConstants.sizeTitle :
                            FontConstants.sizeRegular};
`;</pre>
			<p>This function is called <strong class="bold">interpolation</strong> and makes it possible to use user-generated content <a id="_idIndexMarker248"/>inside the CSS of our styled-components.</p>
			<p>This is awesome because it solves a lot of problems, supports a clear separation between structure and styling, and allows us to use regular CSS, which is more familiar to most developers than the camel-cased CSS in the JavaScript of StyleSheets.</p>
			<p>While I like this approach for the web, I remain critical of it for app-only projects. The styled-components <a id="_idIndexMarker249"/>library has a lot of useful optimization features <a id="_idIndexMarker250"/>for the web, but on pure React Native projects, it also compiles to CSS in JavaScript styles. In addition, it doesn’t provide support for animations, which is a very important part of modern apps. You can read more about this in <a href="B16694_06.xhtml#_idTextAnchor130"><em class="italic">Chapter 6</em></a>, <em class="italic">Working with Animations</em>.</p>
			<p>Although I wouldn’t recommend using styled-components for pure React Native projects, they can be very useful when you try to share your styling code between React Native and React projects, without using react-native-web. In this case, you can benefit from styled-components a lot.</p>
			<p>If you want to <a id="_idIndexMarker251"/>have a deeper look at styled-components, I recommend reading the official documentation at <a href="https://styled-components.com/docs">https://styled-components.com/docs</a>.</p>
			<p>In this section, we learned the most important concepts of styling your React Native app and looked at the most common solutions to implement the styles. Most of the time, you wouldn’t write all your styles on your own but use a UI library. This will be handled in <a href="B16694_09.xhtml#_idTextAnchor282"><em class="italic">Chapter 9</em></a>, <em class="italic">Essential Tools for Improving React Native Development</em>.</p>
			<p>If you want to <a id="_idIndexMarker252"/>see all changes to the example project, please have a look <a id="_idIndexMarker253"/>at the repository for this example project and choose the <strong class="source-inline">chapter-4-styling</strong> tag.</p>
			<p>Now that we know how to style our app, it’s time to store some data on the user’s device.</p>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor089"/>Using local storage solutions in React Native</h1>
			<p>Storing data locally is <a id="_idIndexMarker254"/>a very important task in <a id="_idIndexMarker255"/>mobile apps. Even nowadays, you cannot be sure that a mobile device is always connected to the internet. Because of this, it is best practice to create your app in such a way that it has as much functionality as possible, even without a connection to the internet. That said, you can see why storing data locally is important for React Native apps.</p>
			<p>The most important criterion for differentiation for local storage solutions is if it is a secure or an unsecure storage solution. Since most apps store at least some information about the user, you should always think about which information you want to put in which store.</p>
			<p class="callout-heading">Important</p>
			<p class="callout">Always use a secure storage solution to store sensitive information.</p>
			<p>While it is important to store sensitive data in a secure store, most data, such as user progress, app content, and more, can be stored in a <em class="italic">normal</em> storage solution. Secure storage operations always come with some overhead due to encryption/decryption and/or accessing special device functionalities, so you should only use them for sensitive information to prevent a negative impact on your app’s performance.</p>
			<p>In the following subsection, you will learn about the most common storage solutions for normal data.</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor090"/>Storing non-sensitive data</h2>
			<p>For a long time, React Native <a id="_idIndexMarker256"/>shipped with its built-in <a id="_idIndexMarker257"/>storage solution called AsyncStorage. But since the React Native core team at Facebook tried to reduce the React Native core to the minimum (lean core), AsyncStorage was handed over to the community for further development.</p>
			<p>Nevertheless, it is <a id="_idIndexMarker258"/>very well maintained and most <a id="_idIndexMarker259"/>likely the most used storage solution. Besides <strong class="source-inline">AsyncStorage</strong>, other common solutions include <strong class="source-inline">react-native-mmkv</strong>/<strong class="source-inline">react-native-mmkv-storage</strong>, <strong class="source-inline">react-native-sqlite-<a id="_idTextAnchor091"/><a id="_idTextAnchor092"/>storage</strong>/<strong class="source-inline">react-native-quick-sqlite</strong> and <strong class="source-inline">react-native-fs</strong>. All these solutions have their strengths and weaknesses, work completely differently, and can be used for slightly different tasks. Let’s start with the most popular one.</p>
			<h3>Working with AsyncStorage</h3>
			<p><strong class="source-inline">AsyncStorage</strong> is a simple <a id="_idIndexMarker260"/>key/value store that <a id="_idIndexMarker261"/>can be used to store data. While it can only store primitive <a id="_idIndexMarker262"/>data, you must serialize complex objects to JSON before storing them. Nevertheless, it is very simple to use. The API looks like this:</p>
			<pre class="source-code">
import AsyncStorage from '@react-native-async-storage/async-storage';
// set item
const jsonValue = JSON.stringify(value)
await AsyncStorage.setItem('@key', jsonValue)
// get item
const strValue = await AsyncStorage.getItem('@key')
const jsonValue = strValue != null ? JSON.parse(strValue) : null</pre>
			<p>As you can see, there are very simple APIs for setting and getting data.</p>
			<p><strong class="source-inline">AsyncStorage</strong> is not encrypted and cannot be used to run complex queries. It is a simple key/value store; there is no database. Also, it does not support transactions or locking. This means you have to be extremely careful when you write/read to/from different parts of your application.</p>
			<p>I recommend using it to store user progress, information about app content, and any other data that does <a id="_idIndexMarker263"/>not have to be searchable. For more <a id="_idIndexMarker264"/>information on installing and <a id="_idIndexMarker265"/>using <strong class="source-inline">AsyncStorage</strong>, please look at the official documentation at <a href="https://react-native-async-storage.github.io/async-storage/docs/install/">https://react-native-async-storage.github.io/async-storage/docs/install/</a>.</p>
			<p>A relatively new alternative to <strong class="source-inline">AsyncStorage</strong> is MMKV for React Native. It is up to 30 times faster and comes with a lot more features.</p>
			<h3>Working with MMKV in React Native</h3>
			<p><strong class="bold">MMKV</strong> is a native <a id="_idIndexMarker266"/>storage solution developed by WeChat and <a id="_idIndexMarker267"/>used in their production app. There are multiple React <a id="_idIndexMarker268"/>Native wrappers for this native solution; most of them are already based on JSI and therefore support synchronous and super-fast access.</p>
			<p>Like <strong class="source-inline">AsyncStorage</strong>, MMKV is a simple key/value store. This means complex objects must be serialized to JSON strings before they can be stored. The API is nearly as simple as <strong class="source-inline">AsyncStorage</strong>:</p>
			<pre class="source-code">
import { MMKV } from 'react-native-mmkv'
export const storage = new MMKV()
// set data
const jsonValue = JSON.stringify(value)
storage.set('@key', jsonValue)
// get data
const strValue = storage.getString('@key')
const jsonValue = strValue!= null ? JSON.parse(strValue) : null</pre>
			<p>As you can see, thanks to JSI, the API is synchronous, so we don’t need to work with async/await syntax. In the second line, you can see the initialization of the store. This is one advantage over <strong class="source-inline">AsyncStorage</strong> because you can work with multiple instances of MMKV stores.</p>
			<p>While it is possible to encrypt data with MMKV, at the time of writing, there is no secure solution regarding how to handle the key. Therefore, I would only recommend using it to store non-sensitive data. This may change in the future.</p>
			<p>MMKV can be used as a faster drop-in replacement for <strong class="source-inline">AsyncStorage</strong>. The only disadvantage MMKV has compared to <strong class="source-inline">AsyncStorage</strong> is that the React Native wrappers are not used that much at the time of writing. There are two well-maintained React Native MMKV mappers, so you should have a look at them when you consider using MMKV for <a id="_idIndexMarker269"/>your project. You can find more information <a id="_idIndexMarker270"/>about installation, usage, and APIs there. The first one is <strong class="source-inline">react-native-mmkv</strong>. It is a leaner project <a id="_idIndexMarker271"/>and comes with a simpler API. It’s also much simpler to install. You can have a look at it here: https://github.com/mrousavy/react-native-mmkv. The second one is <strong class="source-inline">react-native-mmkv-storage</strong>. It provides more features, such as indexing and data life cycle methods, which <a id="_idIndexMarker272"/>can be very useful when it comes to locking and transactions. You can have a look at it here: <a href="https://github.com/ammarahm-ed/react-native-mmkv-storage">https://github.com/ammarahm-ed/react-native-mmkv-storage</a>.</p>
			<p>Now that we’ve looked at <strong class="source-inline">AsyncStorage</strong> and MMKV, which handle very similar use cases, let’s look at a solution that comes with some more features: SQLite.</p>
			<h3>Working with SQLite</h3>
			<p>Compared to <strong class="source-inline">AsyncStorage</strong> and MMKV, SQLite is not only a simple key/value store – it is a complete <a id="_idIndexMarker273"/>database engine that includes functionalities such as <a id="_idIndexMarker274"/>locking, transactions, and advanced querying.</p>
			<p>However, this means you can’t simply store your objects as serialized data. SQLite uses SQL queries and tables to store your data, which means you have to process your objects. To insert data, you must create a table with a column for each property and then insert every object with a SQL statement. Let’s have a look at the following code:</p>
			<pre class="source-code">
import { QuickSQLite } from 'react-native-quick-sqlite';
const dbOpenResult = QuickSQLite.open('myDB', 'databases');
// set data
let { status, rowsAffected } = QuickSQLite.executeSql(
  'myDB',
  'UPDATE users SET name = ? where userId = ?',
  ['John', 1]
);
if (!status) {
  console.log(`Update affected ${rowsAffected} rows`);
}
// get data
let { status, rows } = QuickSQLite.executeSql(
  'myDB',
  'SELECT name FROM users'
);
if (!status) {
  rows.forEach((row) =&gt; {
    console.log(row);
  });
}</pre>
			<p>As you can see, it takes much more code to insert and query data. You need to create and execute SQL and process the data you get to have it in a format you can work with. This means that SQLite isn’t as easy and fast to use as <strong class="source-inline">AsyncStorage</strong> and MMKV, but it comes with <a id="_idIndexMarker275"/>advanced querying features. This means that you can filter <a id="_idIndexMarker276"/>and search your data and even join different tables.</p>
			<p>I would recommend using SQLite if you have very complex data structures, where you need to join and query different objects or tables a lot. I prefer simpler solutions for local data storage, but there are use cases where SQLite is the better fit.</p>
			<p>Besides the higher complexity of using it, SQLite also adds some MB to your app size because it adds its SQLite database engine implementation to your app.</p>
			<p>The most used React Native wrapper for SQLite is <strong class="source-inline">react-native-sqlite-storage</strong>. The API is <a id="_idIndexMarker277"/>simple, and it is used in a lot of projects. You can learn more about it at <a href="https://github.com/andpor/react-native-sqlite-storage">https://github.com/andpor/react-native-sqlite-storage</a>.</p>
			<p>Another solution is <strong class="source-inline">react-native-quick-sqlite</strong>. It is a relatively new library, but it is based <a id="_idIndexMarker278"/>on JSI and therefore up to five times as fast as other solutions. You can learn more about it at <a href="https://github.com/ospfranco/react-native-quick-sqlite">https://github.com/ospfranco/react-native-quick-sqlite</a>.</p>
			<p>Now that you’ve <a id="_idIndexMarker279"/>learned about the SQLite database engine, let’s look at another <a id="_idIndexMarker280"/>use case. Sometimes, you have to store large amounts of data, which means you need direct access to the filesystem. This is what we’ll explore next.</p>
			<h3>Using the filesystem with React Native</h3>
			<p>To store large <a id="_idIndexMarker281"/>amounts of data, it is always a good idea to <a id="_idIndexMarker282"/>create and store files. On iOS and Android, every app runs in a sandbox that no other app has access to. While that does not mean that all your files are secure – they can be retrieved by the user quite easily – it gives you at least some level of privacy regarding your data. However, this sandbox mode means that you cannot access the data of other apps.</p>
			<p>To read and write data to your app’s sandbox in React Native, you can use libraries such as <strong class="source-inline">react-native-fs</strong>. This library provides constants with the paths you have access to and lets you read and write files from the filesystem.</p>
			<p>I recommend using this approach when you’re synchronizing files from a server or writing large amounts of data. Most of the time, you can combine this approach with one of the previous approaches to store files locally and then store the path of the file in one of the other storage solutions.</p>
			<p>If you want to find out more about filesystem access on React Native, please have a look at the <a id="_idIndexMarker283"/>documentation of <strong class="source-inline">react-native-fs</strong> at <a href="https://github.com/itinance/react-native-fs">https://github.com/itinance/react-native-fs</a>.</p>
			<p>With that, we’ve covered the most common solutions for storing and accessing non-sensitive data. This is where you should store most of your data. However, some data contains sensitive information such as passwords or other user information. This data needs another <a id="_idIndexMarker284"/>level of protection. So, let’s have a look at <a id="_idIndexMarker285"/>some storage solutions for sensitive information in React Native.</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor093"/>Storing sensitive data</h2>
			<p>When you store sensitive information on the device of a user, you should always think about how to <a id="_idIndexMarker286"/>secure it. Most of the time, this will be irrelevant, but <a id="_idIndexMarker287"/>when the user loses the device, you should make sure that their sensitive information is as secure as possible.</p>
			<p>You will never be able to ensure 100% data security when you have no control over the device. However, we need to do the best we can to make it as hard as possible for that sensitive information to be retrieved.</p>
			<p>The first thing you should consider is if it is necessary to persist the information. Information that is not there cannot be stolen. If you need to persist information, use secure storage. Android and iOS provide built-in solutions for securely storing data. React Native provides wrappers for these native built-in solutions. The following ones are well maintained and can be used with ease:</p>
			<ul>
				<li><strong class="source-inline">expo-secure-store</strong>: Uses iOS Keychain and Android <strong class="source-inline">SharedPreferences</strong> combined <a id="_idIndexMarker288"/>with Keystore System. It provides an easy API and can store values up to 2,048 bytes in size. More information can be found at <a href="https://docs.expo.dev/versions/latest/sdk/securestore/">https://docs.expo.dev/versions/latest/sdk/securestore/</a>.</li>
				<li><strong class="source-inline">react-native-sensitive-info</strong>: This library is very well maintained and provides a lot <a id="_idIndexMarker289"/>of functionality. It also adds another layer of security, which protects your data even on rooted devices. It supports Android, iOS, and Windows. More information can be found at <a href="https://mcodex.dev/react-native-sensitive-info/">https://mcodex.dev/react-native-sensitive-info/</a>.</li>
				<li><strong class="source-inline">react-native-keychain</strong>: This is another well-maintained library with an easy API. It supports <a id="_idIndexMarker290"/>Android and iOS and encrypts data on all devices. More information can be found at <a href="https://github.com/oblador/react-native-keychain">https://github.com/oblador/react-native-keychain</a>.</li>
			</ul>
			<p>Again, even if these solutions are very good and secure, based on native implementations, there <a id="_idIndexMarker291"/>will never be 100% security for <a id="_idIndexMarker292"/>data. So, please only persist necessary.</p>
			<p>Now that you learned about data storage solutions and the difference between sensitive and non-sensitive data, it’s time to look at navigation in React Native apps.</p>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor094"/>Understanding navigation in React Native</h1>
			<p>React Native does not come with a built-in navigation solution. That’s why we worked with a global state and <a id="_idIndexMarker293"/>simply switched components while navigating in our example app. While this works technically, it does not provide a great user experience.</p>
			<p>Modern navigation solutions include performance optimization, animations, integration in global state management solutions, and much more. Before we dive deep into these solutions, let’s see what navigation looks like on different platforms.</p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor095"/>Navigating different platforms</h2>
			<p>If you open any iOS or Android app, you’ll soon realize that navigation in an app is completely different <a id="_idIndexMarker294"/>from navigating the web in a browser. A browser navigates from page to page by replacing the old page with the new one. In addition to that, every page has a URL and can be accessed directly if it’s typed in the browser’s address bar.</p>
			<p>In an iOS or Android app, navigation takes the form of a combination of different navigators. The page you navigate away from doesn’t always get replaced by the new one. Multiple pages can be active at the same time.</p>
			<p>Let’s have a look at the most common navigation scenarios and navigators to handle these scenarios:</p>
			<ul>
				<li><strong class="bold">Stack navigator</strong>: When navigating to a new page in a stack navigator, the new page is pushed <a id="_idIndexMarker295"/>on top of the old page. Nevertheless, the old page doesn’t get unmounted. It continues to exist and if you leave the new page with a back button, you’ll automatically navigate back to the old page. The new page gets <em class="italic">popped</em> from the so-called layer stack, and you’ll find your old page in the same state you left it in. This also includes the scroll position.</li>
				<li><strong class="bold">Tab navigator</strong>: A very popular navigator is the tab navigator. This navigator provides up to five tabs that can be selected via a tab bar. This tab bar contains text and/or icons and <a id="_idIndexMarker296"/>can be on the top or at the bottom of the screen. Every tab has a layer stack. This means you can navigate every tab separately. The state of the tabs does not reset when you select another tab. In most cases, you simply have multiple stack navigators in your tab navigator.</li>
				<li><strong class="bold">Switch navigator</strong>: This navigator provides the same behavior as web navigation. When <a id="_idIndexMarker297"/>using this navigator, you’ll replace an old page or layer stack with the new one. This means the old page or layer stack gets unmounted and removed from memory. If you navigate back, the old page or layer stack will have a complete clean restart, as if you haven’t been there before.</li>
			</ul>
			<p>Most apps combine these navigators to provide a great navigation experience to the user. Because this common navigation experience in mobile apps is so different from the web, you should always keep this in mind when planning a project for mobile and the web. You will learn more about this in <a href="B16694_10.xhtml#_idTextAnchor347"><em class="italic">Chapter 10</em></a>, <em class="italic">Structuring Large-Scale, Multi-Platform Projects</em>.</p>
			<p>Even though multiple <a id="_idIndexMarker298"/>community projects <a id="_idIndexMarker299"/>provide great support for navigation in React Native apps, such as react-native-navigation (supported by Wix; more information can be found at <a href="https://wix.github.io/react-native-navigation/docs/before-you-start/">https://wix.github.io/react-native-navigation/docs/before-you-start/</a>) and react-router/native (more information can be found <a id="_idIndexMarker300"/>at <a href="https://v5.reactrouter.com/native/guides/quick-start">https://v5.reactrouter.com/native/guides/quick-start</a>), we’ll focus on react-navigation in this section. It is by far the most commonly used, most actively maintained, and most advanced navigation solution for React Native.</p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor096"/>Working with React Navigation</h2>
			<p>To understand how React Navigation works, it’s best to simply integrate it into our example project. We’ll do <a id="_idIndexMarker301"/>two things here. First, we’ll replace our global state navigation solution with a React Navigation Stack Navigator. Then, we’ll add a Tab Navigator to create a second tab, which we’ll use in the next chapter.</p>
			<p>But before you can begin using React Navigation, you must install it. This process is easy – you just have to install the package and the dependencies via npm. This can be done with the <strong class="source-inline">npm install @react-navigation/native react-native-screens react-native-safe-area-context</strong> command. Since <strong class="source-inline">react-native-screens</strong> and <strong class="source-inline">react-native-safe-area-context</strong> have a native part, you’ll have to install the iOS Podfiles with the <strong class="source-inline">npx pod-install</strong> command. After this, you’ll have to create fresh builds to be able to use React Navigation. This can be done for iOS with <strong class="source-inline">npx react-native run-ios</strong>.</p>
			<p>At the time of writing, some additional steps are necessary to get React Navigation to work on Android. Since this <a id="_idIndexMarker302"/>may change in the future, please <a id="_idIndexMarker303"/>have a look at the installation part of the official documentation at <a href="https://reactnavigation.org/docs/getting-started/#installation">https://reactnavigation.org/docs/getting-started/#installation</a>.</p>
			<p>Now that have installed React Navigation, it’s time to use it in our example project. First, we’ll replace our global state-based navigation in <strong class="source-inline">App.tsx</strong> with a Stack Navigator. To use the Stack Navigator, we’ll have to install it using the <strong class="source-inline">npm install @react-navigation/na<a id="_idTextAnchor097"/><a id="_idTextAnchor098"/>tive-stack</strong> command. Then, we can start using it in our app:</p>
			<pre class="source-code">
const MainStack = createNativeStackNavigator&lt;MainStackParamList&gt;();
const App = () =&gt; {
  return (
    &lt;NavigationContainer&gt;
      &lt;MainStack.Navigator&gt;
        &lt;MainStack.Screen
          name="Home"
          component={Home}
          options={{title: 'Movie Genres'}}
        /&gt;
        &lt;MainStack.Screen
          name="Genre"
          component={Genre}
          options={{title: 'Movies'}}
        /&gt;
        &lt;MainStack.Screen
          name="Movie"
          component={Movie}
          options={({route}) =&gt;
          ({title: route.params.movie.title})}
        /&gt;
      &lt;/MainStack.Navigator&gt;
    &lt;/NavigationContainer&gt;
  );
};</pre>
			<p>As you can see, our <strong class="source-inline">App.tsx</strong> got a lot simpler. We can remove all the <strong class="source-inline">useState</strong> hooks and all the setter functions because React Navigation will handle all this. All we need to do is create a Stack Navigator with React Navigation’s <strong class="source-inline">createNativeStackNavigator</strong> command and then return our Layer Stack in our return statement. Please note <strong class="source-inline">&lt;NavigationContainer /&gt;</strong>, which is wrapping the entire application. This is necessary to be able to manage the navigation state and should usually wrap the root component.</p>
			<p>Here, every screen has a name, a component, and some options. The name is also the key that the screen <a id="_idIndexMarker304"/>can be navigated to with. <strong class="source-inline">component</strong> is the component that should be mounted when the screen is navigated to. <strong class="source-inline">options</strong> allows us to configure things such as the header and the back button.</p>
			<p>Now that we have defined the Layer Stack, it’s time to look at the views and see what has changed there. Let’s look at <strong class="source-inline">&lt;GenreView /&gt;</strong>. This is where we can see all the changes best:</p>
			<pre class="source-code">
type GenreProps = NativeStackScreenProps&lt;MainStackParamList, 'Genre'&gt;;
const Genre = (props: GenreProps) =&gt; {
  const [m<a id="_idTextAnchor099"/><a id="_idTextAnchor100"/>ovies,<a id="_idTextAnchor101"/><a id="_idTextAnchor102"/> setMovies] = useState&lt;IMovie[]&gt;([]);
  useEffect(() =&gt; {
    if (typeof<a id="_idTextAnchor103"/><a id="_idTextAnchor104"/> props.route.params.genre !== 'undefined') {
      setMovies(getMovieByGenreId(props.route.params.genre.
        id));
    }
  }, [props.route.params.genre]);
  return (
    &lt;ScrollContainer&gt;
      {movies.map(movie =&gt; {
        return (
          &lt;Pressable
            onPress={() =&gt;
              props.navigation.navigate('Movie',
                {movie: movie})}&gt;
            &lt;Text
             style={styles.movieTitle}&gt;{movie.title}&lt;/Text&gt;
          &lt;/Pressable&gt;
        );
      })}
    &lt;/ScrollContainer&gt;
  );
};</pre>
			<p>The first thing you can see is that there is another way to access the properties that are passed via React Navigation. Every component, which is a React Navigation screen, is passed two additional properties – <strong class="source-inline">navigation</strong> and <strong class="source-inline">route</strong>.</p>
			<p><strong class="source-inline">route</strong> contains information about the current route. The most important property of <strong class="source-inline">route</strong> is <strong class="source-inline">params</strong>. When navigating to a screen, we can pass <strong class="source-inline">params</strong>, which can then be retrieved through <strong class="source-inline">route.params</strong>. In this example, this is how we pass the genre to the view (<strong class="source-inline">props.route.params.genre</strong>), which we then use to fetch the movie list.</p>
			<p>When you have a look at the <strong class="source-inline">onPress</strong> function of the <strong class="source-inline">&lt;Pressable /&gt;</strong> component in the return <a id="_idIndexMarker305"/>statement, you can see how to navigate to another page in React Navigation. The <strong class="source-inline">navigation</strong> property provides different functions to navigate between screens. In our case, we use the <strong class="source-inline">navigate</strong> function with the <strong class="source-inline">Movie</strong> key to navigate to the <strong class="source-inline">&lt;Movie /&gt;</strong> view. We also pass the current movie as a parameter.</p>
			<p>When you compare the code to the example from the previous section, you’ll realize that the <strong class="source-inline">&lt;Header /&gt;</strong> and <strong class="source-inline">&lt;BackButton /&gt;</strong> components are missing. This is because React Navigation comes with built-in header and back button support. While you can disable this, its default behavior is for <a id="_idTextAnchor105"/><a id="_idTextAnchor106"/>every screen to have a header, including a back button to the previous screen.</p>
			<p>If you want to see all these changes, please have a look at the repository for this example project and choose the <strong class="source-inline">chapter-4-navigation</strong> tag.</p>
			<p>If you run the example project on that tag, you’ll also see that React Native added animations to the navigation actions. These animations can be customized in any way possible. There is even a community library to support shared animated elements between the different pages. You can have a look at it here: <a href="https://github.com/IjzerenHein/react-navigation-shared-element">https://github.com/IjzerenHein/react-navigation-shared-element</a>.</p>
			<p>Now that you’ve learned how to use the Stack Navigator, we’ll add another navigator. We want to create a second tab because we want to create an area where the user can save his favorite movies. This will be done with a Tab Navigator.</p>
			<p>As with the Stack Navigator, we have to install the Tab Navigator before using it. This can be done with <strong class="source-inline">npm install @react-navigation/bottom-tabs</strong>. After we have installed the Tab Navigator, we can add it to our <strong class="source-inline">App.tsx</strong>. Please have a look at the following code snippet:</p>
			<pre class="source-code">
const MainStackScreen = () =&gt; {
  return (
    &lt;MainStack.Navigator&gt;
      &lt;MainStack.Screen component={Home}/&gt;
      &lt;MainStack.Screen component={Genre}/&gt;
      &lt;MainStack.Screen component={Movie}/&gt;
    &lt;/MainStack.Navigator&gt;
  );
};
const App = () =&gt; {
  return (
    &lt;NavigationContainer&gt;
      &lt;Ta<a id="_idTextAnchor107"/><a id="_idTextAnchor108"/>bNavigator.Navigator&gt;
        &lt;TabNavigator.Screen
          name="Main"
          component={MainStackScreen}
          options={{
            headerShown: false,
          }}
        /&gt;
        &lt;TabNavigator.Screen
          name="User"
          component={User}
        /&gt;
      &lt;/TabNavigator.Navigator&gt;
    &lt;/NavigationContainer&gt;
  );</pre>
			<p>This is a very limited example. To see the working code, please have a look at the example repository <a id="_idIndexMarker306"/>and choose the <strong class="source-inline">chapter-4-navigation-tabs</strong> tag. As you can see, we move the Main Stack to its own function component. Our <strong class="source-inline">App</strong> component now contains <strong class="source-inline">&lt;TabNavigator /&gt;</strong> with two screens.</p>
			<p>The first screen gets <strong class="source-inline">&lt;MainStackScreen /&gt;</strong> as its component. This means that we use our Stack Navigator when we are on the first tab. The second screen gets a newly created <strong class="source-inline">&lt;User /&gt;</strong> component. You can switch between these tabs with the tab bar, which is created automatically by React Navigation.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You should always <a id="_idIndexMarker307"/>install an icon library such as <strong class="source-inline">react-native-vector-icons</strong> (<a href="https://github.com/oblador/react-native-vector-icons">https://github.com/oblador/react-native-vector-icons</a>) when working with tabs. Such libraries make it easy to find and use expressive icons for your tab bar.</p>
			<p>This example, which contains two different navigators, shows the flexibility of React Navigation. We can either use our views in our <strong class="source-inline">&lt;Navigator.Screen /&gt;</strong> components or use other navigators. This navigator nesting gives us nearly endless possibilities. Please note that in this case, we must hide the header for the first tab because it has already been created by our Stack Navigator. We can do this with the <strong class="source-inline">headerShown: false</strong> option.</p>
			<p>As you can see, navigating with React Navigation is easy and powerful. It also has excellent TypeScript support, as you can see in the repository. You can create types for every layer stack and define exactly what can be passed to the different screens. This includes not only type checking, but also autocomplete functionality in most modern IDEs. You can read more <a id="_idIndexMarker308"/>about TypeScript support for React Navigation here: <a href="https://reactnavigation.org/docs/typescript/">https://reactnavigation.org/docs/typescript/</a>.</p>
			<p>React Navigation supports a lot more features, including deeplinking, testing, persisting the navigation state, and <a id="_idIndexMarker309"/>integrating different state management solutions. If you want to learn more, please visit the official documentation: <a href="https://reactnavigation.org/docs/getting-started/">https://reactnavigation.org/docs/getting-started/</a>.</p>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor109"/>Summary</h1>
			<p>Now that we’ve added a modern navigation library to our example project, it’s time to wrap up this chapter. First, you learned what you have to consider when you wish to style your application. You also learned about the most common solutions for styling React Native applications and learned which of them are suitable for sharing code with web projects.</p>
			<p>Then, you learned how to store data locally in a React Native app. Finally, you learned how navigation is different between the web and mobile and how to use a modern navigation library to implement state-of-the-art navigation solutions in React Native apps.</p>
			<p>In the next chapter, we’ll look at solutions for creating and maintaining a global app state and how to fetch data from external resources. While learning about this, we’ll fill the placeholder screen we created in this chapter with some cool functionality.</p>
		</div>
		<div>
			<div id="_idContainer021">
			</div>
		</div>
	</body></html>