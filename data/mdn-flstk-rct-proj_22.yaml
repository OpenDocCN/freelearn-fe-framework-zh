- en: '17'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '17'
- en: Introducing React Server Components
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍React服务器组件
- en: After implementing our static blog app in Next.js, it’s time to introduce some
    interactivity to it. Instead of using the traditional pattern of writing a separate
    backend server, which the frontend fetches data from and makes requests to, we
    are going to use a new pattern called **React Server Components** (**RSCs**).
    This new pattern allows us to directly access the database from React components
    by executing certain React components (so-called server components) only on the
    server. Together with Server Actions (a way to call functions on the server from
    the client), this new pattern allows us to easily and quickly develop full-stack
    apps. In this chapter, we are going to learn what RSCs and Server Actions are,
    why they matter, what their advantages are, and how to implement them properly
    and securely.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在Next.js中实现我们的静态博客应用之后，是时候给它添加一些交互性了。我们不会使用传统的模式，即编写一个单独的后端服务器，前端从该服务器获取数据并发出请求，而是将使用一种名为**React服务器组件**（**RSCs**）的新模式。这种新模式允许我们通过仅在某些React组件（所谓的服务器组件）上执行来直接从React组件访问数据库。结合服务器操作（一种从客户端调用服务器上函数的方法），这种新模式使我们能够轻松快速地开发全栈应用。在本章中，我们将学习RSCs和服务器操作是什么，为什么它们很重要，它们的优点是什么，以及如何正确且安全地实现它们。
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: What are RSCs?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是RSCs？
- en: Adding a data layer to our Next.js app
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的Next.js应用添加数据层
- en: Using RSCs to fetch data from the database
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RSCs从数据库获取数据
- en: Using Server Actions to sign up, log in, and create new posts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用服务器操作进行注册、登录和创建新帖子
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Before we start, please install all the requirements from [*Chapter 1*](B19385_01.xhtml#_idTextAnchor016),
    *Preparing For Full-Stack Development*, and [*Chapter 2*](B19385_02.xhtml#_idTextAnchor028),
    *Getting to Know Node.js* *and MongoDB*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，请安装从[*第1章*](B19385_01.xhtml#_idTextAnchor016)“为全栈开发做准备”和[*第2章*](B19385_02.xhtml#_idTextAnchor028)“了解Node.js和MongoDB”中提到的所有要求。
- en: The versions listed in those chapters are the ones used in this book. While
    installing a newer version should not be an issue, please note that certain steps
    might work differently. If you are having an issue with the code and steps provided
    in this book, please try using the versions mentioned in *Chapters 1* and *2*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 那些章节中列出的版本是本书中使用的版本。虽然安装较新版本不应成问题，但请注意，某些步骤可能会有所不同。如果你在使用本书中提供的代码和步骤时遇到问题，请尝试使用*第1章*和*第2章*中提到的版本。
- en: 'You can find the code for this chapter on GitHub: [https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch17](https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch17).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本章的代码：[https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch17](https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch17)。
- en: 'The CiA video for this chapter can be found at: [https://youtu.be/4hGZJRmZW6E](https://youtu.be/4hGZJRmZW6E).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的CiA视频可以在以下位置找到：[https://youtu.be/4hGZJRmZW6E](https://youtu.be/4hGZJRmZW6E)。
- en: What are RSCs?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是RSCs？
- en: 'So far, we have been using the traditional React architecture, where all components
    are **client components**. We started with client-side rendering. However, there
    are some downsides to client-side rendering:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用传统的React架构，其中所有组件都是**客户端组件**。我们是从客户端渲染开始的。然而，客户端渲染有一些缺点：
- en: The JavaScript client bundle must be downloaded from the server before the client
    can start rendering anything, delaying the **first contentful paint** (**FCP**)
    for the user.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在客户端开始渲染任何内容之前，必须从服务器下载JavaScript客户端包，这会延迟用户的**首次内容绘制**（**FCP**）。
- en: Data must be fetched from the server (after all JavaScript is downloaded and
    executed) to show anything meaningful, delaying the **first meaningful paint**
    (**FMP**) for the user.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须从服务器获取数据（在下载并执行JavaScript之后）才能显示任何有意义的内容，这会延迟用户的**首次有意义的绘制**（**FMP**）。
- en: Most of the load is on the client, even for pages that are not interactive,
    which is especially problematic for clients with slow processors, such as low-end
    mobile devices or old laptops. It also uses more battery to load a heavy client-side
    rendered page.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大部分负载都在客户端，即使是那些非交互式的页面也是如此，这对处理器较慢的客户端来说尤其成问题，例如低端移动设备或旧笔记本电脑。它还需要更多的电池来加载重量级的客户端渲染页面。
- en: In certain cases, data is fetched sequentially (for example, loading posts first
    and then resolving the authors of each post), which is especially a problem for
    slow connections with high latency.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某些情况下，数据是顺序获取的（例如，首先加载帖子，然后解析每个帖子的作者），这对于具有高延迟的慢速连接来说尤其是一个问题。
- en: 'To solve these problems, **server-side rendering** (**SSR**) was introduced,
    but it still has a big downside: the initial page load can be slow due to everything
    being rendered on the server. This slowdown happens because of the following reasons:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题，**服务器端渲染**（**SSR**）被引入，但它仍然有一个很大的缺点：由于所有内容都在服务器上渲染，初始页面加载可能会很慢。这种减速发生的原因如下：
- en: Data must be fetched from the server before any of it can be shown.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在显示任何数据之前，必须从服务器获取数据。
- en: The JavaScript client bundle must be downloaded from the server before the client
    can be hydrated with it. Hydration means that the page is ready to be interacted
    with by a user. To refresh your knowledge of how hydration works, check out [*Chapter
    7*](B19385_07.xhtml#_idTextAnchor147).
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在客户端使用它进行水合之前，必须从服务器下载JavaScript客户端包。水合意味着页面已准备好供用户交互。为了刷新你对水合工作原理的了解，请查看[*第7章*](B19385_07.xhtml#_idTextAnchor147)。
- en: Hydration has to be completed on the client before anything can be interacted
    with.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 水合作用必须在客户端完成，之后才能与任何内容进行交互。
- en: Even when a client component is pre-rendered on the server, its code will be
    bundled and sent to the client for hydration. This means that client components
    can run on both the server (for SSR) and the client, but they need to at least
    be able to run on the client.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 即使客户端组件在服务器上进行了预渲染，其代码也会被打包并发送到客户端进行水合。这意味着客户端组件可以在服务器（用于SSR）和客户端上运行，但它们至少需要在客户端上能够运行。
- en: 'In a traditional full-stack React architecture with only client components,
    if we needed to access the filesystem of the server or a database, we needed to
    write a separate backend using Node.js and expose an API (such as a REST API).
    Then, this API was queried in client components, for example, using TanStack Query.
    These queries can also be made on the server side (as we saw in [*Chapter 7*](B19385_07.xhtml#_idTextAnchor147),
    *Improving the Load Time Using Server-Side Rendering*), but they need to at least
    be executable on the client. This means we cannot directly access the filesystem
    or database from a React component, even if that code could run on the server;
    it would be bundled and sent to the client, where running it would not work (or
    expose internal information, such as credentials, to the database):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在仅包含客户端组件的传统全栈React架构中，如果我们需要访问服务器的文件系统或数据库，我们需要编写一个单独的后端使用Node.js并公开一个API（例如REST
    API）。然后，这个API在客户端组件中被查询，例如，使用TanStack Query。这些查询也可以在服务器端进行（如我们在[*第7章*](B19385_07.xhtml#_idTextAnchor147)，*使用服务器端渲染提高加载时间*）中看到），但它们至少需要在客户端可执行。这意味着我们无法直接从React组件中访问文件系统或数据库，即使该代码可以在服务器上运行；它会被打包并发送到客户端，在那里运行将不会工作（或者会将内部信息，如凭证，暴露给数据库）：
- en: '![Figure 17.1 – The architecture of a full-stack app without and with RSCs](img/B19385_17_1.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图17.1 – 无RSCs和有RSCs的全栈应用架构](img/B19385_17_1.jpg)'
- en: Figure 17.1 – The architecture of a full-stack app without and with RSCs
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.1 – 无RSCs和有RSCs的全栈应用架构
- en: React 18 introduced a new feature called RSCs, which allows us to define components
    that will be solely executed on the server, with only the output sent to the client.
    Server components can, for example, fetch data from a database or the filesystem,
    and then render interactive client components, passing that data as props to them.
    This new feature allows for an architecture where we can more easily write a full-stack
    application using only React, without having to deal with the overhead of defining
    a REST API.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: React 18引入了一个名为RSCs的新功能，允许我们定义仅将在服务器上执行组件，只将输出发送到客户端。服务器组件可以，例如，从数据库或文件系统中获取数据，然后渲染交互式客户端组件，并将这些数据作为props传递给它们。这个新功能允许我们构建一个架构，我们可以更轻松地仅使用React编写全栈应用程序，而无需处理定义REST
    API的开销。
- en: Note
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It might still make sense to define REST APIs for certain apps, especially if
    the backend is developed by another team in a larger-scale project, or if it is
    consumed by other services and frontends.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些应用程序，定义REST API可能仍然有意义，特别是如果后端是由更大规模项目中的另一个团队开发，或者如果它被其他服务和前端消费。
- en: RSCs solve the aforementioned issues with client-side rendering and SSR by allowing
    us to execute code exclusively on the server (no hydration needed on the client!)
    and selectively streaming components (so we don’t have to wait for everything
    to pre-render before serving components to the client).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: RSC 通过允许我们在服务器上独家执行代码（客户端无需水合！）和选择性地流式传输组件（这样我们就不必等待所有内容预渲染后再向客户端提供组件）来解决客户端渲染和
    SSR 中的上述问题。
- en: 'The following figure compares **client-side rendering (CSR)** with SSR and
    RSCs:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 下图比较了 **客户端渲染 (CSR**) 与 SSR 和 RSC：
- en: '![Figure 17.2 – Comparison between CSR, SSR and RSC](img/B19385_17_2.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.2 – CSR、SSR 和 RSC 的比较](img/B19385_17_2.jpg)'
- en: Figure 17.2 – Comparison between CSR, SSR and RSC
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.2 – CSR、SSR 和 RSC 的比较
- en: As you see, RSCs are not only faster overall (as a result of fewer roundtrips
    over the network), but they can also display the layout of an app immediately
    while waiting for the rest of the components to load.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，RSC 不仅整体上更快（由于网络往返次数更少），而且可以在等待其他组件加载的同时立即显示应用程序的布局。
- en: 'Let’s sum up the most important features of RSCs:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下 RSC 的最重要的特性：
- en: They can run ahead of time and are excluded from the JavaScript bundle, reducing
    bundle size and improving performance.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以在构建之前运行，并且不会被包含在 JavaScript 包中，从而减少包大小并提高性能。
- en: They can run either during build time (resulting in static HTML) or be executed
    on the fly when a request comes in. Interestingly, server components can also
    be exclusively executed during build time, resulting in a static HTML bundle.
    This can be useful for statically built CMS apps or personal blogs. RSCs also
    allow a mix, where the initial cache is primed with a static build, and then later
    revalidated through Server Actions or Webhooks. We are going to learn more about
    caching in [*Chapter 18*](B19385_18.xhtml#_idTextAnchor321)*, Advanced Next.js
    Concepts* *and Optimizations*.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以在构建时运行（生成静态 HTML）或当请求到来时即时执行。有趣的是，服务器组件也可以在构建时独家执行，从而生成静态 HTML 包。这对于静态构建的
    CMS 应用或个人博客可能很有用。RSC 还允许混合使用，其中初始缓存通过静态构建进行预填充，然后通过服务器操作或 Webhooks 进行后续验证。我们将在
    [*第 18 章*](B19385_18.xhtml#_idTextAnchor321)*，高级 Next.js 概念和优化* 中了解更多关于缓存的内容。
- en: They can pass (serializable) data to client components. Additionally, client
    components can still be server-side rendered to further improve performance!
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以将（可序列化）数据传递给客户端组件。此外，客户端组件仍然可以被服务器端渲染，以进一步提高性能！
- en: Inside a server component, other server components can be passed as props to
    client components, allowing for composition patterns where server components are
    “slotted into” interactive client components. However, all components that are
    imported inside client components will be considered client components; they cannot
    be server components anymore.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器组件内部，其他服务器组件可以作为 props 传递给客户端组件，允许使用组合模式，其中服务器组件被“嵌入”到交互式客户端组件中。然而，所有在客户端组件内部导入的组件都将被视为客户端组件；它们不能再是服务器组件。
- en: In frameworks such as Next.js, by default, a React component is considered a
    server component. If we want to turn it into a client component, we need to write
    the `"use client"` directive at the beginning of a file. We need to do this to
    make it possible to add interactivity (event listeners) or use state/life cycle
    effects and browser-only APIs.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在像 Next.js 这样的框架中，默认情况下，React 组件被视为服务器组件。如果我们想将其转换为客户端组件，我们需要在文件开头写入 `"use client"`
    指令。我们需要这样做是为了使其能够添加交互性（事件监听器）或使用状态/生命周期效果和仅浏览器 API。
- en: Note
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The **"use client"** directive defines a network boundary between server and
    client components. All data sent from a server component to a client component
    will be serialized and sent over the network. When using the **"use client"**
    directive in a file, all other modules that are imported into it, including child
    components, are considered to be part of the client bundle.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**"use client"** 指令定义了服务器组件和客户端组件之间的网络边界。所有从服务器组件发送到客户端组件的数据都将被序列化并通过网络发送。当在文件中使用
    **"use client"** 指令时，所有导入到该文件的其他模块，包括子组件，都被视为客户端包的一部分。'
- en: 'The following figure provides an overview of when to use a server component
    or a client component:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 下图概述了何时使用服务器组件或客户端组件：
- en: '![Figure 17.3 – Overview of when to use server components and client components](img/B19385_17_3.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.3 – 何时使用服务器组件和客户端组件概述](img/B19385_17_3.jpg)'
- en: Figure 17.3 – Overview of when to use server components and client components
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.3 – 何时使用服务器组件和客户端组件概述
- en: In general, RSCs are an optimization over client components. You could simply
    write `"use client"` at the top of every file and be done with it, but you would
    be leaving all the advantages of RSCs behind! So, try to use server components
    whenever possible, but do not hesitate to fall back to defining something as a
    client component if it turns out to be too complicated to split it up into server-side
    and client-side parts. It can always be optimized later.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，RSC是对客户端组件的一种优化。你可以在每个文件的顶部简单地写上`"use client"`并完成，但你将放弃RSC的所有优势！所以，尽可能使用服务器组件，但如果你发现将其拆分为服务器端和客户端部分过于复杂，不要犹豫将其定义为客户端组件。它总是可以在以后进行优化。
- en: This new way of writing full-stack React applications can be hard to grasp in
    theory, so feel free to come back to this section again at the end of this chapter.
    For now, we’ll move on and implement RSCs in our Next.js app as this will help
    us understand how the new concepts work in practice. First, we’ll start by adding
    a data layer to our Next.js app, which will allow us to access the database from
    RSCs later on.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这种编写全栈React应用的新方法在理论上可能难以理解，所以请随时在本章结束时再次回到这一节。现在，我们将继续前进，并在我们的Next.js应用中实现RSC，这将帮助我们理解新概念在实际中的工作方式。首先，我们将从向我们的Next.js应用添加数据层开始，这将允许我们稍后从RSC中访问数据库。
- en: Adding a data layer to our Next.js app
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向我们的Next.js应用添加数据层
- en: In the traditional backend structure, we had the database layer, the services
    layer, and the routes layer. In a modern full-stack Next.js app, we don’t need
    the routes layer of our backend because we can directly interface with it in RSCs.
    So, we only need to have the database layer and a data layer to provide functions
    that access the database. Theoretically, we could directly access the database
    in RSCs, but it is best practice to have specific functions that access it in
    certain ways. Defining such functions allows us to clearly define what data is
    accessible (and thus avoid accidentally leaking too much information). They are
    also more reusable and make it easier to unit-test and find potential vulnerabilities
    (for example, via a penetration test) in the data layer.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的后端结构中，我们有数据库层、服务层和路由层。在现代的全栈Next.js应用中，我们不需要后端的路由层，因为我们可以直接在RSC中与之交互。因此，我们只需要数据库层和一个数据层来提供访问数据库的功能。理论上，我们可以在RSC中直接访问数据库，但最佳实践是定义特定的函数以特定方式访问它。定义这样的函数使我们能够清楚地定义哪些数据是可访问的（从而避免意外泄露过多信息）。它们也更易于重用，并使得单元测试和发现数据层中的潜在漏洞（例如，通过渗透测试）更加容易。
- en: 'To recap, there are three main data-handling approaches:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，主要有三种数据处理方法：
- en: '**HTTP APIs**: We used these in previous chapters to implement our blog app.
    These can be useful when separate teams are working on the backend and frontend.
    Due to this, this approach is recommended for existing large projects and organizations.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTP APIs**：我们在前几章中使用这些API来实现我们的博客应用。当后端和前端由不同的团队工作时，这些API非常有用。因此，这种方法推荐用于现有的大型项目和组织。'
- en: '**Data access layer**: This is the pattern we are going to use in this section.
    It is recommended for new projects that make use of the RSC architecture as it
    makes it easier to implement full-stack projects by separating concerns of dealing
    with data (and all the security challenges associated with that) and the user
    interface (displaying the data in React components). Dealing with each problem
    on its own is easier to solve and less error-prone than handling the complexity
    of both at once.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据访问层**：这是我们将在本节中使用的模式。对于使用RSC架构的新项目来说，这是一个推荐的选择，因为它通过分离处理数据（以及与之相关的所有安全挑战）和用户界面（在React组件中显示数据）的职责，使得实现全栈项目更加容易。单独处理每个问题比同时处理两者的复杂性更容易解决且错误率更低。'
- en: '**Component-level data access**: This is a pattern where the database is queried
    directly in RSCs. This approach can be useful for rapid prototyping and learning.
    However, it should not be used in a production app due to scalability issues and
    the potential introduction of security problems.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组件级数据访问**：这是一种在RSC中直接查询数据库的模式。这种方法对于快速原型设计和学习很有用。然而，由于可扩展性问题以及可能引入的安全问题，它不应在生产应用中使用。'
- en: It is not recommended to mix these approaches, so it’s better to pick one and
    stick to it. In our case, we are going with the “data access layer” approach as
    it is the safest approach for a modern RSC architecture.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 不建议混合这些方法，所以最好选择一个并坚持下去。在我们的情况下，我们选择“数据访问层”方法，因为它是对现代 RSC 架构最安全的做法。
- en: Setting up the database connection
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置数据库连接
- en: 'Let’s start by setting up the necessary packages and initializing a database
    connection:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先设置必要的包和初始化数据库连接：
- en: 'Copy the existing **ch16** folder to a new **ch17** folder, as follows:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将现有的 **ch16** 文件夹复制到一个新的 **ch17** 文件夹，如下所示：
- en: '[PRE0]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Open the **ch17** folder in VS Code and open a Terminal.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 中打开 **ch17** 文件夹并打开一个终端。
- en: 'We are going to use a package called **server-only** to make sure code from
    the database and data layer are only executed on the server-side, and not accidentally
    imported on the client. Install it, as follows:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用一个名为 **server-only** 的包来确保数据库和数据层的代码仅在服务器端执行，而不会意外地导入客户端。按照以下步骤安装它：
- en: '[PRE1]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We are also going to need the **mongoose** package to connect to the database
    and create database schemas and models. Run the following command to install it:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要 **mongoose** 包来连接到数据库并创建数据库模式和模型。运行以下命令来安装它：
- en: '[PRE2]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Create a new **src/db/** folder.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **src/db/** 文件夹。
- en: 'Inside this folder, create a new **src/db/init.js** file, in which we first
    import the **server-only** package to make sure the code is only executed on the
    server:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个文件夹内，创建一个新的 **src/db/init.js** 文件，在其中我们首先导入 **server-only** 包以确保代码仅在服务器上执行：
- en: '[PRE3]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, import **mongoose**:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，导入 **mongoose**：
- en: '[PRE4]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Define and export an **async** function to initialize the database:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义并导出一个 **async** 函数以初始化数据库：
- en: '[PRE5]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we need to define **DATABASE_URL** in a **.env** file. So, create a new
    **.env** file in the root of the project and add the following line:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要在 **.env** 文件中定义 **DATABASE_URL**。因此，在项目的根目录中创建一个新的 **.env** 文件并添加以下行：
- en: '[PRE6]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now that the database connection has been set up, we can move on to creating
    the database models.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在数据库连接已经设置好，我们可以继续创建数据库模型。
- en: Creating the database models
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建数据库模型
- en: 'Now, we are going to create database models for posts and users. These are
    going to be very similar to the ones we created for our blog app in previous chapters.
    Follow these steps to start creating the database models:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将为帖子用户创建数据库模型。这些模型将与我们之前章节中为我们的博客应用创建的模型非常相似。按照以下步骤开始创建数据库模型：
- en: Create a new **src/db/models/** folder.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **src/db/models/** 文件夹。
- en: 'Inside it, create a new **src/db/models/user.js** file, where we first import
    the **server-only** and **mongoose** packages:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中，创建一个新的 **src/db/models/user.js** 文件，在其中我们首先导入 **server-only** 和 **mongoose**
    包：
- en: '[PRE7]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Define **userSchema**, which consists of a unique required **username** and
    a required **password**:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 **userSchema**，它由一个唯一的必需的 **username** 和一个必需的 **password** 组成：
- en: '[PRE8]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We create the Mongoose model if it has not been created yet:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果模型尚未创建，我们创建 Mongoose 模型：
- en: '[PRE9]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Returning the model if it already exists and only creating a new one if it does
    not is necessary to avoid an **OverwriteModelError** issue, which happens when
    the model is imported (and thus redefined) multiple times.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模型已经存在，则返回模型，如果不存在，则创建一个新的模型，这是必要的，以避免 **OverwriteModelError** 问题，该问题发生在模型被导入（因此重新定义）多次时。
- en: 'Create a new **src/db/models/post.js** file, where we first import the **server-only**
    and **mongoose** packages:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **src/db/models/post.js** 文件，在其中我们首先导入 **server-only** 和 **mongoose**
    包：
- en: '[PRE10]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Define **postSchema**, which consists of a required **title** and **author**
    (referencing the **user** model), and optional **contents**:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 **postSchema**，它由一个必需的 **title** 和 **author**（引用 **user** 模型）以及可选的 **contents**
    组成：
- en: '[PRE11]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We create the Mongoose model if it has not been created yet:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果模型尚未创建，我们创建 Mongoose 模型：
- en: '[PRE12]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create a new **src/db/models/index.js** file and re-export the models:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **src/db/models/index.js** 文件并重新导出模型：
- en: '[PRE13]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We re-export the models from this folder to ensure that we can, for example,
    load a post and resolve the `author` by querying the corresponding user. This
    would require defining the `user` model, although it is not directly used. To
    avoid issues like these, we simply load models from a file that defines all models
    upon importing them.
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们从这个文件夹重新导出模型，以确保我们可以，例如，通过查询相应的用户来加载一个帖子并解析 `author`。这需要定义 `user` 模型，尽管它不是直接使用的。为了避免这些问题，我们简单地从定义所有模型的文件中加载模型。
- en: After defining the database models, we can define the data layer functions,
    which will provide various ways to access the database.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义数据库模型之后，我们可以定义数据层函数，这些函数将提供各种访问数据库的方式。
- en: Defining data layer functions
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义数据层函数
- en: Now that we have a database connection and schemas, let’s start defining data
    layer functions that access the database.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了数据库连接和架构，让我们开始定义访问数据库的数据层函数。
- en: Defining the posts data layer
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义帖子数据层
- en: 'We’ll start by defining the data layer for posts. This allows us to access
    all the relevant functions for dealing with posts in our app:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先定义帖子数据层。这允许我们访问我们应用中处理帖子的所有相关函数：
- en: Create a new **src/data/** folder.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **src/data/** 文件夹。
- en: 'Inside it, create a new **src/data/posts.js** file, where we import the **server-only**
    package and the **Post** model:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中，创建一个新的 **src/data/posts.js** 文件，我们将导入 **server-only** 包和 **Post** 模型：
- en: '[PRE14]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Define a **createPost** function that takes a **userId**, **title**, and **contents**
    and creates a new post:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个 **createPost** 函数，它接受 **userId**、**title** 和 **contents** 并创建一个新的帖子：
- en: '[PRE15]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, define a **listAllPosts** function, which first gets all posts from the
    database sorted by creation date descending (showing the newest posts first):'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，定义一个 **listAllPosts** 函数，该函数首先从数据库中获取所有帖子，按创建日期降序排序（首先显示最新帖子）：
- en: '[PRE16]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, we must **populate** the **author** field by resolving the **user** model
    and getting the **username** value from it:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们必须通过解析 **user** 模型并从中获取 **username** 值来填充 **author** 字段：
- en: '[PRE17]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In Mongoose, the `populate` function works like a `JOIN` statement in SQL:
    it takes the ID stored in the `author` field and then checks which model the ID
    references by looking at the `post` schema. In the `post` schema, we defined that
    the `author` field references the `user` schema, so Mongoose will query the `user`
    model for the given ID and return a user object. By providing the second argument,
    we specify that we only want to get the `username` value from the `user` object
    (the ID will always be returned anyway). This is done to avoid leaking internal
    information, such as the (hashed) password of a user.'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 Mongoose 中，`populate` 函数类似于 SQL 中的 `JOIN` 语句：它获取存储在 `author` 字段中的 ID，然后通过查看
    `post` 架构来确定该 ID 引用了哪个模型。在 `post` 架构中，我们定义了 `author` 字段引用 `user` 架构，因此 Mongoose
    将查询 `user` 模型以获取给定的 ID 并返回一个用户对象。通过提供第二个参数，我们指定我们只想从用户对象（ID 总是会返回）中获取 `username`
    值。这样做是为了避免泄露内部信息，例如用户的（散列的）密码。
- en: 'After populating the post objects, we use **.lean()** to turn it into a plain,
    serializable JavaScript object:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在填充帖子对象后，我们使用 **.lean()** 将其转换为纯的、可序列化的 JavaScript 对象：
- en: '[PRE18]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Having a serializable object is necessary to be able to pass the data from an
    RSC to a regular client-side component later since all data passed to the client
    needs to cross the network boundary, and thus needs to be serializable.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 拥有一个可序列化的对象是必要的，以便能够将数据从 RSC 传递到常规客户端组件，因为所有传递给客户端的数据都需要跨越网络边界，因此需要可序列化。
- en: 'Lastly, we must define a **getPostById** function, which finds a single post
    by ID, populates the **author** field, and turns the result into a plain JavaScript
    object by using **lean()**:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须定义一个 **getPostById** 函数，该函数通过 ID 查找一个单独的帖子，填充 **author** 字段，并使用 **lean()**
    将结果转换为纯 JavaScript 对象：
- en: '[PRE19]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Defining the data layer for users
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义用户数据层
- en: 'We are now going to define the data layer for users. This will involve creating
    a JWT for authentication. Again, a lot of the code will be very similar to what
    we previously implemented for our blog app. Follow these steps to start defining
    the data layer for users:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将定义用户数据层。这将涉及创建 JWT 进行身份验证。再次强调，大部分代码将与我们在博客应用中之前实现的内容非常相似。按照以下步骤开始定义用户数据层：
- en: 'Install **bcrypt** (for hashing the user password) and **jsonwebtoken** (for
    handling JWTs):'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 **bcrypt**（用于散列用户密码）和 **jsonwebtoken**（用于处理 JWT）：
- en: '[PRE20]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create a new **src/data/users.js** file, where we import **server-only**, **bcrypt**,
    **jwt**, and the **User** model:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **src/data/users.js** 文件，我们将导入 **server-only**、**bcrypt**、**jwt** 和 **User**
    模型：
- en: '[PRE21]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Define a **createUser** function, where we hash the given password and then
    create a new instance of the **User** model and save it:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个 **createUser** 函数，其中我们散列给定的密码，然后创建一个新的 **User** 模型实例并将其保存：
- en: '[PRE22]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, define a **loginUser** function, which first tries to find a user with
    the given username and throws an error if no user is found:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，定义一个 **loginUser** 函数，该函数首先尝试找到具有给定用户名的用户，如果没有找到用户则抛出错误：
- en: '[PRE23]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: Depending on your security requirements, you might want to consider not telling
    a potential attacker that a username exists and instead return a generic message
    such as “Invalid username or password.” However, in our case, the usernames are
    assumed to be public information because each user is an author on the blog and
    their usernames are published with their articles.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的安全需求，您可能希望考虑不要告诉潜在的攻击者存在用户名，而是返回一个通用消息，例如“无效的用户名或密码”。然而，在我们的情况下，假设用户名是公开信息，因为每个用户都是博客的作者，并且他们的用户名与文章一起发布。
- en: 'Then, use **bcrypt** to compare the provided password against the hashed password
    from the database and throw an error if the password is invalid:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用**bcrypt**将提供的密码与数据库中的哈希密码进行比较，如果密码无效则抛出一个错误：
- en: '[PRE24]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Lastly, generate, sign, and return a JWT:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，生成、签名并返回一个JWT：
- en: '[PRE25]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, we are going to define a function to get the user information (for now,
    we’re only going to get the username, but this could be extended later) from a
    user ID. If the user ID does not exist, we throw an error:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将定义一个函数从用户ID中获取用户信息（目前我们只获取用户名，但以后可以扩展这个功能）。如果用户ID不存在，我们抛出一个错误：
- en: '[PRE26]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, define a function to get the user ID from a token, making sure to verify
    the token signature in addition to decoding the JWT, by using **jwt.verify**:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，定义一个函数从令牌中获取用户ID，确保在解码JWT的同时验证令牌签名，使用**jwt.verify**：
- en: '[PRE27]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, define a function to get the user information from a token by combining
    the **getUserIdByToken** and **getUserInfoById** functions:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，定义一个函数通过组合**getUserIdByToken**和**getUserInfoById**函数从令牌中获取用户信息：
- en: '[PRE28]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We still need to define the **JWT_SECRET** environment variable for our code
    to work. Edit **.env** and add it, as follows:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们仍然需要定义**JWT_SECRET**环境变量，以便我们的代码能够工作。编辑**.env**并添加它，如下所示：
- en: '[PRE29]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'This is a very basic implementation of authentication with Next.js. For a large-scale
    project, it is recommended to look into a fully-fledged authentication solution,
    such as Auth.js (formerly next-auth), Auth0, or Supabase. Check out the Next.js
    docs for more information on authentication with Next.js: [https://nextjs.org/docs/app/building-your-application/authentication](https://nextjs.org/docs/app/building-your-application/authentication).'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这是非常基础的Next.js身份验证实现。对于大型项目，建议考虑一个完整的身份验证解决方案，如Auth.js（以前称为next-auth）、Auth0或Supabase。查看Next.js文档以获取有关Next.js身份验证的更多信息：[https://nextjs.org/docs/app/building-your-application/authentication](https://nextjs.org/docs/app/building-your-application/authentication)。
- en: Now that we have a data layer to access the database, we can start implementing
    RSCs and Server Actions, which are going to call functions from the data layer
    to access information from the database and render React components that display
    it, turning our static blog app into a fully functional blog.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了数据层来访问数据库，我们可以开始实现RSCs和Server Actions，这些将调用数据层中的函数来访问数据库中的信息并渲染显示这些信息的React组件，将我们的静态博客应用转变为一个完全功能的博客。
- en: Using RSCs to fetch data from the database
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RSCs从数据库中获取数据
- en: As we have learned, when using Next.js, React components are considered to be
    Server Components by default, so all page components are already executed and
    rendered on the server. Only if we need to use client-only functions, such as
    hooks or input fields, do we need to turn our components into a client component
    by using the `"use client"` directive. For all components that do not require
    user interaction, we can simply keep them as server components, and they will
    only be statically rendered and served as as HTML (encoded in the RSC payload)
    and not hydrated on the client. To the client (the browser), it will seem as if
    these React components don’t even exist as the browser will only see static HTML
    code. This pattern greatly improves the performance of our web application as
    the client doesn’t need to load JavaScript to render such components. It also
    reduces the bundle size because less JavaScript code is needed to load our web
    application.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所学的，在使用Next.js时，React组件默认被认为是服务器组件，所以所有页面组件都已经执行并在服务器上渲染。只有当我们需要使用仅客户端函数，如hooks或输入字段时，我们才需要通过使用“`use
    client`”指令将我们的组件转换为客户端组件。对于所有不需要用户交互的组件，我们可以简单地保持它们作为服务器组件，并且它们将仅作为静态HTML（编码在RSC有效载荷中）渲染和提供，不会在客户端进行激活。对于客户端（浏览器），这些React组件似乎根本不存在，因为浏览器只会看到静态HTML代码。这种模式大大提高了我们Web应用程序的性能，因为客户端不需要加载JavaScript来渲染这些组件。它还减少了包的大小，因为需要加载我们的Web应用程序的JavaScript代码更少。
- en: Now, let’s implement RSCs to fetch data from the database.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现 RSCs 以从数据库中获取数据。
- en: Fetching a list of posts
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取帖子列表
- en: 'We’ll start by implementing the `HomePage`, where we fetch and render a list
    of posts:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先实现 `HomePage`，其中我们获取并渲染帖子列表：
- en: 'Edit **src/app/page.js** and import the **initDatabase** and **listAllPosts**
    functions:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **src/app/page.js** 并导入 **initDatabase** 和 **listAllPosts** 函数：
- en: '[PRE30]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Turn the **HomePage** component into an **async** function, which allows us
    to wait until the data is fetched before rendering the component:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **HomePage** 组件转换为 **async** 函数，这允许我们在渲染组件之前等待数据获取：
- en: '[PRE31]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Replace* the sample **posts** array with the following code:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*替换* 样本的 **posts** 数组为以下代码：'
- en: '[PRE32]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Fetching a single post
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取单个帖子
- en: 'Now that we can view a list of posts, let’s continue by implementing the process
    of fetching a single post for `ViewPostPage`. Follow these steps to get started:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以查看帖子列表，接下来让我们继续实现 `ViewPostPage` 的获取单个帖子的过程。按照以下步骤开始：
- en: 'Edit **src/app/posts/[id]/page.js** and import the **notFound**, **getPostById**,
    and **initDatabase** functions:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **src/app/posts/[id]/page.js** 并导入 **notFound**、**getPostById** 和 **initDatabase**
    函数：
- en: '[PRE33]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Turn the page component into an **async** function:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将页面组件转换为 **async** 函数：
- en: '[PRE34]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Replace* the sample **post** object with calls to **initDatabase** and **getPostById**:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*替换* 样本的 **post** 对象为对 **initDatabase** 和 **getPostById** 的调用：'
- en: '[PRE35]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now, we need to create a `not-found.js` file to catch the error and render a
    different component instead.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个 `not-found.js` 文件来捕获错误并渲染不同的组件。
- en: 'Create a new **src/app/posts/[id]/not-found.js** file, where we render a “Post
    not found!” message, as follows:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **src/app/posts/[id]/not-found.js** 文件，其中我们渲染“帖子未找到！”信息，如下所示：
- en: '[PRE36]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Tip
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: We can also add an **app/not-found.js** file to handle unmatched URLs for the
    whole application. If users access a path that is not defined by the app, the
    component defined in that file will be rendered instead.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以添加一个 **app/not-found.js** 文件来处理整个应用程序中不匹配的 URL。如果用户访问应用程序未定义的路径，该文件中定义的组件将被渲染。
- en: 'Additionally, we can create an error component that will be rendered for any
    errors, such as not being able to connect to the database. Create a new **src/app/posts/[id]/error.js**
    file, where we render an “Error while loading the post!” message, as follows:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们还可以创建一个错误组件，用于渲染任何错误，例如无法连接到数据库。创建一个新的 **src/app/posts/[id]/error.js**
    文件，其中我们渲染“加载帖子时出错！”信息，如下所示：
- en: '[PRE37]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Error pages need to be client components, so we added a `'use` `client'` directive.
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 错误页面需要是客户端组件，因此我们添加了 `'use` `client'` 指令。
- en: Info
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: The reason why error pages need to be client components is that they use the
    React **ErrorBoundary** feature, which is implemented as class components (using
    **componentDidCatch**). React class components cannot be server components, so
    we need to make the error page a client component.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 错误页面需要是客户端组件的原因是它们使用了 React **ErrorBoundary** 功能，该功能作为类组件实现（使用 **componentDidCatch**）。React
    类组件不能是服务器组件，因此我们需要将错误页面作为客户端组件。
- en: 'We still need to make a small adjustment to the **Post** component because
    the **_id** is now actually not a string anymore; instead, it’s an **ObjectId**
    object. Edit **src/components/Post.jsx** and change the type, as follows:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们仍然需要对 **Post** 组件进行小幅调整，因为 **_id** 现在实际上不再是字符串了；相反，它是一个 **ObjectId** 对象。编辑
    **src/components/Post.jsx** 并更改类型，如下所示：
- en: '[PRE38]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Make sure Docker and the MongoDB container are running properly!
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保 Docker 和 MongoDB 容器正常运行！
- en: 'Run the dev server, as follows:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下步骤运行开发服务器：
- en: '[PRE39]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Go to **http://localhost:3000** and click on one of the posts in the list;
    you will see that the post loads successfully. If a post does not exist (for example,
    if you change a single digit in the ID), the “Post not found!” message will be
    shown. If there was any other error (for example, an invalid ID), the “Error while
    loading the post!” message will be shown:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 **http://localhost:3000** 并点击列表中的任意帖子；您将看到帖子成功加载。如果帖子不存在（例如，如果您更改了 ID 中的单个数字），将显示“帖子未找到！”信息。如果发生任何其他错误（例如，无效的
    ID），将显示“加载帖子时出错！”信息：
- en: '![Figure 17.4 – Showing a post and the not found/error components](img/B19385_17_4.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.4 – 显示帖子以及未找到/错误组件](img/B19385_17_4.jpg)'
- en: Figure 17.4 – Showing a post and the not found/error components
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.4 – 显示帖子以及未找到/错误组件
- en: Note
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If there are no posts in your database yet, either create a new post by using
    the blog app from earlier chapters or wait until we implement the create post
    functionality using Next.js at the end of this chapter.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的数据库中还没有帖子，您可以通过使用前面章节中的博客应用创建一个新的帖子，或者等待我们在本章末尾使用Next.js实现创建帖子功能。
- en: After implementing RSCs for fetching posts, our blog app is now connected to
    the database. However, all it can do right now is show posts; there is no way
    for the user to interact with the app yet. Let’s move on to making our blog app
    interactive by adding Server Actions to it.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现用于获取帖子的RSC（React Server Components）之后，我们的博客应用现在已连接到数据库。然而，目前它只能显示帖子；用户还无法与该应用进行交互。让我们继续通过添加服务器操作（Server
    Actions）来使我们的博客应用变得交互式。
- en: Using Server Actions to sign up, log in, and create new posts
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用服务器操作进行注册、登录和创建新帖子
- en: So far, we have only been fetching data from the database on the server and
    sending it to the client, but for user interactivity, we need to be able to send
    data back from the client to the server. To be able to do this, React introduced
    a pattern called Server Actions.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只从服务器上的数据库获取数据并发送给客户端，但为了实现用户交互，我们需要能够从客户端将数据发送回服务器。为了能够做到这一点，React引入了一种称为服务器操作的模式。
- en: '`"use server"` directive, and then either importing them into a client component
    or passing them to a client component via props. While regular JavaScript functions
    cannot be passed to client components (because they aren’t serializable), Server
    Actions can be.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`"use server"`指令，然后要么将它们导入到客户端组件中，要么通过props将它们传递给客户端组件。虽然常规JavaScript函数不能传递给客户端组件（因为它们不可序列化），但服务器操作可以。'
- en: Note
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can define a whole file to be full of Server Actions by adding the **"use
    server"** directive at the beginning of a file. This will tell the bundler that
    all functions in this file are Server Actions; it *does not* define components
    inside it as server components (to enforce something to be executed on the server,
    use the **server-only** package instead, as explained). You can then import functions
    from such a file in client components.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在文件开头添加**"use server"**指令来定义一个充满服务器操作的整个文件。这将告诉打包器该文件中的所有函数都是服务器操作；它**不**定义文件内的组件为服务器组件（为了强制在服务器上执行某些操作，请使用如上所述的**server-only**包，而不是使用服务器组件）。然后您可以从这样的文件中导入函数到客户端组件中。
- en: 'In client components, we can make use of the `useFormState` hook, which has
    a similar signature to `useState` but allows us to execute server actions (on
    the server) and get back the result on the client. The `useFormState` hook’s signature
    looks as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端组件中，我们可以使用`useFormState`钩子，它的签名与`useState`类似，但允许我们执行服务器操作（在服务器上）并在客户端获取结果。`useFormState`钩子的签名如下：
- en: '[PRE40]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In the React 19 release, **useFormState** hook will be renamed to **useActionState**.
    See [https://react.dev/reference/react/useActionState](https://react.dev/reference/react/useActionState)
    for more information.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在React 19版本中，**useFormState**钩子将被重命名为**useActionState**。有关更多信息，请参阅[https://react.dev/reference/react/useActionState](https://react.dev/reference/react/useActionState)。
- en: 'As we can see, we pass in a function (Server Action) and an initial state.
    The hook then returns the current state and a `formAction` function. The state
    is initially set to the initial state, and updated to the result of the Server
    Action after the `formAction` function is called. On the server side, the Server
    Action signature looks as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们传递一个函数（服务器操作）和一个初始状态。钩子随后返回当前状态和一个`formAction`函数。状态最初设置为初始状态，并在调用`formAction`函数后更新为服务器操作的结果。在服务器端，服务器操作的签名如下：
- en: '[PRE41]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As we can see, the Server Action function accepts `previousState` (which will
    initially be set to `initialState` from the client) and a `formData` object (which
    is a regular `formData` object from the XMLHttpRequest API web standard). The
    `formData` object contains all information submitted in form fields. This allows
    us to easily submit forms to perform an action on the server and return the result
    to the client.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，服务器操作函数接受`previousState`（最初将从客户端设置为`initialState`）和一个`formData`对象（这是一个来自XMLHttpRequest
    API网络标准的常规`formData`对象）。`formData`对象包含表单字段中提交的所有信息。这使得我们能够轻松地提交表单以在服务器上执行操作并将结果返回给客户端。
- en: Now, let’s start using Server Actions to implement the signup page in our blog
    app.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始使用服务器操作来实现我们博客应用中的注册页面。
- en: Implementing the signup page
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现注册页面
- en: 'The first action a user needs to take to interact with the blog app is signing
    up, so let’s start by implementing this feature. Follow these steps to get started:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 用户与博客应用交互需要采取的第一个操作是注册，因此让我们从实现这个功能开始。按照以下步骤开始：
- en: 'We start by implementing the client component. Edit **src/components/Signup.jsx**
    and mark it as a client component, then import the **useFormState** hook and **PropTypes**:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先实现客户端组件。编辑**src/components/Signup.jsx**，将其标记为客户端组件，然后导入**useFormState**钩子和**PropTypes**：
- en: '[PRE42]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The **Signup** component now needs to accept a **signupAction**, which we are
    going to define on the server side later:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**注册**组件现在需要接受一个**注册操作**，我们将在稍后服务器端定义：'
- en: '[PRE43]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Define a **useFormState** hook, which takes a Server Action and an initial
    state (in our case, an empty object), and returns the current state and an action:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个**useFormState**钩子，它接受一个服务器操作和一个初始状态（在我们的情况下，是一个空对象），并返回当前状态和一个操作：
- en: '[PRE44]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, we can add **action** to the **<form>** tag, as follows:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在**<form>**标签中添加**action**，如下所示：
- en: '[PRE45]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Additionally, we can show an error message below the “Sign Up” button if we
    get a **state.error** message back from the server:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，如果我们从服务器收到**state.error**消息，我们可以在“注册”按钮下方显示一个错误消息：
- en: '[PRE46]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Let’s not forget to define **propTypes** for the **Signup** component. **signupAction**
    is a function:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不要忘记为**注册**组件定义**propTypes**。**注册操作**是一个函数：
- en: '[PRE47]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, we can start implementing the actual server action. Edit **src/app/signup/page.js**
    and import the **redirect** function from **next/navigation** (to navigate to
    the login page after successfully signing up), as well as the **createUser** and
    **initDatabase** functions:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以开始实现实际的服务器操作。编辑**src/app/signup/page.js**，并从**next/navigation**导入**redirect**函数（在成功注册后导航到登录页面），以及**createUser**和**initDatabase**函数：
- en: '[PRE48]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then, outside of the **SignupPage** component, define a new **async** function
    that accepts the previous state (in our case, this is the empty object we defined
    as the initial state, so we can ignore it) and a **formData** object:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在**注册页面**组件外部，定义一个新的**async**函数，该函数接受前一个状态（在我们的情况下，这是我们定义的初始状态，即空对象，因此我们可以忽略它）和一个**formData**对象：
- en: '[PRE49]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We need to tag the function with the **''use server''** directive to turn it
    into a Server Action:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要给函数加上**'use server'**指令，将其转换为服务器操作：
- en: '[PRE50]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Then, we can initialize the database and attempt to create a user:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以初始化数据库并尝试创建用户：
- en: '[PRE51]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: As you can see, Server Actions build upon existing web APIs and use the `FormData`
    API for form submission. We can simply call `.get()` with the `name` of the input
    field and it will contain the value provided in the respective input field.
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，服务器操作建立在现有的Web API之上，并使用`FormData` API进行表单提交。我们可以简单地使用`name`属性调用`.get()`，它将包含相应输入字段中提供的值。
- en: 'If there is an error, we return the error message (which will then be shown
    in the **Signup** client component):'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有错误，我们返回错误消息（然后将在**注册**客户端组件中显示）：
- en: '[PRE52]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Otherwise, if everything went well, we redirect to the login page:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，如果一切顺利，我们重定向到登录页面：
- en: '[PRE53]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'After defining the Server Action, we can pass it to the **Signup** component,
    as follows:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在定义服务器操作后，我们可以将其传递给**注册**组件，如下所示：
- en: '[PRE54]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Alternatively, the client component could directly import the `signupAction`
    function from a file. So long as the function has the `'use server'` directive,
    it will be executed on the server. In this case, we only need the function on
    this specific page, so it makes more sense to define it on the page and pass it
    to the component.
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，客户端组件可以直接从文件中导入`signupAction`函数。只要函数有`'use server'`指令，它就会在服务器上执行。在这种情况下，我们只需要在这个特定页面上使用该函数，因此将其定义在页面上并传递给组件更有意义。
- en: 'Run the dev server, as follows:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行开发服务器，如下所示：
- en: '[PRE55]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Go to **http://localhost:3000/signup** and try entering a username and password.
    It should work successfully and redirect you to the login screen (the change is
    subtle, but the submit button changes from **Sign Up** to **Log In**).
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次访问**http://localhost:3000/signup**并尝试输入用户名和密码。它应该成功并重定向到登录屏幕（变化微妙，但提交按钮从**注册**变为**登录**）。
- en: 'Go to **http://localhost:3000/signup** again and try entering the same username.
    You will get the following error:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次访问**http://localhost:3000/signup**并尝试输入相同的用户名。你会得到以下错误：
- en: '![Figure 17.5 – An error is shown when the username already exists](img/B19385_17_5.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图17.5 – 当用户名已存在时显示错误](img/B19385_17_5.jpg)'
- en: Figure 17.5 – An error is shown when the username already exists
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.5 – 当用户名已存在时显示错误
- en: Of course, this error message is not very user-friendly, so we could do some
    work to improve the error messages here. But for now, this is sufficient as an
    example to show how Server Actions work.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个错误信息并不非常友好，所以我们可以做一些工作来改进这里的错误信息。但到目前为止，这已经足够作为一个示例来展示服务器操作是如何工作的。
- en: As you can see, RSCs and Server Actions make implementing features that interface
    with the database straightforward. As an additional bonus, all Server Actions
    that are submitted via `<form>` even work with JavaScript disabled – try it out
    by repeating *Steps 15* and *16* with JavaScript disabled!
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，RSCs和服务器操作使实现与数据库交互的功能变得简单。作为额外的奖励，通过`<form>`提交的所有服务器操作即使在禁用JavaScript的情况下也能正常工作——尝试通过禁用JavaScript重复*步骤15*和*16*来试试！
- en: Implementing the login page and JWT handling
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现登录页面和JWT处理
- en: Now that users can sign up, we need a way for them to log in. This also means
    that we will need to implement functionality to create and store JWT. Now that
    we have more control over the server-client interaction with Next.js, we can store
    the JWT in a cookie instead of in memory. This means that the user session will
    persist even when they refresh the page.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用户可以注册，我们需要一种方式让他们登录。这也意味着我们需要实现创建和存储JWT的功能。现在，由于我们对Next.js中的服务器-客户端交互有了更多的控制，我们可以将JWT存储在cookie中而不是内存中。这意味着用户会话将在他们刷新页面时持续存在。
- en: 'Let’s start implementing the login page and JWT handling:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始实现登录页面和JWT处理：
- en: 'We’ll start by implementing the client component. Edit **src/components/Login.jsx**
    and turn it into a client component:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先实现客户端组件。编辑**src/components/Login.jsx**并将其转换为客户端组件：
- en: '[PRE56]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Then, import the **useFormState** hook and **PropTypes**:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，导入**useFormState**钩子和**PropTypes**：
- en: '[PRE57]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Accept **loginAction** as props. We are going to use this to define the **useFormState**
    hook:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受**loginAction**作为props。我们将使用它来定义**useFormState**钩子：
- en: '[PRE58]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Pass **formAction**, which was returned from the hook, to the **<****form>**
    element:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将从钩子返回的**formAction**传递给`**<form>**`元素：
- en: '[PRE59]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now, we can display potential errors at the end of the component:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在组件末尾显示潜在的错误：
- en: '[PRE60]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Lastly, define **propTypes**, as follows:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，定义**propTypes**，如下所示：
- en: '[PRE61]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, we can create the **loginAction** Server Action. Edit **src/app/login/page.js**
    and import the **cookies** and **redirect** functions from Next.js, as well as
    the **loginUser** and **initDatabase** functions from our data layer:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以创建**loginAction**服务器操作。编辑**src/app/login/page.js**并从Next.js导入**cookies**和**redirect**函数，以及从我们的数据层导入**loginUser**和**initDatabase**函数：
- en: '[PRE62]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Define a new **loginAction** outside of the **LoginPage** component, in which
    we attempt to log in with the given username and password:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**LoginPage**组件外部定义一个新的**loginAction**，在其中我们尝试使用给定的用户名和密码进行登录：
- en: '[PRE63]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'If this fails, we return the error message:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果失败，我们返回错误信息：
- en: '[PRE64]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Otherwise, we set an **AUTH_TOKEN** cookie with an expiry of 24 hours (the
    same expiry time as the JWT we created), and make it **secure** and **httpOnly**:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，我们设置一个有效期24小时的**AUTH_TOKEN**cookie（与创建的JWT的有效期相同），并使其**安全**和**httpOnly**：
- en: '[PRE65]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Note
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The **httpOnly** attribute makes sure cookies cannot be accessed by client JavaScript,
    reducing the possibility of cross-site scripting attacks in our app. The **secure**
    attribute ensures that the cookie is set on the HTTPS version of the website.
    To improve the development experience, this doesn’t apply to localhost.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**httpOnly**属性确保cookie不能被客户端JavaScript访问，从而减少我们应用中跨站脚本攻击的可能性。**secure**属性确保cookie在网站的HTTPS版本上设置。为了提高开发体验，这不会应用于localhost。'
- en: 'After setting the cookie, we redirect to the home page:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置cookie后，我们重定向到主页：
- en: '[PRE66]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Finally, we pass the **loginAction** to the **Login** component:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将**loginAction**传递给**Login**组件：
- en: '[PRE67]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Go to **http://localhost:3000/login** and try entering a username that doesn’t
    exist; you will get an error. Then, try entering the same username and password
    that you used to sign up earlier. It should work successfully and redirect you
    to the home page.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**http://localhost:3000/login**并尝试输入一个不存在的用户名；你会得到一个错误。然后，尝试输入你之前注册时使用的相同用户名和密码。它应该可以成功并重定向你到主页。
- en: Checking if the user is logged in
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查用户是否已登录
- en: 'You may have noticed that after the user logs in, the navigation bar doesn’t
    change. We still have to check if the user is logged in and then adjust the navigation
    bar accordingly. Let’s do that now:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在用户登录后，导航栏没有改变。我们仍然需要检查用户是否已登录，然后相应地调整导航栏。现在让我们来做这件事：
- en: 'Edit **src/app/layout.js** and import the **cookies** function from Next.js
    and the **getUserInfoByToken** function from our data layer:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑**src/app/layout.js**并从Next.js导入**cookies**函数，从我们的数据层导入**getUserInfoByToken**函数：
- en: '[PRE68]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Turn **RootLayout** into an **async** function:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**RootLayout**转换为**async**函数：
- en: '[PRE69]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Get the **AUTH_TOKEN** cookie and pass its value to the **getUserInfoByToken**
    function to get the **user** object, *replacing* the sample **user** object we
    defined earlier:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取**AUTH_TOKEN**cookie并将其值传递给**getUserInfoByToken**函数以获取**user**对象，*替换*我们之前定义的示例**user**对象：
- en: '[PRE70]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: If you still have the home page open from earlier, it should hot reload automatically
    and show your username and the logout button.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你之前还打开了主页，它应该会自动热重载并显示你的用户名和注销按钮。
- en: We are already passing `user?.username` to the `Navigation` component, so that’s
    all there is to it!
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将`user?.username`传递给`Navigation`组件，所以这就完成了！
- en: Implementing logout
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现注销
- en: 'Now that we can show a different navigation bar when the user is logged in,
    we can finally see the logout button. However, it doesn’t work yet. We’ll implement
    the logout button now:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以根据用户是否登录显示不同的导航栏，我们终于可以看到注销按钮了。然而，它现在还不工作。我们现在将实现注销按钮：
- en: 'Edit **src/app/layout.js** and define a **logoutAction** Server Action outside
    of the **RootLayout** component:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑**src/app/layout.js**并在**RootLayout**组件外部定义一个**logoutAction**服务器操作：
- en: '[PRE71]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Inside this action, we simply delete the **AUTH_TOKEN** cookie:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个操作中，我们简单地删除了**AUTH_TOKEN**cookie：
- en: '[PRE72]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Pass **logoutAction** to the **Navigation** component, as follows:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式将**logoutAction**传递给**Navigation**组件：
- en: '[PRE73]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Edit **src/components/Navigation.jsx** and add **logoutAction** to **UserBar**
    and the logout form:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑**src/components/Navigation.jsx**并在**UserBar**和注销表单中添加**logoutAction**：
- en: '[PRE74]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Add the action to **propTypes** of the **UserBar** component, as follows:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将操作添加到**UserBar**组件的**propTypes**中，如下所示：
- en: '[PRE75]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Then, add **logoutAction** as props to the **Navigation** component and pass
    it down to the **UserBar** component:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将**logoutAction**作为props添加到**Navigation**组件，并传递给**UserBar**组件：
- en: '[PRE76]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Finally, change **propTypes** of the **Navigation** component, as follows:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，更改**Navigation**组件的**propTypes**，如下所示：
- en: '[PRE77]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Click the **Logout** button to see the navigation bar change back to show the
    **Log In** and **Sign** **Up** links.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Logout**按钮以看到导航栏变回显示**登录**和**注册**链接。
- en: Now, our users can finally log in and log out again successfully. Let’s move
    on to implementing post creation.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的用户可以最终成功登录和注销。让我们继续实现帖子创建。
- en: Implementing post creation
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现帖子创建
- en: 'The last feature missing in our blog app is post creation. We can use Server
    Actions and a JWT to authenticate the user and allow them to create a post. Follow
    these steps to implement post creation:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们博客应用中缺少的最后一个功能是帖子创建。我们可以使用服务器操作和JWT来验证用户身份，并允许他们创建帖子。按照以下步骤实现帖子创建：
- en: 'This time, we start by implementing the Server Action. Edit **src/app/create/page.js**
    and import the **cookies**, **redirect**, **createPost**, **getUserIdByToken**,
    and **initDatabase** functions:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次，我们首先实现服务器操作。编辑**src/app/create/page.js**并导入**cookies**、**redirect**、**createPost**、**getUserIdByToken**和**initDatabase**函数：
- en: '[PRE78]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Inside the **CreatePostPage** component, get the token from the cookie:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**CreatePostPage**组件内部，从cookie中获取令牌：
- en: '[PRE79]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Still inside the **CreatePostPage** component, define a Server Action:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在**CreatePostPage**组件内部，定义一个服务器操作：
- en: '[PRE80]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: We won’t be using the `useFormState` hook this time because we don’t need to
    handle the state or result of the action on the client side. So, the Server Action
    does not have the `(prevState, formData)` signature and instead has a `(``formData)`
    signature.
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这次我们不会使用`useFormState`钩子，因为我们不需要在客户端处理操作的state或result。因此，服务器操作没有`(prevState,
    formData)`签名，而是有`(``formData)`签名。
- en: 'Inside the Server Action, we get the **userId** value from the token, then
    initialize the database connection and create a new post:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在服务器操作中，我们从令牌中获取**userId**值，然后初始化数据库连接并创建一个新的帖子：
- en: '[PRE81]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Lastly, we redirect to the **ViewPost** page of the newly created post:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将重定向到新创建的帖子的**ViewPost**页面：
- en: '[PRE82]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'If the user isn’t logged in, we can now show an error message:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户未登录，我们现在可以显示一个错误消息：
- en: '[PRE83]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Otherwise, we render the **CreatePost** component, passing **createPostAction**
    to it:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，我们渲染**CreatePost**组件，并将**createPostAction**传递给它：
- en: '[PRE84]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Now, we can adjust the **CreatePost** component. We *don’t* need to turn it
    into a client component this time because we won’t be using the **useFormState**
    hook. Edit **src/components/CreatePost.jsx** and import **PropTypes**:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以调整**CreatePost**组件。这次我们*不需要*将其转换为客户端组件，因为我们不会使用**useFormState**钩子。编辑**src/components/CreatePost.jsx**并导入**PropTypes**：
- en: '[PRE85]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Then, add the **createPostAction** as props and pass it to the form element:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将**createPostAction**作为属性传递给表单元素：
- en: '[PRE86]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Finally, define **propTypes**, as follows:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，定义**propTypes**，如下所示：
- en: '[PRE87]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Go to **http://localhost:3000**, log in again, and then click the **Create Post**
    link. Enter a title and some contents and click the **Create** button; you should
    get redirected to the **ViewPost** page of the newly created blog post!
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**http://localhost:3000**，再次登录，然后点击**创建帖子**链接。输入标题和一些内容，然后点击**创建**按钮；你应该会被重定向到新创建的博客帖子的**查看帖子**页面！
- en: Summary
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about RSCs, why they were introduced, what their
    advantages are, and how they fit into our full-stack architecture. Then, we learned
    how to safely implement RSCs by introducing a data layer into our app. Afterward,
    we fetched data from our database and rendered components using RSCs. Finally,
    we learned about Server Actions and added interactive features to our blog app.
    Now, our blog app is fully functional again!
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了RSCs（React Server Components），为什么引入它们，它们的优点是什么，以及它们如何融入我们的全栈架构。然后，我们通过在应用程序中引入数据层来安全地实现RSCs。之后，我们使用RSCs从数据库中获取数据并渲染组件。最后，我们学习了服务器操作，并为我们博客应用程序添加了交互功能。现在，我们的博客应用程序再次完全功能正常！
- en: In the next chapter, [*Chapter 18*](B19385_18.xhtml#_idTextAnchor321), *Advanced
    Next.js Concepts and Optimizations*, we are going to dive deep into how Next.js
    works and how we can further optimize our app when using it. We are going to learn
    about caching, image and font optimizations, and how to define metadata for SEO
    optimization.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，[*第18章*](B19385_18.xhtml#_idTextAnchor321)，*高级Next.js概念和优化*，我们将深入探讨Next.js的工作原理以及在使用它时如何进一步优化我们的应用程序。我们将学习关于缓存、图像和字体优化，以及如何定义SEO优化的元数据。
