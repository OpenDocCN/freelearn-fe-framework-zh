- en: 11\. Working with Vuex – Organizing Larger Stores
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to better organize larger Vuex stores. As
    your applications grow in complexity and features, your store file may become
    harder to work with. Even simply finding things can become a difficult chore as
    the file grows larger and larger. This chapter will discuss two different approaches
    to making it easier to organize your stores for simpler updates. The first approach
    will have you splitting up your code across different files whereas the second
    will use a more advanced Vuex feature, modules.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, the stores we have worked on have been simple and short. But, as everyone
    knows, even the simplest of applications tend toward complexity over time. As
    you have learned in the previous chapters, your store can contain a **state**,
    a block of **getters**, a block of **mutations** and **actions**, and as you will
    learn later in this chapter, **modules**.
  prefs: []
  type: TYPE_NORMAL
- en: As your application grows, having one file for your Vuex store could become
    hard to manage. Both bug fixing and updates for new functionality could become
    more difficult. This chapter will discuss two different ways to help manage this
    complexity and organize your Vuex stores. To be clear, these are *optional* things
    you can do to help manage your store. If your store is simple and you would like
    to keep it that way, that is fine. You can always use these approaches in the
    future, and the great thing is that no-one outside your store will need to be
    aware – they will continue to use Vuex data as they did before. You can keep these
    techniques in mind as a set of tools to help you when your application needs to
    level up. Let's start with the simplest of methods, file splitting.
  prefs: []
  type: TYPE_NORMAL
- en: Approach One – Using File Splitting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first approach, and certainly the simplest one, involves simply taking
    the code of your various Vuex parts (the `state`, the `getters`, and so forth)
    and moving them into their own files. These files can then be imported by the
    main Vuex Store and used as normal. Let''s consider a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is from the first exercise in *Chapter 9*, *Working with Vuex – State,
    Getters, Actions, and Mutations*, and is a store with only three state values.
    To migrate the state to a new file, you could create a new file in the `store`
    folder, called `state.js`, and set it up like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, back in your store, modify it to `import` and make use of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'While this example ends up being *more* lines of code, you can see how we are
    beginning to separate out different parts of the store into different files to
    make it easier to update. Let''s consider a slightly larger example, again taking
    earlier work from the second exercise in *Chapter 9*, *Working with Vuex – State,
    Getters, Actions, and Mutations*. Here is the original store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This example only uses `state` values and a `getter`, but let''s move both
    of them into new files. First, let''s move the `state` into a file called `state.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And next, let''s move the `getters` into a file called `getters.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can update the store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Applying the same type of update to `mutations` and `actions` would follow the
    exact same pattern, and obviously, you do not have to split everything. You could,
    for example, keep the state values in the main file but only split out your functions
    (`getters`, `mutations`, and `actions`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11.01: Using File Splitting'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we are going to use file splitting across a slightly larger
    Vue store. Honestly, it is not very large at all, but we will use file splitting
    to handle `state`, `getters`, `mutations`, and `actions`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access the code files for this exercise, visit [https://packt.live/32uwiKB](https://packt.live/32uwiKB):'
  prefs: []
  type: TYPE_NORMAL
- en: Generate a new Vue application and add Vuex support.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the default store''s `index.js` file (located at `src/store/index.js`)
    to import the four files we will create to represent the store:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit the new `state.js` file to add values for first and last names, numbers
    representing the amounts of cats and dogs possessed by the person in question,
    and a favorite film:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a `getter.js` file that defines a `getter` for the full name and the total
    number of pets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add a `mutations.js` file for adding the number of cats and dogs, setting
    the first and last name, and adding the favorite film:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add `actions.js` to define one action, `updateFavoriteFilm`. This
    will make a network request to the `Star Wars` API to ensure that the new favorite
    film is only allowed if it is a Star Wars film:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To see it in action, update `src/App.vue` to access various parts of the store.
    The only point of this step is to drive home the idea that how you use the store
    does not change:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code will generate an output as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 11.1: Output from the newly organized store'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_11_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 11.1: Output from the newly organized store'
  prefs: []
  type: TYPE_NORMAL
- en: You have now seen a (somewhat simple) example of using file splitting to manage
    the size of your Vuex store. While the functionality is no different than what
    you have seen before, as your application grows, you will probably find it much
    easier to make additions and fixes.
  prefs: []
  type: TYPE_NORMAL
- en: Approach Two – Using Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous approach, we mainly just moved lines of code into other files.
    As we said, while this made it easier to work on the store itself, it changed
    nothing about how the store was used by Vue components. **Modules** help us deal
    with complexity at the level where components come in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine a large `state` object containing values representing many different
    things, such as this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This example contains information about a person, data related to books, and
    a set of values representing robots. That is a lot of data covering three uniquely
    different topics. Moving this into its own file does not necessarily make it easier
    to use or help keep things organized. This complexity would also spill over to
    `getters`, `mutations`, and `actions`. Given an action named `setName`, you could
    assume it applies to the state values representing the person, but if other state
    values had similar names, it could begin to get messy.
  prefs: []
  type: TYPE_NORMAL
- en: This is where modules come in. A module allows us to define a separate `state`,
    `getters`, `mutations`, and `actions` completely separated from the **root** or
    core store.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example store using a `resume` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Both the `state` and `getters` but could also expose `mutations` and `actions`.
    Notice how in the `resume` module `getters`, `totalJobs`, the `state` variable
    refers to its own state, not that of the parent. This is great as it ensures you
    can work within the module and not worry about modifying, by accident, another
    value in the root or some other module. You can access the root state in `getters`
    by using a new third argument, `rootState`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: And actions can use `rootState` via the context object, `context.rootState`.
    In theory, though, your modules should concern themselves with their own data
    and only **reach out** to the root when necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using module values, your code must know the name of the module. Consider
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`getters`, `actions`, and `mutations` are *not* differentiated, though. This
    is how you would access both `getters`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The idea behind this is to allow a module, or multiple modules, to potentially
    respond to the same calls. If this does not appeal to you, you can `namespaced`
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then to refer to `getters`, `mutations`, and `actions` for this module, you
    must pass in the name of the module as part of the call. So, for example, the
    getter now becomes: `$store.getters[''resume/totalJobs'']`.'
  prefs: []
  type: TYPE_NORMAL
- en: For the most part, that is the core of module support, but note there are more
    options for how modules can expose themselves globally that are outside the scope
    of this book. See the latter parts of the module documentation ([https://vuex.vuejs.org/guide/modules.html](https://vuex.vuejs.org/guide/modules.html))
    for examples of that. Finally, note that you can build modules within modules
    as deep as you like. Obviously, you want to put some thought into building incredibly
    deeply nested modules, but if you want to do that, Vuex allows it!
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11.02: Making Use of Modules'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we'll work with a Vuex store that makes use of not one but
    two modules, and to make it more interesting, one of the modules will be stored
    in another file, showing that we can also use the first approach when using modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access the code files for this exercise, visit [https://packt.live/35d1zDv](https://packt.live/35d1zDv):'
  prefs: []
  type: TYPE_NORMAL
- en: As usual, generate a new Vue application and ensure you add Vuex.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the store file (`store/index.js`), add two `state` values for the first
    and last names and a getter to return both:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add a `resume` module to the `store` file. It will have two `state` values,
    one representing an open-for-hire value and the other, an array of past jobs.
    Lastly, add a getter to return the total number of jobs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now create a new file for the next module, `store/portfolio.js`. This will
    contain a `state` value representing an array of websites worked on and a mutation
    to add a value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Back in the main store''s `index.js` file, import `portfolio`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then add `portfolio` to the list of modules, after `resume`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s make use of the modules in our main `src/App.vue` file. Modify
    the template to add calls to various parts of the store:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then add a **form** so that we can add a **new website**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the method for `addSite`. It will commit the `mutation` and clear the
    site value. Be sure to add a local data value for site as well. Here is the complete
    script block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The result will look as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 11.2: The application making use of Vuex data with modules'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_11_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 11.2: The application making use of Vuex data with modules'
  prefs: []
  type: TYPE_NORMAL
- en: Now you have seen yet another way to help manage your Vuex store. **Modules**
    provide a deeper, more complex way to organize your stores. As always, choose
    the method that best fits your application needs and the one you and your team
    are most comfortable with!
  prefs: []
  type: TYPE_NORMAL
- en: Other Approaches to Organizing Your Vuex Stores
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the previous two approaches should give you some good options for managing
    your Vuex store, there are a few other options you may wish to consider as well.
  prefs: []
  type: TYPE_NORMAL
- en: Vuex Pathify
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Vuex Pathify ([https://davestewart.github.io/vuex-pathify/](https://davestewart.github.io/vuex-pathify/))
    is a utility that makes it easier to access the Vuex store via a `resume` and
    a `state` value of `jobs` can be accessed like so: `store.get(''resume/jobs'')`.
    Basically, it creates a shortcut for reading and writing values to the store and
    simplifying synchronization. Fans of **XPath** will love this.'
  prefs: []
  type: TYPE_NORMAL
- en: Vuex Module Generator (VMG)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`state`, `mutations`, and `actions`. Anyone who has been in web development
    for any amount of time is familiar with the CRUD pattern and will absolutely jump
    for joy at not having to write those functions again.'
  prefs: []
  type: TYPE_NORMAL
- en: Check out the GitHub repository ([https://github.com/abdullah/vuex-module-generator](https://github.com/abdullah/vuex-module-generator))
    for more details and sample applications.
  prefs: []
  type: TYPE_NORMAL
- en: Vuex ORM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ORM` library to your Vuex store. **ORM** is short for **object-relational
    mapping** and is a pattern to help make object persistence simpler. Like VMG,
    Vuex ORM aims to simplify the rather common CRUD tasks web developers must write.'
  prefs: []
  type: TYPE_NORMAL
- en: Vuex ORM lets you define classes that represent the structure of your store
    data. Once you have defined the structure of the data, Vuex ORM then provides
    utility functions to make storing and retrieving that data in the store much simpler.
    It even handles relationships between data, such as a `cat` objects that belong
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of how you could define a type of data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding class, four properties are defined for the `Cat` class: `id`,
    `name`, `age`, and `adoptable`. For each property, default values are specified.
    Once defined, asking for all the data is as simple as `Cat.all()`. There''s a
    lot more to Vuex ORM, and you can check it out at [https://vuex-orm.github.io/vuex-orm/](https://vuex-orm.github.io/vuex-orm/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 11.01: Simplifying a Vuex Store'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This activity will be a bit different than the ones you have done before. In
    this activity, you are going to take an *existing* application making use of Vuex
    and apply some of the techniques you have learned in this chapter in order to
    simplify the store and make it easier to use in future updates. This could be
    most useful when needing to tweak or fix existing functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '**Steps:**'
  prefs: []
  type: TYPE_NORMAL
- en: To begin this activity, you will use the completed example found at `Chapter11/activity11.01/initial`
    ([https://packt.live/3kaqBHH](https://packt.live/3kaqBHH)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the store file to place the `state`, `getters`, and `mutations` into
    their own file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the `state` so that the `cat` values are in a `module`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Migrate the cat-related `getter` to the `module`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the `App.vue` file so that it still correctly displays the data it did
    initially.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is how it looks when built:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 11.3: Final output of the activity'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_11_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 11.3: Final output of the activity'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found via [this link](B15218_Solution_Final_SZ_ePub.xhtml#_idTextAnchor403).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned multiple different techniques to prepare your Vuex
    stores for growing complexity. You first learned how to move logic into separate
    files and include them within your store. You then learned about modules and how
    they are exposed to components using the store. Finally, you learned about some
    optional libraries that may make your Vuex use even more powerful.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you are going to learn about an incredibly important aspect
    of development, unit testing.
  prefs: []
  type: TYPE_NORMAL
