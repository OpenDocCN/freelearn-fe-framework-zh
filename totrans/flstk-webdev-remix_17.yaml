- en: '17'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Migration and Upgrade Strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this book, we’ve explored many aspects of web development with Remix.
    You learned how to use Remix to unlock the full potential of the web platform,
    and you thoroughly practiced developing full stack applications by building BeeRich.
    In this last chapter, we will talk about migration and upgrade strategies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The chapter is split into two sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Migrating to Remix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping Remix apps up to date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, we will discuss how to migrate to Remix. Different applications may require
    different migration strategies with varying efforts. We will look at non-React,
    React, and React Router apps and create a migration strategy for each. Next, we
    will learn how major version upgrades are rolled out in Remix. We will introduce
    you to Remix’s future flags and discuss how future flags enable us to gradually
    upgrade Remix apps.
  prefs: []
  type: TYPE_NORMAL
- en: After reading this chapter, you will know different migration strategies for
    Remix. You will understand how to run Remix side by side with an existing legacy
    application and how React Router can be used to prepare your code base for a migration.
    Further, you will know how Remix can be integrated within a wider system architecture.
    Finally, you will learn how to gradually upgrade your Remix application with future
    flags.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating to Remix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Migrations are never easy. Moving an existing code base to a new framework comes
    with difficulties and may involve a lot of refactoring. Remix is no exception,
    but some strategies may make a migration less painful, depending on the existing
    application architecture. In this section, we will discuss different migration
    strategies for Remix. Let’s start by reviewing a migration from a non-React app.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating non-React apps to Remix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Migrating from a non-React app to Remix is a challenging task and may be very
    time-consuming, depending on the size of the existing application. The complexity
    of a migration usually increases with ongoing feature development. Most of the
    time, we may be unable to freeze feature development and bug fixes while migrating.
    This results in having to migrate existing code and features to Remix while also
    having to implement new features in both the old and new applications.
  prefs: []
  type: TYPE_NORMAL
- en: One solution may be to run the new and old applications side by side. By doing
    so, we can keep our legacy application alive while ramping up our Remix application.
    Step by step, we may be able to move more and more code to Remix.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, we can host the new Remix application on a subdomain and implement
    new pages and flows in Remix. Using a subdomain, we can share existing cookies
    between the two applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The migration process could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Remix application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register the Remix application on a subdomain to share cookies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Re-implement reusable components in React.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Recreate the page layout, footer, and navbar in Remix.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Develop new pages and flows in Remix.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Migrate existing pages incrementally to Remix.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By developing new pages in Remix, we avoid having to implement new features
    in both the old and new applications. Instead, we can route users back and forth
    between the two applications. We can use cookies and the URL to share application
    states.
  prefs: []
  type: TYPE_NORMAL
- en: Running both applications side by side still requires us to do some work up
    front, such as re-implementing reusable components and page layout in React, but
    we can avoid having to make a complete switch before being able to run Remix in
    production.
  prefs: []
  type: TYPE_NORMAL
- en: If we already use React, then the migration should be easier.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating from a React app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can reuse bigger parts of our existing code base if we maintain a React application.
    However, if we are currently using a different React framework, such as Gatsby
    or Next.js, then migrating may still require us to run the legacy app and Remix
    app side by side in production.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating from another React meta framework
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Different React frameworks utilize different routing conventions, primitives,
    and component APIs. Migrating from another meta framework may allow us to reuse
    existing React components but may still require refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: 'The migration process from a different React framework could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Remix application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register the Remix application on a subdomain to share cookies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy, paste, and adapt reusable components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy, paste, and adapt the page layout, footer, and navbar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Develop new pages and flows in Remix.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Migrate existing pages incrementally to Remix.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We may need to refactor existing components to use Remix’s primitives and utilities.
    For instance, we want to refactor existing anchor tags to use Remix’s `Link` and
    `NavLink` components. Conclusively, it may be best to copy code to Remix and refactor
    it from there. This requires us to maintain duplicate code across the legacy and
    Remix apps.
  prefs: []
  type: TYPE_NORMAL
- en: It becomes easier if we run a client-side-only React application without a framework.
    Let’s review how to migrate a client-only React app to Remix.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating from a client-only React app
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we maintain Create React App or a Vite React app (client-only), we might
    have an easier time migrating to Remix, especially if the application already
    utilizes React Router.
  prefs: []
  type: TYPE_NORMAL
- en: On the client, Remix runs a client-side React application, and most of the React
    code and client-side fetch requests will work the same way in Remix as they did
    before. Hence, we can run the existing app on the client side inside Remix. From
    there, we can incrementally refactor pieces from the client-side-only app to Remix
    routes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The migration process from a client-only React app could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Remix application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move the existing app inside the new Remix app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Render the existing app in the `index` route.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy and adapt the page layout, footer, and navbar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Develop new pages and flows in Remix.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Migrate existing pages incrementally to Remix.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We may still need to copy and paste existing components to create Remix-compatible
    versions. However, at least for now, we can do so in the same code base.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating becomes much easier if we use React Router as the client-side routing
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating from React Router
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remix was created by Michael Jackson and Ryan Florence, the creators of React
    Router. Remix has been heavily inspired and influenced by the development and
    maintenance of React Router over the years.
  prefs: []
  type: TYPE_NORMAL
- en: React Router is a library for client-side routing in React. Since Remix’s development,
    the Remix team has also worked on releasing React Router version 6, which aligns
    React Router’s API with that of Remix. Remix and React Router have since been
    refactored to build upon the same baseline router package.
  prefs: []
  type: TYPE_NORMAL
- en: When looking through the API documentation of React Router version 6, you may
    notice many familiar concepts such as the `loader` and `action` functions, many
    familiar hooks such as `useLoaderData`, `useActionData`, `useNavigation`, `useSearchParams`,
    `useFetcher` and `useLocation`, and familiar components such as `Form` and `Link`.
  prefs: []
  type: TYPE_NORMAL
- en: React Router’s `loader` and `action` functions are executed on the client, not
    the server, as React Router is a client-side routing solution. However, React
    Router uses the same navigation, data loading, and revalidation flow as Remix,
    which allows us to build React Router apps with the same mental model, conventions,
    and primitives. This makes migrating from React Router version 6 to Remix easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can derive the following migration process for client-only React applications:'
  prefs: []
  type: TYPE_NORMAL
- en: Migrate to React Router version 6.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Iteratively refactor code to use React Router’s primitives and conventions,
    most importantly the `loader` and `action` functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Migrate from React Router version 6 to Remix.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, we need to migrate to React Router version 6\. We can follow the existing
    migration guides on the React Router documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Once we use React Router version 6, we can refactor the code iteratively over
    time. We will refactor existing fetch requests to React Router’s `loader` and
    `action` functions and utilize React Router’s `Link` and `Form` components to
    implement navigations and mutations – just like with Remix. This also allows us
    to utilize React Router’s life cycle hooks, such as `useNavigation` and `useFetcher`,
    to implement pending states and optimistic UI.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast to Remix, React Router does not use a file-based routing convention.
    If we want to utilize Remix’s file-based routing convention – or any other routing
    convention – then we might want to start defining it already in the client-side
    application. For instance, it may be helpful to move route components into a new
    `routes/` folder and to co-locate the `loader` and `action` functions together
    with the React Router route components, matching Remix’s route file convention.
  prefs: []
  type: TYPE_NORMAL
- en: At some point, we will have to make the switch and move the app over to Remix.
    The closer we bring the application to Remix’s routing convention and data flow,
    the better. However, there is no need to refactor everything to the `loader` and
    `action` functions before making the migration, even though it would be helpful.
  prefs: []
  type: TYPE_NORMAL
- en: We can render the client-side React Router routes within Remix, as discussed
    in the previous section. Naturally, this is not as effective as moving the routes
    over to Remix, but for bigger applications, this may be a valid option to ensure
    a timely migration.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read more about an incremental migration from React Router version
    6 to Remix in the Remix documentation: [https://remix.run/docs/en/main/guides/migrating-react-router-app](https://remix.run/docs/en/main/guides/migrating-react-router-app).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have discussed a strategy to migrate the client-side code, let’s
    review the backend code.
  prefs: []
  type: TYPE_NORMAL
- en: Working with a backend application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remix’s `loader` and `action` functions run on the server. We can use them to
    read and write directly from and to a database and implement webhooks and server-sent
    event endpoints with resource routes. We can use Remix to implement standalone
    full stack applications that do not require additional backend applications. In
    this section, we will discuss how Remix fits into a bigger system architecture
    and how we can utilize Remix when there are downstream backend applications.
  prefs: []
  type: TYPE_NORMAL
- en: In bigger application architectures, there might be more systems between a frontend
    application and a database. In this case, Remix will serve as the web server for
    our frontend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s review the code example from [*Chapter 1*](B17399_01.xhtml#_idTextAnchor013):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: On incoming requests, the `loader` function fetches a list of expenses. The
    route component renders both an expense list and an expense form, which on submit
    posts to the same route’s `action` function.
  prefs: []
  type: TYPE_NORMAL
- en: Note how we call the `createExpense` and `getExpense` helper functions in the
    `loader` and `action` functions. We could implement these functions to read and
    write from and to a database. However, we could also implement the functions to
    `fetch` from downstream backend services.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we could implement `requireUserSession` to send a request to a downstream
    authentication service, instead of implementing the authentication code within
    our Remix app. Conclusively, Remix can also be used to forward requests to backend
    applications and implement the **Backend for Frontend** (**BFF**) pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Backend for Frontend
  prefs: []
  type: TYPE_NORMAL
- en: The BFF pattern specifies a software architecture where each frontend has a
    dedicated backend that is used to tailor content for the specific needs of the
    frontend application. The backend then forwards or orchestrates requests to more
    generic downstream services.
  prefs: []
  type: TYPE_NORMAL
- en: We don’t need to migrate our backend application to Remix simultaneously with
    our frontend application. Instead, we can forward requests from the frontend to
    the legacy backend application. We can then gradually migrate the backend code
    into Remix’s `loader` and `action` functions. Alternatively, we can also maintain
    the backend application together with the Remix app. In bigger system architectures,
    it may be desirable to use Remix only as a web server and use generic backend
    services to implement REST APIs that can be reused across different clients.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to migrate different applications to Remix.
    You now understand how to use Remix as a BFF. In the next section, you will learn
    how to keep your Remix app up to date.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping Remix apps up to date
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remix, like every framework, undergoes constant maintenance and development.
    Bigger updates are introduced as major releases that can include breaking changes.
    Upgrading to a newer major version can require refactoring, and especially for
    bigger applications, this can be a painful chore. Remix aims to make upgrading
    to major versions as painless as possible. In this section, we will see how we
    can gradually migrate to newer major versions in Remix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like most open source projects, Remix uses semantic versioning to denote its
    patches and updates. Semantic versioning provides a way to document three different
    kinds of changes in a definitive hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '`2.x.x`: Changes that increment the first digit are major releases that include
    breaking changes'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`x.1.x`: Changes incrementing the middle digit are minor releases that introduce
    new features but remain backward-compatible'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`x.x.1`: Changes that increment the last digit are bug fixes and dependency
    patches that remain backward-compatible'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A new major release breaks backward compatibility, meaning you must update existing
    code to upgrade to the major version. This can be a painful process. Luckily,
    the Remix team provides future flags to avoid all-at-once upgrade processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Future flags are Boolean flags that we can specify in the `remix.config.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Whenever the Remix team finalizes a feature of a new major version, it also
    releases the feature in the previous major version, hidden behind a future flag.
    This means we can start using the new features in the previous version before
    the next major version is released. By utilizing the future flags, we can gradually
    (feature by feature) refactor our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Remix team distinguishes two kinds of future flags:'
  prefs: []
  type: TYPE_NORMAL
- en: Unstable flags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Version flags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unstable future flags (`unstable_`) are used for features where the API is still
    under active development and may be up to change. These features are unstable,
    and the API might be removed or changed in future releases.
  prefs: []
  type: TYPE_NORMAL
- en: Once an unstable feature is stable, the feature may either be introduced in
    a minor version update or transformed into a version future flag (`vX_`). Version-based
    feature flags enable stable API changes in the current Remix version. Enabling
    a version-based feature flag allows developers to prepare for the next major version
    update. For instance, the `v2_meta` future flag is used to enable the updated
    meta-function API of Remix v2 in Remix v1.
  prefs: []
  type: TYPE_NORMAL
- en: Future flags allow the Remix team to iterate on Remix’s primitives and conventions
    and release new features, one by one, in the current major version. This also
    allows the team to receive early feedback and identify potential issues and bugs
    as early as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Future flags do not remove the need to refactor existing code on existing changes,
    but they allow gradual refactoring that can be stretched out over time.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed different migration strategies for Remix. You
    learned strategies to migrate a non-React, React, and React Router application
    to Remix.
  prefs: []
  type: TYPE_NORMAL
- en: For bigger migrations, you can run the new Remix app and the old legacy application
    side by side in production. You can build new pages in Remix while incrementally
    moving features from the old application to Remix. Using a subdomain for your
    new Remix app, you can share UI state using cookies.
  prefs: []
  type: TYPE_NORMAL
- en: You now understand that React Router and Remix use the same baseline routing
    implementation. Thus, migration from React Router applications to Remix is easier,
    as you can incrementally prepare your React Router app by taking advantage of
    the shared primitives and conventions. This allows you to reuse much of the code
    between a React Router and Remix app without further refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: After reading this chapter, you now understand how to use Remix as a BFF to
    forward and orchestrate requests to downstream services. You know that Remix can
    be used independently and as a part of a wider system architecture. When migrating
    to Remix, you can focus on migrating your frontend code while forwarding all requests
    from Remix’s `action` and `loader` functions to the existing backend applications.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you learned about Remix’s future flags system. Remix offers future
    flags to unlock features of upcoming major versions in the current ones. This
    allows gradual upgrades on a per-feature basis and avoids painful migrations that
    require updating all code at once.
  prefs: []
  type: TYPE_NORMAL
- en: Over the last 17 chapters, you studied many concepts to build full stack applications
    with Remix. As a React developer, Remix provides a lot of great primitives, conventions,
    and levers to let you unlock the full potential of the web platform. Due to Remix’s
    philosophy of embracing the web platform, you not only practiced how to work with
    Remix but also learned about many web standards and concepts, such as the web
    Fetch API, progressive enhancement, HTTP caching headers, and HTTP cookies.
  prefs: []
  type: TYPE_NORMAL
- en: Remix is truly a full stack framework for the web, and by following the exercises
    in this book, you were introduced to many aspects of full stack web development,
    such as request-response flows, user authentication, session management, data
    revalidation, and implementing progressive, optimistic, and real-time UIs. I am
    excited to see what you will build next. Happy coding!
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Remix documentation includes a guide on how to migrate from React Router
    to Remix: [https://remix.run/docs/en/main/guides/migrating-react-router-app](https://remix.run/docs/en/main/guides/migrating-react-router-app).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Remix documentation further includes an article by Pedro Cattori that documents
    how to migrate from webpack to Remix: [https://remix.run/blog/migrate-from-webpack](https://remix.run/blog/migrate-from-webpack).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to Remix’s release log to stay up to date with Remix’s releases: [https://github.com/remix-run/remix/releases](https://github.com/remix-run/remix/releases).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sergio Xalambrí wrote an article on how to run Next.js side by side with Remix
    for an incremental migration: [https://sergiodxa.com/articles/run-next-and-remix-on-the-same-server](https://sergiodxa.com/articles/run-next-and-remix-on-the-same-server).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find Remix’s roadmap on GitHub: [https://github.com/orgs/remix-run/projects/5](https://github.com/orgs/remix-run/projects/5).
    You can also find roadmap planning meetings on YouTube: [https://www.youtube.com/c/Remix-Run/videos](https://www.youtube.com/c/Remix-Run/videos).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find more information about semantic versioning here: [https://semver.org/](https://semver.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Learn more about Remix’s future flag approach in this blog post by Matt Brophy:
    [https://remix.run/blog/future-flags](https://remix.run/blog/future-flags).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read more about Remix as a BFF in the Remix documentation: [https://remix.run/docs/en/main/guides/bff](https://remix.run/docs/en/main/guides/bff).'
  prefs: []
  type: TYPE_NORMAL
