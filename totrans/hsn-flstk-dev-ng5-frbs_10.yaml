- en: Unit Testing Our Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will cover Angular testing in detail. We will start with
    a basic introduction to Angular testing and learn about tools and technologies
    used for unit testing. We will write unit tests for our login component using
    Angular testing framework and configure a dependent module. We will also unit
    test our user service. As part of our testing, we will create stubs for dependent
    services or components so that we can focus only on the class unit under test.
    We will unit test our component and service using Angular framework so that dependent
    modules are initialized. We will test an Angular pipe in isolation so that the
    pipe is initialized directly using a `new` keyword. Finally, we will take a look
    at the code coverage for our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Angular testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing an Angular component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing Angular services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing Angular pipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to code coverage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to Angular testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unit testing is an important part of a software development life cycle. The
    benefits of unit testing are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It helps to align our implementation with the design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It helps in protecting our application from regression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring becomes easier if we have good test cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Angular provides various tools and technologies to test our application. As
    a part of our unit testing, we will use the following technologies:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Jasmine**: This provides the basic skeleton to write our unit test. It comes
    with a HTML test runner and runs on a browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Angular testing framework:** This comes along with Angular framework and
    helps to create a test environment for Angular code under test. It also gives
    us access to DOM elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Karma**: We use the Karma tool to run our application. We run our unit tests
    using the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can write two types of Angular test:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit testing with Angular test framework**: We will use Angular test framework
    to write unit tests for our component and services. This will create a test environment
    and provide us access to various elements of the Angular framework.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Isolated unit test**: We can write independent unit tests without Angular
    dependency. This kind of unit test is really useful for testing services and pipes.
    In this chapter, we will test our date pipe this way.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is good to note that it is always better to stick to isolated unit tests
    when you can, and to try to write as few integrated and end-to-end tests whenever
    possible, because isolated unit tests are the easiest to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing an Angular component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will write our first Angular test for the login component.
    The steps involved in writing test cases are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Identifying the class under test**: The first step in writing unit test cases
    is to identify the dependencies. The login component `constructor` shows all the
    dependencies and is dependent on `UserService`, `Router`, `AuthenticationService`,
    and `AngularFireAuth`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**Creating all the mock or stubs classes**: Once we identify all the dependencies,
    we need to eliminate these external dependencies and concentrate only on the component
    class under test. So we create mock or stub classes to eliminate these dependencies.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the login component, we use user service to retrieve user information using
    the `getUser()` method so we create `UserServiceStub` with the `getUser()` method,
    which returns mock user encapsulates in an `Observable` object; we create a test
    data class for the mock user, that contains user details, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a sample `user-test-data.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We use an authentication service in the login component to log in and reset
    the password so we create an `AuthenticationServiceStub` class with an empty `login()`
    and `resetPassword()` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AngularFireAuth` class is part of Angular''s Fire library. This class
    is responsible for authentication in our application and contains an `auth` object,
    so we create a stub for the `auth` class, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the `AuthStub` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we use a router to navigate to pages in our application. This provider
    is part of Angular framework. We create a stub for this class as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '**Creating the test suites**: Once we eliminate the external dependencies,
    we can create test suites within the `describe()` method in Jasmine framework.
    This method accepts `description` for test suites and the `specDefinitions` function
    for Jasmine framework to invoke inner suites of specs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**Creating the test environment**: We create the Angular test environment for
    components under test. Angular provides a `TestBed` class to create the test environment;
    it initializes the dependent modules, providers, services, and components. We
    call a `TestBed.configureTestingModule()` method within `beforeEach()` so that
    this configures modules before each test case execution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '**Initializing the testing objects**: Once we configure modules, we can create
    a login component fixture using `TestBed.createComponent()` and initialize the
    login component and debug element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '**Writing our first test**: The final step is to write the test cases. Our
    first test case is to check whether the login component is instantiated or not.
    We will the write test case within the `it()` method and use `expect()` to validate
    the instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '**Destroying the created instance:** After each test case, we clear the instance
    in the `afterEach()` method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '**Running the test**: Finally, we run our first test case using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After its successful run, this opens in a browser and shows the status as 1
    spec successful with 0 failures:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00033.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Adding more unit tests**:In the next test case, we check whether the `login`
    method of our service is called when a user enters their email and password and
    clicks on the LOGIN button. First, we initialize the DOM elements, such as email
    input text, password input text, and login button. Next, we initialize the default
    values for email and password and `spyOn` the service login method so that this
    mock method is called when the user clicks on the LOGIN button. After the LOGIN
    button is clicked, we then call `detectChanges()` to notify the DOM to refresh
    the elements. Finally, we validate that the `login()` method should be called:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the `login.component.spec.ts` file as of now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Unit testing an Angular service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we unit test an Angular service and we write test cases for
    our user service. The steps for unit testing a service are the same as for our
    component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step in writing unit test cases is to analyze the dependent components,
    as we see user service is dependent on `AngularFireDatabase` and initializes the
    Firebase storage object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'So we create a stub for this dependent object such as `AngularFireDatabaseStub`, which contains
    other dependent stubs such as `AngularFireAppStub` and `AngularFireObjectStub`
    object references and the `object()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the `AngularFireAppStub` stub class with an empty mock method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the `AngularFireObjectStub` stub class with empty mock methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to initialize the test environment using `TestBed` and retrieve
    the user service object using `TestBed.get()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will start writing the test cases for our user service. We will cover
    the following test cases for the user service:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first test case is to add a user to Firebase database. We will add `spyOn` to
    the `set` method of Angular''s fire object and call the add user method using
    mock user; then we expect the `set` method of Angular fire object to be called:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The next test case is to receive our user from the Firebase database. We add
    `spyOn`, the value change method of Angular''s fire object, which returns a mock
    user. We then call a `getUser` method, subscribe to the `Observable` object, and
    then we validate the method call and also test the content of our mock user with
    the expected values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The next test case is to save the user in `member` variables. In this test
    case, we will save a mock user in an `Observable`, then retrieve the user using
    a `get` method, and validate all properties of the mock user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The next test case is to update the email in the Firebase database and also
    update the cache user object in the user service class; we spy on the `update`
    method of Angular''s fire object, pass a new email to update the `email` method,
    which updates the Firebase database and the cache user object, test the Firebase
    database call, retrieve the user from the `get` method, and validate all the properties
    of the mock user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the `user.service.spec.ts` file as of now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Unit testing Angular pipe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Angular pipe unit testing is an example of testing a class independently of
    the Angular test environment. In this example, we test our friend''s date pipe
    class and create the object in the test class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'On this object, we will write the following two test cases:'
  prefs: []
  type: TYPE_NORMAL
- en: First, test the green field scenario, where we pass a valid date in milliseconds
    and test the transformed human-readable date format
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Second, test the edge-case scenario where we pass an invalid date as `-1`, and
    we expect a string return value as `"Invalid Date"`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Code coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code coverage of the application reflects the overall coverage of our code.
    This gives an overview of the line and function coverage of the code so that we
    can write more test cases to cover other parts of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can enable code coverage in `package.json`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We will execute the following command, which runs the test cases, and creates
    a `coverage` folder, which has `index.html` to show coverage statistics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'When we open `index.html`, it shows a beautiful table with an overview of the
    coverage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00034.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered unit testing and discussed various terms and terminologies
    in Angular unit testing. We implemented unit test for our login component, covered `TestBed`, and
    configured our modules. We wrote a unit test for our service, created stubs for
    external dependent classes, and injected these stubbed classes in our module.
    We also wrote isolated test cases for Angular pipe. Finally, we discussed code
    coverage and ran code coverage for our specs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss debugging techniques. This will help us
    to solve and debug our issues faster.
  prefs: []
  type: TYPE_NORMAL
