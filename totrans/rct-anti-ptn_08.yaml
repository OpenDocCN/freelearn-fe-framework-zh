- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Exploring Data Management in React
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 React 中的数据管理
- en: In modern frontend development, the way we handle state and data access can
    make or break an application. Whether you’re a solo developer or part of a large
    team, understanding best practices and common pitfalls is critical. This chapter
    aims to elevate your proficiency in state management and data handling within
    React applications, focusing on scalable and maintainable approaches.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代前端开发中，我们处理状态和数据访问的方式可能会使应用程序成功或失败。无论你是独立开发者还是大型团队的一员，理解最佳实践和常见陷阱至关重要。本章旨在提高你在
    React 应用程序中状态管理和数据处理方面的熟练度，重点关注可扩展和可维护的方法。
- en: State management is challenging, particularly in React, and there are many issues
    that developers tend to face in their day-to-day work. One of the challenges is
    where you can locate the business logic in your code base. When business logic
    infiltrates UI components, it compromises their reusability. Many domain objects,
    along with computational logic, are scattered in UI components either deliberately
    or unintentionally, which can lead to tangled logic that’s hard to follow, debug,
    and test. It can also lead to performance issues, which negatively affect the
    user experience.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 状态管理具有挑战性，尤其是在 React 中，开发者日常工作中会遇到许多问题。其中一个挑战是你在代码库中可以定位业务逻辑的位置。当业务逻辑渗透到 UI
    组件中时，它会损害它们的可重用性。许多领域对象以及计算逻辑要么故意要么无意地散布在 UI 组件中，这可能导致难以追踪、调试和测试的复杂逻辑。它也可能导致性能问题，从而对用户体验产生负面影响。
- en: Another issue is prop drilling, where passing props from a parent component
    to deeply nested children becomes both cumbersome and susceptible to errors. This
    often leads to code duplication as the same snippets find their way into multiple
    files, making any future updates a complicated task.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题就是属性钻取，将属性从父组件传递到深层嵌套的子组件变得既繁琐又容易出错。这通常会导致代码重复，因为相同的代码片段会出现在多个文件中，使得任何未来的更新都变得复杂。
- en: Lastly, sharing state in a React application presents its own set of challenges.
    Various mechanisms exist for this, but choosing the most efficient way to share
    stateful logic across components can be quite perplexing. We’ll dive deep to explore
    the issues of sharing state and see how React’s Context API can help.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 React 应用程序中共享状态也带来了一系列挑战。存在各种机制来实现这一点，但选择最有效的方式在组件之间共享状态逻辑可能会相当令人困惑。我们将深入探讨共享状态的问题，并看看
    React 的 Context API 如何帮助解决这个问题。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding business logic leaks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解业务逻辑泄露
- en: Introducing the anti-corruption layer
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍反腐败层
- en: Exploring the prop drilling issue
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索属性钻取问题
- en: Using the Context API to resolve prop drilling
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Context API 解决属性钻取问题
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: A GitHub repository has been created to host all the code we’ll discuss in this
    book. For this chapter, you can find the recommended structure at [https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch8](https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch8).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 已创建一个 GitHub 仓库来托管本书中讨论的所有代码。对于本章，你可以在[https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch8](https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch8)找到推荐的架构。
- en: Understanding business logic leaks
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解业务逻辑泄露
- en: '**Business logic** refers to the rules, calculations, and processes that are
    essential to the operation of a business application. When this business logic
    “leaks” into components or areas of the application where it doesn’t belong, this
    is known as a **business** **logic leak**.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**业务逻辑**指的是对业务应用程序操作至关重要的规则、计算和流程。当这种业务逻辑“泄露”到不属于它的组件或应用程序区域时，这被称为**业务****逻辑泄露**。'
- en: This issue frequently crops up in various projects, partly because there’s no
    widely agreed-upon approach for handling business logic in React. The framework’s
    flexibility allows you to implement this logic directly in components, Hooks,
    or helper functions; as a result, developers often end up embedding the logic
    directly into components, where it’s immediately needed – hence the leakage.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题在各个项目中经常出现，部分原因是因为在 React 中处理业务逻辑没有广泛达成共识的方法。框架的灵活性允许你直接在组件、Hooks 或辅助函数中实现这种逻辑；因此，开发者往往会将逻辑直接嵌入到需要的组件中——这就是泄露的原因。
- en: This leakage can cause many problems. Business logic leaks can result in tightly
    coupled components that become difficult to test, maintain, or reuse. When business
    logic is scattered across different parts of the application, it leads to code
    duplication and inconsistency, making the application more prone to errors and
    harder to debug. Additionally, this scattering complicates any future modifications
    to the business rules as changes will likely have to be made in multiple places,
    increasing the risk of introducing new issues.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这种泄漏可能导致许多问题。业务逻辑泄漏可能导致紧密耦合的组件变得难以测试、维护或重用。当业务逻辑散布在应用程序的不同部分时，会导致代码重复和不一致，使应用程序更容易出错且更难调试。此外，这种分散使得对业务规则的任何未来修改都变得复杂，因为可能需要在多个地方进行更改，从而增加了引入新问题的风险。
- en: There are various indicators that business logic is leaking into your code,
    but the most prevalent sign is the incorporation of data transformation directly
    within views or UI components. In this section, we’ll delve into this issue in
    depth; in the following section, we’ll explore solutions to mitigate this problem.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种指标表明业务逻辑正在渗入你的代码，但最普遍的迹象是在视图中或 UI 组件中直接包含数据转换。在本节中，我们将深入探讨这个问题；在下一节中，我们将探讨缓解这个问题的解决方案。
- en: '`UserProfile` function:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserProfile` 函数：'
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `UserProfile` function component fetches user data from a backend API. The
    `useEffect` Hook ensures that data fetching happens whenever the ID changes. The
    fetched data is then stored in a local state variable, `user`, and the component
    displays the user’s name once the data is available. If the data is still loading,
    a **Loading…** message is displayed.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserProfile` 函数组件从后端 API 获取用户数据。`useEffect` 钩子确保在 ID 发生变化时进行数据获取。获取的数据随后存储在本地状态变量
    `user` 中，组件在数据可用时显示用户姓名。如果数据仍在加载中，则显示 **加载中…** 消息。'
- en: In the `useEffect` block, the fetched data transforms being stored in the `user`
    state variable. Specifically, the keys from the fetched JSON response are mapped
    to new names that are more suitable for the frontend application – for example,
    `data.user_identification` becomes `id` and `data.user_full_name` becomes `name`.
    This transformation allows for easier handling and readability within the React
    component.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `useEffect` 块中，存储在 `user` 状态变量中的获取数据转换。具体来说，从获取的 JSON 响应中映射的键被映射到更适合前端应用程序的新名称——例如，`data.user_identification`
    变为 `id`，`data.user_full_name` 变为 `name`。这种转换使得在 React 组件中更容易处理和阅读。
- en: 'As you might imagine, this type of transformation can happen in many places
    in an application, and it isn’t limited to the inside of a React component; sometimes,
    this transformation can be present in Hooks and other places, as demonstrated
    in the following figure:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，这种类型的转换可以在应用程序的许多地方发生，并不仅限于 React 组件内部；有时，这种转换可以存在于 Hooks 和其他地方，如下面的图所示：
- en: '![Figure 8.1: Using data transformation in views](img/B21103_08_01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1：在视图中使用数据转换](img/B21103_08_01.jpg)'
- en: 'Figure 8.1: Using data transformation in views'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1：在视图中使用数据转换
- en: The backend service can serve data in various formats that are supported by
    different technologies – some utilize RESTful APIs, while others employ GraphQL.
    From the perspective of the frontend code, the specifics of these formats are
    abstracted away. For instance, one component may be responsible for transforming
    XML data (indicated by an orange diamond shape) into an internal type, *X* (depicted
    as a blue square). Meanwhile, another component may interact with a GraphQL endpoint,
    processing the received data (represented by a red circle) into the same internal
    type, *X*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 后端服务可以以不同技术支持的各种格式提供数据——一些使用 RESTful API，而另一些则使用 GraphQL。从前端代码的角度来看，这些格式的具体细节被抽象化。例如，一个组件可能负责将
    XML 数据（用橙色菱形表示）转换为内部类型 *X*（表示为蓝色方块）。同时，另一个组件可能与 GraphQL 端点交互，将接收到的数据（用红色圆圈表示）处理成相同的内部类型
    *X*。
- en: This discrepancy necessitates data transformations across multiple areas in
    the code. When such transformations are duplicated, there’s a higher risk of overlooking
    changes, especially if the backend alters the structure of their data.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这种差异需要在代码的多个区域进行数据转换。当这种转换被重复时，更容易忽略更改，尤其是如果后端更改了其数据结构。
- en: 'All these varied transformations can be centralized into a single location
    where data reshaping occurs, along with empty field checks, field renaming, and
    the elimination of unnecessary fields. This segues nicely into our next topic:
    the **anti-corruption** **layer** (**ACL**).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些不同的转换都可以集中到一个单一的位置，在那里进行数据重塑，包括空字段检查、字段重命名和消除不必要的字段。这很自然地过渡到我们下一个主题：**反腐败**
    **层**（**ACL**）。
- en: Introducing the ACL
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入ACL
- en: In software development, an ACL acts like a translator or a mediator between
    different subsystems that may not speak the same “language,” so to speak. Imagine
    that you have two systems, each with its own set of rules, structures, and complexities.
    If these systems interact directly, there’s a risk that they could influence each
    other in unintended ways, leading to what is called *corruption* in the domain
    logic.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中，ACL（访问控制列表）充当不同子系统之间的翻译者或调解者，这些子系统可能说着不同的“语言”。想象一下，你有两个系统，每个系统都有自己的规则、结构和复杂性。如果这些系统直接交互，它们可能会以未预料到的方式相互影响，导致领域逻辑中的所谓*腐败*。
- en: In the context of frontend development, especially in complex applications,
    an ACL becomes crucial for managing the interactions between the frontend and
    various backends or APIs. Frontend developers often have to deal with multiple
    services that may have inconsistent or convoluted data formats. Implementing an
    ACL in the frontend allows you to create a unified interface to interact with
    these services.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在前端开发的背景下，尤其是在复杂的应用程序中，ACL对于管理前端与各种后端或API之间的交互至关重要。前端开发者经常必须处理可能具有不一致或复杂的数据格式的多个服务。在前端实现ACL允许你创建一个统一的接口来与这些服务交互。
- en: For example, if your frontend application has to communicate with multiple RESTful
    APIs, GraphQL services, and even WebSocket servers, each may have its own set
    of rules, data structures, and complexities. A frontend ACL would take on the
    role of translating these disparate forms of data into a format that your frontend
    application understands. This means that your UI components don’t have to worry
    about the intricate details of each service’s data format, making the components
    easier to develop, test, and maintain.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你的前端应用程序需要与多个RESTful API、GraphQL服务和甚至WebSocket服务器通信，每个都可能有一套自己的规则、数据结构和复杂性。前端ACL将承担将这些不同的数据形式转换为前端应用程序理解格式的角色。这意味着你的UI组件不必担心每个服务的详细数据格式，这使得组件更容易开发、测试和维护。
- en: 'The ACL can also be a strategic place to handle caching, error transformations,
    and other cross-cutting concerns. By centralizing these functionalities, you avoid
    scattering similar logic all over your frontend code base, thus adhering to the
    **Don’t Repeat Yourself** (**DRY**) principle:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ACL还可以成为处理缓存、错误转换和其他横切关注点的战略位置。通过集中这些功能，你避免了在前端代码库中分散类似的逻辑，从而遵循**不要重复自己**（**DRY**）原则：
- en: '![Figure 8.2: Introduced ACL for data transforming](img/B21103_08_02.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2：引入了用于数据转换的ACL](img/B21103_08_02.jpg)'
- en: 'Figure 8.2: Introduced ACL for data transforming'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：引入了用于数据转换的ACL
- en: As illustrated in *Figure 8**.2*, all data transformations are now centralized,
    eliminating the need for such operations in the views. You might be curious about
    how to put this into practice in your code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图8**.2所示，所有数据转换现在都集中化，消除了在视图中进行此类操作的需求。你可能想知道如何在代码中实现这一点。
- en: Introducing a typical usage
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入典型用法
- en: To get started, let’s build on the example from the previous section and introduce
    a basic function as the starting point for our ACL. We should identify the external
    data format and what we consume, then define functions as the transformers before
    putting them in a common place.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，让我们基于上一节中的示例，引入一个基本函数作为我们ACL的起点。我们应该确定外部数据格式以及我们消费的内容，然后定义函数作为转换器，然后再将它们放在一个公共位置。
- en: 'First, let’s define a type for the user data format we receive from the remote
    server. By using TypeScript, we gain the advantage of compile-time checks, thereby
    ensuring that any inconsistencies in the data format are flagged before the application
    runs:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义从远程服务器接收的用户数据格式的类型。通过使用TypeScript，我们获得了编译时检查的优势，从而确保在应用程序运行之前，任何数据格式的不一致性都会被标记出来：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We will also define the local `User` type – it includes all fields (`id`, `name`,
    and so on) that we use in the `UserProfile` component:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将定义本地的`User`类型——它包括我们在`UserProfile`组件中使用的所有字段（`id`、`name`等）：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `type` definition specifies the structure of a user object that will be
    used in React components. Note that the `subscription` property uses a custom
    type, `UserSubscription`, which can take one of four string values: `expire` is
    a string that indicates when the user’s subscription will expire.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`type` 定义指定了将在 React 组件中使用的用户对象的结构。请注意，`subscription` 属性使用自定义类型 `UserSubscription`，它可以取四个字符串值之一：`expire`
    是一个字符串，表示用户的订阅何时将过期。'
- en: 'With this setup, we can define a new function called `transformUser` in a file
    called `transformer.ts`. The file simply returns the mapped object with the `User`
    type we just defined:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种设置，我们可以在名为 `transformer.ts` 的文件中定义一个新的函数，称为 `transformUser`。该文件简单地返回我们刚刚定义的
    `User` 类型的映射对象：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With this new extracted function in `transformer.ts`, our component can be
    simplified like so:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用在 `transformer.ts` 中提取的新函数，我们的组件可以简化如下：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `UserProfile` component relies on the `fetchUserData` helper function to
    retrieve and process user data from an API. This design insulates `UserProfile`
    from any knowledge of the remote data structure. If there are future changes to
    the `RemoteUser` type, `UserProfile` remains unaffected as all the adjustments
    will be confined to `transformer.ts`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserProfile` 组件依赖于 `fetchUserData` 辅助函数从 API 获取和处理用户数据。这种设计使 `UserProfile`
    与对远程数据结构的任何了解隔离开。如果将来对 `RemoteUser` 类型进行了更改，`UserProfile` 仍然不受影响，因为所有调整都将局限于 `transformer.ts`。'
- en: It’s advantageous to have a distinct function dedicated to managing remote data
    and molding it to suit the requirements of higher-level views. However, complications
    arise when the backend fails to deliver the necessary data. In such scenarios,
    additional logic is necessitated in this layer to establish fallback or default
    values.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个专门用于管理远程数据并将其塑造成适合高级视图要求的函数是有利的。然而，当后端未能提供必要的数据时，会出现复杂性。在这种情况下，需要在这个层中添加额外的逻辑来建立回退或默认值。
- en: Using the fallback or default value
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用回退或默认值
- en: Another frequently observed issue related to data transformation is the excessive
    use of defensive programming in React views. While defensive programming is generally
    good practice and useful in various contexts, overloading React components with
    too many null checks and fallbacks can clutter the code and make it difficult
    to comprehend.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据转换相关的一个常见问题是 React 视图中过度使用防御性编程。虽然防御性编程通常是良好的实践，并在各种环境中很有用，但过度加载 React 组件过多的空值检查和回退可能会使代码杂乱无章，难以理解。
- en: Note
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '**Defensive programming** is a practice that involves writing code in a way
    that anticipates possible errors, failures, or exceptions, and handles them gracefully.
    The goal is to make your application more resilient and maintainable by minimizing
    the impact of unexpected scenarios.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**防御性编程** 是一种编写代码的方式，它预测可能出现的错误、故障或异常，并以优雅的方式处理它们。目标是使你的应用程序更具弹性和可维护性，通过最小化意外情况的影响。'
- en: For instance, in the `UserProfile` example, you might encounter situations where
    certain values from the remote service are empty. Instead of displaying `null`
    or `undefined` to end users, you would need to implement fallback values.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 `UserProfile` 示例中，你可能会遇到远程服务中某些值为空的情况。而不是向最终用户显示 `null` 或 `undefined`，你需要实现回退值。
- en: 'Let’s review the `transformUser` function we extracted previously:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们之前提取的 `transformUser` 函数：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: What if `subscription_details` doesn’t exist, or what happens when `expiry`
    isn’t a valid date format from the backend? These mismatches can cause runtime
    exceptions, so we should fall back to some default value when the remote data
    isn’t in the right format.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `subscription_details` 不存在，或者当 `expiry` 不是后端有效的日期格式时会发生什么？这些不匹配可能导致运行时异常，因此当远程数据格式不正确时，我们应该回退到一些默认值。
- en: 'We could put the fallback logic into components, right before we render them.
    Without the ACL, we might end up with some logic in `UserProfile`, like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将回退逻辑放在组件中，在我们渲染它们之前。如果没有 ACL，我们可能会在 `UserProfile` 中遇到一些逻辑，如下所示：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `UserProfile` function component takes a user object as a prop. It displays
    the user’s full name, subscription level, and subscription expiry date. If any
    of these values are missing or falsy, it provides default fallback text such as
    **Loading…**, **Basic**, or **Never**.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserProfile` 函数组件接受一个用户对象作为属性。它显示用户的全名、订阅级别和订阅过期日期。如果这些值中的任何一个缺失或为假，它将提供默认回退文本，例如
    **加载中…**、**基础** 或 **从未**。'
- en: As such, logic begins to infiltrate the `UserProfile` component, increasing
    the component’s length and therefore complexity.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，逻辑开始渗透到`UserProfile`组件中，增加了组件的长度和复杂性。
- en: 'This kind of logic can be better managed by moving it into a function such
    as `transformUser`, where it can be thoroughly tested:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这种逻辑可以通过将其移动到`transformUser`等函数中更好地管理，这样就可以对其进行彻底的测试：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `transformUser` function maps fields from the remote user data structure
    to the application’s expected `user` data structure, providing default values
    for each field in case they are missing or null. For example, if `remoteUser.user_identification`
    is `null`, it will use **N/A** as the default ID.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`transformUser`函数将远程用户数据结构中的字段映射到应用程序期望的`user`数据结构，为每个字段提供默认值，以防它们缺失或为null。例如，如果`remoteUser.user_identification`为`null`，则将使用**N/A**作为默认ID。'
- en: Note that here, we use `?`), which allows you to access deeply nested properties
    without checking each level of nesting. If `subscription_details` or `level` is
    null or undefined, the result, `subscription`, will also be undefined and no errors
    will be thrown. We also used `??`) for falling back – it takes the value on its
    left if that value isn’t null or undefined; otherwise, it takes the value on its
    right.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这里，我们使用了`?`，这允许您在不检查每一层嵌套的情况下访问深层嵌套的属性。如果`subscription_details`或`level`为null或undefined，则结果`subscription`也将为undefined，并且不会抛出错误。我们还使用了`??`进行回退——如果其左侧的值不是null或undefined，则它将采用左侧的值；否则，它将采用右侧的值。
- en: All this transforming and fallback logic is now encapsulated in a common place
    – the ACL. Any further changes to the remote or local data shape can easily happen
    in this layer, and we don’t have to look up the entire code base for different
    usages.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些转换和回退逻辑现在都被封装在了一个共同的地方——ACL。任何对远程或本地数据形状的进一步更改都可以轻松地发生在这个层，我们不需要在整个代码库中查找不同的用法。
- en: Excellent – the ACL pattern effectively isolates business logic from your views.
    However, there are additional challenges in managing data within a React application,
    such as sharing data between components and avoiding prop drilling. In the following
    section, we’ll explore how to tackle these issues using the Context API.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 优秀——ACL模式有效地将业务逻辑与视图隔离开来。然而，在React应用程序中管理数据时还有额外的挑战，例如在组件之间共享数据和避免属性钻取。在下一节中，我们将探讨如何使用Context
    API来解决这些问题。
- en: Exploring the prop drilling issue
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索钻进问题
- en: '**Prop drilling** is an issue that arises when you have to pass data through
    multiple levels of components that don’t need the data, just so it can reach a
    component deeper in the hierarchy that does need it. This often makes the code
    harder to follow, understand, and maintain.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**属性钻取**是在您必须通过不需要数据的多个组件层级传递数据，以便它能够到达需要它的更深层次的组件时出现的问题。这通常会使代码更难跟踪、理解和维护。'
- en: 'Consider a standard scenario in React where we have a universal searchable
    list component. This component takes in a list and displays each item, whether
    it’s a list of books, menus, tickets, or anything else you can think of. In addition
    to displaying the list, the component also includes a search box, allowing users
    to easily filter through a lengthy list:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个标准的React场景，其中我们有一个通用的可搜索列表组件。该组件接受一个列表并显示每个项目，无论是书籍列表、菜单、票务还是您能想到的任何其他内容。除了显示列表外，该组件还包括一个搜索框，允许用户轻松过滤长列表：
- en: '![Figure 8.3: The searchable list component](img/B21103_08_03.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3：可搜索列表组件](img/B21103_08_03.jpg)'
- en: 'Figure 8.3: The searchable list component'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：可搜索列表组件
- en: 'At first glance, the implementation seems straightforward and not overly complicated:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，实现似乎很简单，并不过于复杂：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The code defines a `SearchableList` component in React that filters and displays
    a list of items based on user input. It starts with a full list of items and updates
    the filtered list whenever the text in the input box changes.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在React中定义了一个`SearchableList`组件，该组件根据用户输入过滤并显示项目列表。它从一个完整的项目列表开始，并在输入框中的文本更改时更新过滤后的列表。
- en: 'Over time, as the component evolves and is used in more diverse scenarios,
    the code base becomes increasingly complex, resulting in additional layout changes
    and more lines of code. As illustrated in *Figure 8**.4*, on the right-hand side,
    we can break the searchable list input into three sub-components called `SearchInput`,
    `List`, and `ListItem`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 随着组件的演变和在更多场景中的应用，代码库变得越来越复杂，导致额外的布局更改和更多的代码行。如图8.4*所示，在右侧，我们可以将可搜索列表输入分解为三个子组件，称为`SearchInput`、`List`和`ListItem`：
- en: '![Figure 8.4: Breaking a searchable list into smaller components](img/B21103_08_04.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.4：将可搜索列表分解成更小的组件](img/B21103_08_04.jpg)'
- en: 'Figure 8.4: Breaking a searchable list into smaller components'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4：将可搜索列表分解成更小的组件
- en: On the right-hand side, `SearchInput` accepts the user’s input (in the top red
    rectangle). It is a sibling of the `List` component (inside the green rectangle),
    which contains multiple `ListItem` (in the purple rectangle) – each `ListItem`
    represents an item (one might have a title, description, or buttons in it).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧，`SearchInput` 接受用户的输入（在顶部红色矩形中）。它是 `List` 组件的兄弟组件（在绿色矩形中），其中包含多个 `ListItem`（在紫色矩形中）——每个
    `ListItem` 代表一个项目（可能包含标题、描述或按钮）。
- en: 'Let’s look at each of these extracted components in detail:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看这些提取的组件：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`ListItem` displays the name and description of an item. For any further details
    that are needed, we only need to modify this file directly.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListItem` 显示项目的名称和描述。对于任何需要的进一步细节，我们只需直接修改此文件即可。'
- en: 'Then, each `ListItem` is wrapped inside a container component, `List`, like
    so:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，每个 `ListItem` 都被包裹在一个容器组件 `List` 中，如下所示：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This `List` acts as the container for all the items. It also includes a footer
    to show some summary information of the items.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `List` 作为所有项目的容器。它还包括一个页脚来显示一些项目的摘要信息。
- en: 'Finally, we have the `SearchInput` component, which is responsible for collecting
    user input and triggering searches as the user is typing:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有 `SearchInput` 组件，它负责收集用户输入并在用户输入时触发搜索：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that this code breakdown is only an internal structural change – we made
    the change only to make each part easy to read and understand. People who use
    `SearchableList` aren’t aware of such changes at all – the props of `SearchableList`
    haven’t been changed so far.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个代码分解仅是一个内部结构变化——我们只做了这个变化，以便使每个部分易于阅读和理解。使用 `SearchableList` 的人根本不知道这样的变化——到目前为止，`SearchableList`
    的属性还没有改变。
- en: 'However, the consumer has requested a new feature: they wish to track user
    interactions for analytics, specifically to gauge the popularity of items and
    the utilization of the search function. To meet this requirement, two new props
    are being introduced: an `onItemClicked` callback to capture when an item is clicked,
    and an `onSearch` callback to monitor when a search is performed.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，消费者请求了一个新功能：他们希望跟踪用户交互以进行数据分析，特别是为了衡量项目的受欢迎程度和搜索功能的利用率。为了满足这一要求，引入了两个新的属性：一个用于捕获项目点击时的
    `onItemClicked` 回调，以及一个用于监控搜索执行时的 `onSearch` 回调。
- en: 'So, we need to modify our code to meet these requirements, starting from the
    new type used in `SearchableList`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要修改我们的代码以满足这些要求，从 `SearchableList` 中使用的新类型开始：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To pass `onSearch` and `onItemClicked`, we’ll make some changes to `ListItem`.
    We need to change the props list (adding `onItemClicked`) and then call the function
    when the list is clicked:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要传递 `onSearch` 和 `onItemClicked`，我们将对 `ListItem` 进行一些修改。我们需要更改属性列表（添加 `onItemClicked`），然后在列表被点击时调用该函数：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'However, as `ListItem` is not exposed directly to the outside world, the props
    are passed from its parent component, `List`. So, we also need to update the `List`
    component’s props list to add `onItemClicked`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于 `ListItem` 没有直接暴露给外部世界，属性是从其父组件 `List` 传递过来的。因此，我们还需要更新 `List` 组件的属性列表，添加
    `onItemClicked`：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `List` component has to accept `onItemClicked` as a prop and then pass on
    the `onItemClicked` prop into `ListItem` without touching it. This is a code smell,
    signaling that the component is dealing with something not directly relevant to
    its function.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`List` 组件必须接受 `onItemClicked` 作为属性，然后将 `onItemClicked` 属性传递给 `ListItem` 而不对其进行任何操作。这是一个代码异味，表明组件正在处理与其功能不直接相关的事情。'
- en: 'Then, the `onItemClick` prop is passed from the `List` component''s parent
    `SearchableList` component, as shown here:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`onItemClick` 属性从 `List` 组件的父组件 `SearchableList` 组件传递过来，如下所示：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Observe how we transfer the `onItemClicked` prop to the `ListItem` component.
    First, it goes through the `List` component, which directly passes it down to
    `ListItem` without using it for anything. This is a classic example of prop drilling.
    The same could happen with `SearchInput`. As we continue to add more and more
    props from the outside and drill them down through the component tree, the entire
    structure could soon become unmanageable.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 观察我们如何将 `onItemClicked` 属性传递给 `ListItem` 组件。首先，它通过 `List` 组件传递，该组件直接将其传递给 `ListItem`
    而不用于任何操作。这是一个经典的属性钻探示例。同样的事情也可能发生在 `SearchInput` 上。随着我们继续添加越来越多的属性并从外部向下钻探组件树，整个结构很快就会变得难以管理。
- en: Fortunately, the Context API provides an elegant solution to the prop drilling
    issue, which we will review in the next section (we covered the fundamentals of
    using the Context API in [*Chapter 2*](B21103_02.xhtml#_idTextAnchor044); you
    can revisit that chapter if you’d like a refresher).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Context API为prop drilling问题提供了一个优雅的解决方案，我们将在下一节中对其进行回顾（我们已经在[*第2章*](B21103_02.xhtml#_idTextAnchor044)中介绍了使用Context
    API的基础知识；如果您想复习，可以回顾一下那一章）。
- en: Using the Context API to resolve prop drilling
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Context API解决prop drilling
- en: The concept behind using the Context API to address prop drilling is to create
    a shared container for all sub-components under a common parent. This eliminates
    the need for explicitly passing down props from parent to child. Sub-components
    can directly access the shared context whenever necessary. Another advantage of
    using the Context API is that it triggers automatic re-rendering of components
    whenever the data within the context changes.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Context API来处理prop drilling背后的概念是为一个共同的父组件下的所有子组件创建一个共享容器。这消除了从父组件显式传递props到子组件的需求。子组件可以在必要时直接访问共享上下文。使用Context
    API的另一个优点是，当上下文中的数据发生变化时，它会触发组件的自动重新渲染。
- en: Returning to our searchable list example, which has already got the *props drilling*
    issue, `onItemClicked` in the `List` component isn’t necessary as `List` doesn’t
    use the prop. This scenario involves just one layer and one prop. Now, envision
    a situation where we need to insert additional elements between the `List` and
    `ListItem` components; we would have to pass the `onItemClicked` prop down to
    where it’s utilized. The complexity is amplified if we have multiple props to
    relay.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的可搜索列表示例，它已经存在prop drilling问题，`List`组件中的`onItemClicked`是不必要的，因为`List`没有使用这个prop。这种场景只涉及一层和一个prop。现在，设想一个我们需要在`List`和`ListItem`组件之间插入额外元素的情况；我们必须将`onItemClicked`
    prop传递到它被使用的地方。如果有多个props需要传递，复杂性会进一步增加。
- en: 'The first step is to define a context with an appropriate type:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是定义一个具有适当类型的上下文：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This code defines a React context called `SearchableListContext`. It specifies
    the types of the `onSearch` and `onItemClicked` functions that the context will
    hold. It also initializes these functions with a no-operation (`noop`) function
    by default.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码定义了一个名为`SearchableListContext`的React上下文。它指定了上下文将持有的`onSearch`和`onItemClicked`函数的类型。它还默认使用无操作(`noop`)函数初始化这些函数。
- en: 'Now, we can use the context as a wrapper in the searchable list to provide
    the context to all its child components:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将上下文用作可搜索列表的包装器，为所有子组件提供上下文：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `SearchableList` component wraps its children, `SearchInput` and `List`,
    inside `SearchableListContext.Provider`. This allows these child components to
    access the `onSearch` and `onItemClicked` functions from the context without passing
    them down explicitly as props. The `handleSearch` function filters items based
    on the search keyword.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`SearchableList`组件将其子组件`SearchInput`和`List`包裹在`SearchableListContext.Provider`内部。这允许这些子组件无需显式作为props传递，就可以从上下文中访问`onSearch`和`onItemClicked`函数。`handleSearch`函数根据搜索关键字过滤项目。'
- en: 'This means our `List` component can be reverted to the simple version before
    we introduce `onItemClicked`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的`List`组件可以恢复到我们在引入`onItemClicked`之前的简单版本：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For `ListItem`, we can directly access `onItemClicked` from the context:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`ListItem`，我们可以直接从上下文中访问`onItemClicked`：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `ListItem` component now uses `useContext` to access the `onItemClicked`
    function from `SearchableListContext`. When a list item is clicked, `onItemClicked`
    is called with the clicked item as an argument.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListItem`组件现在使用`useContext`从`SearchableListContext`访问`onItemClicked`函数。当点击列表项时，`onItemClicked`会以被点击的项作为参数被调用。'
- en: 'Likewise, for the `SearchInput` component, there’s no need to pass down extra
    props from `SearchableList`. Instead, we can directly access what we need from
    the context:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，对于`SearchInput`组件，没有必要从`SearchableList`传递额外的props。相反，我们可以直接从上下文中获取我们需要的：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `SearchInput` component uses the `useContext` Hook to access the `onSearch`
    function from `SearchableListContext`. When the input changes, it calls both the
    local `onSearch` function and the one from the context, effectively merging external
    and internal behaviors.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`SearchInput`组件使用`useContext` Hook从`SearchableListContext`访问`onSearch`函数。当输入改变时，它调用本地的`onSearch`函数和上下文中的函数，有效地合并了外部和内部行为。'
- en: As demonstrated, the Context API results in a much cleaner structure. It allows
    you to make additional structural adjustments to sub-components without the concern
    of continually passing props down the hierarchy. This simplifies the component
    interface, making it easier to read and understand.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，Context API导致结构更加清晰。它允许你在不担心不断向下传递props的情况下，对子组件进行额外的结构调整。这简化了组件接口，使其更容易阅读和理解。
- en: Summary
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we delved into some of the most pressing challenges that are
    often encountered in React development, such as the leakage of business logic,
    the complexities associated with prop drilling, and the difficulties of managing
    shared state. To counter these issues, we introduced robust solutions such as
    the ACL and the Context API. These strategies aim to streamline your code, making
    it both more maintainable and effective for long-term projects.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了在React开发中经常遇到的一些最紧迫的挑战，例如业务逻辑的泄漏、与prop钻取相关的复杂性以及管理共享状态困难。为了应对这些问题，我们引入了如ACL和Context
    API等强大的解决方案。这些策略旨在简化你的代码，使其在长期项目中更具可维护性和有效性。
- en: Next up, we’ll dive into common React design patterns that you can use to further
    refine your coding skills. Stay tuned.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将深入探讨你可用于进一步磨练编码技能的常见React设计模式。敬请期待。
