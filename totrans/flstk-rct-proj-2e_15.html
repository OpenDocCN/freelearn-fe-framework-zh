<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Building a Media Streaming Application</h1>
                </header>
            
            <article>
                
<p>Uploading and streaming media content, specifically video content, has been a growing part of the internet culture for some time now. From individuals sharing personal video content to the entertainment industry disseminating commercial content on online streaming services, we all rely on web applications that enable smooth uploading and streaming. Capabilities within the MERN stack technologies can be used to build and integrate these core streaming features into any MERN-based full-stack application. In this chapter, we <span>will extend the MERN skeleton application to build a media streaming application, while demonstrating how to utilize MongoDB GridFS and add media streaming features to your web applications. </span></p>
<p>In this chapter, we will cover the following topics to implement basic media uploading and streaming by extending the MERN skeleton application:</p>
<ul>
<li>Introducing MERN Mediastream</li>
<li style="font-weight: 400">Uploading videos to MongoDB GridFS</li>
<li style="font-weight: 400">Storing and retrieving media details</li>
<li style="font-weight: 400">Streaming videos from GridFS to a basic media player</li>
<li>Listing, displaying, updating, and deleting media</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing MERN Mediastream</h1>
                </header>
            
            <article>
                
<p>We will build the MERN Mediastream application by extending the skeleton application. This will be a simple video streaming application that allows registered users to upload videos that can be streamed by anyone browsing the application. <span>The following screenshot shows the home page view on the MERN Mediastream application, along with a list of popular videos on the platform:</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-888 image-border" src="assets/a726f61d-5154-48bd-a13e-ae648367456b.png" style="width:78.50em;height:53.50em;"/></div>
<div class="packt_tip">
<div>The code for the complete MERN Mediastream application is available on GitHub at<span> <a href="https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter11%20and%2012/mern-mediastream" target="_blank">https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter11%20and%2012/mern-mediastream</a></span>. </div>
<div>You can clone this code and run the application as you go through the code explanations in the rest of this chapter.</div>
</div>
<p>The frontend user interface views that are needed for the <span>featu</span><span>res related to </span>media uploading, editing, and streaming in a simple media player will be developed by extending and modifying existing <span>React components</span> in the MERN skeleton application.<span> The component tree shown in the following diagram shows all the custom React components that make up the MERN Mediastream frontend that will be developed in this chapter:</span></p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-889 image-border" src="assets/80f78dff-f6a3-48b6-9244-f532cb0ffa45.png" style="width:102.67em;height:66.42em;"/></div>
<div>
<p><span>We will add new React components to implement views for uploading a new video, listing already posted media, modifying media post details, and displaying a video where users can interact with the video content to stream and watch it. We will also modify existing components such as the <kbd>Home</kbd> component so we can render a list of popular videos and the <kbd>Profile</kbd> component so we can list all the videos that are posted by a given user. T</span><span>hese uploading and streaming capabilities in the application will rely on the user's ability to upload video content. In the next section, we will discuss how to allow signed-in users to add media to the application.</span></p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Uploading and storing media</h1>
                </header>
            
            <article>
                
<p>Registered users on the MERN Mediastream application will be able to upload videos from their local files to store each video and related details directly on MongoDB using GridFS. <span>To enable uploading media content to the application, we need to define how to store media details and the video content and implement a full-stack slice that will let users create a new media post and upload a video file. In the following sections, first we will define a media model for storing the details of each media post and configure GridFS to store the associated video content. Then, we will discuss implementations for the backend API, which will receive and store the video content with other media details, and the frontend form view, which will allow a user to create a new media post on the application. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining a Media model</h1>
                </header>
            
            <article>
                
<p>We will implement a Mongoose model <span>to define a Media model for storing the details of each piece of media that's posted to the application. This model will be defined</span> in <kbd>server/models/media.model.js</kbd>,<span> and the implementation will be similar to</span><span> other Mongoose model implementations we covered in the previous chapters, such as the Course model we defined in <a href="c58ac055-5a1e-4bf4-b8a6-c9b311cf267a.xhtml" target="_blank">Chapter 6</a>, <em>Building a Web-Based Classroom Application</em></span><span>. The Media schema in this model will have</span> fields to record the media title, description, genre, number of views, dates of when the media was posted and updated, and a reference to the user who posted the media. <span>The code for defining the media fields is as follows:</span></p>
<ul>
<li><strong>Media title</strong>: <span>The <kbd>title</kbd> field is declared to be of the <kbd>String</kbd> type and will be a required field for introducing the media that are uploaded to the application:</span></li>
</ul>
<pre style="padding-left: 60px">title: {<br/>    type: String,<br/>    required: 'title is required'<br/>}</pre>
<ul>
<li><strong>Media description and genre</strong>: The <kbd>description</kbd> and <kbd>genre</kbd> fields will be of type <kbd>String</kbd>, and these will store additional details about the media posted. The <kbd>genre</kbd> field will also allow us to group the different media uploaded to the application.</li>
</ul>
<pre style="padding-left: 60px"> description: String,<br/> genre: String,</pre>
<p class="mce-root"/>
<ul>
<li><strong>Number of views</strong>: <span>The <kbd>views</kbd> field is defined as a <kbd>Number</kbd> type and will keep track of how many times the uploaded media was viewed by users in the application:</span></li>
</ul>
<pre style="padding-left: 60px">views: {<br/>    type: Number, <br/>    default: 0<br/>},</pre>
<ul>
<li><strong>Media posted by</strong>: <span>The <kbd>postedBy</kbd> field will reference the user who created the media post:</span></li>
</ul>
<pre style="padding-left: 60px"><br/> postedBy: {<br/>    type: mongoose.Schema.ObjectId, <br/>    ref: 'User'<br/> },</pre>
<ul>
<li><strong>Created and updated at times</strong>: <span>The</span><span> </span><kbd>created</kbd><span> </span><span>and</span><span> </span><kbd>updated</kbd><span> </span><span>fields will be <kbd>Date</kbd> types, with</span><span> </span><kbd>created</kbd><span> </span><span>generated when a new media is added and</span><span> </span><kbd>updated</kbd><span> </span><span>changed when any media details are modified:</span></li>
</ul>
<pre style="padding-left: 60px">updated: Date,<br/>created: { <br/>    type: Date, <br/>    default: Date.now <br/>},</pre>
<p><span>The fields that were added to the schema definition will only store details about each video that's posted to the application. In order to store the video content itself, we will use MongoDB GridFS. Before getting into the implementation of uploading a video file, in the next section we will discuss how GridFS makes it possible to store large files in MongoDB, and then add initialization code to start using GridFS in this streaming application. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using MongoDB GridFS to store large files</h1>
                </header>
            
            <article>
                
<p>In previous chapters, we discussed how files uploaded by users could be stored directly in MongoDB as binary data; for example, when adding a profile photo in<span> the <em>Upload profile photo</em> section in</span> <a href="27d3dbdf-0617-4ad8-9dcc-27afa417c174.xhtml" target="_blank"><span>Chapter 5</span></a><span>, <em>Growing the Skeleton into a Social Media Application</em>. </span>But this only worked for files smaller than 16 MB. In order to store larger files in MongoDB, such as video files needed for this streaming application, we will need to use GridFS.</p>
<p class="mce-root"/>
<p>GridFS is a specification in MongoDB that allows us to store large files in MongoDB by dividing a given file into several chunks. Each chunk can be a maximum of 255 KB in size, and is stored as a separate document. When the file has to be retrieved in response to a query to GridFS, the chunks are reassembled as needed. This opens up the option to fetch and load only parts of the file as required, rather than retrieving the whole file.</p>
<p><span>In the case of storing and retrieving video files for the MERN Mediastream application, we will utilize GridFS to store video files and stream parts of the video, depending on which part the user skips to and starts playing from.</span></p>
<div class="packt_tip"><span>You can learn more about the GridFS specification and its features in the official MongoDB documentation at </span><a href="https://docs.mongodb.com/manual/core/gridfs/"><span>https://docs.mongodb.com/manual/core/gridfs/</span></a>.</div>
<p>To access and work with <span>MongoDB </span>GridFS from our backend code, we will use the <span>Node.js MongoDB</span> driver's streaming API by creating a <kbd>GridFSBucket</kbd> with the established database connection.  </p>
<div class="packt_infobox">GridFSBucket is the GridFS streaming interface that gives us access to the streaming GridFS API. It can be used to interact with files in GridFS. You can learn more about GridFSBucket and the streaming API in the Node.js MongoDB Driver API documentation at <a href="https://mongodb.github.io/node-mongodb-native/3.2/api/GridFSBucket.html" target="_blank">https://mongodb.github.io/node-mongodb-native/3.2/api/GridFSBucket.html</a>.</div>
<p>Since we are using Mongoose to establish a connection with the MongoDB database for our application, we will add the following code to initialize a new <kbd>GridFSBucket</kbd> with this database connection after it has been established. </p>
<p><kbd>mern-mediastream/server/controllers/media.controller.js</kbd>:</p>
<pre>import mongoose from 'mongoose'<br/>let gridfs = null<br/>mongoose.connection.on('connected', () =&gt; {<br/>  gridfs = new mongoose.mongo.GridFSBucket(mongoose.connection.db)<br/>})</pre>
<p>The <kbd>gridfs</kbd> object we created here will give us access to the GridFS functionalities that are required to store the video file when new media is created and to fetch the file when the media is to be streamed back to the user. In the next section, we will add a create media form view and an API in the backend, which will use this <kbd>gridfs</kbd> object to save the video file that's uploaded with the request that's sent from the form view in the frontend.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a new media post</h1>
                </header>
            
            <article>
                
<p><span>For a user to be able to create a new media post on the application, we will need to integrate a full-stack slice that allows the user to fill out a form in the frontend and then save both the provided media details and the associated video file in the database in the backend.</span> <span>To implement this feature, in the following sections, we will add a create media API in the backend, along with a way to fetch this API in the frontend. Then, we will implement a create new media form view that allows the user to input media details and select a video file from their local filesystem.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The create media API</h1>
                </header>
            
            <article>
                
<p>We will implement a create media API in the backend to allow users to create new media posts on the application. This API will receive a POST request at <kbd>'/api/media/new/:userId'</kbd> with the multipart body content containing the media fields and the uploaded video file. First, we will declare the create media route and utilize the <kbd>userByID</kbd> method from the user controller, as shown in the following code. </p>
<p><kbd>mern-mediastream/server/routes/media.routes.js</kbd>:</p>
<pre>router.route('/api/media/new/:userId')<br/>        .post(authCtrl.requireSignin, mediaCtrl.create)<br/>router.param('userId', userCtrl.userByID)</pre>
<p><span>The </span><kbd>userByID</kbd><span> method processes the </span><kbd>:userId</kbd><span> parameter that's passed in the URL and retrieves the associated user from the database. The user object becomes available in the request object to be used in the next method that will be executed. </span>Similar to the user and auth routes, we will have to mount the media routes on the Express app in <kbd>express.js</kbd> as follows.</p>
<p><kbd>mern-mediastream/server/express.js</kbd>:</p>
<pre>app.use('/', mediaRoutes)</pre>
<p><span>A POST request to the create route URL, </span><kbd>/api/media/new/:userId</kbd><span>, will make sure the user is signed in and then initiate the </span><kbd>create</kbd><span> method in the media controller. </span>The <kbd>create</kbd> controller method will use the <kbd>formidable</kbd> node module to parse the multipart request body that will contain the media details and video file uploaded by the user. You can install the module by running the following command from the command line:</p>
<pre><strong>yarn add formidable</strong></pre>
<p>In the <kbd>create</kbd> method, we will use the media fields that have been received in the form data and parsed with <kbd>formidable</kbd> to generate a new Media object and then save it to the database. This <kbd>create</kbd> controller method is defined as follows.</p>
<p><kbd>mern-mediastream/server/controllers/media.controller.js</kbd>:</p>
<pre>const create = (req, res) =&gt; {<br/>  let form = new formidable.IncomingForm()<br/>  form.keepExtensions = true<br/>  form.parse(req, async (err, fields, files) =&gt; {<br/>      if (err) {<br/>        return res.status(400).json({<br/>          error: "Video could not be uploaded"<br/>        })<br/>      }<br/>      let media = new Media(fields)<br/>      media.postedBy= req.profile<br/>      if(files.video){<br/>        <strong>let writestream = gridfs.openUploadStream(media._id, {</strong><br/><strong>          contentType: files.video.type || 'binary/octet-stream'})</strong><br/><strong>        fs.createReadStream(files.video.path).pipe(writestream)</strong><br/>      }<br/>      try {<br/>        let result = await media.save()<br/>        res.status(200).json(result)<br/>      }<br/>      catch (err){<br/>          return res.status(400).json({<br/>            error: errorHandler.getErrorMessage(err)<br/>          })<br/>      }<br/>    })<br/>}</pre>
<p>If there is a file in the request, <kbd>formidable</kbd> will store it temporarily in the filesystem. We will use this temporary file and the media object's ID to create a writable stream with <kbd>gridfs.openUploadStream</kbd>. Here, the temporary file will be read and then written into MongoDB GridFS, while setting the <kbd>filename</kbd> value to the media ID. This will generate the associated chunks and file information documents in MongoDB, and when it is time to retrieve this file, we will identify it with the media ID.</p>
<p>To use this create media API in the frontend, we will add a corresponding <kbd>fetch</kbd> method in <kbd>api-media.js</kbd><span> </span>to make a <kbd>POST</kbd> request to the API by passing the multipart form data from the view. This method will be defined as follows. </p>
<p><kbd><span>mern-mediastream/client/media/api-media.js</span></kbd>:</p>
<pre>const create = async (params, credentials, media) =&gt; {<br/>  try {<br/>    let response = await fetch('/api/media/new/'+ params.userId, {<br/>    method: 'POST',<br/>    headers: {<br/>      'Accept': 'application/json',<br/>      'Authorization': 'Bearer ' + credentials.t<br/>    },<br/>    body: media<br/>  }) <br/>    return await response.json()<br/>  } catch(err) {<br/>    console.log(err)<br/>  }<br/>}</pre>
<p>This <kbd>create</kbd> fetch method will take the current user's ID, user credentials, and the media form data to make a POST request to the create media API in the backend. We will use this method when the user submits the new media form to upload a new video and post it on the application. In the next section, we will look at the implementation of this form view in the frontend.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The NewMedia component</h1>
                </header>
            
            <article>
                
<p>Registered users on the MERN Mediastream application will interact with a form view to enter details of a new media post. <span>This form view will be rendered in the</span> <kbd>NewMedia</kbd> component, which will allow a signed-in user to create a media post by entering the title, description, and genre of the video and uploading a video file from their local filesystem.</p>
<p>This form view will render as follows:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-890 image-border" src="assets/044f5619-fbaa-42bb-bcad-e5d2f97c93f6.png" style="width:14.58em;height:16.58em;"/></div>
<p><span>We will implement this form in a React component named </span><kbd>NewMedia</kbd><span>. For the view, we will add the file upload elements using a Material-UI <kbd>Button</kbd> and an HTML5 file <kbd>input</kbd> element, as shown in the following code.</span></p>
<p><kbd>mern-mediastream/client/media/NewMedia.js</kbd>:</p>
<pre>&lt;input <strong>accept="video/*"</strong> <br/>       onChange={handleChange('video')} <br/>       id="icon-button-file" <br/>       type="file"<br/>       style={{display: none}}/&gt;<br/>&lt;label htmlFor="icon-button-file"&gt;<br/>    &lt;Button color="secondary" variant="contained" component="span"&gt;<br/>       Upload &lt;FileUpload/&gt;<br/>    &lt;/Button&gt;<br/>&lt;/label&gt; <br/>&lt;span&gt;{values.video ? values.video.name : ''}&lt;/span&gt;<br/>      </pre>
<p>In the file <kbd>input</kbd> element, we specify that it accepts video files, so when the user clicks on <span class="packt_screen">Upload</span> and browses through their local folders, they only have the option to upload a video file. </p>
<p><span>Then, in the view, we add the</span> title, description, and genre form fields with the <kbd>TextField</kbd> components, as shown in the following code.</p>
<p><kbd><span>mern-mediastream/client/media/NewMedia.js</span></kbd>:</p>
<pre>&lt;TextField id="title" label="Title" value={values.title} <br/>           onChange={handleChange('title')} margin="normal"/&gt;&lt;br/&gt;<br/>&lt;TextField id="multiline-flexible" label="Description"<br/>           multiline rows="2"<br/>           value={values.description}<br/>           onChange={handleChange('description')}/&gt;&lt;br/&gt;<br/>&lt;TextField id="genre" label="Genre" value={values.genre} <br/>           onChange={handleChange('genre')}/&gt;&lt;br/&gt;</pre>
<p>These form field changes will be tracked with the <kbd>handleChange</kbd> method <span>when a user interacts with the input fields to enter values. </span><span>The</span><span> </span><kbd><span>handleChange</span></kbd><span> </span><span>function will be defined as follows.</span></p>
<p><kbd><span>mern-mediastream/client/media/NewMedia.js</span></kbd>:</p>
<pre>const handleChange = name =&gt; event =&gt; {<br/>    const value = name === 'video'<br/>      ? event.target.files[0]<br/>      : event.target.value<br/>    setValues({ ...values, [name]: value })<br/>}</pre>
<p>The <kbd>handleChange</kbd> method updates the state with the new values<span>, including the name of the video file, if one is uploaded by the user.</span></p>
<p><span>Finally, you can complete this form view by adding a Submit button, which, when clicked, should send the form data to the server. We will define a </span><kbd>clickSubmit</kbd><span> method here, which will be called when the Submit button is clicked by the user. </span></p>
<p><kbd><span>mern-mediastream/client/media/NewMedia.js</span></kbd>:</p>
<pre>  const clickSubmit = () =&gt; {<br/>    let mediaData = new FormData()<br/>    values.title &amp;&amp; mediaData.append('title', values.title)<br/>    values.video &amp;&amp; mediaData.append('video', values.video)<br/>    values.description &amp;&amp; mediaData.append('description',<br/>       values.description)<br/>    values.genre &amp;&amp; mediaData.append('genre', values.genre)<br/>    create({<br/>      userId: jwt.user._id<br/>    }, {<br/>      t: jwt.token<br/>    }, mediaData).then((data) =&gt; {<br/>      if (data.error) {<br/>        setValues({...values, error: data.error})<br/>      } else {<br/>        setValues({...values, error: '', mediaId: data._id, <br/>           redirect: true})<br/>      }<br/>    })<br/>  }</pre>
<p><span>This <kbd>clickSubmit</kbd> function will take the input values and populate </span><kbd>mediaData</kbd><span>, which is a </span><kbd>FormData</kbd><span> object that ensures the data is stored in the correct format for the </span><kbd>multipart/form-data</kbd><span> encoding type. Then,</span><span> the </span><kbd>create</kbd><span> fetch method is called to create the new media in the backend with this form data. On successful media creation, the user may be redirected to a different view as desired, for example, to a Media view with the new media details, as shown </span><span>in the following code.</span></p>
<p><kbd><span>mern-mediastream/client/media/NewMedia.js</span></kbd>:</p>
<pre>if (values.redirect) {<br/>    return (&lt;Redirect to={'/media/' + values.mediaId}/&gt;)<br/>}</pre>
<p><span>The </span><kbd>NewMedia</kbd><span> component can only be viewed by a signed-in user. Therefore, we will add a </span><kbd>PrivateRoute</kbd><span> in the </span><kbd>MainRouter</kbd><span> component, which will render this form only for authenticated users at </span><kbd>/media/new</kbd><span>.</span></p>
<p><kbd>mern-mediastream/client/MainRouter.js</kbd>:</p>
<pre>&lt;PrivateRoute path="/media/new" component={NewMedia}/&gt;</pre>
<p><span>This link can be added to any view, such as in the Menu component, so that it's rendered conditionally when users are signed in. Now that it is possible to add new media posts in this media streaming application, in the next section we will discuss the implementation of retrieving and rendering the video content associated with each media post. This will allow users to stream and view video files stored in MongoDB GridFS from the frontend of the application.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Retrieving and streaming media</h1>
                </header>
            
            <article>
                
<p>Any visitor browsing through the MERN Mediastream application will be able to view the media posted on the application by its users. Implementing this feature will require streaming the video files stored in MongoDB GridFS to the requesting client and rendering the stream in a media player. In the following sections, we will set up a backend API to retrieve a single video file, which we will then use as a source in a React-based media player to render the streaming video.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The video API</h1>
                </header>
            
            <article>
                
<p>To retrieve the video file associated with <span>a single media post</span>, we will implement a get video API that will accept a GET request at <kbd>'/api/medias/video/:mediaId'</kbd> and query both the Media collection and GridFS files. We will start implementing this video API by declaring the route shown in the following code, along with a way to handle the <kbd>:mediaId</kbd> parameter in the URL.</p>
<p><kbd>mern-mediastream/server/routes/media.routes.js</kbd>:</p>
<pre>router.route('/api/medias/video/:mediaId')<br/>        .get(mediaCtrl.video)<br/>router.param('mediaId', mediaCtrl.mediaByID)</pre>
<p>The <kbd>:mediaId</kbd> parameter in the route URL will be processed in the <kbd>mediaByID</kbd> controller to fetch the associated document from the Media collection and file details from GridFS. These retrieved results are then attached to the request object so that it can be used in the <kbd>video</kbd> controller method as required. This<span> </span><kbd>mediaByID</kbd><span> controller method is defined as follows.</span></p>
<p><kbd><span>mern-mediastream/server/controllers/media.controller.js</span></kbd>:</p>
<pre>const mediaByID = async (req, res, next, id) =&gt; {<br/>  try{<br/>  let media = await Media.findById(id).populate('postedBy', <br/>      '_id name').exec()<br/>    if (!media)<br/>      return res.status('400').json({<br/>        error: "Media not found"<br/>      })<br/>      req.media = media<br/>     <strong>let files = </strong><strong>await gridfs.find({filename:media._id}).toArray()</strong><br/><strong>       if (!files[0]) {</strong><br/><strong>          return res.status(404).send({</strong><br/><strong>            error: 'No video found'</strong><br/><strong>          })</strong><br/><strong>        } </strong><br/><strong>        req.file = files[0]</strong><br/>        next()<br/>    }catch(err) {<br/>      return res.status(404).send({<br/>        error: 'Could not retrieve media file'<br/>      })<br/>    }<br/>}</pre>
<p>To retrieve the relevant file details from GridFS, we use <kbd>find</kbd> from the MongoDB streaming API. We query the files stored in GridFS by the filename value, which should match the corresponding media ID in the Media collection. Then, we receive the resulting matching file records in an array and attach the first result to the request object so that it can be used in the next method.</p>
<p>The next method that's invoked when this API receives a request is the <kbd>video</kbd> controller method. In this method, depending on whether the request contains range headers, we send back the correct chunks of video with the related content information set as response headers. T<span>he </span><kbd>video</kbd><span> controller method is defined with the following structure, with the response composed depending on the existence of range headers in the request.</span></p>
<p><kbd><span>mern-mediastream/server/controllers/media.controller.js</span></kbd>:</p>
<pre>const video = (req, res) =&gt; {<br/>  const range = req.headers["range"]  <br/>    if (range &amp;&amp; typeof range === "string") {<br/>      ...<br/>      ... consider range headers and send only relevant chunks in response ...<br/>      ...<br/>  } else {<br/>      res.header('Content-Length', req.file.length)<br/>      res.header('Content-Type', req.file.contentType)<br/><br/>      let downloadStream = gridfs.openDownloadStream(req.file._id)<br/>      downloadStream.pipe(res)<br/>      downloadStream.on('error', () =&gt; {<br/>        res.sendStatus(404)<br/>      })<br/>      downloadStream.on('end', () =&gt; {<br/>        res.end()<br/>      })<br/>   }<br/>}</pre>
<p>In the preceding code, if the request does not contain range headers, we stream back the whole video file using <kbd>gridfs.openDownloadStream</kbd>, which gives us a readable stream of the corresponding file stored in GridFS. This is piped with the response sent back to the client. In the response header, we set the content type and total length of the file.</p>
<p>If the request contains range headers <span>–</span> for example, when the user drags to the middle of the video and starts playing from that point <span>–</span> we need to convert the received range headers to the start and end positions, which will correspond with the correct chunks stored in GridFS, as shown in the following code.</p>
<p><kbd><span>mern-mediastream/server/controllers/media.controller.js</span></kbd>:</p>
<pre>    const parts = range.replace(/bytes=/, "").split("-")<br/>    const partialstart = parts[0]<br/>    const partialend = parts[1]<br/><br/>    const start = parseInt(partialstart, 10)<br/>    const end = partialend ? parseInt(partialend, 10) : req.file.length - 1<br/>    const chunksize = (end - start) + 1<br/><br/>    res.writeHead(206, {<br/>        <strong>'Accept-Ranges': 'bytes',</strong><br/><strong>        'Content-Length': chunksize,</strong><br/><strong>        'Content-Range': 'bytes ' + start + '-' + end + '/' + req.file.length,</strong><br/><strong>        'Content-Type': req.file.contentType</strong><br/>    })<br/><br/>    let downloadStream = gridfs.openDownloadStream(req.file._id, {<strong>start, end: end+1</strong>})<br/>    downloadStream.pipe(res)<br/>    downloadStream.on('error', () =&gt; {<br/>      res.sendStatus(404)<br/>    })<br/>    downloadStream.on('end', () =&gt; {<br/>      res.end()<br/>    })</pre>
<p><span>We pass the start and end values that have been extracted from the header as a range to </span><kbd>gridfs.openDownloadStream</kbd><span>. These start and end values specify the 0-based offset in bytes to start streaming from and stop streaming before. </span><span>We also set the response headers with additional file details, including content length, range, and type. The content length will now be the total size of the content within the defined range. Therefore, t</span>he readable stream that's piped back to the response, in this case, will only contain the chunks of file data that fall within the start and end ranges.  </p>
<p>The final readable stream that's piped to the response after a request is <span>received</span> at this get video API can be rendered directly in a basic HTML5 media player or a React-flavored media player in the frontend view. In the next section, we will look at how to render this video stream in a simple React media player.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using a React media player to render the video</h1>
                </header>
            
            <article>
                
<p>In the frontend of the application, we can render the video file being streamed from MongoDB GridFS in a media player. A good option for a React-flavored media player is the <kbd>ReactPlayer</kbd> component, available as a node module, which can be customized as required. Providing the video stream as a source to a default <kbd>ReactPlayer</kbd> component will render <span>with basic player controls, </span>as shown in the following screenshot:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-891 image-border" src="assets/5426cde7-a7af-44d8-922e-a1b36c11aed7.png" style="width:18.83em;height:12.67em;"/></div>
<p>To start using <kbd>ReactPlayer</kbd> in our frontend code, we need to install the corresponding node module by running the following Yarn command from the command line:</p>
<pre><strong>yarn add react-player </strong></pre>
<p>Once installed, we can import it into any React component and add it to the view. For basic usage with the default controls provided by the browser, we can add it to any React view in any application that has access to the ID of the media to be rendered, as shown in the following code:</p>
<pre>&lt;ReactPlayer url={'/api/media/video/'+media._id} controls/&gt;</pre>
<p>This will load the player with the video stream that was received from the get video API and provide the user with basic control options to interact with the stream being played. <kbd>ReactPlayer</kbd><span> can be customized so that more options are available. We will explore some of these </span><span>advanced options for customizing this</span><span> </span><kbd>ReactPlayer</kbd><span> with our own controls in the next chapter.</span></p>
<div class="packt_tip">To learn more about what is possible with <kbd>ReactPlayer</kbd>, visit <a href="https://cookpete.com/react-player" target="_blank">cookpete.com/react-player</a>.<a href="https://cookpete.com/react-player"/></div>
<p>Now, it's possible to retrieve a single video file stored in MongoDB GridFS and stream it to a media player in the frontend for the user to view and play the video as desired. In the next section, we will discuss how to fetch and display lists of multiple videos from the backend to the frontend of the streaming application. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Listing media</h1>
                </header>
            
            <article>
                
<p>In MERN Mediastream, we will add list views of relevant media with a snapshot of each video to give visitors easier access and an overview of the videos on the application. For example, i<span>n the following screenshot, the </span><kbd>Profile</kbd><span> component displays a list of media posted by the corresponding user, showing the video preview and other details of each media:</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-892 image-border" src="assets/d39a7f3f-6078-41a7-8bd5-442e6404057e.png" style="width:34.67em;height:16.75em;"/></div>
<p><span>We will set up list APIs in the backend to retrieve different lists, such as videos uploaded by a single user and the most popular videos with the highest views in the application. Then, these retrieved lists can be rendered in a reusable </span><kbd>MediaList</kbd><span> component, which will receive a list of media objects as a prop from a parent component that fetches the specific API. In the following sections, we will implement the <kbd>MediaList</kbd> component and the backend APIs to retrieve the two different lists of media from the database. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The MediaList component</h1>
                </header>
            
            <article>
                
<p>The <kbd>MediaList</kbd> component is a reusable component that will take a list of media and iterate through it to render each media item in the view. In MERN Mediastream, we use it to render a list of the most popular media in the home view and a list of media uploaded by a specific user in their profile.</p>
<p>In the view part of the <kbd>MediaList</kbd> component, we will iterate through the <kbd>media</kbd> array that's received in <kbd>props</kbd> using <kbd>map</kbd>, as shown in the following code.</p>
<p><kbd>mern-mediastream/client/media/MediaList.js</kbd>:</p>
<pre>&lt;GridList cols={3}&gt;<br/>    {props.media.map((tile, i) =&gt; (<br/>        &lt;GridListTile key={i}&gt;<br/>          &lt;Link to={"/media/"+tile._id}&gt;<br/>            &lt;ReactPlayer url={'/api/media/video/'+tile._id} <br/>               width='100%' height='inherit' style=<br/>                 {{maxHeight:   '100%'}}/&gt;<br/>          &lt;/Link&gt;<br/>          &lt;GridListTileBar title={&lt;Link <br/>              to={"/media/"+tile._id}&gt; {tile.title} &lt;/Link&gt;}<br/>            subtitle={&lt;span&gt;<br/>                        &lt;span&gt;{tile.views} views&lt;/span&gt;<br/>                        &lt;span className={classes.tileGenre}&gt;<br/>                        &lt;em&gt;{tile.genre}&lt;/em&gt;<br/>                        &lt;/span&gt;<br/>                    &lt;/span&gt;}<br/>          /&gt;<br/>        &lt;/GridListTile&gt;<br/>    ))}<br/>&lt;/GridList&gt;</pre>
<p>This <kbd>MediaList</kbd> component uses the Material-UI <kbd>GridList</kbd> components as it iterates through the array of objects sent in the props and renders media details for each item in the list. It also includes a <kbd>ReactPlayer</kbd> component, which renders the video URL without showing any controls. In the view, this gives the visitor a brief overview of each piece of media, as well as a glimpse of the video content.</p>
<p>This component can be added to any view that can provide an array of media objects. In the MERN Mediastream application, we use it to render two different lists of media: a list of popular media and a list of media posted by a specific user. In the next section, we will look at how to retrieve a list of popular media from the database to render it in the frontend. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Listing popular media</h1>
                </header>
            
            <article>
                
<p>To retrieve specific lists of media from the database, we need to set up the relevant APIs on the server. For popular media, we will set up a route that receives a GET request at <kbd>/api/media/popular</kbd>. The route will be declared as follows.</p>
<p><kbd><span>mern-mediastream/server/routes/media.routes.js</span></kbd>:</p>
<pre> router.route('/api/media/popular')<br/>          .get(mediaCtrl.listPopular)</pre>
<p>A GET request to this URL will invoke the <kbd>listPopular</kbd> method. The <kbd>listPopular</kbd> controller method will query the Media collection and retrieve nine media documents that have the highest <kbd>views</kbd> in the whole collection. <span>The </span><kbd>listPopular</kbd><span> method is defined as follows.</span></p>
<p><kbd><span>mern-mediastream/server/controllers/media.controller.js</span></kbd>:</p>
<pre>const listPopular = async (req, res) =&gt; {<br/>  try{<br/>    let media = await Media.find({})<br/>    .populate('postedBy', '_id name')<br/>    .sort('-views')<br/>    .limit(9)<br/>    .exec()<br/>    res.json(media)<br/>  } catch(err){<br/>    return res.status(400).json({<br/>      error: errorHandler.getErrorMessage(err)<br/>    })<br/>  }<br/>}</pre>
<p>The result that's returned by the query to the Media collection is sorted by the number of views in descending order and limited to nine. Each media document in this list will also contain the name and ID of the user who posted it since we are calling <kbd>populate</kbd> to add these user attributes.</p>
<p><span>This API can be used in the frontend with a fetch request. You can define a corresponding fetch method in <kbd>api-media.js</kbd> to make the request, similarly to other API implementations. Then, the</span> fetch method can be called in a React component, such as in the <kbd>Home</kbd> component for this application. In the <kbd>Home</kbd> component, we will fetch a list of popular videos in a <kbd>useEffect</kbd> hook, as shown in the following code.</p>
<p><kbd>mern-mediastream/client/core/Home.js</kbd>:</p>
<pre>  useEffect(() =&gt; {<br/>    const abortController = new AbortController()<br/>    const signal = abortController.signal<br/>    <strong>listPopular</strong>(signal).then((data) =&gt; {<br/>      if (data.error) {<br/>        console.log(data.error)<br/>      } else {<br/>        setMedia(data)<br/>      }<br/>    })<br/>    return function cleanup(){<br/>      abortController.abort()<br/>    }<br/>  }, [])</pre>
<p><span>The list that's fetched from the API in this hook is set in the state so that it can be passed to a </span><kbd>MediaList</kbd><span> component in the view. </span>In the Home view, we can add the <kbd>MediaList</kbd> as follows, with the list provided as a prop.</p>
<p><kbd>mern-mediastream/client/core/Home.js</kbd>:</p>
<pre>&lt;MediaList media={media}/&gt;</pre>
<p>This will render a list of up to nine of the most popular videos from the database on the home page of the MERN Mediastream application. In the next section, we will discuss a similar implementation to retrieve and render a list of media that's been posted by a specific user.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Listing media by users</h1>
                </header>
            
            <article>
                
<p>To be able to retrieve a list of media that's been uploaded by a specific user from the database, we will set up an API with a route that accepts a <kbd>GET</kbd> request at <kbd>'/api/media/by/:userId'</kbd>. The route will be declared as follows.</p>
<p><kbd><span>mern-mediastream/server/routes/media.routes.js</span></kbd>:</p>
<pre>router.route('/api/media/by/:userId')<br/>         .get(mediaCtrl.listByUser) </pre>
<p>A GET request to this route will invoke the <kbd>listByUser</kbd> method. The <kbd>listByUser</kbd> controller method will query the Media collection to find media documents that have <kbd>postedBy</kbd> values matching with the <kbd>userId</kbd> attached as a parameter in the URL. The <kbd>listByUser</kbd><span> controller method is defined as follows.</span></p>
<p><kbd><span>mern-mediastream/server/controllers/media.controller.js</span></kbd>:</p>
<pre>const listByUser = async (req, res) =&gt; {<br/>  try{<br/>    let media = await Media.find({postedBy: req.profile._id})<br/>      .populate('postedBy', '_id name')<br/>      .sort('-created')<br/>      .exec()<br/>    res.json(media)<br/>  } catch(err){<br/>      return res.status(400).json({<br/>        error: errorHandler.getErrorMessage(err)<br/>      })<br/>  }<br/>}</pre>
<p><span>The result that's returned from the query to the Media collection is sorted by the date it was created on, with the latest post showing up first. Each media document in this list will also contain the name and ID of the user who posted it since we are calling </span><kbd>populate</kbd><span> to add these user attributes.</span></p>
<p><span>This API can be used in the frontend with a fetch request. You can define a corresponding <kbd>fetch</kbd> method in <kbd>api-media.js</kbd> to make the request, similar to other API implementations. Then, the fetch method can be called in a React component. In our application, we use the <kbd>fetch</kbd> method </span>in the <kbd>Profile</kbd> component, similar to the <kbd>listPopular</kbd> fetch method we used in the home view, to retrieve the list data, set it to the state, and then pass it to a <kbd>MediaList</kbd> component. This will render a profile page with a list of media that was posted by the corresponding user.</p>
<p>We are able to retrieve and display multiple videos on the application by utilizing APIs that have been implemented in the backend to fetch the list data. We can also utilize a ReactPlayer component without controls to give the user a glimpse of each video when we render the list in the frontend views. In the next section, we will discuss the full-stack slices that will display media posts and <span>allow authorized users to</span> update and delete individual media posts in the application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Displaying, updating, and deleting media</h1>
                </header>
            
            <article>
                
<p><span>Any visitor to MERN Mediastream will be able to vie</span>w media de<span>tails and stream videos, while only r</span>egistered users will be able to edit the media's details and delete it any time after they post it on the application. In the following sections, we will implement full-stack slices, including backend APIs and frontend views, to display a single media post, update details of a media post, and delete a media post from the application. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Displaying media</h1>
                </header>
            
            <article>
                
<p>Any visitor to MERN Mediastream will be able to browse to a single media view to play a video and read the details associated with it. Every time a specific video is loaded on the application, we will also increment the number of views associated with the media. <span>In the following sections, we will implement the individual media view by adding a read media API to the backend, a way to call this API from the frontend, and the React component that will display the media details in the view.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The read media API</h1>
                </header>
            
            <article>
                
<p><span>To implement the read media API in the backend, we will start </span><span>by adding a</span><span> </span><kbd>GET</kbd><span> route that queries the</span><span> </span><kbd>Media</kbd><span> </span><span>collection with an ID and returns the media document in the response. </span>The route is declared as follows.</p>
<p><kbd><span>mern-mediastream/server/routes/media.routes.js</span></kbd>:</p>
<pre>router.route('/api/media/:mediaId')<br/>    .get( mediaCtrl.incrementViews, mediaCtrl.read)</pre>
<p>The <kbd>mediaId</kbd> in the request URL will cause the <kbd>mediaByID</kbd> controller method to execute and attach the retrieved media document to the request object so that it can be accessed in the next method. </p>
<p><span>A <kbd>GET</kbd> request to this API will execute the </span><kbd>incrementViews</kbd><span> </span><span>controller method next, which will find the matching media record and increment the <kbd>views</kbd> value by <kbd>1</kbd>, before saving the updated record to the database. The <kbd>incrementViews</kbd> method is defined as follows.</span></p>
<p><kbd><span>mern-mediastream/server/controllers/media.controller.js</span></kbd>:</p>
<pre>const incrementViews = async (req, res, next) =&gt; {<br/>  try {<br/>    await Media.findByIdAndUpdate(req.media._id, <br/>       {$inc: {"views": 1}}, {new: true}).exec()<br/>    next()<br/>  } catch(err){<br/>      return res.status(400).json({<br/>          error: errorHandler.getErrorMessage(err)<br/>      })<br/>  }<br/>}</pre>
<p>This method will increment the number of views for a given media by 1 every time this read media API is called. After the media is updated from this <kbd>incrementViews</kbd> method, the <kbd>read</kbd> controller method is invoked. The <kbd>read</kbd> controller method will simply return the retrieved media document in response to the requesting client, as shown in the following code.</p>
<p><kbd><span>mern-mediastream/server/controllers/media.controller.js</span></kbd>:</p>
<pre>const read = (req, res) =&gt; {<br/>  return res.json(req.media)<br/>}</pre>
<p>To <span>retrieve the media document that was sent in the response, we need to </span>call this read media API in the frontend using a fetch method. We will set up a corresponding fetch method in <kbd>api-media.js</kbd>, as shown in the following code.</p>
<p><kbd><span>mern-mediastream/client/media/api-media.js</span></kbd>:</p>
<pre>const read = async (params, signal) =&gt; {<br/>  try {<br/>    let response = await fetch('/api/media/' + params.mediaId, {<br/>    method: 'GET',<br/>    signal: signal<br/>  })<br/>    return await response.json()<br/>  } catch(err) {<br/>    console.log(err)<br/>  }<br/>}</pre>
<p>This method takes the ID of the media to be retrieved and makes a <kbd>GET</kbd> request to the read API route using a <kbd>fetch</kbd>.</p>
<p>The read media API can be used to render individual media details in a view or to pre-populate a media edit form. In the next section, we will <span>use this fetch method to call the read media API in the React component to render the media details, as well as a <kbd>ReactPlayer</kbd> that will play the associated video.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Media component</h1>
                </header>
            
            <article>
                
<p>The <kbd>Media</kbd> component will render details of an individual media record and stream the video in a basic <kbd>ReactPlayer</kbd> with default browser controls. <span>The completed single Media view will look as follows:</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-893 image-border" src="assets/c171333d-9949-44de-8e54-08edce73050f.png" style="width:38.17em;height:32.75em;"/></div>
<p>The <kbd>Media</kbd> component can call the read API to fetch the media data itself or receive the data as props from a parent component that makes the call to the read API. In the latter case, the parent component will fetch the media from the server in a <kbd>useEffect</kbd> hook, set it to state, and add it to the <kbd>Media</kbd> component, as follows.</p>
<p><kbd><span>mern-mediastream/client/media/PlayMedia.js</span></kbd>:</p>
<pre>&lt;Media media={media}/&gt;</pre>
<p>In MERN Mediastream, we will add the <kbd>Media</kbd> component in a <kbd>PlayMedia</kbd> component that fetches the media content from the server in a <kbd>useEffect</kbd> hook using the read API and passes it to <kbd>Media</kbd> as a prop. The composition of the <kbd>PlayMedia</kbd> component will be discussed in more detail in the next chapter.</p>
<p>The <kbd>Media</kbd> component will take this data in the props and render it in the view to display the details and load the video in a <kbd>ReactPlayer</kbd> component. The title, genre, and view count details of the media can be rendered in a Material-UI <kbd>CardHeader</kbd> component in the <kbd>Media</kbd> component, as shown in the following code.</p>
<p><kbd>mern-mediastream/client/media/Media.js</kbd>:</p>
<pre>&lt;CardHeader <br/>   title={props.media.title}<br/>   action={&lt;span&gt;<br/>                {props.media.views + ' views'}<br/>           &lt;/span&gt;}<br/>   subheader={props.media.genre}<br/>/&gt;</pre>
<p>Besides rendering these media details, we will also load the video in the <kbd>Media</kbd> component. The video URL, which is basically the get video API route we set up in the backend, is loaded in a <kbd>ReactPlayer</kbd> with default browser controls, as shown in the following code.</p>
<p><kbd><span>mern-mediastream/client/media/Media.js</span></kbd>:</p>
<pre>const <strong>mediaUrl</strong> = props.media._id<br/>          ? `/api/media/video/${props.media._id}`<br/>          : null<br/>            … <br/>&lt;ReactPlayer url={<strong>mediaUrl</strong>} <br/>             <strong>controls</strong><br/>             width={'inherit'}<br/>             height={'inherit'}<br/>             style={{maxHeight: '500px'}}<br/>             config={{ attributes: <br/>                        { style: { height: '100%', width: '100%'} } <br/>}}/&gt;</pre>
<p>This will render a simple player that allows the user to play the video stream.</p>
<p>The <kbd>Media</kbd> component also renders additional details about the user who posted the video, a description of the video, and the date it was created, as shown in the following code.</p>
<p><kbd><span>mern-mediastream/client/media/Media.js</span></kbd>:</p>
<pre>&lt;ListItem&gt;<br/>    &lt;ListItemAvatar&gt;<br/>      &lt;Avatar&gt;<br/>        {props.media.postedBy.name &amp;&amp; <br/>                        props.media.postedBy.name[0]}<br/>      &lt;/Avatar&gt;<br/>    &lt;/ListItemAvatar&gt;<br/>    &lt;ListItemText primary={props.media.postedBy.name} <br/>              secondary={"Published on " + <br/>                        (new Date(props.media.created))<br/>                        .toDateString()}/&gt;<br/>&lt;/ListItem&gt;<br/>&lt;ListItem&gt;<br/>    &lt;ListItemText primary={props.media.description}/&gt;<br/>&lt;/ListItem&gt;</pre>
<p>In the details being displayed in the Material-UI <kbd>ListItem</kbd> component, we will also conditionally show edit and delete options if the currently signed-in user is the one who posted the media being displayed. To render these elements conditionally in the view, we will add the following code after the <kbd>ListItemText</kbd> displaying the date.</p>
<p><kbd><span>mern-mediastream/client/media/Media.js</span></kbd>:</p>
<pre>{(auth.isAuthenticated().user &amp;&amp; auth.isAuthenticated().user._id) <br/>    == props.media.postedBy._id &amp;&amp; (&lt;ListItemSecondaryAction&gt;<br/>        &lt;Link to={"/media/edit/" + props.media._id}&gt;<br/>          &lt;IconButton aria-label="Edit" color="secondary"&gt;<br/>            &lt;Edit/&gt;<br/>          &lt;/IconButton&gt;<br/>        &lt;/Link&gt;<br/>        &lt;DeleteMedia mediaId={props.media._id} mediaTitle=<br/>       {props.media.title}/&gt;<br/>      &lt;/ListItemSecondaryAction&gt;)}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>This will ensure that the edit and delete options only render when the current user is signed in and is the uploader of the media being displayed. The edit option links to the media edit form, while the delete option opens a dialog box that can initiate the deletion of this particular media document from the database. In the next section, <span>we will implement the functionality of this option to edit details of the uploaded media post.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating media details</h1>
                </header>
            
            <article>
                
<p>Registered users will have access to an edit form for each of their media uploads. Updating and submitting this form will save the changes to the given document in the Media collection. <span>To implement this capability, we will have to create a backend API that allows the update operation on a given media after ensuring that the requesting user is authenticated and authorized. Then, this updated API needs to be called from the frontend with the changed details of the media. In the following sections, we will build this backend API and the React component to</span><span> allow users to make changes to the media they already posted on the application.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The media update API</h1>
                </header>
            
            <article>
                
<p><span>In the backend, we will need an API that allows us to update existing media in the database if the user making the request is the authorized creator of the given media post. First, we will declare the PUT route, which accepts the update request from the client.</span></p>
<p><kbd><span>mern-mediastream/server/routes/media.routes.js</span></kbd>:</p>
<pre>router.route('/api/media/:mediaId')<br/>        .put(authCtrl.requireSignin, <br/>                mediaCtrl.isPoster, <br/>                    mediaCtrl.update)</pre>
<p>When a PUT request is received at <kbd>'api/media/:mediaId'</kbd>, the server will ensure the signed-in user is the original poster of the media content by calling the <kbd>isPoster</kbd> controller method. The <kbd>isPoster</kbd><span> controller method is defined as follows.</span></p>
<p><kbd><span>mern-mediastream/server/controllers/media.controller.js:</span></kbd></p>
<pre>const isPoster = (req, res, next) =&gt; {<br/> let isPoster = req.media &amp;&amp; req.auth <br/>    &amp;&amp; req.media.postedBy._id == req.auth._id<br/> if(!isPoster){<br/> return res.status('403').json({<br/> error: "User is not authorized"<br/> })<br/> }<br/> next()<br/>}</pre>
<p>This method ensures the ID of the authenticated user is the same as the user ID referenced in the <kbd>postedBy</kbd> field of the given media document. If the user is authorized, the <kbd>update</kbd> controller method will be called <kbd>next</kbd> in order to update the existing media document with the changes. T<span>he </span><kbd>update</kbd><span> controller method is defined as follows</span>. </p>
<p><kbd><span>mern-mediastream/server/controllers/media.controller.js</span></kbd>:</p>
<pre>const update = async (req, res) =&gt; {<br/>  try {<br/>    let media = req.media<br/>    media = extend(media, req.body)<br/>    media.updated = Date.now()<br/>    await media.save()<br/>    res.json(media)<br/>  } catch(err){<br/>    return res.status(400).json({<br/>        error: errorHandler.getErrorMessage(err)<br/>    })<br/>  }<br/>}</pre>
<p>This method extends the existing media document with the changed details that were received in the request body and <span>saves the updated media to the database.</span></p>
<p>To access the update API in the frontend, we will add a corresponding fetch method in <kbd>api-media.js</kbd> that takes the necessary user auth credentials and media details as parameters before making<span> the fetch call to this update media API, as shown in the following code.</span></p>
<p><kbd><span>mern-mediastream/client/user/api-media.js</span></kbd>:</p>
<pre>const update = async (params, credentials, media) =&gt; {<br/>  try {<br/>    let response = await fetch('/api/media/' + params.mediaId, {<br/>    method: 'PUT',<br/>    headers: {<br/>      'Accept': 'application/json',<br/>      'Content-Type': 'application/json',<br/>      'Authorization': 'Bearer ' + credentials.t<br/>    },<br/>    body: JSON.stringify(media)<br/>  }) <br/>    return await response.json()<br/>    } catch(err) {<br/>      console.log(err)<br/>    }<br/>}</pre>
<p>This fetch method will be used in the media edit form when the user makes updates and submits the form. In the next section, we will discuss the implementation of this media edit form.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The media edit form</h1>
                </header>
            
            <article>
                
<p>The media edit form, which will allow an authorized user to make changes to the details of a media post, will be similar to the new media form. However, it will not have an upload option, and the fields will be pre-populated with the existing values, as shown in the following screenshot:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-894 image-border" src="assets/180e69b1-8f55-46f0-b290-6304b551a616.png" style="width:14.50em;height:13.42em;"/></div>
<p>The <kbd>EditMedia</kbd> component containing this form will fetch the existing values of the media by calling the read media API in a <kbd>useEffect</kbd> hook, as shown in the following code.</p>
<p><kbd>mern-mediastream/client/media/EditMedia.js</kbd>:</p>
<pre>  useEffect(() =&gt; {<br/>    const abortController = new AbortController()<br/>    const signal = abortController.signal<br/><br/>    read({mediaId: match.params.mediaId}).then((data) =&gt; {<br/>      if (data.error) {<br/>        setError(data.error)<br/>      } else {<br/>        setMedia(data)<br/>      }<br/>    })<br/>    return function cleanup(){<br/>      abortController.abort()<br/>    }<br/>  }, [match.params.mediaId])</pre>
<p><span>The retrieved media details are set to state so that the values can be rendered in the text fields. </span>The form field elements will be the same as in the <kbd>NewMedia</kbd> component. When a user updates any of the values in the form, the changes will be registered in the <kbd>media</kbd> object in state with a call to the <kbd>handleChange</kbd> method. T<span>he </span><kbd>handleChange</kbd><span> method is defined as follows.</span></p>
<p><kbd><span>mediastream/client/media/EditMedia.js</span></kbd>:</p>
<pre>  const handleChange = name =&gt; event =&gt; {<br/>    let updatedMedia = {...media}<br/>    updatedMedia[name] = event.target.value<br/>    setMedia(updatedMedia)<br/>  }</pre>
<p>In this method, the specific field that's being updated in the form is reflected in the corresponding attribute in the media object in state. When the user is done editing and clicks submit, a call will be made to the update API with the required credentials and the changed media values. This is done by invoking the <kbd>clickSubmit</kbd> method, which is defined as follows.</p>
<p><kbd>mediastream/client/media/EditMedia.js</kbd>:</p>
<pre>  const clickSubmit = () =&gt; {<br/>    const jwt = auth.isAuthenticated()<br/>    <strong>update</strong>({<br/>      mediaId: media._id<br/>    }, {<br/>      t: jwt.token<br/>    }, media).then((data) =&gt; {<br/>      if (data.error) {<br/>        setError(data.error)<br/>      } else {<br/>        setRedirect(true)<br/>      }<br/>    })<br/>  }</pre>
<p>The call to the update media API will update the media details in the corresponding media document in the Media collection, while the video file associated with the media remains as it is in the database.</p>
<p>This<span> </span><kbd>EditMedia</kbd><span> </span>component can only be accessed by signed-in users and will be rendered at<span> </span><kbd>'/media/edit/:mediaId'</kbd>. Due to this, <span>we will add a </span><kbd>PrivateRoute</kbd><span> in the </span><kbd>MainRouter</kbd><span> component, like so.</span></p>
<p><kbd>mern-mediastream/client/MainRouter.js</kbd>:</p>
<pre>&lt;PrivateRoute path="/media/edit/:mediaId" component={EditMedia}/&gt;</pre>
<p><span>This link is added with an edit icon in the </span><kbd>Media</kbd><span> component, allowing the user who posted the media to access the edit page. In the </span><kbd>Media</kbd><span> view, the user can also choose to delete their media post. We will implement this in the next section.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deleting media</h1>
                </header>
            
            <article>
                
<p>An authorized user can <span>completely </span>delete the media they uploaded to the application, including the media document in the Media collection and the file chunks stored in MongoDB using GridFS. T<span>o allow a user to remove the media from the application, in the following sections, we will define a backend API for media deletion from the database and implement a React component that makes use of this API when the user interacts with the frontend to perform this deletion.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The delete media API</h1>
                </header>
            
            <article>
                
<p><span>To delete media from the database, we will implement a delete media API in the backend, which will accept a DELETE request from a client at <kbd>/api/media/:mediaId</kbd>. We will add the <kbd>DELETE</kbd> route for this API as follows, which will allow an authorized user</span> to delete their uploaded media records.</p>
<p><kbd><span>mern-mediastream/server/routes/media.routes.js</span></kbd>:</p>
<pre>router.route('/api/media/:mediaId')<br/>        .delete(authCtrl.requireSignin, <br/>                    mediaCtrl.isPoster, <br/>                        mediaCtrl.remove)</pre>
<p>When the server receives a DELETE request at <kbd>'/api/media/:mediaId'</kbd>, it will make sure the signed-in user is the original poster of the media by invoking the <kbd>isPoster</kbd> controller method. Then, the <kbd>remove</kbd> controller method will <span>completely </span>delete the specified media from the database. <span>The </span><kbd>remove</kbd><span> method is defined as follows.</span></p>
<p><kbd><span>mern-mediastream/server/controllers/media.controller.js</span></kbd>:</p>
<pre>const remove = async (req, res) =&gt; {<br/>  try {<br/>    let media = req.media<br/>    let deletedMedia = await media.remove()<br/>    gridfs.delete(req.file._id)<br/>    res.json(deletedMedia)<br/>  } catch(err) {<br/>    return res.status(400).json({<br/>      error: errorHandler.getErrorMessage(err)<br/>    })<br/>  }<br/>}</pre>
<p>Besides deleting the media record from the Media collection, we are also using <kbd>gridfs</kbd> to remove the associated file details and chunks stored in the database.</p>
<p><span>To access this backend API in the frontend, you will also need a fetch method with this route, similar to other API implementations. The fetch method will need to take the media ID and the current user's auth credentials in order to call the delete media API with these values.</span></p>
<p><span>The fetch method will be used when the user performs the delete operation by clicking a button in the frontend interface. In the next section, we will discuss a React component called</span><span> </span><kbd><span>DeleteMedia</span></kbd><span>, where by this delete media action will be performed by the user.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The DeleteMedia component</h1>
                </header>
            
            <article>
                
<div class="page">
<div class="layoutArea">
<div class="column">
<p><span>The <kbd>DeleteMedia</kbd> component i</span>s added t<span>o the <kbd>Media</kbd> component and is only visible to the signed-in user who added this specific media. This component is basically a button that, when clicked, opens a <kbd>Dialog</kbd> component asking the user to confirm the delete action, as shown in the following screenshot:</span></p>
</div>
</div>
</div>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-895 image-border" src="assets/71d31ba9-fc95-4b16-a1aa-116fdc04ac03.png" style="width:24.75em;height:9.25em;"/></div>
<div class="page">
<div class="layoutArea">
<div class="column">
<p><span>This <kbd>DeleteMedia</kbd> component takes the media ID and title as props when it is added in the <kbd>Media</kbd> component. Its implementation will be similar to the <kbd>DeleteUser</kbd> component we discussed in <a href="6f2ca10a-8079-4e3a-9d42-a3db8e85b9d9.xhtml" target="_blank">Chapter 4</a>, <em>Adding a React Frontend to Complete MERN</em>. Once the <kbd>DeleteMedia</kbd> component has been added, the user will be able to remove the posted media completely from the application by confirming their action.</span></p>
</div>
</div>
</div>
<p>The MERN Mediastream application that we've developed in this chapter is a complete media streaming application with the capability to upload video files to the database, stream stored videos back to the viewers, support CRUD operations such as media create, update, read, and delete, and support options for listing media by uploader or popularity.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we developed a media streaming application by extending the MERN skeleton application and leveraging MongoDB GridFS.</p>
<p>Besides adding basic add, update, delete, and listing features for media uploads, we looked into how MERN-based applications can allow users to upload video files, store these files into MongoDB GridFS as chunks, and stream the video back to the viewer partially or fully as required. We also covered using <kbd>ReactPlayer</kbd> with default browser controls to stream the video file. You can apply these streaming capabilities to any full-stack application that may require storing and retrieving large files from the database.</p>
<p>In the next chapter, we will learn how to customize <kbd>ReactPlayer</kbd> with our own controls and functionality so that users have more options, such as playing the next video in a list. In addition, we will discuss how to improve the SEO of the media details by implementing server-side rendering with data for the media view.</p>


            </article>

            
        </section>
    </body></html>