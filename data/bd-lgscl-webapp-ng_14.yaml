- en: Design Authentication and Authorization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计身份验证和授权
- en: Designing a high-quality authentication and authorization system without frustrating
    the end user is a difficult problem to solve. Authentication is the act of verifying
    the identity of a user, and authorization specifies the privileges a user has
    to access a resource. Both processes, auth for short, must seamlessly work in
    tandem to address the needs of users with varying roles, needs, and job functions.
    In today's web, users have a high baseline level of expectations from any auth
    system they encounter through the browser, so this is a really important part
    of your application to get absolutely right the first time.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 设计一个高质量的身份验证和授权系统，而不会让最终用户感到沮丧，这是一个难题。 身份验证是验证用户身份的行为，授权指定用户访问资源的特权。 这两个过程，简称为auth，必须无缝地配合工作，以满足具有不同角色、需求和职能的用户的需求。
    在今天的网络中，用户对通过浏览器遇到的任何身份验证系统都有很高的期望，因此这是应用程序中绝对要第一次完全正确的一个非常重要的部分。
- en: The user should always be aware of what they can and can't do in your app. If
    there are errors, failures, or mistakes, the user should be clearly informed as
    to why such an error occured. As your application grows, it is easy to miss all
    the ways an error condition could be triggered. Your implementation should be
    easy to extend or maintain, otherwise this basic backbone of your application
    will require a lot of maintenance. In this chapter, we will walk-through the various
    challenges of creating a great auth UX and implement a solid baseline experience.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 用户应始终知道他们在应用程序中可以做什么和不能做什么。 如果存在错误、失败或错误，用户应清楚地了解为什么发生此类错误。 随着应用程序的增长，很容易忽略错误条件可能被触发的所有方式。
    您的实现应易于扩展或维护，否则您的应用程序的这个基本骨架将需要大量维护。 在本章中，我们将解决创建出色的身份验证用户体验的各种挑战，并实现一个坚实的基线体验。
- en: We will be continuing the router-first approach to designing SPAs by implementing
    the authentication and authorization experience of LemonMart. In [Chapter 12](b49e4716-d083-4c8c-a083-bcf6cf182a6f.xhtml),
    *Create a Router-First Line-of-Business App*, we defined user roles, finished
    our build-out of all major routing and completed a rough walking-skeleton navigation
    experience of LemonMart, so we are well prepared to implement role-based routing
    and the nuances of pulling such an implementation.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续采用路由优先的方式来设计单页应用程序，通过实现 LemonMart 的身份验证和授权体验。 在[第 12 章](b49e4716-d083-4c8c-a083-bcf6cf182a6f.xhtml)中，*创建一个基于路由的企业应用程序*，我们定义了用户角色，完成了所有主要路由的构建，并完成了对
    LemonMart 的初步 walk-through 导航体验，因此我们已经准备好实现基于角色的路由和拉取该实现的细微差别。
- en: In [Chapter 13](215237a5-318b-4de2-82a8-4e40e438b228.xhtml), *Continuous Integration
    and API Design*, we discussed the idea of designing around major data components,
    so you are already familiar with how a user entity looks like, which will come
    in handy in implementing a token-based login experience, including caching role
    information within the entity.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 13 章](215237a5-318b-4de2-82a8-4e40e438b228.xhtml)中，*持续集成和 API 设计*，我们讨论了围绕主要数据组件设计的想法，因此，您已经熟悉用户实体的外观，这将在实现基于令牌的登录体验中非常有用，包括在实体内缓存角色信息。
- en: Before diving into auth, we will discuss the importance of completing high-level
    mock -ups for your application before starting to implement various conditional
    navigation elements, which may change significantly during the design phase.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究身份验证之前，我们将讨论在开始实现各种有条件导航元素之前，完成应用程序的高级模拟 - ups 的重要性，这可能在设计阶段发生重大变化。
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下主题：
- en: Importance of high-level UX design
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级用户体验设计的重要性
- en: Token-based authentication
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于令牌的身份验证
- en: Conditional navigation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有条件的导航
- en: Side Navigation bar
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 侧边导航栏
- en: Reusable UI Service for alerts
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于警报的可重用 UI 服务
- en: Caching data
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存数据
- en: JSON Web Tokens
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON Web 令牌
- en: Angular HTTP interceptors
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular HTTP 拦截器
- en: Router guards
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由守卫
- en: Wrapping up mock-ups
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成模拟 - ups
- en: Mock-ups are important in determining what kind of components and user controls
    we will need throughout the app. Any user control or component that will be used
    across components will need to defined at the root level and others scoped with
    their own modules.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 假象对确定应用程序中将需要的组件和用户控件的类型至关重要。 将在根级别定义用于跨组件使用的任何用户控件或组件，并通过各自的模块进行作用域定义。
- en: 'We have already identified the submodules and designed landing pages for them
    to complete the walking skeleton. Now that we have defined the major data components,
    we can complete mock-ups for the rest of the app. When designing screens at a
    high-level, keep several things in mind:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定了子模块并为它们设计了首次亮相页面，完成行走骨架。 现在我们已经定义了主要的数据组件，可以为应用程序的其余部分完成模型。 在高级别设计屏幕时，要牢记几点：
- en: Can a user complete common tasks required for their role with as little navigation
    as possible?
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户是否可以通过尽可能少的导航完成其角色所需的常见任务？
- en: Can users readily access all information and functionality of the app through
    visible elements on the screen?
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户是否可以通过屏幕上可见的元素轻松访问应用程序的所有信息和功能？
- en: Can a user search for the data they need easily?
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户是否可以轻松搜索他们需要的数据？
- en: Once a user finds a record of interest, can they drill-down into detail records
    or view related records with ease?
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦用户找到感兴趣的记录，他们能够轻松地深入了解详细记录或查看相关记录吗？
- en: Is that pop-up alert really necessary? You know users won't read it, right?
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弹出警告真的有必要吗？您知道用户不会阅读它，对吧？
- en: Keep in mind that there's no one right way to design any user experience, which
    is why when designing screens, always keep modularity and reusability in mind.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，设计任何用户体验都没有唯一正确的方式，这就是为什么在设计屏幕时，始终要考虑模块化和可重用性。
- en: 'As you generate various design artifacts, such as mock-ups or design decisions,
    take care to post them on a wiki reachable by all team members:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当生成各种设计文档，如模型或设计决策时，请注意将其发布在所有团队成员可访问的维基上：
- en: On GitHub, switch over to the Wiki tab
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 GitHub 上，切换到 Wiki 选项卡
- en: 'You may check out my sample wiki at [Github.com/duluca/lemon-mart/wiki](https://github.com/duluca/lemon-mart/wiki),
    as shown:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以在[Github.com/duluca/lemon-mart/wiki](https://github.com/duluca/lemon-mart/wiki)查看我的示例维基页面，如下所示：
- en: '![](img/a128f277-a197-4e69-bd80-58cd58280273.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a128f277-a197-4e69-bd80-58cd58280273.png)'
- en: GitHub.com LemonMart Wiki
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub.com LemonMart 维基
- en: When creating a wiki page, ensure that you cross-link between any other documentation
    available, such as Readme
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建维基页面时，请确保在任何其他可用文档之间进行交叉链接，如Readme
- en: Note that GitHub shows subpages on the wiki under Pages
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，GitHub在页面下显示维基子页面。
- en: However, an additional summary is helpful, such as the Design Artifacts section,
    since some people may miss the navigational element on the right
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，额外的摘要很有用，比如设计文档部分，因为有些人可能会错过右侧的导航元素。
- en: As you complete mock-ups, post them on wiki
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在完成模型后，将其发布在维基上。
- en: 'You can see a summary view of the wiki here:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处查看维基的摘要视图：
- en: '![](img/6a78acfc-a5a0-45df-852e-7adb8497c599.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6a78acfc-a5a0-45df-852e-7adb8497c599.png)'
- en: Summary view of Lemon Mart mock-ups
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Lemon Mart 模型摘要视图
- en: Optionally, place the mock-ups in the walking skeleton app so that testers can
    better envision the functionality that is yet to be developed
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，将模型放在行走骨架应用程序中，以便测试人员可以更好地设想尚未开发的功能。
- en: With the mock-ups completed, we can now continue the implementation of LemonMart
    with the Authentication and Authorization workflow.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 随着模型完成，我们现在可以继续 LemonMart 的实施，包括认证和授权工作流程。
- en: Design authentication and authorization workflow
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计认证和授权工作流程。
- en: A well-designed authentication workflow is stateless so that there's no concept
    of an expiring session. Users are free to interact with your stateless REST APIs
    from as many devices and tabs as they wish, simultaneously or overtime. **JSON
    Web Token** (**JWT**) implements distributed claims-based authentication that
    can be digitally signed or integration protected and/or encrypted using a **Message
    Authentication Code** (**MAC**). This means once a user's identity is authenticated
    through, let's say a password-challenge, they receive an encoded claim ticket
    or a token, which can then be used to make future requests to the system without
    having to reauthenticate the identity of a user. The server can independently
    verify the validity of this claim and process the requests without requiring any
    prior knowledge of having interacted with this user. Thus, we don't have to store
    session information regarding a user, making our solution stateless and easy to
    scale. Each token will expire after a predefined period and due to their distributed
    nature, they can't be remotely or individually revoked; however, we can bolster
    real-time security by interjecting custom account and user role status checks
    to ensure that the authenticated user is authorized to access server-side resources.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 良好设计的身份验证工作流程是无状态的，因此没有会话过期的概念。用户可以自由地从任意设备和选项卡上同时或随时与您的无状态 REST API 进行交互。**JSON
    Web Token** (**JWT**) 实现了分布式基于声明的认证，可以通过数字签名或集成保护和/或使用 **消息认证码** (**MAC**) 进行加密。这意味着一旦用户的身份通过密码挑战等方式进行了认证，他们就会收到一个编码的声明票据或令牌，然后可以使用该令牌对系统进行未来请求，而无需重新验证用户的身份。服务器可以独立验证这一声明的有效性，并处理请求，无需事先知道其是否与该用户进行过交互。因此，我们不必存储关于用户的会话信息，这使得我们的解决方案是无状态且易于扩展的。每个令牌将在预定义的时间后过期，由于其分布式的特性，无法远程或单独吊销；但是，我们可以通过插入自定义账户和用户角色状态检查来增强实时安全性，以确保经过认证的用户有权访问服务器端资源。
- en: JSON Web Tokens implement IETF industry standard RFC7519, found at [https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: JSON Web Tokens 实现了 IETF 行业标准 RFC7519，在 [https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519)
    找到。
- en: A good authorization workflow enables conditional navigation based on a user's
    role so that users are automatically taken to the optimal landing screen; they
    are not shown routes or elements that are not suitable for their roles and if
    by mistake they try to access an authorized path, they're prevented from doing
    so. You must remember that any client-side role-based navigation is merely a convenience
    and is not meant for security. This means that every call made to the server should
    contain the necessary header information, with the secure token, so that the user
    can be reauthenticated by the server, their role independently verified and only
    then they are allowed to retrieve secured data. Client-side authentication can't
    be trusted, which is why password reset screens must be built with a server-side
    rendering technology so that both the user and the server can verify that the
    intended user is interacting with the system.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的授权工作流程能够基于用户的角色实现条件导航，以便用户自动转到最佳的着陆页面；他们不会显示适合其角色的路由或元素，如果他们错误地尝试访问未经授权的路径，系统将会阻止他们这样做。您必须记住，任何客户端角色导航仅仅只是一种便利，而不是为了安全。这意味着每次向服务器发出的调用都应该包含必要的头部信息，并且带有安全令牌，以便服务器可以对用户进行重新认证，独立验证他们的角色，然后才允许其检索受保护的数据。客户端认证是不可信的，这就是为什么密码重置屏幕必须使用服务器端呈现技术来构建，以便用户和服务器都能验证预期的用户正在与系统交互。
- en: 'In the following sections, we will design a fully featured auth workflow around
    the User data entity, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下部分中，我们将围绕用户数据实体设计一个完整功能的身份验证工作流程，如下：
- en: '![](img/3edd23f6-b740-4bcf-be64-946397307fa5.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3edd23f6-b740-4bcf-be64-946397307fa5.png)'
- en: User entity
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 用户实体
- en: Add auth service
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加身份验证服务
- en: 'We will start by creating an auth service with a real and a fake login provider:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个带有真实和虚假登录提供程序的身份验证服务：
- en: 'Add an authentication and authorization service:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加身份验证和授权服务：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Ensure that the service is provided in `app.module`:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保服务在 `app.module` 中提供：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Creating a separate folder for the service will organize various related components
    to authentication and authorization, such as the `enum` definition for Role. Additionally,
    we will be able to add an `authService` fake to the same folder, essential for
    writing unit tests.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为服务创建一个单独的文件夹将组织各种与身份验证和授权相关的组件，比如`enum`用于角色定义。此外，我们还可以在同一个文件夹中添加一个`authService`的假装，这对于编写单元测试至关重要。
- en: 'Define user roles as an `enum`:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将用户角色定义为一个`enum`：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Implement a basic authentication service
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现一个基本的认证服务
- en: 'Now, let''s build a local authentication service that will enable us to demonstrate
    a robust login form, caching, and conditional navigation concepts based on authentication
    status and a user''s role:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建一个本地认证服务，它将使我们能够展示一个强大的登录表单，缓存和基于认证状态和用户角色的条件导航概念：
- en: 'Start by installing a JWT decoding library, and for faking authentication,
    a JWT encoding library:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先安装一个JWT解码库，以及用于伪造认证的JWT编码库：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Define your imports for `auth.service.ts`:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`auth.service.ts`定义您的导入项：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Implement an `IAuthStatus` interface to store decoded user information, a helper
    interface, and the secure by-default `defaultAuthStatus`:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个`IAuthStatus`接口来存储解码后的用户信息，一个辅助接口以及默认的安全`defaultAuthStatus`。
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`IAuthUser` is an interface that represents the shape of a typical JWT that
    you may receive from your authentication service. It contains minimal information
    about the user and its role, so it can be attached to the `header` of server calls
    and optionally cached in `localStorage` to remember the user''s login state. In
    the preceding implementation, we''re assuming the default role of a `Manager`.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`IAuthUser`是一个接口，代表了你可能从认证服务接收到的典型JWT的形状。它包含有关用户及其角色的最少信息，因此它可以附加到服务调用的`header`中，并且可以可选地缓存在`localStorage`中以记住用户的登录状态。在前面的实现中，我们假设了一个`Manager`的默认角色。'
- en: 'Define the `AuthService` class with a `BehaviorSubject` to anchor the current
    `authStatus` of the user and configure an `authProvider` that can process an `email`
    and a `password` and return an `IServerAuthResponse` in the constructor:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`AuthService`类，其中有一个`BehaviorSubject`来锚定用户当前的`authStatus`，并在构造函数中配置一个可以处理`email`和`password`并返回`IServerAuthResponse`的`authProvider`。
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note that `fakeAuthProvider` is configured to be the `authProvider` for this
    service. A real auth provider may look like the following code, where users''
    email and password are sent to a POST endpoint, which verifies their information,
    creating and returning a JWT for our app to consume:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`fakeAuthProvider`被配置为该服务的`authProvider`。一个真实的auth provider可能会像以下代码一样，其中用户的电子邮件和密码发送到一个POST端点，该端点验证他们的信息，创建并返回一个JWT供我们的应用程序消费：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It is pretty straightforward, since the hard work is done on the server side.
    This call can also be made to a third party.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当简单，因为大部分工作是在服务器端完成的。这个调用也可以被发送给第三方。
- en: Note that the API version, `v1`, in the URL path is defined at the service and
    not as part of the `baseUrl`. This is because each API can change versions independently
    from each other. Login may remain `v1` for a long time, while other APIs may be
    upgraded to `v2`, `v3`, and such.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意URL路径中的API版本`v1`是在服务中定义的，而不是作为`baseUrl`的一部分。这是因为每个API可以独立地更改版本。登录可能长时间保持`v1`，而其他API可能会升级为`v2`、`v3`等。
- en: 'Implement a `fakeAuthProvider` that simulates the authentication process, including
    creating a fake JWT on the fly:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个`fakeAuthProvider`来模拟认证过程，包括动态创建假的JWT。
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `fakeAuthProvider` implements what would otherwise be a server-side method
    right in the service, so you can conveniently experiment the code while fine-tuning
    your auth workflow. It creates and signs a JWT, with the temporary `fake-jwt-sign` library
    so that we can also demonstrate how to handle a properly-formed JWT.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`fakeAuthProvider`在服务中实现了本来应该是服务器端方法的内容，因此您可以方便地在微调您的认证流程时进行代码实验。它使用临时的`fake-jwt-sign`库创建和签署一个JWT，这样我们也可以演示如何处理一个符合规范的JWT。'
- en: Do not ship your Angular app with the `fake-jwt-sign` dependency, since it is
    meant to be server-side code.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在您的Angular应用程序中使用`fake-jwt-sign`依赖项，因为它的目的是用于服务器端代码。
- en: 'Before we move on, implement a `transformError` function to handle mixed `HttpErrorResponse`
    and string errors in an observable stream under `common/common.ts`:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续之前，实现一个`transformError`函数，用于处理在`common/common.ts`中的可观察流中混合的`HttpErrorResponse`和字符串错误：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Implement the `login` function that will be called from `LoginComponent`, shown
    in the next section
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`login`函数，它将从下一节中显示的`LoginComponent`调用。
- en: Add ``import { transformError } from '../common/common'``
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 ``import { transformError } from '../common/common'``
- en: 'Also implement a corresponding `logout` function, which may be called by the
    Logout button in the top toolbar, a failed login attempt, or if an unauthorized
    access attempt is detected by a router auth guard as the user is navigating the
    app, which is a topic covered later in the chapter:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要实现一个对应的`注销`功能，可以由顶部工具栏中的注销按钮调用，登录尝试失败，或者如果路由授权守卫在用户浏览应用程序时检测到未经授权的访问尝试，这是本章后续讨论的一个主题：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `login` method encapsulates the correct order of operations by calling the `logout` method,
    the `authProvider` with the `email` and `password` information, and throwing errors
    when necessary.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`login`方法通过调用`logout`方法，`authProvider`以及在必要时抛出错误来封装了正确的操作顺序。'
- en: The `login` method adheres to the Open/Closed principle, from SOLID design,
    by being open to extension by our ability to externally supply different auth
    providers to it, but it remains closed to modification, since the variance in
    functionality is encapsulated with the auth provider.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`login`方法遵循了SOLID设计中的开闭原则，它对外部提供不同的身份验证提供者开放以实现扩展，但对修改是封闭的，因为功能的差异被身份验证提供者封装起来。'
- en: In the next section, we will implement the `LoginComponent` so that users can
    enter their username and password information and attempt a login.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将实现`LoginComponent`，以便用户可以输入他们的用户名和密码信息，并尝试登录。
- en: Implementing the login component
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现登录组件
- en: The `login` component leverages the `authService` that we just created and implements
    validation errors using reactive forms. The login component should be designed
    in a way to be rendered independently of any other component, because during a
    routing event, if we discover that the user is not properly authenticated or authorized,
    we will navigate them to this component. We can capture this origination URL as
    a `redirectUrl` so that once a user logs in successfully, we can navigate them
    back to it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`login`组件利用我们刚刚创建的`authService`，并使用响应式表单实现验证错误。登录组件应该被设计成可以独立渲染，因为在路由事件中，如果我们发现用户没有得到适当的身份验证或授权，我们将把他们导航到这个组件。我们可以将此来源
    URL 捕获为`redirectUrl`，以便用户成功登录后，我们可以将他们导航回去。'
- en: 'Let''s start with implementing the routes to the `login` component:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从实现`login`组件的路由开始：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now implement the component itself:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在实现组件本身：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As the result of a successful login attempt, we leverage the router to navigate
    an authenticated user to their profile. In the case of an error sent from the
    server via the service, we assign that error to `loginError`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 作为成功登录尝试的结果，我们利用路由器将经过身份验证的用户导航到他们的个人资料。在通过服务从服务器发送错误的情况下，我们将将该错误分配给`loginError`。
- en: 'Here''s an implementation for a login form to capture and validate a user''s
    `email` and `password`, and if there are any server errors, display them:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个登录表单的实现，用于捕获和验证用户的`电子邮件`和`密码`，如果有任何服务器错误，就显示它们：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The Login button is disabled until email and password meets client site validation
    rules. Additionally, `<mat-form-field>` will only display one `mat-error` at a
    time, unless you create more space for more errors, so be sure place your error
    conditions in the correct order.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在电子邮件和密码符合客户端网站验证规则之前，登录按钮将被禁用。另外，`<mat-form-field>`一次只会显示一个`mat-error`，除非你为更多的错误创建了更多的空间，所以请确保将您的错误条件放在正确的顺序中。
- en: Once you're done implementing the `login` component, you can now update the
    home screen to conditionally display or hide the new component we created.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 完成`login`组件的实现后，现在可以更新主屏幕以有条件地显示或隐藏我们创建的新组件。
- en: 'Update `home.component` to display login when a user opens up the app:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`home.component`以在用户打开应用程序时显示登录：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Don't forget to import the requisite dependent modules for the code above in
    to your Angular application. It is intentionally left as an exercise for the reader
    to locate and import the missing modules.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记将上面的代码所需的依赖模块导入到您的 Angular 应用程序中。故意留给读者作为练习，以找到并导入丢失的模块。
- en: 'Your app should look similar to this screenshot:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序应该看起来类似于这个屏幕截图：
- en: '![](img/0777c16b-6f65-4c68-86e8-514cb5535817.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0777c16b-6f65-4c68-86e8-514cb5535817.png)'
- en: LemonMart with login
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: LemonMart 带有登录
- en: There's still some work to be done, in terms of implementing and showing/hiding
    the sidenav menu, profile and logout icons, given the user's authentication status.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 就实现和显示/隐藏侧边栏菜单、个人资料和注销图标而言，还有一些工作要做，考虑到用户的身份验证状态。
- en: Conditional navigation
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有条件的导航
- en: Conditional navigation is necessary in creating a frustration-free user experience.
    By selectively showing the elements that the user has access to and hiding the
    ones they don't, we allow the user to confidently navigate through the app.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 有条件的导航对于创建一个没有挫败感的用户体验是必要的。通过选择性地显示用户可以访问的元素并隐藏他们无法访问的元素，我们可以让用户自信地在应用程序中导航。
- en: 'Let''s start by hiding the login component after a user logs in to the app:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在用户登录应用程序后隐藏登录组件：
- en: On the `home` component, import the `authService` in `home.component`
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`home`组件中，在`home.component`中引入`authService`
- en: 'Set the `authStatus` to a local variable named `displayLogin`:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`authStatus`设置为名为`displayLogin`的本地变量：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'A property getter for `displayLogin` here is necessary, otherwise you may receive
    a Error: ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after
    it was checked message. This error is a side effect of how the Angular component
    life-cycle and change detection works. This behavior may very well change in future
    Angular versions.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '属性获取器`displayLogin`在这里是必要的，否则您可能会收到一个Error: ExpressionChangedAfterItHasBeenCheckedError:
    Expression has changed after it was checked消息。这个错误是Angular组件生命周期和变更检测工作方式的副作用。这种行为在未来的Angular版本中可能会改变。'
- en: 'On the `app` component, subscribe to the authentication status and store the
    current value in a local variable named `displayAccountIcons`:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app`组件中，订阅认证状态并将当前值存储在名为`displayAccountIcons`的本地变量中：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Use `*ngIf` to hide all buttons meant for logged in users:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`*ngIf`隐藏所有针对已登录用户的按钮：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, when a user is logged out, your toolbar should look all clean with no
    buttons, as shown:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当用户注销时，您的工具栏应该看起来整洁，没有按钮，如下所示：
- en: '![](img/2734fd18-3722-4964-9ee8-1acbaef74920.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2734fd18-3722-4964-9ee8-1acbaef74920.png)'
- en: LemonMart toolbar after log in
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: LemonMart工具栏登录后
- en: Common validations
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见验证
- en: 'Before we move on, we need to implement validations for `loginForm`. As we
    implement more forms in [Chapter 15](3da8e826-b070-415b-b3ce-d535358db5de.xhtml),
    *Angular App Design and Recipes*, you will realize that it gets tedious, fast,
    to repeatedly type out form validations in either template or reactive forms.
    Part of the allure of reactive forms is that it is driven by code, so we can easily
    extract out the validations to a shared class, unit test, and reuse them:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们需要为`loginForm`实现验证。随着我们在[第15章](3da8e826-b070-415b-b3ce-d535358db5de.xhtml)中实现更多的表单，*Angular应用设计和示例*，你会意识到反复在模板或响应式表单中输入表单验证会变得繁琐快速。响应式表单的吸引之一是它由代码驱动，因此我们可以轻松地将验证提取到一个共享类中，进行单元测试，并重复使用它们：
- en: Create a `validations.ts` file under the `common` folder
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`common`文件夹下创建一个`validations.ts`文件
- en: 'Implement email and password validations:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现电子邮件和密码验证：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Depending on your password validation needs, you can use a `RegEx` pattern with
    the `Validations.pattern()` function to enforce password complexity rules or leverage
    the OWASP npm package, `owasp-password-strength-test`, to enable pass-phrases
    as well as set more flexible password requirements.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的密码验证需求，您可以使用`Validations.pattern()`函数与`RegEx`模式来强制执行密码复杂性规则，或者利用OWASP npm包`owasp-password-strength-test`来启用密码短语，并设置更灵活的密码要求。
- en: 'Update the `login` component with the new validations:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用新的验证更新`login`组件：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: UI service
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UI服务
- en: As we start dealing with complicated workflows, such as the auth workflow, it
    is important to be able to programmatically display a toast notification for the
    user. In other cases, we may want to ask for a confirmation before executing a
    destructive action with a more intrusive pop-up notification.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始处理复杂的工作流程，例如认证工作流程时，有必要能够通过编程方式为用户显示一个弹出通知。在其他情况下，我们可能需要在执行破坏性操作之前询问确认，这时会需要一个更具侵入性的弹出式通知。
- en: 'No matter what component library you use, it gets tedious to recode the same
    boiler plate, just to display a quick notification. A UI service can neatly encapsulate
    a default implementation that can also be customized on a need basis:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用什么组件库，都会很烦琐地重新编写相同的样板代码，只为了显示一个快速通知。一个UI服务可以整洁地封装一个默认实现，也可以根据需要进行定制：
- en: Create a new `uiService` under `common`
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`common`下创建一个新的`uiService`
- en: 'Implement a `showToast` function:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个`showToast`函数：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For a showDialog function, we must implement a basic dialog component:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`showDialog`函数，我们必须实现一个基本的对话框组件：
- en: Add a new `simpleDialog` under the `common` folder provided in `app.module`
    with inline template and styling
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提供的`app.module`下的`common`文件夹中添加一个新的`simpleDialog`，包括内联模板和样式
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Note that `SimpleDialogComponent` should not have app selector like  `selector:
    ''app-simple-dialog''` since we only plan to use it with `UiService`. Remove this
    property from your component.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，`SimpleDialogComponent`不应该像`selector: ''app-simple-dialog''`一样带有应用程序选择器，因为我们计划只在`UiService`中使用它。从您的组件中删除此属性。'
- en: 'Then, implement a `showDialog` function to display the `SimpleDialogComponent`:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，实现一个`showDialog`函数来显示`SimpleDialogComponent`：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`ShowDialog` returns an `Observable<boolean>`, so you can implement a follow-on
    action, depending on what selection the user makes. Clicking on OK will return
    `true`, and Cancel will return `false`.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShowDialog`返回一个`Observable<boolean>`，因此您可以根据用户的选择实现后续动作。点击确定将返回`true`，点击取消将返回`false`。'
- en: In `SimpleDialogComponent`, using `@Inject`, we're able to use all variables
    sent by `showDialog` to customize the content of the dialog.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SimpleDialogComponent`中，使用`@Inject`，我们能够使用`showDialog`发送的所有变量来定制对话框的内容。
- en: Don't forget to update `app.module.ts` and `material.module.ts` with the various
    dependencies that are being introduced.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记更新`app.module.ts`和`material.module.ts`，以适应引入的各种依赖项。
- en: 'Update the `login` component to display a toast message after login:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`login`组件，在登录后显示一个提示消息：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'A toast message will appear after a user logs in, as shown:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 用户登录后，将显示一个提示消息，如图所示：
- en: '![](img/44e78459-77e7-49ec-9b24-6871bfcd4243.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/44e78459-77e7-49ec-9b24-6871bfcd4243.png)'
- en: Material Snack bar
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 材料吐司条
- en: The `snackBar` will either take the full width of the screen or a portion depending
    on the size of the browser.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`snackBar`将占据整个屏幕的宽度，或者根据浏览器的大小占据一部分。'
- en: Caching with cookie and localStorage
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用cookie和localStorage进行缓存
- en: We must be able to cache the authentication status of the logged in user. Otherwise,
    with every page refresh, the user will have go through the login routine. We need
    to update `AuthService` so that it persists the auth status.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须能够缓存已登录用户的认证状态。否则，每次刷新页面，用户都将不得不通过登录流程。我们需要更新`AuthService`以使其保持认证状态。
- en: 'There are three main ways to store data:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种主要的数据存储方式：
- en: '`cookie`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cookie`'
- en: '`localStorage`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localStorage`'
- en: '`sessionStorage`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sessionStorage`'
- en: Cookies should not be used to store secure data, because they can be sniffed
    or stolen by bad actors. In addition, cookies can store 4 KB of data and can be
    set to expire.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 不应将cookie用于存储安全数据，因为它们可能会被坏人嗅探或窃取。此外，cookie可以存储4 KB的数据并可以设置为过期。
- en: '`localStorage` and `sessionStorage` are similar to each other. They are protected
    and isolated browser-side stores that allow for storing larger amounts of data
    for your application. You can''t set an expiration date-time on either stores.
    `sessionStorage` values are removed, when the browser window is closed. The values
    survive page reloads and restores.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`localStorage`和`sessionStorage`相似。它们是受保护且隔离的浏览器端存储，允许为应用程序存储更大量的数据。你无法为这些存储设置过期日期时间。当浏览器窗口关闭时，`sessionStorage`的值会被删除。这些值会在页面重新加载和恢复时保留。'
- en: JSON Web Tokens are encrypted, and they include a timestamp for expiration,
    in essence, countering the weaknesses of `cookie` and `localStorage`. Either option
    should be secure to use with JWTs.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: JSON Web Tokens是加密的，并包含用于到期的时间戳，从本质上讲，对抗了`cookie`和`localStorage`的弱点。任一选项都应该可以安全地与JWT一起使用。
- en: 'Let''s start by implementing a caching service that can abstract away our method
    of caching authentication information that the `AuthService` can consume:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先实现一个缓存服务，它可以将我们的身份验证信息缓存的方式抽象化，以供`AuthService`使用：
- en: 'Start by creating an abstract `cacheService` that encapsulates the method of
    caching:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建一个封装缓存方法的抽象`cacheService`：
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This cache service base class can be used to give caching capabilities to any
    service. It is not the same as creating a centralized cache service that you inject
    into another service. By avoiding a centralized value store, we avoid inter-dependencies
    between various services.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此缓存服务基类可用于为任何服务提供缓存功能。这与创建一个注入到另一个服务中的集中式缓存服务不同。通过避免集中式值存储，我们避免了各种服务之间的相互依赖。
- en: 'Update `AuthService` to extend the `CacheService` and implement caching of
    the `authStatus`:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`AuthService`以扩展`CacheService`并实现对`authStatus`的缓存：
- en: '[PRE25]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The technique demonstrated here can be used to persist any kind of data and
    intentionally leverages RxJS events to update the cache. As you may note, we don't
    need to update the login function to call `setItem`, because it already calls
    `this.authStatus.next`, and we just tap in to the data stream. This helps with
    staying stateless and avoiding side effects, by decoupling functions from each
    other.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此处展示的技术可用于持久化任何类型的数据，并有意利用RxJS事件来更新缓存。正如你可能注意到的，我们不需要更新登录函数来调用`setItem`，因为它已经调用了`this.authStatus.next`，我们只是连接到数据流。这有助于保持无状态和避免副作用，通过将函数之间解耦。
- en: When initializing the `BehaviorSubject`, take care to handle the `undefined/null`
    case, when loading data from the cache and still provide a default implementation.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化`BehaviorSubject`时，务必处理`undefined/null`情况，当从缓存中加载数据并仍提供默认实现时。
- en: You can implement your own custom cache expiration scheme in `setItem` and `getItem`
    functions or leverage a service created by a third party.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`setItem`和`getItem`函数中实现自定义缓存过期方案，或者利用第三方创建的服务。
- en: If you are going after a high-security application, you may choose to only cache
    the JWT to ensure an additional layer security. In either case, the JWT should
    be cached separately, because the token must be sent to the server in the header
    with every request. It is important to understand how token-based authentication
    works well, to avoid revealing compromising secrets. In the next section, we will
    go over the JWT life cycle to improve your understanding.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您追求高安全性的应用程序，您可能选择仅缓存JWT以确保额外的安全层。在任何情况下，JWT应该被单独缓存，因为令牌必须在每个请求的头部与服务器一起发送。重要的是要了解令牌身份验证的工作原理，以避免泄露妥协的秘密。在下一节中，我们将详细讨论JWT生命周期以提高您的理解。
- en: JSON Web Token life cycle
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON Web Token生命周期
- en: 'JSON Web Tokens compliment a stateless REST API architecture with an encrypted
    token mechanism that allow for convenient, distributed, and high-performance authentication
    and authorization of requests sent by clients. There are three main components
    of a token-based authentication scheme:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: JSON Web Tokens搭配着无状态REST API架构，使用加密令牌机制，方便、分布式和高性能地对客户端发送的请求进行身份验证和授权。令牌身份验证方案有三个主要组成部分：
- en: Client-side, captures login information and hides disallowed actions for a good
    UX
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端捕获登录信息并隐藏不允许的操作以获得良好的用户体验
- en: Server-side, validates that every request is both authenticated and has the
    proper authorization
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器端验证每个请求都经过了身份验证和拥有适当授权
- en: Auth service, generates and validates encrypted tokens, independently verifies
    authentication and authorization status of user requests from a data store
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身份验证服务，生成和验证加密令牌，独立验证来自数据存储的用户请求的身份验证和授权状态
- en: A secure system presumes that data sent/received between the major components
    mentioned is encrypted in-transit. This means your REST API must be hosted with
    a properly configured SSL certificate, serving all API calls over HTTPS, so that
    user credentials are never exposed between the client and the server. Similarly,
    any database or third-party service call should happen over HTTPS. Furthermore,
    any data store storing passwords should utilize a secure one-way hashing algorithm
    with good salting practices. Any other sensitive user information should be encrypted
    at-rest with a secure two-way encryption algorithm. Following this layered approach
    to security is critical, because attackers will need to accomplish the unlikely
    feat of compromising all layers of security implemented at the same time to cause
    meaningful harm to your business.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 安全系统假设主要组件之间发送/接收的数据是在传输过程中加密的。这意味着您的REST API必须使用正确配置的SSL证书托管，并通过HTTPS提供所有API调用，以便用户凭据永远不会在客户端和服务器之间暴露。同样，任何数据库或第三方服务调用都应该通过HTTPS进行。此外，任何存储密码的数据存储应该使用安全的单向哈希算法和良好的盐化实践。任何其他敏感用户信息应该使用安全的双向加密算法在静止状态下进行加密。遵循这种分层安全性方法至关重要，因为攻击者需要同时破坏所有实施的安全层来对您的业务造成实质性伤害。
- en: 'The next sequence diagram highlights the life-cycle of JWT-based authentication:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个序列图突显了基于JWT的身份验证生命周期：
- en: '![](img/360df2dd-598c-403c-b9de-2037de5585cd.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/360df2dd-598c-403c-b9de-2037de5585cd.jpg)'
- en: Life-Cycle of JWT-based authentication
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 基于JWT的身份验证生命周期
- en: Initially, a user logs in by providing their username and password. Once validated,
    the user's authentication status and role is encrypted to a JWT with an expiration
    date and time and is sent back to the browser.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，用户通过提供用户名和密码登录。一旦验证通过，用户的认证状态和角色将被加密为具有到期日期和时间的JWT，并发送回浏览器。
- en: Your Angular (or any other SPA) app can cache this token in local or session
    storage securely so that the user isn't forced to login with every request or
    worse yet, we don't store user credentials in the browser. Let's update the authentication
    service so that it can cache the token.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你的Angular（或任何其他SPA）应用可以安全地将该令牌缓存到本地或会话存储中，这样用户就不需要在每个请求中强制登录，或者更糟糕的是，我们不会在浏览器中存储用户凭证。让我们更新认证服务，以便它能够缓存该令牌。
- en: 'Update the service to be able to set, get, decode, and clear the token, as
    shown:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新服务以能够设置、获取、解码和清除令牌，如下所示：
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Call `setToken` during login and `clearToken` during logout as highlight as
    follows:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在登录期间调用`setToken`，在登出期间调用`clearToken`，如下所示：
- en: '[PRE27]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Every subsequent request will contain the JWT in the request header. You should
    secure every API to check for and validate the token received. For example, if
    a user wanted to access their profile, the `AuthService` would validate the token
    to check whether the user authenticated, but a further database call is required
    to check whether the user is also authorized to view the data. This ensures an
    independent confirmation of the users' access to the system and prevents any abuse
    of an unexpired token.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 每个后续的请求都将在请求头中包含JWT。您应该对每个API进行安全保护，以检查并验证接收到的令牌。例如，如果用户想要访问他们的个人资料，`AuthService`将验证令牌，以检查用户是否经过认证，但还需要进一步的数据库调用来检查用户是否有权查看数据。这样可以确保对用户的系统访问进行独立确认，并防止未过期令牌的滥用。
- en: If an authenticated user makes a call to an API, where they don't have the proper
    authorization, say if a clerk wants to get access to a list of all the users,
    then the `AuthService` will return a falsy status and the client will receive
    a 403 Forbidden response, which will be displayed as an error message to the user.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果经过认证的用户调用API，但他们没有适当的授权，例如，如果一个职员要获取所有用户的列表，那么`AuthService`将返回一个虚假状态，并且客户端将收到403
    Forbidden的响应，这将显示为用户的错误消息。
- en: A user can make a request with an expired token; when this happens, a 401 Unauthorized
    response is sent to the client. As a good UX practice, we should automatically
    prompt the user to login again and let them resume their workflow without any
    data loss.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以使用过期的令牌发出请求；当此情况发生时，将向客户端发送401未授权的响应。作为良好的用户体验实践，我们应该自动提示用户重新登录，并允许他们在没有任何数据丢失的情况下恢复他们的工作流程。
- en: In summary, real security is achieved by a robust server-side implementation
    and any client-side implementation is largely there to enable a good UX around
    good security practices.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，真正的安全性是通过健壮的服务器端实现实现的，任何客户端实现主要是为了实现良好的用户体验和良好的安全实践。
- en: HTTP interceptor
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP拦截器
- en: 'Implement an HTTP interceptor to inject the JWT into the header of every request
    sent to the user and also gracefully handle authentication failures by asking
    the user to log in:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个HTTP拦截器，将JWT注入到发送给用户的每个请求的头部，并且通过要求用户登录来优雅地处理认证失败：
- en: 'Create `authHttpInterceptor` under `auth`:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`auth`下创建`authHttpInterceptor`：
- en: '[PRE28]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note that `AuthService` is leveraged to retrieve the token, and the `redirectUrl`
    is being set for the login component after a 401 error.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`AuthService`被利用来检索令牌，而且在401错误之后，为登录组件设置`redirectUrl`。
- en: 'Update the `app` module to provide the interceptor:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`app`模块以提供拦截器：
- en: '[PRE29]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can observe the interceptor in action, while the app is fetching the `lemon.svg`
    file, in the Chrome Dev Tools | Network tab, here:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Chrome Dev Tools | Network选项卡中观察拦截器的实际操作，当应用程序获取`lemon.svg`文件时。
- en: '![](img/c4d4801c-60db-4e1e-be2c-cdad2bd26183.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c4d4801c-60db-4e1e-be2c-cdad2bd26183.png)'
- en: Request header for lemon.svg
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 请求lemon.svg的请求头
- en: Side navigation
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 侧边导航
- en: 'Enable mobile-first workflows and provide an easy navigation mechanism to quickly
    jump to desired functionality. Using the authentication service, given a user''s
    current role, only display the links for features they can access. We will be
    implementing the side navigation mock-up, as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 启用以移动设备为优先的工作流程，并提供轻松的导航机制，以便快速跳转到所需的功能。使用认证服务，根据用户当前的角色，只显示他们可以访问的功能链接。我们将实现侧边导航的模拟如下：
- en: '![](img/c72d8326-ae43-469d-876a-fcc533d94668.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c72d8326-ae43-469d-876a-fcc533d94668.png)'
- en: Side navigation mock-up
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 侧边导航的模拟
- en: 'Let''s implement the code for the side nav as a separate component, so that
    it is easier to maintain:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将侧向导航菜单的代码实现为一个单独的组件，以便更容易维护：
- en: Create and declare a `NavigationMenuComponent` in `app.module`
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app.module`中创建和声明一个`NavigationMenuComponent`
- en: '[PRE30]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The side navigation isn't technically required until after a user is logged
    in. However, in order to be able to launch the side navigation menu from the toolbar,
    we need to be able to trigger it from `app.component`. Since this component will
    be simple, we will eagerly load it. To do this lazily, Angular does have a Dynamic
    Component Loader pattern, which has a high implementation overhead that will only
    make sense if multi-hundred kilobyte savings will be made.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 直到用户登录后才需要侧向导航。但是，为了能够从工具栏启动侧向导航菜单，我们需要能够从`app.component`触发它。由于此组件很简单，我们将会急切加载它。如果要惰性加载它，Angular确实有一个动态组件加载器模式，但这具有高的实现开销，只有在可以节省数百千字节时才有意义。
- en: '`SideNav` will be triggered from the toolbar, and it comes with a `<mat-sidenav-container>` parent
    container that hosts the `SideNav` itself and the content of the app. So we will
    need to render all app content by placing the `<router-outlet>` inside `<mat-sidenav-content>`.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`SideNav`将从工具栏触发，并且它带有一个`<mat-sidenav-container>`父容器，用于承载`SideNav`本身和应用程序的内容。因此，我们需要通过将`<router-outlet>`放置在`<mat-sidenav-content>`中来渲染所有应用程序内容。'
- en: Import `MatSidenavModule` and `MatListModule` to material.module
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在material.module中导入`MatSidenavModule`和`MatListModule`
- en: '[PRE31]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Define some styles that will ensure that the web app will expand to fill the
    entire page and remain properly scrollable on desktop and mobile scenarios:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一些样式，确保Web应用程序在桌面和移动场景上可以填充整个页面，并保持正确的滚动：
- en: '[PRE32]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Import an `ObservableMedia` service in `AppComponent`:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AppComponent`中导入`ObservableMedia`服务：
- en: '[PRE33]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Update the template with a responsive `SideNav` that will slide over the content
    in mobile or push the content aside in desktop scenarios:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用响应式`SideNav`更新模板，将在移动设备上覆盖内容或在桌面场景中将内容推开：
- en: '[PRE34]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The preceding template leverages Angular Flex Layout media observable for a
    responsive implementation that was injected earlier.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的模板利用了之前注入的Angular Flex布局媒体可观察对象来实现响应式。
- en: Since the links that will be shown inside the `SiveNav` will be of variable
    length and subject various role-based business rules, it is a good practice to
    implement it in a separate component.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`SiveNav`内显示的链接长度可变并且受各种基于角色的业务规则约束，最好将其实现为一个单独的组件。
- en: Implement a property getter for `displayAccountIcons` and a `setTimeout` so
    that you can avoid errors like `ExpressionChangedAfterItHasBeenCheckedError`
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`displayAccountIcons`实现一个属性获取器，并使用`setTimeout`来避免诸如`ExpressionChangedAfterItHasBeenCheckedError`之类的错误。
- en: '[PRE35]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Implement navigational links in `NavigationMenuComponent`:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`NavigationMenuComponent`中实现导航链接：
- en: '[PRE37]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`<mat-nav-list>` is functionally equivalent to `<mat-list>`, so you can use
    the documentation for that component for layout purposes. Observe the subheaders
    for Manager, Inventory, and Clerk here:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`<mat-nav-list>`在布局目的上与`<mat-list>`功能上等效，所以您可以使用该组件的文档进行布局目的。在这里观察到的子标题为Manager,
    Inventory和Clerk：'
- en: '![](img/f096272b-e0ed-42f3-a79f-ec26620e9798.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f096272b-e0ed-42f3-a79f-ec26620e9798.png)'
- en: Manager dashboard showing receipt lookup on desktop
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在桌面上显示收据查询的管理仪表板
- en: '`routerLinkActive="active-link"` highlights the selected Receipts route, as
    shown in the preceding screenshot.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`routerLinkActive="active-link"`突出显示所选的Receipts路由，如前面的截图所示。'
- en: 'Additionally, you can see the difference in appearance and behavior on mobile
    devices as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以在移动设备上看到外观和行为的差异如下：
- en: '![](img/bd6e508b-2e56-4e89-921e-610dfc3b4ae0.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd6e508b-2e56-4e89-921e-610dfc3b4ae0.png)'
- en: Manager dashboard showing receipt lookup on mobile
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动端显示收据查询的管理仪表板
- en: Log out
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登出
- en: 'Now that we''re caching the login status, we need to implement a log out experience:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们缓存了登录状态，需要实现一个退出体验：
- en: 'In `AuthService`, implement a `logout` function:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AuthService`中实现`logout`函数：
- en: '[PRE38]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Implement the `logout` component:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`logout`组件：
- en: '[PRE39]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As you note, after a log out, user is navigated back to the home page.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所注意到的，登出后，用户会被导航回主页。
- en: Role-based routing after login
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登录后基于角色的路由
- en: This is the most elemental and important part of your application. With lazy
    loading, we have ensured only the bare minimum amount of assets will be loaded
    to enable a user to login.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您的应用程序最基本和最重要的部分。通过懒加载，我们已经确保只会加载最少量的资产以使用户能够登录。
- en: Once a user logs in, they should be routed to the appropriate landing screen
    as per their user role, so they're not guessing how they need to use the app.
    For example, a cashier needs to only access the POS to check out customers, so
    they can automatically be routed to that screen.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 用户登录后，应根据其用户角色路由到适当的登录屏幕，以便他们不需要猜测如何使用应用。例如，收银员只需访问 POS 以为顾客结账，因此他们可以自动路由到该屏幕。
- en: 'You find the mock up of the POS screen as illustrated:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以找到 POS 屏幕的模拟图示如下：
- en: '![](img/69c5d5f6-adf5-4a80-bf77-e412ca3d9a6f.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69c5d5f6-adf5-4a80-bf77-e412ca3d9a6f.png)'
- en: Point-of-Sale screen mock-up
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 销售点屏幕模拟图
- en: 'Let''s ensure that users get routed to the appropriate page after logging in
    by updating the `LoginComponent`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更新 `LoginComponent`，确保用户在登录后被路由到适当的页面：
- en: 'Update the `login` logic to route per role:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `login` 逻辑以根据角色路由：
- en: '[PRE40]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Similarly, clerks and manager are routed to their landing screens to access
    the features they need to accomplish their tasks, as shown earlier. Since we implemented
    a default manager role, the corresponding landing experience will be launched
    automatically. The other side of the coin is intentional and unintentional attempts
    to access routes that a user isn't meant to have access to. In the next section,
    we will learn about router guards that can help check authentication and even
    load requisite data before the form is rendered.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，店员和经理被路由到他们需要完成任务所需的功能的登录屏幕，正如前面所示。由于我们实现了默认的经理角色，相应的登录体验将自动启动。另一方面，用户意图和非意图尝试访问他们不应访问的路由。在下一节中，我们将了解可以帮助检查身份验证并在表单呈现之前加载必需数据的路由守卫。
- en: Router Guards
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由守卫
- en: Router Guards enable further decoupling and reuse of logic and greater control
    over the component lifecycle.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 路由守卫进一步实现逻辑的解耦和重用，并控制组件生命周期。
- en: 'Here are the four major guards you will most likely use:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您最有可能使用的四个主要守卫：
- en: '`CanActivate` and `CanActivateChild`, used for checking auth access to a route'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CanActivate` 和 `CanActivateChild`，用于检查路由的鉴权访问'
- en: '`CanDeactivate`, used to ask permission before navigating away from a route'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CanDeactivate`，用于在离开路由之前询问权限'
- en: '`Resolve`, allows for pre-fetching of data from route parameters'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Resolve`，允许从路由参数预取数据'
- en: '`CanLoad`, allows for custom logic to execute before loading feature module
    assets'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CanLoad`，允许在加载特性模块资产之前执行自定义逻辑'
- en: Refer to the following sections for how to leverage `CanActivate` and `CanLoad` . `Resolve`
    guard will be covered in [Chapter 15](3da8e826-b070-415b-b3ce-d535358db5de.xhtml),
    *Angular App Design and Recipes*.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下部分，了解如何利用 `CanActivate` 和 `CanLoad`。`Resolve` 守卫将在 [第15章](3da8e826-b070-415b-b3ce-d535358db5de.xhtml)
    中进行介绍，*Angular 应用设计与实例*。
- en: Auth Guard
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 鉴权守卫
- en: Auth Guards enable good UX by allowing or disallowing accidental navigation
    to a feature module or component before it is loaded and any data requests are
    made to the server.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴权守卫通过允许或阻止在加载模块或组件之前意外导航来实现良好的用户体验，并且在向服务器发出任何数据请求之前。
- en: For example, when a Manager logs in, they're automatically routed to the `/manager/home` path. The
    browser will cache this URL, and it will be completely plausible for a clerk to
    accidentally navigate to the same URL. Angular doesn't know whether a particular
    route is accessible to a user or not and, without an `AuthGuard`, it will happily
    render the Manager's home page and trigger server requests that will end up failing.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当经理登录时，他们会自动路由到 `/manager/home` 路径。浏览器将缓存此 URL，并且店员意外地导航到相同的 URL 是完全可能的。Angular
    不知道特定路由对用户是否可访问，如果没有 `AuthGuard`，它将高兴地渲染经理的主页并触发最终会失败的服务器请求。
- en: Regardless of the robustness of your frontend implementation, every REST API
    you implement should be properly secured server-side.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 无论前端实现的健壮性如何，您实施的每个 REST API 都应该在服务器端得到适当的安全保护。
- en: 'Let''s update the router so that `ProfileComponent` can''t be activated without
    an authenticated user and the `ManagerModule` won''t load unless a manager is
    logging in using an `AuthGuard`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新路由，以便在没有经过身份验证的用户的情况下无法激活 `ProfileComponent`，并且除非经理使用 `AuthGuard` 登录，否则不会加载
    `ManagerModule`：
- en: 'Implement an `AuthGuard` service:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个 `AuthGuard` 服务：
- en: '[PRE41]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Use the `CanLoad` guard to prevent loading of lazily loaded module, such as
    Manager''s module:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `CanLoad` 守卫防止懒加载模块的加载，例如经理的模块：
- en: '[PRE42]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In this instance, when the `ManagerModule` is being loaded, `AuthGuard` will
    be activated during the `canLoad` event, and the `checkLogin` function will verify
    the authentication status of the user. If the guard returns `false`, the module
    will not be loaded. At this point, we don't have the metadata to check the role
    of the user.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当加载 `ManagerModule` 时， `AuthGuard` 将在 `canLoad` 事件期间被激活，而 `checkLogin` 函数将验证用户的认证状态。如果守卫返回`false`，该模块将不会被加载。此时，我们没有元数据来检查用户的角色。
- en: 'Use the `CanActivate` guard to prevent activation of individual components,
    such as user''s `profile`:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `CanActivate` 守卫来阻止个别组件的激活，如用户的`profile`：
- en: '[PRE43]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the case of `user-routing.module`, `AuthGuard` is activated during the `canActivate` event,
    and the `checkLogin` function controls where this route can be navigated to. Since
    the user is viewing their own profile, there's no need to check the user's role
    here.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `user-routing.module` 的情况下， `AuthGuard` 在 `canActivate` 事件期间被激活，而 `checkLogin` 函数控制着这个路由可以导航到哪里。由于用户正在查看自己的个人资料，这里不需要检查用户的角色。
- en: 'Use `CanActivate` or `CanActivateChild` with an `expectedRole` property to
    prevent activation of components by other users, such as `ManagerHomeComponent`:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用带有 `expectedRole` 属性的 `CanActivate` 或 `CanActivateChild` 来防止其他用户激活组件，如 `ManagerHomeComponent`：
- en: '[PRE44]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Inside `ManagerModule`, we can verify whether the user is authorized to access
    a particular route. We can do this by defining some metadata in the route definition,
    like `expectedRole`, which will be passed into the `checkLogin` function by the `canActivate` event.
    If a user is authenticated but their role doesn't match `Role.Manager`, `AuthGuard`
    will return false and the navigation will be prevented.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ManagerModule` 内部，我们可以验证用户是否有权访问特定路由。我们可以通过在路由定义中定义一些元数据，如 `expectedRole` 来做到这一点，该元数据将在 `canActivate` 事件中传递给 `checkLogin` 函数。如果用户已经认证但其角色不匹配`Role.Manager`，`AuthGuard` 将返回 false，导航将被阻止。
- en: Ensure that both `AuthService` and `AuthGuard` are provided in `app.module`
    and `manager.module` since they used in both contexts
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保`AuthService`和`AuthGuard`在`app.module` 和 `manager.module` 中都提供，因为它们在两个上下文中都被使用。
- en: As always, before moving on ensure that all your tests pass by executing `npm
    test` and `npm run e2e`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请确保执行`npm test` 和 `npm run e2e` 确保所有测试都通过。
- en: Auth Service Fake and Common Testing Providers
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证服务伪装和共同测试提供程序
- en: We need to implement an `AuthServiceFake` so that our unit tests pass and use
    a pattern similar to `commonTestingModules` mentioned in [Chapter 12,](b49e4716-d083-4c8c-a083-bcf6cf182a6f.xhtml) *Create
    a Router-First Line-of-Business App*, to conveniently provider this fake across
    our spec files.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现一个`AuthServiceFake` 以便我们的单元测试通过，并使用类似于 [第 12 章](b49e4716-d083-4c8c-a083-bcf6cf182a6f.xhtml) 中的 `commonTestingModules` 提到的模式，方便地在我们的规范文件中提供这个假对象。
- en: 'To ensure that our fake will have the same public functions and properties
    as the actual `AuthService`, let''s first start with creating an interface:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们的假对象将具有与实际`AuthService` 相同的公共函数和属性，让我们首先创建一个接口：
- en: Add `IAuthService` to `auth.service.ts`
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `auth.service.ts` 中添加`IAuthService`
- en: '[PRE45]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Make sure `AuthService` implements the interface
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保 `AuthService` 实现了接口
- en: Export `defaultAuthStatus` for reuse
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导出 `defaultAuthStatus` 以供重复使用
- en: '[PRE46]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now we can create a fake that implements the same interface, but provides functions
    that don't have any dependencies to any external authentication system.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建一个假对象，它实现了相同的接口，但提供的功能不依赖于任何外部验证系统。
- en: 'Create a new file named `auth.service.fake.ts` under `auth`:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`auth` 下创建一个名为 `auth.service.fake.ts` 的新文件：
- en: '[PRE47]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Update `common.testing.ts` with `commonTestingProviders`:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `commonTestingProviders` 更新 `common.testing.ts`：
- en: '[PRE48]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Observer the use of the fake in `app.component.spec.ts`:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察 `app.component.spec.ts` 中对假对象的使用：
- en: '[PRE49]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The empty `commonTestingProviders` array we created earlier is being concatenated
    with fakes that are specific to `app.component`, so our new `AuthServiceFake`
    should apply automatically.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前创建的空的 `commonTestingProviders` 数组已经与特定于 `app.component` 的假对象进行了连接，所以我们的新的 `AuthServiceFake` 应该可以自动应用。
- en: 'Update the spec file for `AuthGuard` shown as follows:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用如下所示更新 `AuthGuard` 的规范文件：
- en: '[PRE50]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Go ahead and apply this technique to all spec files that have a dependency on
    `AuthService` and `UiService`
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续将这种技术应用到所有依赖于`AuthService`和`UiService`的规范文件中
- en: 'The notable exception is in `auth.service.spec.ts` where you do *not *want
    to use the fake, since `AuthService` is the class under test, make sure it is
    configure shown as follows:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个显著的例外是在 `auth.service.spec.ts` 中，你*不*想使用假对象，因为`AuthService`是被测试的类，确保它被配置如下：
- en: '[PRE51]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In addition `SimpleDialogComponent` tests require stubbing out some external
    dependencies like:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另外，`SimpleDialogComponent` 的测试需要模拟一些外部依赖项，例如：
- en: '[PRE52]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Remember, don't move on until all your tests are passing!
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，不要在所有测试通过之前进入下一阶段！
- en: Summary
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You should now be familiar with how to create high-quality authentication and
    authorization experiences. We started by going over the importance of completing
    and documenting high-level UX design of our entire app so that we can properly
    design a great conditional navigation experience. We created a reusable UI service
    so that we can conveniently inject alerts into the flow-control logic of our app.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该熟悉如何创建高质量的身份验证和授权体验了。我们开始时强调了完成和记录整个应用的高水平 UX 设计的重要性，这样我们才能适当地设计出一个很棒的有条件导航体验。我们创建了可重用的
    UI 服务，以便我们可以方便地将警报注入到应用的流程控制逻辑中。
- en: We covered the fundamentals of token-based authentication and JWTs so that you
    don't leak any critical user information. We learned that caching and HTTP interceptors
    are necessary so that users don't have to input their login information with every
    request. Finally, we covered router guards to prevent users from stumbling onto
    screens they are not authorized to use, and we reaffirmed the point that the real
    security of your application should be implemented on the server side.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了基于令牌的身份验证和 JWT，以便不泄露任何重要的用户信息。我们了解到缓存和 HTTP 拦截器是必要的，这样用户不必在每个请求中输入他们的登录信息。最后，我们讨论了路由守卫，以防止用户意外进入未经授权使用的屏幕，并重申了应用程序的真正安全性应该在服务器端实现的观点。
- en: In the next chapter, we will go over a comprehensive list of Angular recipes
    to complete the implementation of our line-of-business app—LemonMart.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将详细介绍一系列 Angular 示例，以完成我们的业务线应用—LemonMart 的实现。
