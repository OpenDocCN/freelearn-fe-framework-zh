<html><head></head><body>
		<div id="_idContainer039">
			<h1 id="_idParaDest-82"><em class="italic"><a id="_idTextAnchor085"/>Chapter 4</em>: Hooking Apollo into React</h1>
			<p>Sequelize makes it easy to access and query our database. Posts, chats, and messages can be saved to our database in a snap. React helps us to view and update our data by building a <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>).</p>
			<p>In this chapter, we will introduce Apollo's React client to our frontend to connect it with the backend. We will query, create, and update post data using our frontend.</p>
			<p>This chapter will cover the following topics:</p>
			<ul>
				<li>Installing and configuring Apollo Client</li>
				<li>Sending requests with GQL and Apollo's Query component</li>
				<li>Mutating data with Apollo Client</li>
				<li>Implementing chats and messages</li>
				<li>Pagination in React and GraphQL</li>
				<li>Debugging with the Apollo Client Devtools</li>
			</ul>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor086"/>Technical requirements</h1>
			<p><a id="_idTextAnchor087"/>The source code for this chapter is available in the following GitHub repository: </p>
			<p><a href="https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter04">https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter04</a></p>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor088"/>Installing and configuring Apollo Client</h1>
			<p>We have <a id="_idIndexMarker256"/>tested our GraphQL <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>) multiple times during development. We can now start to <a id="_idIndexMarker257"/>implement the data layer of our frontend code. In later chapters, we will <a id="_idIndexMarker258"/>focus on other tasks, such as authentication and client-side routing. For now, we will aim to use our GraphQL API with our React app.</p>
			<p>To start, we must install the React Apollo Client library. Apollo Client is a GraphQL client that offers excellent integration with React and the ability to easily fetch data from our GraphQL API. Furthermore, it handles actions such as caching and subscriptions, to implement real-time communication with your GraphQL backend. Although Apollo Client is named after the Apollo brand, it is not tied to Apollo Server. You can use Apollo Client with any GraphQL API or schema out there, as long as they follow the protocol standards. You will soon see how perfectly the client merges with our React setup.</p>
			<p>As always, there are many alternatives out there. You can use any GraphQL client that you wish with the current API that we have built. This openness is the great thing about GraphQL: it uses an open standard for communication. Various libraries implement the GraphQL standard, and you are free to use any of them.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">The most well-known alternatives a<a id="_idTextAnchor089"/><a id="_idTextAnchor090"/>re Relay (which is made by Facebook) a<a id="_idTextAnchor091"/><a id="_idTextAnchor092"/>nd <strong class="source-inline">graphql-request</strong> (which is made by the people behind Prisma). All of these are great libraries that you are free to use. Personally, I mostly rely on Apollo, but Relay is highly recommended as well. You can find a long list of packages related to the GraphQL ecosystem at <a href="https://github.com/chentsulin/awesome-graphql">https://github.com/chentsulin/awesome-graphql</a>.</p>
			<p>In addition to special client libraries, you could also just use a plain <strong class="source-inline">fetch</strong> method or <strong class="source-inline">XMLHttpRequest</strong> requests. The disadvantage is that you need to implement caching, write <strong class="source-inline">request</strong> objects, and integrate the <strong class="source-inline">request</strong> method into your application on your own. I do not recommend doing this because it takes a lot of time and you want to put that time into your business, not into implementing existing functionalities.</p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor093"/>Installing Apollo Client</h2>
			<p>We use <strong class="source-inline">npm</strong> to install <a id="_idIndexMarker259"/>our client dependencies, as follo<a id="_idTextAnchor094"/><a id="_idTextAnchor095"/>ws:</p>
			<p class="source-code">npm install --save @apollo/client graphql</p>
			<p>We need to install the following two packages to get the GraphQL client running:</p>
			<ul>
				<li><strong class="source-inline">@apollo/client</strong> is the wrapping package for all of the packages that we installed. Apollo Client relies on all the other packages.</li>
				<li><strong class="source-inline">graphql</strong> is a reference implementation for GraphQL and provides logic to parse GraphQL queries.</li>
			</ul>
			<p>You will see how these packages work together in this section.</p>
			<p>To get started with <a id="_idIndexMarker260"/>the manual setup of Apollo Client, create a new folder and file for the client, as foll<a id="_idTextAnchor096"/><a id="_idTextAnchor097"/>ows:</p>
			<p class="source-code"><strong class="bold">mkdir src/client/apollo</strong></p>
			<p class="source-code"><strong class="bold">touch src/client/apollo/index.js</strong></p>
			<p>We will set up Apollo Client in this <strong class="source-inline">index.js</strong> file. Our first setup will represent the most basic configuration to get a working GraphQL client.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">The code that follows was taken from the official Apollo documentation. Generally, I recommend reading through <a id="_idIndexMarker261"/>the Apollo documentation as it is very well written. You can find this at <a href="https://www.apollographql.com/docs/react/essentials/get-started.html">https://www.apollographql.com/docs/react/essentials/get-started.html</a>.</p>
			<p>Just insert the following <a id="_idTextAnchor098"/><a id="_idTextAnchor099"/>code:</p>
			<p class="source-code">import { ApolloClient, InMemoryCache, from, HttpLink } from '@apollo/client';</p>
			<p class="source-code">import { onError } from "@apollo/client/link/error";</p>
			<p class="source-code">const client = new ApolloClient({</p>
			<p class="source-code">  link: from([</p>
			<p class="source-code">    onError(({ graphQLErrors, networkError }) =&gt; {</p>
			<p class="source-code">      if (graphQLErrors) {</p>
			<p class="source-code">        graphQLErrors.map(({ message, locations, path }) =&gt; </p>
			<p class="source-code">        console.log('[GraphQL error]: Message: ${message},</p>
			<p class="source-code">        Location: </p>
			<p class="source-code">        ${locations}, Path: ${path}'));</p>
			<p class="source-code">        if (networkError) {</p>
			<p class="source-code">          console.log('[Network error]: ${networkError}');</p>
			<p class="source-code">        }</p>
			<p class="source-code">      }</p>
			<p class="source-code">    }),</p>
			<p class="source-code">    new HttpLink({</p>
			<p class="source-code">      uri: 'http://localhost:8000/graphql',</p>
			<p class="source-code">    }),</p>
			<p class="source-code"> ]),</p>
			<p class="source-code"> cache: new InMemoryCache(),</p>
			<p class="source-code">});</p>
			<p class="source-code">export default client;</p>
			<p>The preceding <a id="_idIndexMarker262"/>code uses all of the new packages, apart from <strong class="source-inline">react-apollo</strong>. Let's break down the code, as follows:</p>
			<ul>
				<li>First, at the top of the file, we imported all required functions and classes from the <strong class="source-inline">@apollo/client</strong> package.</li>
				<li>We instantiated <strong class="source-inline">ApolloClient</strong>. For this to work, we passed some parameters, which are the <strong class="source-inline">link</strong> and <strong class="source-inline">cache</strong> properties.</li>
				<li>The <strong class="source-inline">link</strong> property is filled by the <strong class="source-inline">from</strong> command. This function walks through an array of links and initializes each of them, one by one. The links are described further here: <p>a. The first link is the error link. It accepts a function that tells Apollo what should be <a id="_idIndexMarker263"/>done if an error occurs.</p><p>b. The second link is the <strong class="bold">HyperText Transfer Protocol</strong> (<strong class="bold">HTTP</strong>) link for Apollo. You have <a id="_idIndexMarker264"/>to offer a <strong class="bold">Uniform Resource Identifier</strong> (<strong class="bold">URI</strong>), under which our Apollo or GraphQL server is reachable. Apollo Client <a id="_idIndexMarker265"/>sends all requests to this URI. Notably, the order of execution is the same as the array that we just created.</p></li>
				<li>The <strong class="source-inline">cache</strong> property takes an implementation for caching. One implementation can be the default package, <strong class="source-inline">InMemoryCache</strong>, or a different cache.<p class="callout-heading">Important Note</p><p class="callout">There are many more properties that our links can understand (especially the HTTP link). They feature a lot of different customization options, which we will look at later. You can also find them in the official documentation, at <a href="https://www.apollographql.com/docs/react/">https://www.apollographql.com/docs/react/</a>.</p></li>
			</ul>
			<p>In the preceding code snippet, we exported the initialized Apollo Client using the <strong class="source-inline">export default client</strong> line. We are now able to use it in our React app.</p>
			<p>The basic setup to send GraphQL requests using Apollo Client is finished. In the next section, we will send our first GraphQL request through Apollo Client.</p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor100"/>Testing Apollo Client</h2>
			<p>Before inserting the GraphQL client directly into our React application tree, we should test it. We will write <a id="_idIndexMarker266"/>some temporary code to send our first GraphQL query. After testing our GraphQL client, we will remove the code again. Follow these next steps: </p>
			<ol>
				<li>Import the package at the top of the Apollo Client setup, a<a id="_idTextAnchor101"/><a id="_idTextAnchor102"/>s follows:<p class="source-code">import { gql } from '@apollo/client';</p></li>
				<li>Then, add the following code before the client is<a id="_idTextAnchor103"/><a id="_idTextAnchor104"/><a id="_idTextAnchor105"/> exported:<p class="source-code">client<a id="_idTextAnchor106"/><a id="_idTextAnchor107"/>.query({</p><p class="source-code">  query: gql'</p><p class="source-code">    { </p><p class="source-code">      posts { </p><p class="source-code">        id</p><p class="source-code">        text</p><p class="source-code">        user {</p><p class="source-code">          avatar</p><p class="source-code">          username</p><p class="source-code">        }</p><p class="source-code">      }</p><p class="source-code">    }'</p><p class="source-code">}).then(result =&gt; console.log(result));</p></li>
			</ol>
			<p>The preceding code is almost the same as the example from the Apollo documentation, but I have replaced their query with one that matches our backend.</p>
			<p>Here, we used the <strong class="source-inline">gql</strong> tool from Apollo Client to parse a <strong class="bold">template literal</strong>. A template literal <a id="_idIndexMarker267"/>is just a multiline string surrounded by two grace <a id="_idIndexMarker268"/>accents. The <strong class="source-inline">gql</strong> command parses this literal to an <strong class="bold">abstract syntax tree</strong> (<strong class="bold">AST</strong>). ASTs are the first step of GraphQL; they are used to validate deeply nested <a id="_idIndexMarker269"/>objects, the schema, and the query. The client sends our query after the parsing has been completed.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If you want to know more about ASTs, the people at <em class="italic">Contentful</em> wrote a great article about what <a id="_idIndexMarker270"/>ASTs mean to GraphQL, at <a href="https://www.contentful.com/blog/2018/07/04/graphql-abstract-syntax-tree-new-schema/">https://www.contentful.com/blog/2018/07/04/graphql-abstract-syntax-tree-new-schema/</a>.</p>
			<p>To test the preceding code, we should start the server and the frontend. One option is to build the frontend <a id="_idIndexMarker271"/>now, and then start the server. In this case, the <strong class="bold">Uniform Resource Locator</strong> (<strong class="bold">URL</strong>) to browse the frontend would be <a href="http://localhost:8000">http://localhost:8000</a>. A better option <a id="_idIndexMarker272"/>would be to spawn the server with <strong class="source-inline">npm run server</strong> and then open a second terminal. Then, you can start the <strong class="source-inline">webpack</strong> development server by executing <strong class="source-inline">npm run client</strong>. A new browser tab should open automatically.</p>
			<p>However, we have forgotten something: the client is set up in our new file, but it is not yet used anywhere. Import it in the <strong class="source-inline">index.js</strong> root file of our client React app, below the import of the <strong class="source-inline">App</strong> compon<a id="_idTextAnchor108"/><a id="_idTextAnchor109"/>ent, as follows:</p>
			<p class="source-code">import client from './apollo';</p>
			<p>The browser should be reloaded, and the query sent. You should be able to see a new log inside the console of the developer tools of your browser.</p>
			<p>The output should look like this:</p>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="image/Figure_4.01_B17337.jpg" alt="Figure 4.1 – Manual client response&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.1 – Manual client response</p>
			<p>The <strong class="source-inline">data</strong> object looks much like the response that we received when sending requests through Postman, except that <a id="_idIndexMarker273"/>it now has some new properties: <strong class="source-inline">loading</strong> and <strong class="source-inline">networkStatus</strong>. Each of these stands for a specific status, as follows:</p>
			<ul>
				<li><strong class="source-inline">loading</strong>, as you might expect, indicates whether the query is still running or has already finished.</li>
				<li><strong class="source-inline">networkStatus</strong> goes beyond this and gives you the exact status of what happened. For example, the number 7 indicates that there are no running queries that produce errors. The number 8 means that there has been an error. You can look up the other numbers in the official GitHub repository, at <a href="https://github.com/apollographql/apollo-client/blob/main/src/core/networkStatus.ts">https://github.com/apollographql/apollo-client/blob/main/src/core/networkStatus.ts</a>.</li>
			</ul>
			<p>Now that we have verified that the query has run successfully, we can connect Apollo Client to the React <strong class="bold">Document Object Model</strong> (<strong class="bold">DOM</strong>). Please remove the temporary code that we <a id="_idIndexMarker274"/>wrote in this section before continuing. This includes everything except the <strong class="source-inline">import</strong> statement in the <strong class="source-inline">App.js</strong> file.</p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor110"/>Binding Apollo Client to React</h2>
			<p>We have tested <a id="_idIndexMarker275"/>Apollo Client and have confirmed that it works. However, React does <a id="_idIndexMarker276"/>not yet have access to it. Since Apollo Client is going to be used everywhere in our application, we can set it up in our root <strong class="source-inline">index.js</strong> file, as follows:</p>
			<p class="source-code">import React from 'react';</p>
			<p class="source-code">import ReactDOM from 'react-dom';</p>
			<p class="source-code">import { ApolloProvider } from '@apollo/client/react'; </p>
			<p class="source-code">import App from './App';</p>
			<p class="source-code">import client from './apollo';</p>
			<p class="source-code">ReactDOM.render(</p>
			<p class="source-code">  &lt;ApolloProvider client={client}&gt;</p>
			<p class="source-code">    &lt;App /&gt;</p>
			<p class="source-code">  &lt;/ApolloProvider&gt;, document.getElementById('root')</p>
			<p class="source-code">);</p>
			<p>As we mentioned in <a href="B17337_01_Final_ASB_ePub.xhtml#_idTextAnchor017"><em class="italic">Chapter 1</em></a>, <em class="italic">Preparing Your Development Environment</em>, you should only edit this file when the whole application needs access to the new component. In the <a id="_idIndexMarker277"/>preceding code snippet, you can see that we import <a id="_idIndexMarker278"/>the last package that we installed at the beginning, from <strong class="source-inline">@apollo/client/react</strong>. The <strong class="source-inline">ApolloProvider</strong> component that we extracted from it is the first layer of our React application. It surrounds the <strong class="source-inline">App</strong> component, passing the Apollo Client that we wrote to the next level. To do this, we pass <strong class="source-inline">client</strong> to the provider as a property. Every underlying React component can now access Apollo Client.</p>
			<p>We should be now able to send GraphQL requests from our React app.</p>
			<h1 id="_idParaDest-88"><a id="_idTextAnchor111"/>Using Apollo Client in React</h1>
			<p>Apollo Client gives us everything that we need to send requests from our React components. We <a id="_idIndexMarker279"/>have already tested that the client works. Before <a id="_idIndexMarker280"/>moving on, we should clean up our file structure, to make it easier for us later in the development process. Our frontend is still displaying posts that come from static demo data. The first step is to move over to Apollo Client and fetch the data from our GraphQL API.</p>
			<p>Follow these instructions to connect your first React component with Apollo Client:</p>
			<ol>
				<li value="1">Clone the <strong class="source-inline">App.js</strong> file to another file, called <strong class="source-inline">Feed.js</strong>.</li>
				<li>Remove all parts where React <strong class="source-inline">Helmet</strong> is used, remove the <strong class="bold">Cascading Style Sheets</strong> (<strong class="bold">CSS</strong>) import, and <a id="_idIndexMarker281"/>rename the function <strong class="source-inline">Feed</strong> instead of <strong class="source-inline">App</strong>.</li>
				<li>From the <strong class="source-inline">App.js</strong> file, remove all of the parts that we have left in the <strong class="source-inline">Feed</strong> component.</li>
				<li>Furthermore, we <a id="_idIndexMarker282"/>must render the <strong class="source-inline">Feed</strong> component <a id="_idIndexMarker283"/>inside of the <strong class="source-inline">App</strong> component. It should look like this:<p class="source-code">import React from 'react';</p><p class="source-code">import { Helmet } from 'react-helmet';</p><p class="source-code">import Feed from './Feed';</p><p class="source-code">import '../../assets/css/style.css';</p><p class="source-code">const App = () =&gt; {</p><p class="source-code">  return (</p><p class="source-code">    &lt;div className="container"&gt;</p><p class="source-code">      &lt;Helmet&gt;</p><p class="source-code">        &lt;title&gt;Graphbook - Feed&lt;/title&gt;</p><p class="source-code">        &lt;meta name="description" content="Newsfeed of </p><p class="source-code">          all your friends on Graphbook" /&gt;</p><p class="source-code">      &lt;/Helmet&gt;</p><p class="source-code">      &lt;Feed /&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">  )</p><p class="source-code">}</p><p class="source-code">export default App</p></li>
			</ol>
			<p>The corresponding <strong class="source-inline">Feed</strong> component should only include the parts where the news feed is rendered.</p>
			<p>We imported the <strong class="source-inline">Feed</strong> component and inserted it inside of the <strong class="source-inline">return</strong> statement of our <strong class="source-inline">App</strong> component <a id="_idIndexMarker284"/>so that it is rendered. The next chapter focuses on <a id="_idIndexMarker285"/>reusable React components and how to write well-structured React code. Now, let's take a look at why we split our <strong class="source-inline">App</strong> function into two separate files.</p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor112"/>Querying in React with Apollo Client</h2>
			<p>Apollo Client offers one primary way to request data from a GraphQL API. The <strong class="source-inline">useQuery</strong> function <a id="_idIndexMarker286"/>offered by the <strong class="source-inline">@apollo/client</strong> package <a id="_idIndexMarker287"/>provides the ability to request data via React Hooks within a functional React component. Beyond that, you can still rely on the plain <strong class="source-inline">client.query</strong> function for class-based components if required. There had been multiple ways to do this before, which were deprecated when the new version of Apollo Client was released. Before, you were able to use a <strong class="bold">higher-order component</strong> (<strong class="bold">HOC</strong>) or use the <strong class="source-inline">Query</strong> component of Apollo, which is a special React <a id="_idIndexMarker288"/>component. Both approaches still exist but are deprecated, so it is not recommended to use them anymore. This is the reason why those approaches will not be explained in this book.</p>
			<h3>Apollo useQuery Hook</h3>
			<p>The newest version of Apollo Client comes with the <strong class="source-inline">useQuery</strong> Hook. You just need to pass the GraphQL query <a id="_idIndexMarker289"/>string to the <strong class="source-inline">useQuery</strong> Hook and it will return you an object that includes <strong class="source-inline">data</strong>, <strong class="source-inline">error</strong>, and <strong class="source-inline">loading</strong> properties that you can use to render your UI.</p>
			<p>The actual way of implementing this <strong class="source-inline">useQuery</strong> Hook is very straightforward. Just follow these instructions:</p>
			<ol>
				<li value="1">Remove the demo posts from the top of the <strong class="source-inline">Feed.js</strong> file.</li>
				<li>Remove the <strong class="source-inline">useState(initialPosts)</strong> line so that we can query the posts instead.</li>
				<li>Import the <strong class="source-inline">gql</strong> function and the <strong class="source-inline">useQuery</strong> Hook from Apollo and parse the query, as follows:<p class="source-code">import { gql, useQuery } from '@apollo/client';</p><p class="source-code">const GET_POSTS = gql'{ </p><p class="source-code">  posts { </p><p class="source-code">    id</p><p class="source-code">    text</p><p class="source-code">    user {</p><p class="source-code">      avatar</p><p class="source-code">      username</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}';</p></li>
				<li>Execute the <strong class="source-inline">useQuery</strong> Hook within the <strong class="source-inline">Feed</strong> function at the top, as follows:<p class="source-code">const { loading, error, data } = useQuery(GET_POSTS);</p></li>
				<li>Before the actual <strong class="source-inline">return</strong> statement, add the following two statements, which will render <a id="_idIndexMarker290"/>loading and error messages if there have been any:<p class="source-code">if (loading) return 'Loading...';</p><p class="source-code">if (error) return 'Error! ${error.message}';</p></li>
				<li>Beneath these statements and before the last <strong class="source-inline">return</strong> statement, add this line of code: <p class="source-code">const { posts } = data;</p><p>This will make the <strong class="source-inline">posts</strong> property accessible from the data returned by the <strong class="source-inline">useQuery</strong> function if it is no longer loading and there is no error.</p><p>Note that the function is now way cleaner because we only loop over the <strong class="source-inline">posts</strong> property and return the markup.</p></li>
			</ol>
			<p>In comparison with the older approaches, the <strong class="source-inline">useQuery</strong> Hook is easy to understand and also allows <a id="_idIndexMarker291"/>us to write readable and understandable code.</p>
			<p>The rendered output should look like that shown in <a href="B17337_01_Final_ASB_ePub.xhtml#_idTextAnchor017"><em class="italic">Chapter 1</em></a>, <em class="italic">Preparing Your Development Environment</em>. The form to create a new post is not working at the moment because of our changes; let's fix this in the next section.</p>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor113"/>Mutating data with Apollo Client</h1>
			<p>We have replaced the way we get data in our client. The next step is to switch the way in which we create <a id="_idIndexMarker292"/>new posts, too. Before Apollo Client, we had <a id="_idIndexMarker293"/>to add new fake posts to the array of demo posts manually, within the memory of the browser. Now, everything in our text area is sent with the <strong class="source-inline">addPost</strong> mutation to our GraphQL API, through Apollo Client.</p>
			<p>As with the GraphQL queries, there is a <strong class="source-inline">useMutation</strong> Hook that you can use to send a mutation against our GraphQL API. Before, there was also an HOC method and a separate <strong class="source-inline">Mutation</strong> component, which have been deprecated as well. They still exist for backward compatibility, but we will not cover them in this book.</p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor114"/>Apollo useMutation Hook</h2>
			<p>The newest version of Apollo Client comes with the <strong class="source-inline">useMutation</strong> Hook. The method works equally <a id="_idIndexMarker294"/>to the <strong class="source-inline">useQuery</strong> Hook—you just need to pass the parsed mutation string to it. In response to that, the <strong class="source-inline">useMutation</strong> Hook will return a function equally named to the mutation, which you can use to trigger those GraphQL requests.</p>
			<p>Follow these instructions to implement the <strong class="source-inline">useMutation</strong> Hook and start using it:</p>
			<ol>
				<li value="1">Import the <strong class="source-inline">useMutation</strong> Hook from the <strong class="source-inline">@apollo/client</strong> package, like this:<p class="source-code">import { gql, useQuery, useMutation } from '@apollo/client';</p></li>
				<li>Parse the <strong class="source-inline">addPost</strong> mutation string below the <strong class="source-inline">getPost</strong> query with the <strong class="source-inline">gql</strong> function, like this:<p class="source-code">const ADD_POST = gql'</p><p class="source-code">  mutation addPost($post : PostInput!) {</p><p class="source-code">    addPost(post : $post) {</p><p class="source-code">      id</p><p class="source-code">      text</p><p class="source-code">      user {</p><p class="source-code">        username</p><p class="source-code">        avatar</p><p class="source-code">      }</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">';</p></li>
				<li>Inside the <strong class="source-inline">Feed</strong> component, add the following line of code to get the <strong class="source-inline">addPost</strong> function, which <a id="_idIndexMarker295"/>you can use in the <strong class="source-inline">Feed</strong> component wherever you want:<p class="source-code">const [addPost] = useMutation(ADD_POST);</p></li>
				<li>Now that we have got the <strong class="source-inline">addPost</strong> function, we can start making use of it. Just update the <strong class="source-inline">handleSubmit</strong> function, as follows:<p class="source-code">const handleSubmit = (event) =&gt; {</p><p class="source-code">  event.preventDefault();</p><p class="source-code">  addPost({ variables: { post: { text: postContent } } });</p><p class="source-code">  setPostContent('');</p><p class="source-code">};</p><p>As you can see, we completely got rid of the <strong class="source-inline">newPost</strong> object and just send the post's text. Our <a id="_idIndexMarker296"/>GraphQL API will create an <strong class="bold">identifier</strong> (<strong class="bold">ID</strong>) on insert to the database. As mentioned in <a href="B17337_03_Final_ASB_ePub.xhtml#_idTextAnchor054"><em class="italic">Chapter 3</em></a>, <em class="italic">Connecting to the Database</em>, we statically add the first user as the author of the post.</p></li>
			</ol>
			<p>You can try to add a new post through the frontend but you won't be able to see it immediately. The form will be empty, but the new post will not be shown. This happens because the current state (or cache) of our component has not yet received the new post. The easiest way to test that everything has worked is to refresh the browser.</p>
			<p>Of course, this is not the way that it should work. After the mutation has been sent, the new post should be directly visible in the feed. We will fix this now.</p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor115"/>Updating the UI with Apollo Client</h2>
			<p>After running the <strong class="source-inline">addPost</strong> mutation, the request goes through to the server and saves the new post in our <a id="_idIndexMarker297"/>database without any <a id="_idIndexMarker298"/>problems. However, we still cannot see the changes take effect in the frontend immediately.</p>
			<p>There are two different ways to update the UI after a mutation, as follows:</p>
			<ul>
				<li><strong class="bold">Refetching the dataset</strong>: This is easy to implement but it refetches all of the data, which is inefficient.</li>
				<li><strong class="bold">Updating the cache according to the inserted data</strong>: This is harder to understand and implement, but it attaches the new data to the cache of Apollo Client, so no refetching is needed.</li>
			</ul>
			<p>We use these solutions in different scenarios. Let's take a look at some examples. Refetching makes sense if further logic is implemented on the server that is hidden from the client when requesting a list of items and is not applied when inserting only one item. In these cases, the client cannot simulate the state of the typical response of a server.</p>
			<p>Updating the cache, however, makes sense when adding or updating items in a list, such as our post feed. The client can insert the new post at the top of the feed.</p>
			<p>We will start by simply refetching <a id="_idIndexMarker299"/>requests, and then we'll go <a id="_idIndexMarker300"/>over the cache update implementation. The following sections (and chapters) will assume that you are not using the HOC method.</p>
			<h3>Refetching queries</h3>
			<p>As mentioned <a id="_idIndexMarker301"/>previously, this is the easiest method to update your UI. The only step is to set an array of queries to be refetched. The <strong class="source-inline">useMutation</strong> function should look like this:</p>
			<p class="source-code">const [addPost] = useMutation(ADD_POST, {</p>
			<p class="source-code">  refetchQueries: [{query:GET_POSTS}]</p>
			<p class="source-code">});</p>
			<p>Each object that you enter in the <strong class="source-inline">refetchQueries</strong> array needs a <strong class="source-inline">query</strong> property. Each component relying on one of those requests is rerendered when the response for its associated query arrives. It also includes components that are not inside of the <strong class="source-inline">Feed</strong> component. All components using the post's <strong class="source-inline">GET_POSTS</strong> query are rerendered.</p>
			<p>You can also provide more fields to each query, such as variables to send parameters with the <strong class="source-inline">refetch</strong> request. Submitting the form resends the query, and you can see the new post directly in the feed. Refetching also reloads the posts that are already showing, which is unnecessary.</p>
			<p>Now, let's take a look at how we can do this more efficiently.</p>
			<h3>Updating the Apollo Client cache</h3>
			<p>We want to explicitly add only the new post to the cache of Apollo Client. Using the cache helps us to <a id="_idIndexMarker302"/>save data by not refetching the complete feed or rerendering the complete list. To update the cache, you should remove the <strong class="source-inline">refetchQueries</strong> property.</p>
			<p>There are technically at least two ways to update the cache on response of the mutation request. The first one is pretty straightforward and simple. You can then introduce a new property, called <strong class="source-inline">update</strong>, as shown in the following code snippet:</p>
			<p class="source-code">const [addPost] = useMutation(ADD_POST, {</p>
			<p class="source-code">  update(cache, { data: { addPost } }) {</p>
			<p class="source-code">    const data = cache.readQuery({ query: GET_POSTS });</p>
			<p class="source-code">    const newData = { posts: [addPost, ...data.posts]};</p>
			<p class="source-code">    cache.writeQuery({ query: GET_POSTS, data: newData });</p>
			<p class="source-code">  }</p>
			<p class="source-code">});</p>
			<p>The new property runs when the GraphQL <strong class="source-inline">addPost</strong> mutation has finished. The first parameter that it receives is the <strong class="source-inline">cache</strong> parameter of Apollo Client, in which the whole cache is saved. The second <a id="_idIndexMarker303"/>parameter is the returned response of our GraphQL API. </p>
			<p>Updating the cache works like this:</p>
			<ol>
				<li value="1">Use the <strong class="source-inline">cache.readQuery</strong> function by passing <strong class="source-inline">query</strong> as a parameter. It reads the data, which has been saved for this specific query inside of the cache. The <strong class="source-inline">data</strong> variable holds all of the posts that we have in our feed.</li>
				<li>Now that we have all of the posts in an array, we can add the missing post. Make sure that you know whether you need to prepend or append an item. In our example, we create a <strong class="source-inline">newData</strong> object with a <strong class="source-inline">posts</strong> array inside it that consists of the newly added post at the top of our list and a destructured list of the old posts.</li>
				<li>We need to save the changes back to the cache. The <strong class="source-inline">cache.writeQuery</strong> function accepts the <strong class="source-inline">query</strong> parameter that we used to send the request. This <strong class="source-inline">query</strong> parameter is used to update the saved data in our cache. The second parameter is the data that should be saved.</li>
				<li>When the cache has been updated, our UI reactively renders the changes.</li>
			</ol>
			<p>In reality, you can do whatever you want in the <strong class="source-inline">update</strong> function, but we only use it to update the Apollo Client store. </p>
			<p>The second way looks a bit more complicated but represents the way that is shown in the official documentation. The <strong class="source-inline">update</strong> function looks a bit more complex but comes with a small improvement of performance. It is your choice which one you like more.</p>
			<p>Just replace the <strong class="source-inline">update</strong> function of the <strong class="source-inline">useMutation</strong> Hook, like this:</p>
			<p class="source-code">update(cache, { data: { addPost } }) {</p>
			<p class="source-code">  cache.modify({</p>
			<p class="source-code">    fields: {</p>
			<p class="source-code">      posts(existingPosts = []) {</p>
			<p class="source-code">         const newPostRef = cache.writeFragment({</p>
			<p class="source-code">           data: addPost,</p>
			<p class="source-code">           fragment: gql'</p>
			<p class="source-code">             fragment NewPost on Post {</p>
			<p class="source-code">               id</p>
			<p class="source-code">               type</p>
			<p class="source-code">             }</p>
			<p class="source-code">           '</p>
			<p class="source-code">         });</p>
			<p class="source-code">         return [newPostRef, ...existingPosts];</p>
			<p class="source-code">      }</p>
			<p class="source-code">    }</p>
			<p class="source-code">  });</p>
			<p class="source-code">} </p>
			<p>What the preceding code does is use the <strong class="source-inline">cache.modify</strong> function, which allows a more precise update <a id="_idIndexMarker304"/>than the one we did before. Instead of updating the whole <strong class="source-inline">GET_POSTS</strong> query within the Apollo Client, we are using the <strong class="source-inline">cache.writeFragment</strong> method of the <strong class="source-inline">cache</strong> object to update the cache and the UI only with the new post. This will improve the performance of our components, especially as the <a id="_idIndexMarker305"/>component logic grows.</p>
			<p>In the next section, we will be a bit more optimistic about the response of our server and will add the item before the request's response successfully arrives.</p>
			<h3>Optimistic UI</h3>
			<p>Apollo provides a great feature of being able to update the UI in an optimistic manner. An optimistic manner <a id="_idIndexMarker306"/>means that Apollo adds the new data or post to the storage before the request has finished. The advantage is that the user can see the new result, instead of waiting for the response of the server. This solution makes the application feel faster and more responsive.</p>
			<p>This section expects the <strong class="source-inline">update</strong> function of the <strong class="source-inline">Mutation</strong> component to already be implemented. Otherwise, this UI feature will not work. We need to add the <strong class="source-inline">optimisticResponse</strong> property to our mutation next to the <strong class="source-inline">update</strong> property of the <strong class="source-inline">useMutation</strong> configuration, as follows:</p>
			<p class="source-code">optimisticResponse: {</p>
			<p class="source-code">  __typename: "mutation",</p>
			<p class="source-code">  addPost: {</p>
			<p class="source-code">    __typename: "Post",</p>
			<p class="source-code">    text: postContent,</p>
			<p class="source-code">    id: -1,</p>
			<p class="source-code">    user: {</p>
			<p class="source-code">      __typename: "User",</p>
			<p class="source-code">      username: "Loading...",</p>
			<p class="source-code">      avatar: "/public/loading.gif"</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">optimisticResponse</strong> property can be anything from a function to a simple object. The return value, however, needs to be a GraphQL <strong class="source-inline">response</strong> object. What you see here is an <strong class="source-inline">addPost</strong> object that looks as though our GraphQL API could return it, if our request is successful. You need <a id="_idIndexMarker307"/>to fill in the <strong class="source-inline">__typename</strong> fields, according to the GraphQL schema that you are using. That is why the <strong class="source-inline">Post</strong> and <strong class="source-inline">User</strong> type names are inside of this fake object.</p>
			<p>Technically, you can also add the <strong class="source-inline">optimisticResponse</strong> property on the actual call to <strong class="source-inline">addPost</strong> next to the <strong class="source-inline">variables</strong> property, but I think this is nothing that we need to pass with every call to this function but that actually should be set globally to the <strong class="source-inline">useMutation</strong> Hook.</p>
			<p>The <strong class="source-inline">id</strong> property of the optimistic response is set to <strong class="source-inline">-1</strong>. React expects that every component in a loop gets a unique <strong class="source-inline">key</strong> property. We usually use the <strong class="source-inline">id</strong> property of a post as the <strong class="source-inline">key</strong> value. -1 is never used by any other post because MySQL starts counting at 1. Another advantage is that we can use this <strong class="source-inline">id</strong> property to set a special class to the post item in our list.</p>
			<p>Furthermore, the username and the user's avatar are set to <strong class="source-inline">loading</strong>. That is because we don't have built-in authentication. React and Apollo do not have a user associated with the current session, so we cannot enter the user's data into the <strong class="source-inline">optimisticResponse</strong> property. We fix this once the authentication is ready. This is an excellent example of how to handle a situation in which you do not have all of the data until you receive a response from the server.</p>
			<p>To set a particular class on the list item, we conditionally set the correct <strong class="source-inline">className</strong> property in our <strong class="source-inline">map</strong> loop. Insert the following code into the <strong class="source-inline">return</strong> statement:</p>
			<p class="source-code">{posts.map((post, i) =&gt; </p>
			<p class="source-code">  &lt;div key={post.id} className={'post ' + (post.id &lt; 0 ? </p>
			<p class="source-code">    'optimistic': '')}&gt;</p>
			<p class="source-code">    &lt;div className="header"&gt;</p>
			<p class="source-code">      &lt;img src={post.user.avatar} /&gt;</p>
			<p class="source-code">      &lt;h2&gt;{post.user.username}&lt;/h2&gt;</p>
			<p class="source-code">    &lt;/div&gt;</p>
			<p class="source-code">    &lt;p className="content"&gt;</p>
			<p class="source-code">      {post.text}</p>
			<p class="source-code">    &lt;/p&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">)}</p>
			<p>An example CSS style <a id="_idIndexMarker308"/>for this might look like this:</p>
			<p class="source-code">.optimistic {</p>
			<p class="source-code">  -webkit-animation: scale-up 0.4s cubic-bezier(0.390,</p>
			<p class="source-code">    0.575, 0.565, 1.000) both;</p>
			<p class="source-code">  animation: scale-up 0.4s cubic-bezier(0.390, 0.575,</p>
			<p class="source-code">    0.565, 1.000) both;</p>
			<p class="source-code">}</p>
			<p class="source-code">@-webkit-keyframes scale-up {</p>
			<p class="source-code">  0% {</p>
			<p class="source-code">    -webkit-transform: scale(0.5);</p>
			<p class="source-code">    transform: scale(0.5);</p>
			<p class="source-code">  }</p>
			<p class="source-code">  100% {</p>
			<p class="source-code">    -webkit-transform: scale(1);</p>
			<p class="source-code">    transform: scale(1);</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">@keyframes scale-up {</p>
			<p class="source-code">  0% {</p>
			<p class="source-code">    -webkit-transform: scale(0.5);</p>
			<p class="source-code">    transform: scale(0.5);</p>
			<p class="source-code">  }</p>
			<p class="source-code">  100% {</p>
			<p class="source-code">    -webkit-transform: scale(1);</p>
			<p class="source-code">    transform: scale(1);</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>CSS animations make your applications more modern and flexible. If you experience issues when <a id="_idIndexMarker309"/>viewing these in your browser, you may need to check whether your browser supports them.</p>
			<p>You can see the result in the following screenshot:</p>
			<div>
				<div id="_idContainer031" class="IMG---Figure">
					<img src="image/Figure_4.02_B17337.jpg" alt="Figure 4.2 – Loading optimistic response&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.2 – Loading optimistic response</p>
			<p>The loading spinner and the username are removed once the response arrives from our API, and the <strong class="source-inline">update</strong> function is executed again with the real data. You do not need to take care of removing the loading post yourself as this is done by Apollo automatically. Any spinner component from an <strong class="source-inline">npm</strong> package or GIF file can be used where I have inserted the loading animation. The file that I am using needs to be saved under the <strong class="source-inline">public</strong> folder, with the name <strong class="source-inline">loading.gif</strong>, so that it can be used through the CSS we added in the preceding code.</p>
			<p>Everything is now set up for sending new posts. The UI responds immediately and shows you the new post.</p>
			<p>However, what about new posts from your friends and colleagues? Currently, you need to reload the page to see them, which is not very intuitive. At the moment, we only add the posts that we <a id="_idIndexMarker310"/>send on our own but do not receive any information about new posts from other people. I will show you the quickest way to handle this in the following section.</p>
			<h3>Polling with Apollo Client</h3>
			<p><strong class="bold">Polling</strong> is nothing more than rerunning a request after a specified interval. This procedure is the simplest way <a id="_idIndexMarker311"/>to implement updates for our news feed. However, multiple issues are associated with polling, as follows:</p>
			<ul>
				<li>It is inefficient to send requests without knowing whether there is any new data. The browser might send dozens of requests without ever receiving a new post.</li>
				<li>If we directly send the initial request again, we will get all of the posts, including those that we are already showing to the user. </li>
				<li>When sending requests, the server needs to query the database and calculate everything. Unnecessary requests cost money and time.</li>
			</ul>
			<p>There are some use cases in which polling makes sense. One example is a real-time graph, in which every axis tick is displayed to the user, whether there is data or not. You do not need to use an interrupt-based solution, since you want to show everything. Despite the issues that come with polling, let's quickly run through how it works. All you need to do is fill in the <strong class="source-inline">pollInterval</strong> property in the configuration for the <strong class="source-inline">useQuery</strong> Hook, as follows:</p>
			<p class="source-code">const { loading, error, data } = useQuery(GET_POSTS, { pollInterval: 5000 });</p>
			<p>The request is resent every 5 seconds (5,000 <strong class="bold">milliseconds</strong>, or <strong class="bold">ms</strong>). </p>
			<p>As you might expect, there are other ways to implement real-time updates to your UI. One approach is to use <strong class="bold">server-sent events</strong>. A server-sent event is, as the name suggests, an event <a id="_idIndexMarker312"/>that is sent by the server to the client. The client needs to establish a connection to the server, but then the server can send messages to the client, in one <a id="_idIndexMarker313"/>direction. Another method is to use <strong class="bold">WebSockets</strong>, which allow for bidirectional communication between the server and the client. The most common method in relation to GraphQL, however, is to use <strong class="bold">Apollo Subscriptions</strong>. They are based <a id="_idIndexMarker314"/>on WebSockets and work <a id="_idIndexMarker315"/>perfectly with GraphQL. I will show you how Apollo Subscriptions work in <a href="B17337_10_Final_ASB_ePub.xhtml#_idTextAnchor183"><em class="italic">Chapter 10</em></a>, <em class="italic">Real-Time Subscriptions</em>.</p>
			<p>Let's continue and integrate the rest of our GraphQL API.</p>
			<h1 id="_idParaDest-93"><a id="_idTextAnchor116"/>Implementing chats and messages</h1>
			<p>In the previous chapter, we programmed a pretty dynamic way of creating chats and messages with <a id="_idIndexMarker316"/>your friends and colleagues, either one-on-one or in a group. There are <a id="_idIndexMarker317"/>some things that we have not discussed yet, such as authentication, real-time subscriptions, and friend relationships. First, however, we are going to work on our new skills, using React with Apollo Client to send GraphQL requests. It is a complicated task, so let's get started.</p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor117"/>Fetching and displaying chats</h2>
			<p>Our news feed is working <a id="_idIndexMarker318"/>as we expected. Now, we also want to cover chats. As with our feed, we need <a id="_idIndexMarker319"/>to query for every chat that the current user (or, in our case, the first user) is associated with.</p>
			<p>The initial step is to get the rendering working with some demo chats. Instead of writing the data on our own, as we did in the first chapter, we can now execute the <strong class="source-inline">chats</strong> query. Then, we can copy the result into the new file as static demo data, before executing the actual <strong class="source-inline">useQuery</strong> Hook.</p>
			<p>Let's get started, as follows:</p>
			<ol>
				<li value="1">Send the GraphQL query. The best options involve the Apollo Client Devtools if you already know how they work. Otherwise, you can rely on Postman, as you did previously. The code is illustrated in the following snippet:<p class="source-code">query {</p><p class="source-code">  chats {</p><p class="source-code">    id</p><p class="source-code">    users {</p><p class="source-code">      avatar</p><p class="source-code">      username</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p>The request looks a bit different from the one we tested with Postman. The chat panel that we are <a id="_idIndexMarker320"/>going to build only needs specific data. We do not need <a id="_idIndexMarker321"/>to render any messages inside of this panel, so we don't need to request them. A complete chat panel only requires the chat itself, the ID, the usernames, and the avatars. Later, we will retrieve all of the messages, too, when viewing a single chat.</p><p>Next, create a new file called <strong class="source-inline">Chats.js</strong>, next to the <strong class="source-inline">Feed.js</strong> file.</p><p>Copy the complete <strong class="source-inline">chats</strong> array from the response over to an array inside of the <strong class="source-inline">Chats.js</strong> file, as follows. Add it to the top of the file:</p><p class="source-code">const chats = [{</p><p class="source-code">  "id": 1,</p><p class="source-code">  "users": [{</p><p class="source-code">      "id": 1,</p><p class="source-code">      "avatar": "/uploads/avatar1.png",</p><p class="source-code">      "username": "Test User"</p><p class="source-code">    },</p><p class="source-code">    {</p><p class="source-code">      "id": 2,</p><p class="source-code">      "avatar": "/uploads/avatar2.png",</p><p class="source-code">      "username": "Test User 2"</p><p class="source-code">    }]</p><p class="source-code">  }</p><p class="source-code">];</p></li>
				<li>Import React ahead of the <strong class="source-inline">chats</strong> variable. Otherwise, we will not be able to render any React components. Here's the code you'll need to do this:<p class="source-code">import React, { useState } from 'react';</p></li>
				<li>Set up the functional <a id="_idIndexMarker322"/>React component. I have provided the basic markup here. Just <a id="_idIndexMarker323"/>copy it beneath the <strong class="source-inline">chats</strong> variable. I am going to explain the logic of the new component shortly:<p class="source-code">const usernamesToString = (users)  =&gt; {</p><p class="source-code">  const userList = users.slice(1);</p><p class="source-code">  var usernamesString = '';</p><p class="source-code">  for(var i = 0; i &lt; userList.length; i++) {</p><p class="source-code">    usernamesString += userList[i].username;</p><p class="source-code">    if(i - 1 === userList.length) {</p><p class="source-code">      usernamesString += ', ';</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">  return usernamesString;</p><p class="source-code">}</p><p class="source-code">const shorten = (text) =&gt; {</p><p class="source-code">  if (text.length &gt; 12) {</p><p class="source-code">    return text.substring(0, text.length - 9) + '...';</p><p class="source-code">  }</p><p class="source-code">  return text;</p><p class="source-code">}</p><p class="source-code">const Chats = () =&gt; {</p><p class="source-code">  return (</p><p class="source-code">    &lt;div className="chats"&gt;</p><p class="source-code">      {chats.map((chat, i) =&gt;</p><p class="source-code">        &lt;div key={chat.id} className="chat"&gt;</p><p class="source-code">          &lt;div className="header"&gt;</p><p class="source-code">            &lt;img src={(chat.users.length &gt; 2 ?</p><p class="source-code">             '/public/group.png' : </p><p class="source-code">               chat.users[1].avatar)} /&gt;</p><p class="source-code">            &lt;div&gt;</p><p class="source-code">              &lt;h2&gt;{shorten(usernamesToString</p><p class="source-code">                 (chat.users))}&lt;/h2&gt;</p><p class="source-code">            &lt;/div&gt;</p><p class="source-code">          &lt;/div&gt;</p><p class="source-code">        &lt;/div&gt;</p><p class="source-code">      )}</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">  )</p><p class="source-code">}</p><p class="source-code">export default Chats</p><p>The component is pretty basic, at <a id="_idIndexMarker324"/>the moment. The component maps over <a id="_idIndexMarker325"/>all of the chats and returns a new list item for each chat. Each list item has an image that is taken from the second user of the array, since we defined that the first user in the list is the current user, as long as we have not implemented authentication. We use a group icon if there are more than two users. When we have implemented authentication and we know the logged-in user, we can take the specific avatar of the user that we are chatting with.</p><p>The title displayed inside of the <strong class="source-inline">h2</strong> tag at the top of the chat is the name of the user. For this, I have implemented the <strong class="source-inline">usernamesToString</strong> method, which loops over all of the usernames and concatenates them into a long string. The result is passed into the <strong class="source-inline">shorten</strong> function, which removes all of the characters of the string that exceed the size of the maximum-12 characters.</p><p>One thing you may notice is that these helper functions are not within the actual component. I personally recommend having helper functions outside of the component <a id="_idIndexMarker326"/>as they will be recreated on every render of the <a id="_idIndexMarker327"/>component. If the helper function needs the scope of the component, keep it inside, but if they are pure functions just doing transformations here, keep them outside.</p></li>
				<li>Our new component needs some styling. Copy the new CSS to our <strong class="source-inline">style.css</strong> file.<p>To save the file size in our CSS file, replace the two <strong class="source-inline">.post .header</strong> styles to also cover the style of the chats, as follows:</p><p class="source-code">.post .header &gt; *, .chats .chat .header &gt; * {</p><p class="source-code">  display: inline-block;</p><p class="source-code">  vertical-align: middle;</p><p class="source-code">}</p><p class="source-code">.post .header img, .chats .chat .header img {</p><p class="source-code">  width: 50px;</p><p class="source-code">  margin: 5px;</p><p class="source-code">}</p><p>We must append the following CSS to the bottom of the <strong class="source-inline">style.css</strong> file:</p><p class="source-code">.chats {</p><p class="source-code">  background-color: #eee;</p><p class="source-code">  width: 200px;</p><p class="source-code">  height: 100%;</p><p class="source-code">  position: fixed;</p><p class="source-code">  top: 0;</p><p class="source-code">  right: 0;</p><p class="source-code">  border-left: 1px solid #c3c3c3;</p><p class="source-code">}</p><p class="source-code">.chats .chat {</p><p class="source-code">  cursor: pointer;</p><p class="source-code">}</p><p class="source-code">.chats .chat .header &gt; div {</p><p class="source-code">  width: calc(100% - 65px);</p><p class="source-code">  font-size: 16px;</p><p class="source-code">  margin-left: 5px;</p><p class="source-code">}</p><p class="source-code">.chats .chat .header h2, .chats .chat .header span {</p><p class="source-code">  color: #333;</p><p class="source-code">  font-size: 16px;</p><p class="source-code">  margin: 0;</p><p class="source-code">}</p><p class="source-code">.chats .chat .header span {</p><p class="source-code">  color: #333;</p><p class="source-code">  font-size: 12px;</p><p class="source-code">}</p></li>
				<li>To get the code <a id="_idIndexMarker328"/>working, we must also import the <strong class="source-inline">Chats</strong> component <a id="_idIndexMarker329"/>into our <strong class="source-inline">App.js</strong> file, as follows:<p class="source-code">import Chats from './Chats';</p></li>
				<li>Render the <strong class="source-inline">Chats</strong> component inside the return statement beneath the <strong class="source-inline">Feed</strong> component inside of the <strong class="source-inline">App.js</strong> file.<p>The current code generates the following screenshot:</p></li>
			</ol>
			<div>
				<div id="_idContainer032" class="IMG---Figure">
					<img src="image/Figure_4.03_B17337.jpg" alt="Figure 4.3 – Chats panel&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.3 – Chats panel</p>
			<p>On the right-hand side, you can see the chats panel that we have just implemented. Every chat is listed there as a separate row.</p>
			<p>The result isn't bad, but <a id="_idIndexMarker330"/>it would be much more helpful to at least have the last <a id="_idIndexMarker331"/>message of every chat beneath the username so that you could directly see the last content of your conversations.</p>
			<p>Just follow these instructions to get the last message into the chats panel:</p>
			<ol>
				<li value="1">The easiest way to do this would be to add the messages to our query again, but querying all of the messages for every chat that we want to display in the panel would not make much sense. Instead, we will add a new property to the chat entity, called <strong class="source-inline">lastMessage</strong>. That way, we will only get the newest message. We will add the new field to the GraphQL schema of our chat type, in the backend code, as follows:<p class="source-code">lastMessage: Message</p><p>Of course, we must also implement a function that retrieves the <strong class="source-inline">lastMessage</strong> field.</p></li>
				<li>Adding our new <strong class="source-inline">resolvers.js</strong> function inside the <strong class="source-inline">Chats</strong> property of the <strong class="source-inline">resolvers</strong> object orders all of the chat messages by ID and takes the first one. By definition, this should be the latest message in our chat. We need to resolve the promise on our own and return the first element of the array since we expect to return only one <strong class="source-inline">message</strong> object. If you return the promise directly, you will receive <strong class="source-inline">null</strong> in the response from the server because an array is not a valid response for a single message entity. The code is illustrated in the following snippet:<p class="source-code">lastMessage(chat, args, context) {</p><p class="source-code">  return chat.getMessages({limit: 1, order: [['id',</p><p class="source-code">    'DESC']]}).then((message) =&gt; {return message[0];</p><p class="source-code">  });</p><p class="source-code">},</p></li>
				<li>You can add the new <a id="_idIndexMarker332"/>property to our static demo data inside <strong class="source-inline">Chats.js</strong>. for <a id="_idIndexMarker333"/>every array item or rerun the GraphQL query and copy the response again. The code is illustrated here:<p class="source-code">"lastMessage": {</p><p class="source-code">  "text": "This is a third test message."</p><p class="source-code">}</p></li>
				<li>We can render the new message with a simple <strong class="source-inline">span</strong> tag beneath the <strong class="source-inline">h2</strong> header of the username. Copy it directly into the <strong class="source-inline">return</strong> statement, inside of our <strong class="source-inline">Chats</strong> component, as follows:<p class="source-code">&lt;span&gt;{chat?.lastMessage?.text}&lt;/span&gt;</p></li>
			</ol>
			<p>The result of the preceding changes renders every chat row with the last message inside of the chat. It should now look like this:</p>
			<div>
				<div id="_idContainer033" class="IMG---Figure">
					<img src="image/Figure_4.04_B17337.jpg" alt="Figure 4.4 – Last message&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.4 – Last message</p>
			<p>Since everything is displayed correctly from our test data, we can introduce the <strong class="source-inline">useQuery</strong> Hook in <a id="_idIndexMarker334"/>order to fetch all of the data from our GraphQL API. We can <a id="_idIndexMarker335"/>remove the <strong class="source-inline">chats</strong> array. Then, we will import all of the dependencies and parse the GraphQL query, as in the following code snippet:</p>
			<p class="source-code">import { gql, useQuery } from '@apollo/client';</p>
			<p class="source-code">const GET_CHATS = gql'{</p>
			<p class="source-code">  chats {</p>
			<p class="source-code">    id</p>
			<p class="source-code">    users {</p>
			<p class="source-code">      id</p>
			<p class="source-code">      avatar</p>
			<p class="source-code">      username</p>
			<p class="source-code">    }</p>
			<p class="source-code">    lastMessage {</p>
			<p class="source-code">      text</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}';</p>
			<p>To make use of the preceding parsed GraphQL query we will execute the <strong class="source-inline">useQuery</strong> Hook in our functional component, as follows:</p>
			<p class="source-code">const { loading, error, data} = useQuery(GET_CHATS);</p>
			<p class="source-code">if (loading) return &lt;div className="chats"&gt;&lt;p&gt;Loading...&lt;/p&gt;&lt;/div&gt;;</p>
			<p class="source-code">if (error) return &lt;div className="chats"&gt;&lt;p&gt;{error.message}&lt;/p&gt;&lt;/div&gt;;</p>
			<p class="source-code">const { chats } = data;</p>
			<p>When you have added the preceding lines of code to the beginning of the <strong class="source-inline">Chats</strong> function, it will then <a id="_idIndexMarker336"/>make use of the <strong class="source-inline">chats</strong> array returned within the GraphQL <a id="_idIndexMarker337"/>response. Before doing so it will, of course, check if the request is still loading or if there has been an error.</p>
			<p>We render the loading and error state within the <strong class="source-inline">div</strong> tag with the <strong class="source-inline">chats</strong> class so that the messages are wrapped within the gray panel.</p>
			<p>You should have run the <strong class="source-inline">addChat</strong> mutation from the previous chapter through Postman. Otherwise, there will be no chats to query for, and the panel will be empty. You have to also execute this mutation for any following chapter because we are not going to implement a special button for this functionality. The reason is that the logic behind it does not provide further knowledge about React or Apollo as it is just done by executing the <strong class="source-inline">addChat</strong> mutation at the correct location within Graphbook.</p>
			<p>Next, we want to display chat messages after opening a specific chat.</p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor118"/>Fetching and displaying messages</h2>
			<p>First, we have to store the chats <a id="_idIndexMarker338"/>that were opened by a click from the user. Every chat is <a id="_idIndexMarker339"/>displayed in a separate, small chat window, like on Facebook. Add a new state variable to save the IDs of all of the opened chats to the <strong class="source-inline">Chats</strong> component, as follows:</p>
			<p class="source-code">const [openChats, setOpenChats] = useState([]);</p>
			<p>To let our component <a id="_idIndexMarker340"/>insert or remove something from the <a id="_idIndexMarker341"/>array of open chats, we will add the new <strong class="source-inline">openChat</strong> and <strong class="source-inline">closeChat</strong> functions, as follows:</p>
			<p class="source-code">const openChat = (id) =&gt; {</p>
			<p class="source-code">  var openChatsTemp = openChats.slice();</p>
			<p class="source-code">  if(openChatsTemp.indexOf(id) === -1) {</p>
			<p class="source-code">    if(openChatsTemp.length &gt; 2) {</p>
			<p class="source-code">      openChatsTemp = openChatsTemp.slice(1);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    openChatsTemp.push(id);</p>
			<p class="source-code">  }</p>
			<p class="source-code">  setOpenChats(openChatsTemp);</p>
			<p class="source-code">}</p>
			<p class="source-code">const closeChat = (id) =&gt; {</p>
			<p class="source-code">  var openChatsTemp = openChats.slice();</p>
			<p class="source-code">  const index = openChatsTemp.indexOf(id);</p>
			<p class="source-code">  openChatsTemp.splice(index,1),</p>
			<p class="source-code">  setOpenChats(openChatsTemp);</p>
			<p class="source-code">} </p>
			<p>When a chat is clicked on, we will first check that it is not already open, by searching the ID using the <strong class="source-inline">indexOf</strong> function inside of the <strong class="source-inline">openChats</strong> array.</p>
			<p>Every time a new chat is opened, we will check whether there are three or more chats. If that is the case, we will remove the first opened chat from the array and exchange it with the new one by <a id="_idIndexMarker342"/>appending it to the array with the <strong class="source-inline">push</strong> function. We will only save the chat IDs, not the whole <strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>) object.</p>
			<p>For the <strong class="source-inline">closeChat</strong> function, we just revert this by removing the ID from the <strong class="source-inline">openChats</strong> array.</p>
			<p>The last step is to <a id="_idIndexMarker343"/>bind the <strong class="source-inline">onClick</strong> event to our component. In the <strong class="source-inline">map</strong> function, we <a id="_idIndexMarker344"/>can replace the wrapping <strong class="source-inline">div</strong> tag with the following line of code:</p>
			<p class="source-code">&lt;div key={"chat" + chat.id} className="chat" onClick={() =&gt; openChat(chat.id)}&gt;</p>
			<p>Here, we use <strong class="source-inline">onClick</strong> to call the <strong class="source-inline">openChat</strong> function, with the chat ID as the only parameter. At this point, the new function is already working but the updated state isn't used. Let's take care of that, as follows:</p>
			<ol>
				<li value="1">Add a surrounding wrapper <strong class="source-inline">div</strong> tag to the <strong class="source-inline">div</strong> tag with the <strong class="source-inline">chats</strong> class, as follows:<p class="source-code">&lt;div className="wrapper"&gt;</p></li>
				<li>In order to not mess up, the complete code we have written will introduce our first child component. To do so, create a file called <strong class="source-inline">Chat.js</strong> next to the <strong class="source-inline">Chats.js</strong> file.</li>
				<li>In this new file, import React and Apollo and parse the GraphQL query to get all the chat messages that were just opened, as follows:<p class="source-code">import React from 'react';</p><p class="source-code">import { gql, useQuery } from '@apollo/client';</p><p class="source-code">const GET_CHAT = gql'</p><p class="source-code">  query chat($chatId: Int!) {</p><p class="source-code">    chat(chatId: $chatId) {</p><p class="source-code">      id</p><p class="source-code">      users {</p><p class="source-code">        id</p><p class="source-code">        avatar</p><p class="source-code">        username</p><p class="source-code">      }</p><p class="source-code">      messages {</p><p class="source-code">        id</p><p class="source-code">        text</p><p class="source-code">        user {</p><p class="source-code">            id</p><p class="source-code">        }</p><p class="source-code">      }</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">';</p><p>As you can see in the preceding code snippet, we are passing the chat ID as a parameter to the GraphQL query.</p></li>
				<li>The actual component <a id="_idIndexMarker345"/>will then make use of the parsed query to get all the <a id="_idIndexMarker346"/>messages and render them inside a small container. The component should be added, as follows:<p class="source-code">const Chat = (props) =&gt; {</p><p class="source-code">  const { chatId, closeChat } = props;</p><p class="source-code">  const { loading, error, data } = useQuery(GET_CHAT, { </p><p class="source-code">    variables: { chatId }});</p><p class="source-code">  if (loading) return &lt;div className="chatWindow"&gt;</p><p class="source-code">    &lt;p&gt;Loading...&lt;/p&gt;&lt;/div&gt;;</p><p class="source-code">  if (error) return &lt;div className="chatWindow"&gt;</p><p class="source-code">    &lt;p&gt;{error.message}&lt;/p&gt;&lt;/div&gt;;</p><p class="source-code">  const { chat } = data;</p><p class="source-code">  return (</p><p class="source-code">    &lt;div className="chatWindow"&gt;</p><p class="source-code">      &lt;div className="header"&gt;</p><p class="source-code">        &lt;span&gt;{chat.users[1].username}&lt;/span&gt;</p><p class="source-code">        &lt;button onClick={() =&gt; closeChat(chatId)} </p><p class="source-code">          className="close"&gt;X&lt;/button&gt;</p><p class="source-code">      &lt;/div&gt;</p><p class="source-code">      &lt;div className="messages"&gt;</p><p class="source-code">        {chat.messages.map((message, j) =&gt;</p><p class="source-code">          &lt;div key={'message' + message.id}</p><p class="source-code">            className={'message ' + (message.user.id &gt;</p><p class="source-code">              1 ? 'left' : 'right')}&gt;</p><p class="source-code">            {message.text}</p><p class="source-code">          &lt;/div&gt;</p><p class="source-code">        )}</p><p class="source-code">      &lt;/div&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">  )</p><p class="source-code">}</p><p class="source-code">export default Chat</p><p>We execute the <strong class="source-inline">useQuery</strong> Hook to send the GraphQL request. We pass the <strong class="source-inline">chatId</strong> property from the <strong class="source-inline">props</strong> property so that the chat ID must be passed to this child component from the parent component. We also extract the <strong class="source-inline">closeChat</strong> function to call it from the child component, as the actual close button is within the chat container and not within the parent component.</p><p>Once the request arrives, we check again if the request is loading or has an error before actually rendering <a id="_idIndexMarker347"/>the complete chat. Then, we render a <strong class="source-inline">div</strong> tag with <a id="_idIndexMarker348"/>the <strong class="source-inline">chatWindow</strong> class name, in which all messages are displayed. Again, we are using the user ID to fake the class name of the messages. We will replace it when we get authentication running.</p></li>
				<li>As we have prepared the child component, we only need to add one line to the <strong class="source-inline">Chats.js</strong> file to import it, as follows: <p class="source-code">import Chat from './Chat';</p></li>
				<li>Then, to make use of our new <strong class="source-inline">Chat</strong> component, just add these three lines of code inside the <strong class="source-inline">div</strong> tag with the <strong class="source-inline">wrapper</strong> class:<p class="source-code">&lt;div className="openChats"&gt;</p><p class="source-code">  {openChats.map((chatId, i) =&gt; &lt;Chat chatId={chatId}</p><p class="source-code">  key={"chatWindow" + chatId} closeChat={closeChat} /&gt; )}</p><p class="source-code">&lt;/div&gt;</p><p>For each item in the <strong class="source-inline">openChats</strong> array, we will render the <strong class="source-inline">Chat</strong> component, which will then pass the <strong class="source-inline">chatId</strong> property and the <strong class="source-inline">closeChat</strong> function. The child component will then fetch the chat data on its own by the passed <strong class="source-inline">chatId</strong> property.</p></li>
				<li>The last thing missing is some styling. The CSS file is pretty big. Every message from the other users <a id="_idIndexMarker349"/>should be displayed on the left and our own messages <a id="_idIndexMarker350"/>on the right, to differentiate them. Insert the CSS code directly from the GitHub repository to save some time: <a href="https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-2nd-Edition/blob/main/Chapter04/assets/css/style.css">https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-2nd-Edition/blob/main/Chapter04/assets/css/style.css</a>.</li>
			</ol>
			<p>Take a look at the following screenshot:</p>
			<div>
				<div id="_idContainer034" class="IMG---Figure">
					<img src="image/Figure_4.05_B17337.jpg" alt="Figure 4.5 – Chat window&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.5 – Chat window</p>
			<p>We have forgotten something important. We can see all of the messages from our chat, but we are not able to add new messages, which is essential. Let's take a look at how to implement a chat message form in the next section.</p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor119"/>Sending messages through mutations</h2>
			<p>The <strong class="source-inline">addMessage</strong> mutation already exists in our backend, so we can add it to our <strong class="source-inline">Chat</strong> component. To implement <a id="_idIndexMarker351"/>this feature completely, follow these instructions:</p>
			<ol>
				<li value="1">Before adding it straightaway to the frontend too, we need to change the <strong class="source-inline">import</strong> statements so that we also have the <strong class="source-inline">useMutation</strong> and <strong class="source-inline">useState</strong> functions, as follows: <p class="source-code">import React, { useState } from 'react';</p><p class="source-code">import { gql, useQuery, useMutation } from '@apollo/client';</p></li>
				<li>Then, parse the mutation at the top, next to the other requests, like this:<p class="source-code">const ADD_MESSAGE = gql'</p><p class="source-code">  mutation addMessage($message : MessageInput!) {</p><p class="source-code">    addMessage(message : $message) {</p><p class="source-code">      id</p><p class="source-code">      text</p><p class="source-code">      user {</p><p class="source-code">        id</p><p class="source-code">      }</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">';</p></li>
				<li>For now, we will keep it simple and just add the text input to the <strong class="source-inline">Chat</strong> component directly, but we will take a look at a better way to do this in <a href="B17337_05_Final_ASB_ePub.xhtml#_idTextAnchor123"><em class="italic">Chapter 5</em></a>, <em class="italic">Reusable React Components and React Hooks</em>.<p>Now, we need to create a state variable where we save the current value of our new text input that <a id="_idIndexMarker352"/>we still need to create. We need to execute the <strong class="source-inline">useMutation</strong> Hook to send the GraphQL request to create a new chat message. Just add the following code for that:</p><p class="source-code">const [text, setText] = useState('');</p><p class="source-code">const [addMessage] = useMutation(ADD_MESSAGE, {</p><p class="source-code">  update(cache, { data: { addMessage } }) {</p><p class="source-code">    cache.modify({</p><p class="source-code">      id: cache.identify(data.chat),</p><p class="source-code">      fields: {</p><p class="source-code">        messages(existingMessages = []) {</p><p class="source-code">          const newMessageRef = cache.writeFragment({</p><p class="source-code">            data: addMessage,</p><p class="source-code">            fragment: gql'</p><p class="source-code">              fragment NewMessage on Chat {</p><p class="source-code">                id</p><p class="source-code">                type</p><p class="source-code">              }</p><p class="source-code">            '</p><p class="source-code">          });</p><p class="source-code">          return [...existingMessages, newMessageRef];</p><p class="source-code">        }</p><p class="source-code">      }</p><p class="source-code">    });</p><p class="source-code">  }</p><p class="source-code">});</p><p class="source-code">const handleKeyPress = (event) =&gt; {</p><p class="source-code">  if (event.key === 'Enter' &amp;&amp; text.length) {</p><p class="source-code">    addMessage({ variables: { message: { text, chatId </p><p class="source-code">      } } }).then(() =&gt; {</p><p class="source-code">      setText('');</p><p class="source-code">    });</p><p class="source-code">  }</p><p class="source-code">}</p><p>The state variable and mutation function look familiar, as you already know them. One special thing we do for the <strong class="source-inline">useMutation</strong> Hook is to again provide an <strong class="source-inline">update</strong> function to efficiently update the Apollo Client cache with the newest data. To do so, we <a id="_idIndexMarker353"/>must provide an <strong class="source-inline">id</strong> property to the <strong class="source-inline">cache.modify</strong> function. The reason we need to do that is that we want to update the <strong class="source-inline">messages</strong> array of one specific chat, but there could be multiple within our cache. To update the correct chat in the message, we use the <strong class="source-inline">cache.identify</strong> function and provide the current <strong class="source-inline">chat</strong> object, and it will automatically detect which chat to update.</p><p>The <strong class="source-inline">handleKeyPress</strong> function will handle the submission of the text input to trigger a mutation request.</p></li>
				<li>We must insert the markup needed to render a fully functional input. Put the input below the messages list, inside of the chat window. The <strong class="source-inline">onChange</strong> property executes while typing and will update the state of the component with the value of the input. Insert the following code:<p class="source-code">&lt;div className="input"&gt;</p><p class="source-code">  &lt;input type="text" value={text} onChange={(e) =&gt; </p><p class="source-code">    setText(e.target.value)} </p><p class="source-code">    onKeyPress={handleKeyPress}/&gt;</p><p class="source-code">&lt;/div&gt;</p><p>We use the <strong class="source-inline">onKeyPress</strong> event to handle <em class="italic">Enter</em> key hits so that we can send the chat message.</p></li>
				<li>Let's quickly add some CSS to our <strong class="source-inline">style.css</strong> file to make the input field look good, as follows:<p class="source-code">.chatWindow .input input {</p><p class="source-code">  width: calc(100% - 4px);</p><p class="source-code">  border: none;</p><p class="source-code">  padding: 2px;</p><p class="source-code">}</p><p class="source-code">.chatWindow .input input:focus {</p><p class="source-code">  outline: none;</p><p class="source-code">}</p></li>
			</ol>
			<p>The following screenshot <a id="_idIndexMarker354"/>shows the chat window, with a new message inserted through the chat window input:</p>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<img src="image/Figure_4.06_B17337.jpg" alt="Figure 4.6 – Messaging in the chat window&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.6 – Messaging in the chat window</p>
			<p>There are many features that we have not implemented and that we won't cover in this book—for example, it would make sense to have the username next to the chat message if it is a group chat, to show the avatar next to the message, and to update the <strong class="source-inline">lastMessage</strong> field in the chats panel once a new message is sent. The workload required to achieve a fully-fledged social network, such as Facebook, is impossible to cover in this book, but you are going to learn all of the required techniques, tools, and tactics so that you can approach this on your own. The next important feature that we are going to cover is pagination.</p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor120"/>Pagination in React and GraphQL</h1>
			<p>By <strong class="bold">pagination</strong>, most of the time, we mean the batch querying of data. Currently, we query for all posts, chats, and messages in our database. If you think about how much data Facebook stores inside <a id="_idIndexMarker355"/>one chat with your friends, you will realize that it is unrealistic <a id="_idIndexMarker356"/>to fetch all of the messages and data ever shared at once. A better solution is to use pagination. With pagination, we always have a page size, or a limit, of how many items we want to fetch per request. We also have a page or offset number, from which we can start to select data rows.</p>
			<p>In this section, we're going to look at how to use pagination with the posts feed, as it is the most straightforward example. In <a href="B17337_05_Final_ASB_ePub.xhtml#_idTextAnchor123"><em class="italic">Chapter 5</em></a>, <em class="italic">Reusable React Components and React Hooks</em>, we will focus on writing efficient and reusable React code. Sequelize offers the pagination feature by default. We can first insert some more demo posts so that we can paginate in batches of 10.</p>
			<p>We need to adjust the backend a bit before implementing it on our frontend, as follows:</p>
			<ol>
				<li value="1">Add a new <strong class="source-inline">RootQuery</strong> to our GraphQL schema, as follows:<p class="source-code">postsFeed(page: Int, limit: Int): PostFeed</p></li>
				<li>The <strong class="source-inline">PostFeed</strong> type only holds the <strong class="source-inline">posts</strong> field. Later on, in the development of the application, you can return more information, such as the overall count of items, the page count, and so on. The code is illustrated in the following snippet:<p class="source-code">type PostFeed {</p><p class="source-code">  posts: [Post]</p><p class="source-code">}</p></li>
				<li>Next, we must implement the <strong class="source-inline">PostFeed</strong> entity in our <strong class="source-inline">resolvers.js</strong> file. Copy the new resolver function over to the <strong class="source-inline">resolvers</strong> file, as follows:<p class="source-code">postsFeed(root, { page, limit }, context) {</p><p class="source-code">  var skip = 0;</p><p class="source-code">  if(page &amp;&amp; limit) {</p><p class="source-code">    skip = page * limit;</p><p class="source-code">  }</p><p class="source-code">  var query = {</p><p class="source-code">    order: [['createdAt', 'DESC']],</p><p class="source-code">    offset: skip,</p><p class="source-code">  };</p><p class="source-code">  if(limit) {</p><p class="source-code">    query.limit = limit;</p><p class="source-code">  }</p><p class="source-code">  return {</p><p class="source-code">   posts: Post.findAll(query)</p><p class="source-code">  };</p><p class="source-code">},</p></li>
			</ol>
			<p>We build a simple <strong class="source-inline">query</strong> object that Sequelize understands, which allows us to paginate our posts. The <strong class="source-inline">page</strong> number is multiplied by the <strong class="source-inline">limit</strong> parameter, to skip the calculated number of rows. The <strong class="source-inline">offset</strong> parameter skips the number of rows, and the <strong class="source-inline">limit</strong> parameter stops selecting rows after a specified number (which, in our case, is 10).</p>
			<p>Our frontend needs some <a id="_idIndexMarker357"/>adjustments to support pagination. Install a new <a id="_idIndexMarker358"/>React package with <strong class="source-inline">npm</strong>, which provides us with an infinite scroll implementation, as follows:</p>
			<p class="source-code"><strong class="bold">npm install react-infinite-scroll-component --save</strong></p>
			<p>Infinite scrolling is an excellent method to let a user load more content by scrolling to the bottom of the browser window.</p>
			<p>You are free to program this on your own, but we are not going to cover that here. Go back to the <strong class="source-inline">Feed.js</strong> file, replace the <strong class="source-inline">GET_POSTS</strong> query, and import the <strong class="source-inline">react-infinite-scroll-component</strong> package with the following code:</p>
			<p class="source-code">import InfiniteScroll from 'react-infinite-scroll-component';</p>
			<p class="source-code">const GET_POSTS = gql'</p>
			<p class="source-code">  query postsFeed($page: Int, $limit: Int) { </p>
			<p class="source-code">    postsFeed(page: $page, limit: $limit) { </p>
			<p class="source-code">      posts {</p>
			<p class="source-code">        id</p>
			<p class="source-code">        text</p>
			<p class="source-code">        user {</p>
			<p class="source-code">          avatar</p>
			<p class="source-code">          username</p>
			<p class="source-code">        }</p>
			<p class="source-code">      }</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">';</p>
			<p>Since the <strong class="source-inline">postsFeed</strong> query <a id="_idIndexMarker359"/>expects parameters other than the standard query from before, we <a id="_idIndexMarker360"/>need to edit our <strong class="source-inline">useQuery</strong> Hook and also introduce two new state variables. The changed lines are shown here:</p>
			<p class="source-code">const [hasMore, setHasMore] = useState(true);</p>
			<p class="source-code">const [page, setPage] = useState(0);</p>
			<p class="source-code">const { loading, error, data, fetchMore } = useQuery(GET_POSTS, { pollInterval: 5000, variables: { page: 0, limit: 10 } });</p>
			<p>In the preceding code snippet, we extract the <strong class="source-inline">fetchMore</strong> function from the <strong class="source-inline">useQuery</strong> Hook, which is used to <a id="_idIndexMarker361"/>run the pagination request to load more post items. We also <a id="_idIndexMarker362"/>create a <strong class="source-inline">hasMore</strong> state variable that will identify if there is more data to load from the GraphQL API, and the <strong class="source-inline">page</strong> variable will save the current page—or, to be exact, the number of pages we already scrolled.</p>
			<p>According to the new data structure defined in our GraphQL schema, we extract the <strong class="source-inline">posts</strong> array from the <strong class="source-inline">postsFeed</strong> object. You can do that by replacing the code with these two lines:</p>
			<p class="source-code">const { postsFeed } = data;</p>
			<p class="source-code">const { posts } = postsFeed;</p>
			<p>Replace the markup of the <strong class="source-inline">div</strong> tag of our current feed to make use of our new infinite scroll package, as follows:</p>
			<p class="source-code">&lt;div className="feed"&gt;</p>
			<p class="source-code">  &lt;InfiniteScroll</p>
			<p class="source-code">    dataLength={posts.length}</p>
			<p class="source-code">    next={() =&gt; loadMore(fetchMore)}</p>
			<p class="source-code">    hasMore={hasMore}</p>
			<p class="source-code">    loader={&lt;div className="loader" key={"loader"}&gt;</p>
			<p class="source-code">      Loading ...&lt;/div&gt;}</p>
			<p class="source-code">  &gt;</p>
			<p class="source-code">    {posts.map((post, i) =&gt;</p>
			<p class="source-code">      &lt;div key={post.id} className={'post ' + (post.id &lt; 0</p>
			<p class="source-code">        ? 'optimistic': '')}&gt;</p>
			<p class="source-code">        &lt;div className="header"&gt;</p>
			<p class="source-code">          &lt;img src={post.user.avatar} /&gt;</p>
			<p class="source-code">          &lt;h2&gt;{post.user.username}&lt;/h2&gt;</p>
			<p class="source-code">        &lt;/div&gt;</p>
			<p class="source-code">        &lt;p className="content"&gt;{post.text}&lt;/p&gt;</p>
			<p class="source-code">      &lt;/div&gt;</p>
			<p class="source-code">    )}</p>
			<p class="source-code">  &lt;/InfiniteScroll&gt;</p>
			<p class="source-code">&lt;/div&gt;</p>
			<p>The only thing that the infinite scroll package does is run the <strong class="source-inline">loadMore</strong> function provided in the <strong class="source-inline">next</strong> property, as long as <strong class="source-inline">hasMore</strong> is set to <strong class="source-inline">true</strong> and the user scrolls to the bottom of the browser <a id="_idIndexMarker363"/>window. When <strong class="source-inline">hasMore</strong> is set to <strong class="source-inline">false</strong>, the event listeners <a id="_idIndexMarker364"/>are unbound and no more requests are sent. This behavior is great when no further content is available, as we can stop sending more requests.</p>
			<p>We need to implement the <strong class="source-inline">loadMore</strong> function before running the infinite scroller. It relies on the <strong class="source-inline">page</strong> variable that we just configured. The <strong class="source-inline">loadMore</strong> function should look like this:</p>
			<p class="source-code">const loadMore = (fetchMore) =&gt; {</p>
			<p class="source-code">  const self = this;</p>
			<p class="source-code">  fetchMore({</p>
			<p class="source-code">    variables: {</p>
			<p class="source-code">        page: page + 1,</p>
			<p class="source-code">    },</p>
			<p class="source-code">    updateQuery(previousResult, { fetchMoreResult }) {</p>
			<p class="source-code">      if(!fetchMoreResult.postsFeed.posts.length) {</p>
			<p class="source-code">        setHasMore(false);</p>
			<p class="source-code">        return previousResult;</p>
			<p class="source-code">      }</p>
			<p class="source-code">      setPage(page + 1);</p>
			<p class="source-code">      const newData = {</p>
			<p class="source-code">        postsFeed: {</p>
			<p class="source-code">          __typename: 'PostFeed',</p>
			<p class="source-code">          posts: [</p>
			<p class="source-code">            ...previousResult.postsFeed.posts,</p>
			<p class="source-code">            ...fetchMoreResult.postsFeed.posts</p>
			<p class="source-code">          ]</p>
			<p class="source-code">        }</p>
			<p class="source-code">      };</p>
			<p class="source-code">      return newData;</p>
			<p class="source-code">    }</p>
			<p class="source-code">  });</p>
			<p class="source-code">}</p>
			<p>Let's quickly go through the preceding code, as follows:</p>
			<ol>
				<li value="1">The <strong class="source-inline">fetchMore</strong> function receives an object as a parameter.</li>
				<li>We specify the <strong class="source-inline">variables</strong> field, which is sent with our request, to query the correct page index of our paginated posts.</li>
				<li>The <strong class="source-inline">updateQuery</strong> function is <a id="_idIndexMarker365"/>defined to implement the logic to add <a id="_idIndexMarker366"/>the new data that needs to be included in our news feed. We can check whether any new data is included in the response by looking at the returned array length. If there are no posts, we can set the <strong class="source-inline">hasMore</strong> state variable to <strong class="source-inline">false</strong>, which unbinds all scrolling events. Otherwise, we can continue and build a new <strong class="source-inline">postsFeed</strong> object inside of the <strong class="source-inline">newData</strong> variable. The <strong class="source-inline">posts</strong> array is filled by the previous <strong class="source-inline">posts</strong> query result and the newly fetched posts. In the end, the <strong class="source-inline">newData</strong> variable is returned and saved in the client's cache.</li>
				<li>When the <strong class="source-inline">updateQuery</strong> function is finished, the UI rerenders accordingly.</li>
			</ol>
			<p>At this point, your feed is able to load new posts whenever the user visits the bottom of the window. We no longer load all posts at once, but instead, we only get the 10 most recent from our database. Every time you build an application with large lists and many rows, you have to add some kind of pagination, with either infinite scrolling or simple page buttons.</p>
			<p>We have now created a new problem. We can submit a new post with the GraphQL mutation if the React Apollo <a id="_idIndexMarker367"/>cache is empty, but the <strong class="source-inline">update</strong> function <a id="_idIndexMarker368"/>of the <strong class="source-inline">Mutation</strong> component will throw an error. Our new query is stored not only under its name but also under the variables used to send it. To read the data of a specific paginated <strong class="source-inline">posts</strong> request from our client's cache, we must also pass variables, such as the page index. Furthermore, we have a second layer, <strong class="source-inline">postsFeed</strong>, as the parent of the <strong class="source-inline">posts</strong> array. Change the <strong class="source-inline">update</strong> function to get it working again, as follows:</p>
			<p class="source-code">postsFeed(existingPostsFeed) {</p>
			<p class="source-code">  const { posts: existingPosts } = existingPostsFeed;</p>
			<p class="source-code">  const newPostRef = cache.writeFragment({</p>
			<p class="source-code">    data: addPost,</p>
			<p class="source-code">    fragment: gql'</p>
			<p class="source-code">      fragment NewPost on Post {</p>
			<p class="source-code">        id</p>
			<p class="source-code">        type</p>
			<p class="source-code">      }</p>
			<p class="source-code">    '</p>
			<p class="source-code">  });</p>
			<p class="source-code">  return {</p>
			<p class="source-code">    ...existingPostsFeed,</p>
			<p class="source-code">    posts: [newPostRef, ...existingPosts]</p>
			<p class="source-code">  };</p>
			<p class="source-code">}</p>
			<p>We actually just <a id="_idIndexMarker369"/>changed the <strong class="source-inline">posts</strong> property to <strong class="source-inline">postsFeed</strong> and updated the function <a id="_idIndexMarker370"/>to update the extracted <strong class="source-inline">posts</strong> array.</p>
			<p>Complex code such as this requires some useful tools to debug it. Continue reading to learn more about the Apollo Client Devtools.</p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor121"/>Debugging with the Apollo Client Devtools</h1>
			<p>Whenever you write or extend your own application, you have to test, debug, and log different things during <a id="_idIndexMarker371"/>development. In <a href="B17337_01_Final_ASB_ePub.xhtml#_idTextAnchor017"><em class="italic">Chapter 1</em></a>, <em class="italic">Preparing Your Development Environment</em>, we looked at the React Developer Tools for Chrome, while in <a href="B17337_02_Final_ASB_ePub.xhtml#_idTextAnchor032"><em class="italic">Chapter 2</em></a>, <em class="italic">Setting Up GraphQL with Express.js</em>, we explored Postman for testing APIs. Now, let's take a look at another tool.</p>
			<p>The <strong class="bold">Apollo Client Devtools</strong> is another Chrome extension, allowing you to send Apollo requests. While <a id="_idIndexMarker372"/>Postman is great in many ways, it does not integrate with our application and does not implement all GraphQL-specific features. The Apollo Client Devtools rely on the Apollo Client that we set up very early on in this chapter.</p>
			<p>Every request, either a query or mutation, is sent through the Apollo Client of our application. The developer tools also provide features such as autocomplete, for writing requests. They can show us the schema as it is implemented in our GraphQL API, and we also can view the cache. We will go over all four of the main windows offered by the extension.</p>
			<p>Let's take a look at an example here:</p>
			<div>
				<div id="_idContainer036" class="IMG---Figure">
					<img src="image/Figure_4.07_B17337.jpg" alt="Figure 4.7 – The Apollo Client Devtools&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.7 – The Apollo Client Devtools</p>
			<p>The <strong class="bold">GraphiQL</strong> window is shown in the preceding screenshot. The three panels in the preceding screenshot are described as follows:</p>
			<ul>
				<li>You can enter <a id="_idIndexMarker373"/>a request that you want to send in the left-hand text area. It can be a mutation or query, including the markup for inputs, for example. You can also enter the variables at the bottom.</li>
				<li>When sending a request, the response is shown in the middle panel.</li>
				<li>In the panel on the right, you can find the schema against which you will run requests. You can search through the complete GraphQL schema or manually step into the tree by clicking on the root types. This feature is useful when you forget what a specific field or mutation is called or which parameters it accepts.</li>
			</ul>
			<p>In the top bar, you will find the <strong class="bold">Prettify</strong> button, which tidies your query so that it is more readable. The <strong class="bold">Load from cache</strong> checkbox tries to retrieve any requested data directly from the cache, when possible. By clicking on the <strong class="bold">Play</strong> button, you run the query. These are all tools to test our GraphQL requests properly. The <strong class="bold">Build</strong> button will give you a small graphical interface to edit your query.</p>
			<p>Next, there is the <strong class="bold">Queries</strong> window, which is a helpful display. All of the queries that were ever run through the client are listed here, including the query string and variables. If you want to, you can rerun a query by clicking on the button at the top, as illustrated in the following screenshot:</p>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="image/Figure_4.08_B17337.jpg" alt="Figure 4.8 – Apollo Queries window&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.8 – Apollo Queries window</p>
			<p>The <strong class="bold">Mutations</strong> window is actually the same as the <strong class="bold">Queries</strong> window, but for mutations. The list is <a id="_idIndexMarker374"/>empty, as long as you have not sent any mutations.</p>
			<p>The last window is <strong class="bold">Cache</strong>. Here, you are able to see all of the data stored inside the Apollo cache, as illustrated in the following screenshot:</p>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<img src="image/Figure_4.09_B17337.jpg" alt="Figure 4.9 – Apollo Cache window&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.9 – Apollo Cache window</p>
			<p>In the left-hand panel, you can search through your data. The right-hand panel shows you the selected object in JSON.</p>
			<p>You can also see that I have <a id="_idIndexMarker375"/>tested the API a lot, as there are multiple <strong class="source-inline">Post</strong> objects in the left-hand panel. </p>
			<p class="callout-heading">Resetting the Apollo Cache</p>
			<p class="callout">For testing purposes, I submitted multiple posts via a mutation, but I deleted them to make sure that the screenshots were clear. Apollo did not delete the old posts that were deleted in the database, so they are still inside of the cache. You should delete this data when a user logs out of your application so that unauthorized users cannot access it.</p>
			<p>That is everything you need to know about the Apollo Client Devtools.</p>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor122"/>Summary</h1>
			<p>In this chapter, you learned how to connect your GraphQL API to React. To do this, we used Apollo Client to manage the cache and the state of our components and to update React and the actual DOM of the browser. We looked at how to send queries and mutations against our server. We also covered how to implement pagination with React and Apollo, and how to use the Apollo Client Devtools. </p>
			<p>After this chapter, you should be able to integrate the Apollo Client into your React application at any time. Furthermore, you should be able to make use of Apollo in every component of your application and be able to debug it.</p>
			<p>The next chapter will cover how to write reusable React components. Up to this point, we have written the code, but we haven't thought about readability or good practices very much. We will address these issues in the next chapter.</p>
		</div>
	</body></html>