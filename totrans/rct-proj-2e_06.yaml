- en: '*Chapter 6*: Building an Application Exploring TDD Using the React Testing
    Library and Cypress'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To keep your application maintainable, it is good practice to have testing set
    up for your project. Whereas some developers hate writing tests and therefore
    try to avoid writing them, other developers like to make testing the core of their
    development process by implementing a **Test-Driven Development** (**TDD**) strategy.
    There are many opinions about testing your applications and how to do this. Luckily,
    when building an application with React, many great libraries can help you with
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you'll use the **React Testing Library** tool to unit-test
    React applications. This library is maintained by the React community itself and
    ships with Create React App. It has lots of functionalities tailored to testing
    entire life cycles within your components and other React features. Therefore,
    the React Testing Library is a great fit for testing most React applications if
    you want to test whether functions or components behave as expected when they're
    given a certain input. Also, we'll be exploring another tool called **Cypress**
    that is perfect for end-to-end testing of our React application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing React state and Hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: End-to-end testing with Cypress
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will create a hotel review application build with React
    that has state management with the Context API. The React Testing Library will
    be added to perform unit and integration testing for this application, while Cypress
    is used for end-to-end testing. The application has been prebuilt and uses the
    same patterns that we've looked at in the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: The build time is 2 hours.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The application for this chapter builds upon an initial version, which can
    be found at [https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter06-initial](https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter06-initial).
    The complete code for this chapter can be found on GitHub: [https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter06](https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter06).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by downloading the initial project from GitHub and move into the root
    directory for this project, where you must run the `npm install` command. Since
    this project builds upon Create React App, running this command will install `react`,
    `react-dom`, and `react-scripts`. Also, `styled-components` and `react-router-dom`
    will be installed so that they can handle styling and routing for the application.
    Something else that will be installed is the React Test Library, which you will
    recognize with the `@testing-library/*` prefix. After finishing the installation
    process, you can execute the `npm start` command to run the application so that
    you can visit the project in the browser at `http://localhost:3000`. The initial
    application consists of a simple header and a list of hotels. These hotels have
    a title and meta information, such as a thumbnail. This page will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – The initial application](img/Figure_6.1_B17390.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – The initial application
  prefs: []
  type: TYPE_NORMAL
- en: 'If you click on any of the hotels in the list, a new page will open with a
    list of reviews for this hotel. By clicking the button at the top left of this
    page, you can move back to the previous page, and with the button at the top right,
    a page with a form where you can add a review will open. If you add a new review,
    this data will be stored in a global context and sent to a mock API server:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at the project''s structure, you''ll see that it''s using the same
    structure as the projects we created previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Important for this chapter is the `setupTests.js` file, which is used to configure
    the React Testing Library for this project. The entry point of this application
    is a file called `src/index.js`, which renders a component called `App`. In this
    `App` component, all the routes are declared and wrapped within a `Router` component.
    These routes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/`: This renders `Hotels`, with an overview of all of the hotels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/hotel/:hotelId`: This renders `HotelDetail`, with an overview of all reviews
    for a specific hotel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/hotel/:hotelId/new`: This renders `ReviewForm`, with a form to add new reviews
    to a specific hotel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The data is fetched from a mock server that was created using the free `db.json`
    file in the root directory of your project in GitHub. This file consists of a
    JSON object that has two fields, `hotels` and `reviews`, which creates multiple
    endpoints on a mock server. The ones you''ll be using in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://my-json-server.typicode.com/PacktPublishing/React-Projects-Second-Edition/hotels](https://my-json-server.typicode.com/PacktPublishing/React-Projects-Second-Edition/hotels)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://my-json-server.typicode.com/PacktPublishing/React-Projects-Second-Edition/reviews](https://my-json-server.typicode.com/PacktPublishing/React-Projects-Second-Edition/reviews)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `db.json` file must be present in the master branch (or default branch)
    of your GitHub repository for My JSON Server to work. Otherwise, you'll receive
    a **404 Not Found** message when trying to request the API endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: The hotel review application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will add unit and integration testing to the hotel review
    application that was created in Create React App. This application lets you add
    reviews to a list of hotels and controls this data from an application context.
    The React Testing Library will be used to render React components to test assertions
    on these components.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unit testing is an important part of your application, since you want to know
    that your functions and components behave as expected, even when you make code
    changes. For this, we're going to use the React Testing Library, an open source
    testing package for React applications that was created by the React community.
    With the React Testing Library, you can test assertions – for example, whether
    the output of a function matches the value you expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, we don''t have to install anything; it''s part of Create React
    App. If you look at the `package.json` file, you will see that a script is already
    there for running tests. Let''s see what happens if you execute the following
    command from your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return a message saying `No tests found related to files changed
    since last commit.`, which means our tests are running in watch mode and only
    running tests for files that have been changed. Under the hood, the Jest test
    runner is used to run our tests. By pressing the *A* key, you can run all the
    tests, even if you haven''t modified any files. If you press this key, the following
    message will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Jest will automatically check all our files within the `src` directory and look
    for test files. In the first part of this section, we'll show how we can create
    tests that can be run with Jest using the React Test Library.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a unit test
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since there are multiple ways that Jest can detect which file contains a test,
    let''s choose a structure where every component has a separate test file. This
    test file will have the same name as the file that holds the component, with the
    `.test` suffix. If we choose the `NavBar` component, we can create a new file
    called `NavBar.test.js` in the `src/components/NavBar` directory. Add the following
    code to this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The global `test` function from Jest is used here to define a test; the test
    assertions can be placed within the curly brackets. Alternatively, you can also
    use the `describe` or `it` functions to declare a (block) of tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we now run the `npm run test` command again, the Jest runner will find our
    first test and show the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the definition of a test, you can add assumptions such as `toEqual`
    or `toBe`, which check whether the value is exactly equal to something or whether
    the types just match respectively. The assumptions can be added within the callback
    of the `test` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If you still have the test script running in your terminal, you will see that
    Jest has detected your test. The test succeeds, since `1+2` is indeed `3`. Let''s
    go ahead and change the assumption to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, the test will fail, as the second assumption doesn't match. Although `1+2`
    still equals `3`, it's assumed that a string type with a value of `3` is returned,
    while in fact a number type is returned. If you're still running the `npm run
    test` command in the terminal, you can also see this explanation described there.
  prefs: []
  type: TYPE_NORMAL
- en: However, this assumption has no actual usage, as it doesn't test your component.
    To test your component, you need to render it. Rendering components so that you
    can test them will be handled in the next part of this section.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering a React component for testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Jest is based upon Node.js, meaning that it can''t use the browser or (virtual)
    DOM to render your component and test its functionality. Therefore, we''ll be
    using the React Testing Library to help us render these components. Create React
    App comes with this library by default, and the packages it uses can be found
    in the `package.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@testing-library/jest-dom`: Provides custom elements to test the DOM'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@testing-library/react`: The core package for the React Testing Library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@testing-library/user-events`: Provides methods to test user interactions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The React Testing Library can render React components for us so that we can
    write tests for them. The preceding packages will be used to create our tests:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our test file for the `NavBar` component, we can render the component with
    the `render` method from `@testing-library/react` and get the output of this component.
    With the Jest `toMatchSnapshot` assumption, we can test the structure of the component
    by creating a snapshot from this render and comparing it to the actual component
    every time this test is run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `src/components/NavBar` directory, a new directory called `__snapshots__`
    has now been created by Jest. Inside this directory is a file called `NavBar.test.js.snap`,
    which includes the snapshot. If you open this file, you will see that a rendered
    version of the `NavBar` component is stored here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The components that have been created with `styled-components` will be rendered
    as HTML elements with a class name prefixed by `sc-*`.
  prefs: []
  type: TYPE_NORMAL
- en: 'No actual values are being rendered by the React Testing Library since no props
    have been passed to the `NavBar` component. You can inspect how the snapshot works
    by passing, for instance, a `title` prop to the component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next time the tests are run, a new snapshot will be added to the `src/components/NavBar/__snapshots__/NavBar.test.js.snap`
    file. This snapshot has a value rendered for the `title` prop. If you change the
    `title` prop that is displayed by the `NavBar` component in your test file, the
    rendered component will no longer match the snapshot. You can try this by changing
    the value for the `title` prop in the test scenario:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Jest will return the following message in the terminal, where it specifies
    which lines have changed in comparison to the snapshot. In this case, the title
    that''s being displayed is no longer `Test Application` but `Test Application
    #2`, which doesn''t match the title in the snapshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: By pressing the *U* key, you can update the snapshot to handle this new test
    scenario. This is an easy way to test the structure of your component and see
    whether the title has been rendered. With the preceding test, the initially created
    snapshot still matches the rendered component for the first test. Also, another
    snapshot was created for the second test, where a `title` prop was added to the
    `NavBar` component.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can do the same for the other props that are passed to the `NavBar` component,
    which renders differently if you do or don't pass certain props to it. Next to
    `title`, this component takes `goBack` and `openForm` as props, which can also
    be tested.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve now created two tests for our `NavBar` component, which is a good start.
    But something else that Jest does is show you how many lines of code have been
    covered by your tests. The higher your testing coverage, the more reason to assume
    your code is stable. You can check the test coverage of your code by executing
    the `test` script command with the `--coverage` flag and an extra `--` in between,
    or use the following command in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will run your tests and generate a report with all the test coverage
    information about your code per file. After adding the tests for `NavBar`, this
    report will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Testing coverage only tells us something about the lines and the functions of
    your code that have been tested and not their actual implementation. Having a
    test coverage of 100% doesn't mean that there aren't any bugs in your code, as
    there will always be edge cases. Also, reaching a testing coverage of 100% means
    that you may end up spending more time on writing tests than on actual code. Usually,
    a testing coverage above 80% is considered good practice.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the test coverage for the component is 60%, meaning that most
    of the lines are covered in your test. To go to a 100% coverage, we will also
    need to add tests for the other props that are used in the `NavBar` component
    to render the buttons to return to the previous stage or the `form` component.
    Also, the coverage for the `Button` component is 100% due to no actual elements
    being rendered there.
  prefs: []
  type: TYPE_NORMAL
- en: However, this method of testing with snapshots will create a lot of new files
    and lines of code. We'll look at other ways we can test our components in the
    next part of this section.
  prefs: []
  type: TYPE_NORMAL
- en: Testing components with assertions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In theory, snapshot testing is not necessarily a bad practice; however, your
    files can get quite big over time. Also, since you're not explicitly telling Jest
    what part of the component you want to test, you might need to update your code
    regularly.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, using snapshots isn't the only method we can use to test whether our
    components are rendering the correct props. Instead, we can also directly compare
    which props are being rendered by checking the value of the component and making
    assertions. The big advantage of testing with assertions is that you can test
    a lot without having to dig deeper into the logic of the component you're testing.
    For instance, you can see what the children that are being rendered look like.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s change our second snapshot test for the `NavBar` component to compare
    the impact on the test coverage. We''ll need to import the `screen` method from
    the React Testing Library, which is used to scan the rendered components. Instead
    of making a snapshot of the whole component and finding the title in there, we
    will look for any heading components (such as `h2`) and check whether their value
    is equal to the prop that we set on `NavBar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve used the `getByRole` React Testing Library method to find the `Title`
    component in the `NavBar` component, and the `toHaveTextContent` method to check
    whether the text inside `Title` is equal to our prop. The test still passes and
    also allows us to delete the snapshot, as we''re now using an assumption to test
    this part of the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'By pressing *U* or running `npm run test` with the `-u` flag, the snapshot
    for the `NavBar` component is removed by Jest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The test coverage of the `NavBar` component should still be 60%, as we continued
    testing whether the `title` prop was presented and rendered, which you can check
    by running again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: However, the `NavBar` component doesn't just take the `title` prop – it also
    takes the `goBack` and `openForm` functions as props. You also want to test whether
    these functions are triggered when you click on any of the buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test these props, we need to create a mock function that we can pass as
    a prop to `NavBar` and mock the user click events to test whether this function
    is being called. The `fireEvent` method from the React Testing Library can be
    used to mock user events, and with Jest, we can mock a function and check whether
    that function is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'By running the preceding test, a click on the *back* button in `NavBar` will
    be simulated, and Jest will check whether the mocked function is being called.
    The same can be done for the `openForm` prop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The mocked function for both the `goBack` and `openForm` props are the same,
    so we need to check whether this function is called twice after clicking the open
    form button. By testing the user events on these two buttons, we''ve tested 100%
    of the `NavBar` component, as you can also see in the coverage report:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we've created unit tests that will test a specific part of
    our code. However, it can be interesting to test how different parts of our code
    work together. For this, we'll add integration tests to test our state management
    and Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: Testing React state and Hooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The tests that we've created all render components without state management,
    but with the React Testing Library, we also have the option to test state and
    Hooks. In our setup, the pages that are rendered by our router are wrapped in
    an application context component. If we want to test the page components, we need
    to make sure that the data for these pages is being mocked or stubbed, so the
    integration of this component with the state can be tested.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good example of where we can test this is the `Hotels` component, which renders
    the list of hotels that were returned by the context:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As always, the starting point is to create a new file with the `.test` suffix
    in the same directory where the component we want to test is located. Here, we
    need to create the `Hotels.test.js` file in the `src/pages` directory. In this
    file, we need to add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding test imports the context object that the `Hotels` component uses
    to render the page and creates a wrapper function that creates a provider on the
    `HotelsContext`. To this `Provider`, we've added the mock values for the context
    that is used by the `Hotels` component. Our test assertion tries to find an element
    with the `Loading…` text value and checks whether it exists. As the value for
    `loading` in our context is `true`, that element can indeed be found.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To run just a selection of tests, you can press *P* after running the `npm run
    test` command; you can now type a string in the terminal that will be used to
    pattern-match the test files.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test whether the hotels are being rendered when data is present in the context,
    we need to mock this data in a new test in the `Hotels.test.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding mocked context value, the value for `loading` is set to `false`,
    and mocked hotels are also added. Note that we also wrapped the Provider with
    `BrowserRouter` from React Router, as the `Hotels` component uses a `Link` component
    to make the hotels clickable.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test whether the hotels are being rendered, we need to add a test assertion
    to check whether the `loading` message is gone and whether the correct number
    of links to hotels are rendered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `getBy` methods we used before will throw an error when an element cannot
    be found; to test whether something is not rendered, we need to use the `queryBy`
    methods instead. Also, we need to check whether two `Link` components are present
    by looking for the `link` role and counting them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `useEffect` Hook in the `Hotels` component can also be tested to check
    whether the `fetchHotels` function is being called if there are no hotels in the
    context. Therefore, we can edit the first test by importing the `waitFor` method
    from the React Testing Library and altering the context value slightly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also add the test assertion to wait for the mock function to be called.
    Here, we specifically state that the mocked function, which is `fetchHotels` from
    `HotelsContext`, is called only once. In our `Hotels` component, `useEffect` has
    a check to only fetch the hotels if there is no data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this test, we've tested both the context in the `Hotels` component and
    the `useEffect` Hook to fetch hotel data in that function.
  prefs: []
  type: TYPE_NORMAL
- en: 'After running the tests again with the `--coverage` flag, we will be able to
    see what impact writing this integration test has on our coverage. Since an integration
    test not only tests one specific component but multiple components at once, the
    testing coverage for `Hotels` will be updated. This test also covers the `HotelItem`
    component, which we will be able to see in the coverage report after running `npm
    run test --coverage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: According to Jest, the coverage for `Hotels` is 100%. The test coverage for
    `HotelItems` has also reached 100%. This means that we can skip writing unit tests
    for `HotelItem`, assuming that we only use this component within the `Hotels`
    component. The `HotelsContext` component with our context already has a small
    amount of coverage through testing it from the `Hotels` component. To get a higher
    coverage, we can test even more, such as testing how the context itself or the
    `useReducer` Hook in the context is behaving.
  prefs: []
  type: TYPE_NORMAL
- en: The only downside of having integration tests over unit tests is that they're
    harder to write, as they usually contain more complex logic. Also, these integration
    tests will run slower than unit tests because of them having more logic and bringing
    together multiple components. In the final section of this chapter, we'll be adding
    an end-to-end test that will test the entire application from a user perspective
    using Cypress.
  prefs: []
  type: TYPE_NORMAL
- en: End-to-end testing with Cypress
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we've covered both unit and integration testing with the React Testing
    Library that tests our code in an isolated setting. But in order to make sure
    that our application is tested as a whole, we can also write an end-to-end test
    to cover certain aspects of our application from start to finish. End-to-end tests
    are considered more time-consuming to write and run than unit or integration tests.
    It's recommended to have more unit and integrations tests for your project than
    end-to-end tests, and think about what aspects of your application you really
    want to have tested.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add end-to-end tests, we''ll install the open source test tool Cypress,
    which can be used to write and run such tests. Adding Cypress to the project requires
    several steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the library from npm in our project by running the following command
    from the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After completing the installation, the script to run Cypress needs to be added
    to the `package.json` file so that it can be started with a single command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can now run the `npm run cypress` command to start Cypress. Make sure to
    do this in a new tab in the terminal, as you need to have both the application
    and Cypress running simultaneously. If this is the first time that you''re running
    Cypress, it will validate whether it''s able to run on your system. When all goes
    well, Cypress will open and create a new directory called `cypress` in our project,
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Cypress running for the first time](img/Figure_6.2_B17390.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – Cypress running for the first time
  prefs: []
  type: TYPE_NORMAL
- en: 'Cypress has created example tests in the `cypress/integration/examples` directory,
    which you can use to learn more about how the library is working. Otherwise, you
    can delete these, as they will clutter the Cypress runner when we add new tests.
    In the `cypress/integration` directory ,we can add a new end-to-end test for our
    project called `hotels.spec.js` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can run this test by pressing on it in the Cypress runner, after which
    the test will run in a browser. Which browser it uses depends on what you''ve
    selected at the top right in Cypress. This test will open the application within
    a browser and test it with Cypress, giving the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Cypress rendering our application in a test'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.3_B17390.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.3 – Cypress rendering our application in a test
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You need to make sure that you have both Cypress and the application running
    in your terminal. This means that one terminal tab must have `npm run cypress`
    running and the other `npm start`. If you don't have the application running,
    you'll get an error that the web page is not available.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding test will just render our application, without making any assertions.
    To test the application using Cypress, we need to use any of the assertions that
    are provided by the library. Using these assertions, we'll write an end-to-end
    test that checks the entire flow, from visiting the application to adding a review
    for a hotel. This way, we have tested the most critical process of our application,
    namely reviewing hotels.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, we need to change the `hotels.spec.js` file so that it will open
    the application and navigate to a hotel page, and on that page, click on the button
    to open the form. After filling in this form, we want our test to submit the form
    and check whether our review has been added. Follow these steps to make these
    changes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'All the tests in the `hotels.spec.js` file will start by visiting the application
    in the browser, so it can click on any of the hotels listed on this page. After
    clicking on a hotel, we need to verify whether the location in the browser has
    changed by using the `cy.location` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Running this test will validate that you can click on a hotel and navigate to
    the correct page, which you can check in the Cypress runner.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'When you need to visit many URLs over different development environments, you
    can also define `baseUrl` in a `cypress.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`{`'
  prefs: []
  type: TYPE_NORMAL
- en: '`"id": "http://localhost:3000",`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second test, we tell Cypress to find the button with the `+ Add Review`
    text and click on it, which should change the browser''s location to the page
    to add the review. This page is located at the `/hotel/:hotelId/new` route and
    includes the `new` string. Note that we don''t have to navigate to the application
    anymore, as this test builds upon the previous test and is therefore already at
    the correct page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the preceding test, Cypress will look for a button that contains a specific
    word, something that is not future-proof if someone changes the content of the
    button. Deciding which selector to use (`id`, `class`, or content) is important
    when writing tests. To prevent failing tests, you can also add the `data-cy`,
    `data-test`, or `data-testid` attributes to your elements. Therefore, we need
    to change how the `Button` component is rendered in `src/components/NavBar`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `cypress/integrations/hotels.spec.js` Cypress test file, we can look
    for the `data-cy` attribute instead of using the content of the button as a selector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A third test to fill in the form to add the review and submit it can also be
    added to this file. Using the `cy.get` command, Cypress can find the `form` element
    on this page, and the `within` method is used to find the `input` elements inside
    the form. It will search for the name of the `input` field, add a value to it,
    and finally submit `button` inside the form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we need to write a test that checks the hotel details page again and
    tries to find the new review that we''ve added. To find this review, we need to
    search the page for the contents of the review that was just added by Cypress;
    also, we need to add a `wait` command to make sure that the review has been processed
    and displayed on the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By adding this final test to Cypress, we've tested the most important scenario
    of our application, which you can expand even more by adding tests for edge cases
    such as error messages.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: We didn't add a `data-cy` attribute to the elements that display the review,
    which is something that you could add yourself. As we're aware of the content
    that we just added, it's safe to assume that we don't need a complicated selector
    for this.
  prefs: []
  type: TYPE_NORMAL
- en: You can add more functionalities, such as mocking the API requests and responses,
    as the preceding test is using the same API as the application itself. In this
    scenario, there's nothing wrong with that, as the API we're using is already a
    mock API. If you're working in a production environment, you will want to replace
    that with a mocked response that can be generated by Cypress.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, we need to add a `beforeEach` Hook to our test file that intercepts
    the API calls and replaces the response with a mocked value. The format of that
    mocked value should be equal to the format of the actual API. Luckily, our API
    is being populated from the `db.json` file that you can find in the repository
    for this book. From the contents of that file, you can take the data for the hotels
    field and paste it into two separate files inside the `cypress/fixtures` directory.
    Let''s look at the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first one can be called `hotels.json` and needs to have an array of objects
    with hotel details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The second fixture needs to have a single object that replaces the API request
    for a single hotel, in a file called `hotel.json`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Intercepting the calls to the actual API can be done from the test file in
    `cypress/integrations/hotels.spec.js` by adding a `beforeEach` Hook and the `cy.intercept`
    method. For the `hotels` and `hotels/*` endpoints, it can return the fixture,
    and the `reviews` endpoint can return an empty array, as Cypress will add a review
    itself:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By opening the Cypress runner, you can see that our tests are now being executed
    with the data from the fixtures, as the API calls are being intercepted.
  prefs: []
  type: TYPE_NORMAL
- en: The tests we've created in this section gave you a good start on writing end-to-end
    tests for React applications with Cypress. Also, Cypress can be used to do visual
    regression testing for your application or to test API responses.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered testing for React applications using the React Testing
    Library in combination with Jest. Both packages are a great resource for any developer
    that wants to add test scripts to their application, and they work very well with
    React. The advantages of having tests for your application were discussed in this
    chapter, and hopefully, you now know how to add test scripts to any project. The
    differences between unit tests and integration tests were shown, and you've also
    learned how to write end-to-end tests with Cypress.
  prefs: []
  type: TYPE_NORMAL
- en: Since the application that was tested in this chapter has the same structure
    as the applications from previous chapters, the same testing principles can be
    applied to any of the applications we've built in this book.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will combine a lot of the patterns and libraries we've already
    used in this book, as we'll be creating a full-stack e-commerce store with React,
    GraphQL, and Apollo.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information, refer to the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The React Testing Library: [https://testing-library.com/docs/react-testing-library/intro/](https://testing-library.com/docs/react-testing-library/intro/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cypress: [https://docs.cypress.io/](https://docs.cypress.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
