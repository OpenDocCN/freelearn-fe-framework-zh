- en: Chapter 9. Creating a Shared App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Isomorphic apps are JavaScript applications that can run on both client side
    and server side. The idea is that the backend and the frontend should share as
    much code as possible. With a server-rendered app, you can also present content
    up front without waiting for the JavaScript code to initialize.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter is divided into two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: In the first part, we'll extend the setup we created in [Chapter 8](ch08.html
    "Chapter 8. Deploying Your App to the Cloud"), *Deploying Your App to the Cloud*,
    so that it supports the pre-rendering of your components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the second part, we'll add Redux and populate your app with data from the
    server environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In brief, these are the topics we''ll cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Server rendering versus client rendering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terminology confusion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying the setup to enable server rendering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Streaming your pre-rendered components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying a server-rendered app to the cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server rendering versus client rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.js makes it easy to write JavaScript on your backend as well as frontend.
    We've been writing server code all along, but until now, all our apps have been
    client-rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering your app as a client-rendered app means bundling your JavaScript files
    and distributing it with your images, CSS, and HTML files. It can be distributed
    on any kind of web server running on any kind of operating system.
  prefs: []
  type: TYPE_NORMAL
- en: 'A client-rendered app is generally loaded in two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The initial request loads `index.html` and the CSS and JavaScript files either
    synchronously or asynchronously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Typically, the app then makes another request and generates the appropriate
    HTML based on the server response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With a server-rendered app, the second step is generally omitted. The initial
    requests load `index.html`, the CSS, the JavaScript, and the content in one go.
    The app is in memory and ready to serve, with no need to wait for the client to
    parse and execute the JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: You'll sometimes hear the argument that a server-rendered app is a necessity
    to serve users who don't have JavaScript on their device or simply have it turned
    off. This is not a valid argument, because all surveys and statistics known to
    me put the number of users at around 1 percent.
  prefs: []
  type: TYPE_NORMAL
- en: Another argument is to support search bots, who typically struggle with parsing
    JavaScript-based content. This argument is slightly more valid, but major players
    such as Google and Bing are able to do this, although you may need to add a meta
    tag in order for the content to be indexed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Verifying that bots can read your site**'
  prefs: []
  type: TYPE_NORMAL
- en: You can use Google's own **Fetch as Googlebot** to verify that your content
    is being indexed properly. The tool is available at [https://www.google.com/webmasters/tools/googlebot-fetch](https://www.google.com/webmasters/tools/googlebot-fetch).
    Alternatively, you can refer to [http://www.browseo.net/](http://www.browseo.net/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The benefits of a server-rendered app are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Users with a slow computer will not have to wait for the JavaScript code to
    parse.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It also provides us with predictable performance. You can measure the time it
    takes to load your web page when you have control of the rendering process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Doesn't require the user to have a JavaScript runtime on their device.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Makes it easier for search bots to crawl your page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The benefits of a client-rendered app are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Less setup to deal with
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No concurrency issues between the server and the client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generally easier to develop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a server-rendered app is more involving than writing a client-rendered
    app, but it comes with tangible benefits. We'll start by making our scaffold ready
    for the cloud before moving on to add server rendering. First of all, we need
    to clear up the terminology, as in the wild, you'll encounter several different
    terms to describe apps that share code between the server and the client.
  prefs: []
  type: TYPE_NORMAL
- en: Terminology confusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term **isomorphic** is made up of the Greek words *isos* for *equal* and
    *morph* for *shape*. The idea is that by using the term isomorphic, it's easy
    to understand this as code that's shared between the server and client.
  prefs: []
  type: TYPE_NORMAL
- en: In math, isomorphism is a one-to-one mapping function between two sets that
    preserve the relationships between the sets.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, an isomorphic code example would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: These two functions are not the same, but they produce the same result and are
    thus isomorphic for multiplication.
  prefs: []
  type: TYPE_NORMAL
- en: Isomorphism may be a good term in math, but it's clearly not such a good fit
    for developing web apps. We've used the term here as the headline for this chapter
    because it's currently a recognized term for server-rendered apps in the JavaScript
    community. However, it's not a very good term, and the hunt is on for a better
    one.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a search for a replacement, the term **Universal** has cropped up as the
    choice of many. Yet, this is not quite ideal either. For one, it''s easy to misunderstand.
    The closest definition of Universal in relation to web apps is this: used or understood
    by all. Remember, the goal is to describe code sharing. But, Universal can also
    be understood as a term describing JavaScript apps that can run anywhere. This
    includes not only the Web, but also native devices and operating systems. This
    confusion is prevalent throughout the web development sphere.'
  prefs: []
  type: TYPE_NORMAL
- en: The third term is **Shared**, as in Shared JavaScript. This is more appropriate
    because it implies there is some meaning to your code. When you're writing Shared
    JavaScript, it's implied that the code you write is intended to be used in more
    than one environment.
  prefs: []
  type: TYPE_NORMAL
- en: When searching through the code on the Web, you'll find all these terms used
    interchangeably to describe the same pattern of developing web apps. Proper naming
    is important because it makes your code more understandable to the outside audience.
    Buzzwords are nice and sounds good on your resume, but the more buzzwords you
    use, the harder it will be for your code base to understand it.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll use the term server-rendered for code that renders HTML
    prior to serving it to the user. We'll use the term client-rendered for code that
    defers the rendering of the HTML to the user's device. And finally, we'll use
    the term shared code to describe code that is used interchangeably on both the
    server and the client.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a server-rendered app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developing a Shared app in ReactJS requires more work than just building a client-rendered
    app. It also necessitates that you think about your data flow requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two components that together make it possible to write a server-rendered
    app in ReactJS. It can be thought of like an equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Pre-rendering components in your server instance + One-way data flow from
    the server to your components = good app and happy users*'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll look at the first part of the equation. We'll tackle
    the data flow issue in the final section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Adding packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''re going to need a few more packages from `npm` to add them to our dependencies
    section. This is the list of dependencies that we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Add any missing packages to `package.json` and update it by executing `npm install`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding CSS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll need to style our page, so we''ll use a subset of what we used when
    developing **Reactagram** in [Chapter 7](ch07.html "Chapter 7. Reactagram"), *Reactagram*.
    Replace the contents of `assets/app.css` with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Adding Bootstrap CDN to index.html
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since we''re adding `react-bootstrap`, we need to add the Bootstrap CDN files
    as well. Open `assets/index.html` and replace it with this content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Creating components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can''t make an app without some content, so let''s add a few pages and a
    route hierarchy. Start by removing `index.jsx` from the `source` folder and `index-production.html`
    from the `assets` folder. The tree structure will look like this when we''re finished
    with this part of the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We need to be diligent in how we structure our app in order to make it easy
    to understand and notice how everything fits together with regards to client-side
    and server-side rendering.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding the source code for `client/index.jsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The code structure should be very familiar at this point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add our routes. Create `routes/index.jsx` and add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The routes will respond to `/`, `/about`, and `/calculator`, and anything else
    will be routed to the `error` component. The `IndexRoute` function routes the
    app to the `Welcome` component if you visit the app without specifying a route
    (for instance, `http://localhost:8080` without the ending slash).
  prefs: []
  type: TYPE_NORMAL
- en: The routes are assigned to a few basic views that we're going to create next.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `shared/views/layout.jsx` and add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll fetch the title from the `Settings` component. The following component
    will create a link path that you can use as a navigation element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameter `setDocumentTitle` is an argument that will make the component
    change the document title of the window tab to the name of the `child` component
    you''re on, let''s put the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `shared/views/app.jsx` and add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This component creates a simple list with two links. The first goes to the `About`
    component and the second to the `Calculator` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `shared/views/error.jsx` and add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This component will show up if you manually enter a wrong path in the URL locator
    of your browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `shared/views/about.jsx` and add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `About` component is a simple placeholder component in our app. You can
    use it to present some information about your app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `shared/views/calculator.jsx` and add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `getInitialState` element is deprecated when using ES6 classes, so we''ll
    need to set out the initial state in the constructor. We can do this by first
    making an empty `state` variable attached to `this`. Then, we add three states:
    `_input` is the calculator input text box, `_prev` is used to hold the number
    to calculate, `_toZero` is a flag that will be used to zero out the input when
    doing calculations, and `_symbol` is the mathematical operation symbol (plus,
    minus, division, and multiply), let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'These three functions alter the input number directly. Let''s move on to the
    next function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This function is invoked when you press the **Calculate** button (**=**). It
    will check whether the user has activated a mathematical symbol, and if so, it
    will check which symbol is active and perform the calculation on the stored number
    and the current number, let''s take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If the input number needs to be turned into zero, this operation will do that
    and reset the `_toZero` flag. Now we move to `isNaN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `isNaN` is an efficient way to check whether the variable is a number.
    If not, it''s a mathematical symbol and we handle this by storing the symbol in
    the state, requiring the input number to be made zero (so that we don''t calculate
    the wrong numbers) and set the current input as the `_prev` value (to be calculated
    on), let''s take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If it''s a number, we add it to the `_input` state, let''s take a look at the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When using `React.createClass`, all functions are automatically bound to the
    component. Since we''re using ES6 classes, we need to bind our functions manually,
    let''s take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Some characters are difficult to locate on the standard keyboard. Instead,
    we can render it using the Unicode character code. A list of character code and
    their respective images is readily available on the Internet, let''s take a look
    at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the **Calculator** page we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating components](img/B04943_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, add two files: `config.js` to the `root` folder and `settings.js` to
    `source/shared`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code to `config.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add this code to `settings.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Setting up a server-rendered Express React server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have now finished making our shared components, so it's time to set up server
    rendering. In the preceding file structure, you've probably noticed that we've
    added a file called `server-production.es6`. We'll keep the ordinary ES5 version,
    but to simplify our code, we'll type it up in modern JavaScript and use Babel
    to convert it to ES5.
  prefs: []
  type: TYPE_NORMAL
- en: Using Babel is something we have to live with until the node implements full
    support for ES6/ECMAScript 2015\. We could optionally use `babel-node` to run
    our express server, but it's not advisable to do this in production because it
    adds significant overhead to each request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how it should look. Create `server-production.es6` and add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re going to use client-side routes in our Express server. We''ll set up
    a catch-all Express route and implement react-router routes within it, let''s
    take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We'll also implement a streaming DOM utility instead of using React's own `renderToString`.
    The `renderToString` method is synchronous and can become a performance bottleneck
    in server-side rendering of React sites. Streams make this process much faster
    because you don't need to pre-render the entire string before sending it. With
    larger pages, `renderToString` can introduce a latency of hundreds of milliseconds
    as well as require more memory because it needs to allocate memory to the entire
    string.
  prefs: []
  type: TYPE_NORMAL
- en: '`ReactDOMStream` renders asynchronously to a stream and lets the browser render
    the page before the entire response is finished. Refer to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'When performing server rendering, we need to send 500 responses for errors
    and 302 responses for redirects. We can do this by matching and checking the response
    status. If there are no errors, we proceed with the rendering, let''s take a look
    at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to send a `404` status if we do not find any properties or
    routes, let''s take a look at the remaining code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: When the server starts rendering, it will start by writing out our header information.
    It will load the initial CSS files asynchronously, set up the title and the body,
    and the first div. Then, we switch to `ReactDOMStream`, which will then start
    rendering our app starting from `RoutingContext`. When the stream is finished,
    we close the response by wrapping up our `div` and HTML page. Server-rendered
    content now lives inside `<div id="app"></div>`. When `bundle.js` is loaded, it
    will take over and replace the content of this `div`, unless the device it renders
    on doesn't support JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that while the CSS files are asynchronous, they still block the rendering
    until they are loaded. It''s possible to get around this by inlining the CSS to
    avoid extra lookups, let''s take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The final part is the same as before, just modified to use the new JavaScript
    syntax. One thing you have noticed is that we're importing our source components
    from a new folder called `build` rather than `source`. We can get away with converting
    our source code to ES5, with Babel on runtime when developing; however, this won't
    fly in production. Instead, we need to convert our entire source manually.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's change two lines in `webpack.config.dev.js` and verify that it
    builds locally.
  prefs: []
  type: TYPE_NORMAL
- en: Open the file and replace the line in the entry where it says `./source/index`
    with `./source/client/index`, and the line path `path.join(__dirname, 'public',
    'assets')` to `path.join(__dirname, 'assets')`. Then, run the project by executing
    `npm run dev`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the main page of the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up a server-rendered Express React server](img/B04943_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Your app should now run without problems, and `http://localhost:8080` should
    now present you with the **Shared App** screen. You should be able to edit the
    code in your `source` folder and see it updated live on the screen. You should
    also be able to click on the links and perform math operations with the calculator.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Webpack for server-rendering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open `Webpack-production.config.js` and replace its content with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We're not going to rely on Babel to convert our code on the fly, so we can remove
    the `module` and `resolve` section.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up npm scripts for server rendering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open `package.json` and replace the `scripts` section with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what a running `npm start` command will do:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the build (before it starts).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the `public` and `build` folder, and convert the ES2015 source to ES5
    and put it in the `builder` folder (the prebuild process).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run Webpack and create a *bundle* in `public/assets` (the build process).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run convert, which is in order to convert `server-production.es6` to `server-production.js`
    (when it is started).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the Express server (after it has started).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Phew! That's a huge command chain. After the compilation is over, the server
    starts and you can go to `http://localhost:8080` to test your pre-rendered server.
    You'll probably not even notice the difference at first glance, but try turning
    off JavaScript in your browser and perform the refresh action. The page will still
    load and you'll still be able to navigate. The calculator will not work, however,
    because it requires client-side JavaScript to work. As noted earlier, the goal
    is not to support JavaScript-less browsers (as they are rare). The goal is to
    deliver a pre-rendered page, and that's what this does.
  prefs: []
  type: TYPE_NORMAL
- en: 'We change `npm deploy` as well. Here''s what this does:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the build (before it is deployed).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run convert, in order to convert `server-production.es6` to `server-production.js`
    (once it's deployed).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It will let you know it's done. This step could be replaced with a push to the
    cloud (post its deployment).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The server-rendered app is now complete. You can find a demo at [https://reactjsblueprints-srvdeploy.herokuapp.com/](https://reactjsblueprints-srvdeploy.herokuapp.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Adding Redux to your server-rendered app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final piece of the puzzle is the handling of the data flow. In a client-rendered
    app, data flow is generally handled in this way: The user initiates an action,
    for instance, by visiting the index page of your app. The app then routes to the
    view and the render process starts. After the rendering, or during the rendering
    (asynchronously), data is fetched and then displayed to the user.'
  prefs: []
  type: TYPE_NORMAL
- en: In a server-rendered app, the data needs to be prefetched before the rendering
    process starts. The responsibility of fetching the data shifts from the client
    to the server. This necessitates a complete rethink of how we structure our apps.
    It's important to make this decision before you start designing your app because
    changing your data flow architecture after you've started implementing the app
    is a costly operation.
  prefs: []
  type: TYPE_NORMAL
- en: Adding packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to add a number of new packages to our project. The `package.json`
    file should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We're going to perform isomorphic fetching like we did in [Chapter 6](ch06.html
    "Chapter 6. Advanced React"), *Advanced React*, so we need to add the `isomorphic-fetch`
    library. This library adds `fetch` as a global function so that its API is consistent
    between the client and server.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also add Redux and a console logger instead of the devtools logger we
    used in [Chapter 6](ch06.html "Chapter 6. Advanced React"), *Advanced React*.
  prefs: []
  type: TYPE_NORMAL
- en: Adding files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll add a number of new files to our project and change a few of the existing
    ones. The functionality we'll implement is the asynchronous fetching of a set
    of news items from an offline news API available at [http://reactjsblueprints-newsapi.herokuapp.com/stories](http://reactjsblueprints-newsapi.herokuapp.com/stories).
    It provides a set of news stories updated at regular intervals.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with `client/index.jsx`. Open this file and replace the content
    with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here, we add `polyfill` and the `Redux` setup like we did in [Chapter 6](ch06.html
    "Chapter 6. Advanced React"), *Advanced React*. We also add a check for `window.__INITIAL_STATE__`,
    which is how we'll transfer the server-rendered content to our app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, open `routes/index.jsx` and replace the content with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'These functions are responsible for transmitting state and functions to our
    `child` components. We''ll use them to pass the news stories to our `News` component
    and the `dispatch` and `fetchPostsIfNeeded` functions. Next, add a new folder
    to `shared` and call it `actions`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In this folder, add a file called `index.js` with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This function will check whether the stored state exists and has content; if
    not, it will dispatch a call to `fetchPosts()`. This will make sure we will be
    able to take advantage of the state rendered by the server and fetch the content
    on the client if no such state exists. Refer to the next function in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This function returns a `fetch` operation from our API file. It dispatches
    the `receivePosts()` function, which is the `Redux` function that tells the Redux
    store to call the `RECEIVE_POSTS` reducer function. Let''s take a look at the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The next file we''ll add is `fetch-posts.js`. Create a folder called `api`
    in `shared`, then add the file, and then this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This function simply returns a set of stories using the fetch API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add a folder called `reducers` to `shared`, then add `index.js`, and
    then this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Our reducer picks up the new state and returns a new object with the set of
    posts that we fetched.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a folder called `store` in `shared`, add a file and call it `configure-store.js`,
    and then add this content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We create a function that takes `initialState` and returns a store with our
    reducer and adds middleware for asynchronous operation and logging. The logger
    displays log data in the console window of the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final two files we add should be placed in the `views` folder. The first
    one is `news.jsx`. For this, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll initialize the state by setting `_activePost` to `-1`. This will prevent
    the component from showing the body of any post before the user has had time to
    click on any post. Refer to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This is our callback handler in `posts.jsx`. When the user clicks on a news
    headline, a new state will be set with the ID of the news item, let''s take a
    look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Posts` component will be given a set of posts, an active post, and an
    `onClick` handler. The `onClick` handler needs to have the `App` context bound
    or else it will not be able to use internal methods, such as `setState`. If we
    don''t bind it, `setState` will apply to the context of the `Posts` component
    instead, let''s take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll use `propTypes` so that the React devtools can let us know if any of
    the incoming props are missing or have the wrong type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We export the app state so that it''s available for components importing the
    current one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The second file we add to `views` is `posts.jsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The RSS bodies come with their own HTML. We must explicitly allow this HTML
    to be rendered or else ReactJS will escape the content. When the user clicks on
    a headline, the callback executes `handleClickCallback` in `posts.jsx`. It will
    set a new state in `news.jsx`, and this state will be passed to `posts.jsx` as
    a prop, signaling that the body of this headline should be displayed, let''s take
    a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also need to add a link to the news items in our `app.jsx` file. Open
    the file and add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'With these changes, you''re ready to run your app. Start it with `npm run dev`.
    You should be able to go to the front page on `http://localhost:8080` and click
    on the news link. It should display **Loading** until the content is fetched from
    the server. Here''s a screenshot illustrating this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding files](img/B04943_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The screenshot shows that the news data is loaded and displayed even though
    JavaScript is blocked in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Adding server rendering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We're very close now, but we still have a little bit of work to do before we're
    done. We need to add data fetching to our Express server. Let's open up `server-production.es6`
    and add the code necessary to prefetch data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add these imports somewhere at the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, replace `const approutes` with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we start the `fetchPostsAsync` function. When we receive a result, we
    create an initial state with the news items and then create a new Redux store
    instance with this state, let''s take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We add the initial state to the global window so that we can pick it up in
    `client/index.jsx`, let''s take a look at the remaining code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: That's all you need to prefetch the data. You should now be able to execute
    `npm start` and then open `http://localhost:8080`. Try turning off JavaScript
    in your browser, and you should still be able to navigate and see the items in
    the news list.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create a new Heroku instance, run `npm deploy`, and then push it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can view a demo online at [https://reactjsblueprints-shared.herokuapp.com](https://reactjsblueprints-shared.herokuapp.com).
  prefs: []
  type: TYPE_NORMAL
- en: Performing faster cloud deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you push to Heroku now, what will happen is that Heroku will execute `npm
    start`, kicking off the entire build process. This is problematic because if the
    build process is too time consuming or demands too much of resources, it will
    fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can prevent this by committing the `build` folder to your repository and
    then simply execute `node server-production.js` on push. You can do this by adding
    a special start up file called `Procfile` to the repository. Create this file
    in the root of your project and add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that this file is specific to Heroku. Other cloud providers may have a
    different system in place to specify the start up procedure.
  prefs: []
  type: TYPE_NORMAL
- en: The final structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is how our final app structure looks like (excluding the `build` folder,
    which is essentially the same as the `source` folder):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The server structure remains more or less the same, and the `source` folder
    is the only one that is growing. This is how it should be.
  prefs: []
  type: TYPE_NORMAL
- en: It's worth looking at the structure as you develop your apps. It provides a
    bird's eye view that can help you spot inconsistencies in naming and other structural
    issues. For instance, does the component `layout.jsx` really belong in views?
    How about `posts.jsx`? It's a view component, but it can be argued that it's a
    helper to `news.jsx` and may possibly belong somewhere else.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we modified our Webpack scaffold to enable cloud deployment.
    In the second part of the chapter, we added server rendering, and in the third
    part, we added Redux and the prefetching of data asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: With these three projects, you should be able to produce any kind of app, be
    they small or large. However, as you may have noticed, writing an app that supports
    server rendering requires a fair amount of thought and organization. As the application
    increases in size, it becomes even more difficult to reason out the organization
    and data-fetching strategies. You'll be able to make really efficient apps with
    this strategy, but I'd advise you to spend time thinking through how you structure
    your application.
  prefs: []
  type: TYPE_NORMAL
- en: The demos for this chapter are available at [https://reactjsblueprints-srvdeploy.herokuapp.com/](https://reactjsblueprints-srvdeploy.herokuapp.com/)
    and [https://reactjsblueprints-shared.herokuapp.com](https://reactjsblueprints-shared.herokuapp.com).
    The first link showcases the app as it is when server rendering is added. The
    second shows the final app where we fetch data on the server side and populate
    a Redux store before rendering the app to the user.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll create a game with ReactJS. We'll use the HTML5 canvas
    technology and add Flowtype for static type checking.
  prefs: []
  type: TYPE_NORMAL
