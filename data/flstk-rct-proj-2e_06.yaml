- en: Adding a React Frontend to Complete MERN
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将React前端添加到完成MERN
- en: A web application is incomplete without a frontend. It is the part that users
    interact with and it is crucial to any web experience. In this chapter, we will
    use React to add an interactive user interface to the basic user and auth features
    that have been implemented for the backend of the MERN skeleton application, which
    we started building in the previous chapter. This functional frontend will add
    React components that connect to the backend API and allow users to navigate seamlessly
    within the application based on authorization. By the end of this chapter, you
    will have learned how to easily integrate a React client-side with a Node-Express-MongoDB
    server-side to make a full-stack web application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Web应用程序没有前端是不完整的。这是用户与之交互的部分，对于任何Web体验都至关重要。在本章中，我们将使用React为MERN骨架应用程序后端已实现的基本用户和认证功能添加交互式用户界面，我们在上一章中开始构建该应用程序。这个功能性的前端将添加连接到后端API的React组件，并允许用户根据授权在应用程序中无缝导航。到本章结束时，你将学会如何轻松地将React客户端与Node-Express-MongoDB服务器端集成，以创建全栈Web应用程序。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Frontend features of the skeleton
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 骨架的前端特性
- en: Setting up development with React, React Router, and Material-UI
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用React、React Router和Material-UI设置开发环境
- en: Rendering a home page built with React
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用React渲染主页
- en: Backend user API integration
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后端用户API集成
- en: Auth integration for restricted access
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制访问的认证集成
- en: User list, profile, edit, delete, sign up, and sign in UI to complete the user
    frontend
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户列表、个人资料、编辑、删除、注册和登录UI以完成用户前端
- en: Basic server-side rendering
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本服务器端渲染
- en: Defining the skeleton application frontend
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义骨架应用程序的前端
- en: 'In order to fully implement the skeleton application features we discussed
    in the *Feature breakdown* section of Chapter 3, *Building a Backend with MongoDB,
    Express, and Node*, we will add the following user interface components to our
    base application:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完全实现我们在第3章“使用MongoDB、Express和Node构建后端”的“功能分解”部分中讨论的骨架应用程序功能，我们将向我们的基础应用程序添加以下用户界面组件：
- en: '**Home page**: A view that renders at the root URL to welcome users to the
    web application.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主页**：在根URL上渲染的视图，用于欢迎用户访问Web应用程序。'
- en: '**Sign-up page**: A view with a form for user sign-up, allowing new users to
    create a user account and redirecting them to a sign-in page when successfully
    created.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注册页面**：一个带有用户注册表单的视图，允许新用户创建用户账户，并在成功创建后将其重定向到登录页面。'
- en: '**Sign-in page**: A view with a sign-in form that allows existing users to
    sign in so they have access to protected views and actions.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**登录页面**：一个带有登录表单的视图，允许现有用户登录，以便他们可以访问受保护的视图和操作。'
- en: '**User list page**: A view that fetches and shows a list of all the users in
    the database, and also links to individual user profiles.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户列表页面**：一个视图，用于从数据库中检索并显示所有用户的列表，并且还链接到单个用户个人资料。'
- en: '**Profile page**: A component that fetches and displays an individual user''s
    information. This is only accessible by signed-in users and also contains edit
    and delete options, which are only visible if the signed-in user is looking at
    their own profile.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**个人资料页面**：一个组件，用于检索并显示单个用户的信息。这仅对已登录用户可用，并且还包含编辑和删除选项，这些选项仅在已登录用户查看自己的个人资料时可见。'
- en: '**Edit profile page**: A form that fetches the user''s information to prefill
    the form fields. This allows the user to edit the information and this form is
    accessible only if the logged-in user is trying to edit their own profile.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编辑个人资料页面**：一个表单，用于检索用户信息以预填充表单字段。这允许用户编辑信息，并且此表单仅对尝试编辑自己个人资料的已登录用户可用。'
- en: '**Delete user component**: An option that allows the signed-in user to delete
    their own profile after confirming their intent.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除用户组件**：一个选项，允许已登录用户在确认其意图后删除自己的个人资料。'
- en: '**Menu navigation bar**: A component that lists all the available and relevant
    views to the user, and also helps to indicate the user''s current location in
    the application.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**菜单导航栏**：一个组件，列出所有对用户可用和相关的视图，并有助于指示用户在应用程序中的当前位置。'
- en: 'The following React component tree diagram shows all the React components we
    will develop to build out the views for this base application:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的React组件树图显示了我们将开发的所有React组件，以构建此基础应用程序的视图：
- en: '![](img/dbd95d4d-c412-47f9-af09-4e8e52f511aa.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dbd95d4d-c412-47f9-af09-4e8e52f511aa.png)'
- en: '**MainRouter** will be the main React component. This contains all the other
    custom React views in the application. **Home**, **Signup**, **Signin**, **Users**,
    **Profile**, and **EditProfile** will render at individual routes declared with
    React Router, whereas the **Menu** component will render across all these views. **DeleteUser**
    will be a part of the **Profile** view.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**MainRouter**将是主要的React组件。它包含应用程序中的所有其他自定义React视图。**首页**、**注册**、**登录**、**用户**、**个人资料**和**编辑个人资料**将在React
    Router声明的单独路由上渲染，而**菜单**组件将在所有这些视图中渲染。**删除用户**将是**个人资料**视图的一部分。'
- en: The code discussed in this chapter, as well as the complete skeleton, is available
    on GitHub at [https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter03%20and%2004/mern-skeleton](https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter03%20and%2004/mern-skeleton).
    You can clone this code and run the application as you go through the code explanations
    in the rest of this chapter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的代码以及完整的骨架，可在GitHub上找到：[https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter03%20and%2004/mern-skeleton](https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter03%20and%2004/mern-skeleton)。您可以克隆此代码，并在阅读本章其余部分的代码解释时运行应用程序。
- en: In order to implement these frontend React views, we will have to extend the
    existing project code, which contains the standalone server application for the
    MERN skeleton. Next, we'll take a brief look at the files that will make up this
    frontend and that are needed to complete the full-stack skeleton application code.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这些前端React视图，我们不得不扩展现有的项目代码，这些代码包含MERN骨架的独立服务器应用程序。接下来，我们将简要查看构成这个前端并完成全栈骨架应用程序代码所需的文件。
- en: Folder and file structure
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件夹和文件结构
- en: 'The following folder structure shows the new folders and files to be added
    to the skeleton project we started implementing in the previous chapter, in order
    to complete it with a React frontend:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下文件夹结构显示了需要添加到我们在上一章开始实现的基础项目中的新文件夹和文件，以便使用React前端来完成它：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `client` folder will contain the React components, helpers, and frontend
    assets, such as images and CSS. Besides this folder and the Webpack configuration
    files for compiling and bundling the client code, we will also modify some of
    the other existing files to finish up the integration of the complete skeleton
    application in this chapter.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`client`文件夹将包含React组件、辅助工具和前端资产，如图片和CSS。除了这个文件夹和用于编译和打包客户端代码的Webpack配置文件之外，我们还将修改一些其他现有的文件，以完成本章中完整骨架应用程序的集成。'
- en: Before we start implementing the specific frontend features, we need to get
    set up for React development by installing the necessary modules and adding configuration
    to compile, bundle, and load the React views. We will go through these setup steps
    in the next section.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实现具体的前端功能之前，我们需要通过安装必要的模块并添加编译、打包和加载React视图的配置来为React开发做好准备。我们将在下一节中介绍这些设置步骤。
- en: Setting up for React development
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置React开发环境
- en: Before we can start developing with React in our existing skeleton codebase,
    we need to add configuration to compile and bundle the frontend code, add the
    React-related dependencies that are necessary to build the interactive interface,
    and tie this all together in the MERN development flow.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以在现有的骨架代码库中使用React进行开发之前，我们需要添加配置以编译和打包前端代码，添加构建交互式界面所需的React相关依赖项，并在MERN开发流程中将这一切结合起来。
- en: To achieve this, we will add frontend configuration for Babel, Webpack, and
    React Hot Loader to compile, bundle, and hot reload the code. Next, we will modify
    the server code to initiate code bundling for both the frontend and backend in
    one command to make the development flow simple. Then, we will update the code
    further so that it serves the bundled code from the server when the application
    runs in the browser. Finally, we will finish setting up by installing the React
    dependencies that are necessary to start implementing the frontend.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将添加前端配置以编译、打包和热重载代码的Babel、Webpack和React Hot Loader。接下来，我们将修改服务器代码，以便在一条命令中启动前端和后端的代码打包，使开发流程简单化。然后，我们将进一步更新代码，以便在应用程序在浏览器中运行时从服务器提供打包后的代码。最后，我们将通过安装启动前端实现所需的React依赖项来完成设置。
- en: Configuring Babel and Webpack
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Babel和Webpack
- en: It is necessary to compile and bundle the React code that we will write to implement
    the frontend before the code can run in browsers. To compile and bundle the client
    code so that we can run it during development and also bundle it for production,
    we will update the configuration for Babel and Webpack. Then, we will configure
    the Express app to initiate frontend and backend code bundling in one command,
    so that just starting the server during development gets the complete stack ready
    for running and testing.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码可以在浏览器中运行之前，我们需要编译和捆绑我们将编写的 React 代码以实现前端。为了在开发期间运行并捆绑客户端代码，以及为生产捆绑，我们将更新
    Babel 和 Webpack 的配置。然后，我们将配置 Express 应用程序以一个命令来启动前端和后端代码捆绑，这样在开发期间只需启动服务器就可以使整个堆栈准备好运行和测试。
- en: Babel
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Babel
- en: 'To compile React, first, install the Babel React preset module as a development
    dependency by running the following command from the command line:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译 React，首先，通过在命令行中运行以下命令将 Babel React 预设模块作为开发依赖项安装：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Then, update `.babelrc` with the following code. This will include the module
    and also configure the `react-hot-loader` Babel plugin as required for the `react-hot-loader`
    module.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用以下代码更新`.babelrc`。这将包括模块，并配置`react-hot-loader` Babel 插件，这是`react-hot-loader`模块所需的。
- en: '`mern-skeleton/.babelrc`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/.babelrc`:'
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To put this updated Babel configuration to use, we need to update the Webpack
    configuration, which we will look at in the next section.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此更新的 Babel 配置，我们需要更新 Webpack 配置，我们将在下一节中查看。
- en: Webpack
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Webpack
- en: 'To bundle client-side code after compiling it with Babel, and also to enable
    `react-hot-loader` for faster development, install the following modules by running
    these commands from the command line:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Babel 编译客户端代码后捆绑它，以及启用`react-hot-loader`以加快开发速度，通过在命令行中运行以下命令安装以下模块：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Then, to configure Webpack for frontend development and to build the production
    bundle, we will add a `webpack.config.client.js` file and a `webpack.config.client.production.js`
    file with the same configuration code we described in [Chapter 2](fd935468-e403-4363-80b0-2d13845ea65c.xhtml),
    *Preparing the Development Environment*.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了配置 Webpack 以进行前端开发并构建生产包，我们将添加一个`webpack.config.client.js`文件和一个`webpack.config.client.production.js`文件，其中包含我们在[第2章](fd935468-e403-4363-80b0-2d13845ea65c.xhtml)中描述的相同配置代码，*准备开发环境*。
- en: With Webpack configured and ready for bundling the frontend React code, next,
    we will add some code that we can use in our development flow. This will make
    the full-stack development process seamless.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置好 Webpack 并准备好捆绑前端 React 代码后，接下来，我们将添加一些可以在我们的开发流程中使用的代码。这将使全栈开发过程无缝。
- en: Loading Webpack middleware for development
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载开发 Webpack 中间件
- en: During development, when we run the server, the Express app should also load
    the Webpack middleware that's relevant to the frontend with respect to the configuration
    that's been set for the client-side code, so that the frontend and backend development
    workflow is integrated. To enable this, we will use the `devBundle.js` file we
    discussed in [Chapter 2](fd935468-e403-4363-80b0-2d13845ea65c.xhtml), *Preparing
    the Development Environment*, in order to set up a `compile` method that takes
    the Express app and configures it to use the Webpack middleware. The `devBundle.js` file
    in the `server` folder will look as follows.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发期间，当我们运行服务器时，Express 应用程序还应加载与前端相关的 Webpack 中间件，这与为客户端代码设置的配置相匹配，以便前端和后端开发工作流程集成。为此，我们将使用我们在[第2章](fd935468-e403-4363-80b0-2d13845ea65c.xhtml)中讨论的`devBundle.js`文件，*准备开发环境*，以设置一个接受
    Express 应用程序并配置它使用 Webpack 中间件的`compile`方法。`server`文件夹中的`devBundle.js`文件将如下所示。
- en: '`mern-skeleton/server/devBundle.js`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/server/devBundle.js`:'
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this method, the Webpack middleware uses the values set in `webpack.config.client.js`,
    and we enable hot reloading from the server-side using Webpack Hot Middleware.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在此方法中，Webpack 中间件使用在`webpack.config.client.js`中设置的值，并使用 Webpack Hot Middleware
    从服务器端启用热重载。
- en: Finally, we need to import and call this `compile` method in `express.js` by
    adding the following highlighted lines, but only during development.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在`express.js`中导入并调用这个`compile`方法，通过添加以下突出显示的行，但仅在开发期间。
- en: '`mern-skeleton/server/express.js`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/server/express.js`:'
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: These two highlighted lines are only meant for development mode and should be
    commented out when building the code for production. When the Express app runs
    in development mode, adding this code will import the middleware, along with the client-side Webpack
    configuration. Then, it will initiate Webpack to compile and bundle the client-side
    code and also enable hot reloading.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这两条加粗的行仅用于开发模式，在构建生产代码时应将其注释掉。当Express应用以开发模式运行时，添加此代码将导入中间件以及客户端Webpack配置。然后，它将启动Webpack来编译和打包客户端代码，并启用热重载。
- en: The bundled code will be placed in the `dist` folder. This code will be needed
    to render the views. Next, we will configure the Express server app so that it
    serves the static files from this `dist` folder. This will ensure that the bundled
    React code can be loaded in the browser.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 打包的代码将被放置在`dist`文件夹中。这些代码将用于渲染视图。接下来，我们将配置Express服务器应用，使其从`dist`文件夹提供静态文件。这将确保打包的React代码可以在浏览器中加载。
- en: Loading bundled frontend code
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载打包的前端代码
- en: The frontend views that we will see rendered in the browser will load from the
    bundled files in the `dist` folder. For it to be possible to add these bundled
    files to the HTML view containing our frontend, we need to configure the Express
    app so that it serves static files, which are files that aren't generated dynamically
    by server-side code.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在浏览器中看到的渲染的前端视图将加载自`dist`文件夹中的打包文件。为了将这些打包文件添加到包含我们前端代码的HTML视图中，我们需要配置Express应用，使其提供静态文件，这些文件不是由服务器端代码动态生成的。
- en: Serving static files with Express
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Express提供静态文件
- en: To ensure that the Express server properly handles the requests to static files
    such as CSS files, images, or the bundled client-side JS, we will configure it
    so that it serves static files from the `dist` folder by adding the following
    configuration in `express.js`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保Express服务器正确处理对静态文件（如CSS文件、图像或打包的客户端JS）的请求，我们将配置它，通过在`express.js`中添加以下配置，从`dist`文件夹提供静态文件。
- en: '`mern-skeleton/server/express.js`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/server/express.js`：'
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With this configuration in place, when the Express app receives a request at
    a route starting with `/dist`, it will know to look for the requested static resource
    in the `dist` folder before returning the resource in the response. Now, we can
    load the bundled files from the `dist` folder in the frontend.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配置到位后，当Express应用接收到以`/dist`开头的路由请求时，它将知道在返回资源之前在`dist`文件夹中查找请求的静态资源。现在，我们可以在前端加载`dist`文件夹中的打包文件。
- en: Updating the template to load a bundled script
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新模板以加载打包的脚本
- en: To add the bundled frontend code in the HTML to render our React frontend, we
    will update the `template.js` file so that it adds the script file from the `dist`
    folder to the end of the `<body>` tag.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将打包的前端代码添加到HTML中以便渲染我们的React前端，我们将更新`template.js`文件，使其将`dist`文件夹中的脚本文件添加到`<body>`标签的末尾。
- en: '`mern-skeleton/template.js`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/template.js`：'
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This script tag will load our React frontend code in the browser when we visit
    the root URL `'/'` with the server running. We are ready to see this in action
    and can start installing the dependencies that will add the React views.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在服务器运行时访问根URL `'/'` 时，此脚本标签将在浏览器中加载我们的React前端代码。我们已经准备好看到这一效果，并可以开始安装将添加React视图的依赖项。
- en: Adding React dependencies
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加React依赖项
- en: 'The frontend views in our skeleton application will primarily be implemented
    using React. In addition, to enable client-side routing, we will use React Router,
    and to enhance the user experience with a sleek look and feel, we will use Material-UI.
    To add these libraries, we will install the following modules in this section:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们骨架应用的前端视图将主要使用React来实现。此外，为了启用客户端路由，我们将使用React Router，并且为了通过简洁的外观和感觉提升用户体验，我们将使用Material-UI。为了添加这些库，我们将在本节中安装以下模块：
- en: '**Core React modules**: `react` and `react-dom`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**核心React模块**：`react` 和 `react-dom`'
- en: '**React Router modules**: `react-router` and `react-router-dom`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**React Router模块**：`react-router` 和 `react-router-dom`'
- en: '**Material-UI modules**: `@material-ui/core` and `@material-ui/icons`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Material-UI模块**：`@material-ui/core` 和 `@material-ui/icons`'
- en: React
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React
- en: 'Throughout this book, we will use React to code up the frontend. To start writing
    the React component code, we will need to install the following modules as regular
    dependencies:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将使用React来编写前端代码。为了开始编写React组件代码，我们需要将以下模块作为常规依赖项安装：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: These are the core React library modules that are necessary for implementing
    the React-based web frontend. With other additional modules, we will add more
    functionality on top of React.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是实施基于React的Web前端所必需的核心React库模块。通过添加其他附加模块，我们将在React之上添加更多功能。
- en: React Router
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React Router
- en: 'React Router provides a collection of navigational components that enable routing
    on the frontend for React applications. We will add the following React Router
    modules:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: React Router提供了一组导航组件，这些组件使React应用程序在前端实现路由功能。我们将添加以下React Router模块：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: These modules will let us utilize declarative routing and have bookmarkable
    URL routes in the frontend.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模块将使我们能够利用声明式路由，并在前端拥有可书签的URL路由。
- en: Material-UI
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Material-UI
- en: 'In order to keep the UI in our MERN applications sleek without delving too
    much into UI design and implementation, we will utilize the Material-UI library.
    It provides ready to use and customizable React components that implement Google''s
    material design. To start using Material-UI components to make the frontend, we
    need to install the following modules:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持我们的MERN应用程序的UI简洁，而不深入UI设计和实现，我们将利用Material-UI库。它提供了现成可使用且可定制的React组件，实现了谷歌的材质设计。为了开始使用Material-UI组件来构建前端，我们需要安装以下模块：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: At the time of writing, the latest version of Material-UI is `4.9.8`. It is
    recommended that you install this exact version in order to ensure the code for
    the example projects does not break.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Material-UI的最新版本是`4.9.8`。建议您安装此确切版本，以确保示例项目的代码不会出错。
- en: 'To add the `Roboto` fonts that are recommended by Material-UI and to use the
    `Material-UI` icons, we will add the relevant style links into the `template.js`
    file, in the HTML document''s `<head>` section:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了添加Material-UI推荐的`Roboto`字体并使用`Material-UI`图标，我们将把相关的样式链接添加到`template.js`文件中，在HTML文档的`<head>`部分：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With the development configuration all set up and the necessary React modules
    added to the code base, we can now implement the custom React components, starting
    with a home page. This should load up as the first view of the complete application.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发配置全部设置完成，并将必要的React模块添加到代码库之后，我们现在可以开始实现自定义的React组件，从主页开始。这个页面应该作为完整应用程序的第一个视图加载。
- en: Rendering a home page view
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染主页视图
- en: To demonstrate how to implement a functional frontend for this MERN skeleton,
    we will start by detailing how to render a simple home page at the root route
    of the application, before covering backend API integration, user auth integration,
    and implementing the other view components in the rest of this chapter.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示如何实现这个MERN框架的前端功能，我们将首先详细说明如何在应用程序的根路由上渲染一个简单的首页，然后再介绍后端API集成、用户认证集成，以及在本章的其余部分实现其他视图组件。
- en: The process of implementing and rendering a working `Home` component at the
    root route will also expose the basic structure of the frontend code in the skeleton.
    We will start with the top-level entry component that houses the whole React app
    and renders the main router component, which links all the React components in
    the application.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在根路由上实现和渲染一个工作的`Home`组件的过程，也将揭示前端代码骨架的基本结构。我们将从包含整个React应用的顶级入口组件开始，该组件渲染主路由组件，它将应用程序中的所有React组件链接起来。
- en: In the following sections, we will begin implementing the React frontend. First,
    we will add the root React component, which is integrated with React Router and
    Material-UI and configured for hot reloading. We will also learn how to customize
    the Material-UI theme and make the theme available to all our components. Finally,
    we will implement and load the React component representing the home page, in
    turn demonstrating how to add and render React views in this application.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将开始实施React前端。首先，我们将添加根React组件，该组件与React Router和Material-UI集成，并配置为热重载。我们还将学习如何自定义Material-UI主题，并使主题对所有组件可用。最后，我们将实现并加载代表主页的React组件，从而展示如何在应用程序中添加和渲染React视图。
- en: Entry point at main.js
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入口点在main.js
- en: The `client/main.js` file in the client folder will be the entry point to render
    the complete React app, as already indicated in the client-side Webpack configuration
    object. In `client/main.js`, we import the root or top-level React component that
    will contain the whole frontend and render it to the `div` element with the `'root'` ID
    specified in the HTML document in `template.js`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端文件夹中的`client/main.js`文件将是渲染完整React应用程序的入口点，如客户端Webpack配置对象中已指示的那样。在`client/main.js`中，我们导入包含整个前端的最顶层或最高级React组件，并将其渲染到HTML文档中`template.js`指定的具有`'root'`
    ID的`div`元素中。
- en: '`mern-skeleton/client/main.js`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/main.js`:'
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, the top-level root React component is the `App` component and it is being
    rendered in the HTML. The `App` component is defined in `client/App.js`, as discussed
    in the next subsection.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，最高级的根React组件是`App`组件，它正在HTML中被渲染。`App`组件在`client/App.js`中定义，如下一小节所述。
- en: Root React component
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根React组件
- en: The top-level React component that will contain all the components for the application's
    frontend is defined in the `client/App.js` file. In this file, we configure the
    React app so that it renders the view components with a customized Material-UI
    theme, enables frontend routing, and ensures that the React Hot Loader can instantly
    load changes as we develop the components.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 将包含应用程序前端所有组件的最高级React组件定义在`client/App.js`文件中。在这个文件中，我们配置React应用程序，使其使用定制的Material-UI主题渲染视图组件，启用前端路由，并确保React
    Hot Loader可以在我们开发组件时即时加载更改。
- en: In the following sections, we will add code to customize the theme, make this
    theme and React Router capabilities available to our React components, and configure
    the root component for hot reloading.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，我们将添加代码来自定义主题，使此主题和React Router功能可供我们的React组件使用，并配置用于热加载的根组件。
- en: Customizing the Material-UI theme
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义Material-UI主题
- en: The Material-UI theme can be easily customized using the `ThemeProvider` component.
    It can also be used to configure the custom values of theme variables in `createMuiTheme()`.
    We will define a custom theme for the skeleton application in `client/theme.js`
    using `createMuiTheme`, and then export it so that it can be used in the `App`
    component.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`ThemeProvider`组件轻松地自定义Material-UI主题。它还可以用于在`createMuiTheme()`中配置主题变量的自定义值。我们将使用`createMuiTheme`在`client/theme.js`中为骨架应用程序定义一个自定义主题，然后将其导出，以便在`App`组件中使用。
- en: '`mern-skeleton/client/theme.js`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/theme.js`:'
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: For the skeleton, we only apply minimal customization by setting some color
    values to be used in the UI. The theme variables that are generated here will
    be passed to, and available in, all the components we build.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于骨架，我们只通过设置一些用于UI的颜色值进行最小化定制。这里生成的主题变量将被传递到，并在我们构建的所有组件中使用。
- en: Wrapping the root component with ThemeProvider and BrowserRouter
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ThemeProvider和BrowserRouter包装根组件
- en: The custom React components that we will create to make up the user interface
    will be accessed with the frontend routes specified in the `MainRouter` component.
    Essentially, this component houses all the custom views that have been developed
    for the application and needs to be given the theme values and routing features.
    This component will be our core component in the root `App` component, which is
    defined in the following code.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建以构成用户界面的自定义React组件将通过`MainRouter`组件中指定的前端路由来访问。本质上，此组件包含了为应用程序开发的所有自定义视图，需要提供主题值和路由功能。此组件将是根`App`组件中的核心组件，该组件在以下代码中定义。
- en: '`mern-skeleton/client/App.js`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/App.js`:'
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When defining this root component in `App.js`, we wrap the `MainRouter` component
    with `ThemeProvider`, which gives it access to the Material-UI theme, and `BrowserRouter`,
    which enables frontend routing with React Router. The custom theme variables we
    defined previously are passed as a prop to `ThemeProvider`, making the theme available
    in all our custom React components. Finally, in the `App.js` file, we need to
    export this `App` component so that it can be imported and used in `main.js`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在`App.js`中定义此根组件时，我们将`MainRouter`组件包裹在`ThemeProvider`中，使其能够访问Material-UI主题，以及`BrowserRouter`，它通过React
    Router启用前端路由。我们之前定义的自定义主题变量作为属性传递给`ThemeProvider`，使主题可在所有自定义React组件中使用。最后，在`App.js`文件中，我们需要导出此`App`组件，以便可以在`main.js`中导入和使用。
- en: Marking the root component as hot-exported
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标记根组件为热导出
- en: The last line of code in `App.js`, which exports the `App` component, uses the**higher-order
    component** (**HOC**)  `hot` module from `react-hot-loader` to mark the root component
    as `hot`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`App.js`中的最后一行代码，用于导出`App`组件，使用了`react-hot-loader`的**高阶组件**（**HOC**）`hot`模块来标记根组件为`hot`。'
- en: '`mern-skeleton/client/App.js`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/App.js`:'
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Marking the `App` component as `hot` in this way essentially enables live reloading
    of our React components during development.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式标记`App`组件为`hot`实际上在开发期间启用了我们的React组件的实时重新加载。
- en: For our MERN applications, we won't have to change the `main.js` and `App.js`
    code all that much after this point, and we can continue building out the rest
    of the React app by injecting new components into the `MainRouter` component,
    which is what we'll do in the next section.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点之后，对于我们的MERN应用，我们不需要太多地更改`main.js`和`App.js`代码，我们可以通过将新组件注入到`MainRouter`组件中继续构建React应用的其余部分，这正是我们将在下一节中做的。
- en: Adding a home route to MainRouter
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向MainRouter添加主页路由
- en: The `MainRouter.js` code will help render our custom React components with respect
    to the routes or locations in the application. In this first version, we will
    only add the root route for rendering the `Home` component.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainRouter.js`代码将帮助我们根据应用中的路由或位置渲染自定义React组件。在这个第一个版本中，我们只会添加根路由以渲染`Home`组件。'
- en: '`mern-skeleton/client/MainRouter.js`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/MainRouter.js`:'
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As we develop more view components, we will update the `MainRouter` and add
    routes for the new components inside the `Switch` component.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们开发更多的视图组件，我们将更新`MainRouter`并在`Switch`组件内添加新组件的路由。
- en: The `Switch` component in React Router renders a route exclusively. In other
    words, it only renders the first child that matches the requested route path.
    On the other hand, without being nested in a `Switch`, every `Route` component
    renders inclusively when there is a path match; for example, a request at `'/'`
    also matches a route at `'/contact'`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: React Router中的`Switch`组件渲染一个特定的路由。换句话说，它只渲染与请求的路由路径匹配的第一个子组件。另一方面，如果没有嵌套在`Switch`中，当有路径匹配时，每个`Route`组件都会全面渲染；例如，对`'/'`的请求也匹配`'/contact'`路由。
- en: The `Home` component, which we added this route for in `MainRouter`, needs to
    be defined and exported, which we'll do in the next section.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`MainRouter`中添加此路由的`Home`组件需要被定义和导出，我们将在下一节中这样做。
- en: The Home component
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Home`组件'
- en: The `Home` component will be the React component containing the home page view
    of the skeleton application. It will be rendered in the browser when the user
    visits the root route, and we will compose it with Material-UI components.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`Home`组件将是包含骨架应用主页视图的React组件。当用户访问根路由时，它将在浏览器中渲染，我们将使用Material-UI组件来组合它。'
- en: 'The following screenshot shows the `Home` component, as well as the `Menu`
    component, which will be implemented later in this chapter as an individual component
    that provides navigation across the application:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了`Home`组件，以及将在本章后面作为单独组件实现的`Menu`组件，该组件将提供跨应用导航：
- en: '![](img/c93f1841-1700-46f7-ba0e-27e0b61d336a.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c93f1841-1700-46f7-ba0e-27e0b61d336a.png)'
- en: 'The `Home` component and other view components that will be rendered in the
    browser for the user to interact with will follow a common code structure that
    contains the following parts in the given order:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 将在浏览器中渲染并供用户交互的`Home`组件和其他视图组件将遵循一个常见的代码结构，包含以下部分（按顺序）：
- en: Imports of libraries, modules, and files needed to construct the component
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入构建组件所需的库、模块和文件
- en: Style declarations to define the specific CSS styles for the component elements
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样式声明，用于定义组件元素的特定CSS样式
- en: A function that defines the React component
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义React组件的函数
- en: Throughout this book, as we develop new React components representing the frontend
    views, we will focus mainly on the React component definition part. But for our
    first implementation, we will elaborate on all these parts to introduce the necessary
    structure.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，随着我们开发代表前端视图的新React组件，我们将主要关注React组件定义部分。但为了我们的第一次实现，我们将详细阐述所有这些部分以介绍必要的结构。
- en: Imports
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入
- en: For each React component implementation, we need to import the libraries, modules,
    and files being used in the implementation code. The component file will start
    with imports from React, Material-UI, React Router modules, images, CSS, API fetch,
    and the auth helpers from our code, as required by the specific component. For
    example, for the `Home` component code in `Home.js`, we use the following imports.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个React组件实现，我们需要导入实现代码中使用的库、模块和文件。组件文件将首先从React、Material-UI、React Router模块、图片、CSS、API获取以及我们代码中的认证助手导入，具体取决于特定组件的需求。例如，对于`Home.js`中的`Home`组件代码，我们使用以下导入。
- en: '`mern-skeleton/client/core/Home.js`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/core/Home.js`:'
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The image file is kept in the `client/assets/images/` folder and is imported
    so that it can be added to the `Home` component. These imports will help us build
    the component and also define the styles to be used in the component.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图片文件保存在`client/assets/images/`文件夹中，并导入以便将其添加到`Home`组件中。这些导入将帮助我们构建组件并定义组件中使用的样式。
- en: Style declarations
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 样式声明
- en: After the imports, we will define the CSS styles that are required to style
    the elements in the component by utilizing the `Material-UI` theme variables and
    `makeStyles`, which is a custom React hook API provided by `Material-UI`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入之后，我们将通过利用`Material-UI`主题变量和`makeStyles`（这是由`Material-UI`提供的自定义React Hook
    API）来定义所需的CSS样式，以通过`Material-UI`主题变量和`makeStyles`来设置组件中的元素样式。
- en: Hooks are new to React. Hooks are functions that make it possible to use React
    state and life cycle features in function components, without having to write
    a class to define the component. React provides some built-in hooks, but we can
    also build custom hooks as needed to reuse stateful behavior across different
    components. To learn more about React Hooks, visit [reactjs.org/docs/hooks-intro.html](https://reactjs.org/docs/hooks-intro.html).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Hooks是React的新特性。Hooks是函数，使得在函数组件中可以使用React状态和生命周期特性，而无需编写一个类来定义组件。React提供了一些内置的Hooks，但根据需要我们也可以构建自定义Hooks以在不同组件间重用有状态的行为。要了解更多关于React
    Hooks的信息，请访问[reactjs.org/docs/hooks-intro.html](https://reactjs.org/docs/hooks-intro.html)。
- en: For the `Home` component in `Home.js`, we have the following styles.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Home.js`中的`Home`组件，我们有以下样式。
- en: '`mern-skeleton/client/core/Home.js`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/core/Home.js`:'
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The JSS style objects defined here will be injected into the component using
    the hook returned by `makeStyles`. The `makeStyles` hook API takes a function
    as an argument and gives access to our custom theme variables, which we can use
    when defining the styles.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里定义的JSS样式对象将通过`makeStyles` Hook返回的Hook注入到组件中。`makeStyles` Hook API接受一个函数作为参数，并提供访问我们自定义主题变量的权限，我们可以在定义样式时使用这些变量。
- en: Material-UI uses JSS, which is a CSS-in-JS styling solution for adding styles
    to components. JSS uses JavaScript as a language to describe styles. This book
    will not cover CSS and styling implementations in detail. It will mostly rely
    on the default look and feel of Material-UI components. To learn more about JSS,
    visit [http://cssinjs.org/?v=v9.8.1](http://cssinjs.org/?v=v9.8.1). For examples
    of how to customize the `Material-UI` component styles, check out the Material-UI
    documentation at [https://material-ui.com/](https://material-ui.com/).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Material-UI使用JSS，这是一个用于向组件添加样式的CSS-in-JS样式解决方案。JSS使用JavaScript作为描述样式的语言。本书不会详细涵盖CSS和样式实现。它将主要依赖于Material-UI组件的默认外观和感觉。要了解更多关于JSS的信息，请访问[http://cssinjs.org/?v=v9.8.1](http://cssinjs.org/?v=v9.8.1)。有关如何自定义`Material-UI`组件样式的示例，请查看Material-UI文档[https://material-ui.com/](https://material-ui.com/)。
- en: We can use these generated styles to style the elements in the component, as
    shown in the following `Home` component definition.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这些生成的样式来设置组件中的元素样式，如下面的`Home`组件定义所示。
- en: Component definition
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件定义
- en: While writing the function to define the component, we will compose the content
    and behavior of the component. The `Home` component will contain a Material-UI `Card`
    with a headline, an image, and a caption, all styled with the styles we defined
    previously and returned by calling the `useStyles()` hook.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写定义组件的函数时，我们将组合组件的内容和行为。`Home`组件将包含一个带有标题、图片和说明的Material-UI `Card`，所有这些都将使用我们之前定义并调用`useStyles()`
    Hook返回的样式进行样式化。
- en: '`mern-skeleton/client/core/Home.js`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/core/Home.js`:'
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding code, we defined and exported a function component named `Home`.
    The exported component can now be used for composition within other components.
    We already imported this `Home` component in a route in the `MainRouter` component,
    as we discussed earlier.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义并导出了一个名为`Home`的函数组件。现在，这个导出的组件可以在其他组件内部进行组合。正如我们之前讨论的那样，我们已经在`MainRouter`组件中的一个路由中导入了此`Home`组件。
- en: Throughout this book, we will define all our React components as functional
    components. We will utilize React Hooks, which is a new addition to React, to
    add state and life cycle features, instead of using class definitions to achieve
    the same.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中，我们将定义所有我们的React组件为函数组件。我们将利用React Hooks，这是React的新增功能，来添加状态和生命周期特性，而不是使用类定义来实现相同的功能。
- en: The other view components to be implemented in our MERN applications will adhere
    to the same structure. In the rest of this book, we will focus mainly on the component
    definition, highlighting the unique aspects of the implemented component.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的MERN应用程序中实现的其他视图组件将遵循相同的结构。在本书的剩余部分，我们将主要关注组件定义，突出实现组件的独特方面。
- en: We are almost ready to run this code to render the home page component in the
    frontend. But before that, we need to update the Webpack configurations so that
    we can bundle and display images.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎准备好运行此代码以在前端渲染主页组件。但在那之前，我们需要更新Webpack配置，以便我们可以捆绑和显示图像。
- en: Bundling image assets
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捆绑图像资源
- en: The static image file that we imported into the `Home` component view must also
    be included in the bundle with the rest of the compiled JS code so that the code
    can access and load it. To enable this, we need to update the Webpack configuration
    files and add a module rule to load, bundle, and emit image files to the `dist` output
    directory, which contains the compiled frontend and backend code.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入到`Home`组件视图中的静态图像文件也必须包含在与其他编译JS代码捆绑的捆绑包中，以便代码可以访问和加载它。为了启用此功能，我们需要更新Webpack配置文件，并添加一个模块规则来加载、捆绑并将图像文件输出到`dist`目录，该目录包含编译的前端和后端代码。
- en: 'Update the `webpack.config.client.js`, `webpack.config.server.js`, and `webpack.config.client.production.js` files
    so that you can add the following module rule after the use of `babel-loader`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`webpack.config.client.js`、`webpack.config.server.js`和`webpack.config.client.production.js`文件，以便在`babel-loader`使用后添加以下模块规则：
- en: '[PRE20]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This module rule uses the `file-loader` node module for Webpack, which needs
    to be installed as a development dependency, as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块规则使用Webpack的`file-loader`节点模块，需要将其作为开发依赖项安装，如下所示：
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With this image bundling configuration added, the home page component should
    successfully render the image when we run the application.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了此图像捆绑配置后，当运行应用程序时，主页组件应成功渲染图像。
- en: Running and opening in the browser
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在浏览器中运行和打开
- en: 'The client code up to this point can be run so that we can view the `Home`
    component in the browser at the root URL. To run the application, use the following
    command:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的客户端代码可以运行，这样我们就可以在根URL中查看`Home`组件。要运行应用程序，请使用以下命令：
- en: '[PRE22]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Then, open the root URL (`http://localhost:3000`) in the browser to see the
    `Home` component.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在浏览器中打开根URL（`http://localhost:3000`）以查看`Home`组件。
- en: The `Home` component we've developed in this section is a basic view component
    without interactive features and does not require the use of the backend APIs
    for user CRUD or auth. However, the remaining view components for our skeleton
    frontend will need the backend APIs and auth, so we will look at how to integrate
    these in the next section.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节中开发的`Home`组件是一个基本的视图组件，没有交互功能，并且不需要使用后端API进行用户CRUD或认证。然而，我们前端骨架的剩余视图组件将需要后端API和认证，因此我们将探讨如何在下一节中集成这些功能。
- en: Integrating backend APIs
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成后端API
- en: Users should be able to use the frontend views to fetch and modify user data
    in the database based on authentication and authorization. To implement these
    functionalities, the React components will access the API endpoints that are exposed
    by the backend using the Fetch API.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 用户应该能够使用前端视图根据认证和授权从数据库中检索和修改用户数据。为了实现这些功能，React组件将使用Fetch API访问后端公开的API端点。
- en: The Fetch API is a newer standard that makes network requests similar to **XMLHttpRequest**
    (**XHR**) but using promises instead, enabling a simpler and cleaner API. To learn
    more about the Fetch API, visit [https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Fetch API是一个较新的标准，它使网络请求类似于**XMLHttpRequest**（XHR），但使用promise而不是回调，从而实现了一个更简单、更干净的API。要了解更多关于Fetch
    API的信息，请访问[https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)。
- en: Fetch for user CRUD
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户CRUD的获取
- en: In the `client/user/api-user.js` file, we will add methods for accessing each
    of the user CRUD API endpoints, which the React components can use to exchange
    user data with the server and database as required. In the following sections,
    we will look at the implementation of these methods and how they correspond to
    each CRUD endpoint.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在`client/user/api-user.js`文件中，我们将添加访问每个用户CRUD API端点的方法，React组件可以使用这些方法根据需要与服务器和数据库交换用户数据。在接下来的章节中，我们将探讨这些方法的实现以及它们如何对应到每个CRUD端点。
- en: Creating a user
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用户
- en: The `create` method will take user data from the view component, which is where
    we will invoke this method. Then, it will use `fetch` to make a `POST` call at
    the create API route, `'/api/users'`, to create a new user in the backend with
    the provided data.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`create`方法将从视图组件获取用户数据，我们将在那里调用此方法。然后，它将使用`fetch`在创建API路由`''/api/users''`上发起一个`POST`调用，以在后端使用提供的数据创建一个新用户。'
- en: '`mern-skeleton/client/user/api-user.js`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/user/api-user.js`:'
- en: '[PRE23]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Finally, in this method, we return the response from the server as a promise.
    So, the component calling this method can use this promise to handle the response
    appropriately, depending on what is returned from the server. Similarly, we will
    implement the `list` method next.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在这个方法中，我们作为promise返回来自服务器的响应。因此，调用此方法的组件可以使用这个promise来适当地处理响应，具体取决于从服务器返回的内容。同样，我们将在下一节中实现`list`方法。
- en: Listing users
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出用户
- en: The `list` method will use fetch to make a `GET` call to retrieve all the users
    in the database, and then return the response from the server as a promise to
    the component.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`list`方法将使用`fetch`发起一个`GET`调用，以检索数据库中的所有用户，然后作为promise将服务器的响应返回给组件。'
- en: '`mern-skeleton/client/user/api-user.js`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/user/api-user.js`:'
- en: '[PRE24]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The returned promise, if it resolves successfully, will give the component an
    array containing the user objects that were retrieved from the database. In the
    case of a single user read, we will deal with a single user object instead, as
    demonstrated next.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果返回的promise成功解析，将给组件提供一个包含从数据库检索到的用户对象的数组。在单个用户读取的情况下，我们将处理单个用户对象，如下所示。
- en: Reading a user profile
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阅读用户资料
- en: The `read` method will use fetch to make a `GET` call to retrieve a specific
    user by ID. Since this is a protected route, besides passing the user ID as a
    parameter, the requesting component must also provide valid credentials, which,
    in this case, will be a valid JWT received after a successful sign-in.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`read`方法将使用`fetch`发起一个`GET`调用，通过ID检索特定用户。由于这是一个受保护的路由，除了传递用户ID作为参数外，请求的组件还必须提供有效的凭据，在这种情况下，将是一个在成功登录后收到的有效JWT。'
- en: '`mern-skeleton/client/user/api-user.js`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/user/api-user.js`:'
- en: '[PRE25]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The JWT is attached to the `GET` fetch call in the `Authorization` header using
    the `Bearer` scheme, and then the response from the server is returned to the
    component in a promise. This promise, when it resolves, will either give the component
    the user details for the specific user or notify that access is restricted to
    authenticated users. Similarly, the updated user API method also needs to be passed
    valid JWT credentials for the fetch call, as shown in the next section.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: JWT通过`Bearer`方案附加到`GET` fetch调用中的`Authorization`头，然后服务器响应作为promise返回给组件。当这个promise解析时，它将要么给组件提供特定用户的用户详情，要么通知访问权限仅限于认证用户。同样，更新的用户API方法也需要为fetch调用传递有效的JWT凭据，如下一节所示。
- en: Updating a user's data
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新用户数据
- en: The `update` method will take changed user data from the view component for
    a specific user, then use `fetch` to make a `PUT` call to update the existing
    user in the backend. This is also a protected route that will require a valid
    JWT as the credential.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`update`方法将获取特定用户的更改后的用户数据，然后使用`fetch`发起一个`PUT`调用，以更新后端中现有的用户。这也是一个受保护的路由，将需要有效的JWT作为凭据。'
- en: '`mern-skeleton/client/user/api-user.js`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/user/api-user.js`:'
- en: '[PRE26]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As we have seen with the other fetch calls, this method will also return a promise
    containing the server's response to the user update request. In the final method,
    we will learn how to call the user delete API.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们看到的其他 `fetch` 调用一样，此方法也将返回一个包含服务器对用户更新请求响应的承诺。在最后一个方法中，我们将学习如何调用用户删除 API。
- en: Deleting a user
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除用户
- en: The `remove` method will allow the view component to delete a specific user
    from the database and use fetch to make a `DELETE` call. This, again, is a protected
    route that will require a valid JWT as a credential, similar to the `read` and
    `update` methods.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove` 方法将允许视图组件从数据库中删除特定用户，并使用 `fetch` 发起一个 `DELETE` 请求。这同样是一个受保护的路线，需要有效的
    JWT 作为凭证，类似于 `read` 和 `update` 方法。'
- en: '`mern-skeleton/client/user/api-user.js`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/user/api-user.js`:'
- en: '[PRE27]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The response from the server to the delete request will be returned to the component
    as a promise, as in the other methods.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器对删除请求的响应将以承诺的形式返回到组件中，就像其他方法一样。
- en: In these five helper methods, we have covered calls to all the user CRUD-related
    API endpoints that we implemented on the backend. Finally, we can export these
    methods from the `api-user.js` file as follows.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这五个辅助方法中，我们已经涵盖了所有与用户 CRUD 相关的后端实现的 API 端点调用。最后，我们可以如下从 `api-user.js` 文件导出这些方法。
- en: '`mern-skeleton/client/user/api-user.js`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/user/api-user.js`:'
- en: '[PRE28]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: These user CRUD methods can now be imported and used by the React components
    as required. Next, we will implement similar helper methods to integrate the auth-related
    API endpoints.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这些用户 CRUD 方法现在可以根据需要由 React 组件导入和使用。接下来，我们将实现类似的辅助方法以集成与认证相关的 API 端点。
- en: Fetch for the auth API
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为认证 API 获取
- en: In order to integrate the auth API endpoints from the server with the frontend
    React components, we will add methods for fetching sign-in and sign-out API endpoints
    in the `client/auth/api-auth.js` file. Let's take a look at them.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将服务器端的认证 API 端点与前端 React 组件集成，我们将在 `client/auth/api-auth.js` 文件中添加获取登录和注销
    API 端点的方法。让我们来看看它们。
- en: Sign-in
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登录
- en: The `signin` method will take user sign-in data from the view component, then
    use `fetch` to make a `POST` call to verify the user with the backend.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`signin` 方法将从视图组件获取用户登录数据，然后使用 `fetch` 发起一个 `POST` 请求以验证用户与后端。'
- en: '`mern-skeleton/client/auth/api-auth.js`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/auth/api-auth.js`:'
- en: '[PRE29]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The response from the server will be returned to the component in a promise,
    which may provide the JWT if sign-in was successful. The component invoking this
    method needs to handle the response appropriately, such as storing the received
    JWT locally so it can be used when making calls to other protected API routes
    from the frontend. We will look at the implementation for this when we implement
    the **Sign In** view later in this chapter.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器响应将以承诺的形式返回到组件中，如果登录成功，可能会提供 JWT。调用此方法的组件需要适当地处理响应，例如将接收到的 JWT 本地存储，以便在从前端调用其他受保护
    API 路由时使用。我们将在本章后面实现 **登录** 视图时查看此实现。
- en: After the user is successfully signed in, we also want the option to call the
    signout API when the user is signing out. The call to the signout API is discussed
    next.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 用户成功登录后，我们还想在用户注销时调用注销 API。接下来将讨论注销 API 的调用。
- en: Sign-out
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注销
- en: We will add a `signout` method to `api-auth.js`, which will use fetch to make
    a GET call to the signout API endpoint on the server.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `api-auth.js` 中添加一个 `signout` 方法，它将使用 `fetch` 发起一个 GET 请求到服务器的注销 API 端点。
- en: '`mern-skeleton/client/auth/api-auth.js`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/auth/api-auth.js`:'
- en: '[PRE30]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This method will also return a promise to inform the component about whether
    the API request was successful.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法也将返回一个承诺，以通知组件 API 请求是否成功。
- en: At the end of the `api-auth.js` file, we will export the `signin` and `signout`
    methods.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `api-auth.js` 文件的末尾，我们将导出 `signin` 和 `signout` 方法。
- en: '`mern-skeleton/client/auth/api-auth.js`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/auth/api-auth.js`:'
- en: '[PRE31]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, these methods can be imported into the relevant React components so that
    we can implement the user sign-in and signout features.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这些方法可以被导入到相关的 React 组件中，以便我们可以实现用户登录和注销功能。
- en: With these API fetch methods added, the React frontend has complete access to
    the endpoints we made available in the backend. Before we start putting these
    methods to use in our React components, we will look into how user auth state
    can be maintained across the frontend.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了这些 API 获取方法之后，React 前端可以完全访问我们在后端提供的端点。在我们开始在 React 组件中使用这些方法之前，我们将探讨如何在前端维护用户认证状态。
- en: Adding auth in the frontend
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在前端添加认证
- en: As we discussed in the previous chapter, implementing authentication with JWT
    relinquishes responsibility to the client-side to manage and store user auth state.
    To this end, we need to write code that will allow the client-side to store the
    JWT that's received from the server on successful sign-in, make it available when
    accessing protected routes, delete or invalidate the token when the user signs
    out, and also restrict access to views and components on the frontend based on
    the user auth state.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中讨论的，使用 JWT 实现认证将管理用户认证状态的责任转移给了客户端。为此，我们需要编写代码，允许客户端在成功登录后存储从服务器接收到的
    JWT，在访问受保护的路由时使其可用，当用户登出时删除或使令牌无效，并且根据用户认证状态限制对视图和组件的前端访问。
- en: Using examples of the auth workflow from the React Router documentation, in
    the following sections, we will write helper methods to manage the auth state
    across the components, and also use a custom `PrivateRoute` component to add protected
    routes to the frontend of the MERN skeleton application.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 React Router 文档中的认证工作流程示例，在以下章节中，我们将编写辅助方法来管理组件间的认证状态，并使用自定义的 `PrivateRoute`
    组件将受保护的路由添加到 MERN 骨架应用程序的前端。
- en: Managing auth state
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理认证状态
- en: To manage auth state in the frontend of the application, the frontend needs
    to be able to store, retrieve, and delete the auth credentials that are received
    from the server on successful user sign in. In our MERN applications, we will
    use the browser's `sessionsStorage` as the storage option to store the JWT auth
    credentials.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理应用程序前端中的认证状态，前端需要能够存储、检索和删除在用户成功登录时从服务器接收到的认证凭据。在我们的 MERN 应用程序中，我们将使用浏览器的
    `sessionStorage` 作为存储选项来存储 JWT 认证凭据。
- en: Alternatively, you can use `localStorage` instead of `sessionStorage` to store
    the JWT credentials. With `sessionStorage`, the user auth state will only be remembered
    in the current window tab. With `localStorage`, the user auth state will be remembered
    across tabs in a browser.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用 `localStorage` 而不是 `sessionStorage` 来存储 JWT 凭据。使用 `sessionStorage`，用户认证状态将仅在当前窗口标签中记住。使用
    `localStorage`，用户认证状态将在浏览器的标签间记住。
- en: In `client/auth/auth-helper.js`, we will define the helper methods discussed
    in the following sections to store and retrieve JWT credentials from client-side `sessionStorage`,
    and also clear out the `sessionStorage` on user sign-out.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `client/auth/auth-helper.js` 中，我们将定义以下章节中讨论的辅助方法，以从客户端的 `sessionStorage` 中存储和检索
    JWT 凭据，并在用户登出时清除 `sessionStorage`。
- en: Saving credentials
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存凭据
- en: In order to save the JWT credentials that are received from the server on successful
    sign-in, we use the `authenticate` method, which is defined as follows.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在成功登录后保存从服务器接收到的 JWT 凭据，我们使用 `authenticate` 方法，该方法定义如下。
- en: '`mern-skeleton/client/auth/auth-helper.js`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/auth/auth-helper.js`:'
- en: '[PRE32]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `authenticate` method takes the JWT credentials, `jwt`, and a callback function, `cb`,
    as arguments. It stores the credentials in `sessionStorage` after ensuring `window`
    is defined, in other words ensuring this code is running in a browser and hence
    has access to `sessionStorage`. Then, it executes the callback function that is
    passed in. This callback will allow the component – in our case, the component
    where sign-in is called – to define actions that should take place after successfully
    signing in and storing credentials. Next, we will discuss the method that lets
    us access these stored credentials.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`authenticate` 方法接受 JWT 凭据 `jwt` 和一个回调函数 `cb` 作为参数。在确保 `window` 已定义后，即在确保此代码在浏览器中运行并因此可以访问
    `sessionStorage` 后，它将凭据存储在 `sessionStorage` 中。然后，它执行传入的回调函数。此回调将允许组件——在我们的例子中，是调用登录的组件——定义在成功登录并存储凭据后应执行的操作。接下来，我们将讨论让我们访问这些存储凭据的方法。'
- en: Retrieving credentials
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检索凭据
- en: In our frontend components, we will need to retrieve the stored credentials
    to check if the current user is signed in. In the `isAuthenticated()` method,
    we can retrieve these credentials from `sessionStorage`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的前端组件中，我们需要检索存储的凭据以检查当前用户是否已登录。在 `isAuthenticated()` 方法中，我们可以从 `sessionStorage`
    中检索这些凭据。
- en: '`mern-skeleton/client/auth/auth-helper.js`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/auth/auth-helper.js`:'
- en: '[PRE33]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: A call to `isAuthenticated()` will return either the stored credentials or `false`,
    depending on whether credentials were found in `sessionStorage`. Finding credentials
    in storage will mean a user is signed in, whereas not finding credentials will
    mean the user is not signed in. We will also add a method that allows us to delete
    the credentials from storage when a signed-in user signs out from the application.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 对`isAuthenticated()`的调用将返回存储的凭据或`false`，这取决于是否在`sessionStorage`中找到了凭据。在存储中找到凭据意味着用户已登录，而没有找到凭据则意味着用户未登录。我们还将添加一个方法，允许我们在登录用户从应用程序注销时从存储中删除凭据。
- en: Deleting credentials
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除凭据
- en: When a user successfully signs out from the application, we want to clear the
    stored JWT credentials from `sessionStorage`. This can be accomplished by calling
    the `clearJWT` method, which is defined in the following code.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户成功从应用程序注销时，我们希望从`sessionStorage`中清除存储的JWT凭据。这可以通过调用以下代码中定义的`clearJWT`方法来实现。
- en: '`mern-skeleton/client/auth/auth-helper.js`:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/auth/auth-helper.js`:'
- en: '[PRE34]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This `clearJWT` method takes a callback function as an argument, and it removes
    the JWT credential from `sessionStorage`. The passed in `cb()` function allows
    the component initiating the `signout` functionality to dictate what should happen
    after a successful sign-out.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`clearJWT`方法接受一个回调函数作为参数，并从`sessionStorage`中移除JWT凭据。传入的`cb()`函数允许启动`signout`功能的组件决定在成功注销后应该发生什么。
- en: The `clearJWT` method also uses the `signout` method we defined earlier in `api-auth.js`
    to call the signout API in the backend. If we had used `cookies` to store the
    credentials instead of `sessionStorage`, the response to this API call would be
    where we clear the cookie, as shown in the preceding code. Using the signout API
    call is optional since this is dependent on whether cookies are used as the credential
    storage mechanism.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`clearJWT`方法还使用了我们在`api-auth.js`中定义的`signout`方法来调用后端中的注销API。如果我们使用`cookies`而不是`sessionStorage`来存储凭据，那么对这个API调用的响应将是我们清除cookie的地方，如前面的代码所示。使用注销API调用是可选的，因为这取决于是否使用cookie作为凭据存储机制。'
- en: With these three methods, we now have ways of storing, retrieving, and deleting
    JWT credentials on the client-side. Using these methods, the React components
    we build for the frontend will be able to check and manage user auth state to
    restrict access in the frontend, as demonstrated in the following section with
    the custom `PrivateRoute` component.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这三个方法，我们现在有了在客户端存储、检索和删除JWT凭据的方法。使用这些方法，我们为前端构建的React组件将能够检查和管理用户认证状态，以限制前端访问，如下一节中自定义`PrivateRoute`组件所示。
- en: The PrivateRoute component
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`PrivateRoute`组件'
- en: The code in the file defines the `PrivateRoute` component, as shown in the auth
    flow example at [https://reacttraining.com/react-router/web/example/auth-workflow](https://reacttraining.com/react-router/web/example/auth-workflow),
    which can be found in the React Router documentation. It will allow us to declare
    protected routes for the frontend to restrict view access based on user auth.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 文件中的代码定义了`PrivateRoute`组件，如[https://reacttraining.com/react-router/web/example/auth-workflow](https://reacttraining.com/react-router/web/example/auth-workflow)中的认证流程示例所示，该示例可在React
    Router文档中找到。它将允许我们为前端声明受保护的路线，根据用户认证来限制视图访问。
- en: '`mern-skeleton/client/auth/PrivateRoute.js`:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/auth/PrivateRoute.js`:'
- en: '[PRE35]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Components to be rendered in this `PrivateRoute` will only load when the user
    is authenticated, which is determined by a call to the `isAuthenticated` method;
    otherwise, the user will be redirected to the `Signin` component. We load the
    components that should have restricted access, such as the user profile component,
    in a `PrivateRoute`. This will ensure that only authenticated users are able to
    view the user profile page.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在此`PrivateRoute`中要渲染的组件只有在用户认证时才会加载，这是通过调用`isAuthenticated`方法确定的；否则，用户将被重定向到`Signin`组件。我们将在`PrivateRoute`中加载应有限制访问的组件，例如用户配置文件组件，这将确保只有认证用户才能查看用户配置文件页面。
- en: With the backend APIs integrated and the auth management helper methods ready
    for use in the components, we can now start building the remaining view components
    that utilize these methods and complete the frontend.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在将后端API集成并准备好在组件中使用认证管理辅助方法后，我们现在可以开始构建剩余的视图组件，这些组件利用这些方法并完成前端。
- en: Completing the User frontend
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成用户前端
- en: 'The React components that will be described in this section complete the interactive
    features we defined for the skeleton by allowing users to view, create, and modify
    user data stored in the database with respect to auth restrictions. The components
    we will implement are as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中将要描述的React组件通过允许用户根据认证限制查看、创建和修改存储在数据库中的用户数据，从而完成我们为骨架定义的交互式功能。我们将实现的组件如下：
- en: '`Users`: To fetch and list all users from the database to the view'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Users`: 从数据库获取并显示所有用户'
- en: '`Signup`: To display a form that allows new users to sign up'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Signup`: 显示一个表单，允许新用户注册'
- en: '`Signin`: To display a form that allows existing users to sign in'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Signin`: 显示一个表单，允许现有用户登录'
- en: '`Profile`: To display details for a specific user after retrieving from the
    database'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Profile`: 在从数据库检索后显示特定用户的详细信息'
- en: '`EditProfile`: To display details for a specific user and allow authorized
    user to update these details'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EditProfile`: 显示特定用户的详细信息，并允许授权用户更新这些信息'
- en: '`DeleteUser`: To allow an authorized user to delete their account from the
    application'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DeleteUser`: 允许授权用户从应用程序中删除他们的账户'
- en: '`Menu`: To add a common navigation bar to each view in the application'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Menu`: 为应用程序中的每个视图添加一个通用的导航栏'
- en: For each of these components, we will go over their unique aspects, as well
    as how to add them to the application in the `MainRouter`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些组件中的每一个，我们将讨论它们的独特之处，以及如何在`MainRouter`中添加它们。
- en: The Users component
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户组件
- en: 'The `Users` component in `client/user/Users.js` shows the names of all the
    users that have been fetched from the database and links each name to the user
    profile. The following component can be viewed by any visitor to the application
    and will render at the `''/users''` route:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`client/user/Users.js`中的`Users`组件显示了从数据库中检索到的所有用户的名称，并将每个名称链接到用户个人资料。以下组件可以被应用程序的任何访客查看，并在`''/users''`路由上渲染：'
- en: '![](img/276f7c2c-23cf-4c9e-937e-8481d3924c81.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/276f7c2c-23cf-4c9e-937e-8481d3924c81.png)'
- en: In the component definition, similar to how we implemented the `Home` component,
    we define and export a function component. In this component, we start by initializing
    the state with an empty array of users.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件定义中，类似于我们实现`Home`组件的方式，我们定义并导出一个函数组件。在这个组件中，我们首先使用一个空的用户数组初始化状态。
- en: '`mern-skeleton/client/user/Users.js`:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/user/Users.js`:'
- en: '[PRE36]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We are using the built-in React hook, `useState`, to add state to this function
    component. By calling this hook, we are essentially declaring a state variable
    named `users`, which can be updated by invoking `setUsers`, and also set the initial
    value of `users` to `[]`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用内置的React钩子`useState`给这个函数组件添加状态。通过调用这个钩子，我们实际上声明了一个名为`users`的状态变量，可以通过调用`setUsers`来更新它，并将`users`的初始值设置为`[]`。
- en: Using the built-in `useState` hook allows us to add state behavior to a function
    component in React. Calling it will declare a state variable, similar to using
    `this.state` in class component definitions. The argument that's passed to `useState`
    is the initial value of this variable – in other words, the initial state. Invoking
    `useState` returns the current state and a function that updates the state value,
    which is similar to `this.setState` in a class definition.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内置的`useState`钩子允许我们在React中给函数组件添加状态行为。调用它将声明一个状态变量，类似于在类组件定义中使用`this.state`。传递给`useState`的参数是这个变量的初始值——换句话说，初始状态。调用`useState`返回当前状态和一个更新状态值的函数，这类似于类定义中的`this.setState`。
- en: With the `users` state initialized, next, we will use another built-in React
    hook named `useEffect` to fetch a list of users from the backend and update the
    `users` value in the state.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化`users`状态后，接下来我们将使用另一个内置的React钩子`useEffect`从后端获取用户列表并更新状态中的`users`值。
- en: The Effect Hook, `useEffect`, serves the purpose of the `componentDidMount`,
    `componentDidUpdate`, and `componentWillUnmount` React life cycle methods that
    we would otherwise use in React classes. Using this hook in a function component
    allows us to perform side effects such as fetching data from a backend. By default,
    React runs the effects defined with `useEffect` after every render, including
    the first render. But we can also instruct the effect to only rerun if something
    changes in state. Optionally, we can also define how to clean up after an effect,
    for example, to perform an action such as aborting a fetch signal when the component
    unmounts to avoid memory leaks.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`useEffect`钩子用于替代我们本应在React类中使用的`componentDidMount`、`componentDidUpdate`和`componentWillUnmount`生命周期方法。在函数组件中使用此钩子允许我们执行副作用，例如从后端获取数据。默认情况下，React在每次渲染后（包括第一次渲染）都会运行使用`useEffect`定义的效果。但我们可以指示效果仅在状态发生变化时重新运行。可选地，我们还可以定义在效果之后如何清理，例如，在组件卸载时执行取消fetch信号等操作，以避免内存泄漏。'
- en: In our `Users` component, we use `useEffect` to call the `list` method from
    the `api-user.js` helper methods. This will fetch the user list from the backend
    and load the user data into the component by updating the state.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Users`组件中，我们使用`useEffect`来调用`api-user.js`辅助方法中的`list`方法。这将从后端获取用户列表，并通过更新状态将用户数据加载到组件中。
- en: '`mern-skeleton/client/user/Users.js`:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/user/Users.js`:'
- en: '[PRE37]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this effect, we also add a cleanup function to abort the fetch call when
    the component unmounts. To associate a signal with the fetch call, we use the
    AbortController web API, which allows us to abort DOM requests as needed.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在此效果中，我们还添加了一个清理函数，在组件卸载时取消fetch调用。为了将信号与fetch调用关联起来，我们使用AbortController Web
    API，这允许我们根据需要取消DOM请求。
- en: In the second argument of this `useEffect` hook, we pass an empty array so that
    this effect cleanup runs only once upon mounting and unmounting, and not after
    every render.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在此`useEffect`钩子的第二个参数中，我们传递一个空数组，以便此效果清理只在组件挂载和卸载时运行一次，而不是在每次渲染后。
- en: Finally, in the return of the `Users` function component, we add the actual
    view content. The view is composed of Material-UI components such as `Paper`,
    `List`, and `ListItem`. These elements are styled with the CSS that is defined
    and made available with the `makeStyles` hook, the same way as in the `Home` component.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`Users`函数组件的返回值中，我们添加实际视图内容。视图由Material-UI组件组成，如`Paper`、`List`和`ListItem`。这些元素使用`makeStyles`钩子定义和提供的CSS进行样式化，与`Home`组件中的方式相同。
- en: '`mern-skeleton/client/user/Users.js`:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/user/Users.js`:'
- en: '[PRE38]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this view, to generate each list item, we iterate through the array of users
    in the state using the `map` function. A list item is rendered with an individual
    user's name from each item that's accessed per iteration on the users array.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种观点下，为了生成每个列表项，我们使用`map`函数遍历状态中的用户数组。每个列表项都会渲染从用户数组中访问的每个项目的单个用户名称。
- en: To add this `Users` component to the React application, we need to update the
    `MainRouter` component with a `Route` that renders this component at the `'/users'` path.
    Add the `Route` inside the `Switch` component after the `Home` route.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此`Users`组件添加到React应用程序中，我们需要更新`MainRouter`组件，添加一个在`'/users'`路径上渲染此组件的`Route`。在`Home`路由之后，将`Route`添加到`Switch`组件内部。
- en: '`mern-skeleton/client/MainRouter.js`:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/MainRouter.js`:'
- en: '[PRE39]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To see this view rendered in the browser, you can temporarily add a `Link`
    component to the `Home` component to be able to route to the `Users` component:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 要在浏览器中看到此视图的渲染效果，您可以暂时将`Link`组件添加到`Home`组件中，以便能够路由到`Users`组件：
- en: '[PRE40]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Clicking on this link after rendering the Home view at the root route in the
    browser will display the `Users` component we implemented in this section. We
    will implement the other React components similarly, starting with the `Signup`
    component in the next section.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中渲染根路由的首页视图后，点击此链接将显示我们在本节中实现的`Users`组件。我们将在下一节中类似地实现其他React组件，从`Signup`组件开始。
- en: The Signup component
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册组件
- en: 'The `Signup` component in `client/user/Signup.js` presents a form with name,
    email, and password fields to the user for sign-up at the `''/signup''` path,
    as displayed in the following screenshot:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`client/user/Signup.js`中的`Signup`组件向用户展示一个包含姓名、电子邮件和密码字段的表单，用于在`''/signup''`路径上注册，如下截图所示：'
- en: '![](img/b786119b-9e65-40ee-bb58-1d26f7a0f4d9.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/b786119b-9e65-40ee-bb58-1d26f7a0f4d9.png)'
- en: In the component definition, we initialize the state using the `useState` hook
    with empty input field values, an empty error message, and set the dialog open
    variable to false.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件定义中，我们使用 `useState` 钩子初始化状态，使用空的输入字段值、空的错误消息，并将对话框打开变量设置为 `false`。
- en: '`mern-skeleton/client/user/Signup.js`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/user/Signup.js`:'
- en: '[PRE41]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We also define two handler functions to be called when the input values change
    or the submit button is clicked. The `handleChange` function takes the new value
    that's entered in the input field and sets it as the state.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了两个处理函数，用于在输入值更改或点击提交按钮时调用。`handleChange` 函数接受输入字段中输入的新值，并将其设置为状态。
- en: '`mern-skeleton/client/user/Signup.js`:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/user/Signup.js`:'
- en: '[PRE42]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `clickSubmit` function is called when the form is submitted. It takes the
    input values from the state and calls the `create` fetch method to sign up the
    user with the backend. Then, depending on the response from the server, either
    an error message is shown or a success dialog is shown.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 当表单提交时，会调用 `clickSubmit` 函数。该函数从状态中获取输入值，并调用 `create` fetch 方法在后端注册用户。然后，根据服务器的响应，要么显示错误消息，要么显示成功对话框。
- en: '`mern-skeleton/client/user/Signup.js`:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/user/Signup.js`:'
- en: '[PRE43]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the `return` function, we compose and style the form components in the signup
    view using components such as `TextField` from Material-UI.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `return` 函数中，我们使用 Material-UI 的 `TextField` 等组件组合和样式化注册视图中的表单组件。
- en: '`mern-skeleton/client/user/Signup.js`:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/user/Signup.js`:'
- en: '[PRE44]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This return also contains an error message block, along with a `Dialog` component
    that is conditionally rendered depending on the signup response from the server.
    If the server returns an error, the error block that was added below the form,
    which we implemented in the preceding code, will render in the view with the corresponding
    error message. If the server returns a successful response, a `Dialog` component
    will be rendered instead.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 此返回值还包含一个错误消息块，以及一个根据服务器注册响应条件渲染的 `Dialog` 组件。如果服务器返回错误，则添加到表单下方的错误块（我们在前面的代码中实现），将在视图中渲染相应的错误消息。如果服务器返回成功响应，则将渲染一个 `Dialog` 组件。
- en: The `Dialog` component in `Signup.js` is composed as follows.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`Signup.js` 中的 `Dialog` 组件如下组成。'
- en: '`mern-skeleton/client/user/Signup.js`:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/user/Signup.js`:'
- en: '[PRE45]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'On successful account creation, the user is given confirmation and asked to
    sign in using this `Dialog` component, which links to the `Signin` component, as
    shown in the following screenshot:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功创建账户后，用户会收到确认信息，并被要求使用此 `Dialog` 组件进行登录，该组件链接到 `Signin` 组件，如下截图所示：
- en: '![](img/a3edd525-ab6e-4021-8e15-2f0b90fe1928.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/a3edd525-ab6e-4021-8e15-2f0b90fe1928.png)'
- en: To add the `Signup` component to the app, add the following `Route` to `MainRouter` in
    the `Switch` component.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 `Signup` 组件添加到应用中，请将以下 `Route` 添加到 `Switch` 组件中的 `MainRouter`。
- en: '`mern-skeleton/client/MainRouter.js`:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/MainRouter.js`:'
- en: '[PRE46]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This will render the `Signup` view at `'/signup'`. Similarly, we will implement
    the `Signin` component next.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在 `'/signup'` 路径上渲染 `Signup` 视图。同样，我们将接下来实现 `Signin` 组件。
- en: The Signin component
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登录组件
- en: 'The `Signin` component in `client/auth/Signin.js` is also a form with only
    email and password fields for signing in. This component is quite similar to the `Signup` component
    and will render at the `''/signin''` path. The key difference is in the implementation
    of redirection after a successful sign-in and storing the received JWT credentials.
    The rendered `Signin` component can be seen in the following screenshot:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`client/auth/Signin.js` 中的 `Signin` 组件也是一个仅包含电子邮件和密码字段的登录表单。该组件与 `Signup` 组件非常相似，将在 `''/signin''` 路径上渲染。关键区别在于成功登录后的重定向实现以及存储接收到的
    JWT 凭证。渲染的 `Signin` 组件如下截图所示：'
- en: '![](img/c43a997a-7aac-4897-8e47-ac3c084e349e.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/c43a997a-7aac-4897-8e47-ac3c084e349e.png)'
- en: 'For redirection, we will use the `Redirect` component from React Router. First,
    initialize a `redirectToReferrer` value to `false` in the state with the other
    fields:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 对于重定向，我们将使用 React Router 的 `Redirect` 组件。首先，在状态中将 `redirectToReferrer` 值初始化为 `false`，与其他字段一起：
- en: '`mern-skeleton/client/auth/Signin.js`:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/auth/Signin.js`:'
- en: '[PRE47]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `Signin` function will take props in the argument that contain React Router
    variables. We will use these for the redirect. `redirectToReferrer` should be
    set to `true` when the user successfully signs in after submitting the form and
    the received JWT is stored in `sessionStorage`. To store the JWT and redirect
    afterward, we will call the `authenticate()` method defined in `auth-helper.js`.
    This implementation will go in the `clickSubmit()` function so that it can be
    called on form submit.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`Signin`函数将接受包含React Router变量的props作为参数。我们将使用这些变量进行重定向。当用户在提交表单后成功登录，并且收到的JWT存储在`sessionStorage`中时，`redirectToReferrer`应设置为`true`。为了存储JWT并在之后进行重定向，我们将调用在`auth-helper.js`中定义的`authenticate()`方法。这种实现将放在`clickSubmit()`函数中，以便在表单提交时调用。'
- en: '`mern-skeleton/client/auth/Signin.js`:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/auth/Signin.js`:'
- en: '[PRE48]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The redirection will happen conditionally based on the `redirectToReferrer` value
    using the `Redirect` component from React Router. We add the redirect code inside
    the function before the return block, as follows.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 重定向将根据`redirectToReferrer`的值条件性地发生，使用React Router中的`Redirect`组件。我们将在函数的返回块之前添加重定向代码，如下所示。
- en: '`mern-skeleton/client/auth/Signin.js`:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/auth/Signin.js`:'
- en: '[PRE49]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `Redirect` component, if rendered, will take the app to the last location
    that was received in the props or to the `Home` component at the root.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如果渲染了`Redirect`组件，它将带应用程序到在props中接收到的最后一个位置，或者到根目录的`Home`组件。
- en: The function return code is not displayed here as it is very similar to the
    code in `Signup`. It will contain the same form elements with just `email` and `password` fields,
    a conditional error message, and the `submit` button.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 函数返回的代码在此处未显示，因为它与`Signup`中的代码非常相似。它将包含相同的表单元素，只是`email`和`password`字段，一个条件性错误消息，以及`submit`按钮。
- en: To add the `Signin` component to the app, add the following Route to `MainRouter` in
    the `Switch` component.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 要将`Signin`组件添加到应用程序中，请将以下Route添加到`MainRouter`中的`Switch`组件。
- en: '`mern-skeleton/client/MainRouter.js`:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/MainRouter.js`:'
- en: '[PRE50]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This will render the `Signin` component at `"/signin"` and can be linked in
    the Home component, similar to the `Signup` component, so that it can be viewed
    in the browser. Next, we will implement the profile view to display the details
    of a single user.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`"/signin"`处渲染`Signin`组件，并且可以在Home组件中链接，类似于`Signup`组件，以便在浏览器中查看。接下来，我们将实现个人资料视图以显示单个用户的详细信息。
- en: The Profile component
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Profile`组件'
- en: 'The `Profile` component in `client/user/Profile.js` shows a single user''s
    information in the view at the `''/user/:userId''` path, where the `userId` parameter
    represents the ID of the specific user. The completed `Profile` will display user
    details, and also conditionally show edit/delete options. The following screenshot
    shows how the `Profile` renders when the user currently browsing is viewing someone
    else''s profile and not their own profile:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`client/user/Profile.js`中的`Profile`组件在`''/user/:userId''`路径的视图中显示单个用户的信息，其中`userId`参数代表特定用户的ID。完成的`Profile`将显示用户详细信息，并条件性地显示编辑/删除选项。以下截图显示了当当前浏览的用户正在查看其他用户的个人资料而不是自己的个人资料时，`Profile`是如何渲染的：'
- en: '![](img/cef473f4-40dc-4c07-9bb2-e6d42319711a.png)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cef473f4-40dc-4c07-9bb2-e6d42319711a.png)'
- en: This profile information can be fetched from the server if the user is signed
    in. To verify this, the component has to provide the JWT credential to the `read`
    fetch call; otherwise, the user should be redirected to the Sign In view.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户已登录，则可以从服务器获取此配置文件信息。为了验证这一点，组件必须向`read`获取调用提供JWT凭证；否则，用户应重定向到登录视图。
- en: In the `Profile` component definition, we need to initialize the state with
    an empty user and set `redirectToSignin` to `false`.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Profile`组件定义中，我们需要使用空用户初始化状态，并将`redirectToSignin`设置为`false`。
- en: '`mern-skeleton/client/user/Profile.js`:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/user/Profile.js`:'
- en: '[PRE51]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We also need to get access to the `match` props passed by the `Route` component,
    which will contain a `:userId` parameter value. This can be accessed as `match.params.userId`.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要获取由`Route`组件传递的`match` props的访问权限，它将包含一个`:userId`参数值。这可以通过`match.params.userId`访问。
- en: The `Profile` component should fetch user information and render the view with
    these details. To implement this, we will use the `useEffect` hook, as we did
    in the `Users` component.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`Profile`组件应获取用户信息并使用这些详细信息渲染视图。为了实现这一点，我们将使用`useEffect`钩子，就像我们在`Users`组件中所做的那样。'
- en: '`mern-skeleton/client/user/Profile.js`:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/user/Profile.js`:'
- en: '[PRE52]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This effect uses the `match.params.userId` value and calls the `read` user fetch
    method. Since this method also requires credentials to authorize the signed-in
    user, the JWT is retrieved from `sessionStorage` using the `isAuthenticated` method
    from `auth-helper.js`, and passed in the call to `read`.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 此效果使用`match.params.userId`值并调用`read`用户获取方法。由于此方法还需要凭据来授权已登录的用户，因此使用`auth-helper.js`中的`isAuthenticated`方法从`sessionStorage`检索JWT，并将其传递给`read`调用。
- en: Once the server responds, either the state is updated with the user information
    or the view is redirected to the Sign In view if the current user is not authenticated.
    We also add a cleanup function in this effect hook to abort the fetch signal when
    the component unmounts.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务器响应，要么将状态更新为用户信息，要么如果当前用户未认证，将视图重定向到登录视图。我们还在此效果钩子中添加了一个清理函数，以便在组件卸载时中止获取信号。
- en: This effect only needs to rerun when the `userId` parameter changes in the route,
    for example, when the app goes from one profile view to the other. To ensure this
    effect reruns when the `userId` value updates, we will add `[match.params.userId]` in
    the second argument to `useEffect`.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 此效果仅在路由中的`userId`参数更改时需要重新运行，例如，当应用程序从一个个人资料视图切换到另一个视图时。为了确保在`userId`值更新时此效果重新运行，我们将在`useEffect`的第二个参数中添加`[match.params.userId]`。
- en: If the current user is not authenticated, we set up the conditional redirect
    to the Sign In view.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前用户未认证，我们将设置条件重定向到登录视图。
- en: '`mern-skeleton/client/user/Profile.js`'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/user/Profile.js`'
- en: '[PRE53]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The function will return the `Profile` view with the following elements if the
    user who's currently signed in is viewing another user's profile.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前登录的用户正在查看另一个用户的个人资料，该函数将返回包含以下元素的`Profile`视图。
- en: '`mern-skeleton/client/user/Profile.js`:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/user/Profile.js`:'
- en: '[PRE54]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'However, if the user that''s currently signed in is viewing their own profile,
    they will be able to see edit and delete options in the `Profile` component, as
    shown in the following screenshot:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果当前登录的用户正在查看自己的个人资料，他们将在`Profile`组件中看到编辑和删除选项，如下面的截图所示：
- en: '![](img/1015c42c-63e0-4226-9868-f65ee50d15d4.png)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1015c42c-63e0-4226-9868-f65ee50d15d4.png)'
- en: To implement this feature, in the first `ListItem` component in the `Profile`,
    add a `ListItemSecondaryAction` component containing the `Edit` button and a `DeleteUser`
    component, which will render conditionally based on whether the current user is
    viewing their own profile.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现此功能，在`Profile`中的第一个`ListItem`组件中添加一个包含`Edit`按钮和`DeleteUser`组件的`ListItemSecondaryAction`组件，该组件将根据当前用户是否查看自己的个人资料有条件地渲染。
- en: '`mern-skeleton/client/user/Profile.js`:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/user/Profile.js`:'
- en: '[PRE55]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `Edit` button will route to the `EditProfile` component, while the custom
    `DeleteUser` component will handle the delete operation with the `userId` passed
    to it as a prop.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '`Edit`按钮将路由到`EditProfile`组件，而自定义的`DeleteUser`组件将处理删除操作，并将`userId`作为prop传递给它。'
- en: To add the `Profile` component to the app, add the `Route` to `MainRouter` in
    the `Switch` component.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 要将`Profile`组件添加到应用程序中，请将`Route`添加到`Switch`组件中的`MainRouter`。
- en: '`mern-skeleton/client/MainRouter.js`:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/MainRouter.js`:'
- en: '[PRE56]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: To visit this route in the browser and render a `Profile` with user details,
    the link should be composed with a valid user ID in it. In the next section, we
    will use this same approach of retrieving single user details and rendering it
    in the component to implement the Edit Profile view.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 要在浏览器中访问此路由并渲染包含用户详情的`Profile`，链接中应包含有效的用户ID。在下一节中，我们将使用相同的方法检索单个用户详情并在组件中渲染它来实现编辑个人资料视图。
- en: The EditProfile component
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EditProfile组件
- en: 'The `EditProfile` component in `client/user/EditProfile.js` has similarities
    in its implementation to both the `Signup` and `Profile` components. It allows
    the authorized user to edit their own profile information in a form similar to
    the signup form, as shown in the following screenshot:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '`client/user/EditProfile.js`中的`EditProfile`组件在其实现上与`Signup`和`Profile`组件有相似之处。它允许授权用户以与注册表单类似的形式编辑自己的个人资料信息，如下面的截图所示：'
- en: '![](img/3df6da71-c22b-416b-bd85-8d3b6363b112.png)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3df6da71-c22b-416b-bd85-8d3b6363b112.png)'
- en: Upon loading at `'/user/edit/:userId'`, the component will fetch the user's
    information with their ID after verifying JWT for auth, and then load the form
    with the received user information. The form will allow the user to edit and submit
    only the changed information to the `update` fetch call, and, on successful update,
    redirect the user to the `Profile` view with updated information.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在`'/user/edit/:userId'`加载时，组件将在验证JWT进行身份验证后，使用其ID获取用户信息，然后加载带有接收到的用户信息的表单。表单将允许用户编辑并提交仅更改的信息到`update`获取调用，并且在更新成功后，将用户重定向到带有更新信息的`Profile`视图。
- en: '`EditProfile` will load the user information the same way as in the `Profile`
    component, that is, by fetching with `read` in `useEffect` using the `userId`
    parameter from `match.params`. It will gather credentials from `auth.isAuthenticated`.
    The form view will contain the same elements as the `Signup` component, with the
    input values being updated in the state when they change.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '`EditProfile`将以与`Profile`组件相同的方式加载数据，即通过在`useEffect`中使用`match.params`中的`userId`参数进行`read`获取。它将从`auth.isAuthenticated`中收集凭证。表单视图将包含与`Signup`组件相同的元素，当输入值发生变化时，它们将在状态中更新。'
- en: On form submit, the component will call the `update` fetch method with the `userId`,
    JWT and updated user data.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在表单提交时，组件将调用带有`userId`、JWT和更新后的用户数据的`update`获取方法。
- en: '`mern-skeleton/client/user/EditProfile.js`:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/user/EditProfile.js`:'
- en: '[PRE57]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Depending on the response from the server, the user will either see an error
    message or be redirected to the updated Profile page using the `Redirect` component,
    as follows.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 根据服务器的响应，用户将看到错误消息或使用`Redirect`组件重定向到更新后的个人资料页面，如下所示。
- en: '`mern-skeleton/client/user/EditProfile.js`:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/user/EditProfile.js`:'
- en: '[PRE58]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: To add the `EditProfile` component to the app, we will use a `PrivateRoute`,
    which will restrict the component from loading at all if the user is not signed
    in. The order of placement in `MainRouter` will also be important.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 要将`EditProfile`组件添加到应用程序中，我们将使用`PrivateRoute`，这将阻止未登录的用户加载组件。在`MainRouter`中的放置顺序也将很重要。
- en: '`mern-skeleton/client/MainRouter.js`:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/MainRouter.js`:'
- en: '[PRE59]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The route with the `'/user/edit/:userId'` path needs to be placed before the
    route with the `'/user/:userId'` path, so that the edit path is matched first
    exclusively in the Switch component when this route is requested, and not confused
    with the `Profile` route.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 带有`'/user/edit/:userId'`路径的路由需要放在带有`'/user/:userId'`路径的路由之前，这样在请求此路由时，Switch组件将首先唯一匹配编辑路径，而不会与`Profile`路由混淆。
- en: With this profile edit view added, we only have the user delete UI implementation
    left to complete the user-related frontend.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了此个人资料编辑视图后，我们只剩下用户删除UI实现需要完成用户相关的前端。
- en: The DeleteUser component
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DeleteUser组件
- en: 'The `DeleteUser` component in `client/user/DeleteUser.js` is basically a button
    that we will add to the Profile view that, when clicked, opens a `Dialog` component
    asking the user to confirm the `delete` action, as shown in the following screenshot:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '`client/user/DeleteUser.js`中的`DeleteUser`组件基本上是一个按钮，我们将将其添加到个人资料视图中，当点击时，将打开一个`Dialog`组件，提示用户确认`delete`操作，如下面的截图所示：'
- en: '![](img/46ebac43-14ae-484d-8393-7445c320f5bf.png)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46ebac43-14ae-484d-8393-7445c320f5bf.png)'
- en: This component initializes the state with `open` set to `false` for the `Dialog`
    component, as well as `redirect` set to `false` so that it isn't rendered first.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件将`Dialog`组件的`open`状态初始化为`false`，以及将`redirect`设置为`false`，以便它不会首先渲染。
- en: '`mern-skeleton/client/user/DeleteUser.js`:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/user/DeleteUser.js`:'
- en: '[PRE60]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The `DeleteUser` component will also receive props from the parent component.
    In this case, the props will contain the `userId` that was sent from the `Profile`
    component.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '`DeleteUser`组件也将从父组件接收属性。在这种情况下，属性将包含从`Profile`组件发送的`userId`。'
- en: Next, we need some handler methods to open and close the `dialog` button. The
    dialog is opened when the user clicks the `delete` button.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一些处理方法来打开和关闭`dialog`按钮。当用户点击`delete`按钮时，对话框将被打开。
- en: '`mern-skeleton/client/user/DeleteUser.js`:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/user/DeleteUser.js`:'
- en: '[PRE61]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The dialog is closed when the user clicks `cancel` on the dialog.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在对话框中点击`cancel`时，对话框将被关闭。
- en: '`mern-skeleton/client/user/DeleteUser.js`:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/user/DeleteUser.js`:'
- en: '[PRE62]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The component will have access to the `userId` that's passed in as a prop from
    the `Profile` component, which is needed to call the `remove` fetch method, along
    with the JWT credentials, after the user confirms the `delete` action in the dialog.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 组件将能够访问从 `Profile` 组件作为属性传递的 `userId`，这是调用 `remove` 获取方法所需的，以及用户在对话框中确认删除操作后的
    JWT 凭据。
- en: '`mern-skeleton/client/user/DeleteUser.js`:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/user/DeleteUser.js`:'
- en: '[PRE63]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'On confirmation, the `deleteAccount` function calls the `remove` fetch method
    with the `userId` from props and JWT from `isAuthenticated`. On successful deletion,
    the user will be signed out and redirected to the Home view. The `Redirect` component
    from React Router is used to redirect the current user to the Home view, as follows:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在确认后，`deleteAccount` 函数调用带有从属性中获取的 `userId` 和来自 `isAuthenticated` 的 JWT 的 `remove`
    获取方法。在删除成功后，用户将被注销并重定向到主页视图。React Router 的 `Redirect` 组件用于将当前用户重定向到主页视图，如下所示：
- en: '[PRE64]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The component function returns the `DeleteUser` component elements, including
    a `DeleteIcon` button and the confirmation `Dialog`.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 组件函数返回 `DeleteUser` 组件元素，包括一个 `DeleteIcon` 按钮和确认 `Dialog`。
- en: '`mern-skeleton/client/user/DeleteUser.js`:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/user/DeleteUser.js`:'
- en: '[PRE65]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '`DeleteUser` takes the `userId` as a prop to be used in the `delete` fetch
    call, so we need to add a required prop validation check for this React component.
    We''ll do this next.'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '`DeleteUser` 接收 `userId` 作为属性，用于在 `delete` 获取调用中使用，因此我们需要为这个 React 组件添加一个必需的属性验证检查。我们将在下一步进行此操作。'
- en: Validating props with PropTypes
  id: totrans-395
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 PropTypes 验证属性
- en: To validate the required injection of `userId` as a prop to the component, we'll
    add the `PropTypes` requirement validator to the defined component.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证将 `userId` 作为属性注入到组件中的必要性，我们将在定义的组件中添加 `PropTypes` 验证器。
- en: '`mern-skeleton/client/user/DeleteUser.js`:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/user/DeleteUser.js`:'
- en: '[PRE66]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Since we are using the `DeleteUser` component in the `Profile` component, it
    gets added to the application view when `Profile` is added in `MainRouter`.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在 `Profile` 组件中使用了 `DeleteUser` 组件，因此当在 `MainRouter` 中添加 `Profile` 时，它会被添加到应用程序视图中。
- en: With the delete user UI added, we now have a frontend that contains all the
    React component views in order to complete the skeleton application features.
    But, we still need a common navigation UI to link all these views together and
    make each view easy to access for the frontend user. In the next section, we will
    implement this navigation menu component.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了删除用户界面之后，我们现在有一个包含所有 React 组件视图的前端，以便完成骨架应用程序的功能。但是，我们仍然需要一个公共导航 UI 来将这些视图连接起来，并使前端用户能够轻松访问每个视图。在下一节中，我们将实现这个导航菜单组件。
- en: The  Menu component
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 菜单组件
- en: The `Menu` component will function as a navigation bar across the frontend application
    by providing links to all the available views, and also by indicating the user's
    current location in the application.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '`Menu` 组件将通过提供对所有可用视图的链接以及指示用户在应用程序中的当前位置，作为前端应用程序中的导航栏工作。'
- en: To implement these navigation bar functionalities, we will use the HOC `withRouter` from
    React Router to get access to the `history` object's properties. The following
    code in the `Menu` component adds just the title, the `Home` icon linked to the
    root route, and the `Users` button, which is linked to the `'/users'` route.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这些导航栏功能，我们将使用 React Router 的 HOC `withRouter` 来获取对 `history` 对象属性的访问权限。以下
    `Menu` 组件中的代码仅添加了标题、链接到根路由的“主页”图标以及链接到 `'/users'` 路由的“用户”按钮。
- en: '`mern-skeleton/client/core/Menu.js`:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/core/Menu.js`:'
- en: '[PRE67]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: To indicate the current location of the application on the `Menu`, we will highlight
    the link that matches the current location path by changing the color conditionally.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 `Menu` 上指示应用程序的当前位置，我们将通过条件性地更改颜色来突出显示与当前位置路径匹配的链接。
- en: '`mern-skeleton/client/core/Menu.js`:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/core/Menu.js`:'
- en: '[PRE68]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The `isActive` function is used to apply color to the buttons in the `Menu`,
    as follows:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '`isActive` 函数用于将颜色应用到 `Menu` 中的按钮上，如下所示：'
- en: '[PRE69]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The remaining links such as SIGN IN, SIGN UP, MY PROFILE, and SIGN OUT will
    show up on the `Menu` based on whether the user is signed in or not. The following
    screenshot shows how the Menu renders when the user is not signed in:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 根据用户是否已登录，以下链接（如“登录”、“注册”、“我的资料”和“注销”）将显示在 `Menu` 中。以下截图显示了用户未登录时菜单的渲染方式：
- en: '![](img/af094174-ddd9-4444-9c5c-90ae2230144d.png)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/af094174-ddd9-4444-9c5c-90ae2230144d.png)'
- en: For example, the links to SIGN UP and SIGN IN should only appear on the menu
    when the user is not signed in. Therefore, we need to add it to the `Menu` component
    after the `Users` button with a condition.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，只有当用户未登录时，注册和登录的链接才应出现在菜单中。因此，我们需要在`Users`按钮之后添加它到`Menu`组件，并使用条件。
- en: '`mern-skeleton/client/core/Menu.js`:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/core/Menu.js`:'
- en: '[PRE70]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Similarly, the link to `MY PROFILE` and the `SIGN OUT` button should only appear
    on the menu when the user is signed in, and should be added to the `Menu` component
    with the following condition check.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，只有当用户已登录时，`MY PROFILE`链接和`SIGN OUT`按钮才应出现在菜单中，并且应使用以下条件检查添加到`Menu`组件中。
- en: '`mern-skeleton/client/core/Menu.js`:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/core/Menu.js`:'
- en: '[PRE71]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The MY PROFILE button uses the signed-in user''s information to link to the
    user''s own profile, while the SIGN OUT button calls the `auth.clearJWT()` method
    when it''s clicked. When the user is signed in, the `Menu` will look as follows:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，MY PROFILE按钮使用已登录用户的信息链接到用户的个人资料，而SIGN OUT按钮在点击时调用`auth.clearJWT()`方法。当用户已登录时，`Menu`将如下所示：
- en: '![](img/f0cc63b3-2970-4e7d-b313-6ff5cc246d62.png)'
  id: totrans-420
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f0cc63b3-2970-4e7d-b313-6ff5cc246d62.png)'
- en: To have the `Menu` navigation bar present in all the views, we need to add it
    to the `MainRouter` before all the other routes, and outside the `Switch` component.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 要使`Menu`导航栏在所有视图中都显示，我们需要在所有其他路由之前，并在`Switch`组件外部将其添加到`MainRouter`。
- en: '`mern-skeleton/client/MainRouter.js`:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/MainRouter.js`:'
- en: '[PRE72]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This will make the `Menu` component render on top of all the other components
    when these components are accessed at their respective routes.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使`Menu`组件在访问相应路由时渲染在其他所有组件之上。
- en: The skeleton frontend is now complete and has all necessary components to allow
    a user to sign up, view, and modify user data on the backend while considering
    authentication and authorization restrictions. However, it is still not possible
    to visit the frontend routes directly in the browser address bar; these can only
    be accessed when they're linked from within the frontend view. To enable this
    functionality in the skeleton application, we need to implement basic server-side
    rendering.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 前端骨架现在已完整，并包含所有必要的组件，允许用户在考虑身份验证和授权限制的情况下，在后台注册、查看和修改用户数据。然而，目前还不能直接在浏览器地址栏中访问前端路由；这些路由只能在前端视图中链接时访问。为了在骨架应用程序中启用此功能，我们需要实现基本的服务器端渲染。
- en: Implementing basic server-side rendering
  id: totrans-426
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现基本的服务器端渲染
- en: Currently, when the React Router routes or pathnames are directly entered in
    the browser address bar or when a view that is not at the root path is refreshed,
    the URL does not work. This happens because the server does not recognize the
    React Router routes we defined in the frontend. We have to implement basic server-side
    rendering on the backend so that the server is able to respond when it receives
    a request to a frontend route.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，当React Router路由或路径名直接输入到浏览器地址栏中，或者当非根路径的视图刷新时，URL不起作用。这是因为服务器无法识别我们在前端定义的React
    Router路由。我们必须在后台实现基本的服务器端渲染，以便服务器在接收到对前端路由的请求时能够响应。
- en: To render the relevant React components properly when the server receives requests
    to the frontend routes, we need to initially generate the React components on
    the server-side with regard to the React Router and Material-UI components, before
    the client-side JS is ready to take over the rendering.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在服务器接收到对前端路由的请求时正确渲染相关React组件，我们需要在客户端JS准备好接管渲染之前，首先在服务器端根据React Router和Material-UI组件生成React组件。
- en: The basic idea behind server-side rendering React apps is to use the `renderToString`
    method from `react-dom` to convert the root React component into a markup string.
    Then, we can attach it to the template that the server renders when it receives
    a request.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端渲染React应用程序的基本思想是使用`react-dom`中的`renderToString`方法将根React组件转换为标记字符串。然后，我们可以将其附加到服务器在接收到请求时渲染的模板上。
- en: 'In `express.js`, we will replace the code that returns `template.js` in response
    to the `GET` request for `''/''` with code that, upon receiving any incoming GET
    request, generates some server-side rendered markup and the CSS of the relevant
    React component tree, before adding this markup and CSS to the template. This
    updated code will achieve the following:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在`express.js`中，我们将替换响应`'/'`的`GET`请求返回`template.js`的代码，用接收任何传入的GET请求时生成一些服务器端渲染的标记和相应React组件树的CSS的代码替换。此更新后的代码将实现以下功能：
- en: '[PRE73]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In the following sections, we will look at the implementation of the steps outlined
    in the preceding code block, and also discuss how to prepare the frontend so that
    it accepts and handles this server-rendered code.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将查看前面代码块中概述的步骤的实现，并讨论如何准备前端以便它接受和处理此服务器端渲染的代码。
- en: Modules for server-side rendering
  id: totrans-433
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端渲染模块
- en: 'To implement basic server-side rendering, we will need to import the following
    React, React Router, and Material-UI-specific modules into the server code. In
    our code structure, the following modules will be imported into `server/express.js`:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现基本的服务器端渲染，我们需要将以下React、React Router和Material-UI特定模块导入到服务器代码中。在我们的代码结构中，以下模块将被导入到`server/express.js`中：
- en: '**React modules**: The following modules are required to render the React components
    and use `renderToString`:'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**React模块**：以下模块是渲染React组件和使用`renderToString`所必需的：'
- en: '[PRE74]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '**Router modules**: `StaticRouter` is a stateless router that takes the requested
    URL to match with the frontend route which was declared in the `MainRouter` component.
    The `MainRouter` is the root component in our frontend.'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由模块**：`StaticRouter`是一个无状态的路由器，它接受请求的URL以匹配在`MainRouter`组件中声明的前端路由。`MainRouter`是我们前端中的根组件。'
- en: '[PRE75]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '**Material-UI modules and the custom theme**: The following modules will help
    generate the CSS styles for the frontend components based on the stylings and
    Material-UI theme that are used on the frontend:'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Material-UI模块和自定义主题**：以下模块将帮助根据前端使用的样式和Material-UI主题生成前端组件的CSS样式：'
- en: '[PRE76]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: With these modules, we can prepare, generate, and return server-side rendered
    frontend code, as we will discuss next.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些模块，我们可以准备、生成并返回服务器端渲染的前端代码，正如我们接下来将要讨论的。
- en: Generating CSS and markup
  id: totrans-442
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成CSS和标记
- en: To generate the CSS and markup representing the React frontend views on the
    server-side, we will use Material-UI's `ServerStyleSheets` and React's `renderToString`.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 要在服务器端生成表示React前端视图的CSS和标记，我们将使用Material-UI的`ServerStyleSheets`和React的`renderToString`。
- en: On every request received by the Express app, we will create a new `ServerStyleSheets`
    instance. Then, we will render the relevant React tree with the server-side collector
    in a call to `renderToString`, which ultimately returns the associated markup
    or HTML string version of the React view that is to be shown to the user in response
    to the requested URL.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 在Express应用接收到的每个请求中，我们将创建一个新的`ServerStyleSheets`实例。然后，我们将使用`renderToString`调用中的服务器端收集器渲染相关的React树，最终返回要向用户显示的React视图的关联标记或HTML字符串版本。
- en: The following code will be executed on every GET request that's received by
    the Express app.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将在Express应用接收到的每个GET请求上执行。
- en: '`mern-skeleton/server/express.js`:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/server/express.js`:'
- en: '[PRE77]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: While rendering the React tree, the client app's root component, `MainRouter`,
    is wrapped with the Material-UI  `ThemeProvider` to provide the styling props
    that are needed by the `MainRouter` child components. The stateless `StaticRouter`
    is used here instead of the `BrowserRouter` that's used on the client-side in
    order to wrap `MainRouter` and provide the routing props that are used for implementing
    the client-side components.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染React树时，客户端应用的根组件`MainRouter`被Material-UI的`ThemeProvider`包装，以提供`MainRouter`子组件所需的样式props。在这里使用无状态的`StaticRouter`而不是客户端上使用的`BrowserRouter`，是为了包装`MainRouter`并提供用于实现客户端组件的路由props。
- en: Based on these values, such as the requested `location` route and `theme` that
    are passed in as props to the wrapping components, `renderToString` will return
    the markup containing the relevant view.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些值，例如作为props传递给包装组件的请求的`location`路由和`theme`，`renderToString`将返回包含相关视图的标记。
- en: Sending a template with markup and CSS
  id: totrans-450
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送带有标记和CSS的模板
- en: Once the markup has been generated, we need to check if there was a `redirect`
    rendered in the component to be sent in the markup. If there was no redirect,
    then we get the CSS string from `sheets` using `sheets.toString`, and, in the
    response, we send the `Template` back with the markup and CSS injected, as shown
    in the following code.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦生成了标记，我们需要检查组件中是否生成了要发送在标记中的`redirect`。如果没有生成重定向，那么我们使用`sheets.toString`从`sheets`获取CSS字符串，并在响应中发送带有注入的标记和CSS的`Template`，如下面的代码所示。
- en: '`mern-skeleton/server/express.js`:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/server/express.js`:'
- en: '[PRE78]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: An example of a case where redirect is rendered in the component is when we're
    trying to access a `PrivateRoute` via a server-side render. As the server-side
    cannot access the auth token from the browser's `sessionStorage`, the redirect
    in `PrivateRoute` will render. The `context.url` value , in this case, will have
    the `'/signin'` route, and hence, instead of trying to render the `PrivateRoute`
    component, it will redirect to the `'/signin'` route.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试通过服务器端渲染访问 `PrivateRoute` 时，会渲染重定向的例子。由于服务器端无法从浏览器的 `sessionStorage` 中访问认证令牌，`PrivateRoute`
    中的重定向将会渲染。在这种情况下，`context.url` 的值将是 `'/signin'` 路由，因此，而不是尝试渲染 `PrivateRoute` 组件，它将重定向到
    `'/signin'` 路由。
- en: This completes the code we need to add to the server-side to enable the basic
    server-side rendering of the React views. Next, we need to update the frontend
    so it is able to integrate and render this server-generated code.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们需要添加到服务器端的代码，以启用 React 视图的简单服务器端渲染。接下来，我们需要更新前端，使其能够集成并渲染由服务器生成的代码。
- en: Updating template.js
  id: totrans-456
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新 template.js
- en: The markup and CSS that we generated on the server must be added to the `template.js` HTML
    code for it to be loaded when the server renders the template.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在服务器上生成的标记和 CSS 必须添加到 `template.js` HTML 代码中，以便在服务器渲染模板时加载。
- en: '`mern-skeleton/template.js`:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/template.js`:'
- en: '[PRE79]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: This will load the server-generated code in the browser before the frontend
    script is ready to take over. In the next section, we will learn how the frontend
    script needs to account for this takeover from server-rendered code.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在前端脚本准备好接管之前在浏览器中加载服务器生成的代码。在下一节中，我们将学习前端脚本需要如何处理从服务器端渲染代码的接管。
- en: Updating App.js
  id: totrans-461
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新 App.js
- en: Once the code that's been rendered on the server-side reaches the browser and
    the frontend script takes over, we need to remove the server-side injected CSS
    when the root React component mounts, using the `useEffect` hook.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务器端渲染的代码到达浏览器，并且前端脚本接管，我们需要在根 React 组件挂载时移除服务器端注入的 CSS，使用 `useEffect` 钩子。
- en: '`mern-skeleton/client/App.js`:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/client/App.js`:'
- en: '[PRE80]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: This will give back full control over rendering the React app to the client-side.
    To ensure this transfer happens efficiently, we need to update how the ReactDOM
    renders the views.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使客户端能够完全控制 React 应用的渲染。为了确保这种转移高效进行，我们需要更新 ReactDOM 渲染视图的方式。
- en: Hydrate instead of render
  id: totrans-466
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替换渲染为激活
- en: 'Now that the React components will be rendered on the server-side, we can update
    the `main.js` code so that it uses `ReactDOM.hydrate()` instead of `ReactDOM.render()`:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于 React 组件将在服务器端渲染，我们可以更新 `main.js` 代码，使其使用 `ReactDOM.hydrate()` 而不是 `ReactDOM.render()`：
- en: '[PRE81]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The `hydrate` function hydrates a container that already has HTML content rendered
    by `ReactDOMServer`. This means the server-rendered markup is preserved and only
    event handlers are attached when React takes over in the browser, allowing the
    initial load performance to be better.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '`hydrate` 函数用于将已经由 `ReactDOMServer` 渲染的 HTML 内容的容器进行激活。这意味着服务器端渲染的标记被保留，当 React
    在浏览器中接管时，仅附加事件处理器，从而使得初始加载性能更佳。'
- en: With basic server-side rendering implemented, direct requests to the frontend
    routes from the browser address bar can now be handled properly by the server,
    making it possible to bookmark the React frontend views.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 实现基本的服务器端渲染后，现在浏览器地址栏直接请求前端路由可以由服务器正确处理，这使得可以保存 React 前端视图的快捷方式。
- en: The skeleton MERN application that we've developed in this chapter is now a
    completely functioning MERN web application with basic user features. We can extend
    the code in this skeleton to add a variety of features for different applications.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们开发的骨架 MERN 应用程序现在是一个完全功能性的 MERN 网络应用程序，具有基本用户功能。我们可以扩展这个骨架中的代码，为不同的应用程序添加各种功能。
- en: Summary
  id: totrans-472
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we completed the MERN skeleton application by adding a working
    React frontend, including frontend routing and basic server-side rendering of
    the React views.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过添加一个可工作的 React 前端，包括前端路由和基本的 React 视图服务器端渲染，完成了 MERN 骨架应用程序。
- en: We started off by updating the development flow so that it included client-side
    code bundling for the React views. We updated the configuration for Webpack and
    Babel to compile the React code and discussed how to load the configured Webpack
    middleware from the Express app to initiate server-side and client-side code compilation
    from one place during development.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先更新了开发流程，使其包括用于 React 视图的客户端代码打包。我们更新了 Webpack 和 Babel 的配置，以编译 React 代码，并讨论了如何在开发过程中从一个地方加载配置的
    Webpack 中间件，以启动服务器端和客户端代码的编译。
- en: With the development flow updated, and before building out the frontend, we
    added the relevant React dependencies, along with React Router for frontend routing
    and Material-UI, to use their existing components in the skeleton app's user interface.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新开发流程并构建前端之前，我们添加了相关的 React 依赖项，包括用于前端路由的 React Router 和 Material-UI，以便在骨架应用的用户界面中使用它们现有的组件。
- en: Then, we implemented the top-level root React components and integrated React
    Router, which allowed us to add client-side routes for navigation. Using these
    routes, we loaded the custom React components that we developed using Material-UI
    components to make up the skeleton application's user interface.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们实现了顶级根 React 组件，并集成了 React Router，这使得我们能够添加客户端路由以进行导航。使用这些路由，我们加载了我们使用
    Material-UI 组件开发的自定义 React 组件，以构成骨架应用的用户界面。
- en: To make these React views dynamic and interactive with data fetched from the
    backend, we used the Fetch API to connect to the backend user APIs. Then, we incorporated
    authentication and authorization on the frontend views. We did this using `sessionStorage`,
    which stores user-specific details, and JWT fetched from the server on successful
    sign-in, as well as by limiting access to certain views using a `PrivateRoute`
    component.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这些 React 视图能够动态地与从后端获取的数据进行交互，我们使用了 Fetch API 来连接到后端用户 API。然后，我们在前端视图中集成了认证和授权。我们使用
    `sessionStorage` 来存储用户特定的详细信息，以及从服务器成功登录后获取的 JWT，以及通过使用 `PrivateRoute` 组件限制对某些视图的访问。
- en: Finally, we modified the server code so that we could implement basic server-side
    rendering, which allows us to load the frontend routes directly in the browser
    with server-side rendered markup after the server recognizes that the incoming
    request is actually for a React route.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们修改了服务器代码，以便我们可以实现基本的服务器端渲染，这允许我们在服务器识别到传入的请求实际上是为 React 路由时，直接在浏览器中加载前端路由的标记。
- en: Now, you should be able to implement and integrate a React-based frontend that
    incorporates client-side routing and auth management with a standalone server application.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能够实现并集成一个基于 React 的前端，该前端结合了客户端路由和独立服务器应用程序的认证管理。
- en: In the next chapter, we will use the concepts we've learned in this chapter
    to extend the skeleton application code so that we can build a fully-featured
    social media application.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用本章学到的概念来扩展骨架应用程序代码，以便我们可以构建一个功能齐全的社交媒体应用程序。
