- en: Working with Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与微服务一起工作
- en: In the previous chapter, we created a gateway and two microservices using JHipster;
    now, let's see how we can further develop our microservices to include our domain
    model and additional business logic. Since we are converting our online shop monolith
    to a microservice architecture, we will see how the domain model we created using
    JDL can be converted into a microservice domain model. But before we can start,
    we need to set up some tools in order to work with microservices.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用 JHipster 创建了一个网关和两个微服务；现在，让我们看看我们如何进一步开发我们的微服务，包括我们的领域模型和额外的业务逻辑。由于我们将我们的在线商店单体应用转换为微服务架构，我们将看到我们使用
    JDL 创建的领域模型如何转换为微服务领域模型。但在我们开始之前，我们需要设置一些工具以便与微服务一起工作。
- en: 'So in this chapter, we will see the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在本章中，我们将看到以下主题：
- en: How to set up JHipster Registry
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设置 JHipster 注册表
- en: How to run the microservice setup locally
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在本地运行微服务设置
- en: Creating the domain model using JDL
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JDL 创建领域模型
- en: Generating the domain model in JHipster
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 JHipster 中生成领域模型
- en: Let's get started!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Setting up JHipster Registry locally
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在本地设置 JHipster 注册表
- en: We have created our gateway and two microservice applications. The microservices
    have two different databases. So far, it has been easy and simple to create those
    with JHipster.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了我们的网关和两个微服务应用。这些微服务使用两个不同的数据库。到目前为止，使用 JHipster 创建这些应用既简单又容易。
- en: JHipster provides two different options we have previously seen, Consul and
    JHipster Registry. For our use case, let's go with JHipster Registry. We have
    already learned about JHipster Registry in [Chapter 8](673932d7-7927-4a12-8c02-86197cc8d3aa.xhtml), *Introduction
    to Microservice Server-Side Technologies.* Now, we will see how to set up and
    start it in our local development environment.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster 提供了两种不同的选项，我们之前已经见过，即 Consul 和 JHipster 注册表。对于我们的用例，让我们选择 JHipster
    注册表。我们已经在[第 8 章](673932d7-7927-4a12-8c02-86197cc8d3aa.xhtml)中学习了 JHipster 注册表，*微服务服务器端技术简介*。现在，我们将看到如何在我们的本地开发环境中设置和启动它。
- en: Now, these three services basically act as Eureka clients. We need a service
    registry that registers and deregisters the application as and when the application
    is started and stopped, respectively; this is JHipster Registry. The Eureka server
    (JHipster Registry server) acts as a master to all the Eureka clients.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这三个服务基本上充当 Eureka 客户端。我们需要一个服务注册表，它会在应用启动和停止时分别注册和注销应用；这就是 JHipster 注册表。Eureka
    服务器（JHipster 注册表服务器）作为所有 Eureka 客户端的权威。
- en: Since JHipster Registry, as the name suggests, acts as a registry service, all
    microservice applications and the gateway will register/deregister themselves
    when the application starts and stops.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如同其名，JHipster 注册表作为一个注册服务，所有微服务应用和网关在应用启动和停止时都会自动注册/注销。
- en: Let's recap a little bit of what we learned already. The JHipster Registry is
    made up of a Eureka server and Spring Cloud Config server and they help in the
    following
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们已经学到的内容。JHipster 注册表由一个 Eureka 服务器和 Spring Cloud Config 服务器组成，它们在以下方面提供帮助
- en: '**The Eureka server **helps in service discovery and load balancing the requests.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Eureka 服务器**帮助进行服务发现和请求负载均衡。'
- en: '**The Spring Cloud Config server** acts as a single place where we will manage
    the external properties of applications across environments. It also provides
    a dashboard for users. With this, users can manage and monitor the application.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Spring Cloud Config 服务器**作为一个单一的地方，我们将管理跨环境的应用外部属性。它还提供了一个用户仪表板。通过这个仪表板，用户可以管理和监控应用。'
- en: This makes JHipster Registry an ideal choice for both monolithic and microservice
    architectures.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得 JHipster 注册表对于单体和微服务架构都是一个理想的选择。
- en: If you are developing microservice applications where different services are
    written in different languages, and if you prefer consistency over availability
    of services, then you can choose Consul.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在开发不同服务用不同语言编写的微服务应用，并且你更倾向于一致性而非服务的可用性，那么你可以选择 Consul。
- en: There are three ways in which we can set up JHipster Registry to run locally.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三种方法可以设置 JHipster 注册表以在本地运行。
- en: We can either download the WAR file (pre-packaged) and run it directly, or clone
    our GitHub repository and run from there. We can also use a Docker container to
    run it. We will see how to do each of these now.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以下载 WAR 文件（预包装）并直接运行它，或者克隆我们的 GitHub 仓库并从那里运行。我们还可以使用 Docker 容器来运行它。我们现在将看到如何执行这些操作中的每一个。
- en: You can choose to use JHipster Registry while generating monolithic applications
    as well. Just select yes for the question Do you want to use the JHipster Registry
    to configure, monitor and scale your application? during generation.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择在生成单体应用程序时使用 JHipster 注册表。在生成过程中，对于问题“您想使用 JHipster 注册表来配置、监控和扩展应用程序吗？”选择是。
- en: Using a pre-packaged WAR file
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用预打包的 WAR 文件
- en: 'Download the latest version of the pre-packaged executable WAR file from the registry
    releases page ([https://github.com/jhipster/jhipster-registry/releases](https://github.com/jhipster/jhipster-registry/releases)):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从注册表的发布页面下载预打包的可执行 WAR 文件的最新版本（[https://github.com/jhipster/jhipster-registry/releases](https://github.com/jhipster/jhipster-registry/releases)）：
- en: 'Open your terminal and then type the following command, replacing `<version>`
    with the latest one. If you are using Windows and do not have `curl` set up, you
    can also download the file by visiting the link in a browser:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的终端，然后输入以下命令，将 `<version>` 替换为最新版本。如果您使用 Windows 并且没有设置 `curl`，您也可以通过在浏览器中访问链接来下载文件：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will download the latest WAR file from the JHipster Registry project.
    Once downloaded, we can run JHipster Registry using the following command:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将从 JHipster 注册表项目下载最新的 WAR 文件。下载完成后，我们可以使用以下命令运行 JHipster 注册表：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Note that we pass a few values to our registry server; they are:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们向我们的注册表服务器传递了一些值；它们是：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Since JHipster Registry is built on top of the JHipster application, it will
    have the default admin user. For that admin user, we provide the password with
    the Spring property `security.user.password`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 JHipster 注册表建立在 JHipster 应用程序之上，它将具有默认的管理员用户。对于该管理员用户，我们使用 Spring 属性 `security.user.password`
    提供密码：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then we define the JWT token for the application in two ways. We can either
    set the information in the environment variable and use that, or else add this
    key value when we define the secret. This also uses the `spring config` property
    to set the property:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们以两种方式定义应用程序的 JWT 令牌。我们可以在环境变量中设置信息并使用它，或者在我们定义密钥时添加此键值。这也使用 `spring config`
    属性来设置属性：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Finally, we tell the JHipster Registry where to find the central configurations
    that are available for the Spring Cloud Config server.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们告诉 JHipster 注册表在哪里可以找到 Spring Cloud Config 服务器提供的中央配置。
- en: Before we see what value to pass in here, we need to know about the Spring profiles
    in the context of `spring-cloud-config`. Spring Cloud Config supports `native` and
    `git` profiles by default.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们了解在这里传递什么值之前，我们需要了解 `spring-cloud-config` 上下文中的 Spring 配置文件。Spring Cloud
    Config 默认支持 `native` 和 `git` 配置文件。
- en: In a `native` profile, the Cloud Config server expects its properties to be
    defined in a file, and we have to pass in the file location to the JHipster Registry.
    On the other hand, the `git` profile will expect `--spring.cloud.config.server.git.uri`
    to be set.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `native` 配置文件中，云配置服务器期望其属性在文件中定义，我们必须将文件位置传递给 JHipster 注册表。另一方面，`git` 配置文件将期望设置
    `--spring.cloud.config.server.git.uri`。
- en: 'For example, the sample JHipster config file for the the registry is as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，注册表的示例 JHipster 配置文件如下：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This can be seen in the Spring Cloud Configuration page of the Registry as
    well:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以在注册表的 Spring Cloud 配置页面中看到：
- en: '![](img/b8e07533-0801-4208-9a96-c5446ee1a212.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b8e07533-0801-4208-9a96-c5446ee1a212.png)'
- en: Just like the JHipster app provides `dev` and `prod` profiles, JHipster Registry
    also supports `dev` and `prod` profiles. By default, it will start in the `dev` profile
    when started, but we can make it run in a `prod` profile using  `--spring.profiles.active=prod,git`, passing
    in the `git` URL, and then defining the configuration properties there. For production
    mode, `git` is the preferred profile to use on a Spring Cloud Server.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 JHipster 应用程序提供 `dev` 和 `prod` 配置文件一样，JHipster 注册表也支持 `dev` 和 `prod` 配置文件。默认情况下，启动时将在
    `dev` 配置文件下启动，但我们可以使用 `--spring.profiles.active=prod,git` 来使其在 `prod` 配置文件下运行，传递
    `git` URL，并在那里定义配置属性。对于生产模式，`git` 是在 Spring Cloud 服务器上使用的首选配置文件。
- en: Building from source
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从源码构建
- en: 'If you want to work on leading-edge technology and are interested in exploring
    the latest features added to the JHipster Registry, then you can go a step further
    and clone the repository from GitHub:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想从事前沿技术工作并对探索添加到 JHipster 注册表的最新功能感兴趣，那么您可以进一步操作并从 GitHub 克隆存储库：
- en: 'Navigate to your preferred folder and run the following command:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到您首选的文件夹并运行以下命令：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once cloned, navigate to the folder using the following command:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦克隆，使用以下命令导航到文件夹：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Run the application in dev mode as follows:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式以开发模式运行应用程序：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can also run it in prod mode as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以按如下方式以生产模式运行：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can also package and run the WAR file:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以打包并运行 WAR 文件：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Docker mode
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 模式
- en: You can also start JHipster Registry from the provided Docker image. The application
    that we generated already has the `docker-compose` file required.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以从提供的 Docker 镜像启动 JHipster Registry。我们生成的应用程序已经包含了所需的 `docker-compose` 文件。
- en: For example, in the gateway application we created, look for the `docker-compose`
    file under `src/main/docker/jhipster-registry.yml`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们的网关应用程序中，在 `src/main/docker/jhipster-registry.yml` 下查找 `docker-compose`
    文件。
- en: 'We can start the JHipster Registry by typing the following command in the terminal:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在终端中键入以下命令来启动 JHipster Registry：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `docker compose` file (`src/main/docker/jhipster-registry.yml`) contains:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker compose` 文件（`src/main/docker/jhipster-registry.yml`）包含：'
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This defines the image as `jhipster-registry` with a version (the latest). It
    also defines a volume to mount the `central-config`, which is required by the
    Spring Cloud Config server to define the application properties for the microservice
    application and gateway. The environment variables such as the Spring profile,
    password for the admin, and cloud config search location are also defined here.
    The port in which it is exposed (`8761`) is also specified.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这将镜像定义为 `jhipster-registry` 并指定版本（最新版）。它还定义了一个挂载 `central-config` 的卷，这是 Spring
    Cloud Config 服务器用于定义微服务应用程序和网关的应用程序属性所必需的。这里还定义了环境变量，如 Spring 配置文件、管理员密码和云配置搜索位置。它还指定了暴露的端口（`8761`）。
- en: Of course, this needs Docker to be installed and running on the machine.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这需要在机器上安装并运行 Docker。
- en: In all preceding cases (when they are successful), it boots up JHipster Registry
    on port `8761` and uses native mode by default (unless otherwise changed explicitly).
    You can actually navigate to `http://localhost:8761` to access JHipster Registry
    and then log in to the application with the password that we used when we started
    the application.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有上述情况（如果成功）中，它将在端口 `8761` 上启动 JHipster Registry，并默认使用原生模式（除非明确更改）。您实际上可以导航到
    `http://localhost:8761` 来访问 JHipster Registry，然后使用我们启动应用程序时使用的密码登录到应用程序。
- en: Running a generated application locally
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地运行生成的应用程序
- en: So we are all set now. We have generated a gateway application, we have a microservice
    with an SQL DB that runs with H2 in a dev profile and MySQL in a prod profile
    (invoice application), we have a microservice with MongoDB (notification application),
    and finally we just finished setting up our JHipster Registry locally. Now it
    is time to start everything locally and see how seamless our microservice setup
    works.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备就绪。我们已经生成了一个网关应用程序，我们有一个带有 SQL 数据库的微服务，它在开发配置下使用 H2，在生产配置下使用 MySQL（发票应用程序），我们还有一个带有
    MongoDB 的微服务（通知应用程序），最后我们刚刚在本地完成了 JHipster Registry 的设置。现在是我们开始本地运行一切并查看我们的微服务设置如何无缝工作的时候了。
- en: Gateway application pages
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网关应用程序页面
- en: 'We head over to terminal now and then go to the `e-commerce-app` folder. Navigate
    to the `online-store` folder and start the gateway application in dev mode:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在转到终端，然后进入 `e-commerce-app` 文件夹。导航到 `online-store` 文件夹，并以开发模式启动网关应用程序：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This will start our Gateway application on port `8080`. Let''s open `http://localhost:8080`
    in our favorite browser:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在端口 `8080` 上启动我们的网关应用程序。让我们在我们的浏览器中打开 `http://localhost:8080`：
- en: '![](img/2b34359a-b72a-4ad4-9bb8-e5b6ff99a76f.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2b34359a-b72a-4ad4-9bb8-e5b6ff99a76f.png)'
- en: Then we can click on the sign in button on the home page or `Account/sign in` from
    the top menu, and then enter the username and password as `admin` and `admin`
    respectively.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以点击主页上的登录按钮或从顶部菜单选择 `Account/sign in`，然后分别输入用户名和密码为 `admin` 和 `admin`。
- en: 'Once logged in as an admin user, you can see the administration menu:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦以管理员用户身份登录，您可以看到管理菜单：
- en: '![](img/18d5069d-ba32-4469-bdf7-415cfe37f2e0.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/18d5069d-ba32-4469-bdf7-415cfe37f2e0.png)'
- en: 'In the administration menu, you can find the following pages:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在管理菜单中，您可以找到以下页面：
- en: '![](img/0a89eeb0-f2d6-4559-bec3-8c4efe731566.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a89eeb0-f2d6-4559-bec3-8c4efe731566.png)'
- en: 'This includes the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括以下内容：
- en: '**Gateway**: The Gateway page will show the list of microservice applications
    for which this application acts as a gateway. It will also show the routes and
    the services that handle the route, and the available servers for the route:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**网关**：网关页面将显示该应用程序作为网关的微服务应用程序列表。它还将显示路由和处理路由的服务，以及可用于路由的服务器：'
- en: '![](img/1b64e45f-7f30-4b41-902f-a899e61bb50b.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b64e45f-7f30-4b41-902f-a899e61bb50b.png)'
- en: Currently, there is no microservice application booted up, so the page is empty.
    We will see how this page is changed once we start our notification and invoice
    services.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，没有启动微服务应用程序，所以页面是空的。一旦我们启动通知和发票服务，我们将看到这个页面是如何变化的。
- en: '**User management**: This is similar to monolithic user management and holds
    the basic user information and management.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户管理**：这与单体用户管理类似，并包含基本用户信息和管理工作。'
- en: '**Metrics**: The Metrics page holds the information about JVM metrics and service/DB
    statistics. This is, again, similar to the monolithic application. Added to that,
    this also shows the metric statistics for the microservice applications registered.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**指标**：指标页面包含有关 JVM 指标和服务的/数据库统计信息。这又与单体应用类似。除此之外，它还显示了已注册微服务应用的指标统计。'
- en: '**Health**: The Health page shows the basic health information of the various
    services that we have in our application:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**健康**：健康页面显示了我们在应用程序中拥有的各种服务的基本健康信息：'
- en: '![](img/a95d6deb-60a4-4873-a3dc-30e512e2c334.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a95d6deb-60a4-4873-a3dc-30e512e2c334.png)'
- en: Similar to the monolithic application, it shows Disk space and Database. But
    added to that it also shows the health of the Discovery network (that is, the
    discoveryClient and the Eureka server). It also shows the microservice config
    server's health, which is `spring-cloud-config-server`, and then shows the health
    of the circuit breaker we use (Hystrix).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 与单体应用类似，它显示了磁盘空间和数据库。但除此之外，它还显示了发现网络的健康状况（即 discoveryClient 和 Eureka 服务器）。它还显示了微服务配置服务器的健康状况，即
    `spring-cloud-config-server`，然后显示了我们所使用的断路器的健康状况（Hystrix）。
- en: Configuration, Audits, Logs, and API pages are similar to the monolithic application
    we saw earlier.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 配置、审计、日志和 API 页面与我们之前看到的单体应用类似。
- en: JHipster Registry pages
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JHipster 注册表页面
- en: Since we have started the registry server at port `8761`, we can visit `http://localhost:8761`
    and log in with `admin` as the username and `admin` (the password that we have
    provided when starting the application) as the password.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在端口 `8761` 上启动了注册表服务器，我们可以通过 `http://localhost:8761` 访问并使用 `admin` 作为用户名，以及我们在启动应用程序时提供的密码
    `admin` 登录。
- en: 'Upon logging in, JHipster Registry shows the following information in the form
    of a dashboard:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，JHipster 注册表以仪表板的形式显示以下信息：
- en: '![](img/cf0453ee-976f-48c5-ab72-57d55afd1e1b.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cf0453ee-976f-48c5-ab72-57d55afd1e1b.png)'
- en: System status
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统状态
- en: This panel will show the environment in which the application is running and
    how long the application has been running (System uptime).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个面板将显示应用程序正在运行的环境以及应用程序运行了多长时间（系统运行时间）。
- en: Below renew threshold
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 低于续订阈值
- en: Our applications will have to send heartbeat signals to the registry service
    to notify the registry that the application is alive and running. The registry
    services rely on this heartbeat signal to register and deregister the application.
    That is, the existence of the application is determined with the help of this
    heartbeat ping. This is what will happen in the renew phase.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序必须向注册表服务发送心跳信号，以通知注册表应用程序正在运行。注册表服务依赖于这个心跳信号来注册和注销应用程序。也就是说，应用程序的存在是通过这个心跳ping来确定的。这就是在续订阶段会发生的事情。
- en: However, when the Eureka server is booting up, it will try to get all the information
    about instance registries from the nearby service. If the nearby service fails
    for any reason, then it will try to connect to all of its peers to fetch the information.
    If the Eureka server was able to fetch the information for all the servers, then
    it will set the renewal threshold based on the information received. Based on
    this information, JHipster Registry will hold the information on whether the current
    level is below the renewal threshold specified and notify users in the UI.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当 Eureka 服务器启动时，它会尝试从附近的服务获取所有关于实例注册的信息。如果附近的服务由于任何原因失败，那么它将尝试连接到所有对等节点以获取信息。如果
    Eureka 服务器能够获取所有服务器的信息，那么它将根据接收到的信息设置续订阈值。基于这些信息，JHipster 注册表将保留有关当前级别是否低于指定的续订阈值的信息，并在
    UI 中通知用户。
- en: Instances registered
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 已注册实例
- en: This will show basic information about the instances that have been registered
    with the registry. Since we have only booted up the gateway service, we will see
    only one instance here. Basically, this will list all the instances that are connected
    to this registry service.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示已注册到注册表中的实例的基本信息。由于我们只启动了网关服务，这里将只看到一个实例。基本上，这将列出所有连接到此注册表服务的实例。
- en: It shows the status of the system, the name of the system, and then the instance
    ID. The instance ID is generated based on the configuration in the `application.yml`
    of JHipster Registry. It assigns a random value.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 它显示了系统的状态、系统名称，然后是实例ID。实例ID是根据JHipster Registry的`application.yml`配置生成的，并分配一个随机值。
- en: General info and health
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一般信息和健康
- en: It also shows general information about the JHipster Registry service and health
    information of the cluster of services, similar to the gateway health. The data
    here is fetched with the help of Spring Actuator health and metric endpoints.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 它还显示了有关JHipster Registry服务的一般信息以及服务集群的健康信息，类似于网关健康信息。这里的数据是在Spring Actuator健康和指标端点的帮助下获取的。
- en: Note the UNKNOWN in the **Health** section (refer to the preceding screenshot).
    It tells us that the Eureka server is not running in a highly available mode,
    or only one instance of JHipster Registry is running. When you boot another instance
    of the registry (that is, make the application highly available) it goes off.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意**健康**部分中的UNKNOWN（参见图表）。它告诉我们Eureka服务器没有以高可用模式运行，或者只有一个JHipster Registry实例正在运行。当您启动另一个注册表实例（即使应用程序高可用）时，它就会消失。
- en: Application listing page
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序列表页面
- en: This page lists the applications that are registered in the JHipster Registry
    service.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此页面列出了在JHipster Registry服务中注册的应用程序。
- en: 'Navigate to Administration | Gateway:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到管理 | 网关：
- en: '![](img/c68e9920-23a1-4e30-b4c8-7f7bf3598e04.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c68e9920-23a1-4e30-b4c8-7f7bf3598e04.png)'
- en: 'It shows the following information:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 它显示了以下信息：
- en: The current instance ID and its name
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前实例ID及其名称
- en: The current status of the instance
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例的当前状态
- en: The version that is deployed
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署的版本
- en: The profile
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置文件
- en: The zone in which it is deployed
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署的区域
- en: The version number is fetched from the `build.gradle` or `pom.xml` for Gradle
    and Maven projects respectively.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 版本号是从Gradle和Maven项目的`build.gradle`或`pom.xml`中获取的。
- en: The zone here normally refers to an Amazon zone. It is used by Ribbon to route
    the request to the nearest server. This configuration is useless if you don't
    use Amazon, and this is why we force it to *primary* (otherwise the load balancing
    algorithm would be wrong).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的区域通常指的是亚马逊区域。它被Ribbon用于将请求路由到最近的服务器。如果您不使用亚马逊，此配置将无济于事，这就是为什么我们将其设置为*主要*（否则负载均衡算法将不正确）。
- en: All the pages in the administration module will have a drop-down menu that lists
    the various instances that are registered, and we can select that instance to
    view its metrics, health, configuration, and other information depending on the
    page we are on.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 管理模块中的所有页面都将有一个下拉菜单，列出已注册的各种实例，我们可以选择该实例以查看其指标、健康、配置和其他信息，具体取决于我们所在的页面。
- en: Metrics page
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指标页面
- en: 'By default, this will show Registry''s JVM metrics and its service statistics:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这将显示注册表的JVM指标及其服务统计信息：
- en: '![](img/0657f768-31b3-454b-8218-653752c5e25a.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0657f768-31b3-454b-8218-653752c5e25a.png)'
- en: 'We can select any instance from the drop-down menu provided and see its statistics,
    thus, making JHipster Registry a single point of information that provides all
    the necessary insight into your microservice architecture. For example, upon selecting
    the Gateway application instance, we will get gateway-related information:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从提供的下拉菜单中选择任何实例并查看其统计信息，因此，使JHipster Registry成为提供所有必要洞察的单一信息点，了解您的微服务架构。例如，在选择网关应用程序实例后，我们将获得网关相关信息：
- en: '![](img/57618e00-e5af-4658-9c91-1a6eeb491f9c.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/57618e00-e5af-4658-9c91-1a6eeb491f9c.png)'
- en: Health page
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 健康页面
- en: 'The health page will list the health of the Registry itself and all the instances
    that are connected to it. For example, upon selecting the gateway application
    instance, we will get  gateway-related information:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 健康页面将列出注册表本身及其所有连接的实例的健康状况。例如，在选择网关应用程序实例后，我们将获得以下网关相关信息：
- en: '![](img/48a8763a-2e6c-4590-aab4-7ebf5e6f4e87.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/48a8763a-2e6c-4590-aab4-7ebf5e6f4e87.png)'
- en: Configuration page
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置页面
- en: 'Similar to the health and metrics pages, JHipster Registry will provide detailed
    configuration of all the instances connected to it and we can choose the instances
    from the drop-down menu:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 与健康和指标页面类似，JHipster Registry将提供所有连接到它的实例的详细配置，我们可以从下拉菜单中选择实例：
- en: The following image shows configuration screen for the Gateway application
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了网关应用程序的配置屏幕
- en: '![](img/2f49b534-e49c-4c7a-b48b-35f8bfcff894.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2f49b534-e49c-4c7a-b48b-35f8bfcff894.png)'
- en: Logs page
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志页面
- en: 'Similar to the preceding pages, the log page will also show the real-time logs
    of the application. This is really useful for debugging and getting more information
    when there is a failure:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的页面类似，日志页面也会显示应用程序的实时日志。这在出现故障时进行调试和获取更多信息时非常有用：
- en: The logs are formatted at the application level. The console here shows `tail
    -f` for consolidating logs.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 日志在应用层面进行格式化。这里的控制台显示了`tail -f`用于合并日志。
- en: 'The following image shows logs from the Gateway application:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了网关应用程序的日志：
- en: '![](img/1dc8fee6-d096-4d45-8e92-b7ac19c3af45.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1dc8fee6-d096-4d45-8e92-b7ac19c3af45.png)'
- en: Swagger API endpoints
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swagger API端点
- en: The microservice architecture relies heavily on API calls between gateway and
    services, services and registry, and gateway and registries. So it is essential
    for developers and users to get to know the API endpoints that they can access,
    as well as the information required to access those endpoints.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构高度依赖于网关和服务、服务和注册表、网关和注册表之间的API调用。因此，对于开发者和用户来说，了解他们可以访问的API端点以及访问这些端点所需的信息至关重要。
- en: 'This can be a lot of work. Fortunately, libraries such as Swagger come to the
    rescue. We just have to add the standard comments to the methods, and then the
    Swagger API will do the necessary work to extract information from them and convert
    them into a beautiful user interface:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是一项大量工作。幸运的是，像Swagger这样的库可以提供帮助。我们只需将标准注释添加到方法中，然后Swagger API将执行从这些方法中提取信息并将其转换为美观用户界面的必要工作：
- en: '![](img/1b9b74bb-9c3a-4e94-966d-64a09d6b3367.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1b9b74bb-9c3a-4e94-966d-64a09d6b3367.png)'
- en: The preceding image shows the default generated Swagger UI page. It lists all
    the endpoints available, and then provides the list of operations that it provides.
    It shows the playground where we can frame requests and test them for output.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图像显示了默认生成的Swagger UI页面。它列出了所有可用的端点，然后提供了它提供的操作列表。它显示了我们可以在这里构建请求并测试输出的游乐场。
- en: Normally, the Swagger API docs are available only in development mode. If you
    are developing an API service and if there is a need to expose this to end users
    or external developers using your service, you can enable it in production by
    setting the swagger profile, along with `prod`, by setting `spring.profiles.active=prod,swagger`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Swagger API文档仅在开发模式下可用。如果您正在开发API服务，并且需要将此暴露给最终用户或使用您服务的开发人员，您可以通过设置`swagger`配置文件以及`prod`来在生产中启用它，通过设置`spring.profiles.active=prod,swagger`。
- en: 'Similar to the other pages, this also lists the various instances that are
    connected to this registry service and we can select them from the drop-down menu
    (upper-right corner) to see what APIs are provided by various applications:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他页面类似，此页面也会列出连接到此注册服务器的各种实例，我们可以从下拉菜单（右上角）中选择它们，以查看各种应用程序提供的API：
- en: '![](img/8291b0b3-59d3-41f8-8410-90af0bcfab02.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8291b0b3-59d3-41f8-8410-90af0bcfab02.png)'
- en: 'The listed operations in the gateway API will provide the following information:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 网关API中列出的操作将提供以下信息：
- en: '![](img/01fc07f9-d529-4471-bece-a88c4b3db9ed.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/01fc07f9-d529-4471-bece-a88c4b3db9ed.png)'
- en: 'It lists all the operations that are available in the `AccountResource` file.
    It shows the method type (`GET` / `POST` / `PUT` / `DELETE`), and then the endpoint
    and the method name that is present in the `AccountResource` file:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 它列出了`AccountResource`文件中所有可用的操作。它显示了方法类型（`GET` / `POST` / `PUT` / `DELETE`），然后是`AccountResource`文件中存在的端点和方法名称：
- en: '![](img/ca90823e-e343-4ff6-9b8c-ee59f3c5b52d.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ca90823e-e343-4ff6-9b8c-ee59f3c5b52d.png)'
- en: 'Upon clicking any one of the endpoints, it shows detailed information about
    the response classes, response errors, response content type, and also how the
    response object is structured. In addition to this, it also shows how the model
    object is constructed. These are particularly helpful for end users who want to
    access these APIs:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 点击任何一个端点，它会显示关于响应类、响应错误、响应内容类型以及响应对象结构的详细信息。此外，它还显示了模型对象的构建方式。这对于想要访问这些API的最终用户特别有帮助：
- en: '[PRE14]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, there is an option to try out the endpoint upon clicking the button:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，有一个选项在点击按钮后尝试端点：
- en: '![](img/ebbd03a7-a9ed-46b1-93c7-aaaa52cc89fc.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ebbd03a7-a9ed-46b1-93c7-aaaa52cc89fc.png)'
- en: 'It shows the request and its response. It also shows how to frame the request,
    along with the authentication token. It provides the response code and the response
    header information that is returned by the server, which is also extremely useful
    for API programmers:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 它显示了请求及其响应。它还显示了如何构建请求，包括身份验证令牌。它提供了服务器返回的响应代码和响应头信息，这对于API程序员来说也非常有用：
- en: '![](img/6e347b5a-f5cf-4b28-936f-bedc37248ead.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6e347b5a-f5cf-4b28-936f-bedc37248ead.png)'
- en: Running invoice and notification applications locally
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在本地运行发票和通知应用程序
- en: 'We have started the gateway and the registry services. We can then go to our
    invoice and notification application folders and then run them locally:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经启动了网关和注册服务。然后我们可以进入我们的发票和通知应用程序文件夹，并在本地运行它们：
- en: '[PRE15]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Open another terminal and run the following command:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 打开另一个终端并运行以下命令：
- en: '[PRE16]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This will run them in `8081` and `8082` ports respectively:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这将分别在`8081`和`8082`端口上运行它们：
- en: '![](img/9e38cf2c-0561-428a-84ad-c9cbf73ba485.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9e38cf2c-0561-428a-84ad-c9cbf73ba485.png)'
- en: Upon starting the application, it will also try to connect to JHipster Registry
    and register itself. You can watch for the preceding message once your server
    has started, to make sure that it is connected to JHipster Registry.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序启动时，它也会尝试连接到JHipster注册表并注册自己。一旦服务器启动，你可以查看前面的消息，以确保它已连接到JHipster注册表。
- en: 'You can alternatively test this via your Gateway application. Log in to your
    Gateway application and then navigate to Administration | Gateway:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过你的网关应用程序进行测试。登录到网关应用程序，然后导航到管理 | 网关：
- en: '![](img/5fe810da-73f5-4835-a2cd-b359544f3bb3.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5fe810da-73f5-4835-a2cd-b359544f3bb3.png)'
- en: Here, you can see the two microservice applications, invoice and notification,
    are booted up and they are available at their respective URLs.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到两个微服务应用程序，发票和通知，都已启动，并且它们分别在各自的URL上可用。
- en: 'You can also check the JHipster Registry service to list the registered instances:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以检查JHipster注册表服务以列出已注册的实例：
- en: '![](img/b8c09632-408d-46eb-bd63-4be24e62b416.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b8c09632-408d-46eb-bd63-4be24e62b416.png)'
- en: Similarly, all the other pages in JHipster Registry will start to show the invoice
    and notification as one of the instances, and we can get their health, configuration,
    logs, and metrics right from JHipster Registry.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，JHipster注册表中的所有其他页面都将开始显示发票和通知作为实例之一，我们可以直接从JHipster注册表中获取它们的健康状态、配置、日志和指标。
- en: 'If you have followed along with the book, this will be the directory structure
    you will have:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经跟随书籍学习，这将是你将拥有的目录结构：
- en: '![](img/ccd353fd-9500-4200-ad98-10e736fb2156.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ccd353fd-9500-4200-ad98-10e736fb2156.png)'
- en: Modeling entities in JDL
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在JDL中建模实体
- en: Since we have already used the JDL studio when we were setting up our monolithic
    application, it's time to update it.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在设置单体应用时已经使用了JDL工作室，现在是时候更新它了。
- en: As discussed in the previous chapter, we will move the entities from a monolithic
    application to a gateway application, then, remove the invoice-related entities
    from the monolithic application, use them in our invoice microservice, and then
    update the related invoice references in that. Finally, we create entities for
    the notification microservice.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，我们将实体从单体应用迁移到网关应用，然后，从单体应用中移除与发票相关的实体，在发票微服务中使用它们，然后更新相关的发票引用。最后，我们为通知微服务创建实体。
- en: 'The following diagram shows our new JDL entity model:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了我们的新JDL实体模型：
- en: '![](img/9b90e1c3-001b-4550-b64e-c1cfb3bd4e9c.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9b90e1c3-001b-4550-b64e-c1cfb3bd4e9c.png)'
- en: The invoice is a perfect candidate to move out into a separate service. We can
    completely decouple invoice and its dependencies, but this will cause one problem
    in our current application—the `ProductOrder` entity is related to the `Invoice`
    table and we have to remove this dependency while keeping the relationship (but
    not as a foreign key) as an indirect key in `ProductOrder` that connects with
    the `Invoice` entity.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 发票是迁移到单独服务的理想候选者。我们可以完全解耦发票及其依赖项，但这将在我们的当前应用程序中引起一个问题——`ProductOrder`实体与`Invoice`表相关联，我们必须在保持关系（但不是作为外键）的同时，将其作为间接键移除依赖关系，并在`ProductOrder`中与`Invoice`实体连接。
- en: This can be achieved in two ways. We can change the foreign key into just another
    column in the `ProductOrder` entity, or create another entity called `InvoiceOrder`
    that just holds InvoiceIDs and `ProductOrder` IDs and map it to the `ProductOrder`
    entity.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过两种方式实现。我们可以将外键改为 `ProductOrder` 实体中的另一列，或者创建另一个名为 `InvoiceOrder` 的实体，它只包含InvoiceID和
    `ProductOrder` ID，并将其映射到 `ProductOrder` 实体。
- en: The former keeps the table structure more or less the same and allows easier
    migration. The latter will increase isolation at the cost of normalization, and
    they are heavily used in high-performance applications. As you see, both have
    their own merits and demerits. The approach you should take depends purely on
    your requirement. We will consider the first approach.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 前者基本上保持了表结构不变，并允许更容易的迁移。后者将以牺牲规范化为代价增加隔离性，并且在高性能应用程序中被大量使用。正如你所见，它们都有各自的优点和缺点。你应该采取的方法完全取决于你的需求。我们将考虑第一种方法。
- en: 'As a first step, we will remove the relationship from Product owner in JDL
    defined in `online-store.jh` as shown for:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，我们将从 `online-store.jh` 中定义的JDL中删除产品所有者之间的关系，如下所示：
- en: '[PRE17]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Remove the highlighted line and move all the invoice-related entities to the `invoice-jdl.jh` file.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 删除高亮显示的行，并将所有与发票相关的实体移动到 `invoice-jdl.jh` 文件。
- en: 'Then, go to the Product Order entity, add an `invoiceId` field, and mark it
    as the `Long` type. It is an optional field and hence doesn''t need the required
    keyword:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，转到产品订单实体，添加一个 `invoiceId` 字段，并将其标记为 `Long` 类型。这是一个可选字段，因此不需要必需的关键字：
- en: '[PRE18]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Entities for microservices can be tagged using the microservice keyword supported
    by JDL. This helps JHipster to identify entities that belong to a specific microservice.
    It follows the same JDL options syntax that we saw earlier:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用JDL支持的 `microservice` 关键字对微服务实体进行标记。这有助于JHipster识别属于特定微服务的实体。它遵循我们之前看到的相同的JDL选项语法：
- en: '`<OPTION> <ENTITIES | * | all> [with <VALUE>] [except <ENTITIES>]`'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`<OPTION> <ENTITIES | * | all> [with <VALUE>] [except <ENTITIES>]`'
- en: '`microservice` keyword'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`microservice` 关键字'
- en: Followed by the names of the entity, comma separated if multiple
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 紧接着是实体名称，如果多个则用逗号分隔
- en: Followed by the `with` keyword
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 紧接着是 `with` 关键字
- en: Followed by the name of the microservice
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 紧接着是微服务的名称
- en: We should use different files for microservices' entities, so that we create
    two files, `invoice-jdl.jh` and `notification-jdl.jh`, that contain the entities
    related to invoice and notification respectively, along with the original.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该为微服务的实体使用不同的文件，因此创建两个文件，`invoice-jdl.jh` 和 `notification-jdl.jh`，分别包含与发票和通知相关的实体，以及原始文件。
- en: 'Then, we map the existing `Invoice` entity to the microservice in our JDL:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在JDL中将现有的 `Invoice` 实体映射到微服务：
- en: '[PRE19]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, it is time to create another JDL file to hold the notification service
    details. Create a file called **notification-jdl.jh** and add the entities for
    notifications into it:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，是时候创建另一个JDL文件来保存通知服务的详细信息。创建一个名为 **notification-jdl.jh** 的文件，并将通知实体添加到其中：
- en: '[PRE20]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, we bind these entities to the `Notification` microservice, with the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将这些实体绑定到 `Notification` 微服务，如下所示：
- en: '[PRE21]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: That is it. We have defined the domain model for our microservices.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。我们已经为我们的微服务定义了领域模型。
- en: Entity generation on microservices
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务上的实体生成
- en: Our JDL is ready to use now. The next step will be generating the entities in
    the gateway and the services. To start with, we will download our JDL files from
    the JDL studio. Once downloaded, we will move the files into our gateway and microservice
    applications respectively.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的JDL现在可以使用了。下一步将是生成网关和服务中的实体。首先，我们将从JDL工作室下载我们的JDL文件。下载后，我们将文件分别移动到我们的网关和微服务应用程序中。
- en: 'Once moved, run the following command after navigating into the gateway application
    folder. This will create the entities for the gateway and also create the UI for
    the microservice entities in the gateway:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦移动到网关应用程序文件夹，请运行以下命令。这将创建网关的实体，并在网关中为微服务实体创建UI：
- en: '[PRE22]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `--skip-ui-grouping` flag disables the client-side entity component grouping
    behavior for microservices introduced in JHipster 5.x. This helps us to cherry-pick
    our changes from the monolithic application without many conflicts. This grouping
    behavior is useful when you have entities with the same name in different services.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`--skip-ui-grouping` 标志禁用了JHipster 5.x中引入的微服务客户端实体组件分组行为。这有助于我们在不发生许多冲突的情况下从单体应用程序中挑选我们的更改。当你在不同的服务中有相同名称的实体时，这种分组行为很有用。'
- en: 'Run the following command for the notification service so that the backend
    for the entities are created there:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以创建发票服务的后端：
- en: '[PRE23]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Run the following command for the invoice service so that the backends for
    the entities are created there:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以创建发票服务的后端：
- en: '[PRE24]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: JHipster will ask about overwriting the modified files; please select the applicable
    ones. We will use `"a" ->`, which means that it will overwrite everything.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster将询问是否覆盖已修改的文件；请选择适用的文件。我们将使用`"a" ->`，这意味着将覆盖一切。
- en: Don't forget to cherry-pick any changes we made to entities originally in the
    monolith back to our gateway and microservices.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记将我们对原始单体中的实体所做的任何更改 cherry-pick 回网关和微服务。
- en: 'Don''t forget to commit the changes in each of the services and gateway. You
    could also init the entire `e-commerce-app` folder as a `git` source if you like,
    by running `git init`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在每个服务和网关中提交更改。你也可以通过运行`git init`将整个`e-commerce-app`文件夹初始化为`git`源，如果你喜欢的话：
- en: '[PRE25]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Explaining the generated  code
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释生成的代码
- en: 'In the notification service, once we have generated the application, the following
    files were created:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在通知服务中，一旦我们生成了应用程序，以下文件被创建：
- en: '![](img/24baa8ee-5736-4ae8-9d4c-53d1c8f7ac89.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/24baa8ee-5736-4ae8-9d4c-53d1c8f7ac89.png)'
- en: As you can see, this will only generate the backend files and not the frontend
    files, since they are already generated in the gateway service.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这只会生成后端文件，而不会生成前端文件，因为它们已经在网关服务中生成。
- en: 'Similarly, running the `jhipster import-jdl` command in the invoice application
    will generate similar Java files:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在发票应用中运行`jhipster import-jdl`命令将生成类似的Java文件：
- en: '![](img/cb672b0d-0c9f-4eab-85cf-7ac4cc798af7.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cb672b0d-0c9f-4eab-85cf-7ac4cc798af7.png)'
- en: Gateway application
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网关应用
- en: 'In the Gateway application, the entire frontend (including the entities in
    microservices) will be generated. Since JHipster produces proxy-based microservices,
    all the frontend code will live in the Gateway application:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在网关应用中，整个前端（包括微服务中的实体）都将生成。由于JHipster生成基于代理的微服务，所有前端代码都将位于网关应用中：
- en: '![](img/0201c4c8-1f97-47ab-9aad-c6145d776a63.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0201c4c8-1f97-47ab-9aad-c6145d776a63.png)'
- en: '`ProductOrder.Java` will remove the `Invoice` as a foreign key and then use
    the long value that we passed in here:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductOrder.Java`将移除`Invoice`作为外键，然后使用我们在这里传递的长整数值：'
- en: '[PRE26]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: So, the application is generated completely. Now, it is time to run it.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，应用程序已完全生成。现在，是时候运行它了。
- en: 'Fire up three consoles (since we need to run three applications). If we have
    the applications running already, then we just need to compile them and Spring
    devtools will auto reload the applications. Make sure the registry is already
    running as well:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 启动三个控制台（因为我们需要运行三个应用程序）。如果我们已经有应用程序在运行，那么我们只需要编译它们，Spring devtools将自动重新加载应用程序。确保注册表已经运行：
- en: In console 1, navigate to the gateway and then start the server with `./gradlew`
    if it is not already running, otherwise compile with `` `./gradlew compileJava`
    ``
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在控制台1中，导航到网关，如果服务器尚未运行，则使用`./gradlew`启动服务器，否则使用`./gradlew compileJava`进行编译
- en: In console 2, navigate to the invoice and then start the server with` ./gradlew` if
    it is not already running, otherwise compile with `./gradlew compileJava`
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在控制台2中，导航到发票，如果服务器尚未运行，则使用`./gradlew`启动服务器，否则使用`./gradlew compileJava`进行编译
- en: In console 3, navigate to the notification and then start the server with` ./gradlew` if
    it is not already running, otherwise compile with `./gradlew compileJava`
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在控制台3中，导航到通知，如果服务器尚未运行，则使用`./gradlew`启动服务器，否则使用`./gradlew compileJava`进行编译
- en: Explaining the generated pages
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释生成的页面
- en: Once the application has started successfully, it is time to spin up your favorite
    browser and navigate to the gateway server at `http://localhost:8080`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序成功启动后，是时候打开你喜欢的浏览器并导航到`http://localhost:8080`的网关服务器。
- en: Once logged in, you can see that the entities are generated in the gateway application
    and they are available under the entity nav menu.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，你可以看到实体在网关应用中生成，并且它们在实体导航菜单下可用。
- en: 'It includes all the gateway entities and also the microservice entities:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 它包括所有网关实体以及微服务实体：
- en: '![](img/4ccffb10-6c53-4ac5-9366-0e0860e8bd19.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4ccffb10-6c53-4ac5-9366-0e0860e8bd19.png)'
- en: 'This is the invoice screen created in the gateway application:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这是网关应用中创建的发票屏幕：
- en: '![](img/47eb47e0-b724-4685-bdc1-6048ea1ff23e.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/47eb47e0-b724-4685-bdc1-6048ea1ff23e.png)'
- en: Try to create a few entities to verify that everything is working fine.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试创建一些实体以验证一切是否运行正常。
- en: Summary
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Since we have done a lot of things in this chapter, let's recap what we have
    done so far.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在本章中做了很多事情，让我们回顾一下到目前为止我们已经做了什么。
- en: We have successfully generated a gateway and two microservices. We have downloaded
    JHipster Registry and then started it locally. We have successfully segregated
    and generated the entity files for a notification and invoice service. We have
    finally booted up all our applications and saw how things are generated, and were
    able to create the microservice application. Last but not least, we have also
    committed all our changes to Git (in other words, reached a checkpoint).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已成功生成一个网关和两个微服务。我们已下载 JHipster Registry 并在本地启动它。我们已成功隔离并生成了通知和发票服务的实体文件。我们最终启动了所有应用程序，并看到了事物是如何生成的，并且能够创建微服务应用程序。最后但同样重要的是，我们还将所有更改提交到了
    Git（换句话说，达到了一个检查点）。
