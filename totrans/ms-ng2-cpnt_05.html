<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Component-Based Routing" id="aid-1565U1"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Component-Based Routing</h1></div></div></div><p>Routing is an integral part of today's frontend applications. In general, a router serves two main purposes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Making your application navigable so that users can use their browser's back button and store and share links within the application</li><li class="listitem">Offload parts of the application composition so that the router takes responsibility to compose your application, based on routes and route parameters</li></ul></div><p>The router that comes with Angular supports many different use-cases, and it comes with an easy-to-use API. This supports child routers that are similar to the Angular UI-Router nested states, Ember.js nested routes, or child routers in the Durandal framework. Tied to the component tree, this also makes use of its own tree structure to store states and to resolve requested URLs.</p><p>In this chapter, we refactor our code to use the component-based router of Angular. We will look into the core elements of the router and how to use them to enable routing in our application.</p><p>The following topics will be covered in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">An introduction to the Angular router</li><li class="listitem">An overview of the refactoring to enable the router in our application</li><li class="listitem">Composition by template, composition by routing, and how to mix them</li><li class="listitem">Using the <code class="literal">Routes</code> decorator to configure routes and child routes</li><li class="listitem">Using the <code class="literal">OnActivate</code> router lifecycle hook to obtain route parameters</li><li class="listitem">Using the <code class="literal">RouterOutlet</code> directive to create insertion points that are controlled by the router</li><li class="listitem">Using the <code class="literal">RouterLink</code> directive and the router DSL to create navigation links</li><li class="listitem">Querying for the <code class="literal">RouterLink</code> directives using the <code class="literal">@ChildView</code> decorator in order to obtain the link's active state</li></ul></div><div class="section" title="An introduction to the Angular router"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec33"/>An introduction to the Angular router</h1></div></div></div><p>The router in Angular is closely coupled to our component tree. The design <a id="id198" class="indexterm"/>of the Angular router is built on the assumption that a component tree is directly related to our URL structure. This is certainly true for most of the cases. If we look at a component <span class="strong"><strong>B</strong></span>, which is nested within a component <span class="strong"><strong>A</strong></span>, the URL to represent our location would very likely be <code class="literal">/a/b</code>.</p><p>In order to specify the location in our template where we'd like to enable the router to instantiate components, we can use so-called outlets. Simply by including a <code class="literal">&lt;router-outlet&gt;</code> element, we can make use of the <code class="literal">RouterOutlet</code> directive to mark the router insertion point in our template.</p><p>Based on some route configuration that we can place on our component, the router then decides which components need to be instantiated and placed into the router outlets. Routes can also be parameterized, and we can access these parameters within the instantiated components.</p><p>Based on our component tree and the route configurations on components in this tree, we can build a hierarchical routing and decouple child routes from their parent routes. Such nested routes make it possible to specify route configuration on multiple layers in our component tree and reuse parent components for multiple child routes.</p><div class="mediaobject"><img src="../Images/image00319.jpeg" alt="An introduction to the Angular router"/><div class="caption"><p>Router hierarchy established through a component tree</p></div></div><p style="clear:both; height: 1em;"> </p><p>Let's look at the elements <a id="id199" class="indexterm"/>of the router again in more detail:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Route configuration</strong></span>: The route configuration is placed at component level, and it contains the <a id="id200" class="indexterm"/>different routes possible for this level in the component tree. By placing multiple route configurations on different components in the component tree, we can build decoupled nested routes easily.</li><li class="listitem"><span class="strong"><strong>Router outlets</strong></span>: Outlets <a id="id201" class="indexterm"/>are the locations in components that will be managed by the router. Instantiated components that are based on the route configuration will be placed into these outlets.</li><li class="listitem"><span class="strong"><strong>Router link</strong></span>: These are links built with <a id="id202" class="indexterm"/>a DSL style notation that enable the developer to build complex links through the routing tree.</li></ul></div></div></div>
<div class="section" title="Composition by routing" id="aid-164MG1"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec34"/>Composition by routing</h1></div></div></div><p>So far, we <a id="id203" class="indexterm"/>achieved composition by including subcomponents in component <a id="id204" class="indexterm"/>templates. However, we'd now like to give the control to the router to decide which component should be included and where.</p><p>The following illustration provides an overview of the component architecture of our application, which we're going to enable to route:</p><div class="mediaobject"><img src="../Images/image00320.jpeg" alt="Composition by routing"/><div class="caption"><p>A component tree displaying routing components (solid line) and router outlets</p></div></div><p style="clear:both; height: 1em;"> </p><p>The <code class="literal">Project</code> component is now not directly included with our <code class="literal">App</code> component. Instead, we use a router outlet in the template of our <code class="literal">App</code> component. This way, we can give control to the router, and let it decide which component should be placed into the outlet. The <code class="literal">App</code> component's router configuration will contain all top-level routes. In the current application, we only have the <code class="literal">Project</code> component as a secondary-level component, but this will change in further chapters.</p><p>The <code class="literal">Project</code> component contains child route configuration to navigate to the tasks and comments view. However, it does not directly contain a router outlet. We use the <code class="literal">Tabs</code> component as a navigation element for any sub views. As a result, we'll place the router outlet into the <code class="literal">Tabs</code> component and include the component directly in the template of the <code class="literal">Project</code> component.</p><div class="section" title="Router versus template composition"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec32"/>Router versus template composition</h2></div></div></div><p>The composition <a id="id205" class="indexterm"/>that we dealt with so far was purely based on <a id="id206" class="indexterm"/>instantiation via template inclusion. We used input and output properties to decouple and encapsulate components, and followed nice reusable patterns.</p><p>With the router, we face a problem that has not yet been solved by Angular and requires that we find our own solution. As we give control to the router to instantiate and insert components into our component tree, we can't control any bindings on our instantiated component. While we previously relied on the clean decoupling of components using input and output properties, we can no longer do this. The only thing that a router provides us are route parameters that may have been set along the activated route.</p><p>This puts us in quite a nasty situation. Basically, we need to decide between two designs when writing components, which are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">We use a given component purely in template composition and, therefore, rely on input and output properties as the glue between the parent component</li><li class="listitem">We use a component instantiated by the router and rely on input-provided view route parameters and don't require communication with the parent component</li></ul></div><p>Well, both of the preceding design approaches aren't very nice, are they? In an ideal world, we would not need to apply any changes to a component when we enable it for routing. The router should just enable the component for routing, but it should not require any changes on the component itself. Unfortunately, there's no agreement for a solution to this problem at the time of writing this book.</p><p>As we don't want to lose any composition capabilities that we gain from relying on inputs and outputs in our <code class="literal">TaskList</code> and <code class="literal">Comments</code> components, we need to a find a better solution to enable routing in our application.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The following solution allows us to leave the <code class="literal">TaskList</code> and <code class="literal">Comments</code> components untouched while they can still rely on input and output properties. Instead of exposing them directly to the router, we will build wrapper components that we address from our routes. These wrappers follow some mechanics to bridge this gap between the router and our components.</li><li class="listitem">The <code class="literal">wrapper</code> component deals with any route parameters or route data that might have been set in the activated route.</li><li class="listitem">Their template should only include the component that is wrapped and its input and output bindings.</li><li class="listitem">They handle the required data and functionality to provide the input and output bindings of the concerned component</li><li class="listitem">They may use parent component injection to establish communication with the parent and propagate any action that is required by emitted events. Parent component <a id="id207" class="indexterm"/>injection should be used with caution <a id="id208" class="indexterm"/>as it somewhat breaks our decoupling of components.</li></ul></div></div><div class="section" title="Understanding the route tree"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec33"/>Understanding the route tree</h2></div></div></div><p>Angular uses tree data <a id="id209" class="indexterm"/>structures to represent the router state. You can imagine that every navigation in your application activates a branch in this tree. Let's look at the following example.</p><p>We have an application that consists of four possible routes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">/</code>: This is the root route of the application, which is handled in a component called <span class="strong"><strong>A</strong></span>.</li><li class="listitem"><code class="literal">/b/:id</code>: This is the route where we can access a <code class="literal">b</code> detail view, which is handled in a component called <span class="strong"><strong>B</strong></span>. In the URL, we can pass an <code class="literal">id</code> parameter (that is, <code class="literal">/b/100</code>).</li><li class="listitem"><code class="literal">/b/:id/c</code>: This is the route where the <code class="literal">b</code> detail view has another navigation possibility, which reveals more specific details that we call <code class="literal">c</code>. This is handled in a <span class="strong"><strong>C</strong></span> component.</li><li class="listitem"><code class="literal">/b/:id/d</code>: This is the route where we can also navigate to a <code class="literal">d</code> view in the <code class="literal">b</code> detail view. This is handled by a component, called <span class="strong"><strong>D</strong></span>:</li></ul></div><div class="mediaobject"><img src="../Images/image00321.jpeg" alt="Understanding the route tree"/><div class="caption"><p>A route tree consisting of an active branch of route segments for an activated route /b/100/d</p></div></div><p style="clear:both; height: 1em;"> </p><p>Let's assume that we activate a route in our example by navigating the URL, <code class="literal">/b/100/d</code>. In this case, we'd activate a route that reflects the state that is outlined in the preceding figure. Note that the route segment <span class="strong"><strong>B</strong></span> actually consists of two URL segments. The reason for this is that we've specified that our route <span class="strong"><strong>B</strong></span> actually consists of the <code class="literal">b</code> identifier and an <code class="literal">:id</code> route parameter.</p><p>Using this tree data <a id="id210" class="indexterm"/>structure, we have a perfect abstraction to deal with navigation trees. We can compare trees, check whether certain segments exist in a tree, and extract parameters present on resolved route segments.</p><p>To demonstrate the use of routing trees, let's take a look at the <code class="literal">OnActivate</code> router lifecycle hook that we can implement on our navigable components:</p><div class="informalexample"><pre class="programlisting">routerOnActivate(currentRouteSegment, 
                 previousRouteSegment,
                 currentTree,
                 previousTree)</pre></div><p>When we implement this lifecycle hook on our components, we can run some code after the route was activated. The <code class="literal">currentRouteSegment</code> argument will point to the <code class="literal">RouteSegment</code> instance that was activated on our component.</p><p>Let's take a look at our example again and assume that we want to access the <code class="literal">:id</code> parameter in the <code class="literal">routerOnActivate</code> hook of our <span class="strong"><strong>B</strong></span> component:</p><div class="informalexample"><pre class="programlisting">routerOnActivate(<span class="strong"><strong>currentRouteSegment</strong></span>) {
<span class="strong"><strong>  this.id = currentRouteSegment.getParam('id');</strong></span>
}</pre></div><p>Using the <code class="literal">getParam</code> function on the <code class="literal">RouteSegment</code> instance, we obtain any parameters that are resolved on the given segment. In our example case, this would return a <code class="literal">100</code> string.</p><p>Let's take a look at a more complex example. What if we want to access the <code class="literal">:id</code> parameter from the <span class="strong"><strong>D</strong></span> component on the <code class="literal">d</code> detail view? In the <code class="literal">OnActivate</code> lifecycle hook, we'll receive only the route segment that is relevant to the <span class="strong"><strong>D</strong></span> component. This only consists of the <code class="literal">d</code> URL segment and this does not include the <code class="literal">:id</code> parameter from the parent route. We can now make use of the <code class="literal">RouteTree</code> instance to find the parent route segment and obtain the parameter from there:</p><div class="informalexample"><pre class="programlisting">routerOnActivate(<span class="strong"><strong>currentRouteSegment, </strong></span>
                 previousRouteSegment, 
<span class="strong"><strong>                  currentTree</strong></span>) {
<span class="strong"><strong>  this.id = currentTree.parent(currentRouteSegment).getParam('id');</strong></span>
}</pre></div><p>Using the current <code class="literal">RouteTree</code> instance, we can obtain the parent of the current route segment. As a result, we'll receive the parent route segment (<code class="literal">RouteSegment</code> <span class="strong"><strong>B</strong></span> in the preceding figure) from where we can obtain the <code class="literal">:id</code> parameter.</p><p>As you can see, the router API is quite flexible, and it allows us to inspect route activity on a very fine granularity. The tree structures that are used in the router make it possible to compare complex router <a id="id211" class="indexterm"/>states in our application without bothering about the underlying complexity.</p></div></div>
<div class="section" title="Back to the routes"><div class="titlepage" id="aid-173722"><div><div><h1 class="title"><a id="ch05lvl1sec35"/>Back to the routes</h1></div></div></div><p>All right, now it's time to <a id="id212" class="indexterm"/>implement routing for our application! In the following topics, we'll create the following routes for our application:</p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><thead><tr><th valign="bottom">
<p>Route path</p>
</th><th valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td valign="top">
<p><code class="literal">/projects/:projectId</code></p>
</td><td valign="top">
<p>This route will activate the <code class="literal">Project</code> component in the outlet of our main application component. This consists of the <code class="literal">projects</code> URL segment as well as the <code class="literal">:projectId</code> URL segment to specify the project ID.</p>
</td></tr><tr><td valign="top">
<p><code class="literal">/projects/:projectId/tasks</code></p>
</td><td valign="top">
<p>This route will activate the <code class="literal">TaskList</code> component. We will create a <code class="literal">ProjectTaskList</code> wrapper component in order to decouple our <code class="literal">TaskList</code> component from routing. We'll apply the procedure described in the previous section, <span class="emphasis"><em>Router versus template composition</em></span>.</p>
</td></tr><tr><td valign="top">
<p><code class="literal">/projects/:projectId/comments</code></p>
</td><td valign="top">
<p>This route will activate the <code class="literal">Comments</code> component. We'll create a <code class="literal">ProjectComments</code> wrapper component in order to decouple our <code class="literal">Comments</code> component from routing. We'll apply the procedure described in the previous section, <span class="emphasis"><em>Router versus template composition</em></span>.</p>
</td></tr></tbody></table></div><p>In order to use the router of Angular, the first thing that we need to do is to add the route provider to our application. We'll do this on bootstrap in order to make sure the router providers are only loaded once. Let's open our <code class="literal">boostrap.js</code> file and add the necessary dependencies:</p><div class="informalexample"><pre class="programlisting">...
<span class="strong"><strong>import {bootstrap} from '@angular/platform-browser-dynamic';</strong></span>
<span class="strong"><strong>import {provide} from '@angular/core';</strong></span>
// Import router dependencies
<span class="strong"><strong>import {HashLocationStrategy, LocationStrategy} from '@angular/common';</strong></span>
<span class="strong"><strong>import {ROUTER_PROVIDERS} from '@angular/router'; </strong></span>
...
bootstrap(App, [
  ...
  <span class="strong"><strong>ROUTER_PROVIDERS,</strong></span>
<span class="strong"><strong>  provide(LocationStrategy, {</strong></span>
<span class="strong"><strong>    useClass: HashLocationStrategy</strong></span>
<span class="strong"><strong>  })</strong></span>
]);</pre></div><p>From the router module, we <a id="id213" class="indexterm"/>import the <code class="literal">ROUTER_PROVIDERS</code> constant that contains a list of modules that are required to be exposed as providers when using the router. We also import the <code class="literal">LocationStrategy</code> and <code class="literal">HashLocationStrategy</code> type from the common module that need to be provided manually.</p><p>Using the <code class="literal">provide</code> function, we provide the <code class="literal">HashLocationStrategy</code> class as a substitution for the <code class="literal">LocationStrategy</code> abstract class. This way, the router will know which strategy to use when resolving URLs.</p><p>The following two strategies exist at the moment:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>HashLocationStrategy</strong></span>: This can be used when the router should use hash URLs, such as <code class="literal">localhost:8080#/child/something</code>. This location strategy makes sense if you're working in an environment where the HTML5 push state can't be used due to browser or server constraints. The whole navigation state will be managed in the fragment identifier of the URL.</li><li class="listitem"><span class="strong"><strong>PathLocationStrategy</strong></span>: This strategy can be used if you'd like to use the HTML5 push state to handle application URLs. This means that your application navigation becomes the actual path of the URL. Using the preceding example of a hash-based URL, this strategy would enable the direct use of <code class="literal">localhost:8080/child/something</code>. As the initial requests will hit the server if the state is encoded in the path of a URL, you'll need to enable the correct routing on the server to make this work properly.</li></ul></div><p>After enabling the router for our application, we will need to make our root component routable. We can do this by including a route configuration on our <code class="literal">App</code> component. Let's look at the necessary code to do this. We edit the <code class="literal">app.js</code> file in our <code class="literal">lib</code> folder:</p><div class="informalexample"><pre class="programlisting">...
<span class="strong"><strong>import {Project} from './project/project';</strong></span>
<span class="strong"><strong>import {Routes, Route} from '@angular/router';</strong></span>

@Component({
  selector: 'ngc-app',
  ...
})
<span class="strong"><strong>@Routes([</strong></span>
<span class="strong"><strong>  new Route({path: 'projects/:projectId', component: Project})</strong></span>
<span class="strong"><strong>])</strong></span>
export class App {
     ...
}</pre></div><p>In the preceding code, we imported the <code class="literal">Routes</code> decorator as well as the <code class="literal">Route</code> type from the router module.</p><p>In order to configure routes on our component, we can use the <code class="literal">@Routes</code> decorator by passing an array of <code class="literal">Route</code> objects that describe the possible child routes on this component.</p><p>Let's look at the available <a id="id214" class="indexterm"/>options that we can pass to the <code class="literal">Route</code> constructor:</p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><thead><tr><th valign="bottom">
<p>Route property</p>
</th><th valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td valign="top">
<p><code class="literal">path</code></p>
</td><td valign="top">
<p>This property is required. Using the path, we can describe the navigation URL in the browser using the route matcher DSL. This can contain route parameter placeholders.</p>
<p>Some examples are as follows:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The following route gets activated if the user navigates to <code class="literal">/home</code> in the browser:<div class="informalexample"><pre class="programlisting">path: '/home'</pre></div></li><li class="listitem">The following route gets activated when the user navigates to a <code class="literal">/child/something</code> URL where something will be available as route parameter with the name, <code class="literal">id</code>:</li></ul></div>
<div class="informalexample"><pre class="programlisting">path: '/child/:id'</pre></div><p>
</p>
</td></tr><tr><td valign="top">
<p><code class="literal">component</code></p>
</td><td valign="top">
<p>This property is required, and it defines which component should be instantiated by the router. As already explained in the previous section, the router does not allow us here to specify any bindings to the instantiated component.</p>
</td></tr></tbody></table></div><p>The route configuration on our <code class="literal">App</code> component covers the <code class="literal">Project</code> component being instantiated on the <code class="literal">projects/:projectId</code> route path. This means that we use a <code class="literal">projectId</code> parameter on the child route, which will be available to the <code class="literal">Project</code> component.</p><p>We also need to modify our <code class="literal">App</code> component template and remove the direct inclusion of the <code class="literal">Project</code> component there. We now give control to the router to decide which component to display. For this, we need to make use of the <code class="literal">RouterOutlet</code> directive to provide a slot in our template where the router will instantiate components.</p><p>The <code class="literal">RouterOutlet</code> directive is <a id="id215" class="indexterm"/>part of the <code class="literal">ROUTER_DIRECTIVES</code> constant that is exported by the router module. Let's import and add the constant to the directives list on our component:</p><div class="informalexample"><pre class="programlisting">...
import {Routes, Route, <span class="strong"><strong>ROUTER_DIRECTIVES</strong></span>} from '@angular/router';
   ...
@Component({
  selector: 'ngc-app',
  ...
  directives: [..., <span class="strong"><strong>ROUTER_DIRECTIVES</strong></span>],
  ...
})
...
export class App {
  ...
}</pre></div><p>Now, we can use the <code class="literal">RouterOutlet</code> directive in our template to indicate the insertion position of instantiated components by the router. Let's open our <code class="literal">App</code> component template file, <code class="literal">app.html</code>, and make the necessary modifications:</p><div class="informalexample"><pre class="programlisting">&lt;div class="app"&gt;
  ...
  &lt;div class="app__l-main"&gt;
    <span class="strong"><strong>&lt;router-outlet&gt;&lt;/router-outlet&gt;</strong></span>
  &lt;/div&gt;
&lt;/div&gt;</pre></div><p>The next step is to refactor our <code class="literal">Project</code> component so that it can be used in routing. As we already outlined in the previous section, the router comes with certain constraints when it comes to component design. For the <code class="literal">Project</code> component, we decide to redesign it in a way so that we can only use it with routing. This isn't a bad thing here because we can exclude the possibility that it will be reused somewhere else in our application.</p><p>The redesign of the <code class="literal">Project</code> component includes the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Getting rid of all input and output properties of the component.</li><li class="listitem">Using the <code class="literal">OnActivate</code> router lifecycle hook to obtain the <code class="literal">projectId</code> parameter from the activated route segment of the <code class="literal">App</code> component.</li><li class="listitem">Obtaining the project data directly from the data store using the <code class="literal">projectId</code> parameter.</li><li class="listitem">Handling updates on the project data directly on the component instead of delegating to the <code class="literal">App</code> component.</li></ol><div style="height:10px; width: 1px"/></div><p>Let's modify the <code class="literal">Component</code> <a id="id216" class="indexterm"/>class located in <code class="literal">lib/project/project.js</code> to implement the preceding design changes:</p><div class="informalexample"><pre class="programlisting">import {Component, ViewEncapsulation, Inject} from '@angular/core';
import template from './project.html!text';
import {Tabs} from '../ui/tabs/tabs';
<span class="strong"><strong>import {DataProvider} from '../../data-access/data-provider';</strong></span>
<span class="strong"><strong>import {LiveDocument} from '../../data-access/live-document';</strong></span>

@Component({
  selector: 'ngc-project',
  host: {class: 'project'},
  template,
  encapsulation: ViewEncapsulation.None,
  directives: [Tabs]
})
export class Project {
  constructor(<span class="strong"><strong>@Inject(DataProvider) dataProvider</strong></span>) {
<span class="strong"><strong>    this.dataProvider = dataProvider;</strong></span>
    this.tabItems = [
      {title: 'Tasks', link: ['tasks']},
      {title: 'Comments', link: ['comments']}
    ];
  }

<span class="strong"><strong>  routerOnActivate(currentRouteSegment) {</strong></span>
<span class="strong"><strong>    this.id = currentRouteSegment.getParam('projectId');</strong></span>
<span class="strong"><strong>    this.document = new LiveDocument(this.dataProvider, {</strong></span>
<span class="strong"><strong>      type: 'project',</strong></span>
<span class="strong"><strong>      _id: this.id</strong></span>
<span class="strong"><strong>    });</strong></span>
<span class="strong"><strong>    this.document.change.subscribe((data) =&gt; {</strong></span>
<span class="strong"><strong>      this.title = data.title;</strong></span>
<span class="strong"><strong>      this.description = data.description;</strong></span>
<span class="strong"><strong>      this.tasks = data.tasks;</strong></span>
<span class="strong"><strong>      this.comments = data.comments;</strong></span>
<span class="strong"><strong>    });</strong></span>
<span class="strong"><strong>  }</strong></span>

  updateTasks(tasks) {
<span class="strong"><strong>    this.document.data.tasks = tasks;</strong></span>
<span class="strong"><strong>    this.document.persist();</strong></span>
  }

  updateComments(comments) {
<span class="strong"><strong>    this.document.data.comments = comments;</strong></span>
<span class="strong"><strong>    this.document.persist();</strong></span>
  }

  ngOnDestroy() {
<span class="strong"><strong>    this.document.unsubscribe();</strong></span>
  }
}</pre></div><p>Besides implementing these changes that are already described in the redesigning steps, we also made use of a new <code class="literal">LiveDocument</code> utility class that we imported from the <code class="literal">data-access</code> folder. This helps us to keep our programming reactive when we're concerned about changes on a single data entity. Using the <code class="literal">LiveDocument</code> class, we can query the database for a single entity, while the change property of the <code class="literal">LiveDocument</code> instance is an observable that keeps us notified about changes on the entity. A <code class="literal">LiveDocument</code> instance also exposes the data of the entity into a <code class="literal">data</code> property, which can be accessed directly. If we'd like to make an update on the entity, we can add, modify, or remove properties on the data object and then store the changes by calling <code class="literal">persist()</code>.</p><p>As our <code class="literal">Project</code> component is now activated by the router in the <code class="literal">App</code> component, we can make use of the <code class="literal">OnActivate</code> router lifecycle hook by implementing a method, named <code class="literal">routerOnActivate</code>. We use the <code class="literal">getParam</code> function of the current route segment to obtain the <code class="literal">:projectId</code> parameter of the route.</p><p>In the <code class="literal">subscribe</code> function on the change observable of our <code class="literal">LiveDocument</code> instance, we expose the project data directly on the <code class="literal">Project</code> component. This simplifies later use in the view.</p><p>In the <code class="literal">OnDestroy</code> lifecycle hook, we make sure that we unsubscribe from the document change observable.</p><p>Now, we can rely on the <code class="literal">projectId</code> route parameter to be passed into our component, which makes the <code class="literal">Project</code> component depend on the router. We got rid of all input properties, and then we set the necessary data by querying our data store using the project ID.</p><p>Now, it's time to build the <a id="id217" class="indexterm"/>wrapper components that we talked about in order to route to our <code class="literal">TaskList</code> and <code class="literal">Comments</code> components.</p><p>Let's create a new component called <code class="literal">ProjectTaskList</code>, which will serve as a wrapper to enable the <code class="literal">TaskList</code> component in routing. We will create a <code class="literal">project-task-list.js</code> file in the <code class="literal">lib/project/project-task-list</code> path, as follows:</p><div class="informalexample"><pre class="programlisting">import {Component, ViewEncapsulation, Inject,<span class="strong"><strong> forwardRef</strong></span>} from '@angular/core';
import template from './project-task-list.html!text';
import {TaskList} from '../../task-list/task-list';
import {Project} from '../project';

@Component({
  selector: 'ngc-project-task-list',
  ...
  directives: [TaskList]
})
export class ProjectTaskList {
  constructor(@Inject(<span class="strong"><strong>forwardRef(() =&gt; Project)) project</strong></span>) {
    this.project = project;
  }

  <span class="strong"><strong>updateTasks(tasks) {</strong></span>
<span class="strong"><strong>    this.project.updateTasks(tasks);</strong></span>
<span class="strong"><strong>  }</strong></span>
}</pre></div><p>Let's also take a look at the template in the <code class="literal">project-task-list.html</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;ngc-task-list <span class="strong"><strong>[tasks]="project.tasks"</strong></span>
             <span class="strong"><strong>(tasksUpdated)="updateTasks($event)"</strong></span>&gt;&lt;/ngc-task-list&gt;</pre></div><p>We inject the <code class="literal">Project</code> parent <a id="id218" class="indexterm"/>component into our wrapper component. As we can't rely on output properties any more to emit events, this is the only way to communicate with the parent <code class="literal">Project</code> component. We're dealing with a circular reference here (<code class="literal">Project</code> depends on <code class="literal">ProjectTaskList</code>, and <code class="literal">ProjectTaskList</code> depends on <code class="literal">Project</code>), hence we need to use a <code class="literal">forwardRef</code> helper function to prevent the <code class="literal">Project</code> type evaluating to <code class="literal">undefined</code>.</p><p>If we receive a <code class="literal">tasksUpdated</code> event in the template, we will call the <code class="literal">updateTasks</code> method on our wrapper component. The wrapper then simply delegates the call to the project component.</p><p>Similarly, we use the project data to obtain the list of tasks and create a binding to the <code class="literal">tasks</code> input property of the <code class="literal">TaskList</code> component.</p><p>Using this wrapper approach for routing, we're able to leave our components unmodified when enabling them for routing. This is much better than the option to make our task list only available for the router. We would lose the freedom to use a task list outside of the context of a project, and then use it with pure template composition.</p><p>For the <code class="literal">Comments</code> component, we perform the exact same task, and create a wrapper on the <code class="literal">lib/project/project-comments</code> path. Besides dealing with comments instead of tasks, the code looks exactly the same as with the <code class="literal">ProjectTaskList</code> wrapper component.</p><p>After creating the two wrapper components, we can now create the router configuration on our <code class="literal">Project</code> component. Let's modify the <code class="literal">project/project.js</code> file to enable routing:</p><div class="informalexample"><pre class="programlisting">...
<span class="strong"><strong>import {ProjectTaskList} from './project-task-list/project-task-list';</strong></span>
<span class="strong"><strong>import {ProjectComments} from './project-comments/project-comments';</strong></span>
import {<span class="strong"><strong>Routes, Route</strong></span>} from '@angular/router';
...
@Component({
  selector: 'ngc-project',
  ...
})
<span class="strong"><strong>@Routes([</strong></span>
<span class="strong"><strong>  new Route({ path: 'tasks', component: ProjectTaskList}),</strong></span>
<span class="strong"><strong>  new Route({ path: 'comments', component: ProjectComments})</strong></span>
<span class="strong"><strong>])</strong></span>
export class Project {
  ...
}</pre></div><p>To enable the task list and make comments navigable using the router, we simply create a router configuration that <a id="id219" class="indexterm"/>instantiates our wrapper components. We also specify that the tasks route should be the default route if no child route was selected.</p><div class="section" title="Routable tabs"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec34"/>Routable tabs</h2></div></div></div><p>Okay, if you've read through <a id="id220" class="indexterm"/>this chapter so far, you now may wonder where the router will instantiate the components of the child routes. We've not yet included a router outlet in the <code class="literal">Project</code> component template so that the router knows where to instantiate components.</p><p>We won't include the outlet for the project router directly in the <code class="literal">Project</code> component. Instead, we will use our <code class="literal">Tabs</code> component to take over this job. Instead of using content insertion in our <code class="literal">Tabs</code> component like we did so far, we now use a router outlet to compose its content. This will make our <code class="literal">Tabs</code> component unusable for nonrouting cases, but we can establish a nice decoupling by only providing the router outlet. This way we can still reuse the <code class="literal">Tabs</code> component in other routing situations:</p><div class="mediaobject"><img src="../Images/image00322.jpeg" alt="Routable tabs"/><div class="caption"><p>The App component includes a router outlet directly; however, the Project component relies on the Tabs component to provide a router outlet.</p></div></div><p style="clear:both; height: 1em;"> </p><p>On a higher level, we can <a id="id221" class="indexterm"/>describe the new design of our <code class="literal">Tabs</code> component, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">It renders all tab buttons, based on a list of router links and titles to provide a router navigation</li><li class="listitem">It provides a router outlet that will be used by the parent component to instantiate navigated components</li></ul></div><p>Let's modify our <code class="literal">Tabs</code> component in <code class="literal">lib/ui/tabs/tabs.js</code> to implement these changes:</p><div class="informalexample"><pre class="programlisting">...
import {<span class="strong"><strong>ROUTER_DIRECTIVES</strong></span>} from '@angular/router';

@Component({
  selector: 'ngc-tabs',
  ...
<span class="strong"><strong>  directives: [ROUTER_DIRECTIVES]</strong></span>
})
export class Tabs {
<span class="strong"><strong>  @Input() items;</strong></span>
}</pre></div><p>The <code class="literal">ROUTER_DIRECTIVES</code> constant from the router module contains the <code class="literal">RouterOutlet</code> directive as well as the <code class="literal">RouterLink</code> directive. By importing the constant and providing it to the components directives list, we enable both router directives to be used in our template.</p><p>The <code class="literal">RouterOutlet</code> directive is used inside the <code class="literal">Tabs</code> component template to indicate the instantiation point for the router.</p><p>The <code class="literal">RouterLink</code> directive can be used to generate routing URLs from the template using the router link DSL. This allows you to generate navigation links in your application and it can be placed both on anchor tags as well as other elements where it will trigger navigation on click.</p><p>The <code class="literal">items</code> input is an array of link items that contain a title and a router link. On our parent project component, we already prepare these items in the constructor.</p><p>Let's also take a quick look at the template of our component in the <code class="literal">tabs.html</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;ul class="tabs__tab-list"&gt;
  &lt;li <span class="strong"><strong>*ngFor="let item of items"</strong></span>&gt;
    &lt;a class="tabs__tab-button"
       <span class="strong"><strong>[routerLink]="item.link"</strong></span>&gt;{{item.title}}&lt;/a&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="tabs__l-container"&gt;
  &lt;div class="tabs__tab tabs__tab--active"&gt;
    <span class="strong"><strong>&lt;router-outlet&gt;&lt;/router-outlet&gt;</strong></span>
  &lt;/div&gt;
&lt;/div&gt;</pre></div><p>As we let the router deal with the active view using a router outlet, there's no need any more to use multiple tab <a id="id222" class="indexterm"/>components that are switched active. We will always have one active tab, and let the router handle the content.</p><p>Let's see how we can make use of the new <code class="literal">Tabs</code> component in our <code class="literal">Project</code> component to make the configured routes navigable. First, we need to add the following code to our <code class="literal">Project</code> component constructor to provide the necessary navigation items to our <code class="literal">Tabs</code> component:</p><div class="informalexample"><pre class="programlisting">this.tabItems = [
  {title: 'Tasks', <span class="strong"><strong>link: ['tasks']</strong></span>},
  {title: 'Comments', <span class="strong"><strong>link: ['comments']</strong></span>}
];</pre></div><p>In the link property of our navigation items, we use the router link DSL to specify which route should be navigated. As the navigation is relative to the parent route segment and we're already in the <code class="literal">/projects/:projectId</code> route, the only thing in our router link DSL should be a relative path to the <code class="literal">tasks</code> and <code class="literal">comments</code> child routes.</p><p>In the template of our <code class="literal">Project</code> component, we can now use the <code class="literal">tabItems</code> property to create a binding to the input property of the <code class="literal">Tabs</code> component:</p><div class="informalexample"><pre class="programlisting">&lt;div class="project__l-header"&gt;
  &lt;h2 class="project__title"&gt;{{title}}&lt;/h2&gt;
  &lt;p&gt;{{description}}&lt;/p&gt;
&lt;/div&gt;
<span class="strong"><strong>&lt;ngc-tabs [items]="tabItems"&gt;&lt;/ngc-tabs&gt;</strong></span>
</pre></div></div></div>
<div class="section" title="Refactoring navigation" id="aid-181NK1"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec36"/>Refactoring navigation</h1></div></div></div><p>As a final step, we also <a id="id223" class="indexterm"/>need to refactor our navigation components to rely on the router. So far, we used our own routing that was implemented in a complex nested-navigation component structure. We can simplify this a lot using the Angular router.</p><p>Let's start with the smallest component first, and edit our <code class="literal">NavigationItem</code> component template in the <code class="literal">lib/navigation/navigation-section/navigation-item/navigation-item.html</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;a class="navigation-section__link"
   <span class="strong"><strong>[class.navigation-section__link--active]="isActive()"</strong></span>
   <span class="strong"><strong>[routerLink]="link"</strong></span>&gt;{{title}}&lt;/a&gt;</pre></div><p>Instead of controlling the link behavior ourselves, we now use the <code class="literal">RouterLink</code> directive to generate a link that is based on the component <code class="literal">link</code> input property. To set the active class on the navigation link, we still rely on the <code class="literal">isActive</code> method on our component, and there's no change required in the template.</p><p>Let's look at the changes to the <code class="literal">Component</code> class in the <code class="literal">navigation-item.js</code> file:</p><div class="informalexample"><pre class="programlisting">...
<span class="strong"><strong>import {RouterLink} from '@angular/router/src/directives/router_link';</strong></span>

@Component({
  selector: 'ngc-navigation-item',
  ...
<span class="strong"><strong>  directives: [RouterLink]</strong></span>
})
export class NavigationItem {
  @Input() title;
  @Input() link;
<span class="strong"><strong>  @ViewChild(RouterLink) routerLink;</strong></span>

  <span class="strong"><strong>isActive() {</strong></span>
<span class="strong"><strong>    return this.routerLink ? </strong></span>
<span class="strong"><strong>                   this.routerLink.isActive : false;</strong></span>
<span class="strong"><strong>  }</strong></span>
}</pre></div><p>Instead of relying on the <code class="literal">Navigation</code> component to manage the active state of navigation items, we now rely on the <code class="literal">RouterLink</code> directive. Each <code class="literal">RouterLink</code> directive provides an <code class="literal">accessor</code> property, <code class="literal">isActive</code>, which tells us whether this specific route addressed by the router link is currently activated within the browsers URL. Using the <code class="literal">@ViewChild</code> decorator, we can query for the <code class="literal">RouterLink</code> directive in our view and then query the <code class="literal">isActive</code> property to find out if the current navigation item is active or not.</p><p>Now, we only need to make sure that we pass the necessary items to the <code class="literal">Navigation</code> component in our <code class="literal">App</code> component in order to make our navigation work again.</p><p>The following code needs <a id="id224" class="indexterm"/>to be changed in the <code class="literal">App</code> component constructor in the <code class="literal">app.js</code> file:</p><div class="informalexample"><pre class="programlisting">this.projectsSubscription = projectService.change
  .subscribe((projects) =&gt; {
    this.projects = projects;
    // We create new navigation items for our projects
    <span class="strong"><strong>this.projectNavigationItems</strong></span> = this.projects
      // We first filter for projects that are not deleted
      .filter((project) =&gt; !project.deleted)
      .map((project) =&gt; {
        return {
          title: project.title,
          <span class="strong"><strong>link: ['/projects', project._id]</strong></span>
        };
      });
    });</pre></div><p>By filtering and mapping the available projects, we can create a list of navigation items that contain a <code class="literal">title</code> and <code class="literal">link</code> property. The <code class="literal">link</code> property contains a route link DSL that points to the project details route that is configured in the <code class="literal">App</code> component router configuration. By passing an object literal as a sibling to the route name, we can specify some parameters along the route. Here, we simply set the expected <code class="literal">projectId</code> parameter to the ID of the project in the projects list.</p><p>Now, our navigation components make use of the router to enable navigation. We got rid of our custom routing functionality in the <code class="literal">Navigation</code> component, and we use router link DSL to create navigation items.</p></div>
<div class="section" title="Summary" id="aid-190861"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec37"/>Summary</h1></div></div></div><p>In this chapter, we learned about the basic concepts of the router in Angular. We looked at how we can use the existing component tree to configure child routes in nested-router scenarios. Using nested-child routes, we enabled the reuse of components with route configurations.</p><p>We also looked at the problem of router versus template composition and how to mitigate this problem using wrapper components. In this way, we close the gap between the router and underlying components using an in-between layer.</p><p>We looked into route configuration specifics and the basics of the router link DSL. We also covered the basics of the <code class="literal">RouteTree</code> and <code class="literal">RouteSegment</code> classes and how to use them to perform in-depth route analysis.</p><p>In the next chapter, we will <a id="id225" class="indexterm"/>learn about SVG and how to use this web standard in order to draw graphics in our Angular applications. We will visualize an activity log of our application activities using SVG and see how Angular makes this technology even greater by enabling composability.</p></div></body></html>