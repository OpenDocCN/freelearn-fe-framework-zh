<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer026">
<h1 class="chapter-number" id="_idParaDest-147"><a id="_idTextAnchor147"/>8</h1>
<h1 id="_idParaDest-148"><a id="_idTextAnchor148"/>Building an Application Component</h1>
<p>The components you’ve built so far have been built in isolation: they don’t fit together, and there’s no workflow for the user to follow when they load the application. Up to this point, we’ve been manually testing our components by swapping them in and out of our index file, <strong class="source-inline">src/index.js</strong>.</p>
<p>In this chapter, we’ll tie all<a id="_idIndexMarker830"/> those components into a functioning system by creating a root application component, <strong class="source-inline">App</strong>, that displays each of these components in turn.</p>
<p>You have now seen almost all the TDD techniques you’ll need for test-driving React applications. This chapter covers one final technique: testing callback props.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Formulating a plan</li>
<li>Using state to control the active view</li>
<li>Test-driving callback props</li>
<li>Making use of callback values</li>
</ul>
<p>By the end of this chapter, you’ll have learned how to use mocks to test the root component of your application, and you’ll have a working application that ties together all the components you’ve worked on in <em class="italic">Part 1</em> of this book.</p>
<h1 id="_idParaDest-149"><a id="_idTextAnchor149"/>Technical requirements</h1>
<p>The code files for this chapter can be found here: <a href="https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter08">https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter08</a></p>
<h1 id="_idParaDest-150"><a id="_idTextAnchor150"/>Formulating a plan</h1>
<p>Before we<a id="_idIndexMarker831"/> jump into the code for the <strong class="source-inline">App</strong> component, let’s do a little up-front design so that we know what we’re building.</p>
<p>The following diagram shows all the components you’ve built and how <strong class="source-inline">App</strong> will connect them:</p>
<div>
<div class="IMG---Figure" id="_idContainer024">
<img alt="Figure 8.1 – The component hierarchy " height="347" src="image/Figure_8.01_B18423.jpg" width="893"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – The component hierarchy</p>
<p>Here’s how it’ll work:</p>
<ol>
<li>When the user first loads the app, they will see a list of today’s appointments using the <strong class="source-inline">AppointmentsDayView</strong> component, which will have its appointment data populated by its container <strong class="source-inline">AppointmentsDayViewLoader</strong> component.</li>
<li>At the top of the screen, the user will see a button labeled <strong class="bold">Add customer and appointment</strong>. Clicking that button makes <strong class="source-inline">AppointmentsDayView</strong> disappear and <strong class="source-inline">CustomerForm</strong> appear.</li>
<li>When the form is filled out and the submit button is clicked, the user is shown <strong class="source-inline">AppointmentForm</strong> and can add a new appointment for that customer.</li>
<li>Once they’ve added the appointment, they’ll be taken back to <strong class="source-inline">AppointmentsDayView</strong>.</li>
</ol>
<p>This first step is shown in the following screenshot. Here, you can see the new button in the top-left<a id="_idIndexMarker832"/> corner. The <strong class="source-inline">App</strong> component will render this button and then orchestrate this workflow:</p>
<div>
<div class="IMG---Figure" id="_idContainer025">
<img alt="Figure 8.2 –  The app showing the new button in the top-left corner " height="1190" src="image/Figure_8.02_B18423.jpg" width="1037"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 –  The app showing the new button in the top-left corner</p>
<p>This is a very simple <a id="_idIndexMarker833"/>workflow that supports just a single use case: adding a new customer and an appointment at the same time. Later in this book, we’ll add support for creating appointments for existing customers.</p>
<p>With that, we’re ready to build the new <strong class="source-inline">App</strong> component<a id="_idTextAnchor151"/>.</p>
<h1 id="_idParaDest-151"><a id="_idTextAnchor152"/>Using state to control the active view</h1>
<p>In this section, we’ll <a id="_idIndexMarker834"/>start building a new <strong class="source-inline">App</strong> component, in <a id="_idIndexMarker835"/>the usual way. First, we’ll display an <strong class="source-inline">AppointmentsDayViewLoader</strong> component. Because this child component makes a network request when mounted, we’ll mock it out. Then, we’ll add a button<a id="_idIndexMarker836"/> inside a <strong class="source-inline">menu</strong> element, at the top of the page. When this button is clicked, we switch out the <strong class="source-inline">AppointmentsDayViewLoader</strong> component for a <strong class="source-inline">CustomerForm </strong>component.</p>
<p>We will introduce a state variable named <strong class="source-inline">view</strong> that defines which component is currently displayed. Initially, it will be set to <strong class="source-inline">dayView</strong>. When the button is clicked, it will change to <strong class="source-inline">addCustomer</strong>.</p>
<p>The JSX constructs will initially use a ternary to switch between these two views. Later, we’ll add a third value<a id="_idIndexMarker837"/> called <strong class="source-inline">addAppointment</strong>. When we do that, we’ll “upgrade” our ternary expression to a <strong class="source-inline">switch</strong> statement.</p>
<p>To get started, follow these steps:</p>
<ol>
<li value="1">Create a new file, <strong class="source-inline">test/App.test.js</strong>, with the following imports for the new <strong class="source-inline">App</strong> component:<p class="source-code">import React from "react";</p><p class="source-code">import {</p><p class="source-code">  initializeReactContainer,</p><p class="source-code">  render,</p><p class="source-code">} from "./reactTestExtensions";</p><p class="source-code">import { App } from "../src/App";</p></li>
<li>Next, import <strong class="source-inline">AppointmentsDayViewLoader</strong> and mock its implementation:<p class="source-code">import {</p><p class="source-code">  AppointmentsDayViewLoader</p><p class="source-code">} from "../src/AppointmentsDayViewLoader";</p><p class="source-code">jest.mock("../src/AppointmentsDayViewLoader", () =&gt; ({</p><p class="source-code">  AppointmentsDayViewLoader: jest.fn(() =&gt; (</p><p class="source-code">    &lt;div id="AppointmentsDayViewLoader" /&gt;</p><p class="source-code">  )),</p><p class="source-code">}));</p></li>
<li>Now, let’s <a id="_idIndexMarker838"/>add our<a id="_idIndexMarker839"/> first test, which checks<a id="_idIndexMarker840"/> that <strong class="source-inline">AppointmentsDayViewLoader</strong> has been rendered:<p class="source-code">describe("App", () =&gt; {</p><p class="source-code">  beforeEach(() =&gt; {</p><p class="source-code">    initializeReactContainer();</p><p class="source-code">  });</p><p class="source-code">  it("initially shows the AppointmentDayViewLoader", () =&gt; {</p><p class="source-code">    render(&lt;App /&gt;);</p><p class="source-code">    expect(AppointmentsDayViewLoader).toBeRendered();</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>Make that pass by adding the following code to a new file, <strong class="source-inline">src/App.js</strong>:<p class="source-code">import React from "react";</p><p class="source-code">import ReactDOM from "react-dom";</p><p class="source-code">import {</p><p class="source-code">  AppointmentsDayViewLoader</p><p class="source-code">} from "./AppointmentsDayViewLoader";</p><p class="source-code">export const App = () =&gt; (</p><p class="source-code">  &lt;AppointmentsDayViewLoader /&gt;</p><p class="source-code">);</p></li>
<li>For the second test, we’ll add a menu to the top of the page. For this, we’ll need the element matcher, so add that to your test suite imports:<p class="source-code">import {</p><p class="source-code">  initializeReactContainer,</p><p class="source-code">  render,</p><p class="source-code"><strong class="bold">  element,</strong></p><p class="source-code">} from "./reactTestExtensions";</p></li>
<li>Add<a id="_idIndexMarker841"/> the<a id="_idIndexMarker842"/> second test:<p class="source-code">it("has a menu bar", () =&gt; {</p><p class="source-code">  render(&lt;App /&gt;);</p><p class="source-code">  expect(element("menu")).not.toBeNull();</p><p class="source-code">});</p></li>
<li>To make that pass, change the <strong class="source-inline">App</strong> component so<a id="_idIndexMarker843"/> that it includes a <strong class="source-inline">menu</strong> element above the loader component:<p class="source-code">export const App = () =&gt; (</p><p class="source-code"><strong class="bold">  &lt;&gt;</strong></p><p class="source-code"><strong class="bold">    &lt;menu /&gt;</strong></p><p class="source-code">    &lt;AppointmentsDayViewLoader /&gt;</p><p class="source-code"><strong class="bold">  &lt;/&gt;</strong></p><p class="source-code">)</p></li>
<li>Next, we want to display a button in the menu that, when clicked, will switch to <strong class="source-inline">CustomerForm</strong>. Add the following test, which asserts that the button appears on the page, using a CSS selector <a id="_idIndexMarker844"/>to find the rendered button element. This uses the <strong class="source-inline">:first-of-type</strong> pseudoclass to ensure we find the<a id="_idIndexMarker845"/> first <a id="_idIndexMarker846"/>button (later in this book, we’ll add a second button to the menu):<p class="source-code">it("has a button to initiate add customer and appointment action", () =&gt; {</p><p class="source-code">  render(&lt;App /&gt;);</p><p class="source-code">  const firstButton = element(</p><p class="source-code">    "menu &gt; li &gt; button:first-of-type"</p><p class="source-code">  );</p><p class="source-code">  expect(firstButton).toContainText(</p><p class="source-code">    "Add customer and appointment"</p><p class="source-code">  );</p><p class="source-code">}); </p></li>
<li>To make that pass, change the menu in the <strong class="source-inline">App</strong> component to the following:<p class="source-code">&lt;menu&gt;</p><p class="source-code">  &lt;li&gt;</p><p class="source-code">    &lt;button type="button"&gt;</p><p class="source-code">      Add customer and appointment</p><p class="source-code">    &lt;/button&gt;</p><p class="source-code">  &lt;li&gt;</p><p class="source-code">&lt;/menu&gt;</p></li>
<li>For the next test, we must check that clicking the button renders <strong class="source-inline">CustomerForm</strong>. We must also mock this component out. To do that, we’ll need the component that’s been imported into the test suite. Add the following line to <strong class="source-inline">test/App.test.js</strong>:<p class="source-code">import { CustomerForm } from "../src/CustomerForm";</p></li>
<li>Just below<a id="_idIndexMarker847"/> that, add<a id="_idIndexMarker848"/> the following mock<a id="_idIndexMarker849"/> definition, which is our standard mock definition:<p class="source-code">jest.mock("../src/CustomerForm", () =&gt; ({</p><p class="source-code">  CustomerForm: jest.fn(() =&gt; (</p><p class="source-code">    &lt;div id="CustomerForm" /&gt;</p><p class="source-code">  )),</p><p class="source-code">}));</p></li>
</ol>
<p class="callout-heading">Why mock a component that has no effects on mount?</p>
<p class="callout">This component already has a test suite so that we can use a test double and verify the right props to avoid re-testing functionality we’ve tested elsewhere. For example, the <strong class="source-inline">CustomerForm</strong> test suite has a test to check that the submit button calls the <strong class="source-inline">onSave</strong> prop with the saved customer object. So, rather than extending the test surface area of <strong class="source-inline">App</strong> so that it includes that submit functionality, we can mock out the component and call <strong class="source-inline">onSave</strong> directly instead. We’ll do that in the next section.</p>
<ol>
<li value="12">To click the button, we’ll need our click helper. Bring that in now:<p class="source-code">import {</p><p class="source-code">  initializeReactContainer,</p><p class="source-code">  render,</p><p class="source-code">  element,</p><p class="source-code"><strong class="bold">  click,</strong></p><p class="source-code">} from "./reactTestExtensions";</p></li>
<li>Now, add the test. This introduces a helper function, <strong class="source-inline">beginAddingCustomerAndAppointment</strong>, which finds the button and clicks it. We’ll pull<a id="_idIndexMarker850"/> that out now because we’ll <a id="_idIndexMarker851"/>be using it in most of the remaining<a id="_idIndexMarker852"/> tests:<p class="source-code">const beginAddingCustomerAndAppointment = () =&gt;</p><p class="source-code">  click(element("menu &gt; li &gt; button:first-of-type"));</p><p class="source-code">it("displays the CustomerForm when button is clicked", async () =&gt; {</p><p class="source-code">  render(&lt;App /&gt;);</p><p class="source-code">  beginAddingCustomerAndAppointment();</p><p class="source-code">  expect(element("#CustomerForm")).not.toBeNull();</p><p class="source-code">});</p></li>
<li>Making this pass involves adding a component state to track that we’ve clicked the button. In <strong class="source-inline">src/App.js</strong>, import the two hooks we’ll need, <strong class="source-inline">useState</strong> and <strong class="source-inline">useCallback</strong>, and import <strong class="source-inline">CustomerForm</strong> too:<p class="source-code">import React<strong class="bold">, { useState, useCallback }</strong> from "react";</p><p class="source-code"><strong class="bold">import { CustomerForm } from "./CustomerForm";</strong></p></li>
<li>In the <strong class="source-inline">App</strong> component, define the new view state variable and initialize it to the <strong class="source-inline">dayView</strong> string, which we’ll use to represent <strong class="source-inline">AppointmentsDayViewLoader</strong>:<p class="source-code">const [view, setView] = useState("dayView");</p></li>
<li>Just below that, add a new callback named <strong class="source-inline">transitionToAddCustomer</strong>, which we’ll attach to the button’s <strong class="source-inline">onClick</strong> handler in the next step. This callback updates the view state variable so that it points to the second page, which we’ll call <strong class="source-inline">addCustomer</strong>:<p class="source-code">const transitionToAddCustomer = useCallback(</p><p class="source-code">  () =&gt; setView("addCustomer"),</p><p class="source-code">  []</p><p class="source-code">);</p></li>
<li>Plug that into the <strong class="source-inline">onClick</strong> prop of the button:<p class="source-code">&lt;button</p><p class="source-code">  type="button"</p><p class="source-code"><strong class="bold">  onClick={transitionToAddCustomer}&gt;</strong></p><p class="source-code">  Add customer and appointment</p><p class="source-code">&lt;/button&gt;</p></li>
<li>Now, all that’s left <a id="_idIndexMarker853"/>is <a id="_idIndexMarker854"/>to modify our JSX to ensure the <strong class="source-inline">CustomerForm</strong> component is rendered when the <strong class="source-inline">view</strong> state variable is set to <strong class="source-inline">addCustomer</strong>. Notice how the test doesn’t force us to hide <strong class="source-inline">AppointmentsDayViewLoader</strong>. That will come in a later test. For now, we just need the simplest code that will make our test pass. Update your JSX, as shown here:<p class="source-code">return (</p><p class="source-code">  &lt;&gt;</p><p class="source-code">    &lt;menu&gt;</p><p class="source-code">      ...</p><p class="source-code">    &lt;/menu&gt;</p><p class="source-code">    <strong class="bold">{view === "addCustomer" ? &lt;CustomerForm /&gt; : null}</strong></p><p class="source-code">  &lt;/&gt;</p><p class="source-code">);</p></li>
</ol>
<p class="callout-heading">Testing for the presence of a new component</p>
<p class="callout">Strictly speaking, this <em class="italic">isn’t</em> the simplest way to make the test pass. We could make it pass by <em class="italic">always</em> rendering a <strong class="source-inline">CustomerForm</strong> component, regardless of the value of <strong class="source-inline">view</strong>. Then, we’d need to triangulate with a second test that proves the component is not initially rendered. I’m skipping this step for brevity, but feel free to add it in if you prefer.</p>
<ol>
<li value="19">We need to ensure that we pass an <strong class="source-inline">original</strong> prop to <strong class="source-inline">CustomerForm</strong>. In this workflow, we’re creating a new customer so that we can give it a blank customer object, just like the one we used in the <strong class="source-inline">CustomerForm</strong> test suite. Add the <a id="_idIndexMarker855"/>following <a id="_idIndexMarker856"/>test below it. We’ll define <strong class="source-inline">blankCustomer</strong> in the next step:<p class="source-code">it("passes a blank original customer object to CustomerForm", async () =&gt; {</p><p class="source-code">  render(&lt;App /&gt;);</p><p class="source-code">  beginAddingCustomerAndAppointment();</p><p class="source-code">  expect(CustomerForm).toBeRenderedWithProps(</p><p class="source-code">    expect.objectContaining({</p><p class="source-code">      original: blankCustomer</p><p class="source-code">    })</p><p class="source-code">  );</p><p class="source-code">});</p></li>
<li>Create a new file, <strong class="source-inline">test/builders/customer.js</strong>, and add a definition for <strong class="source-inline">blankCustomer</strong>:<p class="source-code">export const blankCustomer = {</p><p class="source-code">  firstName: "",</p><p class="source-code">  lastName: "",</p><p class="source-code">  phoneNumber: "",</p><p class="source-code">};</p></li>
<li>Import that new definition into your <strong class="source-inline">App</strong> test suite:<p class="source-code">import { blankCustomer } from "./builders/customer";</p></li>
</ol>
<p class="callout-heading">Value builders versus function builders</p>
<p class="callout">We’ve defined <strong class="source-inline">blankCustomer</strong> as a constant value, rather than a function. We can do this because all the code we’ve written treats variables as immutable objects. If that wasn’t the case, we may prefer to use a function, <strong class="source-inline">blankCustomer()</strong>, that generates new values each time it is called. That way, we can be sure that one test doesn’t accidentally modify the setup for any subsequent tests.</p>
<ol>
<li value="22">Let’s make<a id="_idIndexMarker857"/> that <a id="_idIndexMarker858"/>test pass. First, define <strong class="source-inline">blankCustomer</strong> at the top of <strong class="source-inline">src/App.js</strong>:<p class="source-code">const blankCustomer = {</p><p class="source-code">  firstName: "",</p><p class="source-code">  lastName: "",</p><p class="source-code">  phoneNumber: "",</p><p class="source-code">};</p></li>
</ol>
<p class="callout-heading">Using builder functions in both production and test code</p>
<p class="callout">You now have the same <strong class="source-inline">blankCustomer</strong> definition in both your production and test code. This kind of duplication is usually okay, especially since the object is so simple. But for non-trivial builder functions, you should consider test-driving the implementation and then making good use of it within your test suite.</p>
<ol>
<li value="23">Then, simply reference that value by setting it as an <strong class="source-inline">original</strong> prop of <strong class="source-inline">CustomerForm</strong>. After making this change, your test should be passing:<p class="source-code">{view === "addCustomer" ? (</p><p class="source-code">    &lt;CustomerForm <strong class="bold">original={blankCustomer}</strong> /&gt;</p><p class="source-code">) : null}</p></li>
<li>Next, add the following test to hide <strong class="source-inline">AppointmentsDayViewLoader</strong> when a customer is being added:<p class="source-code">it("hides the AppointmentsDayViewLoader when button is clicked", async () =&gt; {</p><p class="source-code">  render(&lt;App /&gt;);</p><p class="source-code">  beginAddingCustomerAndAppointment();</p><p class="source-code">  expect(</p><p class="source-code">    element("#AppointmentsDayViewLoader")</p><p class="source-code">  ).toBeNull();</p><p class="source-code">});</p></li>
<li>To make<a id="_idIndexMarker859"/> that <a id="_idIndexMarker860"/>pass, we need to move <strong class="source-inline">AppointmentsDayViewLoader</strong> into the ternary expression, in place of the null:<p class="source-code">{ view === "addCustomer" ? (</p><p class="source-code"> &lt;CustomerForm original={blankCustomer} /&gt;</p><p class="source-code">) : (</p><p class="source-code"><strong class="bold"> &lt;AppointmentsDayViewLoader /&gt;</strong></p><p class="source-code">)}</p></li>
<li>Let’s hide the button bar, too:<p class="source-code">it("hides the button bar when CustomerForm is being displayed", async () =&gt; {</p><p class="source-code">  render(&lt;App /&gt;);</p><p class="source-code">  beginAddingCustomerAndAppointment();</p><p class="source-code">  expect(element("menu")).toBeNull();</p><p class="source-code">});</p></li>
<li>To solve this, we need to lift the ternary out of the JSX entirely, as shown in the following code. This is messy, but we’ll improve its implementation in the next section:<p class="source-code">return view === "addCustomer" ? (</p><p class="source-code">  &lt;CustomerForm original={blankCustomer} /&gt;</p><p class="source-code">) : (</p><p class="source-code">  &lt;&gt;</p><p class="source-code">    &lt;menu&gt;</p><p class="source-code">      ...</p><p class="source-code">    &lt;/menu&gt;</p><p class="source-code">    &lt;AppointmentsDayViewLoader /&gt;</p><p class="source-code">  &lt;/&gt;</p><p class="source-code">);</p></li>
</ol>
<p>With that, you have <a id="_idIndexMarker861"/>implemented<a id="_idIndexMarker862"/> the initial step in the workflow – that is changing the screen from an <strong class="source-inline">AppointmentsDayViewLoader</strong> component to a <strong class="source-inline">CustomerForm</strong> component. You did this by changing the <strong class="source-inline">view</strong> state variable from <strong class="source-inline">dayView</strong> to <strong class="source-inline">addCustomer</strong>. For the next step, we’ll use the <strong class="source-inline">onSave</strong> prop of <strong class="source-inline">CustomerForm</strong> to alert us when it’s time to update <strong class="source-inline">view</strong> to <strong class="source-inline">addAppointment</strong>.</p>
<h1 id="_idParaDest-152"><a id="_idTextAnchor153"/>Test-driving callback props</h1>
<p>In this section, we’ll <a id="_idIndexMarker863"/>introduce a new extension function, <strong class="source-inline">propsOf</strong>, that reaches into a mocked child component and returns the props that were<a id="_idIndexMarker864"/> passed to it. We’ll use this to get hold of the <strong class="source-inline">onSave</strong> callback prop value and invoke it from our test, mimicking what would happen if the real <strong class="source-inline">CustomerForm</strong> had been submitted.</p>
<p>It’s worth revisiting why this is something we’d like to do. Reaching into a component and calling the prop directly seems complicated. However, the alternative is <em class="italic">more</em> complicated and <em class="italic">more</em> brittle.</p>
<p>The test we want to write next is the one that asserts that the <strong class="source-inline">AppointmentFormLoader</strong> component is shown after <strong class="source-inline">CustomerForm</strong> has been submitted and a new customer has been saved:</p>
<pre class="source-code">
it("displays the AppointmentFormLoader after the CustomerForm is submitted", async () =&gt; {
  // ...
});</pre>
<p>Now, imagine that we wanted to test this without a mocked <strong class="source-inline">CustomerForm</strong>. We would need to fill in the real <strong class="source-inline">CustomerForm</strong> form fields and hit the submit button. That may seem reasonable, but we’d be increasing the surface area of our <strong class="source-inline">App</strong> test suite to include the <strong class="source-inline">CustomerForm</strong> component. Any changes to the <strong class="source-inline">CustomerForm</strong> component would require not only the <strong class="source-inline">CustomerForm</strong> tests to be updated but also now the <strong class="source-inline">App</strong> tests. This is the exact scenario we’ll see in <a href="B18423_09.xhtml#_idTextAnchor159"><em class="italic">Chapter 9</em></a>, <em class="italic">Form Validation</em>, when we update <strong class="source-inline">CustomerForm</strong> so that it includes field validation.</p>
<p>By mocking the<a id="_idIndexMarker865"/> child component, we can reduce the surface area and reduce the likelihood of breaking tests when child components change.</p>
<p class="callout-heading">Mocked components require care</p>
<p class="callout">Even with mocked components, our parent component test suite can still be affected by child component changes. This can happen if the meaning of the props changes. For example, if we updated the <strong class="source-inline">onSave</strong> prop on <strong class="source-inline">CustomerForm</strong> to return a different value, we’d need to update the <strong class="source-inline">App</strong> tests to reflect that. </p>
<p>Here’s what we’ve got to do. First, we <a id="_idIndexMarker866"/>must define a <strong class="source-inline">propsOf</strong> function in our extensions module. Then, we must write tests that mimic the submission of a <strong class="source-inline">CustomerForm</strong> component and transfer the user to an <strong class="source-inline">AppointmentFormLoader</strong> component. We’ll do that by introducing a new <strong class="source-inline">addAppointment</strong> value for the view state variable. Follow these steps:</p>
<ol>
<li value="1">In <strong class="source-inline">test/reactTestExtensions.js</strong>, add the following definition of <strong class="source-inline">propsOf</strong>. It looks up the last call to the mocked component and returns its props:<p class="source-code">export const propsOf = (mockComponent) =&gt; {</p><p class="source-code">  const lastCall = mockComponent.mock.calls[</p><p class="source-code">    mockComponent.mock.calls.length – 1</p><p class="source-code">  ];</p><p class="source-code">  return lastCall[0];</p><p class="source-code">};</p></li>
<li>Back in <strong class="source-inline">test/App.test.js</strong>, update<a id="_idIndexMarker867"/> the extensions import so that it includes <strong class="source-inline">propsOf</strong>:<p class="source-code">import {</p><p class="source-code">  initializeReactContainer,</p><p class="source-code">  render,</p><p class="source-code">  element,</p><p class="source-code">  click,</p><p class="source-code"><strong class="bold">  propsOf,</strong></p><p class="source-code">} from "./reactTestExtensions";</p></li>
<li>You also <a id="_idIndexMarker868"/>need to import the <strong class="source-inline">act</strong> function from React’s test utils. Our test will wrap its invocation of the callback prop to ensure that any setters are run before the call returns:<p class="source-code">import { act } from "react-dom/test-utils";</p></li>
<li>There’s one more import to add – the import for <strong class="source-inline">AppointmentFormLoader</strong>:<p class="source-code">import {</p><p class="source-code">  AppointmentFormLoader</p><p class="source-code">} from "../src/AppointmentFormLoader";</p></li>
<li>Just below<a id="_idIndexMarker869"/> that, define its mock using the standard component mock definition:<p class="source-code">jest.mock("../src/AppointmentFormLoader", () =&gt; ({</p><p class="source-code">  AppointmentFormLoader: jest.fn(() =&gt; (</p><p class="source-code">    &lt;div id="AppointmentFormLoader" /&gt;</p><p class="source-code">  )),</p><p class="source-code">}));</p></li>
<li>We’re almost ready for our test. First, though, let’s define a helper function, <strong class="source-inline">saveCustomer</strong>. This is the key part of the code that invokes the prop. Note that this sets a default customer object of <strong class="source-inline">exampleCustomer</strong>. We’ll use this default value to avoid having to specify the customer in each test where the value<a id="_idIndexMarker870"/> doesn’t matter:<p class="source-code">const exampleCustomer = { id: 123 };</p><p class="source-code">const saveCustomer = (customer = exampleCustomer) =&gt;</p><p class="source-code">  act(() =&gt; propsOf(CustomerForm).onSave(customer));</p></li>
</ol>
<p class="callout-heading">Using act within the test suite</p>
<p class="callout">This is the first occasion that we’ve willingly left a reference to act within our test suite. In every other use case, we managed to hide calls to <strong class="source-inline">act</strong> within our extensions module. Unfortunately, that’s just not possible here – at least, it’s not possible with the way we wrote <strong class="source-inline">propsOf</strong>. An <a id="_idIndexMarker871"/>alternative approach would be to write an extension function named <strong class="source-inline">invokeProp</strong> that takes the name of a prop and invokes it for us:</p>
<p class="callout"><strong class="source-inline">invokeProp(CustomerForm, "onSave", customer);</strong></p>
<p class="callout">The downside of this approach is that you’ve now downgraded <strong class="source-inline">onSave</strong> from an object property to a string. So, we’ll ignore this approach for now and just live with <strong class="source-inline">act</strong> usage in our test suite.</p>
<ol>
<li value="7">Let’s write our test. We want to assert that <strong class="source-inline">AppointmentsFormLoader</strong> is displayed once <strong class="source-inline">CustomerForm</strong> has been submitted:<p class="source-code">it("displays the AppointmentFormLoader after the CustomerForm is submitted", async () =&gt; {</p><p class="source-code">  render(&lt;App /&gt;);</p><p class="source-code">  beginAddingCustomerAndAppointment();</p><p class="source-code">  saveCustomer();</p><p class="source-code">  expect(</p><p class="source-code">    element("#AppointmentFormLoader")</p><p class="source-code">  ).not.toBeNull();</p><p class="source-code">});</p></li>
<li>Making this pass will involve adding a new value to the view state variable, <strong class="source-inline">addAppointment</strong>. With this third value, the ternary expression is no longer fit for <a id="_idIndexMarker872"/>purpose because it can only handle two possible values of view. So, before we continue making this pass, let’s refactor that ternary so that it uses a <strong class="source-inline">switch</strong> statement. Skip the test you just wrote using <strong class="source-inline">it.skip</strong>.</li>
<li>Replace the return statement of your component with the following:<p class="source-code">switch (view) {</p><p class="source-code">  case "addCustomer":</p><p class="source-code">    return (</p><p class="source-code">      &lt;CustomerForm original={blankCustomer} /&gt;</p><p class="source-code">    );</p><p class="source-code">  default:</p><p class="source-code">    return (</p><p class="source-code">      &lt;&gt;</p><p class="source-code">        &lt;menu&gt;</p><p class="source-code">          &lt;li&gt;</p><p class="source-code">            &lt;button</p><p class="source-code">              type="button"</p><p class="source-code">              onClick={transitionToAddCustomer}&gt;</p><p class="source-code">              Add customer and appointment</p><p class="source-code">            &lt;/button&gt;</p><p class="source-code">          &lt;/li&gt;</p><p class="source-code">        &lt;/menu&gt;</p><p class="source-code">        &lt;AppointmentsDayViewLoader /&gt;</p><p class="source-code">      &lt;/&gt;</p><p class="source-code">    );</p><p class="source-code">}</p></li>
<li>Once you’ve verified that your tests still pass, un-skip your latest test by changing <strong class="source-inline">it.skip</strong> back to <strong class="source-inline">it</strong>.</li>
<li>The <a id="_idIndexMarker873"/>component should update the view to <strong class="source-inline">addAppointment</strong> whenever the <strong class="source-inline">onSave</strong> prop of <strong class="source-inline">CustomerForm</strong> is called. Let’s do that with a new callback handler. Add the following code just below the definition of <strong class="source-inline">transitionToAddCustomer</strong>:<p class="source-code">const transitionToAddAppointment = useCallback(</p><p class="source-code">  () =&gt; {</p><p class="source-code">  setView("addAppointment")</p><p class="source-code">}, []);</p></li>
<li>Modify the <strong class="source-inline">CustomerForm</strong> render expression so that it takes this as a prop:<p class="source-code">&lt;CustomerForm</p><p class="source-code">  original={blankCustomer}</p><p class="source-code"><strong class="bold">  onSave={transitionToAddAppointment}</strong></p><p class="source-code">/&gt;</p></li>
<li>Hook up the new <strong class="source-inline">addAppointment</strong> value by adding the following <strong class="source-inline">case</strong> statement to the switch. After making this change, your test should be passing:<p class="source-code">case "addAppointment":</p><p class="source-code">  return (</p><p class="source-code">    &lt;AppointmentFormLoader /&gt;</p><p class="source-code">  );</p></li>
<li>For the next test, we <a id="_idIndexMarker874"/>need to pass a value for the <strong class="source-inline">original</strong> prop, this time to <strong class="source-inline">AppointmentFormLoader</strong>. Note the double use of <strong class="source-inline">expect.objectContaining</strong>. This is necessary because our appointment is not going to be a simple blank appointment object. This time, the appointment will have a customer ID passed to it. That customer ID is the ID of the customer we’ve just added – we’ll write a test for that next:<p class="source-code">it("passes a blank original appointment object to CustomerForm", async () =&gt; {</p><p class="source-code">  render(&lt;App /&gt;);</p><p class="source-code">  beginAddingCustomerAndAppointment();</p><p class="source-code">  saveCustomer();</p><p class="source-code">  expect(AppointmentFormLoader).toBeRenderedWithProps(</p><p class="source-code">    expect.objectContaining({</p><p class="source-code">      original: </p><p class="source-code">        expect.objectContaining(blankAppointment),</p><p class="source-code">    })</p><p class="source-code">  );</p><p class="source-code">});</p></li>
<li>We need a builder function, just like with <strong class="source-inline">blankCustomer</strong>. Create a new file, <strong class="source-inline">test/builders/appointment.js</strong>, and add the following definition:<p class="source-code">export const blankAppointment = {</p><p class="source-code">  service: "",</p><p class="source-code">  stylist: "",</p><p class="source-code">  startsAt: null,</p><p class="source-code">};</p></li>
<li>Update the test code to import that:<p class="source-code">import {</p><p class="source-code">  blankAppointment</p><p class="source-code">} from "./builders/appointment";</p></li>
<li>Then, create <a id="_idIndexMarker875"/>the same thing in <strong class="source-inline">src/App.js</strong>:<p class="source-code">const blankAppointment = {</p><p class="source-code">  service: "",</p><p class="source-code">  stylist: "",</p><p class="source-code">  startsAt: null,</p><p class="source-code">};</p></li>
<li>Finally, you can make the test pass by setting the <strong class="source-inline">original</strong> prop, as shown here:<p class="source-code">&lt;AppointmentFormLoader <strong class="bold">original={blankAppointment}</strong> /&gt;</p></li>
</ol>
<p>We’re almost done with the display of <strong class="source-inline">AppointmentFormLoader</strong>, but not quite: we still need to take the customer ID we receive from the <strong class="source-inline">onSave</strong> callback and pass it into <strong class="source-inline">AppointmentFormLoader</strong>, by way of the <strong class="source-inline">original</strong> prop value, so that <strong class="source-inline">AppointmentForm</strong> knows<a id="_idIndexMarker876"/> which customer we’re creating an appointment for.</p>
<h1 id="_idParaDest-153"><a id="_idTextAnchor154"/>Making use of callback values</h1>
<p>In this section, we’ll<a id="_idIndexMarker877"/> introduce a new state variable, <strong class="source-inline">customer</strong>, that will be set when <strong class="source-inline">CustomerForm</strong> receives the <strong class="source-inline">onSave</strong> callback. After that, we’ll do the final transition in our workflow, from <strong class="source-inline">addAppointment</strong> back to <strong class="source-inline">dayView</strong>.</p>
<p>Follow these steps:</p>
<ol>
<li value="1">This time, we’ll check that the new customer ID is passed to <strong class="source-inline">AppointmentFormLoader</strong>. Remember in the previous section how we gave <strong class="source-inline">saveCustomer</strong> a customer parameter? We’ll make use of that in this test:<p class="source-code">it("passes the customer to the AppointmentForm", async () =&gt; {</p><p class="source-code">  const customer = { id: 123 };</p><p class="source-code">  render(&lt;App /&gt;);</p><p class="source-code">  beginAddingCustomerAndAppointment();</p><p class="source-code">  saveCustomer(customer);</p><p class="source-code">  expect(AppointmentFormLoader).toBeRenderedWithProps(</p><p class="source-code">    expect.objectContaining({</p><p class="source-code">      original: expect.objectContaining({</p><p class="source-code">        customer: customer.id,</p><p class="source-code">      }),</p><p class="source-code">    })</p><p class="source-code">  );</p><p class="source-code">});</p></li>
<li>For this to work, we’ll need to add a state variable for the customer. Add the following at the top of the <strong class="source-inline">App</strong> component:<p class="source-code">const [customer, setCustomer] = useState();</p></li>
<li>When we built the <strong class="source-inline">onSave</strong> prop of <strong class="source-inline">CustomerForm</strong> back in <a href="B18423_06.xhtml#_idTextAnchor099"><em class="italic">Chapter 6</em></a>,<em class="italic"> Exploring Test Doubles</em>, we passed it the updated customer object. Update the <strong class="source-inline">transitiontoAddAppointment</strong> handler so that it takes this parameter <a id="_idIndexMarker878"/>value and saves it using the <strong class="source-inline">setCustomer</strong> setter:<p class="source-code">const transitionToAddAppointment = useCallback(</p><p class="source-code"><strong class="bold">  (customer) =&gt; {</strong></p><p class="source-code"><strong class="bold">  setCustomer(customer);</strong></p><p class="source-code">  setView("addAppointment")</p><p class="source-code">}, []);</p></li>
<li>Pass that through to <strong class="source-inline">AppointmentFormLoader</strong> by creating a new <strong class="source-inline">original</strong> object value that merges the customer ID into <strong class="source-inline">blankAppointment</strong>:<p class="source-code">case "addAppointment":</p><p class="source-code">  return (</p><p class="source-code">    &lt;AppointmentFormLoader</p><p class="source-code">      original=<strong class="bold">{{</strong></p><p class="source-code"><strong class="bold">        ...blankAppointment,</strong></p><p class="source-code"><strong class="bold">        customer: customer.id,</strong></p><p class="source-code"><strong class="bold">      }}</strong></p><p class="source-code">    /&gt;</p><p class="source-code">);</p></li>
<li>It’s time for the final test for this component. We complete the user workflow by asserting that <a id="_idIndexMarker879"/>once the appointment is saved, the view updates back to <strong class="source-inline">dayView</strong>:<p class="source-code">const saveAppointment = () =&gt;</p><p class="source-code">  act(() =&gt; propsOf(AppointmentFormLoader).onSave());</p><p class="source-code">it("renders AppointmentDayViewLoader after AppointmentForm is submitted", async () =&gt; {</p><p class="source-code">  render(&lt;App /&gt;);</p><p class="source-code">  beginAddingCustomerAndAppointment();</p><p class="source-code">  saveCustomer();</p><p class="source-code">  saveAppointment();</p><p class="source-code">  expect(AppointmentsDayViewLoader).toBeRendered();</p><p class="source-code">});</p></li>
<li>Define a new function to set the state back to <strong class="source-inline">dayView</strong>:<p class="source-code">const transitionToDayView = useCallback(</p><p class="source-code">  () =&gt; setView("dayView"),</p><p class="source-code">  []</p><p class="source-code">);</p></li>
<li>Pass this function to <strong class="source-inline">AppointmentsFormLoader</strong> to ensure it’s called when the appointment is saved. After this, your tests should be complete and passing:<p class="source-code">case "addAppointment":</p><p class="source-code">  return (</p><p class="source-code">    &lt;AppointmentFormLoader</p><p class="source-code">      original={{</p><p class="source-code">        ...blankAppointment,</p><p class="source-code">        customer: customer.id,</p><p class="source-code">      }}</p><p class="source-code"><strong class="bold">      onSave={transitionToDayView}</strong></p><p class="source-code">    /&gt;</p><p class="source-code">  );</p></li>
</ol>
<p>We’re done!</p>
<p>Now, all that’s left is<a id="_idIndexMarker880"/> to update <strong class="source-inline">src/index.js</strong> to render the <strong class="source-inline">App</strong> component. Then, you can manually test this to check out your handiwork:</p>
<pre class="source-code">
import React from "react";
import ReactDOM from "react-dom";
import { App } from "./App";
ReactDOM
  .createRoot(document.getElementById("root"))
  .render(&lt;App /&gt;);</pre>
<p>To run the application, use the <strong class="source-inline">npm run serve</strong> command. For more information see the <em class="italic">Technical requirements</em> section in <a href="B18423_06.xhtml#_idTextAnchor099"><em class="italic">Chapter 6</em></a><em class="italic">, Exploring Test Doubles</em>, <a id="_idTextAnchor155"/>or consult the <strong class="source-inline">README.md</strong> file in the repository.</p>
<h1 id="_idParaDest-154"><a id="_idTextAnchor156"/>Summary</h1>
<p>This chapter covered the final TDD technique for you to learn – mocked component callback props. You learned how to get a reference to a component callback using the <strong class="source-inline">propsOf</strong> extension, as well as how to use a state variable to manage the transitions between different parts of a workflow.</p>
<p>You will have noticed how <em class="italic">all</em> the child components in <strong class="source-inline">App</strong> were mocked out. This is often the case with top-level components, where each child component is a relatively complex, self-contained unit.</p>
<p>In the next part of this book, we’ll apply everything we’ve learned to more complex scenarios. We’ll start by introducing field validation into our <strong class="source-inline">CustomerForm</strong> component.</p>
<h1 id="_idParaDest-155"><a id="_idTextAnchor157"/>Exercises</h1>
<p>The following are some exercises for you to try out:</p>
<ol>
<li value="1">Update your <strong class="source-inline">CustomerForm</strong> and <strong class="source-inline">AppointmentForm</strong> tests to use the new builders you’ve created.</li>
<li>Add a test to <strong class="source-inline">AppointmentForm</strong> that ensures that the customer ID is submitted when the form is submitted.</li>
</ol>
</div>
<div>
<div id="_idContainer027">
</div>
</div>
</div>

<div id="sbo-rt-content"><div class="Content" id="_idContainer028">
<h1 id="_idParaDest-156"><a id="_idTextAnchor158"/>Part 2 – Building Application Features</h1>
<p>This part builds on the basic techniques you’ve learned in <em class="italic">Part 1</em> by applying them to real-world problems that you’ll encounter in your work, and introduces libraries that many React developers use: React Router, Redux, and Relay (GraphQL). The goal is to show you how the TDD workflow can be used even for large applications.</p>
<p>This part includes the following chapters:</p>
<ul>
<li><a href="B18423_09.xhtml#_idTextAnchor159"><em class="italic">Chapter 9</em></a>, <em class="italic">Form Validation</em></li>
<li><a href="B18423_10.xhtml#_idTextAnchor183"><em class="italic">Chapter 10</em></a>, <em class="italic">Filtering and Searching Data</em></li>
<li><a href="B18423_11.xhtml#_idTextAnchor207"><em class="italic">Chapter 11</em></a>, <em class="italic">Test-Driving React Router</em></li>
<li><a href="B18423_12.xhtml#_idTextAnchor231"><em class="italic">Chapter 12</em></a>, <em class="italic">Test-Driving Redux</em></li>
<li><a href="B18423_13.xhtml#_idTextAnchor258"><em class="italic">Chapter 13</em></a>, <em class="italic">Test-Driving GraphQL</em></li>
</ul>
</div>
</div></body></html>