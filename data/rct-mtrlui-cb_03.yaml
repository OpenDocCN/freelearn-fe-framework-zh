- en: Drawers - A Place for Navigation Controls
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽屉 - 导航控制的位置
- en: 'In this chapter, you''ll learn about the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下食谱：
- en: Drawer types
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽屉类型
- en: Drawer item state
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽屉项目状态
- en: Drawer item navigation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽屉项目导航
- en: Drawer sections
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽屉部分
- en: AppBar interaction
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AppBar交互
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Material-UI uses drawers to present the user with the main navigation of the
    app. The `Drawer` component acts like a physical drawer that can move out of view
    when it is not being used.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Material-UI使用抽屉向用户提供应用程序的主要导航。`Drawer`组件就像一个物理抽屉，当它未被使用时可以移出视图。
- en: Drawer types
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽屉类型
- en: 'There are three types of `Drawer` components that you''ll use in your app,
    as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用程序中，你将使用以下三种类型的`Drawer`组件，如下所示：
- en: '**Temporary**: A transient drawer that closes when an action is taken.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**临时**：一个在执行操作时关闭的短暂抽屉。'
- en: '**Persistent**: A drawer that can be opened and stays open until explicitly
    closed.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久**：一个可以打开并保持打开状态直到明确关闭的抽屉。'
- en: '**Permanent**: A drawer that is always visible.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**永久**：一个始终可见的抽屉。'
- en: How to do it...
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Let''s say that you want to support different types of drawers in your app.
    You can control the `Drawer` component type using the `variant` property. Here''s
    the code:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要在应用程序中支持不同类型的抽屉。你可以使用`variant`属性来控制`Drawer`组件类型。以下是代码：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `variant` property defaults to `temporary`. When you first load this screen,
    you''ll only see the button to toggle the drawer display:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`variant`属性默认为`temporary`。当你首次加载此屏幕时，你将只会看到切换抽屉显示的按钮：'
- en: '![](img/9d6c488b-915a-49f0-a0e2-164daaa0f241.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9d6c488b-915a-49f0-a0e2-164daaa0f241.png)'
- en: 'When you click on this button, you''ll see a temporary drawer:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击此按钮时，你会看到一个临时抽屉：
- en: '![](img/31351208-3f04-4717-9dc1-a008497baef6.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/31351208-3f04-4717-9dc1-a008497baef6.png)'
- en: How it works...
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Before you start changing the `variant` property, let''s walk through the code
    in this example, starting with the `Drawer` markup, as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始更改`variant`属性之前，让我们先浏览一下这个示例中的代码，从`Drawer`标记开始，如下所示：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `Drawer` component takes an `open` property, which displays the drawer when
    true. The `variant` property determines the type of drawer to render. The screenshot
    shown previously is a temporary drawer, the default variant value. The `Drawer`
    component has `List` as its child, where each of the items displayed in the drawer
    are rendered.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`Drawer`组件接受一个`open`属性，当为`true`时显示抽屉。`variant`属性决定了要渲染的抽屉类型。之前显示的截图是一个临时抽屉，默认的变体值。`Drawer`组件的子组件是`List`，其中抽屉中显示的每个项目都会被渲染。'
- en: 'Next, let''s take a look at the `Button` component that toggles the display
    of the `Drawer` component:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看用于切换`Drawer`组件显示的`Button`组件：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When this button is clicked, the `open` state of your component is toggled.
    Likewise, the text of the button is toggled depending on the value of the `open`
    state.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击此按钮时，你的组件的`open`状态会切换。同样，按钮的文本也会根据`open`状态的值切换。
- en: 'Now let''s try changing the value of the `variant` property to `permanent`.
    Here''s what the drawer looks like when rendered:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试将`variant`属性的值更改为`permanent`。以下是抽屉渲染后的样子：
- en: '![](img/5f39ffc3-b127-46f2-8c84-f1e140add015.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5f39ffc3-b127-46f2-8c84-f1e140add015.png)'
- en: 'A permanent drawer, as the name suggests, is always visible and is always in
    the same place on the screen. If you click on the SHOW DRAWER button, the `open`
    state of your component is toggled to true. You''ll see the text of the button
    change, but since the `Drawer` component is using the `permanent` variant, the
    `open` property has no effect:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 永久抽屉，正如其名所示，始终可见，并且始终位于屏幕上的同一位置。如果你点击显示抽屉按钮，你的组件的`open`状态会被切换为`true`。你会看到按钮的文本改变，但由于`Drawer`组件使用的是`permanent`变体，所以`open`属性没有效果：
- en: '![](img/2ac0e855-67c2-43e3-988d-5b0773d3367a.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2ac0e855-67c2-43e3-988d-5b0773d3367a.png)'
- en: Next, let's try the `persistent` variant. Persistent drawers are similar to
    permanent drawers in that they stay visible on the screen while the user interacts
    with the app, and they're similar to temporary drawers in that they can be hidden
    by changing the `open` property.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们尝试使用`persistent`变体。持久抽屉与永久抽屉类似，在用户与应用程序交互时它们会保持在屏幕上可见，并且它们与临时抽屉类似，可以通过更改`open`属性来隐藏。
- en: Let's change the `variant` property to `persistent`. When the screen first loads,
    the drawer isn't visible because the `open` state of your component is `false`.
    Try clicking on the SHOW DRAWER button. The drawer is displayed, and it looks
    like the permanent drawer. If you click the HIDE DRAWER button, the `open` state
    of your component is toggled to `false` and the drawer is hidden.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`variant`属性更改为`persistent`。当屏幕首次加载时，抽屉不可见，因为组件的`open`状态是`false`。尝试点击SHOW
    DRAWER按钮。抽屉被显示，看起来像永久抽屉。如果您点击HIDE DRAWER按钮，组件的`open`状态将切换到`false`，抽屉将被隐藏。
- en: Persistent drawers should be used when you want the user to be able to control
    the visibility of the drawer. For example, with temporary drawers the user can
    close the drawer by clicking on the overlay or by hitting the *Esc *key. Permanent
    drawers are useful when you want to use the left-hand navigation as an integral
    part of the page layout—they are always visible and other items are laid out around
    them.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当您希望用户能够控制抽屉的可见性时，应使用持久抽屉。例如，使用临时抽屉时，用户可以通过点击覆盖层或按*Esc*键来关闭抽屉。当您希望将左侧导航作为页面布局的组成部分时，永久抽屉非常有用——它们始终可见，其他项目则围绕它们布局。
- en: There's more...
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: When you click on any of the items in the drawer, the event handlers set the
    `open` state of your component to `false`. This might not be what you want and
    could potentially confuse your users. For example, if you're using a persistent
    drawer, your app probably has a button outside of the drawer that controls the
    visibility of the drawer. If the user clicks on a drawer item, they're probably
    not expecting the drawer to close.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当您点击抽屉中的任何项目时，事件处理器会将组件的`open`状态设置为`false`。这可能不是您想要的，可能会让您的用户感到困惑。例如，如果您使用的是持久抽屉，那么您的应用可能有一个位于抽屉外的按钮来控制抽屉的可见性。如果用户点击抽屉项目，他们可能不会期望抽屉关闭。
- en: 'To address this issue, your event handlers can take into consideration a variant
    of the `Drawer` component:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，您的事件处理器可以考虑`Drawer`组件的一个变体：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, when you click on any of these items, the `open` state is only changed
    to `false` if the `variant` property is `temporary`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您点击这些项目中的任何一个时，只有当`variant`属性是`temporary`时，`open`状态才会更改为`false`。
- en: See also
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '`Drawer` demos: [https://material-ui.com/demos/drawers/](https://material-ui.com/demos/drawers/)'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Drawer` 示例：[https://material-ui.com/demos/drawers/](https://material-ui.com/demos/drawers/)'
- en: '`Drawer` API documentation: [https://material-ui.com/api/drawer/](https://material-ui.com/api/drawer/)'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Drawer` API 文档：[https://material-ui.com/api/drawer/](https://material-ui.com/api/drawer/)'
- en: Drawer item state
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽屉项目状态
- en: The items that are rendered in `Drawer` components are rarely static. Instead,
    the drawer items are rendered based on the state of your component, allowing for
    more control over how items are displayed.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Drawer`组件中渲染的项目很少是静态的。相反，抽屉项目是根据组件的状态渲染的，这允许您对项目的显示方式有更多的控制。
- en: How to do it...
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Let's say that you have a component that renders drawer navigation using the
    `Drawer` component. Instead of writing the `items` state directly in the component
    markup, you want to have the `items` state stored in the state of the component.
    For example, in response to permission checks on the user, items might be disabled
    or completely hidden.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一个使用`Drawer`组件渲染抽屉导航的组件。您不想直接在组件标记中写入`items`状态，而是希望将`items`状态存储在组件的状态中。例如，在响应用户的权限检查时，项目可能会被禁用或完全隐藏。
- en: 'Here''s an example that uses an array of `item` objects from the component
    state:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个使用组件状态中的`item`对象数组的示例：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is what the drawer looks like when you click on the SHOW DRAWER button:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 点击SHOW DRAWER按钮时，抽屉看起来是这样的：
- en: '![](img/ca571334-0b02-485f-bb77-8c48a771ba1c.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ca571334-0b02-485f-bb77-8c48a771ba1c.png)'
- en: 'If you select one of these items, the drawer will close and the content of
    the screen will be updated; for example, after clicking on Page 2, you should see
    something similar to the following screenshot:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择这些项目中的任何一个，抽屉将关闭，屏幕内容将更新；例如，在点击页面2后，您应该看到以下截图类似的内容：
- en: '![](img/d23b7e85-7e2e-4b52-bcbf-80d90409243c.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d23b7e85-7e2e-4b52-bcbf-80d90409243c.png)'
- en: How it works...
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s start by looking at the state of your component:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看组件的状态开始：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `open` state controls the visibility of the `Drawer` component, and the
    `content` state is the text that's displayed on the screen depending on which
    drawer item is clicked on. The `items` state is an array of objects that is used
    to render the drawer items. Every object has a `label` property and an `Icon`
    property that are used to render the item text and icon respectively.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`open`状态控制`Drawer`组件的可见性，`content`状态是屏幕上显示的文本，取决于哪个抽屉项被点击。`items`状态是一个用于渲染抽屉项的对象数组。每个对象都有一个`label`属性和一个`Icon`属性，分别用于渲染项目文本和图标。'
- en: The `Icon` property is capitalized in order to maintain the React convention
    of capitalizing components. This makes it easier to differentiate React components
    from other data when reading the code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持React组件大写命名约定，`Icon`属性被大写。这使得在阅读代码时更容易区分React组件和其他数据。
- en: 'The `disabled` property is used to render the item as disabled; for example,
    Page 3 is marked as disabled by setting this property to `true`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`disabled`属性用于将项目渲染为禁用状态；例如，通过将此属性设置为`true`，将第3页标记为禁用：'
- en: '![](img/fb518bc4-d0f0-4f9b-85d7-746bf7944c89.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fb518bc4-d0f0-4f9b-85d7-746bf7944c89.png)'
- en: This could be due to permission restrictions for the user on this particular
    page, or some other reason. Because this is controlled through the component state
    instead of rendered statically, you could update the `disabled` state for any
    menu item at any time using any mechanism that you like, such as an API call.
    The `hidden` property uses the same principle, except when this value is `true`,
    the item isn't rendered at all. In this example, Page 5 isn't rendered because
    it's marked as hidden.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是由于用户在此特定页面上存在权限限制或其他原因。因为这是通过组件状态而不是静态渲染来控制的，所以你可以使用任何你喜欢的机制（如API调用）在任何时候更新任何菜单项的`disabled`状态。`hidden`属性使用相同的原则，只是当此值为`true`时，项目根本不会渲染。在这个例子中，第5页没有渲染，因为它被标记为隐藏。
- en: 'Next, let''s look at how the `List` items are rendered based on the `items`
    state, as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何根据`items`状态渲染`List`项，如下所示：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: First, the `items` array is filtered to remove `hidden` items. Then, `map()`
    is used to render each `ListItem` component. The `disabled` property is passed
    to `ListItem` and it will be visibly disabled when rendered. The `Icon` component
    also comes from the list item state. The `onClick()` event handler hides the drawer
    and updates the `content` label.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`items`数组被过滤以移除`hidden`项。然后，使用`map()`渲染每个`ListItem`组件。将`disabled`属性传递给`ListItem`，当渲染时它将显示为禁用状态。`Icon`组件也来自列表项状态。`onClick()`事件处理程序隐藏抽屉并更新`content`标签。
- en: The `onClick()` handler isn't executed when disabled list items are clicked
    on.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击禁用列表项时，`onClick()`处理程序不会执行。
- en: There's more...
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'You might want to separate the rendering of list items into its own component.
    This way, you can use the list items in other places. For example, you might want
    to use the same rendering logic to render a list of buttons elsewhere in your
    app. Here''s an example of how you can extract the `ListItems` component into
    its own component:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望将列表项的渲染分离成独立的组件。这样，你可以在其他地方使用列表项。例如，你可能希望在其他地方使用相同的渲染逻辑来渲染按钮列表。以下是一个如何将`ListItems`组件提取为独立组件的示例：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `ListItems` component will return an array of `ListItem` components. It
    takes the `items` state to render as an array property. It also takes an `onClick()`
    function property. This is a higher-order function that takes the `label` component
    to display as an argument and returns a new function that will update the content
    when the item is clicked on.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListItems`组件将返回一个`ListItem`组件的数组。它接受一个作为数组属性的`items`状态来渲染。它还接受一个`onClick()`函数属性。这是一个高阶函数，它接受要显示的`label`组件作为参数，并返回一个新函数，当项目被点击时将更新内容。'
- en: 'Here''s what the new JSX markup looks like, updated to use the new `ListItems`
    component:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是新的JSX标记的示例，已更新为使用新的`ListItems`组件：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There is no more list item rendering code in this component. Instead, `ListItems`
    is rendered as the child of `List`. You pass it the items to render and the `onClick()`
    handler. You now have a generic `ListItems` component that can be used anywhere
    that you show lists in your app. It will consistently handle the `Icon`, `disabled`,
    and display logic wherever it is used.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在此组件中不再有列表项渲染代码。相反，`ListItems`作为`List`的子组件被渲染。你传递给它要渲染的项目和`onClick()`处理程序。现在你有一个通用的`ListItems`组件，可以在你应用中显示列表的任何地方使用。它将在任何使用位置一致地处理`Icon`、`disabled`和显示逻辑。
- en: See also
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '`Drawer` demos: [https://material-ui.com/demos/drawers/](https://material-ui.com/demos/drawers/)'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Drawer` 示例：[https://material-ui.com/demos/drawers/](https://material-ui.com/demos/drawers/)'
- en: '`Drawer` API documentation: [https://material-ui.com/api/drawer/](https://material-ui.com/api/drawer/)'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Drawer` API 文档：[https://material-ui.com/api/drawer/](https://material-ui.com/api/drawer/)'
- en: Drawer item navigation
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽屉项目导航
- en: If your Material-UI app uses a router such as `react-router` to navigate from
    page to page, you'll probably want links as your `Drawer` items. To do so, you
    have to integrate components from the `react-router-dom` package.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的Material-UI应用使用`react-router`等路由器在页面之间导航，你可能希望将链接作为`Drawer`项目。为此，你必须集成来自`react-router-dom`包的组件。
- en: How to do it...
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s say that your app is composed of three pages. To navigate from page
    to page, you want to provide your users with links in the `Drawer` component.
    Here''s what the code looks like:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的应用由三个页面组成。为了在页面之间导航，你希望在`Drawer`组件中为用户提供链接。以下是代码的样子：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When you first load the screen, you''ll see the SHOW DRAWER button and the
    home screen content:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当你首次加载屏幕时，你会看到显示抽屉按钮和主页内容：
- en: '![](img/46804d4b-9540-467d-ae24-d84a125efcf1.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/46804d4b-9540-467d-ae24-d84a125efcf1.png)'
- en: 'Here''s what the drawer looks like when it''s opened:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是抽屉打开时的样子：
- en: '![](img/2009526a-078d-4682-a60a-fdee2a67dcc0.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2009526a-078d-4682-a60a-fdee2a67dcc0.png)'
- en: 'If you click on Page 2, which points to `/page2`, the drawer should close and
    you should be taken to the second page. Here''s what it looks like:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击第2页，它指向`/page2`，抽屉应该关闭，并且你应该被带到第二页。以下是它的样子：
- en: '![](img/f731a302-e6f9-4372-bd33-fcce103055b0.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f731a302-e6f9-4372-bd33-fcce103055b0.png)'
- en: You should see something similar if you click on Page 3 or on Home. The content
    on the left side of the screen is updated.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击第3页或主页，你应该能看到类似的内容。屏幕左侧的内容会更新。
- en: How it works...
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s start by looking at the `Route` components that `render` content based
    on the active the `Route` components:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看基于活动`Route`组件`render`内容的`Route`组件：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There's a `Route` component used for each `path` in your app. The `render()`
    function returns the content that should be rendered within this `Grid` item when
    the `path` property matches the current URL.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用中的`path`都会使用一个`Route`组件。`render()`函数返回当`path`属性与当前URL匹配时应在`Grid`项中渲染的内容。
- en: 'Next, let''s look at one of the `ListItem` components within the `Drawer` component,
    as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看`Drawer`组件中的一个`ListItem`组件，如下所示：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: By default, the `ListItem` component will render a `div` element. It accepts
    a `button` property that when true, will render a `button` element. You don't
    want either of these. Instead, you want the list items to be links that `react-router`
    will process. The `component` property accepts a custom component to use; in this
    example, you want to use the `Link` component from the `react-router-dom` package.
    This will render the appropriate link while maintaining the proper styles.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`ListItem`组件将渲染一个`div`元素。它接受一个`button`属性，当为`true`时，将渲染一个`button`元素。你都不需要这些。相反，你希望列表项是`react-router`将处理的链接。`component`属性接受一个自定义组件来使用；在这个例子中，你想要使用来自`react-router-dom`包的`Link`组件。这将渲染适当的链接，同时保持正确的样式。
- en: The properties that you pass to `ListItem` are also passed to your custom component,
    which, in this case, is `Link`. This means that the required `to` property is
    passed to `Link`, pointing the link to `/`. Likewise, the `onClick` handler is
    also passed to the `Link` component, which is important because you want to close
    the temporary drawer whenever a link is clicked.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你传递给`ListItem`组件的属性也会传递给你的自定义组件，在这个例子中，是`Link`组件。这意味着必需的`to`属性被传递给`Link`组件，指向`/`。同样，`onClick`处理程序也被传递给`Link`组件，这很重要，因为你想在点击链接时关闭临时抽屉。
- en: There's more...
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'When the items in your drawer are links, you probably want a visual indication
    for the active link. The challenge is that you want to style the active link using
    Material-UI theme styles. Here''s what the modified example looks like:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的抽屉中的项是链接时，你可能想要为活动链接提供一个视觉指示。挑战在于你想使用Material-UI主题样式来样式化活动链接。以下是修改后的示例：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, when the screen first loads and you open the drawer, it should look similar
    to the following screenshot:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当屏幕首次加载并打开抽屉时，它应该看起来类似于以下截图：
- en: '![](img/5a885787-b548-4c9b-bb81-0a939229c273.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5a885787-b548-4c9b-bb81-0a939229c273.png)'
- en: 'Since the Home link is active, it''s styled using the primary color from the
    Material-UI theme. If you click on the Page 2 link and then open the drawer again,
    it should look similar to the following screenshot:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于主页链接处于活动状态，它使用Material-UI主题的基色进行样式化。如果你点击页面2链接然后再次打开抽屉，它应该看起来类似于以下截图：
- en: '![](img/7e655bd5-9ef9-4e4c-b642-fb132e5a2657.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7e655bd5-9ef9-4e4c-b642-fb132e5a2657.png)'
- en: 'Let''s take a look at the two new components that you''ve added, starting with
    `NavItem`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你添加的两个新组件，从`NavItem`开始：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This component is used to determine whether or not the item is active, based
    on the current URL. It uses the `Switch` component from `react-router-dom`. Instead
    of just rendering `Route` components, `Switch` will only render the first route
    whose path matches the current URL. The first `Route` component in `NavItem` is
    the specific path (as it uses the `exact` property). If this `Route` component
    matches, it renders a `NavListItem` component with the `active` property set to
    true. Because it's in a `Switch` component, the second `Route` component will
    not be rendered.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件用于根据当前URL确定项目是否处于活动状态。它使用来自`react-router-dom`的`Switch`组件。`Switch`组件不仅会渲染`Route`组件，而且只会渲染与当前URL匹配的第一个路由。`NavItem`中的第一个`Route`组件是特定路径（因为它使用了`exact`属性）。如果这个`Route`组件匹配，它将渲染一个将`active`属性设置为true的`NavListItem`组件。因为它在`Switch`组件中，所以第二个`Route`组件将不会被渲染。
- en: 'If, on the other hand, the first `Route` component doesn''t match, the second
    `Route` component will always match. This will render a `NavListItem` component
    without the `active` property. Now, let''s take a look at the `NavListItem` component,
    as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果第一个`Route`组件不匹配，第二个`Route`组件将始终匹配。这将渲染一个不带`active`属性的`NavListItem`组件。现在，让我们看一下`NavListItem`组件，如下所示：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `NavListItem` component is now responsible for rendering the `ListItem`
    components in the `Drawer` component. It takes a `text` property and an `Icon`
    property to render the label and the icon respectively, just like before your
    enhancements. The `active` property is used to determine the class that gets applied
    to the `ListItemIcon` and `ListItemText` components. The `activeListItem` CSS
    class is applied to both of these components if `active` is true. This is how
    you're able to style the `active` item based on the Material-UI theme.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`NavListItem`组件现在负责在`Drawer`组件中渲染`ListItem`组件。它接受一个`text`属性和一个`Icon`属性来分别渲染标签和图标，就像在你增强之前一样。`active`属性用于确定应用于`ListItemIcon`和`ListItemText`组件的类。如果`active`为true，则将应用`activeListItem`
    CSS类到这两个组件上。这就是你能够根据Material-UI主题样式化活动项的方式。'
- en: 'The `clsx()` function is used extensively by Material-UI–this isn''t an extra
    dependency. It allows you to dynamically change the class of an element without
    introducing custom logic into your markup. For example, the `clsx({ [classes.activeListItem]:
    active })` syntax will only apply the `activeListItem` class if `active` is true.
    The alternative will involve introducing more logic into your component.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`clsx()`函数在Material-UI中被广泛使用——这不是一个额外的依赖。它允许你动态地更改元素的类，而无需在标记中引入自定义逻辑。例如，`clsx({
    [classes.activeListItem]: active })`语法只有在`active`为true时才会应用`activeListItem`类。另一种方法将涉及在你的组件中引入更多的逻辑。'
- en: 'Lastly, let''s take a look at the `activeListItem` class, as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看一下`activeListItem`类，如下所示：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `activeListItem` class sets the color CSS property by using the `theme.palette.primary.main`
    value. This means that if the theme changes, your active link in the drawer will
    be styled accordingly.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`activeListItem`类通过使用`theme.palette.primary.main`值来设置颜色CSS属性。这意味着如果主题发生变化，抽屉中的活动链接将被相应地样式化。'
- en: See also
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'React Router documentation: [https://reacttraining.com/react-router/](https://reacttraining.com/react-router/)'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Router 文档：[https://reacttraining.com/react-router/](https://reacttraining.com/react-router/)
- en: '`Drawer` demos: [https://material-ui.com/demos/drawers/](https://material-ui.com/demos/drawers/)'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Drawer`演示：[https://material-ui.com/demos/drawers/](https://material-ui.com/demos/drawers/)'
- en: '`Drawer` API documentation: [https://material-ui.com/api/drawer/](https://material-ui.com/api/drawer/)'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Drawer` API 文档：[https://material-ui.com/api/drawer/](https://material-ui.com/api/drawer/)'
- en: Drawer sections
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽屉部分
- en: When you have lots of items in your `Drawer`, you might want to divide your
    drawer into sections. When you have lots of drawer items and no sections, you
    end up having to put section names into the items themselves, which leads to messy
    and awkward drawer item labels.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在你的`Drawer`中有大量项时，你可能想要将你的抽屉分成几个部分。当你有大量的抽屉项而没有部分时，你最终不得不在项本身中放入部分名称，这会导致混乱和不自然的抽屉项标签。
- en: How to do it...
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s say that you''re working on an app that has screens for managing different
    aspects of the CPU, memory, storage, and network. Instead of having a flat list
    of drawer items, you could display drawer items in their relevant sections, making
    it easier to navigate. Here''s the code to do it:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在开发一个应用程序，该应用程序有用于管理CPU、内存、存储和网络不同方面的屏幕。你可以在相关的部分中显示抽屉项，而不是有一个平面的抽屉项列表，这样可以更容易地进行导航。以下是实现这一点的代码：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When you click on the SHOW DRAWER button, your drawer should look like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击SHOW DRAWER按钮时，你的抽屉应该看起来像这样：
- en: '![](img/a9693127-5df8-4733-b79e-d538d65b573c.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a9693127-5df8-4733-b79e-d538d65b573c.png)'
- en: There are lots of add and usage items in this drawer. The sections make the
    items easier for your users to scan.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个抽屉中有许多添加和使用项。部分使你的用户更容易扫描这些项。
- en: How it works...
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s start by taking a look at the state of your component, as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看你的组件状态，如下所示：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Instead of the `items` state being a flat array of items, it''s now an object
    with arrays grouped by category. These are the drawer sections that you want to
    render. Next, let''s look at the `List` markup for rendering the `items` state
    and the section headers:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 与`items`状态是一个平面的项数组不同，它现在是一个对象，其中数组按类别分组。这些是你想要渲染的抽屉部分。接下来，让我们看看用于渲染`items`状态和部分标题的`List`标记：
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `ListSubheader` component is used when you need a label above the list items.
    For example, underneath the Storage header, you have the `ListItems` component
    that renders items from the `items.storage` state.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要在上面的列表项之上有一个标签时，使用`ListSubheader`组件。例如，在存储标题下面，你有`ListItems`组件，它从`items.storage`状态渲染项。
- en: There's more...
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: When you have a lot of drawer items and sections, you can still overwhelm your
    users with the amount of information to parse. One solution is to have collapsible
    sections. For this, you can add a `Button` component to the `ListSubheader` component
    so that it's clickable.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有大量的抽屉项和部分时，你仍然可以用需要解析的信息量压倒你的用户。一个解决方案是拥有可折叠的部分。为此，你可以在`ListSubheader`组件中添加一个`Button`组件，使其可点击。
- en: 'Here''s what the code looks like:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是代码的样子：
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The ripple effect that would normally happen when you click on a button is
    disabled here because you want the header text to still look like header text.
    This also requires a little bit of CSS customization in the `listSubheader` class:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击按钮时通常会发生的水波效应在这里被禁用了，因为你希望标题文本仍然看起来像标题文本。这也需要在`listSubheader`类中进行一些CSS定制：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When the section header button is clicked, it toggles the state of the section,
    which in turn, toggles the visibility of the section items. Here''s the `toggleSection()`
    function:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击部分标题按钮时，它会切换部分的状态，进而切换部分项的可见性。以下是`toggleSection()`函数：
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is a higher-order function that returns a new function as the `onClick`
    handler for the button. The `name` argument is the name of the section state to
    toggle.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个高阶函数，它返回一个新的函数作为按钮的`onClick`处理程序。`name`参数是要切换的部分状态名称。
- en: 'Here''s the new state that was added to support toggling sections:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这是添加以支持切换部分的新状态：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When the screen first loads, the CPU section will be the only section with
    visible items since it''s the only state that''s `true`. Next, let''s look at
    how the `ListItems` are actually collapsed when their corresponding section state
    is `false`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当屏幕首次加载时，CPU部分将是唯一有可见项的部分，因为它是最初状态为`true`的唯一状态。接下来，让我们看看当相应的部分状态为`false`时，`ListItems`是如何实际折叠的：
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `ListItems` component now accepts a `visible` property. This is used by
    the `Collapse` component, which will hide its children using a collapsing animation
    when hiding components. Finally, here''s how the new `ListItems` component is
    used:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListItems`组件现在接受一个`visible`属性。这个属性被`Collapse`组件使用，当隐藏组件时，它将使用折叠动画隐藏其子元素。最后，这是使用新的`ListItems`组件的方法：'
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When the screen first loads, and you click on the SHOW DRAWER button, you should
    see something similar to this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当屏幕首次加载时，并点击SHOW DRAWER按钮，你应该看到类似这样的东西：
- en: '![](img/850d28a3-cfd7-4162-8b22-e46b98fb0e93.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/850d28a3-cfd7-4162-8b22-e46b98fb0e93.png)'
- en: 'There''s way less information for the user to parse now. They can click on
    the section headers to see the list items, and they can click again to collapse
    the section; for example, they could collapse the CPU section and expand the MEMORY
    section:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用户需要解析的信息少多了。他们可以点击部分标题来查看列表项，并且可以再次点击来折叠部分；例如，他们可以折叠CPU部分并展开内存部分：
- en: '![](img/3e66d110-145f-43b1-b1db-33c4d932d747.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3e66d110-145f-43b1-b1db-33c4d932d747.png)'
- en: See also
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '`Drawer` demos: [https://material-ui.com/demos/drawers/](https://material-ui.com/demos/drawers/)'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Drawer` 演示：[https://material-ui.com/demos/drawers/](https://material-ui.com/demos/drawers/)'
- en: '`Drawer` API documentation: [https://material-ui.com/api/drawer/](https://material-ui.com/api/drawer/)'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Drawer` API 文档：[https://material-ui.com/api/drawer/](https://material-ui.com/api/drawer/)'
- en: AppBar interaction
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`AppBar`交互'
- en: A common place to put a button that toggles the visibility of `Drawer` components
    is the `AppBar` component at the top of every page in your app. Furthermore, by
    selecting items in a drawer, the title of the `AppBar` component needs to change
    to reflect this selection. `Drawer` and `AppBar` components often need to interact
    with one another.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用中每个页面的顶部放置一个切换`Drawer`组件可见性的按钮是一个常见的地方。此外，通过在抽屉中选择项目，`AppBar`组件的标题需要改变以反映此选择。`Drawer`和`AppBar`组件通常需要相互交互。
- en: How to do it...
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Let''s say that you have a `Drawer` component with a few items in it. You also
    have an `AppBar` component with a menu button and a title. The menu button should
    toggle the visibility of the drawer, and clicking on a drawer item should update
    the title in the `AppBar`. Here''s the code to do it:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个包含一些项目的`Drawer`组件。你还有一个带有菜单按钮和标题的`AppBar`组件。菜单按钮应该切换抽屉的可见性，点击抽屉中的项目应该更新`AppBar`中的标题。以下是实现这一功能的代码：
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here''s what the screen looks like when it first loads:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这是首次加载时的屏幕截图：
- en: '![](img/787e6390-a40a-415c-ac4a-8949de696a90.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/787e6390-a40a-415c-ac4a-8949de696a90.png)'
- en: 'When you click on the menu icon button to the left of the title, you''ll see
    the drawer:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击标题左侧的菜单图标按钮时，你会看到抽屉：
- en: '![](img/2bd42494-2c19-45ad-8187-67695e0bd04f.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2bd42494-2c19-45ad-8187-67695e0bd04f.png)'
- en: 'If you click on the Page 2 item, the drawer will close and the title of the
    `AppBar` will change:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击页面2的项目，抽屉将关闭，`AppBar`的标题将改变：
- en: '![](img/92a5a840-a69e-4f7e-a3ed-a334cfacc96d.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/92a5a840-a69e-4f7e-a3ed-a334cfacc96d.png)'
- en: How it works...
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'This example defines three components, as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例定义了三个组件，如下所示：
- en: The `MyToolbar` component
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MyToolbar`组件'
- en: The `MyDrawer` component
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MyDrawer`组件'
- en: The main app component
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主应用组件
- en: 'Let''s walk through each of these individually, starting with `MyToolbar`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一分析这些，从`MyToolbar`开始：
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `MyToolbar` component renders an `AppBar` component that accepts a `title`
    property and a `onMenuClick()` property. Both of these properties are used to
    interact with the `MyDrawer` component. The `title` property changes when a drawer
    item selection is made. The `onMenuClick()` function changes state in your main
    app component, causing the drawer to display. Next, let''s take a look at `MyDrawer`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyToolbar`组件渲染一个接受`title`属性和`onMenuClick()`属性的`AppBar`组件。这两个属性都用于与`MyDrawer`组件交互。当抽屉项目被选中时，`title`属性会改变。`onMenuClick()`函数会在你的主应用组件中改变状态，导致抽屉显示。接下来，让我们看看`MyDrawer`：'
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `MyDrawer` component is functional like `MyToolbar`. It accepts properties
    instead of maintaining its own state. For example, the `open` property is how
    the visibility of the drawer is controlled. The `onClose()` and `setTitle()` properties
    are functions that are called when drawer items are clicked on.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyDrawer`组件与`MyToolbar`类似，是函数式的。它接受属性而不是维护自己的状态。例如，`open`属性用于控制抽屉的可见性。`onClose()`和`setTitle()`属性是在点击抽屉项目时被调用的函数。'
- en: 'Finally, let''s look at the app component where all of the state lives:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看包含所有状态的app组件：
- en: '[PRE28]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `title` state is passed to the `MyDrawer` component, along with the `toggleDrawer()`
    function. The `MyDrawer` component is passed the drawer state to control visibility,
    the `toggleDrawer()` function to change visibility, and the `setTitle()` function
    to update the title in `MyToolbar`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`title`状态传递给`MyDrawer`组件，以及`toggleDrawer()`函数。`MyDrawer`组件接收抽屉状态以控制可见性，`toggleDrawer()`函数以改变可见性，以及`setTitle()`函数以更新`MyToolbar`中的标题。'
- en: There's more...
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: What if you want the flexibility of having a persistent drawer that can be toggled
    using the same menu button in the App bar? Let's add a `variant` property to the
    `AppBarInteraction` component that is passed to `MyDrawer`. This can be changed
    from `temporary` to `persistent` and the menu button will still work as expected.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要一个可以通过应用栏中的相同菜单按钮切换的持久抽屉的灵活性怎么办？让我们给传递给`MyDrawer`的`AppBarInteraction`组件添加一个`variant`属性。这可以从`temporary`更改为`persistent`，菜单按钮仍然按预期工作。
- en: 'Here''s what a persistent drawer looks like when you click on the menu button:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当您点击菜单按钮时，这是一个持久抽屉的样子：
- en: '![](img/b71eabc1-a4e7-4d3d-893f-fba1c4ca06c4.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b71eabc1-a4e7-4d3d-893f-fba1c4ca06c4.png)'
- en: The drawer overlaps the App bar. Another problem is that if you click on any
    of the drawer items, the drawer is closed, which isn't ideal for a persistent
    drawer. Let's fix both of these issues.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 抽屉覆盖了应用栏。另一个问题是，如果您点击任何抽屉项目，抽屉将关闭，这对持久抽屉来说并不理想。让我们修复这两个问题。
- en: 'First, let''s address the `z-index` issue that''s causing the drawer to appear
    on top of the App bar. You can create a CSS class that looks like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们解决导致抽屉出现在应用栏上面的`z-index`问题。您可以创建一个看起来像这样的CSS类：
- en: '[PRE29]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can apply this class to the `AppBar` component in `MyToolbar`, as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将此类应用于`MyToolbar`中的`AppBar`组件，如下所示：
- en: '[PRE30]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now when you open the drawer, it appears underneath the `AppBar`, as expected:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当您打开抽屉时，它出现在`AppBar`下面，正如预期的那样：
- en: '![](img/ee5575fd-6c33-4051-a601-da8c0650534b.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ee5575fd-6c33-4051-a601-da8c0650534b.png)'
- en: 'Now you just have to fix the margin. When the drawer uses the `persistent`
    variant, you can add the `toolbarMargin` class to a `<div>` element as the first
    element in the `Drawer` component:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您只需调整边距。当抽屉使用`persistent`变体时，您可以将`toolbarMargin`类添加到`<div>`元素中，作为`Drawer`组件中的第一个元素：
- en: '[PRE31]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'With the help of the `clsx()` function, the `toolbarMargin` class is only added
    when needed – that is, when the drawer is persistent. Here''s what it looks like
    now:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在`clsx()`函数的帮助下，`toolbarMargin`类仅在需要时添加——也就是说，当抽屉处于持久状态时。现在它看起来是这样的：
- en: '![](img/25865580-0027-47d7-865e-431ec73cd544.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/25865580-0027-47d7-865e-431ec73cd544.png)'
- en: 'Lastly, let''s fix the issue where the drawer closes when a drawer item is
    clicked on. In the main app component, you can add a new method that looks like
    the following code block:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们修复当点击抽屉项目时抽屉关闭的问题。在主应用组件中，您可以添加一个看起来像以下代码块的新方法：
- en: '[PRE32]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `onItemClick()` function takes care of setting the text in the App bar,
    as well as closing the drawer if it''s temporary. To use this new function, you
    can replace the `setTitle` property in `MyDrawer` with an `onItemClick` property.
    You can then use it in your list items, as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`onItemClick()`函数负责设置应用栏中的文本，如果抽屉是临时的，它还会关闭抽屉。要使用这个新函数，您可以将`MyDrawer`中的`setTitle`属性替换为`onItemClick`属性。然后您可以在列表项中使用它，如下所示：'
- en: '[PRE33]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now when you click on items in the drawer when it's persistent, the drawer will
    stay open. The only way to close it is by clicking on the menu button beside the
    title in the App bar.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当您在持久状态下的抽屉中点击项目时，抽屉将保持打开。唯一关闭它的方法是在应用栏标题旁边的菜单按钮上点击。
- en: See also
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '`Drawer` demos: [https://material-ui.com/demos/drawers/](https://material-ui.com/demos/drawers/)'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Drawer`演示：[https://material-ui.com/demos/drawers/](https://material-ui.com/demos/drawers/)'
- en: '`AppBar` demos: [https://material-ui.com/demos/app-bar/](https://material-ui.com/demos/app-bar/)'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AppBar`演示：[https://material-ui.com/demos/app-bar/](https://material-ui.com/demos/app-bar/)'
- en: '`Drawer` API documentation: [https://material-ui.com/api/drawer/](https://material-ui.com/api/drawer/)'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Drawer` API文档：[https://material-ui.com/api/drawer/](https://material-ui.com/api/drawer/)'
- en: '`AppBar` API documentation: [https://material-ui.com/api/app-bar/](https://material-ui.com/api/app-bar/)'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AppBar` API文档：[https://material-ui.com/api/app-bar/](https://material-ui.com/api/app-bar/)'
