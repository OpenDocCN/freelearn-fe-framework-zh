- en: Chapter 11. Putting Things to the Test
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。对事物进行测试
- en: Writing tests is crucial for the maintainability of your code. It's a known
    fact that having a good range of tests that cover most of your functionality is
    equally important as the functionality itself.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试对于代码的可维护性至关重要。众所周知，拥有一个覆盖大多数功能的好测试范围与功能本身同样重要。
- en: 'The first thing that comes to mind when thinking about tests is probably code
    quality assurance. You test the code that you write, so this is definitely true.
    However, there are many other important aspects of writing tests:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当想到测试时，首先想到的可能就是代码质量保证。你测试你写的代码，这无疑是正确的。然而，编写测试还有很多其他重要的方面：
- en: '**Resistance to unexpected change**: Your tests define what your code is supposed
    to do. They test whether your code conforms to your specifications. This has several
    benefits, where the most obvious is probably a resistance to unexpected change
    in the future. If you modify the code in the future, you''ll less likely break
    your existing code because your tests will validate whether the existing functionality
    still works as specified.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抵抗意外变化**：你的测试定义了你的代码应该做什么。它们测试你的代码是否符合你的规范。这有几个好处，其中最明显的好处可能是对未来意外变化的抵抗。如果你将来修改代码，你不太可能破坏现有的代码，因为你的测试将验证现有功能是否仍然按指定的方式工作。 '
- en: '**Documentation**: Your tests define what your code should do. At the same
    time, they display the API calls that are required to use the concerned functionality.
    This is the perfect documentation for any developer. Whenever I want to understand
    how a library really works, the tests are the first thing that I look at.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档**：你的测试定义了你的代码应该做什么。同时，它们显示了使用相关功能所需的API调用。这是任何开发者的完美文档。每当我想要了解一个库是如何真正工作的，我首先看的就是测试。'
- en: '**Avoiding unnecessary code**: The practice of writing tests forces you to
    limit your code to fulfil the requirements of your specification and nothing more.
    Any code in your application that is not reached in your automated tests can be
    considered dead code. If you stick to a merciless refactoring approach, you''d
    then remove such unused code ASAP.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免不必要的代码**：编写测试迫使你将代码限制在满足你的规范要求，而不再需要更多。你应用程序中任何在自动化测试中未触及的代码都可以被认为是死代码。如果你坚持无情地重构方法，那么你将尽快移除这些未使用的代码。'
- en: So far, we haven't considered testing in our book at all, and given its importance,
    you may wonder why I come up with this now in the last chapter. In a real project,
    we'd definitely create tests much earlier if not at first. However, I hope you
    understand that in this book, we postponed this rather important topic until the
    end. I really love testing, but as we're mainly focused on the component architecture
    of Angular, placing this chapter at the end seemed more logical.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们完全没有在我们的书中考虑测试，鉴于其重要性，你可能想知道为什么我在最后一章才提出这个观点。在实际项目中，如果我们不是一开始就创建测试，我们肯定会更早地创建测试。然而，我希望你理解，在这本书中，我们将这个相当重要的主题推迟到了最后。我真的很喜欢测试，但因为我们主要关注Angular的组件架构，所以将这一章放在最后似乎更合理。
- en: In this chapter, we'll look into how to perform proper unit testing on your
    components. We'll focus on unit testing; automated end-to-end testing is beyond
    the scope of this book. Still, we'll look into how to test user interaction on
    components, although not on the level it would be done in end-to-end testing.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何对你的组件进行适当的单元测试。我们将专注于单元测试；自动化端到端测试超出了本书的范围。尽管如此，我们还将探讨如何测试组件上的用户交互，尽管不是在端到端测试的水平上。
- en: 'In this chapter, we will delve into the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨以下主题：
- en: An introduction to the Jasmine testing framework
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jasmine测试框架的介绍
- en: Writing simple JavaScript tests for components
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为组件编写简单的JavaScript测试
- en: Creating a `tests.html` file, which serves as an in-browser test runner
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`tests.html`文件，它作为浏览器中的测试运行器
- en: Creating Jasmine spies and observing component output properties
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Jasmine间谍和观察组件输出属性
- en: Learning about Angular testing utilities, such as `inject`, `async`, `TestComponentBuilder`,
    `DebugElement`, and more
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Angular测试工具，例如`inject`、`async`、`TestComponentBuilder`、`DebugElement`等
- en: Mocking components
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟组件
- en: Mocking existing services
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟现有服务
- en: Creating tests for our `AutoComplete` UI component
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的`AutoComplete` UI组件创建测试
- en: Creating tests for our plugin system
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的插件系统创建测试
- en: An introduction to Jasmine
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jasmine的介绍
- en: Jasmine is a very simple testing framework, which comes with an API that allows
    you to write **Behavior-driven Development** (**BDD**) style tests. BDD is an
    agile software development process of defining specifications in a written format.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine 是一个非常简单的测试框架，它提供了一个 API，允许你编写 **行为驱动开发**（**BDD**）风格的测试。BDD 是一种敏捷软件开发过程，它以书面格式定义规范。
- en: 'In BDD, we define that an agile user story consists of multiple scenarios.
    These scenarios closely relate to or even replace the acceptance criteria of a
    story. They define requirements on a higher level, and they are mostly written
    narrative. Each scenario then consists of three parts:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在 BDD 中，我们定义敏捷用户故事由多个场景组成。这些场景与故事的可接受标准密切相关，甚至可以替代它们。它们在更高层次上定义需求，并且主要是叙事性的。每个场景然后由三个部分组成：
- en: '**Given**: This part is used to describe the initial state of the scenario.
    The test code is where we perform all the setup that is needed to execute the
    test scenario.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Given**: 这部分用于描述场景的初始状态。测试代码是我们执行测试场景所需的所有设置的执行部分。'
- en: '**When**: This part reflects the changes that we perform to the system under
    test. Usually, this part consists of some API calls and actions that reflect the
    behavior of a user of the system.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**When**: 这部分反映了我们对测试系统所做的更改。通常，这部分包括一些 API 调用和反映系统用户行为的操作。'
- en: '**Then**: This part specifies what the system should look like after the given
    state and the changes applied in the *when* part. In our code, this is the part
    that is usually at the end of our tests function, where we use assertion libraries
    to verify the state of the system.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Then**: 这部分指定在给定状态和 `when` 部分应用更改后系统应该看起来像什么。在我们的代码中，这部分通常是测试函数的末尾，我们使用断言库来验证系统的状态。'
- en: 'Jasmine comes with an API that makes it very easy to write tests which structure
    according to the BDD style. Let''s look at a very simple example of how we use
    Jasmine to write a test for a shopping cart system:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jasmine 提供了一个 API，使得编写按照 BDD 风格结构的测试变得非常简单。让我们看看如何使用 Jasmine 为购物车系统编写一个测试的非常简单的例子：
- en: '[PRE0]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Jasmine provides us with a `describe` function, which allows us to group certain
    scenarios on the same subject. In this example, we used the `describe` function
    to register a new test suite for tests about buying items in a shop.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine 提供了一个 `describe` 函数，允许我们将某些场景分组在同一个主题上。在这个例子中，我们使用了 `describe` 函数来为关于商店购买物品的测试注册一个新的测试套件。
- en: Using the `it` function, we can register individual scenarios, which we'd like
    to get tested. In the `describe` callback function, we can register as many scenarios
    using the `it` function as we like.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `it` 函数，我们可以注册我们想要测试的个别场景。在 `describe` 回调函数中，我们可以使用 `it` 函数注册尽可能多的场景。
- en: Inside the callback function of the Jasmine `it` function, we can start writing
    our test. We use a `BDD` style to structure the code inside our test.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Jasmine `it` 函数的回调函数内部，我们可以开始编写我们的测试。我们在测试内部使用 `BDD` 风格来组织代码。
- en: 'You don''t necessarily need to run Jasmine in the browser, but if you do this,
    you''ll get a nice summary report of all tests and their state:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你不一定需要在浏览器中运行 Jasmine，但如果你这样做，你将获得所有测试及其状态的简洁总结报告：
- en: '![An introduction to Jasmine](img/image00355.jpeg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![Jasmine 简介](img/image00355.jpeg)'
- en: Jasmine provides a nice visual report over all your test specifications, which
    also allows you to rerun individual tests and provides you with more options
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine 提供了所有测试规范的漂亮视觉报告，还允许你重跑单个测试，并提供更多选项
- en: 'Jasmine comes in three parts that are relevant to us:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine 有三个与我们相关的部分：
- en: '**Jasmine core**: This contains the test definition APIs, the assertion library,
    and all the other core parts of the testing framework'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jasmine 核心**: 这部分包含测试定义 API、断言库以及测试框架的所有其他核心部分'
- en: '**Jasmine HTML**: This is the HTML reporter, which will write all tests results
    to the browser document and even provide options to rerun individual tests'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jasmine HTML**: 这是指定将所有测试结果写入浏览器文档的 HTML 报告器，并提供重跑单个测试的选项'
- en: '**Jasmine boot**: This is the file that bootstraps the Jasmine framework for
    the browser and performs any setup that is needed with the HTML reporter'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jasmine 引擎**: 这是一个用于浏览器中启动 Jasmine 框架并执行与 HTML 报告器相关的任何设置的文件'
- en: In our project, we will use Jasmine and the preceding parts directly from a
    CDN, so we don't need to install anything to get started. We create a new `tests.html`
    file, which will serve as a runner for our tests. In conjunction with `live-server`,
    we can always have this page open in our browser. This way we'll get immediate
    feedback on our tests while developing.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目中，我们将直接从 CDN 使用 Jasmine 和前面的部分，因此我们不需要安装任何东西就可以开始。我们创建一个新的 `tests.html`
    文件，它将作为我们的测试运行器。结合 `live-server`，我们总可以在浏览器中打开这个页面。这样我们就可以在开发过程中立即获得测试的反馈。
- en: Tip
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Jasmine also plays nice with test runners such as Karma to run your tests. Karma
    is a popular test runner, which allows you to run your tests in parallel using
    the Karma CLI or integrate it in your build pipeline. This also allows you to
    run tests in different browsers. In this chapter, we will use the Jasmine HTML
    and Jasmine boot to run our tests directly in the browser. This allows us to skip
    the rather complex setup that we'd need to undertake if we used Karma as our test
    runner.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine 还与测试运行器（如 Karma）很好地配合使用，以运行您的测试。Karma 是一个流行的测试运行器，它允许您使用 Karma CLI 并行运行测试，或者将其集成到您的构建管道中。这也允许您在不同的浏览器中运行测试。在本章中，我们将使用
    Jasmine HTML 和 Jasmine 启动直接在浏览器中运行我们的测试。这样，我们可以跳过如果使用 Karma 作为测试运行器时需要进行的相当复杂的设置。
- en: 'Let''s look at the code of the `tests.html` file that we create in the root
    folder of our application, right next to the `index.html` file, which is already
    present:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们在应用程序根目录中创建的 `tests.html` 文件的代码，它紧挨着已经存在的 `index.html` 文件：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Besides loading the usual suspects for our Angular application (ES6 shim, Angular
    polyfills, and SystemJS), we now also load the three main components of Jasmine.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 除了加载我们 Angular 应用程序的常规组件（ES6 shim、Angular polyfills 和 SystemJS）之外，我们现在还加载了 Jasmine
    的三个主要组件。
- en: 'By default, Jasmine executes all registered tests on the window''s `load` event.
    However, as we will load our tests using SystemJS, we need to defer the bootstrap
    of Jasmine until SystemJS has completely loaded our tests:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Jasmine 在窗口的 `load` 事件上执行所有注册的测试。然而，由于我们将使用 SystemJS 加载我们的测试，我们需要将 Jasmine
    的启动推迟到 SystemJS 完全加载我们的测试：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We first put aside the function that was registered by Jasmine boot on `window.onload`.
    We store the function in a temporary `_jasmineOnLoad` global variable.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将 Jasmine 启动在 `window.onload` 上注册的函数放在一边。我们将该函数存储在一个临时 `_jasmineOnLoad`
    全局变量中。
- en: Now, we use SystemJS to import our entry point module for our tests, which will
    be stored in the `all.spec.js` file. SystemJS returns a `Promise` that will be
    resolved if the test module has been loaded and executed successfully. We can
    use the `then` function of the returned `Promise` to execute the Jasmine boot
    function stored in `window._jasmineOnLoad`. In this way, we make sure that Jasmine
    is booted after all our tests have been registered.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们使用 SystemJS 导入我们的测试入口模块，它将被存储在 `all.spec.js` 文件中。SystemJS 返回一个 `Promise`，如果测试模块已成功加载和执行，则该
    `Promise` 将被解决。我们可以使用返回的 `Promise` 的 `then` 函数来执行存储在 `window._jasmineOnLoad` 中的
    Jasmine 启动函数。这样，我们确保在所有测试注册后启动 Jasmine。
- en: Writing our first test
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写我们的第一个测试
- en: Now that we are all set with the Jasmine setup, we can start writing our first
    test. In this section, we will create a first test for the `AutoComplete` component
    that we created in [Chapter 8](part0054.xhtml#aid-1JFUC2 "Chapter 8. Time Will
    Tell"), *Time Will Tell*, of this book.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了 Jasmine 的设置，我们可以开始编写我们的第一个测试了。在本节中，我们将为本书第 8 章 [Time Will Tell](part0054.xhtml#aid-1JFUC2
    "第 8 章. 时间会告诉我们") 中创建的 `AutoComplete` 组件编写一个测试。这个组件是在 [第 8 章](part0054.xhtml#aid-1JFUC2
    "第 8 章. 时间会告诉我们") 中创建的。
- en: As Angular components are just classes, we can already test a lot of the functionality
    by instantiating the `Component` class and testing its methods. Tests that can
    be performed like this should always be considered first. These tests can run
    without Angular bootstrapping the component.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Angular 组件只是类，我们可以通过实例化 `Component` 类并测试其方法来测试很多功能。应该首先考虑可以以这种方式执行的测试。这些测试可以在不启动
    Angular 组件的情况下运行。
- en: The `AutoComplete` component filters displayed results based on the available
    items and a filter criteria. In the following test, we'll verify that the `filter`
    method on the component works as expected.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`AutoComplete` 组件根据可用的项和筛选标准筛选显示的结果。在下面的测试中，我们将验证组件上的 `filter` 方法是否按预期工作。'
- en: Tip
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In this book, we follow the practice to store test files by appending a `.spec.js`
    file to the name of the file that has to be tested. We'll also store these test
    files in the same folder of the subject. This makes it much easier to keep the
    context.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们遵循将测试文件存储为需要测试的文件名后追加`.spec.js`文件的做法。我们还将这些测试文件存储在主题的同一文件夹中。这使得保持上下文变得更加容易。
- en: 'We''ll create a new `auto-complete.spec.js` file in the folder of the `AutoComplete`
    component at `lib/ui/auto-complete`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`AutoComplete`组件的文件夹`lib/ui/auto-complete`中创建一个新的`auto-complete.spec.js`文件：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As we loaded Jasmine prior to executing our test, we could rely on the global
    `describe`, `it`, and `expect` functions that are exposed by Jasmine. However,
    Angular provides us with some nice wrappers of the Jasmine functions, which we
    can import from the module located in `@angular/core/testing`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在执行测试之前加载了Jasmine，我们可以依赖Jasmine暴露的全球`describe`、`it`和`expect`函数。然而，Angular为我们提供了一些很好的Jasmine函数包装器，我们可以从位于`@angular/core/testing`模块中导入这些包装器。
- en: As you can see, we don't really need to activate the `AutoComplete` component
    in order to test some of its functionality. By simply testing the component class,
    we can already execute some of our executable specifications.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们实际上不需要激活`AutoComplete`组件来测试其一些功能。通过简单地测试组件类，我们就可以执行一些可执行规范。
- en: We follow a BDD approach to structure our test, and in the `Given` section,
    we instantiate a new `AutoComplete` component class, and then we initialize the
    items list with some test items. Even if the items field is actually a component
    input, we can simply disregard this fact in order to test the filtering functionality.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遵循BDD方法来构建我们的测试，在`Given`部分，我们实例化一个新的`AutoComplete`组件类，然后使用一些测试项目初始化项目列表。即使项目字段实际上是一个组件输入，我们也可以简单地忽略这个事实来测试过滤功能。
- en: In the `When` section of our test, we actually call the `filterItems` method
    of the component class and test whether it does filter the items according to
    the specification.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试的`When`部分，我们实际上调用组件类的`filterItems`方法，并测试它是否根据规范过滤项目。
- en: In the `Then` section, we use the `expect` function of Jasmine in order to assert
    the expected state after the `When` section. As the component should filter all
    items with partial and case-insensitive matches of the filter criteria, the expected
    value in `filteredItems` should be an array with the `One` and `two` items.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Then`部分，我们使用Jasmine的`expect`函数来断言`When`部分之后的预期状态。由于组件应该过滤所有与过滤标准部分匹配和大小写不敏感的项目，`filteredItems`中的预期值应该是一个包含`One`和`two`项目的数组。
- en: We use the assertion `toEqual` function in order to perform a deep equal check.
    If we use the `toBe` matcher, we'd compare the references of the two arrays, which
    will result in a negative match.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`toEqual`断言函数来执行深度相等检查。如果我们使用`toBe`匹配器，我们将比较两个数组的引用，这将导致负匹配。
- en: This is it for our first test. What's left to do still is to create our main
    test module that is loaded in the `tests.html` file.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的第一次测试。接下来要做的事情就是创建我们的主要测试模块，该模块将在`tests.html`文件中加载。
- en: 'We created the main entry point for all our tests in a `all.spec.js` file on
    the root path of our application. This file will then include all specification
    files that we create in our application:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在应用程序根目录下的`all.spec.js`文件中创建了所有测试的主要入口点。该文件将包括我们在应用程序中创建的所有规范文件：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is currently all that we need to make our test run. We simply import the
    test file that we just created. Now, `tests.html` will use SystemJS to load our
    `all.spec.js` file, and here, we then load the `auto-complete-spec.js` file.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只需要做这些来使我们的测试运行。我们只需导入我们刚刚创建的测试文件。现在，`tests.html`将使用SystemJS加载我们的`all.spec.js`文件，然后在这里，我们加载`auto-complete-spec.js`文件。
- en: We can now start `live-server` in the root path of our application and navigate
    to `http://127.0` `.0.1:8080/tests.html` in our browser. As `live-server` will
    reload our browser on changes, we can start adding new tests while we constantly
    get updates on our test state in the browser.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在应用程序的根目录下启动`live-server`，并在浏览器中导航到`http://127.0.1:8080/tests.html`。由于`live-server`会在变化时重新加载我们的浏览器，因此我们可以在浏览器中不断获取测试状态更新的同时开始添加新的测试。
- en: Spying on component outputs
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 间谍组件输出
- en: A common practice in testing is to use spy function calls during the execution
    of tests and then evaluate these calls, checking whether all functions have been
    called correctly.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 测试中的一个常见做法是在测试执行期间使用间谍函数调用，然后评估这些调用，检查是否所有函数都正确地被调用。
- en: Jasmine provides us with some nice helpers in order to use spy function calls.
    We can use the `spyOn` function of Jasmine in order to replace the original function
    with a spy function. The spy function will record any calls, and we can later
    on evaluate how many times it was called and with what parameters.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine为我们提供了一些很好的辅助工具来使用间谍函数调用。我们可以使用Jasmine的`spyOn`函数来用间谍函数替换原始函数。间谍函数将记录任何调用，我们可以在之后评估它被调用了多少次以及使用了什么参数。
- en: 'Let''s look at a simple example of how to use the `spyOn` function:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`spyOn`函数的一个简单例子：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We will test a simple `Calculator` class that has two methods. The `multiply`
    method simply multiplies two numbers and returns the result. The `pythagorean`
    method calculates the hypotenuse of a right-angled triangle with two sides, `a`
    and `b`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将测试一个简单的`Calculator`类，它有两个方法。`multiply`方法简单地乘以两个数字并返回结果。`pythagorean`方法计算直角三角形的斜边，该三角形有两个边长`a`和`b`。
- en: 'You might remember the formula for the Pythagorean theorem from your early
    school days:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得从你早期的学校生活中学到的毕达哥拉斯定理的公式：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We will use this formula to produce `c` from `a` and `b` by getting the square
    root of the result of `a*a + b*b`. For the multiplications, we'll use our `multiply`
    method instead of using arithmetic operators directly.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个公式通过获取`a*a + b*b`的结果的平方根来从`a`和`b`生成`c`。对于乘法，我们将使用我们的`multiply`方法而不是直接使用算术运算符。
- en: 'Now, we''d want to test our calculator `pythagorean` method, and as it uses
    the `multiply` method to multiply `a` and `b`, we can spy on this method to verify
    our test result in depth:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要测试我们的计算器`pythagorean`方法，因为它使用`multiply`方法来乘以`a`和`b`，我们可以监视这个方法以深入验证我们的测试结果：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `spyOn` function of Jasmine takes an object as first parameter and the function
    name on the object which we'd like to spy on.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine的`spyOn`函数接受一个对象作为第一个参数，以及我们想要监视的对象上的函数名。
- en: This will effectively replace the original `multiply` function on our class
    instance with a new spy function of Jasmine. By default, spy functions will only
    record function calls, and they won't delegate the call further to the original
    function. We can use the `.and.callThrough()` function to specify that we'd like
    Jasmine to call the original function. This way our spy function will act as a
    proxy and record any calls at the same time.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这将有效地用Jasmine的间谍函数替换我们类实例上的原始`multiply`函数。默认情况下，间谍函数只会记录函数调用，并且不会将调用进一步委托给原始函数。我们可以使用`.and.callThrough()`函数来指定我们希望Jasmine调用原始函数。这样，我们的间谍函数将充当代理并记录任何调用。
- en: In the `Then` section of our test, we can then inspect the spy function. Using
    the `toHaveBeenCalled` matcher, we can check whether the spy function was called
    after all.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们测试的`Then`部分，我们可以检查间谍函数。使用`toHaveBeenCalled`匹配器，我们可以检查间谍函数是否被调用过。
- en: Using the `calls` property of the spy function, we can inspect in more detail
    and verify the call count as well as the arguments that individual calls received.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用间谍函数的`calls`属性，我们可以更详细地检查并验证调用次数以及各个调用接收到的参数。
- en: Using the knowledge that we gained about Jasmine spies, we can now apply that
    to our component tests. As we know that all output properties of components contain
    an `EventEmitter`, we can actually spy on them to check whether our component
    sends output.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 利用我们关于Jasmine间谍的知识，我们现在可以将这些应用到我们的组件测试中。正如我们所知，所有组件的输出属性都包含一个`EventEmitter`，我们实际上可以监视它们以检查我们的组件是否发送输出。
- en: Inside components, we call the `next` method on `EventEmitter` in order to send
    output to parent component bindings. As this is an asynchronous operation and
    we'd also like to test our components without needing to involve parent components,
    we can simply spy on the `next` method of our output properties.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件内部，我们调用`EventEmitter`上的`next`方法以将输出发送到父组件绑定。由于这是一个异步操作，我们还想在不涉及父组件的情况下测试我们的组件，因此我们可以简单地监视输出属性的`next`方法。
- en: 'In the next two tests for our `AutoComplete` component, we''d like to verify
    the functionality when we save an edit in the `Editor` child component. Let''s
    quickly recap on this behavior:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们`AutoComplete`组件的下一个两个测试中，我们想验证在`Editor`子组件中保存编辑时的功能。让我们快速回顾一下这个行为：
- en: On saved edits, we get the `onEditSaved` method on the `AutoComplete` component
    that is called
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在保存编辑后，我们在`AutoComplete`组件上获得`onEditSaved`方法，该方法被调用。
- en: If the saved value is an empty string, the `AutoComplete` component should emit
    a `selectedItemChange` event with a `null` value
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果保存的值是一个空字符串，`AutoComplete`组件应该发出一个带有`null`值的`selectedItemChange`事件。
- en: If the saved value is no empty string and the value is not present in the items
    of the `AutoComplete` component, an `itemCreated` event should be emitted
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果保存的值不是空字符串，并且该值不在`AutoComplete`组件的项中，则应该发出一个`itemCreated`事件
- en: 'Let''s create the tests for the previous expected behavior to the already existing
    `lib/ui/auto-complete/auto-complete.spec.js` test file:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为之前预期的行为创建测试，并将其添加到已存在的`lib/ui/auto-complete/auto-complete.spec.js`测试文件中：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We create two Jasmine spies here. The first one spies on the `selectedItemChange`
    output property, while the second one spies on the `itemCreated` output property.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里创建了两个Jasmine间谍。第一个间谍监视`selectedItemChange`输出属性，而第二个间谍监视`itemCreated`输出属性。
- en: After simulation, the editor was saved with an empty string. We can start verifying
    our spies in the `Then` section of our test.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟后，编辑器以空字符串保存。我们可以在测试的`Then`部分开始验证我们的间谍。
- en: The `next` function of the `selectedItemChange` event, `EventEmitter`, should
    have been called with a `null` value, while `next` of `itemCreated` shouldn't
    have been called at all. We can use the `not` property on the returned expectation
    object to invert the matcher.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`selectedItemChange`事件的`next`函数，即`EventEmitter`，应该被一个`null`值调用，而`itemCreated`的`next`函数则根本不应该被调用。我们可以使用返回的期望对象上的`not`属性来反转匹配器。'
- en: 'Let''s add a second test for the behavior when an editor was saved with a value
    that does not yet exist in the `AutoComplete` component:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加第二个测试，以测试当编辑器保存的值在`AutoComplete`组件中尚不存在时的行为：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This time, we simulate a saved edit with a value, which isn't an empty string
    and does not exist in the autocomplete items already.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们模拟了一个带有值的已保存编辑，这个值不是空字符串，并且不在自动完成项中存在。
- en: In the `Then` section of our code, we evaluate the spies and expect that the
    `itemCreated.next` function was called with a `four` string.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码的`Then`部分，我们评估间谍并期望`itemCreated.next`函数被一个`four`字符串调用。
- en: Using Jasmine spies, we managed to test our component output successfully without
    the need to bootstrap Angular. We performed these tests solely on the component
    class and by creating spies on the `EventEmitter` that is present on all output
    properties.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Jasmine间谍，我们成功测试了我们的组件输出，而不需要引导Angular。我们仅在组件类上执行了这些测试，并在所有输出属性上创建了`EventEmitter`的间谍。
- en: Utilities to test components
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件测试的实用工具
- en: So far, we tested our components with plain vanilla JavaScript. The fact that
    components are in just regular classes make this possible. However, this can only
    be done for very simple use-cases. As soon as we'd like to test components for
    things that involve template compilation, user interaction on components, change
    detection, or dependency injection, we'll need to get a little help from Angular
    to perform our tests.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用纯JavaScript测试了我们的组件。组件只是常规类的事实使得这一点成为可能。然而，这只能用于非常简单的用例。一旦我们想要测试涉及模板编译、组件上的用户交互、变更检测或依赖注入的组件，我们就需要从Angular那里得到一点帮助来执行我们的测试。
- en: Angular comes with a whole bunch of testing tools that help us out here. In
    fact, the platform-agnostic way that Angular is built allows us to exchange the
    regular view adapter with a debug view adapter. This enables us to render components
    in such a way that allows us to inspect them in great detail.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Angular附带了一系列测试工具，帮助我们完成这项工作。事实上，Angular构建的平台无关性允许我们用调试视图适配器替换常规视图适配器。这使得我们能够以允许我们详细检查组件的方式渲染组件。
- en: To enable the debugging capabilities of Angular while rendering components,
    we need to modify our main entry point for our tests first.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要在渲染组件时启用Angular的调试功能，我们首先需要修改我们的测试主入口点。
- en: 'Let''s open up `all.spec.js` to make the necessary modifications:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开`all.spec.js`以进行必要的修改：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Using the `setBaseTestProviders` function of the `@angular/core/testing` module,
    we can actually initialize a test platform injector, which will then be used in
    the context of our Angular testing. This function takes two arguments where the
    first one is an array of platform providers, and the second one is an array of
    application providers.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@angular/core/testing`模块的`setBaseTestProviders`函数，我们可以实际初始化一个测试平台注入器，该注入器将在Angular测试的上下文中使用。这个函数接受两个参数，第一个是一个平台提供者数组，第二个是一个应用提供者数组。
- en: 'From the `@angular/platform-browser-dynamic/testing` module, we can import
    two constants that contain an already prepared list for both platform and application-level
    dependencies. Here are some of the providers present in these constants:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `@angular/platform-browser-dynamic/testing` 模块，我们可以导入两个常量，它们包含平台和应用级依赖项的已准备列表。以下是这些常量中的一些提供者：
- en: '**Platform-level providers**: These consist mostly of platform initialization
    providers to debug'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平台级提供者**：这些主要是由平台初始化提供者组成，用于调试'
- en: '**Application-level providers**: These consist of the following:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用级提供者**：这些包括以下内容：'
- en: '`DebugDomRootRenderer`: This overrides the default `DomRenderer` in the browser
    and enables debugging of elements using `DebugElement` and probing'
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DebugDomRootRenderer`: 这覆盖了浏览器中的默认 `DomRenderer` 并使使用 `DebugElement` 和探测进行元素调试成为可能'
- en: '`MockDirectiveResolver`: This overrides the default `DirectiveResolver` and
    allows overriding of directive metadata for testing purposes'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MockDirectiveResolver`: 这覆盖了默认的 `DirectiveResolver` 并允许在测试目的下覆盖指令元数据'
- en: '`MockViewResolver`: This overrides the default `ViewResolver` and allows overriding
    of component view specific metadata'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MockViewResolver`: 这覆盖了默认的 `ViewResolver` 并允许覆盖组件视图特定的元数据'
- en: Using the `setBaseTestProviders` function and the imported constants with the
    debugging providers, we can now initialize our test environment. After calling
    this function and passing our providers, Angular is set up for testing.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `setBaseTestProviders` 函数和导入的调试提供者常量，我们现在可以初始化我们的测试环境。在调用此函数并传递我们的提供者之后，Angular
    已设置好以进行测试。
- en: Injecting in tests
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试中的注入
- en: Injecting Angular dependencies in tests is made easy by two helper functions
    that we can use. The `inject` and `async` functions are available through the
    `@angular/core/testing` package, and they help us inject dependencies in our tests.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过两个辅助函数简化了在测试中注入 Angular 依赖项。`inject` 和 `async` 函数通过 `@angular/core/testing`
    包提供，并帮助我们在我们的测试中注入依赖项。
- en: 'Let''s look at this simple example where we inject the document element using
    the `inject` wrapper function. This test is irrelevant for our application, but
    it illustrates how we can now make use of injection in our tests:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个简单的例子，其中我们使用 `inject` 包装器函数注入文档元素。这个测试对我们应用程序来说并不相关，但它说明了我们现在如何在测试中利用注入：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can simply use `inject` to wrap our test function. The `inject` function
    accepts an array as the first parameter that should include a list of injectables.
    The second parameter is our actual test function, which will now receive the injected
    document.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以简单地使用 `inject` 来包装我们的测试函数。`inject` 函数接受一个数组作为第一个参数，该数组应包含一个可注入项列表。第二个参数是我们实际的测试函数，现在它将接收注入的文档。
- en: 'The `async` function on the other hand helps us with a different concern too.
    What if our tests actually involve asynchronous operations? Well, a standard asynchronous
    Jasmine test would look like the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`async` 函数也帮助我们解决另一个问题。如果我们的测试实际上涉及异步操作怎么办？嗯，一个标准的异步 Jasmine 测试看起来如下所示：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Jasmine provides us with a nice way to specify asynchronous tests. We can simply
    use the first parameter of our test functions, which resolves to a callback function.
    By calling this callback function, in our case we named it `done`, we tell Jasmine
    that our asynchronous operations are done, and we would like to finish the test.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine 提供了一种很好的方式来指定异步测试。我们可以简单地使用测试函数的第一个参数，它解析为一个回调函数。通过调用这个回调函数，在我们的例子中我们称之为
    `done`，我们告诉 Jasmine 我们的异步操作已完成，我们希望完成测试。
- en: Using callbacks to indicate whether our asynchronous test is finished is a valid
    option. However, this can make our test quite complicated if many asynchronous
    operations are involved. It's sometimes even impossible to monitor all the asynchronous
    operations that are happening under the hood, which also makes it impossible for
    us to determine the end of our test.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用回调来指示我们的异步测试是否完成是一个有效选项。然而，如果涉及许多异步操作，这可能会使我们的测试相当复杂。有时甚至无法监控底层的所有异步操作，这也使得我们无法确定测试的结束。
- en: This is where the `async` helper function comes into play. Angular uses a library
    called Zone.js to monitor any asynchronous operation in the browser. Simply put,
    Zone.js hooks into any asynchronous operation and monitors where they are initiated
    as well as when they are finished. With this information, Angular knows exactly
    how many pending asynchronous operations there are.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`async`辅助函数发挥作用的地方。Angular使用一个名为Zone.js的库来监控浏览器中的任何异步操作。简单来说，Zone.js挂钩到任何异步操作并监控它们的启动位置以及何时完成。有了这些信息，Angular可以确切地知道有多少挂起的异步操作。
- en: If we're using the `async` helper, we tell Angular to automatically finish our
    test when all asynchronous operations in our test are done. The helper uses Zone.js
    to create a new zone and determine whether all the microtasks executed within
    this zone are finished.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`async`辅助函数，我们告诉Angular在测试中的所有异步操作完成后自动完成我们的测试。辅助函数使用Zone.js创建一个新的区域并确定该区域内执行的所有微任务是否已完成。
- en: 'Let''s look at how we can combine injection with an asynchronous operation
    in our test:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何在测试中将注入与异步操作结合：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: By combining `inject` with `async` (wrapping), we now have an asynchronous operation
    in our test. The `async` helper will make our test wait until all asynchronous
    operations are completed. We don't need to rely on a callback, and we have the
    guarantee that even internal asynchronous operations will complete before our
    test finishes.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`inject`与`async`（包装）结合，我们现在在我们的测试中有一个异步操作。`async`辅助函数将使我们的测试等待直到所有异步操作都完成。我们不需要依赖于回调，并且我们有保证，即使内部异步操作也会在我们的测试完成之前完成。
- en: Tip
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Zone.js is designed to work with all asynchronous operations in the browser.
    It patches all core DOM APIs and makes sure that every operation goes through
    a zone. Angular also relies on Zone.js in order to initiate change detection.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Zone.js旨在与浏览器中的所有异步操作一起工作。它修补了所有核心DOM API并确保每个操作都通过一个区域。Angular也依赖于Zone.js来启动变更检测。
- en: Test component builder
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试组件构建器
- en: 'Angular comes with another very important testing utility to test components
    and directives. So far, we only tested the component class of our components.
    However, as soon as we need to test components and their behavior in our application,
    this involves a few more things:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Angular附带另一个非常重要的测试实用工具，用于测试组件和指令。到目前为止，我们只测试了组件的组件类。然而，一旦我们需要测试应用中的组件及其行为，这就涉及到更多的事情：
- en: '**Testing the view of components**: It''s sometimes required that we test the
    rendered view of components. With all the bindings in our view, dynamic instantiation
    using template directives and content insertion, it''s required that we can have
    a way to test all this behavior.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试组件视图**：有时需要测试组件的渲染视图。在我们的视图中，所有绑定、使用模板指令的动态实例化和内容插入，我们需要有一种方法来测试所有这些行为。'
- en: '**Testing change detection**: As soon as we update our model in our component
    class, we want to test the updates that are performed via change detection. This
    involves the whole change detection behavior of our components.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试变更检测**：一旦我们在组件类中更新了我们的模型，我们希望测试通过变更检测执行的所有更新。这涉及到我们组件的整个变更检测行为。'
- en: '**User interaction**: Our component templates probably contain a set of event
    bindings, which trigger some behavior on user interaction. We''d also need a way
    to test the state after some user interaction.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户交互**：我们的组件模板可能包含一组事件绑定，这些绑定在用户交互时触发某些行为。我们还需要一种方法来测试某些用户交互后的状态。'
- en: '**Overriding and mocking**: In a testing scenario, it''s sometimes required
    to mock certain areas in our components in order to create a proper isolation
    for our test. In unit testing, we should be concerned only about the specific
    behavior that we want to test.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**覆盖和模拟**：在测试场景中，有时需要模拟组件中的某些区域，以便为测试创建适当的隔离。在单元测试中，我们应该只关注我们想要测试的特定行为。'
- en: The `TestComponentBuilder`, which is available through the `@angular/compiler/testing`
    package, helps us exactly with the previous concerns. It's our main tool to test
    components.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestComponentBuilder`，通过`@angular/compiler/testing`包提供，帮助我们解决上述问题。它是我们测试组件的主要工具。'
- en: '`TestComponentBuilder` is provided to the test application injector, which
    we initialized in our `all.spec.js` module using the `setBaseTestProviders` function.
    The reason for this is that the builder itself also relies on a lot of platform
    and application dependencies to create components. As all our dependencies now
    come from the test injector and most of them are overridden to enable inspection,
    this makes perfect sense.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestComponentBuilder`提供给测试应用程序注入器，我们在`all.spec.js`模块中使用`setBaseTestProviders`函数初始化了它。这样做的原因是，构建器本身也依赖于大量的平台和应用依赖来创建组件。由于我们所有的依赖都来自测试注入器，并且大多数都已被覆盖以启用检查，这完全合理。'
- en: 'Let''s look at a very simple example of how we can use `TestComponentBuilder`
    to test the view rendering of a dummy component:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个非常简单的例子，说明我们如何使用`TestComponentBuilder`来测试一个虚拟组件的视图渲染：
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As `TestComponentBuilder` is exposed in the test injector, we need to use dependency
    injection to get hold of the instance. We use the `inject` helper for this purpose.
    As creating a component is an asynchronous operation, we also need to make our
    test wait for completion using the `async` helper.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`TestComponentBuilder`在测试注入器中公开，我们需要使用依赖注入来获取其实例。我们为此使用`inject`辅助函数。由于创建组件是一个异步操作，我们还需要使用`async`辅助函数使我们的测试等待完成。
- en: In our test function, we call the `createAsync` method of `TestComponentBuilder`
    and pass a reference to `DummyComponent`, which we want to create. This method
    returns a `Promise`, which will resolve once the component is successfully compiled.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试函数中，我们调用`TestComponentBuilder`的`createAsync`方法，并传递我们想要创建的`DummyComponent`的引用。此方法返回一个`Promise`，一旦组件成功编译，它就会解析。
- en: In the `then` callback of the returned promise, we'll receive a special fixture
    object of the `ComponentFixture` type. We can then call the `detectChanges` method
    on this fixture object, which will execute change detection on the created component.
    After this initial change detection, the view of our dummy component is updated.
    We can now use the `nativeElement` property of the fixture in order to access
    the root DOM element of the created component.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在返回的`Promise`的`then`回调中，我们将收到一个特殊的`ComponentFixture`类型的固定对象。然后我们可以调用此固定对象的`detectChanges`方法，这将执行创建的组件的变更检测。在此初始变更检测之后，我们虚拟组件的视图已更新。现在我们可以使用固定对象的`nativeElement`属性来访问创建的组件的根DOM元素。
- en: 'Let''s look at the `ComponentFixture` type and the available fields in more
    detail:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看`ComponentFixture`类型及其可用的字段：
- en: '| Member | Description |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 成员 | 描述 |'
- en: '| --- | --- |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `detectChanges()` | This executes change detection on the root component
    that was created in the context of the fixture. The template bindings will not
    be evaluated automatically after creating a component using `TestComponentBuilder`.
    It''s our own responsibility to trigger change detection. Even after we change
    the state of our components, we''d need to trigger change detection again. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `detectChanges()` | 此方法在固定上下文中创建的根组件上执行变更检测。使用`TestComponentBuilder`创建组件后，模板绑定不会自动评估。这是我们的责任来触发变更检测。即使我们更改了组件的状态，我们也需要再次触发变更检测。|'
- en: '| `destroy()` | This method destroys the underlying component and performs
    any cleanup that is required. This can be used to test the `OnDestroy` component''s
    lifecycle. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `destroy()` | 此方法销毁底层组件并执行所需的任何清理。这可以用来测试`OnDestroy`组件的生命周期。|'
- en: '| `componentInstance` | This property points to the component class instance,
    and this is our main interaction point if we want to interact with the component.
    |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `componentInstance` | 此属性指向组件类实例，如果我们想与组件交互，这是我们的主要交互点。|'
- en: '| `nativeElement` | This is a reference to the native DOM element at the root
    of the created component. This property can be used to inspect the rendered DOM
    of our component directly. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `nativeElement` | 这是创建的组件根部的原生DOM元素的引用。此属性可用于直接检查我们组件的渲染DOM。|'
- en: '| `elementRef` | This is the `ElementRef` wrapper around the root element of
    the created component. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `elementRef` | 这是创建的组件根元素的`ElementRef`包装器。|'
- en: '| `debugElement` | This property points to an instance of `DebugElement` that
    was created by `DebugDomRootRenderer` in the component view rendering pipeline.
    The debug element provides us with some nice utilities to inspect the rendered
    element tree and testing user interaction. We''ll take a closer look at this later
    in another section. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `debugElement` | 这个属性指向由`DebugDomRootRenderer`在组件视图渲染管道中创建的`DebugElement`实例。调试元素为我们提供了一些检查渲染元素树和测试用户交互的便利工具。我们将在另一部分中更详细地探讨这一点。|'
- en: We've now looked at a very simple dummy component and how to test it using `TestComponentBuilder`
    in conjunction with the `inject` and `async` helper functions.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经查看了一个非常简单的虚拟组件以及如何使用`TestComponentBuilder`结合`inject`和`async`辅助函数来测试它。
- en: This is great, but it doesn't really reflect the complexity that we face when
    we need to test real components. Real components have a lot more dependencies
    than our dummy component. We rely on child directives and probably on injected
    services to obtain data.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但它并没有真正反映我们在需要测试真实组件时所面临的复杂性。真实组件比我们的虚拟组件有更多的依赖。我们依赖于子指令，可能还需要注入服务来获取数据。
- en: Of course, the `TestComponentBuilder` also provides us with the tools that we
    need in order to test more complex components and keep the necessary isolation
    in a unit test.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`TestComponentBuilder`也为我们提供了测试更复杂组件并保持单元测试中必要隔离所需的工具。
- en: 'Let''s first look at an example where we''d like to test a `ParentComponent`
    component, which uses a `ChildComponent` component to render a list of numbers.
    As we''d only like to test `ParentComponent`, we''re not interested in how `ChildComponent`
    renders this list. We want to remove the behavior of the child component from
    our test by providing a mock component for `ChildComponent` during our test, which
    allows us to easily verify that the data is received by the child component:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先来看一个例子，我们想要测试一个`ParentComponent`组件，它使用`ChildComponent`组件来渲染一个数字列表。因为我们只想测试`ParentComponent`，所以我们不关心`ChildComponent`如何渲染这个列表。我们希望在测试期间为`ChildComponent`提供一个模拟组件，以此来移除子组件的行为，这样我们就可以轻松地验证数据是否被子组件接收：
- en: '[PRE15]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is our starting point. We have two components, where we'll only be interested
    in testing the parent component. However, the child component is required by the
    parent component, and it implies a very specific way to render the numbers that
    are passed by the parent. We would only like to test whether our numbers were
    passed successfully to the child component. We don't want to involve the rendering
    logic of the child component in our test. This is very important because changing
    only the child component could then break our parent component test, which we
    want to avoid.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的起点。我们有两个组件，我们只对测试父组件感兴趣。然而，父组件需要子组件，并且它意味着一种非常特定的渲染方式来渲染父组件传递的数字。我们只想测试我们的数字是否成功传递给了子组件。我们不希望在测试中涉及子组件的渲染逻辑。这非常重要，因为仅仅更改子组件可能会破坏我们的父组件测试，这是我们想要避免的。
- en: 'The thing we want to achieve now is to create a mock of our child component
    in the context of our test:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在想要实现的是在测试的上下文中创建子组件的模拟：
- en: '[PRE16]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In our `MockChildComponent` class, it's important that we use the same selector
    property as the real component. Otherwise, the mocking will not work. In the template,
    we use a very simple output of the numbers input, which enables an easy inspection.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`MockChildComponent`类中，使用与真实组件相同的选择器属性是很重要的。否则，模拟将不会工作。在模板中，我们使用一个非常简单的数字输入输出，这使得检查变得容易。
- en: It's also important that we provide the same input properties as the original
    component. Otherwise, we won't imitate the real component correctly.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 同样重要的是，我们需要提供与原始组件相同的输入属性。否则，我们无法正确地模仿真实组件。
- en: 'Now, we can go ahead and perform our test. Using an additional method of `TestComponentBuilder`,
    we are able to override the real `ChildComponent` with our mock component:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续进行我们的测试。使用`TestComponentBuilder`的另一个方法，我们能够用我们的模拟组件覆盖真实的`ChildComponent`：
- en: '[PRE17]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Using the `overrideDirective` method on `TestBuilderComponent`, we can modify
    the parent component's `directives` metadata before we create it. In this way,
    we're able to exchange the real child component with our `MockChildComponent`
    class.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在`TestBuilderComponent`上使用`overrideDirective`方法，我们可以在创建它之前修改父组件的`directives`元数据。这样，我们能够用我们的`MockChildComponent`类替换真实的子组件。
- en: As a result, we decouple `ParentComponent` from `ChildComponent` in the context
    of our test. We need this level of separation in order to create a proper isolation
    of our unit test. As our mock child component simply renders the string representation
    of the passed array, we can easily test the text content of our fixture.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在测试的上下文中将`ParentComponent`与`ChildComponent`解耦。我们需要这种级别的分离，以便正确地隔离我们的单元测试。由于我们的模拟子组件只是渲染传递数组的字符串表示，我们可以轻松地测试我们的固定内容的文本。
- en: Tip
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The definition of a unit test is to test a single unit and isolate the unit
    from any dependencies. If we want to stick to this paradigm, we'd need to create
    a mock for every dependent component. This can easily get us into a situation
    where we need to maintain more complexity only for the sake of our tests. The
    key here lies in finding the right balance. You should mock dependencies that
    have a great impact on our subject and ignore dependencies that have low impact
    on the functionality we'd like to test.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的定义是测试单个单元，并隔离该单元与任何依赖项。如果我们想坚持这种范式，我们需要为每个依赖组件创建一个模拟。这很容易让我们陷入一种需要仅为了测试而维护更多复杂性的情况。关键在于找到正确的平衡。你应该模拟对我们主题有重大影响的依赖项，而忽略对我们想要测试的功能影响较小的依赖项。
- en: Let's look at a different use case where we have a component that injects a
    service in order to obtain data. As we also want to test only our component and
    not the service it relies on, we somehow need to sneak in a mock service instead
    of the real service into our component. `TestComponentBuilder` also provides a
    method to modify the `providers` metadata of directives, which comes in very handy
    for this case.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个不同的用例，其中我们有一个注入服务以获取数据的组件。由于我们只想测试我们的组件，而不是它所依赖的服务，我们 somehow 需要偷偷将模拟服务而不是真实服务注入到我们的组件中。`TestComponentBuilder`还提供了一个方法来修改指令的`providers`元数据，这对于这种情况非常有用。
- en: 'First, we declare our base component and a service that it relies on. In this
    example, the `NumbersComponent` class injects the `NumbersService` class, and
    it obtains an array with numbers from it:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明我们的基础组件及其依赖的服务。在这个例子中，`NumbersComponent`类注入了`NumbersService`类，并从中获取一个包含数字的数组：
- en: '[PRE18]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, we need to create a mock service that provides the data required in our
    test and isolates our component from the original service:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个提供测试所需数据并使我们的组件从原始服务中隔离的模拟服务：
- en: '[PRE19]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this simplified example, we just provide a different set of numbers. However,
    in a real mocking case, we can exclude a lot of steps that are unnecessary and
    could potentially create side effects. Using a mock service also ensures that
    our test, which is focused on the `NumbersComponent` class, will not break because
    of a change in the `NumbersService` class.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简化的例子中，我们只是提供了一组不同的数字。然而，在实际的模拟案例中，我们可以排除很多不必要的步骤，这些步骤可能会产生副作用。使用模拟服务还可以确保我们的测试，该测试专注于`NumbersComponent`类，不会因为`NumbersService`类的变化而中断。
- en: By extending the real service, we can leverage some of the behavior of our original
    service while overriding certain functionality in our mock. You need to be careful
    with this approach though, as we rely on the original service by doing this. If
    you'd like to create a fully isolated test, you should probably override all methods
    and properties. Or you can create a completely independent mock service, which
    provides the same methods and properties that are used in your test.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 通过扩展真实服务，我们可以利用原始服务的一些行为，同时在模拟中覆盖某些功能。不过，你需要小心这种做法，因为我们通过这样做依赖于原始服务。如果你想要创建一个完全隔离的测试，你可能需要覆盖所有方法和属性。或者，你可以创建一个完全独立的模拟服务，它提供与测试中使用的相同的方法和属性。
- en: Tip
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When using TypeScript, you should use interfaces for this purpose where both
    your real service as well as your mock service implement the same interface.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 TypeScript 时，你应该为此目的使用接口，其中你的实际服务和模拟服务都实现了相同的接口。
- en: 'Let''s now look at the test case and how we can use `TestComponentBuilder`
    to provide our mock service instead of the real one:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看测试用例以及我们如何使用`TestComponentBuilder`来提供我们的模拟服务而不是真实服务：
- en: '[PRE20]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Using the `overrideProviders` method on `TestComponentBuilder`, we can provide
    additional providers to the component under test. This allows us to override existing
    providers that are already present on the component. Using the `provide` function
    of the `@angular/core` module, we can create a provider which provides on requests
    for `NumberService` but also resolves to a `MockNumberService`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`TestComponentBuilder`上的`overrideProviders`方法，我们可以向正在测试的组件提供额外的提供者。这允许我们覆盖组件上已经存在的现有提供者。使用`@angular/core`模块的`provide`函数，我们可以创建一个提供者，它在请求`NumberService`时提供，但也解析为`MockNumberService`。
- en: '`TestComponentBuilder` allows us to perform tests in a very simple, isolated,
    and flexible fashion. It plays a major role when writing unit tests for components.
    If you''d like to read more about the available methods on `TestComponentBuilder`,
    you can visit the official documentation website at [https://angular.io/docs/ts/latest/api/core/testing/TestComponentBuilder-class.html](https://angular.io/docs/ts/latest/api/core/testing/TestComponentBuilder-class.html).'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestComponentBuilder`允许我们以非常简单、隔离和灵活的方式执行测试。它在编写组件的单元测试时扮演着重要角色。如果您想了解更多关于`TestComponentBuilder`上可用的方法，您可以访问官方文档网站[https://angular.io/docs/ts/latest/api/core/testing/TestComponentBuilder-class.html](https://angular.io/docs/ts/latest/api/core/testing/TestComponentBuilder-class.html)。'
- en: Now, it's time to use what we learned about `TestComponentBuilder` service and
    start to test our application components in action!
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候使用我们关于`TestComponentBuilder`服务的知识来开始测试我们的应用程序组件的实际操作了！
- en: Testing components in action
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试组件的实际操作
- en: In the previous topic, we learned about the `TestComponentBuilder` service and
    how to use it to create components in our testing environment. We learned about
    the `inject` and `async` helpers as well as how to mock components and services.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个主题中，我们学习了`TestComponentBuilder`服务以及如何使用它来在我们的测试环境中创建组件。我们还学习了`inject`和`async`辅助函数以及如何模拟组件和服务。
- en: Let's now use this knowledge to work on our tests for the `AutoComplete` component.
    Let's add another test to the `auto-complete.spec.js` file on the `lib/ui/auto-complete`
    path.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们利用这些知识来处理`AutoComplete`组件的测试。让我们向`lib/ui/auto-complete`路径上的`auto-complete.spec.js`文件添加另一个测试。
- en: 'As the `AutoComplete` component relies on the rather complex `Editor` component,
    it''s probably a good idea to mock our `Editor` component before we start writing
    a test:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`AutoComplete`组件依赖于相对复杂的`Editor`组件，在我们开始编写测试之前模拟我们的`Editor`组件可能是个好主意：
- en: '[PRE21]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This might look a bit tenuous, but this is actually all that we need for our
    current tests on the `AutoComplete` component. The `Editor` component should just
    accept a content input, which is the main interaction between the two components.
    In the template of our `MockEditor` component, we just render the content input
    property. This way, we can easily verify the result of using the `AutoComplete`
    component.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来有点牵强，但实际上这正是我们当前对`AutoComplete`组件测试所需的所有内容。`Editor`组件应该只接受一个内容输入，这是两个组件之间的主要交互。在我们的`MockEditor`组件的模板中，我们只渲染内容输入属性。这样，我们可以轻松验证使用`AutoComplete`组件的结果。
- en: 'Let''s use this mock editor to write our next test:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这个模拟编辑器来编写我们的下一个测试：
- en: '[PRE22]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In our tests, we'd like to test whether the `AutoComplete` component initializes
    `Editor` (respectively, our `MockEditor` component) with the right content. We
    test whether `selectedItem` of our `AutoComplete` component successfully reflects
    into the editor.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试中，我们想测试`AutoComplete`组件是否以正确的内容初始化`Editor`（分别，我们的`MockEditor`组件）。我们测试`AutoComplete`组件的`selectedItem`是否成功反映到编辑器中。
- en: We use `TestComponentBuilder`, which creates components asynchronously. Using
    the `async` helper function, we tell Jasmine to wait for all asynchronous operations
    to complete for this test.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`TestComponentBuilder`，它异步创建组件。使用`async`辅助函数，我们告诉Jasmine等待所有异步操作完成以进行此测试。
- en: Using the `ComponentFixture` that is provided by `TestComponentBuilder`, we
    can start to interact with the created component. Using the `componentInstance`
    member of the component fixture, we can set the required input properties of our
    `AutoComplete` component.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`TestComponentBuilder`提供的`ComponentFixture`，我们可以开始与创建的组件进行交互。使用组件固件的`componentInstance`成员，我们可以设置`AutoComplete`组件所需的所有输入属性。
- en: As we're responsible for the triggering of change detection manually in our
    tests, we use the `detectChanges` method on our fixture to update the component
    view, based on the new state. This will initiate the change detection lifecycle
    on our component and perform the necessary view updates.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在测试中负责手动触发变更检测，我们使用 fixture 上的 `detectChanges` 方法根据新状态更新组件视图。这将启动组件的变更检测生命周期并执行必要的视图更新。
- en: After the view updates both of our `AutoComplete` component and the underlying
    `MockEditor` component, we can run our assertions to validate the updated DOM
    by getting the text content of the `nativeElement` property on our fixture.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图更新后，我们的 `AutoComplete` 组件和底层的 `MockEditor` 组件都更新了，我们可以运行断言来验证更新的 DOM，通过获取我们
    fixture 上的 `nativeElement` 属性的文本内容。
- en: For this particular test, we're fine with this approach. However, in other scenarios
    where we have more DOM elements involved, it wouldn't be sufficient to assert
    on the root component's `textContent` property directly. This would probably include
    a lot of noise, which we're not interested in for our assertion. We should always
    try to narrow our assertion to the fewest details possible.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个特定的测试，我们对此方法感到满意。然而，在其他涉及更多 DOM 元素的场景中，直接断言根组件的 `textContent` 属性可能就不够了。这可能会包括很多我们对于断言不感兴趣的信息。我们应该始终尝试将断言缩小到尽可能少的细节。
- en: 'As we have access to the native DOM element on our fixture, we can simply use
    the DOM API to select child elements in order to narrow our assertion:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可以在我们的 fixture 上访问原生的 DOM 元素，我们可以简单地使用 DOM API 来选择子元素，以缩小我们的断言：
- en: '[PRE23]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This would successfully select the DOM element of our mock editor, and we can
    only check the text content inside the editor.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这将成功选择我们的模拟编辑器的 DOM 元素，我们只能检查编辑器内的文本内容。
- en: Although this would be a feasible approach, Angular provides us with a much
    better approach to achieve this goal.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可能是一个可行的方案，但 Angular 为我们提供了一个更好的方法来实现这个目标。
- en: Provided by `ComponentFixture`, we have access to the `DebugElement` tree that
    is created by `DebugDomRootRenderer` in the context of our test. `DebugElement`
    allows us advanced inspection of the element tree that was created by Angular
    when rendering our components. It also contains an advanced querying API, which
    allows us to search for certain elements in the tree.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 由 `ComponentFixture` 提供，我们可以访问由 `DebugDomRootRenderer` 在测试上下文中创建的 `DebugElement`
    树。`DebugElement` 允许我们对 Angular 渲染我们的组件时创建的元素树进行高级检查。它还包含一个高级查询 API，允许我们在树中搜索特定元素。
- en: 'Let''s rewrite our test to use the advanced capabilities provided by `DebugElement`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重写我们的测试，以使用 `DebugElement` 提供的高级功能：
- en: '[PRE24]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `query` and `queryAll` methods that are available on every `DebugElement`
    object allow us to query the Angular view tree like we would query a DOM tree
    using `querySelector` and `querySelectorAll`. The difference here is that we can
    use a predicate helper to query for matching elements. Using the `By` helper class,
    we can create these predicates, which will then be used in order to query the
    `DebugElement` tree.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `DebugElement` 对象上可用的 `query` 和 `queryAll` 方法允许我们像使用 `querySelector` 和 `querySelectorAll`
    查询 DOM 树一样查询 Angular 视图树。这里的区别在于，我们可以使用谓词辅助器来查询匹配的元素。使用 `By` 辅助类，我们可以创建这些谓词，然后按顺序用于查询
    `DebugElement` 树。
- en: 'There are currently three different predicates available using the `By` helper:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，使用 `By` 辅助器有三种不同的谓词可用：
- en: '| Member | Description |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 成员 | 描述 |'
- en: '| --- | --- |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `By.all()` | This is the predicate, which will result in querying for all
    the child `DebugElement` object of the current `DebugElement` object |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `By.all()` | 这是对应的谓词，它将导致查询当前 `DebugElement` 对象的所有子 `DebugElement` 对象 |'
- en: '| `By.css(selector)` | This is the predicate, which will result in querying
    for `DebugElement` using the specified CSS selector |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `By.css(selector)` | 这是对应的谓词，它将导致使用指定的 CSS 选择器查询 `DebugElement` |'
- en: '| `By.directive(type)` | This is the predicate, which will result in querying
    for `DebugElement` that contain the specified directive |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `By.directive(type)` | 这是对应的谓词，它将导致查询包含指定指令的 `DebugElement` |'
- en: Going back to our test, we can now use the query method on the fixture debug
    element in order to query for our editor. As we've exchanged the real `Editor`
    component with our `MockEditor` component, we need to query for the latter. We
    use a `By.directive(MockEditor)` predicate, which will successfully query for
    the `DebugElement` object that represents the host element of our `MockEditor`
    component.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的测试中，我们现在可以使用固定调试元素上的查询方法来查询我们的编辑器。由于我们已经用`MockEditor`组件替换了真实的`Editor`组件，我们需要查询后者。我们使用`By.directive(MockEditor)`谓词，这将成功查询代表我们的`MockEditor`组件宿主元素的`DebugElement`对象。
- en: The `query` method of the `DebugElement` object will always return a new `DebugElement`
    object of the first found element if there was a match. It will return `null`
    if the queried element was not found.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`DebugElement`对象的`query`方法将始终返回一个新创建的`DebugElement`对象，该对象是第一个找到的元素。如果没有找到查询的元素，它将返回`null`。'
- en: The `queryAll` method of the `DebugElement` will return an array of many `DebugElement`
    which contains all elements that match the predicate. If there were no matching
    elements, this method will return an empty array.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`DebugElement`的`queryAll`方法将返回一个包含所有匹配谓词的`DebugElement`对象的数组。如果没有匹配的元素，此方法将返回一个空数组。'
- en: Testing component interaction
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试组件交互
- en: Although UI interaction testing is probably part of end-to-end testing, we'll
    look at how to test basic user interaction on your components in this topic.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然UI交互测试可能是端到端测试的一部分，但我们将在这个主题中探讨如何测试组件的基本用户交互。
- en: In this topic, we'll test the autocomplete component behavior if the user clicks
    on an item in the callout window that shows all available items.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个主题中，我们将测试当用户点击调用窗口中显示所有可用项的项时，自动完成组件的行为。
- en: 'Let''s add this test to the already existing `auto-complete.spec.js` module:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个测试添加到已经存在的`auto-complete.spec.js`模块中：
- en: '[PRE25]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: First, we want to set up a Jasmine spy on the `selectedItemChange` `EventEmitter`
    `next` function for our test. This way, we can check later whether our `AutoComplete`
    component successfully emitted the event when the user selects an item from the
    callout.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们想在测试中为`selectedItemChange` `EventEmitter` `next`函数设置一个Jasmine间谍。这样，我们可以在之后检查我们的`AutoComplete`组件在用户从调用中选择一个项时是否成功发出了事件。
- en: In the `Given` section of our test code, we also call the `onEditModeChanged`
    and `onEditableInput` methods on the `AutoComplete` component instance. With these
    calls, we simulate the editor that was used, and there's currently no content
    in the editor. This will result in the desired filtering, which will present all
    available items in the callout for selection.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试代码的`Given`部分，我们还调用`AutoComplete`组件实例上的`onEditModeChanged`和`onEditableInput`方法。通过这些调用，我们模拟了使用的编辑器，目前编辑器中没有内容。这将导致所需的过滤，将所有可用项在调用中呈现以供选择。
- en: In the `When` section of our code, we first need to trigger change detection
    on the fixture. This results in the callout with all available auto-complete items
    being rendered in the `AutoComplete` component.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码的`When`部分，我们首先需要在固定件上触发变更检测。这将导致包含所有可用自动完成项的调用在`AutoComplete`组件中被渲染。
- en: Now, we can simulate the `click` event on one of our autocomplete items to fishing
    the actions in this test.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以模拟点击我们的自动完成项之一来触发这个测试中的动作。
- en: First, we'll select all `DebugElement` object that match the CSS class of our
    autocomplete items in the callout. This will provide us with an array containing
    all the elements, where we can now use the `Array.prototype.find` method to select
    one specific item based on the contained text.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将选择所有匹配我们自动完成项调用中CSS类的`DebugElement`对象。这将为我们提供一个包含所有元素的数组，我们可以使用`Array.prototype.find`方法根据包含的文本选择一个特定的项。
- en: On the `DebugElement` resulting from our query, we now call the `triggerEventHandler`
    method to simulate a click event. This will actually not trigger a real click
    event, but rather it will execute the handler attached to the binding in the view
    directly.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在查询得到的`DebugElement`上，我们现在调用`triggerEventHandler`方法来模拟一个点击事件。这实际上不会触发一个真实的点击事件，而是会直接执行视图绑定中附加的处理程序。
- en: After simulating a click on the autocomplete item with the text content of `two`,
    we can now inspect our spy on the `selectedItemChange.next` function. According
    to the behavior in our component, this should have been called with the selected
    item value.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟点击具有文本内容为`two`的自动完成项之后，我们现在可以检查我们的`selectedItemChange.next`函数上的间谍。根据我们组件中的行为，这应该已经用所选项的值调用了。
- en: Testing user interaction on components is made very easy using the `DebugElement`.
    We also decouple our tests from the underlying DOM events by taking the shortcut
    enabled by the `triggerEventHandler` method.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`DebugElement`测试组件的用户交互变得非常简单。我们还通过使用`triggerEventHandler`方法提供的快捷方式，将我们的测试与底层DOM事件解耦。
- en: Tip
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `triggerEventHandler` method operates on the virtual element tree of Angular,
    rather than the actual DOM tree. Due to this, we can also use this method to trigger
    event handlers that are attached to component output properties.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`triggerEventHandler`方法作用于Angular的虚拟元素树，而不是实际的DOM树。因此，我们也可以使用此方法来触发附加到组件输出属性的事件处理器。'
- en: Testing our plugin system
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试我们的插件系统
- en: In the previous sections, we created tests for the `AutoComplete` component,
    which is a rather simple UI component. However, we learned about all the techniques
    that are required to perform testing on more complex components or even systems
    of components.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们为`AutoComplete`组件创建了测试，这是一个相对简单的UI组件。然而，我们学习了进行更复杂组件或组件系统测试所需的所有技术。
- en: Now, we'll look into testing the plugin system that was created in [Chapter
    10](part0064.xhtml#aid-1T1401 "Chapter 10. Making Things Pluggable"), *Making
    Things Pluggable*.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将探讨测试在[第10章](part0064.xhtml#aid-1T1401 "第10章。使事物可插拔")中创建的插件系统，即*使事物可插拔*。
- en: It's probably a good time to recap on the plugin system architecture overview
    before working on this topic. As always with testing, it's crucial to understand
    exactly what's happening in the system under test.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在着手这个主题之前，回顾一下插件系统架构概述可能是个好主意。与测试一样，理解正在测试的系统中的确切发生情况至关重要。
- en: Let's create a new `plugin.spec.js` file in the `lib/plugin` path.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`lib/plugin`路径下创建一个新的`plugin.spec.js`文件。
- en: 'Before we implement our first test function for this subject, we will need
    to create some dummy components and plugins to test our system with. Let''s create
    these at the top of our testing module:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们为这个主题实现第一个测试函数之前，我们需要创建一些虚拟组件和插件来测试我们的系统。让我们在测试模块的顶部创建这些组件：
- en: '[PRE26]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Nothing special here. We declare two dummy components with a static template
    that will serve us in performing our plugin tests. Additionally, we created a
    dummy application component, which will be our main testing component. In the
    following tests, we will make use of a dummy component to test our `PluginSlot`
    directive, as opposed to testing a component directly.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么特别的。我们声明了两个具有静态模板的虚拟组件，这些模板将帮助我们进行插件测试。此外，我们还创建了一个虚拟应用程序组件，它将成为我们的主要测试组件。在接下来的测试中，我们将使用虚拟组件来测试我们的`PluginSlot`指令，而不是直接测试组件。
- en: 'Next, we''ll need to mock our `PluginService` injectable, which is designed
    to load plugins asynchronously from URLs. In our mock, we''d want to override
    this functionality. Instead of loading plugins from URLs, we want to load some
    predefined test plugins:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要模拟我们的`PluginService`注入服务，该服务旨在从URL异步加载插件。在我们的模拟中，我们想要覆盖这个功能。我们不想从URL加载插件，而是想加载一些预定义的测试插件：
- en: '[PRE27]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We override the `loadPlugins` method to avoid any plugins being loaded during
    the construction of the service. We also override the RxJS subject present on
    the `change` property in order to prevent any reactive behavior of our plugin
    system because this would only disturb our tests.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们覆盖了`loadPlugins`方法，以避免在服务构建过程中加载任何插件。我们还覆盖了`change`属性上存在的RxJS主题，以防止我们的插件系统有任何反应行为，因为这只会干扰我们的测试。
- en: 'Let''s dive right into our first test where we want to test a very basic plugin
    with one plugin component, to be instantiated correctly by the `PluginSlot` directive.
    First, we set up our test structure using the `describe` and `it` functions:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接进入我们的第一个测试，我们想要测试一个非常基本的插件，该插件通过`PluginSlot`指令正确实例化。首先，我们使用`describe`和`it`函数设置我们的测试结构：
- en: '[PRE28]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The only difference here to what we already knew is that we use a new `beforeEachProviders`
    function from the `@angular/core/testing` module. This function allows us to set
    up some default providers that are used in our tests. As all our plugin system
    tests will rely on the presence of `PluginService`, we use this function to set
    up the mock provider resolving to our `MockPluginService` class.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们已知的内容唯一的区别是，我们使用了来自`@angular/core/testing`模块的新`beforeEachProviders`函数。此函数允许我们设置一些默认提供者，这些提供者在我们的测试中使用。由于我们所有的插件系统测试都将依赖于`PluginService`的存在，我们使用此函数来设置模拟提供者，解析为我们的`MockPluginService`类。
- en: Instead of using `beforeEachProviders`, we could also use the `overrideProviders`
    method in the `TestComponentBuilder` to provide additional injectables. However,
    this will limit the use to the inside of our components. If we want to interact
    with the service from our test function, we need to use the `beforeEachProviders`
    helper.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用`beforeEachProviders`，我们还可以在`TestComponentBuilder`中使用`overrideProviders`方法来提供额外的可注入项。然而，这将限制使用范围仅限于我们的组件内部。如果我们想从我们的测试函数中与该服务交互，我们需要使用`beforeEachProviders`辅助函数。
- en: Using the `inject` helper, we inject `TestComponentBuilder` and `PluginService`,
    which we provided using the `beforeEachProviders` helper.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`inject`辅助函数，我们注入`TestComponentBuilder`和`PluginService`，我们使用`beforeEachProviders`辅助函数提供这些。
- en: Let's now implement the missing test body inside of the `Promise` callback after
    executing `createAsync`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来实现`createAsync`执行后的`Promise`回调中缺失的测试主体。
- en: 'As a first step, we define a new dummy plugin, which uses the `PluginConfig`
    decorator from the previous chapter. We create a `PluginPlacement` in the plugin
    metadata, which includes a mapping of `DummyPluginComponent1` into the slot with
    the name `dummy-slot`. If you take a look at the `DummyApplication` component
    that we use in this test again, you can see that it contains a `PluginSlot` directive
    with the name attribute set to `dummy-slot`:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，我们定义一个新的虚拟插件，它使用上一章中的`PluginConfig`装饰器。我们在插件元数据中创建一个`PluginPlacement`，它将`DummyPluginComponent1`映射到名为`dummy-slot`的槽位。如果你再次查看我们在这个测试中使用的`DummyApplication`组件，你可以看到它包含一个名为`dummy-slot`的`PluginSlot`指令：
- en: '[PRE29]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This plugin should now cause the `DummyPluginComponent1` component to be rendered
    in the plugin slot of our `DummyApplication` class.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 此插件现在应该会导致`DummyPluginComponent1`组件在我们的`DummyApplication`类的插件槽中渲染。
- en: 'As a next step, we add the `DummyPlugin` class to the plugins list of our `MockPluginService`
    mock service:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 作为下一步，我们将`DummyPlugin`类添加到我们的`MockPluginService`模拟服务的插件列表中：
- en: '[PRE30]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The object that we're adding to the plugins array of the `MockPluginService`
    simply simulates a plugin that would normally be loaded in `PluginService`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加到`MockPluginService`插件数组中的对象仅仅模拟了通常在`PluginService`中加载的插件。
- en: 'Next, we put aside a reference to the `PluginSlot` directive, which is placed
    in our `DummyApplication` component. For this, we can use the `query` method on
    the `DebugElement` root of our fixture. We use a predicate, which allows us to
    query by the directive type of our `PluginSlot` component:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们保留一个指向放置在我们`DummyApplication`组件中的`PluginSlot`指令的引用。为此，我们可以使用我们的固定`DebugElement`根上的`query`方法。我们使用一个谓词，它允许我们通过我们的`PluginSlot`组件的指令类型进行查询：
- en: '[PRE31]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We need the reference to the directive instance of the plugin slot in order
    to initialize the slot prior to our test assertion. This is an important step
    because we can't rely on the observable subject in our `MockPluginService` class
    to initialize our `PluginSlot` directive. We explicitly disabled the reactive
    features of our plugin system in order to perform proper testing. Therefore, we
    need to manually initialize our plugin slot before we can perform any assertion.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要插件槽指令实例的引用，以便在测试断言之前初始化槽位。这是一个重要的步骤，因为我们不能依赖于`MockPluginService`类中的可观察主题来初始化我们的`PluginSlot`指令。我们明确禁用了插件系统的响应式功能，以便进行适当的测试。因此，在执行任何断言之前，我们需要手动初始化我们的插件槽。
- en: After executing the query with the directive predicate (searching for an element
    which contains the `PluginSlot` directive), we'll receive `DebugElement` of our
    plugin slot element. In order to get the directive instance, we use the element
    injector present on each `DebugElement` object.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用指令谓词（搜索包含`PluginSlot`指令的元素）执行查询后，我们将收到我们的插件槽元素上的`DebugElement`。为了获取指令实例，我们使用每个`DebugElement`对象上存在的元素注入器。
- en: 'The `initialize` method on the `PluginSlot` component instance will create
    all relevant plugin components. Luckily, this will also return a `Promise` to
    us, which will be resolved once all components have been created in the view of
    our `ApplicationDummy` component:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`PluginSlot`组件实例上的`initialize`方法将创建所有相关的插件组件。幸运的是，这也会返回一个`Promise`给我们，一旦所有组件在我们的`ApplicationDummy`组件视图中创建完成，这个`Promise`就会被解析：'
- en: '[PRE32]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the callback of the `Promise` returned by the `initialize` method of the
    `PluginSlot` instance, we can finally assert on the text content of the root element
    of our `DummyApplication` component.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PluginSlot`实例的`initialize`方法返回的`Promise`回调中，我们最终可以对`DummyApplication`组件根元素的文本内容进行断言。
- en: As the `DummyPluginComponent1` class has a simple static template that contains
    the text `dummy1`, we should see a complete text content of `dummy-slot:dummy1`
    in our application view.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `DummyPluginComponent1` 类有一个简单的静态模板，其中包含文本 `dummy1`，我们应该在我们的应用程序视图中看到完整的文本内容为
    `dummy-slot:dummy1`。
- en: This is it for our first plugin test. Now, we will look at a second test, which
    we'll use to verify another feature of our plugin system. Our plugin system should
    also be able to render two components of the same plugin into two separate plugin
    slots. However, in the template of our `DummyApplication` component, we currently
    only have one plugin slot with the name `dummy-slot`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的第一个插件测试的全部内容。现在，我们将看看第二个测试，我们将使用它来验证我们的插件系统的另一个功能。我们的插件系统也应该能够将同一插件的两个组件渲染到两个不同的插件槽位中。然而，在我们的
    `DummyApplication` 组件的模板中，我们目前只有一个名为 `dummy-slot` 的插件槽位。
- en: 'In order to modify the template of our `DummyApplication` component just for
    a particular test, we can use the `overrideTemplate` method on `TestBuilderComponent`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 为了仅针对特定测试修改 `DummyApplication` 组件的模板，我们可以使用 `TestBuilderComponent` 上的 `overrideTemplate`
    方法：
- en: '[PRE33]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In our test function, we create a new template for our `DummyApplication` component.
    We're adding two plugin slots to the template with their name attributes set to
    `dummy-slot1` and `dummy-slot2`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试函数中，我们为 `DummyApplication` 组件创建一个新的模板。我们在模板中添加了两个插件槽位，其名称属性设置为 `dummy-slot1`
    和 `dummy-slot2`。
- en: Now, we can use the `overrideTemplate` method on `TestComponentBuilder` to override
    the `DummyApplication` component template before we create it. This provides us
    with the necessary flexibility to reuse mock and dummy components for different
    tests.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 `TestComponentBuilder` 上的 `overrideTemplate` 方法在创建之前覆盖 `DummyApplication`
    组件的模板。这为我们提供了必要的灵活性，以便为不同的测试重用模拟和虚拟组件。
- en: 'Let''s take a look at the code that comes in the `createAsync` promise callback:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `createAsync` 承诺回调中包含的代码：
- en: '[PRE34]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: First, we create a new `DummyPlugin` plugin class and use the `PluginConfig`
    decorator to configure it. In the placement metadata, we configure the mappings
    so that we map two components into different plugin slots. The first component
    is mapped to the plugin slot with the name `DummySlot1`, while the second one
    will go to the slot with the name `DummySlot2`. We've overridden our `DummyApplication`
    template to include both of these plugin slots.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个新的 `DummyPlugin` 插件类，并使用 `PluginConfig` 装饰器对其进行配置。在放置元数据中，我们配置映射，以便将两个组件映射到不同的插件槽位。第一个组件被映射到名为
    `DummySlot1` 的插件槽位，而第二个组件将被映射到名为 `DummySlot2` 的槽位。我们已经覆盖了我们的 `DummyApplication`
    模板，以包含这两个插件槽位。
- en: 'We now add our `DummyPlugin` class to the `MockPluginService` class and simulate
    the plugin being loaded:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将我们的 `DummyPlugin` 类添加到 `MockPluginService` 类中，并模拟插件被加载：
- en: '[PRE35]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The following code queries for `DebugElements` in the fixture using the `queryAll`
    method. We use a predicate that queries for all elements containing the `PluginSlot`
    directive. With an additional call to `Array.prototype.map`, we transform the
    array in order to get back the component instances of the discovered `PluginSlot`
    components directly:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用 `queryAll` 方法在固定装置中查询 `DebugElements`。我们使用一个谓词来查询包含 `PluginSlot` 指令的所有元素。通过
    `Array.prototype.map` 的附加调用，我们转换数组，以便直接获取发现的 `PluginSlot` 组件的组件实例：
- en: '[PRE36]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, it''s time to complete our test. Using the `Promise.all` function, we''re
    able to streamline an array of Promises into a single Promise, which will resolve
    once all underlying Promises are resolved. We can then map our `pluginSlots` array
    by executing the initialize method on each of the `PluginSlot` components. This
    will return an array of Promises to us, which will resolve when all components
    within the plugin slots are created:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是我们完成测试的时候了。使用 `Promise.all` 函数，我们可以将一系列承诺流线化为单个承诺，该承诺将在所有底层承诺解决后解决。然后，我们可以通过在每个
    `PluginSlot` 组件上执行初始化方法来映射我们的 `pluginSlots` 数组。这将返回一个承诺数组给我们，这些承诺将在插件槽位中的所有组件创建后解决：
- en: '[PRE37]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the `then` callback of the consolidated promise using the `Promise.all` function,
    we can finally perform our assertion. With the overridden template of our `DummyApplication`
    component and the output of our two plugin components in the two separated plugin
    slots, we should get a text content of `dummy-slot1:dummy1dummy-slot2:dummy2`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `Promise.all` 函数的合并承诺的 `then` 回调中，我们最终可以执行我们的断言。使用覆盖后的 `DummyApplication`
    组件模板和两个分离的插件槽位中的两个插件组件的输出，我们应该得到文本内容为 `dummy-slot1:dummy1dummy-slot2:dummy2`。
- en: This is the last test that we look at in this chapter. However, there are more
    tests in the code that comes with this book. Just check out the code repository
    and get your hands on those tests yourself.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本章我们要查看的最后一个测试。然而，这本书附带代码中还有更多的测试。只需查看代码仓库，自己动手尝试那些测试即可。
- en: Summary
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to write concise unit tests for our components.
    We followed a BDD style approach of writing tests, and we also covered the basics
    of the JavaScript testing framework, Jasmine.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何为我们的组件编写简洁的单元测试。我们遵循了BDD风格的测试编写方法，同时也涵盖了JavaScript测试框架Jasmine的基础知识。
- en: We learned about the debugging tools that are available in Angular and how to
    set up an injector environment for testing. Using `TestComponentBuilder`, we were
    able to perform tests in a very flexible but precise way. We also learned about
    the view tree of multiple `DebugElement` that are created along with `TestComponentBuilder`
    running in the debug environment. This allowed us to perform clever inspection
    and apply practical queries to the rendered views in order to assert expected
    results.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解了Angular中可用的调试工具以及如何设置测试的注入器环境。使用`TestComponentBuilder`，我们能够以非常灵活但精确的方式执行测试。我们还了解了在调试环境中运行的`TestComponentBuilder`所创建的多个`DebugElement`的视图树。这使我们能够进行巧妙的检查，并对渲染的视图应用实际查询，以断言预期的结果。
- en: We used the `inject` and `async` helpers to inject dependencies and, at the
    same time, run asynchronous tests. We built both mock and dummy components in
    order to isolate our tests from the rest of our application.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`inject`和`async`辅助函数来注入依赖，并同时运行异步测试。我们构建了模拟和虚拟组件，以便将我们的测试与应用程序的其他部分隔离开来。
