- en: Introduction to Modern Web Application Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: According to the Stack Overflow developer survey 2017 ([https://insights.stackoverflow.com/survey/2017#developer-profile-specific-developer-types](https://insights.stackoverflow.com/survey/2017#developer-profile-specific-developer-types)),
    *full-stack web developer* is the most popular developer title. The software industry
    defines a full-stack developer as someone who can work on different areas of an
    application stack. The term stack refers to different components and tools that
    make up an application.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of web application development, the stack can be broadly classified
    into two areas—**frontend** and **backend** stack or **client-side** and **server-side**
    stack. Frontend generally refers to the part that is responsible for rendering
    the user interface, and backend refers to the part that is responsible for the
    business logic, database interactions, user authentication, server configuration,
    and so on. A full-stack Java web application developer is expected to work on
    both frontend and backend technologies, ranging from writing HTML/JavaScript for
    the user interface to writing Java class files for business logic and SQL queries
    for database operations as required.
  prefs: []
  type: TYPE_NORMAL
- en: With an ever-evolving software architecture landscape, the scope of technologies
    that a full-stack web developer is expected to work has increased tremendously.
    It is no longer enough that we can write HTML and JavaScript to build a user interface,
    we are expected to know client-side frameworks such as Angular, React, VueJS,
    and so on. It is also not enough that we are proficient in enterprise Java and
    SQL, we are expected to know server-side frameworks such as Spring, Hibernate,
    Play, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will introduce the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Modern full-stack web development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web architecture patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing the right pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modern full-stack web development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we were to even begin discussing the life of a full-stack developer, it would
    be worthy of a whole book by itself – so let's leave that for another day.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at a user story about a full-stack Java web application and see what
    is involved.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use an example of developing a user management module for a typical
    Java web application. Let''s assume that you would be writing unit test cases
    for the all the code hence we won''t detail them out here:'
  prefs: []
  type: TYPE_NORMAL
- en: You would start by designing the architecture for the feature. You would decide
    on the plugins and frameworks to use, patterns to follow, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will be modeling the domain model for the feature depending on the database
    technology used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, you would create server-side code and database queries to persist and
    fetch data from the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the data is ready you would implement server-side code for any business
    logic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, you would implement an API that can be used to provide data for the presentation
    over an HTTP connection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You would write integration tests for the API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, since the backend is ready, you would start writing frontend code in JavaScript
    or a similar technology.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You would write client-side services to fetch data from the backend API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You would write client-side components to display the data on a web page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You would build the page and style it as per the design provided.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You would write automated end to end tests for the web page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is not done yet. Once you have tested everything works locally you would
    create pull requests or check-in the code to the version control system used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You would wait for the continuous integration process to verify everything,
    and fix anything that is broken.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once everything is green and the code is accepted, typically you would start
    the deployment of this feature to a staging or acceptance environment, either
    on-premises or to a cloud provider. If it is the latter you would be expected
    to be familiar with the cloud technologies used as well. You would also be upgrading
    the database schema as necessary and writing migration scripts when required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the feature is accepted you might be responsible for deploying it into
    the production environment in a similar way, and troubleshoot issues where necessary.
    In some teams, you might swap the steps with other team members so that you would
    be deploying a feature developed by your co-worker while s/he deploys yours.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You might also be responsible, along with your co-workers, to make sure the
    production environment is up and running including the database, virtual machines,
    and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see it is no easy task. The range of responsibilities spawns across
    making stylesheet updates on the client side to running database migration scripts
    on a virtual machine in the production cloud service. If you are not familiar
    enough, this would be a herculean task and you would soon be lost in the vast
    ocean of frameworks, technologies, and design patterns out there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Full stack development is not for the faint-hearted. It takes a lot of time
    and effort in keeping yourself up to date with various technologies and patterns
    in multiple disciplines of software development. Following are some of the common
    problems you might face as a full-stack Java developer:'
  prefs: []
  type: TYPE_NORMAL
- en: Client-side development is not just about writing plain HTML and JavaScript
    anymore. It is becoming as complex as server-side development with build tools,
    transpilers, frameworks, and patterns.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a new framework almost every week in the JavaScript world and if you
    are coming from a Java background it could be very overwhelming for you.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container technologies such as Docker revolutionalized the software industry
    but they also introduced a lot of new stuff to learn and keep track of, such as
    orchestration tools, container management tools, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloud services are growing day by day. To stay on track you would have to familiarize
    yourself with their API and related orchestration tools.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java server-side technologies have also undergone a major shift in recent times
    with the introduction of JVM languages such as Scala, Groovy, Kotlin, and so on,
    forcing you to keep yourself up to date with them. On the other side, server-side
    frameworks are becoming more feature rich and hence more complex.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most important thing of all is the pain of making sure all of these work
    together well when required. It will need a lot of configuration, some glue code,
    and endless cups of coffee.
  prefs: []
  type: TYPE_NORMAL
- en: '**Transpilers** are source-to-source compilers. Whereas a traditional compiler
    compiles from source to binary, a transpiler compiles from one type of source
    code to another type of source code. TypeScript and CoffeeScript are excellent
    examples of this, both compile down to JavaScript.'
  prefs: []
  type: TYPE_NORMAL
- en: It's very easy to get lost here and this is where technologies such as JHipster
    and Spring Boot step in to help. We will see the details in later chapters but
    in short, they help by providing the wiring between moving parts so that you only
    need to concentrate on writing business code. JHipster also helps by providing
    the abstractions to deploy and manage the application to various cloud providers.
  prefs: []
  type: TYPE_NORMAL
- en: Web architecture patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The full-stack landscape is further complicated by the different web architecture
    patterns commonly used these days. The widely used web application architecture
    patterns today can be broadly classified into two—**monolithic architecture**
    and **microservice architecture**, the latter being the new kid on the block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: Monolithic architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservice architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monolithic web architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A monolithic architecture is the most used pattern for web applications due
    to its simplicity in development and deployment. Though the actual moving parts
    will differ from application to application, the general pattern remains the same.
    In general, a monolithic web application may do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It can support different clients such as desktop/mobile browsers and native
    desktop/mobile applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can expose APIs for third-party consumption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can integrate with other applications over REST/SOAP web services or message
    queues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can handle HTTP requests, execute business logic, access a database, and
    can exchange data with other systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can run on web application containers such as Tomcat, JBoss, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be scaled vertically by increasing the power of the machines it runs
    on or scaled horizontally by adding additional instances behind load balancers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**REST** (**Representational State Transfer**) relies on a stateless, client-server,
    cacheable communications protocol. HTTP is the most commonly used protocol for
    REST. It is a lightweight architectural style in which RESTful HTTP communication
    is used to transfer data between a client and server or between two systems.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SOAP** (**Simple Object Access Protocol**) is a messaging protocol using
    HTTP and XML. It is widely used in SOAP web services to transfer data between
    two different systems.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a typical monolithic web application architecture would be as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's imagine an online hotel reservation system that takes reservation orders
    online from customers, verifies the room availability, verifies the payment option,
    makes the reservation, and notifies the hotel. The application consists of several
    layers and components including a client-side app, which builds a nice rich user
    interface, and several other backend components responsible for managing the reservations,
    verifying payment, notifying customers/hotels, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application will be deployed as a single monolithic **Web Application Archive** (**WAR**)
    file that runs on a web application container such as Tomcat and will be scaled
    horizontally by adding multiple instances behind an Apache web server acting as
    a load balancer. Take a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1f631e18-1e1c-41b3-aac2-5d5ff802dbb4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The advantages of a monolithic web application architecture are as detailed
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: Simpler to develop as the technology stack is uniform throughout all layers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simpler to test as the entire application is bundled in a single package making
    it easier to run integration and end-to-end tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simpler and faster to deploy, as you only have one package to worry about.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simpler to scale as you can multiply the number of instances behind a load balancer
    to scale out.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requires a smaller team to maintain the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Team members share more or less the same skill set.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The technical stack is simpler and most of the times easier to learn.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initial development is faster hence making time to market faster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requires simpler infrastructure. Even a simple application container or JVM
    will be sufficient to run the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The disadvantages of a monolithic web application architecture are as detailed
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: Components are tightly coupled together resulting in unwanted side effects such
    as changes to one component causing a regression in another and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Becomes complex and huge over time resulting in slow development turnaround.
    New features will take more time to develop and refactoring of existing features
    will be more difficult due to tight coupling.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The entire application needs to be redeployed for any changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is less reliable due to tightly coupled modules. A small issue in a service
    might break the entire application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Newer technology adoption is difficult as entire application needs to be migrated.
    Incremental migration is not possible most of the time. Hence many monolithic
    applications end up having an outdated technology stack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Critical services cannot be scaled individually resulting in increased resource
    usage as the entire application will need to be scaled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Huge monolith applications will have a higher start-up time and high resource
    usage in terms of CPU and memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Teams will be more interdependent and it will be challenging to scale the teams.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservice architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The microservice architecture has gained momentum in recent years, and is gaining
    popularity in web application development due to its modularity and scalability.
    Microservice architecture can offer almost all the features of a monolith that
    we saw in the earlier section. Additionally, it offers many more features and
    flexibility, and hence is often considered a superior choice for complex applications.
    Unlike the monolithic architecture, it''s quite difficult to generalize the microservice
    architecture as it could vary heavily depending on the use case and implementation.
    But they do share some common traits and they are, in general, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Microservice components are loosely coupled. Components can be developed, tested,
    deployed, and scaled independently without disrupting other components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components need not be developed using the same technology stack. This means
    a single component can choose its own technology stack and programming language.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They often utilize advanced features such as service discovery, circuit breaking,
    load balancing, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservice components are mostly lightweight and they do a specific functionality.
    For example, an authentication service will only care about authenticating a user
    into the system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Often has an extensive monitoring and troubleshooting setup.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example of a microservice web application architecture would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's imagine a huge online e-commerce system where customers can go through
    categories of merchandise, maintain favorites, add items to a shopping cart, make
    and track orders, and so on. The system has inventory management, customer management,
    multiple payment modes, order management, and so on. The application consists
    of several modules and components including a UI gateway application, which builds
    a nice rich user interface and also handles user authentication and load balancing,
    and several other backend applications responsible for managing the inventory,
    verifying payment, and managing orders. It also has performance monitoring and
    automatic failover for services.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application will be deployed as multiple executable WAR files in Docker
    containers hosted by a cloud provider. Take a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a317c956-4678-47c3-b60e-67baed5d0cac.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The advantages of a microservice web application architecture are as detailed
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: Loosely coupled components resulting in better isolation, easier to test and
    faster to startup.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Faster development turnaround and better time to market. New features can be
    built faster and existing features can be easily refactored.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services can be deployed independently making the application more reliable
    and make patching easier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Issues, such as a memory leak in one of the services, are isolated and hence
    will not bring down the entire application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technology adoption is easier, components can be independently upgraded in incremental
    migration making it possible to have a different stack for each component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More complex and efficient scaling models can be established. Critical services
    can be scaled more effectively. Infrastructure is used more efficiently.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Individual components will start up faster making it possible to parallelize
    and improve overall start-up.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Teams will be less dependent on each other. Best suited for agile teams.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The disadvantages of a microservice web application architecture are as detailed
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: More complex in terms of the overall stack as different components might have
    different technology stacks forcing the team to invest more time in keeping up
    with them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Difficult to perform end-to-end tests and integration tests as there are more
    moving parts in the stack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The entire application is more complex to deploy as there are complexities with
    containers and virtualization involved.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaling is more efficient but setting upscaling is more complex as it would
    require advanced features such as service discovery, DNS routing, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requires a larger team to maintain the application as there are more components
    and more technologies involved.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Team members share varying skill sets based on the component they work on, making
    replacements and knowledge sharing harder.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The technical stack is complex and most of the times harder to learn.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initial development time will be higher making time to market slower.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requires a complex infrastructure. Most often will require containers (Docker)
    and multiple JVM or app containers to run on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing the right pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When starting a new project, it is always difficult to choose an architecture
    pattern these days. There are so many factors to take into account and it is easy
    to get confused with all the **hype** around different patterns and technologies
    (see **Hype Driven Development** ([https://blog.daftcode.pl/hype-driven-development-3469fc2e9b22](https://blog.daftcode.pl/hype-driven-development-3469fc2e9b22))).
    Following are some general guidelines on when to choose a monolithic web application
    architecture over a microservice architecture and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: When to choose a monolithic architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following list can be used as a general guide when choosing a monolithic
    architecture. This is not a definitive list but gives an idea of when to go with
    a monolithic architecture over microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: When the **application** **scope** is small and well defined, and you are sure
    that the application will not grow tremendously in terms of features. For example,
    a blog, a simple online shopping website, a simple CRUD application, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the **team size** is small, say less than eight people (it's not a hard
    limit but rather practical).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the **average skill set** of the team is either novice or intermediate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When **time to market** is critical.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you do not want to spend too much on **infrastructure**, monitoring, and
    so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When your **user base** is rather small and you do not expect them to grow.
    For example, an enterprise app targeting a specific set of users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In most practical use cases, a monolithic architecture would suffice. Read on
    to the next section to see when you should consider a microservice architecture
    over monolithic.
  prefs: []
  type: TYPE_NORMAL
- en: When to choose a microservice architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following list can be used as a general guide when choosing a microservice
    architecture. This is not a definitive list but gives an idea of when to go with
    microservices architecture over a monolith. Please note that unlike choosing a
    monolithic architecture, the decision here is more complex and may involve cross
    consideration among many of the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: When the **application** **scope** is large and well defined and you are sure
    that the application will grow tremendously in terms of features. For example,
    an online e-commerce store, a social media service, a video streaming service
    with a large user base, an API provider, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the **team size** is large, there must be enough members to effectively
    develop individual components independently.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the **average skill set** of the team is good and team members are confident
    about advanced microservice patterns.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When **time to market** is not critical. The microservice architecture will
    take more time to get right up front.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you are ready to spend more on **infrastructure**, monitoring, and so on,
    in order to improve the product quality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When your **user base** is huge and you expect them to grow. For example, a
    social media application targeting users all over the world.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Though a monolithic architecture would suffice in most cases, investing up front
    in a microservice architecture will reap long-term benefits when the application
    grows huge.
  prefs: []
  type: TYPE_NORMAL
- en: For more on these architecture patterns, you can refer to [https://articles.microservices.com/monolithic-vs-microservices-architecture-5c4848858f59](https://articles.microservices.com/monolithic-vs-microservices-architecture-5c4848858f59).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've seen what full stack development is and compared two of the most
    prominent architecture patterns. We also learned advantages and disadvantages
    of monolithic and microservice architecture, which helps us to choose the right
    pattern for our use cases at hand.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a deep dive into the JHipster platform and
    look at all the options it provides. We will also learn how to install JHipster
    and set up our tools and development environment.
  prefs: []
  type: TYPE_NORMAL
