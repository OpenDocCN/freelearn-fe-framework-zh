<html><head></head><body>
<section epub:type="frontmatter chapter" role="doc-chapter">
<h1 class="chapter-number" id="_idParaDest-139"><a id="_idTextAnchor251"/><span class="koboSpan" id="kobo.1.1">10</span></h1>
<h1 id="_idParaDest-140"><a id="_idTextAnchor252"/><span class="koboSpan" id="kobo.2.1">Diving Deep into Composition Patterns</span></h1>
<p><span class="koboSpan" id="kobo.3.1">The journey of building scalable and maintainable user interfaces is riddled with challenges. </span><span class="koboSpan" id="kobo.3.2">One primary challenge faced by developers is ensuring that components remain modular, reusable, and easy to understand as a code base grows. </span><span class="koboSpan" id="kobo.3.3">The more intertwined and tightly coupled our components become, the harder it is to maintain, test, or even onboard new team members.</span></p>
<p><span class="koboSpan" id="kobo.4.1">Composition has </span><a id="_idIndexMarker442"/><span class="koboSpan" id="kobo.5.1">emerged as a powerful technique to address this challenge, enabling developers to build more organized, scalable, and cleaner code bases. </span><span class="koboSpan" id="kobo.5.2">Instead of creating large, monolithic components that carry out numerous tasks, we break them down into smaller, more manageable pieces that can be combined in versatile ways. </span><span class="koboSpan" id="kobo.5.3">This offers us a clear path to streamline logic, enhance reusability, and maintain a clear separation of concerns.</span></p>
<p><span class="koboSpan" id="kobo.6.1">This chapter is dedicated to understanding and mastering composition in React. </span><span class="koboSpan" id="kobo.6.2">We’ll delve into foundational techniques such as higher-order functions before transitioning into higher-order components and Hooks. </span><span class="koboSpan" id="kobo.6.3">You’ll learn how these tools seamlessly align with the principles of composition, allowing you to build more robust applications with React. </span><span class="koboSpan" id="kobo.6.4">Our journey will culminate with a deep dive into headless components, a paradigm that encapsulates logic without dictating the UI, offering unparalleled flexibility.</span></p>
<p><span class="koboSpan" id="kobo.7.1">By the chapter’s end, you’ll appreciate the benefits of employing composition techniques. </span><span class="koboSpan" id="kobo.7.2">You’ll be equipped to create UIs that are not just scalable and maintainable but also a pleasure to work with. </span><span class="koboSpan" id="kobo.7.3">Let’s embark on this enlightening exploration of composition in React.</span></p>
<p><span class="koboSpan" id="kobo.8.1">In this chapter, we will cover the following topics:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">Understanding composition through higher-order components</span></li>
<li><span class="koboSpan" id="kobo.10.1">Diving deep into custom Hooks</span></li>
<li><span class="koboSpan" id="kobo.11.1">Developing a drop-down list component</span></li>
<li><span class="koboSpan" id="kobo.12.1">Exploring a headless component pattern</span><a id="_idTextAnchor253"/></li>
</ul>
<h1 id="_idParaDest-141"><a id="_idTextAnchor254"/><span class="koboSpan" id="kobo.13.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.14.1">A GitHub repository has been created to host all the code we discuss in the book. </span><span class="koboSpan" id="kobo.14.2">For this chapter, you can find the recommended structure at</span><a href="https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch10"><span class="koboSpan" id="kobo.15.1"> https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch1</span></a><span class="koboSpan" id="kobo.16.1">0.</span><a id="_idTextAnchor255"/></p>
<h1 id="_idParaDest-142"><a id="_idTextAnchor256"/><span class="koboSpan" id="kobo.17.1">Understanding composition through higher-order components</span></h1>
<p><span class="koboSpan" id="kobo.18.1">Composition </span><a id="_idIndexMarker443"/><span class="koboSpan" id="kobo.19.1">might be the most important technique in software design overall, and like many other fundamental design principles, it applies on many different levels. </span><span class="koboSpan" id="kobo.19.2">In this section, we’ll review how we can use higher-order functions and their variation in the React world – higher-order components – to implement composition</span><a id="_idTextAnchor257"/><span class="koboSpan" id="kobo.20.1">.</span></p>
<h2 id="_idParaDest-143"><a id="_idTextAnchor258"/><span class="koboSpan" id="kobo.21.1">Reviewing higher-order functions</span></h2>
<p><span class="koboSpan" id="kobo.22.1">We </span><a id="_idIndexMarker444"/><span class="koboSpan" id="kobo.23.1">discussed some examples of higher-order functions in </span><a href="B21103_09.xhtml#_idTextAnchor227"><i class="italic"><span class="koboSpan" id="kobo.24.1">Chapter 9</span></i></a><span class="koboSpan" id="kobo.25.1">, but it’s such an important concept that I would like to review it a bit more here. </span><span class="koboSpan" id="kobo.25.2">A </span><strong class="bold"><span class="koboSpan" id="kobo.26.1">higher-order function</span></strong><span class="koboSpan" id="kobo.27.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.28.1">HOF</span></strong><span class="koboSpan" id="kobo.29.1">) is a function that either takes another function as its argument, returns a function, or both. </span><span class="koboSpan" id="kobo.29.2">The ability to accept a function as a parameter has a lot of advantages, especially when it comes to composition.</span></p>
<p><span class="koboSpan" id="kobo.30.1">Consider the following example:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.31.1">
const report = (content: string) =&gt; {
  const header = "=== Header ===";
  const footer = "=== Footer ===";
  return [header, content, footer].join("\n");
};</span></pre> <p><span class="koboSpan" id="kobo.32.1">Here, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.33.1">report</span></strong><span class="koboSpan" id="kobo.34.1"> function</span><a id="_idIndexMarker445"/><span class="koboSpan" id="kobo.35.1"> generates a formatted report containing a header, the provided content, and a footer. </span><span class="koboSpan" id="kobo.35.2">For instance, given the input </span><strong class="source-inline"><span class="koboSpan" id="kobo.36.1">hello world</span></strong><span class="koboSpan" id="kobo.37.1">, the output would be as follows:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.38.1">
=== Header ===
hello world
=== Footer ===</span></pre> <p><span class="koboSpan" id="kobo.39.1">Now, imagine a scenario where some users wish to print the content in uppercase. </span><span class="koboSpan" id="kobo.39.2">While we could achieve this with </span><strong class="source-inline"><span class="koboSpan" id="kobo.40.1">content.toUpperCase()</span></strong><span class="koboSpan" id="kobo.41.1">, other users might prefer the content as-is. </span><span class="koboSpan" id="kobo.41.2">Introducing conditions within our report function is one approach to pleasing both sets of users. </span><span class="koboSpan" id="kobo.41.3">Drawing inspiration from our previous discussion about the title example in </span><a href="B21103_09.xhtml#_idTextAnchor227"><i class="italic"><span class="koboSpan" id="kobo.42.1">Chapter 9</span></i></a><span class="koboSpan" id="kobo.43.1">, we can allow a </span><strong class="source-inline"><span class="koboSpan" id="kobo.44.1">transformer</span></strong><span class="koboSpan" id="kobo.45.1"> function to be passed. </span></p>
<p><span class="koboSpan" id="kobo.46.1">This enables clients to format the string as they desire, like so:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.47.1">
const report = (content: string, transformer: (s: string) =&gt; string) =&gt; {
  const header = "=== Header ===";
  const footer = "=== Footer ===";
  return [header, transformer(content), footer].join("\n");
};</span></pre> <p><span class="koboSpan" id="kobo.48.1">For flexibility, we can provide a default transformer, ensuring that those who don’t wish to customize the format can use the function without changes:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.49.1">
const report = (
  content: string,
  transformer: (s: string) =&gt; string = (s) =&gt; s
) =&gt; {
  const header = "=== Header ===";
  const footer = "=== Footer ===";
  return [header, transformer(content), footer].join("\n");
};</span></pre> <p><span class="koboSpan" id="kobo.50.1">The report function </span><a id="_idIndexMarker446"/><span class="koboSpan" id="kobo.51.1">generates a string with a defined header and footer, and the main content in between. </span><span class="koboSpan" id="kobo.51.2">It accepts a content string and an optional transformer function. </span><span class="koboSpan" id="kobo.51.3">If the transformer is provided, it modifies the content; otherwise, the content remains unchanged. </span><span class="koboSpan" id="kobo.51.4">The result is a formatted report with the modified or original content placed between the header and footer. </span><span class="koboSpan" id="kobo.51.5">That’s essentially how powerful HOFs can be, helping us to write more composable code.</span></p>
<p><span class="koboSpan" id="kobo.52.1">Reflecting upon this, an interesting thought emerges – can we incorporate this composable and functional approach into our React applications? </span><span class="koboSpan" id="kobo.52.2">Indeed, we can. </span><span class="koboSpan" id="kobo.52.3">The ability to augment components isn’t just limited to standard functions. </span><span class="koboSpan" id="kobo.52.4">In React, we have </span><strong class="bold"><span class="koboSpan" id="kobo.53.1">higher-order </span></strong><strong class="bold"><span class="koboSpan" id="kobo.54.1">components</span></strong><span class="koboSpan" id="kobo.55.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.56.1">HOC</span><a id="_idTextAnchor259"/><span class="koboSpan" id="kobo.57.1">s</span></strong><span class="koboSpan" id="kobo.58.1">).</span></p>
<h2 id="_idParaDest-144"><a id="_idTextAnchor260"/><span class="koboSpan" id="kobo.59.1">Introducing HOCs</span></h2>
<p><span class="koboSpan" id="kobo.60.1">An HOC is</span><a id="_idIndexMarker447"/><span class="koboSpan" id="kobo.61.1"> essentially a function that accepts a component and returns a new, enhanced version of it. </span><span class="koboSpan" id="kobo.61.2">The principle behind HOCs is straightforward – they allow you to inject additional functionality into an existing component. </span><span class="koboSpan" id="kobo.61.3">This pattern is especially beneficial when you want to reuse certain behaviors across multiple components.</span></p>
<p><span class="koboSpan" id="kobo.62.1">Let’s delve into an example:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.63.1">
const checkAuthorization = () =&gt; {
    // Perform authorization check, e.g., check local storage or send 
        a request to a remote server
}
const withAuthorization = (Component: React.FC): React.FC =&gt; {
  return (props: any) =&gt; {
    const isAuthorized = checkAuthorization();
    return isAuthorized ? </span><span class="koboSpan" id="kobo.63.2">&lt;Component {...props} /&gt; : &lt;Login /&gt;;
  };
};</span></pre> <p><span class="koboSpan" id="kobo.64.1">In this snippet, we </span><a id="_idIndexMarker448"/><span class="koboSpan" id="kobo.65.1">define a function, </span><strong class="source-inline"><span class="koboSpan" id="kobo.66.1">checkAuthorization</span></strong><span class="koboSpan" id="kobo.67.1">, to handle the authorization check. </span><span class="koboSpan" id="kobo.67.2">Then, we create a HOC, </span><strong class="source-inline"><span class="koboSpan" id="kobo.68.1">withAuthorization</span></strong><span class="koboSpan" id="kobo.69.1">. </span><span class="koboSpan" id="kobo.69.2">This HOC takes a component (</span><strong class="source-inline"><span class="koboSpan" id="kobo.70.1">Component</span></strong><span class="koboSpan" id="kobo.71.1">) as its argument and returns a new function. </span><span class="koboSpan" id="kobo.71.2">This returned function, when rendered, will either render the original </span><strong class="source-inline"><span class="koboSpan" id="kobo.72.1">Component</span></strong><span class="koboSpan" id="kobo.73.1"> (if the user is authorized) or a </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">Login</span></strong><span class="koboSpan" id="kobo.75.1"> component (if the user is not authorized).</span></p>
<p><span class="koboSpan" id="kobo.76.1">Now, suppose we have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">ProfileComponent</span></strong><span class="koboSpan" id="kobo.78.1"> that we want to secure. </span><span class="koboSpan" id="kobo.78.2">We can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">withAuthorization</span></strong><span class="koboSpan" id="kobo.80.1"> to create a new, secured version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">ProfileComponent</span></strong><span class="koboSpan" id="kobo.82.1">:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.83.1">
const Profile = withAuthorization(ProfileComponent);</span></pre> <p><span class="koboSpan" id="kobo.84.1">This means that whenever </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">Profile</span></strong><span class="koboSpan" id="kobo.86.1"> is rendered, it will first check whether a user is authorized. </span><span class="koboSpan" id="kobo.86.2">If so, it renders </span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">ProfileComponent</span></strong><span class="koboSpan" id="kobo.88.1">; otherwise, it redirects the user to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">Login</span></strong><span class="koboSpan" id="kobo.90.1"> component.</span></p>
<p><span class="koboSpan" id="kobo.91.1">Now that we’ve seen how HOCs can control access with </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">withAuthorization</span></strong><span class="koboSpan" id="kobo.93.1">, let’s shift our focus to enhancing user interactions. </span><span class="koboSpan" id="kobo.93.2">We’ll delve into an </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">ExpandablePanel</span></strong><span class="koboSpan" id="kobo.95.1"> component, showcasing how HOCs can also manage interactive UI elements and state transi</span><a id="_idTextAnchor261"/><span class="koboSpan" id="kobo.96.1">tions.</span></p>
<h2 id="_idParaDest-145"><a id="_idTextAnchor262"/><span class="koboSpan" id="kobo.97.1">Implementing an ExpandablePanel component</span></h2>
<p><span class="koboSpan" id="kobo.98.1">Let’s kick</span><a id="_idIndexMarker449"/><span class="koboSpan" id="kobo.99.1"> things off with a basic </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">ExpandablePanel</span></strong><span class="koboSpan" id="kobo.101.1"> component. </span><span class="koboSpan" id="kobo.101.2">This component, as the name suggests, consists</span><a id="_idIndexMarker450"/><span class="koboSpan" id="kobo.102.1"> of a title and a content area. </span><span class="koboSpan" id="kobo.102.2">Initially, the content area is collapsed, but a click on the title expands it to reveal the content.</span></p>
<figure>
<div class="IMG---Figure" id="_idContainer054">
<span class="koboSpan" id="kobo.103.1"><img alt="Figure 10.1: An expandable panel" src="image/B31103_10_01.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.104.1">Figure 10.1: An expandable panel</span></figcaption> </figure>
<p><span class="koboSpan" id="kobo.105.1">The code for</span><a id="_idIndexMarker451"/><span class="koboSpan" id="kobo.106.1"> such a </span><a id="_idIndexMarker452"/><span class="koboSpan" id="kobo.107.1">component is straightforward:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.108.1">
export type PanelProps = {
  heading: string;
  content: ReactNode;
};
const ExpandablePanel = ({ heading, content }: PanelProps) =&gt; {
  const [isOpen, setIsOpen] = useState&lt;boolean&gt;(false);
  return (
    &lt;article&gt;
      &lt;header onClick={() =&gt; setIsOpen((isOpen) =&gt; 
       !isOpen)}&gt;{heading}&lt;/header&gt;
      {isOpen &amp;&amp; &lt;section&gt;{content}&lt;/section&gt;}
    &lt;/article&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.109.1">Now, suppose we want to jazz it up a bit, making the panel expand automatically when rendered and then</span><a id="_idIndexMarker453"/><span class="koboSpan" id="kobo.110.1"> collapse </span><a id="_idIndexMarker454"/><span class="koboSpan" id="kobo.111.1">after a few seconds. </span><span class="koboSpan" id="kobo.111.2">Here’s how we could adjust the code to achieve that:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.112.1">
const AutoCloseExpandablePanel = ({ heading, content }: PanelProps) =&gt; {
  const [isOpen, setIsOpen] = useState&lt;boolean&gt;(true);
  useEffect(() =&gt; {
    const id = setTimeout(() =&gt; {
      setIsOpen(false);
    }, 3000);
    return () =&gt; {
      clearTimeout(id);
    };
  }, []);
  return (
    &lt;article&gt;
      &lt;header onClick={() =&gt; setIsOpen((isOpen) =&gt; 
       !isOpen)}&gt;{heading}&lt;/header&gt;
      {isOpen &amp;&amp; &lt;section&gt;{content}&lt;/section&gt;}
    &lt;/article&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.113.1">In this revised version, we initialize </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">isOpen</span></strong><span class="koboSpan" id="kobo.115.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">true</span></strong><span class="koboSpan" id="kobo.117.1"> so that the panel starts as expanded. </span><span class="koboSpan" id="kobo.117.2">Then, we utilize </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">useEffect</span></strong><span class="koboSpan" id="kobo.119.1"> to set a timer that collapses the panel after 3,000 milliseconds (3 seconds).</span></p>
<p><span class="koboSpan" id="kobo.120.1">This</span><a id="_idIndexMarker455"/><span class="koboSpan" id="kobo.121.1"> pattern of auto-collapsing</span><a id="_idIndexMarker456"/><span class="koboSpan" id="kobo.122.1"> components is quite common in UI development – think of notifications, alerts, or tooltips that disappear after a while. </span><span class="koboSpan" id="kobo.122.2">To promote code reusability, let’s extract this auto-collapsing logic into a HOC:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.123.1">
interface Toggleable {
  isOpen: boolean;
  toggle: () =&gt; void;
}
const withAutoClose = &lt;T extends Partial&lt;Toggleable&gt;&gt;(
  Component: React.FC&lt;T&gt;,
  duration: number = 2000
) =&gt; (props: T) =&gt; {
  const [show, setShow] = useState&lt;boolean&gt;(true);
  useEffect(() =&gt; {
    if (show) {
      const timerId = setTimeout(() =&gt; setShow(false), duration);
      return () =&gt; clearTimeout(timerId);
    }
  }, [show]);
  return (
    &lt;Component
      {…props}
      isOpen={show}
      toggle={() =&gt; setShow((show) =&gt; !show)}
    /&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.124.1">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">withAutoClose</span></strong><span class="koboSpan" id="kobo.126.1">, we </span><a id="_idIndexMarker457"/><span class="koboSpan" id="kobo.127.1">define a</span><a id="_idIndexMarker458"/><span class="koboSpan" id="kobo.128.1"> generic HOC that adds auto-closing functionality to any component. </span><span class="koboSpan" id="kobo.128.2">This HOC accepts a duration parameter to customize the auto-close delay, defaulting to 2,000 milliseconds (2 seconds).</span></p>
<p><span class="koboSpan" id="kobo.129.1">To ensure a smooth integration, we can also extend </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">PanelProps</span></strong><span class="koboSpan" id="kobo.131.1"> to include optional </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">Toggleable</span></strong><span class="koboSpan" id="kobo.133.1"> properties:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.134.1">
type PanelProps = {
  heading: string;
  content: ReactNode;
}  &amp; Partial&lt;Toggleable&gt;;</span></pre> <p><span class="koboSpan" id="kobo.135.1">Now, we can refactor </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">ExpandablePanel</span></strong><span class="koboSpan" id="kobo.137.1"> to accept </span><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">isOpen</span></strong><span class="koboSpan" id="kobo.139.1"> and toggle props from </span><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">withAutoClose</span></strong><span class="koboSpan" id="kobo.141.1">:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.142.1">
const ExpandablePanel = ({
  isOpen,
  toggle,
  heading,
  content,
}: PanelProps) =&gt; {
  return (
    &lt;article&gt;
      &lt;header onClick={toggle}&gt;{heading}&lt;/header&gt;
      {isOpen &amp;&amp; &lt;section&gt;{content}&lt;/section&gt;}
    &lt;/article&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.143.1">With</span><a id="_idIndexMarker459"/><span class="koboSpan" id="kobo.144.1"> this setup, creating an auto-closing version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">ExpandablePanel</span></strong><span class="koboSpan" id="kobo.146.1"> is a breeze:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.147.1">
export default withAutoClose(ExpandablePanel, 3000);</span></pre> <p><span class="koboSpan" id="kobo.148.1">And guess what? </span><span class="koboSpan" id="kobo.148.2">The </span><a id="_idIndexMarker460"/><span class="koboSpan" id="kobo.149.1">auto-closing logic we’ve encapsulated in </span><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">withAutoClose</span></strong><span class="koboSpan" id="kobo.151.1"> can be reused across various components:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.152.1">
const AutoDismissToast = withAutoClose(Toast, 3000);
const TimedTooltip = withAutoClose(Tooltip, 3000);</span></pre> <p><span class="koboSpan" id="kobo.153.1">The versatility of HOCs shines when it comes to composition – the ability to apply one HOC to the result of another. </span><span class="koboSpan" id="kobo.153.2">This capability aligns well with the principle of function composition in functional programming.</span></p>
<p><span class="koboSpan" id="kobo.154.1">Let’s consider another HOC, </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">withKeyboardToggle</span></strong><span class="koboSpan" id="kobo.156.1">, which augments a panel’s behavior to respond to keyboard inputs to toggle the panel’s expanded/collapsed state. </span><span class="koboSpan" id="kobo.156.2">Here’s the code for </span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">withKeyboardToggle</span></strong><span class="koboSpan" id="kobo.158.1">:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.159.1">
const noop = () =&gt; {};
const withKeyboardToggle =
  &lt;T extends Partial&lt;Toggleable&gt;&gt;(Component: React.FC&lt;T&gt;) =&gt;
  (props: T) =&gt; {
    const divRef = useRef&lt;HTMLDivElement&gt;(null);
    const handleKeyDown = (event: KeyboardEvent&lt;HTMLDivElement&gt;) =&gt; {
      if (event.key === "Enter" || event.key === " ") {
        event.preventDefault();
        (props.toggle ?? </span><span class="koboSpan" id="kobo.159.2">noop)();
      }
      if (event.key === "Escape" &amp;&amp; divRef.current) {
        divRef.current.blur();
      }
    };
    return (
      &lt;div onKeyDown={handleKeyDown} tabIndex={0} ref={divRef}&gt;
        &lt;Component {...props} /&gt;
      &lt;/div&gt;
    );
  };
export default withKeyboardToggle;</span></pre> <p><span class="koboSpan" id="kobo.160.1">In</span><a id="_idIndexMarker461"/><span class="koboSpan" id="kobo.161.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">withKeyboardToggle</span></strong><span class="koboSpan" id="kobo.163.1"> HOC, a reference (</span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">divRef</span></strong><span class="koboSpan" id="kobo.165.1">) is created for the wrapping </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">div</span></strong><span class="koboSpan" id="kobo.167.1"> to enable </span><a id="_idIndexMarker462"/><span class="koboSpan" id="kobo.168.1">keyboard interactions. </span><span class="koboSpan" id="kobo.168.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">handleKeyDown</span></strong><span class="koboSpan" id="kobo.170.1"> function defines the behavior for the </span><i class="italic"><span class="koboSpan" id="kobo.171.1">Enter</span></i><span class="koboSpan" id="kobo.172.1">, </span><i class="italic"><span class="koboSpan" id="kobo.173.1">Space</span></i><span class="koboSpan" id="kobo.174.1">, and </span><i class="italic"><span class="koboSpan" id="kobo.175.1">Escape</span></i><span class="koboSpan" id="kobo.176.1"> keys – the </span><i class="italic"><span class="koboSpan" id="kobo.177.1">Enter</span></i><span class="koboSpan" id="kobo.178.1"> or </span><i class="italic"><span class="koboSpan" id="kobo.179.1">Space</span></i><span class="koboSpan" id="kobo.180.1"> keys toggle the panel’s state, while the </span><i class="italic"><span class="koboSpan" id="kobo.181.1">Escape</span></i><span class="koboSpan" id="kobo.182.1"> key removes focus from the panel. </span><span class="koboSpan" id="kobo.182.2">These keyboard event handlers allow the wrapped component to respond to keyboard navigation.</span></p>
<p><span class="koboSpan" id="kobo.183.1">Now, let’s compose </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">withKeyboardToggle</span></strong><span class="koboSpan" id="kobo.185.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">withAutoClose</span></strong><span class="koboSpan" id="kobo.187.1"> together to create a new component, </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">AccessibleAutoClosePanel</span></strong><span class="koboSpan" id="kobo.189.1">:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.190.1">
const AccessibleAutoClosePanel = withAutoClose(withKeyboardToggle(ExpandablePanel), 2000);</span></pre> <p><span class="koboSpan" id="kobo.191.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">withAutoClose(withKeyboardToggle(ExpandablePanel), 2000);</span></strong><span class="koboSpan" id="kobo.193.1"> expression, </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">withKeyboardToggle</span></strong><span class="koboSpan" id="kobo.195.1"> is first applied to </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">ExpandablePanel</span></strong><span class="koboSpan" id="kobo.197.1">, enhancing it with keyboard toggle capability. </span><span class="koboSpan" id="kobo.197.2">The result is then fed into </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">withAutoClose</span></strong><span class="koboSpan" id="kobo.199.1">, which further enhances the component to auto-close after a 2,000-millisecond delay. </span><span class="koboSpan" id="kobo.199.2">This chaining of HOCs results in a new component, </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">AccessibleAutoClosePanel</span></strong><span class="koboSpan" id="kobo.201.1">, which inherits both the keyboard toggle and auto-close behaviors.</span></p>
<p><span class="koboSpan" id="kobo.202.1">This is a </span><a id="_idIndexMarker463"/><span class="koboSpan" id="kobo.203.1">vivid example of how HOCs can</span><a id="_idIndexMarker464"/><span class="koboSpan" id="kobo.204.1"> be nested and composed to build more complex behavior from simpler, single-responsibility components, which is illustrated further in </span><i class="italic"><span class="koboSpan" id="kobo.205.1">Figure 10</span></i><i class="italic"><span class="koboSpan" id="kobo.206.1">.2</span></i><span class="koboSpan" id="kobo.207.1">:</span></p>
<figure>
<div class="IMG---Figure" id="_idContainer055">
<span class="koboSpan" id="kobo.208.1"><img alt="Figure 10.2: A Higher-Order Component" src="image/B31103_10_02.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.209.1">Figure 10.2: A Higher-Order Component</span></figcaption> </figure>
<p><span class="koboSpan" id="kobo.210.1">If you have some background in object-oriented programming, this concept might resonate with you, as it aligns with</span><a id="_idIndexMarker465"/><span class="koboSpan" id="kobo.211.1"> the </span><strong class="bold"><span class="koboSpan" id="kobo.212.1">Decorator</span></strong><span class="koboSpan" id="kobo.213.1"> design pattern. </span><span class="koboSpan" id="kobo.213.2">If you’re not familiar, it dynamically adds </span><a id="_idIndexMarker466"/><span class="koboSpan" id="kobo.214.1">behaviors to objects by </span><a id="_idIndexMarker467"/><span class="koboSpan" id="kobo.215.1">wrapping them in additional objects, rather than altering their structure. </span><span class="koboSpan" id="kobo.215.2">This allows for greater flexibility than subclassing, as it extends functionality without modifying the original object.</span></p>
<p><span class="koboSpan" id="kobo.216.1">Now, while HOCs remain beneficial in various scenarios for both class components and functional components, React Hooks offer a more lightweight approach to achieving composition. </span><span class="koboSpan" id="kobo.216.2">Le</span><a id="_idTextAnchor263"/><span class="koboSpan" id="kobo.217.1">t’s look at Hooks next.</span></p>
<h1 id="_idParaDest-146"><a id="_idTextAnchor264"/><span class="koboSpan" id="kobo.218.1">Exploring React Hooks</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.219.1">Hooks</span></strong><span class="koboSpan" id="kobo.220.1"> provide a</span><a id="_idIndexMarker468"/><span class="koboSpan" id="kobo.221.1"> means to extract stateful logic from a component, enabling its independent testing and reuse. </span><span class="koboSpan" id="kobo.221.2">They pave the way for reutilizing stateful logic without altering your component hierarchy. </span><span class="koboSpan" id="kobo.221.3">Essentially, Hooks let you “hook into” React state and other life cycle features from function components.</span></p>
<p><span class="koboSpan" id="kobo.222.1">Following on from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">ExpandablePanel</span></strong><span class="koboSpan" id="kobo.224.1"> component example, let’s look at this code:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.225.1">
const useAutoClose = (duration: number) =&gt; {
  const [isOpen, setIsOpen] = useState&lt;boolean&gt;(true);
  useEffect(() =&gt; {
    if (isOpen) {
      const timerId = setTimeout(() =&gt; setIsOpen(false), duration);
      return () =&gt; clearTimeout(timerId);
    }
  }, [duration, isOpen]);
  const toggle = () =&gt; setIsOpen((show) =&gt; !show);
  return { isOpen, toggle };
};
export default useAutoClose;</span></pre> <p><span class="koboSpan" id="kobo.226.1">In</span><a id="_idIndexMarker469"/><span class="koboSpan" id="kobo.227.1"> this </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">useAutoClose</span></strong><span class="koboSpan" id="kobo.229.1"> Hook, we create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">isOpen</span></strong><span class="koboSpan" id="kobo.231.1"> state and a function toggle to switch the state. </span><span class="koboSpan" id="kobo.231.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">useEffect</span></strong><span class="koboSpan" id="kobo.233.1"> function sets a timer to change </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">isOpen</span></strong><span class="koboSpan" id="kobo.235.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">false</span></strong><span class="koboSpan" id="kobo.237.1"> after a specified duration, but only if </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">isOpen</span></strong><span class="koboSpan" id="kobo.239.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">true</span></strong><span class="koboSpan" id="kobo.241.1">. </span><span class="koboSpan" id="kobo.241.2">It also cleans up the timer to prevent memory leaks.</span></p>
<p><span class="koboSpan" id="kobo.242.1">Now, to integrate this Hook into our </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">ExpandablePanel</span></strong><span class="koboSpan" id="kobo.244.1">, minimal amendments are needed:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.245.1">
const ExpandablePanel = ({ heading, content }: PanelProps) =&gt; {
  const { isOpen, toggle } = useAutoClose(2000);
  return (
    &lt;article&gt;
      &lt;header onClick={toggle}&gt;{heading}&lt;/header&gt;
      {isOpen &amp;&amp; &lt;section&gt;{content}&lt;/section&gt;}
    &lt;/article&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.246.1">Here, we deleted the passed-in </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">isOpen</span></strong><span class="koboSpan" id="kobo.248.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">toggle</span></strong><span class="koboSpan" id="kobo.250.1"> props and utilized the return value from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">useAutoClose</span></strong><span class="koboSpan" id="kobo.252.1"> Hook, seamlessly incorporating the auto-close functionality.</span></p>
<p><span class="koboSpan" id="kobo.253.1">Next, to incorporate keyboard navigation, we define another Hook, </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">useKeyboard</span></strong><span class="koboSpan" id="kobo.255.1">, which captures key events to toggle the panel:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.256.1">
const useKeyboard = (toggle: () =&gt; void) =&gt; {
  const handleKeyDown = (event: KeyboardEvent) =&gt; {
    if (event.key === "Enter" || event.key === " ") {
      event.preventDefault();
      toggle();
    }
  };
  return { handleKeyDown };
};</span></pre> <p><span class="koboSpan" id="kobo.257.1">Then, embedding </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">useKeyboard</span></strong><span class="koboSpan" id="kobo.259.1"> within </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">ExpandablePanel</span></strong><span class="koboSpan" id="kobo.261.1"> is </span><a id="_idIndexMarker470"/><span class="koboSpan" id="kobo.262.1">straightforward:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.263.1">
const ExpandablePanel = ({ heading, content }: PanelProps) =&gt; {
  const { isOpen, toggle } = useAutoClose(2000);
  const { handleKeyDown } = useKeyboard(toggle);
  return (
    &lt;article onKeyDown={handleKeyDown} tabIndex={0}&gt;
      &lt;header onClick={toggle}&gt;{heading}&lt;/header&gt;
      {isOpen &amp;&amp; &lt;section&gt;{content}&lt;/section&gt;}
    &lt;/article&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.264.1">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">handleKeyDown</span></strong><span class="koboSpan" id="kobo.266.1"> from </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">useKeyboard</span></strong><span class="koboSpan" id="kobo.268.1"> is employed to detect key presses, enhancing our component with keyboard interactivity.</span></p>
<p><span class="koboSpan" id="kobo.269.1">In </span><i class="italic"><span class="koboSpan" id="kobo.270.1">Figure 10</span></i><i class="italic"><span class="koboSpan" id="kobo.271.1">.3</span></i><span class="koboSpan" id="kobo.272.1">, you can observe how the Hooks link with the underlying </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">ExpandablePanel</span></strong><span class="koboSpan" id="kobo.274.1">, contrasting the HOC scenario where the component is wrapped:</span></p>
<figure>
<div class="IMG---Figure" id="_idContainer056">
<span class="koboSpan" id="kobo.275.1"><img alt="Figure 10.3: Using alternative Hooks" src="image/B31103_10_03.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.276.1">Figure 10.3: Using alternative Hooks</span></figcaption> </figure>
<p><span class="koboSpan" id="kobo.277.1">Hooks</span><a id="_idIndexMarker471"/><span class="koboSpan" id="kobo.278.1"> embody a neat package of reusable logic, isolated from the component yet easily </span><a id="_idIndexMarker472"/><span class="koboSpan" id="kobo.279.1">integrated. </span><span class="koboSpan" id="kobo.279.2">Unlike the wrapping approach of HOCs, Hooks offer a plugin mechanism, making them lightweight and well-managed by React. </span><span class="koboSpan" id="kobo.279.3">This characteristic of Hooks not only promotes code modularity but also facilitates a cleaner and more intuitive way to enrich our components with additional functionalities.</span></p>
<p><span class="koboSpan" id="kobo.280.1">However, be aware that Hooks offer more versatility than initially apparent. </span><span class="koboSpan" id="kobo.280.2">They’re not just for managing UI-related state but are also effective for handling UI side effects, such as data fetching and global event handling (such as page-level keyboard shortcuts). </span><span class="koboSpan" id="kobo.280.3">We have seen how to use them for keyboard event handlers, so now, let’s explore how Hooks can s</span><a id="_idTextAnchor265"/><span class="koboSpan" id="kobo.281.1">treamline network requests.</span></p>
<h2 id="_idParaDest-147"><a id="_idTextAnchor266"/><span class="koboSpan" id="kobo.282.1">Unveiling remote data fetching</span></h2>
<p><span class="koboSpan" id="kobo.283.1">In previous chapters, we leveraged </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">useEffect</span></strong><span class="koboSpan" id="kobo.285.1"> for data fetching, a prevalent approach. </span><span class="koboSpan" id="kobo.285.2">When</span><a id="_idIndexMarker473"/><span class="koboSpan" id="kobo.286.1"> retrieving data from a remote server, it typically necessitates the introduction of three distinct states – </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">loading</span></strong><span class="koboSpan" id="kobo.288.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">error</span></strong><span class="koboSpan" id="kobo.290.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">data</span></strong><span class="koboSpan" id="kobo.292.1">.</span></p>
<p><span class="koboSpan" id="kobo.293.1">Here’s a method</span><a id="_idIndexMarker474"/><span class="koboSpan" id="kobo.294.1"> to implement these states:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.295.1">
//...
</span><span class="koboSpan" id="kobo.295.2">  const [loading, setLoading] = useState&lt;boolean&gt;(false);
  const [data, setData] = useState&lt;Item[] | null&gt;(null);
  const [error, setError] = useState&lt;Error | undefined&gt;(undefined);
  useEffect(() =&gt; {
    const fetchData = async () =&gt; {
      setLoading(true);
      try {
        const response = await fetch("/api/users");
        if (!response.ok) {
          const error = await response.json();
          throw new Error(`Error: ${error.error || response.status}`);
        }
        const data = await response.json();
        setData(data);
      } catch (e) {
        setError(e as Error);
      } finally {
        setLoading(false);
      }
    };
    fetchData();
  }, []);
//...</span></pre> <p><span class="koboSpan" id="kobo.296.1">In the </span><a id="_idIndexMarker475"/><span class="koboSpan" id="kobo.297.1">preceding code, we use React Hooks to manage asynchronous data fetching, initializing states for </span><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">loading</span></strong><span class="koboSpan" id="kobo.299.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">data</span></strong><span class="koboSpan" id="kobo.301.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">error</span></strong><span class="koboSpan" id="kobo.303.1">. </span><span class="koboSpan" id="kobo.303.2">Inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">useEffect</span></strong><span class="koboSpan" id="kobo.305.1">, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">fetchData</span></strong><span class="koboSpan" id="kobo.307.1"> function attempts to retrieve user data from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">"/api/users"</span></strong><span class="koboSpan" id="kobo.309.1"> endpoint. </span><span class="koboSpan" id="kobo.309.2">If successful, the data is stored; if not, an error is recorded. </span><span class="koboSpan" id="kobo.309.3">Regardless of the outcome, the loading state is updated to reflect completion. </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">useEffect</span></strong><span class="koboSpan" id="kobo.311.1"> runs only once, similar to the compo</span><a id="_idTextAnchor267"/><span class="koboSpan" id="kobo.312.1">nent’s initial mounting phase.</span></p>
<h2 id="_idParaDest-148"><a id="_idTextAnchor268"/><span class="koboSpan" id="kobo.313.1">Refactoring for elegance and reusability</span></h2>
<p><span class="koboSpan" id="kobo.314.1">Incorporating fetching logic directly within our component can work, but it’s not the most elegant or reusable approach. </span><span class="koboSpan" id="kobo.314.2">Let’s refactor this </span><a id="_idIndexMarker476"/><span class="koboSpan" id="kobo.315.1">by extracting the fetching logic into a separate function:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.316.1">
const fetchUsers = async () =&gt; {
  const response = await fetch("/api/users");
  if (!response.ok) {
    const error = await response.json();
    throw new Error('Something went wrong');
  }
  return await response.json();
};</span></pre> <p><span class="koboSpan" id="kobo.317.1">With the </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">fetchUsers</span></strong><span class="koboSpan" id="kobo.319.1"> function in place, we can take a step further by abstracting our fetching</span><a id="_idIndexMarker477"/><span class="koboSpan" id="kobo.320.1"> logic into a generic Hook. </span><span class="koboSpan" id="kobo.320.2">This Hook will accept a fetch function and manage the associated </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">loading</span></strong><span class="koboSpan" id="kobo.322.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">error</span></strong><span class="koboSpan" id="kobo.324.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">data</span></strong><span class="koboSpan" id="kobo.326.1"> states:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.327.1">
const useService = &lt;T&gt;(fetch: () =&gt; Promise&lt;T&gt;) =&gt; {
  const [loading, setLoading] = useState&lt;boolean&gt;(false);
  const [data, setData] = useState&lt;T | null&gt;(null);
  const [error, setError] = useState&lt;Error | undefined&gt;(undefined);
  useEffect(() =&gt; {
    const fetchData = async () =&gt; {
      setLoading(true);
      try {
        const data = await fetch();
        setData(data);
      } catch(e) {
        setError(e as Error);
      } finally {
        setLoading(false);
      }
    };
    fetchData();
  }, [fetch]);
  return {
    loading,
    error,
    data,
  };
}</span></pre> <p><span class="koboSpan" id="kobo.328.1">Now, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">useService</span></strong><span class="koboSpan" id="kobo.330.1"> Hook emerges as a reusable solution to fetch data across our application. </span><span class="koboSpan" id="kobo.330.2">It’s a </span><a id="_idIndexMarker478"/><span class="koboSpan" id="kobo.331.1">neat abstraction that we can employ to fetch various types of data, as seen here:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.332.1">
const { loading, error, data } = useService(fetchProducts);
//or
const { loading, error, data } = useService(fetchTickets);</span></pre> <p><span class="koboSpan" id="kobo.333.1">With this refactoring, we’ve not only simplified our data fetching logic but also made it reusable across different scenarios in our application. </span><span class="koboSpan" id="kobo.333.2">This sets a solid foundation as we continue to enhance our drop-down component and delve deeper into more advanced features and optimizations.</span></p>
<p><span class="koboSpan" id="kobo.334.1">As we have explored Hooks and their capabilities in managing state and logic, let’s apply this knowledge to build a more complex UI component from scratch — a drop-down list. </span><span class="koboSpan" id="kobo.334.2">This exercise will not only reinforce our understanding of Hooks but also demonstrate their practical application in creating interactive UI elements.</span></p>
<p><span class="koboSpan" id="kobo.335.1">We’ll start with a basic version of a drop-down list and then gradually introduce more features to make it functional and user-friendly. </span><span class="koboSpan" id="kobo.335.2">This process will also set the stage for a later discussion on headless components, showcasing a design pattern that further abstracts and manages </span><a id="_idTextAnchor269"/><span class="koboSpan" id="kobo.336.1">state and logic in UI components.</span></p>
<h1 id="_idParaDest-149"><a id="_idTextAnchor270"/><span class="koboSpan" id="kobo.337.1">Developing a drop-down list component</span></h1>
<p><span class="koboSpan" id="kobo.338.1">A drop-down list is a</span><a id="_idIndexMarker479"/><span class="koboSpan" id="kobo.339.1"> common component used in many places. </span><span class="koboSpan" id="kobo.339.2">Although there’s a native select component for basic use cases, a more advanced version</span><a id="_idIndexMarker480"/><span class="koboSpan" id="kobo.340.1"> offering more control over each option provides a better user experience.</span></p>
<figure>
<div class="IMG---Figure" id="_idContainer057">
<span class="koboSpan" id="kobo.341.1"><img alt="Figure 10.4: A drop-down list component" src="image/B31103_10_04.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.342.1">Figure 10.4: A drop-down list component</span></figcaption> </figure>
<p><span class="koboSpan" id="kobo.343.1">When creating one from scratch, a complete implementation requires more effort than it appears at first glance. </span><span class="koboSpan" id="kobo.343.2">It’s essential to consider keyboard navigation, accessibility (for instance, screen reader compatibility), and usability on mobile devices, among others.</span></p>
<p><span class="koboSpan" id="kobo.344.1">We’ll begin with a simple, desktop version that only supports mouse clicks, gradually building in more features to make it realistic. </span><span class="koboSpan" id="kobo.344.2">Note that the goal here is to reveal a few software design patterns rather than teach you how to build a drop-down list for production use (actually, I don’t recommend doing this from scratch and would instead suggest using more mature libraries).</span></p>
<p><span class="koboSpan" id="kobo.345.1">Basically, we need an element (let’s call it a trigger) for the user to click, and a state to control the show and hide actions of the list panel. </span><span class="koboSpan" id="kobo.345.2">Initially, we hide the panel, and when the trigger is clicked, we show the list panel. </span><span class="koboSpan" id="kobo.345.3">Here is the code:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.346.1">
import { useState } from "react";
interface Item {
  icon: string;
  text: string;
  id: string;
  description: string;
}
type DropdownProps = {
  items: Item[];
};
const Dropdown = ({ items }: DropdownProps) =&gt; {
  const [isOpen, setIsOpen] = useState(false);
  const [selectedItem, setSelectedItem] = useState&lt;Item | null&gt;(null);
  return (
    &lt;div className="dropdown"&gt;
      &lt;div className="trigger" tabIndex={0} onClick={() =&gt; 
       setIsOpen(!isOpen)}&gt;
        &lt;span className="selection"&gt;
          {selectedItem ? </span><span class="koboSpan" id="kobo.346.2">selectedItem.text : "Select an item..."}
        &lt;/span&gt;
      &lt;/div&gt;
      {isOpen &amp;&amp; (
        &lt;div className="dropdown-menu"&gt;
          {items.map((item) =&gt; (
            &lt;div
              key={item.id}
              onClick={() =&gt; setSelectedItem(item)}
              className="item-container"
            &gt;
              &lt;img src={item.icon} alt={item.text} /&gt;
              &lt;div className="details"&gt;
                &lt;div&gt;{item.text}&lt;/div&gt;
                &lt;small&gt;{item.description}&lt;/small&gt;
              &lt;/div&gt;
            &lt;/div&gt;
          ))}
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.347.1">In the code, we’ve set</span><a id="_idIndexMarker481"/><span class="koboSpan" id="kobo.348.1"> up the basic structure for our drop-down component. </span><span class="koboSpan" id="kobo.348.2">Using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">useState</span></strong><span class="koboSpan" id="kobo.350.1"> Hook, we manage the </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">isOpen</span></strong><span class="koboSpan" id="kobo.352.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">selectedItem</span></strong><span class="koboSpan" id="kobo.354.1"> states to control the dropdown’s behavior. </span><span class="koboSpan" id="kobo.354.2">A simple click on the trigger toggles the drop-down menu, while selecting an item updates the </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">selectedItem</span></strong><span class="koboSpan" id="kobo.356.1"> state.</span></p>
<p><span class="koboSpan" id="kobo.357.1">Let’s break down the component into smaller, manageable pieces to see it more clearly. </span><span class="koboSpan" id="kobo.357.2">We’ll start by extracting a </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">Trigger</span></strong><span class="koboSpan" id="kobo.359.1"> component to handle user clicks:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.360.1">
const Trigger = ({
  label,
  onClick,
}: {
  label: string;
  onClick: () =&gt; void;
}) =&gt; {
  return (
    &lt;div className="trigger" tabIndex={0} onClick={onClick}&gt;
      &lt;span className="selection"&gt;{label}&lt;/span&gt;
    &lt;/div&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.361.1">Similarly, we’ll </span><a id="_idIndexMarker482"/><span class="koboSpan" id="kobo.362.1">extract a </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">DropdownMenu</span></strong><span class="koboSpan" id="kobo.364.1"> component to render the list of items:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.365.1">
const DropdownMenu = ({
  items,
  onItemClick,
}: {
  items: Item[];
  onItemClick: (item: Item) =&gt; void;
}) =&gt; {
  return (
    &lt;div className="dropdown-menu"&gt;
      {items.map((item) =&gt; (
        &lt;div
          key={item.id}
          onClick={() =&gt; onItemClick(item)}
          className="item-container"
        &gt;
          &lt;img src={item.icon} alt={item.text} /&gt;
          &lt;div className="details"&gt;
            &lt;div&gt;{item.text}&lt;/div&gt;
            &lt;small&gt;{item.description}&lt;/small&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      ))}
    &lt;/div&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.366.1">Now, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">Dropdown</span></strong><span class="koboSpan" id="kobo.368.1"> component, we simply use these two components, passing in the corresponding state, turning </span><a id="_idIndexMarker483"/><span class="koboSpan" id="kobo.369.1">them into purely controlled components (stateless components):</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.370.1">
const Dropdown = ({ items }: DropdownProps) =&gt; {
  const [isOpen, setIsOpen] = useState(false);
  const [selectedItem, setSelectedItem] = useState&lt;Item | null&gt;(null);
  return (
    &lt;div className="dropdown"&gt;
      &lt;Trigger
        label={selectedItem ? </span><span class="koboSpan" id="kobo.370.2">selectedItem.text : "Select an item..."}
        onClick={() =&gt; setIsOpen(!isOpen)}
      /&gt;
      {isOpen &amp;&amp; &lt;DropdownMenu items={items} 
       onItemClick={setSelectedItem} /&gt;}
    &lt;/div&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.371.1">In this updated</span><a id="_idIndexMarker484"/><span class="koboSpan" id="kobo.372.1"> code structure, we’ve separated concerns by creating specialized components for different parts of the dropdown, making the code more organized and easier to manage. </span><span class="koboSpan" id="kobo.372.2">We can see the result here:</span></p>
<p class="IMG---Figure"><a id="_idTextAnchor271"/></p>
<figure>
<div class="IMG---Figure" id="_idContainer058">
<span class="koboSpan" id="kobo.373.1"><img alt="Figure 10.5: A native implementation list" src="image/B31103_10_05.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.374.1">Figure 10.5: A native implementation list</span></figcaption> </figure>
<p><span class="koboSpan" id="kobo.375.1">As you can see in </span><i class="italic"><span class="koboSpan" id="kobo.376.1">Figure 10</span></i><i class="italic"><span class="koboSpan" id="kobo.377.1">.5</span></i><span class="koboSpan" id="kobo.378.1">, the basic drop-down list appears, but that’s only a small part of the </span><a id="_idIndexMarker485"/><span class="koboSpan" id="kobo.379.1">whole drop-down list features. </span><span class="koboSpan" id="kobo.379.2">Keyboard navigation, for example, is a necessary feature for an accessible component, which we will implement next.</span></p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor272"/><span class="koboSpan" id="kobo.380.1">Implementing keyboard navigation</span></h2>
<p><span class="koboSpan" id="kobo.381.1">Incorporating </span><a id="_idIndexMarker486"/><span class="koboSpan" id="kobo.382.1">keyboard navigation within our drop-down list enhances the user experience by providing an alternative to mouse interactions. </span><span class="koboSpan" id="kobo.382.2">This is particularly important for accessibility and offers a seamless navigation experience on a web page. </span><span class="koboSpan" id="kobo.382.3">Let’s explore how we can achieve this using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">onKeyDown</span></strong><span class="koboSpan" id="kobo.384.1"> event handler.</span></p>
<p><span class="koboSpan" id="kobo.385.1">Initially, we’ll attach a </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">handleKeyDown</span></strong><span class="koboSpan" id="kobo.387.1"> function to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">onKeyDown</span></strong><span class="koboSpan" id="kobo.389.1"> event in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">Dropdown</span></strong><span class="koboSpan" id="kobo.391.1"> component. </span><span class="koboSpan" id="kobo.391.2">Here, we utilize a </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">switch</span></strong><span class="koboSpan" id="kobo.393.1"> statement to determine the specific key pressed and perform actions accordingly. </span><span class="koboSpan" id="kobo.393.2">For instance, when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">Enter</span></strong><span class="koboSpan" id="kobo.395.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">Space</span></strong><span class="koboSpan" id="kobo.397.1"> key is pressed, the dropdown is toggled. </span><span class="koboSpan" id="kobo.397.2">Similarly, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">ArrowDown</span></strong><span class="koboSpan" id="kobo.399.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">ArrowUp</span></strong><span class="koboSpan" id="kobo.401.1"> keys allow navigation through the list items, cycling back to the start or end of the list when necessary:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.402.1">
const Dropdown = ({ items }: DropdownProps) =&gt; {
  // ... </span><span class="koboSpan" id="kobo.402.2">previous state variables ...
</span><span class="koboSpan" id="kobo.402.3">  const handleKeyDown = (e: React.KeyboardEvent) =&gt; {
    switch (e.key) {
      // ... </span><span class="koboSpan" id="kobo.402.4">case blocks ...
</span><span class="koboSpan" id="kobo.402.5">    }
  };
  return (
    &lt;div className="dropdown" onKeyDown={handleKeyDown}&gt;
      {/* ... </span><span class="koboSpan" id="kobo.402.6">rest of the JSX ... </span><span class="koboSpan" id="kobo.402.7">*/}
    &lt;/div&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.403.1">Additionally, we have updated our </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">DropdownMenu</span></strong><span class="koboSpan" id="kobo.405.1"> component to accept a </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">selectedIndex</span></strong><span class="koboSpan" id="kobo.407.1"> prop. </span><span class="koboSpan" id="kobo.407.2">This prop is used to apply a highlighted style and set the aria-selected </span><a id="_idIndexMarker487"/><span class="koboSpan" id="kobo.408.1">attribute to the currently selected item, enhancing the visual feedback and accessibility:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.409.1">
const DropdownMenu = ({
  items,
  selectedIndex,
  onItemClick,
}: {
  items: Item[];
  selectedIndex: number;
  onItemClick: (item: Item) =&gt; void;
}) =&gt; {
  return (
    &lt;div className="dropdown-menu" role="listbox"&gt;
      {/* ... </span><span class="koboSpan" id="kobo.409.2">rest of the JSX ... </span><span class="koboSpan" id="kobo.409.3">*/}
    &lt;/div&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.410.1">Moving forward, we can encapsulate the state and keyboard event handling logic within a custom Hook named </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">useDropdown</span></strong><span class="koboSpan" id="kobo.412.1">. </span><span class="koboSpan" id="kobo.412.2">This Hook returns an object containing the necessary states and functions, which can be destructured and used within our </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">Dropdown</span></strong><span class="koboSpan" id="kobo.414.1"> component, keeping it clean and maintainable:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.415.1">
const useDropdown = (items: Item[]) =&gt; {
  // ... </span><span class="koboSpan" id="kobo.415.2">state variables ...
</span><span class="koboSpan" id="kobo.415.3">  const handleKeyDown = (e: React.KeyboardEvent) =&gt; {
    // ... </span><span class="koboSpan" id="kobo.415.4">switch statement ...
</span><span class="koboSpan" id="kobo.415.5">  };
  const toggleDropdown = () =&gt; setIsOpen((isOpen) =&gt; !isOpen);
  return {
    isOpen,
    toggleDropdown,
    handleKeyDown,
    selectedItem,
    setSelectedItem,
    selectedIndex,
  };
};</span></pre> <p><span class="koboSpan" id="kobo.416.1">Now, our </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">Dropdow</span></strong><span class="koboSpan" id="kobo.418.1">n component </span><a id="_idIndexMarker488"/><span class="koboSpan" id="kobo.419.1">is simplified and more readable; it leverages the </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">useDropdown</span></strong><span class="koboSpan" id="kobo.421.1"> Hook to manage its state and handle keyboard interactions, demonstrating a clear separation of concerns and making the code easier to understand and manage:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.422.1">
const Dropdown = ({ items }: DropdownProps) =&gt; {
  const {
    isOpen,
    selectedItem,
    selectedIndex,
    toggleDropdown,
    handleKeyDown,
    setSelectedItem,
  } = useDropdown(items);
  return (
    &lt;div className="dropdown" onKeyDown={handleKeyDown}&gt;
      &lt;Trigger
        onClick={toggleDropdown}
        label={selectedItem ? </span><span class="koboSpan" id="kobo.422.2">selectedItem.text : "Select an item..."}
      /&gt;
      {isOpen &amp;&amp; (
        &lt;DropdownMenu
          items={items}
          onItemClick={setSelectedItem}
          selectedIndex={selectedIndex}
        /&gt;
      )}
    &lt;/div&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.423.1">Through these </span><a id="_idIndexMarker489"/><span class="koboSpan" id="kobo.424.1">modifications, we have successfully implemented keyboard navigation in our drop-down list, making it more accessible and user-friendly. </span><span class="koboSpan" id="kobo.424.2">This example also illustrates how Hooks can be utilized to manage complex state and logic in a structured and modular manner, paving the way for further enhancements and feature additions to our UI components.</span></p>
<p><span class="koboSpan" id="kobo.425.1">We can</span><a id="_idIndexMarker490"/><span class="koboSpan" id="kobo.426.1"> visualize the code a bit better with the React DevTools. </span><span class="koboSpan" id="kobo.426.2">Note that in the </span><strong class="bold"><span class="koboSpan" id="kobo.427.1">hooks</span></strong><span class="koboSpan" id="kobo.428.1"> section, all the states are listed:</span></p>
<figure>
<div class="IMG---Figure" id="_idContainer059">
<span class="koboSpan" id="kobo.429.1"><img alt="Figure 10.6: Chrome DevTools to inspect what’s in the hooks section" src="image/B31103_10_06.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.430.1">Figure 10.6: Chrome DevTools to inspect what’s in the hooks section</span></figcaption> </figure>
<p><span class="koboSpan" id="kobo.431.1">The power of extracting our logic into a Hook comes into full play when we need to implement a different UI while maintaining the same underlying functionality. </span><span class="koboSpan" id="kobo.431.2">By doing so, we’ve segregated our state management and interaction logic from the UI rendering, making it a breeze to change the UI without touching the logic.</span></p>
<p><span class="koboSpan" id="kobo.432.1">We’ve explored how utilizing small components with custom Hooks can enhance our code structure. </span><span class="koboSpan" id="kobo.432.2">However, what happens when we’re faced with managing more complex states? </span><span class="koboSpan" id="kobo.432.3">Consider a scenario where the drop-down data comes from a service API, requiring us to handle asynchronous service calls along with additional state management. </span><span class="koboSpan" id="kobo.432.4">In such cases, does</span><a id="_idTextAnchor273"/><span class="koboSpan" id="kobo.433.1"> this structure still hold up effectively?</span></p>
<p><span class="koboSpan" id="kobo.434.1">The scenario of fetching data from a remote source brings forth the necessity to manage a few more states – specifically, we need to handle loading, error, and data states. </span><span class="koboSpan" id="kobo.434.2">As illustrated in </span><i class="italic"><span class="koboSpan" id="kobo.435.1">Figure 10</span></i><i class="italic"><span class="koboSpan" id="kobo.436.1">.7</span></i><span class="koboSpan" id="kobo.437.1">, besides displaying a regular list, we also aim to manage scenarios </span><a id="_idIndexMarker491"/><span class="koboSpan" id="kobo.438.1">where the data is not immediately accessible – either when it’s still loading from a remote API or it isn’t avai</span><a id="_idTextAnchor274"/><span class="koboSpan" id="kobo.439.1">lable.</span></p>
<figure>
<div class="IMG---Figure" id="_idContainer060">
<span class="koboSpan" id="kobo.440.1"><img alt="Figure 10.7: Different statuses" src="image/B31103_10_07.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.441.1">Figure 10.7: Different statuses</span></figcaption> </figure>
<p><span class="koboSpan" id="kobo.442.1">Such states, while common, are crucial for the user experience. </span><span class="koboSpan" id="kobo.442.2">Take, for instance, a drop-down list featuring country names. </span><span class="koboSpan" id="kobo.442.3">It’s a common feature, yet when we open the list, the names might still be loading, during which a loading indicator is displayed. </span><span class="koboSpan" id="kobo.442.4">Additionally, in situations where the downstream service is unavailable or other errors arise, an error message is presented instead.</span></p>
<p><span class="koboSpan" id="kobo.443.1">When extending our existing code, it’s crucial to deliberate on the additional states that will be introduced. </span><span class="koboSpan" id="kobo.443.2">Let’s explore strategies to preserve simplicity as we integrate new features.</span></p>
<h2 id="_idParaDest-151"><a id="_idTextAnchor275"/><span class="koboSpan" id="kobo.444.1">Maintaining simplicity in the Dropdown component</span></h2>
<p><span class="koboSpan" id="kobo.445.1">Incorporating</span><a id="_idIndexMarker492"/><span class="koboSpan" id="kobo.446.1"> remote data fetching has not complicated our </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">Dropdown</span></strong><span class="koboSpan" id="kobo.448.1"> component, thanks to the abstracted logic in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">useService</span></strong><span class="koboSpan" id="kobo.450.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">useDropdown</span></strong><span class="koboSpan" id="kobo.452.1"> Hooks. </span><span class="koboSpan" id="kobo.452.2">Our component code remains in its simplest form, effectively managing the fetching states and rendering the content based on the data</span><a id="_idIndexMarker493"/><span class="koboSpan" id="kobo.453.1"> received:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.454.1">
const Dropdown = () =&gt; {
  const { data, loading, error } = useService(fetchUsers);
  const {
    toggleDropdown,
    dropdownRef,
    isOpen,
    selectedItem,
    selectedIndex,
    updateSelectedItem,
    getAriaAttributes,
  } = useDropdown&lt;Item&gt;(data || []);
  const renderContent = useCallback(() =&gt; {
    if (loading) return &lt;Loading /&gt;;
    if (error) return &lt;Error /&gt;;
    if (data) {
      return (
        &lt;DropdownMenu
          items={data}
          updateSelectedItem={updateSelectedItem}
          selectedIndex={selectedIndex}
        /&gt;
      );
    }
    return null;
  }, [loading, error, data, updateSelectedItem, selectedIndex]);
  return (
    &lt;div
      className="dropdown"
      ref={dropdownRef as RefObject&lt;HTMLDivElement&gt;}
      {...getAriaAttributes()}
    &gt;
      &lt;Trigger
        onClick={toggleDropdown}
        text={selectedItem ? </span><span class="koboSpan" id="kobo.454.2">selectedItem.text : "Select an item..."}
      /&gt;
      {isOpen &amp;&amp; renderContent()}
    &lt;/div&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.455.1">In this </span><a id="_idIndexMarker494"/><span class="koboSpan" id="kobo.456.1">updated </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">Dropdown</span></strong><span class="koboSpan" id="kobo.458.1"> component, we utilize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">useService</span></strong><span class="koboSpan" id="kobo.460.1"> Hook to manage the data fetching states and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">useDropdown</span></strong><span class="koboSpan" id="kobo.462.1"> Hook to manage the drop-down-specific states and interactions. </span><span class="koboSpan" id="kobo.462.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">renderContent</span></strong><span class="koboSpan" id="kobo.464.1"> function elegantly handles the rendering logic based on the fetching states, ensuring that the correct content is displayed, whether it’s loading, an error, or data.</span></p>
<p><span class="koboSpan" id="kobo.465.1">Through the separation of concerns and the use of Hooks, our </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">Dropdown</span></strong><span class="koboSpan" id="kobo.467.1"> component remains clean and straightforward, showcasing the power of composable logic in React. </span><span class="koboSpan" id="kobo.467.2">Now, this pattern actually has a particular name in building UI – the Headless Compon</span><a id="_idTextAnchor276"/><span class="koboSpan" id="kobo.468.1">ent pattern. </span><span class="koboSpan" id="kobo.468.2">Let’s look at it in more detail.</span></p>
<h1 id="_idParaDest-152"><a id="_idTextAnchor277"/><span class="koboSpan" id="kobo.469.1">Introducing the Headless Component pattern</span></h1>
<p><span class="koboSpan" id="kobo.470.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.471.1">Headless Component pattern</span></strong><span class="koboSpan" id="kobo.472.1"> unveils a</span><a id="_idIndexMarker495"/><span class="koboSpan" id="kobo.473.1"> robust avenue to cleanly segregate our JSX code from the underlying logic. </span><span class="koboSpan" id="kobo.473.2">While composing a declarative UI with JSX comes naturally, the real challenge lies in managing state. </span><span class="koboSpan" id="kobo.473.3">This is where headless components come into play, by shouldering all the state management intricacies and propelling us toward a new horizon of abstraction.</span></p>
<p><span class="koboSpan" id="kobo.474.1">In essence, a </span><strong class="bold"><span class="koboSpan" id="kobo.475.1">Headless Component</span></strong><span class="koboSpan" id="kobo.476.1"> is a function or object that encapsulates logic but doesn’t render anything itself. </span><span class="koboSpan" id="kobo.476.2">It leaves the rendering part to the consumer, thus offering a high degree of flexibility in how the UI is rendered. </span><span class="koboSpan" id="kobo.476.3">This pattern can be exceedingly useful when we have complex logic that we want to reuse across different visual representations.</span></p>
<p><span class="koboSpan" id="kobo.477.1">As shown in the following code, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">useDropdownLogic</span></strong><span class="koboSpan" id="kobo.479.1"> Hook has all the logic but no UI elements, while </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">MyDropdown</span></strong><span class="koboSpan" id="kobo.481.1"> uses the headless component and only has to deal with rendering logic:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.482.1">
function useDropdownLogic() {
  // ... </span><span class="koboSpan" id="kobo.482.2">all the dropdown logic
  return {
    // ... </span><span class="koboSpan" id="kobo.482.3">exposed logic
  };
}
function MyDropdown() {
  const dropdownLogic = useDropdownLogic();
  return (
    // ... </span><span class="koboSpan" id="kobo.482.4">render the UI using the logic from dropdownLogic
  );
}</span></pre> <p><span class="koboSpan" id="kobo.483.1">In a visual </span><a id="_idIndexMarker496"/><span class="koboSpan" id="kobo.484.1">representation, the headless component acts as a thin interface layer. </span><span class="koboSpan" id="kobo.484.2">On one side, it interacts with JSX views, and on the other, it communicates with underlying data models. </span><span class="koboSpan" id="kobo.484.3">We touched upon data modeling in </span><a href="B21103_08.xhtml#_idTextAnchor212"><i class="italic"><span class="koboSpan" id="kobo.485.1">Chapter 8</span></i></a><span class="koboSpan" id="kobo.486.1"> and will revisit it in </span><a href="B21103_11.xhtml#_idTextAnchor286"><i class="italic"><span class="koboSpan" id="kobo.487.1">Chapter 11</span></i></a><span class="koboSpan" id="kobo.488.1">. </span><span class="koboSpan" id="kobo.488.2">This pattern is particularly beneficial for individuals seeking solely the behavior or state management aspect of the UI, as it conveniently segregates it from the visual representation.</span></p>
<p><span class="koboSpan" id="kobo.489.1">Let’s see a visual illustration in </span><i class="italic"><span class="koboSpan" id="kobo.490.1">Figure 10</span></i><i class="italic"><span class="koboSpan" id="kobo.491.1">.8</span></i><span class="koboSpan" id="kobo.492.1">. </span><span class="koboSpan" id="kobo.492.2">You can think of your code as having a few layers – the JSX is on the top and is response for the look and feel part of the application, the headless component (Hooks in this case) manages all the stateful logic, and beneath them is the domain layer, which has the logic to handle data mapping and transformation (we will go into more detail on this in </span><a href="B21103_11.xhtml#_idTextAnchor286"><i class="italic"><span class="koboSpan" id="kobo.493.1">Chapter 11</span></i></a><span class="koboSpan" id="kobo.494.1"> and </span><a href="B21103_12.xhtml#_idTextAnchor323"><i class="italic"><span class="koboSpan" id="kobo.495.1">Chapter 12</span></i></a><span class="koboSpan" id="kobo.496.1">).</span><a id="_idTextAnchor278"/></p>
<figure>
<div class="IMG---Figure" id="_idContainer061">
<span class="koboSpan" id="kobo.497.1"><img alt="Figure 10.8: The Headless Component pattern" src="image/B31103_10_08.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.498.1">Figure 10.8: The Headless Component pattern</span></figcaption> </figure>
<p><span class="koboSpan" id="kobo.499.1">In summarizing the Headless Component pattern, it’s worth mentioning that although it can be realized through HOCs or render props, its implementation as a React Hook is more prevalent. </span><span class="koboSpan" id="kobo.499.2">Within </span><a id="_idIndexMarker497"/><span class="koboSpan" id="kobo.500.1">the Headless Component pattern, all shareable logic is encapsulated, allowing for a seamless transition to other UIs without necessitating any modifications to the stateful logic.</span></p>
<h2 id="_idParaDest-153"><a id="_idTextAnchor279"/><span class="koboSpan" id="kobo.501.1">The advantages and drawbacks of Headless Component pattern</span></h2>
<p><span class="koboSpan" id="kobo.502.1">The advantages of the </span><a id="_idIndexMarker498"/><span class="koboSpan" id="kobo.503.1">Headless Component pattern include the following:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.504.1">Reusability</span></strong><span class="koboSpan" id="kobo.505.1">: The logic encapsulated in Headless Component pattern can be reused across multiple components. </span><span class="koboSpan" id="kobo.505.2">This fosters </span><strong class="bold"><span class="koboSpan" id="kobo.506.1">Don’t Repeat Yourself</span></strong><span class="koboSpan" id="kobo.507.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.508.1">DRY</span></strong><span class="koboSpan" id="kobo.509.1">) principles in your codebase.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.510.1">Separation of concerns</span></strong><span class="koboSpan" id="kobo.511.1">: By decoupling logic from rendering, headless components promote a clear separation of concerns, which is a cornerstone of maintainable code.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.512.1">Flexibility</span></strong><span class="koboSpan" id="kobo.513.1">: They allow for varying UI implementations while sharing the same core logic, making it easier to adapt</span><a id="_idTextAnchor280"/><span class="koboSpan" id="kobo.514.1"> to different design requirements or frameworks.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.515.1">The drawbacks </span><a id="_idIndexMarker499"/><span class="koboSpan" id="kobo.516.1">of Headless Component pattern include the following:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.517.1">Learning curve</span></strong><span class="koboSpan" id="kobo.518.1">: The pattern may introduce a learning curve for developers unfamiliar with it, potentially slowing down development initially.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.519.1">Over-abstraction</span></strong><span class="koboSpan" id="kobo.520.1">: If not managed judiciously, the abstraction created by headless components can lead to a level of indir</span><a id="_idTextAnchor281"/><span class="koboSpan" id="kobo.521.1">ection that might make the code harder to follow.</span></li>
</ul>
<h2 id="_idParaDest-154"><a id="_idTextAnchor282"/><span class="koboSpan" id="kobo.522.1">Libraries and further learnings</span></h2>
<p><span class="koboSpan" id="kobo.523.1">The Headless Component pattern </span><a id="_idIndexMarker500"/><span class="koboSpan" id="kobo.524.1">has been embraced by various libraries to facilitate the creation of accessible, customizable, and reusable components. </span><span class="koboSpan" id="kobo.524.2">Here are some</span><a href="https://react-spectrum.adobe.com/react-aria/"><span class="koboSpan" id="kobo.525.1"> notable l</span></a><span class="koboSpan" id="kobo.526.1">ibraries along with a brief description of each:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.527.1">React Aria</span></strong><span class="koboSpan" id="kobo.528.1">: A</span><a id="_idIndexMarker501"/><span class="koboSpan" id="kobo.529.1"> library from Adobe that </span><a id="_idIndexMarker502"/><span class="koboSpan" id="kobo.530.1">provides accessibility primitives and Hooks to build inclusive React applications. </span><span class="koboSpan" id="kobo.530.2">It offers a collection of Hooks to manage keyboard interactions, focus management, and Aria annot</span><a href="https://headlessui.dev/"><span class="koboSpan" id="kobo.531.1">ations, mak</span></a><span class="koboSpan" id="kobo.532.1">ing it easier to create accessible UI components.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.533.1">Headless UI</span></strong><span class="koboSpan" id="kobo.534.1">: A</span><a id="_idIndexMarker503"/><span class="koboSpan" id="kobo.535.1"> completely unstyled, fully </span><a id="_idIndexMarker504"/><span class="koboSpan" id="kobo.536.1">accessible UI component library, designed to integrate beautifully with Tailwind CSS. </span><span class="koboSpan" id="kobo.536.2">It provides the behavior and accessibility f</span><a href="https://react-table.tanstack.com/"><span class="koboSpan" id="kobo.537.1">oundation u</span></a><span class="koboSpan" id="kobo.538.1">pon which you can build your own styled components.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.539.1">React Table</span></strong><span class="koboSpan" id="kobo.540.1">: A</span><a id="_idIndexMarker505"/><span class="koboSpan" id="kobo.541.1"> headless utility </span><a id="_idIndexMarker506"/><span class="koboSpan" id="kobo.542.1">for building fast and extendable tables and data grids for React. </span><span class="koboSpan" id="kobo.542.2">It provides a flexible Hook that allows you to create co</span><a href="https://www.downshift-js.com/"><span class="koboSpan" id="kobo.543.1">mplex tab</span></a><span class="koboSpan" id="kobo.544.1">les with ease, leaving the UI representation up to you.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.545.1">Downshift</span></strong><span class="koboSpan" id="kobo.546.1">: A</span><a id="_idIndexMarker507"/><span class="koboSpan" id="kobo.547.1"> minimalist library to help you </span><a id="_idIndexMarker508"/><span class="koboSpan" id="kobo.548.1">create accessible and customizable dropdowns, comboboxes, and so on. </span><span class="koboSpan" id="kobo.548.2">It handles all the logic while letting you define the rendering aspect.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.549.1">These</span><a id="_idIndexMarker509"/><span class="koboSpan" id="kobo.550.1"> libraries embody the essence of the Headless Component pattern by encapsulating complex logic and behaviors, making it straightforward to create highly interactive and accessible UI components. </span><span class="koboSpan" id="kobo.550.2">While the provided example serves as a learning stepping stone, it’s prudent to leverage these production-ready libraries to build robust, accessible, and customizable components in a real-world scenario.</span></p>
<p><span class="koboSpan" id="kobo.551.1">This pattern not only educates us on managing complex logic and state but also encourages us to explore production-ready libraries that have honed the Headless Component approach, delivering robust, </span><a id="_idTextAnchor283"/><span class="koboSpan" id="kobo.552.1">accessible, and customizable components for real-world use.</span></p>
<h1 id="_idParaDest-155"><a id="_idTextAnchor284"/><span class="koboSpan" id="kobo.553.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.554.1">In this chapter, we delved into the world of HOCs and Hooks in React, exploring their utility in enhancing component logic while maintaining a clean, readable code base. </span><span class="koboSpan" id="kobo.554.2">Through the lens of creating an expandable panel and a drop-down list, we illustrated the composability of HOCs and the encapsulation of stateful logic that Hooks offer. </span><span class="koboSpan" id="kobo.554.3">Transitioning to a more intricate drop-down list, we introduced asynchronous data fetching, demonstrating how Hooks can simplify state management in data-loading scenarios.</span></p>
<p><span class="koboSpan" id="kobo.555.1">We then transitioned into the realm of Headless Component, a powerful pattern that separates logic from the JSX code, providing a robust framework to manage state while leaving the UI representation to the developer. </span><span class="koboSpan" id="kobo.555.2">Through examples, we demonstrated how this separation facilitates the creation of reusable, accessible, and customizable components. </span><span class="koboSpan" id="kobo.555.3">The discussion was enriched with a review of notable libraries, such as React Table, Downshift, React Aria, and Headless UI, that embody the Headless Component pattern, providing ready-to-use solutions to build interactive and accessible UI components.</span></p>
<p><span class="koboSpan" id="kobo.556.1">In the upcoming chapter, we’ll implement the patterns we’ve discussed and delve into architectural strategies to enhance modularity. </span><span class="koboSpan" id="kobo.556.2">We’ll also address the challenges posed by larger applications.</span></p>
</section>


<section class="Content" epub:type="part" id="_idContainer062" role="doc-part">
<h1 id="_idParaDest-156"><a id="_idTextAnchor285"/><span class="koboSpan" id="kobo.1.1">Part 4: Engaging in Practical Implementation</span></h1>
<p><span class="koboSpan" id="kobo.2.1">In the final part of this book, you will apply your accumulated knowledge in a hands-on manner by employing a layered architecture in React and journeying through an end-to-end project implementation. </span><span class="koboSpan" id="kobo.2.2">This part aims to encapsulate the essence of all the principles, patterns, and practices discussed throughout the book.</span></p>
<p><span class="koboSpan" id="kobo.3.1">This part contains the following chapters:</span></p>
<ul>
<li><a href="B21103_11.xhtml#_idTextAnchor286"><em class="italic"><span class="koboSpan" id="kobo.4.1">Chapter 11</span></em></a><span class="koboSpan" id="kobo.5.1">, </span><em class="italic"><span class="koboSpan" id="kobo.6.1">Introducing Layered Architecture in React</span></em></li>
<li><a href="B21103_12.xhtml#_idTextAnchor323"><em class="italic"><span class="koboSpan" id="kobo.7.1">Chapter 12</span></em></a><span class="koboSpan" id="kobo.8.1">, </span><em class="italic"><span class="koboSpan" id="kobo.9.1">Implementing an End-To-End Project</span></em></li>
<li><a href="B21103_13.xhtml#_idTextAnchor356"><em class="italic"><span class="koboSpan" id="kobo.10.1">Chapter 13</span></em></a><span class="koboSpan" id="kobo.11.1">, </span><em class="italic"><span class="koboSpan" id="kobo.12.1">Recapping Anti-Pattern Principles</span></em></li>
</ul>
</section>
</body></html>