- en: Integration Testing with Appium
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding chapter, we explored how to do unit testing, but unit testing
    doesn't allow you to test whether the button used in your app still actually runs
    a function, or what happens when the user swipes left. For that, we will need
    application testing or end-to-end testing. Well, let's start learning end-to-end
    testing; this is where testing can get complicated and fun.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Appium testing framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing MochaJS, ChaiJS, and ShouldJS tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to find and interact with elements on the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to run the tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Travis and GitHub integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several full application frameworks out there, but we will show you
    how to use Appium ([http://appium.io](http://appium.io)). Appium is an awesome
    open source application testing framework. Appium supports both iOS and Android,
    which makes it a perfect fit for doing all our on-device testing. You want to
    start creating tests to test your basic flow through your application, and even
    create more complicated tests that test alternate flows through your app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get it installed first; run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command installs Appium, the Appium communication driver **WD** ([http://admc.io/wd/](http://admc.io/wd/)),
    and the **NativeScript driver** ([https://github.com/NativeScript/nativescript-dev-appium](https://github.com/NativeScript/nativescript-dev-appium)).
    The WD driver is what communicates with Appium and the NativeScript driver. The
    `nativescript-dev-appium` is the driver that interacts with WD and your test code.
    In reality, the NativeScript driver is a very thin wrapper around the WD driver
    and just facilitates some configuration and then exposes the WD driver to your
    application. So interaction commands will be found in the WD documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Application/Integration testing takes a bit more work, as you have to programmatically
    run it as a normal user would interact with your app. So, you have to do things,
    such as find the button element, then perform `button.tap()`. So, your tests might
    be a bit verbose, but this allows you to test any, and all, functionalities. The
    down side is that this is a lot more time-consuming to run and takes more maintenance
    work when you change screens. However, the payoff is that when you add code, it
    verifies that your app still runs properly on each screen automatically, and you
    can test it on multiple devices and resolutions, once again automatically.
  prefs: []
  type: TYPE_NORMAL
- en: After installation, you will have a brand new `e2e-tests` folder in your root
    folder of your application. This folder is where all your end-to-end test files
    will live. Now, one thing that you need to know is that the Appium NativeScript
    driver uses the MochaJS test framework ([https://mochajs.org/](https://mochajs.org/)).
    The Mocha testing framework is similar to the Jasmine framework, which we discussed
    in the preceding chapter. It uses the same `describe` and `it` functions for the
    start of the tests, just like Jasmine. In addition, it uses the Chai ([http://chaijs.com/](http://chaijs.com/))
    and ShouldJS ([https://github.com/shouldjs/should.js](https://github.com/shouldjs/should.js))
    testing frameworks that work hand in hand with the Mocha test framework and the
    WD driver.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to note is that all these are designed around pure JavaScript.
    You can get typings for Mocha, Should, and Chai, but for the NativeScript Appium
    driver or WD driver, typings don't exist. You can use TypeScript, but it is awkward,
    as commands are not just WD-based commands but chained through mocha. TypeScript
    gets easily confused as to what context you are in. So, mostly the Appium tests
    are created in pure JavaScript rather than in TypeScript. However, feel free to
    use TypeScript if you want; just make sure that you run `tsc` to build the `JS`
    files before you run the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One more setup step that you will need to do is to create an `appium.capabilities.json`
    file in the root folder of your project. This is basically a configuration file
    that you can use to configure the emulator that you need to run any of your tests
    on. The file is documented on the Appium site but to get you up and running quickly
    you can use the paired-down file which we use as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We've simplified it and removed all other emulator entries to save space. However
    you give each emulator entry a key-- you tell Appium using the key the emulator
    configuration that you will be running. This example file shows two configurations.
    The first one is an Android 4.4 device, and the second one is an iOS simulator
    (iPhone 6 runs iOS 10). You can have as many configurations as you want in this
    file. When you run Appium, you can tell it which device you will target, using
    the `--runType=KEY` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start our journey and create a new test file: `list.test.js`. This file
    will test our mix-list screen. The screen''s HTML (`/app/modules/mixer/components/mix-list.component.html`)
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We've included the code here so that you can see easily how we made the test
    with the details provided on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to include the NativeScript Appium driver in our JavaScript test code;
    this is what is used to actually communicate and set up the Mocha, ShouldJS, WD,
    Appium, and Chia to be able to work properly. The following line alone is required
    for your usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As the comments in the source code mention, it is critical that you give enough
    time to start up Appium and the application in your emulator. So, out personal
    default is `100,000`; you can play with this number, but this is the maximum amount
    of time it will wait before it will declare the tests a failure. Having a larger
    value means that you give your emulator and Appium more time to actually start
    running. Appium gives you its startup output quickly, but when it goes to actually
    initialize the test and driver, that process takes a lot of time. Once the test
    starts to run, it runs very fast:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also very important to initialize and create the driver before your tests
    are run. This driver is global throughout your tests. So, we will declare it globally
    in the `describe` function and then initialize it with the Mocha `before` function
    that runs before any tests are run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We also add a Mocha after function to shut down the driver when we are all
    done. It is very important to ensure that any time you are working with the driver
    that you properly return it. Almost every single test piece is actually a promise
    underneath it. If you forget to return the promise, the testing harness will get
    royally mixed up and may run tests out of order and even close the driver before
    the tests are completed. So, always return the promise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `it` function is used just like we did in Jasmine--you are describing a
    test you plan on running so that you can find it if the test fails. Again, we
    return the promise chain; it is very important that you don't forget to do this.
    The driver variable is what gives us the different functionality when dealing
    with the emulators. So, the documentation for the functionality is in the WD repository,
    but I will give you a quick overview to get you going.
  prefs: []
  type: TYPE_NORMAL
- en: '`.elementByXPath` and `.elementById` are really the only two functions that
    work well to properly find elements with NativeScript . However there is also
    a `.waitForElementByXPath` and `.waitForElementById` which both wait for the elements
    to show up. If you look at the documentation, you will observe a lot of `elementByXXX`
    commands, but Appium was designed for a browser, and NativeScript is not a browser.
    That is why, only some commands that have been emulated in the nativescript-dev-appium
    driver work to find elements in the NativeScript DOM.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So our test says find an element by XPath. XPath allows you to drill into your
    DOM and find components any level deep and also subcomponents of other components.
    So, if you do something like `/GridLayout/StackLayout/Label`, it will find a `Label`
    that is a child of a `StackLayout`, which is a child of a `GridLayout`. Using
    `*//*` will mean that you can find that element at any level in the DOM. Finally
    the `nsAppium.getXPathElement` is a method which was added to the official NativeScript
    driver by Nathanael Anderson to allow us to make the XPath tests cross-platform.
    In all reality, what you are passing to the XPath function is the real native
    name of the object. For example, a button on Android is a `android.widget.Button` or
    it could be a `UIAButton` or a `XCUIElementTypeButton` on iOS. So because you
    don''t want to hardcode `getByElementXPath("android.widget.Button")`, this helper
    function translates the NativeScript `Button` to the proper underlying OS element
    that NativeScript actually uses when it creates a button in NativeScript. If,
    in the future, you add a plugin that uses an element that the `getXPathElement`
    doesn''t know about, you can still use the real name of the element for those
    tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`.text()` is a function that Appium driver exposes to get the text value of
    the elements it finds. The `.should.eventually.exist.equal` is a Mocha and Should
    code. We are basically making sure that once this item is found, it actually matches
    the Unicode value of F067, which in Font-Awesome is the Plus character (fa-plus).
    Once it exists, we are happy--the test either succeeds or fails, depending on
    whether we break the screen or the screen continues to be the way we expect it.
    In addition, after the `**.equal**`, we could have chained more commands, such
    as `.tap()`, to fire the button if we wanted.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, let''s look at the next test that runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This test searches the screen to show the `Demo` ListView item. We are looking
    for a NativeScript Label (that is, `nsAppium.getXPathElement`) anywhere in the
    NativeScript DOM (that is, `*//*`) that contains the text value of Demo in it.
    (that is, `[@text=''Demo'']`). This element should eventually exist, and once
    it does exist, it calls the `tap()` function. Now, if you look at the source code,
    you will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: So, it will run the select function when the `tap` is fired. The `select` function
    ends up ultimately loading the `/app/modules/player/components/track-list/track-list.component.html`
    file, which is used to display the composition of that mixer item on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: All the tests are executed sequentially, and the state of the app is preserved
    from one test to another. This means that tests are not independent like we are
    used to when writing unit-tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next test we will verify is that the `Demo` Label actually switches screens
    in the next test after we tap on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'So, now that we are on a new screen, we will verify that the `ListView` contains
    a Label with the name of `Drums`. This test just verifies that the screen actually
    changed when we tapped on the `Demo` Label in the prior test. We could have verified
    the text value but really if it exists, we are good. So, let''s look at the next
    test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Our final example test shows chaining. We search the Label that has the volume
    control symbol. Then, once it exists, we tap on it. Then, we verify that the text
    actually became the volume off symbol. The `f028` is the Font Awesome Unicode
    value for `fa-volume-up`, and the `f026` is the Font Awesome Unicode value for
    `fa-volume-off`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So now that you have this really cool test, you want to launch your emulator.
    The emulator should be already running. You also should ensure that you have the
    latest version of the application on the device. Then, to run the test, simply
    type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Ensure that you put in which run type configuration you are going to use, and
    you should see something like this after a few minutes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00058.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Remember that Appium end-to-end tests take a while to start, so if it looks
    like it is frozen for a while, don't panic and quit it. It may take 24 seconds
    for the first test, seconds for each additional test. The first test has all the
    time in it. It is normal for Appium to take a long time to start the driver and
    the application on the emulator. This delay normally occurs after you see the
    first couple of lines of text printed, as shown in the preceding screen, so, have
    some patience.
  prefs: []
  type: TYPE_NORMAL
- en: More Appium testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I wanted to include one more test (not used in this application) that I have
    written in the past for a different project since this will give you an idea of
    just how powerful Appium can be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The first thing you might note is that I did not return the promise chain. That
    is because this example shows how to use the asynchronous support of `it`. For
    an async support, you can use a promise or make the function coming into `it`
    have a `done` callback function. When Mocha detects a callback function in the
    `it`, it will run your `it` tests in the async mode and doesn't need the promise
    to let it know that it can resume with the next test. Sometimes, you may just
    want to maintain full control or you may be calling code that requires async callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: This test looks for a `EditText` element that contains `Enter your name`. Then,
    it actually types *Testing* into it using the `sendKeys`. Next, it asks for the
    `text` out of the field and uses the `then` part of the promise to check the value
    against the hardcoded testing. When it is all finished, it calls the `done` function.
    If you pass the `done` function an `Error` object, then it knows that the test
    failed. So, you can see in the `if` statement that we passed a `new Error` and
    that we put the `done` function in the `catch` part of the `then` statement.
  prefs: []
  type: TYPE_NORMAL
- en: We have barely scratched the surface of what you can do with Appium, Should,
    Mocha, and Chia. You can control pretty much all aspects of the application as
    if you were manually doing each step. Initially, in your development, manually
    testing is a lot faster. However, as you start to build up end-to-end tests, each
    time you make changes, you can check whether the app still works properly, and
    you do not have to sit in front of multiple devices for any amount of time--you
    just start the tests and see the results later.
  prefs: []
  type: TYPE_NORMAL
- en: Automated testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One more thing that you should note is that the more automated you make your
    testing, the more likely you are to use it and gain from its benefits. If you
    constantly have to manually run the test, you are likely to get annoyed and stop
    running them. So automating this is critical in our opinion. Since there are many
    books written on this subject we are just going to give you a couple of pointers
    that you can research and then move forward.
  prefs: []
  type: TYPE_NORMAL
- en: Most source control systems allow you to create hooks. With these hooks, you
    can create a commit hook so that on check-in of any new code, your testing frameworks
    will run. These hooks are normally pretty simple to create as they are simple
    scripts that just run each time a commit is made.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, if you are using GitHub, there are sites such as Travis that you
    can tie into easily without having to do any hook changes.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub and Travis integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is how you can do some integration with GitHub and Travis; this will allow
    your NativeScript Testing framework, which we discussed in the preceding chapter,
    to automatically run your tests on each change or pull request. Create a new `.travis.yml`
    file in the very root of your GitHub repository. This file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This basically configures Travis to start an Android emulator; it waits for
    the emulator to start and then runs the `npm` commands. You can learn what these
    `npm` commands do from your `package.json`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in your root application, that is, the package.json file of your app, you
    want to add the following keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: With these two changes, Travis will automatically test every single pull request
    to your repository, which then means that you can code, and Travis will continually
    do all your unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, you can change the preceding Travis configuration file to add
    Appium to be installed and run also just by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Appium dependencies to your main `package.json` dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding to the root of your project a `appium.capabilities.json` that has a `travisAndroid`
    key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the `&& npm run appium --runType=travisAndroid` to your `travistest` key
    in the `package.json` file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitHub already has the integration with Travis built-in, so it is simple to
    document and get it running. If you use Gitlabs, you can use the Gitlabs CI system
    to do testing. In addition, you can use the repository hooks to use a wide number
    of other continuous integration services that are available. Finally, you can
    also develop your own.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered how to install and run Appium, how to build complete
    end-to-end tests and how to use the testing frameworks to test your screens fully.
    In addition, we covered how important it is to automate the running of the unit
    testing and Appium, and one way you can do so is using Travis and GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Now hang on tight--we will make a quick turn and start discussing how to deploy
    and use Webpack to optimize your builds for release.
  prefs: []
  type: TYPE_NORMAL
