<html><head></head><body>
		<div id="_idContainer113">
			<h1 id="_idParaDest-186" class="chapter-number"><a id="_idTextAnchor205"/><span class="koboSpan" id="kobo.1.1">10</span></h1>
			<h1 id="_idParaDest-187"><a id="_idTextAnchor206"/><span class="koboSpan" id="kobo.2.1">Exploring Optimization Techniques for Angular Applications</span></h1>
			<p><span class="koboSpan" id="kobo.3.1">In today’s digital age, users expect applications to be fast and responsive. </span><span class="koboSpan" id="kobo.3.2">A slight delay can lead to decreased user satisfaction and can even impact business metrics. </span><span class="koboSpan" id="kobo.3.3">By understanding and implementing performance optimization techniques, you ensure that your applications meet user expectations, leading to better user engagement, higher retention rates, and positive user feedback. </span><span class="koboSpan" id="kobo.3.4">So, as we delve deeper into the world of Angular and PrimeNG, it’s essential to ensure our applications are not just functional and aesthetically pleasing but also perform at their peak. </span><span class="koboSpan" id="kobo.3.5">This chapter is dedicated to equipping you with the tools and techniques to optimize the performance of Angular applications that utilize </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">PrimeNG components.</span></span></p>
			<p><span class="koboSpan" id="kobo.5.1">Throughout this chapter, you’ll delve into the core concepts of performance optimization. </span><span class="koboSpan" id="kobo.5.2">We’ll unravel some popular techniques, such as lazy loading, </span><strong class="source-inline"><span class="koboSpan" id="kobo.6.1">trackBy</span></strong><span class="koboSpan" id="kobo.7.1"> via </span><strong class="source-inline"><span class="koboSpan" id="kobo.8.1">*ngFor</span></strong><span class="koboSpan" id="kobo.9.1">, pure pipes, bundle optimization, and more. </span><span class="koboSpan" id="kobo.9.2">As we progress, you’ll be introduced to the subtle nuances of change detection strategies, gaining a comprehensive understanding of their profound implications on performance. </span><span class="koboSpan" id="kobo.9.3">To round off, we’ll immerse you in hands-on sessions with Angular’s built-in performance tools. </span><span class="koboSpan" id="kobo.9.4">These tools stand out as true game-changers that are adept at pinpointing and rectifying </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">performance bottlenecks.</span></span></p>
			<p><span class="koboSpan" id="kobo.11.1">This chapter will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">following topics:</span></span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.13.1">Introducing Angular </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">performance optimization</span></span></li>
				<li><span class="koboSpan" id="kobo.15.1">Working with performance profiling </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">and analysis</span></span></li>
				<li><span class="koboSpan" id="kobo.17.1">Implementing lazy loading </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">and deferring</span></span></li>
				<li><span class="koboSpan" id="kobo.19.1">Working with </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">change detection</span></span></li>
				<li><span class="koboSpan" id="kobo.21.1">Optimizing </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">data binding</span></span></li>
				<li><span class="koboSpan" id="kobo.23.1">Working with code and </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">bundle optimization</span></span></li>
			</ul>
			<h1 id="_idParaDest-188"><a id="_idTextAnchor207"/><span class="koboSpan" id="kobo.25.1">Technical requirements</span></h1>
			<p><span class="koboSpan" id="kobo.26.1">This chapter contains various working code samples on Angular optimization. </span><span class="koboSpan" id="kobo.26.2">You can find the related source code in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.27.1">chapter-10</span></strong><span class="koboSpan" id="kobo.28.1"> folder in this book’s GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">repository: </span></span><a href="https://github.com/PacktPublishing/Next-Level-UI-Development-with-PrimeNG/tree/main/apps/chapter-10"><span class="No-Break"><span class="koboSpan" id="kobo.30.1">https://github.com/PacktPublishing/Next-Level-UI-Development-with-PrimeNG/tree/main/apps/chapter-10</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.31.1">.</span></span></p>
			<h1 id="_idParaDest-189"><a id="_idTextAnchor208"/><span class="koboSpan" id="kobo.32.1">Introducing Angular performance optimization</span></h1>
			<p><span class="koboSpan" id="kobo.33.1">Every developer dreams of building applications that are both feature-rich and blazing fast. </span><span class="koboSpan" id="kobo.33.2">But as we add more features and complexity to our Angular applications, we might inadvertently introduce performance bottlenecks. </span><span class="koboSpan" id="kobo.33.3">That’s where </span><strong class="bold"><span class="koboSpan" id="kobo.34.1">Angular performance optimization</span></strong><span class="koboSpan" id="kobo.35.1"> comes into play. </span><span class="koboSpan" id="kobo.35.2">Let’s dive deep into understanding this crucial aspect of </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">Angular development.</span></span></p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor209"/><span class="koboSpan" id="kobo.37.1">What is Angular performance optimization?</span></h2>
			<p><strong class="bold"><span class="koboSpan" id="kobo.38.1">Angular performance optimization</span></strong><span class="koboSpan" id="kobo.39.1"> refers to the practice of improving the performance and responsiveness of Angular applications by applying various techniques, strategies, and best</span><a id="_idIndexMarker472"/><span class="koboSpan" id="kobo.40.1"> practices. </span><span class="koboSpan" id="kobo.40.2">It involves identifying and addressing performance bottlenecks, reducing unnecessary computations, optimizing rendering processes, and minimizing load times. </span><span class="koboSpan" id="kobo.40.3">By optimizing the performance of Angular applications, we can enhance user satisfaction, minimize user exits, and improve overall </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">application success.</span></span></p>
			<h2 id="_idParaDest-191"><a id="_idTextAnchor210"/><span class="koboSpan" id="kobo.42.1">Major performance issues in Angular applications</span></h2>
			<p><span class="koboSpan" id="kobo.43.1">Angular is a powerful </span><a id="_idIndexMarker473"/><span class="koboSpan" id="kobo.44.1">framework, but like any tool, it’s not immune to performance issues. </span><span class="koboSpan" id="kobo.44.2">Some of the common culprits are </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">as follows:</span></span></p>
			<ul>
				<li><strong class="bold"><span class="koboSpan" id="kobo.46.1">Slow initial load time</span></strong><span class="koboSpan" id="kobo.47.1">: When an Angular application has a large code base, loading all the required resources can be time-consuming. </span><span class="koboSpan" id="kobo.47.2">Slow initial load times can significantly impact user perception </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">and engagement.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.49.1">Excessive change detection</span></strong><span class="koboSpan" id="kobo.50.1">: Angular’s default change detection mechanism can be computationally expensive, especially in large applications with frequent updates. </span><span class="koboSpan" id="kobo.50.2">Inefficient </span><a id="_idIndexMarker474"/><span class="koboSpan" id="kobo.51.1">change detection can lead to unnecessary rendering and </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">performance degradation.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.53.1">Memory leaks</span></strong><span class="koboSpan" id="kobo.54.1">: These can occur when components or services are not destroyed properly, particularly in cases where you overlook unsubscribing from an observable, leading to increased memory usage </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">over time.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.56.1">Complex computations</span></strong><span class="koboSpan" id="kobo.57.1">: Running complex algorithms or computations, especially in real-time scenarios such as animations, can slow down </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">the application.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.59.1">Inadequate lazy loading</span></strong><span class="koboSpan" id="kobo.60.1">: Loading all components and modules upfront, even if they are not immediately required, can result in increased initial load times. </span><span class="koboSpan" id="kobo.60.2">A lack of proper lazy loading techniques can impact the application’s </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">performance negatively.</span></span></li>
			</ul>
			<h2 id="_idParaDest-192"><a id="_idTextAnchor211"/><span class="koboSpan" id="kobo.62.1">Popular optimization techniques</span></h2>
			<p><span class="koboSpan" id="kobo.63.1">To address these performance issues and optimize the performance of Angular applications, developers </span><a id="_idIndexMarker475"/><span class="koboSpan" id="kobo.64.1">employ various techniques and strategies. </span><span class="koboSpan" id="kobo.64.2">Here are some popular </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">optimization options:</span></span></p>
			<ul>
				<li><strong class="bold"><span class="koboSpan" id="kobo.66.1">Performance profiling and analysis</span></strong><span class="koboSpan" id="kobo.67.1">: Angular provides built-in performance tools and techniques that allow us to profile and analyze the performance of our applications. </span><span class="koboSpan" id="kobo.67.2">Tools such as Angular DevTools help identify performance bottlenecks and provide insights </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">for optimization.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.69.1">Lazy loading and deferring</span></strong><span class="koboSpan" id="kobo.70.1">: They are techniques that load modules or components on-demand, rather than upfront. </span><span class="koboSpan" id="kobo.70.2">By implementing lazy loading and deferring in our Angular applications, we can reduce the initial load time and improve </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">overall performance.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.72.1">Change detection strategies</span></strong><span class="koboSpan" id="kobo.73.1">: Angular provides different change detection strategies, including the </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">Default</span></strong><span class="koboSpan" id="kobo.75.1"> strategy and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.76.1">OnPush</span></strong><span class="koboSpan" id="kobo.77.1"> strategy. </span><span class="koboSpan" id="kobo.77.2">By choosing the appropriate change detection strategy based on the application’s requirements, we can minimize unnecessary change detection and </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">improve performance.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.79.1">Optimized data binding</span></strong><span class="koboSpan" id="kobo.80.1">: Utilizing efficient data binding practices, such as one-time binding and </span><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">trackBy</span></strong><span class="koboSpan" id="kobo.82.1"> function usage, helps minimize unnecessary updates and improve</span><a id="_idIndexMarker476"/><span class="koboSpan" id="kobo.83.1"> rendering performance. </span><span class="koboSpan" id="kobo.83.2">Optimized data binding ensures that only the necessary components are updated when </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">changes occur.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.85.1">Code and bundle optimization</span></strong><span class="koboSpan" id="kobo.86.1">: Minifying and bundling JavaScript and CSS files, tree shaking, and code splitting are techniques that are used to optimize the size and loading speed of Angular applications. </span><span class="koboSpan" id="kobo.86.2">These optimizations reduce network requests and improve </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">overall performance.</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.88.1">Now that we understand Angular performance optimization and its significance, in the following sections, we will explore these techniques in detail. </span><span class="koboSpan" id="kobo.88.2">We will start with performance profiling </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">and analysis.</span></span></p>
			<h1 id="_idParaDest-193"><a id="_idTextAnchor212"/><span class="koboSpan" id="kobo.90.1">Introducing performance profiling and analysis</span></h1>
			<p><strong class="bold"><span class="koboSpan" id="kobo.91.1">Performance profiling</span></strong><span class="koboSpan" id="kobo.92.1"> is similar to a health checkup for your application. </span><span class="koboSpan" id="kobo.92.2">It involves monitoring the application’s operations, understanding where it spends most of its time, and identifying </span><a id="_idIndexMarker477"/><span class="koboSpan" id="kobo.93.1">potential bottlenecks. </span><strong class="bold"><span class="koboSpan" id="kobo.94.1">Analysis</span></strong><span class="koboSpan" id="kobo.95.1">, on the other hand, is the subsequent step where this data</span><a id="_idIndexMarker478"/><span class="koboSpan" id="kobo.96.1"> is interpreted, issues are pinpointed, and strategies for performance enhancement </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">are devised.</span></span></p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor213"/><span class="koboSpan" id="kobo.98.1">When is performance profiling and analysis used?</span></h2>
			<p><span class="koboSpan" id="kobo.99.1">The need </span><a id="_idIndexMarker479"/><span class="koboSpan" id="kobo.100.1">for performance profiling</span><a id="_idIndexMarker480"/><span class="koboSpan" id="kobo.101.1"> and analysis arises in the </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">following situations:</span></span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.103.1">Parts of an application seem slower </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">than expected</span></span></li>
				<li><span class="koboSpan" id="kobo.105.1">There’s a desire to ensure that new implementations don’t </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">degrade performance</span></span></li>
				<li><span class="koboSpan" id="kobo.107.1">Large-scale applications </span><a id="_idIndexMarker481"/><span class="koboSpan" id="kobo.108.1">need to optimize </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">resource-intensive operations</span></span></li>
				<li><span class="koboSpan" id="kobo.110.1">The goal is to offer </span><a id="_idIndexMarker482"/><span class="koboSpan" id="kobo.111.1">users a seamless experience, characterized by swift load times and </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">fluid interactions</span></span></li>
			</ul>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor214"/><span class="koboSpan" id="kobo.113.1">How does performance profiling and analysis work in Angular?</span></h2>
			<p><span class="koboSpan" id="kobo.114.1">Performance profiling captures data about an</span><a id="_idIndexMarker483"/><span class="koboSpan" id="kobo.115.1"> application’s behavior during runtime. </span><span class="koboSpan" id="kobo.115.2">For </span><a id="_idIndexMarker484"/><span class="koboSpan" id="kobo.116.1">Angular developers, a game-changer in this space is the </span><strong class="bold"><span class="koboSpan" id="kobo.117.1">Angular DevTools</span></strong><span class="koboSpan" id="kobo.118.1"> extension (</span><a href="https://angular.io/guide/devtools"><span class="koboSpan" id="kobo.119.1">https://angular.io/guide/devtools</span></a><span class="koboSpan" id="kobo.120.1">). </span><span class="koboSpan" id="kobo.120.2">This</span><a id="_idIndexMarker485"/><span class="koboSpan" id="kobo.121.1"> browser extension, tailored for Angular applications, offers insights into component tree structures and change detection cycles and even provides a</span><a id="_idIndexMarker486"/><span class="koboSpan" id="kobo.122.1"> dedicated performance profiling feature. </span><span class="koboSpan" id="kobo.122.2">It’s an indispensable tool that complements the browser’s native </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">developer tools.</span></span></p>
			<p><span class="koboSpan" id="kobo.124.1">To utilize the Angular DevTools extension for performance profiling, follow </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">these steps:</span></span></p>
			<ol>
				<li><span class="koboSpan" id="kobo.126.1">Install the Angular DevTools extension in your preferred web browser. </span><span class="koboSpan" id="kobo.126.2">The extension is available for Chrome and Firefox and can be installed from the respective browser’s extension marketplace. </span><span class="koboSpan" id="kobo.126.3">In this section, I will use the </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">Chrome browser.</span></span></li>
				<li><span class="koboSpan" id="kobo.128.1">Open the Chrome DevTools by right-clicking on an element of your Angular application and selecting </span><strong class="bold"><span class="koboSpan" id="kobo.129.1">Inspect</span></strong><span class="koboSpan" id="kobo.130.1"> (or by using the </span><em class="italic"><span class="koboSpan" id="kobo.131.1">Ctrl</span></em><span class="koboSpan" id="kobo.132.1"> + </span><em class="italic"><span class="koboSpan" id="kobo.133.1">Shift</span></em><span class="koboSpan" id="kobo.134.1"> + </span><em class="italic"><span class="koboSpan" id="kobo.135.1">I</span></em> <span class="No-Break"><span class="koboSpan" id="kobo.136.1">keyboard shortcut).</span></span></li>
				<li><span class="koboSpan" id="kobo.137.1">In the Chrome DevTools, click on the </span><strong class="bold"><span class="koboSpan" id="kobo.138.1">Angular</span></strong><span class="koboSpan" id="kobo.139.1"> tab to switch to the Angular </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">DevTools view.</span></span></li>
			</ol>
			<div>
				<div id="_idContainer102" class="IMG---Figure">
					<span class="koboSpan" id="kobo.141.1"><img src="image/B18805_10_01.jpg" alt="Figure 10.1 – The Angular DevTools tab"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.142.1">Figure 10.1 – The Angular DevTools tab</span></p>
			<ol>
				<li value="4"><span class="koboSpan" id="kobo.143.1">Within the Angular DevTools, you can enable </span><a id="_idIndexMarker487"/><span class="koboSpan" id="kobo.144.1">the performance profiling feature by clicking on the </span><a id="_idIndexMarker488"/><span class="koboSpan" id="kobo.145.1">red circle to collect performance data related to rendering, change detection, and other </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">Angular-specific activities:</span></span></li>
			</ol>
			<div>
				<div id="_idContainer103" class="IMG---Figure">
					<span class="koboSpan" id="kobo.147.1"><img src="image/B18805_10_02.jpg" alt="Figure 10.2 – Angular DevTools profiling"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.148.1">Figure 10.2 – Angular DevTools profiling</span></p>
			<ol>
				<li value="5"><span class="koboSpan" id="kobo.149.1">With performance profiling enabled, interact with your Angular application and perform typical user actions. </span><span class="koboSpan" id="kobo.149.2">The Angular DevTools extension will collect performance data in </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">real time.</span></span></li>
				<li><span class="koboSpan" id="kobo.151.1">Use Angular DevTools to inspect </span><a id="_idIndexMarker489"/><span class="koboSpan" id="kobo.152.1">various performance metrics and identify areas of concern. </span><span class="koboSpan" id="kobo.152.2">For</span><a id="_idIndexMarker490"/><span class="koboSpan" id="kobo.153.1"> example, you can analyze the time spent on rendering individual components, the number of change detection cycles, or the duration of </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">network requests.</span></span></li>
				<li><span class="koboSpan" id="kobo.155.1">Based on the collected performance data, identify components, directives, or services that contribute to performance bottlenecks. </span><span class="koboSpan" id="kobo.155.2">Look for areas where rendering or change detection takes a significant amount of time or where unnecessary data </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">fetching occurs.</span></span></li>
				<li><span class="koboSpan" id="kobo.157.1">Once performance bottlenecks have been identified, make targeted optimizations to the code, component structure, or data fetching mechanisms. </span><span class="koboSpan" id="kobo.157.2">This may involve optimizing change detection strategies, implementing memoization techniques, or introducing pagination or caching for </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">data fetching.</span></span></li>
				<li><span class="koboSpan" id="kobo.159.1">After applying optimizations, reanalyze the performance of your Angular application using the Angular DevTools. </span><span class="koboSpan" id="kobo.159.2">Validate that the optimizations have improved the identified </span><a id="_idIndexMarker491"/><span class="koboSpan" id="kobo.160.1">performance bottlenecks and have not introduced new issues. </span><span class="koboSpan" id="kobo.160.2">Iterate on</span><a id="_idIndexMarker492"/><span class="koboSpan" id="kobo.161.1"> the optimization process if further improvements </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">are necessary.</span></span></li>
			</ol>
			<p><span class="koboSpan" id="kobo.163.1">By following these steps and utilizing the Angular DevTools extension, you can gain valuable insights into Angular applications’ performance characteristics. </span><span class="koboSpan" id="kobo.163.2">This enables you to make informed optimizations and improve the overall performance of </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">the applications.</span></span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.165.1">Note</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.166.1">It’s easy to fall into the trap of over-optimization. </span><span class="koboSpan" id="kobo.166.2">Always weigh the benefits of optimization against the effort and complexity introduced. </span><span class="koboSpan" id="kobo.166.3">For example, if the component in question is relatively simple and the performance gains from implementing advanced optimization techniques are negligible or difficult to measure, it might be more practical to stick with the default change detection strategy provided by Angular. </span><span class="koboSpan" id="kobo.166.4">This ensures a balance between optimization and development effort, avoiding unnecessary complexity and potential trade-offs in code maintainability </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">and readability.</span></span></p>
			<p><span class="koboSpan" id="kobo.168.1">Performance profiling and analysis serve as the magnifying glass, revealing the intricate details of our application’s behavior and efficiency. </span><span class="koboSpan" id="kobo.168.2">In the next section, we’ll delve into the realm of lazy loading, a technique that promises to further enhance our application’s responsiveness </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">and speed.</span></span></p>
			<h1 id="_idParaDest-196"><a id="_idTextAnchor215"/><span class="koboSpan" id="kobo.170.1">Implementing lazy loading and deferring</span></h1>
			<p><strong class="bold"><span class="koboSpan" id="kobo.171.1">Lazy loading</span></strong><span class="koboSpan" id="kobo.172.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.173.1">deferring</span></strong><span class="koboSpan" id="kobo.174.1"> are design </span><a id="_idIndexMarker493"/><span class="koboSpan" id="kobo.175.1">patterns in which content is loaded only when it’s</span><a id="_idIndexMarker494"/><span class="koboSpan" id="kobo.176.1"> needed or requested, rather than loading everything upfront. </span><span class="koboSpan" id="kobo.176.2">This approach optimizes resource allocation and improves performance. </span><span class="koboSpan" id="kobo.176.3">Here is a detailed explanation of </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">these concepts:</span></span></p>
			<ul>
				<li><strong class="bold"><span class="koboSpan" id="kobo.178.1">Lazy loading</span></strong><span class="koboSpan" id="kobo.179.1">: Lazy loading is a design pattern in which content, such as Angular routes, components, or </span><a id="_idIndexMarker495"/><span class="koboSpan" id="kobo.180.1">services, is loaded dynamically and on-demand, rather than everything being uploaded upfront. </span><span class="koboSpan" id="kobo.180.2">By implementing lazy loading, unnecessary resources are not loaded initially, resulting in a smaller initial bundle size and improved application startup times. </span><span class="koboSpan" id="kobo.180.3">This approach is particularly useful in large-scale applications, where loading all resources upfront can lead to </span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">performance degradation.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.182.1">Deferring</span></strong><span class="koboSpan" id="kobo.183.1">: Deferring is a</span><a id="_idIndexMarker496"/><span class="koboSpan" id="kobo.184.1"> design pattern that involves delaying the loading or execution of certain resources, such as scripts or assets, until they are needed. </span><span class="koboSpan" id="kobo.184.2">In the context of web development, deferring typically refers to deferring the loading of JavaScript files or other resources that are not essential for the initial rendering and functionality of a web page. </span><span class="koboSpan" id="kobo.184.3">By deferring the loading of non-critical resources, the web page can be rendered and displayed more quickly, improving the perceived performance and overall user experience. </span><span class="koboSpan" id="kobo.184.4">This technique is often employed to prioritize and optimize the loading of critical resources, allowing the page to be usable as soon as possible while non-essential resources are loaded in </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">the background.</span></span></li>
			</ul>
			<h2 id="_idParaDest-197"><a id="_idTextAnchor216"/><span class="koboSpan" id="kobo.186.1">When are lazy loading and deferring used?</span></h2>
			<p><span class="koboSpan" id="kobo.187.1">Lazy loading and deferring are especially beneficial in the </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">following scenarios:</span></span></p>
			<ul>
				<li><strong class="bold"><span class="koboSpan" id="kobo.189.1">Large applications</span></strong><span class="koboSpan" id="kobo.190.1">: For applications</span><a id="_idIndexMarker497"/><span class="koboSpan" id="kobo.191.1"> with numerous features and components, loading everything at once can be resource-intensive. </span><span class="koboSpan" id="kobo.191.2">Lazy loading ensures that only the necessary components are loaded, improving the initial </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">load </span></span><span class="No-Break"><a id="_idIndexMarker498"/></span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">time.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.194.1">User roles and permissions</span></strong><span class="koboSpan" id="kobo.195.1">: In applications where different users have different roles and permissions, lazy loading can be used to load components based on user roles, ensuring that users only download the features they have </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">access to.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.197.1">Network efficiency</span></strong><span class="koboSpan" id="kobo.198.1">: For users with slower internet connections, downloading a large application can be time-consuming. </span><span class="koboSpan" id="kobo.198.2">Lazy loading can help by reducing the initial </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">download size.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.200.1">Feature-rich platforms</span></strong><span class="koboSpan" id="kobo.201.1">: In platforms </span><a id="_idIndexMarker499"/><span class="koboSpan" id="kobo.202.1">where certain features are used less frequently than others, it</span><a id="_idIndexMarker500"/><span class="koboSpan" id="kobo.203.1"> makes sense to defer those lesser-used features to improve the initial load time of the platform, resulting in </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">faster rendering.</span></span></li>
			</ul>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor217"/><span class="koboSpan" id="kobo.205.1">Example of lazy loading</span></h2>
			<p><span class="koboSpan" id="kobo.206.1">Imagine an eCommerce </span><a id="_idIndexMarker501"/><span class="koboSpan" id="kobo.207.1">platform built using Angular. </span><span class="koboSpan" id="kobo.207.2">This platform has various routes such as </span><strong class="bold"><span class="koboSpan" id="kobo.208.1">Home</span></strong><span class="koboSpan" id="kobo.209.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.210.1">Product Listings</span></strong><span class="koboSpan" id="kobo.211.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.212.1">Product Details</span></strong><span class="koboSpan" id="kobo.213.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.214.1">Cart</span></strong><span class="koboSpan" id="kobo.215.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.216.1">User Profile</span></strong><span class="koboSpan" id="kobo.217.1">. </span><span class="koboSpan" id="kobo.217.2">In a traditional loading approach, when a user visits the site, they would download all these routes/components upfront, even if they’re just browsing the </span><strong class="bold"><span class="koboSpan" id="kobo.218.1">Home</span></strong><span class="koboSpan" id="kobo.219.1"> page. </span><span class="koboSpan" id="kobo.219.2">For example, without lazy loading, the routing will look </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">like this:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.221.1">
export const appRoutes: Route[] = [
  {
    path: 'home',
    </span><strong class="bold"><span class="koboSpan" id="kobo.222.1">component: HomeComponent,</span></strong><span class="koboSpan" id="kobo.223.1">
  },
  {
    path: 'cart',
    component: CartComponent,
  },
  {
    path: 'user-profile',
    component: UserProfileComponent,
  },
]</span></pre>			<p><span class="koboSpan" id="kobo.224.1">In this code, the routing name is associated with a component. </span><span class="koboSpan" id="kobo.224.2">When the user navigates to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">home</span></strong><span class="koboSpan" id="kobo.226.1"> page, </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">HomeComponent</span></strong><span class="koboSpan" id="kobo.228.1"> will </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">be displayed:</span></span></p>
			<div>
				<div id="_idContainer104" class="IMG---Figure">
					<span class="koboSpan" id="kobo.230.1"><img src="image/B18805_10_03.jpg" alt="Figure 10.3 – Page without lazy loading"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.231.1">Figure 10.3 – Page without lazy loading</span></p>
			<p><span class="koboSpan" id="kobo.232.1">You’ll notice that when the application is loaded, it loads all the necessary scripts from the beginning. </span><span class="koboSpan" id="kobo.232.2">As you can see, the main bundle size is </span><strong class="bold"><span class="koboSpan" id="kobo.233.1">820 kB</span></strong><span class="koboSpan" id="kobo.234.1"> and is loaded in </span><strong class="bold"><span class="koboSpan" id="kobo.235.1">1.40 s</span></strong><span class="koboSpan" id="kobo.236.1">. </span><span class="koboSpan" id="kobo.236.2">When you navigate to other routes, their scripts are already ready-loaded. </span><span class="koboSpan" id="kobo.236.3">This could lead to unnecessary</span><a id="_idIndexMarker502"/><span class="koboSpan" id="kobo.237.1"> data consumption and a delay in page rendering, especially if the user never visits certain sections, such as </span><strong class="bold"><span class="koboSpan" id="kobo.238.1">Cart</span></strong><span class="koboSpan" id="kobo.239.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.240.1">User Profile</span></strong><span class="koboSpan" id="kobo.241.1">, during their session. </span><span class="koboSpan" id="kobo.241.2">Let’s see how lazy loading can improve the </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">current implementation.</span></span></p>
			<p><span class="koboSpan" id="kobo.243.1">With lazy loading, the application can be structured to load the routes </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">more intelligently:</span></span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.245.1">Initially, only the </span><strong class="bold"><span class="koboSpan" id="kobo.246.1">Home</span></strong><span class="koboSpan" id="kobo.247.1"> page is loaded when a user visits </span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">the site</span></span></li>
				<li><span class="koboSpan" id="kobo.249.1">If a user decides to view a product, the </span><strong class="bold"><span class="koboSpan" id="kobo.250.1">Products</span></strong><span class="koboSpan" id="kobo.251.1"> page is loaded on </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">the fly</span></span></li>
				<li><span class="koboSpan" id="kobo.253.1">When the user wants to check their shopping cart, the </span><strong class="bold"><span class="koboSpan" id="kobo.254.1">Cart</span></strong><span class="koboSpan" id="kobo.255.1"> page is loaded just </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">in time</span></span></li>
				<li><span class="koboSpan" id="kobo.257.1">If they decide to view or edit their profile, the </span><strong class="bold"><span class="koboSpan" id="kobo.258.1">User Profile</span></strong><span class="koboSpan" id="kobo.259.1"> page is </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">then loaded</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.261.1">Here’s a basic example of how lazy loading can </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">be implemented:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.263.1">
export const appRoutes: Route[] = [
  {
    path: '',
    pathMatch: 'full',
    redirectTo: 'home',
  },
  {
    path: 'home',
    </span><strong class="bold"><span class="koboSpan" id="kobo.264.1">loadComponent: () =&gt; import('./components/home.component'),</span></strong><span class="koboSpan" id="kobo.265.1">
  },
  {
    path: 'cart',
    loadComponent: () =&gt; import('./components/cart.component'),
  },
  {
    path: 'user-profile',
    loadComponent: () =&gt; import('./components/user-profile.component'),
  },
]</span></pre>			<p><span class="koboSpan" id="kobo.266.1">In the preceding code snippet, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">loadComponent</span></strong><span class="koboSpan" id="kobo.268.1"> property is utilized to define functions that will load the </span><a id="_idIndexMarker503"/><span class="koboSpan" id="kobo.269.1">respective component, but only when the routes are activated. </span><span class="koboSpan" id="kobo.269.2">This ensures that users only download the parts of the application they are actively engaging with, leading to faster load times and more efficient use </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">of resources.</span></span></p>
			<p><span class="koboSpan" id="kobo.271.1">Here is </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">the result:</span></span></p>
			<div>
				<div id="_idContainer105" class="IMG---Figure">
					<span class="koboSpan" id="kobo.273.1"><img src="image/B18805_10_04.jpg" alt="Figure 10.4 – Page with lazy loading"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.274.1">Figure 10.4 – Page with lazy loading</span></p>
			<p><span class="koboSpan" id="kobo.275.1">As you can see, the website only loads </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">main.js</span></strong><span class="koboSpan" id="kobo.277.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">HomeComponent</span></strong><span class="koboSpan" id="kobo.279.1"> for the first navigation. </span><span class="koboSpan" id="kobo.279.2">You’ll observe a significant enhancement as the main bundle size has decreased from </span><strong class="bold"><span class="koboSpan" id="kobo.280.1">820 kB</span></strong><span class="koboSpan" id="kobo.281.1"> to </span><strong class="bold"><span class="koboSpan" id="kobo.282.1">385 kB</span></strong><span class="koboSpan" id="kobo.283.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.284.1">844 B</span></strong><span class="koboSpan" id="kobo.285.1">, resulting in a reduced load time of roughly 1 second compared to the previous 1.4 seconds (</span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.286.1">Figure 10</span></em></span><em class="italic"><span class="koboSpan" id="kobo.287.1">.3</span></em><span class="koboSpan" id="kobo.288.1">). </span><span class="koboSpan" id="kobo.288.2">This represents a substantial performance</span><a id="_idIndexMarker504"/><span class="koboSpan" id="kobo.289.1"> improvement. </span><span class="koboSpan" id="kobo.289.2">After that, it will load </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">CartComponent</span></strong><span class="koboSpan" id="kobo.291.1"> if you navigate to the cart route, which is initiated </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">app.routes.ts</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">.</span></span></p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor218"/><span class="koboSpan" id="kobo.295.1">Example of PrimeNG deferring</span></h2>
			<p><span class="koboSpan" id="kobo.296.1">PrimeNG’s </span><strong class="bold"><span class="koboSpan" id="kobo.297.1">Defer</span></strong><span class="koboSpan" id="kobo.298.1"> directive is a</span><a id="_idIndexMarker505"/><span class="koboSpan" id="kobo.299.1"> tool that’s designed to delay the loading of content until it enters the viewport. </span><span class="koboSpan" id="kobo.299.2">In essence, it’s a form of lazy loading, but for various types of content. </span><span class="koboSpan" id="kobo.299.3">By deferring the initialization </span><a id="_idIndexMarker506"/><span class="koboSpan" id="kobo.300.1">of content until it’s needed, we can significantly improve the initial load time of </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">a page.</span></span></p>
			<p><span class="koboSpan" id="kobo.302.1">Take the eCommerce site as an example. </span><span class="koboSpan" id="kobo.302.2">The site lists hundreds of products on its </span><strong class="bold"><span class="koboSpan" id="kobo.303.1">Products</span></strong><span class="koboSpan" id="kobo.304.1"> page. </span><span class="koboSpan" id="kobo.304.2">Loading all these products at once can be overwhelming and slow. </span><span class="koboSpan" id="kobo.304.3">With PrimeNG’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">Defer</span></strong><span class="koboSpan" id="kobo.306.1">, we can </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">optimize this.</span></span></p>
			<p><span class="koboSpan" id="kobo.308.1">To do so, first, ensure you’ve imported </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">DeferModule</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.310.1">from PrimeNG:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.311.1">
import { DeferModule } from 'primeng/defer'</span></pre>			<p><span class="koboSpan" id="kobo.312.1">Now, let’s see how a PrimeNG </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">Defer</span></strong><span class="koboSpan" id="kobo.314.1"> can be set up to display the </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">product list:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.316.1">
&lt;div class="grid gap-4" </span><strong class="bold"><span class="koboSpan" id="kobo.317.1">pDefer</span></strong><span class="koboSpan" id="kobo.318.1">&gt;
  </span><strong class="bold"><span class="koboSpan" id="kobo.319.1">&lt;ng-template&gt;</span></strong><span class="koboSpan" id="kobo.320.1">
    &lt;p-card
      *ngFor="let product of products"
      [header]="product.name"
      [style]="{ width: '300px' }"
    &gt;
     &lt;!-- product content --&gt;
    &lt;/p-card&gt;
  </span><strong class="bold"><span class="koboSpan" id="kobo.321.1">&lt;/ng-template&gt;</span></strong><span class="koboSpan" id="kobo.322.1">
&lt;/div&gt;</span></pre>			<p><span class="koboSpan" id="kobo.323.1">Let’s break </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">this down:</span></span></p>
			<ul>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">&lt;div pDefer&gt;</span></strong><span class="koboSpan" id="kobo.326.1">: The purpose of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">pDefer</span></strong><span class="koboSpan" id="kobo.328.1"> directive is to defer the rendering of its contents </span><a id="_idIndexMarker507"/><span class="koboSpan" id="kobo.329.1">until later in the rendering cycle. </span><span class="koboSpan" id="kobo.329.2">This directive must be followed by an </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">ng-template</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.331.1"> element.</span></span></li>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">&lt;p-card *ngFor="let product of products"&gt;</span></strong><span class="koboSpan" id="kobo.333.1">: This element utilizes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">*ngFor</span></strong><span class="koboSpan" id="kobo.335.1"> directive to iterate over an array of </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">products</span></strong><span class="koboSpan" id="kobo.337.1">, rendering one </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">&lt;p-card&gt;</span></strong><span class="koboSpan" id="kobo.339.1"> for each product in </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">the array.</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.341.1">After the implementation, the content of the product list will not appear until it becomes visible in </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">the scroll.</span></span></p>
			<p><span class="koboSpan" id="kobo.343.1">PrimeNG </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">Defer</span></strong><span class="koboSpan" id="kobo.345.1"> is also beneficial when you want to fetch product data from an API after the product list is in the viewport, which will greatly enhance the performance of your application. </span><span class="koboSpan" id="kobo.345.2">Here is </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">an example:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.347.1">
// products.components.ts
</span><strong class="bold"><span class="koboSpan" id="kobo.348.1">&lt;div pDefer (onLoad)="loadAnotherProducts()"&gt;</span></strong><span class="koboSpan" id="kobo.349.1">
  &lt;ng-template&gt;
    &lt;primengbook-product-list [products]="anotherProducts" /&gt;
  &lt;/ng-template&gt;
&lt;/div&gt;
...
</span><span class="koboSpan" id="kobo.349.2">loadAnotherProducts() {
  </span><strong class="bold"><span class="koboSpan" id="kobo.350.1">this.anotherProducts = this.productService.loadProducts()</span></strong><span class="koboSpan" id="kobo.351.1">
}</span></pre>			<p><span class="koboSpan" id="kobo.352.1">Let’s break down </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">the code:</span></span></p>
			<ul>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">&lt;div pDefer (onLoad)="loadAnotherProducts()"&gt;</span></strong><span class="koboSpan" id="kobo.355.1">: This </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">&lt;div&gt;</span></strong><span class="koboSpan" id="kobo.357.1"> element is using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">pDefer</span></strong><span class="koboSpan" id="kobo.359.1"> directive, which defers the loading products and rendering of its contents until the element is in </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">the viewport.</span></span></li>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">loadAnotherProducts() { ... </span><span class="koboSpan" id="kobo.361.2">}</span></strong><span class="koboSpan" id="kobo.362.1">: This method is executed when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">(onLoad)</span></strong><span class="koboSpan" id="kobo.364.1"> event is</span><a id="_idIndexMarker508"/><span class="koboSpan" id="kobo.365.1"> triggered. </span><span class="koboSpan" id="kobo.365.2">Inside the method, it calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">this.productService.loadProducts()</span></strong><span class="koboSpan" id="kobo.367.1"> to load the products and assign the result to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">anotherProducts</span></strong><span class="koboSpan" id="kobo.369.1"> property in </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">the component.</span></span></li>
			</ul>
			<p class="callout-heading"><span class="koboSpan" id="kobo.371.1">Note</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.372.1">If you are working with </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">Table</span></strong><span class="koboSpan" id="kobo.374.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">Tree</span></strong><span class="koboSpan" id="kobo.376.1">, or a long list of items, you can implement </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">Virtual Scroller</span></strong><span class="koboSpan" id="kobo.378.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">Pagination</span></strong><span class="koboSpan" id="kobo.380.1"> to help enhance performance and increase </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">user experience.</span></span></p>
			<p><span class="koboSpan" id="kobo.382.1">Harnessing the power of lazy loading and deferring can significantly enhance the performance of our applications, ensuring that users only load what they need when they need it. </span><span class="koboSpan" id="kobo.382.2">In the next section, we’ll delve into another crucial aspect of Angular performance: understanding and managing </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">change detection.</span></span></p>
			<h1 id="_idParaDest-200"><a id="_idTextAnchor219"/><span class="koboSpan" id="kobo.384.1">Working with change detection</span></h1>
			<p><strong class="bold"><span class="koboSpan" id="kobo.385.1">Change detection</span></strong><span class="koboSpan" id="kobo.386.1"> is the process by which Angular determines if components need to be updated in response to data changes. </span><span class="koboSpan" id="kobo.386.2">Whenever the data-bound properties of a component change, Angular checks if the</span><a id="_idIndexMarker509"/><span class="koboSpan" id="kobo.387.1"> view needs to be updated to reflect those changes. </span><span class="koboSpan" id="kobo.387.2">This process is automatic, but it’s essential to understand its workings to </span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">optimize performance.</span></span></p>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor220"/><span class="koboSpan" id="kobo.389.1">How does change detection work?</span></h2>
			<p><span class="koboSpan" id="kobo.390.1">The change detection process in Angular follows a unidirectional flow. </span><span class="koboSpan" id="kobo.390.2">It starts from the root component and traverses down the component tree, checking for changes in each component. </span><span class="koboSpan" id="kobo.390.3">Here’s a brief overview of</span><a id="_idIndexMarker510"/><span class="koboSpan" id="kobo.391.1"> how change detection works </span><span class="No-Break"><span class="koboSpan" id="kobo.392.1">in Angular:</span></span></p>
			<ol>
				<li><strong class="bold"><span class="koboSpan" id="kobo.393.1">Initialization</span></strong><span class="koboSpan" id="kobo.394.1">: During component initialization, Angular sets up the component’s change detector and initializes the component’s properties </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">and bindings.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.396.1">Change detection strategy</span></strong><span class="koboSpan" id="kobo.397.1">: Angular provides two change </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">detection strategies:</span></span><ul><li><span class="koboSpan" id="kobo.399.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">Default</span></strong><span class="koboSpan" id="kobo.401.1"> strategy triggers change detection for a component whenever any of its input properties change or when an event binding is fired. </span><span class="koboSpan" id="kobo.401.2">Take the following component tree as </span><span class="No-Break"><span class="koboSpan" id="kobo.402.1">an example:</span></span></li></ul></li>
			</ol>
			<div>
				<div id="_idContainer106" class="IMG---Figure">
					<span class="koboSpan" id="kobo.403.1"><img src="image/B18805_10_05.jpg" alt="  Figure 10.5 – Change detection – the default strategy"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.404.1">Figure 10.5 – Change detection – the default strategy</span></p>
			<p class="list-inset"><span class="koboSpan" id="kobo.405.1">    When an event occurs on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">ProductList</span></strong><span class="koboSpan" id="kobo.407.1"> component, the change detection process</span><a id="_idIndexMarker511"/><span class="koboSpan" id="kobo.408.1"> initiates, propagating from the root level (</span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">AppComponent</span></strong><span class="koboSpan" id="kobo.410.1">) through all of its </span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">descendant components.</span></span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.412.1">On the other hand, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">OnPush</span></strong><span class="koboSpan" id="kobo.414.1"> strategy triggers change detection only when an input property changes or when the component receives an event from its template or a component in its view hierarchy. </span><span class="koboSpan" id="kobo.414.2">In the same scenario previously illustrated in </span><em class="italic"><span class="koboSpan" id="kobo.415.1">Figure 10.5</span></em><span class="koboSpan" id="kobo.416.1">, introducing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">OnPush</span></strong><span class="koboSpan" id="kobo.418.1"> change detection strategy to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">ProductListDefer</span></strong><span class="koboSpan" id="kobo.420.1"> component alters the behavior of the change </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">detection process:</span></span></li>
			</ul>
			<div>
				<div id="_idContainer107" class="IMG---Figure">
					<span class="koboSpan" id="kobo.422.1"><img src="image/B18805_10_06.jpg" alt="  Figure 10.6 – Change detection – the OnPush strategy"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.423.1">Figure 10.6 – Change detection – the OnPush strategy</span></p>
			<p class="list-inset"><span class="koboSpan" id="kobo.424.1">    Now, when an event occurs on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">ProductList</span></strong><span class="koboSpan" id="kobo.426.1"> component, change detection is limited to the hierarchy</span><a id="_idIndexMarker512"/><span class="koboSpan" id="kobo.427.1"> from </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">AppComponent</span></strong><span class="koboSpan" id="kobo.429.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">Products</span></strong><span class="koboSpan" id="kobo.431.1"> and down to </span><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">ProductList</span></strong><span class="koboSpan" id="kobo.433.1">. </span><span class="koboSpan" id="kobo.433.2">Notably, there is no change detection on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">ProductListDefer</span></strong><span class="koboSpan" id="kobo.435.1"> component because no new reference is passed to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">ProductListDefer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.437.1"> component.</span></span></p>
			<ol>
				<li value="3"><strong class="bold"><span class="koboSpan" id="kobo.438.1">Change detection cycle</span></strong><span class="koboSpan" id="kobo.439.1">: Angular’s change detection system follows a cyclic process. </span><span class="koboSpan" id="kobo.439.2">In each cycle, the change detection process is performed for all components in the component tree. </span><span class="koboSpan" id="kobo.439.3">It involves the </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">following steps:</span></span><ol><li class="upper-roman"><strong class="bold"><span class="koboSpan" id="kobo.441.1">Change detection check</span></strong><span class="koboSpan" id="kobo.442.1">: Angular checks the component’s properties, bindings, and other inputs to detect changes. </span><span class="koboSpan" id="kobo.442.2">It compares the current values with the values that were stored during the previous change </span><span class="No-Break"><span class="koboSpan" id="kobo.443.1">detection cycle.</span></span></li><li class="upper-roman"><strong class="bold"><span class="koboSpan" id="kobo.444.1">Update view</span></strong><span class="koboSpan" id="kobo.445.1">: If a change is detected, Angular updates the component’s view by updating the DOM elements associated with the changed properties </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">or bindings.</span></span></li><li class="upper-roman"><strong class="bold"><span class="koboSpan" id="kobo.447.1">Propagation</span></strong><span class="koboSpan" id="kobo.448.1">: If the component’s view is updated, Angular propagates the changes to the child components in the component tree, triggering their change detection </span><span class="No-Break"><span class="koboSpan" id="kobo.449.1">process recursively.</span></span></li></ol></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.450.1">Manually trigger change detection</span></strong><span class="koboSpan" id="kobo.451.1">: This can be a powerful tool in Angular when you want to explicitly update the view based on changes that might not be automatically</span><a id="_idIndexMarker513"/><span class="koboSpan" id="kobo.452.1"> detected. </span><span class="koboSpan" id="kobo.452.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">ChangeDetectorRef</span></strong><span class="koboSpan" id="kobo.454.1"> class provides a set of functions to interact with the change </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">detection mechanism:</span></span><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">markForCheck()</span></strong><span class="koboSpan" id="kobo.457.1">: This function marks the component and its ancestors as needing checking during the next change detection cycle. </span><span class="koboSpan" id="kobo.457.2">Even if the component is not directly involved in the change, marking it for check ensures that its view will </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">be updated.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">detach()</span></strong><span class="koboSpan" id="kobo.460.1">: This function detaches the component’s change detector from the change detector tree. </span><span class="koboSpan" id="kobo.460.2">This means that the component will be skipped during the change detection process until it </span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">is reattached.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">detectChanges()</span></strong><span class="koboSpan" id="kobo.463.1">: Invoking </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">detectChanges()</span></strong><span class="koboSpan" id="kobo.465.1"> triggers a change detection cycle for the component and its descendants. </span><span class="koboSpan" id="kobo.465.2">This is particularly useful when you want to manually check for changes in response to </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">specific events.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">reattach()</span></strong><span class="koboSpan" id="kobo.468.1">: This function reverses the effect of </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">detach()</span></strong><span class="koboSpan" id="kobo.470.1">. </span><span class="koboSpan" id="kobo.470.2">It reattaches the component’s change detector to the change detector tree, allowing it to participate in subsequent change </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">detection cycles.</span></span></li></ul></li>
			</ol>
			<p><span class="koboSpan" id="kobo.472.1">One of the pivotal elements in Angular’s change detection mechanism is </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">zone.js</span></strong><span class="koboSpan" id="kobo.474.1">. </span><span class="koboSpan" id="kobo.474.2">This library plays a crucial role by “monkey-patching” most asynchronous operations in a browser, such as user interactions, HTTP requests, </span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">and timers.</span></span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.476.1">Note</span></p>
			<p class="callout"><strong class="bold"><span class="koboSpan" id="kobo.477.1">Monkey patching</span></strong><span class="koboSpan" id="kobo.478.1"> is a technique that </span><a id="_idIndexMarker514"/><span class="koboSpan" id="kobo.479.1">allows for the modification, extension, or even suppression of the default behavior of a code segment, all without requiring any direct changes to its </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">source code.</span></span></p>
			<p><span class="koboSpan" id="kobo.481.1">When these operations are</span><a id="_idIndexMarker515"/><span class="koboSpan" id="kobo.482.1"> completed, </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">zone.js</span></strong><span class="koboSpan" id="kobo.484.1"> notifies Angular to run change detection. </span><span class="koboSpan" id="kobo.484.2">Essentially, it acts as a watchdog, keeping an eye on all asynchronous tasks. </span><span class="koboSpan" id="kobo.484.3">Once any of these tasks are complete, </span><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">zone.js</span></strong><span class="koboSpan" id="kobo.486.1"> informs Angular to check components and update the view </span><span class="No-Break"><span class="koboSpan" id="kobo.487.1">if necessary.</span></span></p>
			<p><span class="koboSpan" id="kobo.488.1">For instance, when a user clicks a button, </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">zone.js</span></strong><span class="koboSpan" id="kobo.490.1"> detects this interaction and tells Angular that something might have changed. </span><span class="koboSpan" id="kobo.490.2">Angular then runs the change detection process, checking if there are any actual changes to update in </span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">the view.</span></span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.492.1">Note</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.493.1">For third-party scripts, one of the techniques that can help improve the performance of your application is to load the script and run the logic outside of Angular </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">NgZone (</span></span><a href="https://angular.io/api/core/NgZone#runoutsideangular"><span class="No-Break"><span class="koboSpan" id="kobo.495.1">https://angular.io/api/core/NgZone#runoutsideangular</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.496.1">).</span></span></p>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor221"/><span class="koboSpan" id="kobo.497.1">How change detection strategies affect performance</span></h2>
			<p><span class="koboSpan" id="kobo.498.1">The default change</span><a id="_idIndexMarker516"/><span class="koboSpan" id="kobo.499.1"> detection strategy is thorough but can be inefficient for large applications or complex component trees. </span><span class="koboSpan" id="kobo.499.2">Every minor data change triggers a check across all components, which can lead to lag or janky animations, especially on </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">slower devices.</span></span></p>
			<p><span class="koboSpan" id="kobo.501.1">One way to improve performance is to utilize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">OnPush</span></strong><span class="koboSpan" id="kobo.503.1"> strategy, in which we’re telling Angular to be more selective about when it checks for changes. </span><span class="koboSpan" id="kobo.503.2">This can lead to a noticeable performance boost as Angular will skip checking components that we know haven’t changed. </span><span class="koboSpan" id="kobo.503.3">However, it also means we need to be more mindful of when and how data changes to ensure our views remain up </span><span class="No-Break"><span class="koboSpan" id="kobo.504.1">to date.</span></span></p>
			<p><span class="koboSpan" id="kobo.505.1">Imagine that we have two lists that display a list of products using PrimeNG components. </span><span class="koboSpan" id="kobo.505.2">By default, Angular checks for changes in this component and all its children every time something happens in our application. </span><span class="koboSpan" id="kobo.505.3">However, if our product lists don’t change frequently, this can be overkill and lead to </span><span class="No-Break"><span class="koboSpan" id="kobo.506.1">performance issues.</span></span></p>
			<p><span class="koboSpan" id="kobo.507.1">Let’s look into the details </span><a id="_idIndexMarker517"/><span class="koboSpan" id="kobo.508.1">of the default change detection strategy. </span><span class="koboSpan" id="kobo.508.2">Here is the sample code for the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.509.1">Products</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.510.1"> page:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.511.1">
@Component({
  standalone: true,
  imports: [CommonModule, ProductListComponent, FormsModule, InputTextModule],
  template: `
    &lt;h2&gt;Products&lt;/h2&gt;
    &lt;div class="p-input-icon-left mb-8"&gt;
      &lt;i class="pi pi-search"&gt;&lt;/i&gt;
      &lt;input
        type="text"
        pInputText
        [(ngModel)]="productName"
        (keyup)="filterProduct()"
      /&gt;
    &lt;/div&gt;
    &lt;primengbook-product-list [products]="filteredProducts" /&gt;
    &lt;primengbook-product-list [products]="anotherProducts" /&gt;
  `,
})
export default class ProductsComponent {
  ...
</span><span class="koboSpan" id="kobo.511.2">  filterProduct() {...}
}</span></pre>			<p><span class="koboSpan" id="kobo.512.1">The preceding code snippet is an example of an Angular component called </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">ProductsComponent</span></strong><span class="koboSpan" id="kobo.514.1">. </span><span class="koboSpan" id="kobo.514.2">Let’s break down the code and explain </span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">its functionality:</span></span></p>
			<ul>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">&lt;input type="text" pInputText (keyup)="filterProduct()" ... </span><span class="koboSpan" id="kobo.516.2">/&gt;</span></strong><span class="koboSpan" id="kobo.517.1">: This defines a PrimeNG input field that executes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">filterProduct()</span></strong><span class="koboSpan" id="kobo.519.1"> method whenever a key is released in the </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">input field</span></span></li>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">&lt;primengbook-product-list [products]="..." </span><span class="koboSpan" id="kobo.521.2">/&gt;</span></strong><span class="koboSpan" id="kobo.522.1">: This represents a custom component called </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">primengbook-product-list</span></strong><span class="koboSpan" id="kobo.524.1"> and binds the </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">filteredProducts</span></strong><span class="koboSpan" id="kobo.526.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">anotherProducts</span></strong><span class="koboSpan" id="kobo.528.1"> property of the component to </span><a id="_idIndexMarker518"/><span class="koboSpan" id="kobo.529.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">products</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.531.1">input property</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.532.1">This is an example of a standalone component utilizing the default change detection strategy, which is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">Default</span></strong><span class="koboSpan" id="kobo.534.1"> by default. </span><span class="koboSpan" id="kobo.534.2">Let’s observe how the application behaves in </span><span class="No-Break"><span class="koboSpan" id="kobo.535.1">this scenario:</span></span></p>
			<div>
				<div id="_idContainer108" class="IMG---Figure">
					<span class="koboSpan" id="kobo.536.1"><img src="image/B18805_10_07.jpg" alt="Figure 10.7 – A page using the default change detection strategy"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.537.1">Figure 10.7 – A page using the default change detection strategy</span></p>
			<p><span class="koboSpan" id="kobo.538.1">As you can see, after we type the keyword for filtering products, it rerenders the two lists of products and the total time spent for the entire app is 4.4 ms, even though we only do the search </span><a id="_idIndexMarker519"/><span class="koboSpan" id="kobo.539.1">on one </span><span class="No-Break"><span class="koboSpan" id="kobo.540.1">product list.</span></span></p>
			<p><span class="koboSpan" id="kobo.541.1">The ideal situation is that when you search, it will only touch one product list. </span><span class="koboSpan" id="kobo.541.2">To optimize the code so that it follows this, we can set the change detection strategy to </span><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">OnPush</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.543.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">ProductListComponent</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.545.1">:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.546.1">
@Component({
  selector: 'primengbook-product-list',
  standalone: true,
  imports: [CommonModule, CardModule, ButtonModule],
</span><strong class="bold"><span class="koboSpan" id="kobo.547.1">  changeDetection: ChangeDetectionStrategy.OnPush,</span></strong><span class="koboSpan" id="kobo.548.1">
  ...
</span><span class="koboSpan" id="kobo.548.2">})
export class ProductListComponent {
  @Input() products: Product[] = []
  ...
</span><span class="koboSpan" id="kobo.548.3">}</span></pre>			<p><span class="koboSpan" id="kobo.549.1">With this setup, Angular will only check the one </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">ProductListComponent</span></strong><span class="koboSpan" id="kobo.551.1"> for changes when its</span><a id="_idIndexMarker520"/><span class="koboSpan" id="kobo.552.1"> input properties change. </span><span class="koboSpan" id="kobo.552.2">This means that Angular won’t waste cycles checking unrelated components. </span><span class="koboSpan" id="kobo.552.3">Let’s see how the application performs </span><span class="No-Break"><span class="koboSpan" id="kobo.553.1">this time:</span></span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer109" class="IMG---Figure">
					<span class="koboSpan" id="kobo.554.1"><img src="image/B18805_10_08.jpg" alt="Figure 10.8 – The page with the default change detection strategy"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.555.1">Figure 10.8 – The page with the default change detection strategy</span></p>
			<p><span class="koboSpan" id="kobo.556.1">You’ll notice that when we search, our application only rerenders one product list, which reduced the time spent from 4.4 ms to 1.1 ms in total. </span><span class="koboSpan" id="kobo.556.2">This is a significant improvement if your application </span><span class="No-Break"><span class="koboSpan" id="kobo.557.1">is complex.</span></span></p>
			<h2 id="_idParaDest-203"><a id="_idTextAnchor222"/><span class="koboSpan" id="kobo.558.1">Potential pitfalls of OnPush</span></h2>
			<p><span class="koboSpan" id="kobo.559.1">While </span><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">OnPush</span></strong><span class="koboSpan" id="kobo.561.1"> is powerful, it’s not without its quirks. </span><span class="koboSpan" id="kobo.561.2">One common issue you may run into is that changes made inside</span><a id="_idIndexMarker521"/><span class="koboSpan" id="kobo.562.1"> the component (such as user interactions) won’t trigger change detection. </span><span class="koboSpan" id="kobo.562.2">This can lead to situations where the UI doesn’t update, even though the data </span><span class="No-Break"><span class="koboSpan" id="kobo.563.1">has changed.</span></span></p>
			<p><span class="koboSpan" id="kobo.564.1">Another challenge is when working with objects and arrays. </span><span class="koboSpan" id="kobo.564.2">If you modify an object or array that’s an input property, but the reference remains the same, Angular won’t detect the change. </span><span class="koboSpan" id="kobo.564.3">This is where libraries such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">immutable.js</span></strong><span class="koboSpan" id="kobo.566.1"> or Angular Signals come </span><span class="No-Break"><span class="koboSpan" id="kobo.567.1">into play:</span></span></p>
			<ul>
				<li><strong class="bold"><span class="koboSpan" id="kobo.568.1">Immutable.js</span></strong><span class="koboSpan" id="kobo.569.1">: This offers immutable data structures such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.570.1">List</span></strong><span class="koboSpan" id="kobo.571.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.572.1">Map</span></strong><span class="koboSpan" id="kobo.573.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.574.1">Set</span></strong><span class="koboSpan" id="kobo.575.1"> that, by design, cannot be </span><a id="_idIndexMarker522"/><span class="koboSpan" id="kobo.576.1">modified after creation. </span><span class="koboSpan" id="kobo.576.2">This immutability ensures that any change to data results in a new object reference, making it more efficient for Angular to detect differences. </span><span class="koboSpan" id="kobo.576.3">Furthermore, </span><strong class="source-inline"><span class="koboSpan" id="kobo.577.1">Immutable.js</span></strong><span class="koboSpan" id="kobo.578.1"> encourages the use of pure functions when modifying data, creating new instances of data structures while preserving the original data. </span><span class="koboSpan" id="kobo.578.2">Angular can then efficiently identify changes by comparing </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">object references.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.580.1">Signals</span></strong><span class="koboSpan" id="kobo.581.1"> (</span><a href="https://angular.io/guide/signals"><span class="koboSpan" id="kobo.582.1">https://angular.io/guide/signals</span></a><span class="koboSpan" id="kobo.583.1">): Matured in Angular v17, it’s a native solution that enables Angular to optimize rendering updates more efficiently. </span><span class="koboSpan" id="kobo.583.2">A signal</span><a id="_idIndexMarker523"/><span class="koboSpan" id="kobo.584.1"> serves as a wrapper for a value and can notify interested consumers when that value changes. </span><span class="koboSpan" id="kobo.584.2">Signals have the flexibility to hold various types of values, ranging from basic primitives to complex data structures. </span><span class="koboSpan" id="kobo.584.3">Using Signals </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">update</span></strong><span class="koboSpan" id="kobo.586.1"> also enforces an immutable approach, which is a usual practice when working with </span><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">OnPush</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.588.1">change detection.</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.589.1">I highly recommend using Signals when it’s ready for production to optimize the rendering updates since it is a built-in solution from Angular instead of a </span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">third-party library.</span></span></p>
			<p><span class="koboSpan" id="kobo.591.1">In the realm of Angular, understanding change detection strategies is pivotal for ensuring our applications run efficiently. </span><span class="koboSpan" id="kobo.591.2">Next, let’s delve into another crucial aspect of Angular performance: optimizing data binding to further enhance our app’s responsiveness </span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">and speed.</span></span></p>
			<h1 id="_idParaDest-204"><a id="_idTextAnchor223"/><span class="koboSpan" id="kobo.593.1">Optimizing data binding</span></h1>
			<p><span class="koboSpan" id="kobo.594.1">At its core, </span><strong class="bold"><span class="koboSpan" id="kobo.595.1">data binding</span></strong><span class="koboSpan" id="kobo.596.1"> in Angular is about keeping your view and component data in sync. </span><span class="koboSpan" id="kobo.596.2">It’s the magic that allows a </span><a id="_idIndexMarker524"/><span class="koboSpan" id="kobo.597.1">change in your component data to reflect instantly in your view and vice versa. </span><span class="koboSpan" id="kobo.597.2">However, not all data changes are equal. </span><span class="koboSpan" id="kobo.597.3">Some are frequent and minor, while others are rare but significant. </span><span class="koboSpan" id="kobo.597.4">Optimized data binding is about being selective, updating the view only when truly necessary, and doing so in the most </span><span class="No-Break"><span class="koboSpan" id="kobo.598.1">efficient manner.</span></span></p>
			<h2 id="_idParaDest-205"><a id="_idTextAnchor224"/><span class="koboSpan" id="kobo.599.1">When is optimized data binding used?</span></h2>
			<p><span class="koboSpan" id="kobo.600.1">Optimized data binding</span><a id="_idIndexMarker525"/><span class="koboSpan" id="kobo.601.1"> techniques are typically employed in the </span><span class="No-Break"><span class="koboSpan" id="kobo.602.1">following scenarios:</span></span></p>
			<ul>
				<li><strong class="bold"><span class="koboSpan" id="kobo.603.1">Large datasets</span></strong><span class="koboSpan" id="kobo.604.1">: When working with large datasets, updating the entire view whenever a small portion of the data changes can be inefficient. </span><span class="koboSpan" id="kobo.604.2">Optimized data binding techniques help identify and update only the relevant portions of the view, minimizing unnecessary updates and </span><span class="No-Break"><span class="koboSpan" id="kobo.605.1">improving performance.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.606.1">Frequent updates</span></strong><span class="koboSpan" id="kobo.607.1">: In applications where data changes frequently, traditional data binding approaches can lead to excessive re-rendering and unnecessary DOM manipulations. </span><span class="koboSpan" id="kobo.607.2">Optimized data binding techniques help optimize data change detection and update processes to reduce overhead and </span><span class="No-Break"><span class="koboSpan" id="kobo.608.1">improve responsiveness.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.609.1">Complex computation</span></strong><span class="koboSpan" id="kobo.610.1">: In some cases, data binding involves computationally expensive operations, such as sorting or filtering large arrays. </span><span class="koboSpan" id="kobo.610.2">Optimized data binding techniques can optimize these operations by selectively updating only the affected parts of the view, rather than re-rendering the </span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">entire dataset.</span></span></li>
			</ul>
			<h2 id="_idParaDest-206"><a id="_idTextAnchor225"/><span class="koboSpan" id="kobo.612.1">A few optimized data binding techniques</span></h2>
			<p><span class="koboSpan" id="kobo.613.1">Optimizing data binding in Angular revolves</span><a id="_idIndexMarker526"/><span class="koboSpan" id="kobo.614.1"> around a few </span><span class="No-Break"><span class="koboSpan" id="kobo.615.1">key strategies:</span></span></p>
			<ul>
				<li><strong class="bold"><span class="koboSpan" id="kobo.616.1">The trackBy function</span></strong><span class="koboSpan" id="kobo.617.1">: When using </span><strong class="source-inline"><span class="koboSpan" id="kobo.618.1">*ngFor</span></strong><span class="koboSpan" id="kobo.619.1"> to loop </span><a id="_idIndexMarker527"/><span class="koboSpan" id="kobo.620.1">through items, by default, Angular checks each item in the list to detect changes. </span><span class="koboSpan" id="kobo.620.2">By using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">trackBy</span></strong><span class="koboSpan" id="kobo.622.1"> function, you can instruct Angular to track items based on their unique IDs, reducing </span><span class="No-Break"><span class="koboSpan" id="kobo.623.1">unnecessary checks.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.624.1">Pure pipes</span></strong><span class="koboSpan" id="kobo.625.1">: Pipes transform data in your template. </span><span class="koboSpan" id="kobo.625.2">A pure pipe only re-evaluates when the input</span><a id="_idIndexMarker528"/><span class="koboSpan" id="kobo.626.1"> changes, making it more efficient than its impure counterparts. </span><span class="koboSpan" id="kobo.626.2">It’s crucial to bear in mind that making external requests within pipes can cause performance issues and should </span><span class="No-Break"><span class="koboSpan" id="kobo.627.1">be avoided.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.628.1">OnPush change detection strategy</span></strong><span class="koboSpan" id="kobo.629.1">: By utilizing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">OnPush</span></strong><span class="koboSpan" id="kobo.631.1"> change detection strategy, Angular only triggers change detection for a component when its input properties change or when an event is raised within </span><span class="No-Break"><span class="koboSpan" id="kobo.632.1">the component.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.633.1">Immutable data structures</span></strong><span class="koboSpan" id="kobo.634.1">: Using immutable data structures can improve data binding</span><a id="_idIndexMarker529"/><span class="koboSpan" id="kobo.635.1"> performance. </span><span class="koboSpan" id="kobo.635.2">Immutable objects are not modified directly; instead, they create new instances when changes occur. </span><span class="koboSpan" id="kobo.635.3">This allows Angular to detect changes more efficiently and </span><span class="No-Break"><span class="koboSpan" id="kobo.636.1">optimize rendering.</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.637.1">In the following sections, we will explore examples of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.638.1">trackBy</span></strong><span class="koboSpan" id="kobo.639.1"> function and </span><span class="No-Break"><span class="koboSpan" id="kobo.640.1">pure pipes.</span></span></p>
			<h2 id="_idParaDest-207"><a id="_idTextAnchor226"/><span class="koboSpan" id="kobo.641.1">Optimized data binding example – the trackBy function</span></h2>
			<p><span class="koboSpan" id="kobo.642.1">Imagine an eCommerce platform displaying a list of products. </span><span class="koboSpan" id="kobo.642.2">Each product has a name, price, and rating. </span><span class="koboSpan" id="kobo.642.3">With </span><a id="_idIndexMarker530"/><span class="koboSpan" id="kobo.643.1">thousands of products, any </span><a id="_idIndexMarker531"/><span class="koboSpan" id="kobo.644.1">change in the product list, such as a price update, could potentially trigger a massive </span><span class="No-Break"><span class="koboSpan" id="kobo.645.1">view update.</span></span></p>
			<p><span class="koboSpan" id="kobo.646.1">Using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.647.1">trackBy</span></strong><span class="koboSpan" id="kobo.648.1"> function, we can ensure that only the affected product gets updated in </span><span class="No-Break"><span class="koboSpan" id="kobo.649.1">the view:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.650.1">
&lt;div *ngFor="let product of products; </span><strong class="bold"><span class="koboSpan" id="kobo.651.1">trackBy: trackByProductId</span></strong><span class="koboSpan" id="kobo.652.1">"&gt;
  {{ product.name }} - {{ product.price | currency }}
&lt;/div&gt;
...
</span><span class="koboSpan" id="kobo.652.2">trackByProductId(_: number, product: Product): number {
  return product.id
}</span></pre>			<p><span class="koboSpan" id="kobo.653.1">In this example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">trackBy</span></strong><span class="koboSpan" id="kobo.655.1"> function ensures that Angular only updates the view for products with actual change based on product </span><span class="No-Break"><span class="koboSpan" id="kobo.656.1">id value.</span></span></p>
			<p><span class="koboSpan" id="kobo.657.1">PrimeNG also seamlessly</span><a id="_idIndexMarker532"/><span class="koboSpan" id="kobo.658.1"> supports the </span><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">trackBy</span></strong><span class="koboSpan" id="kobo.660.1"> function. </span><span class="koboSpan" id="kobo.660.2">Since version 16.x, PrimeNG provides the </span><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">trackBy</span></strong><span class="koboSpan" id="kobo.662.1"> property, where you can pass </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">trackBy</span></strong><span class="koboSpan" id="kobo.664.1"> function to the data binding in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">DataView</span></strong><span class="koboSpan" id="kobo.666.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">OrderList</span></strong><span class="koboSpan" id="kobo.668.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">PickList</span></strong><span class="koboSpan" id="kobo.670.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.671.1">Tree</span></strong><span class="koboSpan" id="kobo.672.1"> components. </span><span class="koboSpan" id="kobo.672.2">Here’s an example of how to </span><span class="No-Break"><span class="koboSpan" id="kobo.673.1">use it:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.674.1">
 &lt;p-dataView
  ...
</span><span class="koboSpan" id="kobo.674.2">  </span><strong class="bold"><span class="koboSpan" id="kobo.675.1">[trackBy]="trackByProductId"</span></strong><span class="koboSpan" id="kobo.676.1">
&gt;
  &lt;!-- DataView content --&gt;
&lt;/p-dataView&gt;</span></pre>			<p><span class="koboSpan" id="kobo.677.1">As demonstrated in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.678.1">DataView</span></strong><span class="koboSpan" id="kobo.679.1"> component, you can assign the </span><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">trackByProductId</span></strong><span class="koboSpan" id="kobo.681.1"> function</span><a id="_idIndexMarker533"/><span class="koboSpan" id="kobo.682.1"> to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.683.1">trackBy</span></strong><span class="koboSpan" id="kobo.684.1"> property. </span><span class="koboSpan" id="kobo.684.2">This configuration ensures that the view is only updated when the product ID </span><span class="No-Break"><span class="koboSpan" id="kobo.685.1">value changes.</span></span></p>
			<h2 id="_idParaDest-208"><a id="_idTextAnchor227"/><span class="koboSpan" id="kobo.686.1">Optimized data binding example – pure pipes</span></h2>
			<p><span class="koboSpan" id="kobo.687.1">Suppose you have an</span><a id="_idIndexMarker534"/><span class="koboSpan" id="kobo.688.1"> Angular application that displays a list of products. </span><span class="koboSpan" id="kobo.688.2">Each product has properties such as name, price, and quantity. </span><span class="koboSpan" id="kobo.688.3">The </span><a id="_idIndexMarker535"/><span class="koboSpan" id="kobo.689.1">application also allows the user to calculate the product’s pricing using a calculation based on the existing </span><span class="No-Break"><span class="koboSpan" id="kobo.690.1">product quantity.</span></span></p>
			<p><span class="koboSpan" id="kobo.691.1">Without using pure pipes, you might have a component template that looks </span><span class="No-Break"><span class="koboSpan" id="kobo.692.1">like this:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.693.1">
&lt;span class="text-2xl font-semibold"&gt;
{{
  '$' + </span><strong class="bold"><span class="koboSpan" id="kobo.694.1">calculateTotal(product.quantity)</span></strong><span class="koboSpan" id="kobo.695.1">
}}
&lt;/span&gt;</span></pre>			<p><span class="koboSpan" id="kobo.696.1">In this example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">calculateTotal</span></strong><span class="koboSpan" id="kobo.698.1"> function is called for each product to calculate the total price based on the existing product quantity. </span><span class="koboSpan" id="kobo.698.2">Consider the scenario where the </span><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">calculateTotal</span></strong><span class="koboSpan" id="kobo.700.1"> function is </span><a id="_idIndexMarker536"/><span class="koboSpan" id="kobo.701.1">a custom function that performs a complex calculation. </span><span class="koboSpan" id="kobo.701.2">Let’s look at </span><span class="No-Break"><span class="koboSpan" id="kobo.702.1">the result:</span></span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer110" class="IMG---Figure">
					<span class="koboSpan" id="kobo.703.1"><img src="image/B18805_10_09.jpg" alt="Figure 10.9 – Calculating the total price from the template"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.704.1">Figure 10.9 – Calculating the total price from the template</span></p>
			<p><span class="koboSpan" id="kobo.705.1">As you can see, without any optimization, every time a change is made to the product or the page, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.706.1">calculateTotal</span></strong><span class="koboSpan" id="kobo.707.1"> function would be called for all products, even if only a single product’s quantity has changed. </span><span class="koboSpan" id="kobo.707.2">This leads to unnecessary executions, even if only a single product’s quantity</span><a id="_idIndexMarker537"/><span class="koboSpan" id="kobo.708.1"> has changed, resulting in 20 executions, as indicated in the console log. </span><span class="koboSpan" id="kobo.708.2">This can lead to redundant recalculations and harm performance, particularly when working with </span><span class="No-Break"><span class="koboSpan" id="kobo.709.1">extensive datasets.</span></span></p>
			<p><span class="koboSpan" id="kobo.710.1">To optimize the performance using pure pipes, you can create a custom pure </span><strong class="source-inline"><span class="koboSpan" id="kobo.711.1">pipe</span></strong><span class="koboSpan" id="kobo.712.1"> called </span><strong class="source-inline"><span class="koboSpan" id="kobo.713.1">TotalPipe</span></strong><span class="koboSpan" id="kobo.714.1"> that calculates the total price for a </span><span class="No-Break"><span class="koboSpan" id="kobo.715.1">given product:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.716.1">
import { Pipe, PipeTransform } from '@angular/core'
@Pipe({
  name: 'total',
  standalone: true,
  </span><strong class="bold"><span class="koboSpan" id="kobo.717.1">pure: true,</span></strong><span class="koboSpan" id="kobo.718.1">
})
export class TotalPipe implements PipeTransform {
  transform(quantity: number): number {
    return calculateTotal(quantity)
  }
}</span></pre>			<p><span class="koboSpan" id="kobo.719.1">In this example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.720.1">TotalPipe</span></strong><span class="koboSpan" id="kobo.721.1"> has been declared as a pure pipe by setting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.722.1">pure</span></strong><span class="koboSpan" id="kobo.723.1"> property to </span><strong class="source-inline"><span class="koboSpan" id="kobo.724.1">true</span></strong><span class="koboSpan" id="kobo.725.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.726.1">@Pipe</span></strong><span class="koboSpan" id="kobo.727.1"> decorator. </span><span class="koboSpan" id="kobo.727.2">This ensures that the pipe will only recalculate its output when the </span><a id="_idIndexMarker538"/><span class="koboSpan" id="kobo.728.1">quantity </span><span class="No-Break"><span class="koboSpan" id="kobo.729.1">value </span></span><span class="No-Break"><a id="_idIndexMarker539"/></span><span class="No-Break"><span class="koboSpan" id="kobo.730.1">changes.</span></span></p>
			<p><span class="koboSpan" id="kobo.731.1">Now, you can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.732.1">TotalPipe</span></strong><span class="koboSpan" id="kobo.733.1"> in your </span><span class="No-Break"><span class="koboSpan" id="kobo.734.1">component template:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.735.1">
&lt;span class="text-2xl font-semibold"&gt;
  $ {{ product.quantity </span><strong class="bold"><span class="koboSpan" id="kobo.736.1">| total</span></strong><span class="koboSpan" id="kobo.737.1"> }}
&lt;/span&gt;</span></pre>			<p><span class="koboSpan" id="kobo.738.1">By using </span><strong class="source-inline"><span class="koboSpan" id="kobo.739.1">TotalPipe</span></strong><span class="koboSpan" id="kobo.740.1">, the calculation of the total price is now delegated to the pipe. </span><span class="koboSpan" id="kobo.740.2">If a change is made to the quantity of a product, only the affected product’s total price will be recalculated; the other products will </span><span class="No-Break"><span class="koboSpan" id="kobo.741.1">remain unaffected:</span></span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer111" class="IMG---Figure">
					<span class="koboSpan" id="kobo.742.1"><img src="image/B18805_10_10.jpg" alt="Figure 10.10 – Calculating the total price from the pipe"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.743.1">Figure 10.10 – Calculating the total price from the pipe</span></p>
			<p><span class="koboSpan" id="kobo.744.1">As we can see, when there is a change in the quality or product, it only affects one product instead of there being 20 changes (</span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.745.1">Figure 10</span></em></span><em class="italic"><span class="koboSpan" id="kobo.746.1">.9</span></em><span class="koboSpan" id="kobo.747.1">), as in the previous approach. </span><span class="koboSpan" id="kobo.747.2">This optimization significantly improves performance, especially when dealing with large datasets or </span><span class="No-Break"><span class="koboSpan" id="kobo.748.1">complex calculations.</span></span></p>
			<p><span class="koboSpan" id="kobo.749.1">In conclusion, optimizing data binding in web applications is essential for improving performance and reducing unnecessary re-rendering. </span><span class="koboSpan" id="kobo.749.2">By following best practices, you can minimize the</span><a id="_idIndexMarker540"/><span class="koboSpan" id="kobo.750.1"> impact of data binding on </span><a id="_idIndexMarker541"/><span class="koboSpan" id="kobo.751.1">application performance. </span><span class="koboSpan" id="kobo.751.2">Now, let’s transition to the next topic: code and </span><span class="No-Break"><span class="koboSpan" id="kobo.752.1">bundle optimization.</span></span></p>
			<h1 id="_idParaDest-209"><a id="_idTextAnchor228"/><span class="koboSpan" id="kobo.753.1">Working with code and bundle optimization</span></h1>
			<p><strong class="bold"><span class="koboSpan" id="kobo.754.1">Code and bundle optimization</span></strong><span class="koboSpan" id="kobo.755.1"> refers to the process of optimizing the code base and the resulting bundles in a web application to enhance its performance and efficiency. </span><span class="koboSpan" id="kobo.755.2">It involves analyzing, restructuring, and minimizing code to eliminate redundancies, reduce</span><a id="_idIndexMarker542"/><span class="koboSpan" id="kobo.756.1"> file sizes, and improve </span><span class="No-Break"><span class="koboSpan" id="kobo.757.1">execution speed.</span></span></p>
			<p><span class="koboSpan" id="kobo.758.1">Optimizing both the code and bundle size is essential for delivering faster-loading web applications, reducing bandwidth usage, and enhancing the overall user experience. </span><span class="koboSpan" id="kobo.758.2">It helps ensure that the application loads quickly, responds promptly to user interactions, and performs efficiently across a range of devices and </span><span class="No-Break"><span class="koboSpan" id="kobo.759.1">network conditions.</span></span></p>
			<h2 id="_idParaDest-210"><a id="_idTextAnchor229"/><span class="koboSpan" id="kobo.760.1">When is code and bundle optimization used?</span></h2>
			<p><span class="koboSpan" id="kobo.761.1">Optimization isn’t just a </span><a id="_idIndexMarker543"/><span class="koboSpan" id="kobo.762.1">one-time task; it’s an ongoing process. </span><span class="koboSpan" id="kobo.762.2">As soon as our application starts to grow, or when we notice performance issues, it’s time to consider optimization. </span><span class="koboSpan" id="kobo.762.3">It’s especially crucial for the </span><span class="No-Break"><span class="koboSpan" id="kobo.763.1">following aspects:</span></span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.764.1">Large applications with extensive </span><span class="No-Break"><span class="koboSpan" id="kobo.765.1">code bases</span></span></li>
				<li><span class="koboSpan" id="kobo.766.1">Apps that rely on several third-party libraries </span><span class="No-Break"><span class="koboSpan" id="kobo.767.1">or frameworks</span></span></li>
				<li><span class="koboSpan" id="kobo.768.1">Applications targeting regions with slower </span><span class="No-Break"><span class="koboSpan" id="kobo.769.1">internet connections</span></span></li>
				<li><span class="koboSpan" id="kobo.770.1">Projects aiming for faster load times and improved </span><span class="No-Break"><span class="koboSpan" id="kobo.771.1">user experience</span></span></li>
			</ul>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor230"/><span class="koboSpan" id="kobo.772.1">Utilizing Source Map Explorer for bundle optimization</span></h2>
			<p><span class="koboSpan" id="kobo.773.1">One of the most effective tools for understanding the composition of your application’s bundles is </span><strong class="bold"><span class="koboSpan" id="kobo.774.1">Source Map Explorer</span></strong><span class="koboSpan" id="kobo.775.1">. </span><span class="koboSpan" id="kobo.775.2">It provides </span><a id="_idIndexMarker544"/><span class="koboSpan" id="kobo.776.1">a visual representation of the different parts of your bundle, making it easier to identify large chunks of code or unnecessary libraries that might be</span><a id="_idIndexMarker545"/><span class="koboSpan" id="kobo.777.1"> affecting your </span><span class="No-Break"><span class="koboSpan" id="kobo.778.1">app’s performance.</span></span></p>
			<p><span class="koboSpan" id="kobo.779.1">Before diving into its usage, let’s set up Source </span><span class="No-Break"><span class="koboSpan" id="kobo.780.1">Map Explorer:</span></span></p>
			<ol>
				<li><span class="koboSpan" id="kobo.781.1">You can add Source Map Explorer to your project by using </span><strong class="source-inline"><span class="koboSpan" id="kobo.782.1">npm</span></strong><span class="koboSpan" id="kobo.783.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.784.1">yarn</span></strong><span class="koboSpan" id="kobo.785.1">. </span><span class="koboSpan" id="kobo.785.2">Run the following command in your </span><span class="No-Break"><span class="koboSpan" id="kobo.786.1">project directory:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.787.1">
npm install source-map-explorer --save-dev
OR
yarn add -D source-map-explorer</span></pre></li>				<li><span class="koboSpan" id="kobo.788.1">To generate source maps during the build process, you need to adjust the Angular build configuration. </span><span class="koboSpan" id="kobo.788.2">In your </span><strong class="source-inline"><span class="koboSpan" id="kobo.789.1">angular.json</span></strong><span class="koboSpan" id="kobo.790.1"> file, locate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.791.1">sourceMap</span></strong><span class="koboSpan" id="kobo.792.1"> option within your application’s build configurations and set it </span><span class="No-Break"><span class="koboSpan" id="kobo.793.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.794.1">true</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.795.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.796.1">
// angular.json or project.json
"build": {
  "executor": "@angular-devkit/build-angular:browser",
  "outputs": [
    "{options.outputPath}"
  ],
  "options": {
    ...
</span><strong class="bold"><span class="koboSpan" id="kobo.797.1">    "sourceMap": true</span></strong><span class="koboSpan" id="kobo.798.1">
  },
  ...
</span><span class="koboSpan" id="kobo.798.2">}</span></pre></li>			</ol>
			<p><span class="koboSpan" id="kobo.799.1">With the tool installed and the configuration adjusted, you’re ready to analyze </span><span class="No-Break"><span class="koboSpan" id="kobo.800.1">your bundles:</span></span></p>
			<ol>
				<li><span class="koboSpan" id="kobo.801.1">First, you need to</span><a id="_idIndexMarker546"/><span class="koboSpan" id="kobo.802.1"> create a production build of your Angular application with source maps. </span><span class="koboSpan" id="kobo.802.2">Use the following command to </span><span class="No-Break"><span class="koboSpan" id="kobo.803.1">do so:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.804.1">
ng build --prod</span></pre></li>				<li><span class="koboSpan" id="kobo.805.1">After building, navigate to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.806.1">dist</span></strong><span class="koboSpan" id="kobo.807.1"> folder (or wherever your build artifacts are located). </span><span class="koboSpan" id="kobo.807.2">You’ll find several </span><strong class="source-inline"><span class="koboSpan" id="kobo.808.1">.js</span></strong><span class="koboSpan" id="kobo.809.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.810.1">.js.map</span></strong><span class="koboSpan" id="kobo.811.1"> files. </span><span class="koboSpan" id="kobo.811.2">To analyze a specific bundle, use Source Map Explorer, </span><span class="No-Break"><span class="koboSpan" id="kobo.812.1">like so:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.813.1">
// for single file
npx source-map-explorer dist/{your-project-path}/main.2e8930c4811df7ab.js
// for all files
npx source-map-explorer dist/{your-project-path}/**/*.js</span></pre></li>				<li><span class="koboSpan" id="kobo.814.1">Source Map Explorer will present a visual treemap of your bundle. </span><span class="koboSpan" id="kobo.814.2">Each section represents a portion of your code or an imported library. </span><span class="koboSpan" id="kobo.814.3">The size and position of each section correlate with its size in the bundle. </span><span class="koboSpan" id="kobo.814.4">Hovering over a section will display more detailed information. </span><span class="koboSpan" id="kobo.814.5">Here is </span><span class="No-Break"><span class="koboSpan" id="kobo.815.1">an example:</span></span></li>
			</ol>
			<div>
				<div id="_idContainer112" class="IMG---Figure">
					<span class="koboSpan" id="kobo.816.1"><img src="image/B18805_10_11.jpg" alt="Figure 10.11 – Visual map of the bundle"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.817.1">Figure 10.11 – Visual map of the bundle</span></p>
			<p><span class="koboSpan" id="kobo.818.1">The treemap’s visual representation makes it easier to spot large libraries or chunks of code. </span><span class="koboSpan" id="kobo.818.2">If you see a library that you don’t recognize or seems disproportionately large, it might be worth investigating further. </span><span class="koboSpan" id="kobo.818.3">You can research the unfamiliar library, analyze its dependencies, review its </span><a id="_idIndexMarker547"/><span class="koboSpan" id="kobo.819.1">usage in your code base, and seek community feedback to understand its purpose and impact </span><span class="No-Break"><span class="koboSpan" id="kobo.820.1">on performance.</span></span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.821.1">Note</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.822.1">While source maps are invaluable for development and analysis, they can expose your application’s code structure. </span><span class="koboSpan" id="kobo.822.2">Always ensure that source maps are not served in a production environment unless you want to debug </span><span class="No-Break"><span class="koboSpan" id="kobo.823.1">on production.</span></span></p>
			<p><span class="koboSpan" id="kobo.824.1">In the web development world, optimizing your code and bundles is essential to achieving the best application performance. </span><span class="koboSpan" id="kobo.824.2">Through tools and techniques such as Source Map Explorer, we’ve learned how to dissect and refine our application bundles for peak efficiency. </span><span class="koboSpan" id="kobo.824.3">As we wrap up this chapter, let’s take a moment to reflect on the </span><span class="No-Break"><span class="koboSpan" id="kobo.825.1">key takeaways.</span></span></p>
			<h1 id="_idParaDest-212"><a id="_idTextAnchor231"/><span class="koboSpan" id="kobo.826.1">Summary</span></h1>
			<p><span class="koboSpan" id="kobo.827.1">Throughout this chapter, we delved deep into the world of performance and optimization. </span><span class="koboSpan" id="kobo.827.2">We embarked on a journey to understand the intricacies of Angular performance, from the foundational concepts of lazy loading to the advanced techniques of code and </span><span class="No-Break"><span class="koboSpan" id="kobo.828.1">bundle optimization.</span></span></p>
			<p><span class="koboSpan" id="kobo.829.1">At this point, you’re equipped with the knowledge of how to optimize Angular applications, especially those utilizing PrimeNG components. </span><span class="koboSpan" id="kobo.829.2">We’ve seen firsthand the transformative power of efficient change detection strategies, the nuances of optimized data binding, and the importance of analyzing and refining our application bundles. </span><span class="koboSpan" id="kobo.829.3">These techniques are not just theoretical; they have practical implications that can drastically improve the user experience of </span><span class="No-Break"><span class="koboSpan" id="kobo.830.1">your applications.</span></span></p>
			<p><span class="koboSpan" id="kobo.831.1">Why is this so crucial? </span><span class="koboSpan" id="kobo.831.2">In the fast-paced digital age, every millisecond counts. </span><span class="koboSpan" id="kobo.831.3">Users expect seamless, lightning-fast applications, and even the slightest delay can impact user retention and satisfaction. </span><span class="koboSpan" id="kobo.831.4">By implementing the strategies we’ve discussed, you’re not just enhancing your application’s performance; you’re also ensuring that your users have the best </span><span class="No-Break"><span class="koboSpan" id="kobo.832.1">experience possible.</span></span></p>
			<p><span class="koboSpan" id="kobo.833.1">As we transition to the next chapter, we’ll shift our focus to building reusable components that can be easily integrated and adapted across various parts of our applications. </span><span class="koboSpan" id="kobo.833.2">This will empower you to write code that’s not only efficient but also modular and maintainable. </span><span class="koboSpan" id="kobo.833.3">So, gear up for another exciting journey where we’ll delve into the best practices and techniques for crafting versatile </span><span class="No-Break"><span class="koboSpan" id="kobo.834.1">Angular components.</span></span></p>
		</div>
	</body></html>