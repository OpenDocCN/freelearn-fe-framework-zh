- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: End-to-End Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will look at how to create an **End-to-End** (**E2E**) test
    suite for a Vue.js application with Cypress. In order to write robust tests, we’ll
    look at common pitfalls and best practices, such as intercepting HTTP requests
    and waiting for elements to appear without timeouts.
  prefs: []
  type: TYPE_NORMAL
- en: As we proceed, you will gain an understanding of E2E testing and its use cases.
    You will see how Cypress can be configured to test a Vue.js application and also
    interact with and inspect a **User Interface** (**UI**) using it. Throughout the
    chapter, you will gain familiarity with the pitfalls of arbitrary timeouts and
    how to avoid them with Cypress’ waiting functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Toward the end of the chapter, you will also learn when, why, and how to intercept
    HTTP requests with Cypress.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding E2E testing and its use cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Cypress for a Vue.js application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Cypress to interact with and inspect a Vue.js UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Triggering and waiting for UI updates with Cypress
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intercepting HTTP requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are no technical requirements for this chapter beyond the `git` CLI,
    which you will have already used by now. You can find this chapter’s source here:
    [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter12](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter12)'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding E2E testing and its use cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most developers will have seen a version of the testing pyramid shown in the
    following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – A diagram of the testing pyramid](img/Figure_12.01_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – A diagram of the testing pyramid
  prefs: []
  type: TYPE_NORMAL
- en: E2E tests fall under the UI testing category. The type of test we’ll be looking
    at in this chapter is automated E2E tests using Cypress.
  prefs: []
  type: TYPE_NORMAL
- en: E2E and UI tests provide a level of confidence higher than unit or integration
    tests. They’re testing the application as used by the end user. The end user doesn’t
    care why or where a bug is happening, just that there is a bug.
  prefs: []
  type: TYPE_NORMAL
- en: The where and why of a bug tends to be the concern of unit and system-level
    tests. Unit and system-level tests check that the internals of a system work as
    the specification or code describes them. UI-level tests validate that application
    flows are working as expected.
  prefs: []
  type: TYPE_NORMAL
- en: A strong E2E test suite that runs quickly, has few false negatives (where a
    test fails but the application works), and even fewer false positives (where all
    tests pass but the application is broken) enables **Continuous Deployment** (**CD**).
    CD, as its name suggests, involves deploying a project or application continuously.
  prefs: []
  type: TYPE_NORMAL
- en: In this kind of setup, an application version is validated by the E2E suite
    and is then automatically deployed to production.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Cypress for a Vue.js application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cypress is a JavaScript E2E testing framework. It’s designed to solve the very
    specific need of writing E2E tests using JavaScript. This is in contrast to other
    full-fledged browser automation solutions, such as WebdriverIO ([https://webdriver.io/](https://webdriver.io/)),
    Selenium WebDriver ([https://www.selenium.dev/](https://www.selenium.dev/)), Puppeteer
    ([https://developers.google.com/web/tools/puppeteer/](https://developers.google.com/web/tools/puppeteer/)),
    and Playwright ([https://github.com/microsoft/playwright](https://github.com/microsoft/playwright)),
    which are commonly used to write E2E tests.
  prefs: []
  type: TYPE_NORMAL
- en: The big difference with Cypress compared to these other solutions is its singular
    focus on writing E2E tests (as opposed to generic browser automation). Tests can
    only be written using JavaScript (Selenium supports other languages), and require
    Chrome, Edge, or Firefox (WebKit support is in development).
  prefs: []
  type: TYPE_NORMAL
- en: Cypress has a **Graphical User Interface** (**GUI**) to run and debug tests
    locally and comes with built-in assertion and stubbing/mocking libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add Cypress to a new Vue project, simply enable it when prompted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – Enabling Cypress when creating a new Vue 3 project](img/Figure_12.02_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – Enabling Cypress when creating a new Vue 3 project
  prefs: []
  type: TYPE_NORMAL
- en: To add Cypress to an existing project, use `npm install @``cypress/vue@next
    --dev`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The plugin adds a `test:e2e` script that we can run using the following two
    commands. The first prepares a build of the Vue application. The second actually
    starts the Cypress app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You will be asked to use a browser for testing first, as shown in *Figure 12**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3 – Cypress asking for the preferred browser to use for testing](img/Figure_12.03_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.3 – Cypress asking for the preferred browser to use for testing
  prefs: []
  type: TYPE_NORMAL
- en: 'After selecting a browser, the main Cypress UI is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4 – Cypress testing UI](img/Figure_12.04_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.4 – Cypress testing UI
  prefs: []
  type: TYPE_NORMAL
- en: 'If you click on the example link, you’ll see the test running and the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.5 – Cypress running a test](img/Figure_12.05_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.5 – Cypress running a test
  prefs: []
  type: TYPE_NORMAL
- en: 'Cypress creates a default test for us at `cypress/e2e/example.cy.js`. The test
    navigates to the root of the Vue application and looks for an `h1` tag that contains
    `You` `did it!`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will work in a default Vue 3 project.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can try visiting `google.com` using `cy.visit(url)` and check that the `input`
    element that’s synonymous with the Google home page is there by selecting the
    input elements on the page with `cy.get(''input'')` first and then using the `.``should(''exist'')`
    assertion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The Cypress window will automatically load and run the new test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.6 – Cypress tests running in Chrome while visiting the Google home
    page](img/Figure_12.06_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.6 – Cypress tests running in Chrome while visiting the Google home
    page
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now seen how to install and use Cypress to visit web pages. In the next
    section, we’ll see how Cypress can be used to interact with and inspect a UI.
  prefs: []
  type: TYPE_NORMAL
- en: Using Cypress to interact with and inspect a Vue.js UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to E2E test a new application, Commentator Pro, we should start by
    adding something to test. In this case, we’ll have a heading (`h2`) with the name
    of the application. In the `App.vue` file, we’ll have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to test this with Cypress, we can change the `cypress/e2e/example.cy.js`
    file with the following code. We’ll go to the running application using `cy.visit(''/'')`
    and then check that the `h2` on the page contains `Commentator Pro` using `cy.contains(''h2'',
    ''Commentator Pro'')`. The `cy.contains` function is overloaded and can be used
    with one parameter (the text to match against) or two parameters (the selector
    for the container and the text to match against):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then run `example.cy.js` using the Cypress UI, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.7 – A heading content test running successfully in Chrome](img/Figure_12.07_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.7 – A heading content test running successfully in Chrome
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve seen how to visit a page and assert its content, we’ll see how
    we can use Cypress to automate tests for a new feature in a Vue.js application.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 12.01 – adding a New Comment button and a corresponding E2E test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order for the Commentator Pro application to be useful, we should have an
    **Add a New Comment** button to allow users to add comments.
  prefs: []
  type: TYPE_NORMAL
- en: We will add a blue jumbo button with **Add a New Comment** as text and write
    the corresponding E2E test with Cypress.
  prefs: []
  type: TYPE_NORMAL
- en: The complete code can be found at [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter12/Exercise12.01](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter12/Exercise12.01)
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a button in the app, we’ll add a `button` element with some text in
    `src/App.vue`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output should show as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.8 – The Commentator Pro application with the Add a New Comment
    button](img/Figure_12.08_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.8 – The Commentator Pro application with the Add a New Comment button
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll create a new E2E test at `cypress/e2e/add-new-comment.cy.js`. We’ll
    set the name of the suite and description of the test to `Adding a New Comment`,
    and the home page should have a button with the right text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In order to test the home page, we’ll have to navigate to it using `cy.visit(''/'')`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we can write the assertion that a `button` instance containing the
    `Add a New Comment` text is on the page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can run this test using the Cypress UI first by running a new build (`npm
    run build`), and then `npm run test:e2e`. If you already had Cypress running,
    you do not need to restart it. You can visit the list of tests by clicking on
    the **Specs** navigation item in the left-hand menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.9 – The add-new-comment.cy.js test displaying in the Cypress UI](img/Figure_12.09_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.9 – The add-new-comment.cy.js test displaying in the Cypress UI
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run the test (by clicking on it), we’ll get the following output in
    Chrome. The test passes since there is a button with the relevant text on the
    home page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.10 – Cypress running our add-new-comment test in Chrome](img/Figure_12.10_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.10 – Cypress running our add-new-comment test in Chrome
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now seen how to visit pages and assert against their content.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at using Cypress to test interactive behavior.
    Cypress has automatic selector retries, which makes it a great fit for testing
    highly interactive Vue.js applications. We’ll see how to use Cypress to interact
    with the UI and assert the effect of our interactions.
  prefs: []
  type: TYPE_NORMAL
- en: Triggering and waiting for UI updates with Cypress
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The tests we’ve written up until now are quite simple and only check that the
    application isn’t crashing on load in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: One of the strengths of E2E tests is testing that the UI behaves as expected
    when a user interacts with it with high fidelity. We’ll use Cypress’ selection
    (the `.get()` function), event triggering (the `.click()` function), and assertion
    (the `.should()` function) functionality to test a Vue.js application in this
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Cypress’ automatic retries on DOM selection will allow us to write E2E tests
    without explicit wait or timeout conditions. Waits and timeouts are a staple of
    other E2E testing systems and tend to be a source of flakiness in tests.
  prefs: []
  type: TYPE_NORMAL
- en: To begin with, we will add a comment editor to our Commentator Pro application.
    Displaying the editor (a simple `textarea`) will be toggled by clicking on the
    **Add a New** **Comment** button.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to keep writing tests without wrangling complicated and brittle selectors,
    we’ll start adding `data-test-id` attributes; to begin with, we can add one to
    the `App.vue` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we’ll add a `showEditor` property to the Vue.js `data()` method on the
    `App` component. We’ll use this expression in `v-if` for the editor. We can also
    set the **Add a New Comment** button to toggle this instance property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add our editor with `new-comment-editor` `data-test-id` that is toggled
    by `showEditor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to test the toggling, we can add a test that opens that app and checks
    that the comment editor is not initially shown, as well as checking whether or
    not it is displayed depending on how many clicks are triggered on `new-comment-button`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will generate the following result in Cypress:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.11 – Cypress running add-new-comment tests, including the new editor-toggling
    test](img/Figure_12.11_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.11 – Cypress running add-new-comment tests, including the new editor-toggling
    test
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now seen how to write Cypress tests that select and assert over DOM elements.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`data-test-id` instances, as a convention, are a way to decouple tests from
    application-specific and styling-specific selectors. This is especially useful
    if the people writing the tests aren’t always the ones writing the code. In that
    situation, using `data-test-id` allows the markup structure and classes to change,
    but the tests will keep passing as long as the `test-id` instances remain on the
    correct element.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 12.02 – adding new comment editor input and a Submit functionality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To be able to send the new comment text to an API, we will need to store the
    text in a Vue.js state. The other prerequisite to adding a comment is to have
    a dummy **Submit** button.
  prefs: []
  type: TYPE_NORMAL
- en: The complete code can be found at [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter12/Exercise12.02](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter12/Exercise12.02)
  prefs: []
  type: TYPE_NORMAL
- en: 'To accomplish this, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To store the `textarea` (editor) content in memory, we’ll use `v-model`. We’ll
    create a new data (state) variable, `newComment`, that gets initialized to `""`.
    Now, `v-model` will two-way bind the `textarea` content and `newComment`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll add a `submit` button inside the editor, which should only appear when
    the editor is toggled on. We also make sure to include a `data-test-id="new-comment-submit"`
    attribute in order to be able to select it with Cypress later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It’s now time to add an E2E test to test that `new-comment-editor` works as
    expected when we type text into it. In order to achieve this, we need to load
    up the application and click on the `new-comment` button so that the editor displays.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can then select `new-comment-editor` (by `data-test-id`) and use the Cypress
    `.type` function to add some text. We can chain `.should(''have.value'', ''Just
    saying...'')` to validate that our interaction with `textarea` was successful.
    Remember to run `npm run build` when adding new tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'When run using the Cypress UI, this `add-new-comment` test suite should yield
    the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.12 – Cypress running add-new-comment tests, including the new editor
    text input test](img/Figure_12.12_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.12 – Cypress running add-new-comment tests, including the new editor
    text input test
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can add an E2E test to check that the `submit` button does not
    appear by default but does appear when we click on the `new-comment` button. We
    can also check the text content of the `new-comment-submit` button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When this test is run through the Cypress UI, we see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.13 – Cypress running add-new-comment tests, including the new submit
    button test](img/Figure_12.13_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.13 – Cypress running add-new-comment tests, including the new submit
    button test
  prefs: []
  type: TYPE_NORMAL
- en: 'One more feature we can add is to disable the `submit` button until there’s
    text in the text editor. To do this, we can bind `:disabled` to `!newComment`
    on the `new-comment-submit` button. As an aside, one of the major reasons we added
    a two-way binding between `newComment` and `textarea` is to enable UI validations
    such as this one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The relevant test will look at whether or not the `new-comment-submit` button
    is disabled when the text editor content is empty using Cypress’ `should(''be.disabled'')`
    and `should(''not.be.disabled'')` assertions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This yields the following output when run through Cypress UI and Chrome automation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.14 – Cypress running add-new-comment tests, including the new-comment-submit
    button disabled test](img/Figure_12.14_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.14 – Cypress running add-new-comment tests, including the new-comment-submit
    button disabled test
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now seen how to use Cypress to select, click, and input text. We’ve also
    seen approaches to check element visibility, text content, input values, and disabled
    states.
  prefs: []
  type: TYPE_NORMAL
- en: Anyone familiar with other automation frameworks will have noticed that in Cypress
    tests, there are no explicit waits or retries. This is because Cypress waits and
    retries assertions and selections automatically. Most of the tests we’ve written
    don’t showcase this in a major way, but the next exercise, where we bring asynchronicity
    into the mix, will.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 12.03 – adding a submitting state to the new comment editor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to showcase Cypress’s impressive, automatic retry/wait capability,
    we will look at adding and testing a `submitting` state for the new comment editor.
  prefs: []
  type: TYPE_NORMAL
- en: In effect, we’ll be reacting to a click on the `2.5` seconds to simulate a reasonably
    slow HTTP request to a backend API. The loading state is simply a CSS class that
    makes the button have italic text.
  prefs: []
  type: TYPE_NORMAL
- en: This test will be an example that showcases Cypress’ ability to automatically
    wait and retry selections. This feature reduces the need for arbitrary waits and
    the flakiness associated with them.
  prefs: []
  type: TYPE_NORMAL
- en: The complete code can be found at [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter12/Exercise12.03](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter12/Exercise12.03)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s do this by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to show a loading state, we add a new class to the component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to add an `isSubmitting` state to the Vue.js application in `data()`,
    which will allow us to toggle the state for the `submit` button. We will initialize
    it to `false` since we are not submitting anything until the user clicks on the
    **Submit** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will add a click handler for the `submit` button (as `methods.submitNewComment`).
    It will simulate a 2.5-second load time using `setTimeout`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we’ve got a fake `submit` handler, we should bind it to click events
    on the `new-comment-submit` button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE138]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE139]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE140]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE141]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE142]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now comes the part where we need to react to the `submit` button. The `submitting`
    class will show when `isSubmitting` is `true`. To do this, we simply need to set
    the `submitting` class to be added when `isSubmitting` is `true`. In addition
    to this, we’ll disable the button when `isSubmitting` is `true`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE144]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE145]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE146]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE147]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE148]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, we can add a test to check that the button applies the `submitting`
    class when the `submit` button is clicked. To begin with, we’ll need to set up
    the text editor so that when clicking on the `add-new-comment` button and setting
    a text value for the comment, the text editor is shown and enabled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we can click on the enabled `new-comment-submit` button and check that
    it is disabled and has the `submitting` class (using the `should()` function).
    After that, we should write another assertion that the button does not show the
    `submitting` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'Despite the `2.5` seconds during which the `submitting` class is shown, this
    test still passes due to Cypress’ automatic retry/wait functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.15 – Cypress running add-new-comment tests, including the comment
    submission loading state test](img/Figure_12.15_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.15 – Cypress running add-new-comment tests, including the comment
    submission loading state test
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now seen how Cypress allows us to seamlessly work around asynchronicity
    in the application by automatically waiting/retrying where an assertion or selection
    would fail.
  prefs: []
  type: TYPE_NORMAL
- en: Intercepting HTTP requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in previous sections, Cypress is designed as a JavaScript E2E testing
    solution. This means that it comes with built-ins such as assertions, automatic
    wait/retries, sane defaults for running the application, and extensive mocking
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP requests can be slow and tend to introduce flaky behavior into tests. What’s
    meant by flaky is intermittent false negatives – that is, failures that are not
    caused by an application issue but rather by connectivity issues (for example,
    between the server running the tests and the backend hosts).
  prefs: []
  type: TYPE_NORMAL
- en: We would also be testing the implementation of the backend system. When using
    **Continuous Integration** (**CI**), this would mean having to run the backend
    systems in whichever CI pipeline step needs to run E2E tests.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, when the backend requests are intercepted and a mock response is sent,
    we also say that the HTTP requests are *stubbed* in order to avoid tests flaking
    (meaning intermittent failures not linked to application changes).
  prefs: []
  type: TYPE_NORMAL
- en: Seeing that the requests do not go all the way through the stack (including
    the backend API), this is technically not a full E2E test of the system anymore.
    We can, however, consider it an E2E test of the frontend application since the
    whole application is made up of separate exercises and is not implementation-specific.
  prefs: []
  type: TYPE_NORMAL
- en: In order to mock requests in Cypress, we’ll need to use `cy.intercept()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To showcase HTTP interception, we’ll fetch a list of comments from `JSONPlaceholder`
    and store them under a `comments` reactive instance variable. We can use `fetch`
    to do this in the `mounted()` life cycle event as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: A sample comment includes an ID, a body, and an email, among other properties.
  prefs: []
  type: TYPE_NORMAL
- en: That means we can render the comments by creating a `div` container, which only
    shows if there are comments (`comments.length > 0)`. Inside the `div` container,
    we can render a list of `div` elements using `v-for`. Each card will render the
    body of the comment and the author’s email inside a `mailto:` link.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note how we set `comments-list` and `comment-card` `data-test-ids` for the
    list container and the list items respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'If we were to test this without HTTP interception, we would have to keep the
    assertions quite generic. For example, we can check that `comments-list` is visible
    and that there is a number (greater than `0`) of `comment-card` instances in a
    new E2E test file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'The following test run using the Cypress GUI passes but the tests are quite
    generic. We can’t make any assertions about the specific number of comments or
    their content:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.16 – Cypress running load-comments tests, including a generic load
    and display test](img/Figure_12.16_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.16 – Cypress running load-comments tests, including a generic load
    and display test
  prefs: []
  type: TYPE_NORMAL
- en: 'To intercept the request, we use `cy.intercept`. It lets us define a route
    and a static response – in our case, an array of comments. We’ll use a fictitious
    email address in our stubs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we’ve got our stub route set up, we can visit the page and wait for the
    comment fetching to finish using `cy.wait(''@getComments'')`, since we’ve previously
    set the alias of the comments’ `fetch` route to `getComments` with `.as(''getComments'')`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then start asserting, first off, that `comments-list` is visible, and
    then assert the number of `comment-card` elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also assert the specific contents of the cards using the `.``contains()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then run the suite with the Cypress GUI and see it passing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.17 – Cypress running load-comments tests, including our stubbed
    comments test](img/Figure_12.17_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.17 – Cypress running load-comments tests, including our stubbed comments
    test
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now seen how and why we might stub HTTP requests using Cypress.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 12.04 – POST comment to the API on submission
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `new-comment-submit` button currently only sets a loading state for a few
    seconds and then resets – the comment is not actually being sent anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use the `JSONPlaceholder` API as the place to send our new comment. When
    the `POST` request to the API succeeds, we’ll add the comment to the top of the
    comment list.
  prefs: []
  type: TYPE_NORMAL
- en: The complete code can be found at [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter12/Exercise12.04](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter12/Exercise12.04)
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete the exercise, we will perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by making the `submitNewComment` method actually post data using `fetch`.
    New comments require an email address, which our application doesn’t have, but
    we can set a fake email in our data as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE158]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE159]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE160]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE161]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE162]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE163]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE164]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE165]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE166]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE167]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE168]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE169]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE170]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE171]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE172]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE173]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE174]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE175]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE176]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE177]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE178]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE179]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE180]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE181]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Unfortunately, the `fetch()` call doesn’t update the data by itself or come
    out of the loading state. In order to do so, we need to chain some `.then()` function
    calls to handle the response, and a `.catch` function call in case we have an
    error.
  prefs: []
  type: TYPE_NORMAL
- en: 'On success (`.then`), we should get the JSON output of the request and add
    it to the front of a copy of the `comments` array. We should also reset `isSubmitting`,
    `newComment`, and `showEditor`. On error (`.catch`), we will just reset the loading
    state, `isSubmitting`, to `false`; we won’t clear the editor or close it since
    the user might want to try to submit it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: We should now add new tests to the `cypress/e22/add-new-comment.js` test suite.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, to be good users of the JSON placeholder, we’ll stub out all
    the `GET` requests to `/comments` for the `add-new-comment` suite. In order to
    do this, we’ll use a `beforeEach` hook that will intercept requests matching the
    `**/comments` glob and return an empty array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE184]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE185]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE186]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE187]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can then proceed to update the `the new comment editor should show a submitting
    class on submit` test since we’re not using `setTimeout` anymore but an HTTP request.
    To start with, we need to stub out the `/comments` `POST` request, for which we’ll
    use the configuration object syntax for `cy.intercept` in order to introduce a
    delay into the HTTP request so that it doesn’t respond immediately.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We alias this request with `.as(''newComment'')`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of `// eventually, the submitting class should be removed`, we can
    now use `cy.wait()` to wait for the `newComment` HTTP request to complete before
    checking that the spinner is gone:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE190]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE191]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE192]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE193]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE194]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE195]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE196]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE197]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE198]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE199]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Upon successfully posting a new comment, the comment text is cleared. We should
    test that this happens when a comment is posted. We’ll use a similar skeleton
    to the updated loading state test, with the setup of the `POST` comments route
    stubbing `cy.intercept('POST', '**/comments', {}`, aliased as .`as('newComment')`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can then get the new comment editor to display, add some text, and submit
    the form. We’ll then proceed to wait for the `POST` request to complete before
    checking that the comment has been cleared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: 'This test can now be run with the Cypress GUI and will pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.18 – Cypress running add-new-comment tests, including the editor
    comment text being cleared](img/Figure_12.18_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.18 – Cypress running add-new-comment tests, including the editor comment
    text being cleared
  prefs: []
  type: TYPE_NORMAL
- en: 'The second bit of functionality that we’ve added is that on completion of the
    HTTP request, the new comment is added to the top of the comments list. To test
    this, it’s better to change the response of the comments’ `GET` request to have
    at least one element (so that we can check that the new comment is added to the
    top of the list):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE202]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE203]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE204]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE205]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE206]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE207]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE208]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE209]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE210]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE211]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE212]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE213]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can then stub the `POST` request with some mock data, add text to the editor,
    and submit the form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE215]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE216]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE217]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE218]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE219]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE220]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE221]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE222]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE223]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE224]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE225]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE226]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE227]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE228]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE229]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE230]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE231]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE232]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE233]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE234]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE235]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE236]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE237]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE238]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE239]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE240]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we can assert the fact that the first comment is the newly added comment
    using a combination of `cy.get()`, `.first()`, and `.contains()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE242]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE243]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE244]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE245]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE246]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE247]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE248]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE249]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE250]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE251]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE252]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE253]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE254]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE255]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When running the `add-new-comment` suite with the Cypress GUI, we can see the
    new test passing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.19 – Cypress running add-new-comment tests, including the new comment
    added to the top of the list test](img/Figure_12.19_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.19 – Cypress running add-new-comment tests, including the new comment
    added to the top of the list test
  prefs: []
  type: TYPE_NORMAL
- en: You’ve now seen how to handle network operations in your testing. As most applications
    make use of some sort of API call, this will be tremendously helpful in ensuring
    your tests cover as much ground as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Activity 12.01 – adding the ability to set a user’s email and test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You’ll remember that we’ve hardcoded `fakeemail@email.com` as the email for
    any comments. What we’ll do in this activity is add an email input that will set
    the `email` property on comments. We’ll add the relevant tests in a new `cypress/e2e/enter-email.cy.js`
    suite:'
  prefs: []
  type: TYPE_NORMAL
- en: In order to keep track of the email, we’ll set it as a piece of reactive state
    in `data()` and add an email input to the page, which will be two-way bound to
    `email` using `v-model`. We also add a label and corresponding markup. Note that
    we’ll have a `data-test-id` attribute on the email input set to `email-input`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ll now add a `beforeEach` hook to have Cypress intercept and stub out the
    `GET` comments (list) request. The comments list request should be aliased as
    `getComments`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ll add our first test, which checks whether typing into the email input works
    correctly. We’ll go to the app, type an email, and check that what we typed is
    now the input value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When it is run using the Cypress UI, we should get the following passing test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.20 – Cypress running enter-email tests with the email input test](img/Figure_12.20_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.20 – Cypress running enter-email tests with the email input test
  prefs: []
  type: TYPE_NORMAL
- en: Having the `email` property is a pre-requisite to adding comments, so we’ll
    disable the `email` is empty (`!email`). We’ll bind to the `disabled` attribute
    based on whether or not the email field is populated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this new `disable add new comment button while email is empty` functionality,
    we should add a new E2E test. We’ll load up the page and on initial load, we’ll
    check that the email input is empty and that the `not` disabled, which means it
    is enabled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When run using the Cypress UI, we should see the new test passing with the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 12.21 – Cypress running enter-email\uFEFF tests with the disabled\
    \ add comment button test](img/Figure_12.21_B18645.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 12.21 – Cypress running enter-email tests with the disabled add comment
    button test
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve got a way to capture the email, we should pass it to the backend
    API when making the `POST` comments call (that is, when submitting a new comment).
    In order to do this, we should modify the spot in `methods.submitNewComment` where
    the email is hardcoded as `fakeemail@email.com`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we’re using the email that’s been input by the user, we should write
    an E2E test to check that it’s being sent. We’ll stub out the `POST` request,
    alias it to `newComment`, and send back an arbitrary value. We can then visit
    the page, fill out the email input, open the comment editor, fill that out, and
    submit it. We’ll then wait on the `newComment` request and assert in the request
    body that the body and email are as they were when we completed them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We could also opt to not stub out the `POST` request and instead check that
    the new comment inserted on the page contains the right email and body.
  prefs: []
  type: TYPE_NORMAL
- en: 'When run using the Cypress UI, we get the following test run output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.22 – Cypress running enter-email tests with the email input test](img/Figure_12.22_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.22 – Cypress running enter-email tests with the email input test
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found at [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter12/Activity12.01](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter12/Activity12.01)
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we’ve looked at leveraging Cypress to test Vue.js applications
    E2E. E2E tests in general are useful to give us a high level of confidence that
    tested flows will work as expected, as opposed to unit or integration tests, which
    validate that our code works as expected at a much lower overhead.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve seen how to use Cypress to inspect, interact with, and assert against
    a UI. We’ve also shown how Cypress’ default wait/retry functionality is a great
    advantage when writing robust tests. We leveraged Cypress’ HTTP interception library
    to stub out HTTP requests and make tests more predictable and faster.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked at how to set up visual regression testing with Cypress.
    In the next chapter, we’ll look at how to deploy a Vue.js application to the web.
  prefs: []
  type: TYPE_NORMAL
