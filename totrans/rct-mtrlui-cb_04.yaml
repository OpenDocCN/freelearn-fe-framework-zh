- en: Tabs - Grouping Content into Tab Sections
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标签 - 将内容分组到标签部分
- en: 'In this chapter, you''ll learn about the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: AppBar integration
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AppBar` 集成'
- en: Tab alignment
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签对齐
- en: Rendering tabs based on state
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据状态渲染标签
- en: Abstracting tab content
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象标签内容
- en: Tab navigation with routes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用路由进行标签导航
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: The `Tabs` Material-UI component is used to organize content on your screen.
    The tabs are organized in a horizontal fashion and they should feel natural for
    your users. You can use tabs any time your screen has lots of content that could
    be split into different category sections.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tabs` Material-UI 组件用于在屏幕上组织内容。标签以水平方式组织，并且应该让用户感觉自然。当你的屏幕上有大量内容可以分成不同的类别部分时，你可以随时使用标签。'
- en: AppBar integration
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`AppBar` 集成'
- en: '`AppBar` components can be used with the `Tabs` component. You can do this
    so that the tab buttons are rendered within an App Bar. This provides a container
    for your tab buttons—by default, there is nothing surrounding them.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppBar` 组件可以与 `Tabs` 组件一起使用。你可以这样做，以便标签按钮在 App Bar 中渲染。这为你的标签按钮提供了一个容器——默认情况下，它们周围没有任何东西。'
- en: How to do it...
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Let''s say that you have a `Tabs` component with three `Tab` buttons. Instead
    of rendering the tabs so that they look as though they''re floating on the screen,
    you can wrap them in an `AppBar` component to give them a contained look and feel.
    Here''s the code:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个包含三个 `Tab` 按钮的 `Tabs` 组件。你不必将标签渲染得看起来像是漂浮在屏幕上，而是可以将它们包裹在一个 `AppBar` 组件中，以赋予它们一个封装的外观和感觉。以下是代码示例：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When the screen first loads, you''ll see the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当屏幕首次加载时，你会看到以下内容：
- en: '![](img/09960806-49a4-4d67-976e-75b0667b6abe.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/09960806-49a4-4d67-976e-75b0667b6abe.png)'
- en: 'When you click on one of the tab buttons, the selected tab changes, along with
    the content underneath the tabs. For example, clicking on the ITEM THREE tab results
    in this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击其中一个标签按钮时，选中的标签会改变，以及标签下方的相关内容也会更新。例如，点击“项目三”标签会得到以下结果：
- en: '![](img/e7b18d8b-8848-4de1-b7fe-04f5edcb640b.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e7b18d8b-8848-4de1-b7fe-04f5edcb640b.png)'
- en: How it works...
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The `Tabs` and `Tab` components are rendered inside the `AppBar` component.
    Usually, `AppBar` has a `Toolbar` component as its child, but `Tab` can work too:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tabs` 和 `Tab` 组件在 `AppBar` 组件内部渲染。通常，`AppBar` 有一个 `Toolbar` 组件作为其子组件，但 `Tab`
    也可以工作：'
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Your component has a `value` state that is used to keep track of the selected
    tab. The `onChange()` handler is used to update this state; it gets set to the
    current index of the selected tab. Then, you can use the `value` state to determine
    which content to render below the `AppBar` component:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你的组件有一个 `value` 状态，用于跟踪选中的标签。`onChange()` 处理器用于更新这个状态；它被设置为当前选中标签的索引。然后，你可以使用
    `value` 状态来确定在 `AppBar` 组件下方渲染哪个内容：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If the first tab is selected, then the value is `0` and the `Item One` text
    is rendered. The same logic follows for the other two tabs.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个标签被选中，那么值是 `0`，并且会渲染“项目一”文本。对于其他两个标签，遵循相同的逻辑。
- en: There's more...
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'If you want tabs but you don''t want the indicator that''s rendered underneath
    the text, you can set it to be the same color as the `AppBar` component. This
    is done using the `indicatorColor` property, as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要标签，但不想在文本下方渲染指示器，你可以将其设置为与 `AppBar` 组件相同的颜色。这可以通过 `indicatorColor` 属性完成，如下所示：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'By setting the `indicatorColor` value to `primary`, the indicator should now
    be the same color as the `AppBar` component:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 `indicatorColor` 值设置为 `primary`，指示器现在应该与 `AppBar` 组件颜色相同：
- en: '![](img/b21a3313-39ab-43f7-a191-f791bc18cc2a.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b21a3313-39ab-43f7-a191-f791bc18cc2a.png)'
- en: See also
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: '`Tabs` API documentation: [https://material-ui.com/api/tabs/](https://material-ui.com/api/tabs/)'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tabs` API 文档：[https://material-ui.com/api/tabs/](https://material-ui.com/api/tabs/)'
- en: '`Tabs` demos: [https://material-ui.com/demos/tabs/](https://material-ui.com/demos/tabs/)'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tabs` 示例：[https://material-ui.com/demos/tabs/](https://material-ui.com/demos/tabs/)'
- en: Tab alignment
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标签对齐
- en: The `Tabs` component has two properties to help you align your tab buttons.
    The `centered` property centers the tabs, while the `fullWidth` property spreads
    out the tabs.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tabs` 组件有两个属性可以帮助你对齐标签按钮。`centered` 属性使标签居中，而 `fullWidth` 属性使标签展开。'
- en: How to do it...
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Let''s say that you have three basic tabs using the following code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你使用了以下代码创建了三个基本标签：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here''s what you should see when the screen first loads:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当屏幕首次加载时，你应该看到以下内容：
- en: '![](img/39fbb81c-8587-4e7d-baef-56929e5508ce.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/39fbb81c-8587-4e7d-baef-56929e5508ce.png)'
- en: 'By default, tabs are aligned to the left. You can center your tabs by setting
    the `centered` property, as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，制表符对齐到左侧。您可以通过设置`centered`属性来使制表符居中，如下所示：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here''s what centered tabs look like:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是居中制表符的外观：
- en: '![](img/d8af98bd-1853-465b-9ba1-86100051bcbf.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d8af98bd-1853-465b-9ba1-86100051bcbf.png)'
- en: 'When your tabs are centered, all of the empty space goes to the left and right
    of the tabs. The alternative is setting the `variant` property to `fullWidth`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的制表符居中时，所有空余空间都位于制表符的左右两侧。另一种选择是将`variant`属性设置为`fullWidth`：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here''s what full width tabs look like:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是全宽制表符的外观：
- en: '![](img/e9bf778b-ce3f-4224-b2a3-36a7f5cb8fa5.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e9bf778b-ce3f-4224-b2a3-36a7f5cb8fa5.png)'
- en: The tabs are centered, but they're spaced evenly to cover the width of the screen.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 制表符居中，但它们均匀分布以覆盖屏幕宽度。
- en: How it works...
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `centered` property is just a convenient way of specifying the `justifyContent`
    style on the `Tabs` component. Whenever there is a property to style Material-UI
    components in a specific way, you should use it instead of applying your own styles.
    Future versions of the library could include fixes that rely on the property that
    you'll miss out on.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`centered`属性只是指定`Tabs`组件上的`justifyContent`样式的一种方便方式。每当有属性可以以特定方式样式化Material-UI组件时，您应该使用它而不是应用自己的样式。库的将来版本可能包括依赖于您将错过的属性的修复。'
- en: Another reason to style components using the property is that Material-UI might
    behave differently depending on how other properties are set. For example, with
    the `Tabs` component, you can't set the `centered` property while the `scrollable`
    property is set to true; Material-UI checks for this and handles it.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用属性来设置组件样式的另一个原因是，Material-UI可能会根据其他属性的设置方式表现出不同的行为。例如，在使用`Tabs`组件时，当`scrollable`属性设置为`true`时，您不能设置`centered`属性；Material-UI会检查这一点并处理它。
- en: The `fullWidth` value of the `variant` property is actually passed to the `Tab`
    component, which alters the styles it uses based on this value. The result is
    the even spacing of tabs within the container element.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`variant`属性的`fullWidth`值实际上传递给了`Tab`组件，这将根据此值更改它使用的样式。结果是制表符在容器元素内的均匀分布。'
- en: You can set the `centered` and `variant` properties at the same time. However,
    `centered` isn't necessary if `variant` has a value of `fullWidth`. Using both
    is harmless though.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以同时设置`centered`和`variant`属性。然而，如果`variant`的值为`fullWidth`，则`centered`不是必需的。尽管如此，同时使用两者是无害的。
- en: There's more...
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The centered layout for tabs works well on smaller screens, while the full width
    layout looks good on larger screens. You can use Material-UI utilities that tell
    you about breakpoint changes. You can then use this information to change the
    alignment of your tabs.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 制表符的居中布局在小屏幕上表现良好，而全宽布局在大屏幕上看起来不错。您可以使用Material-UI的实用工具来了解断点更改。然后，您可以使用这些信息来更改制表符的对齐方式。
- en: 'Here''s a modified version of this example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是此示例的修改版本：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now when you resize your screen, the alignment properties of the grid can change
    in response to breakpoint changes. Let''s break down these changes from the bottom
    up, starting with the `variant` property value:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当您调整屏幕大小时，网格的对齐属性会根据断点更改而改变。让我们从底部开始分析这些更改，首先是`variant`属性值：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The value will be `fullWidth` if the `width` property is anything but the `xs`
    or `sm` breakpoint. In other words, if it's a larger screen, the value will be `fullWidth`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`width`属性不是`xs`或`sm`断点，则值将是`fullWidth`。换句话说，如果屏幕更大，则值将是`fullWidth`。
- en: Next, you need the width property to be passed to your component somehow. You
    can use the `withWidth()` utility from Material-UI. It works like `withStyles()`
    in that it returns a new component with new properties assigned to it. The component
    returned by `withWidth()` will update its `width` prop any time the breakpoint
    changes. For example, if the user resizes their screen from `sm` to `md`, this
    will trigger a width change and `fullWidth` will change from false to true.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要以某种方式将宽度属性传递给您的组件。您可以使用Material-UI的`withWidth()`实用工具。它的工作方式类似于`withStyles()`，它会返回一个新的组件，并为其分配新的属性。`withWidth()`返回的组件将在断点更改时更新其`width`属性。例如，如果用户将屏幕大小从`sm`调整为`md`，这将触发宽度更改，`fullWidth`将从`false`变为`true`。
- en: 'To use the `withWidth()` component—along with the `withStyles()` component—you
    can use the `compose()` function from `recompose`. This function makes your code
    more readable when you''re applying several higher-order functions that decorate
    your component:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `withWidth()` 组件——以及 `withStyles()` 组件——你可以使用 `recompose` 中的 `compose()`
    函数。当你应用多个高阶函数来装饰你的组件时，这个函数会使你的代码更易于阅读：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You could call `withWidth(withStyles(styles))(TabAlignment)` if you really don't
    want to use `recompose`, but as a general rule, I like to use it any time more
    than one higher-order function is involved.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的不想使用 `recompose`，你可以调用 `withWidth(withStyles(styles))(TabAlignment)`，但作为一个一般规则，我喜欢在涉及多个高阶函数时使用它。
- en: See also
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '`Tabs` demos: [https://material-ui.com/demos/tabs/](https://material-ui.com/demos/tabs/)'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tabs` 示例：[https://material-ui.com/demos/tabs/](https://material-ui.com/demos/tabs/)'
- en: '`Tabs` API documentation: [https://material-ui.com/api/tabs/](https://material-ui.com/api/tabs/)'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tabs` API 文档：[https://material-ui.com/api/tabs/](https://material-ui.com/api/tabs/)'
- en: 'Tools for composing React components: [https://github.com/acdlite/recompose/](https://github.com/acdlite/recompose/)'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 组件组合工具：[https://github.com/acdlite/recompose/](https://github.com/acdlite/recompose/)
- en: Rendering tabs based on state
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根据状态渲染标签页
- en: Tabs in your React application might be driven by data. If so, you can set tab
    data in the state of your component to have them render initially and update if
    anything changes.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 React 应用程序中，标签页可能是由数据驱动的。如果是这样，你可以在组件的状态中设置标签数据，以便它们最初渲染并在有任何更改时更新。
- en: How to do it...
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s say that you have some data that determines the tabs to render in your
    app. You can set this data in the state of your component and use it to render
    the `Tab` components, as well as the tab content when tab selections are made.
    Here''s the code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一些数据，这些数据决定了你的应用程序中要渲染的标签页。你可以在组件的状态中设置这些数据，并使用它来渲染 `Tab` 组件，以及当标签选择被做出时的标签内容。以下是代码：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When you first load the screen, you''ll see the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当你首次加载屏幕时，你会看到以下内容：
- en: '![](img/59bf0bed-1616-4cc2-9921-b16103e6f1da.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/59bf0bed-1616-4cc2-9921-b16103e6f1da.png)'
- en: 'If you click on the ITEM TWO tab, here''s what you''ll see:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击“项目二”标签，你会看到以下内容：
- en: '![](img/bdbaebd1-78ec-4887-b5e3-2a8142bc7904.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bdbaebd1-78ec-4887-b5e3-2a8142bc7904.png)'
- en: How it works...
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s start by looking at the state of your component that drives the `tabs`
    that are rendered:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看驱动渲染的 `tabs` 的组件状态开始：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `tabs` state is an array, and each object within it represents a tab to
    be rendered. The `active` Boolean property determines which tab is `active`. The
    `label` property is what is rendered as the actual tab button and the content
    is rendered below the tabs when the tab is clicked on.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`tabs` 状态是一个数组，数组中的每个对象代表一个要渲染的标签。`active` 布尔属性确定哪个标签是“活动”的。`label` 属性是实际渲染为标签按钮的内容，当点击标签时，内容在标签下方渲染。'
- en: 'Next, let''s take a look at the markup used to render the `tabs` and the content:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看用于渲染 `tabs` 和内容的标记：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Instead of manually rendering `Tab` components, you're iterating over the `tabs`
    state to render each tab. For the selected content, you now only have to render
    one `Typography` component that references `content`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是手动渲染 `Tab` 组件，你现在正在遍历 `tabs` 状态来渲染每个标签。对于选定的内容，你现在只需要渲染一个引用 `content` 的 `Typography`
    组件。
- en: 'Let''s take a look at the two `active` and `content` values, as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看两个 `active` 和 `content` 值，如下所示：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `active` constant is the index of the active tab. This value is passed to
    the `value` property of the `Tabs` component. It's also used by the `content`
    value—the content of the active tab. Both of these constants simplify the markup
    that your component needs to render.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`active` 常量是活动标签的索引。这个值传递给 `Tabs` 组件的 `value` 属性。它也被 `content` 值——活动标签的内容——使用。这两个常量简化了你的组件需要渲染的标记。'
- en: There's more...
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Now that you''re controlling your tabs with `state`, you can control more aspects
    of your rendered tabs. For instance, you could add `disabled` and `hidden` states
    to each tab. You could also place an `icon` property to render in your tab state.
    Here''s a new version of the `tabs` state:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你用 `state` 控制你的标签页后，你可以控制更多渲染的标签的方面。例如，你可以在每个标签中添加 `disabled` 和 `hidden` 状态。你还可以在标签状态中放置一个
    `icon` 属性来渲染。以下是 `tabs` 状态的新版本：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now you have the ability to render `disabled` tabs that cannot be clicked on—as
    is the case with the SEARCH tab. You can also hide tabs completely by setting
    `hidden` to `true`—as is the case with the Add tab. Every tab now has an icon
    as well. Let''s see what this looks like when you load the screen:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您有了渲染`disabled`标签的能力，这些标签不能被点击——例如，SEARCH标签的情况。您还可以通过将`hidden`设置为`true`来完全隐藏标签——例如，添加标签的情况。每个标签现在都有一个图标。让我们看看加载屏幕时的样子：
- en: '![](img/d1c63de0-6440-4891-8cb8-2e87825e78ff.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d1c63de0-6440-4891-8cb8-2e87825e78ff.png)'
- en: 'The icons for every tab are rendered as expected, even for the SEARCH tab,
    which has been marked as `disabled`. There''s no Add tab because it was marked
    as `hidden`. Let''s take a look at the changes to the `Tabs` markup that were
    necessary to accommodate these new state values:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 每个标签的图标都按预期渲染，即使是标记为`disabled`的SEARCH标签。没有添加标签，因为它被标记为`hidden`。让我们看看为了适应这些新的状态值而对`Tabs`标记所做的更改：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `disabled` and `icon` properties of `Tab` are passed directly from the tab
    in your component state. The `filter()` call was added to remove tabs that are
    marked as hidden.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tab`的`disabled`和`icon`属性直接从组件状态中的标签传递。添加了`filter()`调用以删除标记为隐藏的标签。'
- en: See also
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '`Tabs` API documentation: [https://material-ui.com/api/tabs/](https://material-ui.com/api/tabs/)'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tabs` API 文档：[https://material-ui.com/api/tabs/](https://material-ui.com/api/tabs/)'
- en: '`Tabs` demos: [https://material-ui.com/demos/tabs/](https://material-ui.com/demos/tabs/)'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tabs`演示：[https://material-ui.com/demos/tabs/](https://material-ui.com/demos/tabs/)'
- en: Abstracting tab content
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象标签内容
- en: If your application uses tabs in several places, you can create abstractions
    that simplify the markup involved with rendering tabs and tab content. Instead
    of having tab content defined outside of the tabs component, why not have everything
    be self-contained and easier to read?
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序在多个位置使用标签，您可以创建抽象来简化涉及渲染标签和标签内容的标记。为什么不将所有内容都包含在内，使其更容易阅读，而不是在标签组件外部定义标签内容？
- en: How to do it...
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Let''s say that your app uses tabs in several places throughout your app, and
    you want to simplify the markup used to create the tabs and the tab content. In
    the places where you use tabs, you just want to be able to render the content
    and not have to worry about handing state for the active tab. Here''s some code
    that creates two new components that simplify the **JavaScript XML** (**JSX**)
    required for rendering tab content:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您的应用程序在应用程序的多个位置使用标签，并且您想简化创建标签和标签内容的标记。在您使用标签的地方，您只想能够渲染内容，而无需担心处理活动标签的状态。以下是一些代码，创建了两个新的组件，这些组件简化了渲染标签内容所需的**JavaScript
    XML**（**JSX**）：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When you load the screen, you''ll see three tabs rendered with the first tab
    selected by default. The content of the first tab is also visible. The following
    screenshot shows what it looks like:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当您加载屏幕时，您将看到三个标签被渲染，默认选中第一个标签。第一个标签的内容也是可见的。以下截图显示了它的样子：
- en: '![](img/e048c474-bfd1-4b15-932a-08fafd552787.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e048c474-bfd1-4b15-932a-08fafd552787.png)'
- en: How it works...
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s start by looking at the markup used to render the tabs in this following
    example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看在这个以下示例中用于渲染标签的标记：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This markup is much more concise than using the `Tab` and `Tabs` components
    directly. This approach also handles rendering the content of the selected tab.
    Everything is self-contained with this approach.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 与直接使用`Tab`和`Tabs`组件相比，这种标记更加简洁。这种方法还处理了渲染选中标签的内容。这种方法将所有内容都包含在内。
- en: 'Next, let''s take a look at the `TabContainer` component:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看`TabContainer`组件：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `TabContainer` component handles the state of the selected tab and changing
    the state when a different tab is selected. This component renders a `Fragment`
    component so that it can place the selected tab content after the `Tabs` component.
    It's using `Children.map()` to render the individual `Tab` components. The label
    of the tab comes from the `label` property of the child. In this example, there
    are three children (`TabContent`). The next call to `Children.map()` renders the
    content of the selected tab. This is based on the `value` state—if the child index
    matches, it's the `active` content. Otherwise, it gets mapped to `null` and nothing
    is rendered.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`TabContainer`组件处理选中标签的状态，并在选择不同的标签时更改状态。该组件渲染一个`Fragment`组件，以便它可以在`Tabs`组件之后放置选中的标签内容。它使用`Children.map()`来渲染单个`Tab`组件。标签的标签来自子组件的`label`属性。在这个例子中，有三个子组件（`TabContent`）。下一次调用`Children.map()`将渲染选中标签的内容。这是基于`value`状态——如果子组件索引匹配，则是`active`内容。否则，它被映射到`null`，不进行渲染。'
- en: 'Lastly, let''s take a look at the `TabContent` component:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们来看看`TabContent`组件：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`TabContent` takes care of styling the `Typography` component and renders the
    child text within. Although the `label` property is passed to `TabContent`, it
    doesn''t actually use it; instead, it''s used by `TabContainer` when rendering
    tabs.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`TabContent`负责对`Typography`组件进行样式设置，并在其中渲染子文本。尽管将`label`属性传递给了`TabContent`，但它实际上并没有使用它；相反，它在渲染标签时由`TabContainer`使用。'
- en: There's more...
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'You can add a `value` property to the `TabsContainer` component so that you
    can set whichever tab to activate initially. For example, you might want the second
    tab to be `active` instead of the first tab when the screen first loads. To do
    this, you''ll have to add a default property value for `value`, call `setValue()`
    if the `value` state hasn''t been set yet, and remove `value` from the initial
    state:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以向`TabsContainer`组件添加一个`value`属性，这样你就可以设置要激活的任何标签。例如，你可能希望在屏幕首次加载时，第二个标签是`active`而不是第一个标签。为此，你必须为`value`添加一个默认属性值，如果`value`状态尚未设置，则调用`setValue()`，并从初始状态中删除`value`。
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The default property is necessary because the `value` state is now undefined
    by default. The `setValue()` method is called if the `value` state is undefined.
    If it is, then you can set it by passing it the `value` property value.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 默认属性是必要的，因为`value`状态默认是未定义的。如果`value`状态是未定义的，则调用`setValue()`方法。如果是，则可以通过传递`value`属性值来设置它。
- en: 'Now, you can pass this property to your component to change the initially-active
    tab:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以将这个属性传递给你的组件以更改初始激活的标签页：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The value property is set to `1`. It''s a zero-based index, which means that
    the second tab will be active by default:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 值属性设置为`1`。它是一个基于零的索引，这意味着第二个标签将默认激活：
- en: '![](img/3e1099f3-0513-4a71-a2f5-af4903b1a7ed.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3e1099f3-0513-4a71-a2f5-af4903b1a7ed.png)'
- en: When the user starts clicking on other tabs, the `value` state updates as expected—only
    the initially-active tab is impacted by this change.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户开始点击其他标签时，`value`状态按预期更新——只有初始激活的标签受此更改影响。
- en: See also
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '`Tabs` API documentation: [https://material-ui.com/api/tabs/](https://material-ui.com/api/tabs/)'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tabs` API文档：[https://material-ui.com/api/tabs/](https://material-ui.com/api/tabs/)'
- en: '`Tabs` demos: [https://material-ui.com/demos/tab/](https://material-ui.com/demos/tab/)'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tabs`演示：[https://material-ui.com/demos/tab/](https://material-ui.com/demos/tab/)'
- en: 'Working with React child components: [https://reactjs.org/docs/react-api.html#reactchildren](https://reactjs.org/docs/react-api.html#reactchildren)'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与React子组件一起工作：[https://reactjs.org/docs/react-api.html#reactchildren](https://reactjs.org/docs/react-api.html#reactchildren)
- en: Tab navigation with routes
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于路由的标签导航
- en: You can base your tab content on routes in a routing solution, such as `react-router`.
    To do this, you have to make your tab buttons into links, and you need to have `Route`
    components below the `Tabs` component to render the current URL.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在路由解决方案（如`react-router`）中根据路由来设置你的标签内容。为此，你必须将你的标签按钮转换为链接，并且需要在`Tabs`组件下方有`Route`组件来渲染当前URL。
- en: How to do it...
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s say that your app has three URLs and you want tabs as the navigation
    mechanism to navigate between the routes. The first step is turning the `Tab`
    buttons into links. The second step is having `Route` components render the appropriate
    tab content, based on which one was clicked on. Here''s the code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的应用有三个URL，你想要使用标签作为导航机制在路由之间导航。第一步是将`Tab`按钮转换为链接。第二步是让`Route`组件根据点击的标签渲染相应的标签内容。以下是代码：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When you load the screen, the first tab should be selected and the first tab
    content should be rendered:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当你加载屏幕时，第一个标签应该被选中，并且第一个标签内容应该被渲染：
- en: '![](img/fdbe0165-c323-49ce-88ad-4aa37321aee5.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fdbe0165-c323-49ce-88ad-4aa37321aee5.png)'
- en: 'If you click on the ITEM TWO tab, you''ll be taken to the `/page2` URL. This
    results in the active `Route` component changing the tab content, and the changed
    tab state changes the selected tab:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击“项目二”标签页，你将被带到`/page2` URL。这会导致活动的`Route`组件更改标签内容，并且更改的标签状态会改变选中的标签：
- en: '![](img/f376d9f6-76c1-42d7-9caf-2adc0dd7315c.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f376d9f6-76c1-42d7-9caf-2adc0dd7315c.png)'
- en: How it works...
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The state portion of your component remains the same as any other component
    that uses the `Tabs` component. The `onChange` event changes the `value` state,
    which is passed to `Tabs` as a property to mark the selected tab.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你的组件的状态部分与使用`Tabs`组件的任何其他组件相同。`onChange`事件改变`value`状态，该状态作为属性传递给`Tabs`以标记选中的标签。
- en: 'Let''s take a closer look at the `Tab` components:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看`Tab`组件：
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: A major difference with this implementation compared to something more standard
    is that you're using `Link` as the component property value. The `Link` component,
    from `react-router-dom`, is used to make the tab button into a link that the router
    will process. The `to` property is actually passed to `Link`, which is how it
    knows where the link should take the user.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 与更标准的实现相比，这个实现的一个主要区别是，你使用`Link`作为组件属性值。来自`react-router-dom`的`Link`组件被用来将标签按钮变成路由器将处理的链接。`to`属性实际上传递给了`Link`，这样它就知道链接应该将用户带到哪里。
- en: 'Below the `Tabs` component are the routes that render the tab content, based
    on the tab that the user has clicked on. Let''s take a look at one of these Routes:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Tabs`组件下方是渲染标签内容的路由，基于用户点击的标签。让我们看看这些Routes中的一个：
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The content that is rendered below the tab is based on the current URL, not
    the `value` state of your component. The `value` state is only used to control
    the state of the selected tab.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在标签下方渲染的内容基于当前URL，而不是组件的`value`状态。`value`状态仅用于控制选中标签的状态。
- en: There's more...
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Given that the active tab depends on the active route, you could completely
    remove any tab-related state. First, you create a `TabContainer` component to
    render the `Tabs` component:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于活动标签依赖于活动路由，你可以完全移除任何与标签相关的状态。首先，你创建一个`TabContainer`组件来渲染`Tabs`组件：
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Instead of supplying an `onChange()` handler to the `Tabs` component, the `value`
    property is passed from `TabContainer`. Now, you can `render` this component in
    each `Route` component, passing the appropriate `value` property:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 不同于向`Tabs`组件提供`onChange()`处理程序，`value`属性是从`TabContainer`传递的。现在，你可以在每个`Route`组件中`render`此组件，传递适当的`value`属性：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: There's no more confusing the component state with the current `Route` and how
    the two interact. Everything is handled by the route.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 不要再混淆组件状态与当前`Route`以及它们之间的交互了。所有这些都由路由处理。
- en: See also
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '`Tabs` API documentation: [https://material-ui.com/api/tabs/](https://material-ui.com/api/tabs/)'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tabs` API 文档：[https://material-ui.com/api/tabs/](https://material-ui.com/api/tabs/)'
- en: '`Tabs` demos: [https://material-ui.com/demos/tabs/](https://material-ui.com/demos/tabs/)'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tabs` 示例：[https://material-ui.com/demos/tabs/](https://material-ui.com/demos/tabs/)'
- en: 'React Router documentation: [https://reacttraining.com/react-router/](https://reacttraining.com/react-router/)'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Router 文档：[https://reacttraining.com/react-router/](https://reacttraining.com/react-router/)
