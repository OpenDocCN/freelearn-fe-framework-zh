<html><head></head><body>
		<div id="_idContainer008">
			<h1 id="_idParaDest-15" class="chapter-number"><a id="_idTextAnchor016"/>1</h1>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor017"/>What Is React Native?</h1>
			<p>Building high-quality apps for multiple platforms is the holy grail of app development. Since React Native was published, it has been challenged in very competitive environments because it seemed to be this holy grail for a long time. Its performance was much better than the performance of any of the competitors (Ionic, Cordova) back when it was released by Facebook in 2015 and its development speed is much faster than creating separate Android and iOS apps. </p>
			<p>Since 2015, a lot has happened regarding React Native. Facebook open sourced the framework, a lot of contributors and even big companies such as Microsoft, Discord, and Shopify invested heavily in React Native, and new competitors such as Flutter of Kotlin Multiplatform Mobile evolved. </p>
			<p>In 7 years, a lot of companies migrated their apps to React Native successfully, while others failed in doing so, migrated back to native development, or finally chose other multiplatform technologies. </p>
			<p>In 2022, React Native is used in more products than ever and it has become a lot more developer friendly than in the early days. It is not only available for iOS and Android but also for macOS, Windows, web, VR, and other platforms. Most importantly, and despite many rumours claiming otherwise, Facebook is still betting heavily on React Native.</p>
			<p>The React Native core team at Facebook just completed a rewrite of more than 1,000 React Native screens in its main application, including Dating, Jobs, and Marketplace, which is visited by more than 1 billion users each month. This means React Native powers important and business-critical parts of the biggest and most used app in the world, which is the ultimate proof of it being a stable and supported framework. </p>
			<p>As you can see, React Native has become very powerful and is widely used. But you have to know how to leverage its strengths and how to deal with its weaknesses to create a high-quality app and a well-run software product. This book contains learnings, best practices, and basic architectural and processual concepts you need to know about to be able to decide on the following things: </p>
			<ul>
				<li>When to use React Native for your project</li>
				<li>How to set up your React Native project to work on a bigger scale</li>
				<li>How to use React Native to create a world-class product</li>
				<li>How to organize your team in a software project with React Native</li>
				<li>How to support your development team with useful tools and processes</li>
			</ul>
			<p>This chapter contains a very brief introduction to the main concepts of React as the foundation on which React Native was built, of React Native itself, and of the Expo framework, which is a set of tools and libraries built on top of React Native. We will focus on the key concepts that are relevant for understanding the content that will be covered later in this book.</p>
			<p>If you already have a very good understanding of how React, React Native, and Expo work, feel free to skip this chapter. </p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Exploring React</li>
				<li>Understanding React basics</li>
				<li>Introducing React Native</li>
				<li>Introducing Expo</li>
			</ul>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor018"/>Technical requirements</h1>
			<p>To try out the code examples in this chapter, you need to set up a small React app for the <em class="italic">Exploring React</em> and <em class="italic">Understanding React basics</em> sections, and a React Native app for the <em class="italic">Introducing React Native</em> section. This requires you to install various libraries, depending on what OS you are working with. Both <a href="https://reactjs.org/">https://reactjs.org/</a> and <a href="https://reactnative.dev/">https://reactnative.dev/</a> provide step-by-step guides for setting up the development environment correctly. </p>
			<p>You can find the code in the book’s GitHub repository:</p>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor019"/>Exploring React</h1>
			<p>On <a href="https://reactjs.org/">https://reactjs.org/</a>, React<a id="_idIndexMarker000"/> is defined as a <em class="italic">JavaScript library for building user interfaces</em>. The main<a id="_idIndexMarker001"/> catchphrases<a id="_idIndexMarker002"/> used on the home page are declarative, component-based, and learn once, write anywhere. </p>
			<p>When React was first introduced at the JSConf US conference in May 2013 by Jordan Walke of Facebook, the audience was so skeptical that Facebook decided to start a <em class="italic">React tour</em> to convince people of the benefits of this new library. Today, React is one of the most popular frameworks for creating web applications, and it’s used not only by Facebook itself, but also by many other big players such as Instagram, Netflix, Microsoft, and Dropbox.</p>
			<p>In the next section, I will show you how React works, what makes it so special compared to other similar frameworks and approaches, and how it is related to React Native.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If you already have Node and Node Package Manager installed, you can set up a new app by using the following command in the terminal:</p>
			<p class="callout"><strong class="bold">npx create-react-app name-of-your-app</strong></p>
			<h1 id="_idParaDest-19"><a id="_idTextAnchor020"/>Understanding React basics</h1>
			<p>To get started, open a project<a id="_idIndexMarker003"/> in your IDE so that we can explore a simple example. This is what a React app returning a simple <strong class="source-inline">Hello World</strong> message looks like:</p>
			<pre class="source-code">
function App() {
  return (
    &lt;div&gt;
      &lt;p&gt;Hello World!&lt;/p&gt;
    &lt;/div&gt;
  )
}</pre>
			<p>The first thing that comes<a id="_idIndexMarker004"/> to mind when seeing these code lines is probably that this looks just like XML/HTML! Indeed, it does, but these tags get converted into JavaScript by a preprocessor, so it’s JavaScript<a id="_idIndexMarker005"/> code that looks like XML/HTML tags. Hence the name <strong class="bold">JSX</strong>, which is short for <strong class="bold">JavaScript XML</strong>. </p>
			<p>The JSX tags can be used much like XML/HTML tags; you can structure your code using the different types of tags, and you can style them using CSS files and the <strong class="source-inline">className</strong> attribute, which is the React equivalent of HTML’s <strong class="source-inline">class</strong> attribute.</p>
			<p>On the other hand, you can insert JavaScript code anywhere in the JSX, either as a value for an attribute or inside a tag. You just have to put curly brackets around it. Please have a look at the following code, which uses a JavaScript variable inside JSX:</p>
			<pre class="source-code">
function App() {
  const userName = 'Some Name';
  return (
    &lt;div&gt;
      &lt;p&gt;Hello {userName}!&lt;/p&gt;
    &lt;/div&gt;
  )
}</pre>
			<p>In this example, we are greeting a user whose name we have previously stored in a <strong class="source-inline">userName</strong> variable by inserting this <strong class="source-inline">userName</strong> variable into our example code’s JSX.</p>
			<p>These JSX tags are really handy, but what if I have some part of the code that I want to reuse throughout the code, such as a special kind of button or a sidebar element? This is where the <em class="italic">component-based</em> catchphrase from the ReactJS home page comes into play. </p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor021"/>Understanding React components</h2>
			<p>Our example includes<a id="_idIndexMarker006"/> one component called <strong class="source-inline">App</strong>. In this case, it’s a functional component. It’s also possible to use class components in React but most of the following examples will use the more common functional components. React allows you to write custom components and use them exactly like a normal JSX tag in another part of the code. </p>
			<p>Let’s say we want to have a button that opens an external link to the ReactJS home page upon being clicked. We could define a custom <strong class="source-inline">ReactButton</strong> component like this:</p>
			<pre class="source-code">
function ReactButton() {
  const link = 'https://reactjs.org';
  return (
    &lt;div&gt;
      &lt;a href={link} target="_blank" rel="noopener noreferrer"&gt;
        Go To React
      &lt;/a&gt;
  &lt;/div&gt;
  )
} </pre>
			<p>Then, we can use the button in the main component, using the empty tag notation as it doesn’t have any child components:</p>
			<pre class="source-code">
function App() {
  const userName = 'Some Name';
  return (
    &lt;div&gt;
      &lt;p&gt;Hello {userName}!&lt;/p&gt;
      &lt;ReactButton/&gt;
    &lt;/div&gt;
  )
 }</pre>
			<p>As you can see, every component in React has to implement the <strong class="source-inline">return</strong> function to render a view in the app. The JSX code can only be executed when it is called by the <strong class="source-inline">return</strong> function, and there has to be one JSX tag that wraps all the other tags and components. There is no need to explicitly implement how the view should behave when the content changes – React automatically handles this. This is what we mean when we describe React as being declarative.</p>
			<p>So far, we have seen why React<a id="_idIndexMarker007"/> is defined as a declarative, component-based JavaScript library for building user interfaces. But we haven’t talked about one of the main advantages of React yet: how it efficiently rerenders views. To understand this, we need to have a look at props and state.</p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor022"/>Understanding React props and state</h2>
			<p>A <strong class="bold">prop</strong> is a parameter that<a id="_idIndexMarker008"/> is transferred from a parent<a id="_idIndexMarker009"/> component to a child component. Let’s say we want to create a <strong class="source-inline">WelcomeMessage</strong> component that shows a welcoming text, including the username from the <strong class="source-inline">App</strong> component.</p>
			<p>This component could look like this:</p>
			<pre class="source-code">
function WelcomeMessage(props) {
  return (
    &lt;div&gt;
      &lt;p&gt;Welcome {props.userName}!&lt;/p&gt;
      &lt;p&gt;It's nice to see you here!&lt;/p&gt;
    &lt;/div&gt;
  )
 }</pre>
			<p>Then, we can include it in the <strong class="source-inline">App</strong> component:</p>
			<pre class="source-code">
function App() {
  const userName = "Some Name";
  return (
    &lt;div&gt;
      &lt;WelcomeMessage userName={userName}/&gt;
      &lt;ReactButton/&gt;
    &lt;/div&gt;
  )
 }</pre>
			<p>The name of the prop<a id="_idIndexMarker010"/> is used like an attribute<a id="_idIndexMarker011"/> on the JSX tag of the child component. By using <strong class="source-inline">props</strong> as a parameter for the child component, all those attributes are automatically accessible in the child component, such as <strong class="source-inline">username</strong> in our example. </p>
			<p>What makes React so efficient is the fact that any time the value of a prop changes, only those components that are affected by that change are rerendered. This massively reduces the rerendering costs, especially for large applications with many layers.</p>
			<p>The same goes for state changes. React<a id="_idIndexMarker012"/> provides the possibility<a id="_idIndexMarker013"/> to turn any component into a stateful component by implementing the <strong class="source-inline">state</strong> variable in class components or the <strong class="source-inline">useState</strong> Hook (more on Hooks in <a href="B16694_03.xhtml#_idTextAnchor061"><em class="italic">Chapter 3</em></a>, <em class="italic">Hello React Native</em>) in functional components. The classical example of a stateful component is a <strong class="source-inline">Counter</strong>:</p>
			<pre class="source-code">
function Counter () {
  const [numClicks, setNumClicks] = useState(0);
  return (
    &lt;div&gt;
      &lt;p&gt;You have clicked {numClicks} times!&lt;/&gt;
      &lt;button onClick={() =&gt; setNumClicks(numClicks+1)&gt;
        Click Me
      &lt;/button&gt;
    &lt;/div&gt;
  )
 }</pre>
			<p>The <strong class="source-inline">numClicks</strong> state variable is initialized with a value of <strong class="source-inline">0</strong>. Any time the user clicks on the button and the internal state of the <strong class="source-inline">Counter</strong> component changes, only the content of the <strong class="source-inline">&lt;p&gt;</strong> tag is rerendered. </p>
			<p>ReactDOM is responsible for comparing all the elements in the UI tree with the previous ones and updating only the nodes whose content has changed. This package also makes it possible to easily integrate React code into existing web apps, regardless of what language they are written in.</p>
			<p>When Facebook decided<a id="_idIndexMarker014"/> to become a mobile-first <a id="_idIndexMarker015"/>company in 2012, this <em class="italic">learn once, write anywhere</em> approach of React was applied to the development of mobile applications, which led to the emergence of React Native in 2013, where it is possible to write apps for iOS or Android using only JavaScript or TypeScript.</p>
			<p>Now that we have learned what React is and how it works in general, let’s learn more about React Native.</p>
			<h1 id="_idParaDest-22">Introduci<a id="_idTextAnchor023"/>n<a id="_idTextAnchor024"/>g React Native</h1>
			<p>React Native is a framework<a id="_idIndexMarker016"/> that makes it possible to write React code and deploy it to multiple platforms. The most well known are iOS and Android, but you can use React Native to create apps for Windows, macOS, Oculus, Linux, tvOS, and much more. With React Native for Web, you can even deploy a mobile application as a web app using the same code.  </p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If you don’t want to spend an hour setting up the development environment for creating a new React Native app and trying out the code examples, you could install the Expo CLI using <strong class="source-inline">npm</strong> or <strong class="source-inline">yarn</strong>:</p>
			<p class="callout"><strong class="bold">npm install -g expo-cli</strong>        OR        <strong class="bold">yarn global add expo-cli</strong></p>
			<p class="callout">After that, setting up a new React Native app just takes running one command in the terminal:</p>
			<p class="callout"><strong class="bold">expo init NameOfYourApp</strong></p>
			<p class="callout"><strong class="bold">Pro tip</strong>: The default package manager for a new app created by running <strong class="source-inline">expo init</strong> is yarn. If you want to use <strong class="source-inline">npm</strong> instead, add <strong class="source-inline">--npm</strong> to the <strong class="source-inline">expo init</strong> command.</p>
			<p>In the next section, you will<a id="_idIndexMarker017"/> learn how cross-platform development is made possible in the React Native framework.</p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor025"/>React Native basics</h2>
			<p>As React Native<a id="_idIndexMarker018"/> is heavily based on React, the code looks much the same; you use components to structure the code, props to hand over parameters from one component to another, and JSX in a return statement to render the view. One of the main differences is the type of basic JSX components you can use.</p>
			<p>In React, they look a lot like XML/HTML tags, as we have seen in the previous section. In React Native, the so-called core components are imported from the <strong class="source-inline">react-native</strong> library and look different:</p>
			<pre class="source-code">
import React from 'react';
import {ScrollView, Text, View} from 'react-native';
const App = () =&gt; {
  return (
   &lt;ScrollView contentInsetAdjustmentBehavior="automatic"&gt;
        &lt;View&gt;
           &lt;Text&gt;Hello World!&lt;/Text&gt;
        &lt;/View&gt;
     &lt;/ScrollView&gt;
  );
};
export default App;</pre>
			<p>React Native<a id="_idIndexMarker019"/> does not use web views to render the JavaScript code on the device like some other cross-platform solutions; instead, it converts the UI written in JavaScript into native UI elements. The React Native <strong class="source-inline">View</strong> component, for example, gets converted into a <strong class="source-inline">ViewGroup</strong> component for Android, and into a <strong class="source-inline">UIView</strong> component for iOS. This conversion<a id="_idIndexMarker020"/> is done via the Yoga engine (<a href="https://yogalayout.com">https://yogalayout.com</a>). </p>
			<p>React Native is powered by two threads – the JavaScript thread, where the JavaScript code is executed, and the native thread (or UI thread), where all device interaction such as user input and drawing screens happens.</p>
			<p>The communication between<a id="_idIndexMarker021"/> these two threads takes place over the so-called <strong class="bold">Bridge</strong>, which is a kind of interface between the JavaScript code and the native part of the app. Information such as native events or instructions is sent in serialized batches from the native UI thread over the Bridge to the JavaScript thread and back. This process is shown in the following diagram:</p>
			<div>
				<div id="_idContainer006" class="IMG---Figure">
					<img src="image/B16694_01_01.jpg" alt="Figure 1.1 – React Native Bridge&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – React Native Bridge</p>
			<p>As you can see, events are collected in the native thread. The information is then serialized and passed to the JavaScript thread via the<a id="_idIndexMarker022"/> Bridge. In the JavaScript thread, information is deserialized and processed. This also works the other way round, as you can see in <em class="italic">Steps 5</em> to <em class="italic">8</em> of the preceding diagram. You can call methods, which are provided by native components, or React Native can update the UI when necessary. This is also done by serializing the information and passing it to the native thread via the Bridge. This Bridge makes it possible to communicate between native and JavaScript in an asynchronous way, which is great to create real native apps with JavaScript. </p>
			<p>But it also has some downsides. The serialization<a id="_idIndexMarker023"/> and deserialization of information, as well as being the only central point of communication between native and JS, makes the bridge a bottleneck that can cause performance issues in some situations. This is why React Native was completely rewritten between 2018 and 2022.</p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor026"/>The new React Native (2022)</h2>
			<p>Because of the architectural<a id="_idIndexMarker024"/> problems mentioned previously, the React Native core was rearchitectured and rewritten completely. The main goal was to get rid of the Bridge and the performance issues tied to it. This was done by introducing JSI, the JavaScript interface, which allows direct communication between native and JavaScript code without the need for serialization/deserialization.</p>
			<p>The JS part is truly aware of the native objects, which means you can directly call methods synchronously. Also, a new renderer was introduced during the rearchitecture, which is called Fabric. More details on the<a id="_idIndexMarker025"/> React Native rearchitecture will be provided in <a href="B16694_03.xhtml#_idTextAnchor061"><em class="italic">Chapter 3</em></a>, <em class="italic">Hello React Native</em>.</p>
			<p>The rearchitecture made the awesome React Native framework even more awesome by improving its out-of-the-box performance significantly. At the time of writing, more and more packages are being adapted to the new React Native architecture. </p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor027"/>More React Native advantages</h2>
			<p>Ever since it was open-sourced in 2015, there has been a huge<a id="_idIndexMarker026"/> and ever-growing community that develops and provides a lot of add-on packages for a multitude of different problems and use cases. This is one of the main advantages that React Native has over other, similar cross-platform approaches.</p>
			<p>These packages are mostly well maintained and provide nearly all native functionality that currently exists, so you only have to work with JavaScript to write your apps. </p>
			<p>This means using React Native for mobile app development makes it possible to reduce the size of the developer team greatly, as you no longer need both Android and iOS specialists, or you can at least reduce the team size of native specialists significantly. </p>
			<p>And the best thing about working with these well-maintained packages is that things such as the React Native core rewrites come to your app automatically when the packages are updated. </p>
			<p>Additionally, the hot reload feature speeds up the development process by making it possible to see the effect of code changes in a matter of seconds. Several other tools make the life of a React Native developer even more comfortable, which we will look at in more detail in <a href="B16694_09.xhtml#_idTextAnchor282"><em class="italic">Chapter 9</em></a>, <em class="italic">Essential Tools for Improving React Native Development</em>.</p>
			<p>Now that we understand<a id="_idIndexMarker027"/> what React and React Native are, and how they are related to each other, let’s have a look at a tool that makes the whole development process much easier – Expo.</p>
			<h1 id="_idParaDest-26"><a id="_idTextAnchor028"/>Introducing Expo</h1>
			<p>There are several ways to set up a new React<a id="_idIndexMarker028"/> Native app. For the example project in this book, we will use Expo. It’s a powerful framework built on top of React Native that includes many different tools and libraries. Expo uses plain React Native and enhances it with a lot of functionality.</p>
			<p>While React Native is a very lean framework when it comes to core components and native functionality, Expo provides nearly every functionality that you can think of using in your app. It provides components and APIs for nearly all native device functions, such as video playback, sensors, location, security, device information, and a lot more.</p>
			<p>Think of Expo as a full-service package that makes your life as a React Native developer a lot easier. Since everything comes with a downside, Expo adds some size to your final app bundle, because you add all the libraries to your app whether you use them or not.</p>
			<p>It also uses a somehow modified version of React Native, which is normally one or two versions behind the latest React Native version. So, when working with Expo, you have to wait for the latest React Native features a couple of months after they are released.</p>
			<p>I would recommend using Expo if you want to achieve results at maximum speed and don’t have to optimize your bundle size. </p>
			<p>When setting up a new project with Expo, you can choose between two different types of workflows – a bare workflow and a managed workflow. In both workflows, the framework provides you with easy-to-use libraries for including native elements such as the camera, the filesystem, and others. Additionally, services such as push notification handling, over-the-air feature updates, and a special Expo build service for iOS and Android builds are available.</p>
			<p>If you choose the bare workflow, you have a plain React Native app and can add the Expo libraries you need. You can also add other third-party libraries, which is not possible in the managed workflow. There, you only write JavaScript or TypeScript code in the IDE of your choice; everything else is handled by the framework.</p>
			<p>On their home page (<a href="https://docs.expo.dev/">https://docs.expo.dev/</a>), Expo suggests that you<a id="_idIndexMarker029"/> start with a managed workflow for a new app because it is always possible to switch over to a bare<a id="_idIndexMarker030"/> workflow, if necessary, by using the <strong class="source-inline">expo eject</strong> command in the CLI. This necessity can arise if you need to integrate a third-party package or library that is not supported by Expo, or if you want to add or change native code.</p>
			<p>After initializing the app, you can run it by using the <strong class="source-inline">expo start</strong> command. This will start up the Metro bundler, which compiles the JavaScript code of the app using Babel. Additionally, it opens the Expo Developer CLI interface, where you can choose which simulator you want to open the app in, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer007" class="IMG---Figure">
					<img src="image/B16694_01_02.jpg" alt="Figure 1.2 – Expo CLI Interface&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – Expo CLI Interface</p>
			<p>Expo Developer Tools provides access to the Metro bundler logs. It also creates key bindings for multiple options regarding how to run the app, such as iOS or Android simulators. Finally it creates a QR code that can be scanned with the Expo Go app. Expo even supports creating web applications from React Native code for most use cases.</p>
			<p>With Expo, it’s very easy to run your app on a hard device – just install the Expo app on your smartphone or tablet and scan the QR code, as described previously. It’s also possible to run the app on several devices or simulators at the same time. </p>
			<p>All these features make Expo<a id="_idIndexMarker031"/> a very handy and easy-to-use framework for mobile app development with React Native.</p>
			<h1 id="_idParaDest-27"><a id="_idTextAnchor029"/>Summary</h1>
			<p>In this chapter, we introduced the main concepts of the JavaScript library React. We have shown that React is declarative, component-based, and follows a <em class="italic">learn once, write everywhere</em> approach. These concepts are the base for the cross-platform mobile development framework React Native.</p>
			<p>You saw the main advantages of this framework, namely the huge community that provides additional packages and libraries, the fact that a lot of operating systems besides iOS and Android are available, and the usage of native elements via the Bridge or JSI. Last but not least, you discovered Expo as one way of setting up a React Native app, and you know when to use which Expo workflow.</p>
			<p>In the next chapter, we will briefly talk about the most important facts and features of JavaScript and TypeScript.</p>
		</div>
	</body></html>