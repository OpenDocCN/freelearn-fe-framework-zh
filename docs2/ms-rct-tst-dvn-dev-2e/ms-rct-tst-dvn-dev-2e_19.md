# 19

# 在更广泛的测试领域中理解 TDD

除了测试驱动开发的机制之外，本书还涉及了一些关于 TDD 实践者心态的想法：何时何地“作弊”，系统重构，*严格*的 TDD 等等。

一些开发团队喜欢采用“快速行动，打破事物”的口号。TDD 则相反：放慢速度，深思熟虑。为了理解在实践中这意味着什么，我们可以将 TDD 与各种其他流行的测试技术进行比较。

本章将涵盖以下主题：

+   测试驱动开发作为一种测试技术

+   手动测试

+   自动化测试

+   完全不进行测试

到本章结束时，你应该对为什么以及如何与其他编程实践相比，我们实践 TDD（测试驱动开发）有一个很好的理解。

# 测试驱动开发作为一种测试技术

TDD 实践者有时喜欢说，TDD 不是关于测试；而是关于设计、行为或规范，而我们最终拥有的自动化测试只是一个额外的好处。

是的，TDD 是关于设计的，但 TDD 当然也是关于测试的。TDD 实践者关心他们的软件具有高*质量*，这与测试人员关心的是同一件事。

有时，人们会质疑 TDD 的命名，因为他们觉得“测试”这个概念混淆了实际的过程。原因在于开发者误解了构建“测试”的含义。典型的单元测试工具实际上几乎不提供如何编写*良好*测试的指导。结果证明，将测试重新构造成规范和示例是向开发者介绍测试的好方法。

所有自动化测试都很难编写。有时，我们会忘记编写重要的测试，或者构建脆弱的测试，编写宽松的期望，过度复杂化解决方案，忘记重构，等等。

不仅新手会遇到这个问题——每个人都会，包括专家。人们经常一团糟。这也是乐趣的一部分。发现 TDD 的乐趣需要一定的谦卑，并接受你大多数时候不会编写完美的测试套件。完美的测试套件确实非常罕见。

如果你很幸运，你的团队里有测试人员，你可能会认为 TDD 侵犯了他们的工作，甚至可能让他们失业。然而，如果你询问他们的意见，你无疑会发现他们非常希望开发者对他们的工作质量感兴趣。有了 TDD，你可以自己捕捉到所有那些微不足道的逻辑错误，而不需要依赖他人的手动测试。然后测试人员可以更好地利用他们的时间，专注于测试复杂用例和寻找遗漏的需求。

## 单元测试的最佳实践

以下是一些优秀的单元测试：

+   **独立**：每个测试应该只测试一件事，并只调用一个单元。我们可以采用许多技术来实现这一目标。仅举两个例子，协作者通常（但不总是）被模拟，示例数据应该是正确描述测试所需的最小数据集。

经典主义者与模拟主义者 TDD

你可能听说过伟大的 TDD 辩论，即*经典主义者*与*模拟主义者*的 TDD。其想法是，经典主义者不会使用模拟和存根，而模拟主义者会模拟所有协作者。在现实中，这两种技术都很重要。你在本书中已经看到了它们的使用。我鼓励你不要局限于单一的方法，而是实验并学会对两者都感到舒适。

+   **简短，高度抽象**：测试描述应该简洁。测试代码应突出显示对测试重要的所有代码片段，并隐藏任何所需但不相关的设备。

+   **快速运行**：使用测试替身而不是与系统资源（文件、网络连接等）或其他进程交互。不要在代码中使用超时，或依赖时间的流逝。

+   **专注于可观察的行为**：系统对外部世界的影响才是有趣的，而不是它如何做到这一点。在 React 的情况下，我们关注 DOM 交互。

+   **分为三部分**：这些部分是**安排**、**行动**和**断言**，也称为**AAA**模式。每个测试都应该遵循这个结构。

+   **不要重复自己**（**DRY**）：始终花时间重构和清理你的测试，目标是可读性。

+   **设计工具**：优秀的测试帮助你弄清楚如何设计你的系统。这并不是说前置设计不重要。在本书的几乎每一章中，我们在开始测试之前都进行了一些设计。做一些思考，这样你就有了一个大致的方向。只是不要试图计划得太远，并且准备好在前进过程中完全放弃你的设计。

TDD 不是优秀设计的替代品。要成为一名优秀的 TDD 实践者，你还应该了解并练习软件设计。关于软件设计有许多书籍。不要局限于关于 JavaScript 或 TypeScript 的书籍；优秀的设计超越语言。

## 提高你的技术

以下是一些改进的一般性建议：

+   **与他人合作**：除了阅读这本书之外，提高 TDD 水平的最佳方式是与专家合作。由于 TDD 非常适合结对和团队编程，它可以给不同经验水平的团队提供结构。经验丰富的开发者可以使用小型测试的粒度来帮助提高经验不足的开发者的工作。

+   **实验设计**：TDD 为你提供了一个安全网，让你可以实验程序的风格和形状。利用这个安全网来了解更多关于设计的信息。你的测试会保护你。

+   **学会放慢速度**：TDD 需要大量的个人自律。不幸的是，没有余地可以马虎。你绝对不能走捷径；相反，要抓住每一个机会进行重构。一旦测试通过，就坐下来审视你的代码。在继续下一个测试之前，仔细看看你的当前解决方案，并认真思考它是否是最好的。

+   **不要害怕推迟设计决策**：有时，我们面临几个设计选择，知道选择哪个选项可能很棘手。即使是命名变量这样的简单行为也可能很困难。拥有设计感的一部分是知道何时推迟你的思考。如果你处于重构阶段，并发现自己正在权衡两个或更多选项，那就继续前进，添加另一个测试，然后回过头来审视你的设计。你通常会发现自己有更多的设计知识，并且更接近正确答案。

+   **每天解决一个 kata**：kata 是一种短期的练习，旨在反复练习以教授你某种技术。两个基本的 kata 是 *硬币兑换器* 和 *罗马数字*。更复杂的 kata 包括保龄球 kata、银行 kata 和康威的 *生命游戏*。钻石 kata 是我最喜欢的，还有排序算法。

+   **参加编码 retreat**：**编码 retreat** 涉及一天的对偶编程和 TDD，围绕 *生命游戏* kata 展开。*全球编码 retreat 日* 在 11 月举行。来自世界各地的团队聚集在一起解决这个问题。这不仅有趣，而且是扩展你的 TDD 视野的好方法。

这涵盖了关于 TDD 的一般建议。接下来，让我们看看手动测试技术。

# 手动测试

如你所猜到的，手动测试意味着启动你的应用程序并实际使用它。

由于你的软件是你的创造性作品，自然地，你很想知道它的表现如何。你当然应该花时间做这件事，但把它视为休息和放松的机会，而不是你开发过程的一个正式部分。

与 *使用* 软件相比，*开发* 软件的缺点是使用它需要花费大量时间。听起来很傻，但指向、点击和输入都占用了宝贵的时间。此外，设置测试环境并准备好相关测试数据也需要时间。

因此，尽可能避免手动测试是很重要的。然而，在某些情况下，它是必要的，正如我们将在本节中发现的那样。

总是会有一种诱惑，在每一个特性完成后手动测试软件，只是为了验证它是否工作。如果你发现自己经常这样做，考虑一下你对单元测试的信心有多大。

如果你声称，“我对我的单元测试有 100% 的信心”，那你为什么还需要 *使用* 你的软件来证明它呢？

让我们看看一些具体的手动测试类型，从展示软件开始。

## 展示软件

至少有两个重要场合你应该*始终*手动测试：当你向客户和用户展示你的软件时，以及当你准备展示你的软件时。

准备意味着写下一份演示脚本，列出你想要执行的所有操作。在实际演示之前，至少练习你的脚本两遍。很多时候，排练会带来对脚本的修改，这就是为什么排练如此重要的原因。在正式演示之前，一定要确保你已经至少进行了一次不需要修改的完整演练。

## 测试整个产品

前端开发包括很多移动部件，包括以下内容：

+   需要支持的多个浏览器环境

+   CSS

+   分布式组件，如代理和缓存

+   认证机制

由于所有这些移动部件的交互，手动测试是必要的。我们需要检查所有部件是否能够很好地组合在一起。

或者，你可以使用端到端测试来达到相同的覆盖率；然而，这些测试的开发和维护成本也很高。

## 探索性测试

探索性测试是你希望你的 QA 团队做的事情。如果你没有与 QA 团队合作，你应该分配时间自己来做这件事。探索性测试涉及探索软件并寻找团队尚未考虑的缺失需求或复杂用例。

由于 TDD 在非常低的层面上工作，很容易错过或甚至误解需求。你的单元测试可能覆盖了 95%的情况，但你可能会不小心忘记剩下的 5%。当团队刚开始使用 TDD，或者由新手程序员组成时，这种情况经常发生。即使是经验丰富的 TDD 实践者，也会发生这种情况——即使是那些写 TDD 书籍的人！我们都会时不时犯错误。

一个非常常见的错误场景涉及到模拟。当一个类或函数签名发生变化时，该类或函数的任何模拟也必须更新。这一步经常被遗忘；单元测试仍然通过，错误只有在实际运行应用程序时才会被发现。

无 bug 的软件

TDD 可以给你更多的信心，但绝对没有保证 TDD 能保证无 bug 的软件。

随着时间和经验的积累，你将更擅长在它们到达 QA 团队之前发现所有那些讨厌的边缘情况。

探索性测试的替代方案是自动化验收测试，但就像端到端测试一样，这些测试的开发和维护成本很高，而且它们还要求有高水平的专业知识和团队纪律。

## 浏览器中的调试

调试总是耗时巨大。这可能是一种极其令人沮丧的经历，伴随着大量的焦虑。这就是我们进行测试驱动开发的一个主要原因：这样我们就永远不需要调试。我们的测试为我们做了调试。

相反，TDD 的一个缺点是，你的调试技能可能会退化。

对于 TDD 实践者来说，从理论上讲，调试应该是一个非常罕见的情况，或者至少是积极避免的情况。但总有需要调试的情况。

打印行调试是一种调试技术，其中代码库中充满了`console.log`语句，希望它们可以提供有关运行时错误的线索。我与许多程序员合作过，他们职业生涯的开始是 TDD；对于他们中的许多人来说，打印行调试是他们所知道的唯一调试形式。尽管这是一个简单的技术，但它也很耗时，涉及大量的尝试和错误，您完成工作后必须记得清理。有可能会忘记一个多余的`console.log`，然后它在生产环境中生效。

现代浏览器具有非常复杂的调试工具，直到最近，这些工具只能在“全功能”IDE（如 Visual Studio 或 IntelliJ）中想象得到。您应该抽出时间来了解所有标准的调试技术，包括设置断点（包括条件断点）、进入、退出和跳过、监视变量等等。

一个常见的反模式是使用调试技术来追踪一个错误，一旦发现，就修复它并继续下一个任务。您应该做的是编写一个失败的测试来证明错误的存在。就像魔法一样，测试已经为您完成了调试。然后，您可以修复错误，并且立即，测试会告诉您问题是否已修复，而无需您手动重新测试。想想您将节省多少时间！

查看**进一步阅读**部分，获取有关 Chrome 调试器的资源。

这涵盖了您将执行的主要手动测试类型。接下来，让我们看看自动化测试技术。

# 自动化测试

TDD 是一种自动化测试形式。本节列出了其他一些流行的自动化测试类型，以及它们与 TDD 的比较。

## 集成测试

这些测试检查两个或更多独立进程之间的交互。这些进程可以是同一台机器上的，也可以分布在网络中。然而，您的系统应该使用与生产环境中相同的通信机制，因此如果它向一个网络服务发出 HTTP 调用，那么它应该在您的集成测试中这样做，无论该网络服务在哪里运行。

集成测试应该使用与单元测试相同的单元测试框架编写，所有关于编写良好单元测试的规则都适用于集成测试。

集成测试中最棘手的部分是编排代码，这涉及到启动和停止进程，以及等待进程完成其工作。可靠地执行这些操作可能很困难。

如果你选择在单元测试中模拟对象，当你不模拟这些交互时，你需要至少*一些*对这些交互的覆盖，集成测试是这样做的一种方式。另一种方式是系统测试，如以下所述。

## 系统测试和端到端测试

这些是自动化测试，它们通过驱动 UI 来测试整个系统，通常（但不一定）是通过驱动 UI 来实现的。

当手动探索性测试开始占用过多时间时，它们是有用的。这种情况发生在代码库随着规模和年龄的增长而增长。

端到端测试的建设和维护成本很高。幸运的是，它们可以逐步引入，这样你就可以从小规模开始，证明它们的价值，然后再扩大其范围。

## 接受测试

接受测试是由客户或代表客户的代理（如产品负责人）编写的，其中“接受”指的是必须通过的质量关卡，以便发布的软件被视为完整。它们可能是自动化的，也可能不是，并且它们在系统级别指定行为。

客户应该如何编写这些测试？对于自动化测试，你通常可以使用系统测试工具，如 Cucumber 和 Cypress。我们在*第十七章**，编写您的第一个 Cucumber 测试*和*第十八章**，由 Cucumber 测试引导的功能添加*中看到的 Gherkin 语法是这样做的一种方式。

接受测试可以用来在开发人员和产品利益相关者之间建立信任。如果客户不断测试你的软件以寻找错误，这表明开发团队与外界之间的信任水平很低。如果接受测试开始捕获那些客户可能发现的错误，它们可以帮助提高这种信任。然而，与此同时，你也应该问自己为什么 TDD 一开始就没有捕获所有这些错误，并考虑如何改进你的整体测试流程。

## 基于属性和生成式测试

在传统的 TDD 中，我们找到一小组规范或示例来测试我们的函数。基于属性的测试不同：它基于对函数输入定义的测试生成大量测试。测试框架负责生成输入数据和测试。

例如，如果我有一个将华氏度转换为摄氏度的函数，我就可以使用生成式测试框架来生成针对大量随机整数华氏度测量值的测试，并确保每个值都能正确转换为摄氏度值。

基于属性的测试与 TDD（测试驱动开发）一样困难。它不是万能的灵丹妙药。找到正确的属性进行断言是具有挑战性的，尤其是如果你旨在以测试驱动的方式构建它们。

这种测试不会取代 TDD，但它是任何 TDD 实践者的工具箱中的另一个工具。

## 快照测试

这是一种流行的 React 应用程序测试技术。React 组件树被序列化为 JSON 字符串并存储到磁盘上，然后在测试运行之间进行比较。

React 组件树在几个重要场景中非常有用，包括以下内容：

+   当你的团队在 TDD 和一般程序设计方面经验不足，并且可以通过快照测试的安全网来增强信心时

+   当你正在使用的软件在生产的测试覆盖率为零，并且你希望在做出任何更改之前快速获得一定程度的信心时

质量保证团队有时会对软件在版本之间的视觉变化感兴趣，但他们可能不会想在你的单元测试套件中编写测试；他们会有自己的专用工具来做这件事。

快照测试当然是一个值得了解的有用工具，但要注意以下问题：

+   快照不是描述性的。它们不会超出说“这个组件树看起来和之前一样”。这意味着如果它们崩溃了，不会立即清楚为什么它们崩溃了。

+   如果快照在组件树的高层渲染，它们就会变得脆弱。脆弱的测试经常失败，因此需要花费大量时间来纠正。由于测试是在高层进行的，它们无法精确指出错误的位置，因此你将花费大量时间寻找失败的原因。

+   快照测试可以在两种情况下通过：首先，当组件树与之前测试的版本相同，其次，当找不到之前测试运行中的快照工件。这意味着绿色测试并不能给你带来完全的信心——它可能只是因为之前的工件缺失而变绿。

当编写良好的测试（任何类型的测试）时，你希望以下关于任何测试失败都是真实的：

+   非常快地确定失败是由于错误还是规范的变化

+   在错误的情况下，非常快地确定问题和错误的位置

TDD 是一种社区已经学到了足够多的、知道如何编写良好测试的成熟技术。我们在快照测试方面还没有达到这个水平。如果你绝对必须在代码库中采用快照测试，请确保你衡量它为你和你的团队提供的价值。

## 金丝雀测试

金丝雀测试是在你将软件发布给一小部分用户并观察发生了什么。对于拥有大量用户的 Web 应用程序来说，这可能很有用。金丝雀测试的一种形式涉及将每个请求发送到两个系统：运行中的系统和测试系统。用户只能感知到运行中的系统，但测试系统的结果由你记录和分析。然后可以观察到功能和性能的差异，而你的用户永远不会受到测试软件的影响。

金丝雀测试很有吸引力，因为从表面上看，它似乎非常具有成本效益，而且几乎不需要程序员进行任何*思考*。

与 TDD 不同，金丝雀测试无法帮助你设计软件，而且你可能需要一段时间才能得到任何反馈。

这就完成了我们对自动化测试领域的考察。我们本章开始时探讨了手动测试技术。现在，让我们以一个最终技术来结束本章：完全不进行测试！

# 完全不进行测试

有一种观点认为，TDD 不适用于某些它确实适用的场景——例如，如果你的代码是废弃的，或者一旦部署就被认为永远不需要修改。相信这一点几乎可以确保相反的情况是真实的。代码，尤其是没有测试的代码，往往会在其预期寿命之外继续存在。

删除代码的恐惧

除了减少更改代码的恐惧之外，测试还可以减少删除代码的恐惧。没有测试，你可能会阅读一些代码并想“也许有人用这段代码来达到我不太记得的目的。”有了测试，这就不会成为问题。你会阅读测试，看到由于需求的变化，测试不再适用，然后删除测试及其相应的生产代码。

然而，有一些情况下不编写测试是可以接受的。其中最重要的两个如下。

## 当质量不重要时

不幸的是，在许多环境中，质量并不重要。我们中的许多人都能理解这一点。我们为那些积极忽视质量的雇主工作过。这些人赚得足够的利润，以至于他们不需要或不想关心。关心质量，不幸的是，是一个个人的选择。如果你在一个不重视质量的团队中，将很难说服他们 TDD 是值得的。

如果你处于这种情况，并且你迫切希望使用 TDD，那么你有几个选择。首先，你可以花时间说服你的同事这是一个好主意。这从来都不是一件容易的事情。你也可以玩 TDD-by-stealth 游戏，在你开始之前不征求任何人的同意。如果这些选项都失败了，一些程序员可能会足够幸运，能够找到一家确实重视质量的替代雇主。

## 编写和删除代码

Spike 意味着不进行测试的编码。我们在未知领域时进行 spike。我们需要找到解决我们以前从未解决过的问题的可行方法，这很可能会涉及大量的尝试和错误，以及大量的回溯。在找到可行方法之前，找到不可行方法的可能性很高。在这种情况下编写测试没有太多意义，因为许多在过程中编写的测试最终都会被废弃。

假设，例如，我正在构建一个 WebSocket 服务器和客户端，但这是我第一次使用 WebSocket。这将是一个很好的 spike 候选者——我可以安全地探索 WebSocket API，直到我对将其集成到我的应用程序中感到舒适。

当你觉得你已经找到了一个可行的方案时，重要的是要停止 spiking。你不需要一个完整的解决方案，只需要一个能教会你足够知识，让你走上正确道路的方案。

在 TDD 的纯粹主义视角中，spiking 必须随后进行删除。如果你要进行 spike，你必须习惯于删除你的工作。不幸的是，说起来容易做起来难；很难清除创造性输出。你必须摆脱你的代码是神圣的信念。乐于将其丢弃。

在 TDD 的实用主义视角中，spiking 常常可以随后编写围绕 spike 代码的测试。我经常使用这个技巧。如果你是 TDD 的新手，在你自信能够想出一套测试序列，覆盖 spike 代码中所有必需的功能之前，避免使用这个特定的作弊技巧可能更明智。

纯粹主义者可能会说，你的 spike 代码可以包含冗余代码，并且它可能不是最简单的解决方案，因为测试并没有驱动实现。这个论点有一定的道理。

Spiking 和测试最后开发

Spiking 与**测试最后**的实践有关，但存在细微的差别。围绕 spike 编写代码是 TDD 的一个作弊行为，因为你希望你的最终测试看起来就像你一开始就使用了 TDD 一样。任何在你之后到来的人都不应该知道你作弊了。

**测试最后**，然而，是一种更宽松的测试方式，你先编写所有生产代码，然后编写一些单元测试来证明*一些*更重要的用例。以这种方式编写测试给你提供了一定程度的回归覆盖率，但没有 TDD 的其他好处。

# 摘要

成为 TDD 的优秀实践者需要极大的努力。这需要练习、经验、决心和纪律。

许多人尝试过 TDD 并失败了。其中一些人可能会得出结论说 TDD 是有缺陷的。但我并不认为它是有缺陷的。只是需要努力和耐心才能做对。

但究竟什么是做对的呢？

所有软件开发技术都是主观的。本书中的所有内容都是主观的；它不是*正确的方式*。这是一系列我喜欢使用并且发现成功的技巧集合。其他人也用其他技巧取得了成功。

TDD 的激动人心之处不在于过程的黑白、严格形式；而是在于灰色地带，我们可以定义（并完善）一个适合我们和同事的开发过程。TDD 循环给我们提供了*刚好足够*的结构，我们可以从中找到乐趣，用我们的规则和教条来充实它。

我希望你觉得这本书有价值且有趣。测试驱动 React 应用程序的方法有很多，我希望这能成为你发展测试实践的平台。

# 进一步阅读

要了解更多关于本章所涉及的主题，请查看以下资源：

+   有用的 Kata 资源：

[`codingdojo.org/kata/`](http://codingdojo.org/kata/)

[`codekata.com`](http://codekata.com)

[`kata-log.rocks`](http://kata-log.rocks)

[`github.com/sandromancuso/Bank-kata`](https://github.com/sandromancuso/Bank-kata)

[`www.natpryce.com/articles/000807.xhtml`](http://www.natpryce.com/articles/000807.xhtml)

+   全球程序员重置日：[`www.coderetreat.org`](https://www.coderetreat.org)

+   在 Chrome 开发者工具中开始调试 JavaScript：[`developers.google.com/web/tools/chrome-devtools/javascript/`](https://developers.google.com/web/tools/chrome-devtools/javascript/)

+   JavaScript 的基于属性的测试：[`github.com/leebyron/testcheck-js`](https://github.com/leebyron/testcheck-js)
