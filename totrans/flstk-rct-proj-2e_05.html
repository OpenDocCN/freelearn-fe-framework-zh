<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Building a Backend with MongoDB, Express, and Node</h1>
                </header>
            
            <article>
                
<p>While developing different web applications, you will find there are common tasks, basic features, and implementation code repeated across the process. The same is true for the MERN applications that will be developed in this book. Taking these similarities into consideration, we will first lay the foundations for a skeleton MERN application that can be easily modified and extended to implement a variety of MERN applications.</p>
<p>In this chapter, we will cover the following topics and start with the backend implementation of the MERN skeleton using Node, Express, and MongoDB:</p>
<ul>
<li>Overview of the skeleton application</li>
<li>Backend code setup</li>
<li style="font-weight: 400">User model with Mongoose</li>
<li>User CRUD API endpoints with Express</li>
<li>User Auth with JSON Web Tokens</li>
<li style="font-weight: 400">Running backend code and checking APIs</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Overview of the skeleton application</h1>
                </header>
            
            <article>
                
<p>The skeleton application will encapsulate rudimentary features and a workflow that's repeated for most MERN applications. We will build the skeleton as a basic but fully functioning MERN web application with user <strong>create</strong>, <strong>read</strong>, <strong>update</strong>, <strong>delete</strong> (<strong>CRUD</strong>), and <strong>auth</strong>entication-<strong>auth</strong>orization (<strong>auth</strong>) capabilities; this will also demonstrate how to develop, organize, and run code for general web applications built using this stack. <span>The aim is to keep the skeleton as simple as possible so that it is easy to extend and can be used as a base application for developing different</span> <span>MERN</span> <span>applications.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Feature breakdown</h1>
                </header>
            
            <article>
                
<p>In the skeleton application, we will add the following use cases with user CRUD and auth functionality implementations:</p>
<ul>
<li style="font-weight: 400"><strong>Sign up</strong>: Users can register by creating a new account using an email address.</li>
<li style="font-weight: 400"><strong>User list</strong>: Any visitor can see a list of all registered users.</li>
<li style="font-weight: 400"><strong>Authentication</strong>: Registered users can sign-in and sign-out.</li>
<li style="font-weight: 400"><strong>Protected user profile</strong>: Only registered users can view individual user details after signing in.</li>
<li style="font-weight: 400"><strong>Authorized user edit and delete</strong>: Only a registered and authenticated user can edit or remove their own user account details.</li>
</ul>
<p>With these features, we will have a simple working web application that supports user accounts. We will start building this basic web application with the backend implementation, then integrate a React frontend to complete the full stack.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining the backend components</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will focus on building a working backend for the skeleton application with Node, Express, and MongoDB. The completed backend will be a standalone server-side application that can handle HTTP requests to create a user, list all users, and view, update, or delete a user in the database while taking user authentication and authorization into consideration.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">User model</h1>
                </header>
            
            <article>
                
<p class="mce-root CDPAlignLeft CDPAlign">The user model will define the user details to be stored in the MongoDB database, and also handle user-related business logic such as password encryption and user data validation. The user model for this skeletal version will be basic with support for the following attributes:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 12.2209%"><strong>Field name</strong></td>
<td class="CDPAlignCenter CDPAlign" style="width: 10%"><strong>Type</strong></td>
<td style="width: 80%">
<p class="mce-root" style="padding-left: 30px"><strong>Description</strong></p>
</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 12.2209%">
<p class="mce-root"><kbd>name</kbd></p>
</td>
<td class="CDPAlignCenter CDPAlign" style="width: 10%">String</td>
<td style="width: 80%;padding-left: 30px">Required field to store the user's name.</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 12.2209%">
<p class="mce-root"><kbd>email</kbd></p>
</td>
<td class="CDPAlignCenter CDPAlign" style="width: 10%"><span>String</span></td>
<td style="width: 80%;padding-left: 30px">Required unique field to store the user's email and identify each account (only one account allowed per unique email).</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 12.2209%">
<p class="mce-root"><kbd>password</kbd></p>
</td>
<td class="CDPAlignCenter CDPAlign" style="width: 10%"><span>String</span></td>
<td style="width: 80%;padding-left: 30px">A required field for authentication. The database will store the encrypted password and not the actual string for security purposes.</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 12.2209%">
<p class="mce-root"><kbd>created</kbd></p>
</td>
<td class="CDPAlignCenter CDPAlign" style="width: 10%"><span>Date</span></td>
<td style="width: 80%;padding-left: 30px">Automatically generated timestamp when a new user account is created.</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 12.2209%">
<p class="mce-root"><kbd>updated</kbd></p>
</td>
<td class="CDPAlignCenter CDPAlign" style="width: 10%">Date</td>
<td style="width: 80%;padding-left: 30px">Automatically generated timestamp when existing user details are updated.</td>
</tr>
</tbody>
</table>
<p> </p>
<p>When we build applications by extending this skeleton, we can add more fields as required. But starting w<span>ith these fields will be enough to identify</span> unique <span>user accounts, and also for implementing user CRUD operation-related features. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">API endpoints for user CRUD</h1>
                </header>
            
            <article>
                
<div>
<p>To enable and handle user CRUD operations on the user database, the backend will implement and expose API endpoints that the frontend can utilize in the views, as follows:</p>
<div>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td class="CDPAlignCenter CDPAlign">
<p style="padding-left: 30px"><strong>Operation</strong></p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p style="padding-left: 30px"><strong>API route</strong></p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p style="padding-left: 30px"><strong>HTTP method</strong></p>
</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign">
<p style="padding-left: 30px">Create a user</p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p style="padding-left: 30px"><kbd>/api/users</kbd></p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p style="padding-left: 30px"><kbd>POST</kbd></p>
</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign">
<p style="padding-left: 30px">List all users</p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p style="padding-left: 30px"><kbd>/api/users</kbd></p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p style="padding-left: 30px"><kbd>GET</kbd></p>
</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign">
<p style="padding-left: 30px">Fetch a user</p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p style="padding-left: 30px"><kbd>/api/users/:userId</kbd></p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p style="padding-left: 30px"><kbd>GET</kbd></p>
</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign">
<p style="padding-left: 30px">Update a user</p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p style="padding-left: 30px"><kbd>/api/users/:userId</kbd></p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p style="padding-left: 30px"><kbd>PUT</kbd></p>
</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign">
<p style="padding-left: 30px">Delete a user</p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p style="padding-left: 30px"><kbd>/api/users/:userId</kbd></p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p style="padding-left: 30px"><kbd>DELETE</kbd></p>
</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign">
<p style="padding-left: 30px">User sign-in</p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p style="padding-left: 30px"><kbd>/auth/signin</kbd></p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p style="padding-left: 30px"><kbd>POST</kbd></p>
</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign">
<p style="padding-left: 30px">User signout (optional)</p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p style="padding-left: 30px"><kbd>/auth/signout</kbd></p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p style="padding-left: 30px"><kbd>GET</kbd></p>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<p>Some of these user CRUD operations will have protected access, which will require the requesting client to be <span>authenticated, authorized, or both, as defined by the feature specifications.</span> The last two routes in the table are for authentication and will allow the user to sign-in and sign-out. For the applications developed in this book, we will use the JWT mechanism to implement these authentication features, as discussed in more detail in the next section.    </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Auth with JSON Web Tokens</h1>
                </header>
            
            <article>
                
<p>To restrict and protect access to user API endpoints according to the skeleton features, the backend will need to incorporate authentication and authorization mechanisms. There are a number of options when it comes to implementing user auth for web applications. The most common and time-tested option is the use of sessions to store user state on both the client and server-side. But a newer approach is the use of <strong>JSON Web Token</strong> (<strong>JWT</strong>) as a stateless authentication mechanism that does not require storing user state on the server side. </p>
<p>Both approaches have strengths for relevant real-world use cases. However, for the purpose of keeping the code simple in this book, and because it pairs well with the MERN stack and our example applications, we will use JWT for auth implementation. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How JWT works</h1>
                </header>
            
            <article>
                
<p><span>Before diving into the implementation of authentication with JWT in the MERN stack, we will look at how this mechanism generally works across a client-server application, as outlined in the following diagram: </span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-770 image-border" src="assets/37d37ce8-62c0-4627-9f8f-c25a5c63b36f.png" style="width:24.17em;height:22.75em;"/></div>
<p>Initially, when a user <span>signs i</span><span>n using their </span><span>credentials, the server-side generates a JWT signed with a secret key and a</span> unique <span>user detail. Then, this token is returned to the requesting client to be saved locally either in <kbd>localStorage</kbd>, <kbd>sessionStorage</kbd> or a cookie in the browser, essentially handing over the responsibility for maintaining user state to the client-side.</span></p>
<p>For HTTP requests that are made following a successful sign-in, especially <span>requests for API endpoints that are protected and have restricted access, t</span>he client-side has to attach this token to the request. <span>More specifically, t</span>he <kbd>JSON Web Token</kbd> must be included in the request <kbd>Authorization</kbd> header as a <kbd>Bearer</kbd>:</p>
<pre>Authorization: Bearer &lt;JSON Web Token&gt;</pre>
<p>When the server receives a request for a protected API endpoint, it checks the <kbd>Authorization</kbd> header of the request for a valid JWT, then verifies the signature to identify the sender and ensures the request data was not corrupted. If the token is valid, the requesting client is given access to the associated operation or resource; otherwise, an authorization error is returned.</p>
<p><span>In the skeleton application, when a user signs in with their email and password, the backend will generate a signed JWT with the user's ID and with a secret key that's available only on the server. This token will then be required for verification when a user tries to view any user profiles, update their account details, or delete their user account.</span></p>
<p>Implementing the user model to store and validate user data, then integrating it with APIs to perform CRUD operations based on auth with JWT, will produce a functioning standalone backend. In the rest of this chapter, we will look at how to achieve this in the MERN stack and setup.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up the skeleton backend</h1>
                </header>
            
            <article>
                
<p class="mce-root">To start developing the backend part of the MERN skeleton, we will set up the project folder, install and configure the necessary Node modules, and then prepare run scripts to aid development and run the code. Then, we will go through the code step by step to implement a working Express server, a user model with Mongoose, API endpoints with Express router, and JWT-based auth to meet the specifications we defined earlier for user-oriented features.</p>
<div class="packt_tip"><span>The code that will be discussed in this chapter, as well as the complete skeleton application, is available on GitHub</span><span> at</span><a href="https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter03%20and%2004/mern-skeleton" target="_blank"> https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter03%20and%2004/mern-skeleton</a> . <span>The code for just the backend is available at the same repository in the branch named <kbd>mern2-skeleton-backend</kbd>. You can clone this code and run the application as you go through the code explanations in the rest of this chapter. </span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Folder and file structure</h1>
                </header>
            
            <article>
                
<p>As we go through our setup and implementation in the rest of this chapter, we will end up with the following folder structure containing files that are relevant to the MERN skeleton backend. With these files, we will have a functioning, standalone server-side application: </p>
<pre>| mern_skeleton/<br/>   | -- config/<br/>      | --- config.js<br/>   | -- server/<br/>      | --- controllers/<br/>         | ---- auth.controller.js<br/>         | ---- user.controller.js<br/>      | --- helpers/<br/>         | ---- dbErrorHandler.js<br/>      | --- models/<br/>         | ---- user.model.js<br/>      | --- routes/<br/>         | ---- auth.routes.js<br/>         | ---- user.routes.js<br/>      | --- express.js<br/>      | --- server.js<br/>  | -- .babelrc<br/>  | -- nodemon.json<br/>  | -- package.json<br/>  | -- template.js<br/>  | -- webpack.config.server.js<br/>  | -- yarn.lock</pre>
<p><span>We will keep the configuration files in the root directory and the backend-related code in the <kbd>server</kbd> folder. Within the <kbd>server</kbd> folder, we will divide the backend code into modules containing models, controllers, routes, helpers, and common server-side code. This folder structure will be further expanded in the next chapter, where we'll complete the skeleton application by adding a</span> React <span>front</span><span>end</span><span>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Initializing the project</h1>
                </header>
            
            <article>
                
<p>If your development environment is already set up, you can initialize the MERN project to start developing the backend. First, we will initialize <kbd>package.json</kbd> in the project folder, configure and install any development dependencies, set configuration variables to be used in the code, and update <kbd>package.json</kbd> with run scripts to help develop and run the code. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding package.json</h1>
                </header>
            
            <article>
                
<p>We will need a <kbd>package.json</kbd> file to store meta information about the project, list module dependencies with version numbers, and to define run scripts. To initialize a <kbd>package.json</kbd> file in the project folder, go to the project folder from the command line and run <kbd>yarn init</kbd>, then follow the instructions to add the necessary details. <span>With <kbd>package.json</kbd> created, we can proceed with setup and development and update the file</span> <span>as more modules are required </span><span>throughout code implementation.</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Development dependencies</h1>
                </header>
            
            <article>
                
<p>In order to begin the development process and run the backend server code, we will configure and install Babel, Webpack, and Nodemon, as discussed in <a href="" target="_blank">Chapter 2</a><em>,</em> <em>Preparing the Development Environment</em>, and make some minor adjustments to the backend.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Babel</h1>
                </header>
            
            <article>
                
<p>Since we will be using ES6+ and the latest JS features in the backend code, we will install and configure Babel modules to convert ES6+ into older versions of JS so that it's compatible with the Node version being used.</p>
<p>First, we'll configure Babel in the <kbd>.babelrc</kbd> file with presets for the latest JS features<span> and specify the current version of Node as the target environment</span>.</p>
<p><kbd>mern-skeleton/.babelrc</kbd>:</p>
<pre>{<br/>  "presets": [<br/>    ["@babel/preset-env",<br/>      {<br/>        "targets": {<br/>          "node": "current"<br/>        }<br/>      }<br/>    ]<br/>  ]<br/>}</pre>
<p>Setting <kbd>targets.node</kbd> to <kbd>current</kbd> instructs Babel to compile against the current version of Node and allows us to use expressions such as <kbd>async/await</kbd> in our backend code.</p>
<p>Next, we need to install the Babel modules as <kbd>devDependencies</kbd> from the command line:</p>
<pre><strong>yarn add --dev @babel/core babel-loader @babel/preset-env</strong></pre>
<p>Once the module installations are done, you will notice that the <kbd>devDependencies</kbd> list has been updated in the <kbd>package.json</kbd> file.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Webpack</h1>
                </header>
            
            <article>
                
<p>We will need Webpack to compile and bundle the server-side code using Babel. For configuration, we can use the same <kbd>webpack.config.server.js</kbd> we discussed in <a href="" target="_blank">Chapter 2</a>, <em>Preparing the Development Environment</em>.</p>
<p>From the command line, run the following command to install <kbd>webpack</kbd>, <kbd>webpack-cli</kbd>, and the <kbd>webpack-node-externals</kbd> module:</p>
<pre><strong>yarn add --dev webpack webpack-cli webpack-node-externals</strong></pre>
<p>This will install the Webpack modules and update the <kbd>package.json</kbd> file.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Nodemon</h1>
                </header>
            
            <article>
                
<p>To automatically restart the Node server as we update our code during development, we will use Nodemon to monitor the server code for changes. We can use the same installation and configuration guidelines we discussed in <a href="" target="_blank">Chapter 2</a>, <em>Preparing the Development Environment</em>.</p>
<p>Before we add run scripts to start developing and running the backend code, we will define configuration variables for values that are used across the backend implementation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Config variables</h1>
                </header>
            
            <article>
                
<p>In the <kbd>config/config.js</kbd> file, we will define some server-side configuration-related variables that will be used in the code but should not be hardcoded as a best practice, as well as for security purposes.</p>
<p><kbd><span>mern-skeleton/config/config.js</span></kbd>:</p>
<pre>const config = {<br/>  env: process.env.NODE_ENV || 'development',<br/>  port: process.env.PORT || 3000,<br/>  jwtSecret: process.env.JWT_SECRET || "YOUR_secret_key",<br/>  mongoUri: process.env.MONGODB_URI ||<br/>    process.env.MONGO_HOST ||<br/>    'mongodb://' + (process.env.IP || 'localhost') + ':' +<br/>    (process.env.MONGO_PORT || '27017') +<br/>    '/mernproject'<br/>}<br/><br/>export default config</pre>
<p>The config variables that were defined are as follows:</p>
<ul>
<li style="font-weight: 400"><kbd>env</kbd>: To differentiate between development and production modes</li>
<li style="font-weight: 400"><kbd>port</kbd>: To define the listening port for the server</li>
<li style="font-weight: 400"><kbd>jwtSecret</kbd>: The secret key to be used to sign JWT</li>
<li style="font-weight: 400"><kbd>mongoUri</kbd>: The location of the MongoDB database instance for the project</li>
</ul>
<p>These variables will give us the flexibility to change values from a single file and use it across the backend code. Next, we will add the run scripts, which will allow us to run and debug the backend implementation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running scripts</h1>
                </header>
            
            <article>
                
<p>To run the server as we develop the code for only the backend, we can start with the <kbd>yarn development</kbd> script in the <kbd>package.json</kbd> file. For the complete skeleton application, we will use the same run scripts we defined in <a href="" target="_blank">Chapter 2</a>, <em>Preparing the Development Environment</em>.</p>
<p><kbd><span>mern-skeleton/package.json</span></kbd>:</p>
<pre>"scripts": {<br/>    "development": "nodemon"<br/> }</pre>
<p>With this script added, running <kbd><span>yarn development</span></kbd> in the command line from your project folder will basically start Nodemon according to the configuration in <kbd>nodemon.json</kbd>. The configuration instructs Nodemon to monitor server files for updates and, on update, to build the files again, then restart the server so that the changes are immediately available. We will begin by implementing a working server with this configuration in place. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Preparing the server</h1>
                </header>
            
            <article>
                
<p>In this section, we will integrate Express, Node, and MongoDB in order to run a completely configured server before we start implementing user-specific features.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring Express</h1>
                </header>
            
            <article>
                
<p>To use Express, we will install it and then add and configure it in the <kbd>server/express.js</kbd> file. </p>
<p class="mce-root"/>
<p>From the command line, r<span>un the following command </span>to install the <kbd>express</kbd> module and<span> to have the</span> <kbd>package.json</kbd> <span>file automatically updated</span>:</p>
<pre><strong>yarn add express</strong></pre>
<p>Once Express has been installed, we can import it into the <kbd>express.js</kbd> file, configure it as required, and make it available to the rest of the app.</p>
<p><kbd><span>mern-skeleton/server/express.js</span></kbd>:</p>
<pre>import express from 'express'<br/>const app = express()<br/>  /*... configure express ... */<br/>export default app</pre>
<p>To handle <span>HTTP requests </span>and serve responses properly, we will use the following modules to <span>configure Express</span>:</p>
<ul>
<li style="font-weight: 400"><span><kbd>body-parser</kbd>: </span>Request body-parsing middleware to handle the complexities of parsing streamable request objects so that we can simplify browser-server communication by exchanging JSON in the request body. To install the module, run <kbd>yarn add body-parser</kbd> from the command line. Then, configure the Express app with <kbd>bodyParser.json()</kbd><span> </span>and<span> </span><kbd>bodyParser.urlencoded({ extended: true })</kbd>.</li>
<li style="font-weight: 400"><kbd>cookie-parser</kbd>: Cookie parsing middleware to parse and set cookies in request objects. To install the<span> </span><kbd>cookie-parser</kbd><span> </span>module, run <kbd>yarn add cookie-parser</kbd> from the command line.</li>
<li style="font-weight: 400"><kbd>compression</kbd>: Compression middleware that will attempt to compress response bodies for all requests that traverse through the middleware. To install the <kbd>compression</kbd> module, run <kbd>yarn add compression</kbd> from the command line.</li>
<li style="font-weight: 400"><kbd>helmet</kbd>: Collection of middleware functions to help secure Express apps by setting various HTTP headers. To install the <kbd>helmet</kbd> module, run <kbd>yarn add helmet</kbd> from the command line.</li>
<li style="font-weight: 400"><kbd>cors</kbd>: Middleware to enable <strong>cross-origin resource sharing</strong> (<strong>CORS</strong>). To install the <kbd>cors</kbd> module, run <kbd>yarn add cors</kbd> from the command line.</li>
</ul>
<p>After the preceding modules have been installed, we can update <kbd>express.js</kbd> to import these modules and configure the Express app before exporting it for use in the rest of the server code.</p>
<p class="mce-root"/>
<p>The updated <kbd><span>mern-skeleton/server/express.js</span></kbd> code should be as follows:</p>
<pre>import express from 'express'<br/>import bodyParser from 'body-parser'<br/>import cookieParser from 'cookie-parser'<br/>import compress from 'compression'<br/>import cors from 'cors'<br/>import helmet from 'helmet'<br/><br/>const app = express()<br/><br/><strong>app.use(bodyParser.json())</strong><br/><strong>app.use(bodyParser.urlencoded({ extended: true }))</strong><br/><strong>app.use(cookieParser())</strong><br/><strong>app.use(compress())</strong><br/><strong>app.use(helmet())</strong><br/><strong>app.use(cors())</strong><br/><br/>export default app</pre>
<p>The Express app can now accept and process information from incoming HTTP requests, for which we first need to start a server using this app.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Starting the server</h1>
                </header>
            
            <article>
                
<p>With the Express app configured to accept HTTP requests, we can go ahead and use it to implement a server that can listen for incoming requests.</p>
<p>In the <kbd><span>mern-skeleton/server/server.js</span></kbd> file, add the following code to implement the server:</p>
<pre>import config from './../config/config'<br/>import app from './express'<br/><br/>app.listen(config.port, (err) =&gt; {<br/>  if (err) {<br/>    console.log(err)<br/>  }<br/>  console.info('Server started on port %s.', config.port)<br/>})</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>First, we import the config variables to set the port number that the server will listen on and then import the configured Express app to start the server. To get this code running and continue development, we can run <kbd>yarn development</kbd> <span>from the command line. If the code has no errors, the server should start running with Nodemon monitoring for code changes. Next, we will update this server code to integrate the database connection.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up Mongoose and connecting to MongoDB</h1>
                </header>
            
            <article>
                
<p>We will be using the <kbd>mongoose</kbd> module to implement the user model in this skeleton, as well as all future data models for our MERN applications. Here, we will start by configuring Mongoose and utilizing it to define a connection with the MongoDB database.</p>
<p>First, to install the <kbd>mongoose</kbd> module, run the following command:</p>
<pre><strong>yarn add mongoose</strong></pre>
<p>Then, update the <kbd>server.js</kbd> file to import the <kbd>mongoose</kbd> module, configure it so that it uses native ES6 promises, and finally use it to handle the connection to the MongoDB database for the project.</p>
<p><kbd><span>mern-skeleton/server/server.js</span></kbd>:</p>
<pre>import mongoose from 'mongoose'<br/><br/>mongoose.Promise = global.Promise<br/>mongoose.connect(config.mongoUri, { useNewUrlParser: true, <br/>                                    useCreateIndex: true,         <br/>                                    useUnifiedTopology: true } ) <br/><br/>mongoose.connection.on('error', () =&gt; {<br/>  throw new Error(`unable to connect to database: ${mongoUri}`)<br/>})</pre>
<p>If you have the code running in development and also have MongoDB running, saving this update should successfully restart the server, which is now integrated with Mongoose and MongoDB.</p>
<p class="mce-root"/>
<div class="packt_infobox">Mongoose is a MongoDB object modeling tool that provides a schema-based solution to model application data. It includes built-in type casting, validation, query building, and business logic hooks. Using Mongoose with this backend stack provides a higher layer over MongoDB with more functionality, including mapping object models to database documents. This makes it simpler and more productive to develop with a Node and MongoDB backend. To learn more about Mongoose, visit <a href="http://mongoosejs.com" target="_blank">mongoosejs.com</a>.<br/>
<br/>
<a href="http://mongoosejs.com"/></div>
<p>With an Express app configured, the database integrated with Mongoose, and a listening server ready, we can add code to load an HTML view from this backend.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Serving an HTML template at a root URL</h1>
                </header>
            
            <article>
                
<p>With a Node- Express- and MongoDB- enabled server now running, we can extend it so that it serves an HTML template in response to an incoming request at the root URL <kbd>/</kbd>.</p>
<p>In the <kbd>template.js</kbd> file, add a JS function that returns a simple HTML document that will render <kbd>Hello World</kbd> on the browser screen.</p>
<p><kbd><span>mern-skeleton/template.js</span></kbd>:</p>
<pre>export default () =&gt; {<br/>    return `&lt;!doctype html&gt;<br/>      &lt;html lang="en"&gt;<br/>          &lt;head&gt;<br/>             &lt;meta charset="utf-8"&gt;<br/>             &lt;title&gt;MERN Skeleton&lt;/title&gt;<br/>          &lt;/head&gt;<br/>          &lt;body&gt;<br/>            &lt;div id="root"&gt;Hello World&lt;/div&gt;<br/>          &lt;/body&gt;<br/>      &lt;/html&gt;`<br/>}</pre>
<p>To serve this template at the root URL, update the <kbd>express.js</kbd> file to import this template and send it in the response to a GET request for the <kbd>'/'</kbd> route.</p>
<p><kbd><span>mern-skeleton/server/express.js</span></kbd>:</p>
<pre>import Template from './../template'<br/>...<br/>app.get('/', (req, res) =&gt; {<br/> res.status(200).send(Template())<br/>})<br/>...</pre>
<p>With this update, opening the root URL in a browser should show <span class="packt_screen">Hello World</span> rendered on the page. If you are running the code on your local machine, the root URL will be <kbd>http://localhost:3000/</kbd>.</p>
<p>At this point, the backend Node- Express- and MongoDB-based server that we can build on to add user-specific features.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing the user model</h1>
                </header>
            
            <article>
                
<p>We will implement the user model in the <kbd>server/models/user.model.js</kbd> file and use Mongoose to define the schema with the necessary user data fields. We're doing this so that we can add built-in validation for the fields and incorporate business logic such as password encryption, authentication, and custom validation.</p>
<p>We will begin by importing the <kbd>mongoose</kbd> module and use it to generate a <kbd>UserSchema</kbd>, which will contain the schema definition and user-related business logic to make up the user model. This user model will be exported so that it can be used by the rest of the backend code.</p>
<p><kbd><span>mern-skeleton/server/models/user.model.js</span></kbd>:</p>
<pre>import mongoose from 'mongoose'<br/><br/>const UserSchema = new mongoose.Schema(<strong>{ … }</strong>)<br/><br/>export default mongoose.model('User', UserSchema) </pre>
<p>The <kbd>mongoose.Schema()</kbd> function takes a schema definition object as a parameter to generate a new Mongoose schema object that will specify the properties or structure of each document in a collection. We will discuss this schema definition for the User collection before we add any business logic code to complete the user model.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">User schema definition</h1>
                </header>
            
            <article>
                
<p>The user schema definition object that's needed to generate the new Mongoose schema will declare all user data fields and associated properties. The schema will record user-related information including name, email, created-at and last-updated-at timestamps, hashed passwords, and the associated unique password salt. We will elaborate on these properties next, showing you how each field is defined in the user schema code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Name</h1>
                </header>
            
            <article>
                
<p>The <kbd>name</kbd> field is a required field of the <kbd>String</kbd> type.</p>
<p><kbd><span>mern-skeleton/server/models/user.model.js</span></kbd>:</p>
<pre>name: {<br/>   type: String,<br/>   trim: true,<br/>   required: 'Name is required'<br/> },</pre>
<p>This field will store the user's name.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Email</h1>
                </header>
            
            <article>
                
<p>The <kbd>email</kbd> field is a required field of the <kbd>String</kbd> type.</p>
<p><kbd><span>mern-skeleton/server/models/user.model.js</span></kbd>:</p>
<pre>email: {<br/>  type: String,<br/>  trim: true,<br/>  unique: 'Email already exists',<br/>  match: [/.+\@.+\..+/, 'Please fill a valid email address'],<br/>  required: 'Email is required'<br/>},</pre>
<p><span>The value to be stored in this email field must have a valid email format and must also be </span>unique i<span>n the user collection.</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Created and updated timestamps</h1>
                </header>
            
            <article>
                
<p>The <kbd>created</kbd> and <kbd>updated</kbd> fields are <kbd>Date</kbd> values.</p>
<p><kbd><span>mern-skeleton/server/models/user.model.js</span></kbd>:</p>
<pre>created: {<br/>  type: Date,<br/>  default: Date.now<br/>},<br/>updated: Date,</pre>
<p><span> These <kbd>Date</kbd> values will be programmatically generated to record timestamps that indicate when a user is created and user data is updated.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Hashed password and salt</h1>
                </header>
            
            <article>
                
<p>The <kbd>hashed_password</kbd> and <kbd>salt</kbd> fields represent the encrypted user password that we will use for authentication.</p>
<p><kbd><span>mern-skeleton/server/models/user.model.js</span></kbd>:</p>
<pre>hashed_password: {<br/>    type: String,<br/>    required: "Password is required"<br/>},<br/>salt: String</pre>
<p><span>The actual</span> password <span>string is not stored directly in the database for security purposes and is handled separately, as discussed in the next section.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Password for auth</h1>
                </header>
            
            <article>
                
<p>The <kbd>password</kbd> field is very crucial for providing secure user authentication in any application, and each user password needs to be encrypted, validated, and authenticated securely as a part of the user model.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling the password string as a virtual field</h1>
                </header>
            
            <article>
                
<p>The <kbd>password</kbd> string that's provided by the user is not stored directly in the user document. Instead, it is handled as a <kbd>virtual</kbd> field.</p>
<p><kbd><span>mern-skeleton/server/models/user.model.js</span></kbd>:</p>
<pre>UserSchema<br/>  .virtual('password')<br/>  .set(function(password) {<br/>    this._password = password<br/>    this.salt = this.makeSalt()<br/>    this.hashed_password = this.<strong>encryptPassword</strong>(password)<br/>  })<br/>  .get(function() {<br/>    return this._password<br/>  })</pre>
<p>When the <kbd>password</kbd> value is received on user creation or update, it is encrypted into a new hashed value and set to the <kbd>hashed_password</kbd> field, along with the unique <kbd>salt</kbd> value in the <kbd>salt</kbd> field.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Encryption and authentication</h1>
                </header>
            
            <article>
                
<p>The encryption logic and salt generation logic, which are used to generate the <kbd>hashed_password</kbd> and <kbd>salt</kbd> values representing the <kbd>password</kbd> value, are defined as <kbd>UserSchema</kbd> methods. </p>
<p><kbd><span>mern-skeleton/server/models/user.model.js</span></kbd>:</p>
<pre>UserSchema.methods = {<br/>  <strong>authenticate</strong>: function(plainText) {<br/>    return this.encryptPassword(plainText) === this.hashed_password<br/>  },<br/>  <strong>encryptPassword</strong>: function(password) {<br/>    if (!password) return ''<br/>    try {<br/>      return crypto<br/>        .createHmac('sha1', this.salt)<br/>        .update(password)<br/>        .digest('hex')<br/>    } catch (err) {<br/>      return ''<br/>    }<br/>  },<br/>  <strong>makeSalt</strong>: function() {<br/>    return Math.round((new Date().valueOf() * Math.random())) + ''<br/>  }<br/>}</pre>
<p>The <kbd>UserSchema</kbd> methods can be used to provide the following functionality:</p>
<ul>
<li> <kbd>authenticate</kbd>: This method is called to verify sign-in attempts by matching the user-provided password text with the <kbd>hashed_password</kbd> stored in the database for a specific user. </li>
<li><kbd>encryptPassword</kbd>: This method is used to generate an encrypted hash from the plain-text password and a unique <kbd>salt</kbd> value using the <kbd>crypto</kbd> module from Node. </li>
<li><kbd>makeSalt</kbd>: This method generates a unique and random salt value using the current timestamp at execution and <span><kbd>Math.random()</kbd>.</span></li>
</ul>
<div class="packt_infobox">The <kbd>crypto</kbd> module <span><span>provides a range of cryptographi</span></span><span><span>c functionality, including some standard cryptographic hashing algorithms. In our code, we use the SHA1 hashing algorithm and <kbd>createHmac</kbd> from <kbd>crypto</kbd> to generate the cryptographic HMAC hash from the password text and <kbd>salt</kbd> pair. <br/>
<br/></span></span> <span><span>Hashing algorithms generate the same hash for the same input value. But to ensure two users don't end up with the same hashed password if they happen to use the same password text, we pair each password with a</span></span> unique <kbd>salt</kbd><span><span> value before generating the hashed password for each user. </span></span><span><span>This will also make it difficult to guess the hashing algorithm being used because the same user input is seemingly generating different hashes.</span></span></div>
<p>These <kbd>UserSchema</kbd> methods are used to encrypt the user-provided password string into a <kbd>hashed_password</kbd> with a randomly generated <kbd>salt</kbd> value. The <kbd>hashed_password</kbd> and the <kbd>salt</kbd> are stored in the user document when the user details are saved to the database on a create or update. Both the <kbd>hashed_password</kbd> and <kbd>salt</kbd> values are required in order to match and authenticate a password string provided during user sign-in using the <kbd>authenticate</kbd> method. We should also ensure the user selects a strong password string to begin with, which can done by adding custom validation to the passport field. </p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Password field validation</h1>
                </header>
            
            <article>
                
<p>To add validation constraints to the actual password string that's selected by the end user, we need to add custom validation logic and associate it with the <kbd>hashed_password</kbd> field in the schema.</p>
<p><kbd><span>mern-skeleton/server/models/user.model.js</span></kbd>:</p>
<pre>UserSchema.path('hashed_password').validate(function(v) {<br/>  if (this._password &amp;&amp; this._password.length &lt; 6) {<br/>    this.invalidate('password', 'Password must be at least 6 characters.')<br/>  }<br/>  if (this.isNew &amp;&amp; !this._password) {<br/>    this.invalidate('password', 'Password is required')<br/>  }<br/>}, null)</pre>
<p>We will keep the password validation criteria simple in our application and ensure that a password value is provided and it has a length of at least six characters when a new user is created or an existing password is updated. We achieve this by adding custom validation to check the password value before Mongoose attempts to store the <kbd>hashed_password</kbd> value. If validation fails, the logic will return the relevant error message.</p>
<p>The defined <kbd>UserSchema</kbd>, along with all the password-related business logic, completes the user model implementation. <span>Now, we can import and use this u</span>ser <span>model in</span> other parts of the backend code. But before we begin using this model to extend backend functionality, we will add a helper module so that we can parse readable Mongoose error messages, which are thrown against schema validations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mongoose error handling</h1>
                </header>
            
            <article>
                
<p>The validation constraints that are added to the user schema fields will throw error messages if they're violated when user data is saved to the database. To handle these validation errors and other errors that the database may throw when we make queries to it, we will define a helper method that will return a relevant error message that can be propagated in the request-response cycle as appropriate.  </p>
<p class="mce-root"/>
<p>We will add the <kbd>getErrorMessage</kbd> <span>helper method </span>to the <kbd>server/helpers/dbErrorHandler.js</kbd> file. This method will parse and return the error message associated with the specific validation error or other errors that can occur while querying MongoDB using Mongoose.</p>
<p><kbd><span>mern-skeleton/server/helpers/dbErrorHandler.js</span></kbd>:</p>
<pre>const getErrorMessage = (<strong>err</strong>) =&gt; {<br/>  let message = ''<br/>  if (<strong>err.code</strong>) {<br/>      switch (err.code) {<br/>          case 11000:<br/>          case 11001:<br/>              message = <strong>getUniqueErrorMessage(err)</strong><br/>              break<br/>          default:<br/>              message = 'Something went wrong'<br/>      }<br/>  } else {<br/>      for (let errName in err.errors) {<br/>          if (err.errors[errName].message)<br/>          <strong>message = err.errors[errName].message</strong><br/>      }<br/>  }<br/>  <strong>return message</strong><br/>}<br/><br/>export default {getErrorMessage}</pre>
<p>Errors that are not thrown because of a Mongoose validator violation will contain an associated error <kbd>code</kbd>. In some cases, these errors need to be handled differently. For example, errors caused due to a violation of the <kbd>unique</kbd> constraint will return an error object that is different from Mongoose validation errors. The <kbd>unique</kbd> option is not a validator but a convenient helper for building MongoDB <kbd>unique</kbd> indexes, so we will add another <kbd>getUniqueErrorMessage</kbd> method to parse the <kbd>unique</kbd> constraint-related error object and construct an appropriate error message.</p>
<p><kbd><span>mern-skeleton/server/helpers/dbErrorHandler.js</span></kbd>:</p>
<pre>const getUniqueErrorMessage = (err) =&gt; {<br/>  let output<br/>  try {<br/>      let fieldName =   <br/>      err.message.substring(err.message.lastIndexOf('.$') + 2,                                             <br/>      err.message.lastIndexOf('_1'))<br/>      output = fieldName.charAt(0).toUpperCase() + fieldName.slice(1) +   <br/>      ' already exists'<br/>  } catch (ex) {<br/>      output = 'Unique field already exists'<br/>  }<br/>  return output<br/>}</pre>
<p>By using the <kbd>getErrorMessage</kbd> function that's exported from this helper file, we can add meaningful error messages when handling errors that are thrown by Mongoose operations.</p>
<p>With the user model completed, we can perform Mongoose operations that are relevant to achieving user CRUD functionality with the User APIs we'll develop in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding user CRUD APIs </h1>
                </header>
            
            <article>
                
<p>The user API endpoints exposed by the Express app will allow the frontend to perform CRUD operations on documents that are generated according to the user model. To implement these working endpoints, we will write Express routes and the corresponding controller callback functions that should be executed when HTTP requests come in for these declared routes. In this section, we will look at how these endpoints work without any auth restrictions.</p>
<p>Our user API routes will be declared using the Express router in <kbd>server/routes/user.routes.js</kbd>, and then mounted on the Express app we configured in <kbd>server/express.js</kbd>.</p>
<p><kbd><span>mern-skeleton/server/express.js</span></kbd>:</p>
<pre>import userRoutes from './routes/user.routes'<br/>...<br/>app.use('/', userRoutes)<br/>...</pre>
<p>All routes and API endpoints, such as the user-specific routes we'll declare next, need to be mounted on the Express app so that they can be accessed from the client-side.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">User routes</h1>
                </header>
            
            <article>
                
<p>The user routes that are defined in the <kbd>user.routes.js</kbd> file will use <kbd>express.Router()</kbd> to define route paths with the relevant HTTP methods and assign the corresponding controller function that should be called when these requests are received by the server.</p>
<p>We will keep the user routes simplistic by using the following:</p>
<ul>
<li style="font-weight: 400"><kbd>/api/users</kbd> for the following:
<ul>
<li style="font-weight: 400">Listing users with GET</li>
<li style="font-weight: 400">Creating a new user with POST</li>
</ul>
</li>
<li style="font-weight: 400"><kbd>/api/users/:userId</kbd> for the following:
<ul>
<li style="font-weight: 400">Fetching a user with GET</li>
<li style="font-weight: 400">Updating a user with PUT</li>
<li style="font-weight: 400">Deleting a user with DELETE</li>
</ul>
</li>
</ul>
<p>The resulting <kbd>user.routes.js</kbd> code will look as follows (without the auth considerations that need to be added for protected routes).</p>
<p><kbd><span>mern-skeleton/server/routes/user.routes.js</span></kbd>:</p>
<pre>import express from 'express'<br/>import userCtrl from '../controllers/user.controller'<br/><br/>const router = express.Router()<br/><br/>router.route('/api/users')<br/>  .get(userCtrl.list)<br/>  .post(userCtrl.create)<br/><br/>router.route('/api/users/:userId')<br/>  .get(userCtrl.read)<br/>  .put(userCtrl.update)<br/>  .delete(userCtrl.remove)<br/><br/>router.param('userId', userCtrl.userByID)<br/><br/>export default router</pre>
<p>Besides declaring API endpoints that correspond to user CRUD operations, we'll also configure the Express router so that it handles the <kbd>userId</kbd> parameter in a requested route by executing the <kbd>userByID</kbd> controller function.</p>
<p>When the server receives requests at each of these defined routes, the corresponding controller functions are invoked. We will define the functionality for each of these controller methods and export it from the <kbd>user.controller.js</kbd> file in the next subsection.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">User controller</h1>
                </header>
            
            <article>
                
<p>The <kbd>server/controllers/user.controller.js</kbd> file will contain definitions of the controller methods that were used in the preceding user route declarations as callbacks to be executed when a route request is received by the server.</p>
<p>The <kbd>user.controller.js</kbd> file will have the following structure:</p>
<pre>import User from '../models/user.model'<br/>import extend from 'lodash/extend'<br/>import errorHandler from './error.controller'<br/><br/>const <strong>create</strong> = (req, res, next) =&gt; { … }<br/>const <strong>list</strong> = (req, res) =&gt; { … }<br/>const <strong>userByID</strong> = (req, res, next, id) =&gt; { … }<br/>const <strong>read</strong> = (req, res) =&gt; { … }<br/>const <strong>update</strong> = (req, res, next) =&gt; { … }<br/>const <strong>remove</strong> = (req, res, next) =&gt; { … }<br/><br/>export default { <strong>create</strong>, <strong>userByID</strong>, <strong>read</strong>, <strong>list</strong>, <strong>remove</strong>, <strong>update</strong> }</pre>
<p>This controller will make use of the <kbd>errorHandler</kbd> helper to respond to route requests with meaningful messages when a Mongoose error occurs. It will also use a module called <kbd>lodash</kbd> when updating an existing user with changed values.</p>
<div class="packt_tip"><span><kbd>lodash</kbd> is a JavaScript library that provides utility functions for common programming tasks, including the manipulation of arrays and objects. </span>To install <kbd>lodash</kbd>, run <kbd>yarn add lodash</kbd> from the command line. </div>
<p>Each of the controller functions we defined previously is related to a route request, and will be elaborated on in relation to each API use case.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a new user</h1>
                </header>
            
            <article>
                
<p>The API endpoint to create a new user is declared in the following route.</p>
<p><kbd><span>mern-skeleton/server/routes/user.routes.js</span></kbd>:</p>
<pre>router.route('/api/users').post(userCtrl.<strong>create</strong>)</pre>
<p>When the Express app gets a POST request at <kbd>'/api/users'</kbd>, it calls the <kbd>create</kbd> function we defined in the controller.</p>
<p><kbd><span>mern-skeleton/server/controllers/user.controller.js</span></kbd>:</p>
<pre>const <strong>create</strong> = async (req, res) =&gt; {<br/>  const user = new User(req.body)<br/>  try {<br/>    await user.save()<br/>    return res.status(200).json({<br/>      message: "Successfully signed up!"<br/>    })<br/>  } catch (err) {<br/>    return res.status(400).json({<br/>      error: errorHandler.getErrorMessage(err)<br/>    })<br/>  }<br/>}</pre>
<p>This function creates a new user with the user JSON object that's received in the POST request from the frontend within <kbd>req.body</kbd>. The call to <kbd>user.save</kbd> attempts to save the new user in the database after Mongoose has performed a validation check on the data. Consequently, an error or success response is returned to the requesting client.</p>
<p><span>The </span><kbd>create</kbd><span> function is defined as an asynchronous function with the </span><strong>async</strong><span> keyword, allowing us to use </span><strong>await</strong><span> with </span><kbd>user.save()</kbd><span>, which returns a Promise. Using the <strong>await</strong> keyword inside an <strong>async</strong> function causes this function to wait until the returned Promise resolves, before the next lines of code are executed. If the Promise rejects, an error is thrown and caught in the <kbd>catch</kbd> block. </span></p>
<div class="packt_infobox"><kbd>Async/await</kbd> is an addition to ES8 that allows us to write asynchronous JavaScript code in a seemingly sequential or synchronous manner. <span>For controller functions that handle asynchronous behavior such as accessing the database, we will use the</span> <kbd>async/await</kbd> <span>syntax to implement them. </span> <span> </span></div>
<p>Similarly, <span>in the next section</span>, we will use <kbd>async/await</kbd> <span>while </span>implementing the controller function to list all users after querying the database.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Listing all users</h1>
                </header>
            
            <article>
                
<p>The API endpoint to fetch all the users is declared in the following route.</p>
<p><kbd><span>mern-skeleton/server/routes/user.routes.js</span></kbd>:</p>
<pre>router.route('/api/users').get(userCtrl.<strong>list</strong>)</pre>
<p>When the Express app gets a GET request at <kbd>'/api/users'</kbd>, it executes the <kbd>list</kbd> controller function.</p>
<p><kbd><span>mern-skeleton/server/controllers/user.controller.js</span></kbd>:</p>
<pre>const <strong>list</strong> = async (req, res) =&gt; {<br/>  try {<br/>    let users = await User.find().select('name email updated created')<br/>    res.json(users)<br/>  } catch (err) {<br/>    return res.status(400).json({<br/>      error: errorHandler.getErrorMessage(err)<br/>    })<br/>  }<br/>}</pre>
<p>The <kbd>list</kbd> controller function finds all the users from the database, populates only the <kbd>name</kbd>, <kbd>email</kbd>, <kbd>created</kbd>, and <kbd>updated</kbd> fields in the resulting user list, and then returns this list of users as JSON objects in an array to the requesting client.</p>
<p>The remaining CRUD operations to read, update, and delete a single user require that we retrieve a specific user by ID first. In the next section, we will implement the controller functions that enable fetching a single user from the database to either return the user, update the user, or delete the user in response to the corresponding requests.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Loading a user by ID to read, update, or delete</h1>
                </header>
            
            <article>
                
<p>All three API endpoints for read, update, and delete require a user to be loaded from the database based on the user ID of the user being accessed. We will program the Express router to do this action first before responding to a specific request to read, update, or delete.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Loading </h1>
                </header>
            
            <article>
                
<p>Whenever the Express app receives a request to a route that matches a path containing the <kbd>:userId</kbd> parameter in it, the app will execute the <kbd>userByID</kbd> controller function, which fetches and loads the user into the Express request object, before propagating it to the <kbd>next</kbd> function that's specific to the request that came in.</p>
<p><kbd><span>mern-skeleton/server/routes/user.routes.js</span></kbd>:</p>
<pre>router.param('userId', userCtrl.<strong>userByID</strong>)</pre>
<p>The <kbd>userByID</kbd> controller function uses the value in the <kbd>:userId</kbd> parameter to query the database by <kbd>_id</kbd> and load the matching user's details.</p>
<p><kbd><span>mern-skeleton/server/controllers/user.controller.js</span></kbd>:</p>
<pre>const <strong>userByID</strong> = async (req, res, next, id) =&gt; {<br/>  try {<br/>    let user = await User.findById(id)<br/>    if (!user)<br/>      return res.status('400').json({<br/>        error: "User not found"<br/>      })<br/>    req.profile = user<br/>    next()<br/>  } catch (err) {<br/>    return res.status('400').json({<br/>      error: "Could not retrieve user"<br/>    })<br/>  }<br/>}</pre>
<p>If a matching user is found in the database, the user object is appended to the request object in the <kbd>profile</kbd> key. Then, the <kbd>next()</kbd> middleware is used to propagate control to the next relevant controller function. For example, if the original request was to read a user profile, the <kbd>next()</kbd> call in <kbd>userByID</kbd> would go to the <kbd>read</kbd> controller function, which is discussed next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reading</h1>
                </header>
            
            <article>
                
<p>The API endpoint to read a single user's data is declared in the following route.</p>
<p><kbd><span>mern-skeleton/server/routes/user.routes.js</span></kbd>:</p>
<pre>router.route('/api/users/:userId').get(userCtrl.<strong>read</strong>)</pre>
<p>When the Express app gets a GET request at <kbd>'/api/users/:userId'</kbd>, it executes the <kbd>userByID</kbd> controller function to load the user by the <kbd>userId</kbd> value, followed by the <kbd>read</kbd> controller function.</p>
<p><kbd><span>mern-skeleton/server/controllers/user.controller.js</span></kbd>:</p>
<pre>const <strong>read</strong> = (req, res) =&gt; {<br/>  req.profile.hashed_password = undefined<br/>  req.profile.salt = undefined<br/>  return res.json(req.profile)<br/>}</pre>
<p>The <kbd>read</kbd> function retrieves the user details from <kbd>req.profile</kbd> and removes sensitive information, such as the <kbd>hashed_password</kbd> and <kbd>salt</kbd> values, before sending the user object in the response to the requesting client. This rule is also followed in <span>implementing</span> the <span>controller function to </span>update a user, as shown next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating</h1>
                </header>
            
            <article>
                
<p>The API endpoint to update a single user is declared in the following route.</p>
<p><kbd><span>mern-skeleton/server/routes/user.routes.js</span></kbd>:</p>
<pre>router.route('/api/users/:userId').put(userCtrl.<strong>update</strong>)</pre>
<p>When the Express app gets a PUT request at <kbd>'/api/users/:userId'</kbd>, similar to <kbd>read</kbd>, it loads the user with the <kbd>:userId</kbd> parameter value before executing the <kbd>update</kbd> controller function.</p>
<p><kbd><span>mern-skeleton/server/controllers/user.controller.js</span></kbd>:</p>
<pre>const <strong>update</strong> = async (req, res) =&gt; {<br/>  try {<br/>    let user = req.profile<br/>    user = extend(user, req.body)<br/>    user.updated = Date.now()<br/>    await user.save()<br/>    user.hashed_password = undefined<br/>    user.salt = undefined<br/>    res.json(user)<br/>  } catch (err) {<br/>    return res.status(400).json({<br/>      error: errorHandler.getErrorMessage(err)<br/>    })<br/>  }<br/>}</pre>
<p>The <kbd>update</kbd> function retrieves the user details from <kbd>req.profile</kbd> and then uses the <kbd>lodash</kbd> module to extend and merge the changes that came in the request body to update the user data. Before saving this updated user to the database, the <kbd>updated</kbd> field is populated with the current date to reflect the last updated timestamp. Upon successfully saving this update, the updated user object is cleaned by removing sensitive data, such as <kbd>hashed_password</kbd> and <kbd>salt</kbd>, before sending the user object in the response to the requesting client. Implementation of the final user controller function to delete a user is similar to the <kbd>update</kbd> function, as detailed in the next section. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deleting</h1>
                </header>
            
            <article>
                
<p>The API endpoint to delete a user is declared in the following route.</p>
<p><kbd><span>mern-skeleton/server/routes/user.routes.js</span></kbd>:</p>
<pre>router.route('/api/users/:userId').delete(userCtrl.<strong>remove</strong>)</pre>
<p>When the Express app gets a DELETE request at <kbd>'/api/users/:userId'</kbd>, similar to read and update, it loads the user by ID and then the <kbd>remove</kbd> controller function is executed.</p>
<p><kbd><span>mern-skeleton/server/controllers/user.controller.js</span></kbd>:</p>
<pre>const <strong>remove</strong> = async (req, res) =&gt; {<br/>  try {<br/>    let user = req.profile<br/>    let deletedUser = await user.remove()<br/>    deletedUser.hashed_password = undefined<br/>    deletedUser.salt = undefined<br/>    res.json(deletedUser)<br/>  } catch (err) {<br/>    return res.status(400).json({<br/>      error: errorHandler.getErrorMessage(err)<br/>    })<br/>  }<br/>}</pre>
<p>The <kbd>remove</kbd> function retrieves the user from <kbd>req.profile</kbd> and uses the <kbd>remove()</kbd> query to delete the user from the database. On successful deletion, the requesting client is returned the deleted user object in the response.</p>
<p class="mce-root"/>
<p>With the implementation of the API endpoints so far, any client can perform CRUD operations on the user model. However, we want to restrict access to some of these operations with authentication and authorization. We'll look at this in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Integrating user auth and protected routes</h1>
                </header>
            
            <article>
                
<p>To restrict access to user operations such as user profile view, user update, and user delete, we will first implement sign-in authentication with JWT, then use it to protect and authorize the read, update, and delete routes.</p>
<p>The auth-related API endpoints for sign-in and sign-out will be declared in <kbd>server/routes/auth.routes.js</kbd> and then mounted on the Express app in <kbd>server/express.js</kbd>.</p>
<p><kbd><span>mern-skeleton/server/express.js</span></kbd>:</p>
<pre>import authRoutes from './routes/auth.routes'<br/>  ...<br/>  app.use('/', authRoutes)<br/>  ...</pre>
<p><span>This will make the routes we define in <kbd>auth.routes.js</kbd> accessible from the client-side.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Auth routes</h1>
                </header>
            
            <article>
                
<p>The two auth APIs are defined in the <kbd>auth.routes.js</kbd> file using <kbd>express.Router()</kbd> to declare the route paths with the relevant HTTP methods. They're also assigned the corresponding controller functions, which should be called when requests are received for these routes.</p>
<p>The auth routes are as follows: </p>
<ul>
<li style="font-weight: 400"><kbd>'/auth/signin'</kbd>: POST request to authenticate the user with their email and password</li>
<li style="font-weight: 400"><kbd>'/auth/signout'</kbd>: GET request to clear the cookie containing a JWT that was set on the response object after sign-in</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The resulting <kbd><span>mern-skeleton/server/routes/auth.routes.js</span></kbd> file will be as follows: </p>
<pre>import express from 'express'<br/>import authCtrl from '../controllers/auth.controller'<br/><br/>const router = express.Router()<br/><br/>router.route('/auth/signin')<br/>  .post(authCtrl.signin)<br/>router.route('/auth/signout')<br/>  .get(authCtrl.signout)<br/><br/>export default router</pre>
<p>A POST request to the <kbd>signin</kbd> route and a GET request to the <kbd>signout</kbd> route will invoke the corresponding controller functions defined in the <kbd>auth.controller.js</kbd> file, as discussed in the next section. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Auth controller</h1>
                </header>
            
            <article>
                
<p>The auth controller functions in <kbd>server/controllers/auth.controller.js</kbd> will not only handle requests to the <kbd>signin</kbd> and <kbd>signout</kbd> routes, but also provide JWT and <kbd>express-jwt</kbd> functionality to enable authentication and authorization for protected user API endpoints.</p>
<p>The <kbd>mern-skeleton/server/controllers/auth.controller.js</kbd> file will have the following structure:</p>
<pre>import User from '../models/user.model'<br/>import jwt from 'jsonwebtoken'<br/>import expressJwt from 'express-jwt'<br/>import config from './../../config/config'<br/><br/>const <strong>signin</strong> = (req, res) =&gt; { … }<br/>const <strong>signout</strong> = (req, res) =&gt; { … }<br/>const <strong>requireSignin</strong> = … <br/>const <strong>hasAuthorization</strong> = (req, res) =&gt; { … }<br/><br/>export default { signin, signout, requireSignin, hasAuthorization }</pre>
<p>The four controller functions are elaborated on in the following sections to show how the backend implements user auth using JSON Web Tokens. We'll start with the <kbd>signin</kbd> controller function in the next section.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sign-in</h1>
                </header>
            
            <article>
                
<p>The API endpoint to sign-in a user is declared in the following route.</p>
<p><kbd><span>mern-skeleton/server/routes/auth.routes.js</span></kbd>:</p>
<pre>router.route('/auth/signin').post(authCtrl.<strong>signin</strong>)</pre>
<p>When the Express app gets a POST request at <kbd>'/auth/signin'</kbd>, it executes the <kbd>signin</kbd> controller function.</p>
<p><kbd><span>mern-skeleton/server/controllers/auth.controller.js</span></kbd>:</p>
<pre>const <strong>signin</strong> = async (req, res) =&gt; {<br/>  try {<br/>    let user = await User.findOne({ "email": req.body.email })<br/>    if (!user)<br/>      return res.status('401').json({ error: "User not found" })<br/><br/>    if (!<strong>user.authenticate</strong>(req.body.password)) {<br/>      return res.status('401').send({ error: "Email and<br/>           password don't match." })<br/>    }<br/><br/>    <strong>const token = jwt.sign({ _id: user._id }, config.jwtSecret)</strong><br/><br/>    res.cookie('t', token, { expire: new Date() + 9999 })<br/><br/>    return res.json({<br/>      token,<br/>      user: {<br/>        _id: user._id,<br/>        name: user.name,<br/>        email: user.email<br/>      }<br/>    })<br/>  } catch (err) {<br/>    return res.status('401').json({ error: "Could not sign in" })<br/>  }<br/>}</pre>
<p>The <kbd>POST</kbd> request object receives the email and password in <kbd>req.body</kbd>. This email is used to retrieve a matching user from the database. Then, the password authentication method defined in <kbd>UserSchema</kbd> is used to verify the password that's received in <kbd>req.body</kbd> from the client.</p>
<p class="mce-root"/>
<p>If the password is successfully verified, the JWT module is used to generate a signed JWT using a secret key and the user's <kbd>_id</kbd> value.</p>
<div class="packt_tip">Install the <kbd>jsonwebtoken</kbd> module to make it available to this controller in the import by running <kbd> yarn add jsonwebtoken</kbd> from the command line.</div>
<p>Then, the signed JWT is returned to the authenticated client, along with the user's details. Optionally, we can also set the token to a cookie in the response object so that it is available to the client-side if cookies are the chosen form of JWT storage. On the client-side, this token must be attached as an <kbd>Authorization</kbd> header when requesting protected routes from the server. To sign-out a user, the client-side can simply delete this token depending on how it is being stored. In the next section, we will learn how to use a <kbd>signout</kbd> API endpoint to clear the cookie containing the token. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Signout</h1>
                </header>
            
            <article>
                
<p>The API endpoint to sign-out a user is declared in the following route.</p>
<p><kbd><span>mern-skeleton/server/routes/auth.routes.js</span></kbd>:</p>
<pre>router.route('/auth/signout').get(authCtrl.signout)</pre>
<p>When the Express app gets a GET request at <kbd>'/auth/signout'</kbd>, it executes the <kbd>signout</kbd> controller function.</p>
<p><kbd><span>mern-skeleton/server/controllers/auth.controller.js</span></kbd>:</p>
<pre>const signout = (req, res) =&gt; {<br/>  res.clearCookie("t")<br/>  return res.status('200').json({<br/>    message: "signed out"<br/>  })<br/>}</pre>
<p>The <kbd>signout</kbd> function clears the response cookie containing the signed JWT. This is an optional endpoint and not really necessary for auth purposes if cookies are not used at all in the frontend.</p>
<p class="mce-root"/>
<p>With JWT, user state storage is the client's responsibility, and there are multiple options for client-side storage besides cookies. On signout, the client needs to delete the token on the client-side to establish that the user is no longer authenticated. On the server-side, we can use and verify the token that's generated at sign-in to protect routes that should not be accessed without valid authentication. In the next section, we will learn how to implement these protected routes using JWT.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Protecting routes with express-jwt</h1>
                </header>
            
            <article>
                
<p>To protect access to the read, update, and delete routes, the server will need to check that the requesting client is actually an authenticated and authorized user.</p>
<p>To check whether the requesting user is signed in and has a valid JWT when a protected route is accessed, we will use the <kbd>express-jwt</kbd> module.</p>
<div class="packt_tip">The <kbd>express-jwt</kbd> module is a piece of middleware that validates JSON Web Tokens. Run <kbd>yarn add express-jwt</kbd> from the command line to install <kbd>express-jwt</kbd>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Protecting user routes</h1>
                </header>
            
            <article>
                
<p>We will define two auth controller methods<span> called </span><kbd>requireSignin</kbd><span> </span>and<span> </span><kbd>hasAuthorization</kbd>, both of which will be added to the user route declarations that need to be protected with authentication and authorization.</p>
<p>The read, update, and delete routes in<span> </span><kbd><span>user.routes.js</span></kbd> need to be updated as follows.</p>
<p><kbd><span>mern-skeleton/server/routes/user.routes.js</span></kbd>:</p>
<pre>import <strong>authCtrl</strong> from '<strong>../controllers/auth.controller</strong>'<br/>...<br/>router.route('/api/users/:userId')<br/>    .get(<strong>authCtrl.requireSignin</strong>, userCtrl.read)<br/>    .put(<strong>authCtrl.requireSignin</strong>, <strong>authCtrl.hasAuthorization</strong>, <br/>     userCtrl.update)<br/>    .delete(<strong>authCtrl.requireSignin</strong>, <strong>authCtrl.hasAuthorization</strong>, <br/>     userCtrl.remove)<br/>...</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>The route to read a user's information only needs authentication verification, whereas the update and delete routes should check for both authentication and authorization before these CRUD operations are executed. We will look into the implementation of the <kbd>requireSignin</kbd> method, which checks authentication, and the <kbd>hasAuthorization</kbd> method, which checks authorization, in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Requiring sign-in</h1>
                </header>
            
            <article>
                
<p>The <kbd>requireSignin</kbd> method in <kbd>auth.controller.js</kbd> uses <kbd>express-jwt</kbd> to verify that the incoming request has a valid JWT in the <kbd>Authorization</kbd> header. If the token is valid, it appends the verified user's ID in an <kbd>'auth'</kbd> key to the request object; otherwise, it throws an authentication error.</p>
<p><kbd><span>mern-skeleton/server/controllers/auth.controller.js</span></kbd>:</p>
<pre>const requireSignin = expressJwt({<br/>  secret: config.jwtSecret,<br/>  userProperty: 'auth'<br/>})</pre>
<p>We can add <kbd>requireSignin</kbd> to any route that should be protected against unauthenticated access.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Authorizing signed in users</h1>
                </header>
            
            <article>
                
<p>For some of the protected routes, such as update and delete, on top of checking for authentication we also want to make sure the requesting user is only updating or deleting their own user information.</p>
<p>To achieve this, the <kbd>hasAuthorization</kbd> function defined in <kbd>auth.controller.js</kbd> will check whether the authenticated user is the same as the user being updated or deleted before the corresponding CRUD controller function is allowed to proceed.</p>
<p><kbd><span>mern-skeleton/server/controllers/auth.controller.js</span></kbd>:</p>
<pre>const hasAuthorization = (req, res, next) =&gt; {<br/>  const authorized = req.profile &amp;&amp; req.auth <br/>        &amp;&amp; req.profile._id ==  req.auth._id<br/>  if (!(authorized)) {<br/>    return res.status('403').json({<br/>      error: "User is not authorized"<br/>    })<br/>  }<br/>  next()<br/>}</pre>
<p>The <kbd>req.auth</kbd> object is populated by <kbd>express-jwt</kbd> in <kbd>requireSignin</kbd> after authentication verification, while <kbd>req.profile</kbd> is populated by the <kbd>userByID</kbd> function in <kbd>user.controller.js</kbd>. We will add the <kbd>hasAuthorization</kbd> function to routes that require both authentication and authorization.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Auth error handling for express-jwt</h1>
                </header>
            
            <article>
                
<p>To handle auth-related errors thrown by <kbd>express-jwt</kbd> when it tries to validate JWT tokens in incoming requests, we need to add the following error-catching code to the Express app configuration in <kbd><span>mern-skeleton/server/express.js</span></kbd>, near the end of the code, after the routes are mounted and before the app is exported: </p>
<pre>app.use((err, req, res, next) =&gt; {<br/>  if (err.name === 'UnauthorizedError') {<br/>    res.status(401).json({"error" : err.name + ": " + err.message})<br/>  }else if (err) {<br/>    res.status(400).json({"error" : err.name + ": " + err.message})<br/>    console.log(err)<br/>  }<br/>})</pre>
<p><kbd>express-jwt</kbd> throws an error named <kbd>UnauthorizedError</kbd> when a token cannot be validated for some reason. We catch this error here to return a <kbd>401</kbd> status back to the requesting client. We also add a response to be sent if other server-side errors are generated and caught here.</p>
<p>With user auth implemented for protecting routes, we have covered all the desired features of a working backend for our skeleton MERN application. In the next section, we will look at how we can check whether this standalone backend is functioning as desired without implementing a frontend.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Checking the standalone backend</h1>
                </header>
            
            <article>
                
<p>There are a number of options when it comes to selecting tools to check backend APIs, ranging from the command-line tool curl (<a href="https://github.com/curl/curl" target="_blank">https://github.com/curl/curl</a>) to <strong>Advanced REST Client</strong> (<strong>ARC</strong>) (<a href="https://chrome.google.com/webstore/detail/advanced-rest-client/hgmloofddffdnphfgcellkdfbfbjeloo" target="_blank">https://chrome.google.com/webstore/detail/advanced-rest-client/hgmloofddffdnphfgcellkdfbfbjeloo</a>), a Chrome extension app with an interactive user interface.</p>
<p>To check the APIs that were implemented in this chapter, first, have the server running from the command line and use either of these tools to request the routes. If you are running the code on your local machine, the root URL is <kbd>http://localhost:3000/</kbd>.</p>
<p>Using ARC, we will showcase the expected behavior for five use cases so that we can check the implemented API endpoints.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a new user</h1>
                </header>
            
            <article>
                
<p>First, we will create a new user with the <kbd>/api/users</kbd> POST request and pass name, email, and password values in the request body. When the user is successfully created in the database without any validation errors, we will see a <span class="packt_screen">200 OK</span> success message, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-771 image-border" src="assets/b9f549c9-8db0-4578-8f8a-41399b35ddff.png" style="width:41.83em;height:30.25em;"/></div>
<p>You can also try to send the same request with invalid values for name, email, and password to check whether the relevant error messages are returned by the backend. Next, we will check whether the users were successfully created and stored in the database by calling the list users API. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Fetching the user list</h1>
                </header>
            
            <article>
                
<p>We can see whether a new user is in the database by fetching a list of all users with a <kbd>GET</kbd> request to <kbd>/api/users</kbd>. The response should contain an array of all the user objects stored in the database:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-772 image-border" src="assets/0ba36f8e-98d2-4426-b9db-44182588be8e.png" style="width:35.92em;height:36.08em;"/></div>
<p>Notice how the returned user objects only show the <kbd>_id</kbd>, <kbd>name</kbd>, <kbd>email</kbd>, and <kbd>created</kbd> field values, and not the <kbd>salt</kbd> or <kbd>hashed_password</kbd> values, which are also present in the actual documents stored in the database. The request only retrieves the selected fields we specified in the Mongoose <kbd>find</kbd> query that we made in the list controller method. This omission is also in place when fetching a single user.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Trying to fetch a single user</h1>
                </header>
            
            <article>
                
<p>Next, we will try to access a protected API without signing in first. A <kbd>GET</kbd> request to read any one of the users will return a <span class="packt_screen">401 Unauthorized</span> error, such as in the following example. Here, a <kbd>GET</kbd> request to <kbd>/api/users/5a1c7ead1a692aa19c3e7b33</kbd> returns a <span class="packt_screen">401</span> error:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-773 image-border" src="assets/70f7128e-1a9d-44e6-8e84-8837b61a8236.png" style="width:67.08em;height:41.92em;"/></div>
<p>To make this request return a successful response with user details, a valid authorization token needs to be provided in the request header. We can generate a valid token by successfully calling the sign-in request. </p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Signing in</h1>
                </header>
            
            <article>
                
<p>To be able to access the protected route, we will sign-in using the credentials of the user we created in the first example. To sign-in, a POST request is sent to <kbd>/auth/signin</kbd> with the email and password in the request body, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-774 image-border" src="assets/24e09460-8fe0-468f-91e4-7632e51bd8ef.png" style="width:66.42em;height:51.75em;"/></div>
<p><span>On successful sign-in, the server returns a signed JWT and user details. We will need this token to access the protected route for fetching a single user.</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Fetching a single user successfully</h1>
                </header>
            
            <article>
                
<p>Using the token received after sign-in, we can now access the protected route that failed previously. The token is set in the <kbd>Authorization</kbd> header in the Bearer scheme when making the GET request to <kbd>/api/users/5a1c7ead1a692aa19c3e7b33</kbd>. This time, the user object is returned successfully:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-775 image-border" src="assets/c157ee7c-b504-497a-9d46-051f24e4f9da.png" style="width:66.50em;height:50.83em;"/></div>
<p>Using ARC as demonstrated in this section, you can also check the implementation of the other API endpoints for updating and deleting a user. With all these API endpoints working as expected, we have a complete working backend for MERN-based applications. </p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we developed a fully functioning standalone server-side application using Node, Express, and MongoDB and covered the first part of the MERN skeleton application. In the backend, we implemented a user model for storing user data, implemented with Mongoose; user API endpoints to perform CRUD operations, which were implemented with Express; and user auth for protected routes, which was implemented with JWT and <kbd>express-jwt</kbd>.</p>
<p>We also set up the development flow by configuring Webpack so that it compiles ES6+ code using Babel. We also configured Nodemon so that it <span>restarts the server when the</span> code changes. Finally, we checked the implementation of the APIs using the Advanced Rest API Client extension app for Chrome. </p>
<p>Now, we are ready to extend this backend application code and add the React frontend, which will complete the MERN skeleton application. We will do this in the next chapter.</p>


            </article>

            
        </section>
    </body></html>