- en: Chapter 5. Component-Based Routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Routing is an integral part of today''s frontend applications. In general,
    a router serves two main purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: Making your application navigable so that users can use their browser's back
    button and store and share links within the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Offload parts of the application composition so that the router takes responsibility
    to compose your application, based on routes and route parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The router that comes with Angular supports many different use-cases, and it
    comes with an easy-to-use API. This supports child routers that are similar to
    the Angular UI-Router nested states, Ember.js nested routes, or child routers
    in the Durandal framework. Tied to the component tree, this also makes use of
    its own tree structure to store states and to resolve requested URLs.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we refactor our code to use the component-based router of Angular.
    We will look into the core elements of the router and how to use them to enable
    routing in our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to the Angular router
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of the refactoring to enable the router in our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composition by template, composition by routing, and how to mix them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `Routes` decorator to configure routes and child routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `OnActivate` router lifecycle hook to obtain route parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `RouterOutlet` directive to create insertion points that are controlled
    by the router
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `RouterLink` directive and the router DSL to create navigation links
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Querying for the `RouterLink` directives using the `@ChildView` decorator in
    order to obtain the link's active state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to the Angular router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The router in Angular is closely coupled to our component tree. The design of
    the Angular router is built on the assumption that a component tree is directly
    related to our URL structure. This is certainly true for most of the cases. If
    we look at a component **B**, which is nested within a component **A**, the URL
    to represent our location would very likely be `/a/b`.
  prefs: []
  type: TYPE_NORMAL
- en: In order to specify the location in our template where we'd like to enable the
    router to instantiate components, we can use so-called outlets. Simply by including
    a `<router-outlet>` element, we can make use of the `RouterOutlet` directive to
    mark the router insertion point in our template.
  prefs: []
  type: TYPE_NORMAL
- en: Based on some route configuration that we can place on our component, the router
    then decides which components need to be instantiated and placed into the router
    outlets. Routes can also be parameterized, and we can access these parameters
    within the instantiated components.
  prefs: []
  type: TYPE_NORMAL
- en: Based on our component tree and the route configurations on components in this
    tree, we can build a hierarchical routing and decouple child routes from their
    parent routes. Such nested routes make it possible to specify route configuration
    on multiple layers in our component tree and reuse parent components for multiple
    child routes.
  prefs: []
  type: TYPE_NORMAL
- en: '![An introduction to the Angular router](img/image00319.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Router hierarchy established through a component tree
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the elements of the router again in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Route configuration**: The route configuration is placed at component level,
    and it contains the different routes possible for this level in the component
    tree. By placing multiple route configurations on different components in the
    component tree, we can build decoupled nested routes easily.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Router outlets**: Outlets are the locations in components that will be managed
    by the router. Instantiated components that are based on the route configuration
    will be placed into these outlets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Router link**: These are links built with a DSL style notation that enable
    the developer to build complex links through the routing tree.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composition by routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we achieved composition by including subcomponents in component templates.
    However, we'd now like to give the control to the router to decide which component
    should be included and where.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following illustration provides an overview of the component architecture
    of our application, which we''re going to enable to route:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Composition by routing](img/image00320.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A component tree displaying routing components (solid line) and router outlets
  prefs: []
  type: TYPE_NORMAL
- en: The `Project` component is now not directly included with our `App` component.
    Instead, we use a router outlet in the template of our `App` component. This way,
    we can give control to the router, and let it decide which component should be
    placed into the outlet. The `App` component's router configuration will contain
    all top-level routes. In the current application, we only have the `Project` component
    as a secondary-level component, but this will change in further chapters.
  prefs: []
  type: TYPE_NORMAL
- en: The `Project` component contains child route configuration to navigate to the
    tasks and comments view. However, it does not directly contain a router outlet.
    We use the `Tabs` component as a navigation element for any sub views. As a result,
    we'll place the router outlet into the `Tabs` component and include the component
    directly in the template of the `Project` component.
  prefs: []
  type: TYPE_NORMAL
- en: Router versus template composition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The composition that we dealt with so far was purely based on instantiation
    via template inclusion. We used input and output properties to decouple and encapsulate
    components, and followed nice reusable patterns.
  prefs: []
  type: TYPE_NORMAL
- en: With the router, we face a problem that has not yet been solved by Angular and
    requires that we find our own solution. As we give control to the router to instantiate
    and insert components into our component tree, we can't control any bindings on
    our instantiated component. While we previously relied on the clean decoupling
    of components using input and output properties, we can no longer do this. The
    only thing that a router provides us are route parameters that may have been set
    along the activated route.
  prefs: []
  type: TYPE_NORMAL
- en: 'This puts us in quite a nasty situation. Basically, we need to decide between
    two designs when writing components, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We use a given component purely in template composition and, therefore, rely
    on input and output properties as the glue between the parent component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use a component instantiated by the router and rely on input-provided view
    route parameters and don't require communication with the parent component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Well, both of the preceding design approaches aren't very nice, are they? In
    an ideal world, we would not need to apply any changes to a component when we
    enable it for routing. The router should just enable the component for routing,
    but it should not require any changes on the component itself. Unfortunately,
    there's no agreement for a solution to this problem at the time of writing this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: As we don't want to lose any composition capabilities that we gain from relying
    on inputs and outputs in our `TaskList` and `Comments` components, we need to
    a find a better solution to enable routing in our application.
  prefs: []
  type: TYPE_NORMAL
- en: The following solution allows us to leave the `TaskList` and `Comments` components
    untouched while they can still rely on input and output properties. Instead of
    exposing them directly to the router, we will build wrapper components that we
    address from our routes. These wrappers follow some mechanics to bridge this gap
    between the router and our components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `wrapper` component deals with any route parameters or route data that might
    have been set in the activated route.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Their template should only include the component that is wrapped and its input
    and output bindings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They handle the required data and functionality to provide the input and output
    bindings of the concerned component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They may use parent component injection to establish communication with the
    parent and propagate any action that is required by emitted events. Parent component
    injection should be used with caution as it somewhat breaks our decoupling of
    components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the route tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Angular uses tree data structures to represent the router state. You can imagine
    that every navigation in your application activates a branch in this tree. Let's
    look at the following example.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have an application that consists of four possible routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/`: This is the root route of the application, which is handled in a component
    called **A**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/b/:id`: This is the route where we can access a `b` detail view, which is
    handled in a component called **B**. In the URL, we can pass an `id` parameter
    (that is, `/b/100`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/b/:id/c`: This is the route where the `b` detail view has another navigation
    possibility, which reveals more specific details that we call `c`. This is handled
    in a **C** component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/b/:id/d`: This is the route where we can also navigate to a `d` view in the
    `b` detail view. This is handled by a component, called **D**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Understanding the route tree](img/image00321.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A route tree consisting of an active branch of route segments for an activated
    route /b/100/d
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume that we activate a route in our example by navigating the URL,
    `/b/100/d`. In this case, we'd activate a route that reflects the state that is
    outlined in the preceding figure. Note that the route segment **B** actually consists
    of two URL segments. The reason for this is that we've specified that our route
    **B** actually consists of the `b` identifier and an `:id` route parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Using this tree data structure, we have a perfect abstraction to deal with navigation
    trees. We can compare trees, check whether certain segments exist in a tree, and
    extract parameters present on resolved route segments.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate the use of routing trees, let''s take a look at the `OnActivate`
    router lifecycle hook that we can implement on our navigable components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When we implement this lifecycle hook on our components, we can run some code
    after the route was activated. The `currentRouteSegment` argument will point to
    the `RouteSegment` instance that was activated on our component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at our example again and assume that we want to access the
    `:id` parameter in the `routerOnActivate` hook of our **B** component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Using the `getParam` function on the `RouteSegment` instance, we obtain any
    parameters that are resolved on the given segment. In our example case, this would
    return a `100` string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a more complex example. What if we want to access the
    `:id` parameter from the **D** component on the `d` detail view? In the `OnActivate`
    lifecycle hook, we''ll receive only the route segment that is relevant to the
    **D** component. This only consists of the `d` URL segment and this does not include
    the `:id` parameter from the parent route. We can now make use of the `RouteTree`
    instance to find the parent route segment and obtain the parameter from there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Using the current `RouteTree` instance, we can obtain the parent of the current
    route segment. As a result, we'll receive the parent route segment (`RouteSegment`
    **B** in the preceding figure) from where we can obtain the `:id` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the router API is quite flexible, and it allows us to inspect
    route activity on a very fine granularity. The tree structures that are used in
    the router make it possible to compare complex router states in our application
    without bothering about the underlying complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Back to the routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All right, now it''s time to implement routing for our application! In the
    following topics, we''ll create the following routes for our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Route path | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `/projects/:projectId` | This route will activate the `Project` component
    in the outlet of our main application component. This consists of the `projects`
    URL segment as well as the `:projectId` URL segment to specify the project ID.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `/projects/:projectId/tasks` | This route will activate the `TaskList` component.
    We will create a `ProjectTaskList` wrapper component in order to decouple our
    `TaskList` component from routing. We''ll apply the procedure described in the
    previous section, *Router versus template composition*. |'
  prefs: []
  type: TYPE_TB
- en: '| `/projects/:projectId/comments` | This route will activate the `Comments`
    component. We''ll create a `ProjectComments` wrapper component in order to decouple
    our `Comments` component from routing. We''ll apply the procedure described in
    the previous section, *Router versus template composition*. |'
  prefs: []
  type: TYPE_TB
- en: 'In order to use the router of Angular, the first thing that we need to do is
    to add the route provider to our application. We''ll do this on bootstrap in order
    to make sure the router providers are only loaded once. Let''s open our `boostrap.js`
    file and add the necessary dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: From the router module, we import the `ROUTER_PROVIDERS` constant that contains
    a list of modules that are required to be exposed as providers when using the
    router. We also import the `LocationStrategy` and `HashLocationStrategy` type
    from the common module that need to be provided manually.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `provide` function, we provide the `HashLocationStrategy` class as
    a substitution for the `LocationStrategy` abstract class. This way, the router
    will know which strategy to use when resolving URLs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following two strategies exist at the moment:'
  prefs: []
  type: TYPE_NORMAL
- en: '**HashLocationStrategy**: This can be used when the router should use hash
    URLs, such as `localhost:8080#/child/something`. This location strategy makes
    sense if you''re working in an environment where the HTML5 push state can''t be
    used due to browser or server constraints. The whole navigation state will be
    managed in the fragment identifier of the URL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PathLocationStrategy**: This strategy can be used if you''d like to use the
    HTML5 push state to handle application URLs. This means that your application
    navigation becomes the actual path of the URL. Using the preceding example of
    a hash-based URL, this strategy would enable the direct use of `localhost:8080/child/something`.
    As the initial requests will hit the server if the state is encoded in the path
    of a URL, you''ll need to enable the correct routing on the server to make this
    work properly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After enabling the router for our application, we will need to make our root
    component routable. We can do this by including a route configuration on our `App`
    component. Let''s look at the necessary code to do this. We edit the `app.js`
    file in our `lib` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we imported the `Routes` decorator as well as the `Route`
    type from the router module.
  prefs: []
  type: TYPE_NORMAL
- en: In order to configure routes on our component, we can use the `@Routes` decorator
    by passing an array of `Route` objects that describe the possible child routes
    on this component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the available options that we can pass to the `Route` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Route property | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `path` | This property is required. Using the path, we can describe the navigation
    URL in the browser using the route matcher DSL. This can contain route parameter
    placeholders.Some examples are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following route gets activated if the user navigates to `/home` in the
    browser:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following route gets activated when the user navigates to a `/child/something`
    URL where something will be available as route parameter with the name, `id`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `component` | This property is required, and it defines which component should
    be instantiated by the router. As already explained in the previous section, the
    router does not allow us here to specify any bindings to the instantiated component.
    |'
  prefs: []
  type: TYPE_TB
- en: The route configuration on our `App` component covers the `Project` component
    being instantiated on the `projects/:projectId` route path. This means that we
    use a `projectId` parameter on the child route, which will be available to the
    `Project` component.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to modify our `App` component template and remove the direct inclusion
    of the `Project` component there. We now give control to the router to decide
    which component to display. For this, we need to make use of the `RouterOutlet`
    directive to provide a slot in our template where the router will instantiate
    components.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `RouterOutlet` directive is part of the `ROUTER_DIRECTIVES` constant that
    is exported by the router module. Let''s import and add the constant to the directives
    list on our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can use the `RouterOutlet` directive in our template to indicate the
    insertion position of instantiated components by the router. Let''s open our `App`
    component template file, `app.html`, and make the necessary modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The next step is to refactor our `Project` component so that it can be used
    in routing. As we already outlined in the previous section, the router comes with
    certain constraints when it comes to component design. For the `Project` component,
    we decide to redesign it in a way so that we can only use it with routing. This
    isn't a bad thing here because we can exclude the possibility that it will be
    reused somewhere else in our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The redesign of the `Project` component includes the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting rid of all input and output properties of the component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the `OnActivate` router lifecycle hook to obtain the `projectId` parameter
    from the activated route segment of the `App` component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Obtaining the project data directly from the data store using the `projectId`
    parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Handling updates on the project data directly on the component instead of delegating
    to the `App` component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s modify the `Component` class located in `lib/project/project.js` to
    implement the preceding design changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Besides implementing these changes that are already described in the redesigning
    steps, we also made use of a new `LiveDocument` utility class that we imported
    from the `data-access` folder. This helps us to keep our programming reactive
    when we're concerned about changes on a single data entity. Using the `LiveDocument`
    class, we can query the database for a single entity, while the change property
    of the `LiveDocument` instance is an observable that keeps us notified about changes
    on the entity. A `LiveDocument` instance also exposes the data of the entity into
    a `data` property, which can be accessed directly. If we'd like to make an update
    on the entity, we can add, modify, or remove properties on the data object and
    then store the changes by calling `persist()`.
  prefs: []
  type: TYPE_NORMAL
- en: As our `Project` component is now activated by the router in the `App` component,
    we can make use of the `OnActivate` router lifecycle hook by implementing a method,
    named `routerOnActivate`. We use the `getParam` function of the current route
    segment to obtain the `:projectId` parameter of the route.
  prefs: []
  type: TYPE_NORMAL
- en: In the `subscribe` function on the change observable of our `LiveDocument` instance,
    we expose the project data directly on the `Project` component. This simplifies
    later use in the view.
  prefs: []
  type: TYPE_NORMAL
- en: In the `OnDestroy` lifecycle hook, we make sure that we unsubscribe from the
    document change observable.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can rely on the `projectId` route parameter to be passed into our component,
    which makes the `Project` component depend on the router. We got rid of all input
    properties, and then we set the necessary data by querying our data store using
    the project ID.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's time to build the wrapper components that we talked about in order
    to route to our `TaskList` and `Comments` components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new component called `ProjectTaskList`, which will serve as
    a wrapper to enable the `TaskList` component in routing. We will create a `project-task-list.js`
    file in the `lib/project/project-task-list` path, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also take a look at the template in the `project-task-list.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We inject the `Project` parent component into our wrapper component. As we can't
    rely on output properties any more to emit events, this is the only way to communicate
    with the parent `Project` component. We're dealing with a circular reference here
    (`Project` depends on `ProjectTaskList`, and `ProjectTaskList` depends on `Project`),
    hence we need to use a `forwardRef` helper function to prevent the `Project` type
    evaluating to `undefined`.
  prefs: []
  type: TYPE_NORMAL
- en: If we receive a `tasksUpdated` event in the template, we will call the `updateTasks`
    method on our wrapper component. The wrapper then simply delegates the call to
    the project component.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we use the project data to obtain the list of tasks and create a
    binding to the `tasks` input property of the `TaskList` component.
  prefs: []
  type: TYPE_NORMAL
- en: Using this wrapper approach for routing, we're able to leave our components
    unmodified when enabling them for routing. This is much better than the option
    to make our task list only available for the router. We would lose the freedom
    to use a task list outside of the context of a project, and then use it with pure
    template composition.
  prefs: []
  type: TYPE_NORMAL
- en: For the `Comments` component, we perform the exact same task, and create a wrapper
    on the `lib/project/project-comments` path. Besides dealing with comments instead
    of tasks, the code looks exactly the same as with the `ProjectTaskList` wrapper
    component.
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating the two wrapper components, we can now create the router configuration
    on our `Project` component. Let''s modify the `project/project.js` file to enable
    routing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: To enable the task list and make comments navigable using the router, we simply
    create a router configuration that instantiates our wrapper components. We also
    specify that the tasks route should be the default route if no child route was
    selected.
  prefs: []
  type: TYPE_NORMAL
- en: Routable tabs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Okay, if you've read through this chapter so far, you now may wonder where the
    router will instantiate the components of the child routes. We've not yet included
    a router outlet in the `Project` component template so that the router knows where
    to instantiate components.
  prefs: []
  type: TYPE_NORMAL
- en: 'We won''t include the outlet for the project router directly in the `Project`
    component. Instead, we will use our `Tabs` component to take over this job. Instead
    of using content insertion in our `Tabs` component like we did so far, we now
    use a router outlet to compose its content. This will make our `Tabs` component
    unusable for nonrouting cases, but we can establish a nice decoupling by only
    providing the router outlet. This way we can still reuse the `Tabs` component
    in other routing situations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Routable tabs](img/image00322.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The App component includes a router outlet directly; however, the Project component
    relies on the Tabs component to provide a router outlet.
  prefs: []
  type: TYPE_NORMAL
- en: 'On a higher level, we can describe the new design of our `Tabs` component,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It renders all tab buttons, based on a list of router links and titles to provide
    a router navigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides a router outlet that will be used by the parent component to instantiate
    navigated components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s modify our `Tabs` component in `lib/ui/tabs/tabs.js` to implement these
    changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `ROUTER_DIRECTIVES` constant from the router module contains the `RouterOutlet`
    directive as well as the `RouterLink` directive. By importing the constant and
    providing it to the components directives list, we enable both router directives
    to be used in our template.
  prefs: []
  type: TYPE_NORMAL
- en: The `RouterOutlet` directive is used inside the `Tabs` component template to
    indicate the instantiation point for the router.
  prefs: []
  type: TYPE_NORMAL
- en: The `RouterLink` directive can be used to generate routing URLs from the template
    using the router link DSL. This allows you to generate navigation links in your
    application and it can be placed both on anchor tags as well as other elements
    where it will trigger navigation on click.
  prefs: []
  type: TYPE_NORMAL
- en: The `items` input is an array of link items that contain a title and a router
    link. On our parent project component, we already prepare these items in the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s also take a quick look at the template of our component in the `tabs.html`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As we let the router deal with the active view using a router outlet, there's
    no need any more to use multiple tab components that are switched active. We will
    always have one active tab, and let the router handle the content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we can make use of the new `Tabs` component in our `Project`
    component to make the configured routes navigable. First, we need to add the following
    code to our `Project` component constructor to provide the necessary navigation
    items to our `Tabs` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the link property of our navigation items, we use the router link DSL to
    specify which route should be navigated. As the navigation is relative to the
    parent route segment and we're already in the `/projects/:projectId` route, the
    only thing in our router link DSL should be a relative path to the `tasks` and
    `comments` child routes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the template of our `Project` component, we can now use the `tabItems` property
    to create a binding to the input property of the `Tabs` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Refactoring navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a final step, we also need to refactor our navigation components to rely
    on the router. So far, we used our own routing that was implemented in a complex
    nested-navigation component structure. We can simplify this a lot using the Angular
    router.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the smallest component first, and edit our `NavigationItem`
    component template in the `lib/navigation/navigation-section/navigation-item/navigation-item.html`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Instead of controlling the link behavior ourselves, we now use the `RouterLink`
    directive to generate a link that is based on the component `link` input property.
    To set the active class on the navigation link, we still rely on the `isActive`
    method on our component, and there's no change required in the template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the changes to the `Component` class in the `navigation-item.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Instead of relying on the `Navigation` component to manage the active state
    of navigation items, we now rely on the `RouterLink` directive. Each `RouterLink`
    directive provides an `accessor` property, `isActive`, which tells us whether
    this specific route addressed by the router link is currently activated within
    the browsers URL. Using the `@ViewChild` decorator, we can query for the `RouterLink`
    directive in our view and then query the `isActive` property to find out if the
    current navigation item is active or not.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we only need to make sure that we pass the necessary items to the `Navigation`
    component in our `App` component in order to make our navigation work again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code needs to be changed in the `App` component constructor in
    the `app.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: By filtering and mapping the available projects, we can create a list of navigation
    items that contain a `title` and `link` property. The `link` property contains
    a route link DSL that points to the project details route that is configured in
    the `App` component router configuration. By passing an object literal as a sibling
    to the route name, we can specify some parameters along the route. Here, we simply
    set the expected `projectId` parameter to the ID of the project in the projects
    list.
  prefs: []
  type: TYPE_NORMAL
- en: Now, our navigation components make use of the router to enable navigation.
    We got rid of our custom routing functionality in the `Navigation` component,
    and we use router link DSL to create navigation items.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the basic concepts of the router in Angular.
    We looked at how we can use the existing component tree to configure child routes
    in nested-router scenarios. Using nested-child routes, we enabled the reuse of
    components with route configurations.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at the problem of router versus template composition and how
    to mitigate this problem using wrapper components. In this way, we close the gap
    between the router and underlying components using an in-between layer.
  prefs: []
  type: TYPE_NORMAL
- en: We looked into route configuration specifics and the basics of the router link
    DSL. We also covered the basics of the `RouteTree` and `RouteSegment` classes
    and how to use them to perform in-depth route analysis.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about SVG and how to use this web standard
    in order to draw graphics in our Angular applications. We will visualize an activity
    log of our application activities using SVG and see how Angular makes this technology
    even greater by enabling composability.
  prefs: []
  type: TYPE_NORMAL
