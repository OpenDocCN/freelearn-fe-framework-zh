<html><head></head><body>
<section epub:type="bodymatter chapter" role="doc-chapter">
<h1 class="chapter-number" id="_idParaDest-126"><a id="_idTextAnchor227"/><span class="koboSpan" id="kobo.1.1">9</span></h1>
<h1 id="_idParaDest-127"><a id="_idTextAnchor228"/><span class="koboSpan" id="kobo.2.1">Applying Design Principles in React</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Design principles</span><a id="_idIndexMarker396"/><span class="koboSpan" id="kobo.4.1"> are like the cardinal rules that guide software development, ensuring that code remains maintainable, scalable, and readable over time. </span><span class="koboSpan" id="kobo.4.2">In the ever-changing landscape of technology, adhering to these principles can be the difference between a project’s long-term success and its descent into “code hell,” where changes become increasingly arduous and bugs frequent.</span></p>
<p><span class="koboSpan" id="kobo.5.1">For React applications, the importance of design principles escalates due to the library’s declarative nature and component-based architecture. </span><span class="koboSpan" id="kobo.5.2">React empowers developers to build complex UIs from small, isolated pieces of code known as components. </span><span class="koboSpan" id="kobo.5.3">While this modular approach is one of React’s strongest features, it can also lead to a messy and unmanageable code base if design principles are ignored.</span></p>
<p><span class="koboSpan" id="kobo.6.1">In a typical React project, components often share state and behavior, get nested within each other, and are reused across different parts of an application. </span><span class="koboSpan" id="kobo.6.2">Without following design principles, you might find yourself entangled in a web of dependencies, making it difficult to change or even understand</span><a id="_idIndexMarker397"/><span class="koboSpan" id="kobo.7.1"> the code. </span><span class="koboSpan" id="kobo.7.2">For instance, neglecting the </span><strong class="bold"><span class="koboSpan" id="kobo.8.1">Single Responsibility Principle</span></strong><span class="koboSpan" id="kobo.9.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.10.1">SRP</span></strong><span class="koboSpan" id="kobo.11.1">) could result in components that are difficult to test and refactor, while ignoring the </span><strong class="bold"><span class="koboSpan" id="kobo.12.1">Interface Segregation Principle</span></strong><span class="koboSpan" id="kobo.13.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.14.1">ISP</span></strong><span class="koboSpan" id="kobo.15.1">) could </span><a id="_idIndexMarker398"/><span class="koboSpan" id="kobo.16.1">make your components less reusable and more coupled to specific use cases.</span></p>
<p><span class="koboSpan" id="kobo.17.1">Furthermore, as React continues to evolve, with new features such as Hooks and concurrent mode, having a design principle-centered approach ensures that you can adapt to these changes without significant rewrites. </span><span class="koboSpan" id="kobo.17.2">This allows you to focus on building features, fixing bugs, and delivering value, instead of grappling with technical debt.</span></p>
<p><span class="koboSpan" id="kobo.18.1">Adhering to design principles in React development is not just a best practice but a necessity. </span><span class="koboSpan" id="kobo.18.2">It serves as a proactive measure to counteract complexity, making your React code easier to read, test, and maintain.</span></p>
<p><span class="koboSpan" id="kobo.19.1">In this chapter, we commence by revisiting the SRP, a core concept that often serves as the bedrock of clean, maintainable code. </span><span class="koboSpan" id="kobo.19.2">From the humble beginnings of a simple string-transforming function, we’ll explore how this principle scales up to the complexities of render props, enriching the structure and readability of your React components.</span></p>
<p><span class="koboSpan" id="kobo.20.1">Transitioning from there, we introduce </span><a id="_idIndexMarker399"/><span class="koboSpan" id="kobo.21.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.22.1">Dependency Inversion Principle</span></strong><span class="koboSpan" id="kobo.23.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.24.1">DIP</span></strong><span class="koboSpan" id="kobo.25.1">), a transformative approach to component design. </span><span class="koboSpan" id="kobo.25.2">This section emphasizes that focusing on the interface – not the nitty-gritty details of implementation – is the pathway to reusable and easily understandable components.</span></p>
<p><span class="koboSpan" id="kobo.26.1">Concluding the chapter, we delve into </span><strong class="bold"><span class="koboSpan" id="kobo.27.1">Command and Query</span></strong><strong class="bold"><span class="koboSpan" id="kobo.28.1"> Responsibility Segregation</span></strong><span class="koboSpan" id="kobo.29.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.30.1">CQRS</span></strong><span class="koboSpan" id="kobo.31.1">), a</span><a id="_idIndexMarker400"/><span class="koboSpan" id="kobo.32.1"> pattern that gains importance as your React applications grow in size and complexity. </span><span class="koboSpan" id="kobo.32.2">Through a discussion on CQRS, you’ll discover strategies to separate your application’s command and query responsibilities, thereby making it more manageable and scalable.</span></p>
<p><span class="koboSpan" id="kobo.33.1">This chapter aims to equip you with a holistic understanding of key design principles, which in turn will lay a strong foundation for the rest of your journey in mastering React.</span></p>
<p><span class="koboSpan" id="kobo.34.1">In this chapter, we will cover the following topics:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.35.1">Revisiting the Single Responsibility Principle</span></li>
<li><span class="koboSpan" id="kobo.36.1">Embracing the Dependency Inversion Principle</span></li>
<li><span class="koboSpan" id="kobo.37.1">Understanding Command and Query Responsibility Segregation in R</span><a id="_idTextAnchor229"/><span class="koboSpan" id="kobo.38.1">eact</span></li>
</ul>
<h1 id="_idParaDest-128"><a id="_idTextAnchor230"/><span class="koboSpan" id="kobo.39.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.40.1">A GitHub repository has been created to host all the code we discuss in the book. </span><span class="koboSpan" id="kobo.40.2">For this chapter, you can find the recommended structure at </span><a href="https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch9"><span class="koboSpan" id="kobo.41.1">https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch9</span></a><span class="koboSpan" id="kobo.42.1">.</span></p>
<h1 id="_idParaDest-129"><a id="_idTextAnchor232"/><span class="koboSpan" id="kobo.43.1">Revisiting the Single Responsibility Principle</span></h1>
<p><span class="koboSpan" id="kobo.44.1">In </span><a href="B21103_04.xhtml#_idTextAnchor111"><i class="italic"><span class="koboSpan" id="kobo.45.1">Chapter 4</span></i></a><span class="koboSpan" id="kobo.46.1">, we delved</span><a id="_idIndexMarker401"/><span class="koboSpan" id="kobo.47.1"> into the SRP within the context of designing React components. </span><span class="koboSpan" id="kobo.47.2">Yet this principle is more universal, acting as the bedrock for various other programming tenets. </span><span class="koboSpan" id="kobo.47.3">To bring this idea to life, let’s work through some hands-on examples.</span></p>
<p><span class="koboSpan" id="kobo.48.1">Identifying the core responsibility of a component is key to adhering to the SRP. </span><span class="koboSpan" id="kobo.48.2">Once you isolate what the component is fundamentally meant to do, it becomes easier to refactor and abstract out auxiliary functionalities.</span></p>
<p><span class="koboSpan" id="kobo.49.1">The SRP, being a high-level guideline, is advantageous when applied directly at the code level. </span><span class="koboSpan" id="kobo.49.2">There are numerous ways to implement this principle, but recognizing when to apply it is crucial, especially as complexity increases.</span></p>
<p><span class="koboSpan" id="kobo.50.1">The most common two techniques we’ll use are </span><i class="italic"><span class="koboSpan" id="kobo.51.1">render props</span></i><span class="koboSpan" id="kobo.52.1"> and </span><i class="italic"><span class="koboSpan" id="kobo.53.1">composition</span></i><span class="koboSpan" id="kobo.54.1">. </span><span class="koboSpan" id="kobo.54.2">Render </span><a id="_idIndexMarker402"/><span class="koboSpan" id="kobo.55.1">props refer to a technique in React for sharing code between components using a prop whose value is a function. </span><span class="koboSpan" id="kobo.55.2">A component with a render prop takes a function that returns a React element and calls it instead of implementing its own render logic. </span><span class="koboSpan" id="kobo.55.3">On the other hand, composition</span><a id="_idIndexMarker403"/><span class="koboSpan" id="kobo.56.1"> in React is a development pattern where you build components as </span><a id="_idIndexMarker404"/><span class="koboSpan" id="kobo.57.1">small, reusable pieces and then compose them together to create more complex UIs.</span></p>
<p><span class="koboSpan" id="kobo.58.1">In the following section, we’ll explore two specific examples, demonstrating how we use render props and composition respectively to adhere to this principle in p</span><a id="_idTextAnchor233"/><span class="koboSpan" id="kobo.59.1">ractice.</span></p>
<h2 id="_idParaDest-130"><a id="_idTextAnchor234"/><span class="koboSpan" id="kobo.60.1">Exploring the render props pattern</span></h2>
<p><span class="koboSpan" id="kobo.61.1">Let’s start simple </span><a id="_idIndexMarker405"/><span class="koboSpan" id="kobo.62.1">with a basic function component called </span><strong class="source-inline"><span class="koboSpan" id="kobo.63.1">Title</span></strong><span class="koboSpan" id="kobo.64.1">:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.65.1">
const Title = () =&gt; &lt;div&gt;Title │ This is a title&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.66.1">As it stands, this component merely outputs a static string. </span><span class="koboSpan" id="kobo.66.2">To give it the ability to render different titles, we introduce a </span><strong class="source-inline"><span class="koboSpan" id="kobo.67.1">title</span></strong><span class="koboSpan" id="kobo.68.1"> prop:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.69.1">
const Title = ({ title }: { title: string }) =&gt; &lt;div&gt;Title │ {title}&lt;/div&gt;;</span></pre> <p><span class="koboSpan" id="kobo.70.1">With this change, the component becomes more versatile, appending a fixed prefix, </span><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">Title |</span></strong><span class="koboSpan" id="kobo.72.1">, to any title we pass in. </span><span class="koboSpan" id="kobo.72.2">But what if we want to further manipulate the title, perhaps to capitalize it?</span></p>
<p><span class="koboSpan" id="kobo.73.1">By utilizing a higher-order function – the </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">transformer</span></strong><span class="koboSpan" id="kobo.75.1"> parameter in the following code snippet – we can modify our </span><strong class="source-inline"><span class="koboSpan" id="kobo.76.1">Title</span></strong><span class="koboSpan" id="kobo.77.1"> component as follows:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.78.1">
const Title = ({
  title,
  transformer,
}: {
  title: string;
  transformer: (s: string) =&gt; string;
}) =&gt; &lt;div&gt;Title │ {transformer(title)}&lt;/div&gt;;</span></pre> <p class="callout-heading"><span class="koboSpan" id="kobo.79.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.80.1">In many programming languages (including JavaScript), a </span><strong class="bold"><span class="koboSpan" id="kobo.81.1">higher-order function</span></strong><span class="koboSpan" id="kobo.82.1"> is one that either takes another function as an argument, returns a</span><a id="_idIndexMarker406"/><span class="koboSpan" id="kobo.83.1"> function, or both. </span><span class="koboSpan" id="kobo.83.2">These functions are foundational in functional programming, enabling you to write modular and reusable code. </span><span class="koboSpan" id="kobo.83.3">They are commonly used for operations such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">map</span></strong><span class="koboSpan" id="kobo.85.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.86.1">filter</span></strong><span class="koboSpan" id="kobo.87.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">reduce</span></strong><span class="koboSpan" id="kobo.89.1"> on arrays, function composition, currying, and event handling. </span><span class="koboSpan" id="kobo.89.2">Higher-order functions simplify code structure, improve maintainability, and allow for more advanced programming techniques.</span></p>
<p><span class="koboSpan" id="kobo.90.1">Great – our title is now</span><a id="_idIndexMarker407"/><span class="koboSpan" id="kobo.91.1"> fully customizable. </span><span class="koboSpan" id="kobo.91.2">But let’s stretch this even further. </span><span class="koboSpan" id="kobo.91.3">What if we want the title to be inside an </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">h3</span></strong><span class="koboSpan" id="kobo.93.1"> tag rather than a simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">div</span></strong><span class="koboSpan" id="kobo.95.1"> tag? </span><span class="koboSpan" id="kobo.95.2">React has got us covered – we can pass a function that returns JSX elements:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.96.1">
const Title = ({
  title,
  render,
}: {
  title: string;
  render: (s: string) =&gt; React.ReactNode;
}) =&gt; &lt;div&gt;{render(title)}&lt;/div&gt;;</span></pre> <p><span class="koboSpan" id="kobo.97.1">Notice the use of the</span><a id="_idIndexMarker408"/><span class="koboSpan" id="kobo.98.1"> render prop – we call it as a function and pass in </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">title</span></strong><span class="koboSpan" id="kobo.100.1">.</span></p>
<p><span class="koboSpan" id="kobo.101.1">To use the render prop, we can pass an anonymous function (inside the curly braces) into it, as in the following code:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.102.1">
&lt;Title
  title="This is a title"
  render={(s: string) =&gt; {
    const formatted = s.toUpperCase();
    return &lt;h3&gt;{formatted}&lt;/h3&gt;;
  }}
/&gt;</span></pre> <p><span class="koboSpan" id="kobo.103.1">In React, this higher-order function doesn’t necessarily have to be named </span><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">render</span></strong><span class="koboSpan" id="kobo.105.1">. </span><span class="koboSpan" id="kobo.105.2">We could just as easily use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">children</span></strong><span class="koboSpan" id="kobo.107.1"> prop for a more intuitive design, like so:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.108.1">
const Title = ({
  title,
  children,
}: {
  title: string;
  children: (s: string) =&gt; React.ReactNode;
}) =&gt; &lt;div&gt;{children(title)}&lt;/div&gt;;</span></pre> <p><span class="koboSpan" id="kobo.109.1">This allows us to invoke </span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">children</span></strong><span class="koboSpan" id="kobo.111.1"> as if it were a regular function:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.112.1">
&lt;Title title="This is a title"&gt;
  {(s: string) =&gt; {
    const formatted = s.toUpperCase();
    return &lt;h3&gt;{formatted}&lt;/h3&gt;;
  }}
&lt;/Title&gt;</span></pre> <p><span class="koboSpan" id="kobo.113.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">Title</span></strong><span class="koboSpan" id="kobo.115.1"> component receives a </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">title</span></strong><span class="koboSpan" id="kobo.117.1"> prop and a child function (the latter of which is called a </span><strong class="bold"><span class="koboSpan" id="kobo.118.1">render prop</span></strong><span class="koboSpan" id="kobo.119.1">). </span><span class="koboSpan" id="kobo.119.2">The child function takes a string, </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">s</span></strong><span class="koboSpan" id="kobo.121.1">, converts it to uppercase, and renders it within an </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">h3</span></strong><span class="koboSpan" id="kobo.123.1"> tag. </span><span class="koboSpan" id="kobo.123.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">Title</span></strong><span class="koboSpan" id="kobo.125.1"> component calls this child function with the provided title prop for custom rendering.</span></p>
<p><span class="koboSpan" id="kobo.126.1">In React, the render prop pattern involves passing a function as a prop to a component. </span><span class="koboSpan" id="kobo.126.2">This function returns JSX that the component will render as part of its output. </span><span class="koboSpan" id="kobo.126.3">The pattern allows for more flexible and reusable components by giving the parent component control over a part of the child component’s rendering logic. </span><span class="koboSpan" id="kobo.126.4">It’s particularly useful for sharing behavior across multiple components.</span></p>
<p><span class="koboSpan" id="kobo.127.1">Take note of the </span><a id="_idIndexMarker409"/><span class="koboSpan" id="kobo.128.1">overarching pattern at play here: abstraction. </span><span class="koboSpan" id="kobo.128.2">Initially, we might think of </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">h2</span></strong><span class="koboSpan" id="kobo.130.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">h3</span></strong><span class="koboSpan" id="kobo.132.1"> as specific instances of headings. </span><span class="koboSpan" id="kobo.132.2">However, upon zooming out a bit, we start to understand that they’re part of a broader abstraction: a React component or, more technically, </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">ReactNode</span></strong><span class="koboSpan" id="kobo.134.1">.</span></p>
<p><span class="koboSpan" id="kobo.135.1">This realization allows us to see the utility of using render props or children as higher-order functions. </span><span class="koboSpan" id="kobo.135.2">They’re not just features; they represent the level of abstraction we’ve achieved. </span><span class="koboSpan" id="kobo.135.3">Now, instead of being limited to a specific HTML tag such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">h3</span></strong><span class="koboSpan" id="kobo.137.1">, we can pass any JSX element as an argument, from headings to fully styled components.</span></p>
<p><span class="koboSpan" id="kobo.138.1">With our newly crafted generic component that uses a render prop, we’ve essentially created a reusable framework. </span><span class="koboSpan" id="kobo.138.2">The beauty lies in the fact that we only need to write this general-purpo</span><a id="_idTextAnchor235"/><span class="koboSpan" id="kobo.139.1">se code once.</span></p>
<p><span class="koboSpan" id="kobo.140.1">Render props and composition are excellent techniques for this. </span><span class="koboSpan" id="kobo.140.2">They allow you to extend or customize the behavior of a component without altering its core logic. </span><span class="koboSpan" id="kobo.140.3">This keeps your components clean, modular, and easy to test, as each component does one thing and does it well. </span><span class="koboSpan" id="kobo.140.4">We have already seen how render props work in the evolution of </span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">Title</span></strong><span class="koboSpan" id="kobo.142.1">, so let’s now have a look at</span><a id="_idTextAnchor236"/><span class="koboSpan" id="kobo.143.1"> composition.</span></p>
<h2 id="_idParaDest-131"><a id="_idTextAnchor237"/><span class="koboSpan" id="kobo.144.1">Using composition to apply the SRP</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.145.1">Composition</span></strong><span class="koboSpan" id="kobo.146.1"> is a </span><a id="_idIndexMarker410"/><span class="koboSpan" id="kobo.147.1">term we have used in many places throughout the book, and at its core is the SRP. </span><span class="koboSpan" id="kobo.147.2">If each part of the system can do its job well, it’s then possible to compose them together. </span><span class="koboSpan" id="kobo.147.3">Let’s inspect a concrete example of this.</span></p>
<p><span class="koboSpan" id="kobo.148.1">Assume we</span><a id="_idIndexMarker411"/><span class="koboSpan" id="kobo.149.1"> have an </span><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">Avatar</span></strong><span class="koboSpan" id="kobo.151.1"> component in a design system with a</span><a id="_idIndexMarker412"/><span class="koboSpan" id="kobo.152.1"> handy feature: if a user passes in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">name</span></strong><span class="koboSpan" id="kobo.154.1"> prop to the component, then when the mouse hovers over the avatar, a tooltip will show up at the bottom of the avatar with the name as its content:</span></p>
<figure>
<div class="IMG---Figure" id="_idContainer053">
<span class="koboSpan" id="kobo.155.1"><img alt="Figure 9.1: Avatar component with Tooltip" src="image/B31103_09_01.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.156.1">Figure 9.1: Avatar component with Tooltip</span></figcaption> </figure>
<p><span class="koboSpan" id="kobo.157.1">Internally, </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">Avatar</span></strong><span class="koboSpan" id="kobo.159.1"> utilizes another component, </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">Tooltip</span></strong><span class="koboSpan" id="kobo.161.1">, to make it happen:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.162.1">
import Tooltip from "@xui/tooltip";
type AvatarProps = {
  name?: string;
  url: string;
};
const Avatar = ({ name, url }: AvatarProps) =&gt; {
  if (name) {
    return (
      &lt;Tooltip content={name}&gt;
        &lt;div className="rounded"&gt;
          &lt;img src={url} alt={name} /&gt;
        &lt;/div&gt;
      &lt;/Tooltip&gt;
    );
  }
  return (
    &lt;div className="rounded"&gt;
      &lt;img src={url} alt="" /&gt;
    &lt;/div&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.163.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">Avatar</span></strong><span class="koboSpan" id="kobo.165.1"> component </span><a id="_idIndexMarker413"/><span class="koboSpan" id="kobo.166.1">takes two optional props, </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">name</span></strong><span class="koboSpan" id="kobo.168.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">url</span></strong><span class="koboSpan" id="kobo.170.1">, and</span><a id="_idIndexMarker414"/><span class="koboSpan" id="kobo.171.1"> displays an image using the URL provided. </span><span class="koboSpan" id="kobo.171.2">If the </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">name</span></strong><span class="koboSpan" id="kobo.173.1"> prop is also provided, it wraps the image in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">Tooltip</span></strong><span class="koboSpan" id="kobo.175.1"> component that shows the name when hovered over. </span><span class="koboSpan" id="kobo.175.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">div</span></strong><span class="koboSpan" id="kobo.177.1"> tag is styled with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">rounded</span></strong><span class="koboSpan" id="kobo.179.1"> class, which will present the avatar in a circle.</span></p>
<p><span class="koboSpan" id="kobo.180.1">The original code for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">Avatar</span></strong><span class="koboSpan" id="kobo.182.1"> component tightly coupled it to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">Tooltip</span></strong><span class="koboSpan" id="kobo.184.1"> feature. </span><span class="koboSpan" id="kobo.184.2">As users demanded more customization options for the tooltip, maintaining this coupling became challenging. </span><span class="koboSpan" id="kobo.184.3">Adding more props to handle tooltip customization can bloat the </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">Avatar</span></strong><span class="koboSpan" id="kobo.186.1"> component and create a ripple effect: any change in </span><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">Tooltip</span></strong><span class="koboSpan" id="kobo.188.1"> may necessitate changes in </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">Avatar</span></strong><span class="koboSpan" id="kobo.190.1">, making it hard to manage.</span></p>
<p><span class="koboSpan" id="kobo.191.1">Instead of forcing </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">Tooltip</span></strong><span class="koboSpan" id="kobo.193.1"> into </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">Avatar</span></strong><span class="koboSpan" id="kobo.195.1">, we can simplify </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">Avatar</span></strong><span class="koboSpan" id="kobo.197.1"> to focus solely on its primary function—displaying an image. </span><span class="koboSpan" id="kobo.197.2">This stripped-down version excludes the tooltip, reducing its bundle size and making it more maintainable. </span><span class="koboSpan" id="kobo.197.3">Here’s how the simplified </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">Avatar</span></strong><span class="koboSpan" id="kobo.199.1"> component looks:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.200.1">
const Avatar = ({ name = "", url }: AvatarProps) =&gt; (
  &lt;div className="rounded"&gt;
    &lt;img src={url} alt={name} title={name} /&gt;
  &lt;/div&gt;
);</span></pre> <p><span class="koboSpan" id="kobo.201.1">By doing so, we make the </span><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">Avatar</span></strong><span class="koboSpan" id="kobo.203.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">Tooltip</span></strong><span class="koboSpan" id="kobo.205.1"> components composable, meaning they can work independently of each other. </span><span class="koboSpan" id="kobo.205.2">The consumer can then choose to wrap </span><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">Avatar</span></strong><span class="koboSpan" id="kobo.207.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">Tooltip</span></strong><span class="koboSpan" id="kobo.209.1"> if desired, as shown in the following code snippet:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.210.1">
import Avatar from "@xui/avatar";
import Tooltip from "@xui/tooltip";
const MyAvatar = (props) =&gt; (
  &lt;Tooltip
    content="Juntao Qiu"
  &gt;
    &lt;Avatar
      name="Juntao Qiu"
      url="https://avatars.githubusercontent.com/u/122324"
    /&gt;
  &lt;/Tooltip&gt;
);</span></pre> <p><span class="koboSpan" id="kobo.211.1">The code imports </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">Avatar</span></strong><span class="koboSpan" id="kobo.213.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">Tooltip</span></strong><span class="koboSpan" id="kobo.215.1"> components from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">"@xui"</span></strong><span class="koboSpan" id="kobo.217.1"> library. </span><span class="koboSpan" id="kobo.217.2">It then defines a </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">MyAvatar</span></strong><span class="koboSpan" id="kobo.219.1"> component that displays an avatar for </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">"Juntao Qiu"</span></strong><span class="koboSpan" id="kobo.221.1"> (if there isn’t a name needed here, we don’t use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">Tooltip</span></strong><span class="koboSpan" id="kobo.223.1"> component). </span><span class="koboSpan" id="kobo.223.2">When you hover over the avatar, a tooltip appears on top with the name </span><strong class="bold"><span class="koboSpan" id="kobo.224.1">Juntao Qiu</span></strong><span class="koboSpan" id="kobo.225.1"> in a design customized</span><a id="_idIndexMarker415"/><span class="koboSpan" id="kobo.226.1"> with a white </span><a id="_idIndexMarker416"/><span class="koboSpan" id="kobo.227.1">font color on a blue background.</span></p>
<p><span class="koboSpan" id="kobo.228.1">The benefit of this approach is twofold:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.229.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">Avatar</span></strong><span class="koboSpan" id="kobo.231.1"> component remains lean, reducing its bundle size</span></li>
<li><span class="koboSpan" id="kobo.232.1">The consumer has the freedom to customize </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">Tooltip</span></strong><span class="koboSpan" id="kobo.234.1"> or even use different tooltip libraries without affecting </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">Avatar</span></strong></li>
</ul>
<p><span class="koboSpan" id="kobo.236.1">In short, the separation makes the code more modular, and users only have to “pay” in terms of code and complexity for the features they actually use.</span></p>
<p><span class="koboSpan" id="kobo.237.1">In both the </span><a id="_idIndexMarker417"/><span class="koboSpan" id="kobo.238.1">render props and composition examples, we</span><a id="_idIndexMarker418"/><span class="koboSpan" id="kobo.239.1"> underlined the essence of the SRP in modern web development. </span><span class="koboSpan" id="kobo.239.2">The SRP advocates for building components that do one thing and do it well, making them more maintainable, reusable, and flexible.</span></p>
<p><span class="koboSpan" id="kobo.240.1">Next, let’s pivot to discussing the DIP, another crucial perspective that complements the</span><a id="_idTextAnchor238"/><span class="koboSpan" id="kobo.241.1">se design principles.</span></p>
<h1 id="_idParaDest-132"><a id="_idTextAnchor239"/><span class="koboSpan" id="kobo.242.1">Embracing the Dependency Inversion Principle</span></h1>
<p><span class="koboSpan" id="kobo.243.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.244.1">DIP</span></strong><span class="koboSpan" id="kobo.245.1"> is</span><a id="_idIndexMarker419"/><span class="koboSpan" id="kobo.246.1"> one of the five principles that make up SOLID, a set of guidelines aimed at helping developers create more maintainable, flexible, and scalable software. </span><span class="koboSpan" id="kobo.246.2">Specifically, the DIP encourages developers to depend on abstractions, not on concrete implementations.</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.247.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.248.1">The five principles of SOLID are the Single Responsibility Principle, Open-Closed Principle, Liskov Substitution Principle, Interface Segregation Principle, and Dependency Inversion Principle.</span></p>
<p><span class="koboSpan" id="kobo.249.1">The DIP addresses several challenges that developers face when building and maintaining large systems. </span><span class="koboSpan" id="kobo.249.2">One such problem is the rigidity that comes from tightly coupled modules. </span><span class="koboSpan" id="kobo.249.3">When high-level modules are dependent on low-level modules, even small changes to the low-level code can have a broad impact, necessitating changes across the system.</span></p>
<h2 id="_idParaDest-133"><a id="_idTextAnchor240"/><span class="koboSpan" id="kobo.250.1">Understanding how the DIP works</span></h2>
<p><span class="koboSpan" id="kobo.251.1">In terms of </span><a id="_idIndexMarker420"/><span class="koboSpan" id="kobo.252.1">high-level modules and low-level modules, let’s think of a notification feature in a system. </span><span class="koboSpan" id="kobo.252.2">Here, we want to send out a notification in a form that the user prefers, either an email, an SMS message, or both:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.253.1">
class EmailNotification {
  send(message: string, type: string) {
    console.log(`Sending email with message: ${message}, type: ${type}`);
  }
}
class Application {
  private emailNotification: EmailNotification;
  constructor(emailNotification: EmailNotification) {
    this.emailNotification = emailNotification;
  }
  process() {
    // perform some actions to response user interaction
    this.emailNotification.send("Some events happened", "info");
  }
}
const app = new Application(new EmailNotification());
app.process();</span></pre> <p><span class="koboSpan" id="kobo.254.1">In the code, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">EmailNotification</span></strong><span class="koboSpan" id="kobo.256.1"> class has a method called </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">send</span></strong><span class="koboSpan" id="kobo.258.1"> that takes </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">message</span></strong><span class="koboSpan" id="kobo.260.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">type</span></strong><span class="koboSpan" id="kobo.262.1"> as parameters. </span><span class="koboSpan" id="kobo.262.2">It </span><a id="_idIndexMarker421"/><span class="koboSpan" id="kobo.263.1">then prints out a log to indicate that an email with this </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">message</span></strong><span class="koboSpan" id="kobo.265.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">type</span></strong><span class="koboSpan" id="kobo.267.1"> is being sent. </span><span class="koboSpan" id="kobo.267.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">Application</span></strong><span class="koboSpan" id="kobo.269.1"> class, on the other hand, has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">process</span></strong><span class="koboSpan" id="kobo.271.1"> method that simulates some kind of user interaction. </span><span class="koboSpan" id="kobo.271.2">Inside this method, </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">Application</span></strong><span class="koboSpan" id="kobo.273.1"> uses an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">EmailNotification</span></strong><span class="koboSpan" id="kobo.275.1"> to send an email whenever </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">process</span></strong><span class="koboSpan" id="kobo.277.1"> is invoked.</span></p>
<p><span class="koboSpan" id="kobo.278.1">One important thing to note here is that </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">Application</span></strong><span class="koboSpan" id="kobo.280.1"> is tightly coupled to </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">EmailNotification</span></strong><span class="koboSpan" id="kobo.282.1">. </span><span class="koboSpan" id="kobo.282.2">This means that if you wanted to change how notifications are sent, perhaps by using SMS instead of email, you’d have to modify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">Application</span></strong><span class="koboSpan" id="kobo.284.1"> class directly, thereby violating the SRP and making the system less flexible.</span></p>
<p><span class="koboSpan" id="kobo.285.1">So, to resolve the problem, we can introduce a </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">Notification</span></strong><span class="koboSpan" id="kobo.287.1"> interface and let </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">EmailNotification</span></strong><span class="koboSpan" id="kobo.289.1"> implement the interface. </span><span class="koboSpan" id="kobo.289.2">That means we could have multiple implementations of the interface. </span><span class="koboSpan" id="kobo.289.3">Plus, instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">Application</span></strong><span class="koboSpan" id="kobo.291.1"> depending on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">EmailNotification</span></strong><span class="koboSpan" id="kobo.293.1"> class, </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">Application</span></strong><span class="koboSpan" id="kobo.295.1"> depends on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">Notification</span></strong><span class="koboSpan" id="kobo.297.1"> interface. </span><span class="koboSpan" id="kobo.297.2">Because we</span><a id="_idIndexMarker422"/><span class="koboSpan" id="kobo.298.1"> rely on the interface, from </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">Application</span></strong><span class="koboSpan" id="kobo.300.1">’s view, it doesn’t matter which concrete implementation is passed in, as long as it implements the </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">Notification</span></strong><span class="koboSpan" id="kobo.302.1"> interface – that means we could easily swap it to an </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">SMSNotification</span></strong><span class="koboSpan" id="kobo.304.1"> class if we like. </span><span class="koboSpan" id="kobo.304.2">Here’s what the code for all of this will look like:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.305.1">
interface Notification {
  send(message: string, type: string): void;
}
class EmailNotification implements Notification {
  send(message: string, type: string) {
    console.log(`Sending email with message: ${message}, type: 
     ${type}`);
  }
}
class Application {
  private notifier: Notification;
  constructor(notifier: Notification) {
    this.notifier = notifier;
  }
  process() {
    // perform some actions to response user interaction
    this.notifier.send("Some event happened", "info");
  }
}</span></pre> <p><span class="koboSpan" id="kobo.306.1">The code </span><a id="_idIndexMarker423"/><span class="koboSpan" id="kobo.307.1">defines a </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">Notification</span></strong><span class="koboSpan" id="kobo.309.1"> interface with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">send</span></strong><span class="koboSpan" id="kobo.311.1"> method, which is then implemented by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">EmailNotification</span></strong><span class="koboSpan" id="kobo.313.1"> class. </span><span class="koboSpan" id="kobo.313.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">Application</span></strong><span class="koboSpan" id="kobo.315.1"> class is now constructed with any object that adheres to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">Notification</span></strong><span class="koboSpan" id="kobo.317.1"> interface. </span><span class="koboSpan" id="kobo.317.2">Within its </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">process</span></strong><span class="koboSpan" id="kobo.319.1"> method, </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">Application</span></strong><span class="koboSpan" id="kobo.321.1"> uses this object to send a notification. </span><span class="koboSpan" id="kobo.321.2">This setup decouples the </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">Application</span></strong><span class="koboSpan" id="kobo.323.1"> class from the specific notification mechanism, making it more flexible and easier to change or extend.</span></p>
<p><span class="koboSpan" id="kobo.324.1">For instance, if we decide to replace </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">EmailNotification</span></strong><span class="koboSpan" id="kobo.326.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">SMSNotification</span></strong><span class="koboSpan" id="kobo.328.1">, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">Application</span></strong><span class="koboSpan" id="kobo.330.1"> class won’t need any modifications; we would simply provide a different instance that implements the </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">Notification</span></strong><span class="koboSpan" id="kobo.332.1"> interface:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.333.1">
const app = new Application(new EmailNotification());
app.process();
// or
const app = new Application(new SMSNotification());
app.process();</span></pre> <p><span class="koboSpan" id="kobo.334.1">All right – that’s briefly about how the DIP works. </span><span class="koboSpan" id="kobo.334.2">Let’s look at another example to find out how to apply the same principle i</span><a id="_idTextAnchor241"/><span class="koboSpan" id="kobo.335.1">nside a React application.</span></p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor242"/><span class="koboSpan" id="kobo.336.1">Applying the DIP in an analytics button</span></h2>
<p><span class="koboSpan" id="kobo.337.1">Now, imagine </span><a id="_idIndexMarker424"/><span class="koboSpan" id="kobo.338.1">you have a generic button component that’s used across various parts of your application. </span><span class="koboSpan" id="kobo.338.2">You want to send analytics events when the button is clicked, but how exactly those events are sent should be abstracted away from the button component itself.</span></p>
<p><span class="koboSpan" id="kobo.339.1">The problem is that generic buttons are widely used in many products already, and not all of them need the analytics functionality. </span><span class="koboSpan" id="kobo.339.2">So, if you simply change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">onClick</span></strong><span class="koboSpan" id="kobo.341.1"> handler in the shared </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">Button</span></strong><span class="koboSpan" id="kobo.343.1"> component, it will annoy many innocent users.</span></p>
<p><span class="koboSpan" id="kobo.344.1">Let’s have a look at the current </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">Button</span></strong><span class="koboSpan" id="kobo.346.1"> implementation:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.347.1">
const Button = ({ onClick: provided, name, ...rest }: ButtonProps) =&gt; {
  const onClick = (e) =&gt; {
    // emit an event to the analytic server
    return provided(e);
  };
  return &lt;button onClick={onClick} {...rest} /&gt;;
};</span></pre> <p><span class="koboSpan" id="kobo.348.1">Instead, we could define a new component that wraps the original button around and hijacks the click handler for the analysis:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.349.1">
import { Button } from "@xui/button";
const FancyButton = ({
  onClick: originalOnClick,
  ...rest
}: FancyButtonProps) =&gt; {
  const onClick = (e) =&gt; {
    //emit an event to the analytic server
    console.log('sending analytics event to a remote server');
    return originalOnClick(e);
  };
  return &lt;Button onClick={onClick} {...rest} /&gt;;
};</span></pre> <p><span class="koboSpan" id="kobo.350.1">The new code </span><a id="_idIndexMarker425"/><span class="koboSpan" id="kobo.351.1">defines a </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">FancyButton</span></strong><span class="koboSpan" id="kobo.353.1"> component that wraps around a basic </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">Button</span></strong><span class="koboSpan" id="kobo.355.1"> component. </span><span class="koboSpan" id="kobo.355.2">When clicked, </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">FancyButton</span></strong><span class="koboSpan" id="kobo.357.1"> first sends an analytics event to a remote server and then proceeds to execute the original </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">onClick</span></strong><span class="koboSpan" id="kobo.359.1"> function passed to it. </span><span class="koboSpan" id="kobo.359.2">All other props are passed down directly to the underlying </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">Button</span></strong><span class="koboSpan" id="kobo.361.1"> component.</span></p>
<p><span class="koboSpan" id="kobo.362.1">The issue here is that many instances where the </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">Button</span></strong><span class="koboSpan" id="kobo.364.1"> component is used might contain similar analytics code, leading to repetitive logic across the code base. </span><span class="koboSpan" id="kobo.364.2">This redundancy is undesirable, as any changes to the analytics logic would require updates in multiple locations, increasing the risk of errors.</span></p>
<p><span class="koboSpan" id="kobo.365.1">So, let’s consider the DIP. </span><span class="koboSpan" id="kobo.365.2">We will make some changes in the original </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">Button</span></strong><span class="koboSpan" id="kobo.367.1"> component, but instead of sending analytics events directly, we’ll first extract an interface and make the button rely on the interface (keep in mind there could be multiple implementations of that interface).</span></p>
<p><span class="koboSpan" id="kobo.368.1">Just as with the previous </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">Notification</span></strong><span class="koboSpan" id="kobo.370.1"> example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">EmailNotification</span></strong><span class="koboSpan" id="kobo.372.1"> is one of the notification channels that send email. </span><span class="koboSpan" id="kobo.372.2">In this button example, one of the implementations sends an event, whereas for products that don’t use analytics at all, they just pass in an empty implementation.</span></p>
<p><span class="koboSpan" id="kobo.373.1">To make the change, we’ll need to define a new interface type, and we need a context for the implementation of the interface to live in:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.374.1">
import { createContext } from "react";
export interface InteractionMeasurement {
  measure(name: string | undefined, timestamp?: number): void;
}
export default createContext&lt;InteractionMeasurement | null&gt;(null);</span></pre> <p><span class="koboSpan" id="kobo.375.1">This code creates a</span><a id="_idIndexMarker426"/><span class="koboSpan" id="kobo.376.1"> React context named </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">InteractionMeasurement</span></strong><span class="koboSpan" id="kobo.378.1"> with an interface that specifies a </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">measure</span></strong><span class="koboSpan" id="kobo.380.1"> method. </span><span class="koboSpan" id="kobo.380.2">This method takes a name (either a string or undefined) and an optional timestamp, while the context is initialized as </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">null</span></strong><span class="koboSpan" id="kobo.382.1">.</span></p>
<p><span class="koboSpan" id="kobo.383.1">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">Button</span></strong><span class="koboSpan" id="kobo.385.1"> component, we can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">useContext</span></strong><span class="koboSpan" id="kobo.387.1"> to access the context we defined:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.388.1">
import InteractionContext, {
  InteractionMeasurement
} from "./InteractionContext";
const Button = ({ name, onClick: providedOnClick, children }: ButtonType) =&gt; {
  const interactionContext = useContext&lt;InteractionMeasurement | 
   null&gt;(
    InteractionContext
  );
  const handleClick = useCallback(
    (e) =&gt; {
      interactionContext &amp;&amp;
      interactionContext.measure(name, e.timeStamp);
      providedOnClick(e);
    },
    [providedOnClick, interactionContext, name]
  );
  return &lt;button onClick={handleClick}&gt;{children}&lt;/button&gt;;
};</span></pre> <p><span class="koboSpan" id="kobo.389.1">The code defines a </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">Button</span></strong><span class="koboSpan" id="kobo.391.1"> component that uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">InteractionContext</span></strong><span class="koboSpan" id="kobo.393.1"> to track clicks. </span><span class="koboSpan" id="kobo.393.2">When the button is clicked, it calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">measure</span></strong><span class="koboSpan" id="kobo.395.1"> method from the context, passing in the button’s name and the click event’s timestamp. </span><span class="koboSpan" id="kobo.395.2">Then, it proceeds to execute any additional </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">onClick</span></strong><span class="koboSpan" id="kobo.397.1"> logic provided. </span><span class="koboSpan" id="kobo.397.2">This way, click tracking is abstracted away into the context, making the </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">Button</span></strong><span class="koboSpan" id="kobo.399.1"> component more reusable and maintainable.</span></p>
<p><span class="koboSpan" id="kobo.400.1">If </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">interactionContext</span></strong><span class="koboSpan" id="kobo.402.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">null</span></strong><span class="koboSpan" id="kobo.404.1">, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">measure</span></strong><span class="koboSpan" id="kobo.406.1"> function won’t be called, and the component will</span><a id="_idIndexMarker427"/><span class="koboSpan" id="kobo.407.1"> proceed to execute only the </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">providedOnClick</span></strong><span class="koboSpan" id="kobo.409.1"> function passed in as a prop. </span><span class="koboSpan" id="kobo.409.2">This allows for optional analytics tracking based on the availability of </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">InteractionContext</span></strong><span class="koboSpan" id="kobo.411.1">.</span></p>
<p><span class="koboSpan" id="kobo.412.1">That would perfectly resolve the problem we have – if a product wants to enable the analytics, they can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">Button</span></strong><span class="koboSpan" id="kobo.414.1"> within a context that contains an </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">InteractionMeasurement</span></strong><span class="koboSpan" id="kobo.416.1"> implementation.</span></p>
<p><span class="koboSpan" id="kobo.417.1">Having said that, let’s say we have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">FormApp</span></strong><span class="koboSpan" id="kobo.419.1"> application that uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">Button</span></strong><span class="koboSpan" id="kobo.421.1"> inside an </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">InteractionContext</span></strong><span class="koboSpan" id="kobo.423.1"> instance:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.424.1">
import InteractionContext from "./InteractionContext";
import { Button } from "@xui/button";
const FormApp = () =&gt; {
  const context = {
    measure: (e, t) =&gt; {
      //send event and timestamp to remote
      console.log(`sending to remote server  ${e}: ${t}`);
    },
  };
  const onClick = () =&gt; {
    console.log("submit");
  };
  return (
    &lt;InteractionContext.Provider value={context}&gt;
      &lt;form&gt;
        &lt;Button name="submit-button" onClick={onClick}&gt;
          Submit
        &lt;/Button&gt;
      &lt;/form&gt;
    &lt;/InteractionContext.Provider&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.425.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">FormApp</span></strong><span class="koboSpan" id="kobo.427.1"> component defines its own analytics logic in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">measure</span></strong><span class="koboSpan" id="kobo.429.1"> function inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">context</span></strong><span class="koboSpan" id="kobo.431.1"> object. </span><span class="koboSpan" id="kobo.431.2">It then passes this function to child components through </span><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">InteractionContext.Provider</span></strong><span class="koboSpan" id="kobo.433.1">. </span><span class="koboSpan" id="kobo.433.2">When a button inside the form is clicked, not only will the button’s specific </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">onClick</span></strong><span class="koboSpan" id="kobo.435.1"> logic be executed, but the </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">measure</span></strong><span class="koboSpan" id="kobo.437.1"> function will also send event and timestamp data to a remote server for analytics. </span><span class="koboSpan" id="kobo.437.2">This setup allows for context-based analytics without tying the </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">Button</span></strong><span class="koboSpan" id="kobo.439.1"> component to a specific implementation.</span></p>
<p><span class="koboSpan" id="kobo.440.1">For users who don’t want the analytics functionality, they can just use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">Button</span></strong><span class="koboSpan" id="kobo.442.1"> component as usual:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.443.1">
import { Button } from "@xui/button";
const App = () =&gt; {
  const onClick = () =&gt; {
    console.log("checkout");
  };
  return (
    &lt;Button name="checkout-button" onClick={onClick}&gt;
      Checkout
    &lt;/Button&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.444.1">This methodology offers exceptional flexibility and dynamism, making it invaluable for designing common components. </span><span class="koboSpan" id="kobo.444.2">It enhances both code reusability and system maintainability while also reducing the overall bundle size.</span></p>
<p><span class="koboSpan" id="kobo.445.1">Be aware that adding an extra </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">context</span></strong><span class="koboSpan" id="kobo.447.1"> object in such scenarios may initially seem excessive. </span><span class="koboSpan" id="kobo.447.2">However, in large code bases where different teams work on distinct parts, this approach becomes more relevant. </span><span class="koboSpan" id="kobo.447.3">For instance, a product team focused on analysis might have different objectives compared to a design system team, whose aim is to develop generic and atomic components. </span><span class="koboSpan" id="kobo.447.4">The design system team may not be concerned with analytical aspects. </span><span class="koboSpan" id="kobo.447.5">Consequently, directly modifying the </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">Button</span></strong><span class="koboSpan" id="kobo.449.1"> component in this</span><a id="_idIndexMarker428"/><span class="koboSpan" id="kobo.450.1"> environment can be impractical or challenging.</span></p>
<p><span class="koboSpan" id="kobo.451.1">Having that said, I would like to introduce another design principle I constantly use in my code; you can think of it as a special form of the SRP at its</span><a id="_idTextAnchor243"/><span class="koboSpan" id="kobo.452.1"> core. </span><span class="koboSpan" id="kobo.452.2">This principle is CQRS.</span></p>
<h1 id="_idParaDest-135"><a id="_idTextAnchor244"/><span class="koboSpan" id="kobo.453.1">Understanding Command and Query Responsibility Segregation in React</span></h1>
<p><span class="koboSpan" id="kobo.454.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.455.1">Command and Query Responsibility Segregation</span></strong><span class="koboSpan" id="kobo.456.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.457.1">CQRS</span></strong><span class="koboSpan" id="kobo.458.1">) principle (also known as the </span><strong class="bold"><span class="koboSpan" id="kobo.459.1">Separation of Command and Query Principle</span></strong><span class="koboSpan" id="kobo.460.1">) is a software design principle that </span><a id="_idIndexMarker429"/><span class="koboSpan" id="kobo.461.1">suggests that methods or functions should either be commands that modify the system’s state or queries that return information about the system’s state, but not both.</span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.462.1">Commands</span></strong><span class="koboSpan" id="kobo.463.1"> (or </span><strong class="bold"><span class="koboSpan" id="kobo.464.1">modifiers</span></strong><span class="koboSpan" id="kobo.465.1">) are </span><a id="_idIndexMarker430"/><span class="koboSpan" id="kobo.466.1">methods that perform an action or change the state of an object without returning a value. </span><strong class="bold"><span class="koboSpan" id="kobo.467.1">Queries</span></strong><span class="koboSpan" id="kobo.468.1">, on the other hand, are methods to read an object’s state without any </span><a id="_idIndexMarker431"/><span class="koboSpan" id="kobo.469.1">changes. </span><span class="koboSpan" id="kobo.469.2">Separating commands and queries can help reduce coupling between components, making testing, maintaining, and modifying code easier. </span><span class="koboSpan" id="kobo.469.3">It also makes it easier to reason about the behavior of code and can improve the overall design of a system.</span></p>
<p><span class="koboSpan" id="kobo.470.1">Although this pattern is widely used on a large scale, such as in designing the architecture of systems, it works well at the code level as well. </span><span class="koboSpan" id="kobo.470.2">I will demonstrate this in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">ShoppingCart</span></strong><span class="koboSpan" id="kobo.472.1"> component:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.473.1">
type Item = {
  id: string;
  name: string;
  price: number;
}
const ShoppingApplication = () =&gt; {
  const [cart, setCart] = useState&lt;Item[]&gt;([]);
  const addItemToCart = (item: Item) =&gt; {
    setCart([...cart, item]);
  };
  const removeItemFromCart = (id: string) =&gt; {
    setCart(cart.filter((item) =&gt; item.id !== id));
  };
  const totalPrice = cart.reduce((total, item) =&gt; total + item.price, 
   0);
  return (
    &lt;div&gt;
      &lt;ProductList addToCart={addItemToCart} /&gt;
      &lt;h2&gt;Shopping Cart&lt;/h2&gt;
      &lt;ul&gt;
        {cart.map((item) =&gt; (
          &lt;li key={item.id}&gt;
            {item.name} - {item.price}
            &lt;button onClick={() =&gt; removeItemFromCart(item.
</span><span class="koboSpan" id="kobo.473.2">             id)}&gt;Remove&lt;/button&gt;
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
      &lt;p&gt;Total Price: {totalPrice}&lt;/p&gt;
    &lt;/div&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.474.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">ShoppingApplication</span></strong><span class="koboSpan" id="kobo.476.1"> component maintains a shopping cart using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">useState</span></strong><span class="koboSpan" id="kobo.478.1"> Hook with an array of items of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">Item</span></strong><span class="koboSpan" id="kobo.480.1">. </span><span class="koboSpan" id="kobo.480.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">addItemToCart</span></strong><span class="koboSpan" id="kobo.482.1"> function adds new items to the cart, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">removeItemFromCart</span></strong><span class="koboSpan" id="kobo.484.1"> removes items based on their </span><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">id</span></strong><span class="koboSpan" id="kobo.486.1"> value. </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">totalPrice</span></strong><span class="koboSpan" id="kobo.488.1"> is calculated as the sum of all item prices in the cart.</span></p>
<p><span class="koboSpan" id="kobo.489.1">The component renders a list of items in the cart, along with their total price. </span><span class="koboSpan" id="kobo.489.2">Each item has a </span><strong class="bold"><span class="koboSpan" id="kobo.490.1">Remove</span></strong><span class="koboSpan" id="kobo.491.1"> button that calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.492.1">removeItemFromCart</span></strong><span class="koboSpan" id="kobo.493.1"> when clicked. </span><span class="koboSpan" id="kobo.493.2">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">ProductList</span></strong><span class="koboSpan" id="kobo.495.1"> component is also rendered, and it receives </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">addItemToCart</span></strong><span class="koboSpan" id="kobo.497.1"> as a prop for adding products to the cart.</span></p>
<p><span class="koboSpan" id="kobo.498.1">The previous code </span><a id="_idIndexMarker432"/><span class="koboSpan" id="kobo.499.1">appears to be okay at first glance, but it contains some subtle issues. </span><span class="koboSpan" id="kobo.499.2">One problem is that when multiple identical products are added to the cart, the keys will overlap, triggering React’s warning about unique keys. </span><span class="koboSpan" id="kobo.499.3">Additionally, if you click the </span><strong class="bold"><span class="koboSpan" id="kobo.500.1">Remove</span></strong><span class="koboSpan" id="kobo.501.1"> button in this situation, it will delete all instances of that product from the cart, which is far from ideal and leads to a poor user experience.</span></p>
<p><span class="koboSpan" id="kobo.502.1">To fix these issues, we need to introduce a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">uniqKey</span></strong><span class="koboSpan" id="kobo.504.1"> field to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">Item</span></strong><span class="koboSpan" id="kobo.506.1"> type. </span><span class="koboSpan" id="kobo.506.2">We also need to generate a unique key before an item is inserted into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">cart</span></strong><span class="koboSpan" id="kobo.508.1"> array. </span><span class="koboSpan" id="kobo.508.2">With that unique ID, we are finally able to remove items by </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">uniqKey</span></strong><span class="koboSpan" id="kobo.510.1"> instead of by </span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">id</span></strong><span class="koboSpan" id="kobo.512.1">. </span><span class="koboSpan" id="kobo.512.2">This is what the code will look like:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.513.1">
const addItemToCart = (item: Item) =&gt; {
  setCart([...cart, { ...item, uniqKey: `${item.id}-${Date.now()}` }]);
};
const removeItemFromCart = (key: string) =&gt; {
  setCart(cart.filter((item) =&gt; item.uniqKey !== key));
};</span></pre> <p><span class="koboSpan" id="kobo.514.1">We also need to update how the cart is rendered in JSX:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.515.1">
&lt;h2&gt;Shopping Cart&lt;/h2&gt;
&lt;ul&gt;
  {cart.map((item) =&gt; (
    &lt;li key={item.uniqKey}&gt;
      {item.name} - {item.price}
      &lt;button onClick={() =&gt; removeItemFromCart(item.uniqKey)}&gt;
        Remove
      &lt;/button&gt;
    &lt;/li&gt;
  ))}
&lt;/ul&gt;</span></pre> <p><span class="koboSpan" id="kobo.516.1">While the</span><a id="_idIndexMarker433"/><span class="koboSpan" id="kobo.517.1"> code is technically sound and sufficiently straightforward for its current scope, as we expand the </span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">ShoppingApplication</span></strong><span class="koboSpan" id="kobo.519.1"> component with more states and calculations, applying the CQRS principle could provide a structured way to keep everything organized.</span></p>
<p><span class="koboSpan" id="kobo.520.1">We’ll use the React Context API and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">useReducer</span></strong><span class="koboSpan" id="kobo.522.1"> Hook to implement CQRS for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">ShoppingApplication</span></strong><span class="koboSpan" id="kobo.524.1"> compo</span><a id="_idTextAnchor245"/><span class="koboSpan" id="kobo.525.1">nent. </span><span class="koboSpan" id="kobo.525.2">Let’s take a look at them now.</span></p>
<h2 id="_idParaDest-136"><a id="_idTextAnchor246"/><span class="koboSpan" id="kobo.526.1">Introducing useReducer</span></h2>
<p><span class="koboSpan" id="kobo.527.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">useReducer</span></strong><span class="koboSpan" id="kobo.529.1"> Hook</span><a id="_idIndexMarker434"/><span class="koboSpan" id="kobo.530.1"> in React is used for state management in functional components; it is particularly useful when the next state depends on the previous one or when you have complex state logic. </span><span class="koboSpan" id="kobo.530.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">useReducer</span></strong><span class="koboSpan" id="kobo.532.1"> Hook takes two arguments: a reducer function and an initial state, and it returns the current state and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">dispatch</span></strong><span class="koboSpan" id="kobo.534.1"> method to trigger updates.</span></p>
<p><span class="koboSpan" id="kobo.535.1">For the first parameter, a reducer function receives the current state and an </span><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">action</span></strong><span class="koboSpan" id="kobo.537.1"> object, which contains information on how to update the state. </span><span class="koboSpan" id="kobo.537.2">The function should return the new state based on the action type and payload. </span><span class="koboSpan" id="kobo.537.3">The second parameter is the initial state you want to pass in and will be used as the default value when invoked.</span></p>
<p><span class="koboSpan" id="kobo.538.1">Let’s define a reducer function for our </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">ShoppingApplication</span></strong><span class="koboSpan" id="kobo.540.1"> component:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.541.1">
type ShoppingCartState = {
  items: Item[];
  totalPrice: number;
};
type ActionType = {
  type: string;
  payload: Item;
};
const shoppingCartReducer = (
  state: ShoppingCartState = initState,
  action: ActionType
) =&gt; {
  switch (action.type) {
    case "ADD_ITEM": {
      const item = {
        ...action.payload,
        uniqKey: `${action.payload.id}-${Date.now()}`,
      };
      return { ...state, items: [...state.items, item] };
    }
    case "REMOVE_ITEM":
      const newItems = state.items.filter(
        (item) =&gt; item.uniqKey !== action.payload.uniqKey
      );
      return { ...state, items: newItems };
    default:
      return state;
  }
};</span></pre> <p><span class="koboSpan" id="kobo.542.1">So, </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">shoppingCartReducer</span></strong><span class="koboSpan" id="kobo.544.1"> is a function that takes two arguments – the current state and an action:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.545.1">The state is of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">ShoppingCartState</span></strong><span class="koboSpan" id="kobo.547.1">, which includes an array of items and </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">totalPrice</span></strong></li>
<li><span class="koboSpan" id="kobo.549.1">The action is of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">ActionType</span></strong><span class="koboSpan" id="kobo.551.1">, which includes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">string</span></strong><span class="koboSpan" id="kobo.553.1"> type to identify the action and a payload containing an </span><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">Item</span></strong><span class="koboSpan" id="kobo.555.1"> object</span></li>
</ul>
<p><span class="koboSpan" id="kobo.556.1">Inside the reducer function, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">switch</span></strong><span class="koboSpan" id="kobo.558.1"> statement is used to determine which action is being dispatched. </span><span class="koboSpan" id="kobo.558.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">"ADD_ITEM"</span></strong><span class="koboSpan" id="kobo.560.1"> case adds a new item to the state’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">items</span></strong><span class="koboSpan" id="kobo.562.1"> array. </span><span class="koboSpan" id="kobo.562.2">This item is given a unique key, </span><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">uniqKey</span></strong><span class="koboSpan" id="kobo.564.1">, to differentiate it from identical items. </span><span class="koboSpan" id="kobo.564.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">"REMOVE_ITEM"</span></strong><span class="koboSpan" id="kobo.566.1"> case removes an item from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">items</span></strong><span class="koboSpan" id="kobo.568.1"> array based on this unique key.</span></p>
<p><span class="koboSpan" id="kobo.569.1">By using this </span><a id="_idIndexMarker435"/><span class="koboSpan" id="kobo.570.1">structure, the reducer function provides a predictable way to manage the shopping cart’s state in response to different actions. </span><span class="koboSpan" id="kobo.570.2">Note there is nothing fancy here in this reducer function; it’s just a regular JavaScript function. </span><span class="koboSpan" id="kobo.570.3">To see how it works, we could test the reducer function with the following code:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.571.1">
const item = {
  id: "p1",
  name: "iPad",
  price: 666,
};
let x = shoppingCartReducer(initState, {
  type: "ADD_ITEM",
  payload: item,
});
console.log(x);</span></pre> <p><span class="koboSpan" id="kobo.572.1">And we would get something like this (obviously, your </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">uniqKey</span></strong><span class="koboSpan" id="kobo.574.1"> value would be different from mine as it’s generated by the time an item is added):</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.575.1">
{
    "items": [
        {
            "id": "p1",
            "name": "iPad",
            "price": 666,
            "uniqKey": "p1-1696059737801"
        }
    ],
    "totalPrice": 0
}</span></pre> <p><span class="koboSpan" id="kobo.576.1">All right – that </span><a id="_idIndexMarker436"/><span class="koboSpan" id="kobo.577.1">should give a taste of what a reducer function is and how it works with any given input. </span><span class="koboSpan" id="kobo.577.2">Now, let’s see how w</span><a id="_idTextAnchor247"/><span class="koboSpan" id="kobo.578.1">e can connect it with our application.</span></p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor248"/><span class="koboSpan" id="kobo.579.1">Using a reducer function in a context</span></h2>
<p><span class="koboSpan" id="kobo.580.1">Let’s see how we can use a</span><a id="_idIndexMarker437"/><span class="koboSpan" id="kobo.581.1"> reducer function to implement CQRS to simplify our shopping cart example. </span><span class="koboSpan" id="kobo.581.2">Firstly, we’ll need a context to manage the cart state, and also expose query functions for components to use:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.582.1">
import React, { createContext, useContext, useReducer } from "react";
import { Item } from "./type";
type ShoppingCartContextType = {
  items: Item[];
  addItem: (item: Item) =&gt; void;
  removeItem: (item: Item) =&gt; void;
};
const ShoppingCartContext = createContext&lt;ShoppingCartContextType | null&gt;(null);
export const ShoppingCartProvider = ({
  children,
}: {
  children: React.ReactNode;
}) =&gt; {
  const [state, dispatch] = useReducer(shoppingCartReducer, {
    items: [],
    totalPrice: 0,
  });
  const addItem = (item: Item) =&gt; {
    dispatch({type: ADD_ITEM, payload: item});
  };
  const removeItem = (item: Item) =&gt; {
    dispatch({type: REMOVE_ITEM, payload: item});
  };
  return (
    &lt;ShoppingCartContext.Provider value={{items: state.items, addItem, 
     removeItem}}&gt;
      {children}
    &lt;/ShoppingCartContext.Provider&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.583.1">This</span><a id="_idIndexMarker438"/><span class="koboSpan" id="kobo.584.1"> code creates a React context for managing a shopping cart. </span><span class="koboSpan" id="kobo.584.2">Inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">ShoppingCartProvider</span></strong><span class="koboSpan" id="kobo.586.1">, it uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">useReducer</span></strong><span class="koboSpan" id="kobo.588.1"> Hook to handle cart actions. </span><span class="koboSpan" id="kobo.588.2">Two functions, </span><strong class="source-inline"><span class="koboSpan" id="kobo.589.1">addItem</span></strong><span class="koboSpan" id="kobo.590.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.591.1">removeItem</span></strong><span class="koboSpan" id="kobo.592.1">, dispatch actions to modify the cart. </span><span class="koboSpan" id="kobo.592.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.593.1">Provider</span></strong><span class="koboSpan" id="kobo.594.1"> component makes the cart state and these functions available to its child components via </span><strong class="source-inline"><span class="koboSpan" id="kobo.595.1">ShoppingCartContext</span></strong><span class="koboSpan" id="kobo.596.1">. </span><span class="koboSpan" id="kobo.596.2">This allows any nested components to interact with the shopping cart.</span></p>
<p><span class="koboSpan" id="kobo.597.1">Note that </span><strong class="source-inline"><span class="koboSpan" id="kobo.598.1">addItem</span></strong><span class="koboSpan" id="kobo.599.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.600.1">removeItem</span></strong><span class="koboSpan" id="kobo.601.1"> are two command functions in the CQRS principle that only change the state without returning any data. </span><span class="koboSpan" id="kobo.601.2">If we want to get the data, we can define a query function, like so:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.602.1">
export const useTotalPrice = () =&gt; {
  const context = useContext&lt;ShoppingCartContextType&gt;(
    ShoppingCartContext
  );
  const {items} = context;
  return items.reduce((acc, item) =&gt; acc + item.price, 0);
};</span></pre> <p><span class="koboSpan" id="kobo.603.1">Here, we define a custom Hook called </span><strong class="source-inline"><span class="koboSpan" id="kobo.604.1">useTotalPrice</span></strong><span class="koboSpan" id="kobo.605.1"> that calculates the total price of items in</span><a id="_idIndexMarker439"/><span class="koboSpan" id="kobo.606.1"> a shopping cart. </span><span class="koboSpan" id="kobo.606.2">It uses the React </span><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">useContext</span></strong><span class="koboSpan" id="kobo.608.1"> Hook to access the shopping cart data from </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">ShoppingCartContext</span></strong><span class="koboSpan" id="kobo.610.1">. </span><span class="koboSpan" id="kobo.610.2">It then uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">reduce</span></strong><span class="koboSpan" id="kobo.612.1"> method to sum up the prices of all items in the cart, starting with an initial value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">0</span></strong><span class="koboSpan" id="kobo.614.1">.</span></p>
<p><span class="koboSpan" id="kobo.615.1">For the </span><strong class="source-inline"><span class="koboSpan" id="kobo.616.1">ShoppingApplication</span></strong><span class="koboSpan" id="kobo.617.1"> component, we can simply wrap </span><strong class="source-inline"><span class="koboSpan" id="kobo.618.1">ProductList</span></strong><span class="koboSpan" id="kobo.619.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">ShoppingCart</span></strong><span class="koboSpan" id="kobo.621.1"> inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">ShoppingCartContext</span></strong><span class="koboSpan" id="kobo.623.1"> instance we just created:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.624.1">
const ShoppingApplication = () =&gt; {
  const context = useContext(ShoppingCartContext);
  const { items, addItem, removeItem } = context;
  const totalPrice = useTotalPrice();
  return (
    &lt;div&gt;
      &lt;ProductList addToCart={addItem} /&gt;
      &lt;h2&gt;Shopping Cart&lt;/h2&gt;
      &lt;ul&gt;
        {items.map((item) =&gt; (
          &lt;li key={item.uniqKey}&gt;
            {item.name} - {item.price}
            &lt;button onClick={() =&gt; removeItem(item)}&gt;Remove&lt;/button&gt;
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
      &lt;p&gt;Total Price: {totalPrice}&lt;/p&gt;
    &lt;/div&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.625.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.626.1">ShoppingApplication</span></strong><span class="koboSpan" id="kobo.627.1"> component serves as the main interface for the shopping </span><a id="_idIndexMarker440"/><span class="koboSpan" id="kobo.628.1">application. </span><span class="koboSpan" id="kobo.628.2">It uses React’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">useContext</span></strong><span class="koboSpan" id="kobo.630.1"> Hook to access the shopping cart context, which provides a list of items in the cart (</span><strong class="source-inline"><span class="koboSpan" id="kobo.631.1">items</span></strong><span class="koboSpan" id="kobo.632.1">), a function to add items (</span><strong class="source-inline"><span class="koboSpan" id="kobo.633.1">addItem</span></strong><span class="koboSpan" id="kobo.634.1">), and a function to remove items (</span><strong class="source-inline"><span class="koboSpan" id="kobo.635.1">removeItem</span></strong><span class="koboSpan" id="kobo.636.1">). </span><span class="koboSpan" id="kobo.636.2">The component also uses a </span><strong class="source-inline"><span class="koboSpan" id="kobo.637.1">useTotalPrice</span></strong><span class="koboSpan" id="kobo.638.1"> custom Hook to calculate the total price of items in the cart.</span></p>
<p><span class="koboSpan" id="kobo.639.1">And in the outmost </span><strong class="source-inline"><span class="koboSpan" id="kobo.640.1">App</span></strong><span class="koboSpan" id="kobo.641.1"> component, we can encapsulate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">ShoppingApplication</span></strong><span class="koboSpan" id="kobo.643.1"> component:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.644.1">
&lt;ShoppingCartProvider&gt;
  &lt;ShoppingApplication /&gt;
&lt;/ShoppingCartProvider&gt;</span></pre> <p><span class="koboSpan" id="kobo.645.1">So, CQRS is </span><a id="_idIndexMarker441"/><span class="koboSpan" id="kobo.646.1">a design pattern that separates the modification and query aspects of a system to enhance scalability, maintainability, and simplicity. </span><span class="koboSpan" id="kobo.646.2">We demonstrated this principle by implementing a shopping cart feature – commands to modify the cart’s state, such as adding or removing items, were segregated from the queries, which included fetching a list of items and calculating the total price; this separation was made clear through the use of React’s Context API and custom Hooks, which isolated each responsibility effectively. </span><span class="koboSpan" id="kobo.646.3">This not only improves code readability but also makes it easier to man</span><a id="_idTextAnchor249"/><span class="koboSpan" id="kobo.647.1">age and scale the application in the future.</span></p>
<h1 id="_idParaDest-138"><a id="_idTextAnchor250"/><span class="koboSpan" id="kobo.648.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.649.1">In this chapter, we’ve unpacked three crucial design principles: the SRP for focused, easy-to-understand components, the DIP for modular, testable code, and CQRS for a distinct separation between commands and queries, enhancing maintainability. </span><span class="koboSpan" id="kobo.649.2">These principles offer a robust foundation for building scalable and high-quality software.</span></p>
<p><span class="koboSpan" id="kobo.650.1">In the next chapter, we’ll dive deeper into composition principles to further refine our approach to React application design.</span></p>
</section>
</body></html>