<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer039">
			<h1 id="_idParaDest-97"><em class="italic"><a id="_idTextAnchor099"/>Chapter 9</em>: Debugging with the New Ivy Runtime APIs</h1>
			<p>Angular Ivy introduces a new API for inspecting and debugging our Angular applications at runtime. It replaces the previous <strong class="source-inline">NgProbe</strong> API and allows tree-shaking of <strong class="source-inline">DebugElement</strong>.</p>
			<p>We will explore Angular's most useful runtime debugging functions, including the following:</p>
			<ul>
				<li><strong class="source-inline">ng.applyChanges</strong></li>
				<li><strong class="source-inline">ng.getComponent</strong></li>
				<li><strong class="source-inline">ng.getContext</strong></li>
				<li><strong class="source-inline">ng.getListeners</strong></li>
			</ul>
			<p>Having these debugging utilities at hand will allow you to verify your assumptions about active components, their templates, and their DOM bindings at runtime.</p>
			<p>This chapter covers these topics:</p>
			<ul>
				<li>Introduction to the new Ivy runtime API</li>
				<li>Inspecting an active component</li>
				<li>Inspecting event listeners</li>
				<li>Inspecting an embedded view context</li>
			</ul>
			<p>Getting familiar with these topics will improve your development workflow when implementing Angular Ivy applications.</p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor100"/>Technical requirements</h1>
			<p>To support all the features used in the code examples of this chapter, your application requires at least the following:</p>
			<ul>
				<li>Angular Ivy version 12.0</li>
				<li>TypeScript version 4.2</li>
			</ul>
			<p>Also, note that the runtime debugging API is only available when Angular runs in development mode.</p>
			<p>You can find complete code examples for the random number generator in this book's companion GitHub repository at <a href="https://github.com/PacktPublishing/Accelerating-Angular-Development-with-Ivy/tree/main/projects/chapter9/random-number">https://github.com/PacktPublishing/Accelerating-Angular-Development-with-Ivy/tree/main/projects/chapter9/random-number</a>.</p>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor101"/>Introducing the new Ivy runtime API</h1>
			<p>If you have worked with Angular versions<a id="_idIndexMarker335"/> before Angular Ivy, you might be familiar with the <strong class="source-inline">NgProbe</strong> API, which was available in the global scope at runtime as the <strong class="source-inline">ng.probe</strong> function. Angular Ivy replaces this API with a set of new runtime debugging functions, which are only available in Angular development mode.</p>
			<p>The new API contains the following functions:</p>
			<ul>
				<li><strong class="source-inline">ng.applyChanges(component: {}): void;</strong><p>Mark the specified component for dirty checking if it is using the <strong class="source-inline">OnPush</strong> change detection strategy. Afterward, trigger a change detection cycle.</p></li>
				<li><strong class="source-inline">ng.getComponent&lt;T&gt;(element: Element): T | null;</strong><p>Resolve the Angular component that is attached to the specified DOM element.</p></li>
				<li><strong class="source-inline">ng.getContext&lt;T&gt;(element: Element): T | null;</strong><p>When passed a DOM element generated by a structural directive such as <strong class="source-inline">NgIf</strong> or <strong class="source-inline">NgFor</strong>, resolve the view context of the embedded view. In other cases, resolve the parent component.</p></li>
				<li><strong class="source-inline">ng.getDirectiveMetadata(directiveOrComponentInstance: any): ComponentDebugMetadata | DirectiveDebugMetadata | null;</strong><p>Resolve the metadata of the specified Angular component or directive instance.</p></li>
				<li><strong class="source-inline">ng.getDirectives(element: Element): {}[];</strong><p>Resolve Angular directives – but not components – attached to the specified DOM element.</p></li>
				<li><strong class="source-inline">ng.getHostElement(componentOrDirective: {}): Element;</strong><p>Resolve the host element that the specified component or directive is attached to.</p></li>
				<li><strong class="source-inline">ng.getInjector(elementOrDir: {} | Element): Injector;</strong><p>Resolve the injector associated with the specified element, directive, or component. </p></li>
				<li><strong class="source-inline">ng.getListeners(element: Element): Listener[];</strong><p>Resolve event listeners<a id="_idIndexMarker336"/> attached to the specified DOM element. This does not include host listeners created from directive or component metadata but includes event listeners not added by Angular.</p></li>
				<li><strong class="source-inline">ng.getOwningComponent&lt;T&gt;(elementOrDir: {} | Element): T | null;</strong><p>Resolve the host component of the specified DOM element, directive, or component.</p></li>
				<li><strong class="source-inline">ng.getRootComponents(elementOrDir: {} | Element): {}[];</strong><p>Resolve the root components associated with the specified DOM element, directive, or component, that is, the components bootstrapped by Angular.</p></li>
			</ul>
			<p>The <strong class="source-inline">Listener</strong> data structures returned by <strong class="source-inline">ng.getListeners</strong> have the following interface:</p>
			<p class="source-code">interface Listener {</p>
			<p class="source-code">  callback: (value: any) =&gt; any;</p>
			<p class="source-code">  element: Element;</p>
			<p class="source-code">  name: string;</p>
			<p class="source-code">  type: 'dom' | 'output';</p>
			<p class="source-code">  useCapture: boolean;</p>
			<p class="source-code">}</p>
			<p>The data structures returned by <strong class="source-inline">ng.getDirectiveMetadata</strong> have the following interfaces:</p>
			<p class="source-code">interface DirectiveDebugMetadata {</p>
			<p class="source-code">  inputs: Record&lt;string, string&gt;;</p>
			<p class="source-code">  outputs: Record&lt;string, string&gt;;</p>
			<p class="source-code">}</p>
			<p class="source-code">interface ComponentDebugMetadata extends DirectiveDebugMetadata {</p>
			<p class="source-code">  changeDetection: ChangeDetectionStrategy;</p>
			<p class="source-code">  encapsulation: ViewEncapsulation;</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">inputs</strong> and <strong class="source-inline">outputs</strong> properties<a id="_idIndexMarker337"/> defined in the preceding debug metadata interfaces contain object maps from data binding property names to component property names.</p>
			<p>It is important to be aware that the <strong class="source-inline">ComponentDebugMetadata#changeDetection</strong> and <strong class="source-inline">ComponentDebugMetadata#encapsulation</strong> properties are number enumerations, so their values will be numbers at runtime, not strings. This makes them a bit harder to interpret when debugging.</p>
			<p>As seen in the preceding overview, most of these runtime debugging utilities accept as a parameter a DOM element, a component<a id="_idIndexMarker338"/> instance, or a directive instance. From the specified object, they look up DOM elements, one or more component instances, one or more directive instances, an injector, or event listeners attached to the DOM.</p>
			<p>The one that stands out is <strong class="source-inline">ng.applyChanges</strong>. We will discuss when and how to use it in the next section.</p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor102"/>Inspecting a component instance</h1>
			<p>To explore our application programmatically<a id="_idIndexMarker339"/> at runtime, we often need a reference to an active component instance. Once we have a component reference, we can change bound properties and call event handlers or other methods.</p>
			<p>However, first, we need a reference to either a directive instance or a DOM element with an attached component. Using the <strong class="bold">Elements</strong> tab of our browser developer tools, we can pick a DOM element and the developer tools will store a reference in the global <strong class="source-inline">$0</strong> variable. Alternatively, we can use <strong class="source-inline">document.querySelector</strong>, or any other DOM querying or traversing API.</p>
			<p>Say we have a component that generates random numbers, as seen in the following figure:</p>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="Images/Figure_9.1_B16295.jpg" alt="Figure 9.1 – A component for generating a random number&#13;&#10;" width="442" height="144"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.1 – A component for generating a random number</p>
			<p>It has a component model as seen in the following code block:</p>
			<p class="source-code">import { Component } from '@angular/core';</p>
			<p class="source-code">@Component({</p>
			<p class="source-code">  selector: 'app-random-number',</p>
			<p class="source-code">  templateUrl: './random-number.component.html',</p>
			<p class="source-code">  styleUrls: ['./random-number.component.css'],</p>
			<p class="source-code">})</p>
			<p class="source-code">export class RandomNumberComponent {</p>
			<p class="source-code">  generatedNumber?: number;</p>
			<p class="source-code">  onNumberGenerated(generatedNumber: number): void {</p>
			<p class="source-code">    this.generatedNumber = generatedNumber;</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>In its template, it is using Angular<a id="_idIndexMarker340"/> Material's Button component as seen in the following code listing:</p>
			<p class="source-code">&lt;ng-container</p>
			<p class="source-code">  #generator="appRandomNumber"</p>
			<p class="source-code">  appRandomNumber</p>
			<p class="source-code">  (numberGenerated)="onNumberGenerated($event)"</p>
			<p class="source-code">  &gt;&lt;/ng-container&gt;</p>
			<p class="source-code">&lt;mat-card&gt;</p>
			<p class="source-code">  &lt;mat-card-header&gt;</p>
			<p class="source-code">    &lt;mat-card-title&gt;Random number generator&lt;/mat-card-</p>
			<p class="source-code">     title&gt;</p>
			<p class="source-code">  &lt;/mat-card-header&gt;</p>
			<p class="source-code">  &lt;mat-card-content&gt;</p>
			<p class="source-code">    &lt;p&gt;Your random number is {{ generatedNumber }}&lt;/p&gt;</p>
			<p class="source-code">  &lt;/mat-card-content&gt;</p>
			<p class="source-code">  &lt;mat-card-actions&gt;</p>
			<p class="source-code">    &lt;button mat-button (click)= "generator.generateNumber()"&gt;GENERATE&lt;/button&gt;</p>
			<p class="source-code">  &lt;/mat-card-actions&gt;</p>
			<p class="source-code">&lt;/mat-card&gt;</p>
			<p>Given that we have a reference to the <strong class="source-inline">&lt;button&gt;</strong> DOM element in the <strong class="source-inline">$0</strong> variable, we can do the following to resolve<a id="_idIndexMarker341"/> two different component instances:</p>
			<p class="source-code">ng.getComponent($0);</p>
			<p class="source-code">// -&gt; MatButton</p>
			<p class="source-code">ng.getOwningComponent($0);</p>
			<p class="source-code">// -&gt; RandomNumberComponent</p>
			<p>There is a subtle but important distinction between <strong class="source-inline">ng.getComponent</strong> and <strong class="source-inline">ng.getOwningComponent</strong>. The first invocation returns an instance of the <strong class="source-inline">MatButton</strong> component, which is attached to the <strong class="source-inline">&lt;button&gt;</strong> DOM element. The second invocation gives us a reference to the active instance of <strong class="source-inline">RandomNumberComponent</strong>.</p>
			<p>We conclude that <strong class="source-inline">ng.getComponent</strong> returns the component attached to the specified DOM element, in this case <strong class="source-inline">MatButton</strong>. Now, <strong class="source-inline">ng.getOwningComponent</strong> returns the component instance that's associated with the component template used to generate the specified DOM element, in this case an instance of <strong class="source-inline">RandomNumberComponent</strong>.</p>
			<p>The <strong class="source-inline">generatedNumber</strong> UI property is bound to text in the DOM created for the random generator component<a id="_idIndexMarker342"/> by Angular. What if we wanted to change it to something specific, say <strong class="source-inline">42</strong>? With a reference to an active component instance, we can change UI properties directly as seen in the following browser console listing:</p>
			<p class="source-code">const component = ng.getOwningComponent($0);</p>
			<p class="source-code">component.generatedNumber = 42;</p>
			<p>However, when looking at the rendered application, we notice that the DOM has not been updated to reflect this new component state. When using the runtime debugging API, we must let Angular know when we have manually changed the state and want Angular to update the DOM it manages.</p>
			<p>We notify Angular of the dirty state by passing the component instance to <strong class="source-inline">ng.applyChanges</strong> as follows:</p>
			<p class="source-code">ng.applyChanges(component);</p>
			<p>After Angular completes a change detection cycle, we notice that the new state is reflected in the DOM, as seen in the following figure:</p>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<img src="Images/Figure_9.2_B16295.jpg" alt="Figure 9.2 – A component displaying a manually specified number&#13;&#10;" width="438" height="144"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.2 – A component displaying a manually specified number</p>
			<p>Great, now you are familiar with the most common runtime debugging functions, which put us in control of Angular components. In the following sections, we will look at debugging APIs that are instrumental to runtime debugging, yet not as commonly used.</p>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor103"/>Inspecting event listeners</h1>
			<p>We'll reuse the random number generator<a id="_idIndexMarker343"/> example from the <em class="italic">Inspecting a component instance</em> section.</p>
			<p>For reference, the following is the random number directive used in the template of the random number component:</p>
			<p class="source-code">import {</p>
			<p class="source-code">  Directive, EventEmitter, OnInit, Output</p>
			<p class="source-code">} from '@angular/core';</p>
			<p class="source-code">@Directive({</p>
			<p class="source-code">  exportAs: 'appRandomNumber',</p>
			<p class="source-code">  selector: '[appRandomNumber]'</p>
			<p class="source-code">})</p>
			<p class="source-code">export class RandomNumberDirective implements OnInit {</p>
			<p class="source-code">  #generatedNumber?: number;</p>
			<p class="source-code">  @Output()</p>
			<p class="source-code">  numberGenerated = new EventEmitter&lt;number&gt;();</p>
			<p class="source-code">  ngOnInit(): void {</p>
			<p class="source-code">    this.generateNumber();</p>
			<p class="source-code">  }</p>
			<p class="source-code">  generateNumber(): void {</p>
			<p class="source-code">    this.#generatedNumber = </p>
			<p class="source-code">      Math.floor(1000 * Math.random());</p>
			<p class="source-code">    this.numberGenerated.emit(this.#generatedNumber);</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>When its <strong class="source-inline">generateNumber</strong> method is called, it outputs the randomly generated number through the <strong class="source-inline">numberGenerated</strong> output property. The random number component<a id="_idIndexMarker344"/> has bound its event handler <strong class="source-inline">RandomNumberComponent#onNumberGenerated</strong> to this custom component event.</p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor104"/>DOM event listeners</h2>
			<p>We pick the <strong class="source-inline">&lt;button&gt;</strong> element in the <strong class="bold">Elements</strong> tab of our browser developer tools, so that a reference to it is stored in <strong class="source-inline">$0</strong>.</p>
			<p>Notice in the component<a id="_idIndexMarker345"/> template that the button component has a click<a id="_idIndexMarker346"/> event binding. We want to access it so that we can trigger it. To do that, pass the button DOM element to the <strong class="source-inline">ng.getListeners</strong> function, as seen in the following browser console listing:</p>
			<p class="source-code">const [onButtonClick] = ng.getListeners($0);</p>
			<p class="source-code">// onButtonClick -&gt; Listener</p>
			<p class="source-code">onButtonClick.callback();</p>
			<p>We unpack the first and only event listener that is returned by <strong class="source-inline">ng.getListeners</strong> when passed the button DOM element. This <strong class="source-inline">Listener</strong> data structure is stored in the <strong class="source-inline">onButtonClick</strong> variable.</p>
			<p>We invoke the click event handler by invoking <strong class="source-inline">onButtonClick.callback</strong>. This triggers the same state update as clicking the <strong class="bold">Generate</strong> button. However, Angular is not aware of the dirty state.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">DOM event listeners registered outside of Angular code are also returned by <strong class="source-inline">ng.getListeners</strong>.</p>
			<p>You might remember from the <em class="italic">Inspecting a component instance</em> section that we must notify Angular of state changes we introduce through the runtime debugging APIs. We do this by passing the component instance to <strong class="source-inline">ng.applyChanges</strong> as follows:</p>
			<p class="source-code">const component = ng.getOwningComponent($0);</p>
			<p class="source-code">ng.applyChanges(component);</p>
			<p>When Angular finishes<a id="_idIndexMarker347"/> a change detection cycle, the newly generated number<a id="_idIndexMarker348"/> is displayed in the DOM for the random number generator component, which is managed by Angular.</p>
			<p>Notice that we did not pass any parameters to the <strong class="source-inline">Listener#callback</strong> method. In our use case, the event handler did not accept any parameters. If it did, we would most likely have to pass arguments of the expected type for it to work. For example, a click event listener might accept a <strong class="source-inline">MouseEvent</strong> event of type <strong class="source-inline">click</strong>.</p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor105"/>Custom component event bindings</h2>
			<p>Event handlers bound by Angular custom component<a id="_idIndexMarker349"/> event bindings are also registered as listeners. Our example component has an inline event<a id="_idIndexMarker350"/> handler bound for the custom <strong class="source-inline">numberGenerated</strong> event.</p>
			<p>We pick the <strong class="source-inline">&lt;span&gt;</strong> element in the <strong class="bold">Elements</strong> tab of our browser developer tools so that a reference to it is stored in <strong class="source-inline">$0</strong>.</p>
			<p>We pass the <strong class="source-inline">span</strong> element to <strong class="source-inline">ng.getListeners</strong>, and notice that it lists two listeners, one of type <strong class="source-inline">"dom"</strong> and another one of type <strong class="source-inline">"output"</strong>, as shown here:</p>
			<p class="source-code">const [domListener, outputListener] = ng.getListeners($0);</p>
			<p class="source-code">// domListener -&gt; Listener { element: span, name: "numberGenerated", useCapture: false, type: "dom", callback: ƒ }</p>
			<p class="source-code">// outputListener -&gt; Listener { element: span, name: "numberGenerated", useCapture: false, type: "output", callback: ƒ }</p>
			<p>We simulate a random number generation by passing <strong class="source-inline">7</strong> to <strong class="source-inline">outputListener.callback</strong> and run change detection by passing the component to <strong class="source-inline">ng.applyChanges</strong>. This is shown in the following browser console listing:</p>
			<p class="source-code">const component = ng.getOwningComponent($0);</p>
			<p class="source-code">outputListener.callback(7);</p>
			<p class="source-code">ng.applyChanges(component);</p>
			<p>Once a change detection<a id="_idIndexMarker351"/> cycle has finished, the random number generation that we simulated is displayed<a id="_idIndexMarker352"/> in the DOM, which is managed by Angular.</p>
			<p>That is all for inspecting native and custom event listeners using the Angular runtime debugging API. In the final section of this chapter, we'll learn what an embedded view context is, and how to inspect it using Angular Ivy's runtime debugging API.</p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor106"/>Inspecting an embedded view context</h1>
			<p>A structural directive is used to add and remove<a id="_idIndexMarker353"/> elements to the DOM throughout the lifecycle of a component. They create an embedded view, which is bound to a view context. This is the case of the <strong class="source-inline">NgIf</strong> and <strong class="source-inline">NgFor</strong> directives that are part of the Angular framework.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Only one structural directive can be attached to an element. If you need to apply multiple structural directives, wrap the element in the special <strong class="source-inline">&lt;ng-container&gt;</strong> element, attach the outer structural directive to this element, and so on. </p>
			<p>When we pass an element with a structural directive attached to <strong class="source-inline">ng.getContext</strong>, it returns the view context. For example, when we pass an element with an <strong class="source-inline">NgIf</strong> directive attached to it, <strong class="source-inline">NgIfContext</strong> is returned, which has the following shape:</p>
			<p class="source-code">interface NgIfContext {</p>
			<p class="source-code">  $implicit: boolean;</p>
			<p class="source-code">  ngIf: boolean;</p>
			<p class="source-code">}</p>
			<p>The embedded view that is dynamically created by <strong class="source-inline">NgIf</strong> is bound to the <strong class="source-inline">$implicit</strong> property of <strong class="source-inline">NgIfContext</strong>.</p>
			<p>If we instead pass an element<a id="_idIndexMarker354"/> that has an <strong class="source-inline">NgFor</strong> directive attached to it, <strong class="source-inline">NgForOfContext</strong> is returned. It has the following shape:</p>
			<p class="source-code">interface NgForOfContext&lt;T&gt; {</p>
			<p class="source-code">  $implicit: T;</p>
			<p class="source-code">  count: number;</p>
			<p class="source-code">  index: number;</p>
			<p class="source-code">  ngForOf: T[];</p>
			<p class="source-code">  even: boolean;</p>
			<p class="source-code">  first: boolean;</p>
			<p class="source-code">  last: boolean;</p>
			<p class="source-code">  odd: boolean;</p>
			<p class="source-code">}</p>
			<p>An embedded view is dynamically created by the <strong class="source-inline">NgFor</strong> directive for each item in <strong class="source-inline">NgForOfContext#ngForOf</strong>. Each embedded view is bound to the <strong class="source-inline">$implicit</strong> property of <strong class="source-inline">NgForOfContext</strong> specific to that item.</p>
			<p>However, each embedded view also has access to the other properties that are specified in <strong class="source-inline">NgForOfContext</strong>. For example, we can loop through a list of users and store a reference to the <strong class="source-inline">index</strong> and <strong class="source-inline">first</strong> context properties, like so:</p>
			<p class="source-code">&lt;ul&gt;</p>
			<p class="source-code">  &lt;li *ngFor="let user of users; index as i; first as </p>
			<p class="source-code">   isFirst"&gt;</p>
			<p class="source-code">    {{i}}/{{users.length}}.</p>
			<p class="source-code">    {{user}} &lt;span *ngIf="isFirst"&gt;(default)&lt;/span&gt;</p>
			<p class="source-code">  &lt;/li&gt;</p>
			<p class="source-code">&lt;/ul&gt;</p>
			<p>The embedded view created for each user has access to and uses the <strong class="source-inline">index</strong> and <strong class="source-inline">first</strong> properties, which are aliased as <strong class="source-inline">i</strong> and <strong class="source-inline">isFirst</strong>, respectively.</p>
			<p>Passing a list item element from the previous<a id="_idIndexMarker355"/> code listing to <strong class="source-inline">ng.getContext</strong> results in an <strong class="source-inline">NgForOfContext</strong> value, such as the examples in the following code listing:</p>
			<p class="source-code">const listItems = document.querySelectorAll('li');</p>
			<p class="source-code">ng.getContext(listItems[0]);</p>
			<p class="source-code">// -&gt; NgForOfContext { $implicit: "Nacho", count: 4, index: 0, ngForOf: ["Nacho", "Santosh", "Serkan", "Lars"], even: true, first: true, last: false, odd: false }</p>
			<p class="source-code">ng.getContext(listItems[1]);</p>
			<p class="source-code">// -&gt; NgForOfContext { $implicit: "Santosh", count: 4, index: 1, ngForOf: ["Nacho", "Santosh", "Serkan", "Lars"], even: false, first: false, last: false, odd: true }</p>
			<p>Similarly, if we pass the <strong class="source-inline">&lt;span&gt;</strong> element to <strong class="source-inline">ng.getContext</strong>, we get an <strong class="source-inline">NgIfContext</strong> value, such as the following:</p>
			<p class="source-code">ng.getContext(document.querySelector('span'));</p>
			<p class="source-code">// -&gt; NgIfContext { $implicit: true, ngIf: true }</p>
			<p>Take special care to pass the element that has a structural directive attached, or you will instead receive the closest component instance.</p>
			<p>Now you know how to inspect the embedded view context of template elements with a structural directive attached.</p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor107"/>Summary</h1>
			<p>I hope you like the new shiny tools that we added to your toolbox in this chapter. We started with an overview of Angular Ivy's runtime debugging API, which is available only in development mode.</p>
			<p>Next, we learned how to inspect a component instance using <strong class="source-inline">ng.getComponent</strong> and <strong class="source-inline">ng.getOwningComponent</strong>. We also changed the component state, then updated the DOM using <strong class="source-inline">ng.applyChanges</strong>.</p>
			<p>In the <em class="italic">Inspecting event listeners</em> section, we used <strong class="source-inline">ng.getListeners</strong> to inspect both native DOM event listeners and custom component event listeners. We passed arguments to their callbacks and triggered change detection using <strong class="source-inline">ng.applyChanges</strong>.</p>
			<p>Finally, you now know what an embedded view context is and how to inspect it, for example, how one is created and bound to each component or element managed by the <strong class="source-inline">NgFor</strong> directive. Similarly, we explored an example of an embedded view context for an element managed by an <strong class="source-inline">NgIf</strong> directive.</p>
			<p>With all these newfound skills, you are ready to debug Angular applications by inspecting and updating state directly or through events, then reflecting the changes by triggering change detection.</p>
			<p>You are even able to inspect the ever-so-hard-to-locate embedded view contexts. Amazing!</p>
			<p>In the next chapter, you will learn about the Angular Compatibility Compiler, and when and why it is needed. We will explore its configuration options and optimize it for a CI/CD workflow.</p>
		</div>
	</div></body></html>