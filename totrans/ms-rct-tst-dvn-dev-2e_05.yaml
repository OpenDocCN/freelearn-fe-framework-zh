- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Adding Complex Form Interactions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加复杂表单交互
- en: 'It’s time to apply what you’ve learned to a more complicated HTML setup. In
    this chapter, we’ll test-drive a new component: `AppointmentForm`. It contains
    a select box, for selecting the service required, and a grid of radio buttons
    that form a calendar view for selecting the appointment time.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候将你所学应用到更复杂的HTML设置中了。在本章中，我们将测试一个新的组件：`AppointmentForm`。它包含一个下拉框，用于选择所需的服务，以及一组单选按钮，形成一个用于选择预约时间的日历视图。
- en: 'Combining both layout and form input, the code in this chapter shows how TDD
    gives you a structure for your work that makes even complicated scenarios straightforward:
    you will use your tests to grow the component into a component hierarchy, splitting
    out functionality from the main component as it begins to grow.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 结合布局和表单输入，本章中的代码展示了TDD如何为你提供一个工作结构，使复杂场景变得简单易懂：你将使用测试来扩展组件成为组件层次结构，随着组件开始增长，将功能从主组件中分离出来。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Choosing a value from a select box
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从下拉框中选择一个值
- en: Constructing a calendar view
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建日历视图
- en: Test-driving radio button groups
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试单选按钮组
- en: Reducing effort when constructing components
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少构建组件时的努力
- en: By the end of the chapter, you’ll have learned how to apply test-driven development
    to complex user input scenarios. These techniques will be useful for all kinds
    of form components, not just select boxes and radio buttons.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将学会如何将测试驱动开发应用于复杂用户输入场景。这些技术对所有类型的表单组件都很有用，而不仅仅是下拉框和单选按钮。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code files for this chapter can be found here: [https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter05).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在以下位置找到：[https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter05)。
- en: Choosing a value from a select box
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从下拉框中选择一个值
- en: Let’s start by creating a component for booking new appointments, named `AppointmentForm`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个名为`AppointmentForm`的组件来预订新预约开始。
- en: 'The first field is a select box for choosing which service the customer requires:
    cut, color, blow-dry, and so on. Let’s create that now:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 第一字段是一个下拉框，用于选择客户所需的服务：剪发、染色、吹干等。让我们现在创建它：
- en: 'Create a new file, `test/AppointmentForm.test.js`, with the following test
    and setup:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件，`test/AppointmentForm.test.js`，包含以下测试和设置：
- en: '[PRE0]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Make this test pass by implementing and creating a new file, `src/AppointmentForm.js`,
    as shown here:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过实现并创建一个新文件，`src/AppointmentForm.js`，如下所示，使这个测试通过：
- en: '[PRE1]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create a nested `describe` block for the service field. We’ll jump to this
    right away because we know this form will have multiple fields:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为服务字段创建一个嵌套的`describe`块。我们将立即跳到这一点，因为我们知道这个表单将包含多个字段：
- en: '[PRE2]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add the following test to the `describe` block:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下测试添加到`describe`块中：
- en: '[PRE3]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To make this test pass, modify the `AppointmentForm` component, as follows:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使这个测试通过，修改`AppointmentForm`组件，如下所示：
- en: '[PRE4]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Run the tests and ensure they are all passing.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试并确保它们全部通过。
- en: With that, we’ve done the basic scaffolding for the new select box field so
    that it’s ready to be populated with `option` elements.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经为新下拉框字段完成了基本的脚手架，使其准备好填充`option`元素。
- en: Providing select box options
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供下拉框选项
- en: 'Our salon provides a whole range of salon services. We should ensure that they
    are all listed in the app. We could start our test by defining our expectations,
    like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的沙龙提供一系列沙龙服务。我们应该确保它们都在应用程序中列出。我们可以从定义我们的期望开始测试，如下所示：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we do this, we’ll end up repeating the same array of services in our test
    code and our production code. We can avoid that repetition by focusing our unit
    tests on the *behavior* of the select box rather than the static data that populates
    it: what should the select box *do*?'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们这样做，我们最终会在测试代码和生产代码中重复相同的数组服务。我们可以通过将单元测试集中在下拉框的*行为*上而不是填充它的静态数据来避免这种重复：下拉框应该*做什么*？
- en: 'As it turns out, we can specify the functionality of our select box with just
    *two* items in our array. There’s another good reason for keeping it to just two,
    which is that keeping the array brief helps us focus the test on what’s important:
    the behavior, not the data.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，我们只需要在数组中指定两个项目就可以指定我们的选择框的功能。保持数组简短还有另一个很好的原因，那就是这有助于我们集中测试的重点：行为，而不是数据。
- en: That leaves the question, how do we use only two items in our test when we need
    six items for the production code?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这就留下了一个问题，当我们需要六个项目用于生产代码时，我们如何在测试中只使用两个项目？
- en: We’ll do this by introducing a new prop, `selectableServices`, to `AppointmentForm`.
    Our tests can choose to specify a value if they need to. In our production code,
    we can specify a value for the component’s `defaultProps`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过向`AppointmentForm`引入一个新的属性`selectableServices`来实现这一点。我们的测试可以选择指定一个值，如果需要的话。在我们的生产代码中，我们可以为组件的`defaultProps`指定一个值。
- en: '`defaultProps` is a nifty mechanism that React offers for setting default prop
    values that will be used when required props are not explicitly provided.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`defaultProps`是React提供的一种巧妙机制，用于设置当所需的属性未明确提供时将使用的默认属性值。'
- en: For our tests that *don’t* care about the select box values, we can avoid passing
    the prop and ignore it entirely in the test. For the tests that *do* care, we
    can provide a short, two-item array for our tests.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些不关心选择框值的测试，我们可以避免传递属性并在测试中完全忽略它。对于那些确实关心的测试，我们可以为测试提供一个简短的两个项目数组。
- en: How do we verify the real select box values?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何验证实际的选择框值？
- en: Testing static data does happen, just not within our unit tests. One place this
    can be tested is within acceptance tests, which we’ll look at in *Part 4, Behavior-Driven
    Development with Cucumber*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 测试静态数据确实会发生，但不是在我们的单元测试中。这种测试可以在验收测试中进行，我们将在第4部分*使用Cucumber的行为驱动开发*中探讨。
- en: 'We’ll start with a test to ensure the first value is a blank entry. This is
    the value that’s initially selected when the user creates a new appointment: no
    option is selected. Let’s write that test now:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从确保第一个值是一个空白条目开始测试。这是当用户创建新的预约时最初选择的值：没有选择任何选项。让我们现在编写这个测试：
- en: 'Add the following test at the end of the `AppointmentForm` test suite. It specifies
    that the very first item in the select box is blank, meaning the user is not automatically
    assigned a choice from our list of services:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AppointmentForm`测试套件的末尾添加以下测试。它指定选择框中的第一个项目是空白，这意味着用户不会自动从我们的服务列表中分配一个选择：
- en: '[PRE6]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Make that pass by adding a blank `option` element to the existing `select`
    element:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过向现有的`select`元素添加一个空白的`option`元素来使这个测试通过：
- en: '[PRE7]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Back in your tests, add this new helper just after the `beforeEach` block.
    We’ll make use of it in our next test to build an array of all the labels of the
    select box options:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的测试中，在`beforeEach`块之后添加这个新的辅助函数。我们将在下一个测试中使用它来构建选择框选项的所有标签的数组：
- en: '[PRE8]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add the following test. This makes use of a new prop, `selectableServices`,
    which is simply the array of available options:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下测试。这使用了新的属性`selectableServices`，它简单地是可用选项的数组：
- en: '[PRE9]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Choosing test data
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 选择测试数据
- en: 'I’ve used “real” data for my expected services: `Cut` and `Blow-dry`. It’s
    also fine to use non-real names such as `Service A` and `Service B`. Often, that
    can be more descriptive. Both are valid approaches.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经为预期的服务使用了“真实”数据：`Cut`和`Blow-dry`。使用非真实名称，如`Service A`和`Service B`也是可以的。通常，这可以提供更详细的描述。这两种方法都是有效的。
- en: 'Let’s make this pass. Change the component definition, as follows:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使这个测试通过。更改组件定义，如下所示：
- en: '[PRE10]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Check that the latest test now passes. However, you will see that our earlier
    tests break because of the introduction of the new prop.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查最新的测试现在是否通过。然而，你会看到我们之前的测试因为引入了新的属性而失败了。
- en: 'We can make these tests pass again using `defaultProps`. Just below the definition
    of the `AppointmentForm` function in `src/AppointmentForm.js`, add the following:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`defaultProps`使这些测试再次通过。在`src/AppointmentForm.js`中`AppointmentForm`函数定义下方，添加以下内容：
- en: '[PRE11]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Run your tests and verify they are passing.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行你的测试并验证它们是否通过。
- en: That’s all there is to it. With that, we’ve learned how to define the behavior
    of our component using a short two-item array and saved the real data for `defaultProps`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是全部内容。通过这样，我们学习了如何使用简短的两个项目数组来定义我们组件的行为，并将真实数据保存为`defaultProps`。
- en: Preselecting a value
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预选一个值
- en: 'Let’s ensure that our component preselects the value that has already been
    saved if we’re editing an existing appointment:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确保如果我们在编辑现有的预约，我们的组件会预选已经保存的值：
- en: 'Define a `findOption` arrow function at the top of the `describe` block. This
    function searches the DOM tree for a particular text node:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In our next test, we can find that node and then check that it is selected:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To make this pass, set the value property on the root `select` tag:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Accessible rich internet applications (ARIA) labels
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: If you have experience with building React applications, you may be expecting
    to set the `aria-label` property on the `select` element. However, one of this
    chapter’s *Exercises* is to add a label element for this `select` box that will
    ensure an ARIA label is set implicitly by the browser.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll need to change your component props so that it includes the new `service`
    prop:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Run your tests. Although this test is now passing, you’ll find the previous
    tests are failing because the original prop has not been set. To fix them, first,
    define a new constant, `blankAppointment`, just above your `beforeEach` block.
    We’ll use this in each of the failing tests:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Update your previous tests so that they use this new constant as the value
    for the `original` prop. For example, the very first test for `AppointmentForm`
    will look as follows:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Run the tests again with `npm test`; all your tests should be passing. (If they
    aren’t, go back and check that you’ve got an `original` prop value for each test.)
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s finish with a small bit of refactoring. Your last two tests both have
    the same definition for services. Pull that out of each test, placing it above
    the definition of `blankAppointment`. Make sure that you delete that line from
    both tests:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: That completes this test, but there is still more functionality to add if we
    want a fully functional select box. Completing those tests is left as one of the
    *Exercises* at the end of this chapter. They work the same as the tests for the
    text boxes in `CustomerForm`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'If you compare our select box tests to those of the text box, you will see
    that it’s a similar pattern but with a couple of additional techniques: we used
    `defaultProps` to separate the definition of production data from test behavior,
    and we defined a couple of localized helper methods, `labelsOfAllOptions` and
    `findOption`, to help keep our tests short.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s move on to the next item in our form: the time of the appointment.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Constructing a calendar view
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll learn how to use our existing helpers, such as `element`
    and `elements`, mixed with CSS selectors, to select specific elements we’re interested
    in within our HTML layout.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: But first, let’s start with some planning.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'We’d like `AppointmentForm` to display available time slots over the next 7
    days as a grid, with columns representing days and rows representing 30-minute
    time slots, just like a standard calendar view. The user will be able to quickly
    find a time slot that works for them and then select the right radio button before
    submitting the form:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – The visual design of our calendar view ](img/Figure_5.01_B18423.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – The visual design of our calendar view
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of the HTML structure that we’re aiming to build. We can
    use this as a guide as we write out our React component:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the next few sections, we’ll test-drive the `table` element itself, then
    build a header column for times of the day, and then a header for days of the
    week.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Adding the table
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s begin by building `table` itself:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a nested `describe` block with a new test at the bottom of `test/AppointmentForm.test.js`:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You’ll need to pull the `element` helper into your imports:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To make that pass, move to `src/AppointmentForm.js` and define a new `TimeSlotTable`
    component, above the definition of `AppointmentForm`. We don’t need to mark this
    one as an export as it will only be referenced by `AppointmentForm`:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Why add an ID?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: The ID is important because that’s what the application’s CSS uses to find the
    `table` element. Although it’s not covered in this book, if you’re using CSS and
    it defines selectors based on element IDs, then you should treat those IDs as
    a kind of technical specification that your code must satisfy. That’s why we write
    unit tests for them.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this component to your `AppointmentForm` JSX, right at the bottom, just
    below the `select` tag:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Run the tests and verify that they are all passing.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: That’s all there is to the `table` element. Now, let’s get some data into the
    first column.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Adding a header column
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the next test, we’ll test the left-hand header column that displays a list
    of times. We’ll introduce two new props, `salonOpensAt` and `salonClosesAt`, which
    inform the component of which time to show each day. Follow these steps:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following test:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Asserting on array patterns
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we are checking `textContent` on *three* array entries, even
    though there are four entries in the array.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Properties that are the same for all array entries only need to be tested on
    one entry. Properties that vary per entry, such as `textContent`, need to be tested
    on two or three entries, depending on how many you need to test a pattern.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: For this test, I want to test that it starts and ends at the right time and
    that each time slot increases by 30 minutes. I can do that with assertions on
    array entries 0, 1, and 3.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: This test “breaks” our rule of one expectation per test. However, in this scenario,
    I think it’s okay. An alternative approach might be to use the `textOf` helper
    instead.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll need to pull the `elements` helper into your imports:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To make this pass, add the following functions above the `TimeSlotTable` component.
    They calculate the list of daily time slots:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Define the `toTimeValue` function, as follows:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, you can make use of those two functions. Update `TimeSlotTable` so that
    it reads as follows:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the JSX for `AppointmentForm`, pass the `salonOpensAt` and `salonClosesAt`
    props to `TimeSlotTable`:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Fill in `defaultProps` for both `salonOpensAt` and `salonsCloseAt`:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Run the tests and make sure everything is passing.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That’s all there is to adding the left-hand side column of headings.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Adding a header row
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, what about the column headings? In this section, we’ll create a new top
    row that contains these cells, making sure to leave an empty cell in the top-left
    corner, since the left column contains the time headings and not data. Follow
    these steps:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following test:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Modify the table JSX so that it includes a new table row:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'For the rest of the header row, we’ll show the 7 days starting from today.
    `AppointmentForm` will need to take a new prop, `today`, which is the first day
    to display within the table. The value that’s assigned to that prop is stored
    in a variable named `specificDate`. This name has been chosen to highlight the
    fact that this chosen date affects the rendered day output, for example, `"Sat
    01"`:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Why pass a date into the component?
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: When you’re testing a component that deals with dates and times, you almost
    always want a way to control the time values that the component will see, as we
    have in this test. You’ll rarely want to just use the real-world time because
    that can cause intermittent failures in the future. For example, your test may
    assume that a month has at least 30 days in the year, which is only true for 11
    out of 12 months. It’s better to fix the month to a specific month rather than
    have an unexpected failure when February comes around.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: For an in-depth discussion on this topic, take a look at [https://reacttdd.com/controlling-time](https://reacttdd.com/controlling-time-within-unit-tests/).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'To make that pass, first, create a function that lists the 7 days we’re after,
    in the same way we did with time slots. You can place this just after the `toTimeValue`
    function:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Define the `toShortDate` function, which formats our date as a short string:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Modify `TimeSlotTable` so that it takes the new `today` prop and uses the two
    new functions:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Within `AppointmentForm`, pass the `today` prop from `AppointmentForm` into
    `TimeSlotTable`:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, add a `defaultProp` for `today`. Set it to the current date by calling
    the `Date` constructor:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Run the tests. They should be all green.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With that, we’re done with our table layout. You’ve seen how to write tests
    that specify the table structure itself and fill in both a header column and a
    header row. In the next section, we’ll fill in the table cells with radio buttons.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Test-driving radio button groups
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have our table with headings in place, it’s time to add radio buttons
    to each of the table cells. Not all cells will have radio buttons – only those
    that represent an available time slot will have a radio button.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'This means we’ll need to pass in another new prop to `AppointmentForm` that
    will help us determine which time slots to show. This prop is `availableTimeSlots`,
    which is an array of objects that list times that are still available. Follow
    these steps:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following test, which establishes a value for the `availableTimeSlots`
    prop and then checks that radio buttons have been rendered for each of those slots:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下测试，它为`availableTimeSlots`属性设置一个值，然后检查是否为每个时间段渲染了单选按钮：
- en: '[PRE39]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Notice that this test uses a `cellsWithRadioButtons` helper, which we need
    to define now. You can place this just above the test; there’s no need to move
    it to the extension’s module since it’s specific to this one component:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，此测试使用了一个`cellsWithRadioButtons`辅助函数，我们现在需要定义它。你可以将它放在测试上方；没有必要将其移动到扩展模块中，因为它只针对这个组件：
- en: '[PRE40]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This test checks that there are radio buttons in the first two time slots for
    today. These will be in cells 0 and 7 since `elements` returns matching elements
    in page order. We can make this test pass very simply by adding the following
    to our `AppointmentForm` render method, just below `th` within each `tr`:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此测试检查今天前两个时间段内是否有单选按钮。这些按钮将位于单元格0和7，因为`elements`按页面顺序返回匹配的元素。我们可以通过在`AppointmentForm`的渲染方法中添加以下内容来非常简单地使此测试通过，就在每个`tr`中的`th`下面：
- en: '[PRE41]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: At this point, your test will be passing.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你的测试将通过。
- en: We didn’t need to use `availableTimeSlots` in our production code, even though
    our tests require it! Instead, we just put a radio button in *every* cell! This
    is obviously “broken.” However, if you think back to our rule of only ever implementing
    the simplest thing that will make the test pass, then it makes sense. What we
    need now is another test to prove the opposite – that certain radio buttons do
    *not* exist, given `availableTimeSlots`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的测试需要它，但我们不需要在产品代码中使用`availableTimeSlots`！相反，我们只是在*每个*单元格中放了一个单选按钮！这显然是“错误的”。然而，如果你回想起我们只实现使测试通过的最简单规则，那么这就有意义了。我们现在需要另一个测试来证明相反的情况——在`availableTimeSlots`给定的情况下，某些单选按钮*不存在*。
- en: Hiding input controls
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐藏输入控件
- en: 'How can we get to the right implementation? We can do this by testing that
    having no available time slots renders no radio buttons at all:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何得到正确的实现？我们可以通过测试没有可用的时间段将不会渲染任何单选按钮来实现：
- en: 'Add the following test:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下测试：
- en: '[PRE42]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To make that pass, first, move to `src/AppointmentForm.js` and define the `mergeDateAndTime`
    function above the `TimeSlotTable` component. This takes the date from a column
    header, along with a time from a row header, and converts them into a timestamp
    that we can use to compare against the `startsAt` fields in `availableTimeSlots`:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使它通过，首先，转到`src/AppointmentForm.js`并在`TimeSlotTable`组件上方定义`mergeDateAndTime`函数。这个函数从列标题中获取日期，以及从行标题中获取时间，并将它们转换成我们可以用来与`availableTimeSlots`中的`startsAt`字段进行比较的时间戳：
- en: '[PRE43]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Update `TimeSlotTable` so that it takes the new `availableTimeSlots` prop:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`TimeSlotTable`使其接受新的`availableTimeSlots`属性：
- en: '[PRE44]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Replace the existing radio button element in `TimeSlotTable` with a JSX conditional:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用JSX条件替换`TimeSlotTable`中现有的单选按钮元素：
- en: '[PRE45]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Also, update `AppointmentForm` so that it takes the new prop, and then pass
    it through to `TimeSlotTable`:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，更新`AppointmentForm`使其接受新的属性，并将其传递给`TimeSlotTable`：
- en: '[PRE46]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Although your test will now be passing, the rest will be failing: they need
    a value for the `availableTimeSlots` prop. To do that, first, add the following
    definitions to the top of `AppointmentForm`:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然你的测试现在将通过，但其余的将失败：它们需要一个`availableTimeSlots`属性的值。为此，首先，在`AppointmentForm`的顶部添加以下定义：
- en: '[PRE47]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Go through each test and update each call to render to specify an `availableTimeSlots`
    prop with a value of `availableTimeSlots`. For example, the first test should
    have the following render call:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历每个测试并更新每个渲染调用，以指定一个值为`availableTimeSlots`的`availableTimeSlots`属性。例如，第一个测试应该有以下的渲染调用：
- en: '[PRE48]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Handling sensible defaults for props
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 处理属性的合理默认值
- en: Adding a default value for a new prop in every single test is no one’s idea
    of fun. Later in this chapter you'll learn how to avoid prop explosion in your
    tests by introducing a `testProps` object to group sensible default prop values.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个测试中为新的属性添加默认值并不是什么有趣的事情。在本章的后面，你将学习如何通过引入一个`testProps`对象来分组合理的默认属性值，以避免在测试中出现属性爆炸。
- en: 'Let’s continue with the next test. We must ensure each radio button has the
    correct value. We’ll use the `startsAt` value for each radio button’s value. Radio
    button values are strings, but the appointment object property, `startsAt`, is
    a number. We’ll use a standard library function, `parseInt`, to convert the button
    value back into a usable number:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续下一个测试。我们必须确保每个单选按钮都有正确的值。我们将使用每个单选按钮的`startsAt`值。单选按钮的值是字符串，但预约对象的属性`startsAt`是数字。我们将使用标准库函数`parseInt`将按钮值转换回可用的数字：
- en: '[PRE49]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Defining constants within tests
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, it’s preferable to keep constants within a test rather than pulling
    them out as helpers. In this case, these helpers are only used by this one test
    and are very specific in what they do. Keeping them inline helps you understand
    what the functions are doing without having to search through the file for the
    function definitions.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'In your production code, pull out the ternary that contained the original call
    to `mergeDateAndTime` into a new component. Take care to add the new `name` and
    `value` attributes to the `input` element:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The name property
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Radio buttons with the same `name` attribute are part of the same group. Clicking
    one radio button will check that button and uncheck all others in the group.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now use this within `TimeSlotTable`, replacing the existing ternary
    with an instance of this functional component. After this, your tests should be
    passing:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now that you’ve got the radio buttons displaying correctly, it’s time to give
    them some behavior.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Selecting a radio button in a group
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s see how we can use the `checked` property on the input element to ensure
    we set the right initial value for our radio button.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, we’ll use a helper called `startsAtField` that takes an index and
    returns the radio button at that position. To do that, the radio buttons must
    all be given the same name. This joins the radio button into a group, which means
    only one can be selected at a time. Follow these steps:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding the `startsAtField` helper at the top of the time slot table’s
    `describe` block:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Add the following test. It passes in an existing appointment with a `startsAt`
    value set to the second item in the `availableTimeSlots` list. Choosing the second
    item rather than the first isn’t strictly necessary (since the default will be
    for *all* radio buttons to be unchecked), but it can help highlight to future
    maintainers that a specific value has been chosen and is being checked:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'To make that pass, first, add a new `checkedTimeSlot` prop to `TimeSlotTable`
    that has the value of the original `startsAt` value:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Update `TimeSlotTable` so that it makes use of this new prop, passing it through
    to `RadioButtonIfAvailable`:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, you can make use of that in `RadioButtonIfAvailable`, setting the `isChecked`
    prop on the input element, as shown here. After this change, your test should
    be passing:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: That’s it for setting the initial value. Next, we’ll hook up the component with
    the `onChange` behavior.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Handling field changes through a component hierarchy
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Throughout this chapter, we have slowly built up a component hierarchy: `AppointmentForm`
    renders a `TimeSlotTable` component that renders a bunch of `RadioButtonIfAvailable`
    components that may (or may not) render the radio button input elements.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: The final challenge involves how to take an `onChange` event from the input
    element and pass it back up to `AppointmentForm`, which will control the appointment
    object.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'The code in this section will make use of the `useCallback` hook. This is a
    form of performance optimization: we can’t write a test to specify that this behavior
    exists. A good rule of thumb is that if you’re passing functions through as props,
    then you should consider using `useCallback`.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的代码将使用`useCallback`钩子。这是一种性能优化的形式：我们无法编写测试来指定这种行为。一个很好的经验法则是，如果你正在将函数作为属性传递，那么你应该考虑使用`useCallback`。
- en: The useCallback hook
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`useCallback`钩子'
- en: The `useCallback` hook returns a `TimeSlotTable`) would re-render each time
    the parent re-renders, because the different reference would cause it to believe
    that a re-render was required.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`useCallback`钩子返回的`TimeSlotTable`会在父组件每次重新渲染时重新渲染，因为不同的引用会导致它认为需要重新渲染。'
- en: Event handlers on `input` elements don’t need to use `useCallback` because event
    handler props are handled centrally; changes to those props do not require re-renders.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`input`元素上的事件处理器不需要使用`useCallback`，因为事件处理器属性是集中处理的；这些属性的更改不需要重新渲染。'
- en: The second parameter to `useCallback` is the set of dependencies that will cause
    `useCallback` to update. In this case, it’s `[]`, an empty array, because it isn’t
    dependent on any props or other functions that may change. Parameters to the function
    such as `target` don’t count, and `setAppointment` is a function that is guaranteed
    to remain constant across re-renders.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`useCallback`的第二个参数是`useCallback`更新的依赖项集合。在这种情况下，它是`[]`，一个空数组，因为它不依赖于任何可能会改变的属性或其他函数。函数的参数，如`target`不计，而`setAppointment`是一个保证在重新渲染中保持恒定的函数。'
- en: See the *Further reading* section at the end of this chapter for a link to more
    information on `useCallback`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章末尾的*进一步阅读*部分查看有关`useCallback`的更多信息链接。
- en: 'Since we haven’t done any work on submitting `AppointmentForm` yet, we need
    to start there. Let’s add a test for the form’s submit button:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们还没有对提交`AppointmentForm`进行任何工作，我们需要从这里开始。让我们为表单的提交按钮添加一个测试：
- en: 'Add the following test to your `AppointmentForm` test suite, which tests for
    the presence of a submit button. This can go at the top of the test suite, just
    underneath the `renders a form` test:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下测试添加到你的`AppointmentForm`测试套件中，该测试用于检查提交按钮的存在。这可以放在测试套件的顶部，就在`renders a form`测试下面：
- en: '[PRE57]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You’ll also need to import the `submitButton` helper into your tests:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还需要将`submitButton`辅助函数导入到你的测试中：
- en: '[PRE58]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'To make that pass, add the button at the bottom of your `AppointmentForm`:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使这一步通过，请在你的`AppointmentForm`底部添加按钮：
- en: '[PRE59]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'For the next test, let’s submit the form and check that we get the original
    `startsAt` value submitted back. We’ll use the same `expect.hasAssertions` technique
    that we saw in the previous chapter. The test verifies that the `onSubmit` prop
    was called with the original, unchanged `startsAt` value:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于下一个测试，让我们提交表单并检查我们是否得到了提交的原始`startsAt`值。我们将使用我们在上一章中看到的相同`expect.hasAssertions`技术。测试验证`onSubmit`属性是否以原始的、未更改的`startsAt`值被调用：
- en: '[PRE60]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Since this test uses the `click` helper, you’ll need to import it:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这个测试使用了`click`辅助函数，你需要导入它：
- en: '[PRE61]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'For this test, all we need is to get the form’s `onSubmit` event handler in
    place. At this stage, it will simply submit the `original` object without any
    registered changes. Update the `AppointmentForm` component, as shown here:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个测试，我们只需要将表单的`onSubmit`事件处理器设置好。在这个阶段，它将简单地提交没有任何注册更改的`original`对象。更新`AppointmentForm`组件，如下所示：
- en: '[PRE62]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'With that test passing, let’s add the final test. This uses a `click` action
    rather than `change`, which we used for the text box and select box. We click
    on the desired radio button just as a user would:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 那个测试通过后，让我们添加最后的测试。这个测试使用的是`click`动作而不是`change`，我们之前用于文本框和选择框。我们将点击所需的单选按钮，就像用户一样：
- en: '[PRE63]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now, the fun begins. Let’s work from the top down: we’ll start by defining
    a new `appointment` state object, which we’ll then use in a new event handler
    that modifies the current appointment when a radio button is clicked. Move to
    `src/AppointmentForm.js` and update your React import so that it reads as follows:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，有趣的部分开始了。从上到下工作：我们首先定义一个新的`appointment`状态对象，然后使用一个新的事件处理器，当点击单选按钮时修改当前预约。移动到`src/AppointmentForm.js`并更新你的React导入，使其如下所示：
- en: '[PRE64]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Introduce a new `appointment` state object and update your `checkedTimeSlot`
    prop to use this object, rather than the `original` prop value:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引入一个新的`appointment`状态对象，并将你的`checkedTimeSlot`属性更新为使用此对象，而不是使用`original`属性值：
- en: '[PRE65]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Update the `handleSubmit` function so that it uses `appointment` rather than
    `original`:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`handleSubmit`函数，使其使用`appointment`而不是`original`：
- en: '[PRE66]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The call to preventDefault
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 阻止默认行为的调用
- en: I’m avoiding writing the test for `preventDefault` since we’ve covered it previously.
    In a real application, I would almost certainly add that test again.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it’s time for the new event handler. This is the one that makes use of
    `useCallback` so that we can safely pass it through to `TimeSlotTable` and beyond.
    Add the following definition just below the `useState` call you added in the previous
    step. The handler uses `parseInt` to convert between our radio button’s string
    value and the numeric timestamp value we’ll be storing:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We’ve got to weave the event handler through to the `input` element, just like
    we did with `checkedTimeSlot`. Start by passing it into `TimeSlotTable`:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Then, update `TimeSlotTable`, taking that prop and passing it through to `RadioButtonIfAvailable`:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Finally, in `RadioButtonIfAvailable`, remove the `readOnly` property on the
    input field and set `onChange` in its place:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: At this point, your test should pass, and your time slot table should be fully
    functional.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'This section has covered a great deal of code: conditionally rendering `input`
    elements, as well as details of radio button elements, such as giving a group
    `name` and using the `onChecked` prop, and then passing its `onChange` event through
    a hierarchy of components.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a good moment to manually test what you’ve built. You’ll need to update
    `src/index.js` so that it loads `AppointmentForm`, together with sample data.
    These changes are included in the `Chapter05/Complete` directory:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – AppointmentForm on show ](img/Figure_5.02_B18423.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – AppointmentForm on show
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: You’ve now completed the work required to build the radio button table. Now
    it’s time to refactor.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Reducing effort when constructing components
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s look at a couple of simple ways to reduce the amount of time and code
    needed for test suites like the one we’ve just built: first, extracting builder
    functions, and second, extracting objects to store sensible defaults for our component
    props.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Extracting test data builders for time and date functions
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ve already seen how we can extract reusable functions into namespaces of
    their own, such as the `render`, `click`, and `element` DOM functions. A special
    case of this is the **builder** function, which constructs objects that you’ll
    use in the **Arrange** and **Act** phases of your test.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of these functions is not just to remove duplication but also for
    simplification and to aid with comprehension.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'We already have one candidate in our test suite, which is the following code:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We’ll update our test suite so that it uses a builder function called `todayAt`,
    which will save a bit of typing:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: We’ll also extract the `today` value as a constant as we’ll also make use of
    that.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Builders for domain objects
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Most often, you’ll create builder functions for the domain objects in your code
    base. In our case, that would be `customer` or `appointment` objects, or even
    the time slot objects with the single `startsAt` field. Our code base hasn’t progressed
    enough to warrant this, so we’ll start with builders for the `Date` objects that
    we’re using. We’ll write more builders later in this book.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get started:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Create a new directory, `test/builders`. This is where all our `builder` functions
    will live.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new file, `test/builders/time.js`. This is where we’ll throw everything
    related to time.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following constant to your new file:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Back in `test/AppointmentForm.test.js`, add the following import, just below
    your other imports:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Delete the definition of the `today` constant in the test suite.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `test/builders/time.js`, add the following definition of `todayAt`. Notice
    that this does allow us to specify hours, minutes, seconds, and milliseconds if
    we so choose, but it has a default value of `0` for each if we don’t specify them.
    We’ll make use of this full form in one of the tests. We must also make a copy
    of the `today` constant by calling the `date` constructor. This ensures that we
    don’t unexpectedly modify the `today` constant on any callers of this function:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Immutability of builder functions
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: If your namespaces use shared constant values, like we’re doing with `today`
    here, make sure your functions don’t inadvertently mutate them.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in `test/AppointmentForm.test.js`, update your import so that it includes
    the new function:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Time for a search and replace! Find all occurrences of the following:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Replace it with the following:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Find all occurrences of the following:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Replace it with the following:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Ensure your tests are still passing.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Move these lines from the test suite into `test/builders/time.js`:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Rather than use the `tomorrow` constant directly, let’s write a `tomorrowAt`
    helper for that:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Update your import so that it includes the new function:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Delete the definitions of `oneDayInMs` and `tomorrow` from the test suite.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Find the following expression:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Replace it with the following code:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Run the tests again; they should be passing.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ll make use of these helpers again in [*Chapter 7*](B18423_07.xhtml#_idTextAnchor125),
    *Testing useEffect and Mocking Components*. However, there’s one more extraction
    we can do before we finish with this chapter.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Extracting a test props object
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A test props object is an object that sets sensible defaults for props that
    you can use to reduce the size of your `render` statements. For example, look
    at the following render call:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Depending on the test, some (or all) of these props may be irrelevant to the
    test. The `original` prop is necessary so that our render function doesn’t blow
    up when rendering existing field values. But if our test is checking that we show
    a label on the page, we don’t care about that – and that’s one reason we created
    the `blankAppointment` constant. Similarly, `availableTimeSlots` and the `today`
    prop may not be relevant to a test.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Not only that, but often, our components can end up needing a whole lot of props
    that are necessary for a test to function. This can end up making your tests extremely
    verbose.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Too many props?
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: The technique you’re about to see is one way of dealing with many required props.
    But having a lot of props (say, more than four or five) might be a hint that the
    design of your components can be improved. Can the props be joined into a complex
    type? Or should the component be split into two or more components?
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: This is another example of listening to your tests. If the tests are difficult
    to write, take a step back and look at your component design.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define an object named `testProps` that exists at the top of our `describe`
    block:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'This can then be used in the `render` call, like this:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'If the test does depend on a prop, such as if its expectation mentions part
    of the `props` value, then you shouldn’t rely on the hidden-away value in the
    `testProps` object. Those values are sensible defaults. The values in your test
    should be prominently displayed, as in this example:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Notice how the `original` prop is still included in the render call after `testProps`.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you’ll want to explicitly include a prop, even if the value is the
    same as the `testProps` value. That’s to highlight its use within the test. We’ll
    see an example of that in this section.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: When to use an explicit prop
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: As a rule of thumb, if the prop is used in your test assertions, or if the prop’s
    value is crucial for the scenario the test is testing, then the prop should be
    included explicitly in the `render` call, even if its value is the same as the
    value defined in `testProps`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s update the `AppointmentForm` test suite so that it uses a `testProps`
    object:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: In your test suite, find the definitions for `services`, `availableTimeSlots`,
    and `blankAppointment`. These should be near the top.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `testProps` definition just after the other definitions:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The first test in the suite looks like this:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'This can be updated to look as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The next two tests, `renders a submit button` and `renders as a select box`,
    can use the same change. Go ahead and do that now.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next up, we have the following test:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Since this test depends on having a blank value passed in for the `service`
    field, let’s keep the original prop there:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: We’ve effectively hidden the `availableTimeSlots` property, which was noise
    before.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have a test that makes use of `selectableServices`:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'This test uses the `services` constant in its expectation, so this is a sign
    that we need to keep that as an explicit prop. Change it so that it matches the
    following:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'In the next test, it’s just `availableTimeSlots` that we can get rid of since
    both `services` and `appointments` are defined in the test itself:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The remaining tests in this test suite are in the nested `describe` block for
    the time slot table. Updating this is left as an exercise for you.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ve now learned yet more ways to clean up your test suites: extracting test
    data builders and extracting a `testProps` object. Remember that using the `testProps`
    object isn’t always the right thing to do; it may be better to refactor your component
    so that it takes fewer props.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned how to use two types of HTML form elements: select
    boxes and radio buttons.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: The component we’ve built has a decent amount of complexity, mainly due to the
    component hierarchy that’s used to display a calendar view, but also because of
    the date and time functions we’ve needed to help display that view.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: 'That is about as complex as it gets: writing React component tests shouldn’t
    feel any more difficult than it has in this chapter.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Taking a moment to review our tests, the biggest issue we have is the use of
    `expect.hasAssertions` and the unusual **Arrange-Assert-Act** order. In [*Chapter
    6*](B18423_06.xhtml#_idTextAnchor099), *Exploring Test Doubles*, we’ll discover
    how we can simplify these tests and get them back into **Arrange-Act-Assert**
    order.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are some exercises for you to try out:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `toBeElementWithTag` matcher that replaces the two expectations in the
    `renders as a select box` test. It should be used like so:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Complete the remaining tests for the `AppointmentForm` select box:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Renders a label
  id: totrans-345
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Assigns an ID that matches the label ID
  id: totrans-346
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Saves an existing value when submitted
  id: totrans-347
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Saves a new value when submitted
  id: totrans-348
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: These tests are practically the same as they were for `CustomerForm`, including
    the use of the `change` helper. If you want a challenge, you can try extracting
    these form test helpers into a module of their own that is shared between `CustomerForm`
    and `AppointmentForm`.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Update the time slot table tests so that they use the `testProps` object.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the `AppointmentsDayView` component so that it uses the `todayAt` builder,
    where appropriate.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the ability to choose a stylist before choosing a time slot. This should
    be a select box that filters based on the service required, as not all stylists
    will be qualified to provide all services. You’ll need to decide on a suitable
    data structure to hold this data. Modify `availableTimeSlots` so that it lists
    which stylists are available at each time, and update the table to reflect which
    stylist has been chosen and their availability during the week.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `useCallback` hook is useful when you’re passing event handlers through
    a hierarchy of components. Take a look at the React documentation for tips on
    how to ensure correct usage: https://reactjs.org/docs/hooks-reference.xhtml#usecallback.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
