- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Fetching and Mutating Data
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取和修改数据
- en: Handling dynamic data is crucial in today's web development landscape. Most
    modern apps interact with data from various sources. The way an app manages loading
    states, errors, and data updates plays a big role in user experience. Fortunately,
    Remix offers a comprehensive solution for both retrieving and updating data.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今的Web开发领域中，处理动态数据至关重要。大多数现代应用程序都与来自各种来源的数据进行交互。应用程序管理加载状态、错误和数据更新的方式在用户体验中起着重要作用。幸运的是，Remix为获取和更新数据提供了全面的解决方案。
- en: 'This chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Fetching data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取数据
- en: Mutating data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改数据
- en: In this chapter, we will implement data reads and writes in BeeRich. First,
    we will practice data loading. Then, we will learn about data mutations in Remix
    and implement an expense creation form.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将实现BeeRich中的数据读取和写入。首先，我们将练习数据加载。然后，我们将学习Remix中的数据修改，并实现支出创建表单。
- en: By the end of this chapter, you will know how to fetch and mutate data in Remix.
    You will also understand how Remix executes `loader` and `action` functions and
    how Remix revalidates loader data after mutations. Finally, you will have practiced
    building applications with progressive enhancement in mind, which we will build
    upon in [*Chapter 6*](B17399_06.xhtml#_idTextAnchor090), *Progressively Enhancing
    the* *User Experience*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解如何在Remix中获取和修改数据。你还将理解Remix如何执行`loader`和`action`函数，以及如何在修改后重新验证loader数据。最后，你将练习以渐进增强为出发点构建应用程序，我们将在[*第6章*](B17399_06.xhtml#_idTextAnchor090)，*渐进增强用户体验*中继续构建。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find the setup instructions for this chapter here: [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/blob/main/05-fetching-and-mutating-data/bee-rich/README.md](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/blob/main/05-fetching-and-mutating-data/bee-rich/README.md).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在此处找到本章的设置说明：[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/blob/main/05-fetching-and-mutating-data/bee-rich/README.md](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/blob/main/05-fetching-and-mutating-data/bee-rich/README.md)。
- en: Note that the code in the `start` folder of this chapter is different from our
    final solution from [*Chapter 4*](B17399_04.xhtml#_idTextAnchor057), *Routing
    in Remix*. Read the instructions in the `README.md` file of this chapter’s folder
    on GitHub before you continue.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，本章`start`文件夹中的代码与我们在[*第4章*](B17399_04.xhtml#_idTextAnchor057)，*Remix中的路由*中的最终解决方案不同。在继续之前，请先阅读GitHub上本章文件夹的`README.md`文件中的说明。
- en: Fetching data
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取数据
- en: 'Before diving into this chapter, make sure you''ve followed the steps in the
    technical requirements section. Once you''ve completed the setup guide, let''s
    briefly revisit the key steps to prevent any issues:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入本章之前，请确保你已经遵循了技术要求部分的步骤。一旦你完成了设置指南，让我们简要回顾一下关键步骤，以防止出现任何问题：
- en: Run `npm i` to install all dependencies.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`npm i`以安装所有依赖项。
- en: 'If you are missing a `.env` file in your project’s root, create a new `.env`
    file and add the following line to it:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你项目根目录中缺少`.env`文件，请创建一个新的`.env`文件，并将其以下行添加到其中：
- en: '[PRE0]'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Prisma – our database toolkit of choice – uses the `DATABASE_URL` environment
    variable to connect to our database.
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Prisma –我们选择的数据工具包 – 使用`DATABASE_URL`环境变量连接到我们的数据库。
- en: Next, run `npm run build` to generate the Prisma client for our data schema.
    Prisma reads our Prisma schema from the `prisma/schema.prisma` file and generates
    types and functions for us to work with.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，运行`npm run build`以生成我们数据模式的数据客户端。Prisma从`prisma/schema.prisma`文件读取我们的Prisma模式，并为我们生成类型和函数。
- en: Run `npm run update:db` to create or update the SQLite database. We use SQLite
    with Prisma to persist our development data.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`npm run update:db`以创建或更新SQLite数据库。我们使用SQLite和Prisma来持久化我们的开发数据。
- en: Finally, run `npm run seed` to seed our local database with mock data. You can
    find the mock script in `prisma/seed.tsx`.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，运行`npm run seed`以使用模拟数据填充我们的本地数据库。你可以在`prisma/seed.tsx`中找到模拟脚本。
- en: Our datatabase is set up, and we can now use Prisma to query the database. Next,
    let's add the code to fetch data from the database to BeeRich.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设置了数据库，现在我们可以使用Prisma来查询数据库。接下来，让我们添加从数据库获取数据的代码到BeeRich中。
- en: Fetching data at the route level
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在路由级别获取数据
- en: 'Let’s use Remix’s `loader` functions and route-level data fetching to query
    the database for expense data:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Remix的`loader`函数和路由级别数据获取来查询数据库以获取支出数据：
- en: Open the `app/routes/dashboard.expenses.tsx` file in your editor.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的编辑器中打开`app/routes/dashboard.expenses.tsx`文件。
- en: 'Add a `loader` function to the route module:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向路由模块添加`loader`函数：
- en: '[PRE1]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`loader` functions are Remix’s HTTP `Request`–`Response` interface. Remix’s
    `loader` functions are executed only on the server and must return a `Response`
    object ([https://developer.mozilla.org/en-US/docs/Web/API/Response](https://developer.mozilla.org/en-US/docs/Web/API/Response)).'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`loader` 函数是 Remix 的 HTTP `Request`–`Response` 接口。Remix 的 `loader` 函数仅在服务器上执行，并且必须返回一个
    `Response` 对象 ([https://developer.mozilla.org/en-US/docs/Web/API/Response](https://developer.mozilla.org/en-US/docs/Web/API/Response)).'
- en: For now, we return an empty JavaScript object. Remix serializes the object for
    us (`JSON.stringify`) and creates a `Response` object with `Content-Type` `application/json`.
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 目前，我们返回一个空的 JavaScript 对象。Remix 会为我们序列化对象（`JSON.stringify`）并创建一个带有 `Content-Type`
    `application/json` 的 `Response` 对象。
- en: 'Next, import our new database client:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，导入我们新的数据库客户端：
- en: '[PRE2]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Important note
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'You can find more information about our Prisma client setup in the `README.md`
    file here: [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/blob/main/05-fetching-and-mutating-data/bee-rich/README.md](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/blob/main/05-fetching-and-mutating-data/bee-rich/README.md).'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本地的 `README.md` 文件中找到更多关于我们 Prisma 客户端设置的信息：[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/blob/main/05-fetching-and-mutating-data/bee-rich/README.md](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/blob/main/05-fetching-and-mutating-data/bee-rich/README.md).
- en: 'Use the database client to query for all expenses and return the results array
    from the `loader` function:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用数据库客户端查询所有费用，并从 `loader` 函数返回结果数组：
- en: '[PRE3]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: json helper function returns a Response object with Content-Type application/json.
    Using the helper function allows us to provide an init object as the second argument
    to add HTTP headers, a status text, and a status code to the response.This step
    is optional as we don’t return any HTTP headers or cookies with the `Response`
    object just yet. We’ll cover this in more detail later in this book.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: json 辅助函数返回一个带有 Content-Type application/json 的 Response 对象。使用辅助函数允许我们将 init
    对象作为第二个参数提供，以便向响应添加 HTTP 头部、状态文本和状态码。这一步是可选的，因为我们还没有在 `Response` 对象中返回任何 HTTP
    头部或 cookies。我们将在本书的后面更详细地介绍这一点。
- en: '[PRE4]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Update the database query to order the data by date:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新数据库查询以按日期排序数据：
- en: '[PRE5]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Move as much logic as possible to the server
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能地将逻辑移动到服务器
- en: We should try to move as much code as possible to the server-side `action` and
    `loader` functions.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该尝试将尽可能多的代码移动到服务器端的 `action` 和 `loader` 函数。
- en: Moving code to the server ensures that less code is shipped to the client. It
    also increases the amount of logic that works before JavaScript has fully loaded
    on the client. Finally, we make sure we decrease the complexity of our client-side
    application by moving the code to our fast and powerful server and database runtimes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码移动到服务器确保发送到客户端的代码更少。它还增加了在客户端 JavaScript 完全加载之前可以工作的逻辑量。最后，我们通过将代码移动到快速且强大的服务器和数据库运行时，确保我们降低客户端应用程序的复杂性。
- en: Thereafter, add `console.log` to the `loader` function so that we can track
    its execution on the terminal.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此后，在 `loader` 函数中添加 `console.log` 以便我们可以在终端中跟踪其执行。
- en: Run the app (`npm run dev`) and open BeeRich in a browser window.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序（`npm run dev`）并在浏览器窗口中打开 BeeRich。
- en: Finally, navigate between different pages and check the server terminal for
    your `console.log` message. Take note when the `loader` function is executed.
    Since `loader` functions only run on the server, you will find the log statements
    in the terminal and not the browser console.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在不同页面之间导航并检查服务器终端中的 `console.log` 消息。注意当 `loader` 函数执行时。由于 `loader` 函数仅在服务器上运行，你将在终端而不是浏览器控制台中找到日志语句。
- en: Great! Whenever the `dashboard/expenses` path is added to the URL, Remix calls
    the `dashboard.expenses.tsx` route module’s `loader` function.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！每当将 `dashboard/expenses` 路径添加到 URL 中时，Remix 会调用 `dashboard.expenses.tsx`
    路由模块的 `loader` 函数。
- en: Next, we need to figure out how to access the data in React. Luckily, this is
    as easy as it gets in Remix.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要找出如何在 React 中访问数据。幸运的是，在 Remix 中这非常简单。
- en: Again, open the `dashboard.expenses.tsx` route module in your editor.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，在你的编辑器中打开 `dashboard.expenses.tsx` 路由模块。
- en: Import the `useLoaderData` hook from `@remix-run/react`.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `@remix-run/react` 中导入 `useLoaderData` 钩子。
- en: 'Next, call the hook in the route module component:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在路由模块组件中调用钩子：
- en: '[PRE6]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We use the `useLoaderData` hook to access the loader data `loader` functions
    first and then renders the React application on the server. In our React component,
    we access the fetched data without having to manage loading states. This allows
    us to eliminate a big chunk of boilerplate code that many React apps suffer from.
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用`useLoaderData`钩子首先访问loader数据`loader`函数，然后在服务器上渲染React应用程序。在我们的React组件中，我们访问获取到的数据，而无需管理加载状态。这使我们能够消除许多React应用程序都遭受的大量样板代码。
- en: So far, the `expenses` variable in our route component is typed as `any`. This
    isn’t ideal. Luckily, we are using TypeScript for both our frontend and backend
    code. We are further co-locating client and server code in the same `app` folder.
    This allows us to do powerful things, such as inferring the type of the loader
    data when calling `useLoaderData`.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们路由组件中的`expenses`变量被类型化为`any`。这并不理想。幸运的是，我们正在使用TypeScript来编写前端和后端代码。我们还在同一个`app`文件夹中集中存放客户端和服务器代码。这使我们能够做一些强大的事情，例如，在调用`useLoaderData`时推断loader数据的类型。
- en: 'Pass the type of the `loader` function to the generic slot of `useLoaderData`:'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将`loader`函数的类型传递给`useLoaderData`的泛型槽位：
- en: '[PRE7]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let’s use the expense array to replace the hardcoded expense list. Loop over
    the expense data to render the list of expenses:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用支出数组来替换硬编码的支出列表。遍历支出数据以渲染支出列表：
- en: '[PRE8]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Finally, run the application and visit the expense overview page. You should
    be able to view a list of expenses from the seed data.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，运行应用程序并访问支出概览页面。你应该能够从种子数据中查看支出列表。
- en: Amazing! We utilize a server-side `loader` function to fetch data, and then
    we access the data in React to render our page. Remix’s `loader` function allows
    us to co-locate server-side data loading and data rendering in the same file.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 太棒了！我们利用服务器端的`loader`函数来获取数据，然后在React中访问这些数据以渲染我们的页面。Remix的`loader`函数允许我们将服务器端数据加载和数据渲染放在同一个文件中。
- en: Note that data fetching in Remix happens in `loader` functions at the route
    level. Route-level data fetching offers many advantages by giving up some of the
    flexibility of fetching from components.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在Remix中，数据获取发生在路由级别的`loader`函数中。通过放弃从组件中获取数据的部分灵活性，路由级别的数据获取提供了许多优势。
- en: Component-based data loading is susceptible to blocking requests, which may
    lead to fetch waterfalls. A component that fetches data often defers rendering
    its child components until the data is loaded. This blocks the children from kicking
    off their own fetch requests, effectively creating a waterfall of fetch requests.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 基于组件的数据加载容易受到阻塞请求的影响，这可能导致获取瀑布。一个经常获取数据的组件会推迟渲染其子组件，直到数据加载完成。这阻止了子组件启动它们自己的获取请求，实际上创建了一个获取请求的瀑布。
- en: Imagine a component that renders the layout of the page. First, it fetches the
    user object and displays a big loading spinner until the user data has been fetched.
    After the user data has been fetched, the page is rendered. Nested components
    now fetch their own data. The user fetch request blocked these requests. This
    behavior may repeat itself several times in nested subtrees of an app.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个渲染页面布局的组件。首先，它获取用户对象，并在用户数据被获取之前显示一个大的加载指示器。在用户数据被获取后，页面被渲染。嵌套组件现在会获取它们自己的数据。用户获取请求阻塞了这些请求。这种行为可能在应用程序嵌套子树中重复多次。
- en: Remix promotes route-level data fetching
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Remix促进路由级别的数据获取
- en: In Remix, we aim to fetch data in route modules instead of components. By avoiding
    granular data fetching at the component level, we aim to optimize data loading
    and prevent fetch waterfalls. We should remember this as a best practice.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在Remix中，我们的目标是路由模块中获取数据，而不是组件。通过避免在组件级别进行细粒度数据获取，我们旨在优化数据加载并防止获取瀑布。我们应该将此作为最佳实践记住。
- en: Note that route-level data fetching does not imply that you can only access
    the data at the route level. You can use the `useLoaderData`, `useRouteLoaderData`,
    and `useMatches` hooks in any custom hook or component of your application to
    access loader data.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，路由级别的数据获取并不意味着你只能在该路由级别访问数据。你可以在应用程序的任何自定义钩子或组件中使用`useLoaderData`、`useRouteLoaderData`和`useMatches`钩子来访问loader数据。
- en: 'The `useRouteLoaderData` and `useMatches` hooks are used to access data from
    any currently active route – compared to `useLoaderData`, which returns the data
    of the route module that the hook is called in. Refer to the Remix documentation
    for more information: [https://remix.run/docs/en/2/hooks/use-route-loader-data](https://remix.run/docs/en/2/hooks/use-route-loader-data).'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`useRouteLoaderData`和`useMatches`钩子用于访问任何当前活动路由中的数据——与返回钩子所在的路由模块数据的`useLoaderData`相比。有关更多信息，请参阅Remix文档：[https://remix.run/docs/en/2/hooks/use-route-loader-data](https://remix.run/docs/en/2/hooks/use-route-loader-data)。'
- en: As always, make sure to implement the same functionality for the income routes.
    This ensures you revisit the concepts introduced in this section before moving
    on.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，确保为收入路由实现相同的功能。这确保你在继续之前重新审视本节中介绍的概念。
- en: Next, let’s have a look at how we can fetch data based on dynamic route parameters.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何根据动态路由参数获取数据。
- en: Fetching dynamic data in parameterized routes
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在参数化路由中获取动态数据
- en: Now that we’ve updated the expenses overview page, you might have noticed that
    this broke our hardcoded expense details route. Let’s fix that.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经更新了支出概览页面，你可能已经注意到这破坏了我们硬编码的支出详情路由。让我们修复它。
- en: You may remember from [*Chapter 4*](B17399_04.xhtml#_idTextAnchor057), *Routing
    in Remix*, that we designed the expense details page as a nested route that renders
    within the expenses overview page. It is also a parameterized route that uses
    a dynamic route parameter.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得从[*第4章*](B17399_04.xhtml#_idTextAnchor057)，*Remix中的路由*，我们设计了支出详情页面作为一个嵌套路由，它在支出概览页面中渲染。它也是一个使用动态路由参数的参数化路由。
- en: 'Let’s update the code so that it queries the requested expense from the database
    based on the route parameter:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新代码，以便根据路由参数从数据库查询请求的支出：
- en: Open the `/app/routes/dashboard.expenses.$id.tsx` file in your editor. We’re
    already using a `loader` function to render our mock data.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的编辑器中打开`/app/routes/dashboard.expenses.$id.tsx`文件。我们已经在其中使用`loader`函数来渲染模拟数据。
- en: Delete the mock data array from the file.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从文件中删除模拟数据数组。
- en: 'Next, update the `loader` function to query the database and find a unique
    expense object with the `id` parameter that we access from the URL:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，更新`loader`函数以查询数据库并找到我们从URL访问的具有`id`参数的唯一支出对象：
- en: '[PRE9]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Run BeeRich by executing `npm run dev` in a terminal.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在终端中执行`npm run dev`来运行BeeRich。
- en: Open a browser window and navigate to [http://localhost:3000/dashboard/expenses/](http://localhost:3000/dashboard/expenses/).
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个浏览器窗口并导航到[http://localhost:3000/dashboard/expenses/](http://localhost:3000/dashboard/expenses/)。
- en: Click on one of the listed expenses.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击列表中的任一支出。
- en: Notice that the URL changes to include the `id` parameter of the expense. Remix
    executes a client-side navigation (when JS is available) to update the URL.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意URL会改变以包含支出的`id`参数。Remix执行客户端导航（当JS可用时）以更新URL。
- en: 'Remix executes a `loader` function when we navigate to the associated route
    segment. On every page navigation, Remix fetches the loader data of each new route
    module that matches the newly requested page. If we navigate to `/login`, then
    the `loader` functions of all **newly matching routes** are executed. This may
    include the following route modules (from root to leaf):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Remix在我们导航到相关路由段时执行`loader`函数。在每次页面导航时，Remix都会获取与请求的新页面匹配的每个新路由模块的`loader`数据。如果我们导航到`/login`，那么所有**新匹配的路由**的`loader`函数都会执行。这可能包括以下路由模块（从根到叶）：
- en: '`root.tsx`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`root.tsx`'
- en: '`routes/_layout.tsx`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`routes/_layout.tsx`'
- en: '`routes/_layout.login.tsx`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`routes/_layout.login.tsx`'
- en: If we further navigate from `/login` to `/signup`, then only the `_layout.signup.tsx`
    route module’s `loader` function is executed as it’s the only route segment that
    wasn’t already active before.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们进一步从`/login`导航到`/signup`，那么只有`_layout.signup.tsx`路由模块的`loader`函数会执行，因为它是我们之前尚未激活的唯一路由段。
- en: 'Let’s visualize what’s going on by reviewing the **Network** tab in the developer
    tools of the browser window:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过回顾浏览器窗口开发者工具中的**网络**选项卡来可视化正在发生的事情：
- en: Open the developer tools in the browser window that runs your app.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行你的应用的浏览器窗口中打开开发者工具。
- en: Open the **Network** tab of the developer tools.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开开发者工具的**网络**选项卡。
- en: Filter by `Fetch/XHR` network requests. This is optional but helps you find
    all fetch requests made to the `loader` functions.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`Fetch/XHR`网络请求进行筛选。这是可选的，但有助于你找到所有发送到`loader`函数的fetch请求。
- en: Now, change the URL in the URL bar to [http://localhost:3000/dashboard/expenses/](http://localhost:3000/dashboard/expenses/)
    and reload the browser window.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将 URL 栏中的 URL 更改为 [http://localhost:3000/dashboard/expenses/](http://localhost:3000/dashboard/expenses/)
    并重新加载浏览器窗口。
- en: You should see no fetch requests in the `dashboard.expenses.tsx` route module’s
    `loader` function is executed, and the data is used to render the HTML on the
    server.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该看不到在 `dashboard.expenses.tsx` 路由模块的 `loader` 函数执行时出现的 fetch 请求，数据被用于在服务器上渲染
    HTML。
- en: Next, click on any of the expenses in the expenses list.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，点击费用列表中的任何一项费用。
- en: Remix is now running client-side. After hydration, the client-side Remix app
    takes over the routing of our application. This allows us to avoid full-page requests,
    which would require more network bandwidth and increase response times.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Remix 现在在客户端运行。在 hydration 之后，客户端 Remix 应用接管了我们应用程序的路由。这允许我们避免全页请求，这需要更多的网络带宽并增加响应时间。
- en: Since we are using Remix’s `Link` component, Remix can intercept page transitions.
    Remix prevents the browser’s default behavior (full-page reload) if JavaScript
    is loaded. Instead, it emulates the behavior by making fetch requests to our `loader`
    functions to fetch the required data.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们正在使用 Remix 的 `Link` 组件，Remix 可以拦截页面转换。如果加载了 JavaScript，Remix 会阻止浏览器默认行为（全页刷新），而是通过向我们的
    `loader` 函数发送 fetch 请求来模拟这种行为以获取所需数据。
- en: 'Inspect the request in the `/dashboard/expenses/$id` invokes a fetch request
    to the `dashboard.expenses.$id.tsx` route module’s `loader` function, as shown
    in *Figure 5**.1*:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `/dashboard/expenses/$id` 路由中检查请求会调用 `dashboard.expenses.$id.tsx` 路由模块的 `loader`
    函数，如 *图 5.1* 所示：
- en: '![Figure 5.1 – Screenshot of the fetched loader data after a route transition](img/Figure_5.01_B17399.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – 路由转换后获取的 loader 数据截图](img/Figure_5.01_B17399.jpg)'
- en: Figure 5.1 – Screenshot of the fetched loader data after a route transition
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 路由转换后获取的 loader 数据截图
- en: As visible in *Figure 5**.1*, Remix executes a fetch request to the `loader`
    function, which then returns the expense object as JSON.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 5.1* 所示，Remix 执行对 `loader` 函数的 fetch 请求，然后返回 JSON 格式的费用对象。
- en: Click on another expense. Notice that Remix repeats the behavior for each navigation
    to an expense details route. Every time we click on a new expense, the URL changes,
    and the `loader` function of the details page is called again with the next `$id`
    route parameter.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击另一项费用。注意，Remix 对每个导航到费用详情路由的行为进行重复。每次我们点击新的费用时，URL 都会改变，并且详情页的 `loader` 函数会再次调用下一个
    `$id` 路由参数。
- en: Notice that Remix never re-fetches the expenses array for the overview page.
    That is because we remain on the `dashboard.expenses.tsx` route segment. **Remix
    only loads data for newly matching** **route segments.**
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，Remix 从不重新获取概述页的费用数组。这是因为我们仍然位于 `dashboard.expenses.tsx` 路由段。**Remix 只为新的匹配路由段加载数据。**
- en: Great! We are now able to fetch dynamic data with parameterized routes. Note
    that Remix only fetches data for newly matching route segments. This avoids unnecessary
    requests. We also learned that Remix fetches from `loader` functions during server-side
    rendering and client-side navigations. Remix handles data loading on a per-route
    level on both sides of the network.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们现在能够使用参数化路由获取动态数据。请注意，Remix 只为新匹配的路由段获取数据。这避免了不必要的请求。我们还了解到，Remix 在服务器端渲染和客户端导航期间从
    `loader` 函数获取数据。Remix 在网络的两侧按路由级别处理数据加载。
- en: Remix is both a frontend and a backend framework
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 是一个前端和后端框架
- en: Remix calls `loader` functions on the initial request on the server before rendering
    React server-side. On the client, Remix fetches loader data on client-side navigations
    with AJAX requests (fetch requests).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 在服务器端渲染 React 之前，在服务器上对初始请求调用 `loader` 函数。在客户端，Remix 使用 AJAX 请求（fetch
    请求）在客户端导航时获取 loader 数据。
- en: Revisit the concepts introduced in this section by updating the `dashboard.income.$id.tsx`
    route module so that it matches `dashboard.expenses.$id.tsx`. Make sure you test
    your implementation before moving on. Inspect which `loader` functions are executed
    when switching between the `/income` and `/expenses` routes by using the **Network**
    tab.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更新 `dashboard.income.$id.tsx` 路由模块以匹配 `dashboard.expenses.$id.tsx`，回顾本节中介绍的概念。在继续之前，确保测试你的实现。通过使用
    **网络** 选项卡检查在 `/income` 和 `/expenses` 路由之间切换时执行的 `loader` 函数。
- en: Next, let’s see how `loader` functions are called in parallel. For this, we
    need to adapt our application logic a bit.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 `loader` 函数是如何并行调用的。为此，我们需要对我们的应用程序逻辑进行一些调整。
- en: Loading data in parallel
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行加载数据
- en: 'As visible in *Figure 5**.2*, the expense overview page has two sections –
    the list of all expenses (`dashboard.expenses.tsx`) and the details view of the
    currently selected expense (`dashboard.expenses.$id.tsx`). The details view is
    empty when navigating to `/dashboard/expenses` since the nested `$id` route module
    does not appear on the screen:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 5**.2* 所示，费用概览页面有两个部分 – 所有费用的列表 (`dashboard.expenses.tsx`) 和当前选中费用的详细视图
    (`dashboard.expenses.$id.tsx`)。当导航到 `/dashboard/expenses` 时，详细视图是空的，因为嵌套的 `$id`
    路由模块不会出现在屏幕上：
- en: '![Figure 5.2 – Screenshot of the expenses route with a nested $id route module](img/Figure_5.02_B17399.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 费用路由的截图，包含嵌套的 $id 路由模块](img/Figure_5.02_B17399.jpg)'
- en: Figure 5.2 – Screenshot of the expenses route with a nested $id route module
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 费用路由的截图，包含嵌套的 $id 路由模块
- en: 'Let’s update the `/dashboard/expenses`. We will update this link so that it
    points to the most recently created expense instead:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新 `/dashboard/expenses`。我们将更新此链接，使其指向最近创建的费用：
- en: Open the `dashboard.tsx` route module in your editor.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的编辑器中打开 `dashboard.tsx` 路由模块。
- en: 'Add the following `loader` function to the route module:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 `loader` 函数添加到路由模块中：
- en: '[PRE10]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `loader` function queries the database for the most recently created expense.
    It then returns the queried `firstExpense`.
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`loader` 函数查询数据库以获取最近创建的费用。然后它返回查询到的 `firstExpense`。'
- en: Note that `firstExpense` can also be `null` if the database has no expense entries.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，如果数据库中没有费用条目，`firstExpense` 也可以是 `null`。
- en: 'Next, access the `firstExpense` object using the `useLoaderData` hook:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用 `useLoaderData` 钩子访问 `firstExpense` 对象：
- en: '[PRE11]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We type the `useLoaderData` hook with the type of the `loader` function. `firstExpense`
    is now correctly typed as the serialized version of an expense object or `null`.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用 `loader` 函数的类型来键入 `useLoaderData` 钩子。`firstExpense` 现在正确地键入为费用对象的序列化版本或
    `null`。
- en: 'Use `firstExpense` to update the `to` property of the `NavLink`. Since `firstExpense`
    can be `null`, we must ensure we make this change conditionally:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `firstExpense` 更新 `NavLink` 的 `to` 属性。由于 `firstExpense` 可能是 `null`，我们必须确保我们条件性地进行此更改：
- en: '[PRE12]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Run BeeRich by executing `npm run dev` and open the expenses overview page
    in a browser window: [http://localhost:3000/dashboard/expenses](http://localhost:3000/dashboard/expenses).'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行 `npm run dev` 来运行 BeeRich，并在浏览器窗口中打开费用概览页面：[http://localhost:3000/dashboard/expenses](http://localhost:3000/dashboard/expenses)。
- en: Notice that the `NavLink` component lost its active styling. This is because
    the link now points to a nested route, which does not trigger the `isActive` condition
    on Remix’s `NavLink` component. Luckily, our custom `NavLink` component offers
    a `styleAsActive` prop, which can be used to apply the active styling whenever
    we want.
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，`NavLink` 组件丢失了其活动样式。这是因为链接现在指向一个嵌套路由，它不会在 Remix 的 `NavLink` 组件上触发 `isActive`
    条件。幸运的是，我们的自定义 `NavLink` 组件提供了一个 `styleAsActive` 属性，我们可以在需要时使用它来应用活动样式。
- en: Import the `useLocation` hook from `@remix-run/react`.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `@remix-run/react` 中导入 `useLocation` 钩子。
- en: 'Next, call the hook in the route module component:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在路由模块组件中调用钩子：
- en: '[PRE13]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Remix’s `useLocation` hook lets us access a global location object with information
    about the current URL.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Remix 的 `useLocation` 钩子让我们能够访问一个全局位置对象，其中包含有关当前 URL 的信息。
- en: 'Add the `styleAsActive` prop to the `NavLink`. Set the property to `true` whenever
    the user is on an `/``expenses` route:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `styleAsActive` 属性添加到 `NavLink` 中。当用户位于 `/``expenses` 路由时，将属性设置为 `true`：
- en: '[PRE14]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Visit the `/dashboard/income` page in a browser window and clear the **Network**
    tab.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器窗口中访问 `/dashboard/income` 页面并清除 **网络** 选项卡。
- en: Now, navigate to the details page of the most recently created expense by clicking
    on the **Expenses** navigation menu link.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过点击 **费用** 导航菜单链接，导航到最近创建的费用详情页面。
- en: 'As visible in *Figure 5**.3*, you should now see two fetch requests in the
    `loader` functions:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如 *图 5**.3* 所示，你现在应该在 `loader` 函数中看到两个 fetch 请求：
- en: '`dashboard.expenses.tsx`'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dashboard.expenses.tsx`'
- en: '`dashboard.expenses.$id.tsx`'
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dashboard.expenses.$id.tsx`'
- en: 'The `loader` function in `dashboard.tsx` is not executed as the route module
    was already active on the page before the navigation:'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`dashboard.tsx` 中的 `loader` 函数在没有导航之前页面上的路由模块已经激活的情况下不会执行：'
- en: '![Figure 5.3 – Inspecting the fetch request waterfall](img/Figure_5.03_B17399.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – 检查 fetch 请求瀑布图](img/Figure_5.03_B17399.jpg)'
- en: Figure 5.3 – Inspecting the fetch request waterfall
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 检查 fetch 请求瀑布图
- en: As visible in *Figure 5**.3*, we can inspect the waterfall of the fetch requests
    in the **Network** tab. The green bar indicates the server execution time for
    the request. Note that both fetch requests are executed in parallel. This flattens
    the request waterfall and improves the response time.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 5**.3 所示，我们可以在 **网络** 选项卡中检查获取请求的水瀑布。绿色条表示请求的服务器执行时间。请注意，两个获取请求都是并行执行的。这平缓了请求水瀑布并提高了响应时间。
- en: You might have noticed that we query the database again in the `loader` function
    in `dashboard.expenses.$id.tsx`. You might have asked yourself why we are not
    reusing the loader data from `dashboard.expenses.tsx` as we already fetch all
    expenses from the database. This is a trade-off for the parallel execution of
    `loader` functions. Several loaders cannot depend on each other’s data as they
    are all executed in parallel.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们在 `dashboard.expenses.$id.tsx` 的 `loader` 函数中再次查询数据库。你可能已经问过自己为什么我们不重用来自
    `dashboard.expenses.tsx` 的 `loader` 数据，因为我们已经从数据库中获取了所有费用。这是 `loader` 函数并行执行的一个权衡。由于所有
    `loader` 都是在并行执行，因此几个 `loader` 不能相互依赖。
- en: 'Let’s summarize our observations:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下我们的观察结果：
- en: On initial request, Remix renders our app on the server.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在初始请求时，Remix 在服务器上渲染我们的应用程序。
- en: All active `loader` functions are executed in parallel and passed to the React
    app during server-side rendering.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有活跃的 `loader` 函数都并行执行，并在服务器端渲染期间传递给 React 应用程序。
- en: With loaders, we fetch application data on a per-route level.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用加载器，我们在每个路由级别上获取应用程序数据。
- en: Remix emulates the browser’s default behavior with JavaScript. All subsequent
    page navigations execute client-side if JavaScript has loaded.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Remix 使用 JavaScript 模拟浏览器的默认行为。所有后续的页面导航如果已加载 JavaScript，则执行客户端操作。
- en: Remix uses fetch requests to load all required loader data on navigation.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Remix 使用获取请求在导航时加载所有必需的 `loader` 数据。
- en: The `loader` functions of all newly matching route segments are executed in
    parallel.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有新匹配的路由段 `loader` 函数都并行执行。
- en: Already active `loader` functions are not executed again.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已经活跃的 `loader` 函数不再执行。
- en: Practice what you’ve learned in this section by implementing the same functionality
    on the `/income` routes. Query for the most recently created invoice in the `dashboard.tsx`
    route module’s `loader` function. Then, update the `NavLink` component. Finally,
    use the `useLocation` hook to add the `styleAsActive` prop.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 `/income` 路由上实现相同的功能来练习本节中学到的内容。在 `dashboard.tsx` 路由模块的 `loader` 函数中查询最近创建的发票。然后，更新
    `NavLink` 组件。最后，使用 `useLocation` 钩子添加 `styleAsActive` 属性。
- en: 'Next, let’s see whether we can optimize the code a bit:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看我们是否可以稍微优化一下代码：
- en: Open the `app/routes/dashboard.tsx` file in your editor.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的编辑器中打开 `app/routes/dashboard.tsx` 文件。
- en: 'After adding the invoice query to the `loader` function, the function may look
    like this:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将发票查询添加到 `loader` 函数后，该函数可能看起来像这样：
- en: '[PRE15]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Refactor the code so that it executes the two queries in parallel:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重构代码，使其并行执行两个查询：
- en: '[PRE16]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this section, we went over data fetching in Remix. You learned how to use
    and type the `useLoaderData` hook and how to query data based on dynamic route
    parameters. You now know that Remix promotes data fetching at the route module
    level. This allows us to execute `loader` functions in parallel and avoid request
    waterfalls. You further understand the importance of moving as much logic as possible
    to the server to reduce the size and complexity of the client bundle. Finally,
    you practiced optimizing `loader` functions to make independent requests in parallel.
    Next, we’ll learn about data mutations.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了 Remix 中的数据获取。你学习了如何使用和类型化 `useLoaderData` 钩子以及如何根据动态路由参数查询数据。你现在知道
    Remix 在路由模块级别上促进数据获取。这允许我们并行执行 `loader` 函数并避免请求瀑布。你进一步理解了尽可能将逻辑移动到服务器以减少客户端包的大小和复杂性的重要性。最后，你练习了优化
    `loader` 函数以并行执行独立请求。接下来，我们将学习关于数据变更的内容。
- en: Mutating data
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据变更
- en: Creating and updating data is just as important as fetching data. In this section,
    we will add an expense creation form and learn how to mutate data in Remix.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和更新数据与获取数据一样重要。在本节中，我们将添加一个费用创建表单并学习如何在 Remix 中变更数据。
- en: Mutating data without JavaScript
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无 JavaScript 的数据变更
- en: Remember the three-step process for building web UIs from Ryan Florence that
    we discussed in [*Chapter 1*](B17399_01.xhtml#_idTextAnchor013)? The first step
    is to make the user experience work without JavaScript. After that, we add JavaScript
    to enhance the experience but ensure that the baseline implementation still works.
    This process is called **progressive enhancement**.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们之前讨论过的瑞安·弗洛伦斯（Ryan Florence）构建Web UI的三个步骤吗？[第1章](B17399_01.xhtml#_idTextAnchor013)？第一步是让用户体验在没有JavaScript的情况下也能工作。之后，我们添加JavaScript来增强用户体验，但确保基本实现仍然有效。这个过程被称为**渐进增强**。
- en: 'In this section, we use Remix''s `action` function to handle incoming form
    submissions on the server. In the `action` function, we will validate the user
    data and write the new expense object to the database. Let''s see how we can use
    the native form element to submit user data, without the need for client-side
    JavaScript:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们使用Remix的`action`函数来处理服务器上的传入表单提交。在`action`函数中，我们将验证用户数据并将新的支出对象写入数据库。让我们看看我们如何使用原生的表单元素提交用户数据，而无需客户端JavaScript：
- en: 'First, create a new route module for the expense creation form: `app/routes/dashboard.expenses._index.tsx`.'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，为支出创建表单创建一个新的路由模块：`app/routes/dashboard.expenses._index.tsx`。
- en: 'We add the expense creation form to the index route of the `/dashboard/expenses/`
    path. This leads to the following route hierarchy:'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将支出创建表单添加到`/dashboard/expenses/`路径的索引路由中。这导致以下路由层次结构：
- en: '`/dashboard/expenses/`: Shows the expenses list and the expense creation form'
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/dashboard/expenses/`：显示支出列表和支出创建表单'
- en: '`/dashboard/expenses/$id`: Shows the expenses list and the expense details
    for the expense with the `id` identifier'
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/dashboard/expenses/$id`：显示支出列表和具有`id`标识符的支出详情'
- en: 'Add a route component to `dashboard.expenses._index.tsx` that contains an HTML
    form element:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`dashboard.expenses._index.tsx`添加一个包含HTML表单元素的路由组件：
- en: '[PRE17]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: POST to mutate, GET to load
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用POST进行修改，使用GET进行加载
- en: HTML forms use the HTTP verbs `POST` and `GET` for submissions. It’s best to
    use a `POST` request for mutations and a `GET` request to read data from the server.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: HTML表单使用HTTP动词`POST`和`GET`进行提交。最好使用`POST`请求进行修改，使用`GET`请求从服务器读取数据。
- en: We want to submit the data to the `dashboard.expenses._index.tsx` route module
    (the route module of the form element). Note that this is the default behavior,
    so we could also omit the attribute declaration. However, for educational purposes,
    we set `action` to `/dashboard/expenses?index` as the pathname for the action.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将数据提交到`dashboard.expenses._index.tsx`路由模块（表单元素的路由模块）。请注意，这是默认行为，因此我们也可以省略属性声明。然而，出于教育目的，我们将`action`设置为`/dashboard/expenses?index`作为动作的路径名。
- en: Note the `?index` search parameter that is added to the action’s pathname. Index
    route modules and their parent route modules both match the same URL. When defining
    an `action` function, that action can live in either `dashboard.expenses.tsx`
    or `dashboard.expenses._index.tsx`. The `?index` search parameter tells Remix
    to submit to the index route module, not the parent module.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 注意添加到动作路径名的`?index`搜索参数。索引路由模块及其父路由模块都匹配相同的URL。在定义`action`函数时，该动作可以存在于`dashboard.expenses.tsx`或`dashboard.expenses._index.tsx`中。`?index`搜索参数告诉Remix提交到索引路由模块，而不是父模块。
- en: 'Next, let’s add input fields for the expense data:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们添加支出数据的输入字段：
- en: '[PRE18]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, add an `action` function to the route module:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，向路由模块添加一个`action`函数：
- en: '[PRE19]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Use the `request` parameter to parse the request body into form data:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`request`参数将请求体解析为表单数据：
- en: '[PRE20]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Import our database client and the `redirect` function from Remix:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Remix导入我们的数据库客户端和`redirect`函数：
- en: '[PRE21]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Validate the form data before using it to create a new expense:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用之前验证表单数据以创建新的支出：
- en: '[PRE22]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Review the return statement of the `action` function. We redirect to the expense
    details page of the created expense to communicate success:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`action`函数的返回语句。我们将重定向到创建的支出的详情页面以传达成功：
- en: '[PRE23]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Like `loader` functions, `action` functions must return a `Response` object
    or plain JSON (which Remix wraps in a `Response` object for us).
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与`loader`函数一样，`action`函数必须返回一个`Response`对象或纯JSON（Remix为我们将其包装在`Response`对象中）。
- en: We utilize Remix’s `redirect` helper function to create a redirect response
    object.
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用Remix的`redirect`辅助函数来创建重定向响应对象。
- en: 'Open the `/dashboard.expenses.$id.tsx` route module in your editor and add
    a quick link to the expense creation page:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的编辑器中打开`/dashboard/expenses.$id.tsx`路由模块，并添加一个快速链接到支出创建页面：
- en: '[PRE24]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Execute `npm run dev` to start the dev server.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`npm run dev`以启动开发服务器。
- en: Navigate to the expenses overview page ([http://localhost:3000/dashboard/expenses/](http://localhost:3000/dashboard/expenses/))
    and test the implementation. Create your first expense!
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到费用概览页面([http://localhost:3000/dashboard/expenses/](http://localhost:3000/dashboard/expenses/))并测试实现。创建你的第一个费用！
- en: What do you notice? When submitting the native HTML form element, the browser
    executes a full-page reload. This is the browser’s default behavior on form submissions.
    Furthermore, you might notice that the created expense appears in the expense
    list after completing the submission.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到了什么？当提交原生的HTML表单元素时，浏览器执行了整个页面的重新加载。这是浏览器在表单提交时的默认行为。此外，你可能还会注意到，创建的费用在提交完成后出现在费用列表中。
- en: A full-page reload triggers a refresh of the full page. Remix renders the HTML
    on the server and triggers all active loader functions. The expense overview is
    reloaded on submission.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 整个页面的重新加载会触发整个页面的刷新。Remix在服务器上渲染HTML并触发所有活动的加载器函数。费用概览在提交时重新加载。
- en: The form element provides a `FormData` API and use named input fields to declare
    what fields should be sent to the server. Form submissions trigger `POST` requests
    to the `action` function. We use the `Request` object to parse the submitted form
    data. This happens on the server. So far, our implementation uses no client-side
    JavaScript.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 表单元素提供了一个`FormData` API，并使用命名输入字段来声明应该发送到服务器的字段。表单提交会触发对`action`函数的`POST`请求。我们使用`Request`对象来解析提交的表单数据。这发生在服务器上。到目前为止，我们的实现没有使用任何客户端JavaScript。
- en: 'In a React SPA, we often call `event.preventDefault` in `onSubmit` handlers
    to prevent the browser’s default behavior. Here, we initiate a client-side fetch
    request. This may look something like this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在React单页应用（SPA）中，我们通常在`onSubmit`处理程序中调用`event.preventDefault`来防止浏览器的默认行为。这里，我们发起一个客户端的fetch请求。这可能看起来像这样：
- en: '[PRE25]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: By doing so, we avoid full-page reloads and gain control over what pieces of
    the React state should be updated by the mutation. However, without supporting
    native form submissions, we lose the ability to fall back to the browser’s default
    behavior. Worse, implementing this ourselves forces us to develop custom solutions
    for pending states, error handling, and state revalidation after mutation.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们避免了整个页面的重新加载，并能够控制哪些React状态应该通过修改来更新。然而，由于不支持原生的表单提交，我们失去了回退到浏览器默认行为的能力。更糟糕的是，自行实现这一功能迫使我们开发针对挂起状态、错误处理和修改后的状态重新验证的自定义解决方案。
- en: Making it work without JavaScript enables us to support user interactions before
    JavaScript has loaded or in case it fails to load. This is a powerful feature
    we get when using Remix’s primitives and conventions. However, Remix also scales
    upward. Let’s add JavaScript to enhance the experience.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在不使用JavaScript的情况下使其工作使我们能够支持在JavaScript加载之前或加载失败时的用户交互。这是使用Remix原语和约定时所获得的一个强大功能。然而，Remix也具有向上扩展的能力。让我们添加JavaScript来增强体验。
- en: Mutating data with JavaScript
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用JavaScript修改数据
- en: 'Remix provides a `Form` component that progressively enhances the experience.
    All we need to do is replace the native HTML form element through Remix’s `Form`
    component:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Remix提供了一个`Form`组件，它渐进地增强了体验。我们只需要通过Remix的`Form`组件替换原生的HTML表单元素：
- en: 'Import the `Form` component from Remix:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Remix导入`Form`组件：
- en: '[PRE26]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Use it to replace the native HTML form element:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用它来替换原生的HTML表单元素：
- en: '[PRE27]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Our custom page loading indicator is triggered, indicating that form submissions
    also affect Remix’s global navigation object.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的自定义页面加载指示器被触发，表明表单提交也会影响Remix的全局导航对象。
- en: After submission, the app still executes a redirect and transitions the user
    to the expense details page.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交后，应用仍然执行重定向并将用户过渡到费用详情页面。
- en: After submission, the new expense appears in the expense overview list as part
    of the `/dashboard/expenses/` route’s loader data. Remix emulates the browser’s
    default behavior of refreshing all content on the page.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交后，新的费用作为`/dashboard/expenses/`路由的加载器数据的一部分出现在费用概览列表中。Remix模拟了浏览器在页面上刷新所有内容的默认行为。
- en: Remember how Remix’s `NavLink` and `Link` components enhance anchor tag navigations?
    By replacing the native form element with Remix’s `Form` component, we get client-side
    data fetching, progressive enhancement, and client-side state revalidation out
    of the box.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 记得Remix的`NavLink`和`Link`组件如何增强锚标签导航吗？通过用Remix的`Form`组件替换原生的表单元素，我们能够获得客户端数据获取、渐进增强和客户端状态重新验证的功能。
- en: We now take advantage of JavaScript on the client, but that JavaScript is provided
    through Remix’s `Form` component, and no custom boilerplate code is required.
    Remix’s `Form` component sets the global navigation object’s state to `submitting`
    and `loading` for managing pending UIs. Using Remix’s `Form` component further
    ensures the refetching of all active `loader` functions after mutation.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在利用客户端的JavaScript，但这个JavaScript是通过Remix的`Form`组件提供的，不需要任何自定义样板代码。Remix的`Form`组件将全局导航对象的州设置为`submitting`和`loading`，以管理挂起的UI。使用Remix的`Form`组件进一步确保在突变后重新获取所有活动的`loader`函数。
- en: Remix revalidates loader data after every action
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Remix在每次操作后都会重新验证loader数据
- en: Remix refreshes all loader data by re-fetching from all active `loader` functions
    after executing an `action` function, just like a full-page reload would do on
    a HTML form submission.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Remix在执行`action`函数后，通过从所有活动的`loader`函数重新获取来刷新所有loader数据，就像在HTML表单提交时进行完整页面重新加载一样。
- en: Data revalidation is a powerful feature that lets us avoid stale data on the
    client or having to develop custom logic to synchronize client and server states.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 数据重新验证是一个强大的功能，它让我们能够避免客户端上的过时数据，或者不必开发自定义逻辑来同步客户端和服务器状态。
- en: Nice! In this section, we implemented an expense creation form and associated
    `action` function. You learned how Remix removes boilerplate code by providing
    the `Form` component, which does the heavy lifting under the hood. You practiced
    declaring a fetch request using named input fields and Remix’s `Form` component.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！在本节中，我们实现了一个费用创建表单及其相关的`action`函数。你学习了Remix如何通过提供`Form`组件来移除样板代码，该组件在幕后完成繁重的工作。你练习了使用命名输入字段和Remix的`Form`组件声明获取请求。
- en: 'Before moving on, let’s style our form by bringing in some of the prepared
    UI components:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们通过引入一些准备好的UI组件来美化我们的表单：
- en: 'Import the `Textarea`, `Input`, and `Form` components from the `components`
    folder:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`components`文件夹中导入`Textarea`、`Input`和`Form`组件：
- en: '[PRE28]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Remove the import of Remix’s `Form` component since we will be using our custom
    wrapper component instead.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除Remix的`Form`组件的导入，因为我们将使用我们自己的自定义包装组件。
- en: 'Replace the native label, input, and textarea elements with our styled counterparts:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用我们的样式化替代品替换原生的标签、输入和文本区域元素：
- en: '[PRE29]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: import { Button } from '~/components/buttons';
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`import { Button } from ''~/components/buttons'';`'
- en: '[PRE30]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Replace the native button element with our wrapper component and add the `isPrimary`
    property:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用我们的包装组件替换原生的按钮元素，并添加`isPrimary`属性：
- en: '[PRE31]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Run BeeRich locally. The form should look much nicer now.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本地运行BeeRich。现在表单看起来应该好多了。
- en: 'Make sure you implement the invoice creation form and replicate what we did
    for the expense routes. Start by implementing the functionality without JavaScript.
    Then, enhance the experience with Remix’s `Form` component. I encourage you to
    keep the `Fetch/XHR` network requests and inspect how Remix revalidates all loader
    data after each form submission. If you get stuck working on the income routes,
    you can find the final solution for this chapter on GitHub: [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/05-fetching-and-mutating-data/bee-rich/solution](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/05-fetching-and-mutating-data/bee-rich/solution).'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你实现了发票创建表单，并复制我们在费用路由中做的事情。首先，在不使用JavaScript的情况下实现功能。然后，使用Remix的`Form`组件增强体验。我鼓励你保留`Fetch/XHR`网络请求，并检查Remix在每次表单提交后如何重新验证所有loader数据。如果你在处理收入路由时遇到困难，你可以在GitHub上找到本章的最终解决方案：[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/05-fetching-and-mutating-data/bee-rich/solution](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/05-fetching-and-mutating-data/bee-rich/solution)。
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Reading and writing data are important aspects of modern web application development.
    Remix provides primitives, conventions, and levers for both.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 读取和写入数据是现代网络应用开发的重要方面。Remix提供了原语、约定和杠杆，以支持这两者。
- en: This chapter introduced you to Remix’s server-side `loader` and `action` functions.
    You learned that `loader` and `action` functions are route-level HTTP request
    handlers that get and mutate data. Loaders handle HTTP `GET` requests, while `action`
    functions receive all other incoming HTTP requests.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了Remix的服务器端`loader`和`action`函数。你了解到`loader`和`action`函数是路由级别的HTTP请求处理器，用于获取和修改数据。Loaders处理HTTP
    `GET`请求，而`action`函数接收所有其他传入的HTTP请求。
- en: Initially, Remix renders our app on the server. All further page transitions
    happen on the client. On the initial request, loader data is used during server-side
    rendering. On all subsequent navigations, Remix fetches loader data via fetch
    requests and only re-renders the changing parts of the route hierarchy on the
    client.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，Remix 在服务器上渲染我们的应用程序。所有后续的页面转换都在客户端发生。在初始请求中，加载器数据在服务器端渲染期间使用。在所有后续导航中，Remix
    通过 fetch 请求获取加载器数据，并且仅在客户端重新渲染路由层次结构中变化的部分。
- en: Next, you learned that route-level data fetching allows us – among other things
    – to flatten request waterfalls that may occur with component-level fetching.
    Remix also executes `loader` functions in parallel to reduce response times.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您了解到路由级别的数据获取使我们能够——在其他方面——简化可能发生在组件级别获取中的请求瀑布。Remix 还并行执行 `loader` 函数以减少响应时间。
- en: By completing this chapter, you should now understand how Remix uses the HTML
    form element to work with mutations declaratively. Remix provides progressive
    enhancement out of the box. By default, Remix executes client-side fetch requests
    to perform data mutations. However, if JavaScript isn’t available (hasn’t loaded
    yet, failed to load, or is disabled), then Remix can fall back to the browser’s
    default behavior.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成本章，您现在应该了解 Remix 如何使用 HTML 表单元素声明式地处理突变。Remix 提供了开箱即用的渐进式增强。默认情况下，Remix
    执行客户端 fetch 请求以执行数据突变。然而，如果 JavaScript 不可用（尚未加载、加载失败或被禁用），那么 Remix 可以回退到浏览器的默认行为。
- en: In this chapter, we added an `action` function to validate request data and
    create a new expense object. Remix automatically refetches all loader data after
    every mutation. With Remix, we get data revalidation out of the box.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们添加了一个 `action` 函数来验证请求数据并创建一个新的支出对象。Remix 在每次突变后自动重新获取所有加载器数据。使用 Remix，我们能够开箱即用地获得数据重新验证。
- en: Remix’s data loading and mutations work with and without JavaScript. This allows
    us to enhance the experience progressively and make our application accessible
    to more users. In the next chapter, we will learn more about progressively enhancing
    the experience. We will formalize what we learned in this chapter and learn about
    more tools to enhance the experience in our Remix apps.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 的数据加载和突变可以在有和无 JavaScript 的情况下工作。这使我们能够逐步增强用户体验，并使我们的应用程序对更多用户可访问。在下一章中，我们将学习更多关于逐步增强用户体验的内容。我们将正式化本章所学内容，并学习更多用于增强
    Remix 应用程序体验的工具。
- en: Further reading
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The Remix documentation outlines the full stack data flow in Remix here: [https://remix.run/docs/en/2/discussion/data-flow](https://remix.run/docs/en/2/discussion/data-flow).'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 文档在这里概述了 Remix 中的全栈数据流：[https://remix.run/docs/en/2/discussion/data-flow](https://remix.run/docs/en/2/discussion/data-flow).
- en: 'You can find Remix’s documentation about data loading here: [https://remix.run/docs/en/2/guides/data-loading](https://remix.run/docs/en/2/guides/data-loading).'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下位置找到有关 Remix 数据加载的文档：[https://remix.run/docs/en/2/guides/data-loading](https://remix.run/docs/en/2/guides/data-loading).
- en: 'You can find Remix’s documentation about mutations here: [https://remix.run/docs/en/2/guides/data-writes](https://remix.run/docs/en/2/guides/data-writes).'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下位置找到有关 Remix 突变的文档：[https://remix.run/docs/en/2/guides/data-writes](https://remix.run/docs/en/2/guides/data-writes).
- en: 'The Remix team has created an amazing video series called Remix Singles that
    goes in depth into how to work with data in Remix. The series starts with a video
    about data loading, which you can find here: [https://www.youtube.com/watch?v=NXqEP_PsPNc](https://www.youtube.com/watch?v=NXqEP_PsPNc).'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 团队创建了一个名为 Remix Singles 的精彩视频系列，深入探讨了如何在 Remix 中处理数据。该系列从关于数据加载的视频开始，您可以在以下位置找到：[https://www.youtube.com/watch?v=NXqEP_PsPNc](https://www.youtube.com/watch?v=NXqEP_PsPNc).
- en: 'MDN Web Docs is a great place to learn more about the HTTP protocol: [https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP).'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: MDN Web Docs 是一个学习 HTTP 协议的绝佳地方：[https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP).
