- en: Chapter 8. React Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we looked at React on the server. We created a simple HTTP
    server followed by multiple endpoints and web sockets.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will take a step back and consider the component architecture
    we have built so far. We'll look at a couple of popular React design patterns
    and how we can make subtle improvements to our architecture.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Where we are
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take a look at the things we have created so far and how they interact
    with each other. If you've been following closely, this may all be familiar to
    you; but stick with it.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'We will talk about how these interactions are failing us and how we can improve
    them. From the moment our interface begins to render, we start to see the following
    things happen:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: We begin by creating a backend object. We use this as a store for the pages
    in our application. This has methods such as `add`, `edit`, `delete`, and `all`.
    It also acts as an event emitter, notifying listeners whenever pages change.
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create a `PageAdmin` React component and pass the `Backend` object to it.
    The `PageAdmin` component uses the `Backend` object as a data source for other
    page components, all of which are created within the `PageAdmin` render method.
    The `PageAdmin` component listens for changes in `Backend` as soon as it is mounted.
    It stops listening after it is unmounted.
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `PageAdmin` component has a few callbacks, which it passes down to the other
    page components it creates. These provide a way for child components to trigger
    changes in the `Backend` object.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Through user interaction, components such as `PageEditor` and `PageView` trigger
    the callback functions they receive from `PageAdmin`. These then trigger changes
    in the `Backend` object.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Data changes in `Backend`. At the same time, `Backend` notifies event listeners
    that the data has changed and `PageAdmin` is one of those listeners.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `PageAdmin` component updates its internal state to the newest version of
    the `Backend` pages, which causes other page components to re-render.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can imagine this as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '![Where we are](img/5268_08_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
- en: We can even reduce our existing code to the essential parts of this architecture.
    Let's re-implement listing and adding pages without styles or the build chain.
    We can use this as a starting point for the architectural improvements later in
    this chapter. This will also be a good place to recap some of the new ES6 features
    we've seen so far and learn about a few new ones.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I don''t want to repeat the whole build chain here, but we do need some help
    to use ES6 and JSX in our code:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We enable ES6/JSX transformers in `.babelrc`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can run this code with the following command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will transform the ES6/JSX code in `index.js` and all the files it imports.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'We began with the `src/backend.js` file:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`Backend` is a class with internal `id` and `pages` properties. The `id` property
    acts as an auto-increment identity value for each new page object. It has the
    `add` and `getAll` methods, which add new pages and return all pages, respectively.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: In ES6, we can define constants (variables which cannot be changed after they
    are defined and assigned). These are great for when we only need to define a variable
    once, as they guard against unintended changes.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: We assign the next identity value and increment the internal `id` property so
    that the next identity value will be different. ES6 template strings allow us
    to interpolate variables (like we do with the identity value) and define multiline
    strings.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define objects with keys matching defined local variable names using
    the new ES6 object literal syntax. In other words, `{ title }` means the same
    as `{ title: title }`.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'Each time a new page is added, `Backend` emits its `onAdd` event to any listeners.
    We can see all of this in action with the following code (in `index.js`):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In ES6, the `let` keyword works similarly to `var`. The difference is that
    `var` is scoped to the enclosing function, where `let` is scoped to the enclosing
    block:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you run this `Backend` code, you should see the following output:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can combine this with the `PageAdmin` component (in `src/page-admin.js`):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is a stateless function version of our previous `PageAdmin` component.
    We can use it with the following code (in `index.js`):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This will generate the following output:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, if we were rendering this into an HTML page, we would click on the **add
    page** link and a new page would be added to the list of existing pages inside
    `Backend`. We also created `PageAdmin` as a class so that we could add an event
    listener in the `componentWillMount` life cycle method. This listener would then
    update the child `Page` components with an updated array of pages.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: The `PageAdmin` component was used to render the `Page` components, which in
    turn rendered the `PageView` and `PageEditor` components to show and edit pages,
    respectively. We passed callback functions down through each layer so that every
    component could trigger changes in the `Backend` object without knowing how it
    stores or manipulates the data.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Flux
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this stage, we encounter the first design pattern (and the improvements we
    can make). Flux is a pattern proposed by Facebook that defines the flow of data
    in an interface.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Flux is not a library, but Facebook has released a few tools that help implement
    the design pattern. You don't have to use those tools to implement Flux. To install
    it, run `npm install --save flux` in addition to the previous dependencies.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: We implemented something very close to Flux, but our implementation is at a
    slight disadvantage. Our `Backend` class does too much. We call it directly to
    add and fetch pages. It emits events when new pages are added. It's tightly coupled
    with the components that use it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: So, we'd have a hard time replacing it with a new `Backend` class (unless the
    methods, events and return values were in the exact same format). We'd have a
    hard time using multiple data backends. We don't even really have unidirectional
    flow of data because we send *and* receive data from `Backend`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Flux differs here; it defines separate objects for *making changes* and *getting
    data*. Our `Backend` class becomes a *dispatcher* for the former and a *store*
    for the latter. What's more, instructions to change application state take the
    form of message objects (called *actions*).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'We can imagine this as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '![Flux](img/5268_08_02.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
- en: Note
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These code examples will require another library, which you can install with
    `npm install --save flux`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'We can implement this design change by creating a new `PageDispatcher` object
    (in `src/page-dispatcher.js`):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `Dispatcher` class isn't too complex. It has a couple of methods, which
    we will use shortly. What's important to note is that we are exporting an instance
    of the `Dispatcher` class, not a subclass. We only need one dispatcher for our
    page operations. So, we use it as a kind of singleton, even though we've not coded
    it specifically to be a singleton.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you're unfamiliar with the singleton pattern, you can learn about it at [https://en.wikipedia.org/wiki/Singleton_pattern](https://en.wikipedia.org/wiki/Singleton_pattern).
    The basic idea is that we create a class for something (or, in this case, use
    an existing class) but we only ever create and use a single instance of the class.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part of this change is a class called `PageStore`, which we create
    in `src/page-store.js`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This class closely resembles the `Backend` class. One notable change is that
    we no longer emit the `onAdd` event after adding new pages. Instead, we register
    a sort of event listener on `PageDispatcher`, which is how we know to add new
    pages to `PageStore`. It''s possible to call `PageStore.add` directly, but here,
    we do that in response to actions being dispatched to `PageDispatcher`. This is
    how those actions look (in `src/index.js`):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Dispatchers trigger event listeners in all registered stores. If you dispatch
    an action through a dispatcher, all stores will be notified, no matter the payload.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, stores don''t only manage collections of objects (like our pages). They''re
    not an application database. They''re meant to store all application states. Perhaps
    we should change a few methods to make this clearer, beginning in `src/page-store.js`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We're still calling this store `PageStore`, but it can hold many other kinds
    of state besides an array of pages. It could, for instance, store filter and sorting
    state as well. For each new action, we would just need to add some code to the
    `handle` method.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to adjust the calling code in `index.js`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When we run this, we should see the following output:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, we need to implement these changes in `src/page-admin.js`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, we can update `index.js` to reflect these new changes:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If we run this code, we see very similar output to the code we had before implementing
    Flux.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of using Flux
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a sense, we're still tightly coupling the code that renders interface elements
    and the code that stores and manipulates state. We've just created a bit of a
    barrier between them. So, what do we gain from this approach?
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: To start with, Flux is a popular design pattern for React applications. We can
    talk about actions, dispatchers, and stores and be sure that other React developers
    will know exactly what we mean. This decreases the learning curve for bringing
    new developers into React projects.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: We've also separated state storage from user and system actions. We have a single,
    universal object through which we can send actions. These may result in changes
    to multiple stores, which in turn can trigger changes in multiple parts of our
    interface. We don't need of multiple stores in our simple example, but complex
    interfaces can benefit from multiple stores. In these cases, a single dispatcher
    and multiple stores work well together.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's worth noting that while we've named the Flux dispatcher in such a way that
    we could have more than one dispatcher, apps usually only have one. It's also
    common to have the data backend and dispatcher act as singletons. I've chosen
    to deviate from this based on how we began our application and how we're going
    to end it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Redux
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flux leads us to separate our `Backend` class into a dispatcher and a store
    as a means of decoupling from a single state store and implementation. This leads
    to quite a bit of boilerplate, and we still have some coupling (to global dispatcher
    and store objects). It's great to have some terminology to work with, but it doesn't
    feel like the best solution.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: What if we could decouple actions and storage and remove the global objects?
    This is what Redux seeks to do along with reducing boilerplate code and bringing
    about better standards overall.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can download the Redux tools by running `npm install --save redux react-redux`
    in addition to the previous dependences. Redux is also just a pattern, but the
    tools in these libraries will help greatly in setting things up.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'Redux can be a lot to take in at first, but there are some simple underlying
    things which bind it all together. For a start, there''s the idea that all state
    is held in immutable objects. This state should only be transformed by pure functions,
    which take in the current state, and produce a new state. These pure functions
    are also sometimes called idempotent, which means they can be run many times (with
    the same input) and produce the exact same output every time. Let''s explore this
    idea with some code in `index.js`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here, we have a function that takes an initial state value and modifies it
    in the presence of the same sort of action we created for Flux. This is a pure
    function with no side-effects. A new state object is returned, and we even use
    the ES6 spread operator as a way of concatenating the pages into a new array.
    It''s really the same as doing the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When we prefix an array with `...`, its values expand as if we wrote them all
    out in a row. This transformer function is called a *reducer*, named after the
    reduce part of *MapReduce* ([https://en.wikipedia.org/wiki/MapReduce](https://en.wikipedia.org/wiki/MapReduce)).
    That is, Redux defines reducers as a way of reducing an initial state by passing
    it through one or more reducers to a new state.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'We give this reducer to a store similar to the one we created for Flux:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The store also acts as a dispatcher, so this is much closer to our original
    code. We register listeners on the store, so we can be notified of changes to
    state. We can use a `PageAdmin` component similar to the one we make for Flux
    (in `src/page-admin.js`):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Also, we can render all of this with a few small changes to `index.js`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can imagine a Redux application like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '![Redux](img/5268_08_03.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
- en: So, we've removed the global dependencies. We've almost come full-circle—from
    our original code to Flux to Redux.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Using context
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you build increasingly complex components, you may discover a frustrating
    side-effect to all this. In Redux, the store acts as a dispatcher. So, if you
    want to dispatch from components deep within a component hierarchy, you need to
    pass the store through multiple components that may not even need it themselves.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider, for a moment, building our CMS interface components to dispatch actions
    directly to the store. We may arrive at a hierarchy similar to this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Those nested components could also be part of a `render` method.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'It becomes tiresome passing these stores down to each component level in the
    interface. Fortunately, there is a solution to this problem. It''s called *context*,
    and it works like this. First, we create a new component and modify how things
    are rendered in `index.js`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The new component is called `Provider`, and it renders all nested components
    without modification. However, it does define a new life cycle method called `getChildContext`.
    This returns an object with the property values that we want nested components
    to be given. These values are similar to `props`; however, they are implicitly
    provided to nested components.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'Along with `getChildContext`, we also need to define `Provider.childContextTypes`.
    These `React.PropTypes` should match what we want to return from `getChildContext`.
    Similarly, we need to modify `PageAdmin`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When we define `PageAdmin.contextTypes`, we allow components higher up in the
    hierarchy to provide their context to `PageAdmin`. In this case, context will
    contain a reference to the store. To that end, we change `props.store` to `context.store`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a common occurrence in Redux architecture. It is so common that such
    a `Provider` component comes standard with the Redux tools. We can replace our
    `Provider` implementation with the one imported from *ReactRedux*:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这在 Redux 架构中是一个常见的现象。它如此普遍，以至于这样的 `Provider` 组件是 Redux 工具的标准组成部分。我们可以用从 *ReactRedux*
    导入的 `Provider` 实现来替换我们的 `Provider` 实现：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We don't even need to define `Provider.childContextTypes`. We do, however, still
    need to define `PageAdmin.contextTypes` to opt in to the provided context though.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至不需要定义 `Provider.childContextTypes`。然而，我们仍然需要定义 `PageAdmin.contextTypes`
    以选择加入提供的环境。
- en: Benefits of Redux
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Redux 的优势
- en: Redux is growing in popularity, and it's no surprise. It has all the benefits
    of Flux (such as true unidirectional flow of data and less coupling to a single
    backend implementation) without all of the boilerplate. There's much more to learn
    about it, but what we've covered will set you in great stead to begin architecting
    better applications!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Redux 正在变得越来越受欢迎，这并不令人惊讶。它拥有 Flux 的所有优势（例如真正的单向数据流和减少对单一后端实现的耦合）而没有所有样板代码。关于
    Redux 还有更多东西要学习，但我们所涵盖的内容将为你开始构建更好的应用程序打下坚实的基础！
- en: Note
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can learn more about Redux at [https://egghead.io/series/getting-started-with-redux](https://egghead.io/series/getting-started-with-redux).
    It's a fantastic video course by the creator of Redux.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://egghead.io/series/getting-started-with-redux](https://egghead.io/series/getting-started-with-redux)
    了解更多关于 Redux 的信息。这是一套由 Redux 创作者制作的精彩视频课程。
- en: Summary
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about modern architectural design patterns that
    we can use to build better React applications. We began with the Flux pattern
    and moved on to Redux.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了我们可以用来构建更好的 React 应用程序的现代架构设计模式。我们从 Flux 模式开始，然后转向 Redux。
- en: In the next chapter, we will look at how to create plugin-based components to
    allow our interfaces to be extended by others.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何创建基于插件的组件，以便我们的界面可以被他人扩展。
