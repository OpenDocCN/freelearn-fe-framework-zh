- en: '*Chapter 10*: Using the Angular Compatibility Compiler'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 10 章*：使用 Angular 兼容性编译器'
- en: Angular Ivy replaces the previous-generation Angular compiler and rendering
    runtime known as Angular View Engine. The last version to support the View Engine
    runtime is Angular version 11.2.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Angular Ivy 替换了之前一代的 Angular 编译器和渲染运行时，即 Angular View Engine。支持 View Engine
    运行时的最后一个版本是 Angular 版本 11.2。
- en: In this chapter, we are going to learn about the bridge between View Engine-compiled
    Angular packages on npm and your Angular Ivy application, namely the **Angular
    Compatibility Compiler** (**ngcc**).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习 npm 上 View Engine 编译的 Angular 包与您的 Angular Ivy 应用程序之间的桥梁，即 **Angular
    兼容性编译器**（**ngcc**）。
- en: 'This chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Introducing the Angular Compatibility Compiler
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Angular 兼容性编译器
- en: Using the Angular Compatibility Compiler
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Angular 兼容性编译器
- en: Improving the Angular Compatibility Compiler in your CI/CD workflow
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的 CI/CD 工作流程中改进 Angular 兼容性编译器
- en: If your Angular Ivy application consumes View Engine-compiled libraries from
    a package registry, you must use the Angular Compatibility Compiler. After learning
    about the topics covered in this chapter, you will know what is happening in your
    local development workflow and be able to fine-tune the Angular Compatibility
    Compiler in your CI/CD workflow.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的 Angular Ivy 应用程序从包注册表中消费 View Engine 编译的库，您必须使用 Angular 兼容性编译器。在了解本章涵盖的主题之后，您将了解您本地开发工作流程中正在发生的事情，并能够微调您的
    CI/CD 工作流程中的 Angular 兼容性编译器。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For the techniques demonstrated in this chapter, your application requires
    at least the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章中演示的技术，您的应用程序至少需要以下要求：
- en: Angular Ivy version 11.1
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular Ivy 版本 11.1
- en: TypeScript version 4.0
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript 版本 4.0
- en: Introducing the Angular Compatibility Compiler
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Angular 兼容性编译器
- en: The source code of Angular libraries is compiled before it is published on a
    package registry such as npm. Until Angular version 12.0, it was not possible
    to compile Angular libraries using partial Angular Ivy compilation; they had to
    be compiled with the View Engine compiler. As part of a transition period, Angular
    uses the Angular Compatibility Compiler to allow Angular Ivy applications to use
    libraries that are compiled using the View Engine compiler and published to a
    package registry.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 库的源代码在发布到 npm 等包注册表之前进行编译。直到 Angular 版本 12.0，无法使用部分 Angular Ivy 编译来编译
    Angular 库；它们必须使用 View Engine 编译器进行编译。作为过渡期的一部分，Angular 使用 Angular 兼容性编译器，允许 Angular
    Ivy 应用程序使用使用 View Engine 编译器编译并发布到包注册表的库。
- en: As of Angular version 12.2, the Angular Compatibility Compiler is still included
    as part of the Angular CLI, meaning that our Angular Ivy applications can consume
    libraries that are compiled using either the View Engine or the Angular Ivy compiler.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 Angular 版本 12.2，Angular 兼容性编译器仍然作为 Angular CLI 的一部分包含在内，这意味着我们的 Angular Ivy
    应用程序可以消费使用 View Engine 或 Angular Ivy 编译器编译的库。
- en: In Angular CLI version 12.0, partial Ivy compilation for Angular libraries was
    introduced. In short, it compiles all Angular-specific code except component templates.
    However, partial Ivy compilation breaks backward compatibility for libraries in
    that consumers must also have at least Angular CLI version 12.0\. In the period
    following this release, we will see a transition from View Engine-compiled Angular
    libraries to partially Ivy-compiled Angular libraries.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular CLI 版本 12.0 中，引入了 Angular 库的局部 Ivy 编译。简而言之，它编译了所有 Angular 特定代码，除了组件模板。然而，局部
    Ivy 编译破坏了库的向后兼容性，因为消费者也必须至少使用 Angular CLI 版本 12.0。在此发布之后的时期，我们将看到从 View Engine
    编译的 Angular 库向部分 Ivy 编译的 Angular 库的过渡。
- en: The good news is that we do not have to change anything in our Angular Ivy application
    except keep Angular packages up to date. As soon as we have at least Angular 12.0,
    our application supports partially Ivy-compiled Angular libraries through an internal
    part of the Angular framework known as the Angular Linker.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，我们不需要在我们的 Angular Ivy 应用程序中进行任何更改，只需保持 Angular 包更新即可。一旦我们至少有 Angular 12.0，我们的应用程序就通过
    Angular 框架的一个内部部分——Angular Linker，支持部分 Ivy 编译的 Angular 库。
- en: The Angular Linker is a replacement for the Angular Compatibility Compiler in
    that it converts a partially Ivy-compiled Angular library bundle to a fully Ivy-compiled
    library bundle before including it in the compilation of our application.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Angular Linker 是 Angular 兼容性编译器的替代品，它在将部分 Ivy 编译的 Angular 库包包含到我们的应用程序编译之前，将其转换为完全
    Ivy 编译的库包。
- en: As such, the Angular Compatibility Compiler will be removed in a version of
    Angular unknown at the time of writing but later than version 12.2\. When this
    happens, our Angular application will only be able to use partially Ivy-compiled
    Angular libraries.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Angular兼容性编译器将在撰写本文时未知的Angular版本中移除，但晚于版本12.2。当这种情况发生时，我们的Angular应用程序将只能使用部分Ivy编译的Angular库。
- en: Now that you have an overview of what the Angular Compatibility Compiler and
    the Angular Linker are and awareness of why they are needed, in the next section,
    we will discuss how to use the Angular Compatibility Compiler.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了Angular兼容性编译器和Angular链接器是什么，以及为什么需要它们，在下一节中，我们将讨论如何使用Angular兼容性编译器。
- en: Using the Angular Compatibility Compiler
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Angular兼容性编译器
- en: In some Angular version 9 releases, we had to run the Angular Compatibility
    Compiler manually before building, testing, or serving our Angular Ivy application.
    In later releases, this changed so that the Angular CLI triggers the Angular Compatibility
    Compiler as needed.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些Angular 9版本发布中，我们必须在构建、测试或提供Angular Ivy应用程序之前手动运行Angular兼容性编译器。在后续版本中，这发生了变化，使得Angular
    CLI根据需要触发Angular兼容性编译器。
- en: It is still possible to run the Angular Compatibility Compiler manually. In
    fact, this allows for fine-tuning it to optimal compilation speed.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然可以手动运行Angular兼容性编译器。实际上，这允许我们将其微调到最佳编译速度。
- en: 'The Angular Compatibility Compiler needs to run at least once before any of
    the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下操作之前，Angular兼容性编译器需要至少运行一次：
- en: Starting a development server
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动开发服务器
- en: Executing automated tests
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行自动化测试
- en: Building our application
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建我们的应用程序
- en: Every time we install a new version of an Angular library or an additional Angular
    library from a package registry, we must run the Angular Compatibility Compiler
    again.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们安装Angular库的新版本或从包注册表中安装的附加Angular库时，我们必须再次运行Angular兼容性编译器。
- en: Consider running the Angular Compatibility Compiler as part of your Git repository's
    `postinstall` hook. When using this technique, we do not have to wait the next
    time we perform one of the actions mentioned in the previous list. While the Angular
    Compatibility Compiler is running, we are free to change our source code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑将Angular兼容性编译器作为Git仓库的`postinstall`钩子的一部分运行。当使用此技术时，我们不必等待下一次执行前述列表中提到的任何操作。当Angular兼容性编译器正在运行时，我们可以自由更改我们的源代码。
- en: Alternatively, use the `--target` option, as described in the *Angular Compatibility
    Compiler options* section coming up next.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，使用下一节中描述的`--target`选项，即*Angular兼容性编译器选项*部分。
- en: Angular Compatibility Compiler options
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular兼容性编译器选项
- en: 'The Angular Compatibility Compiler bundles an executable named `ngcc`. When
    running this command, we can pass the following options:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Angular兼容性编译器捆绑了一个名为`ngcc`的可执行文件。当运行此命令时，我们可以传递以下选项：
- en: '`--create-ivy-entry-points`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--create-ivy-entry-points`'
- en: Create an `__ivy_ngcc_` subdirectory inside each Angular library package directory.
    Inside this directory, another subdirectory will be created with the name of the
    output bundle format, for example, `fesm2015`. Inside the bundle format folder,
    the Ivy-compiled bundles and source maps will be placed. If this option is not
    passed, the original bundles will instead be overwritten.
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在每个Angular库包目录内创建一个`__ivy_ngcc_`子目录。在此目录内，将创建一个以输出包格式命名的另一个子目录，例如，`fesm2015`。在包格式文件夹内，将放置Ivy编译的包和源映射。如果不传递此选项，则原始包将被覆盖。
- en: '`--first-only`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--first-only`'
- en: When this option is used in combination with `--properties`, the Angular Compatibility
    Compiler will only compile the first module format it recognizes in a library
    package based on the order of the package property names specified by `--properties`.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当此选项与`--properties`结合使用时，Angular兼容性编译器将根据`--properties`指定的包属性名称顺序，仅编译库包中识别的第一个模块格式。
- en: '`--properties <package-property-names>`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--properties <package-property-names>`'
- en: This option specifies the acceptable library package formats to compile using
    the Angular Compatibility Compiler. The package property names refer to the properties
    of the JSON configuration in a library package's `package.json` module declaration.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此选项指定了使用Angular兼容性编译器编译的可接受的库包格式。包属性名称指的是库包的`package.json`模块声明中的属性。
- en: 'Example: `--properties es2015 browser module main`'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 示例：`--properties es2015 browser module main`
- en: '`--target <package-name>`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--target <package-name>`'
- en: This option only compiles the specified package.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此选项仅编译指定的包。
- en: 'Example: `--target @angular/material/button`'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 示例：`--target @angular/material/button`
- en: '`--tsconfig <tsconfig-path>`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--tsconfig <tsconfig-path>`'
- en: You can use this option with `--use-program-dependencies` to target a specific
    project in your Angular workspace.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以使用此选项与 `--use-program-dependencies` 一起使用，以针对您的 Angular 工作空间中的特定项目。
- en: 'Example: `--tsconfig projects/music-app/tsconfig.app.json`'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 示例：`--tsconfig projects/music-app/tsconfig.app.json`
- en: '`--use-program-dependencies`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--use-program-dependencies`'
- en: You can use this option to decide which library packages you want to compile
    with the Angular Compatibility Compiler based on the source code in your Angular
    workspace or project.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以使用此选项根据您的 Angular 工作空间或项目中的源代码来决定您想要使用 Angular 兼容编译器编译哪些库包。
- en: A few more options exist but are for exceptional use cases.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他选项，但它们主要用于特殊情况。
- en: 'Running the Angular Compatibility Compiler manually, for example, after modifying
    or adding a package dependency, allows us to optimize the compilation speed. When
    we are triggering compilation of the entire workspace manually, we should generally
    use the following command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 手动运行 Angular 兼容编译器，例如，在修改或添加包依赖项之后，可以让我们优化编译速度。当我们手动触发整个工作空间的编译时，我们通常应该使用以下命令：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `--first-only` option ensures that only one package format is compiled into
    an Angular Ivy-compatible package bundle using the `esm2015` package format. The
    `--properties` option lists the preferred package format. Research has shown that
    the `es2015` format is generally the fastest package format to compile from a
    View Engine-compatible bundle to an Angular Ivy-compatible bundle, closely followed
    by the `module` format. Finally, the `--create-ivy-entry-points` option is generally
    faster than in-place bundle replacement.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`--first-only` 选项确保仅使用 `esm2015` 捆绑格式将一个包格式编译成与 Angular Ivy 兼容的包捆绑。`--properties`
    选项列出首选的包格式。研究表明，`es2015` 格式通常是编译从视图引擎兼容捆绑到 Angular Ivy 兼容捆绑的最快包格式，其次是 `module`
    格式。最后，`--create-ivy-entry-points` 选项通常比原地捆绑替换更快。'
- en: Important Note
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you are using Angular version 9.0 or 11.1, consider leaving out the `--create-ivy-entry-points`
    option to use in-place bundle replacement. Research has found this option to be
    slightly faster in these specific versions.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用 Angular 版本 9.0 或 11.1，请考虑省略 `--create-ivy-entry-points` 选项，以使用原地捆绑替换。研究发现，在这些特定版本中，此选项略快。
- en: Consider also adding the `--use-program-dependencies` option to only compile
    packages that are imported by an application. When using this option, we must
    run the Angular Compatibility Compiler every time we use a package for the first
    time in our application.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以考虑添加 `--use-program-dependencies` 选项，仅编译应用程序导入的包。当使用此选项时，我们必须在应用程序中首次使用包时运行
    Angular 兼容编译器。
- en: The `--use-program-dependencies` option is especially useful when using Angular
    CDK and Angular Material because they have many sub-packages that are all compiled
    individually. Additionally, every Angular CDK and Angular Material sub-package
    is compiled by default, not just the ones used by an application. This impacts
    compilation speed significantly.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`--use-program-dependencies` 选项在使用 Angular CDK 和 Angular Material 时特别有用，因为它们有许多子包，这些子包都是单独编译的。此外，默认情况下，每个
    Angular CDK 和 Angular Material 子包都会被编译，而不仅仅是应用程序使用的那些。这显著影响了编译速度。'
- en: Important Note
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The `ngcc` commands listed in this chapter are meant to be used in pre-defined
    command listings inside the `scripts` property of `package.json`. To run them
    from a terminal, prefix them with `npx`, for example, `npx ngcc --create-ivy-entry-points`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中列出的 `ngcc` 命令旨在用于 `package.json` 中 `scripts` 属性预定义的命令列表中。要从终端运行它们，请在前面加上
    `npx`，例如，`npx ngcc --create-ivy-entry-points`。
- en: That is all about options and common techniques for your local development workflow.
    In the following section, you will learn how to optimize the Angular Compatibility
    Compiler for speed in a CI/CD workflow.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是关于您本地开发工作流程中的选项和常见技术的全部内容。在下一节中，您将学习如何优化 CI/CD 工作流程中的 Angular 兼容编译器以提高速度。
- en: Improving the Angular Compatibility Compiler in your CI/CD workflow
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 CI/CD 工作流程中改进 Angular 兼容编译器
- en: As you can tell from the description of some of the options supported by the
    Angular Compatibility Compiler, it maintains files inside your application's `node_modules`
    folder. Depending on your CI environment, caching and restoring the entire `node_modules`
    folder might be too slow. In this case, cache your package manager's package cache
    folder instead.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从Angular兼容性编译器支持的一些选项的描述中可以看出，它维护您应用程序的`node_modules`文件夹中的文件。根据您的CI环境，缓存和恢复整个`node_modules`文件夹可能太慢。在这种情况下，缓存您的包管理器的包缓存文件夹。
- en: Maybe caching is not enabled at all in your CI/CD workflow. In both cases, we
    must run the Angular Compatibility Compiler in every CI/CD workflow run. It starts
    from scratch with the files it manages.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 可能你的CI/CD工作流程中根本未启用缓存。在两种情况下，我们必须在每次CI/CD工作流程运行中运行Angular兼容性编译器。它从它管理的文件开始从头开始。
- en: 'For this use case, we use guidelines described in *Angular Compatibility Compiler
    options section*. We use the following `postinstall` hook to run `ngcc` in what
    is overall the fastest combination of parameter options:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个用例，我们使用*Angular 兼容性编译器选项*章节中描述的指南。我们使用以下`postinstall`钩子来运行`ngcc`，在所有参数选项组合中，这是整体最快的组合：
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This only compiles a single package format to the Angular Ivy package format
    and prefers package formats in the order of the formats that are overall the fastest
    to compile. The package files are compiled to new files in subfolders managed
    by the Angular Compatibility Compiler rather than replacing the existing, View
    Engine-compiled package files.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这只编译单个包格式到Angular Ivy包格式，并优先考虑编译速度整体最快的格式。包文件被编译到由Angular兼容性编译器管理的子文件夹中的新文件，而不是替换现有的、由View
    Engine编译的包文件。
- en: Important Note
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Consider leaving out the `--create-ivy-entry-points` option if you are using
    Angular versions 9.0 or 11.1\. Research has indicated that in-place Ivy compilation
    is faster in these versions.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是Angular版本9.0或11.1，考虑不使用`--create-ivy-entry-points`选项。研究表明，在这些版本中，原地Ivy编译更快。
- en: Running the Angular Compatibility Compiler in a separate step rather than on
    demand has the benefit of allowing fine-tuning as we just did. Additionally, it
    allows us to track the time spent on testing or building our application while
    excluding the View Engine to Angular Ivy compilation time.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 将Angular兼容性编译器作为一个单独的步骤运行而不是按需运行的好处是，它可以像我们刚才做的那样进行微调。此外，它允许我们在排除View Engine到Angular
    Ivy编译时间的同时跟踪我们在测试或构建我们的应用上花费的时间。
- en: Targeting a single application in a monorepo workspace
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 针对一个monorepo工作区中的单个应用
- en: As discussed in the *Angular Compatibility Compiler options* section, the Angular
    CDK and Angular Material are examples of Angular library packages with many sub-packages.
    If we have a monorepo workspace with several Angular applications, perhaps only
    some of them are using the Angular CDK or Angular Material. Additionally, any
    single one of these applications is most likely not using every sub-package of
    the Angular CDK or Angular Material.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在*Angular 兼容性编译器选项*章节中讨论的那样，Angular CDK和Angular Material是Angular库包的例子，它们包含许多子包。如果我们有一个包含几个Angular应用的monorepo工作区，可能只有其中一些应用使用了Angular
    CDK或Angular Material。此外，任何一个这样的应用很可能并没有使用Angular CDK或Angular Material的每一个子包。
- en: 'We can take this into account if we have a CI or CD job targeting a single
    application, for example, a test or build job for a particular application. Imagine
    that we have a monorepo workspace with two Angular applications, one using the
    Bootstrap UI component library and the other using Angular Material. In a test
    or build job for the application using Bootstrap, we use the following command
    in a step after installing package dependencies:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个针对单个应用的CI或CD作业，例如，针对特定应用的测试或构建作业，我们可以考虑这一点。想象一下，我们有一个包含两个Angular应用的monorepo工作区，一个使用Bootstrap
    UI组件库，另一个使用Angular Material。在针对使用Bootstrap的应用的测试或构建作业中，我们在安装包依赖项的步骤之后使用以下命令：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We are targeting the Bootstrap application by passing the path of its TypeScript
    configuration file to the `--tsconfig` option and finally we are adding the `--use-program-dependencies`
    option.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过传递其TypeScript配置文件的路径到`--tsconfig`选项来针对Bootstrap应用，最后我们添加了`--use-program-dependencies`选项。
- en: This will save significant compute time in our CI/CD jobs as our CI server will
    not have to compile any sub-packages of Angular Material.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在我们的CI/CD作业中节省大量的计算时间，因为我们的CI服务器将不需要编译Angular Material的任何子包。
- en: 'Even in the case of the application using Angular Material, we can use a similar
    command to save time because it will only compile the Angular Material sub-packages
    that are imported by our application instead of all of them. This is shown in
    the following example command:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是使用Angular Material的应用程序，我们也可以使用类似的命令来节省时间，因为它只会编译由我们的应用程序导入的Angular Material子包，而不是所有子包。以下是一个示例命令：
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding command, we changed the path passed to the `--tsconfig` option.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，我们更改了传递给`--tsconfig`选项的路径。
- en: Now you have learned the most common optimization techniques for Angular application
    CI/CD workflows.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经学会了Angular应用程序CI/CD工作流程中最常见的优化技术。
- en: Summary
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we first discussed how the Angular Compatibility Compiler is
    a tool needed in the transition phase while Angular library packages are still
    compiled using the Angular View Engine compiler. The Angular Compatibility Compiler
    compiles these package bundles into the Angular Ivy format so that they can be
    used by our Angular Ivy applications.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先讨论了Angular 兼容性编译器在Angular库包仍然使用Angular 视图引擎编译器编译的过渡阶段是一个需要的工具。Angular
    兼容性编译器将这些包捆绑编译成Angular Ivy格式，以便它们可以被我们的Angular Ivy应用程序使用。
- en: Additionally, we discussed how recent versions of Angular support partially
    Ivy-compiled Angular library packages using the Angular Linker, which eventually
    fully replaces the Angular Compatibility Compiler.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还讨论了Angular的最新版本如何通过Angular Linker支持部分Ivy编译的Angular库包，这最终将完全取代Angular 兼容性编译器。
- en: After reviewing the use cases that rely on the Angular Compatibility Compiler,
    we briefly discussed the most useful options for the `ngcc` command-line tool.
    Following that, we walked through common optimization techniques using these options.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在回顾了依赖于Angular 兼容性编译器的用例之后，我们简要讨论了`ngcc`命令行工具最有用的选项。随后，我们通过使用这些选项介绍了常见的优化技术。
- en: Finally, this chapter ended by considering how the Angular Compatibility Compiler
    can be optimized for speed in CI/CD workflows. We discussed solutions for several
    specific and common use cases.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，本章通过考虑如何优化Angular 兼容性编译器在CI/CD工作流程中的速度来结束。我们讨论了针对几个特定和常见用例的解决方案。
- en: Now you know how to take advantage of the Angular Compatibility Compiler and
    you know when and how to optimize it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你知道如何利用Angular 兼容性编译器，也知道何时以及如何优化它。
- en: In the next chapter, you will be guided on migrating your existing Angular application
    from View Engine to Ivy. You will learn about automated and manual migrations
    as well as other considerations when migrating from View Engine to Angular Ivy.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将指导如何将现有的Angular应用程序从视图引擎迁移到Ivy。你将了解自动和手动迁移，以及从视图引擎迁移到Angular Ivy时的其他考虑因素。
