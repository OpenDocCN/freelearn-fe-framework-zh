- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test-Driving Redux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Redux** is a **predictable state container**. To the uninitiated, these words
    mean very little. Thankfully, TDD can help us understand how to think about and
    implement our Redux application architecture. The tests in the chapter will help
    you see how Redux can be integrated into any application.'
  prefs: []
  type: TYPE_NORMAL
- en: The headline benefit of Redux is the ability to share state between components
    in a way that provides data consistency when operating in an asynchronous browser
    environment. The big drawback is that you must introduce a whole bunch of plumbing
    and complexity into your application.
  prefs: []
  type: TYPE_NORMAL
- en: Here be dragons
  prefs: []
  type: TYPE_NORMAL
- en: For many applications, the complexity of Redux outweighs the benefits. Just
    because this chapter exists in this book does not mean you should be rushing out
    to use Redux. In fact, I hope that the code samples contained herein serve as
    warning enough for the complexity you will be introducing.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll build a reducer and a saga to manage the submission of
    our `CustomerForm` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll use a testing library named `expect-redux` to test Redux interactions.
    This library allows us to write tests that are not tied to the `redux-saga` library.
    Being independent of libraries is a great way of ensuring that your tests are
    not brittle and are resilient to change: you could replace `redux-saga` with `redux-thunk`
    and your tests would still work.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Up-front design for a reducer and a saga
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test-driving a reducer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test-driving a saga
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Switching component state for Redux state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you’ll have seen all the techniques you need for
    testing Redux.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code files for this chapter can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter12](https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter12)'
  prefs: []
  type: TYPE_NORMAL
- en: Up-front design for a reducer and a saga
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll do the usual thing of mapping out a rough plan of what
    we’re going to build.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by looking at what the actual technical change is going to be and
    discuss why we’re going to do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re going to move the logic for submitting a customer—the `doSave` function
    in `CustomerForm`—out of the React component and into Redux. We’ll use a Redux
    reducer to manage the status of the operation: whether it’s currently submitting,
    finished, or had a validation error. We’ll use a Redux saga to perform the asynchronous
    operation.'
  prefs: []
  type: TYPE_NORMAL
- en: Why Redux?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Given the current feature set of the application, there’s really no reason
    to use Redux. However, imagine that in the future, we’d like to support these
    features:'
  prefs: []
  type: TYPE_NORMAL
- en: After adding a new customer, the `AppointmentForm` component shows the customer
    information just before submitting it, without having to re-fetch the data from
    the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After finding a customer from the `CustomerSearch` component and choosing to
    create an appointment, the same customer information is shown on the appointment
    screen, without having to re-fetch the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this future scenario, it *might* make sense to have some shared Redux state
    for the customer data.
  prefs: []
  type: TYPE_NORMAL
- en: 'I say “might” because there are other, potentially simpler solutions: component
    context, or perhaps some kind of HTTP response caching. Who knows what the solution
    would look like? It’s too hard to say without a concrete requirement.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To sum up: in this chapter, we’ll use Redux to store customer data. It has
    no real benefit over our current approach, and in fact, has the drawback of all
    the additional plumbing. However, let’s press on, given that the purpose of this
    book is educational.'
  prefs: []
  type: TYPE_NORMAL
- en: Designing the store state and actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A Redux store is simply an object of data with some restrictions on how it
    is accessed. Here’s how we want ours to look. The object encodes all the information
    that `CustomerForm` already uses about a `fetch` request to save customer data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Redux changes this state by means of named actions. We will have the following
    actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ADD_CUSTOMER_REQUEST`, called when the user presses the button to submit a
    customer. This triggers the saga, which then fires off the remaining actions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ADD_CUSTOMER_SUBMITTING`, when the saga begins its work'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ADD_CUSTOMER_SUCCESSFUL`, when the server saves the customer and returns a
    new customer ID. With this action, we’ll also save the new customer information
    in the reducer, ready for later use'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ADD_CUSTOMER_VALIDATION_FAILED`, if the provided customer data is invalid'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ADD_CUSTOMER_FAILED`, if there is some other reason the server fails to save
    data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For reference, here’s the existing code that we’ll be extracting from `CustomerForm`.
    It’s all helpfully in one function, `doSave`, even though it is quite long:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We’ll replace all this code with a combination of a saga and reducer. We’ll
    start with the reducer, in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Test-driving a reducer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll test-drive a new reducer function, and then pull out
    some repeated code.
  prefs: []
  type: TYPE_NORMAL
- en: 'A reducer is a simple function that takes an action and the current store state
    as input and returns a new state object as output. Let’s build that now, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file (in a new directory) named `test/reducers/customer.test.js`.
    Add the following first test, which checks that if the reducer is invoked with
    an unknown action, our reducer should return a default state for our object. This
    is standard behavior for Redux reducers, so you should always start with a test
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `src/reducers/customer.js` file, as follows, and let’s make that test
    pass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the next test, add in support for the `ADD_CUSTOMER_SUBMITTING` action,
    as follows. This test checks that when this action is received, the status value
    is updated to `SUBMITTING`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make that pass by replacing the body of the reducer with the following code.
    We can jump directly to using a `switch` statement here (rather than using an
    `if` statement) because we know for certain that we’ll be filling out other action
    types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a second test to the `ADD_CUSTOMER_SUBMITTING` `describe` block, as follows.
    This test specifies behavior that’s expected for reducer actions: any state that
    we don’t care about (which is `status` in this case) is maintained:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make that pass by modifying the reducers, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to handle the `ADD_CUSTOMER_SUCCESSFUL` action. Start with the two
    tests shown next. I’m cheating by writing two tests at once, but that’s fine because
    I know they are a close replica of the `ADD_CUSTOMER_SUBMITTING` tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make that pass, add a final `case` statement to your reducer, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a third test, shown next. The action provides a new `customer` object with
    its assigned ID, which we should save in the reducer for later use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make that pass by adding in the `customer` property, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the next `describe` block, for `ADD_CUSTOMER_FAILED`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make those both pass by adding a new `case` statement to the `switch` reducer,
    like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We aren’t quite done with `ADD_CUSTOMER_FAILED`. In this case, we also want
    to set `error` to `true`. Recall that we used an `error` state variable in the
    `CustomerForm` component to mark when an unexplained error had occurred. We need
    to replicate that here. Add this third test to the `describe` block, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make that pass by modifying the `case` statement, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add tests for the `ADD_CUSTOMER_VALIDATION_FAILED` action, which occurs if
    field validation failed. The code is illustrated here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make these tests pass with another `case` statement in the reducer, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This action also needs a third test. This time, the action can include error
    information on what the validation errors were, as shown in the following code
    snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make that pass with the change shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That completes the reducer, but before we use it from within a saga, how about
    we dry these tests up a little?
  prefs: []
  type: TYPE_NORMAL
- en: Pulling out generator functions for reducer actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most reducers will follow the same pattern: each action will set some new data
    to ensure that the existing state is not lost.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write a couple of test-generator functions to do that for us, to help
    us dry up our tests. Proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file, `test/reducerGenerators.js`, and add the following function
    to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following `import` statement to the top of `src/reducers/customer.test.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify your tests to use this function, deleting the test in each `describe`
    block and replacing it with the following single line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Back in `test/reducerGenerators.js`, define the following function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the existing `import` statement to pull in the new function, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify your tests to use this function, just as you did before. Make sure you
    run your tests to prove they work! Your tests should now be much shorter. Here’s
    an example of the `describe` block for `ADD_CUSTOMER_SUCCESSFUL`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That concludes the reducer. Before we move on to the saga, let’s tie it into
    the application. We won’t make use of it at all, but it’s good to get the plumbing
    in now.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a store and an entry point
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to the reducer we’ve written, we need to define a function named
    `configureStore` that we’ll then call when our application starts. Proceed as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file named `src/store.js` with the following content. There’s
    no need to test this just yet, as it’s a bit like `src/index.js`: plumbing that
    connects everything together. However, we will utilize it in the next section
    when we test the saga:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `src/index.js`, add the following two `import` statements to the top of
    the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, wrap the existing JSX in a `Provider` component, as shown here. This
    is how all our components will gain access to the Redux store:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With that in place, we’re ready to write the tricky part: the saga.'
  prefs: []
  type: TYPE_NORMAL
- en: Test-driving a saga
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A saga is a special bit of code that uses JavaScript generator functions to
    manage asynchronous operations to the Redux store. Because it’s super complex,
    we won’t actually test the saga itself; instead, we’ll dispatch an action to the
    store and observe the results.
  prefs: []
  type: TYPE_NORMAL
- en: Before we get started on the saga tests, we need a new test helper function
    named `renderWithStore`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the renderWithStore test extension
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of `test/reactTestExtensions.js`, add the following new `import`
    statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The expect-redux package
  prefs: []
  type: TYPE_NORMAL
- en: For that, we’ll use the `expect-redux` package from NPM, which has already been
    included in the `package.json` file for you—make sure to run `npm install` before
    you begin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new variable, `store`, and initialize it in `initializeReactContainer`,
    as illustrated in the following code snippet. This makes use of `storeSpy` from
    `expect-redux`, which we’ll use in our tests to check calls to the store:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add your new render function below the `renderWithRouter` function, as illustrated
    in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add `dispatchStore`, which we’ll need when we start dispatching actions
    in our component, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You’ve now got all the helpers you need to begin testing both sagas and components
    that are connected to a Redux store. With all that in place, let’s get started
    on the saga tests.
  prefs: []
  type: TYPE_NORMAL
- en: Using expect-redux to write expectations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The saga we’re writing will respond to an `ADD_CUSTOMER_REQUEST` action that’s
    dispatched from the `CustomerForm` component when the user submits the form. The
    functionality of the saga is just the same as the `doSave` function listed in
    the *Designing the store state and actions* section at the beginning of this chapter.
    The difference is we’ll need to use the saga’s function calls of `put`, `call`,
    and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin by writing a generator function named `addCustomer`. Proceed as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file (in a new directory) named `test/sagas/customer.test.js`
    and add the following code to set up our `describe` block. We initialize a `store`
    variable that both our sagas and our test expectations will make use of. This
    is a repeat of the code we had previously in our `initializeReactContainer` test
    helper—which we can’t use here because we’re not writing a component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Just below the `beforeEach` block, add the following helper function, which
    gives us a slightly more elegant way of constructing the action—you’ll see that
    in the first test, coming up next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now for the first test. What is the first thing our saga should do? It must
    update our store state to reflect that the form is submitting. That way, the `CustomerForm`
    component can immediately show a submitting indicator to the user. We use an expectation
    from `expect-redux` to ensure that we dispatch the right action, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Returning promises from tests
  prefs: []
  type: TYPE_NORMAL
- en: This test returns a promise. This is a shortcut we can use instead of marking
    our test function as `async` and the expectation with `await`. Jest knows to wait
    if the test function returns a promise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with the saga implementation. Create a new file named `src/sagas/customer.js`
    with the following content. Notice the `function*` syntax, which signifies a generator
    function, and the use of `put` to fire off another action to the store:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Generator-function syntax
  prefs: []
  type: TYPE_NORMAL
- en: The arrow-function syntax that we’ve been using throughout the book does not
    work for generator functions, so we need to fall back to using the `function`
    keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before that test will pass, we need to update the store with a `addCustomer`
    saga. Starting with the imports statements, update `src/store.js` to read as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Just below those imports, add this definition of `rootSaga`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, update `configureStore` to include the saga middleware and “run” `rootSaga`,
    like so. After this change, your test should pass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That completes the first test for the saga, and gets all the necessary plumbing
    into place. You’ve also seen how to use `put`. Next up, let’s introduce `call`.
  prefs: []
  type: TYPE_NORMAL
- en: Making asynchronous requests with sagas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Within a saga, `call` allows us to perform an asynchronous request. Let’s introduce
    that now. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following test, to check the call to `fetch`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll need to define a spy on `global.fetch` for this to work. Change the `beforeEach`
    block as follows, including the new customer constant:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `src/sagas/customer.js`, update the saga import to include the `call` function,
    like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create a `fetch` function and invoke it in the saga with `call`, as follows.
    After this, your test should be passing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alright—now, let’s add a test to add in the configuration for our `fetch` request,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make that pass, add the following lines to the `fetch` definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s test that we’re sending the right customer data across. Here’s how
    we can do that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make that pass, complete the `fetch` definition, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the next test, we want to dispatch an `ADD_CUSTOMER_SUCCESSFUL` event when
    the `fetch` call returns successfully. It uses a constant named `customer` that
    we’ll define in the next step. Here’s the code we need to execute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When we set up our `fetch` spy before, we didn’t set a return value. So, now,
    create a `customer` constant and set up the `fetch` spy to return it, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import `fetchResponseOk`, like so. After this, you’ll be able to run your test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make the test pass by processing the result from the `call` function, like
    so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'What about if the `fetch` call isn’t successful, perhaps because of a network
    failure? Add a test for that, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That test makes use of `fetchResponseError`; import it now, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make the test pass by wrapping the existing code in an `if` statement with
    an `else` clause, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add a test for a more specific type of failure—a validation failure,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make that pass with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The saga is now complete. Compare this function to the function in `CustomerForm`
    that we’re replacing: `doSave`. The structure is identical. That’s a good indicator
    that we’re ready to work on removing `doSave` from `CustomerForm`.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll update `CustomerForm` to make use of our new Redux
    store.
  prefs: []
  type: TYPE_NORMAL
- en: Switching component state for Redux state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The saga and reducer are now complete and ready to be used in the `CustomerForm`
    React component. In this section, we’ll replace the use of `doSave`, and then
    as a final flourish, we’ll push our React Router navigation into the saga, removing
    the `onSave` callback from `App`.
  prefs: []
  type: TYPE_NORMAL
- en: Submitting a React form by dispatching a Redux action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the start of the chapter, we looked at how the purpose of this change was
    essentially a transplant of `CustomerForm`’s `doSave` function into a Redux action.
  prefs: []
  type: TYPE_NORMAL
- en: With our new Redux setup, we used component state to display a submitting indicator
    and show any validation errors. That information is now stored within the Redux
    store, not component state. So, in addition to dispatching an action to replace
    `doSave`, the component also needs to read state from the store. The component
    state variables can be deleted.
  prefs: []
  type: TYPE_NORMAL
- en: This has a knock-on effect on our tests. Since the saga tests the failure modes,
    our component tests for `CustomerForm` simply need to handle various states of
    the Redux store, which we’ll manipulate using our `dispatchToStore` extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start by making our component Redux-aware, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following `import` statement to the top of `test/CustomerForm.test.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the test extensions `import` statement, replacing `render` with `renderWithStore`,
    and adding the two new imports, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace all calls to `render` with `renderWithStore`. Be careful if you’re
    doing a search and replace operation: the word *render* appears in some of the
    test descriptions, and you should keep those as they are.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s rework a single test: the one with the `sends HTTP request to POST /customers
    when submitting data` description. Change that test to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make this pass, we’ll use a side-by-side implementation to ensure our other
    tests continue to pass. In `handleSubmit`, add the line highlighted in the following
    code snippet. This calls a new `addCustomerRequest` prop that we’ll define soon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That makes use of the `useDispatch` hook. Import that now, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add this line to the top of the `CustomerForm` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make the test pass, all that’s left is the definition of `addCustomerRequest`,
    which you can add just below the `import` statements and above the `CustomerForm`
    component definition, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At this point, your component is now Redux-aware, and it’s dispatching the right
    action to Redux. The remaining work is to modify the component to deal with validation
    errors coming from Redux rather than the component state.
  prefs: []
  type: TYPE_NORMAL
- en: Making use of store state within a component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, it’s time to introduce the `useSelector` hook to pull out state from the
    store. We’ll kick things off with the `ADD_CUSTOMER_FAILED` generic error action.
    Recall that when the reducer receives this, it updates the `error` store state
    value to `true`. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Find the test named `renders error message when fetch call fails`. Replace
    it with the implementation shown here. It simulates an `ADD_CUSTOMER_FAILED` action
    so that we make sure all the Redux wiring is correct. Don’t forget to remove the
    `async` keyword from the test function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add an `import` statement for the `useSelector` hook at the top of `src/CustomerForm.js`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call the `useSelector` hook at the top of the `CustomerForm` component, as
    shown in the following code snippet. It pulls out the `error` state value from
    the `customer` section of the Redux store:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Delete any line where `setError` is called. There are two occurrences, both
    in `doSave`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, you can delete the `error`/`setError` pair of variables that are defined
    with the `useState` hook at the top of `CustomerForm`. Your tests won’t run until
    you do this, due to `error` being declared twice. Your tests should be passing
    at this stage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next test, `clears error message when fetch call succeeds`, can be deleted.
    The reducer, as it stands, doesn’t actually do this; completing it is one of the
    exercises in the *Exercise* section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Find the `does not submit the form when there are validation errors` test and
    update it as follows. It should pass already:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The toNotDispatchAnAction matcher
  prefs: []
  type: TYPE_NORMAL
- en: This matcher should always be used with a timeout, such as 100 milliseconds
    in this case. That’s because, in an asynchronous environment, events may just
    be slow to occur, rather than not occurring at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Find the next test, `renders field validation errors from server`. Replace
    it with the following code, remembering to remove the `async` keyword from the
    function definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make this pass, we need to pull out `validationErrors` from the Redux customer
    store. There’s a bit of complexity here: the component already has a `validationErrors`
    state variable that covers *both* server and client validation errors. We can’t
    replace that entirely, because it handles client errors in addition to server
    errors.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So, let’s *rename* the prop we get back from the server, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: A design issue
  prefs: []
  type: TYPE_NORMAL
- en: This highlights a design issue in our original code. The `validationErrors`
    state variable had *two* uses, which were mixed up. Our change here will separate
    those uses.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re not done with this test just yet. Update the `renderError` function to
    render errors for both `validationErrors` (client-side validation) and `serverValidationErrors`
    (server-side validation), as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next tests we need to look at are for the submitting indicator. We’ll update
    these tests to respond to store actions rather than a form submission. Here’s
    the first one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make this pass, add `status` to the `useSelector` call, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Delete anywhere that `setSubmitting` is called within this component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Delete the state variable for `submitting`, and replace it with the following
    line of code. The test should now pass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, update the test named `hides indicator when form has submitted`, as follows.
    This test won’t need any change to the production code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, find the `disable the submit button when submitting` test and modify
    it in the same way as *Step 12*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That’s it for test changes, and `doSave` is almost fully redundant. However,
    the call to `onSave` still needs to be migrated across into the Redux saga, which
    we’ll do in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating router history in a Redux saga
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recall that it is the `App` component that renders `CustomerForm`, and `App`
    passes a function to the `CustomerForm`’s `onSave` prop that causes page navigation.
    When the customer information has been submitted, the user is moved onto the `/addAppointment`
    route.
  prefs: []
  type: TYPE_NORMAL
- en: But now that the form submission happens within a Redux saga, how do we call
    the `onSave` prop? The answer is that we can’t. Instead, we can move page navigation
    into the saga itself and delete the `onSave` prop entirely.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we must update `src/index.js` to use `HistoryRouter` rather than
    `BrowserRouter`. That allows you to pass in your own history singleton object,
    which you can then explicitly construct yourself and then access via the saga.
    Proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file named `src/history.js` and add the following content to it.
    This is very similar to what we already did in `test/reactTestExtensions.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update `src/index.js`, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can use `appHistory` in our saga. Open `test/sagas/customer.js` and
    add the following `import` statement to the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add the following two tests to define how the navigation should occur:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make these pass, start by opening `src/sagas/customer.js` and adding the
    following `import` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, update the `addCustomer` generator function to navigate after a customer
    has been added successfully, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, all that’s left is to delete the existing `onSave` plumbing from `App`
    and `CustomerForm`. Open `test/App.test.js` and delete the following three tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`calls fetch with correct configuration`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`navigates to /addAppointment after the CustomerForm is submitted`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`passes saved customer to AppointmentFormLoader after the CustomerForm is submitted`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also delete the `beforeEach` block that sets up `global.fetch` in the
    nested `describe` block labeled `when POST request returns an error`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `src/App.js`, delete the definition of `transitionToAddAppointment` and
    change the `/addCustomer` route to have no `onSave` prop, as shown in the following
    code snippet. Your `App` tests should be passing at this point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can delete the `onSave` prop from `CustomerForm`. Start by deleting
    the following tests from the `CustomerForm` test suite that are no longer necessary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`notifies onSave when form is submitted`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`does not notify onSave if the POST request returns an error`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete the `onSave` prop from the `CustomerForm` component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, remove the invocation of `doSave` from `handleSubmit`. This function
    no longer awaits anything, so you can safely remove `async` from the function
    definition. At this point, all your tests should be passing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You’ve now seen how you can integrate a Redux store into your React components,
    and how you can control React Router navigation from within a Redux saga.
  prefs: []
  type: TYPE_NORMAL
- en: All being well, your application should now be running with Redux managing the
    workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This has been a whirlwind tour of Redux and how to refactor your application
    to it, using TDD.
  prefs: []
  type: TYPE_NORMAL
- en: As warned in the introduction of this chapter, Redux is a complex library that
    introduces a lot of extra plumbing into your application. Thankfully, the testing
    approach is straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we’ll add yet another library: Relay, the GraphQL client.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modify the customer reducer to ensure that `error` is reset to `false` when
    the `ADD_CUSTOMER_SUCCESSFUL` action occurs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information, have a look at the following sources:'
  prefs: []
  type: TYPE_NORMAL
- en: 'MDN documentation on generator functions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function*](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function*)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Home page for the `expect-redux` package:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/rradczewski/expect-redux](https://github.com/rradczewski/expect-redux)'
  prefs: []
  type: TYPE_NORMAL
