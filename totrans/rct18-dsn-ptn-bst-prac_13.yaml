- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding GraphQL with a Real Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**GraphQL** is a powerful query language designed to work seamlessly with APIs,
    allowing them to efficiently interact with your existing data. Unlike traditional
    REST APIs, GraphQL provides a comprehensive overview of the data in your API,
    making it easy to request only the exact data you need and nothing more. This
    not only streamlines your API requests but also makes it easier to optimize and
    improve your APIs when necessary. Additionally, GraphQL comes equipped with powerful
    developer tools to further enhance your development experience.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll delve into the practical application of GraphQL by building
    a basic login and user registration system for a real-world project. By exploring
    how GraphQL can be utilized in this context, you’ll gain a comprehensive understanding
    of the language and be able to apply it effectively in your own projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing PostgreSQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating environment variables with a `.env` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Apollo Server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining GraphQL queries and mutations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with resolvers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Sequelize models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing JWT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using GraphQL Playground
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Node.js 19+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PostgreSQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Homebrew ([https://brew.sh](https://brew.sh))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: pgAdmin 4 ([https://www.pgadmin.org/download/](https://www.pgadmin.org/download/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the code for this chapter in this book’s GitHub repository at [https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter13](https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter13).
  prefs: []
  type: TYPE_NORMAL
- en: Building a backend login system using PostgreSQL, Apollo Server, GraphQL, Sequelize,
    and JSON Web Tokens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will be building a backend login system using PostgreSQL,
    Apollo Server, GraphQL, Sequelize, and **JSON Web Tokens** (**JWTs**). We will
    utilize PostgreSQL for data storage, Sequelize to perform database operations,
    Apollo Server to create a GraphQL API, GraphQL to shape our API, and JWTs for
    user authentication and authorization. Whether you are a beginner or an experienced
    developer, this guide will offer a comprehensive understanding of how to integrate
    these technologies into a robust and secure backend login system. Let us dive
    in.
  prefs: []
  type: TYPE_NORMAL
- en: Installing PostgreSQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this example, we will use a PostgreSQL database, so you’ll need to install
    PostgreSQL to be able to run this project on your machine.
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL is an excellent choice for our database. *Why?* It excels in keeping
    data secure and well organized, even in the event of an unexpected issue. It has
    the capability to handle various types of data, which proves to be extremely convenient.
    Additionally, PostgreSQL is extensible, enabling it to go beyond the basics. It
    operates efficiently and can manage a substantial number of users concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, it boasts robust security features that ensure the protection of our
    data. Being an open-source platform, it is not only free but also benefits from
    a large community actively working toward its improvement. If you have prior experience
    with other databases, PostgreSQL is easy to comprehend, as it adheres to the same
    standards. Furthermore, it can handle considerable amounts of data and accommodate
    numerous users simultaneously. This is precisely why it stands as a reliable choice
    for projects such as our login system.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have a macOS machine, the easiest way to install PostgreSQL is by doing
    so with Homebrew. You just need to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you’ve installed it, you need to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This command creates a symbolic link (a type of shortcut) from the PostgreSQL
    `plist` files (which are configuration files used by macOS) to your `~/Library/LaunchAgents`
    directory. The options used with the `ln -sfv` command are as follows: “**s**”
    for **symbolic** (to create a symbolic link), “**f**” for **force** (to remove
    existing destination files), and “**v**” for **verbose** (to display what is happening).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you can create two new aliases to start and stop your PostgreSQL server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you should be able to start your PostgreSQL server by using `pg_start`
    or stop it with `pg_stop`. After this, you need to create your first database,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can connect to PostgreSQL using the `psql` command. If you get an
    error stating the role `"postgresql`" does not exist, you can fix it by running
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you did everything correctly, you should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A black screen with white text  Description automatically generated](img/B18414_13_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.1: psql'
  prefs: []
  type: TYPE_NORMAL
- en: If you use Windows, you can download PostgreSQL at [https://www.postgresql.org/download/windows/](https://www.postgresql.org/download/windows/)
    and for those that use Linux (Ubuntu), you can download it from [https://www.postgresql.org/download/linux/ubuntu/](https://www.postgresql.org/download/linux/ubuntu/).
  prefs: []
  type: TYPE_NORMAL
- en: Best tools for PostgreSQL database management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The best tool for PostgreSQL database management is **pgAdmin 4** ([https://www.pgadmin.org/download/](https://www.pgadmin.org/download/)).
    I like this tool as it can be used to create new servers, users, and databases
    and can be used to perform SQL queries and work with data. Remember to create
    a database in order to use it in this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, you may get an error when you start your PostgreSQL server that
    could say something like **FATAL lock file “postmaster.pid” already exists.**
    If you get this error, you can easily fix it by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: With this, you will be able to start your PostgreSQL server.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have completed the setup of PostgreSQL and have the pgAdmin tool
    available for easier database management, we can shift our focus to the next task,
    which is building our backend project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our backend project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, you need to create a backend directory in your GraphQL project (`graphql/backend`).
    After that, let’s review the huge list of NPM packages you will need to install
    (focusing on the most relevant):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Please note that some readers of my last book encountered issues with certain
    code that did not work as intended. This is due to updates to package versions
    since the time of writing.
  prefs: []
  type: TYPE_NORMAL
- en: To ensure that the code in this book functions correctly, I have specified the
    specific versions of packages that I use. It’s important to note that newer versions
    of these packages may contain breaking changes that could impact the functionality
    of the code, so it’s recommended that you use the specified versions to avoid
    any issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'The scripts you should have in your `package.json` file should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we are going to configure our environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring our .env file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `.env` file (also known as *dotenv*) is a configuration file to specify your
    application’s environment variables. Normally your application won’t change in
    development, staging, or production environments but they normally need a different
    configuration. The most common variables to change are the base URL, API URL,
    or even your API keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we jump into the actual login code, we need to create a file called
    `.env` (normally, this file is ignored by **.gitignore**), which will allow us
    to use private data, such as the database connection and security secrets. A file
    already exists in the repository called **.env.example**; you just need to rename
    it and put your connection data inside it. The `.env file` will look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Creating a basic config file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this project, we need to create a config file to store some security data,
    which should be created at **/backend/config/config.json**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we will define some basic configurations, such as our server’s port and
    some security information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you need to create an **index.ts** file in the config directory. This
    will bring in all the database connection information we defined in the `.env`
    file using the dotenv package and then export three configuration variables called
    **$db**, **$security**, and **$server**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If your `.env` file is not in the `root` directory or does not exist, all your
    variables are going to be **undefined**.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have configured your file and verified the security details of your
    project, the subsequent step toward enhancing our project involves the utilization
    and setup of Apollo Server. This invaluable tool facilitates the management of
    data exchanges between your server and client, streamlining the communication
    process.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Apollo Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apollo Server is a highly popular open-source library for working with GraphQL,
    both as a server and client. With extensive documentation and straightforward
    implementation, it has become a go-to choice for many developers. Its intuitive
    interface and flexible architecture make it easy to customize and adapt to your
    specific needs, while its robust features and reliable performance ensure seamless
    integration with your existing code base. Whether you’re a seasoned developer
    or new to GraphQL, Apollo Server is a powerful tool that can help you take your
    projects to the next level.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram explains how Apollo Server works in the client and the
    server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B18414_13_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.2: Apollo Server'
  prefs: []
  type: TYPE_NORMAL
- en: Apollo Server facilitates efficient communication between your app or website
    and the associated database. By utilizing GraphQL, it enables the frontend part
    of your app to request specific data from the backend in a single operation, resulting
    in a faster and smoother data exchange. In essence, it serves as an effective
    intermediary between your user interface and the database.
  prefs: []
  type: TYPE_NORMAL
- en: For our setup, we will use Express to establish our Apollo Server and the Sequelize
    **Object Relational Mapper** (**ORM**) to handle our PostgreSQL database. Express
    is a popular choice to configure Apollo Server due to its seamless integration
    with Apollo and its flexibility, which provides developers with greater freedom.
    Express.js is a lightweight and performance-optimized framework suitable for applications
    of various sizes, from small to large and scalable ones. Moreover, its maturity
    and extensive community support make it a reliable option. Its simplicity, especially
    for those already familiar with JavaScript and Node.js, enables a quick and efficient
    Apollo Server setup. Therefore, we will begin by importing the necessary components.
  prefs: []
  type: TYPE_NORMAL
- en: 'The required file can be found at `/backend/src/index.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we need to set up our `Express.js application` and `cors`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to create our schema using `applyMiddleware` and `makeExecutableSchema`
    by passing `typeDefs` and `resolvers`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we need to create an instance of Apollo Server, where we need to
    pass the schema and the plugins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to synchronize Sequelize. Here, we pass some optional variables
    (`alter` and `force`). If `force` is true and you change your Sequelize models,
    this will delete your tables, including their values, and force you to create
    the tables again, while if `force` is `false` and `alter` is `true`, then you
    will only update the table fields, without this affecting your values. So, you
    need to be careful with this option, as you can lose all your data by accident.
    Then, after the sync, we must run our Apollo Server, which listens to port `4000`
    (**$server.port**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This process will help us in synchronizing our database with our models, ensuring
    that any modifications made to the models will automatically update the corresponding
    tables.
  prefs: []
  type: TYPE_NORMAL
- en: Defining our GraphQL types, queries, and mutations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have created your Apollo Server instance, the next step is to create
    your GraphQL types. When setting up a GraphQL server like Apollo, creating GraphQL
    types is crucial. These types ensure that the data returned from your API is reliable
    and conforms to the expected structure. They act as a helpful reference for available
    data and its expected format. By using types, your application can precisely request
    the required data, resulting in faster execution and reduced data consumption.
    Additionally, types help maintain data consistency, resulting in a robust, comprehensible,
    and efficient API.
  prefs: []
  type: TYPE_NORMAL
- en: Scalar types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing you need to do is define your scalar types at `/backend/src/graphql/types/Scalar.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s create our `User` type (`backend/src/graphql/types/User.ts`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we use some scalar types such as **UUID** and **Datetime** to
    define some fields in our `User` type. In this case, when you define a type in
    GraphQL, you need to do so with the `type` keyword, followed by the type’s name
    capitalized. Then, you can define your fields inside the curly braces, `{}`.
  prefs: []
  type: TYPE_NORMAL
- en: There are some primitive data types in GraphQL such as `String`, `Boolean`,
    `Float`, and `Int`. You can define custom scalar types as we did with **UUID**,
    **Datetime**, and **JSON**, and you can also define custom types such as the `User`
    type and specify whether we want an array of that type, for example, `[User]`.
  prefs: []
  type: TYPE_NORMAL
- en: The `!` character after the types means the field is non-nullable.
  prefs: []
  type: TYPE_NORMAL
- en: Queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'GraphQL queries are used to read or fetch values from a data store. Now that
    you know how to define custom types, let’s define our `Query` type. Here, we will
    define `getUsers` and `getUser`. The first will retrieve a list of users, while
    the second will bring us the data of the specific user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this case, our `getUsers` query will return an array of users (`[User!]`),
    while our `getUser` query, which requires the `at` (access token) attribute, will
    return a single `User!`. Remember that with any query you add here, you will need
    to define it under your `resolvers` later (we will do that in the next section).
  prefs: []
  type: TYPE_NORMAL
- en: Mutations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Mutations are used to write or post values: that is, to modify data in the
    data store: and return a value if you want to do some comparisons with `REST`,
    such as perform any `POST`, `PUT`, `PATCH`, or `DELETE` actions. The `Mutation`
    type works exactly the same as the `Query` type, in that you need to define your
    mutations and specify what arguments you will receive and what data you will return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we have defined two mutations. The first is **createUser**,
    to register or create a new user in our data store, while the second one is to
    perform a **login**. As you may have noticed, both receive the input argument
    with some different values (`CreateUserInput` and `LoginInput`), called **input
    types**, which are used as query or mutation parameters. Finally, they will return
    the `User!` and `Token!` types, respectively. Let’s learn how to define those
    inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The inputs are normally used with mutations, but you can also use them with
    queries.
  prefs: []
  type: TYPE_NORMAL
- en: Merging type definitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we’ve defined all our types, queries, and mutations, we need to merge
    all our GraphQL files to create our GraphQL schema, which is basically one big
    file containing all our GraphQL definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, you need to create a file called `/backend/src/graphql/types/index.ts`
    that contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: After successfully merging your type definitions into one comprehensive GraphQL
    schema, the next critical step is to create resolvers. Resolvers are functions
    that have the responsibility of fetching and generating the data that corresponds
    to the fields defined in your GraphQL schema.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our resolvers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A resolver is a function that’s responsible for generating data for a field
    in your GraphQL schema. It can normally generate the data in any way you want,
    in that it can fetch data from a database or by using a third-party API.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create our user resolvers, you need to create a file called `/backend/src/graphql/resolvers/user.ts`.
    Let’s create a skeleton of what our resolver should look like. Here, we need to
    specify the functions that are defined under **Query** and **Mutation** in our
    GraphQL schema. So, your resolver should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we return an object with two main nodes called **Query** and
    **Mutation**, and we map the queries and the mutations we defined in our GraphQL
    schema (the `User.ts` file). Of course, we need to make some changes to receive
    some parameters and return some data, but I wanted to show you the basic skeleton
    of a resolver file first.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing you need to do is add some imports to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We will create the **getUsers** and **getUser** functions in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the getUsers query
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our first method will be the **getUsers** query. Let’s see how we need to define
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In any query or mutation method, we always receive four parameters: the parent
    (defined as `_`), arguments (defined as `args`), the context (defined as `ctx`),
    and info (which is optional).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to simplify the code a little bit, you can destructure the context,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In our next resolver function, we are going to destructure our arguments as
    well. Just as a reminder, the context is passed in our Apollo Server setup (we
    did this previously):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The context is very important when we need to share something globally in our
    resolvers.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the getUser query
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This function needs to be `async` because we need to perform some asynchronous
    operations, such as getting the connected user via an `at` (access token) if a
    user already has a valid session. Then, we can validate whether this is a real
    user by looking at our database. This helps stop people from modifying the cookies
    or trying to do some form of injection. If we don’t find a connected user, then
    we return an object of the user that contains empty data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Creating the mutations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our mutations are very simple: we just need to execute some functions and pass
    all our arguments by spreading the input value (this comes from our GraphQL schema).
    Let’s see what our `Mutation` node should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: You need to pass the **email**, **password**, and **models** to the `doLogin`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Merging our resolvers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we did with our `types` definitions, we need to merge all our resolvers
    using the `@graphql-tools` packages. You need to create the following file at
    `/backend/src/graphql/resolvers/index.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This will combine all your resolvers into an array of resolvers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once your resolvers are merged, bringing all your data-fetching functions into
    one coherent structure, it’s time to move on to the next phase: creating Sequelize
    models. Sequelize is a powerful tool that simplifies the interaction between your
    application and various databases, translating complex SQL commands into user-friendly
    JavaScript.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the Sequelize ORM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sequelize is a popular ORM library for Node.js. It enables developers to interact
    with databases like MySQL, PostgreSQL, SQLite, and Microsoft SQL Server by abstracting
    the underlying SQL commands into higher-level, easy-to-use JavaScript objects
    and methods.
  prefs: []
  type: TYPE_NORMAL
- en: Using Sequelize, developers can perform database operations like creating, updating,
    deleting, and querying records without having to write raw SQL queries. Sequelize
    also helps with defining data models, managing associations between tables, and
    handling database migrations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some key features of Sequelize ORM include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Model definition**: Sequelize allows you to define models with their attributes,
    data types, and constraints, which map to tables in the underlying database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Associations**: You can easily define relationships between models, such
    as one-to-one, one-to-many, and many-to-many, which map to foreign key constraints
    in the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Querying**: Sequelize provides a robust querying system that allows you to
    fetch, filter, sort, and paginate data without writing raw SQL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transactions**: It supports transactions for performing multiple database
    operations atomically.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Migrations**: Sequelize offers a migration system to manage schema changes
    over time and keep your database schema in sync with your application’s code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a user model in Sequelize
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we jump into the authentication functions, we need to create our `User`
    model in Sequelize. For this, we need to create a file at `/backend/src/models/User.ts`.
    Our model will have the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`username`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`password`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`email`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`role`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`active`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s see the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are defining a Sequelize Hook called `beforeCreate`, which
    helps us **encrypt** (using **sha1**) the user password right before the data
    is saved. Finally, we return the `User` model.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting Sequelize to a PostgreSQL database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we’ve created the user model, we need to connect Sequelize to our PostgreSQL
    database and put all our models together.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to add the following code to the `/backend/src/models/index.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Authentication functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Step by step, we are putting all the puzzle pieces together. Now, let’s look
    at the authentication functions we will use to validate whether a user is connected
    or not and get the user’s data. For this, we need to use JWTs.
  prefs: []
  type: TYPE_NORMAL
- en: JWT is an open standard outlined in RFC 7519 ([https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519)).
    It serves as a valuable tool to transmit information between parties as a JSON
    object. One of the primary advantages of JWTs is their digital signature, which
    allows them to be easily verified and trusted. The token is signed using the HMAC
    algorithm and a secret or a public key pair using RSA or ECDSA, ensuring that
    it remains secure and tamper-proof. This makes JWTs a reliable choice for authentication
    and authorization purposes in a wide range of applications.
  prefs: []
  type: TYPE_NORMAL
- en: Creating JWT functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s create some functions that will help verify a JWT and get the user data.
    For this, we need to create the `jwtVerify`, `getUserData`, and `createToken`
    functions. This file should be created at `/backend/src/lib/jwt.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `jwt.sign` is used to create a new JWT, while `jwt.verify` is
    used to validate our JWT.
  prefs: []
  type: TYPE_NORMAL
- en: Creating authentication functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we’ve created the JWT functions, we need to create some functions
    that will help us log in at `/backend/src/lib/auth.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We find a user by a `WHERE` condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Finding a user by email:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If the user does not exist, we return `Invalid Login`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We verify that our encrypted password is the same as the `user.password` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We validate that the user is active:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'If the password does not match, we return `Invalid Login`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If the account is not active, we return an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'If the user exists, the password is correct and the account is active, then
    we create the JWT:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Here, we validate whether the user exists by email, whether the password is
    correct, and whether the account is active in order to create the JWT.
  prefs: []
  type: TYPE_NORMAL
- en: Defining types and interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, we need to define our types and interfaces for all our Sequelize models
    and GraphQL inputs. For this, you need to create a file at `/backend/src/types/types.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s create our interfaces at `/backend/src/types/interfaces.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to export both files in `/backend/src/types/index.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: When you need to add more models, remember to always add your types and interfaces
    to those files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to create your `tsconfig.json` file in the `root` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will run our project and create our tables.
  prefs: []
  type: TYPE_NORMAL
- en: Running our project for the first time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next up, we’re going to start our project for the first time. If we’ve done
    everything right, we’ll see our `Users` table being set up and our Apollo Server
    will start running.
  prefs: []
  type: TYPE_NORMAL
- en: In this part, we’ll cover how to start our project. After that, we’ll explore
    how to use our GraphQL API. We’ll learn about testing queries, which allow us
    to retrieve data, and mutations, which enable us to modify data. We’ll also discuss
    validations, which are checks to ensure the correctness of our data. Lastly, we’ll
    delve into the process of user login. Let’s get started!
  prefs: []
  type: TYPE_NORMAL
- en: 'If you followed the previous sections correctly and run the `npm run dev` command,
    you should be able to see that the `Users` table has been created and that Apollo
    Server is running on port `4000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing background pattern  Description automatically generated](img/B18414_13_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.3: Running our project for the first time'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s say that you want to modify your user model and change the `"username"`
    field to `"username2"`. Let’s see what will happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This will execute the following SQL query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s suppose you changed the `force` constant in your `index.ts` file
    to `true`. The following will happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text  Description automatically generated](img/B18414_13_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.4: DROP TABLE IF EXISTS'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, if `force` is `true`, it will execute `DROP TABLE IF EXISTS
    "Users" CASCADE;`. This will completely remove your table and values and then
    recreate your table from scratch. That’s why you need to be careful when you use
    the `force` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, if you open [http://localhost:4000/graphql](http://localhost:4000/graphql),
    you should be able to see your new GraphQL Explorer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18414_13_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.5: GraphQL Explorer'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **Query your server** button and then we are ready to test our
    queries and mutations.
  prefs: []
  type: TYPE_NORMAL
- en: Testing GraphQL queries and mutations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Great! At this point, you’re very close to executing your first GraphQL query
    and mutation. The first query we will execute is going to be `getUsers`. The following
    is the correct syntax to run a query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: When you don’t have any attribute to pass to the query, you just need to specify
    the name of the query under the `query {...}` block and then specify the fields
    you want to retrieve once you’ve executed your query. In this case, we want to
    fetch the `id`, `username`, `email`, and `role` fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run this query, you will probably get an empty array of data. This is
    because we don’t have any users registered yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18414_13_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.6: getUsers query'
  prefs: []
  type: TYPE_NORMAL
- en: This means we need to execute our `createUser mutation` in order to register
    our first user. One thing I like about GraphQL Explorer is that you have all the
    schema documentation in the **Schema** icon on the left-hand side. If you click
    on the **Schema** icon, you will see all your queries and mutations listed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s click there and select our `createUser mutation` to see what needs to
    be called and what data may be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application, Teams  Description automatically generated](img/B18414_13_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.7: Schema'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the `createUser mutation` needs an `input` argument, which
    is `CreateUserInput`. Let’s click on that input:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application, Teams  Description automatically generated](img/B18414_13_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.8: CreateUserInput'
  prefs: []
  type: TYPE_NORMAL
- en: Awesome! Now, we know that we need to pass the **username**, **password**, **email**,
    **role**, and **active** fields in order to create a new user. Let’s do this!
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new tab so that you don’t lose the code of your first query and then
    write the mutation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, your mutation needs to be written under the `mutation {...}`
    block, and you must pass the `input` argument as an object in the **Variables**
    section. Finally, you must specify the fields you want to retrieve once the mutation
    has been executed correctly. If everything is OK, you should see something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application  Description automatically generated](img/B18414_13_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.9: CreateUser mutation'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re curious and wish to take a look at the terminal where you run your
    Apollo Server, you will see the SQL query that was performed for this user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The `VALUES` variables are handled by Apollo Server, so you won’t see the actual
    values in there, but you can find out which operation is being executed in the
    database.
  prefs: []
  type: TYPE_NORMAL
- en: Now, go back to your first query (`getUsers`) and run it again!
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application  Description automatically generated](img/B18414_13_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.10: getUsers query'
  prefs: []
  type: TYPE_NORMAL
- en: 'Nice: this is your first query and mutation that have been executed correctly
    in GraphQL. If you want to see this data in your database, you can use OmniDB
    or PgAdmin4 to view your `Users` table in your PostgreSQL database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application  Description automatically generated](img/B18414_13_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.11: Database query'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, our first record has its own `id` field (UUID) and also has
    an encrypted password field (remember our `beforeCreate` Hook in the user model?).
    By default, Sequelize will create the `createdAt` and `updatedAt` fields.
  prefs: []
  type: TYPE_NORMAL
- en: Testing model validations and querying users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you may recall, regarding our user model, you will want to make sure all
    the validations we did work fine, such as whether the user is unique or whether
    their email is valid and unique. You just need to execute the exact same mutation
    again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated with medium confidence](img/B18414_13_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.12: Username must be unique'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we will get a “**username must be unique**” error message because
    we’ve already registered the “admin” username. Now, let’s try to change the username
    to “**admin2**” but leave the email as is (**admin@js.education**):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated with low confidence](img/B18414_13_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.13: Email must be unique'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also get an “**email must be unique**” error for the email. Now, try
    to change the email to something invalid, such as **admin@myfakedomain**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing timeline  Description automatically generated](img/B18414_13_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.14: Invalid email'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we’re getting an `"Invalid email"` error message. This is just amazing,
    don’t you think? Now, let’s stop playing with the validations and add a new valid
    user (**username**: admin2 and **email**: admin2@js.education). Once you’ve created
    your second user, run our **getUsers** query once more. However, this time, add
    the `active` field to the list of fields we want to return:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B18414_13_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.15: getUsers query'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have two registered users, and both are inactive accounts (`"active"
    = false`).
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing I love about GraphQL is that when you’re writing your queries or
    mutations and you don’t remember a certain field, GraphQL will always show you
    the list of available fields for that query or mutation. For example, if you just
    write the letter `p` for the password, you will see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B18414_13_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.16: Autocomplete'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are ready to try and log in!
  prefs: []
  type: TYPE_NORMAL
- en: Performing a login
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I want to congratulate you for getting to this point in this book: I know we
    have covered a lot, but we are almost there! Now, we are going to try and log
    in with GraphQL (how crazy is that?).'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to write our login mutation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to log our user in by using “`fake@email.com`" as our email and
    “`123456`" as our password. These do not exist in our database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text  Description automatically generated](img/B18414_13_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.17: Invalid login after using non-existent login details'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the email does not exist in our database, an `Invalid Login` error
    message will be returned. Now, let’s add the correct email but use a fake password:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B18414_13_18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.18: Invalid login after inputting the correct email but a fake password'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we receive the exact same error (`Invalid Login`). This is because
    we don’t want to provide too much information about what’s wrong with the login,
    as someone may be trying to hack into your system. If we say something such as
    `Invalid password` or `Your email does not exist in our system`, we give the attackers
    extra information that they may find useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s try to connect with the correct user and password (`admin@js.education`
    and `123456`) and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B18414_13_19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.19: Your account is not activated yet'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we receive an error stating`Your account is not activated yet`. This is
    OK because our user has not been activated yet. Normally, when a user is registered
    in a system, you need to send a link to their email so that they can activate
    their account. We don’t have this feature at the moment, but let’s suppose we
    sent that email, and the user has already activated their account. We can simulate
    this by manually changing the value in our database using OnmiDB or PgAdmin4\.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do this by performing an `UPDATE` SQL query:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B18414_13_20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.20: UPDATE SQL query'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s try to log in again!
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B18414_13_21.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.21: Login token'
  prefs: []
  type: TYPE_NORMAL
- en: 'Nice: we are in, baby! This is you at this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18414_13_22.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.22: Anonymous'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve logged in and retrieved our JWT, let’s copy that huge string
    and use it in our **getUser** query to see whether we can get the user’s data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18414_13_23.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.23: Access token'
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything went well, then you should get the user’s data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application  Description automatically generated](img/B18414_13_24.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.24: getUser data'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you change or remove any letter from the string (meaning the token is invalid),
    then you should get empty user data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B18414_13_25.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.25: Empty getUser data'
  prefs: []
  type: TYPE_NORMAL
- en: Now that our login system works perfectly in the backend, it is time to implement
    this in the frontend application. We’ll do this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Building a frontend login system with Apollo Client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we learned how to build the backend for a login system
    using Apollo Server to create our GraphQL queries and mutations. You are probably
    thinking, *Great, I have the backend working, but how can I use this on the frontend?*
    And you’re right: I always like to explain things with full examples and not just
    show basic things, even if this will take longer to do. So let’s get started!'
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code for the example in this section at [https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter13/graphql/frontend](https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter13/graphql/frontend).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Webpack 5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of using a **vite** project, we will configure a React project from
    scratch using Webpack 5 and Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is create the frontend directory and install
    all the packages inside. To do this, we will execute the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The `buffer`, `crypto-browserify`, and `stream-browserify` are polyfills that
    were included by default in Webpack up to and including version 4\. However, in
    the latest version (Webpack 5), these are not included anymore, so you will get
    the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B18414_13_26.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.26: Webpack < 5 used to include polyfills for Node.js core modules
    by default'
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to have those scripts in your `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'I like to split my Webpack configuration into separate files to identify more
    easily what is for the client, for the server, for development, and for production.
    First let’s create our `presets` directory under `/frontend/webpack/presets`,
    and then create our `webpack.client.ts` to specify our client configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'That is our client preset; now let’s create the server preset under `/frontend/webpack/presets/webpack.server.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'After you’ve created the presets, you need to create the `loadPresets.ts` file
    that will handle those presets. This file must exist under `/frontend/webpack/loadPresets.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides the client and server presets, we need to create some other configuration
    files: one for development, another for production, and a file that will contain
    a common configuration between both. First let’s create the common configuration
    at `/frontend/webpack/webpack.common.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we need to create the development configuration at `/frontend/webpack/webpack.development.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in development, we include the `HotModuleReplacementPlugin`
    for the **HMR** to reload the site every time we make a change. After this, you
    need to create the production configuration file at `/frontend/webpack/webpack.production.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to create our Webpack types file at `/frontend/webpack/webpack.types.ts`.
    These are the TypeScript types we will use for Webpack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, you need to create the `index.xhtml` file, which should be at
    `/frontend/src/client/index.xhtml`. This will be our initial HTML file handled
    by `HtmlWebpackPlugin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will configure our TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring our TypeScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TypeScript is a special version of JavaScript, the language typically used to
    write web apps. What makes TypeScript interesting is its ability to identify mistakes
    in our code earlier, potentially saving us significant time. This feature becomes
    particularly valuable when working on large-scale projects. Therefore, we will
    utilize TypeScript for our project. Let’s now delve into the process of setting
    it up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `tsconfig.json` file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s learn how to configure the Express server.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Express server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our application requires a Express server so that we can perform validations.
    These will help us find out whether the user is connected (using a custom middleware,
    which I’ll explain later) and can also configure our Express sessions. We have
    four main routes on our site:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/`: Our home page (handled by React).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/dashboard`: Our dashboard, which is protected. Only connected users with
    god or admin permissions are allowed (handled by Express first then by React).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/login`: Our login page (handled by React).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/logout`: This will delete our existing session (handled by Express).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s look at our server code. The following file should exist at `/frontend/src/server.ts`.
    This is in order to create our Express app and run our React app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we protect our dashboard route with the `isConnected` middleware.
    Here, we validate that we only accept users that are not connected in the login
    route.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our frontend configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we need to create our frontend configuration. So, let’s create the configuration
    at `/frontend/src/config.ts`. This file will assist us to manage our GraphQL port
    and server, as well as incorporate security configurations such as our secret
    key and the expiration options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Next, we need to create a user-called middleware and the **jwt** functions to
    validate whether the user is connected and has the correct privileges.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the user middleware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In web development, a middleware is a function that has access to the request
    object (**req**), the response object (**res**), and the next function in the
    application’s request-response cycle. The next function is a function in the Express
    router that, when invoked, executes the middleware succeeding the current middleware.
    This creates a chain of functions, each of which can perform a specific task or
    modify the request and response objects as needed. By utilizing middleware, you
    can streamline your code and simplify complex processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram provides a visual representation of the middleware flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bubble chart  Description automatically generated](img/B18414_13_27.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.27: Visual representation of the middleware flow'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we will create the **isConnected** middleware to validate if a
    user is connected and has the correct privileges. If not, we will break the flow
    and redirect them to the login page. If the user is valid, we will execute the
    next piece of middleware, which will render our React application. The following
    diagram describes this process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing diagram  Description automatically generated](img/B18414_13_28.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.28: Auth middleware'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s apply the theoretical part to our code. The required file should exist
    at `/frontend/src/server/lib/middlewares/user.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Basically, with this middleware, we can control whether we want to validate
    whether the user is connected (`isLogged = true`). Then, we can validate specific
    roles (`roles = ['god', 'admin']`) and redirect the user if they are not connected
    or do not have the correct roles (`redirectTo = '/'`).
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we are using the `getUserData` function from `jwt`. We’ll create
    our `jwt` functions in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating JWT functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Earlier, when I explained the backend code, I talked about JWTs. In the frontend,
    we need those functions to validate our token and get the user’s data. Let’s create
    a file containing the following code at `/frontend/src/server/lib/jwt.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, our `getUserData` function will retrieve the user data using
    `accessToken`, which we grabbed from the cookies.
  prefs: []
  type: TYPE_NORMAL
- en: A JWT must be valid for security reasons and to ensure that the user’s identity
    is verified. The server verifies this token whenever a user makes a request. If
    the token is invalid, the server will not fulfill the user’s request. Additionally,
    the token helps protect user information, as it cannot be altered without the
    server’s knowledge. Moreover, these tokens have an expiration time, requiring
    users to log in again. This prevents unauthorized individuals from using a stolen
    token to impersonate the user. Hence, ensuring the validity of a JWT is of utmost
    importance.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our GraphQL queries and mutations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve already created the required queries and mutations in our backend project.
    At this point, however, we need to create some files that will execute them in
    our frontend project. For now, we just need to define our `getUserData` query
    and our login mutation to perform the login in the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create our `getUser` query at `/frontend/src/client/graphql/user/getUser.query.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Our login mutation should be at `/frontend/src/graphql/user/login.mutation.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have defined our query and mutation, let’s create the user context
    so that we can use them.
  prefs: []
  type: TYPE_NORMAL
- en: Creating user context to handle login and connected user
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our user context, we will have a login method that will execute our mutation
    and validate whether the email and password are correct. We will also export the
    user data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create this context at `/frontend/src/client/contexts/user.tsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we handle the login and have the `connectedUser` data in our
    context. Here, we execute `GET_USER_QUERY` all the time to verify whether the
    user is connected (validating against the database and not just with the cookies).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Apollo Client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we have created a lot of code, but none of it is going to work if we
    don’t configure Apollo Client. To configure Apollo Client, we need to add it to
    our index file at `/frontend/src/client/index.tsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Basically, we pass `config.api.uri`, which is where GraphQL Playground is running
    ([http://localhost:4000/graphql](http://localhost:4000/graphql)), and then wrap
    our `AppRoutes` component with the `ApolloProvider` component.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our app routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use `react-router-dom` to create our application routes. Let’s create
    the required code at `/frontend/src/client/AppRoutes.tsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are adding some pages to our routes, such as `HomePage`,
    `DashboardPage` (protected), and `LoginPage`. If the user tries to access a different
    URL, then we will display an `Error404` component. We’ll create these pages in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our pages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Home` page should be at `/frontend/src/client/pages/home.tsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Dashboard` page should be at `/frontend/src/client/pages/dashboard.tsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Login` page should be at `/frontend/src/client/pages/login.tsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to create our Error404 page `(/frontend/src/client/pages/error404.tsx`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: We are almost done. The last piece of this puzzle is to create the `Login` and
    `Dashboard` components. We’ll do that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our login components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I created some basic components for our login and our dashboard. Of course,
    their styles can be improved, but let’s see how they work and how our login system
    is going to look.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first file you need to create is called `LoginLayout.tsx` at `/frontend/src/client/components/users/LoginLayout.tsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The layout file is useful when we want to add a specific layout to our components.
    It is also useful to consume data from a context and pass the data or functions
    as props.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `Login` component should look like this (`/frontend/src/client/components/users/Login.tsx`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: We’ll create the `dashboard` components next.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our dashboard components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When creating our `dashboard` components, the first one should be the `DashboardLayout.tsx`
    file at `/frontend/src/client/components/dashboard/DashboardLayout.tsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how we protect our `dashboard` page to allow only connected users.
    Now, let’s create our `dashboard` component at `/frontend/src/components/dashboard/Dashboard.tsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: And with that, we’re done! We’ll test the login system in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our login system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you followed the previous sections correctly, then you should be able to
    run the login system successfully. To do this, we need to open three terminals:'
  prefs: []
  type: TYPE_NORMAL
- en: In the first one, you need to run your backend project (**npm run dev**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the other, you need to run the Node.js server in the frontend project (**npm
    run dev**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The third terminal is that when you open `http://localhost:3000`for the first
    time, you should be able to see the `Home` page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B18414_13_29.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.29: Home page'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, if you click on the **Go to Dashboard** ([http://localhost:3000/dashboard](http://localhost:3000/dashboard))
    link, you will be redirected to [http://localhost:3000/login?redirectTo=/dashboard](http://localhost:3000/login?redirectTo=/dashboard),
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application  Description automatically generated](img/B18414_13_30.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.30: Login page'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is our login form. If you try to log in with fake credentials, you should
    get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application  Description automatically generated](img/B18414_13_31.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.31: Invalid login'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to see the GraphQL request, you can do so on the **Headers** tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B18414_13_32.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.32: GraphQL request'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you can see the query you execute and the variables you send (email and
    password). You can see the response on the **Preview** tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B18414_13_33.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.33: Invalid login'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we get an `"Invalid Login"` error message, and that’s why we
    render it in our `login` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s try to connect with the correct account (**admin@js.education**
    and **123456**). If your login is correct, then you should be redirected to the
    dashboard, where you will see the following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, chat or text message  Description
    automatically generated](img/B18414_13_34.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.34: Welcome, admin! page'
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, you can take a look at the query being executed to retrieve the
    user data (**getUser**):'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer screen  Description automatically generated](img/B18414_13_35.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.35: getUser data'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you will see that the payload is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B18414_13_36.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.36: getUserData payload'
  prefs: []
  type: TYPE_NORMAL
- en: 'We get the user information from the access token (**at**). If you refresh
    the page, you should remain connected to the page. This is because we saved a
    cookie containing our token:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B18414_13_37.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.37: Cookies'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s try to modify the cookie by changing any letter of the token. For
    example, let’s change the first two letters (**ey**) to **XX**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table  Description automatically generated](img/B18414_13_38.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.38: Updating a cookie'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you will receive empty data for the user. This will invalidate the session
    and redirect you to the login page again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B18414_13_39.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.39: Empty data'
  prefs: []
  type: TYPE_NORMAL
- en: Now, you have learned how to implement GraphQL in a backend and how to consume
    queries and mutations in the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: This login system is part of a course I’m doing on YouTube, where I’m teaching
    viewers how to develop a headless CMS from scratch, so if you’re eager to learn
    more, you can check out the course at [https://www.youtube.com/watch?v=4n1AfD6aV4M](https://www.youtube.com/watch?v=4n1AfD6aV4M).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I hope you found this chapter on GraphQL, JWT creation, login functionality,
    and Sequelize model creation informative and engaging. It provided a wealth of
    valuable insights and practical tips that you can apply to your own projects,
    helping you to streamline your development process and achieve your goals more
    efficiently. By mastering these concepts, you’ll be better equipped to build robust,
    scalable applications that meet the needs of your users and drive your success.
  prefs: []
  type: TYPE_NORMAL
- en: Thank you for reading, and I look forward to sharing more with you in the next
    chapter, where you will learn how to create a monorepository and a multi-site
    project.
  prefs: []
  type: TYPE_NORMAL
