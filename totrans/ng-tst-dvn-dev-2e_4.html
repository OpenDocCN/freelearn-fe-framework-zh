<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;End-to-End Testing with Protractor"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. End-to-End Testing with Protractor</h1></div></div></div><p>Unit testing is only one aspect of testing that only tests the responsibility of every piece of code. However, when it comes to testing the flow and feature of any component, module, or full application, then <span class="strong"><strong>end-to-end</strong></span> (<span class="strong"><strong>e2e</strong></span>) testing is the only solution.</p><p>In this chapter, we will look at the end-to-end testing flow step by step through all the layers of an application. We will be introduced to Protractor, the end-to-end testing tool from the Angular team. We already know the reason behind it, why it was created, and what kind of problems it solves.</p><p>In this chapter, we will go through:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The process of installing and configuring Protractor</li><li class="listitem" style="list-style-type: disc">Implementing the Protractor end-to-end test in our existing Angular project</li><li class="listitem" style="list-style-type: disc">e2e test runs</li><li class="listitem" style="list-style-type: disc">Returning the result of the test</li></ul></div><div class="section" title="An overview of Protractor"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec30"/>An overview of Protractor</h1></div></div></div><p>Protractor is an end-to-end testing tool that runs using Node.js and is available as an npm package. Before talking about Protractor specifically, we need to understand what end-to-end testing is.</p><p>We already learned briefly about end-to-end testing in <a class="link" href="ch02.html" title="Chapter 2. Details of JavaScript Testing">Chapter 2</a>, <span class="emphasis"><em>Details of JavaScript Testing</em></span>. But let's have a quick recap:</p><p>End-to-end testing is testing an application against all the interconnected moving parts and layers of an application. This differs from unit tests, where the focus is on individual components, such as classes, services, and directives. With end-to-end testing, the focus is on how the application or a module, as a whole, works, such as confirming that the click of a button triggers x, y, and z actions.</p><p>Protractor allows the end-to-end testing of any module or even any size of web application by interacting the DOM elements of that application. It offers the ability to select a specific DOM element, share the data with that element, simulate the click of a button, and interact with an application in the same way as a user would. It then allows expectations to be set based on what the user would expect.</p><div class="section" title="Core of Protractor"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec47"/>Core of Protractor</h2></div></div></div><p>In a quick overview, we got a basic idea about Protractor--how it needs to select DOM elements and interact with them just like a real user would in order to run an e2e test on any application. To do these activities, Protractor provides some global functions; some are from its core API, and some are from WebDriver. We will discuss them in detail in <a class="link" href="ch05.html" title="Chapter 5. Protractor, a Step Ahead">Chapter 5</a>, <span class="emphasis"><em>Protractor, a Step Ahead</em></span>.</p><p>However, let's take a quick overview now:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Browser</strong></span>: Protractor provides the global function <code class="literal">browser</code>, which is a global object from WebDriver that is mostly used to interact with the application browser where the application is running during the e2e test process. It provides some useful methods to interact with, as follows:<pre class="programlisting">        browser.get('http://localhost:3000'); // to navigate the    &#13;
        browser to a specific url address  &#13;
        browser.getTitle(); // this will return the page title that &#13;
        defined in the projects landing page  &#13;
</pre><p>And there are many more, which we will discuss in the next chapter.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Element</strong></span>: This is a global function provided by Protractor; it's basically used to find a single element based on the locator, but it supports multiple element selection as well, by chaining another method, <code class="literal">.all</code> as <code class="literal">element.all</code>, which also takes <code class="literal">Locator</code> and returns <code class="literal">ElementFinderArray</code>. Let's have a look at an <code class="literal">element</code> example:<pre class="programlisting">        element(Locator); // return the ElementFinder &#13;
        element.all(Locator); // return the ElementFinderArray &#13;
        element.all(Locator).get(position);  // will return the&#13;
        defined  position &#13;
        element from the ElementFinderArray  &#13;
        element.all(Locator).count(); // will return the &#13;
        total number in the select element's array   &#13;
</pre><p>And there are many more, which we will discuss in the next chapter.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Action</strong></span>: As we have seen, the <code class="literal">element</code> method will return a selected DOM <code class="literal">element</code> object, but we need to interact with a DOM and the actions for doing that job come with some built-in methods. The DOM will not contact the browser unit with any action method calls.Let's have a look at few of action's example:<pre class="programlisting">        element(Locator).getText(); // return the ElementFinder &#13;
        based on locator  &#13;
        element.(Locator).click(); // Will trigger the click &#13;
        handler for that specific element  &#13;
        element.(Locator).clear(); // Clear the field's value &#13;
        (suppose the element is input field)</pre><p>And there are many more, which we will discuss in the next chapter.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Locator</strong></span>: This actually informs Protractor how to find a certain element in the DOM element. Protractor exports <code class="literal">Locator</code> as a global factory function, which will be used with a global <code class="literal">by</code> object.Let's have a look at a few examples of <code class="literal">Locator</code>:<pre class="programlisting">        element(by.css(cssSelector)); // select element by css &#13;
        selector  &#13;
        element(by.id(id)); //  select element by element ID &#13;
        element.(by.model); // select element by ng-model &#13;
</pre><p>And there are many more, which we will discuss in the next chapter.</p></li></ul></div></div><div class="section" title="A quick example"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec48"/>A quick example</h2></div></div></div><p>Now we can go through a quick example considering the following user specification.</p><p>Assuming that I input <code class="literal">abc</code> into the search box, the following should occur:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The search button should be clicked on</li><li class="listitem" style="list-style-type: disc">At least one result should be received</li></ul></div><p>The preceding specification describes a basic search feature. Nothing in the preceding specification describes a controller, directive, or service; it only describes the expected application behavior. If a user were to test the specification, they may perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Point the browser to the website.</li><li class="listitem">Select the input field.</li><li class="listitem">Type <code class="literal">abc</code> in the input field.</li><li class="listitem">Click on the <span class="strong"><strong>Search</strong></span> button.</li><li class="listitem">Confirm that the search output displays at least one result.</li></ol></div><p>The structure and syntax of Protractor mirrors that of Jasmine and the tests we have written in <a class="link" href="ch03.html" title="Chapter 3. The Karma Way">Chapter 3</a>, <span class="emphasis"><em>The Karma Way</em></span>. We can think of Protractor as a wrapper around Jasmine, with added features to support end-to-end testing. To write an end-to-end test with Protractor, we can follow the same steps that we just saw, but with the code.</p><p>Here are the steps with code:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Point the browser to the website:<pre class="programlisting">        browser.get('/'); &#13;
</pre></li><li class="listitem">Select the input field:<pre class="programlisting">        var inputField = element.all(by.css('input')); &#13;
</pre></li><li class="listitem">Type <code class="literal">abc</code> in the input field:<pre class="programlisting">        inputField.setText('abc'); &#13;
</pre></li><li class="listitem">Click on the <span class="strong"><strong>Search</strong></span> button:<pre class="programlisting">        var searchButton = element.all(by.css('#searchButton'); &#13;
        searchButton.click(); &#13;
</pre></li><li class="listitem">Find the search result details on the page:<pre class="programlisting">        var searchResults = element.all(by.css('#searchResult'); &#13;
</pre></li><li class="listitem">Finally, the assertion needs to be made that at least one or more search results are available on the screen:<pre class="programlisting">        expect(searchResults).count() &gt;= 1); &#13;
</pre></li></ol></div><p>As a complete test, the code will be as follows:</p><pre class="programlisting">    describe('Given I input 'abc' into the search box',function(){ &#13;
        //1 - Point browser to website &#13;
        browser.get('/'); &#13;
        //2 - Select input field &#13;
        var inputField = element.all(by.css('input')); &#13;
        //3 - Type abc into input field &#13;
        inputField.setText('abc'); &#13;
        //4 - Push search button &#13;
        var searchButton = element.all(by.css('#searchButton'); &#13;
        searchButton.click(); &#13;
        it('should display search results',function(){ &#13;
        // 5 - Find the search result details &#13;
        var searchResults = element.all(by.css('#searchResult'); &#13;
        //6 - Assert &#13;
        expect(searchResults).count() &gt;= 1); &#13;
        }); &#13;
    }); &#13;
</pre><p>That's it! When Protractor runs, it will open a browser, go to the website, follow the instructions, and finally check the expectations. The trick with end-to-end testing is having a clear vision of what the user specification is and then translating that specification to code.</p><p>The previous example is a high-level view of what will be described throughout this chapter. Now that we have been introduced to Protractor, the rest of the chapter will show how Protractor works behind the scenes, how to install it, and finally, walk us through a complete example using TDD.</p></div></div></div>
<div class="section" title="Origins of Protractor"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec31"/>Origins of Protractor</h1></div></div></div><p>Protractor is not the first end-to-end testing tool that the Angular team built. The first tool was called <span class="strong"><strong>Scenario Runner</strong></span>. In order to understand why Protractor was built, we need to first look at its predecessor--Scenario Runner.</p><p>Scenario Runner is in the maintenance mode and has reached the end of its life. It has been deprecated in the place of Protractor. In this section, we will look at what Scenario Runner was and what gaps the tool had.
</p><div class="section" title="The birth of Protractor"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec49"/>The birth of Protractor</h2></div></div></div><p>Julie Ralph is the primary contributor of Protractor. According to Julie Ralph, the motivation for Protractor was based on the following experience with the Angular Scenario Runner on another project within Google (<a class="ulink" href="http://javascriptjabber.com/106-jsj-protractor-with-julie-ralph/">http://javascriptjabber.com/106-jsj-protractor-with-julie-ralph/</a>):</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>"We tried using the Scenario Runner. And we found that it really just couldn't do the things that we needed to test. We needed to test things like logging in. Your login page isn't an Angular page, and the Scenario Runner couldn't deal with that. And it couldn't deal with things like popups and multiple windows, navigating the browser history, stuff like that."</em></span></p></blockquote></div><p>Based on her experience with the Scenario Runner, Julie Ralph decided to create Protractor to fill the gaps.</p><p>Protractor takes advantage of the maturity of the Selenium project, and wraps up its methods so that it can be easily used for Angular projects. Remember, Protractor is about testing through the eyes of the user. It was designed to test all the layers of an application: web UI, backend services, persistence layer, and so on.</p></div><div class="section" title="Life without Protractor"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec50"/>Life without Protractor</h2></div></div></div><p>Unit testing is not the only testing that needs to be written and maintained. Unit tests focus on small individual components of an application. By testing small components, the confidence in the code and logic grows. Unit tests don't focus on how the complete system works when interconnected.</p><p>End-to-end testing with Protractor allows the developer to focus on the complete behavior of a feature or module. Going back to the search example, the test should only pass if the whole user specification passes; enter data into the search box, click on the <span class="strong"><strong>Search</strong></span> button, and see the results. Protractor is not the only end-to-end testing framework out there, but it is the best choice for Angular applications. Here are a few reasons why you should choose Protractor:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It is documented throughout the Angular tutorials and examples</li><li class="listitem" style="list-style-type: disc">It can be written using multiple JavaScript testing frameworks, including Jasmine and Mocha</li><li class="listitem" style="list-style-type: disc">It provides convenience methods for Angular components, including waiting for a page to load, expectations on promises, and so on</li><li class="listitem" style="list-style-type: disc">It wraps Selenium methods that automatically wait for promises to be fulfilled</li><li class="listitem" style="list-style-type: disc">It is supported by <span class="strong"><strong>SaaS</strong></span> (<span class="strong"><strong>Software as a Service</strong></span>) providers, such as Sauce Labs, which is available at <a class="ulink" href="https://saucelabs.com/">https://saucelabs.com/</a></li><li class="listitem" style="list-style-type: disc">It is supported and maintained by the same company that maintains Angular and Google</li></ul></div></div></div>
<div class="section" title="Getting ready with Protractor"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec32"/>Getting ready with Protractor</h1></div></div></div><p>It's time to start getting our hands dirty and install and configure Protractor. Installations and applications are constantly changing. The main focus will be on the specific configuration used in this book, and not an in-depth installation guide. There are several different configurations, so review the Protractor site for additional details. To find the latest installation and configuration guide, visit <a class="ulink" href="http://angular.github.io/protractor/">http://angular.github.io/protractor/</a>.</p><div class="section" title="Installation prerequisites"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec51"/>Installation prerequisites</h2></div></div></div><p>Protractor has the following prerequisites:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Node.js</strong></span>: Protractor is a Node.js module available using npm. The best way to install Node.js is to follow the instructions on the official site at <a class="ulink" href="http://nodejs.org/download/">http://nodejs.org/download/</a>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Chrome</strong></span>: This is a web browser built by Google. It will be used to run end-to-end tests in Protractor without the need for a Selenium server. Follow the installation instructions on the official site at <a class="ulink" href="http://www.google.com/chrome/browser/">http://www.google.com/chrome/browser/</a>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Selenium WebDriver for Chrome</strong></span>: This is a tool that allows you to interact with web applications. Selenium WebDriver is provided with the Protractor <code class="literal">npm</code> module. We will walk through the instructions as we install Protractor.</li></ul></div></div><div class="section" title="Installing Protractor"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec52"/>Installing Protractor</h2></div></div></div><p>Here are the steps to install Protractor:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Once Node.js is installed and available in the Command Prompt, type the following command to install Protractor in the current directory:<pre class="programlisting">
<span class="strong"><strong>$ npm install protractor</strong></span>
</pre></li><li class="listitem">The preceding command uses Node's <code class="literal">npm</code> command to install Protractor in the current local directory.</li><li class="listitem">To use Protractor in the Command Prompt, use the relative path to the Protractor bin directory.</li><li class="listitem">Test that the Protractor version can be determined as follows:<pre class="programlisting">
<span class="strong"><strong>$ ./node_modules/protractor/bin/protractor --version</strong></span>
</pre></li></ol></div></div><div class="section" title="Installing WebDriver for Chrome"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec53"/>Installing WebDriver for Chrome</h2></div></div></div><p>Here are the steps to install WebDriver for Chrome:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">To install Selenium WebDriver for Chrome, go to the <code class="literal">webdriver-manager</code> executable in the Protractor <code class="literal">bin</code> directory that can be found at <code class="literal">./node_modules/protractor/bin/</code>, and type the following:<pre class="programlisting">
<span class="strong"><strong>$ ./node_modules/protractor/bin/webdriver-manager update</strong></span>
</pre></li><li class="listitem">Confirm the directory structure.</li><li class="listitem">The preceding command will create a Selenium directory containing the required Chrome driver used in the project.</li></ol></div><p>The installation is now complete. Both Protractor and Selenium WebDriver for Chrome have been installed. We can now move on to the configuration.</p></div><div class="section" title="Customizing configuration"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec54"/>Customizing configuration</h2></div></div></div><p>In this section, we will be configuring Protractor using the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start with a standard template configuration.</li><li class="listitem">Fortunately, the Protractor installation comes with some base configurations in its installation directory.</li><li class="listitem">The one that we will use is called <code class="literal">conf.js</code>  located in the <code class="literal">protractor/example</code> section. </li><li class="listitem">Review the example configuration file:<p>The <code class="literal">capabilities</code> parameter should only specify the name of the browser:</p><pre class="programlisting">          exports.config = {  &#13;
          //...  &#13;
          capabilities: { &#13;
            'browserName': 'chrome' &#13;
          },   &#13;
          //... &#13;
          }; &#13;
</pre><p>The framework parameter should specify the testing framework name, and we will use Jasmine here:</p><pre class="programlisting">          exports.config = {  &#13;
          //...  &#13;
          framework: 'jasmine'   &#13;
          //... &#13;
          };</pre><p>The final important configuration is the source file declaration:</p><pre class="programlisting">          exports.config = { &#13;
            //... &#13;
            specs: ['example_spec.js'], &#13;
            //... &#13;
          }; &#13;
</pre></li></ol></div><p>Excellent! Now we have Protractor installed and configured.</p></div><div class="section" title="Confirming the installation and configuration"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec55"/>Confirming the installation and configuration</h2></div></div></div><p>To confirm installation, Protractor requires at least one file defined in the <code class="literal">specs</code> configuration section. Before adding a real test and complicating things, create an empty file called <code class="literal">confirmConfigTest.js</code> in the root directory. Then, edit the <code class="literal">conf.js</code> file located in the project root and add the test file to the <code class="literal">specs</code> section so that it looks as follows:</p><pre class="programlisting">
<span class="strong"><strong>specs: ['confirmConfigTest.js'],</strong></span>
</pre><p>To confirm that Protractor has been installed, run Protractor by going to the root of our project directory and type the following:</p><pre class="programlisting">
<span class="strong"><strong>    $ ./node_modules/protractor/bin/protractor conf.js</strong></span>
</pre><p>If everything was set up correctly and installed, we will see something similar to this in our Command Prompt:</p><pre class="programlisting">
<span class="strong"><strong>Finished in 0.0002 seconds</strong></span>
<span class="strong"><strong>0 tests, 0 assertions, 0 failures</strong></span>
</pre></div><div class="section" title="Common installation and configuration issues"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec56"/>Common installation and configuration issues</h2></div></div></div><p>The following are some common issues that you might come across while installing WebDriver for Chrome:</p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><tbody><tr><td>
<p><span class="strong"><strong>Issues</strong></span></p>
</td><td>
<p><span class="strong"><strong>Solution</strong></span></p>
</td></tr><tr><td>
<p>Selenium not installed correctly</p>
</td><td>
<p>If the tests have errors related to the Selenium WebDriver location, you need to ensure that you followed the steps to update WebDriver. The update step downloads the WebDriver components into the local Protractor installation folder. Until WebDriver has been updated, you won't be able to reference it in the Protractor configuration. An easy way to confirm the update is to look in the Protractor directory and ensure that a Selenium folder exists.</p>
</td></tr><tr><td>
<p>Unable to find tests</p>
</td><td>
<p>When no tests are executed by Protractor, it can be frustrating. The best place to start is in the configuration file. Ensure that the relative paths and any filenames or extensions are correct.</p>
</td></tr></tbody></table></div><p>For a complete list, refer to the official Protractor site at <a class="ulink" href="http://angular.github.io/protractor/">http://angular.github.io/protractor/</a>.</p></div></div>
<div class="section" title="Integrating Protractor with Angular"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec33"/>Integrating Protractor with Angular</h1></div></div></div><p>So far, we have seen how to install and configure Protractor and we also have a basic overview of how Protractor works. In this section, we will go through with the process of integrating Protractor in an existing Angular project, where we just have unit testing and will see how Protractor is used in e2e testing in real life.</p><div class="section" title="Getting the existing project"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec57"/>Getting the existing project</h2></div></div></div><p>The code in this test will leverage the unit tested code from <a class="link" href="ch03.html" title="Chapter 3. The Karma Way">Chapter 3</a>, <span class="emphasis"><em>The Karma Way</em></span>. We will copy the code to a new directory called <code class="literal">angular-protractor</code>.</p><p>As a reminder, the application is a to-do application that has some items in the to-do list; let's add some more items to the list. It has a single component class, <code class="literal">AppComponent</code>, that has a list of items and an <code class="literal">add</code> method. The current code directory should be structured as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_04_001.jpg" alt="Getting the existing project"/></div><p>
</p><p>After getting this structure, the first job is to get the required dependencies, <code class="literal">node_modules</code> locally by running the following:</p><pre class="programlisting">
<span class="strong"><strong>$ npm install</strong></span>
</pre><p>This will install all the required modules; next, let's build and run the project with the <code class="literal">npm</code> command:</p><pre class="programlisting">
<span class="strong"><strong>$ npm start</strong></span>
</pre><p>Everything should be fine; the project should run on <code class="literal">http://localhost:3000</code> and the output should be as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_04_002.jpg" alt="Getting the existing project"/></div><p>
</p><p>And yes, we are ready to go to the next step to implement Protractor in our Angular project.</p></div><div class="section" title="The Protractor setup flow"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec58"/>The Protractor setup flow</h2></div></div></div><p>The setup will mirror the installation and configuration steps that we saw earlier in this chapter:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Install Protractor.</li><li class="listitem">Update Selenium WebDriver.</li><li class="listitem">Configure Protractor based on the example configuration.</li></ol></div><p>We will follow the Protractor installation and configuration steps we have covered in the previous section in a new project directory. The only difference is that the Protractor tests could be named with e2e prefix, such as <code class="literal">**.e2e.js</code>. This will allow us to easily identify the Protractor tests in our project structure.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip8"/>Tip</h3><p>This absolutely depends on a developer's choice; some people just put the Protractor test in a new directory with a subfolder, <code class="literal">spec/e2e</code>. It's just part of structuring the project.</p></div></div></div><div class="section" title="Installing Protractor"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec59"/>Installing Protractor</h2></div></div></div><p>We might have Protractor set up globally or we might not, so it's always great to have Protractor installed in the project. And so, we will have Protractor installed locally and will add in <code class="literal">package.json</code> as <code class="literal">devDependency</code>.</p><p>To install Protractor in our project, run this command from the project directory:</p><pre class="programlisting">
<span class="strong"><strong>$ npm install protractor -save-dev</strong></span>
</pre><p>We can check Protractor as follows:</p><pre class="programlisting">
<span class="strong"><strong>$ ./node_modules/protractor/bin/protractor --version</strong></span>
</pre><p>This should provide the latest version, 4.0.10, as follows:</p><pre class="programlisting">
<span class="strong"><strong>Version 4.0.10</strong></span>
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip9"/>Tip</h3><p><span class="strong"><strong>A good practice that we will follow</strong></span></p><p>
We showed how to set up Protractor in a directory, but its good to have Protractor globally installed with the following command:</p></div></div><pre class="programlisting">
<span class="strong"><strong>$ npm install -g protractor</strong></span>
</pre><p>This is so that we can use it easily to call Protractor from the command shell as with <code class="literal">protractor</code>; to know the Protractor version, we can call it as follows:</p><pre class="programlisting">
<span class="strong"><strong>$ protractor -version</strong></span>
</pre></div><div class="section" title="Updating WebDriver"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec60"/>Updating WebDriver</h2></div></div></div><p>To update Selenium WebDriver, go to the <code class="literal">webdriver-manager</code> executable in the Protractor <code class="literal">bin</code> directory that can be found at <code class="literal">./node_modules/protractor/bin/</code> and type the following:</p><pre class="programlisting">
<span class="strong"><strong>$ ./node_modules/protractor/bin/webdriver-manager update</strong></span>
</pre><p>A good practice to follow, as informed, we will install Protractor globally, and if so, we will have the <code class="literal">webdriver-manager</code> command global as well, so that, we can easily run it for <code class="literal">update</code>, as shown here:</p><pre class="programlisting">
<span class="strong"><strong>$ webdriver-manager update</strong></span>
</pre><p>This will update WebDriver and will support the latest browsers.</p></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec61"/>Getting ready</h2></div></div></div><p>As we have cloned the sample quick start project, it has already integrated and configured Protractor in the project. For the purpose of learning, we would like to integrate Protractor in the existing project.</p><p>To do so, we will have to remove the existing <code class="literal">protractor.config.js</code> file from the project root directory.</p></div><div class="section" title="Setting up the core configuration"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec62"/>Setting up the core configuration</h2></div></div></div><p>As we have seen earlier, Protractor configurations will be stored in a JS file. We will need to create a configuration file in our project root; let's name it as <code class="literal">protractor.config.js</code>.</p><p>For the time being, keep the changeable fields empty, as these are on the project structure and configuration dependent. So, the initial look could be something like this and these configuration options are known to us:</p><pre class="programlisting">exports.config = { &#13;
 &#13;
    baseUrl: ' ', &#13;
 &#13;
    framework: 'jasmine', &#13;
 &#13;
    specs: [], &#13;
 &#13;
    capabilities: { &#13;
        'browserName': 'chrome' &#13;
    } &#13;
 &#13;
}; &#13;
</pre><p>As long as our project will run locally on port <code class="literal">3000</code>, our <code class="literal">baseUrl</code> variable will be as follows:</p><pre class="programlisting">exports.config = { &#13;
    // ....  &#13;
    baseUrl: ' http://localhost:3000', &#13;
    // ....  &#13;
}; &#13;
</pre><p>We are planning to keep our e2e test spec in the same folder where we put the unit test files, <code class="literal">app/app.component.spec.ts</code>. This time it will have a new e2e prefix and will look like <code class="literal">app/app.component.e2e.ts</code>. Based on that, our specs and config will be updated:</p><pre class="programlisting">exports.config = { &#13;
    // ....  &#13;
    specs: [ &#13;
        'app/**/*.e2e.js' &#13;
    ], &#13;
    // ..... &#13;
}; &#13;
</pre><p>As long as it's an Angular project, we need to pass an extra configuration, <code class="literal">useAllAngular2AppRoots: true</code>, as it will tell Protractor to wait for all the Angular apps' root elements on the page instead of just the one root element matching:</p><pre class="programlisting">exports.config = { &#13;
    // ....  &#13;
    useAllAngular2AppRoots: true, &#13;
    // ..... &#13;
}; &#13;
</pre><p>We are running our project via the node server; so, we need to pass one more configuration option so that Jasmine itself supports node. This configuration is a must to pass in the Jasmine 2.x version, but we may not need it if we use Jasmine 1.x. Here, we have added the two most common options in <code class="literal">jasmineNodeOpts</code>; there are a few that are used based on requirements:</p><pre class="programlisting">exports.config = { &#13;
    // ....  &#13;
    jasmineNodeOpts: { &#13;
        showColors: true, &#13;
        defaultTimeoutInterval: 30000 &#13;
    }, &#13;
    // ..... &#13;
}; &#13;
</pre></div><div class="section" title="Diving into the test specifics"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec63"/>Diving into the test specifics</h2></div></div></div><p>To run the Protractor test, we need two files: one is the configuration file that we already created in our project root as <code class="literal">protractor.conf.js</code>, and the next one is the spec, where we will define the e2e test spec, and that one will be located in the app folder as <code class="literal">app/app.component.e2e.ts</code>.</p><p>So, let's see the file that we should define there:</p><pre class="programlisting">describe('Title for test suite', () =&gt; { &#13;
 &#13;
    beforeEach(() =&gt; { &#13;
        // ...  &#13;
    }); &#13;
 &#13;
    it('Title for test spec', () =&gt; { &#13;
        // ... &#13;
    }); &#13;
 &#13;
});; &#13;
</pre><p>These syntaxes should be known to us as we already used the Jasmine syntax in our unit test suite as well.</p><p>Let's have a quick recap</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">describe</code>: This contains the block of codes to run the test suite</li><li class="listitem" style="list-style-type: disc"><code class="literal">beforeEach</code>: This is used to contain the setup code, which is used in every test spec</li><li class="listitem" style="list-style-type: disc"><code class="literal">it</code>: This is used to define the test spec and contain the specific code for that test spec to run</li></ul></div><p>The main part of running an e2e test for any website is to get the DOM elements of that website and then interact with those elements through the test process. And so, we will need to get the DOM elements of our running project.</p><p>As long as the current project is running in the web browser, we will have to get the instance of the browser itself first; interestingly, Protractor provides that with the global browser object. With this browser object, we can get all browser-level commands, such as <code class="literal">browser.get</code>, and we can navigate through to our project URL:</p><pre class="programlisting">beforeEach(() =&gt; { &#13;
    browser.get(''); &#13;
});; &#13;
</pre><p>With this <code class="literal">browser.get('')</code> method, we will navigate to the root of our project.</p><p>We have the global browser object, with which we can get the title of the running page, which is basically, the title we defined here in the project <code class="literal">index.html</code> file. <code class="literal">browser.getTitle</code> will provide the title and then we can match that as expected. So, our test spec will look like this:</p><pre class="programlisting">it('Browser should have a defined title', () =&gt; { &#13;
       expect(browser.getTitle()).toEqual('Angular Protractor'); &#13;
}); &#13;
</pre><p>If we take a quick look, our short e2e test spec will look as follows:</p><pre class="programlisting">describe('AppComponent Tests', () =&gt; { &#13;
    beforeEach(() =&gt; { &#13;
        browser.get(''); &#13;
    }); &#13;
 &#13;
    it('Browser should have a defined title', () =&gt; { &#13;
        expect(browser.getTitle()).toEqual('Angular Protractor'); &#13;
    }); &#13;
}); &#13;
</pre><p>Time to run the e2e test with Protractor. The command will look as follows:</p><pre class="programlisting">
<span class="strong"><strong>$ protractor protractor.conf.js</strong></span>
</pre><p>The result is as expected--0 failure as we have set the <code class="literal">index.html</code> page title to <span class="strong"><strong>Angular Protractor<span class="strong"><strong>.</strong></span>
</strong></span> The result will be as follows:</p><pre class="programlisting">1 spec, 0 failures &#13;
Finished in 1.95 seconds &#13;
</pre><p>Time to move on and add a new test spec for the rest of the DOM elements of the page, where we have list items listed on the page; so, we will test them automatically via Protractor.</p><p>At first, we will check whether we have all the three items listed. We have already learned in an earlier section of this chapter about some Protractor common APIs, but a quick recap, we will use the <code class="literal">element.all</code> method by passing some locator (<code class="literal">by.css</code>, <code class="literal">by.id</code>, and <code class="literal">by.model</code>) to get the elements array object. And then, we can use the Jasmine matcher to match with the expected value, as shown:</p><pre class="programlisting">it('Should get the number of items as defined in item object', () =&gt; { &#13;
        var todoListItems = element.all(by.css('li')); &#13;
        expect(todoListItems.count()).toBe(3); &#13;
    }); &#13;
</pre><p>We should get the result passed, as we have three items listed in the UI.</p><p>We can add a few more test specs for testing the UI elements. For example, to check whether the items listed are in the correct order, we can check their label, as follows:</p><pre class="programlisting">it('Should get the first item text as defined', () =&gt; { &#13;
        expect(todoListItems.first().getText()).toEqual('test'); &#13;
    }); &#13;
 &#13;
    it('Should get the last item text as defined', () =&gt; { &#13;
        expect(todoListItems.last().getText()).toEqual('refactor'); &#13;
    }); &#13;
</pre><p>We have matched the first and last item's label/text with the expected value and it should pass as well.</p><p>Let's combine all the test specs in the e2e file. It will look like this:</p><pre class="programlisting">describe('AppComponent Tests', () =&gt; { &#13;
    var todoListItems = element.all(by.css('li')); &#13;
 &#13;
    beforeEach(() =&gt; { &#13;
        browser.get('/'); &#13;
    }); &#13;
 &#13;
    it('Browser should have a defined title', () =&gt; { &#13;
        expect(browser.getTitle()).toEqual('Angular Protractor'); &#13;
    }); &#13;
 &#13;
    it('Should get the number of items as defined in item object', () &#13;
    =&gt; { &#13;
        expect(todoListItems.count()).toBe(3); &#13;
    }); &#13;
 &#13;
    it('Should get the first item text as defined', () =&gt; { &#13;
        expect(todoListItems.first().getText()).toEqual('test'); &#13;
    }); &#13;
 &#13;
    it('Should get the last item text as defined', () =&gt; { &#13;
        expect(todoListItems.last().getText()).toEqual('refactor'); &#13;
    }); &#13;
}); &#13;
</pre><p>Let's run all the specs together:</p><pre class="programlisting">
<span class="strong"><strong>$ protractor protractor.conf.js</strong></span>
</pre><p>As expected, all the tests should pass and the result will be as follows:</p><pre class="programlisting">
<span class="strong"><strong>4 specs, 0 failures</strong></span>
<span class="strong"><strong>Finished in 2.991 seconds</strong></span>
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip10"/>Tip</h3><p>As long as we named our Protractor config file <code class="literal">protractor.conf.js</code>, we don't need to mention the configuration file name while running it with the <code class="literal">protractor</code> command; Protractor will get its configuration file by itself. With any other name, we should mention the configuration file name with Protractor.</p></div></div><p>So, in this case, we can just run the test as follows:</p><pre class="programlisting">
<span class="strong"><strong>$ protractor</strong></span>
</pre><p>The result will be the same as it was before.</p></div><div class="section" title="Running the test via NPM"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec64"/>Running the test via NPM</h2></div></div></div><p>In this project, we will build and run a project via npm. In <a class="link" href="ch03.html" title="Chapter 3. The Karma Way">Chapter 3</a>, <span class="emphasis"><em>The Karma Way</em></span>, we ran the <code class="literal">karma</code> test via <code class="literal">npm</code>; similarly, we will run the <code class="literal">protractor</code> test with <code class="literal">npm</code> as well. And to do so, we have to add <code class="literal">protractor</code> in the <code class="literal">scripts</code> section in <code class="literal">package.json</code> of our project:</p><pre class="programlisting">"scripts": { &#13;
    // ...  &#13;
    "e2e": "protractor" &#13;
    // .... &#13;
  }; &#13;
</pre><p>To install <code class="literal">protractor</code> in our project, run from the project directory:</p><pre class="programlisting">
<span class="strong"><strong>$ npm e2e</strong></span>
</pre><p>In some OSes, this command may produce some <code class="literal">npm</code> error. This is actually for <code class="literal">webdriver-manager</code>, which may not updated. To solve this we have to add the <code class="literal">webdriver-manager</code> update script to <code class="literal">npm</code> and run it only once at the very first time, like this:</p><pre class="programlisting">"scripts": { &#13;
    // ...  &#13;
    "webdriver-update": "webdriver-manager update" &#13;
    // .... &#13;
  }; &#13;
</pre><p>We also have to run it as:</p><pre class="programlisting">
<span class="strong"><strong>$ npm webdriver-update</strong></span>
</pre><p>That's it, we are ready to run the e2e test again and this should work exactly the same as the <code class="literal">protractor</code> command.</p><p>Let's confirm this:</p><pre class="programlisting">
<span class="strong"><strong>$ npm run e2e</strong></span>
</pre><p>The expected result will be as follows:</p><pre class="programlisting">
<span class="strong"><strong>4 specs, 0 failures</strong></span>
<span class="strong"><strong>Finished in 2.991 seconds</strong></span>
</pre></div></div>
<div class="section" title="Making the test better"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec34"/>Making the test better</h1></div></div></div><p>There are a couple of things that were discussed in this chapter that need further clarification. These include the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Where is the asynchronous logic?</li><li class="listitem" style="list-style-type: disc">How do we really implement TDD with end-to-end tests?</li></ul></div><div class="section" title="Async magic"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec65"/>Async magic</h2></div></div></div><p>In the preceding tests, we saw some magic that you might be questioning. Here are some of the magic components that we glanced over:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Loading a page before test execution</li><li class="listitem" style="list-style-type: disc">Assertion on elements that get loaded in promises</li></ul></div><div class="section" title="Loading a page before test execution"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec17"/>Loading a page before test execution</h3></div></div></div><p>In the previous test, we used the following code to specify that the browser should point to the home page:</p><pre class="programlisting">browser.get(''); &#13;
</pre><p>The preceding command will launch the browser and navigate to the <code class="literal">baseUrl</code> location. Once the browser reaches the page, it will have to load Angular and then implement the Angular-specific functions. Our tests don't have any wait logic, and this is part of the beauty of Protractor with Angular. The waiting for page loading is already built into the framework for us. Our tests can then be written very cleanly.</p></div><div class="section" title="Assertion on elements that get loaded in promises"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec18"/>Assertion on elements that get loaded in promises</h3></div></div></div><p>The assertions and expectations already have promise fulfillment written in them. In the case of our test, we wrote the assertion so that it expects the count to be <code class="literal">3</code>:</p><pre class="programlisting">expect(todoListItems.count()).toBe(3); &#13;
</pre><p>However, in reality, we may have thought that we needed to add asynchronous testing to the assertion in order to wait for the promise to be fulfilled, involving something more complicated like the following:</p><pre class="programlisting">it('Should get the number of items as defined in item object', (done) =&gt; { &#13;
    var todoListItems = element.all(by.css('li')); &#13;
    todoListItems.count().then(function(count){ &#13;
        expect(count).toBe(3); &#13;
        done(); &#13;
    }); &#13;
}); &#13;
</pre><p>The preceding code is longer, more granular, and more difficult to read. Protractor has the ability to make tests more concise for certain elements built in to expectations.</p></div></div><div class="section" title="TDD with Protractor"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec66"/>TDD with Protractor</h2></div></div></div><p>With our first test, there is a clear distinction of end-to-end tests and unit tests. With the unit test, we focused on strong coupling the test to the code. As an example, our unit test spied on the scope for a specific component class, <code class="literal">AppComponent</code>. We have to initiate the component to get the instance of the component, as follows:</p><pre class="programlisting">import {AppComponent} from "./app.component"; &#13;
 &#13;
beforeEach(() =&gt; { &#13;
    app = new AppComponent(); &#13;
}); &#13;
</pre><p>In the Protractor test, we don't care about which component class we are testing and our focus is on the user perspective of the test. We start with the selection of a particular element within the DOM; in our case, that element is tied to Angular. The assertion is that the number of elements for a specific repeater is equal to the expected count.</p><p>With the loose coupling of the end-to-end test, we can write a test that focuses on the user specification, which initially displays three elements, and then have the freedom to write that in the page, class, component, and so on, in the way we want.</p></div></div>
<div class="section" title="Self-test questions"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec35"/>Self-test questions</h1></div></div></div><p>Use TDD with Protractor to develop the third development to-do list item.</p><p>Q1. Which of the following frameworks does Protractor use?</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Selenium</li><li class="listitem" style="list-style-type: disc">Unobtanium</li><li class="listitem" style="list-style-type: disc">Karma</li></ul></div><p>Q2. You can install Protractor with any existing Angular project.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">True</li><li class="listitem" style="list-style-type: disc">False</li></ul></div><p>Q3. Karma and Protractor can run together in a single project.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">True</li><li class="listitem" style="list-style-type: disc">False</li></ul></div><p>Q4. Which team has developed Protractor?</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">ReactJS team</li><li class="listitem" style="list-style-type: disc">Angular team</li><li class="listitem" style="list-style-type: disc">NodeJS team</li></ul></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec36"/>Summary</h1></div></div></div><p>This chapter gave us an overview of end-to-end testing with Protractor and also provided the necessary idea to install, configure, and apply end-to-end testing with an existing Angular project. Protractor is an important part of testing any Angular application. It bridges the gap to ensure that a user's specifications work as expected. When end-to-end tests are written according to user specifications, the confidence of the application and ability to refactor grows. In the upcoming chapters, we will see how to apply Karma and Protractor in more depth with simple and straightforward examples.</p><p>The next chapter will walk us through more details on Protractor with some advance configuration, details on some APIs, and it will also debug the tests.</p></div></body></html>