- en: Advanced Functionality with the Expenses App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the last chapter, we began working on an expense tracking app simply titled
    `Expenses`. After getting some basic functionality written for the app, our next
    goal is to continue working on the app and add new features to it that will make
    the app feature-complete. This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing the `react-native-vector-icons` library to utilize icons in our app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to use the `Picker` component to render a dropdown, such as an
    interface that can accept any array of items for user selection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating our list view to show the expense category icons and show the current
    amount spent with a progress bar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a second view that renders the previous months' expenses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `Icon.TabBarIOS` component to toggle between the current month's and
    the previous month's view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing deletion of added expenses for both the current month and the previous
    ones
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Due to the extensive features in this chapter, the section on making modifications
    for this app to run on an Android device has been moved to [Chapter 9](c9cb084b-5c75-4683-94c3-9b2124e8ecb0.xhtml),
    *Additional React Native Components*.
  prefs: []
  type: TYPE_NORMAL
- en: Using vector icons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 3](6ac206f7-d3d2-4b39-89ab-a6fdcf124e02.xhtml), *Our Second Project
    - The Budgeting App*, we mentioned that upon tapping that button, the user should
    be shown a modal that allows them to input details for their expenses: the name,
    amount, date the purchase was made on, and an icon to categorize the item. The
    modal should `allow` the user to either cancel or save the entry they make.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For our first exercise, we should do the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by writing a utilities file for handling icons:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This file should contain an object that contains the stringified names of categories
    and their icon names from our vector icon library.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This file should also contain a method that takes in the name, desired size,
    and color of an icon and returns that icon as a component. Treat this as a stateless
    functional component.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at how we can utilize the vector icon library that we installed in
    the last chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can import `react-native-vector-icons` with the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This maps a reference of `Icon` to a component that uses the Font Awesome icon
    set.
  prefs: []
  type: TYPE_NORMAL
- en: 'To utilize it, you can render an `Icon` component like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `name` property tells the library which icon to pull from its collection.
    You can find a list of all the icons that Font Awesome contains at [http://fontawesome.io](http://fontawesome.io).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our app will contain the following 12 icons:'
  prefs: []
  type: TYPE_NORMAL
- en: '`home`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shopping-cart`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cutlery`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`film`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`car`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`coffee`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`plane`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shopping-bag`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`book`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`beer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gamepad`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`plug`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The categories that these icons represent will be (in order) the following
    ones:'
  prefs: []
  type: TYPE_NORMAL
- en: Home
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grocery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restaurant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Entertainment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Car
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coffee
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Travel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shopping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Books
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drinks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hobby
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these in mind, we should create a helper file that will let us render an
    icon.
  prefs: []
  type: TYPE_NORMAL
- en: Icon methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `iconMethods` file will be a lot simpler than our previous helper methods.
    With `iconMethods`, our goal is to keep an object that maps category names and
    icons and then, export a function that will help us return the `react-native-vector-icon`
    components.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `categories` object lets us quickly access both the category and icon name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have a stateless function, `getIconComponent`, that accepts the `name`
    of a category along with an optional `size` and `color`, then returns an `Icon`
    component for our app.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our `iconMethods` file built out, it's time to create a `Picker`
    component to select a category.
  prefs: []
  type: TYPE_NORMAL
- en: Picker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this book, we have used `DatePickerIOS` and `DatePickerAndroid` for
    users to select dates. Each platform also has access to a native `Picker` component,
    where we can populate an array of choices and allow our users to interact with
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Building a `Picker` is easy. We start by writing a `Picker` in the `render`
    method of a component and populate it with `Picker.Item` children:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can give the `Picker` some props. The following ones are used in this
    exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onValueChange`: This is a callback fired when an item has been selected. It
    passes two arguments: `itemValue` and `itemPosition`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`selectedValue`: This is a reference to the current value of the `Picker` list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting a category
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will modify our existing `AddExpensesModal` component to add the following
    functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `Button` right below the `ExpandableCell`/`DatePickerIOS` component
    to select a category for our expense.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On press, that button should render a `Picker` component for the user to interact
    with. This `Picker` should have the following features:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contain the list of twelve categories that we are using in our app as `Picker`
    items by mapping the array instead of hardcoding each of the twelve categories.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Have a callback that sets the selected value as the selected category for our
    expense. Next:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Render this `Picker` as a child of an `ExpandableCell` component within `AddExpensesModal` so
    that it can be collapsed when not in use.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Render the preceding `ExpandableCell` component between the date and save/cancel
    buttons within `AddExpensesModal`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `getIconComponent` function from `iconMethods` to render the selected
    category's icon, if applicable, and style it so that it appears on the page in
    the same row as the `ExpandableCell` for our `Picker` component.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify `AddExpensesModal` so that its submit button is also disabled if a category
    has not been set by the user.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `AddExpensesModal` component and its styles underwent a significant number
    of changes since the last time we looked at them in the last chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `expanded` key is replaced by two separate Booleans for each `ExpandableCell`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `expandableCellTitle` is replaced by one string for each `ExpandableCell`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The rendering of the original `ExpandableCell` has been modified to accommodate
    the changes in variable and function names to make it more specific to its child
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the newly-added `ExpandableCell` component, rendering a `Picker` underneath
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Button` component used to save an expense has been modified to check for
    the presence of a category to allow its saving:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `_clearFieldsAndCloseModal` method has been updated for the new fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `_onDatePickerExpand` method is just a renaming of the old `_onExpand`
    method, while `_onCategoryPickerExpand` is specific to the `Picker` category:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Render each `Picker.Item` by mapping the array of category names to a new element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `_setItemCategory` function is fired in the `onValueChange` callback of
    our `Picker` category:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the `category` property to storage as part of `_saveItemToBudget`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how the new `Picker` component should look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_04_001-1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'I added styling for `categoryIcon`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code uses the `Dimensions` API to set `marginLeft` to the width of the
    screen minus `50` pixels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code has updated styling to contain a `flexDirection` of `row`.
  prefs: []
  type: TYPE_NORMAL
- en: Updating CurrentMonthExpenses and ExpenseRow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Up to this point, we have been rendering the `CurrentMonthExpenses` and `ExpenseRow`
    components without a category as one did not exist previously. Let''s update them
    with the following goals in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CurrentMonthExpenses` should access each item''s category and pass it to `ExpenseRow`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExpenseRow` should render the appropriate category''s assigned icon in the
    row of expenses so that our users can quickly visualize what it is that they spent
    part of their budget on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We should use the `resetAsyncStorage` method created in `StorageMethods` to
    clear any current list of expenses before modifying `ExpenseRow` so that the previous
    expenses without a category assigned will not cause any issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once you have updated these components, check out my solution, which is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code used one time (and not saved in the file afterwards) to clear
    storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, I updated the `CurrentMonthExpenses` component to pass in the `category`
    an expense was assigned as a prop to the `ExpenseRow` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, I created a new `View` to render the category icon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'For styling, the following `icon` property was added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how your app should look after icons have been added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_04_002-1.png)'
  prefs: []
  type: TYPE_IMG
- en: Great job on the updates! In the next section, we should give the user a visualization
    of their remaining budget using a progress indicator.
  prefs: []
  type: TYPE_NORMAL
- en: Updating App.js with ProgressViewIOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When planning this app in the last chapter, we wrote that this list should also
    prominently display the user's set budget for the month along with a progress
    indicator showing how close they are to hitting their budget.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `ProgressViewIOS`, we can depict our user''s progress toward their monthly
    limit. The following props will be used in this project:'
  prefs: []
  type: TYPE_NORMAL
- en: '`progress`: This is a number between `0` and `1` that tracks the value of the
    progress bar'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`progressTintColor`: This is a string that sets the color of the progress bar'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can render a `ProgressViewIOS` component like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In this section, we should update `Expenses` to do the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we should modify the `checkCurrentMonthBudget` function from `storageMethods`
    to also return the amount spent for the month
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, `App.js` should have its `_updateBudget` function updated to account for
    the amount spent being returned by `checkCurrentMonthBudget`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, add a `ProgressViewIOS` component to `CurrentMonthExpenses`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should have a function to calculate its `progress` prop
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It should also show the dollar amount currently spent as a string
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ProgressViewIOS example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To begin, we will need to make an addition to our `storageMethods` file to
    grab the current month''s spent amount so that we can calculate the `progress`
    prop for `ProgressViewIOS`. This can be done by modifying `checkCurrentMonthBudget`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are returning an object containing both the `budget` and `spent` amounts
    as opposed to just the `budget`. This means that we will also need to modify how
    the `App` component's `_updateBudget` method receives our response data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following addition to the `App` component just shows the `_updateBudget`
    asynchronous method since it is the only part modified to accommodate `storageMethods''`
    `checkCurrentMonthBudget` method''s changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The text block that renders the budget as a string has been modified to display
    the current amount spent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'A `ProgressViewIOS` component is also mounted right after the preceding text
    block, pointing its `progress` prop to a function called `_getProgressViewAmount`,
    which calculates it for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is a simple division to grab the percentage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Set `margin` to `10` so that it does not reach the edge of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Reduce the `fontSize` of both the properties to `16` and set `alignSelf` to
    `center`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As a result of these changes, your app should now have a progress indicator
    showing the user how close they are to hitting their budget for the month.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thanks to the `_updateCurrentMonthExpenses` function in `App.js`, saving new
    expenses for the month will result in the amount spent and progress indicator
    being updated accordingly without any new logic having to be written:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_04_003-1.png)'
  prefs: []
  type: TYPE_IMG
- en: This looks great! Our next step is to create a second view that will let us
    look at all the months' expenses, which in turn will have us using a TabBar to
    toggle between the two.
  prefs: []
  type: TYPE_NORMAL
- en: A view for prior months' expenses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our view for the previous months' expenses should be one that renders a list
    of the existing months in our budget. It should give us the month, the budget
    allocated for the month, and have the years separated by some sort of a header.
    Then, on tap, it should go to the summary for each month to show us our previous
    months' expenses that were input.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should create some functions in a new utilities file, named `mockDataMethods`,
    to help us mock the data for the previous months and populate our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Above, arrays for years, months, and expenses are created and populated with
    data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'I created a mocked object to be assigned to each month:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This function loops through the `years` array and creates an empty object within
    that year's property. It then does another loop within it to create a similar
    object for the `month` within that `year` and assigns the `mockObject` to it.
    Along the way, it also stops the function if we attempt to create any mocked expenses
    for months past January 2017.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we use our `setAsyncStorage` function to assign our mocked expenses object
    to be the source of truth for our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Within the `componentWillMount` life cycle of `App.js`, we can call on the `mockPreviousMonthExpenses`
    function we created in `mockDataMethods` to populate our local storage with this
    mocked data.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we use the `logAsyncStorage` method from `storageMethods` in order
    to log the information to the console so that we can see that our mocked data
    has been saved to storage for later use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this step is completed, you should remove the `mockPreviousMonthExpenses`
    function from `App.js` since it does not need to be continuously called. Here
    is how our mocked expenses will look. You can view your own results by calling
    `console.table` on the object and opening up Chrome developer tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_04_004.png)'
  prefs: []
  type: TYPE_IMG
- en: After this step has been completed, we should create a new component that will
    show these details. Since we want a list that contains some sort of headers to
    separate the years, we will be rendering a `ListView` and using the `renderSectionHeader`
    prop to create sections in our app.
  prefs: []
  type: TYPE_NORMAL
- en: ListView with section headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To set up our `ListView` to accommodate section headers, we need to make some
    modifications to the way we've been creating `ListViews`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, when we instantiate a new `ListView DataSource`, we''ll be passing it
    a second callback, `sectionHeaderHasChanged`. Like `rowHasChanged`, this one checks
    to see whether a section header has changed. In your code, it looks something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, instead of calling `cloneWithRows`, we call the similarly named `cloneWithRowsAndSections`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, your `ListView` component should now accept a function as its `renderSectionHeader`
    prop, which will render the section header for your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you have an overview of how to apply a section header to your `ListView`
    component, it''s time to apply that knowledge. Let''s create a new component,
    `PreviousMonthsList`. This component should do the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: For the time being, replace the rendering of `CurrentMonthExpenses` in `App.js`
    with your `PreviousMonthsList` component so that you can view your progress while
    writing the component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grab the list of expenses from `AsyncStorage` and save it to the component state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Render a `ListView` with section headers, which displays the name of the month
    as a string along with that month's numerical budget and a section header for
    each year that our `mocked` expenses provided
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Style the rows and section headers to have a different look from each other
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once you have built your version of this component, check for the one that
    I built:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The first thing I did was import `PreviousMonthsList` into `App.js` and replace
    where `CurrentMonthExpenses` was being mounted in its `render` method with `PreviousMonthsList`
    instead. This made it simpler for me to work on the component, knowing that any
    changes I made would be immediately noticeable.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this component was completed, I reverted `App.js` back to its original
    state (before the `PreviousMonthsList` component was created):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `DataSource` instance saved into component state has the new `sectionHeaderHasChanged`
    function passed into it.
  prefs: []
  type: TYPE_NORMAL
- en: 'During the `componentWillMount` life cycle event, I am asynchronously calling
    the `getAsyncStorage` function from `storageMethods` and saving its result into
    the `listOfExpenses` property in the component state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `dataSource` constant is being assigned with the `cloneWithRowsAndSections`
    method of the `ListView.DataSource` instance saved in the component state so that
    the section header for our list of expenses is available in the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: There is nothing special in the three stateless functions that handle the rendering
    of our row data, section header, and separator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `rowDataContainer` style is given a `flexDirection` property set to `row`
    so that the two strings being rendered within it are on the same line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sectionHeader` gets its own styling so that a specified `height` and `backgroundColor`
    can be set to visually distinguish it from the rows of data in the `PreviousMonthsList`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, by temporarily rendering `PreviousMonthsList` to where `CurrentMonthExpenses`
    previously belonged, we have a view that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_04_005-1.png)'
  prefs: []
  type: TYPE_IMG
- en: The previous month's expenses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next step that we want to carry out is to create a view that shows us the
    expenses for each month and then allows the user to enter that view by tapping
    on one of these months. This view should be navigated to when the user long presses
    on a month in the `PreviousMonthsList` component.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, we already have a component that can handle this for us. In the
    last chapter, we built the `CurrentMonthExpenses` component that renders the expenses
    for a given month.
  prefs: []
  type: TYPE_NORMAL
- en: So far in our app, `CurrentMonthExpenses` is being rendered in just one place--`App.js`.
    The container that it renders within has a top margin offset to accommodate the
    navigation bar.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to reuse the `CurrentMonthExpenses` component to render any month's
    expenses, we should build some logic to selectively include a top margin offset
    equal to the navigation bar's height if the component is being navigated to by
    `PreviousMonthsList`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be achieved by having `CurrentMonthExpenses` accept an optional Boolean
    as a prop to then append its `currentMonthExpensesContainer` style with its top
    margin being set to the navigation bar''s height:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `Navigator` is being imported so that we have access to its navigation bar
    height. The `CurrentMonthExpenses` component's `propTypes` have been updated to
    expect an optional Boolean titled `isPreviousMonth`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the `render` method of `CurrentMonthExpenses` checks to see whether the
    `isPreviousMonth` Boolean has been passed to the component. If it has, it adds
    the `marginTop` property to the `currentMonthExpensesContainer` style equal to
    the height of the navigation bar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it is time to link each row from `PreviousMonthsList` to navigate to the
    `CurrentMonthExpenses` component. Modify your `PreviousMonthsList` component so
    that it does the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Importing and wrapping a `TouchableHighlight` component over each row being
    rendered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When one of the rows is pressed, your app should navigate to `CurrentMonthExpenses`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As part of this navigation to `CurrentMonthExpenses`, your app's navigator should
    pass it all the props that it expects (as specified in the `propTypes` object
    of `CurrentMonthExpenses`), along with the optional `isPreviousMonth` prop set
    to `true`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you complete this step, check out the solution that I came up with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: I modified the `_renderRowData` method of `PreviousMonthsList` to wrap a `TouchableHighlight`
    component around the row of text. Since `TouchableHighlight` can only accept one
    immediate child component, I wrapped the two text elements around a `View`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `_renderSelectedMonth` method pushes `CurrentMonthExpenses` to the navigator
    and passes it all the expected props for that component. I used the `Number.toString`
    prototype method to convert the `rowData.budget` number to a string as `CurrentMonthExpenses`
    expects a string as its `budget` prop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'I gave the `rowDataTouchableContainer` style a `height` of `30` pixels and
    set the `flexDirection` property of `textRow` to `row` so that the two `Text`
    components within it will render properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'When the user presses on the name of a previous month, they will now see the
    following view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_04_006-1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we have two different paths for our users to take in the app: they can
    view add expenses to the current month''s list in `App.js`, or they can view the
    archives of all of their previous months'' expenses. In the next section, we will
    learn how to implement a tab bar to show these two views.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing TabBarIOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`TabBarIOS` renders a tabbed navigation bar at the bottom of the screen. The
    bar can contain multiple icons, each responsible for a different view.'
  prefs: []
  type: TYPE_NORMAL
- en: The different tabs that `TabBarIOS` renders are considered items of the tab
    bar. They are declared as `TabBarIOS.Item` components and are nested as children
    within `TabBarIOS`.
  prefs: []
  type: TYPE_NORMAL
- en: However, with the `react-native-vector-icons` library we imported, we would
    like to use Font Awesome icons for our navigation. Instead of rendering the `TabBarIOS.Item`
    components as children for our `TabBarIOS` component, we will substitute them
    for `Icon.TabBarItemIOS`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Icon.TabBarItemIOS` is a component that behaves in the exact same way that
    `TabBarIOS.Item` does, but with a couple of extra props that are specific to it.
    We will be using the following props for our implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onPress`: This is a callback that fires when the tab is tapped on by the user.
    This should always at least set the selected component to a Boolean in your state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`selected`: This is a Boolean that determines whether a specific tab is in
    the forefront of the application or not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`title`: This is a string that shows the text that appears underneath your
    icon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iconName`: This is a string that maps to the icon you wish to display.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iconSize`: This is a number that dictates the size of the icon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `iconColor` and `selectedIconColor` will need to have `renderAsOriginal`
    set to `true` so that these child-level settings override the parent `TabBarIOS`
    component's `tintColor` and `unselectedTintColor` props.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how a sample `TabBarIOS` component can look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `TabBarIOS` wraps around the `Icon.TabBarItemIOS` child components.
    Each of these child components handle their own icon type, size, and title. They
    also wrap around a function that renders their respective views.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it''s time for you to give it a try. Let''s build a `TabBarIOS` component
    into our app by doing the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Separate the app into c*urrent month* and *previous month's* expenses using
    `TabBarIOS`. Choose a suitable icon for each one!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjust styling as you see fit to adjust any dimensions needed to accommodate
    `TabBarIOS`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Give each `PreviousMonthsList` its own `NavigatorIOS` component so that the
    `TabBarIOS` component does not disappear when `PreviousMonthsList` navigates to
    a previous month's list of expenses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove the navigation bar from the root-level `NavigatorIOS` component found
    in `index.ios.js` so that the navigation components for `PreviousMonthsList` do
    not render a second navigation bar.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once you have built tabbed navigation for the app, come back and check out
    the version I wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The only change made to the `index.ios.js` root file is the addition of the
    `navigationBarHidden` prop for our root `NavigatorIOS` component, set to `true`
    so that the navigation bar does not appear.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `App.js` component, I am now explicitly setting items in state to default
    values so that components that are dependent on that prop don''t throw an error
    when the prop is not defined. Additionally, the `expenses` key has been modified
    to be an object--this will be the full object returned by the `getAsyncStorage`
    method in `StorageMethods`, not just for the current month:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The entire `expenses` object will be passed into `PreviousMonthsList`, allowing
    it to render all expense data and update whenever a new item is added to a previous
    month through the `AddExpenses` component.
  prefs: []
  type: TYPE_NORMAL
- en: The old `expenses` array, which references just the current month, is now explicitly
    labeled as `currentMonthExpenses`.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a new item in the component's state--`selectedTab`. This defaults
    to `currentMonth`, which is the leftmost tab that we intend on rendering.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The render method for `App.js` has been completely overhauled. It now returns
    a `TabBarIOS` component and two `Icon.TabBarItemIOS` children components that
    render a different view each:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The `_renderCurrentMonthExpenses` method contains the old `render` method for
    this component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The `_renderPreviousMonthsList` method returns a `NavigatorIOS` component whose
    initial route is `PreviousMonthsList`. The `expenses` key in `App.js''` state
    is passed in to `PreviousMonthsList` via `passProps`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The `_setSelectedTab` function changes the `selectedTab` property in the `App.js''`
    component state to the argument passed to it. This is the callback fired by the
    `onPress` props of the `Icon.TabBarItemIOS`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The last change is that `_updateCurrentMonthExpenses` now calls `getAsyncStorge`
    from `storageMethods.js` instead of `getMonthObject` and has been renamed as `_updateExpenses`
    to reflect its new functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The `previousMonthsContainer` style is applied to the `NavigatorIOS` instance
    that renders `PreviousMonthsList`. It does not contain a top margin equal to the
    navigation bar''s height since this will cause the navigation bar itself to have
    a top margin equal to its own height:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Minor changes to `PreviousMonthsList` are that I'm now checking for the `expenses`
    object to be passed to it and the `cloneWithRowsAndSections` call in the `render`
    method is now updated to reflect this.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the `componentWillMount` life cycle has been entirely removed
    since we are now getting all our data as a prop.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The `marginTop` property for `previousMonthsListContainer` in this component
    has been set to the navigation bar height:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `AddExpenses` component has been tweaked to reflect changing the
    `_updateCurrentExpenses` function name to `_updateExpenses`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how your app should look with `TabBarIOS` implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_04_007-1.png)'
  prefs: []
  type: TYPE_IMG
- en: There is one last thing we should do with the app, and it is to let users delete
    expenses.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting expenses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For users to delete expenses from any month, we need to do the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a method to `storageMethods` to update an `expenses` object. It should accept
    the month, year, and array of expenses. Then, it should override the array of
    expenses for that specific month and year combination in `AsyncStorage` with this
    new array, and recalculate the amount spent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wrap a `TouchabbleHighlight` component around each row that, when long pressed,
    opens an alert that asks the user whether they wish to delete the item.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the user confirms that they would like to delete the item, then we should
    delete it. A new array of expenses for the current month should be created without
    the deleted item, and it should be saved using the `storageMethods` function we
    made.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When an expense is deleted, we should update the current view to reflect the
    item being deleted and the updated spent amount.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the user cancels, the alert should close and no changes should be made.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take some time to build this feature; when you're finished, check out the code
    I wrote for this part.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, I modified the `StorageMethods` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The first thing I did was write the `updateMonthExpensesArray` method. As I
    was writing it, I noticed that much of the code was similar to what `saveItemToBudget`
    was executing, so I refactored `saveItemToBudget` to call the new `updateMonthExpensesArray`
    method. This allows me to reuse some code in my file instead of writing it twice.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the `CurrentMonthExpenses` component deletes an item, `App.js` `_updateExpenses`
    method should be executed so that `AsyncStorage` is updated with a new array for
    the month and year that does not contain the deleted expense:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The `_updateExpenses` method is also passed into the `PreviousMonthsList` component
    so that it can propagate it down to its own rendering of `CurrentMonthExpenses`
    for the previous months:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PreviousMonthsList` gets a minor tweak to support the addition of the
    `updateExpenses` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The `render` method has been changed to set the `dataSource` constant of `ListView`
    to accept the expenses value of the `CurrentMonthExpenses` state in case it is
    present--this will be used to visually update the component to exclude a deleted
    item once a deletion occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is necessary because `PreviousMonthsList` is the initial route of its
    own `NavigatorIOS` instance and therefore does not receive updated props from
    `App.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The `_cancelAlert` method closes the `Alert` dialogue that appears:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The following conditional blocks deal with the possibility that a user may
    want to delete more than one item from a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The `_deleteItem` method takes in the ID of the row being deleted, clones the
    expenses array, uses the `splice` method of the `Array` prototype to remove that
    specific index from it, and then removes it from `AsyncStorage` with the `updateMonthExpensesArray`
    method I created in the `StorageMethods` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, I set an `expenses` value in the local state to equal the new expenses
    array and call the `updateExpenses` method from `App.js` to update the data in
    the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Each `ExpenseRow` component will be passed in this `_onLongPress` method, which
    takes in its `rowID` and creates an alert prompt for the user. Based on the selected
    option, it either cancels the alert or deletes the row selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The `_renderRowData` method has been changed to pass in the `onLongPress` prop
    to `ExpenseRow`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The `TouchableHighlight` component of `ExpenseRow` has been updated to add
    an `onLongPress` callback that executes the `onLongPress` method passed into it
    as a prop from `CurrentMonthExpenses`. This is how the alert is triggered, giving
    the user the option to delete an added expense:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: This concludes our work on the iOS version of this app! Since this was a large
    app to build, I don't wish to drag you through the Android modifications in this
    chapter. Instead, the modifications I will make to this app to build it on an
    Android device can be found at the end of [Chapter 9](c9cb084b-5c75-4683-94c3-9b2124e8ecb0.xhtml),
    *Additional React Native Components*.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will begin working on an entirely new project.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we finished building our expense tracking app by utilizing
    the vector icon library we installed earlier to visually display the user's expenses.
    We also built a second view to look at the previous months' expenses and wrote
    a function to mock the data needed to visually verify that our app worked as intended.
    Then, we separated these two views using tabbed navigation and allowed users to
    delete expenses from the app.
  prefs: []
  type: TYPE_NORMAL
