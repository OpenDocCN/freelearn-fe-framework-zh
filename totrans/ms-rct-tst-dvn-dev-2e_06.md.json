["```js\nconst itSubmitsExistingValue = (fieldName, value) =>\n  it(\"saves existing value when submitted\", () => {\n    expect.hasAssertions();\n    const customer = { [fieldName]: value };\n    render(\n      <CustomerForm\n        original={customer}\n        onSubmit={(props) =>\n          expect(props[fieldName]).toEqual(value)\n      }\n    />\n  );\n  click(submitButton());\n});\n```", "```js\n    const itSubmitsExistingValue = (fieldName, value) =>\n      it(\"saves existing value when submitted\", () => {\n        let submitArg;\n        const customer = { [fieldName]: value };\n        render(\n          <CustomerForm\n            original={customer}\n            onSubmit={submittedCustomer => (\n              submitArg = submittedCustomer\n            )}\n          />\n        );\n        click(submitButton());\n        expect(submitArg).toEqual(customer);\n      });\n    ```", "```js\n    <form id=\"customer\" onSubmit={handleSubmit}>\n    ```", "```js\n<form id=\"customer\">\n```", "```js\n    it.only(\"saves existing value when submitted\", () => {\n    ```", "```js\n    FAIL test/CustomerForm.test.js\n      ● CustomerForm › first name field › saves existing value when submitted\n        expect(received).toEqual(expected) // deep equality\n        Expected: {\"firstName\": \"existingValue\"}\n        Received: undefined\n    ```", "```js\n    const singleArgumentSpy = () => {\n      let receivedArgument;\n      return {\n        fn: arg => (receivedArgument = arg),\n        receivedArgument: () => receivedArgument\n      };\n    };\n    ```", "```js\n    const itSubmitsExistingValue = (fieldName, value) =>\n      it(\"saves existing value when submitted\", () => {\n        const submitSpy = singleArgumentSpy();\n        const customer = { [fieldName]: value };\n        render(\n          <CustomerForm\n            original={customer}\n            onSubmit={submitSpy.fn}\n          />\n        );\n        click(submitButton());\n        expect(submitSpy.receivedArgument()).toEqual(\n          customer\n        );\n      });\n    ```", "```js\n    const spy = () => {\n      let receivedArguments;\n      return {\n        fn: (...args) => (receivedArguments = args),\n     receivedArguments: () => receivedArguments,\n        receivedArgument: n => receivedArguments[n]\n      };\n    };\n    ```", "```js\n    const itSubmitsExistingValue = (fieldName, value) =>\n      it(\"saves existing value when submitted\", () => {\n        const submitSpy = spy();\n        const customer = { [fieldName]: value };\n        render(\n          <CustomerForm\n            original={customer}\n            onSubmit={submitSpy.fn}\n          />\n        );\n        click(submitButton());\n        expect(\n          submitSpy.receivedArguments()\n        ).toBeDefined();\n        expect(submitSpy.receivedArgument(0)).toEqual(\n          customer\n        );\n      });\n    ```", "```js\nexpect(submitSpy).toBeCalledWith(value);\n```", "```js\n    expect.extend({\n      toBeCalled(received) {\n        if (received.receivedArguments() === undefined) {\n          return {\n            pass: false,\n            message: () => \"Spy was not called.\",\n          };\n        }\n        return {\n          pass: true,\n          message: () => \"Spy was called.\",\n        };\n      },\n    });\n    ```", "```js\n    const itSubmitsExistingValue = (fieldName, value) =>\n      it(\"saves existing value when submitted\", () => {\n        const submitSpy = spy();\n        const customer = { [fieldName]: value };\n        render(\n          <CustomerForm\n            original={customer}\n            onSubmit={submitSpy.fn}\n          />\n        );\n        click(submitButton());\n        expect(submitSpy).toBeCalled(customer);\n        expect(submitSpy.receivedArgument(0)).toEqual(\n          customer\n        );\n      });\n    ```", "```js\n    expect.extend({\n      toBeCalledWith(received, ...expectedArguments) {\n        if (received.receivedArguments() === undefined) {\n          ...\n        }\n        const notMatch = !this.equals(\n          received.receivedArguments(),\n          expectedArguments\n        );\n        if (notMatch) {\n          return {\n            pass: false,\n            message: () =>\n              \"Spy called with the wrong arguments: \" +\n              received.receivedArguments() +\n              \".\",\n          };\n        }\n        return ...;\n      },\n    });\n    ```", "```js\n    const itSubmitsExistingValue = (fieldName, value) =>\n      it(\"saves existing value when submitted\", () => {\n        ...\n        click(submitButton());\n        expect(submitSpy).toBeCalledWith(customer);\n      });\n    ```", "```js\n    describe(\"CustomerForm\", () => {\n      const originalFetch = global.fetch;\n      let fetchSpy;\n      ...\n    })\n    ```", "```js\n    beforeEach(() => {\n      initializeReactContainer();\n      fetchSpy = spy();\n      global.fetch = fetchSpy.fn;\n    });\n    ```", "```js\n    afterEach(() => {\n      global.fetch = originalFetch;\n    });\n    ```", "```js\n    it(\"sends request to POST /customers when submitting the form\", () => {\n      render(\n        <CustomerForm\n          original={blankCustomer}\n          onSubmit={() => {}}\n        />\n      );\n      click(submitButton());\n      expect(fetchSpy).toBeCalledWith(\n        \"/customers\",\n        expect.objectContaining({\n          method: \"POST\",\n        })\n      );\n    });\n    ```", "```js\n      ● CustomerForm › sends request to POST /customers when submitting the form\n        Spy was not called.\n          163 |     );\n          164 |     click(submitButton());\n        > 165 |     expect(fetchSpy).toBeCalledWith(\n              |                      ^\n          166 |       \"/customers\",\n          167 |       expect.objectContaining({\n          168 |         method: \"POST\",\n    ```", "```js\n    const handleSubmit = (event) => {\n      event.preventDefault();\n      global.fetch(\"/customers\", {\n        method: \"POST\",\n      });\n      onSubmit(customer);\n    };\n    ```", "```js\n    it(\"calls fetch with the right configuration\", () => {\n      render(\n        <CustomerForm\n          original={blankCustomer}\n          onSubmit={() => {}}\n        />\n      );\n      click(submitButton());\n      expect(fetchSpy).toBeCalledWith(\n        expect.anything(),\n        expect.objectContaining({\n          credentials: \"same-origin\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n          },\n        })\n      );\n    });\n    ```", "```js\n      ● CustomerForm › calls fetch with the right configuration when submitting the form\n        Spy was called with the wrong arguments: /customers,[object Object].\n    ```", "```js\n    const handleSubmit = (event) => {\n      event.preventDefault();\n      global.fetch(\"/customers\", {\n        method: \"POST\",\n        credentials: \"same-origin\",\n        headers: { \"Content-Type\": \"application/json\" },\n      });\n      onSubmit(customer);\n    };\n    ```", "```js\n    const itSubmitsExistingValue = (fieldName, value) =>\n      it(\"saves existing value when submitted\", () => {\n        const customer = { [fieldName]: value };\n        const submitSpy = spy();\n        render(\n          <CustomerForm\n            original={customer}\n            onSubmit={submitSpy.fn}\n          />\n        );\n        click(submitButton());\n        expect(submitSpy).toBeCalledWith(customer);\n        expect(fetchSpy).toBeCalledWith(\n          expect.anything(),\n          expect.objectContaining({\n            body: JSON.stringify(customer),\n          })\n        );\n      });\n    ```", "```js\n    const handleSubmit = (event) => {\n      event.preventDefault();\n      global.fetch(\"/customers\", {\n        method: \"POST\",\n        credentials: \"same-origin\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify(original),\n      });\n      onSubmit(customer);\n    };\n    ```", "```js\n    const itSubmitsNewValue = (fieldName, value) =>\n      it(\"saves new value when submitted\", () => {\n        ...\n        expect(fetchSpy).toBeCalledWith(\n          expect.anything(),\n          expect.objectContaining({\n            body: JSON.stringify({\n              ...blankCustomer,\n              [fieldName]: value,\n            }),\n          })\n        );\n      });\n    ```", "```js\n    const handleSubmit = (event) => {\n      event.preventDefault();\n      global.fetch(\"/customers\", {\n        method: \"POST\",\n        credentials: \"same-origin\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify(customer),\n      });\n      onSubmit(customer);\n    };\n    ```", "```js\n    const itSubmitsExistingValue = (fieldName, value) =>\n      it(\"saves existing value when submitted\", () => {\n        const customer = { [fieldName]: value };\n        render(<CustomerForm original={customer} />);\n        click(submitButton());\n        expect(fetchSpy).toBeCalledWith(\n          expect.anything(),\n          expect.objectContaining({\n            body: JSON.stringify(customer),\n          })\n        );\n      });\n    ```", "```js\n    const itSubmitsNewValue = (fieldName, value) =>\n      it(\"saves new value when submitted\", () => {\n        render(<CustomerForm original={blankCustomer} />);\n        change(field(fieldName), value);\n        click(submitButton());\n        expect(fetchSpy).toBeCalledWith(\n          expect.anything(),\n          expect.objectContaining({\n            body: JSON.stringify({\n              ...blankCustomer,\n              [fieldName]: value,\n            }),\n          })\n        );\n      });\n    ```", "```js\n    const bodyOfLastFetchRequest = () =>\n      JSON.parse(fetchSpy.receivedArgument(1).body);\n    ```", "```js\n    const itSubmitsExistingValue = (fieldName, value) =>\n      it(\"saves existing value when submitted\", () => {\n        const customer = { [fieldName]: value };\n        render(<CustomerForm original={customer} />);\n        click(submitButton());\n        expect(bodyOfLastFetchRequest()).toMatchObject(\n          customer\n        );\n      });\n    ```", "```js\n    const itSubmitsNewValue = (fieldName, value) =>\n      it(\"saves new value when submitted\", () => {\n        render(<CustomerForm original={blankCustomer} />);\n        change(field(fieldName), value);\n        click(submitButton());\n        expect(bodyOfLastFetchRequest()).toMatchObject({\n          [fieldName]: value,\n        });\n      });\n    ```", "```js\n    let returnValue;\n    ```", "```js\n    fn: (...args) => {\n      receivedArguments = args;\n      return returnValue;\n    },\n    ```", "```js\n    stubReturnValue: value => returnValue = value\n    ```", "```js\nawait act(async () => performAsyncAction());\n```", "```js\n    const fetchResponseOk = (body) =>\n      Promise.resolve({\n        ok: true,\n        json: () => Promise.resolve(body)\n      });\n    ```", "```js\n    export const clickAndWait = async (element) =>\n      act(async () => click(element));\n    ```", "```js\n    import {\n      ...,\n      clickAndWait,\n    } from \"./reactTestExtensions\";\n    ```", "```js\n    it(\"notifies onSave when form is submitted\", async () => {\n      const customer = { id: 123 };\n      fetchSpy.stubReturnValue(fetchResponseOk(customer));\n      const saveSpy = spy();\n      render(\n        <CustomerForm\n          original={customer}\n          onSave={saveSpy.fn}\n        />\n      );\n      await clickAndWait(submitButton());\n      expect(saveSpy).toBeCalledWith(customer);\n    });\n    ```", "```js\n    export const CustomerForm = ({\n      original, onSave\n    }) => {\n      ...\n    };\n    ```", "```js\n    const handleSubmit = async (event) => {\n      event.preventDefault();\n      const result = await global.fetch(...);\n      const customerWithId = await result.json();\n      onSave(customerWithId);\n    };\n    ```", "```js\n    beforeEach(() => {\n      ...\n      fetchSpy.stubReturnValue(fetchResponseOk({}));\n    });\n    ```", "```js\n    it(\"sends HTTP request to POST /customers when submitting data\", async () => {\n      render(<CustomerForm original={blankCustomer} />);\n      await clickAndWait(submitButton());\n      ...\n    });\n    ```", "```js\n    export const submitAndWait = async (formElement) =>\n      act(async () => submit(formElement));\n    ```", "```js\n    import {\n      ...,\n      submitAndWait,\n    } from \"./reactTestExtensions\";\n    ```", "```js\n    it(\"prevents the default action when submitting the form\", async () => {\n      render(<CustomerForm original={blankCustomer} />);\n      const event = await submitAndWait(form());\n      expect(event.defaultPrevented).toBe(true);\n    });\n    ```", "```js\n    it(\"calls fetch with correct configuration\", async () => {\n      render(\n        <CustomerForm\n          original={blankCustomer}\n          onSave={() => {}}\n        />\n      );\n      ...\n    });\n    ```", "```js\n    const fetchResponseError = () =>\n      Promise.resolve({ ok: false });\n    ```", "```js\n    it(\"does not notify onSave if the POST request returns an error\", async () => {\n      fetchSpy.stubReturnValue(fetchResponseError());\n      const saveSpy = spy();\n      render(\n        <CustomerForm\n          original={blankCustomer}\n          onSave={saveSpy.fn}\n        />\n      );\n      await clickAndWait(submitButton());\n      expect(saveSpy).not.toBeCalledWith();\n    });\n    ```", "```js\n    const handleSubmit = async (event) => {\n      ...\n      const result = ...;\n      if (result.ok) {\n        const customerWithId = await result.json();\n        onSave(customerWithId);\n      }\n    };\n    ```", "```js\n    it(\"renders an alert space\", async () => {\n      render(<CustomerForm original={blankCustomer} />);\n      expect(element(\"[role=alert]\")).not.toBeNull();\n    });\n    ```", "```js\n    const Error = () => (\n      <p role=\"alert\" />\n    );\n    ```", "```js\n    <form>\n      <Error />\n      ...\n    </form>\n    ```", "```js\n    it(\"renders error message when fetch call fails\", async () => {\n      fetchSpy.mockReturnValue(fetchResponseError());\n      render(<CustomerForm original={blankCustomer} />);\n      await clickAndWait(submitButton());\n      expect(element(\"[role=alert]\")).toContainText(\n        \"error occurred\"\n      );\n    });\n    ```", "```js\n    const Error = () => (\n      <p role=\"alert\">\n        An error occurred during save.\n      </p>\n    );\n    ```", "```js\n    it(\"initially hano text in the alert space\", async () => {\n      render(<CustomerForm original={blankCustomer} />);\n      expect(element(\"[role=alert]\")).not.toContainText(\n        \"error occurred\"\n      );\n    });\n    ```", "```js\n    const [error, setError] = useState(false);\n    ```", "```js\n    const handleSubmit = async (event) => {\n      ...\n      if (result.ok) {\n        ...\n      } else {\n        setError(true);\n      }\n    }\n    ```", "```js\n    <form>\n      <Error hasError={error} />\n      ...\n    </form>\n    ```", "```js\n    const Error = ({ hasError }) => (\n      <p role=\"alert\">\n        {hasError ? \"An error occurred during save.\" : \"\"}\n      </p>\n    ); \n    ```", "```js\n    it(\"renders an alert space\", ...)\n    it(\"initially has no text in the alert space\", ...)\n    describe(\"when POST request returns an error\", () => {\n      it(\"does not notify onSave if the POST request returns an error\", ...)\n      it(\"renders error message when fetch call fails\", ...)\n    });\n    ```", "```js\n    describe(\"when POST request returns an error\", () => {\n      it(\"does not notify onSave\", ...)\n      it(\"renders error message \", ...)\n    });\n    ```", "```js\n    describe(\"when POST request returns an error\", () => {\n      beforeEach(() => {\n        fetchSpy.stubReturnValue(fetchResponseError());\n      });\n      ...\n    })\n    ```", "```js\n    beforeEach(() => {\n      initializeReactContainer();\n      jest\n        .spyOn(global, \"fetch\")\n        .mockResolvedValue(fetchResponseOk({}));\n    });\n    ```", "```js\n    fetchSpy.stubResolvedValue(...);\n    ```", "```js\nglobal.fetch.mockResolvedValue(...);\n```", "```js\n    expect(global.fetch).toBeCalledWith(\n      \"/customers\",\n      expect.objectContaining({\n        method: \"POST\",\n      })\n    );\n    ```", "```js\n    const bodyOfLastFetchRequest = () => {\n      const allCalls = global.fetch.mock.calls;\n      const lastCall = allCalls[allCalls.length - 1];\n      return JSON.parse(lastCall[1].body);\n    };\n    ```", "```js\n    \"jest\": {\n      ...,\n      \"restoreMocks\": true\n    }\n    ```", "```js\n    it(\"notifies onSave when form is submitted\", async () => {\n      const customer = { id: 123 };\n      global.fetch.mockResolvedValue(\n        fetchResponseOk(customer)\n      );\n      const saveSpy = jest.fn();\n      render(\n        <CustomerForm\n          original={blankCustomer}\n          onSave={saveSpy}\n        />\n      );\n      await clickAndWait(submitButton());\n      expect(saveSpy).toBeCalledWith(customer);\n    });\n    ```", "```js\n    Cannot spy the fetch property because it is not a function; undefined given instead\n    ```", "```js\n    global.fetch = () => Promise.resolve({});\n    ```", "```js\n    \"setupFilesAfterEnv\": [\n      \"./test/domMatchers.js\",\n      \"./test/globals.js\"\n    ],\n    ```", "```js\n    expect(saveSpy).not.toBeCalledWith();\n    ```", "```js\nexpect(saveSpy).not.toBeCalled();\n```", "```js\n    export const bodyOfLastFetchRequest = () => {\n      const allCalls = global.fetch.mock.calls;\n      const lastCall = allCalls[allCalls.length - 1];\n      return JSON.parse(lastCall[1].body);\n    };\n    ```", "```js\n    export const fetchResponseOk = (body) =>\n      Promise.resolve({\n        ok: true,\n        json: () => Promise.resolve(body),\n      });\n    export const fetchResponseError = () =>\n      Promise.resolve({ ok: false });\n    ```", "```js\n    import { bodyOfLastFetchRequest } from \"./spyHelpers\";\n    import {\n      fetchResponseOk,\n      fetchResponseError,\n    } from \"./builders/fetch\";\n    ```", "```js\n    export const fetchResponseOk = (body) => ({\n      ok: true,\n      json: () => Promise.resolve(body),\n    });\n    export const fetchResponseError = () => ({\n      ok: false,\n    });\n    ```"]