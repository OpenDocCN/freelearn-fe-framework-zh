<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Flip Flop"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Flip Flop</h1></div></div></div><p>At this point, we should be confident about performing the initial implementation of an Angular application using TDD. Also, we should be familiar with using the test-first approach. The test-first approach is very good for the learning stage, but sometimes it's a time suck when we get a lot of errors. For simple and known behavior, it may not be good to go for the test-first approach.</p><p>We have already seen how the test-first approach works, so we can skip those steps by checking any feature without creating those components. Besides that, we can go one step further to make us more confident in writing our components faster. We can have our components ready and then write end-to-end test specs to test the expected behavior. If the e2e test fails, we can trigger an error in the Protractor debugger.</p><p>In this chapter, we will continue to expand our knowledge of applying TDD (but not the test-first approach) with Angular. We will not discuss the details of the basic Angular component ecosystem here; rather, we will go a step ahead and include more Angular features. We will take our knowledge further by looking at the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Angular routes</li><li class="listitem" style="list-style-type: disc">Navigating to routes</li><li class="listitem" style="list-style-type: disc">Communicating with route parameter data</li><li class="listitem" style="list-style-type: disc">Protractor location references with CSS and  HTML elements</li></ul></div><div class="section" title="Fundamentals of TDD"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec51"/>Fundamentals of TDD</h1></div></div></div><p>In this chapter, we will walk-through applying TDD to routes and navigation for a search application. Before getting into the walk-through, we need to be aware of some of the techniques, configurations, and functions that will be used throughout this chapter, which include the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Protractor locators</li><li class="listitem" style="list-style-type: disc">Headless browser testing</li></ul></div><p>After reviewing these concepts, we can move on to the walk-through.</p><div class="section" title="Protractor locators"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec96"/>Protractor locators</h2></div></div></div><p>Protractor locators are key components where everybody should spend some time to learn. In the previous Protractor chapters, we understood some commonly used locators with working examples. We will provide some examples of the Protractor <code class="literal">Locator</code> here.</p><p>Protractor locators allow us to find elements within an HTML page. In this chapter, we will see the CSS, HTML, and Angular-specific locators in action. Locators are passed to the <code class="literal">element</code> function. The <code class="literal">element</code> function will find and return the elements on a page. The generic locator syntax is as follows:</p><pre class="programlisting">element(by.&lt;LOCATOR&gt;); &#13;
</pre><p>In the preceding code, <code class="literal">&lt;LOCATOR&gt;</code> is a placeholder. The following sections describe a couple of these locators.</p><div class="section" title="CSS locators"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec35"/>CSS locators</h3></div></div></div><p>CSS is used to add layout, color, formatting, and style to an HTML page. From an end-to-end testing perspective, the look and style of an element may be part of a specification. As an example, consider the following HTML snippet:</p><pre class="programlisting">&lt;div class="anyClass" id="anyId"&gt;&lt;/div&gt; &#13;
// ... &#13;
var e1 = element(by.css('.anyClass')); &#13;
var e2 = element(by.css('#anyId')); &#13;
var e3 = element(by.css('div')); &#13;
var e4 = $('div'); &#13;
</pre><p>All these four selections will select the <code class="literal">div</code> element.</p></div><div class="section" title="Button and link locators"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec36"/>Button and link locators</h3></div></div></div><p>Besides being able to select and interpret the way something looks, it is also important to be able to find buttons and links within a page. This will allow a test to interact with the site easily. Here are a couple of examples:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">buttonText</code> locator:</li></ul></div><pre class="programlisting">        &lt;button&gt;anyButton&lt;/button&gt; &#13;
        // ... &#13;
        var b1 = element(by.buttonText('anyButton')); &#13;
</pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">linkText</code> locator:</li></ul></div><pre class="programlisting">        &lt;a href="#"&gt;anyLink&lt;/a&gt; &#13;
        // ... &#13;
        var a1 = element(by.linkText('anyLink')); &#13;
</pre></div><div class="section" title="URL location references"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec37"/>URL location references</h3></div></div></div><p>When testing Angular routes, we need to be able to test the URL of our test. By adding tests around the URL and location, we have to ensure that the application works with specific routes. This is important because routes provide an interface to our application. Here is how to get the URL reference in a Protractor test:</p><pre class="programlisting">var location = browser.getLocationAbsUrl(); &#13;
</pre><p>Now that we have seen how to use the different locators, it is time to put the knowledge to use.</p></div></div></div></div>
<div class="section" title="Preparing an Angular project"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec52"/>Preparing an Angular project</h1></div></div></div><p>It is important to get a process and method to set up your projects quickly. The less time you spend on thinking about the structure of the directory and the required tools, the more time you can spend developing!</p><p>For this reason, in the previous chapters, we looked at how to get simple existing projects for Angular developed as <code class="literal">quickstart</code> projects (<a class="ulink" href="https://github.com/angular/quickstart">https://github.com/angular/quickstart</a>).</p><p>However, some people use the <code class="literal">angular2-seed</code> (<a class="ulink" href="https://github.com/angular/angular-seed">https://github.com/mgechev/angular2-seed</a>) project, Yeoman, or create a custom template. Although these techniques are useful and have their merits, when starting out in Angular, it is essential to understand what it takes to build an application from the ground up. By building the directory structure and installing tools by ourselves, we will understand Angular better.</p><p>You will be able to make layout decisions based on your specific application and needs, as opposed to fitting them into some other module. As you grow and become a better Angular developer, this step may not be needed and will become second nature to you.</p><div class="section" title="Loading the existing project"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec97"/>Loading the existing project</h2></div></div></div><p>To start off, we will clone the project from the Angular <code class="literal">quickstart</code> project at <a class="ulink" href="https://github.com/angular/quickstart">https://github.com/angular/quickstart</a>, rename it as <code class="literal">angular-flip-flop</code>, and our project folder structure will look as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_07_001.jpg" alt="Loading the existing project"/></div><p>
</p><p>In the previous chapters, we discussed how to set up the project, understood the different components involved, and walked through the entire process. We will skip these details and assume that you can recall how to perform the necessary installation.</p></div><div class="section" title="Preparing the project"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec98"/>Preparing the project</h2></div></div></div><p>This <code class="literal">quickstart</code> project doesn't included the base <code class="literal">href</code> in the project's landing page (<code class="literal">index.html</code>). We will need that to proceed perfectly with routing, so let's add a single line (<code class="literal">base href</code>) to the <code class="literal">&lt;head&gt;</code> section of <code class="literal">index.html</code>:</p><pre class="programlisting">&lt;base href="/"&gt; &#13;
</pre><p>Here, our bootstrapping component is in the application component and the HTML template is in the component itself. We should separate the template to a new file before proceeding.</p><p>For that, we will update our application component (<code class="literal">app/app.component.ts</code>), as follows:</p><pre class="programlisting">import { Component } from '@angular/core'; &#13;
 &#13;
@Component({ &#13;
  moduleId: module.id, &#13;
  selector: 'my-app', &#13;
  templateUrl: 'app.component.html' &#13;
}) &#13;
export class AppComponent { &#13;
 &#13;
}; &#13;
</pre><p>Let's create our separate template file at <code class="literal">app/app.component.html</code>. And the code will look like this:</p><pre class="programlisting">&lt;h1&gt;My First Angular 2 App&lt;/h1&gt; &#13;
</pre></div><div class="section" title="Running the project"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec99"/>Running the project</h2></div></div></div><p>Let's proceed with it and get ready to run using the following commands:</p><pre class="programlisting">
<span class="strong"><strong>$ cd angular-flip-flop</strong></span>
<span class="strong"><strong>$ npm install // To install the required node modules. </strong></span>
<span class="strong"><strong>$ npm run // To build and run the project in http server. </strong></span>
</pre><p>To confirm the installation and run the project, the application will automatically run in the web browser.</p><p>Here is the expected output after running the project:</p><p>
</p><div class="mediaobject"><img src="graphics/image_07_002.jpg" alt="Running the project"/></div><p>
</p></div><div class="section" title="Restructuring the project"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec100"/>Restructuring the project</h2></div></div></div><p>Let's change the project structure a bit, not much though. By default, it has included unit testing in the same location as the components file and separated the e2e testing file outside the <code class="literal">app/</code> folder in the <code class="literal">e2e/</code> folder.</p><p>However, we will keep all the tests in the same location, that is, outside of <code class="literal">app</code>; we will keep all the tests as <code class="literal">spec/e2e</code> and <code class="literal">spec/unit</code>.</p><p>The goal is to separate the test specs from the component. This way, we can keep our unit tests file outside in the <code class="literal">spec/unit</code> folder.</p><p>So, our current folder structure will look like this:</p><p>
</p><div class="mediaobject"><img src="graphics/image_07_003.jpg" alt="Restructuring the project"/></div><p>
</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note15"/>Note</h3><p>As long as we have changed the path for both unit and e2e tests, we should have to change the path in the Karma configuration and Protractor configuration files.</p></div></div></div></div>
<div class="section" title="Setting up headless browser testing for Karma"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec53"/>Setting up headless browser testing for Karma</h1></div></div></div><p>In the previous chapters, we were running Karma using the default configuration. The default Chrome configuration launches Chrome on every test. Testing against the actual code and browser that the application will run in is a powerful tool. However, when launching, a browser may not always know how you want it to behave. From a unit test perspective, you may not want the browser to be launched in a window. The reason could be that tests may take a long time to run or you may not always have a browser installed.</p><p>Luckily, Karma comes equipped with the ability to easily configure PhantomJS, a headless browser. A headless browser runs in the background and will not display web pages in a UI. The PhantomJS headless browser is a really great tool to use for testing. It can even be set up to take screenshots of your tests! Read more about how this is done and about the WebKit used on the PhantomJS site at <a class="ulink" href="http://phantomjs.org/">http://phantomjs.org/</a>. The following setup configuration will show us how to set up PhantomJS with Karma for headless browser testing.</p><div class="section" title="Preconfiguration"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec101"/>Preconfiguration</h2></div></div></div><p>When Karma is installed, it automatically includes the PhantomJS browser plugin. For further reference, the plugin is located at <a class="ulink" href="https://github.com/karma-runner/karma-phantomjs-launcher">https://github.com/karma-runner/karma-phantomjs-launcher</a>. There shouldn't be any more installation or configuration required.</p><p>However, if your setup states that it is missing <code class="literal">karma-phantomjs-launcher</code>, you can easily install it using <code class="literal">npm</code>, like this:</p><pre class="programlisting">
<span class="strong"><strong>$ npm install karma-phantomjs-launcher --save -dev</strong></span>
</pre></div><div class="section" title="Configuration"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec102"/>Configuration</h2></div></div></div><p>PhantomJS is configured in the <code class="literal">browsers</code> section of the Karma configuration. Open the <code class="literal">karma.conf.js</code> file and update it with the following details:</p><pre class="programlisting">browsers: ['PhantomJS'], &#13;
</pre><p>Do that in the <code class="literal">plugins</code> option as well:</p><pre class="programlisting">plugins: [ &#13;
        ......... &#13;
        require('karma-phantomjs-launcher'), &#13;
    ], &#13;
</pre><p>Now that the project has been initialized and configured with headless browser testing, you can see it in action through the following walk-throughs.</p></div></div>
<div class="section" title="Walk-through of Angular routes and navigation"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec54"/>Walk-through of Angular routes and navigation</h1></div></div></div><p>This walk-through will leverage Angular routes. Routes are an extremely useful feature of Angular, as they were in Angular 1.x before it, but more powerful. They allow us to control certain aspects of the application using different components.</p><p>This walk-through will flip between components to show us how to use TDD to build routes. The following are the specifications. There will be a navigation menu, which has two menu items, <span class="strong"><strong>View1</strong></span> and <span class="strong"><strong>View2</strong></span>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In the navigation menu, click on label <span class="strong"><strong>View1</strong></span></li><li class="listitem" style="list-style-type: disc">The content area (router outlet) will load/flip <span class="strong"><strong>View1</strong></span> content</li></ul></div><p>And here's the second part:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In the navigation menu, click on label <span class="strong"><strong>View2</strong></span></li><li class="listitem" style="list-style-type: disc">The content area (router outlet) will load/flip <span class="strong"><strong>View2</strong></span> content</li></ul></div><p>Essentially, this will be an application that does a flip/flop between two views.</p><div class="section" title="Setting up Angular routes"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec103"/>Setting up Angular routes</h2></div></div></div><p>The router is an optional service in Angular, so it's not included in the Angular core. If we need to use the router, we will have to install the Angular <code class="literal">router</code> service in our application.</p><p>As long as we have cloned our project from <code class="literal">quickstart</code>, we should be okay because it has recently added the Angular router to its dependencies, but we should check and confirm. If it doesn't have <code class="literal">@angular/router</code> in its dependencies in <code class="literal">package.json</code>, we can install the Angular router using <code class="literal">npm</code>, as follows:</p><pre class="programlisting">
<span class="strong"><strong>$ npm install @angular/router --save</strong></span>
</pre><div class="section" title="Defining directions"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec38"/>Defining directions</h3></div></div></div><p>A route specifies a location and expects a result. From an Angular perspective, the routes must first be specified and then associated with certain components.</p><p>To implement a router in our application, we will need to import the router module in the application module, where it will register the router in the application. After that, we will need to configure all the routes and pass that configuration to the application module.</p></div><div class="section" title="The router module"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec39"/>The router module</h3></div></div></div><p>To implement a router in the application, we will need to import the <code class="literal">RouterModule</code> in our application module, located at <code class="literal">app/app.module.ts</code>, as follows:</p><pre class="programlisting">import {RouterModule} from "@angular/router"; &#13;
</pre><p>This will just make the <code class="literal">router</code> module available in the application system, but we will have to have a router configuration to define all the possible routers in the entire application and then import that configuration to the application ecosystem via the application module.</p></div><div class="section" title="Configuring routes"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec40"/>Configuring routes</h3></div></div></div><p>A router is useless until we configure it, and to do so, we first need to import the <code class="literal">router</code> component. Configuration will mainly contain a list of arrays, where route paths and related components live as key-value pairs. We can add the configuration array to the application module, or we can create a separate configuration file and include the app module in it. We will go for the second option so that route configuration will be separated from the app module.</p><p>Let's create the router configuration file in the application root as <code class="literal">app/app.routes.ts</code>. There, at first, we will need to import the Angular <code class="literal">Routes</code> from the Angular service, as shown here:</p><pre class="programlisting">import {Routes} from '@angular/router';&#13;
</pre><p>From the router config file, we will need to export the configuration array, as follows:</p><pre class="programlisting">export const rootRouterConfig: Routes = [ &#13;
 // List of routes will come here &#13;
]; &#13;
</pre></div><div class="section" title="Routers in the application"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec41"/>Routers in the application</h3></div></div></div><p>We've already imported the <code class="literal">router</code> module to our application module, located at <code class="literal">app/app.module.ts</code>.</p><p>Then, we will need to import the router configuration file (<code class="literal">rootRouterConfig</code>) to this application module file, as follows:</p><pre class="programlisting">import {rootRouterConfig} from "./app.routes";&#13;
</pre><p>In the application module, we know <code class="literal">NgModule</code> imports the optional modules to the application ecosystem, and similarly, to include the router in the application, <code class="literal">RouterModule</code> has a function known as <code class="literal">RouterModule.forRoot(RouterConfig)</code>, which accepts the <code class="literal">routerConfiguration</code> to implement a router in the entire application.</p><p>The application module (<code class="literal">app/app.module.ts</code>) will import that <code class="literal">RouterModule</code> as follows:</p><pre class="programlisting">@NgModule({ &#13;
  declarations: [AppComponent, ........], &#13;
  imports     : [........., RouterModule.forRoot(rootRouterConfig)], &#13;
  bootstrap   : [AppComponent] &#13;
}) &#13;
export class AppModule { &#13;
} &#13;
</pre></div><div class="section" title="Routes in the config"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec42"/>Routes in the config</h3></div></div></div><p>Now, let's add some routes to our <code class="literal">Routes</code> configuration array, which is located at <code class="literal">app/app.routes.ts</code>. The route configuration array contains some objects as key-value pairs, with mostly two to three elements in every object.</p><p>The first element in the array object contains the <code class="literal">path</code>, and the second one contains the relevant <code class="literal">component</code> to load for that <code class="literal">path</code>.</p><p>Let's add two routes to our configuration array, as shown here:</p><pre class="programlisting">export const rootRouterConfig: Routes = [ &#13;
  { &#13;
    path: 'view1',  &#13;
    component: View1Component &#13;
  }, &#13;
  { &#13;
    path: 'view2',  &#13;
    component: View2Component &#13;
  } &#13;
]; &#13;
</pre><p>Here, two routes, <code class="literal">view1</code> and <code class="literal">view2</code>, are defined, and two components have been assigned to load for that route.</p><p>In some cases, we may need to redirect from one route to another. For example, for the root path of the application (<code class="literal">''</code>), we may plan to redirect to the <code class="literal">view1</code> route. For that, we have to set the <code class="literal">redirectTo</code> element in the object and assign some route name as its value. We will also need to add one extra element as <code class="literal">pathMatch</code> and set its value to <code class="literal">full</code> so it will match the full path before redirecting to some other route.</p><p>The code will look as follows:</p><pre class="programlisting">export const rootRouterConfig: Routes = [ &#13;
  { &#13;
    path: '',  &#13;
    redirectTo: 'view1',  &#13;
    pathMatch: 'full' &#13;
  }, &#13;
  .............. &#13;
]; &#13;
</pre><p>So, yes, our initial route configuration is ready to go. Now, the full configuration will look like this:</p><pre class="programlisting">import {Routes} from '@angular/router'; &#13;
import {View1Component} from './view/view1.component'; &#13;
import {View2Component} from './view/view2.component'; &#13;
 &#13;
export const rootRouterConfig: Routes = [ &#13;
  { &#13;
    path: '',  &#13;
    redirectTo: 'view1',  &#13;
    pathMatch: 'full' &#13;
  }, &#13;
  { &#13;
    path: 'view1',  &#13;
    component: View1Component &#13;
  }, &#13;
  { &#13;
    path: 'view2',  &#13;
    component: View2Component &#13;
  } &#13;
]; &#13;
</pre><p>I should mention here that we have to import the <code class="literal">view1</code> and <code class="literal">view2</code> components as we have used them in the router config.</p><p>To learn more in detail about Angular routes, refer to <a class="ulink" href="https://angular.io/docs/ts/latest/guide/router.html">https://angular.io/docs/ts/latest/guide/router.html</a>.</p></div></div><div class="section" title="Hands-on routes"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec104"/>Hands-on routes</h2></div></div></div><p>So far, we have installed and imported a router module, configured routes, and included things in the application ecosystem. We still need to do some related tasks, such as creating a router outlet, creating navigation, and creating the component defined in the route, to have hands-on experience with routes.</p><div class="section" title="Defining the router outlet"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec43"/>Defining the router outlet</h3></div></div></div><p>As long as the route is configured in <code class="literal">appComponent</code>, we need a placeholder to load the route's navigated components, which Angular defines as the route outlet.</p><p>A <code class="literal">RouterOutlet</code> is a placeholder that Angular dynamically fills based on the application's route.</p><p>For our application, we will place the <code class="literal">router-outlet</code> in the <code class="literal">appComponent</code> template, located at (<code class="literal">/app/app.component.html</code>), like this:</p><pre class="programlisting">&lt;router-outlet&gt;&lt;/router-outlet&gt; &#13;
</pre></div><div class="section" title="Preparing the navigation"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec44"/>Preparing the navigation</h3></div></div></div><p>In the route configuration, we have set two paths, <code class="literal">/view1</code> and <code class="literal">/view2</code>, for our application. Now, let's create the navigation menu with two route paths to make navigation easy. For that, we can create a separate simple component so that navigation can be isolated for the entire application component.</p><p>Create a new component file for the <code class="literal">NavbarComponent</code> at <code class="literal">/app/nav/navbar.component.ts</code>, as shown here:</p><pre class="programlisting">import {Component} from '@angular/core'; &#13;
 &#13;
@Component({ &#13;
  selector: 'app-navbar', &#13;
  templateUrl: 'navbar.component.html', &#13;
  styleUrls: ['navbar.component.css'] &#13;
}) &#13;
export class NavbarComponent {} &#13;
</pre><p>Also, create a template for the navigation component at (<code class="literal">/app/nav/navbar.component.html</code>), as shown here:</p><pre class="programlisting">&lt;main&gt; &#13;
  &lt;nav&gt; &#13;
    &lt;a [routerLink]="['/view1']"&gt;View1&lt;/a&gt; &#13;
    &lt;a [routerLink]="['/view2']"&gt;View2&lt;/a&gt; &#13;
    &lt;a [routerLink]="['/members']"&gt;Members&lt;/a&gt;      &#13;
  &lt;/nav&gt; &#13;
&lt;/main&gt; &#13;
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note16"/>Note</h3><p>Don't bother about the <code class="literal">members</code> link in in the navigation for now; I'll tell you what it is in a later section.</p></div></div><p>Let's create the basic CSS style for the navigation component for a better look at <code class="literal">/app/nav/navbar.component.css</code>, as shown here:</p><pre class="programlisting">:host { &#13;
  border-color: #e1e1e1; &#13;
  border-style: solid; &#13;
  border-width: 0 0 1px; &#13;
  display: block; &#13;
  height: 48px; &#13;
  padding: 0 16px; &#13;
} &#13;
 &#13;
nav a { &#13;
  color: #8f8f8f; &#13;
  font-size: 14px; &#13;
  font-weight: 500; &#13;
  margin-right: 20px; &#13;
  text-decoration: none; &#13;
  vertical-align: middle; &#13;
} &#13;
 &#13;
nav a.router-link-active { &#13;
  color: #106cc8; &#13;
} &#13;
</pre><p>We have a navigation component. Now we will have to bind that to our app component, which is our application landing page.</p><p>To do so, we have to append the following to the <code class="literal">appComponent</code> template, located at <code class="literal">/app/app.component.html</code>:</p><pre class="programlisting">&lt;h1&gt;My First Angular 2 App&lt;/h1&gt; &#13;
&lt;app-navbar&gt;&lt;/app-navbar&gt; &#13;
&lt;router-outlet&gt;&lt;/router-outlet&gt; &#13;
</pre></div><div class="section" title="Preparing the components"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec45"/>Preparing the components</h3></div></div></div><p>For each defined route, we will need to create an individual component as every route will be associated with a component.</p><p>Here, we have two defined routes, and we will need to create two individual components to work on the routes' navigation. We will create <code class="literal">View1Component</code> and <code class="literal">View2Component</code> as per our requirement.</p><p>Create a new component file for the <code class="literal">View 1</code> component at <code class="literal">/app/view/view1.component.ts</code>, as follows:</p><pre class="programlisting">import {Component} from '@angular/core'; &#13;
 &#13;
@Component({ &#13;
  selector: 'app-view1', &#13;
  template: '&lt;div id="view1"&gt;I am view one component&lt;/div&gt;' &#13;
}) &#13;
export class View1Component { } &#13;
</pre><p>Create another component file for the <code class="literal">View 2</code> component (<code class="literal">/app/view/view2.component.ts</code>):</p><pre class="programlisting">import {Component} from '@angular/core'; &#13;
 &#13;
@Component({ &#13;
  selector: 'app-view2', &#13;
  template: '&lt;div id="view2"&gt;I am view two component&lt;/div&gt;' &#13;
}) &#13;
export class View2Component { } &#13;
</pre><p>We are ready with our routes and related components (<code class="literal">Navigation</code>, <code class="literal">View1</code>, and <code class="literal">View2</code>). Hopefully, everything's working as expected and we can see the application output in the browser.</p><p>Wait, before looking at the expected output in the browser, let's test the expected result with end-to-end testing. Now we know the expected behavior, and we will write out the e2e test specs based on our expectation. Once we're ready with the e2e test specs, we will see how it fulfills our expectation.</p></div></div><div class="section" title="Assembling the flip/flop test"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec105"/>Assembling the flip/flop test</h2></div></div></div><p>Following the first of the 3 As, <span class="emphasis"><em>assemble</em></span>, these steps will show us how to assemble the test:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start with the Protractor base template, as follows:<pre class="programlisting">        describe('Given views should flip through navigation         &#13;
        interaction', () =&gt; { &#13;
          beforeEach( () =&gt; { &#13;
            // ..... &#13;
        }); &#13;
 &#13;
        it('Should fliped to the next view', () =&gt; { &#13;
           // ....  &#13;
        }); &#13;
        }); &#13;
</pre></li><li class="listitem">Navigate to the root of the application using the following code:<pre class="programlisting">        browser.get('view1'); &#13;
</pre></li><li class="listitem">The <code class="literal">beforeEach</code> method needs to confirm that the correct component's view is being displayed. This can be done using a CSS locator to look for the <code class="literal">div</code> tag of <code class="literal">view1</code>. The expectation will look as follows:<pre class="programlisting">        var view1 = element(by.css('#view1')); &#13;
        expect(view1.isPresent()).toBeTruthy(); &#13;
</pre></li><li class="listitem">Then, add an expectation that <code class="literal">view2</code> is not visible:<pre class="programlisting">        var view2 = element(by.css('#view2')); &#13;
        expect(view2.isPresent()).toBeFalsy(); &#13;
</pre></li><li class="listitem">Then add further confirmation by getting the entire text of the <code class="literal">view1</code> component:<pre class="programlisting">        var view1 = element(by.css('#view1')); &#13;
        expect(view1.getText()).toEqual('I am view one component'); &#13;
</pre></li></ol></div><div class="section" title="Flipping to the next view"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec46"/>Flipping to the next view</h3></div></div></div><p>The preceding test needs to confirm that when the <code class="literal">view2</code> link will be clicked in the navigation, the <code class="literal">view2</code> component's content will load. In order to test this, we can use the <code class="literal">by.linkText</code> locator. Here is what it will look like:</p><pre class="programlisting">var view2Link = element(by.linkText('View2')); &#13;
view2Link.click(); &#13;
</pre><p>The <code class="literal">beforeEach</code> function is now complete and looks like this:</p><pre class="programlisting">var view1 = element(by.css('#view1')); &#13;
var view2 = element(by.css('#view2')); &#13;
beforeEach(() =&gt; { &#13;
    browser.get('view1'); &#13;
    expect(view1.isPresent()).toBeTruthy(); &#13;
    var view2Link = element(by.linkText('View2')); &#13;
    view2Link.click(); &#13;
}) &#13;
</pre><p>Next, we will add the assertion.</p></div><div class="section" title="Asserting a flip"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec47"/>Asserting a flip</h3></div></div></div><p>The assertion will again use Protractor's CSS locator, as shown here, to find whether <code class="literal">view2</code> is available:</p><pre class="programlisting">it('Should fliped to View2 and view2 should visible', () =&gt; { &#13;
  expect(view2.isPresent()).toBeTruthy(); &#13;
}); &#13;
</pre><p>We also need to confirm that <code class="literal">view1</code> is no longer available. Add the expectation that <code class="literal">view1</code> should not exist, as follows:</p><pre class="programlisting">it('Should fliped to View2 and view1 should not visible', () =&gt; { &#13;
  expect(view1.isPresent()).toBeFalsy(); &#13;
}); &#13;
</pre><p>Also, to make sure, we can check whether the <code class="literal">view2</code> contents have been loaded, as shown here:</p><pre class="programlisting">it('Should fliped to View2 and should have body content as expected',  () =&gt; { &#13;
    expect(view2.getText()).toEqual('I am view two component'); &#13;
}); &#13;
</pre><p>As we have the test about to switch from the <code class="literal">view1</code> to <code class="literal">view2</code> component by clicking on the <code class="literal">view2</code> link in the navigation, let's go back to the <code class="literal">view1</code> component by clicking on the <code class="literal">view1</code> link in the navigation, hoping things work as expected:</p><pre class="programlisting">it('Should flipped to View1 again and should visible', () =&gt; { &#13;
    var view1Link = element(by.linkText('View1')); &#13;
    view1Link.click(); &#13;
    expect(view1.isPresent()).toBeTruthy(); &#13;
    expect(view2.isPresent()).toBeFalsy(); &#13;
  }); &#13;
</pre><p>The test has now been assembled.</p></div></div><div class="section" title="Running the flip/flop test"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec106"/>Running the flip/flop test</h2></div></div></div><p>Our test spec is ready, and it's time to run it and see the result.</p><p>First, we will have to keep our project running via the HTTP server, with the following command:</p><pre class="programlisting">
<span class="strong"><strong>$ npm start</strong></span>
</pre><p>Then, we have to run Protractor. Be sure about the port number of the running application and Protractor configuration file; just to be sure, update the running server port in the configuration. To run Protractor, use the following command:</p><pre class="programlisting">
<span class="strong"><strong>$ npm run e2e</strong></span>
</pre><p>The results should be as follows:</p><pre class="programlisting">Suite: Given views should flip through navigation in &#13;
    passed - View1 should have body content as expected &#13;
    passed - Should flipped to View2 and view2 should visible &#13;
    passed - Should flipped to View2 and should have body content&#13;
    as expected &#13;
    passed - Should flipped to View1 again and should visible &#13;
        Suite passed: Given views should flip through navigation in &#13;
</pre><p>The Protractor tests have passed as per our expectations. Now we can have a look at the browser to check whether things are working the same way as the e2e test results.</p></div><div class="section" title="Opening the app in a browser"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec107"/>Opening the app in a browser</h2></div></div></div><p>As long as we've run the <code class="literal">npm start</code> command for e2e testing, our application could run on a specific port, <code class="literal">3000</code>,  on the localhost. By default, it will open in the browser.</p><p>The expected output is shown in the following screenshot:</p><p>
</p><div class="mediaobject"><img src="graphics/B05405_07_04-1.jpg" alt="Opening the app in a browser"/></div><p>
</p></div></div>
<div class="section" title="Searching the TDD way"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec55"/>Searching the TDD way</h1></div></div></div><p>This walk-through will show us how to build a simple search application. It has two components: the first discusses a search query component, and the second uses routes to display search result details.</p><div class="section" title="Walk-through of the search query"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec108"/>Walk-through of the search query</h2></div></div></div><p>The application being built is a search application. The first step is to set up the search area with search results. Imagine that I am performing a search. In this case, the following actions will occur:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A search query is typed in</li><li class="listitem" style="list-style-type: disc">The results are displayed at the bottom of the search box</li></ul></div><p>This piece of the application is very similar to the test, layout, and approach we have seen in <a class="link" href="ch06.html" title="Chapter 6. The First Step">Chapter 6</a>, <span class="emphasis"><em>The</em></span>
<span class="emphasis"><em>First Step</em></span>. The application will need to use an input, respond to a click, and confirm the resulting data. Since the tests and code use the same functionality as the previous example, it is not worth providing a complete walk-through of the search functionality. Instead, the following subsections will show the required code with a few explanations.</p></div><div class="section" title="The search query test"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec109"/>The search query test</h2></div></div></div><p>The following code represents the test for the search query functionality:</p><pre class="programlisting">describe('Given should test the search feature', () =&gt; { &#13;
    let searchBox, searchButton, searchResult; &#13;
 &#13;
    beforeEach(() =&gt; { &#13;
   &#13;
    //ASSEMBLE  &#13;
    browser.get(''); &#13;
    element(by.linkText('Search')).click(); &#13;
    searchResult = element.all(by.css('#searchList tbody tr')); &#13;
    expect(searchResult.count()).toBe(3); &#13;
 &#13;
    //ACT &#13;
    searchButton = element(by.css('form button')); &#13;
    searchBox = element(by.css('form input')); &#13;
    searchBox.sendKeys('Thomas'); &#13;
    searchButton.click(); &#13;
    }); &#13;
 &#13;
    //Assert &#13;
    it('There should be one item in search result', () =&gt; { &#13;
    searchResult = element.all(by.css('#searchList tbody tr')); &#13;
    expect(searchResult.count()).toBe(1); &#13;
    }); &#13;
}); &#13;
</pre><p>We should notice a parallel to the previous tests. The functionality is written to mirror the behavior of a user typing in the search box. The test finds the input field, types a value, and then selects the button that says <span class="strong"><strong>Search</strong></span>. The assertion confirms that the result contains a single value.</p></div><div class="section" title="The search application"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec110"/>The search application</h2></div></div></div><p>To perform a search operation, we will need to create a search component that will contain an input field to accept the user input (search query) and a button to perform user action with a click event. Besides that, it may have a placeholder to contain the search result.</p><p>As long as our application already has the router included, we can place the search component for a specific route.</p><p>Note that we have called our search component as <code class="literal">MembersComponent</code>, since we worked with some member data in the search component. And routes will be configured based on that as well.</p><p>So, in our existing <code class="literal">app.routes.ts</code> file, we will add the following search routes:</p><pre class="programlisting">export const rootRouterConfig: Routes = [ &#13;
  { &#13;
    path: '/members', &#13;
    component: MembersComponent &#13;
  } &#13;
................... &#13;
]; &#13;
</pre></div><div class="section" title="The search component"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec111"/>The search component</h2></div></div></div><p>The search component (<code class="literal">MembersComponent</code>) will be the main class for the search functionality here. It will perform a search and return the search result.</p><p>During the initial loading of the search component, it will not have any search query, so we have set the behavior to return all the data. Then, after the search trigger, it will return data based on a search query.</p><p>The search component will be placed in <code class="literal">app/members/members.compoennt.ts</code>. In the code, at first, we will have to import the required Angular services, as shown here:</p><pre class="programlisting">import { Component, OnInit } from '@angular/core'; &#13;
import { Http, Response } from '@angular/http'; &#13;
import { Router } from '@angular/router'; &#13;
</pre><p>We will use the <code class="literal">Http</code> service for the AJAX call, and by default, in Angular, the <code class="literal">Http</code> service returns an observable object. However, it's easier to handle a promise than an observable object. So, we will convert this observable object to a promise. Angular suggests using the <code class="literal">rxjs</code> module, which has the <code class="literal">toPromise</code> method, used to convert an observable object to a promise. So, we will import the <code class="literal">rxjs</code> module, as follows:</p><pre class="programlisting">import 'rxjs/add/operator/toPromise'; &#13;
</pre><p>Angular introduced the <code class="literal">ngOnInit()</code> method to be executed while initializing the component, similar to the contractor method in any class, but it's helpful to run the test spec. For that, we have imported the <code class="literal">OnInit</code> interface from the Angular core, and the <code class="literal">Component</code> class will implement the <code class="literal">OnInit</code> interface to get the <code class="literal">ngOnInit</code> method.</p><p>Besides that, the <code class="literal">Component</code> class should inject the required module, such as <code class="literal">Http</code> and <code class="literal">Router</code>, as follows:</p><pre class="programlisting">export class MembersComponent implements OnInit { &#13;
    constructor(private http:Http, private router:Router) { &#13;
  } &#13;
} &#13;
</pre><p>As discussed, we will use the <code class="literal">ngOnInit()</code> method, and from that, we will initialize the searching mechanism, like this:</p><pre class="programlisting">export class MembersComponent implements OnInit { &#13;
 ngOnInit() { &#13;
    this.search(); &#13;
  } &#13;
</pre><p>Here, we will apply the <code class="literal">search</code> feature on a member list, and for that, we have some dummy data at <code class="literal">app/data/people.json</code>. We will retrieve the data from here and perform a search operation on the data. Let's see how:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">getData()</code> method will retrieve the data from the API and will return a promise.</li></ul></div><pre class="programlisting">        getData() { &#13;
            return this.http.get('app/data/people.json') &#13;
            .toPromise() &#13;
            .then(response =&gt; response.json()); &#13;
        } &#13;
</pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">searchQuery()</code> method will resolve the returned promise and will make a data array based on the search query. If no search query is provided, it will return the complete dataset as an array:</li></ul></div><pre class="programlisting">        searchQuery(q:string) { &#13;
            if (!q || q === '*') { &#13;
              q = ''; &#13;
            } else { &#13;
              q = q.toLowerCase(); &#13;
            } &#13;
            return this.getData() &#13;
              .then(data =&gt; { &#13;
              let results:Array&lt;Person&gt; = []; &#13;
              data.map(item =&gt; { &#13;
                if (JSON.stringify(item).toLowerCase().includes(q)) { &#13;
                  results.push(item); &#13;
                } &#13;
              }); &#13;
              return results; &#13;
            }); &#13;
        } &#13;
</pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">search()</code> method will prepare the dataset for the template to bind to in the frontend:</li></ul></div><pre class="programlisting">        search(): void { &#13;
          this.searchQuery(this.query) &#13;
          .then(results =&gt; this.memberList = results); &#13;
        } &#13;
</pre><p>We have one more optional method here, which is used to navigate to the member details component. We've called that the <code class="literal">person</code> component. Here, the <code class="literal">viewDetails()</code> method will pass the member ID, and the <code class="literal">router.navigate()</code> method will navigate the application to the <code class="literal">person</code> component with the ID as a parameter, as shown here:</p><pre class="programlisting">viewDetails(id:number) { &#13;
    this.router.navigate(['/person', id]); &#13;
  } &#13;
</pre><p>The complete code of <code class="literal">MembersComponent</code> will be as follows:</p><pre class="programlisting">import { Component, OnInit } from '@angular/core'; &#13;
import { Http, Response } from '@angular/http'; &#13;
import { Router } from '@angular/router'; &#13;
import 'rxjs/add/operator/toPromise'; &#13;
import { Person } from './person/person.component'; &#13;
 &#13;
@Component({ &#13;
  selector: 'app-member', &#13;
  moduleId: module.id, &#13;
  templateUrl: 'members.component.html', &#13;
  styleUrls: ['members.component.css'] &#13;
}) &#13;
export class MembersComponent implements OnInit { &#13;
  memberList: Array&lt;Person&gt; = []; &#13;
  query: string; &#13;
 &#13;
  constructor(private http:Http, private router:Router) { &#13;
  } &#13;
 &#13;
  ngOnInit() { &#13;
    this.search(); &#13;
  } &#13;
 &#13;
  viewDetails(id:number) { &#13;
    this.router.navigate(['/person', id]); &#13;
  } &#13;
 &#13;
  getData() { &#13;
    return this.http.get('app/data/people.json') &#13;
      .toPromise() &#13;
      .then(response =&gt; response.json()); &#13;
  } &#13;
 &#13;
  search(): void { &#13;
    this.searchQuery(this.query) &#13;
    .then(results =&gt; this.memberList = results); &#13;
  } &#13;
 &#13;
  searchQuery(q:string) { &#13;
    if (!q || q === '*') { &#13;
      q = ''; &#13;
    } else { &#13;
      q = q.toLowerCase(); &#13;
    } &#13;
    return this.getData() &#13;
      .then(data =&gt; { &#13;
      let results:Array&lt;Person&gt; = []; &#13;
      data.map(item =&gt; { &#13;
        if (JSON.stringify(item).toLowerCase().includes(q)) { &#13;
          results.push(item); &#13;
        } &#13;
      }); &#13;
      return results; &#13;
    }); &#13;
  } &#13;
} &#13;
</pre><p>The <code class="literal">search</code> component template contains the search form and the list of search results when there are results to show.</p><p>The template looks as follows:</p><pre class="programlisting">&lt;h2&gt;Members&lt;/h2&gt; &#13;
 &#13;
&lt;form&gt; &#13;
  &lt;input type="search" [(ngModel)]="query" name="query" (keyup.enter)="search()"&gt; &#13;
  &lt;button type="button" (click)="search()"&gt;Search&lt;/button&gt; &#13;
&lt;/form&gt; &#13;
 &#13;
&lt;table *ngIf="memberList" id="searchList"&gt; &#13;
  &lt;thead&gt; &#13;
  &lt;tr&gt; &#13;
    &lt;th&gt;Name&lt;/th&gt; &#13;
    &lt;th&gt;Phone&lt;/th&gt; &#13;
  &lt;/tr&gt; &#13;
  &lt;/thead&gt; &#13;
  &lt;tbody&gt; &#13;
  &lt;tr *ngFor="let member of memberList; let i=index"&gt; &#13;
    &lt;td&gt;&lt;a href="javascript:void(0)" (click)="viewDetails(member.id)"&gt;{{member.name}}&lt;/a&gt;&lt;/td&gt; &#13;
    &lt;td&gt;{{member.phone}}&lt;/td&gt; &#13;
  &lt;/tr&gt; &#13;
  &lt;/tbody&gt; &#13;
&lt;/table&gt; &#13;
</pre><p>The preceding Angular components are similar to what has already been shown in the previous chapters.</p><p>We are using a dummy dataset from the <code class="literal">people.json</code> file, which contains information about people with addresses. We want to split the information in two parts, one as summary information and the other with address details. As we will work with this dataset, it will be easy to make an object model for this dataset.</p><p>The summary dataset will be defined as a <code class="literal">Person</code> object, and address details will be defined as <code class="literal">Address</code>. Let's create a person object at <code class="literal">app/members/person/person.component.ts</code> and place both object models in the same file.</p><p>The two object model classes for <code class="literal">Person</code> and <code class="literal">Address</code> look like this:</p><pre class="programlisting">export class Person { &#13;
  id:number; &#13;
  name:string; &#13;
  phone:string; &#13;
  address:Address; &#13;
 &#13;
  constructor(obj?:any) { &#13;
    this.id = obj &amp;&amp; Number(obj.id) || null; &#13;
    this.name = obj &amp;&amp; obj.name || null; &#13;
    this.phone = obj &amp;&amp; obj.phone || null; &#13;
    this.address = obj &amp;&amp; obj.address || null; &#13;
  } &#13;
} &#13;
 &#13;
export class Address { &#13;
  street:string; &#13;
  city:string; &#13;
  state:string; &#13;
  zip:string; &#13;
 &#13;
  constructor(obj?:any) { &#13;
    this.street = obj &amp;&amp; obj.street || null; &#13;
    this.city = obj &amp;&amp; obj.city || null; &#13;
    this.state = obj &amp;&amp; obj.state || null; &#13;
    this.zip = obj &amp;&amp; obj.zip || null; &#13;
  } &#13;
} &#13;
</pre></div><div class="section" title="Show me the search results!"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec112"/>Show me the search results!</h2></div></div></div><p>Now that the <span class="strong"><strong>Search</strong></span> button is set with the required features, the result should contain the data only based on the search query, instead of everything. Let's look at the user specification.</p><p>Given a set of search results:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We will have the member list based on the search query</li><li class="listitem" style="list-style-type: disc">We will click on any member's name and navigate to the details component for details</li></ul></div><p>Following the top-down approach, the first step will be the Protractor test, followed by the necessary steps to get the application fully functional.</p><div class="section" title="Testing the search results"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec48"/>Testing the search results</h3></div></div></div><p>As the specification states, we will need to leverage the existing search results. Instead of creating a test from scratch, we can add to the existing search query test. Start with a base test embedded in the search query test, as follows:</p><pre class="programlisting">describe('Given should test the search result in details view', () =&gt; { &#13;
  beforeEach(() =&gt; { &#13;
  }); &#13;
 &#13;
  it('should be load the person details page', () =&gt; { &#13;
  }); &#13;
}); &#13;
</pre><p>The next step is building the test.
</p></div><div class="section" title="Assembling the search result test"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec49"/>Assembling the search result test</h3></div></div></div><p>In this case, the search results are already available from the search query test. We don't have to add any more setup steps for the test.</p></div><div class="section" title="Selecting a search result"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec50"/>Selecting a search result</h3></div></div></div><p>The object under testing is the result. The test is that the result is selected and the application must then do something. The steps to writing this in Protractor are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Select the <code class="literal">resultItem</code>. As we will be representing the details using a route, we will create a link to the details page and click on the link. Here is how to create a link:<p>Select the link within the <code class="literal">resultItem</code>. This uses the currently selected element and then finds any subelements that meet the criteria. The code for this is as follows:</p><pre class="programlisting">        let resultItem = element(by.linkText('Demaryius Thomas')); &#13;
</pre></li><li class="listitem">Now, to select the link, add the following code:<pre class="programlisting">        resultItem.click(); &#13;
</pre></li></ol></div></div><div class="section" title="Confirming a search result"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec51"/>Confirming a search result</h3></div></div></div><p>Now that the search item has been selected, we will need to verify that the result details page is visible. The simplest solution at this point is to ensure that the details view is visible. This can be done using Protractor's CSS locator to look for the search detail view. The following is the code to be added for confirming a search result:</p><pre class="programlisting">it('Should be load the person details page', () =&gt; { &#13;
    var resultDetail = element(by.css('#personDetails')) &#13;
    expect(resultDetail.isDisplayed()).toBeTruthy(); &#13;
}) &#13;
</pre><p>Here is the complete test:</p><pre class="programlisting">describe('Given should test the search result in details view', () =&gt; { &#13;
 &#13;
  beforeEach(() =&gt; { &#13;
    browser.get('members'); &#13;
    let searchButton = element(by.css('form button')); &#13;
    let searchBox = element(by.css('form input')); &#13;
    searchBox.sendKeys('Thomas'); &#13;
    searchButton.click(); &#13;
    let resultItem = element(by.linkText('Demaryius Thomas')); &#13;
    resultItem.click(); &#13;
  }); &#13;
 &#13;
  it('should be load the person details page', () =&gt; { &#13;
    var resultDetail = element(by.css('#personDetails')) &#13;
    expect(resultDetail.isDisplayed()).toBeTruthy(); &#13;
  }); &#13;
 &#13;
}); &#13;
</pre><p>Now that the test is set up, we can continue to the next phase of the life cycle and run it.</p></div></div><div class="section" title="The search result component"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec113"/>The search result component</h2></div></div></div><p>The search result component (the one we named <code class="literal">Person</code>) will route to accept the person ID from the <code class="literal">params</code> route and will search data based on that ID.</p><p>The search result component will be placed in <code class="literal">app/members/person/person.component.ts</code>. In the code, at first, we will have to import the required Angular services, as shown here:</p><pre class="programlisting">import { Component, OnInit } from '@angular/core'; &#13;
import { Http, Response } from '@angular/http'; &#13;
import { Router, ActivatedRoute, Params } from '@angular/router'; &#13;
</pre><p>We've already seen some of these Angular services in the <code class="literal">members</code> component. Here, we will mainly discuss the <code class="literal">ActivatedRoute</code>, as it's new. This is an Angular router module, which is used to interact with the current/activated route: when we need to access the <code class="literal">params</code> in the current route, we'll access them through this.</p><p>As we discussed, we will need <code class="literal">ActivatedRoute</code> while initializing the component; therefore, we have called <code class="literal">ActivatedRoute</code> on the <code class="literal">ngOnInit()</code> method. It will provide the current route params for us, and we will have our expected ID, which will be used to retrieve that specific <code class="literal">Person</code> from the demo members dataset, as shown here:</p><pre class="programlisting">export class PersonComponent implements OnInit { &#13;
  person: Person; &#13;
  constructor(private http:Http, private route: ActivatedRoute, &#13;
  private router: Router) { &#13;
  } &#13;
 &#13;
  ngOnInit() { &#13;
    this.route.params.forEach((params: Params) =&gt; { &#13;
       let id = +params['id']; &#13;
       this.getPerson(id).then(person =&gt; { &#13;
         this.person = person; &#13;
       }); &#13;
     }); &#13;
  } &#13;
</pre><p>We have some dummy data at <code class="literal">app/data/people.json</code>. This is the same data used in the <code class="literal">members</code> component. We will retrieve the data based on the selected ID, like this:</p><pre class="programlisting">getData() { &#13;
    return this.http.get('app/data/people.json') &#13;
      .toPromise() &#13;
      .then(response =&gt; response.json()); &#13;
  } &#13;
</pre><p>The <code class="literal">getData()</code> method will retrieve the data from the API and will return a promise:</p><pre class="programlisting">getPerson(id:number) { &#13;
    return this.getData().then(data =&gt; data.find(member =&gt; &#13;
    member.id === id)); &#13;
  } &#13;
</pre><p>The <code class="literal">getPerson()</code> method will resolve the returned promise and will return the <code class="literal">Person</code> object based on the selected ID.</p><p>The complete code regarding <code class="literal">PersonComponent</code> will be as follows:</p><pre class="programlisting">import { Component, OnInit } from '@angular/core'; &#13;
import { Http, Response } from '@angular/http'; &#13;
import { Router, ActivatedRoute, Params } from '@angular/router'; &#13;
import 'rxjs/add/operator/toPromise'; &#13;
 &#13;
@Component({ &#13;
  selector: 'app-person', &#13;
  moduleId: module.id, &#13;
  templateUrl: 'person.component.html', &#13;
  styleUrls: ['../members.component.css'] &#13;
}) &#13;
export class PersonComponent implements OnInit { &#13;
  person: Person; &#13;
  constructor(private http:Http, private route: ActivatedRoute, private router: Router) { &#13;
  } &#13;
 &#13;
  ngOnInit() { &#13;
    this.route.params.forEach((params: Params) =&gt; { &#13;
       let id = +params['id']; &#13;
       this.getPerson(id).then(person =&gt; { &#13;
         this.person = person; &#13;
       }); &#13;
     }); &#13;
  } &#13;
 &#13;
  getPerson(id:number) { &#13;
    return this.getData().then(data =&gt; data.find(member =&gt; member.id === id)); &#13;
  } &#13;
 &#13;
  getData() { &#13;
    return this.http.get('app/data/people.json') &#13;
      .toPromise() &#13;
      .then(response =&gt; response.json()); &#13;
  } &#13;
} &#13;
</pre><p>The <code class="literal">search</code> component template contains the search form and the list of search results when there are some results to show.</p><p>The template looks as follows:</p><pre class="programlisting">&lt;h2&gt;Member Details&lt;/h2&gt; &#13;
 &#13;
&lt;table *ngIf="person" id="personDetails"&gt; &#13;
  &lt;tbody&gt; &#13;
  &lt;tr&gt; &#13;
    &lt;td&gt;Name :&lt;/td&gt; &#13;
    &lt;td&gt;{{person.name}}&lt;/td&gt; &#13;
  &lt;/tr&gt; &#13;
    &lt;tr&gt; &#13;
      &lt;td&gt;Phone: &lt;/td&gt; &#13;
      &lt;td&gt;{{person.phone}}&lt;/td&gt; &#13;
    &lt;/tr&gt; &#13;
    &lt;tr&gt; &#13;
      &lt;td&gt;Street: &lt;/td&gt; &#13;
      &lt;td&gt;{{person.address.street}}&lt;/td&gt; &#13;
    &lt;/tr&gt; &#13;
    &lt;tr&gt; &#13;
      &lt;td&gt;City: &lt;/td&gt; &#13;
      &lt;td&gt;{{person.address.city}}&lt;/td&gt; &#13;
    &lt;/tr&gt; &#13;
    &lt;tr&gt; &#13;
      &lt;td&gt;State: &lt;/td&gt; &#13;
      &lt;td&gt;{{person.address.state}}&lt;/td&gt; &#13;
    &lt;/tr&gt; &#13;
    &lt;tr&gt; &#13;
      &lt;td&gt;Zip: &lt;/td&gt; &#13;
      &lt;td&gt;{{person.address.zip}}&lt;/td&gt; &#13;
  &lt;/tr&gt; &#13;
  &lt;/tbody&gt; &#13;
&lt;/table&gt; &#13;
</pre></div><div class="section" title="Search results in the route"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec114"/>Search results in the route</h2></div></div></div><p>We have the search result/<code class="literal">Person</code> component, but we forgot to include that in the router configuration. Without that, we will have an exception as it will not be possible to navigate to the <code class="literal">Person</code> component from the <code class="literal">members</code> list without having it in the route.</p><p>So, in our existing <code class="literal">app.routes.ts</code> file, we will add the following search routes:</p><pre class="programlisting">export const rootRouterConfig: Routes = [ &#13;
  { &#13;
    path: '/person/:id', &#13;
    component: PersonComponent &#13;
  } &#13;
................... &#13;
]; &#13;
</pre></div></div>
<div class="section" title="Running the search wheel"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec56"/>Running the search wheel</h1></div></div></div><p>Our application is ready with the restructure, route configuration, e2e testing, and components with their child components. We will look at the current file structure and output of the project.</p><div class="section" title="App structure"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec115"/>App structure</h2></div></div></div><p>We have two major folders in our application, one is the <code class="literal">app</code> directory and the other is the <code class="literal">spec/test</code> directory.</p><p>Let's see the current structure of our <code class="literal">app</code> directory:</p><p>
</p><div class="mediaobject"><img src="graphics/B05405_07_05.jpg" alt="App structure"/></div><p>
</p><p>And here's the <code class="literal">test</code> directory:</p><p>
</p><div class="mediaobject"><img src="graphics/B05405_07_06.jpg" alt="App structure"/></div><p>
</p></div><div class="section" title="Let's run"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec116"/>Let's run</h2></div></div></div><p>Our search feature is ready to run. If we run <code class="literal">npm start</code>, our application will run in the browser on the port <code class="literal">3000</code> by default. Let's navigate to <span class="strong"><strong>Members</strong></span> to get the output of the search feature. The search feature URL is <code class="literal">http://localhost:3000/members</code>.</p><p>When we land on the <span class="strong"><strong>Members</strong></span> page, it will actually load all the data as the search input is empty, which means there is no search query. The output should look as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_07_007.jpg" alt="Let's run"/></div><p>
</p><p>Now let's check the <span class="strong"><strong>Members</strong></span> page with a search query. If we type <code class="literal">Thomas</code> as the query and search, it will give us only one data row, as shown here:</p><p>
</p><div class="mediaobject"><img src="graphics/image_07_008.jpg" alt="Let's run"/></div><p>
</p><p>We have one row in the data list. Now it's time to see the details of the data. After clicking on <span class="strong"><strong>Thomas</strong></span>, we will see detailed information about Thomas, with the address, as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_07_009.jpg" alt="Let's run"/></div><p>
</p><p>Hurray! The complete application is running in the browser as expected.</p></div><div class="section" title="How's e2e now!"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec117"/>How's e2e now!</h2></div></div></div><p>The project is running in the browser, and we've done e2e testing for every component. Let's see how the e2e test reacts when we run the whole application's e2e test together.</p><p>Let's run <code class="literal">npm run e2e</code>; the output is as shown here:</p><p>
</p><div class="mediaobject"><img src="graphics/B05405_07_10.jpg" alt="How's e2e now!"/></div><p>
</p></div></div>
<div class="section" title="Self-test questions"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec57"/>Self-test questions</h1></div></div></div><p>Q1. Which custom placeholder is used to load the component after navigation?</p><pre class="programlisting">&lt;router-output&gt; &lt;/router-output&gt; &#13;
 &#13;
&lt;router-outlet&gt; &lt;/router-outlet&gt; &#13;
 &#13;
&lt;router-link&gt; &lt;/router-link&gt; &#13;
</pre><p>Q2. Given the following Angular component, how would you select the <code class="literal">element</code> and simulate a click?</p><pre class="programlisting">&lt;a href="#"&gt;Some Link&lt;/a&gt; &#13;
$('a').click();. &#13;
element(by.css('li)).click();. &#13;
element(by.linkText('Some Link')).click();. &#13;
</pre><p>Q3. When using routes with Angular, you need to install <code class="literal">@angular/router</code>.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">True</li><li class="listitem" style="list-style-type: disc">False</li></ul></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec58"/>Summary</h1></div></div></div><p>This chapter showed us how to use TDD to build an Angular application. The approach, up to this point, has focused on the specification from a user perspective and using TDD with a top-down approach. This technique helps us get usable and small components tested and completed for the users.</p><p>As applications grow, so does their complexity. In the next chapter, we will explore the bottom-up approach and see when to use that technique over the top-down approach.</p><p>This chapter showed us how TDD can be used to develop a component-based application with navigation by routers. Routes allow us to get a nice separation of our components and views. We looked at the usage of several Protractor locators, from CSS to repeaters, link text, and inner locators. Besides using Protractor, we also learned how to configure Karma with a headless browser, and we got to see it in action.</p></div></body></html>