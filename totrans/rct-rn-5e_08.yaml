- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling Navigation with Routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Almost every web application requires routing, which is the process of responding
    to a URL based on a set of route handler declarations. In other words, this is
    a mapping from the URL to rendered content. However, this task is more involved
    than it seems at first, due to the complexities of managing different URL patterns
    and mapping them to appropriate content rendering. This includes handling nested
    routes and dynamic parameters and ensuring proper navigation flow. The complexities
    of these tasks are why you’re going to leverage the `react-router` package in
    this chapter, the de facto routing tool for React.
  prefs: []
  type: TYPE_NORMAL
- en: First, you’ll learn the basics of declaring routes using JSX syntax. Then, you’ll
    learn about the dynamic aspects of routing, such as dynamic path segments and
    query parameters. Next, you’ll implement links using components from `react-router`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the high-level topics that we’ll cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Declaring routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling route parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using link components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter07](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter07).
  prefs: []
  type: TYPE_NORMAL
- en: Declaring routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With `react-router`, you can collocate routes with the content that they render.
    By defining routes using JSX syntax alongside the components they are associated
    with, `react-router` empowers developers to create a clear and logical structure
    for their React applications. This collocation makes it easier to understand how
    different parts of the application are connected and navigated, leading to improved
    readability and maintainability of the code base.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, we’ll explore the fundamentals of routing in React
    applications using `react-router`. We’ll start by creating a basic example route
    to familiarize ourselves with the syntax and structure of route declarations.
    Then, we’ll dive deeper into organizing routes by feature, rather than relying
    on a monolithic routing module. Finally, we’ll implement a common parent-child
    routing pattern to demonstrate how to handle more complex routing scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Hello route
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we start writing code, let’s set up the `react-router` project. Run
    the following command to add `react-router-dom` to the dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s create a simple route that renders a simple component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have a small React component that we want to render when the route
    is activated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let’s look at the route definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `RouterProvider` component is the top-level component of the application.
    Let’s break it down to find out what’s happening within the router.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have the actual routes declared in the `createBrowserRouter` function.
    There are two key properties of any route: `path` and `element`. When the `path`
    property is matched against the active URL, the component is rendered. But where
    is it rendered, exactly? The router doesn’t actually render anything itself; it’s
    responsible for managing how other components are connected based on the current
    URL. In other words, the router checks the current URL and returns the corresponding
    component from the `createBrowserRouter` declaration. Sure enough, when you look
    at this example in a browser, `<MyComponent>` is rendered as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19636_07_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: The rendered output of our component'
  prefs: []
  type: TYPE_NORMAL
- en: When the `path` property matches the current URL, the route component is replaced
    by the `element` property value. In this example, the route returns `<MyComponent>`.
    If a given route doesn’t match, nothing is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: This example shows the fundamentals of routing in React. It’s really simple
    and intuitive to declare routes. To further solidify your understanding of `react-router`,
    I encourage you to experiment with the concepts we’ve covered. Try creating more
    routes on your own, and observe how they impact the behavior of your application.
    After that, you can try more advanced techniques like lazy loading components
    using React.lazy and Suspense (you’ll learn more about these in the next chapter),
    and implement route-based code splitting to optimize your application’s performance.
    By diving deeper into these topics and applying them to your own projects, you’ll
    gain a greater appreciation for the capabilities of `react-router` and its role
    in building modern, efficient, and user-friendly React applications.
  prefs: []
  type: TYPE_NORMAL
- en: Decoupling route declarations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The difficulty with routing happens when your application has dozens of routes
    declared within a single module since it’s more difficult to mentally map routes
    to features.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help with this, each top-level feature of the application can define its
    own routes. This way, it’s clear which routes belong to which feature. So, let’s
    start with the `App` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the application has two routes: `one` and `two`. These are
    imported as route objects and placed inside `createBrowserRouter`. The first `element`
    in this router is the `<Layout />` component, which renders a page template with
    data that never changes and serves as a place for our route data. Let’s take a
    look at the `<Layout />` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This component contains a small navigation toolbar with links and the `<Outlet
    />` component. It’s a built-in `react-router` component that will be replaced
    with matched route elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The router only gets as big as the number of application features, instead
    of the number of routes, which could be substantially larger. Let’s take a look
    at one of the feature routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This module, `one/index.js`, exports a configuration object with three routes:'
  prefs: []
  type: TYPE_NORMAL
- en: When the `/one` path is matched, redirect to `/one/1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the `/one/1` path is matched, render the `First` component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the `/one/2` path is matched, render the `Second` component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This means that when the app loads the URL, `/one`, the `<Redirect>` component,
    will send the user to `/one/1`. Like the `RouterProvider`, the `Redirect` component
    lacks UI elements inside; it solely manages logic.
  prefs: []
  type: TYPE_NORMAL
- en: This aligns with React’s practice of embedding components in layouts to handle
    specific functionalities. This approach allows for a clean separation of concerns,
    with components focused solely on rendering UI elements and others, like `Redirect`,
    dedicated to handling routing logic. The `Redirect` component in `react-router`
    is responsible for programmatically navigating the user to a different route.
    It’s commonly used to redirect users from one URL to another based on certain
    conditions, such as authentication status or route parameters. By abstracting
    away the navigation logic into a separate component, it promotes code reusability
    and maintainability within the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’re using `Redirect` here because we don’t have content on the root route.
    Often, your application doesn’t actually have content to render at the root of
    a feature, or at the root of the application itself. This pattern allows you to
    send the user to the appropriate route and the appropriate content. Here’s what
    you’ll see when you open the app and click on the **One** link:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19636_07_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.2: The contents of page 1'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second feature follows the exact same pattern as the first. Here’s what
    the `First` component looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Each feature, in this example, uses the same minimal rendered content. These
    components are ultimately what the user needs to see when they navigate to a given
    route. By organizing routes this way, you’ve made your features self-contained
    with regard to routing.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, you’ll learn how to further organize your routes into
    parent-child relationships.
  prefs: []
  type: TYPE_NORMAL
- en: Handling route parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The URLs that you’ve seen so far in this chapter have all been static. Most
    applications will use both **static** and **dynamic** routes. In this section,
    you’ll learn how to pass dynamic URL segments to your components, how to make
    these segments optional, and how to get query string parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Resource IDs in routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One common use case is to make the ID of a resource part of the URL. This makes
    it easy for your code to get the ID and then make an **API** call that fetches
    the relevant resource data. Let’s implement a route that renders a user detail
    page. This will require a route that includes the user ID, which then needs to
    somehow be passed to the component so that it can fetch the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with the `App` component that declares the routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `:` syntax marks the beginning of a URL variable. The `id` variable will
    be passed to the `UserContainer` component. Before displaying the component, the
    `loader` function is triggered, asynchronously fetching data for the specified
    user ID. In the case of data loading errors, the `errorElement` prop provides
    a fallback to handle such situations effectively. Here’s how `UserContainer` is
    implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `useParams()` hook is used to get any dynamic parts of the URL. In this
    case, you’re interested in the `id` parameter. Then, we get `user` from the loader
    function using the `useLoaderData` hook. If the URL is missing the segment completely,
    then this code won’t run at all; the router will revert us to the `errorElement`
    component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s take a look at the API functions that were used in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `fetchUsers()` function is used by the `UsersContainer` component to populate
    the list of user links. The `fetchUser()` function will find and resolve a value
    from the `users` array of the mock data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `User` component, which is responsible for rendering the user details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run this app and navigate to `/`, you should see a list of users that
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19636_07_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.3: The contents of the app home page'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking on the first link should take you to `/users/0`, which looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19636_07_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.4: The contents of the user page'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you navigate to a user that doesn’t exist, for example, `/users/2`, here’s
    what you’ll see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19636_07_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.5: When a user isn’t found'
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason that you get this error message instead of a 500 error is that the
    API endpoint knows how to deal with missing resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This rejection will be handled by `react-router` with the provided `errorElement`
    component.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll look at defining optional route parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Query parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, we need optional URL path values or query parameters. URLs work best
    for simple options, and query parameters work best if there are many values that
    the component can use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s implement a user list component that renders a list of users. Optionally,
    you want to be able to sort the list in descending order. Let’s make this with
    the route that can accept a query string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'There is no special setup in the router for handling query parameters. It’s
    up to the component to handle any query strings provided to it. So, while the
    route declaration doesn’t provide a mechanism to define accepted query strings,
    the router will still pass the query parameters to the component. Let’s take a
    look at the user list container component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This component looks for either of the `order` query strings. It uses this as
    an argument to the `fetchUsers()` API to determine the sort order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what the `Users` component looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is what’s rendered when you navigate to `/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19636_07_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.6: Rendering the user list in default order'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you include the `order` query parameter by navigating to `/?order=desc`,
    here’s what you get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19636_07_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.7: Rendering the user list in descending order'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned about parameters in routes. Perhaps the most common
    pattern is to have the ID of a resource in your app as part of the URL, which
    means that components need to be able to parse out this information in order to
    interact with the API. You also learned about query parameters in routes, which
    are useful for dynamic content, filtering, or passing temporary data between components.
    Next, you’ll learn about link components.
  prefs: []
  type: TYPE_NORMAL
- en: Using link components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you’ll learn how to create links. You might be tempted to use
    the standard `<a>` elements to link to pages controlled by `react-router`. The
    problem with this approach is that these links, in simple terms, will try to locate
    the page on the backend by sending a `GET` request. This isn’t what you want because
    the route configuration is already in the app and we can handle routes locally.
  prefs: []
  type: TYPE_NORMAL
- en: First, you’ll see an example that illustrates how `<Link>` components behave
    somewhat like `<a>` elements, except that they work locally. Then, you’ll see
    how to build links that use URL parameters and query parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Basic linking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The idea of links in React apps is that they point to routes that point to
    components, which render new content. The `Link` component also takes care of
    the browser history API and looks up route-component mappings. Here’s an application
    component that renders two links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `to` property specifies the route to activate when clicked. In this case,
    the application has two routes: `/first` and `/second`. Here is what the rendered
    links look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19636_07_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.8: Links to the first and second pages of the app'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you click the **First** link, the page content changes to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19636_07_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.9: The first page when the app is rendered'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you can use `Link` components to render links to basic paths, it’s
    time to learn about building dynamic links with parameters.
  prefs: []
  type: TYPE_NORMAL
- en: URL and query parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Constructing the dynamic segments of a path that is passed to `<Link>` involves
    string manipulation. Everything that’s part of the path goes to the `to` property.
    This means that you have to write more code to construct the string, but it also
    means less behind-the-scenes magic happening in the router.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a simple component that will echo back whatever is passed to the
    echo URL segment or the echo query parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In order to get search parameters that were passed to a route, you can use the
    `useSearchParams()` hook, which gives you a `URLSearchParams` object. In this
    case, we can call `searchParams.get("msg")` to get the parameter we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s take a look at the `App` component that renders two links. The first
    will build a string that uses a dynamic value as a URL parameter. The second will
    use `URLSearchParams` to build the query string portion of the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s what the two links look like when they’re rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19636_07_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.10: Different types of link parameters'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Param** link takes you to `/echo/From%20Param`, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19636_07_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.11: The param version of the page'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Query** link takes you to `/echo?msg=From+Query`, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19636_07_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.12: The query version of the page'
  prefs: []
  type: TYPE_NORMAL
- en: In learning about the `Link` component and dynamic link construction, you’ve
    unlocked a more interactive and navigable web experience, empowering users to
    move through your application with URL and query parameters that enrich their
    journey.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about routing in React applications. The job of
    a router is to render content that corresponds to a URL. The `react-router` package
    is the standard tool for this job. You learned how routes are JSX elements, just
    like the components they render. Sometimes, you need to split routes into feature-based
    modules. A common pattern for structuring page content is to have a parent component
    that renders the dynamic parts as the URL changes. Then, you learned how to handle
    the dynamic parts of URL segments and query strings. You also learned how to build
    links throughout your application using the `<Link>` element.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding routing in React applications lays the groundwork for building
    complex applications with efficient navigation, preparing you for the subsequent
    chapters that delve into performance optimization, state management, and integrating
    external APIs, ensuring a seamless user experience.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll learn how to split your code into smaller chunks
    using lazy components.
  prefs: []
  type: TYPE_NORMAL
