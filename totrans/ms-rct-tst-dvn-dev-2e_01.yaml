- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: First Steps with Test-Driven Development
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动开发的入门步骤
- en: This book is a walk-through of building React applications using a test-driven
    approach. We’ll touch on many different parts of the React experience, including
    building forms, composing interfaces, and animating elements. Perhaps more importantly,
    we’ll do that all while learning a whole range of testing techniques.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书通过测试驱动的方法一步步讲解如何构建React应用程序。我们将涉及React体验的许多不同方面，包括构建表单、组合界面和动画元素。也许更重要的是，我们将在学习一系列测试技术的同时完成这些任务。
- en: 'You might have already used a React testing library such as React Testing Library
    or Enzyme, but this book doesn’t use them. Instead, we’ll be working from *first
    principles*: building up our own set of test functions based directly on our needs.
    That way, we can focus on the key ingredients that make up all great test suites.
    These ingredients—ideas such as super-small tests, test doubles, and factory methods—are
    decades old and apply across all modern programming languages and runtime environments.
    That’s why this book doesn’t use a testing library; there’s really no need. What
    you’ll learn will be useful to you no matter which testing libraries you use.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经使用过React测试库，如React Testing Library或Enzyme，但这本书不使用它们。相反，我们将从*基本原则*开始：根据我们的需求直接构建我们自己的测试函数集。这样，我们可以专注于构成所有优秀测试套件的关键成分。这些成分——如超级小测试、测试替身和工厂方法等想法——已有几十年历史，并适用于所有现代编程语言和运行时环境。这就是为什么这本书不使用测试库；实际上并没有必要。你将学到的知识无论你使用哪个测试库都将对你有用。
- en: On the other hand, **Test-Driven Development** (**TDD**) is an effective technique
    for learning new frameworks and libraries. That makes this a very well-suited
    book for React and its ecosystem. This book will allow you to explore React in
    a way that you may not have experienced before as well as to make use of React
    Router and Redux and build out a GraphQL interface.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，**测试驱动开发**（**TDD**）是一种学习新框架和库的有效技术。这使得这本书非常适合React及其生态系统。这本书将让你以你可能从未体验过的方式探索React，并利用React
    Router和Redux构建GraphQL接口。
- en: 'If you’re new to the TDD process, you might find it a bit heavy-handed. It
    is a meticulous and disciplined style of developing software. You’ll wonder why
    we’re going to such Herculean efforts to build an application. For those that
    master it, there is tremendous value to be gained in specifying our software in
    this way, as follows:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刚开始接触TDD流程，你可能会觉得它有点过于严格。这是一种细致和有纪律的软件开发风格。你会 wonder 为什么我们要付出如此巨大的努力来构建一个应用程序。对于那些掌握它的人来说，以这种方式指定我们的软件将获得巨大的价值，如下所示：
- en: By being crystal clear about our product specifications, we gain the ability
    to adapt our code without fear of change.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过对产品规格的清晰描述，我们获得了在不担心变化的情况下调整代码的能力。
- en: We gain automated regression testing by default.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们默认获得自动回归测试。
- en: Our tests act as comments for our code, and those comments are verifiable when
    we run them.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的测试充当了我们代码的注释，而这些注释在我们运行它们时是可验证的。
- en: We gain a method of communicating our decision-making process with our colleagues.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们获得了一种与同事沟通我们的决策过程的方法。
- en: You’ll soon start recognizing the higher level of trust and confidence you have
    in the code you’re working on. If you’re anything like us, you’ll get hooked on
    that feeling and find it hard to work without it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你很快就会开始认识到你对正在工作的代码所拥有的更高层次的信任和信心。如果你和我们一样，你可能会对这种感觉上瘾，并发现没有它很难工作。
- en: '*Parts 1* and *2* of this book involve building an appointment system for a
    hair salon – nothing too revolutionary, but as sample applications go, it offers
    plenty of scope. We’ll get started with that in this chapter. *Parts 3* and *4*
    use an entirely different application: a logo interpreter. Building that offers
    a fun way to explore more of the React landscape.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的第一部分和第二部分涉及为美发沙龙构建预约系统——没有什么太过革命性的，但作为示例应用程序来说，它提供了足够的范围。我们将在本章中开始这个项目。第三部分和第四部分使用一个完全不同的应用程序：一个标志解释器。构建它为探索React生态系统提供了有趣的方式。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Creating a new React project from scratch
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从头开始创建新的React项目
- en: Displaying data with your first test
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用你的第一个测试显示数据
- en: Refactoring your work
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构你的工作
- en: Writing great tests
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写优秀的测试
- en: By the end of the chapter, you’ll have a good idea of what the TDD process looks
    like when building out a simple React component. You’ll see how to write a test,
    how to make it pass, and how to refactor your work.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将很好地了解在构建简单的 React 组件时 TDD 流程的样子。您将看到如何编写测试、如何使其通过以及如何重构您的工作。
- en: Technical requirements
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Later in this chapter, you’ll be required to install **Node Package Manager**
    (**npm**) together with a whole host of packages. You’ll want to ensure you have
    a machine capable of running the Node.js environment.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，您将需要安装 **Node 包管理器**（**npm**）以及一系列的包。您需要确保您的机器能够运行 Node.js 环境。
- en: You’ll also need access to a terminal.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要访问终端。
- en: In addition, you should choose a good editor or **Integrated Development Environment**
    (**IDE**) to work with your code.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还应该选择一个好的编辑器或 **集成开发环境**（**IDE**）来与您的代码一起工作。
- en: 'The code files for this chapter can be found at the following link: [https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter01](https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter01).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在以下链接中找到：[https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter01](https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter01).
- en: Creating a new React project from scratch
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从零开始创建新的 React 项目
- en: In this section, we’ll assemble all of the necessary pieces that you’ll need
    to write a React application with TDD.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将组装您编写 TDD React 应用程序所需的所有必要组件。
- en: You may have come across the `create-react-app` package, which many people use
    to create an initial React project, but we won’t be using that. The very first
    TDD principle you’re going to learn is `create-react-app` package adds a whole
    bunch of boilerplate that isn’t relevant to what we’re doing here—things such
    as a `favicon.ico` file, a sample logo, and CSS files. While these are undoubtedly
    useful, the basic idea behind YAGNI is that if it doesn’t meet a needed specification,
    then it doesn’t go in.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经遇到了 `create-react-app` 包，许多人用它来创建初始的 React 项目，但我们将不会使用它。您将要学习的第一个 TDD 原则是
    `create-react-app` 包添加了大量与我们所做无关的样板代码——例如 `favicon.ico` 文件、示例标志和 CSS 文件。虽然这些无疑是有用的，但
    YAGNI 的基本思想是，如果它不符合所需的规范，那么它就不会被包含在内。
- en: The thinking behind YAGNI is that anything unnecessary is simply *technical
    debt* – it’s stuff that’s just sitting there, unused, getting in your way.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: YAGNI 的思考方式是，任何不必要的都是简单的 *技术债务* —— 它们只是在那里闲置，未使用，阻碍了您。
- en: Once you see how easy it is to start a React project from scratch, you won’t
    ever use `create-react-app` again!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您看到从零开始启动 React 项目是多么容易，您就再也不会使用 `create-react-app` 了！
- en: In the following subsections, we’ll install NPM, Jest, React, and Babel.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下小节中，我们将安装 NPM、Jest、React 和 Babel。
- en: Installing npm
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 npm
- en: Following the TDD process means running tests frequently—*very* frequently.
    Tests are run on the command line using the `npm test` command. So, let’s start
    by getting npm installed.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循 TDD 流程意味着频繁地运行测试——*非常* 频繁。测试是通过命令行使用 `npm test` 命令运行的。所以，让我们先安装 npm。
- en: 'You can find out if you already have it installed on your machine by opening
    a terminal window (or Command Prompt if you’re on Windows) and typing the following
    command:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过打开终端窗口（如果您使用的是 Windows，则为命令提示符）并输入以下命令来检查您是否已经安装了它：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If the command isn’t found, head on over to the Node.js website at [https://nodejs.org](https://nodejs.org)
    for installation instructions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令找不到，请访问 Node.js 网站 [https://nodejs.org](https://nodejs.org) 以获取安装说明。
- en: 'If you’ve already got npm installed, we recommend you ensure you’re on the
    latest version. You can do this on the command line by typing the following command:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经安装了 npm，我们建议您确保您使用的是最新版本。您可以在命令行中通过输入以下命令来完成此操作：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now you’re all set. You can use the `npm` command to create your project.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经准备好了。您可以使用 `npm` 命令来创建您的项目。
- en: Creating a new Jest project
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建新的 Jest 项目
- en: 'Now that With npm installed, we can create our project by performing the following
    steps:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经安装了 npm，我们可以通过以下步骤创建我们的项目：
- en: If you’re following along with the book’s Git repository, open a terminal and
    navigate to the repository directory that you’ve cloned. Otherwise, simply navigate
    to where you normally store your work projects.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您正在跟随本书的 Git 仓库，请打开终端并导航到您已克隆的仓库目录。否则，只需导航到您通常存储工作项目的位置。
- en: Create a new directory using `mkdir appointments` and then set it as your current
    directory, using `cd appointments`.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `mkdir appointments` 创建一个新的目录，然后使用 `cd appointments` 将其设置为当前目录。
- en: Enter the `npm init` command. This initializes a new npm project by generating
    a template `package.json` file. You’ll be prompted to enter some information about
    your project, but you can just accept all of the defaults *except* for the `test
    command` question, for which you should type in `jest`. This will enable you to
    run tests by using the `npm test` shortcut command.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `npm init` 命令。这将通过生成模板 `package.json` 文件来初始化一个新的 npm 项目。您将被提示输入有关项目的一些信息，但您只需接受所有默认设置
    *除了* `test command` 问题，对于这个问题，您应该输入 `jest`。这将使您能够通过使用 `npm test` 快捷命令来运行测试。
- en: Editing the package.json file by hand
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 手动编辑 package.json 文件
- en: 'Don’t worry if you miss the prompt for the test command while you work through
    the instructions; you can set it afterwards by adding `"test": "jest"` to the
    `scripts` section of the generated `package.json` file.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '在按照说明操作时，如果错过了测试命令的提示，不要担心；您可以在之后通过将 `"test": "jest"` 添加到生成的 `package.json`
    文件的 `scripts` 部分来设置它。'
- en: 'Now go ahead and install Jest using `npm install --save-dev jest`. NPM will
    then download and install everything. Once completed, you should see a message
    like the following:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在继续使用 `npm install --save-dev jest` 安装 Jest。NPM 将然后下载并安装所有内容。完成后，您应该会看到如下消息：
- en: '[PRE2]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Alternatives to Jest
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 的替代方案
- en: The TDD practices you’ll study in this book will work for a wide variety of
    test runners, not just Jest. An example is the Mocha test runner. If you’re interested
    in using Mocha with this book, take a look at the guidance at [https://reacttdd.com/migrating-from-jest-to-mocha](https://reacttdd.com/migrating-from-jest-to-mocha).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将向您介绍的一些 TDD 实践将适用于各种测试运行器，而不仅仅是 Jest。一个例子是 Mocha 测试运行器。如果您对使用 Mocha 与本书结合感兴趣，请查看
    [https://reacttdd.com/migrating-from-jest-to-mocha](https://reacttdd.com/migrating-from-jest-to-mocha)
    的指南。
- en: Commit early and often
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提交早且频繁
- en: Although we’ve just started, it’s time to commit what you’ve done. The TDD process
    offers natural stopping points to commit – each time you see a new test pass,
    you can commit. This way, your repository will fill up with lots of tiny commits.
    You might not be used to that—you may be more of a “one commit per day” person.
    This is a great opportunity to try something new!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们刚刚开始，但现在是时候提交您所做的工作了。TDD 流程提供了自然的提交停止点——每次您看到一个新的测试通过时，您就可以提交。这样，您的仓库将充满许多小提交。您可能不习惯这样做——您可能更倾向于“每天一个提交”。这是一个尝试新事物的绝佳机会！
- en: Committing *early and often* simplifies commit messages. If you have just one
    test in a commit, then you can use the test description as your commit message.
    No thinking is required. Plus, having a detailed commit history helps you backtrack
    if you change your mind about a particular implementation.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 提交 *早且频繁* 可以简化提交信息。如果您在一个提交中只有一个测试，那么您可以使用测试描述作为您的提交信息。无需思考。此外，详细的提交历史记录有助于您在改变主意时回溯。
- en: So, get used to typing `git commit` when you’ve got a passing test.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当您有一个通过测试时，要习惯于输入 `git commit`。
- en: As you approach the end of a feature’s development, you can use `git rebase`
    to squash your commits so that your Git history is kept tidy.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当您接近一个功能开发的尾声时，您可以使用 `git rebase` 来压缩您的提交，这样您的 Git 历史记录就会保持整洁。
- en: 'Assuming you’re using Git to keep track of your work, go ahead and enter the
    following commands to `commit` what you’ve done so far:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在使用 Git 来跟踪您的工作，请继续输入以下命令以 `commit` 您到目前为止所做的工作：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You’ve now “banked” that change and you can safely put it out of your mind and
    move on to the following two dependencies, which are React and Babel.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经“存入”了那个更改，您可以安全地将它放在一边，继续处理接下来的两个依赖项，即 React 和 Babel。
- en: Bringing in React and Babel
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入 React 和 Babel
- en: 'Let’s install React. That’s two packages that can be installed with this next
    command:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们安装 React。这是两个可以使用此命令安装的包：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, we need Babel, which transpiles a few different things for us: React’s
    **JavaScript Syntax Extension (JSX)** templating syntax, module mocks (which we’ll
    meet in [*Chapter 7*](B18423_07.xhtml#_idTextAnchor125), *Testing useEffect and
    Mocking Components*), and various draft ECMAScript constructs that we’ll use.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要 Babel，它为我们转换了一些不同的事物：React 的 **JavaScript 语法扩展 (JSX**) 模板语法、模块模拟（我们将在
    [*第 7 章*](B18423_07.xhtml#_idTextAnchor125)，*测试 useEffect 和模拟组件*）以及我们将使用的各种草案
    ECMAScript 构造。
- en: Important note
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The following information is accurate for Babel 7\. If you’re using a later
    version, you may need to adjust the installation instructions accordingly.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下信息适用于Babel 7。如果您使用的是后续版本，您可能需要相应地调整安装说明。
- en: 'Now, Jest already includes Babel—for the aforementioned module mocks—so we
    just need to install presets and plugins as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Jest已经包含了Babel——用于上述模块模拟——所以我们只需要按照以下方式安装预设和插件：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: A Babel preset is a set of plugins. Each plugin enables a specific feature of
    the ECMAScript standards or a preprocessor such as JSX.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Babel预设是一组插件。每个插件都启用ECMAScript标准或预处理器（如JSX）的特定功能。
- en: Configuring Babel
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 配置Babel
- en: The `env` preset should usually be configured with target execution environments.
    It’s not necessary for the purposes of this book. See the *Further reading* section
    at the end of this chapter for more information.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`env`预设应该配置为目标执行环境。对于本书的目的来说，这不是必要的。有关更多信息，请参阅本章末尾的*进一步阅读*部分。
- en: 'We need to enable the packages we’ve just installed. Create a new file, `.babelrc`,
    and add the following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要启用我们刚刚安装的包。创建一个新的文件，`.babelrc`，并添加以下代码：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Both Babel and React are now ready for use.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Babel和React都准备好了可以使用。
- en: Tip
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: You may wish to commit your source code to Git at this point.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，您可能希望将源代码提交到Git。
- en: In this section, you’ve installed NPM, primed your new Git repository, and you’ve
    installed the package dependencies you’ll need to build your React app with TDD.
    You’re all set to write some tests.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您已安装NPM，初始化了新的Git仓库，并安装了构建React应用程序所需的包依赖项。您已经准备好编写一些测试了。
- en: Displaying data with your first test
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在您的第一个测试中显示数据
- en: Now we’ll use the**TDD cycle**for the first time, which you’ll learn about as
    we go through each step of the cycle.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将第一次使用**TDD周期**，您将在我们通过周期每个步骤的过程中了解它。
- en: 'We’ll start our application by building out an appointment view, which shows
    the details of an appointment. It’s a React component called `Appointment` that
    will be passed in a data structure that represents an appointment at the hair
    salon. We can imagine it looks a little something like the following example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始构建一个预约视图，以显示预约的详细信息。这是一个名为`Appointment`的React组件，它将传递一个表示美发沙龙预约的数据结构。我们可以想象它看起来有点像以下示例：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We won’t manage to get all of this information displayed by the time we complete
    the chapter; in fact, we’ll only display the customer’s `firstName`, and we’ll
    make use of the `startsAt` timestamp to order a list of today’s appointments.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法在完成本章之前显示所有这些信息；事实上，我们只会显示客户的`firstName`，并使用`startsAt`时间戳来排序今天的预约列表。
- en: In the following few subsections, you’ll write your first Jest test and go through
    all of the necessary steps to make it pass.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个小节中，您将编写第一个Jest测试，并完成所有必要的步骤使其通过。
- en: Writing a failing test
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写失败的测试
- en: 'What exactly *is* a test? To answer that, let’s write one. Perform the following
    steps:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 测试究竟*是什么？为了回答这个问题，让我们写一个。执行以下步骤：
- en: 'In your project directory, type the following commands:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的项目目录中，键入以下命令：
- en: '[PRE8]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Open the `test/Appointment.test.js` file in your favorite editor or IDE and
    enter the following code:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您喜欢的编辑器或IDE中打开`test/Appointment.test.js`文件，并输入以下代码：
- en: '[PRE9]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `describe` function defines a *test suite*, which is simply a set of tests
    with a given name. The first argument is the name of the unit you are testing.
    It could be a React component, a function, or a module. The second argument is
    a function inside of which you define your tests. The purpose of the `describe`
    function is to describe how this named “thing” works—whatever the thing is.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`describe`函数定义了一个*测试套件*，它只是一个具有给定名称的测试集合。第一个参数是您正在测试的单元的名称。它可以是React组件、函数或模块。第二个参数是一个函数，在其中您定义您的测试。`describe`函数的目的是描述这个命名“事物”的工作方式——无论这个“事物”是什么。'
- en: Global Jest functions
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 全局Jest函数
- en: All of the Jest functions (such as `describe`) are already required and available
    in the global namespace when you run the `npm test` command. You don’t need to
    import anything.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行`npm test`命令时，所有的Jest函数（如`describe`）都已经作为全局命名空间中的必需和可用函数。您不需要导入任何内容。
- en: For React components, it’s good practice to give `describe` blocks the same
    name as the component itself.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于React组件，给`describe`块取与组件本身相同的名称是一个好习惯。
- en: Where should you place your tests?
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在何处放置您的测试？
- en: If you do try out the `create-react-app` template, you’ll notice that it contains
    a single unit test file, `App.test.js`, which exists in the same directory as
    the source file, `App.js`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试使用 `create-react-app` 模板，你会注意到它包含一个单独的单元测试文件，`App.test.js`，它位于源文件 `App.js`
    相同的目录中。
- en: We prefer to keep our test files separate from our application source files.
    Test files go in a directory named `test` and source files go in a directory named
    `src`. There is no real objective advantage to either approach. However, do note
    that it’s likely that you won’t have a one-to-one mapping between production and
    test files. You may choose to organize your test files differently from the way
    you organize your source files.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更喜欢将测试文件与应用程序源文件分开。测试文件放在名为 `test` 的目录中，源文件放在名为 `src` 的目录中。这两种方法实际上并没有真正的客观优势。然而，请注意，你可能不会在生产文件和测试文件之间有一个一对一的映射。你可以选择以不同于组织源文件的方式组织你的测试文件。
- en: Let’s go ahead and run this with Jest. You might think that running tests now
    is pointless, since we haven’t even written a test yet, but doing so gives us
    valuable information about what to do next. With TDD, it’s normal to run your
    test runner at every opportunity.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用 Jest 运行这个测试。你可能会认为现在运行测试是没有意义的，因为我们还没有写测试，但这样做会给我们关于下一步做什么的有价值信息。在使用 TDD
    时，在每一个机会运行测试运行器是正常的。
- en: 'On the command line, run the npm test command again. You will see this output:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行中再次运行 npm test 命令。你会看到以下输出：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: That makes sense—we haven’t written any tests yet, just a `describe` block to
    hold them. At least we don’t have any syntax errors!
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有道理的——我们还没有编写任何测试，只是写了一个 `describe` 块来存放它们。至少我们还没有任何语法错误！
- en: Tip
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'If you instead saw the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到了以下内容：
- en: '`> echo "Error: no test specified" && exit 1`'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`> echo "Error: no test specified" && exit 1`'
- en: You need to set Jest as the value for the test command in your `package.json`
    file. See *Step 3* in *Creating a new Jest project* above.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在你的 `package.json` 文件中将 Jest 设置为测试命令的值。参见上面 *创建一个新的 Jest 项目* 中的 *步骤 3*。
- en: Writing your first expectation
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写你的第一个期望
- en: 'Change your `describe` call as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的 `describe` 调用更改为以下内容：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `it` function defines a single test. The first argument is the description
    of the test and always starts with a present-tense verb so that it reads in plain
    English. The `it` in the function name refers to the noun you used to name your
    test suite (in this case, `Appointment`). In fact, if you run tests now, with
    `npm test`, the ouput (as shown below) will make good sense:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`it` 函数定义了一个单独的测试。第一个参数是测试的描述，并且总是以现在时态动词开头，以便用普通英语阅读。函数名中的 `it` 指的是你用来命名测试套件的名词（在这个例子中，是
    `Appointment`）。实际上，如果你现在运行测试，使用 `npm test`，下面的输出（如下所示）将很有意义：'
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can read the `describe` and `it` descriptions together as one sentence:
    *Appointment renders the customer first name*. You should aim for all of your
    tests to be readable in this way.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 `describe` 和 `it` 描述一起读作一个句子：*Appointment 渲染客户的首字母*。你应该努力使所有测试都能以这种方式阅读。
- en: As we add more tests, Jest will show us a little checklist of passing tests.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们添加更多的测试，Jest 将会显示一个通过测试的小清单。
- en: Jest’s test function
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 的测试函数
- en: You may have used the `test` function for Jest, which is equivalent to `it`.
    We prefer `it` because it reads better and serves as a helpful guide for how to
    succinctly describe our test.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经使用了 Jest 的 `test` 函数，它与 `it` 等效。我们更喜欢 `it`，因为它读起来更好，并作为如何简洁描述我们的测试的有用指南。
- en: You may have also seen people start their test descriptions with “*should…*”.
    I don’t really see the point in this, it’s just an additional word we have to
    type. Better to just use a well-chosen verb to follow the “it.”
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也看到人们从 “*应该…*” 开始他们的测试描述。我并不认为这有什么意义，它只是我们不得不输入的一个额外单词。不如直接使用一个精心挑选的动词来跟随
    “it”。
- en: 'Empty tests, such as the one we just wrote, always pass. Let’s change that
    now. Add an *expectation* to our test as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 空测试，就像我们刚才写的，总是通过。现在让我们添加一个 *期望* 到我们的测试中，如下所示：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This `expect` call is an example of a fluent API. Like the test description,
    it reads like plain English. You can read it like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `expect` 调用是一个流畅 API 的例子。像测试描述一样，它读起来像普通英语。你可以这样读：
- en: '*I expect* `document.body.textContent` `toContain` *the string* `Ashley`.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*我期望* `document.body.textContent` `包含` *字符串* `Ashley`。'
- en: Each expectation has an `Ashley` and the received value is whatever is stored
    in `document.body.textContent`. In other words, the expectation passes if `document.body.textContent`
    has the word `Ashley` anywhere within it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 每个期望都有一个 `Ashley`，接收到的值是存储在 `document.body.textContent` 中的任何内容。换句话说，如果 `document.body.textContent`
    中包含 `Ashley` 这个词，则期望通过。
- en: The `toContain` function is called a `matcher` and there are a whole lot of
    different matchers that work in different ways. You can (and should) write your
    own matchers. You’ll discover how to do that in [*Chapter 3*](B18423_03.xhtml#_idTextAnchor053),
    *Refactoring the Test Suite*. Building matchers that are specific to your own
    project is an essential part of writing clear, concise tests.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`toContain` 函数被称为 `matcher`，有许多不同的 `matcher` 以不同的方式工作。你可以（并且应该）编写自己的 `matcher`。你将在
    [*第 3 章*](B18423_03.xhtml#_idTextAnchor053)，*重构测试套件* 中发现如何做到这一点。为你的项目编写特定的 `matcher`
    是编写清晰、简洁测试的重要部分。'
- en: Before we run this test, spend a minute thinking about the code. You might have
    guessed that the test will fail. The question is, how will it fail?
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行这个测试之前，花一分钟时间思考一下代码。你可能已经猜到测试会失败。问题是，它会以什么方式失败？
- en: 'Run the `npm test` command and find out:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `npm test` 命令并找出：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We have our first failure!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遇到了第一个失败！
- en: It’s probably not the failure you were expecting. Turns out, we still have some
    setup to take care of. Jest helpfully tells us what it thinks we need, and it’s
    correct; we need to specify a test environment of `jsdom`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能不是你预期的失败。结果证明，我们还有一些设置要处理。Jest 有助于告诉我们它认为我们需要什么，它是正确的；我们需要指定一个 `jsdom` 测试环境。
- en: A `jsdom` test environment, it instantiates a new `JSDOM` object and sets global
    and document objects, turning Node.js into a browser-like environment.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `jsdom` 测试环境，它实例化一个新的 `JSDOM` 对象并设置全局和文档对象，将 Node.js 转换成了一个类似浏览器的环境。
- en: '**jsdom** is a package that contains a headless implementation of the **Document
    Object Model (DOM)** that runs on Node.js. In effect, it turns Node.js into a
    browser-like environment that responds to the usual DOM APIs, such as the document
    API we’re trying to access in this test.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**jsdom** 是一个包含在 Node.js 上运行的、无头实现 **文档对象模型 (DOM)** 的包。实际上，它将 Node.js 转换成了一个类似浏览器的环境，该环境响应通常的
    DOM API，例如我们在这次测试中试图访问的文档 API。'
- en: Jest provides a pre-packaged `jsdom` test environment that will ensure our tests
    run with these DOM APIs ready to go. We just need to install it and instruct Jest
    to use it.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 提供了一个预包装的 `jsdom` 测试环境，这将确保我们的测试在具有这些 DOM API 准备好的情况下运行。我们只需要安装它并指导 Jest
    使用它。
- en: 'Run the following command at your command prompt:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的命令提示符中运行以下命令：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now we need to open `package.json` and add the following section at the bottom:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要打开 `package.json` 并在底部添加以下部分：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then we run `npm test` again, giving the following output:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们再次运行 `npm test`，得到以下输出：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'There are four parts to the test output that are relevant to us:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 测试输出中有四个部分对我们来说是相关的：
- en: The name of the failing test
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 失败测试的名称
- en: The expected answer
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预期的答案
- en: The actual answer
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际的答案
- en: The location in the source where the error occurred
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误发生的源代码位置
- en: 'All of these help us to pinpoint why our tests failed: `document.body.textContent`
    is empty. That’s not surprising given we haven’t written any React code yet.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都有助于我们确定测试失败的原因：`document.body.textContent` 是空的。鉴于我们还没有编写任何 React 代码，这并不奇怪。
- en: Rendering React components from within a test
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在测试中从内部渲染 React 组件
- en: In order to make this test pass, we’ll have to write some code above the expectation
    that will call into our production code.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让这个测试通过，我们将在期望之上编写一些代码，这些代码将调用我们的生产代码。
- en: Let’s work backward from that expectation. We know we want to build a React
    component to render this text (that’s the `Appointment` component we specified
    earlier). If we imagine we already have that component defined, how would we get
    React to render it from within our test?
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从那个期望开始逆向工作。我们知道我们想要构建一个 React 组件来渲染这个文本（这就是我们之前指定的 `Appointment` 组件）。如果我们想象我们已经定义了那个组件，我们将如何让
    React 在我们的测试中从内部渲染它？
- en: 'We simply do the same thing we’d do at the entry point of our own app. We render
    our root component like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是做我们自己在应用程序入口点会做的事情。我们以这种方式渲染我们的根组件：
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding function replaces the DOM `container` element with a new element
    that is constructed by React by rendering our React `component`, which in our
    case will be called `Appointment`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数用 React 渲染我们的 `component` 构造的新元素替换 DOM `container` 元素，在我们的例子中，这个 `component`
    将被称为 `Appointment`。
- en: The createRoot function
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: createRoot 函数
- en: The `createRoot` function is new in React 18\. Chaining it with the call to
    `render` will suffice for most of our tests, but in [*Chapter 7*](B18423_07.xhtml#_idTextAnchor125)*,
    Testing useEffect and Mocking Components*, you’ll adjust this a little to support
    re-rendering in a single test.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`createRoot` 函数是 React 18 中的新功能。将其与 `render` 的调用链式调用对于大多数测试来说就足够了，但在 [*第 7
    章*](B18423_07.xhtml#_idTextAnchor125)*，测试 useEffect 和组件模拟*，你将对其进行一些调整以支持单个测试中的重新渲染。'
- en: 'In order to call this in our test, we’ll need to define both `component` and
    `container`. The test will then have the following shape:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的测试中调用它，我们需要定义 `component` 和 `container`。然后测试将具有以下形状：
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The value of `component` is easy; it will be an instance of `Appointment`,
    the component under test. We specified that as taking a customer as a prop, so
    let’s write out what that might look like now. Here’s a JSX fragment that takes
    `customer` as a prop:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`component` 的值很容易确定；它将是一个 `Appointment` 的实例，即我们要测试的组件。我们指定它接受一个客户作为属性，所以现在让我们写出它可能的样子。这是一个接受
    `customer` 作为属性的 JSX 片段：'
- en: '[PRE20]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you’ve never done any TDD before, this might seem a little strange. Why are
    we writing test code for a component we haven’t yet built? Well, that’s partly
    the point of TDD – we let the test drive our design. At the beginning of this
    section, we formulated a verbal specification of what our `Appointment` component
    was going to do. Now, we have a concrete, written specification that can be automatically
    verified by running the test.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前从未做过任何 TDD，这可能会显得有些奇怪。为什么我们要为尚未构建的组件编写测试代码？嗯，这部分的目的是 TDD 的一个要点——我们让测试驱动我们的设计。在本节的开始，我们提出了关于
    `Appointment` 组件将要做什么的口头规范。现在，我们有一个具体的、书面的规范，可以通过运行测试自动验证。
- en: Simplifying test data
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 简化测试数据
- en: Back when we were considering our design, we came up with a whole object format
    for our appointments. You might think the definition of a customer here is very
    sparse, as it only contains a first name, but we don’t need anything else for
    a test about customer names.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们考虑设计的时候，我们为我们的预约制定了一个完整的对象格式。你可能会认为这里客户的定义非常稀疏，因为它只包含一个名字，但我们不需要其他任何东西来进行关于客户名字的测试。
- en: 'We’ve figured out `component`. Now, what about `container`? We can use the
    DOM to create a `container` element, like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定了 `component`。那么，关于 `container` 呢？我们可以使用 DOM 创建一个 `container` 元素，如下所示：
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The call to `document.createElement` gives us a new HTML element that we’ll
    use as our rendering root. However, we also need to attach it to the current document
    body. That’s because certain DOM events will only register if our elements are
    part of the document tree. So, we also need to use the following line of code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`document.createElement` 的调用给我们提供了一个新的 HTML 元素，我们将用它作为我们的渲染根。然而，我们还需要将其附加到当前文档的
    body 上。这是因为某些 DOM 事件只有在我们的元素是文档树的一部分时才会注册。因此，我们还需要使用以下代码行：'
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now our expectation should pick up whatever we render because it’s rendered
    as part of `document.body`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的期望应该能够捕获我们渲染的任何内容，因为它被渲染为 `document.body` 的一部分。
- en: Warning
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: We won’t be using `appendChild` for long; later in the chapter, we’ll be switching
    it out for something more appropriate. We would not recommend using `appendChild`
    in your own test suites for reasons that will become clear!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会长时间使用 `appendChild`；在本章的后面部分，我们将用更合适的东西替换它。我们不推荐在自己的测试套件中使用 `appendChild`，原因将在后面变得清楚！
- en: 'Let’s put it all together:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把所有这些放在一起：
- en: 'Change your test in `test/Appointments.test.js` as follows:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `test/Appointments.test.js` 中的测试更改如下：
- en: '[PRE23]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As we’re using both the `ReactDOM` namespace and JSX, we’ll need to include
    the two standard React imports at the top of our test file for this to work, as
    shown below:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们同时使用 `ReactDOM` 命名空间和 JSX，我们需要在测试文件的顶部包含这两个标准的 React 导入，以便它能够正常工作，如下所示：
- en: '[PRE24]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Go ahead and run the test; it’ll fail. Within the output, you’ll see the following
    code:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好吧，运行测试；它会失败。在输出中，你会看到以下代码：
- en: '[PRE25]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is subtly different from the test failure we saw earlier. This is a runtime
    exception, not an expectation failure. Thankfully, though, the exception is telling
    us exactly what we need to do, just as a test expectation would. It’s finally
    time to build `Appointment`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前看到的测试失败略有不同。这是一个运行时异常，而不是期望失败。幸运的是，这个异常告诉我们确切需要做什么，就像测试期望一样。现在是时候构建 `Appointment`
    了。
- en: Make it pass
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让它通过
- en: 'We’re now ready to make the failing test pass. Perform the following steps:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好让失败的测试通过。执行以下步骤：
- en: 'Add a new `import` statement to `test/Appointment.test.js`, below the two React
    imports, as follows:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `test/Appointment.test.js` 中，在两个 React 导入下方添加一个新的 `import` 语句，如下所示：
- en: '[PRE26]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Run tests with `npm test`. You’ll get a different error this time, with the
    key message being this:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `npm test` 运行测试。这次您会得到一个不同的错误，关键信息如下：
- en: '[PRE27]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Default exports
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 默认导出
- en: Although `Appointment` was defined as an export, it wasn’t defined as a *default*
    export. That means we have to import it using the curly brace form of import (`import
    { ... }`). We tend to avoid using default exports as doing so keeps the name of
    our component and its usage in sync. If we change the name of a component, then
    every place where it’s imported will break until we change those, too. This isn’t
    the case with default exports. Once your names are out of sync, it’s harder to
    track where components are used—you can’t simply use text search to find them.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `Appointment` 被定义为导出，但它没有被定义为**默认**导出。这意味着我们必须使用花括号形式的导入（`import { ... }`）来导入它。我们倾向于避免使用默认导出，因为这样做可以保持组件名称及其使用的一致性。如果我们更改组件的名称，那么所有导入它的地方都会中断，直到我们也更改它们。默认导出不是这种情况。一旦您的名称不一致，跟踪组件的使用就变得更加困难——您不能简单地使用文本搜索来找到它们。
- en: 'Let’s create that module. Type the following code in your command prompt:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建那个模块。在您的命令提示符中输入以下代码：
- en: '[PRE28]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In your editor, add the following content to `src/Appointment.js`:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的编辑器中，将以下内容添加到 `src/Appointment.js` 文件中：
- en: '[PRE29]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Why have we created a shell of `Appointment` without actually creating an implementation?
    This might seem pointless, but another core principle of TDD is *always do the
    simplest thing to pass the test*. We could rephrase this as *always do the simplest
    thing to fix the error you’re working on*.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们创建了一个没有实际创建实现的 `Appointment` 壳？这看起来可能有些无意义，但 TDD 的另一个核心原则是**总是做最简单的事情来通过测试**。我们可以将这句话重新表述为**总是做最简单的事情来修复你正在工作的错误**。
- en: Remember when we mentioned that we listen carefully to what the test runner
    tells us? In this case, the test runner said `Cannot` `find module Appointment`,
    so what was needed was to create that module, which we’ve done, and then immediately
    stopped. Before we do anything else, we need to run our tests to learn what’s
    the next thing to do.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们提到我们仔细倾听测试运行器告诉我们的话吗？在这种情况下，测试运行器说“无法”找到模块 `Appointment`，所以需要创建那个模块，我们已经创建了，然后立即停止。在我们做任何其他事情之前，我们需要运行我们的测试，以了解下一步要做什么。
- en: 'Running `npm test` again, you should get this test failure:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行 `npm test`，你应该得到以下测试失败：
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To fix the test, let’s change the `Appointment` definition as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复测试，让我们将 `Appointment` 定义更改为以下内容：
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You might be thinking, *“That’s not a component! There’s no JSX.”* Correct.
    *“And it doesn’t even use the customer prop!”* Also correct. But React will render
    it anyway, and theoretically, it should make the test pass; so, in practice, it’s
    a good enough implementation, at least for now.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能正在想，“那不是一个组件！没有 JSX。” 正确。 “而且它甚至没有使用 customer 属性！” 也正确。但 React 仍然会渲染它，理论上，它应该使测试通过；所以，在实践中，这至少是一个足够好的实现，至少目前是这样。
- en: We always write the minimum amount of code that makes a test pass.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是编写最少的代码，以确保测试通过。
- en: 'But does it pass? Run `npm test` again and take a look at the output:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 但它是否通过了？再次运行 `npm test` 并查看输出：
- en: '[PRE32]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: No, it does not pass. This is a bit of a headscratcher. We *did* define a valid
    React component. And we did tell React to render it in our container. What’s going
    on?
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 不，它没有通过。这有点令人困惑。我们**确实**定义了一个有效的 React 组件。我们也告诉 React 在我们的容器中渲染它。发生了什么？
- en: Making use of the act test helper
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用 act 测试助手
- en: 'In a React testing situation like this, often the answer has something to do
    with the async nature of the runtime environment. Starting in React 18, the render
    function is **asynchronous**: the function call will return before React has modified
    the DOM. Therefore, the expectation will run *before* the DOM is modified.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种类似 React 测试的情况下，答案通常与运行时环境的异步特性有关。从 React 18 开始，渲染函数是**异步的**：函数调用会在 React
    修改 DOM 之前返回。因此，期望会在 DOM 修改之前运行。
- en: 'React provides a helper function for our tests that pauses until asynchronous
    rendering has completed. It’s called `act` and you simply need to wrap it around
    any React API calls. To use `act`, perform the following steps:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: React 为我们的测试提供了一个辅助函数，该函数会在异步渲染完成后暂停。它被称为 `act`，您只需将其包装在任意的 React API 调用周围。要使用
    `act`，请执行以下步骤：
- en: 'Go to the top of `test/Appointment.test.js` and add the following line of code:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 `test/Appointment.test.js` 的顶部并添加以下代码行：
- en: '[PRE33]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, change the line with the `render` call to read as follows:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将包含 `render` 调用的行更改为以下内容：
- en: '[PRE34]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now rerun your test and you should see a passing test, but with an odd warning
    printed above it, like this:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在再次运行您的测试，您应该会看到一个通过测试，但上面会打印出一个奇怪的警告，如下所示：
- en: '[PRE35]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: React would like us to be explicit in our use of `act`. That’s because there
    are use cases where `act` does not make sense—but for unit testing, we almost
    certainly want to use it.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: React希望我们在使用`act`时明确。这是因为有一些情况下`act`是没有意义的——但对于单元测试，我们几乎肯定想要使用它。
- en: Understanding the act function
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 理解`act`函数
- en: Although we’re using it here, the `act` function is not required for testing
    React. For a detailed discussion on this function and how it can be used, head
    to [https://reacttdd.com/understanding-act](https://reacttdd.com/understanding-act).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在这里使用它，但`act`函数对于测试React不是必需的。关于此函数的详细讨论以及如何使用它，请访问[https://reacttdd.com/understanding-act](https://reacttdd.com/understanding-act)。
- en: 'Let’s go ahead and enable the `act` function. Open `package.json` and modify
    your `jest` property to read as follows:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续启用`act`函数。打开`package.json`并修改您的`jest`属性，使其如下所示：
- en: '[PRE36]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now run your test again with `npm test`, giving the output shown:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在再次运行您的测试，使用`npm test`，您应该会看到如下的输出：
- en: '[PRE37]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '*Finally*, you have a passing test, with no warnings!'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*最后*，您的测试通过了，没有任何警告！'
- en: In the following section, you will discover how to remove the hardcoded string
    value that you’ve introduced by adding a second test.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将了解到如何移除通过添加第二个测试而引入的硬编码字符串值。
- en: Triangulating to remove hardcoding
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过三角定位移除硬编码
- en: Now that we’ve got past that little hurdle, let’s think again about the problems
    with our test. We did a bunch of strange acrobatics just to get this test passing.
    One odd thing was the use of a hardcoded value of `Ashley` in the React component,
    even though we’d gone to the trouble of defining a customer prop in our test and
    passing it in.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经克服了这个小障碍，让我们再次思考测试中的问题。我们做了一系列奇怪的杂技动作，只是为了让这个测试通过。其中一件奇怪的事情是在React组件中使用硬编码的`Ashley`值，尽管我们已经费尽心思在我们的测试中定义了一个客户属性并将其传递进去。
- en: We did that because we want to stick to our rule of only doing the simplest
    thing that will make a test pass. In order to get to the real implementation,
    we need to add more tests.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做是因为我们想要坚持我们的规则，只做能让测试通过的最简单的事情。为了到达真正的实现，我们需要添加更多的测试。
- en: This process is called **triangulation**. We add more tests to build more of
    a *real* implementation. The more specific our tests get, the more general our
    production code needs to get.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程被称为**三角定位**。我们添加更多的测试来构建更真实的实现。我们的测试越具体，我们的生产代码就需要越泛化。
- en: Ping pong programming
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 乒乓编程
- en: This is one reason why pair programming using TDD can be so enjoyable. Pairs
    can play *ping pong*. Sometimes, your pair will write a test that you can solve
    trivially, perhaps by hardcoding, and then you force them to do the hard work
    of both tests by triangulating. They need to remove the hardcoding and add the
    generalization.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么使用TDD进行结对编程可以如此有趣的原因之一。结对可以玩*乒乓*。有时，你的搭档会写一个你可以轻易解决的测试，可能通过硬编码，然后你通过三角定位强迫他们做两个测试的艰难工作。他们需要移除硬编码并添加泛化。
- en: 'Let’s triangulate by performing the following steps:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤进行三角定位：
- en: 'Make a copy of your first test, pasting it just under the first test, and change
    the test description and the name of `Ashley` to `Jordan`, as follows:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的第一个测试复制一份，粘贴在第一个测试的下面，并更改测试描述以及`Ashley`的名字为`Jordan`，如下所示：
- en: '[PRE38]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Run tests with `npm test`. We expect this test to fail, and it does. But examine
    the code carefully. Is this what you expected to see? Take a look at the value
    of `Received string` in the following code:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm test`运行测试。我们预计这个测试会失败，并且它确实失败了。但仔细检查代码。这是您期望看到的吗？看看以下代码中的`Received string`的值：
- en: '[PRE39]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The document body has the text `AshleyAshley`. This kind of repeated text is
    an indicator that our tests are not *independent* of one another. The component
    has been rendered twice, once for each test. That’s correct, but the document
    isn’t being cleared between each test run.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 文档体中包含文本`AshleyAshley`。这种重复的文本是表明我们的测试不是彼此*独立*的。组件被渲染了两次，一次对应每个测试。这是正确的，但文档在每次测试运行之间并没有被清除。
- en: This is a problem. When it comes to unit testing, we want all tests to be independent
    of one other. If they aren’t, the output of one test could affect the functionality
    of a subsequent test. A test might pass because of the actions of a previous rest,
    resulting in a false positive. And even if the test did fail, having an unknown
    initial state means you’ll spend time figuring out if it was the initial state
    of the test that caused the issue, rather than the test scenario itself.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个问题。当涉及到单元测试时，我们希望所有测试都是相互独立的。如果它们不是，一个测试的输出可能会影响后续测试的功能。一个测试可能因为上一个测试的动作而通过，导致假阳性。即使测试确实失败了，由于初始状态未知，你将花费时间来确定问题是由于测试的初始状态引起的，而不是测试场景本身。
- en: We need to change course and fix this before we get ourselves into trouble.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要改变方向并修复这个问题，以免我们陷入麻烦。
- en: Test independence
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 测试独立性
- en: Unit tests should be independent of one another. The simplest way to achieve
    this is to not have any shared state between tests. Each test should only use
    variables that it has created itself.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试应该相互独立。实现这一点的最简单方法是在测试之间不共享任何状态。每个测试应该只使用它自己创建的变量。
- en: Backtracking on ourselves
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 退回原点
- en: 'We know that the `document`. This is the single global `document` object that
    is given to us by the `jsdom` environment, which is consistent with how a normal
    web browser operates: there’s a single `document` object. But unfortunately, our
    two tests use `appendChild` to add into that single document that’s shared between
    them. They don’t each get their own separate instance.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道`document`。这是由`jsdom`环境提供的单个全局`document`对象，这与正常网页浏览器的操作方式一致：有一个单一的`document`对象。但不幸的是，我们的两个测试使用`appendChild`将内容添加到它们之间共享的单个文档中。它们各自没有得到自己的单独实例。
- en: 'A simple solution is to replace `appendChild` with `replaceChildren`, like
    this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的解决方案是将`appendChild`替换为`replaceChildren`，如下所示：
- en: '[PRE40]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This will clear out everything from `document.body` before doing the append.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在执行追加之前清除`document.body`中的所有内容。
- en: But there’s a problem. We’re in the middle of a *red* test. We should never
    refactor, rework, or otherwise change course while we’re red.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 但存在问题。我们正在进行一个**红色**测试。在我们处于红色状态时，我们绝不应该重构、重做或以其他方式改变方向。
- en: Admittedly, this is all highly contrived—we could have used `replaceChildren`
    right from the start. But not only are we proving the need for `replaceChildren`,
    we are also about to discover an important technique for dealing with just this
    kind of scenario.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这全部都是高度人为的——我们本可以从一开始就使用`replaceChildren`。但我们不仅证明了`replaceChildren`的必要性，我们还将发现处理这类场景的重要技术。
- en: 'What we’ll have to do is *skip* this test we’re working on, fix the previous
    test, then re-enable the skipped test. Let’s do that now by performing the following
    steps:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须跳过这个正在工作的测试，修复之前的测试，然后重新启用跳过的测试。现在让我们通过执行以下步骤来完成：
- en: 'In the first test you’ve just written, change `it` to `it.skip`. Do that now
    for the second test as follows:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你刚刚编写的第一个测试中，将`it`更改为`it.skip`。现在按照以下方式对第二个测试做同样的操作：
- en: '[PRE41]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Run tests. You’ll see that Jest ignores the second test and the first one still
    passes, as follows:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试。你会看到Jest忽略了第二个测试，而第一个测试仍然通过，如下所示：
- en: '[PRE42]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the first test, change `appendChild` to `replaceChildren` as follows:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一个测试中，按照以下方式将`appendChild`更改为`replaceChildren`：
- en: '[PRE43]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Rerun the tests with `npm test`. It should still be passing.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm test`重新运行测试。它应该仍然通过。
- en: It’s time to bring the skipped test back in by removing `.skip` from the function
    name.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候通过从函数名中移除`.skip`来将跳过的测试重新引入了。
- en: 'Perform the same update in this test as in the first: change `appendChild`
    to `replaceChildren`, like this:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个测试中执行与第一个测试相同的更新：将`appendChild`更改为`replaceChildren`，如下所示：
- en: '[PRE44]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Running tests now should give us the error that we were originally expecting.
    No more repeated text content, as you can see:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行测试应该会给我们原本预期的错误。不再有重复的文本内容，如下所示：
- en: '[PRE45]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To make the test pass, we need to introduce the prop and use it within our
    component. Change the definition of `Appointment` to look as follows, destructuring
    the function arguments to pull out the customer prop:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使测试通过，我们需要引入属性并在我们的组件中使用它。将`Appointment`的定义更改为如下，解构函数参数以提取客户属性：
- en: '[PRE46]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Run tests. We expect this test to now pass:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试。我们预计这个测试现在会通过：
- en: '[PRE47]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Great work! We’re done with our passing test, and we’ve successfully triangulated
    to remove hardcoding.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！我们的通过测试已经完成，并且我们已经成功定位并移除了硬编码。
- en: In this section, you’ve written two tests and, in the process of doing so, you’ve
    discovered and overcome some of the challenges we face when writing automated
    tests for React components.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你编写了两个测试，在这个过程中，你发现了并克服了我们编写 React 组件自动化测试时面临的一些挑战。
- en: Now that we’ve got our tests working, we can take a closer look at the code
    we’ve written.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经让测试工作正常，我们可以更仔细地查看我们编写的代码。
- en: Refactoring your work
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构你的工作
- en: Now that you’ve got a green test, it’s time to refactor your work. Refactoring
    is the process of adjusting your code’s structure without changing its functionality.
    It’s crucial for keeping a code base in a fit, maintainable state.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经得到了一个绿色的测试，是时候重构你的工作了。重构是调整代码结构而不改变其功能的过程。这对于保持代码库处于良好、可维护的状态至关重要。
- en: Sadly, the refactoring step is the step that always gets forgotten. The impulse
    is to rush straight into the next feature. We can’t stress how important it is
    to take time to simply stop and *stare* at your code and think about ways to improve
    it. Practicing your refactoring skills is a sure-fire way to level up as a developer.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，重构步骤总是被遗忘的步骤。冲动是直接进入下一个功能。我们无法强调花时间简单地停下来 *凝视* 代码并思考改进方法的重要性。练习你的重构技能是成为开发者提升水平的一个可靠方法。
- en: The adage “more haste; less speed” applies to coding just as it does in life.
    If you make a habit of skipping the refactoring phase, your code quality will
    likely deteriorate over time, making it harder to work with and therefore slower
    to build new features.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 俗语“欲速则不达”在编程中就像在生活中一样适用。如果你养成了跳过重构阶段的习惯，你的代码质量可能会随着时间的推移而下降，这使得它更难工作，因此构建新功能的速度会变慢。
- en: The TDD cycle helps you build good personal discipline and habits, such as consistently
    refactoring. It might take more effort upfront, but you will reap the rewards
    of a code base that remains maintainable as it ages.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: TDD 循环帮助你建立良好的个人纪律和习惯，例如持续重构。这可能需要前期更多的努力，但你会收获一个随着时间推移仍然可维护的代码库的回报。
- en: Don’t Repeat Yourself
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 不要重复自己
- en: Test code needs as much care and attention as production code. The number one
    principle you’ll be relying on when refactoring your tests is **Don’t Repeat Yourself**
    (**DRY**). *Drying up tests* is a phrase all TDDers repeat often.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代码需要与生产代码一样多的关注和照顾。当你重构测试时，你将依赖的第一大原则是**不要重复自己**（**DRY**）。“干燥测试”是所有 TDD 实践者经常重复的一个短语。
- en: The key point is that you want your tests to be as concise as possible. When
    you see repeated code that exists in multiple tests, it’s a great indication that
    you can pull that repeated code out. There are a few different ways to do that,
    and we’ll cover just a couple in this chapter.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 关键点是你希望你的测试尽可能简洁。当你看到存在于多个测试中的重复代码时，这是一个很好的迹象，表明你可以将这段重复代码提取出来。有几种不同的方法可以做到这一点，我们将在本章中介绍其中的一些。
- en: You will see further techniques for drying up tests in [*Chapter 3*](B18423_03.xhtml#_idTextAnchor053)*,
    Refactoring the Test Suite*.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在 [*第 3 章*](B18423_03.xhtml#_idTextAnchor053)“重构测试套件”中看到进一步干燥测试的技术。
- en: Sharing setup code between tests
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在测试之间共享设置代码
- en: When tests contain identical setup instructions, we can promote those instructions
    into a shared `beforeEach` block. The code in this block is executed before each
    test.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试包含相同的设置说明时，我们可以将这些说明提升为共享的 `beforeEach` 块。此块中的代码在每个测试之前执行。
- en: 'Both of our tests use the same two variables: `container` and `customer`. The
    first one of these, `container`, is initialized identically in each test. That
    makes it a good candidate for a `beforeEach` block.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的两个测试都使用了相同的两个变量：`container` 和 `customer`。其中第一个，`container`，在每个测试中都是相同初始化的。这使得它成为
    `beforeEach` 块的良好候选者。
- en: 'Perform the following steps to introduce your first `beforeEach` block:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以引入你的第一个 `beforeEach` 块：
- en: 'Since `container` needs to be accessed in the `beforeEach` block and each of
    the tests, we must declare it in the outer `describe` scope. And since we’ll be
    setting its value in the `beforeEach` block, that also means we’ll need to use
    `let` instead of `const`. Just above the first test, add the following line of
    code:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于 `container` 需要在 `beforeEach` 块和每个测试中访问，我们必须在外部的 `describe` 范围内声明它。由于我们将在
    `beforeEach` 块中设置其值，这也意味着我们需要使用 `let` 而不是 `const`。在第一个测试上方添加以下代码行：
- en: '[PRE48]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Below that declaration, add the following code:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下声明下方添加以下代码：
- en: '[PRE49]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Delete the corresponding two lines from each of your two tests. Note that since
    we defined `container` in the scope of the `describe` block, the value set in
    the `beforeEach` block will be available to your test when it executes.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从你的两个测试中各自删除相应的两行。注意，由于我们在 `describe` 块的作用域中定义了 `container`，因此在 `beforeEach`
    块中设置的值将在测试执行时对测试可用。
- en: Use of let instead of const
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 let 而不是 const
- en: Be careful when you use `let` definitions within the `describe` scope. These
    variables are not cleared by default between each test execution, and that shared
    state will affect the outcome of each test. A good rule of thumb is that any variable
    you declare in the `describe` scope should be assigned to a new value in a corresponding
    `beforeEach` block, or in the first part of each test, just as we’ve done here.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 `describe` 范围内使用 `let` 定义时，要小心。这些变量在每次测试执行之间默认不会被清除，并且共享的状态将影响每个测试的结果。一个很好的经验法则是，你应在
    `describe` 范围内声明的任何变量都应在相应的 `beforeEach` 块中分配新值，或者在每个测试的第一部分，就像我们在这里所做的那样。
- en: For a more detailed look at the use of `let` in test suites, head to [https://reacttdd.com/use-of-let](https://reacttdd.com/use-of-let).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 要更详细地了解在测试套件中使用 `let` 的方法，请访问 [https://reacttdd.com/use-of-let](https://reacttdd.com/use-of-let)。
- en: In [*Chapter 3*](B18423_03.xhtml#_idTextAnchor053)*, Refactoring the Test Suite*,
    we’ll look at a method for sharing this setup code between multiple test suites.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](B18423_03.xhtml#_idTextAnchor053)*，重构测试套件*中，我们将探讨一种在多个测试套件之间共享此设置代码的方法。
- en: Extracting methods
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提取方法
- en: The call to `render` is the same in both tests. It’s also quite lengthy given
    that it’s wrapped in a call to `act`. It makes sense to extract this entire operation
    and give it a more meaningful name.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 两个测试中的 `render` 调用相同。考虑到它被 `act` 调用所包裹，它的长度也相当长。因此，提取整个操作并给它一个更有意义的名称是有意义的。
- en: 'Rather than pull it out as is, we can create a new function that takes the
    `Appointment` component as its parameter. The explanation for why this is useful
    will come after, but now let’s perform the following steps:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是直接提取出来，我们可以创建一个新的函数，该函数将 `Appointment` 组件作为其参数。为什么这样做有用的解释将在之后给出，但现在让我们执行以下步骤：
- en: 'Above the first test, write the following definition. Note that it still needs
    to be within the `describe` block because it uses the `container` variable:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一个测试上方写下以下定义。注意，它仍然需要位于 `describe` 块内，因为它使用了 `container` 变量：
- en: '[PRE50]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, replace the call to `render` in each test with the following line of code:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将每个测试中的 `render` 调用替换为以下代码行：
- en: '[PRE51]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In the preceding step, we *inlined* the JSX, passing it directly into `render`.
    That means you can now delete the line starting with `const component`. For example,
    your first test should end up looking as follows:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的步骤中，我们*内联*了 JSX，直接将其传递给 `render`。这意味着你现在可以删除以 `const component` 开头的行。例如，你的第一个测试应该看起来像以下示例：
- en: '[PRE52]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Rerun your tests and verify that they are still passing.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行你的测试并验证它们是否仍然通过。
- en: Highlighting differences within your tests
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的测试中突出差异
- en: The parts of a test that you want to highlight are the parts that differ between
    tests. Usually, some code remains the same (such as `container` and the steps
    needed to render a component) and some code differs (`customer` in this example).
    Do your best to hide away whatever is the same and highlight what differs. That
    way, it makes it obvious what a test is specifically testing.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要突出的测试部分是不同测试之间的差异部分。通常，一些代码保持不变（例如 `container` 和渲染组件所需的步骤），而一些代码则不同（例如本例中的
    `customer`）。尽你所能隐藏相同的部分，突出不同的部分。这样，就可以清楚地知道测试具体在测试什么。
- en: This section has covered a couple of simple ways of refactoring your code. As
    the book progresses, we’ll look at many different ways that both production source
    code and test code can be refactored.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了几种重构代码的简单方法。随着本书的进展，我们将探讨许多不同的方法，这些方法可以重构生产源代码和测试代码。
- en: Writing great tests
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写优秀的测试
- en: Now that you’ve written a couple of tests, let’s step away from the keyboard
    and discuss what you’ve seen so far.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经编写了一些测试，让我们暂时离开键盘，讨论一下你迄今为止所看到的内容。
- en: 'Your first test looks like the following example:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 你的第一个测试看起来像以下示例：
- en: '[PRE53]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This is concise and clearly readable.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这份文档简洁且易于阅读。
- en: 'A *good* test has the following three distinct sections:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*好的*测试有三个明显的部分：
- en: '**Arrange**: Sets up test dependencies'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安排**：设置测试依赖项'
- en: '**Act**: Executes production code under test'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行操作**：在测试中执行生产代码'
- en: '**Assert**: Checks that expectations are met'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断言**：检查期望是否得到满足'
- en: This is so well understood that it is called the **Arrange, Act, Assert (AAA)**
    pattern, and all of the tests in this book follow this pattern.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点理解得如此透彻，以至于被称为**安排、行动、断言（AAA）**模式，本书中的所有测试都遵循此模式。
- en: 'A *great* test is not just good but is also the following:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**优秀的**测试不仅很好，而且还有以下特点：
- en: Short
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简短
- en: Descriptive
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述性
- en: Independent of other tests
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他测试独立
- en: Has no side effects
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有副作用
- en: In the remainder of this section, we’ll discuss the TDD cycle, which you’ve
    already used, and also how to set up your development environment for easy TDD.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的剩余部分，我们将讨论你已使用的TDD周期，以及如何设置你的开发环境以方便进行TDD。
- en: Red, green, refactor
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 红色、绿色、重构
- en: TDD, at its heart, is the red, green, refactor cycle that we’ve just seen.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: TDD的核心是我们在前面看到的红色、绿色、重构周期。
- en: '![Figure 1.1 – The TDD cycle ](img/Figure_1.01_B18423.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1 – TDD周期](img/Figure_1.01_B18423.jpg)'
- en: Figure 1.1 – The TDD cycle
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 – TDD周期
- en: 'The steps of the TDD cycle are:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: TDD周期的步骤是：
- en: '**Write a failing test**: Write a short test that describes some functionality
    you want. Execute your test and watch it fail. If it doesn’t fail, then it’s an
    unnecessary test; delete it and write another.'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编写失败的测试**：编写一个简短的测试来描述你想要的功能。执行你的测试并观察它失败。如果它没有失败，那么它是一个不必要的测试；删除它并编写另一个。'
- en: '**Make it pass**: Make the test green by writing the simplest production code
    that will work. Don’t worry about finding a neat code structure; you can tidy
    it up later.'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使其通过**：通过编写最简单的能工作的生产代码来使测试通过。不用担心寻找整洁的代码结构；你可以稍后整理它。'
- en: '**Refactor your code**: Stop, slow down, and resist the urge to move on to
    the next feature. Work hard to make your code—both production and test code—as
    clean as it can be.'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**重构你的代码**：停下来，放慢速度，抵制继续进行下一个功能的冲动。努力使你的代码——无论是生产代码还是测试代码——尽可能干净。'
- en: That’s all there is to it. You’ve already seen this cycle in action in the preceding
    two sections, and we’ll continue to use it throughout the rest of the book.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是全部内容。你已经在前面两个部分中看到了这个周期的实际应用，我们将在本书的其余部分继续使用它。
- en: Streamlining your testing process
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简化你的测试过程
- en: 'Think about the effort you’ve put into this book so far. What actions have
    you been doing the most? They are the following:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 想想你到目前为止在这本书上投入的努力。你做了哪些最多的动作？它们如下：
- en: Switching between `src/Appointment.js` and `test/Appointment.test.js`
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`src/Appointment.js`和`test/Appointment.test.js`之间切换
- en: Running `npm test` and analyzing the output
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行`npm test`并分析输出
- en: Make sure you can perform these actions quickly.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你可以快速执行这些操作。
- en: For a start, you should use split-screen functionality in your editor. If you
    aren’t already, take this opportunity to learn how to do it. Load your production
    module on one side and the corresponding unit test file on the other.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你应该在你的编辑器中使用分屏功能。如果你还没有这样做，利用这个机会学习如何操作。在一侧加载你的生产模块，在另一侧加载相应的单元测试文件。
- en: 'Here’s a picture of our setup; we use `nvim` and `tmux`:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们设置的一个图片；我们使用`nvim`和`tmux`：
- en: '![Figure 1.2 – A typical TDD setup running tmux and vim in a terminal ](img/Figure_1.02_B18423.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![图1.2 – 在终端中运行tmux和vim的典型TDD设置](img/Figure_1.02_B18423.jpg)'
- en: Figure 1.2 – A typical TDD setup running tmux and vim in a terminal
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 – 在终端中运行tmux和vim的典型TDD设置
- en: You can see that we also have a little test window at the bottom for showing
    test output.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们还在底部有一个小测试窗口来显示测试输出。
- en: Jest can also watch your files and auto-run tests when they change. To enable
    this, change the `test` command in `package.json` to `jest --watchAll`. This reruns
    all of your tests when it detects any changes.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: Jest也可以监视你的文件，并在它们更改时自动运行测试。要启用此功能，将`package.json`中的`test`命令更改为`jest --watchAll`。这将在检测到任何更改时重新运行所有测试。
- en: Watching files for changes
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 监视文件变化
- en: Jest’s watch mode has an option to run only the tests in files that have changed,
    but since your React app will be composed of many different files, each of which
    are interconnected, it’s better to run everything as breakages can happen in many
    modules.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: Jest的监视模式有一个选项，可以只运行已更改文件中的测试，但由于你的React应用将由许多不同的文件组成，每个文件都相互关联，因此最好运行所有内容，因为许多模块可能会出现故障。
- en: Summary
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Tests act like a safety harness in our learning; we can build little blocks
    of understanding, building on top of each other, up and up to ever-greater heights,
    without fear of falling.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 测试就像我们学习中的安全带；我们可以在理解的基础上构建小块知识，层层叠加，不断向上，无需担心跌落。
- en: In this chapter, you’ve learned a *lot* about the TDD experience.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经学到了很多关于TDD体验的知识。
- en: To begin with, you set up a React project from scratch, pulling in only the
    dependencies you need to get things running. You’ve written two tests using Jest’s
    `describe`, `it`, and `beforeEach` functions. You discovered the `act` helper,
    which ensures all React rendering has been completed before your test expectations
    execute.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你从头开始设置一个React项目，只引入运行所需的最小依赖。你已经使用Jest的`describe`、`it`和`beforeEach`函数编写了两个测试。你发现了`act`辅助函数，它确保在测试期望执行之前，所有的React渲染都已经完成。
- en: You’ve also seen plenty of testing ideas. Most importantly, you’ve practiced
    TDD’s red-green-refactor cycle. You’ve also used triangulation and you learned
    about the **Arrange, Act, Assert** pattern.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 你还看到了很多测试想法。最重要的是，你已经练习了TDD的“红-绿-重构”循环。你还使用了三角测量法，并学习了**安排、执行、断言**模式。
- en: 'And we threw in a couple of design principles for good measure: DRY and YAGNI.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还加入了一些设计原则，以供参考：DRY（不要重复自己）和YAGNI（你不需要它，直到你需要它）。
- en: While this is a great start, the journey has only just begun. In the following
    chapter, we’ll test drive a more complex component.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个很好的开始，但旅程才刚刚开始。在接下来的章节中，我们将测试一个更复杂的组件。
- en: Further reading
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Take a look at the Babel web page to discover how to correctly configure the
    Babel `env` preset. This is important for real-world applications, but we skipped
    over it in this chapter. You can find it at the following link:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 查看Babel网页，了解如何正确配置Babel的`env`预设。这对于实际应用非常重要，但我们在这章中跳过了它。你可以通过以下链接找到它：
- en: '[https://babeljs.io/docs/en/babel-preset-env](https://babeljs.io/docs/en/babel-preset-env).'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://babeljs.io/docs/en/babel-preset-env](https://babeljs.io/docs/en/babel-preset-env)。'
- en: 'React’s `act` function was introduced in React 17 and has seen updates in React
    18\. It is deceptively complex. See this blog post for some more discussion on
    how this function is used at the following link: [https://reacttdd.com/understanding-act](https://reacttdd.com/understanding-act).'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: React的`act`函数是在React 17中引入的，并在React 18中进行了更新。它表面上看似复杂。有关此函数如何使用的更多讨论，请参阅以下链接中的博客文章：[https://reacttdd.com/understanding-act](https://reacttdd.com/understanding-act)。
- en: 'This book doesn’t make much use of Jest’s `watch` functionality. In recent
    versions of Jest, this has seen some interesting updates, such as the ability
    to choose which files to watch. If you find rerunning tests a struggle, you might
    want to try it out. You can find more information at the following link: [https://jestjs.io/docs/en/cli#watch](https://jestjs.io/docs/en/cli#watch).'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书并没有充分利用Jest的`watch`功能。在Jest的最近版本中，这个功能进行了一些有趣的更新，例如可以选择要监视的文件。如果你发现重新运行测试很困难，你可能想尝试一下。更多信息请参阅以下链接：[https://jestjs.io/docs/en/cli#watch](https://jestjs.io/docs/en/cli#watch)。
