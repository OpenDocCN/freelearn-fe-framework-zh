- en: Explaining Pipes and Communicating with RESTful Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we covered some very powerful features of the framework.
    However, we can go even deeper into the functionality of Angular''s forms module
    and router. In this chapter, we''ll explain how we can perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Developing model-driven forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining parameterized routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining child routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the HTTP module for communication with RESTful APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transforming data with custom pipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will explore all these concepts in the process of extending the functionality
    of the "Coders repository" application. At the beginning of the preceding chapter,
    we mentioned that we will allow the import of developers from GitHub. However,
    before we implement this feature, let's extend the functionality of the form.
  prefs: []
  type: TYPE_NORMAL
- en: Developing model-driven forms in Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These will be the last steps for finishing "Coders repository". You can build
    on top of the code available at `ch7/step-1/` (or `ch7/step-2`, depending on your
    previous work), in order to extend the functionality of the application with the
    new concepts we will cover. The complete example is located at `ch8/multi-page-model-driven`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the result that we will achieve by the end of this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5bbecb65-7340-4363-a5df-54c6c66615c7.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding screenshot, there are two forms:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A form that has the following controls:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The text input for the GitHub handle
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A checkbox that points out whether we want to import the developer from GitHub
    or enter them manually
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A form for entering new users manually
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second form looks exactly the way we left it in the previous chapter. However,
    this time, its definition looks a little bit different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note that this time, we don't have the `submit` handler or the `#f="ngForm"`
    attribute. Instead, we bind the `[formGroup]` input to the `addDevForm` property,
    which is defined inside the component's controller. Using this input, we can bind
    to something called `FormGroup`. As its name states, the `FormGroup` class consists
    of a list of controls grouped together with the sets of validation rules associated
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to use a similar declaration in the form used for importing a developer.
    However, this time, we will provide a different value of the `[formGroup]` property,
    as we will define a different form group in the component''s controller. Place
    the following snippet above the form we introduced earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s declare the `importDevForm` and `addDevForm` properties in the
    component''s controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Initially, we import the `FormGroup` class from the `@angular/forms` module,
    and later, declare the required properties in the controller. Notice that we have
    one additional parameter of `constructor` of `AddDeveloper` called `fb` of the
    `FormBuilder` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `FormBuilder` type provides a programmable API for the definition of `FormGroup`
    where we can attach validation behavior to each control in the group. Let''s use
    the `FormBuilder` instance for the initialization of the `importDevForm` and `addDevForm`
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `FormBuilder` instance has a method called `group` that allows us to define
    controls and set their properties, such as their default values and validators.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the previous snippet, `importDevForm` has two fields: `githubHandle`
    and `fetchFromGitHub`. We declare that the default value of the `githubHandle`
    control is the empty string and its value is required, and set the default value
    of the `fetchFromGitHub` control to `false`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second form, `addDevForm`, we declare four controls. For the `realName`
    control, as the default value, we set the empty string, and use `Validators.requred`
    in order to introduce validation behavior (which is exactly what we did for the
    `githubHandle` control). As a validator for the email input, we will use the `validateEmail`
    function and set the control''s initial value to the empty string. The `validateEmail`
    function is the one we defined in the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The last two controls we define here are the `technology` control, which has
    a required value validator and has an empty string as its initial value, and the
    `popular` control, with its initial value set to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Using composition of control validators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We took a look at how we can apply a single validator to form controls. Using
    the model-driven approach, we applied the `Validators.required` validator in a
    way equivalent to what we did in the previous chapter, where we used template-driven
    forms and added the `required` attribute. However, in some applications, the domain
    may require a more complex validation logic. For example, if we want to apply
    both the required and the `validateEmail` validators to the email control, we
    should do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `compose` method of the `Validators` object accepts an array of validators
    as an argument and returns a new validator. The new validator's behavior will
    be a composition of the logic defined in the individual validators passed as an
    argument, and they will be applied in the same order as they were introduced in
    the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The property names in the object literal passed to the `group` method, of `FormBuilder`,
    should match with the values that we set to the `formControlName` attributes of
    the inputs in the template. This is the complete template of `importDevForm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding template, we can see that, once the `submitted` flag has the
    `true` value, the form will be hidden from the user. Next to the first input element,
    we will set the value of the `formControlName` attribute to `githubHandle`. The
    `formControlName` attribute associates an existing form input in the template
    with one declared in the `FormGroup` class, corresponding to the form element
    where HTML input resides. This means that the key associated with the controls
    definition inside the object literal, which we pass to the `group` method of `FormBuilder`,
    must match with the name of the corresponding control in the template, set with
    `formControlName`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we want to implement the following behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: When the Fetch from GitHub checkbox is checked, `disable` the form for entering
    a new developer and enable the form for importing a developer from GitHub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the current active (or enabled) form is invalid, `disable` the `submit`
    button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll explore how we can achieve this functionality using Angular's reactive
    forms (also known as model-driven forms) API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `AddDeveloper` class, add the following methods definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Notice that in `ngOnInit`, we invoke the `toggleControls` method with the current
    value of the `fetchFromGitHub` checkbox. We can get reference to `AbstractControl`,
    which represents the checkbox, by getting the `fetchFromGitHub` property of `controls`
    within `importDevForm`.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we subscribe to the `valueChange` event of the checkbox by passing
    a callback to its `subscribe` method. Each time the value of the checkbox is changed,
    the callback we've passed to `subscribe` will be invoked.
  prefs: []
  type: TYPE_NORMAL
- en: Later, in `ngOnDestroy`, we unsubscribe from the `valueChange` subscription
    in order to prevent our code from memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the most interesting thing happens in `toggleControls`. To this method,
    we pass a flag that indicates whether we want `importDevForm` to be enabled or
    not. If we want the form to be enabled, all we need to do is to invoke the `enable`
    method of the `githubHandle` control and `disable` all the `controls` in `addDevForm`.
    We can `disable` all the `controls` in `addDevForm` by iterating over the control
    names (that is, the keys of the `controls` property of `addDevForm`), getting
    the corresponding control instance for each individual name, and invoking its
    `disable` method. In case the `importEnabled` flag has the `false` value, we do
    the exact opposite, by invoking the `enable` method of the `controls` from `addDevForm`
    and the `disable` method of the control from `importDevForm`.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the HTTP module of Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, after we have developed both forms—for importing existing developers and
    adding new developers, it is time to implement the logic behind them in the controller
    of the component.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this purpose, we will need to communicate with the GitHub API. Although
    we can do this directly from the component''s controller, by approaching the problem
    this way, we would couple the view with the RESTful API of GitHub. In order to
    enforce better separation of concerns, we can extract the logic for communication
    with GitHub into a separate service called `GitHubGateway`. Open the file called
    `github_gateway.ts`, and enter the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Initially, we import the `HttpClient` class from the `@angular/common/http`
    module. All the HTTP-related functionalities are externalized outside the Angular's
    core.
  prefs: []
  type: TYPE_NORMAL
- en: Right after that we declare the `GitHubUser` interface. We use it in order to
    describe the expected type of the response returned from GitHub. In this case,
    we create the interface declaration manually; however, usually, such interfaces
    are generated using an API schema (such as OpenAPI, for instance), which is shared
    between the frontend and the backend.
  prefs: []
  type: TYPE_NORMAL
- en: After a dependency acceptance of `GitHubGateway`, needs to be injected through
    the DI mechanism of the framework, we will decorate the class with the `@Injectable`
    decorator.
  prefs: []
  type: TYPE_NORMAL
- en: The only functionality from the GitHub's API we use is the one for fetching
    users, so we define a single method called `getUser`. As an argument, it accepts
    the GitHub handle of the developer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that if you make more than 60 requests per day to the GitHub''s API, you
    might get this error: GitHub API Rate limit exceeded. This is due to the rate
    limits for requests without a GitHub API token. For further information, visit
    [https://github.com/blog/1509-personal-api-tokens](https://github.com/blog/1509-personal-api-tokens).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `getUser` method, we use the instance of the `HttpClient` service
    that we received in `constructor`. Notice that the `get` method of the client
    has a type parameter and returns `Observable`. The purpose of the type parameter
    is to indicate what will be the type of the response, which is wrapped inside
    of `Observable`. As the expected type, we set the `GitHubUser` interface. There
    are a few benefits of using observables instead of promises for `HttpClient`;
    for instance, consider the following benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: Observables are cancellable by design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observables can be easily retried
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can map and filter the responses received from a given request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The complete API of the `HttpClient` service can be found at [https://angular.io/api/common/http/HttpClient](https://angular.io/api/common/http/HttpClient).
  prefs: []
  type: TYPE_NORMAL
- en: Using Angular's HTTP module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s implement the logic for importing the existing developers from
    GitHub. First, we will need to import `HttpClientModule` in our `AppModule` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, open the `ch7/step-2/add_developer.ts` file and enter the following
    imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Add `GitHubGateway` to the list of providers of the `AddDeveloper` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As the next step, we have to include the following parameters in `constructor`
    of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This way, the `AddDeveloper` class instances will have a private property called
    `githubAPI`.
  prefs: []
  type: TYPE_NORMAL
- en: The only thing left is to implement the `addDeveloper` method and allow the
    user to import the existing developers using the `GitHubGateway` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the user clicks on the Add button, we will need to check whether we need
    to import an existing GitHub user or add a new developer. For this purpose, we
    can use the value of the `fetchFromGitHub` control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If it has a truthy value, then we can invoke the `getUser` method of the `githubAPI`
    property and pass the value of the `githubHandle` control as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `getUser` method of the `GitHubGateway` instance, we delegate the call
    to the `get` method of the `HttpClient` service, which returns `Observable`. In
    order to get the result that `Observable` will push, we will need to pass a callback
    to its `subscribe` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we first perform an HTTP `GET` request. After this,
    we get the corresponding `Observable` instances that, in general cases, will emit
    a series of values; in this case, only a single one—the body of the response,
    parsed to JSON. If the request fails, then we will get an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that in order to reduce the bundle size of Angular, the team at Google
    has included only the core of RxJS in the framework. In order to use the `map`
    and `catch` methods, you will need to add the following imports at `add_developer.ts`:
    `import ''rxjs/add/operator/map'';` and `import ''rxjs/add/operator/catch'';`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep in mind that RxJS version 5.5 introduced the so called *lettable operators*,
    which allows us to import operators with named imports, compared to the preceding
    example, which uses imports with side effects. This is a big step forward type
    safety. More about lettable operators can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/ReactiveX/rxjs/blob/master/doc/lettable-operators.md](https://github.com/ReactiveX/rxjs/blob/master/doc/lettable-operators.md)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s implement the body of the callback we pass to `subscribe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we set the properties of a new `Developer` instance.
    Here, we establish the mapping between the object returned from GitHub's API and
    the developer's representation in our application. We consider a developer as
    popular if they have more than `1000` followers.
  prefs: []
  type: TYPE_NORMAL
- en: The entire implementation of the `addDeveloper` method can be found at `ch8/multi-page-model-driven/add_developer.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to handle failed requests, we can use the catch method of the Observable
    instances: `this.githubAPI.getUser(model.githubHandle)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`.catch((error, source, caught) => {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`console.log(error);`'
  prefs: []
  type: TYPE_NORMAL
- en: '`return error;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`});`'
  prefs: []
  type: TYPE_NORMAL
- en: Defining parameterized views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the next step, once the user clicks on the name of any of the developers
    on the home page of the application, they should be redirected to a view with
    a detailed profile of the selected developer. The end result will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b1564a7f-12c4-4447-abaa-74ba5697e9e0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do this, we will need to pass an identifier of the developer to
    the component that shows the developer''s detailed profile. Open `app.ts`, and
    add the following import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We haven''t developed the `DeveloperDetails` component yet, so, if you run
    the application, you will get an error. We will define the component in the next
    paragraph, but before this, let''s alter the routes definition of `app.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, we add a single route with the `dev-details/:id` path and associate the
    `DeveloperDetails` component with it.
  prefs: []
  type: TYPE_NORMAL
- en: Note that in the `path` property, we declare that the route has a single parameter
    called `id` and also set the `children` property to `devDetailsRoutes`. The `devDetailsRoutes`
    children contains the nested routes, which should be rendered within `router-outlet`
    located in the `DeveloperDetails` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s pass `id` of the current developer as a parameter to the `routerLink`
    directive. Open `home.html` in your working directory and replace the table cell,
    where we display the developer''s `realName` property with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The value of the `routerLink` directive is an array with the following three
    elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''/dev-details''`: A string that shows the root route'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dev.id`: The ID of the developer whose details we want to see'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''dev-basic-info''`: The path of a route that shows which component within
    the nested route should be rendered'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining nested routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s jump to the `DeveloperDetails` definition. In your working directory,
    create a file called `developer_details.ts` and enter the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: For the sake of simplicity, in order to not introduce a complex directory/file
    structure in the examples for this book, we have a few components and route declarations
    in a single file. Keep in mind that according to best practices, the individual
    declarations should be placed into separate files. For further information, visit
    [https://angular.io/styleguide](https://angular.io/styleguide).
  prefs: []
  type: TYPE_NORMAL
- en: In the previous snippet, we define a component with controller called `DeveloperDetails`.
    Note that within the controller's `constructor` function, through the DI mechanism
    of Angular, we inject a parameter associated with the `ActivatedRoute` token.
    The injected parameter provides us with access to the parameters visible by the
    current route. In `ngOnInit`, we apply an imperative approach, where we subscribe
    changes in the value of the route's `params` property, get the first set of parameters,
    and assign the `dev` property to the result of the invocation of `this.developers.getUserById`
    with the selected developer's identifier as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that a more declarative and reactive approach would be to take advantage
    of the higher-order functions provided by RxJS, where we''d be able to get access
    to the selected developer using code similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`...`'
  prefs: []
  type: TYPE_NORMAL
- en: '`get dev$() {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`return this.route.params.map((params: any) =>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`this.developers.getUserById(parseInt(params[''id''])));`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`...`'
  prefs: []
  type: TYPE_NORMAL
- en: Later, we can bind to the result of the invocation with the Angular's async
    pipe, that we will explain later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Since the parameter we got from `routeParams.params['id']` is a string, we will
    need to parse it to a number in order to get the developer associated with the
    given route.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s define the child routes, which will be rendered in the template
    of `DeveloperDetails`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: There is nothing new for us in the preceding declarations. The route definition
    follows the exact same rules we're already familiar with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to the template of the component, let''s add links associated with the
    individual nested routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Within the template, we declare two links that are relative to the current path.
    The first one points to `dev-basic-info`, which is the path of the first route
    defined within `devDetailsRoutes`, and the second one points to `dev-details-advanced`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the implementations of the components associated with both routes are
    quite similar, let''s take a look only at `DeveloperBasicInfo`. The implementation
    of the second one can be found at `ch8/multi-page-model-driven/developer_advanced_info.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we inject the parent component using the `@Inject`
    parameter decorator. Inside `@Inject`, we use `forwardRef`, since we have a circular
    dependency between the `developer_basic_info` and `developer_details` packages
    (inside `developer_basic_info`, we import `developer_details`, and within `developer_details`,
    we import `developer_basic_info`).
  prefs: []
  type: TYPE_NORMAL
- en: We need a reference to the instance of the parent component in order to get
    the instance of the current developer that corresponds to the selected route.
    We get this reference in the `ngOnInit` life cycle hook.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming data with pipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now it is time to take a look at the last building block that Angular provides
    for the development of applications that we haven't covered in detail yet—pipes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like filters in AngularJS, pipes are intended to encapsulate all the data
    transformation logic. Let''s take a look at the template of the home page of the
    application we have just developed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, depending on the value of the `popular` property,
    we show different data using the `NgSwitch` and `NgSwitchCase` directives. Although
    this works, it is redundant.
  prefs: []
  type: TYPE_NORMAL
- en: Developing stateless pipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s develop a pipe that transforms the value of the `popular` property and
    uses it in place of `NgSwitch` and `NgSwitchCase`. The pipe will accept three
    arguments: a value that should be transformed, a string that should be displayed
    when the value is truthy, and another string that should be displayed in case
    of a falsy value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the use of an Angular custom pipe, we will be able to simplify the template
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can even use emojis, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We apply pipe to the value the same way we would do in AngularJS. The arguments
    we pass to the pipe should be separated by the colon (`:`) symbol.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to develop an Angular pipe, we will need the following imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Pipe` decorator can be used for adding metadata to the class that implements
    the data transformation logic. The `PipeTransform` interface is an interface with
    a single method, called `transform`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet is the entire implementation of `BooleanPipe`. The `name`
    type that we pass to the `@Pipe` decorator determines how we should reference
    it in templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing we need to do before being able to use `BooleanPipe` is to add
    it to the list of declarations in our `AppModule` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Using Angular's built-in pipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Angular provides the following set of built-in pipes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CurrencyPipe`: This pipe is used for formatting currency data. As an argument,
    it accepts the abbreviation of the currency type (that is, `"EUR"`, `"USD"`, and
    so on). It can be used in the following way:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`DatePipe`: This pipe is used for the transformation of dates. It can be used
    in the following way:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`DecimalPipe`: This pipe is used for transformation of decimal numbers. The
    argument it accepts is of the following format: `"{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}"`.
    It can be used in the following way:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '`JsonPipe`: This transforms a JavaScript object into a JSON string. It can
    be used in the following way:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '`LowerCasePipe`: This transforms a string to lowercase. It can be used in the
    following way:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '`UpperCasePipe`: This transforms a string to uppercase. It can be used in the
    following way:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '`PercentPipe`: This transforms a number into a percentage. It can be used in
    the following way:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '`SlicePipe`: This returns a slice of an array. The pipe accepts the start and
    the end indexes of the slice. It can be used in the following way:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '`AsyncPipe`: This is a stateful pipe that accepts an `Observable` object or
    a promise; we will take a look at it at the end of the chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing stateful pipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is one common thing among all the pipes mentioned earlier—all of them
    return exactly the same result each time we apply them to the same value and pass
    them the same set of arguments. Such pipes, which hold the referentially transparency
    property, are called **pure pipes**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@Pipe` decorator accepts an object literal of the `{ name: string, pure?:
    boolean }` type, where the default value for the `pure` property is `true`. This
    means that when we define any given pipe, we can declare whether it is stateful
    or stateless. The pure property is important because, in case the pipe doesn''t
    produce side effects and returns the same result when applied to the same set
    of arguments, the change detection can be optimized.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's build a stateful pipe. Our pipe will make an HTTP `get` request to
    a JSON API. For this purpose, we will use the `@angular/common/http` module.
  prefs: []
  type: TYPE_NORMAL
- en: Note that having business logic in a pipe is not considered as best practice.
    This type of logic should be extracted into a service. The example here is for
    learning purposes only.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the pipe needs to hold a state depending on the status of the
    request (that is, whether it is pending or completed). We will use the pipe in
    the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This way, we apply the `fetchJson` pipe over the URL. Once we have the body
    of the response, we can apply the `json` pipe over it. This example also shows
    how we can chain pipes with Angular.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to stateless pipes, for the development of stateful pipes, we have
    to decorate the class that implements the pipe''s logic with `@Pipe` and implement
    the `PipeTransform` interface. This time, because of the HTTP request functionality,
    we will also need to import the `HttpClient` class from the `@angular/common/http`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Each time it happens to apply the `fetchJson` pipe to an argument with a different
    value, we will need to make a new HTTP `get` request. This means that as the state
    of the pipe, we need to keep at least the values of the response of the remote
    service and the last URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The only piece of logic we need to implement is the `transform` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Inside of it, we initially compare the URL passed as an argument with the one
    we already have (by default, its value will be `null`). If they are different,
    we initiate a new HTTP `get` request using the local instance of the `HttpClient`
    class, which was passed to the `constructor` function. Once the request is completed,
    we set the `data` property to the result.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's suppose that the pipe has started a `get` request, and before it
    is completed, the change detection mechanism invokes the pipe again. In this case,
    we will compare the `prevUrl` property with the `url` parameter. If they are the
    same, we won't perform a new request and will immediately return the value of
    the `data` property. If `prevUrl` has a different value from `url`, we will initiate
    a new request.
  prefs: []
  type: TYPE_NORMAL
- en: Using stateful pipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s use the pipe that we developed. The application that we will implement
    provides a text input and a button with the Get Avatar label to the user. Once
    the user enters a value in the text input and clicks on the button, the avatar
    corresponding to the GitHub user will appear below the text input, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/83f87144-99c0-40e7-af79-e1cec060e9a0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s develop a sample component, which will allow us to enter the GitHub
    user''s handle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The only thing left is to show the GitHub avatar of the user. We can easily
    achieve this by altering the template of the component with the following `img`
    declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Initially, we append the GitHub handle to the base URL used for fetching users
    from the API. Later, we will apply the `fetchJson` filter over it and get the
    `avatar_url` property from the returned result.
  prefs: []
  type: TYPE_NORMAL
- en: Using Angular's AsyncPipe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Angular''s `AsyncPipe` `transform` method accepts an `Observable` object or
    a promise as an argument. Once the argument pushes a value (that is, the promise
    has been resolved or the `subscribe` callback of `Observable` is invoked), `AsyncPipe`
    will return it as a result. Let''s take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Here, we define an Angular component that has two properties, that is, `greetingPromise`
    of the `Promise<string>` type and `resolve` of the `Function` type. We initialized
    the `greetingPromise` property with a new `Promise<string>` instance, and as the
    value of the `resolve` property, we set the `resolve` callback of `promise`.
  prefs: []
  type: TYPE_NORMAL
- en: In `constructor` of the class, we start a time-out with the duration of `3000`
    ms, and inside of its callback, we resolve the promise. Once the promise is resolved,
    the value of the `{{ greetingPromise | async }}` expression will be evaluated
    to the `Foobar!` string. The end result that the user will see on the screen is
    the text, "Hello Foobar!".
  prefs: []
  type: TYPE_NORMAL
- en: The `async` pipe is extremely powerful when we combine it with `Observable`,
    which pushes a sequence of values. It automatically unsubscribes from `Observable`
    when the view it used gets destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: Using AsyncPipe with observables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re already familiar with the concept of observables from the previous chapters.
    We can say that an `Observable` object allows us to subscribe to the emission
    of a sequence of values, for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we subscribe to `Observable`, it will start emitting values each second,
    which will be printed in the console. Let''s combine this snippet with component
    definition and implement a simple timer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The only thing left in order to be able to use the `timer` component is to
    add a template declaration. We can subscribe to `Observable` directly in the template
    using the `async` pipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This way, each second we will get the new value emitted by `Observable`, and
    the `date` pipe will transform it into a readable form.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a deep dive into the Angular's forms module, by developing
    a model-driven (reactive) form, combining it with the HTTP module. We took a look
    at some advanced features of the new component-based router and saw how we can
    use and develop custom stateful and stateless pipes.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter is dedicated to how we can make our Angular applications SEO-friendly
    by taking advantage of the server-side rendering that the module Universal provides.
    Another thing that we'll take a look at is Angular CLI and other tools that make
    our experience as developers better. Finally, we'll explain what ahead-of-time
    compilation is, in the context of Angular, and why we should take advantage of
    it in our applications.
  prefs: []
  type: TYPE_NORMAL
