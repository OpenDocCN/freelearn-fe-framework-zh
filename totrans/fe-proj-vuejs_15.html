<html><head></head><body>
		<div id="_idContainer457" class="Content">
			<h1 id="_idParaDest-286"><a id="_idTextAnchor379"/>Appendix</h1>
		</div>
		<div id="_idContainer509" class="Content">
			<h1 id="_idParaDest-287"><a id="_idTextAnchor380"/>1. Starting Your First Vue Project</h1>
			<h2 id="_idParaDest-288"><a id="_idTextAnchor381"/>Activity 1.01: Building a Dynamic Shopping List App Using Vue.js</h2>
			<p><strong class="bold">Solution:</strong></p>
			<p>To access the code files for this activity, refer to <a href="https://packt.live/35Tkzau">https://packt.live/35Tkzau</a>.</p>
			<ol>
				<li>Create a new Vue project using the Vue CLI by running the <strong class="source-inline">vue create new-activity-app</strong> command. Manually select the features via the command prompts for <strong class="source-inline">dart-sass</strong>, <strong class="source-inline">babel</strong>, and <strong class="source-inline">eslint</strong>. </li>
				<li>Scaffold an input field with a placeholder, <strong class="source-inline">Press enter to add new item</strong>, which has a <strong class="source-inline">v-model</strong> bound to a data object called input and a <strong class="source-inline">ref</strong> attribute with the value of the input. Bind the <em class="italic">Enter</em> key to the <strong class="source-inline">addItem</strong> method, which will be created in the next step, by using <strong class="source-inline">@keyup.enter</strong> and referencing the <strong class="source-inline">addItem</strong> method:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div class="container"&gt;</p><p class="source-code">    &lt;h2&gt;Shopping list&lt;/h2&gt;</p><p class="source-code">    &lt;div class="user-input"&gt;</p><p class="source-code">      &lt;input</p><p class="source-code">        placeholder="Press enter to add new item"</p><p class="source-code">        v-model="input"</p><p class="source-code">        @keyup.enter="addItem"</p><p class="source-code">        ref="input"</p><p class="source-code">      /&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  data() {</p><p class="source-code">    return {</p><p class="source-code">      input: '',</p><p class="source-code">    }</p><p class="source-code">  },</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p><p class="source-code">&lt;style lang="scss"&gt;</p><p class="source-code">@import 'styles/global';</p><p class="source-code">$color-green: #4fc08d;</p><p class="source-code">$color-grey: #2c3e50;</p><p class="source-code">.container {</p><p class="source-code">  max-width: 600px;</p><p class="source-code">  margin: 80px auto;</p><p class="source-code">}</p><p class="source-code">// Type</p><p class="source-code">.h2 {</p><p class="source-code">  font-size: 21px;</p><p class="source-code">}</p><p class="source-code">.user-input {</p><p class="source-code">  display: flex;</p><p class="source-code">  align-items: center;</p><p class="source-code">  padding-bottom: 20px;</p><p class="source-code">  input {</p><p class="source-code">    width: 100%;</p><p class="source-code">    padding: 10px 6px;</p><p class="source-code">    margin-right: 10px;</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/style&gt;</p></li>
				<li>Introduce a button with a bound click event to <strong class="source-inline">addItem</strong> and include the corresponding method, <strong class="source-inline">addItem()</strong>, in the <strong class="source-inline">methods</strong> object. In the <strong class="source-inline">addItem()</strong> method, push the data prop <strong class="source-inline">input</strong> string into  <strong class="source-inline">shoppingList</strong> and add a check to ensure the <strong class="source-inline">input</strong> prop exists. Optionally, add some styling to your buttons:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div class="container"&gt;</p><p class="source-code">    &lt;h2&gt;Shopping list&lt;/h2&gt;</p><p class="source-code">    &lt;div class="user-input"&gt;</p><p class="source-code">      &lt;input</p><p class="source-code">        placeholder="Press enter to add new item"</p><p class="source-code">        v-model="input"</p><p class="source-code">        @keyup.enter="addItem"</p><p class="source-code">        ref="input"</p><p class="source-code">      /&gt;&lt;button @click="addItem"&gt;Add item&lt;/button&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  data() {</p><p class="source-code">    return {</p><p class="source-code">      input: '',</p><p class="source-code">      shoppingList: [],</p><p class="source-code">    }</p><p class="source-code">  },</p><p class="source-code">  methods: {</p><p class="source-code">    addItem() {</p><p class="source-code">      // Don't allow adding to the list if empty</p><p class="source-code">      if (!this.input) return</p><p class="source-code">      this.shoppingList.push(this.input)</p><p class="source-code">      // Clear the input after adding</p><p class="source-code">      this.input = ''</p><p class="source-code">      // Focus the input element again for quick typing!</p><p class="source-code">      this.$refs.input.focus()</p><p class="source-code">    },</p><p class="source-code">  },</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p><p class="source-code">&lt;style lang="scss"&gt;</p><p class="source-code">...</p><p class="source-code">// Buttons</p><p class="source-code">button {</p><p class="source-code">  appearance: none;</p><p class="source-code">  padding: 10px;</p><p class="source-code">  font-weight: bold;</p><p class="source-code">  border-radius: 10px;</p><p class="source-code">  border: none;</p><p class="source-code">  background: $color-grey;</p><p class="source-code">  color: white;</p><p class="source-code">  white-space: nowrap;</p><p class="source-code">  + button {</p><p class="source-code">    margin-left: 10px;</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/style&gt;</p></li>
				<li>Output the shopping list items in the DOM. When you click the <strong class="source-inline">add item</strong> button, it should be added to <strong class="source-inline">shoppingList</strong> and be displayed:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div class="container"&gt;</p><p class="source-code">    ...</p><p class="source-code">    &lt;ul v-if="shoppingList"&gt;</p><p class="source-code">      &lt;li v-for="(item, i) in shoppingList" :key="i" class="item"</p><p class="source-code">         &gt;&lt;span&gt;{{ item }}&lt;/span&gt;</p><p class="source-code">        &lt;/li&gt;</p><p class="source-code">    &lt;/ul&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;style lang="scss"&gt;</p><p class="source-code">.item {</p><p class="source-code">  display: flex;</p><p class="source-code">  align-items: center;</p><p class="source-code">}</p><p class="source-code">ul {</p><p class="source-code">  display: block;</p><p class="source-code">  margin: 0 auto;</p><p class="source-code">  padding: 30px;</p><p class="source-code">  border: 1px solid rgba(0, 0, 0, 0.25);</p><p class="source-code">  &gt; li {</p><p class="source-code">    color: $color-grey;</p><p class="source-code">    margin-bottom: 4px;</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/style&gt;</p><p>The following screenshot displays the shopping list:</p><div id="_idContainer458" class="IMG---Figure"><img src="image/B15218_01_44.jpg" alt="Figure 1.44: The shopping list should be displayed based on user input&#13;&#10;"/></div><p class="figure-caption">Figure 1.44: The shopping list should be displayed based on user input</p></li>
				<li>To match the last requirement to remove items from the list, create a new method called <strong class="source-inline">deleteItem</strong>, and allow one argument to be passed in, called <strong class="source-inline">i</strong>. If there is an argument passed into the method, filter out that array item and update the <strong class="source-inline">shoppingList</strong> prop; otherwise replace the data prop with an empty array:<p class="source-code">...</p><p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  data() {</p><p class="source-code">    return {</p><p class="source-code">      input: '',</p><p class="source-code">      shoppingList: [],</p><p class="source-code">    }</p><p class="source-code">  },</p><p class="source-code">  methods: {</p><p class="source-code">    addItem() {</p><p class="source-code">      // Don't allow adding to the list if empty</p><p class="source-code">      if (!this.input) return</p><p class="source-code">      this.shoppingList.push(this.input)</p><p class="source-code">      // Clear the input after adding</p><p class="source-code">      this.input = ''</p><p class="source-code">      // Focus the input element again for quick typing!</p><p class="source-code">      this.$refs.input.focus()</p><p class="source-code">    },</p><p class="source-code">    deleteItem(i) {</p><p class="source-code">      this.shoppingList = i</p><p class="source-code">        ? this.shoppingList.filter((item, x) =&gt; x !== i)</p><p class="source-code">        : []</p><p class="source-code">    },</p><p class="source-code">  },</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>Create a <strong class="source-inline">Delete all</strong> button element and bind it to the <strong class="source-inline">deleteItem</strong> method using the click event, <strong class="source-inline">@click</strong>:<p class="source-code">    &lt;button class="button--delete" @click="deleteItem()"&gt;      Delete all&lt;/button&gt;</p><p class="source-code">...</p><p class="source-code">&lt;style lang="scss"&gt;</p><p class="source-code">...</p><p class="source-code">.button--delete {</p><p class="source-code">  display: block;</p><p class="source-code">  margin: 0 auto;</p><p class="source-code">  background: red;</p><p class="source-code">}</p><p class="source-code">&lt;/style&gt;</p></li>
				<li>Add a <strong class="source-inline">remove</strong> button in the list loop, which will delete individual shopping list items by passing in the <strong class="source-inline">v-for</strong> prop <strong class="source-inline">i</strong>:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div class="container"&gt;</p><p class="source-code">    ...</p><p class="source-code">    &lt;ul v-if="shoppingList"&gt;</p><p class="source-code">      &lt;li v-for="(item, i) in shoppingList" :key="i" class="item"</p><p class="source-code">        &gt;&lt;span&gt;{{ item }}&lt;/span&gt;</p><p class="source-code">        &lt;button class="button--remove" </p><p class="source-code">          @click="deleteItem(i)"&gt;Remove&lt;/button&gt;</p><p class="source-code">      &lt;/li&gt;</p><p class="source-code">    &lt;/ul&gt;</p><p class="source-code">    &lt;br /&gt;</p><p class="source-code">    &lt;button class="button--delete" @click="deleteItem()"&gt;      Delete all&lt;/button&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">...</p><p class="source-code">&lt;style lang="scss"&gt;</p><p class="source-code">...</p><p class="source-code">.button--remove {</p><p class="source-code">  background: none;</p><p class="source-code">  color: red;</p><p class="source-code">  text-transform: uppercase;</p><p class="source-code">  font-size: 11px;</p><p class="source-code">  align-self: flex-end;</p><p class="source-code">}</p><p class="source-code">&lt;/style&gt;</p><p><em class="italic">Figure 1.45</em> displays the final output with all the details for the shopping list before adding the items:</p><div id="_idContainer459" class="IMG---Figure"><img src="image/B15218_01_45.jpg" alt="Figure 1.45: Final output&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 1.45: Final output</p>
			<p>The following screenshot displays the output after adding items to the shopping list:</p>
			<div>
				<div id="_idContainer460" class="IMG---Figure">
					<img src="image/B15218_01_46.jpg" alt="Figure 1.46: Final output with items added to the shopping list&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.46: Final output with items added to the shopping list</p>
			<p>In this activity, you tested your knowledge of Vue by using all the basic functions of an <strong class="bold">SFC</strong>, such as expressions, loops, two-way binding, and event handling. You built a shopping list application that could let users add and delete individual list items or clear the total list in one click using Vue methods.</p>
			<h1 id="_idParaDest-289"><a id="_idTextAnchor382"/>2. Working with Data</h1>
			<h2 id="_idParaDest-290"><a id="_idTextAnchor383"/>Activity 2.01: Creating a Blog List Using the Contentful API</h2>
			<p><strong class="bold">Solution: </strong></p>
			<p>Perform the following steps to complete the activity.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the code files for this activity, refer to <a href="https://packt.live/33ao1f5">https://packt.live/33ao1f5</a>.</p>
			<ol>
				<li value="1">Create a new Vue project using the Vue CLI <strong class="source-inline">vue create activity</strong> command and select the following presets: Babel, SCSS pre-processor (you can choose either of the pre-processor), and the prettier formatter.</li>
				<li>Add a <strong class="source-inline">contentful</strong> dependency:<p class="source-code">yarn add contentful</p></li>
				<li>In <strong class="source-inline">App.vue</strong>, remove the default content and import <strong class="source-inline">contentful</strong> into the component:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div id=»app»&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">import { createClient } from 'contentful'</p><p class="source-code">const client = createClient({</p><p class="source-code">  space: ‹hpr0uushokd4›,</p><p class="source-code">  accessToken: ‹jwEHepvQx-kMtO7_2ldjhE4WMAsiDp3t1xxBT8aDp7U›,</p><p class="source-code">})</p><p class="source-code">&lt;/script&gt;</p><p class="source-code">&lt;style lang="scss"&gt;</p><p class="source-code">#app {</p><p class="source-code">  font-family: ‹Avenir›, Helvetica, Arial, sans-serif;</p><p class="source-code">  -webkit-font-smoothing: antialiased;</p><p class="source-code">  -moz-osx-font-smoothing: grayscale;</p><p class="source-code">  text-align: center;</p><p class="source-code">  color: #2c3e50;</p><p class="source-code">  margin: 60px auto 0;</p><p class="source-code">  max-width: 800px;</p><p class="source-code">}</p><p class="source-code">&lt;/style&gt;</p></li>
				<li>Add <strong class="source-inline">async</strong> methods to <strong class="source-inline">getPeople</strong> and <strong class="source-inline">getBlogPosts</strong> on the created life cycle, and assign the response of the calls to the <strong class="source-inline">authors</strong> and <strong class="source-inline">posts</strong> data props respectively in the template:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div id=»app»&gt;</p><p class="source-code">    &lt;pre&gt;{{ authors }}&lt;/pre&gt;</p><p class="source-code">    &lt;pre&gt;{{ posts }}&lt;/pre&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">import { createClient } from 'contentful'</p><p class="source-code">const client = createClient({</p><p class="source-code">  space: ‹hpr0uushokd4›,</p><p class="source-code">  accessToken: ‹jwEHepvQx-kMtO7_2ldjhE4WMAsiDp3t1xxBT8aDp7U›,</p><p class="source-code">})</p><p class="source-code">export default {</p><p class="source-code">  name: ‹app›,</p><p class="source-code">  data() {</p><p class="source-code">    return {</p><p class="source-code">      authors: [],</p><p class="source-code">      posts: {},</p><p class="source-code">    }</p><p class="source-code">  },</p><p class="source-code">  async created() {</p><p class="source-code">    this.authors = await this.getPeople()</p><p class="source-code">    this.posts = await this.getBlogPosts()</p><p class="source-code">  },</p><p class="source-code">  methods: {</p><p class="source-code">    async getPeople() {</p><p class="source-code">      const entries = await client.getEntries({ content_type:         'person' })</p><p class="source-code">      return entries.items</p><p class="source-code">    },</p><p class="source-code">    async getBlogPosts() {</p><p class="source-code">      const entries = await client.getEntries({</p><p class="source-code">        content_type: ‹blogPost›,</p><p class="source-code">        order: ‹-fields.publishDate›,</p><p class="source-code">      })</p><p class="source-code">      return entries.items</p><p class="source-code">    },</p><p class="source-code">  },</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>Loop over articles using the <strong class="source-inline">posts</strong> object, and output <strong class="source-inline">publishDate</strong>, <strong class="source-inline">title</strong>, <strong class="source-inline">description</strong>, and <strong class="source-inline">image</strong>:<p class="source-code">   </p><p class="source-code">  &lt;div class=»articles»&gt;</p><p class="source-code">      &lt;hr /&gt;</p><p class="source-code">      &lt;h2&gt;Articles&lt;/h2&gt;</p><p class="source-code">      &lt;section v-if=»posts» class=»articles-list»&gt;</p><p class="source-code">        &lt;article v-for=»(post, i) in posts» :key=»i»&gt;</p><p class="source-code">          &lt;img</p><p class="source-code">            class=»thumbnail»</p><p class="source-code">            :src=»</p><p class="source-code">              post.fields.heroImage.fields.file.url +                 '?fit=scale&amp;w=350&amp;h=196'</p><p class="source-code">            «</p><p class="source-code">          /&gt;</p><p class="source-code">          </p><p class="source-code"> class=»article-text»&gt;</p><p class="source-code">            </p><p class="source-code">&lt;div class="date"&gt;{{</p><p class="source-code">              new Date(post.fields.publishDate).toDateString()</p><p class="source-code">            }}&lt;/div&gt;</p><p class="source-code">            &lt;h4&gt;{{ post.fields.title }}&lt;/h4&gt;</p><p class="source-code">            &lt;p&gt;{{ post.fields.description }}&lt;/p&gt;</p><p class="source-code">          &lt;/div&gt;</p><p class="source-code">        &lt;/article&gt;</p><p class="source-code">      &lt;/section&gt;</p><p class="source-code">    &lt;/div&gt;</p></li>
				<li>Add some <strong class="source-inline">scss</strong> styling to <strong class="source-inline">articles-list</strong>:<p class="source-code">.articles-list {</p><p class="source-code">  article {</p><p class="source-code">    display: flex;</p><p class="source-code">    text-align: left;</p><p class="source-code">    padding-bottom: 15px;</p><p class="source-code">    .article-text {</p><p class="source-code">      padding: 15px 0;</p><p class="source-code">    }</p><p class="source-code">    .thumbnail {</p><p class="source-code">      margin-right: 30px;</p><p class="source-code">    }</p><p class="source-code">    .date {</p><p class="source-code">      font-size: 12px;</p><p class="source-code">      font-weight: bold;</p><p class="source-code">      text-transform: uppercase;</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>Use computed props to output the author's information:<p class="source-code">&lt;template&gt;</p><p class="source-code">   ...</p><p class="source-code">    </p><p class="source-code">    &lt;div v-if=»name» class=»author»&gt;</p><p class="source-code">      &lt;h2</p><p class="source-code">        &gt;{{ name }} &lt;br /&gt;</p><p class="source-code">        &lt;small v-if=»title» &gt;{{ title }}&lt;/small&gt;&lt;/h2</p><p class="source-code">      &gt;</p><p class="source-code">      &lt;p v-if=»bio» &gt;{{ bio }}&lt;/p&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">    ...</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">...  </p><p class="source-code">computed: {</p><p class="source-code">    name() {</p><p class="source-code">      return this.authors[0] &amp;&amp; this.authors[0].fields.name</p><p class="source-code">    },</p><p class="source-code">    title() {</p><p class="source-code">      return this.authors[0] &amp;&amp; this.authors[0].fields.title</p><p class="source-code">    },</p><p class="source-code">    bio() {</p><p class="source-code">      return this.authors[0] &amp;&amp; this.authors[0].fields.shortBio</p><p class="source-code">    },</p><p class="source-code">},</p><p class="source-code">...</p><p>The following screenshot displays the author information along with a list of their blog posts:</p><div id="_idContainer461" class="IMG---Figure"><img src="image/B15218_02_16.jpg" alt="Figure 2.16: Expected outcome with Contentful blog posts&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 2.16: Expected outcome with Contentful blog posts</p>
			<p>In this activity, you built a blog that lists articles from an API source using the basic functions of a Vue SFC, using <strong class="source-inline">async</strong> methods to fetch remote data from an API, and using computed properties to organize deep nested object structures.</p>
			<h1 id="_idParaDest-291"><a id="_idTextAnchor384"/>3. Vue CLI</h1>
			<h2 id="_idParaDest-292"><a id="_idTextAnchor385"/>Activity 3.01: Building a Vue Application Using the Vue-UI and the Vuetify Component Library</h2>
			<p><strong class="bold">Solution:</strong></p>
			<p>Perform the following steps to complete the activity.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the code files for this activity, refer to <a href="https://packt.live/35WaCJG">https://packt.live/35WaCJG</a>.</p>
			<ol>
				<li value="1">Open a command line, and run <strong class="source-inline">vue create activity-app</strong>.</li>
				<li>Choose the last selection, <strong class="source-inline">Manually select features</strong>, by pressing the <em class="italic">Down arrow key</em> once and pressing <em class="italic">Enter</em>:<p class="source-code">? Please pick a preset: (Use arrow keys)</p><p class="source-code">  default (babel, eslint)</p><p class="source-code"> &gt; Manually select features</p></li>
				<li>Choose <strong class="source-inline">Babel</strong>, <strong class="source-inline">CSS Pre-processors</strong>, and <strong class="source-inline">Linter / Formatter</strong>:<p class="source-code">? Check the features needed for your project:</p><p class="source-code"> (*) Babel</p><p class="source-code"> ( ) TypeScript</p><p class="source-code"> ( ) Progressive Web App (PWA) Support</p><p class="source-code"> ( ) Router</p><p class="source-code"> ( ) Vuex</p><p class="source-code"> (*) CSS Pre-processors</p><p class="source-code">&gt;(*) Linter / Formatter</p><p class="source-code"> ( ) Unit Testing</p><p class="source-code"> ( ) E2E Testing</p></li>
				<li>Choose <strong class="source-inline">Sass/SCSS (with dart-sass)</strong>:<p class="source-code">? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default): (Use arrow keys)</p><p class="source-code">&gt; Sass/SCSS (with dart-sass)</p><p class="source-code">  Sass/SCSS (with node-sass)</p><p class="source-code">  Less</p><p class="source-code">  Stylus</p></li>
				<li>Next, we will choose <strong class="source-inline">Eslint+ Prettier</strong> to format the code as we proceed:<p class="source-code">? Pick a linter / formatter config: (Use arrow keys)</p><p class="source-code"> ESLint with error prevention only</p><p class="source-code"> ESLint + Airbnb config</p><p class="source-code"> ESLint + Standard config</p><p class="source-code">&gt; ESLint + Prettier</p></li>
				<li>We will then choose the options <strong class="source-inline">Lint on save</strong> and <strong class="source-inline">Lint and fix on commit</strong> to pick additional lint features and save them:<p class="source-code">? Pick additional lint features: (Press &lt;space&gt; to select,  &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)</p><p class="source-code"> &gt;(*) Lint on save</p><p class="source-code"> (*) Lint and fix on commit</p></li>
				<li>To place the configurations in the dedicated files, we will choose the <strong class="source-inline">In dedicated config files</strong> option:<p class="source-code">? Where do you prefer placing config for Babel, PostCSS, ESLint,  etc.? (Use arrow keys)</p><p class="source-code"> &gt; In dedicated config files</p><p class="source-code"> In package.json</p><p>Skip saving by pressing <em class="italic">Enter</em>. <strong class="source-inline">npm</strong> packages will automatically be installed. You should see the following output in your terminal: </p><p class="source-code">yarn install v1.16.0</p><p class="source-code">info No lockfile found.</p><p class="source-code"> [1/4] Resolving packages...</p></li>
				<li>After the packages are installed, run the <strong class="source-inline">yarn serve</strong> command. Next, go to your browser and navigate to <strong class="source-inline">http://localhost:8080</strong>. You should see the output as follows:<div id="_idContainer462" class="IMG---Figure"><img src="image/B15218_03_43.jpg" alt="Figure 3.43: The default Vue project screen&#13;&#10;"/></div><p class="figure-caption">Figure 3.43: The default Vue project screen</p></li>
				<li>Stop the <strong class="source-inline">serve</strong> task, and run <strong class="source-inline">vue ui</strong> in the command line.</li>
				<li>Inside the Vue-UI, go to the project selection screen (found at <strong class="source-inline">http://localhost:8000/project/select</strong>).</li>
				<li>Click on the <strong class="source-inline">Import</strong> button and navigate to the folder your newly created Vue project is stored in. The following screenshot displays what your screen should look like:<div id="_idContainer463" class="IMG---Figure"><img src="image/B15218_03_44.jpg" alt="Figure 3.44: The Vue-UI project manager&#13;&#10;"/></div><p class="figure-caption">Figure 3.44: The Vue-UI project manager</p></li>
				<li>Click on the big green <strong class="source-inline">Import this folder</strong> button.</li>
				<li>From the <strong class="source-inline">Projects</strong> dashboard, navigate to the <strong class="source-inline">Plugins</strong> tab.</li>
				<li>Click on the <strong class="source-inline">+ Add plugin</strong> button. Your screen should look like the following screenshot:<div id="_idContainer464" class="IMG---Figure"><img src="image/B15218_03_45.jpg" alt="Figure 3.45: The Vue-UI plugins manager, where you can add, remove, &#13;&#10;and modify Vue plugins&#13;&#10;"/></div><p class="figure-caption">Figure 3.45: The Vue-UI plugins manager, where you can add, remove, and modify Vue plugins</p></li>
				<li>Search for <strong class="source-inline">vuetify</strong> and install <strong class="source-inline">vue-cli-plugin-vuetify</strong>, then choose the default configuration settings, as shown in <em class="italic">Figure 3.46</em>:<div id="_idContainer465" class="IMG---Figure"><img src="image/B15218_03_46.jpg" alt="Figure 3.46: The App.vue default configuration when the Vuetify CLI is installed&#13;&#10;"/></div><p class="figure-caption">Figure 3.46: The App.vue default configuration when the Vuetify CLI is installed</p></li>
				<li>Navigate to the <strong class="source-inline">Tasks</strong> page and click on <strong class="source-inline">Start Tasks</strong>. When the app initializes, click on the <strong class="source-inline">Open App</strong> button. On the localhost URL, you should see a Vuetify styled page as follows:<div id="_idContainer466" class="IMG---Figure"><img src="image/B15218_03_47.jpg" alt="Figure 3.47: What you see in your browser when the Vuetify CLI plugin is installed&#13;&#10;"/></div><p class="figure-caption">Figure 3.47: What you see in your browser when the Vuetify CLI plugin is installed</p></li>
				<li>Click on the <strong class="source-inline">Select a layout</strong> hyperlink in your Vuetify page layout.</li>
				<li>Click on the code link for the <strong class="source-inline">Baseline</strong> theme (or any other theme that interests you) from the options shown in the following screenshot:<div id="_idContainer467" class="IMG---Figure"><img src="image/B15218_03_48.jpg" alt="Figure 3.48: The Vuetify website has multiple premade layouts available&#13;&#10;"/></div><p class="figure-caption">Figure 3.48: The Vuetify website has multiple premade layouts available</p></li>
				<li>Copy the contents of the <strong class="source-inline">baseline.vue</strong> file from the Vuetify repo and replace your <strong class="source-inline">App.vue</strong> file content with this content. Your <strong class="source-inline">localhost:8080</strong> should reload with the new content you copied in and the browser should appear as follows:<div id="_idContainer468" class="IMG---Figure"><img src="image/B15218_03_49.jpg" alt="Figure 3.49: The final outcome for the template as seen from your browser&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 3.49: The final outcome for the template as seen from your browser</p>
			<p>By the end of this activity, you saw how to prepare a Vue.js project using the Vue-UI, selecting and organizing valuable presets used in the production of enterprise Vue applications. You installed and utilized the <strong class="source-inline">Vuetify</strong> framework utilizing Vuetify components to create a layout that you could then preview inside your browser.</p>
			<h1 id="_idParaDest-293"><a id="_idTextAnchor386"/>4. Nesting Components (Modularity)</h1>
			<h2 id="_idParaDest-294"><a id="_idTextAnchor387"/>Activity 4.01: A Local Message View with Reusable Components</h2>
			<p><strong class="bold">Solution</strong>:</p>
			<p>Perform the following steps to complete the activity.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the code files for this activity, refer to <a href="https://packt.live/36ZxyH8">https://packt.live/36ZxyH8</a>.</p>
			<p>First, we need a way to capture messages from the user:</p>
			<ol>
				<li value="1">Create a <strong class="source-inline">MessageEditor</strong> component that displays a <strong class="source-inline">textarea</strong>:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div&gt;</p><p class="source-code">    &lt;textarea&gt;&lt;/textarea&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p></li>
				<li>Adding a reactive instance property can be done using the <strong class="source-inline">data</strong> component method:<p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  data() {</p><p class="source-code">    return {</p><p class="source-code">      message: ''</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>On <strong class="source-inline">change</strong> of <strong class="source-inline">textarea</strong>, we will store the state in a <strong class="source-inline">message</strong> reactive instance variable that we have set to null in the <strong class="source-inline">data</strong> component method:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;!-- rest of the template --&gt;</p><p class="source-code">    &lt;textarea</p><p class="source-code">      @change="onChange($event)"</p><p class="source-code">    &gt;</p><p class="source-code">    &lt;/textarea&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  // rest of component properties</p><p class="source-code">  methods: {</p><p class="source-code">    onChange(event) {</p><p class="source-code">      this.message = event.target.value</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>A <strong class="source-inline">Send</strong> operation should result in the latest content of the <strong class="source-inline">textarea</strong> being emitted as the payload of a <strong class="source-inline">send</strong> event:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;!-- rest of the template --&gt;</p><p class="source-code">    &lt;button @click="$emit('send', message)"&gt;Send&lt;/button&gt;</p><p class="source-code">  &lt;!-- rest of the template --&gt;</p><p class="source-code">&lt;/template&gt;</p></li>
				<li>To display <strong class="source-inline">MessageEditor</strong>, we need to import it, register it in <strong class="source-inline">components</strong>, and reference it in the <strong class="source-inline">template</strong> section of <strong class="source-inline">src/App.vue</strong>:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div id="app"&gt;</p><p class="source-code">    &lt;MessageEditor /&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">import MessageEditor from './components/MessageEditor.vue'</p><p class="source-code">export default {</p><p class="source-code">  components: {</p><p class="source-code">    MessageEditor,</p><p class="source-code">  },</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>To display messages, we will listen to <strong class="source-inline">send</strong> events using <strong class="source-inline">@send</strong> and add each payload to a new <strong class="source-inline">messages</strong> array reactive instance variable:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;!-- rest of template --&gt;</p><p class="source-code">    &lt;MessageEditor @send="onSend($event)" /&gt;</p><p class="source-code">  &lt;!-- rest of template --&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">// rest of script</p><p class="source-code">export default {</p><p class="source-code">  // other component fields</p><p class="source-code">  data() {</p><p class="source-code">    return { messages: [] }</p><p class="source-code">  },</p><p class="source-code">  methods: {</p><p class="source-code">    onSend(message) {</p><p class="source-code">      this.messages = [...this.messages, message]</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li><strong class="source-inline">MessageFeed</strong> supports being passed through a <strong class="source-inline">messages</strong> array as a <strong class="source-inline">prop</strong>:<p class="source-code">&lt;template&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  props: {</p><p class="source-code">    messages: {</p><p class="source-code">      type: Array,</p><p class="source-code">      required: true</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>We will use <strong class="source-inline">v-for</strong> to iterate through the <strong class="source-inline">messages</strong> array:<p class="source-code">&lt;template&gt;</p><p class="source-code">    &lt;div&gt;</p><p class="source-code">    &lt;p v-for="(m, i) in messages" :key="i"&gt;</p><p class="source-code">      {{ m }}</p><p class="source-code">    &lt;/p&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p></li>
				<li>To display the messages that we are storing, we will render <strong class="source-inline">MessageFeed</strong> in <strong class="source-inline">App</strong>, binding the <strong class="source-inline">messages</strong> app instance variable as the <strong class="source-inline">messages</strong> prop of <strong class="source-inline">MessageFeed</strong>:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;!-- rest of template --&gt;</p><p class="source-code">    &lt;MessageFeed :messages="messages" /&gt;</p><p class="source-code">  &lt;!-- rest of template --&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">// other imports</p><p class="source-code">import MessageFeed from './components/MessageFeed.vue'</p><p class="source-code">export default {</p><p class="source-code">  components: {</p><p class="source-code">    // other components,</p><p class="source-code">    MessageFeed</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>In <strong class="source-inline">MessageEditor</strong>, we will refactor the <strong class="source-inline">send</strong> button click <strong class="source-inline">handler</strong> so that we also set <strong class="source-inline">this.message</strong> to <strong class="source-inline">''</strong> when it's clicked:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;!-- rest of template --&gt;</p><p class="source-code">    &lt;textarea</p><p class="source-code">      ref="textArea"</p><p class="source-code">      @change="onChange($event)"</p><p class="source-code">    &gt;</p><p class="source-code">    &lt;/textarea&gt;</p><p class="source-code">    &lt;button @click="onSendClick()"&gt;Send&lt;/button&gt;</p><p class="source-code">  &lt;!-- rest of template --&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  // rest of component</p><p class="source-code">  methods: {</p><p class="source-code">    // other methods</p><p class="source-code">    onSendClick() {</p><p class="source-code">      this.$emit('send', this.message)</p><p class="source-code">      this.message = ''</p><p class="source-code">      this.$refs.textArea.value = ''</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p><p>The expected output is as follows:</p><div id="_idContainer469" class="IMG---Figure"><img src="image/B15218_04_34.jpg" alt="Figure 4.34: Message app with Hello World! and Hello JavaScript! sent&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 4.34: Message app with Hello World! and Hello JavaScript! sent</p>
			<p>With that, we have learned how to use components, props, events, and refs to render a chat interface.</p>
			<h1 id="_idParaDest-295"><a id="_idTextAnchor388"/>5. Global Component Composition</h1>
			<h2 id="_idParaDest-296"><a id="_idTextAnchor389"/>Activity 5.0<a id="_idTextAnchor390"/>1: Building a Vue.js Application with Plugins and Reusable Components</h2>
			<p><strong class="bold">Solution</strong>:</p>
			<p>Perform the following steps to complete the activity:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the code files for this activity, refer to <a href="https://packt.live/35UlWpj">https://packt.live/35UlWpj</a>.</p>
			<ol>
				<li value="1">Install <strong class="source-inline">axios</strong> into the project:<p class="source-code">npm install --save axios</p></li>
				<li>To inject <strong class="source-inline">axios</strong> as a property on <strong class="source-inline">this</strong> component instances, create a <strong class="source-inline">src/plugins/axios.js</strong> plugin file that, on <strong class="source-inline">install</strong>, will mean component instances have an <strong class="source-inline">axios</strong> property:<p class="source-code">import axios from 'axios'</p><p class="source-code">export default {</p><p class="source-code">  install(Vue) {</p><p class="source-code">    Vue.prototype.axios = axios</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>For the plugin to work, import and register it in <strong class="source-inline">src/main.js</strong>:<p class="source-code">// other imports</p><p class="source-code">import axiosPlugin from './plugins/axios.js'</p><p class="source-code">Vue.use(axiosPlugin)</p><p class="source-code">// other initialisation code</p></li>
				<li>We also want to inject our API's <strong class="source-inline">baseUrl</strong> into all our components. We will create a plugin inline of the <strong class="source-inline">src/main.js</strong> file to do this:<p class="source-code">const BASE_URL = 'https://jsonplaceholder.typicode.com'</p><p class="source-code">Vue.use({</p><p class="source-code">  install(Vue) {</p><p class="source-code">    Vue.baseUrl = BASE_URL</p><p class="source-code">    Vue.prototype.baseUrl = BASE_URL</p><p class="source-code">  }</p><p class="source-code">})</p><p class="callout-heading">Note</p><p class="callout">Those familiar with <strong class="source-inline">axios</strong> know we could have injected this URL as the <strong class="source-inline">axios</strong> <strong class="source-inline">baseURL</strong>.</p></li>
				<li>Now, we need to fetch all <strong class="source-inline">todos</strong> from our <strong class="source-inline">src/App.vue</strong>. A good place to do this is inside the <strong class="source-inline">mounted</strong> life cycle method:<p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  async mounted() {</p><p class="source-code">    const { data: todos } = await this.axios.get(      `${this.baseUrl}/todos`)</p><p class="source-code">    this.todos = todos</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>To display the <strong class="source-inline">todo</strong> list, we will create a <strong class="source-inline">TodoList</strong> functional component in <strong class="source-inline">src/components/TodoList.vue</strong>. This will take a <strong class="source-inline">todos</strong> prop, loop through the items, and defer rendering of our <strong class="source-inline">todo</strong> under a <strong class="source-inline">todo</strong> scoped slot that binds it:<p class="source-code">&lt;template functional&gt;</p><p class="source-code">  &lt;ul&gt;</p><p class="source-code">    &lt;li v-for="todo in props.todos" :key="todo.id"&gt;</p><p class="source-code">      &lt;slot name="todo" :todo="todo" /&gt;</p><p class="source-code">    &lt;/li&gt;</p><p class="source-code">  &lt;/ul&gt;</p><p class="source-code">&lt;/template&gt;</p></li>
				<li>We can now use the <strong class="source-inline">TodoList</strong> component to render out the <strong class="source-inline">todos</strong> prop we have already fetched in <strong class="source-inline">src/App.vue</strong>:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div id="app"&gt;</p><p class="source-code">    &lt;TodoList :todos="todos"&gt;</p><p class="source-code">      &lt;template #todo="{ todo }"&gt;</p><p class="source-code">      {{ todo.title }}</p><p class="source-code">      &lt;/template&gt;</p><p class="source-code">    &lt;/TodoList&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">import TodoList from './components/TodoList.vue'</p><p class="source-code">export default {</p><p class="source-code">  components: {</p><p class="source-code">    TodoList</p><p class="source-code">  },</p><p class="source-code">  // other component methods</p><p class="source-code">  data() {</p><p class="source-code">    return { todos: [] }</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p><p>This will generate the following output:</p><div id="_idContainer470" class="IMG---Figure"><img src="image/B15218_05_23.jpg" alt="Figure 5.23: Todos loading and titles displaying&#13;&#10;"/></div><p class="figure-caption">Figure 5.23: Todos loading and titles displaying</p><p class="callout-heading">Note</p><p class="callout">The link to this dataset, which has been exposed as a JSON API, can be found at <a href="https://jsonplaceholder.typicode.com/">https://jsonplaceholder.typicode.com/</a>.</p></li>
				<li>Now, let's create a <strong class="source-inline">TodoEntry</strong> component where we will implement the majority of our todo-specific logic. A good practice for components is to have the props be very specific to the component's role. In this case, the properties of the <strong class="source-inline">todo</strong> object we will tackle are <strong class="source-inline">id</strong>, <strong class="source-inline">title</strong>, and <strong class="source-inline">completed</strong>, so those should be the props that our <strong class="source-inline">TodoEntry</strong> component receives. We will not make <strong class="source-inline">TodoEntry</strong> a functional component since we will need a component instance to create HTTP requests:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div&gt;</p><p class="source-code">    &lt;label&gt;{{ title }}&lt;/label&gt;</p><p class="source-code">    &lt;input</p><p class="source-code">      type="checkbox"</p><p class="source-code">      :checked="completed"</p><p class="source-code">    /&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  props: {</p><p class="source-code">    id: {</p><p class="source-code">      type: Number,</p><p class="source-code">      required: true</p><p class="source-code">    },</p><p class="source-code">    title: {</p><p class="source-code">      type: String,</p><p class="source-code">      required: true</p><p class="source-code">    },</p><p class="source-code">    completed: {</p><p class="source-code">      type: Boolean,</p><p class="source-code">      default: false</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>Update <strong class="source-inline">src/App.vue</strong> so that it consumes <strong class="source-inline">TodoEntry</strong> as follows (make sure to bind <strong class="source-inline">id</strong>, <strong class="source-inline">title</strong>, and <strong class="source-inline">completed</strong>):<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div id="app"&gt;</p><p class="source-code">    &lt;TodoList :todos="todos"&gt;</p><p class="source-code">      &lt;template #todo="{ todo }"&gt;</p><p class="source-code">        &lt;TodoEntry</p><p class="source-code">        :id="todo.id"</p><p class="source-code">        :title="todo.title"</p><p class="source-code">        :completed="todo.completed"</p><p class="source-code">      /&gt;</p><p class="source-code">    &lt;/template&gt;</p><p class="source-code">  &lt;/TodoList&gt;</p><p class="source-code"> &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">// other imports</p><p class="source-code">import TodoEntry from './components/TodoEntry.vue'</p><p class="source-code">export default {</p><p class="source-code">  components: {</p><p class="source-code">  // other components</p><p class="source-code">    TodoEntry</p><p class="source-code"> },</p><p class="source-code"> // other component methods</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p><p>We will get the following output:</p><div id="_idContainer471" class="IMG---Figure"><img src="image/B15218_05_24.jpg" alt="Figure 5.24: TodoEntry rendering data that has been fetched from the API&#13;&#10;"/></div><p class="figure-caption">Figure 5.24: TodoEntry rendering data that has been fetched from the API</p></li>
				<li>Now, we need to add the ability to toggle the <strong class="bold">complete</strong> status of a todo. We will implement the majority of this in <strong class="source-inline">src/components/TodoEntry.vue</strong>. We will listen to the <strong class="source-inline">input</strong> change event; on change, we will read the new value and send a <strong class="source-inline">PATCH</strong> request to <strong class="source-inline">/todos/{todoId}</strong> with an object containing <strong class="source-inline">completed</strong> set to the new value. We will also emit a <strong class="source-inline">completedChange</strong> event in Vue.js so that the <strong class="source-inline">App</strong> component can update the data that's in-memory:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;!-- rest of the template --&gt;</p><p class="source-code">    &lt;input       type="checkbox"</p><p class="source-code">      :checked="completed"</p><p class="source-code">      @change="toggleCompletion()"</p><p class="source-code">    /&gt;</p><p class="source-code">  &lt;!-- rest of the template --&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  // other component properties</p><p class="source-code">  methods: {</p><p class="source-code">    toggleCompletion() {</p><p class="source-code">      const newCompleted = !this.completed </p><p class="source-code">      this.$emit('completeChange', newCompleted)</p><p class="source-code">      this.axios.patch(</p><p class="source-code">        `${this.baseUrl}/todos/${this.id}`,</p><p class="source-code">        { completed: newCompleted }</p><p class="source-code">      )</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>In <strong class="source-inline">App.vue</strong>, we need to update the relevant <strong class="source-inline">todo</strong> when <strong class="source-inline">completeChange</strong> is triggered. Since <strong class="source-inline">completeChange</strong> does not include the ID of our <strong class="source-inline">todo</strong>, we will need to read that from the context when we set the <strong class="source-inline">handleCompleteChange</strong> function so that it listens to <strong class="source-inline">completeChange</strong>:<p class="source-code">&lt;template&gt;</p><p class="source-code"> &lt;!-- rest of template --&gt;</p><p class="source-code">        &lt;TodoEntry</p><p class="source-code">          :id="todo.id"</p><p class="source-code">          :title="todo.title"</p><p class="source-code">          :completed="todo.completed"</p><p class="source-code">          @completeChange="handleCompleteChange(todo.id, $event)"</p><p class="source-code">        /&gt;</p><p class="source-code"> &lt;!-- rest of template --&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">// imports</p><p class="source-code">export default {</p><p class="source-code"> // other component properties</p><p class="source-code">  methods: {</p><p class="source-code">    handleCompleteChange(id, newCompleted) {</p><p class="source-code">      this.todos = this.todos.map(</p><p class="source-code">        t =&gt; t.id === id</p><p class="source-code">         ? { ...t, completed: newCompleted }</p><p class="source-code">         : t</p><p class="source-code">      )</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p><p>At this stage,<a id="_idTextAnchor391"/> we should see the following output:</p><div id="_idContainer472" class="IMG---Figure"><img src="image/B15218_05_25.jpg" alt="Figure 5.25: Our to-do app using JSON placeholder data&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 5.25: Our to-do app using JSON placeholder data</p>
			<p>With that, we have learned how to use plugins and reusable components to build a <strong class="source-inline">todo</strong> app that consumes <strong class="source-inline">JSONPlaceholder</strong> data.</p>
			<h1 id="_idParaDest-297"><a id="_idTextAnchor392"/>6. Routing</h1>
			<h2 id="_idParaDest-298"><a id="_idTextAnchor393"/>Activity 6.01: Creating a Message SPA with Dynamic, Nested Routing, and Layouts </h2>
			<p><strong class="bold">Solution:</strong></p>
			<p>Perform the following steps to complete the activity:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the code files for this activity, refer to <a href="https://packt.live/2ISxml7">https://packt.live/2ISxml7</a>.</p>
			<ol>
				<li value="1">Create a new <strong class="source-inline">MessageEditor.vue</strong> file in the <strong class="source-inline">src/views/</strong> folder as the main component to interact with the user when writing a message. We use <strong class="source-inline">textarea</strong> as a message input field and attach the <strong class="source-inline">listener</strong> method <strong class="source-inline">onChange</strong> to the <strong class="source-inline">DOM</strong> event change to capture any input change regarding the message typed by the user. Also, we add <strong class="source-inline">ref</strong> to keep a pointer record to the rendered HTML <strong class="source-inline">textarea</strong> element for modifying our saved messages at a later stage.<p>Besides this, we also attach another <strong class="source-inline">listener</strong> method, <strong class="source-inline">onSendClick</strong>, to the <strong class="source-inline">click</strong> event on the <strong class="source-inline">Submit button</strong> to capture the user's confirmation for sending the message. The actual logic implementation of both <strong class="source-inline">onChange</strong> and <strong class="source-inline">onSendClick</strong> is shown in <em class="italic">Step 3</em>.</p></li>
				<li>The <strong class="source-inline">&lt;template&gt;</strong> section should look like the following:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div&gt;</p><p class="source-code">    &lt;textarea</p><p class="source-code">      ref="textArea"</p><p class="source-code">      @change="onChange($event)"</p><p class="source-code">    &gt;</p><p class="source-code">    &lt;/textarea&gt;</p><p class="source-code">    &lt;button @click="onSendClick()"&gt;Submit&lt;/button&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p></li>
				<li>And in <strong class="source-inline">script</strong>, in addition to the previous code, we will also receive a <strong class="source-inline">list</strong> of messages to update with the new message after submitting, and emit the updated list back to the parent:<p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  props: {</p><p class="source-code">    list: Array</p><p class="source-code">  },</p><p class="source-code">  data() {</p><p class="source-code">    return {</p><p class="source-code">      message: ''</p><p class="source-code">    }</p><p class="source-code">  },</p><p class="source-code">  methods: {</p><p class="source-code">    onChange(event) {</p><p class="source-code">      this.message = event.target.value</p><p class="source-code">    },</p><p class="source-code">    onSendClick() {</p><p class="source-code">      if (!this.message) return;</p><p class="source-code">      this.list.push(this.message);</p><p class="source-code">      this.$emit('list:update', this.list);</p><p class="source-code">      this.message = ''</p><p class="source-code">      this.$refs.textArea.value = ''</p><p class="source-code">    }</p><p class="source-code">  },</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>We need to define a parent route as a default route with the <strong class="source-inline">path</strong> of <strong class="source-inline">/</strong> and <strong class="source-inline">name</strong> of <strong class="source-inline">messages</strong> in the routes array in <strong class="source-inline">./src/router/index.js</strong>:<p class="source-code">{</p><p class="source-code">    path: '/',</p><p class="source-code">    name: 'messages',</p><p class="source-code">    component: () =&gt; import(/* webpackChunkName: "messages" */       '../views/Messages.vue'),</p><p class="source-code">}</p><p>Then add a new route as a nested route called <strong class="source-inline">editor</strong> under the <strong class="source-inline">children</strong> property of this route configuration:</p><p class="source-code">{</p><p class="source-code">    path: '/',</p><p class="source-code">    name: 'messages',</p><p class="source-code">    component: () =&gt; import(/* webpackChunkName: "messages" */       '../views/Messages.vue'),</p><p class="source-code">    children: [{</p><p class="source-code">      path: 'editor',</p><p class="source-code">      name: 'editor',</p><p class="source-code">      component: () =&gt; import(/* webpackChunkName: "editor" */         '../views/MessageList.vue'),</p><p class="source-code">      props: true,</p><p class="source-code">    }]</p><p class="source-code">},</p></li>
				<li>We create a new view component called <strong class="source-inline">MessageList.vue</strong> with <strong class="source-inline">v-for</strong> to render the list of messages into the <strong class="source-inline">router-link</strong> component:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div&gt;</p><p class="source-code">    &lt;h2&gt; Message Feed &lt;/h2&gt;</p><p class="source-code">    &lt;div v-for="(m, i) in list" :key="i" &gt;</p><p class="source-code">      &lt;router-link :to="`/message/${i}`"&gt;</p><p class="source-code">        {{ i }}</p><p class="source-code">        &lt;/router-link&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">&lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  props: {</p><p class="source-code">    list: {</p><p class="source-code">      type: Array,</p><p class="source-code">      default: () =&gt; []</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>And, similarly to <em class="italic">Step 2</em>, register the <strong class="source-inline">MessageList.vue</strong> component with the <strong class="source-inline">children</strong> routes array of the <strong class="source-inline">messages</strong> route: <p class="source-code">{</p><p class="source-code">    path: '/',</p><p class="source-code">    name: 'messages',</p><p class="source-code">    component: () =&gt; import(/* webpackChunkName: "messages" */       '../views/Messages.vue'),</p><p class="source-code">    children: [{</p><p class="source-code">      path: 'list',</p><p class="source-code">      name: 'list',</p><p class="source-code">      component: () =&gt; import(/* webpackChunkName: "list" */         '../views/MessageList.vue'),</p><p class="source-code">      props: true,</p><p class="source-code">    }, {</p><p class="source-code">      path: 'editor',</p><p class="source-code">      name: 'editor',</p><p class="source-code">      component: () =&gt; import(/* webpackChunkName: "editor" */         '../views/MessageEditor.vue'),</p><p class="source-code">      props: true,</p><p class="source-code">    }]</p><p class="source-code">  },</p></li>
				<li>Now our <strong class="source-inline">messages</strong> view needs a UI. We define the <strong class="source-inline">Messages.vue</strong> view with the use of <strong class="source-inline">router-link</strong> to allow navigation between <strong class="source-inline">editor</strong> and <strong class="source-inline">list</strong> and a <strong class="source-inline">router-view</strong> component for rendering the nested view:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div&gt;</p><p class="source-code">    &lt;router-link :to="{ name: 'list', params: { list       }}"&gt;List&lt;/router-link&gt; |</p><p class="source-code">    &lt;router-link :to="{ name: 'editor', params: { list       }}"&gt;Editor&lt;/router-link&gt;</p><p class="source-code">    &lt;router-view :list.sync="list"/&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p>And, of course, we need to receive a <strong class="source-inline">list</strong> of messages from <strong class="source-inline">props</strong>:</p><p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  props: {</p><p class="source-code">    list: Array</p><p class="source-code">  }</p><p class="source-code">&lt;/script&gt;</p><p>Since we don't have a global state or proper database, we need to mock a global list of messages in <strong class="source-inline">./src/router/index.js</strong>:</p><p class="source-code">const messages = []</p><p>Then pass it as default <strong class="source-inline">props</strong> for the <strong class="source-inline">messages</strong> route, as follows:</p><p class="source-code">{</p><p class="source-code">    path: '/',</p><p class="source-code">    name: 'messages',</p><p class="source-code">    /* ... */ </p><p class="source-code">    props: {</p><p class="source-code">      list: messages</p><p class="source-code">    },</p><p class="source-code">}</p></li>
				<li>In order to catch whether the user is leaving the current editor view, we will add a Hook on the <strong class="source-inline">beforeRouteLeave</strong> in-component navigation guard, which will allow us to display a warning and abort or continue per the user's decision. This is done within <strong class="source-inline">MessageEditor.vue</strong> file:<p class="source-code">beforeRouteLeave(to, from, next) {</p><p class="source-code">      if (this.$refs.textArea.value !== '') {</p><p class="source-code">        const ans = window.confirm(You have an unsaved message.           Are you sure you want to navigate away?');</p><p class="source-code">        next(!!ans);</p><p class="source-code">      }</p><p class="source-code">      else {</p><p class="source-code">        next();</p><p class="source-code">      }</p><p class="source-code">  }</p></li>
				<li>Creating <strong class="source-inline">messageLayout.vue</strong> is simple, with a header text, the <strong class="source-inline">content</strong> from <strong class="source-inline">props</strong>, and a <strong class="source-inline">Back button</strong>:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div class="message"&gt;</p><p class="source-code">    &lt;h2&gt;Message content:&lt;/h2&gt;</p><p class="source-code">    &lt;main&gt;</p><p class="source-code">      &lt;slot/&gt;</p><p class="source-code">    &lt;/main&gt;</p><p class="source-code">    &lt;button @click="goBack"&gt;Back&lt;/button&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p>The <strong class="source-inline">goBack</strong> logic should be simple: if there is a previous route saved, let's go back one step in the navigation stack with <strong class="source-inline">this.$routes.go(-1)</strong>. Otherwise, we will just push the <strong class="source-inline">messages</strong> navigation route to the stack with <strong class="source-inline">this.$router.push({ name: 'message'})</strong>:</p><p class="source-code">&lt;script&gt;</p><p class="source-code">import MessageLayout from '../layouts/messageLayout.vue';</p><p class="source-code">export default {</p><p class="source-code">  props: {</p><p class="source-code">    content: {</p><p class="source-code">      type: String,</p><p class="source-code">      default: ''</p><p class="source-code">    },</p><p class="source-code">  },</p><p class="source-code">  methods: {</p><p class="source-code">    goBack() {</p><p class="source-code">      if (this.$route.params.from) {</p><p class="source-code">        this.$router.go(-1)</p><p class="source-code">      }</p><p class="source-code">      else {</p><p class="source-code">        this.$router.push({</p><p class="source-code">          name: 'messages'</p><p class="source-code">        })</p><p class="source-code">      }</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p><p>But then we still need to pass the previous route, <strong class="source-inline">this.$route.params.from</strong>, from the tracking. It should be done at the route registration.</p></li>
				<li>We add the <strong class="source-inline">message</strong> route configuration inside <strong class="source-inline">routes</strong>, and we will use the <strong class="source-inline">beforeEnter</strong> component guard to save and pass the <strong class="source-inline">from</strong> previous navigation route to the <strong class="source-inline">params</strong> of the view. <p>Also, since it is a dynamic route with the <strong class="source-inline">message/:id</strong> pattern, we need to retrieve the content of the message and map that content to the related prop accordingly:</p><p class="source-code">{</p><p class="source-code">    path: '/message/:id',</p><p class="source-code">    name: 'message',</p><p class="source-code">    component: () =&gt; import(/* webpackChunkName: "message" */       '../views/Message.vue'),</p><p class="source-code">    props:true,</p><p class="source-code">    beforeEnter(to, from, next) {</p><p class="source-code">      if (to.params &amp;&amp; to.params.id) {</p><p class="source-code">        const id = to.params.id;</p><p class="source-code">      </p><p class="source-code">        if (messages &amp;&amp; messages.length &gt; 0 &amp;&amp; id &lt;           messages.length) {</p><p class="source-code">          to.params.content = messages[id];</p><p class="source-code">          }</p><p class="source-code">      }</p><p class="source-code">      to.params.from = from;</p><p class="source-code">      next()</p><p class="source-code">    },</p><p class="source-code">  }</p></li>
				<li>Finally, to code-split the UI layouts from <strong class="source-inline">Message.vue</strong> and <strong class="source-inline">Messages.vue</strong>, in the <strong class="source-inline">./src/layouts</strong> folder, we create both a <strong class="source-inline">default.vue</strong> layout and <strong class="source-inline">messageLayout.vue</strong> layout. <p>As we learned in this chapter, in <strong class="source-inline">App.vue</strong>, we will wrap <strong class="source-inline">router-view</strong> with a component that renders according to a layout variable. And, certainly, <strong class="source-inline">router-view</strong> needs to have a synchronous <strong class="source-inline">layout</strong> property to dynamically change the layout according to the current view:</p><p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div id="app"&gt;</p><p class="source-code">    &lt;component :is="layout"&gt;</p><p class="source-code">      &lt;router-view :layout.sync="layout"/&gt;</p><p class="source-code">    &lt;/component&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  data() {</p><p class="source-code">    return {</p><p class="source-code">      layout: () =&gt; import(/* webpackChunkName: "defaultLayout"         */ './layouts/default.vue')</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>In <strong class="source-inline">default.vue</strong>, we will simply just have the header text for the <strong class="source-inline">messages</strong> section and a <strong class="source-inline">slot</strong>:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div class="default"&gt;</p><p class="source-code">    &lt;h1&gt;Messages section&lt;/h1&gt;</p><p class="source-code">    &lt;main&gt;</p><p class="source-code">      &lt;slot/&gt;</p><p class="source-code">    &lt;/main&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p></li>
				<li>In <strong class="source-inline">messageLayout.vue</strong>, we will extract the header text and the button logic from <strong class="source-inline">Message.vue</strong>:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div class="message"&gt;</p><p class="source-code">    &lt;h2&gt;Message content:&lt;/h2&gt;</p><p class="source-code">    &lt;main&gt;</p><p class="source-code">      &lt;slot/&gt;</p><p class="source-code">    &lt;/main&gt;</p><p class="source-code">    &lt;button @click="goBack"&gt;Back&lt;/button&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  methods: {</p><p class="source-code">    goBack() {</p><p class="source-code">      if (this.$route.params.from) {</p><p class="source-code">        this.$router.go(-1)</p><p class="source-code">      }</p><p class="source-code">      else {</p><p class="source-code">        this.$router.push({</p><p class="source-code">          name: 'messages'</p><p class="source-code">        })</p><p class="source-code">      }</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p><p>And the final step is to make sure an <strong class="source-inline">update:layout</strong> event will be triggered to update the view layout upon component creation for both <strong class="source-inline">Message.vue</strong> and <strong class="source-inline">Messages.vue</strong>:</p><p class="source-code">import MessageLayout from '../layouts/messageLayout.vue';</p><p class="source-code">export default {</p><p class="source-code">/*...*/</p><p class="source-code">  created() {</p><p class="source-code">    this.$emit('update:layout', MessageLayout);</p><p class="source-code">  }</p><p class="source-code">}</p><p>In <strong class="source-inline">Messages.vue</strong>, this will be as follows:</p><p class="source-code">&lt;script&gt;</p><p class="source-code">import DefaultLayout from '../layouts/default';</p><p class="source-code">export default {</p><p class="source-code">  props: {</p><p class="source-code">    list: Array</p><p class="source-code">  },</p><p class="source-code">  created() {</p><p class="source-code">    this.$emit('update:layout', DefaultLayout);</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>Run the application using the following command:<p class="source-code">yarn serve</p><p>To ensure you've completed the steps correctly, you will need to visit each route and ensure the content renders as shown in the corresponding figure. First, ensure that the <strong class="source-inline">/list</strong> view renders a message feed as shown in <em class="italic">Figure 6.47</em>:</p><div id="_idContainer473" class="IMG---Figure"><img src="image/B15218_06_47.jpg" alt="Figure 6.47: The /list view in the Messages app&#13;&#10;"/></div><p class="figure-caption">Figure 6.47: The /list view in the Messages app</p></li>
				<li>Next, ensure that the <strong class="source-inline">/editor</strong> view allows a user to send a new message, as shown in <em class="italic">Figure 6.48</em>:<div id="_idContainer474" class="IMG---Figure"><img src="image/B15218_06_48.jpg" alt="Figure 6.48: The /editor view in the Messages app&#13;&#10;"/></div><p class="figure-caption">Figure 6.48: The /editor view in the Messages app</p></li>
				<li>Next, ensure the <strong class="source-inline">/message/:id</strong> dynamic route is working by going to the <strong class="source-inline">/message/0</strong> route. You should see message content similar to that shown in <em class="italic">Figure 6.49</em>:<div id="_idContainer475" class="IMG---Figure"><img src="image/B15218_06_49.jpg" alt="Figure 6.49: The /message/0 view in the Message app&#13;&#10;"/></div><p class="figure-caption">Figure 6.49: The /message/0 view in the Message app</p></li>
				<li>Ensure that when the user is composing a message, if they try to navigate away without having a saved message, an alert is triggered, as shown in <em class="italic">Figure 6.50</em>:<div id="_idContainer476" class="IMG---Figure"><img src="image/B15218_06_50.jpg" alt="Figure 6.50: The /editor view when the user tries to navigate away with an unsaved message&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 6.50: The /editor view when the user tries to navigate away with an unsaved message</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Our <strong class="source-inline">messages</strong> data is not saved upon refresh, as we don't have global state management. We can use <strong class="source-inline">localStorage</strong> to help to save the data while exploring the application.</p>
			<p>In this activity, we put together several of the topics covered in this chapter, including setting up views, making use of templates and dynamic routes, and the use of Hooks to prompt a confirmation alert before the user navigates away with unsaved content. These tools can be used for many common SPA use cases and will be helpful in your future projects.</p>
			<h1 id="_idParaDest-299">7. Animati<a id="_idTextAnchor394"/>ons and Transitions</h1>
			<h2 id="_idParaDest-300"><a id="_idTextAnchor395"/>Activity 7.01: Building a Messages App with Transition and GSAP </h2>
			<p><strong class="bold">Solution:</strong></p>
			<p>Perform the following steps to complete the activity:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the code files for this activity, visit <a href="https://packt.live/399tZ3Y">https://packt.live/399tZ3Y</a>.</p>
			<ol>
				<li value="1">We will reuse the code created in <em class="italic">Chapter 6</em>, <em class="italic">Routing</em> for the <strong class="source-inline">Message</strong> app so we have all the routing setup accordingly.<p>The <strong class="source-inline">template</strong> section of <strong class="source-inline">src/views/MessageEditor.vue</strong> will be as follows:</p><p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div&gt;</p><p class="source-code">    &lt;textarea</p><p class="source-code">      ref="textArea"</p><p class="source-code">      @change="onChange($event)"</p><p class="source-code">    &gt;</p><p class="source-code">    &lt;/textarea&gt;</p><p class="source-code">    &lt;button @click="onSendClick()"&gt;Submit&lt;/button&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p></li>
				<li>Next, the <strong class="source-inline">script</strong> section of <strong class="source-inline">src/views/MessageEditor.vue</strong> should contain logic for both clicking on and leaving the route:<p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  props: {</p><p class="source-code">    list: Array</p><p class="source-code">  },</p><p class="source-code">  data() {</p><p class="source-code">    return {</p><p class="source-code">      message: ''</p><p class="source-code">    }</p><p class="source-code">  },</p><p class="source-code">  methods: {</p><p class="source-code">    onChange(event) {</p><p class="source-code">      this.message = event.target.value</p><p class="source-code">    },</p><p class="source-code">    onSendClick() {</p><p class="source-code">      if (!this.message) return;</p><p class="source-code">      this.list.push(this.message);</p><p class="source-code">      this.$emit('list:update', this.list);</p><p class="source-code">      this.message = ''</p><p class="source-code">      this.$refs.textArea.value = ''</p><p class="source-code">    }</p><p class="source-code">  },</p><p class="source-code">  beforeRouteLeave(to, from, next) {</p><p class="source-code">      if (this.$refs.textArea.value !== '') {</p><p class="source-code">        const ans = window.confirm('You have unsaved message.           Are you sure to navigate away?');</p><p class="source-code">        next(ans);</p><p class="source-code">      }</p><p class="source-code">      else {</p><p class="source-code">        next();</p><p class="source-code">      }</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>Next, we will need our <strong class="source-inline">template</strong> code for <strong class="source-inline">MessageList.vue</strong>. The code will be as follows:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div&gt;</p><p class="source-code">    &lt;h2&gt; Message Feed &lt;/h2&gt;</p><p class="source-code">    &lt;transition-group</p><p class="source-code">      @appear="enter"</p><p class="source-code">      tag="div"</p><p class="source-code">      move-class="flip"</p><p class="source-code">      :css="false"</p><p class="source-code">    &gt;</p><p class="source-code">      &lt;div v-for="(m, i) in list" :key="m"&gt;</p><p class="source-code">        &lt;router-link :to="`/message/${i}`"&gt;</p><p class="source-code">          {{ i }}</p><p class="source-code">        &lt;/router-link&gt;</p><p class="source-code">      &lt;/div&gt;</p><p class="source-code">    &lt;/transition-group&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p></li>
				<li>Next, we will need a <strong class="source-inline">script</strong> section in our <strong class="source-inline">MessageList.vue</strong> file. To add the <strong class="source-inline">script</strong> section, the code will be as follows:<p class="source-code">&lt;script&gt;</p><p class="source-code">import { TimelineMax } from 'gsap';</p><p class="source-code">export default {</p><p class="source-code">  props: {</p><p class="source-code">    list: {</p><p class="source-code">      type: Array,</p><p class="source-code">      default: () =&gt; []</p><p class="source-code">    }</p><p class="source-code">  },</p><p class="source-code">  methods: {</p><p class="source-code">    enter(el, done) {</p><p class="source-code">      const tl = new TimelineMax({</p><p class="source-code">        onComplete: done,</p><p class="source-code">        stagger: 1.2,</p><p class="source-code">        duration: 2,</p><p class="source-code">      });</p><p class="source-code">      tl.fromTo(el, {opacity: 0}, {opacity: 1})</p><p class="source-code">        .to(el, {rotation: -270, duration: 1, ease: "bounce"})</p><p class="source-code">        .to(el, {rotation: -360})</p><p class="source-code">        .to(el, {rotation: -180, opacity: 0})</p><p class="source-code">        .to(el, {rotation: 0, opacity: 1});</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>We'll also create a <strong class="source-inline">style</strong> section in <strong class="source-inline">MessageList.vue</strong> and define the <strong class="source-inline">.flip-move</strong> class with the following code:<p class="source-code">&lt;style&gt;</p><p class="source-code">.flip-move {</p><p class="source-code">  transition: transform 1s;</p><p class="source-code">}</p><p class="source-code">&lt;/style&gt;</p></li>
				<li><strong class="source-inline">Message.vue</strong> should contain the rendered content inside a <strong class="source-inline">p</strong> element. We'll also define the <strong class="source-inline">content</strong> prop and emit an update signal:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div&gt;</p><p class="source-code">    &lt;p&gt;{{content}}&lt;/p&gt;</p><p class="source-code">    &lt;router-view/&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">import MessageLayout from '../layouts/messageLayout.vue';</p><p class="source-code">export default {</p><p class="source-code">  props: {</p><p class="source-code">    content: {</p><p class="source-code">      type: String,</p><p class="source-code">      default: ''</p><p class="source-code">    }</p><p class="source-code">  },</p><p class="source-code">  created() {</p><p class="source-code">    this.$emit('update:layout', MessageLayout);</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>Ensure your <strong class="source-inline">src/router/index.js</strong> file is the same as the one created in <em class="italic">Activity 6.01</em>, <em class="italic">Creating a Message SPA with Dynamic, Nested Routing, and Layouts</em> in <em class="italic">Chapter 6</em>, <em class="italic">Routing</em>, which can be found at <a href="https://packt.live/2ISxml7">https://packt.live/2ISxml7</a>:<p class="source-code">import Vue from 'vue'</p><p class="source-code">import VueRouter from 'vue-router'</p><p class="source-code">import Messages from '@/views/Messages.vue'</p><p class="source-code">Vue.use(VueRouter)</p><p class="source-code">const messages = []</p><p class="source-code">export const routes = [</p><p class="source-code">  {</p><p class="source-code">    path: '/',</p><p class="source-code">    name: 'messages',</p><p class="source-code">    component: () =&gt; import(/* webpackChunkName: "messages" */       '../views/Messages.vue'),</p><p class="source-code">    props: {</p><p class="source-code">      list: messages</p><p class="source-code">    },</p><p class="source-code">    children: [{</p><p class="source-code">      path: 'list',</p><p class="source-code">      name: 'list',</p><p class="source-code">      component: () =&gt; import(/* webpackChunkName: "list" */         '../views/MessageList.vue'),</p><p class="source-code">      props: true,</p><p class="source-code">    }, {</p><p class="source-code">      path: 'editor',</p><p class="source-code">      name: 'editor',</p><p class="source-code">      component: () =&gt; import(/* webpackChunkName: "list" */         '../views/MessageEditor.vue'),</p><p class="source-code">      props: true,</p><p class="source-code">    }]</p><p class="source-code">  },</p><p class="source-code">  {</p><p class="source-code">    path: '/message/:id',</p><p class="source-code">    name: 'message',</p><p class="source-code">    component: () =&gt; import(/* webpackChunkName: "message" */       '../views/Message.vue'),</p><p class="source-code">    props:true,</p><p class="source-code">    beforeEnter(to, from, next) {</p><p class="source-code">      if (to.params &amp;&amp; to.params.id) {</p><p class="source-code">        const id = to.params.id;</p><p class="source-code">        </p><p class="source-code">        if (messages &amp;&amp; messages.length &gt; 0 &amp;&amp; id &lt;           messages.length) {</p><p class="source-code">          to.params.content = messages[id];</p><p class="source-code">        }</p><p class="source-code">      }</p><p class="source-code">      to.params.from = from;</p><p class="source-code">      next()</p><p class="source-code">    },</p><p class="source-code">  }</p><p class="source-code">]</p><p class="source-code">const router = new VueRouter({</p><p class="source-code">  mode: 'history',</p><p class="source-code">  base: process.env.BASE_URL,</p><p class="source-code">  routes</p><p class="source-code">})</p><p class="source-code">export default router</p></li>
				<li>We will now wrap <strong class="source-inline">router-view</strong> in the <strong class="source-inline">&lt;template&gt;</strong> section of <strong class="source-inline">App.vue</strong> with a <strong class="source-inline">transition</strong> component that has two attributes, <strong class="source-inline">name="fade"</strong> and <strong class="source-inline">mode="out-in"</strong>:<p class="source-code">&lt;component :is="layout"&gt;</p><p class="source-code">      &lt;transition name="fade" mode="out-in"&gt;</p><p class="source-code">        &lt;router-view :layout.sync="layout"/&gt;</p><p class="source-code">      &lt;/transition&gt;</p><p class="source-code">    &lt;/component&gt;</p><p class="source-code">Create CSS stylings for the related classes, inside App.vue:</p><p class="source-code">&lt;style&gt;</p><p class="source-code">.fade-enter-active, .fade-leave-active {</p><p class="source-code">  transition: opacity 2s, transform 3s;</p><p class="source-code">}</p><p class="source-code">.fade-enter, .fade-leave-to {</p><p class="source-code">  opacity: 0;</p><p class="source-code">  transform: translateX(-20%);</p><p class="source-code">}</p><p class="source-code">&lt;/style&gt;</p></li>
				<li>In <strong class="source-inline">src/views/Messages.vue</strong>, we will wrap <strong class="source-inline">router-view</strong> with a <strong class="source-inline">transition</strong> component. This time, we will use a custom <strong class="source-inline">enter-active-class</strong> transition class attribute in addition to the <strong class="source-inline">fade</strong> name:<p class="source-code">&lt;transition name="fade" enter-active-class="zoom-in"&gt;</p><p class="source-code">  &lt;router-view :list.sync="list"/&gt;</p><p class="source-code">&lt;/transition&gt;</p></li>
				<li>Add the <strong class="source-inline">zoom-in</strong> and <strong class="source-inline">fade-enter</strong> animation effects in the <strong class="source-inline">style</strong> section of <strong class="source-inline">src/views/Messages.vue</strong>:<p class="source-code">&lt;style&gt;</p><p class="source-code">.zoom-in {</p><p class="source-code">  animation-duration: 0.3s;</p><p class="source-code">  animation-fill-mode: both;</p><p class="source-code">  animation-name: zoom;</p><p class="source-code">}</p><p class="source-code">.fade-enter-active {</p><p class="source-code">  transition: opacity 2s, transform 3s;</p><p class="source-code">}</p><p class="source-code">.fade-enter {</p><p class="source-code">  opacity: 0;</p><p class="source-code">  transform: translateX(-20%);</p><p class="source-code">}</p><p class="source-code">&lt;/style&gt;</p></li>
				<li>Add <strong class="source-inline">transition-group</strong> as the wrapper for the list of message links in <strong class="source-inline">src/views/MessageList.vue</strong>, with JavaScript hooks for programmatic animation. But we have to specify that transition on the initial render of the page, as the list is supposed to animate when appearing. We will add the <strong class="source-inline">appear</strong> attribute and bind <strong class="source-inline">enter</strong> to <strong class="source-inline">appear</strong>, as well as add the <strong class="source-inline">move-class</strong> flip (an animation to be created later in the <strong class="source-inline">style</strong> section):<p class="source-code">&lt;transition-group</p><p class="source-code">  appear</p><p class="source-code">  @appear="enter"</p><p class="source-code">  tag="div"</p><p class="source-code">  move-class="flip"</p><p class="source-code">  :css="false"</p><p class="source-code">&gt;</p><p class="source-code">  &lt;div v-for="(m, i) in list" :key="m"&gt;</p><p class="source-code">    &lt;router-link :to="`/message/${i}`"&gt;</p><p class="source-code">      {{ i }}</p><p class="source-code">    &lt;/router-link&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/transition-group&gt;</p></li>
				<li>Add GSAP as a dependency and implement the bounce-in effect on the <strong class="source-inline">appear</strong> transition event handler (hook) in <strong class="source-inline">src/views/MessageList.vue</strong>:<p class="source-code">&lt;script&gt;</p><p class="source-code">import { TimelineMax } from 'gsap';</p><p class="source-code">export default {</p><p class="source-code">  props: {</p><p class="source-code">    list: {</p><p class="source-code">      type: Array,</p><p class="source-code">      default: () =&gt; []</p><p class="source-code">    }</p><p class="source-code">  },</p><p class="source-code">  methods: {</p><p class="source-code">    enter(el, done) {</p><p class="source-code">      const tl = new TimelineMax({</p><p class="source-code">        onComplete: done,</p><p class="source-code">        stagger: 1.2,</p><p class="source-code">        duration: 2,</p><p class="source-code">      });</p><p class="source-code">      tl.fromTo(el, {opacity: 0}, {opacity: 1})</p><p class="source-code">        .to(el, {rotation: -270, duration: 1, ease: "bounce"})</p><p class="source-code">        .to(el, {rotation: -360})</p><p class="source-code">        .to(el, {rotation: -180, opacity: 0})</p><p class="source-code">        .to(el, {rotation: 0, opacity: 1});</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>Next, we need to create the <strong class="source-inline">flip-move</strong> class that we defined in our HTML. We'll do that by adding a <strong class="source-inline">style</strong> section with our new <strong class="source-inline">flip-move</strong> class:<p class="source-code">&lt;style&gt;</p><p class="source-code">.flip-move {</p><p class="source-code">  transition: transform 1s;</p><p class="source-code">}</p><p class="source-code">&lt;/style&gt;</p></li>
				<li>Run the application using the <strong class="source-inline">yarn serve</strong> command and you should see the following in your browser at <strong class="source-inline">localhost:8080</strong>:<div id="_idContainer477" class="IMG---Figure"><img src="image/B15218_07_19.jpg" alt="Figure 7.19: Fade out when navigating from message list view to editor view&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 7.19: Fade out when navigating from message list view to editor view</p>
			<p>You should now see a fade out when navigating from the message list view to the editor view, as shown in <em class="italic">Figure 7.19</em>, and also a fade out when going from the editor view to the list view, as shown in <em class="italic">Figure 7.20</em>:</p>
			<div>
				<div id="_idContainer478" class="IMG---Figure">
					<img src="image/B15218_07_20.jpg" alt="Figure 7.20: Fade out when navigating from editor view to message list view&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.20: Fade out when navigating from editor view to message list view</p>
			<p>When the messages are in the feed, you should see a bouncing effect during the flipping motion, as shown in <em class="italic">Figure 7.21</em>:</p>
			<div>
				<div id="_idContainer479" class="IMG---Figure">
					<img src="image/B15218_07_21.jpg" alt="Figure 7.21: Bouncing effect when displaying the message feed in the message list view&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.21: Bouncing effect when displaying the message feed in the message list view</p>
			<p>Finally, when clicking on a specific message in the list, it should render the content as shown in <em class="italic">Figure 7.22</em>:</p>
			<div>
				<div id="_idContainer480" class="IMG---Figure">
					<img src="image/B15218_07_22.jpg" alt="Figure 7.22: Single message view&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.22: Single message view</p>
			<p>In this activity, we put together several different animations and combined them with routing to create custom page transitions. We used several different animation types to demonstrate the many possibilities animations can provide.</p>
			<h1 id="_idParaDest-301"><a id="_idTextAnchor396"/>8. The State of Vue.js State Management</h1>
			<h2 id="_idParaDest-302"><a id="_idTextAnchor397"/>Activity 8.01: Adding Email and Phone Number to a Profile Card Generator</h2>
			<p><strong class="bold">Solution:</strong></p>
			<p>Perform the following steps to compete the activity:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the code files for this activity, refer to <a href="https://packt.live/3m1swQE">https://packt.live/3m1swQE</a>.</p>
			<ol>
				<li value="1">We can start by adding a new <strong class="source-inline">email</strong> input field and label to <strong class="source-inline">src/components/AppProfileForm</strong> for the <strong class="source-inline">Email</strong> field:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;!-- rest of template --&gt;</p><p class="source-code">    &lt;div class="flex flex-col mt-2"&gt;</p><p class="source-code">      &lt;label class="flex text-gray-800 mb-2" for="email"&gt;Email</p><p class="source-code">      &lt;/label&gt;</p><p class="source-code">      &lt;input</p><p class="source-code">        id="email"</p><p class="source-code">        type="email"</p><p class="source-code">        name="email"</p><p class="source-code">        class="border-2 border-solid border-blue-200 rounded           px-2 py-1"</p><p class="source-code">      /&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">  &lt;!-- rest of template --&gt;</p><p class="source-code">&lt;/template&gt;</p></li>
				<li>We can then add a new <strong class="source-inline">phone</strong> input field (of type <strong class="source-inline">tel</strong>) and a label to <strong class="source-inline">AppProfileForm</strong> for the <strong class="source-inline">Phone Number</strong> field:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;!-- rest of template --&gt;</p><p class="source-code">    &lt;div class="flex flex-col mt-2"&gt;</p><p class="source-code">      &lt;label class="flex text-gray-800 mb-2" for="phone"&gt;Phone         Number&lt;/label&gt;</p><p class="source-code">      &lt;input</p><p class="source-code">        id="phone"</p><p class="source-code">        type="tel"</p><p class="source-code">        name="phone"</p><p class="source-code">        class="border-2 border-solid border-blue-200 rounded           px-2 py-1"</p><p class="source-code">      /&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">  &lt;!-- rest of template --&gt;</p><p class="source-code">&lt;/template&gt;</p><p>The new fields look as follows:</p><div id="_idContainer481" class="IMG---Figure"><img src="image/B15218_08_35.jpg" alt="Figure 8.35: Application with new Email and Phone Number fields&#13;&#10;"/></div><p class="figure-caption">Figure 8.35: Application with new Email and Phone Number fields</p></li>
				<li>We can then add the <strong class="source-inline">email</strong> and <strong class="source-inline">phone</strong> fields to the initial state and mutations in <strong class="source-inline">src/store.js</strong> so that <strong class="source-inline">organization</strong> gets initialized, set during <strong class="source-inline">profileUpdate</strong>, and reset during <strong class="source-inline">profileClear</strong>:<p class="source-code">// imports &amp; Vuex setup</p><p class="source-code">export default new Vuex.Store({</p><p class="source-code">  state: {</p><p class="source-code">    formData: {</p><p class="source-code">      // rest of formData fields</p><p class="source-code">      email: '',</p><p class="source-code">      phone: '',</p><p class="source-code">    }</p><p class="source-code">  },</p><p class="source-code">  mutations: {</p><p class="source-code">    profileUpdate(state, payload) {</p><p class="source-code">      state.formData = {</p><p class="source-code">        // rest of formData fields</p><p class="source-code">        email: payload.email || '',</p><p class="source-code">        phone: payload.phone || '',</p><p class="source-code">      }</p><p class="source-code">    },</p><p class="source-code">    profileClear(state) {</p><p class="source-code">      state.formData = {</p><p class="source-code">        // rest of formData fields</p><p class="source-code">        email: '',</p><p class="source-code">        phone: '',</p><p class="source-code">      }</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">})</p></li>
				<li>We need to track <strong class="source-inline">email</strong> in the local state of the <strong class="source-inline">src/components/AppProfileForm.vue</strong> component using <strong class="source-inline">v-model</strong> and initialize it in the <strong class="source-inline">data()</strong> function:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;!-- rest of template --&gt;</p><p class="source-code">    &lt;div class="flex flex-col mt-2"&gt;</p><p class="source-code">      &lt;label class="flex text-gray-800 mb-2" for="email"&gt;Email</p><p class="source-code">      &lt;/label&gt;</p><p class="source-code">      &lt;input</p><p class="source-code">        id="email"</p><p class="source-code">        type="email"</p><p class="source-code">        name="email"</p><p class="source-code"><strong class="bold">        v-model="email"</strong></p><p class="source-code">        class="border-2 border-solid border-blue-200 rounded           px-2 py-1"</p><p class="source-code">      /&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">  &lt;!-- rest of template --&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  // rest of component</p><p class="source-code">  data() {</p><p class="source-code">    return {</p><p class="source-code">      // other data properties</p><p class="source-code">      email: ''</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>We need to track <strong class="source-inline">phone</strong> in the local state of the <strong class="source-inline">src/components/AppProfileForm.vue</strong> component using <strong class="source-inline">v-model</strong> and initialize it in the <strong class="source-inline">data()</strong> function:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;!-- rest of template --&gt;</p><p class="source-code">    &lt;div class="flex flex-col mt-2"&gt;</p><p class="source-code">      &lt;label class="flex text-gray-800 mb-2" for="phone"&gt;Phone         Number&lt;/label&gt;</p><p class="source-code">      &lt;input</p><p class="source-code">        id="phone"</p><p class="source-code">        type="tel"</p><p class="source-code">        name="phone"</p><p class="source-code"><strong class="bold">        v-model="phone"</strong></p><p class="source-code">        class="border-2 border-solid border-blue-200 rounded           px-2 py-1"</p><p class="source-code">      /&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">  &lt;!-- rest of template --&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  // rest of component</p><p class="source-code">  data() {</p><p class="source-code">    return {</p><p class="source-code">      // other data properties</p><p class="source-code">      phone: ''</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>For the payload of the mutation to contain <strong class="source-inline">email</strong> and <strong class="source-inline">phone</strong>, we'll need to add it to the <strong class="source-inline">$store.commit('profileUpdate')</strong> payload. We'll also want to reset it on the form when a component triggers a <strong class="source-inline">profileClear</strong> mutation:<p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  // rest of component</p><p class="source-code">  methods: {</p><p class="source-code">    submitForm() {</p><p class="source-code">      this.$store.commit('profileUpdate', {</p><p class="source-code">        // rest of payload</p><p class="source-code">        email: this.email,</p><p class="source-code">        phone: this.phone</p><p class="source-code">      })</p><p class="source-code">    },</p><p class="source-code">    resetProfileForm() {</p><p class="source-code">      // other resets</p><p class="source-code">      this.email = ''</p><p class="source-code">      this.phone = ''</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>For <strong class="source-inline">email</strong> to display, we need to render it in <strong class="source-inline">src/components/AppProfileDisplay.vue</strong> using a conditional paragraph (to hide the <strong class="source-inline">Email</strong> label when there is no email set):<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;!-- rest of template --&gt;</p><p class="source-code">    &lt;p class="mt-2" v-if="formData.email"&gt;</p><p class="source-code">      Email: {{ formData.email }}</p><p class="source-code">    &lt;/p&gt;</p><p class="source-code">  &lt;!-- rest of template --&gt;</p><p class="source-code">&lt;/template&gt;</p></li>
				<li>For <strong class="source-inline">phone</strong> to display, we need to render it in <strong class="source-inline">src/components/AppProfileDisplay.vue</strong> using a conditional span (to hide the <strong class="source-inline">Phone Number</strong> label when there is no phone set):<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;!-- rest of template --&gt;</p><p class="source-code">    &lt;p class="mt-2" v-if="formData.phone"&gt;</p><p class="source-code">      Phone Number: {{ formData.phone }}</p><p class="source-code">    &lt;/p&gt;</p><p class="source-code">  &lt;!-- rest of template --&gt;</p><p class="source-code">&lt;/template&gt;</p><p>The application should look as follows when the form is filled out and submitted:</p><div id="_idContainer482" class="IMG---Figure"><img src="image/B15218_08_36.jpg" alt="Figure 8.36: Application with Email and Phone Number fields&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 8.36: Application with Email and Phone Number fields</p>
			<p>We have now seen how to add new fields to a Vuex-managed application. Next, we will see how to decide whether to put something into global or local state.</p>
			<h1 id="_idParaDest-303"><a id="_idTextAnchor398"/>9. Working with Vuex – State, Getters, Actions, and Mutations</h1>
			<h2 id="_idParaDest-304"><a id="_idTextAnchor399"/>Activity 9.01: Creating a Simple Shopping Cart and Price Calculator</h2>
			<p><strong class="bold">Solution</strong>:</p>
			<p>Perform the following steps to complete the activity:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the code files for this activity, refer to <a href="https://packt.live/2KpvBvQ">https://packt.live/2KpvBvQ</a>.</p>
			<ol>
				<li value="1">Create a new Vue application with Vuex support via the CLI.</li>
				<li>Add the products and empty <strong class="source-inline">cart</strong> to the store located in <strong class="source-inline">store/index.js</strong>. Note that the product names and prices are arbitrary:<p class="source-code">  state: {</p><p class="source-code">    products: [</p><p class="source-code">      { name: "Widgets", price: 10 },</p><p class="source-code">      { name: "Doodads", price: 8 },</p><p class="source-code">      { name: "Roundtuits", price: 12 },</p><p class="source-code">      { name: "Fluff", price: 4 },</p><p class="source-code">      { name: "Goobers", price: 7 }</p><p class="source-code">    ],</p><p class="source-code">    cart: [</p><p class="source-code">    ]</p></li>
				<li>Create a new <strong class="source-inline">Products</strong> component (<strong class="source-inline">components/Products.vue</strong>) that iterates over each product and includes the name and price for each product. It will also include buttons to add or remove items from the cart:<p class="source-code">    &lt;h2&gt;Products&lt;/h2&gt;</p><p class="source-code">    &lt;table&gt;</p><p class="source-code">      &lt;thead&gt;</p><p class="source-code">        &lt;tr&gt;</p><p class="source-code">          &lt;th&gt;Name&lt;/th&gt;</p><p class="source-code">          &lt;th&gt;Price&lt;/th&gt;</p><p class="source-code">          &lt;th&gt;&amp;nbsp;&lt;/th&gt;</p><p class="source-code">        &lt;/tr&gt;</p><p class="source-code">      &lt;/thead&gt;</p><p class="source-code">      &lt;tbody&gt;</p><p class="source-code">        &lt;tr v-for="(product, idx) in products" :key="idx"&gt;</p><p class="source-code">          &lt;td&gt;{{ product.name }}&lt;/td&gt;</p><p class="source-code">          &lt;td&gt;{{ product.price  }}&lt;/td&gt;</p><p class="source-code">          &lt;td&gt;</p><p class="source-code">            &lt;button @click="addToCart(product)"&gt;Add to Cart               &lt;/button&gt; </p><p class="source-code">            &lt;button @click="removeFromCart(product)"&gt;Remove from               Cart&lt;/button&gt;</p><p class="source-code">          &lt;/td&gt;</p><p class="source-code">        &lt;/tr&gt;</p><p class="source-code">      &lt;/tbody&gt;</p><p class="source-code">    &lt;/table&gt;</p></li>
				<li>In order for products to be used without prepending <strong class="source-inline">$store</strong>, include <strong class="source-inline">mapState</strong> and define its use within the <strong class="source-inline">computed</strong> property of the <strong class="source-inline">Products</strong> component:<p class="source-code">import { mapState } from 'vuex';</p><p class="source-code">export default {</p><p class="source-code">  name: 'Products',</p><p class="source-code">  computed: mapState(['products']),</p></li>
				<li>Next include the methods for adding and removing items from the cart. This will simply call the mutations in the store:<p class="source-code">  methods: {</p><p class="source-code">    addToCart(product) {</p><p class="source-code">      this.$store.commit('addToCart', product);</p><p class="source-code">    },</p><p class="source-code">    removeFromCart(product) {</p><p class="source-code">      this.$store.commit('removeFromCart', product);</p><p class="source-code">    }</p><p class="source-code">  }</p></li>
				<li>Define your mutations to handle working with the cart in the <strong class="source-inline">store/index.js</strong> file. When adding a new item to the cart, you first need to see if it was previously added and if so, simply increment the quantity. When removing items from the cart, if the quantity hits 0, the item should be removed completely:<p class="source-code">  mutations: {</p><p class="source-code">    addToCart(state, product) {</p><p class="source-code">      let index = state.cart.findIndex(p =&gt; p.name ===         product.name);</p><p class="source-code">      if(index !== -1) {</p><p class="source-code">        state.cart[index].quantity++;</p><p class="source-code">      } else {</p><p class="source-code">        state.cart.push({ name: product.name, quantity: 1});</p><p class="source-code">      }</p><p class="source-code">    },</p><p class="source-code">    removeFromCart(state, product) {</p><p class="source-code">      let index = state.cart.findIndex(p =&gt; p.name ===         product.name);</p><p class="source-code">      if(index !== -1) {</p><p class="source-code">        state.cart[index].quantity--;</p><p class="source-code">        if(state.cart[index].quantity === 0) state.cart.splice           (index, 1);</p><p class="source-code">      }</p><p class="source-code">    }</p></li>
				<li>Define a <strong class="source-inline">Cart</strong> component (<strong class="source-inline">components/Cart.vue</strong>) that iterates over the cart and shows the quantity of each item:<p class="source-code">    &lt;h2&gt;Cart&lt;/h2&gt;</p><p class="source-code">    &lt;table&gt;</p><p class="source-code">      &lt;thead&gt;</p><p class="source-code">        &lt;tr&gt;</p><p class="source-code">          &lt;th&gt;Name&lt;/th&gt;</p><p class="source-code">          &lt;th&gt;Quantity&lt;/th&gt;</p><p class="source-code">        &lt;/tr&gt;</p><p class="source-code">      &lt;/thead&gt;</p><p class="source-code">      &lt;tbody&gt;</p><p class="source-code">        &lt;tr v-for="(product, idx) in cart" :key="idx"&gt;</p><p class="source-code">          &lt;td&gt;{{ product.name }}&lt;/td&gt;</p><p class="source-code">          &lt;td&gt;{{ product.quantity  }}&lt;/td&gt;</p><p class="source-code">        &lt;/tr&gt;</p><p class="source-code">      &lt;/tbody&gt;</p><p class="source-code">    &lt;/table&gt;</p></li>
				<li>As with the previous component, add <strong class="source-inline">mapState</strong> and alias the cart:<p class="source-code">import { mapState } from 'vuex';</p><p class="source-code">export default {</p><p class="source-code">  name: 'Cart',</p><p class="source-code">  computed: mapState(['cart'])</p><p class="source-code">}</p></li>
				<li>Define the final component, <strong class="source-inline">Checkout</strong> (<strong class="source-inline">components/Checkout.vue</strong>), and have it display a property named <strong class="source-inline">cartTotal</strong>. This will be defined via a getter that will be created in the store:<p class="source-code">&lt;h2&gt;Checkout&lt;/h2&gt;</p><p class="source-code">Your total is ${{ cartTotal }}.</p></li>
				<li>Map the getter in the script block:<p class="source-code">import { mapGetters } from 'vuex';</p><p class="source-code">export default {</p><p class="source-code">  name: 'Cart',</p><p class="source-code">  computed: mapGetters(['cartTotal']),</p></li>
				<li>Add a checkout button. It should only show up when there is a total and should run a method named <strong class="source-inline">checkout</strong>:<p class="source-code">    &lt;button v-show="cartTotal &gt; 0" @click="checkout"&gt;Checkout       &lt;/button&gt;</p></li>
				<li>Define <strong class="source-inline">checkout</strong> to simply alert the user:<p class="source-code">  methods: {</p><p class="source-code">    checkout() {</p><p class="source-code">        alert('Checkout process!');</p><p class="source-code">    }</p><p class="source-code">  }</p></li>
				<li>Back in the Vuex store, define the getter for <strong class="source-inline">cartTotal</strong>. It needs to iterate over the cart and determine the sum by multiplying price by quantity:<p class="source-code">  getters: {</p><p class="source-code">    cartTotal(state) {</p><p class="source-code">      return state.cart.reduce((total, item) =&gt; {</p><p class="source-code">        let product = state.products.find(p =&gt; p.name ===           item.name);</p><p class="source-code">        return total + (product.price * item.quantity);</p><p class="source-code">      }, 0);</p><p class="source-code">    }</p><p class="source-code">  },</p></li>
				<li>Use all three components in the main <strong class="source-inline">App.vue</strong> component:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div id="app"&gt;</p><p class="source-code">    &lt;Products /&gt;</p><p class="source-code">    &lt;Cart /&gt;</p><p class="source-code">    &lt;Checkout /&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">import Products from './components/Products.vue'</p><p class="source-code">import Cart from './components/Cart.vue'</p><p class="source-code">import Checkout from './components/Checkout.vue'</p><p class="source-code">export default {</p><p class="source-code">  name: 'app',</p><p class="source-code">  components: {</p><p class="source-code">    Products, Cart, Checkout</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p><p>Start your application as you have done before (<strong class="source-inline">npm run serve</strong>) and open the URL in your browser. You should get the following output initially, showing an empty cart:</p><div id="_idContainer483" class="IMG---Figure"><img src="image/B15218_09_09.jpg" alt="Figure 9.9: Initial display of the cart&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 9.9: Initial display of the cart</p>
			<p>As you add and remove items, you'll see the cart and totals update in real time:</p>
			<div>
				<div id="_idContainer484" class="IMG---Figure">
					<img src="image/B15218_09_10.jpg" alt="Figure 9.10: The cart with items of multiple quantities added&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.10: The cart with items of multiple quantities added</p>
			<p>The preceding figure displays the products and their prices, along with a cart containing multiple quantities of different products and the final checkout amount. You've now got a fully built, albeit simple, e-commerce cart product driven by Vue and Vuex.</p>
			<h1 id="_idParaDest-305"><a id="_idTextAnchor400"/>10. Working with Vuex – Fetching Remote Data</h1>
			<h2 id="_idParaDest-306"><a id="_idTextAnchor401"/>Activity 10.01: Using Axios and Vuex with Authentication</h2>
			<p><strong class="bold">Solution:</strong></p>
			<p>Perform the following steps to complete the activity.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the code files for this activity, refer to <a href="https://packt.live/3kVox6M">https://packt.live/3kVox6M</a>.</p>
			<ol>
				<li value="1">Use the CLI to scaffold a new application and be sure to enable both Vuex and Vue Router. When done, then use <strong class="source-inline">npm</strong> to install <strong class="source-inline">Axios</strong>. Now that you have got the app scaffolded, let's begin building it. First, open <strong class="source-inline">App.vue</strong>, the core component in the application, and modify it so that the entire template is the view:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div id="app"&gt;</p><p class="source-code">    &lt;router-view/&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p></li>
				<li>By default, the CLI will scaffold two <strong class="source-inline">views</strong>: <strong class="source-inline">Home</strong> and <strong class="source-inline">About</strong>. We are going to change <strong class="source-inline">About</strong> to be the view that displays cats, but for now, open <strong class="source-inline">Home.vue</strong> and add the login form. Use a button to run a method to perform the (fake) login:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div&gt;</p><p class="source-code">    &lt;h2&gt;Login&lt;/h2&gt;</p><p class="source-code">    &lt;form&gt;</p><p class="source-code">      &lt;div&gt;</p><p class="source-code">        &lt;label for="username"&gt;Username: &lt;/label&gt;</p><p class="source-code">        &lt;input type="text" id="username" v-model="username"           required&gt;</p><p class="source-code">      &lt;/div&gt;</p><p class="source-code">      &lt;div&gt;</p><p class="source-code">        &lt;label for="password"&gt;Password: &lt;/label&gt;</p><p class="source-code">        &lt;input type="password" id="password" v-model="password"           required&gt;</p><p class="source-code">      &lt;/div&gt;</p><p class="source-code">      &lt;div&gt;</p><p class="source-code">        &lt;input type="submit" @click.prevent="login" value=          "Log In"&gt;</p><p class="source-code">      &lt;/div&gt;</p><p class="source-code">    &lt;/form&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p></li>
				<li>Add the <strong class="source-inline">data</strong> for the login form and a <strong class="source-inline">handler</strong> for the login button. This will then fire off a dispatch to the store. On a successful login (and it will always be successful), <strong class="source-inline">$router.replace</strong> is used to navigate to the next page. This is done instead of <strong class="source-inline">$router.go</strong> so that the user cannot hit their back button to return to the login form:<p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  name: 'home',</p><p class="source-code">  data() {</p><p class="source-code">    return {</p><p class="source-code">      username:'',</p><p class="source-code">      password:''</p><p class="source-code">    }</p><p class="source-code">  },</p><p class="source-code">  methods: {</p><p class="source-code">    async login() {</p><p class="source-code">      let response = await this.$store.dispatch('login',</p><p class="source-code">      { username:this.username,</p><p class="source-code">        password:this.password</p><p class="source-code">      });</p><p class="source-code">      if(response) {</p><p class="source-code">        this.$router.replace('cats');</p><p class="source-code">      } else {</p><p class="source-code">        // handle a bad login here..</p><p class="source-code">      }</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>Now let's build the <strong class="source-inline">Cats</strong> component in <strong class="source-inline">views/Cats.vue</strong>. This will simply iterate over the cats from the store and dispatch a call to the store to load them:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div&gt;</p><p class="source-code">    &lt;h2&gt;Cats&lt;/h2&gt;</p><p class="source-code">    &lt;ul&gt;</p><p class="source-code">    &lt;li v-for="(cat,idx) in cats" :key="idx"&gt;</p><p class="source-code">      {{cat.name}} is {{cat.gender}}</p><p class="source-code">    &lt;/li&gt;</p><p class="source-code">    &lt;/ul&gt;  </p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">import { mapState } from 'vuex';</p><p class="source-code">export default {</p><p class="source-code">  created() {</p><p class="source-code">    this.$store.dispatch('loadCats');</p><p class="source-code">  },</p><p class="source-code">  computed: {</p><p class="source-code">    ...mapState(["cats"])</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>Now build the Vuex store by editing <strong class="source-inline">store/index.js</strong>. Begin by importing Vuex and defining constants for the two endpoints. Remember that we are <em class="italic">faking</em> a real API here, so the endpoints just return static JSON:<p class="source-code">import Vue from 'vue'</p><p class="source-code">import Vuex from 'vuex'</p><p class="source-code">Vue.use(Vuex)</p><p class="source-code">import axios from 'axios';</p><p class="source-code">const LOGIN_URL = 'https://api.jsonbin.io/b/  5debc045bc5ffd04009563cd';</p><p class="source-code">const CATS_URL = 'https://api.jsonbin.io/b/  5debc16dcb4ac6042075d594';</p></li>
				<li>The store needs to keep two things: the authentication <strong class="source-inline">token</strong> and <strong class="source-inline">cats</strong>. Set up the <strong class="source-inline">state</strong> and define <strong class="source-inline">mutations</strong> for them:<p class="source-code">export default new Vuex.Store({</p><p class="source-code">  state: {</p><p class="source-code">    token:'',</p><p class="source-code">    cats:[]</p><p class="source-code">  },</p><p class="source-code">  mutations: {</p><p class="source-code">    setCats(state, cats) {</p><p class="source-code">      state.cats = cats;</p><p class="source-code">    },</p><p class="source-code">    setToken(state, t) {</p><p class="source-code">      state.token = t;</p><p class="source-code">    }</p><p class="source-code">  },</p></li>
				<li>Now add the <strong class="source-inline">actions</strong>. The login action stores the result as a <strong class="source-inline">token</strong> and the <strong class="source-inline">cats</strong> action passes the <strong class="source-inline">token</strong> as an <strong class="source-inline">authorization</strong> header:<p class="source-code">  actions: {</p><p class="source-code">    loadCats(context) {</p><p class="source-code">      axios.get(CATS_URL,</p><p class="source-code">        {</p><p class="source-code">          headers: {</p><p class="source-code">            'Authorization': 'bearer '+context.state.token</p><p class="source-code">          }</p><p class="source-code">        })</p><p class="source-code">      .then(res =&gt; {</p><p class="source-code">        context.commit('setCats', res.data);</p><p class="source-code">      })</p><p class="source-code">      .catch(error =&gt; {</p><p class="source-code">        console.error(error);</p><p class="source-code">      });</p><p class="source-code">    },</p><p class="source-code">    async login(context, credentials) {</p><p class="source-code">      return axios.get(LOGIN_URL, {</p><p class="source-code">        params:{</p><p class="source-code">          username: credentials.username,</p><p class="source-code">          password: credentials.password</p><p class="source-code">        }</p><p class="source-code">      })</p><p class="source-code">      .then(res =&gt; {</p><p class="source-code">        context.commit('setToken', res.data.token);</p><p class="source-code">        return true;</p><p class="source-code">      })</p><p class="source-code">      .catch(error =&gt; {</p><p class="source-code">        console.error(error);</p><p class="source-code">      });  </p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">})</p></li>
				<li>The final piece of the application is the router, and there is a pretty interesting aspect to it. Think about the <strong class="source-inline">cats</strong> page. What happens if a user goes to that page first? With no token, the call to the endpoint will fail to return valid data. (Again, in a <em class="italic">real</em> server, that is.) Luckily, Vue Router provides a very simple way to handle this—route guards. Make use of <strong class="source-inline">beforeEnter</strong> to handle this call in the <strong class="source-inline">cats</strong> route. Edit your <strong class="source-inline">router/index.js</strong> file to look like the following code:<p class="source-code">import Vue from 'vue'</p><p class="source-code">import VueRouter from 'vue-router'</p><p class="source-code">import Home from '../views/Home.vue'</p><p class="source-code">import store from '../store';</p><p class="source-code">Vue.use(VueRouter)</p><p class="source-code">const routes = [</p><p class="source-code">  {</p><p class="source-code">    path: '/',</p><p class="source-code">    name: 'home',</p><p class="source-code">    component: Home</p><p class="source-code">  },</p><p class="source-code">  {</p><p class="source-code">    path: '/cats',</p><p class="source-code">    name: 'cats',</p><p class="source-code">    component: () =&gt; import(/* webpackChunkName: "cats" */ '../views/Cats.vue'),</p><p class="source-code">    beforeEnter: (to, from, next) =&gt; {</p><p class="source-code">      if(!store.state.token) {</p><p class="source-code">        next('/');</p><p class="source-code">      }</p><p class="source-code">      next();</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">]</p><p class="source-code">const router = new VueRouter({</p><p class="source-code">  mode: 'history',</p><p class="source-code">  base: process.env.BASE_URL,</p><p class="source-code">  routes</p><p class="source-code">})</p><p class="source-code">export default router</p></li>
				<li>Start the application with <strong class="source-inline">npm run serve</strong>, copy the URL to your browser, and you should get the following output initially:<div id="_idContainer485" class="IMG---Figure"><img src="image/B15218_10_08.jpg" alt="Figure 10.8: Initial login screen&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 10.8: Initial login screen</p>
			<p>After logging in, you will see the data displayed as in the following screenshot:</p>
			<div>
				<div id="_idContainer486" class="IMG---Figure">
					<img src="image/B15218_10_09.jpg" alt="Figure 10.9: Successfully displaying the data after login&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.9: Successfully displaying the data after login</p>
			<p>In this activity, you have seen what an authentication system would look like when using Vuex and <strong class="source-inline">Axios</strong>. While the backend was fake, the code used here could easily be connected to a real authentication system.</p>
			<h1 id="_idParaDest-307"><a id="_idTextAnchor402"/>11. Working with Vuex – Organizing Larger Stores</h1>
			<h2 id="_idParaDest-308"><a id="_idTextAnchor403"/>Activity 11.01: Simplifying a Vuex Store</h2>
			<p><strong class="bold">Solution:</strong></p>
			<p>Perform the following steps to complete the activity.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the initial code file for this activity, visit <a href="https://packt.live/3kaqBHH">https://packt.live/3kaqBHH</a>.</p>
			<ol>
				<li value="1">Begin by creating a new file, <strong class="source-inline">src/store/state.js</strong>, that will store the state values for everything but the <strong class="source-inline">cat</strong> object:<p class="source-code">export default {</p><p class="source-code">    name:'Lindy',</p><p class="source-code">    job:'tank',</p><p class="source-code">    favoriteColor:'blue',</p><p class="source-code">    favoriteAnimal:'cat'</p><p class="source-code">}</p></li>
				<li>Make a new file, <strong class="source-inline">src/store/getters.js</strong>, and move the getter for <strong class="source-inline">desiredPet</strong> into it:<p class="source-code">export default {</p><p class="source-code">    desiredPet(state) {</p><p class="source-code">        return state.favoriteColor + ' ' + state.favoriteAnimal;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Next, make <strong class="source-inline">src/store/mutations.js</strong> and copy over the <strong class="source-inline">mutations</strong> not related to the cat name:<p class="source-code">export default {</p><p class="source-code">  setName(state, name) {</p><p class="source-code">    state.name = name;</p><p class="source-code">  },</p><p class="source-code">  setJob(state, job) {</p><p class="source-code">    state.job = job;</p><p class="source-code">  },</p><p class="source-code">  setFavoriteColor(state, color) {</p><p class="source-code">    state.color = color;</p><p class="source-code">  },</p><p class="source-code">  setFavoriteAnimal(state, animal) {</p><p class="source-code">    state.animal = animal;</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>Update the store (<strong class="source-inline">src/store/index.js</strong>) file to import the new files:<p class="source-code">import state from './state.js';</p><p class="source-code">import getters from './getters.js';</p><p class="source-code">import mutations from './mutations.js';</p></li>
				<li>Edit the existing <strong class="source-inline">state</strong>, <strong class="source-inline">mutations</strong>, and <strong class="source-inline">getters</strong> block to use the included values:<p class="source-code">export default new Vuex.Store({</p><p class="source-code">  state,</p><p class="source-code">  getters, </p><p class="source-code">  mutations, </p></li>
				<li>Now move the cat-related values into the <strong class="source-inline">modules</strong> block of the store. Create a <strong class="source-inline">state</strong>, <strong class="source-inline">getters</strong>, and <strong class="source-inline">mutations</strong> block and move all the values over, updating them to refer to the state values, not <strong class="source-inline">state.cat</strong>:<p class="source-code">    cat: {</p><p class="source-code">        state: {</p><p class="source-code">          name:'Cracker',</p><p class="source-code">          gender:'male',</p><p class="source-code">          job:'annoyer'  </p><p class="source-code">        },</p><p class="source-code">        getters: {</p><p class="source-code">          petDescription(state) {</p><p class="source-code">            return state.name + ' is a ' + state.gender + </p><p class="source-code">            ' ' + state.job +  ' cat.';</p><p class="source-code">          }</p><p class="source-code">        },</p><p class="source-code">        mutations: {</p><p class="source-code">          setCatName(state, name) {</p><p class="source-code">            state.name = name;</p><p class="source-code">          },</p><p class="source-code">          setCatGender(state, gender) {</p><p class="source-code">            state.gender = gender;</p><p class="source-code">        },</p><p class="source-code">          setCatJob(state, job) {</p><p class="source-code">            state.job = job;</p><p class="source-code">          }</p><p class="source-code">        }</p><p class="source-code">    }</p></li>
				<li>Run the application and confirm that the <strong class="source-inline">App.vue</strong> component continues to work as it did before.<p>Your output will be as follows:</p><div id="_idContainer487" class="IMG---Figure"><img src="image/B15218_11_04.jpg" alt="Figure 11.4: Final output of the activity&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 11.4: Final output of the activity</p>
			<p>You now have a Vuex store modified to be more approachable, easier to edit, and simpler to debug in the future. To access the solution for this activity, visit <a href="https://packt.live/3l4Lg0x">https://packt.live/3l4Lg0x</a>.</p>
			<h1 id="_idParaDest-309"><a id="_idTextAnchor404"/>12. Unit Testing</h1>
			<h2 id="_idParaDest-310"><a id="_idTextAnchor405"/>Activity 12.01: Adding a Simpl<a id="_idTextAnchor406"/>e Search by Title Page with Tests</h2>
			<p><strong class="bold">Solution:</strong></p>
			<p>Perform the following steps to complete the activity:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the code files for this activity, refer to <a href="https://packt.live/2UVF28c">https://packt.live/2UVF28c</a>.</p>
			<ol>
				<li value="1">Create the search form with an input and a button in a new file in <strong class="source-inline">src/components/SearchForm.vue</strong>:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;form class="flex flex-row m-auto mb-10"&gt;</p><p class="source-code">    &lt;input</p><p class="source-code">      placholder="Search"</p><p class="source-code">      class="bg-white focus:outline-none focus:shadow-outline         border</p><p class="source-code">      border-gray-300 rounded py-2 px-4 flex</p><p class="source-code">      appearance-none leading-normal"</p><p class="source-code">      type="text"</p><p class="source-code">    /&gt;</p><p class="source-code">    &lt;button</p><p class="source-code">      type="submit"</p><p class="source-code">      class="flex bg-blue-500 hover:bg-blue-700</p><p class="source-code">      text-white font-semibold font-sm hover:text-white         py-2 px-4 border</p><p class="source-code">      border-blue-500 hover:border-transparent rounded"</p><p class="source-code">    &gt;</p><p class="source-code">      Search</p><p class="source-code">    &lt;/button&gt;</p><p class="source-code">  &lt;/form&gt;</p><p class="source-code">&lt;/template&gt;</p></li>
				<li>We'll now get the form to display by importing, registering, and rendering it in <strong class="source-inline">src/App.vue</strong>:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;!-- rest of template --&gt;</p><p class="source-code">    &lt;div class="flex flex-col"&gt;</p><p class="source-code">      &lt;SearchForm /&gt;</p><p class="source-code">      &lt;!-- rest of template --&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">  &lt;!-- rest of template --&gt;</p><p class="source-code">&lt;/template&gt;</p></li>
				<li>We're now ready to add a snapshot test for the search form. In <strong class="source-inline">__tests__/SearchForm.test.js</strong>, we should add <strong class="source-inline">SearchForm should match expected HTML</strong>:<p class="source-code">import {render} from '@testing-library/vue'</p><p class="source-code">import SearchForm from '../src/components/SearchForm.vue'</p><p class="source-code">test('SearchForm should match expected HTML', () =&gt; {</p><p class="source-code">  const {html} = render(SearchForm)</p><p class="source-code">  expect(html()).toMatchSnapshot()</p><p class="source-code">})</p></li>
				<li>We want to track the contents of the search form input using <strong class="source-inline">v-model</strong> to two-way bind the <strong class="source-inline">searchTerm</strong> instance variable and the contents of the input:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;!-- rest of template --&gt;</p><p class="source-code">    &lt;input</p><p class="source-code">      v-model="searchTerm"</p><p class="source-code">      placholder="Search"</p><p class="source-code">      class="bg-white focus:outline-none focus:shadow-outline         border</p><p class="source-code">      border-gray-300 rounded py-2 px-4 flex</p><p class="source-code">      appearance-none leading-normal"</p><p class="source-code">      type="text"</p><p class="source-code">    /&gt;</p><p class="source-code">  &lt;!-- rest of template --&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  data() {</p><p class="source-code">    return {</p><p class="source-code">      searchTerm: ''</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>When the search form is submitted, we'll need to update the URL with the right parameter. This can be done with <strong class="source-inline">this.$router.push()</strong>. We will store the search in a <strong class="source-inline">q</strong> query parameter.<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;form</p><p class="source-code">    @submit="onSubmit()"</p><p class="source-code">    class="flex flex-row m-auto mb-10"</p><p class="source-code">  &gt;</p><p class="source-code">  &lt;!-- rest of template --&gt;</p><p class="source-code">  &lt;/form&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  // other properties</p><p class="source-code">  methods: {</p><p class="source-code">    onSubmit() {</p><p class="source-code">      this.$router.push({</p><p class="source-code">        path: '/'</p><p class="source-code">        query: {</p><p class="source-code">          q: this.searchTerm</p><p class="source-code">        }</p><p class="source-code">      })</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>We will want to reflect the state of the <strong class="source-inline">q</strong> query parameter in the search form input. Read <strong class="source-inline">q</strong> from <strong class="source-inline">this.$route.query</strong> and set it as the initial value for the <strong class="source-inline">searchTerm</strong> data field in the <strong class="source-inline">SearchForm</strong> component state:<p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  data() {</p><p class="source-code">    return {</p><p class="source-code">      searchTerm: this.$route.query.q || ''</p><p class="source-code">    }</p><p class="source-code">  },</p><p class="source-code">  // other properties</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>Next, we'll want to filter the posts passed to <strong class="source-inline">PostList</strong> on the home page. We'll use <strong class="source-inline">this.$route.query.q</strong> in a computed property that filters posts by their title. This new computed property will then be used instead of <strong class="source-inline">posts</strong> in <strong class="source-inline">src/App.vue</strong>:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;!-- rest of template --&gt;</p><p class="source-code">      &lt;router-view</p><p class="source-code">        :posts="relevantPosts"</p><p class="source-code">      /&gt;</p><p class="source-code">  &lt;!-- rest of template --&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  // other properties</p><p class="source-code">  computed: {</p><p class="source-code">    relevantPosts() {</p><p class="source-code">      const { q } = this.$route.query</p><p class="source-code">      if (!q) {</p><p class="source-code">        return this.posts</p><p class="source-code">      }</p><p class="source-code">      return this.posts.filter(</p><p class="source-code">        p =&gt; p.title.toLowerCase().includes(q.toLowerCase())</p><p class="source-code">      )</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>Next, we should add a test that changes the search query parameter and check that the app shows the right result. To do this, we can import <strong class="source-inline">src/App.vue</strong>, <strong class="source-inline">src/store.js</strong>, and <strong class="source-inline">src/router.js</strong>, and render the app with the store and the router. We can then update the search field contents by using the fact that the placeholder for the field is <strong class="source-inline">Search</strong>. Finally, we can submit the form by clicking the element where <strong class="source-inline">test id</strong> is <strong class="source-inline">Search</strong> (which is the <strong class="source-inline">search</strong> button):<p class="source-code">// imports and other tests</p><p class="source-code">test('SearchForm filter by keyword on submission',   async () =&gt; {</p><p class="source-code">  const {getByPlaceholderText, getByText, queryByText} =     render(App, {</p><p class="source-code">    router,</p><p class="source-code">    store</p><p class="source-code">  })</p><p class="source-code">  expect(queryByText('Migrating an AngularJS app to Vue.js')).    toBeTruthy()</p><p class="source-code">  expect(queryByText('Vue.js for React developers')).    toBeTruthy()</p><p class="source-code">  await fireEvent.update(getByPlaceholderText('Search'), 'react')</p><p class="source-code">  await fireEvent.click(getByText('Search'))</p><p class="source-code">  expect(queryByText('Vue.js for React developers')).    toBeTruthy()</p><p class="source-code">  expect(queryByText('Migrating an AngularJS app to Vue.js')).    toBeFalsy()</p><p class="source-code">})</p><p>We are now in a state where we have passing tests. The following screenshot shows this:</p><div id="_idContainer488" class="IMG---Figure"><img src="image/B15218_12_29.jpg" alt="Figure 12.29: Passing tests for routing&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 12.29: Passing tests for routing</p>
			<p>We have also got an application that is able to filter by search term, as follows:</p>
			<div>
				<div id="_idContainer489" class="IMG---Figure">
					<img src="image/B15218_12_30.jpg" alt="Figure 12.30: Searching for &quot;react&quot; filters posts relevant to that search term&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.30: Searching for "react" filters posts relevant to that search term</p>
			<p>We've seen how to create and test a Vue.js application with multiple pages, Vuex, and a slew of components.</p>
			<h1 id="_idParaDest-311"><a id="_idTextAnchor407"/>13. End-to-End Testing</h1>
			<h2 id="_idParaDest-312"><a id="_idTextAnchor408"/>Activity 13.01: Adding the Abili<a id="_idTextAnchor409"/>ty to Set a User's Email and Tests</h2>
			<p><strong class="bold">Solution:</strong></p>
			<p>Perform the following <a id="_idTextAnchor410"/>steps to complete the activity:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the code files for this activity, refer to <a href="https://packt.live/2IZP4To">https://packt.live/2IZP4To</a>.</p>
			<ol>
				<li value="1">In order to keep track of the email, we'll set it as a piece of reactive state in <strong class="source-inline">data()</strong> and add an email type input to the page, which will be two-way bound to <strong class="source-inline">email</strong> using <strong class="source-inline">v-model</strong>. We also add a label and the corresponding markup. Note that we'll have a <strong class="source-inline">data-test-id</strong> attribute on the email input set to <strong class="source-inline">"email-input"</strong>:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div id="app" class="p-10"&gt;</p><p class="source-code">    &lt;div class="flex flex-col"&gt;</p><p class="source-code">      &lt;!-- rest of template --&gt;</p><p class="source-code">      &lt;div class="flex flex-col mx-auto mb-4"&gt;</p><p class="source-code">        &lt;label</p><p class="source-code">          class="flex text-gray-700 text-sm font-bold mb-2"</p><p class="source-code">          for="email"</p><p class="source-code">        &gt;</p><p class="source-code">          Enter your email:</p><p class="source-code">        &lt;/label&gt;</p><p class="source-code">        &lt;input</p><p class="source-code">          v-model="email"</p><p class="source-code">          id="email"</p><p class="source-code">          type="email"</p><p class="source-code">          data-test-id="email-input"</p><p class="source-code">          class="flex shadow appearance-none border             rounded py-2 px-3 text-gray-700 leading-tight             focus:outline-none focus:shadow-outline"</p><p class="source-code">          required</p><p class="source-code">        /&gt;</p><p class="source-code">      &lt;/div&gt;</p><p class="source-code">      &lt;!-- rest of template --&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">// imports</p><p class="source-code">export default {</p><p class="source-code">  data() {</p><p class="source-code">    return {</p><p class="source-code">      email: '',</p><p class="source-code">      // other data properties</p><p class="source-code">    }</p><p class="source-code">  },</p><p class="source-code">  // other component properties</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>We'll now add a <strong class="source-inline">beforeEach</strong> hook to set up the Cypress mock server and stub out the <strong class="source-inline">GET</strong> comments (list) request. The comments list request should be aliased as <strong class="source-inline">getComments</strong>:<p class="source-code">describe('Email input', () =&gt; {</p><p class="source-code">  beforeEach(() =&gt; {</p><p class="source-code">    cy.server()</p><p class="source-code">    cy.route('GET', '**/comments', []).as('getComments')</p><p class="source-code">  })</p><p class="source-code">})</p></li>
				<li>We'll add our first test that checks whether typing into the email input works correctly. We'll go to the app, type an email, and check that what we typed is now the input value:<p class="source-code">describe('Email input', () =&gt; {</p><p class="source-code">  // setup</p><p class="source-code">  it('email input should work', () =&gt; {</p><p class="source-code">    cy.visit('/')</p><p class="source-code">    cy.get('[data-test-id="email-input"]')</p><p class="source-code">      .type('hugo@example.tld')</p><p class="source-code">      .should('have.value', 'hugo@example.tld')</p><p class="source-code">  })</p><p class="source-code">})</p><p>When run using the Cypress UI, we get the following passing test:</p><div id="_idContainer490" class="IMG---Figure"><img src="image/B15218_13_24.jpg" alt="Figure 13.24: Cypress running &quot;enter-email&quot; tests, with the email input test&#13;&#10;"/></div><p class="figure-caption">Figure 13.24: Cypress running "enter-email" tests, with the email input test</p></li>
				<li>The <strong class="source-inline">email</strong> property existing is a pre-requisite to adding comments, so we'll disable the <strong class="source-inline">add new comment</strong> button while <strong class="source-inline">email</strong> is empty (<strong class="source-inline">!email</strong>). We'll bind to the <strong class="source-inline">disabled</strong> attribute and toggle some classes based on whether or not the <strong class="source-inline">email</strong> field is populated:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div id="app" class="p-10"&gt;</p><p class="source-code">    &lt;div class="flex flex-col"&gt;</p><p class="source-code">      &lt;!-- rest of template --&gt;</p><p class="source-code">      &lt;button</p><p class="source-code">        @click="showEditor = !showEditor"</p><p class="source-code">        class="flex mx-auto bg-blue-500 hover:bg-blue-700           text-white font-bold py-2 px-4 rounded"</p><p class="source-code">        data-test-id="new-comment-button"</p><p class="source-code">        :disabled="!email"</p><p class="source-code">        :class="{ 'opacity-50 cursor-not-allowed' : !email }"</p><p class="source-code">      &gt;</p><p class="source-code">        Add a New Comment</p><p class="source-code">      &lt;/button&gt;</p><p class="source-code">      &lt;!-- rest of template --&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p></li>
				<li>With this new <strong class="source-inline">disable add new comment button while email is empty</strong> functionality, we should add a new E2E test. We'll load up the page and on initial load, we'll check that the <strong class="source-inline">email</strong> input is empty and that the <strong class="source-inline">new comment</strong> button is disabled. We'll then type an email into the email input field and check that the <strong class="source-inline">new comment</strong> button is now <em class="italic">not</em> disabled, which means it is enabled:<p class="source-code">describe('Email input', () =&gt; {</p><p class="source-code">  // setup &amp; other tests</p><p class="source-code">  it('add comment button should be disabled when no email',     () =&gt; {</p><p class="source-code">    cy.visit('/')</p><p class="source-code">    cy.get('[data-test-id="email-input"]')</p><p class="source-code">      .should('have.value', '')</p><p class="source-code">    cy.get('[data-test-id="new-comment-button"]')</p><p class="source-code">      .should('be.disabled')</p><p class="source-code">    cy.get('[data-test-id="email-input"]')</p><p class="source-code">      .type('hugo@example.tld')</p><p class="source-code">    </p><p class="source-code">    cy.get('[data-test-id="new-comment-button"]')</p><p class="source-code">      .should('not.be.disabled')</p><p class="source-code">  })</p><p class="source-code">})</p><p>The output from the test run after the updates is as follows:</p><div id="_idContainer491" class="IMG---Figure"><img src="image/B15218_13_25.jpg" alt="Figure 13.25: Cypress running &quot;enter-email&quot; tests, with the disabled &#13;&#10;add comment button test&#13;&#10;"/></div><p class="figure-caption">Figure 13.25: Cypress running "enter-email" tests, with the disabled add comment button test</p></li>
				<li>Now that we've got a way to capture the email, we should pass it to the backend API when making the POST comments call (that is, when submitting a new comment). In order to do this, we should modify the spot in <strong class="source-inline">methods.submitNewComment</strong> where <strong class="source-inline">email</strong> is hardcoded as <strong class="source-inline">evan@vuejs.org</strong>:<p class="source-code">&lt;script&gt;</p><p class="source-code">// imports</p><p class="source-code">export default {</p><p class="source-code">  // other component properties</p><p class="source-code">  methods: {</p><p class="source-code">    submitNewComment() {</p><p class="source-code">      // rest of method</p><p class="source-code">      fetch('https://jsonplaceholder.typicode.com/comments', {</p><p class="source-code">        // other fetch options</p><p class="source-code">        body: JSON.stringify({</p><p class="source-code">          email: this.email,</p><p class="source-code">          body: this.newComment</p><p class="source-code">        })</p><p class="source-code">      }).then(res =&gt; res.json())</p><p class="source-code">      // rest of promise chain</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>Now that we're using the email that's been input by the user, we should write an E2E test to check that it's being sent. We'll stub out the <strong class="source-inline">POST</strong> request, alias it to <strong class="source-inline">newComment</strong>, and send back an arbitrary value. We can then visit the page, fill out the email input, open the comment editor, fill that out, and submit it. We'll then wait on the <strong class="source-inline">newComment</strong> request and assert on the request body that the body and email are as they were when we completed them:<p class="source-code">describe('Email input', () =&gt; {</p><p class="source-code">  // setup &amp; other tests</p><p class="source-code">  it('when adding comment, it should be created with the     input email', () =&gt; {</p><p class="source-code">    cy.route('POST', '**/comments', {</p><p class="source-code">      body: 'My new comment',</p><p class="source-code">      email: 'hugo@example.tld'</p><p class="source-code">    }).as('newComment')</p><p class="source-code">    cy.visit('/')</p><p class="source-code">    cy.get('[data-test-id="email-input"]')</p><p class="source-code">      .type('hugo@example.tld')</p><p class="source-code">    cy.get('[data-test-id="new-comment-button"]')</p><p class="source-code">      .should('not.be.disabled')</p><p class="source-code">      .click()</p><p class="source-code">    </p><p class="source-code">    cy.get('[data-test-id="new-comment-editor"]')</p><p class="source-code">      .type('My new comment')</p><p class="source-code">    </p><p class="source-code">    cy.get('[data-test-id="new-comment-submit"]')</p><p class="source-code">      .should('not.be.disabled')</p><p class="source-code">      .click()</p><p class="source-code">    </p><p class="source-code">    cy.wait('@newComment')</p><p class="source-code">      .its('request.body')</p><p class="source-code">      .should('deep.equal', {</p><p class="source-code">        body: 'My new comment',</p><p class="source-code">        email: 'hugo@example.tld'</p><p class="source-code">      })</p><p class="source-code">  })</p><p class="source-code">})</p><p>When run using the Cypress UI, we get the following test run output:</p><div id="_idContainer492" class="IMG---Figure"><img src="image/B15218_13_26.jpg" alt="Figure 13.26: Cypress running &quot;enter-email&quot; tests, with the email input test&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 13.26: Cypress running "enter-email" tests, with the email input test</p>
			<p>We've now seen how to effectively build and test (with an E2E test) a Vue.js application with Cypress.</p>
			<h1 id="_idParaDest-313"><a id="_idTextAnchor411"/>14. Deploying Your Code to the Web</h1>
			<h2 id="_idParaDest-314"><a id="_idTextAnchor412"/>Activity 14.01: Adding CI/CD with G<a id="_idTextAnchor413"/>itLab to a Book Search App and Deploying to Amazon S3 and CloudFront</h2>
			<p><strong class="bold">Solution</strong></p>
			<p>Perform the following steps to complete the activity:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the code files for this activity, refer to <a href="https://packt.live/36ZecBT">https://packt.live/36ZecBT</a>.</p>
			<ol>
				<li value="1">To start, we'll want to run a production build locally. We can use the regular command used to build all Vue CLI projects for production. We'll also want to check that the relevant assets (JavaScript, CSS, and HTML) are generated correctly.<p>The production build command is <strong class="source-inline">npm run build</strong>, as seen in the following screenshot:</p><div id="_idContainer493" class="IMG---Figure"><img src="image/B15218_14_65.jpg" alt="Figure 14.65: The npm run build output for the initial book-search Vue CLI project&#13;&#10;"/></div><p class="figure-caption">Figure 14.65: The npm run build output for the initial book-search Vue CLI project</p><p>The <strong class="source-inline">npm run build</strong> command builds a <strong class="source-inline">dist</strong> directory with contents as in the following screenshot. It contains <strong class="source-inline">CSS</strong>, <strong class="source-inline">JavaScript</strong>, and <strong class="source-inline">HTML</strong> assets, as well as <strong class="source-inline">sourcemaps</strong> (<strong class="source-inline">.js.map</strong> files) and <strong class="source-inline">favicon</strong>:</p><div id="_idContainer494" class="IMG---Figure"><img src="image/B15218_14_66.jpg" alt="Figure 14.66: Sample contents of the dist folder (generated using the tree command) &#13;&#10;after a Vue CLI production build run&#13;&#10;"/></div><p class="figure-caption">Figure 14.66: Sample contents of the dist folder (generated using the tree command) after a Vue CLI production build run</p></li>
				<li>In order to run GitLab CI/CD, we will need a <strong class="source-inline">.gitlab-ci.yml</strong> file. We will add a job to<strong class="source-inline">.gitlab-ci.yml</strong> in which we run an install of the packages followed by the production build in a Node.js LTS Docker container, at the <strong class="source-inline">build</strong> stage. We'll also make sure to cache the output of the production build:<p class="source-code">build:</p><p class="source-code">  image: node:lts</p><p class="source-code">  stage: build</p><p class="source-code">  script:</p><p class="source-code">    - npm ci</p><p class="source-code">    - npm run build</p><p class="source-code">  cache:</p><p class="source-code">    key: $CI_COMMIT_REF_SLUG</p><p class="source-code">    paths:</p><p class="source-code">      - dist</p><p class="source-code">  artifacts:</p><p class="source-code">    expire_in: 1 week</p><p class="source-code">    paths:</p><p class="source-code">      - dist</p><p>Once we use <strong class="source-inline">git add .gitlab-ci.yml</strong> and commit and push the changes, we should see the following GitLab CI/CD pipeline run, which includes the <strong class="source-inline">build</strong> job in the running state:</p><div id="_idContainer495" class="IMG---Figure"><img src="image/B15218_14_67.jpg" alt="Figure 14.67: The GitLab CI/CD pipeline with the build job running&#13;&#10;"/></div><p class="figure-caption">Figure 14.67: The GitLab CI/CD pipeline with the build job running</p><p>The following screenshot displays the GitLab CI/CD pipeline with the <strong class="source-inline">build</strong> job completed successfully:</p><div id="_idContainer496" class="IMG---Figure"><img src="image/B15218_14_68.jpg" alt="Figure 14.68: The GitLab CI/CD pipeline with the build job passed&#13;&#10;"/></div><p class="figure-caption">Figure 14.68: The GitLab CI/CD pipeline with the build job passed</p></li>
				<li>Next, we will want to add a code quality job to the <strong class="source-inline">test</strong> stage on GitLab CI/CD (by updating <strong class="source-inline">.gitlab-ci.yml</strong>). We'll call the job <strong class="source-inline">lint</strong> and it will run an install of the dependencies as well as linting through the Vue CLI:<p class="source-code"># other jobs</p><p class="source-code">lint:</p><p class="source-code">  image: node:lts</p><p class="source-code">  stage: test</p><p class="source-code">  script:</p><p class="source-code">    - npm ci</p><p class="source-code">    - npm run lint</p><p>Once we use <strong class="source-inline">git add .gitlab-ci.yml</strong> and commit and push the changes, we should see the following GitLab CI/CD pipeline run, which includes the <strong class="source-inline">lint</strong> job in the running state:</p><div id="_idContainer497" class="IMG---Figure"><img src="image/B15218_14_69.jpg" alt="Figure 14.69: The GitLab CI/CD pipeline with the lint job running&#13;&#10;"/></div><p class="figure-caption">Figure 14.69: The GitLab CI/CD pipeline with the lint job running</p><p>The following screenshot displays the GitLab CI/CD pipeline with the <strong class="source-inline">lint</strong> job completed successfully:</p><div id="_idContainer498" class="IMG---Figure"><img src="image/B15218_14_70.jpg" alt="Figure 14.70: The GitLab CI/CD pipeline with the lint job passed&#13;&#10;"/></div><p class="figure-caption">Figure 14.70: The GitLab CI/CD pipeline with the lint job passed</p></li>
				<li>In order to deploy our application, we'll need to create a <strong class="source-inline">vue-workshop-book-search</strong> S3 bucket with public access enabled using the S3 console.<p>The S3 bucket creation page should look as shown in the following screenshots:</p><div id="_idContainer499" class="IMG---Figure"><img src="image/B15218_14_71.jpg" alt="Figure 14.71: The S3 bucket creation page with vue-workshop-book-search &#13;&#10;entered as the bucket name&#13;&#10;"/></div><p class="figure-caption">Figure 14.71: The S3 bucket creation page with vue-workshop-book-search entered as the bucket name</p><p><em class="italic">Figure 14.72</em> displays the S3 bucket creation page with the public access and disclaimer information:</p><div id="_idContainer500" class="IMG---Figure"><img src="image/B15218_14_72.jpg" alt="Figure 14.72: The S3 bucket creation page with public access enabled &#13;&#10;and the relevant disclaimer accepted&#13;&#10;"/></div><p class="figure-caption">Figure 14.72: The S3 bucket creation page with public access enabled and the relevant disclaimer accepted</p></li>
				<li>To access the S3 bucket contents over the web, we'll also need to configure it for web hosting. We can configure the web hosting property through the S3 console.<p>It should be configured as follows, with the index and error page set to <strong class="source-inline">index.html</strong>:</p><div id="_idContainer501" class="IMG---Figure"><img src="image/B15218_14_73.jpg" alt="Figure 14.73: The S3 bucket properties page with web hosting enabled and configured with the index and error page set to index.html&#13;&#10;"/></div><p class="figure-caption">Figure 14.73: The S3 bucket properties page with web hosting enabled and configured with the index and error page set to index.html</p></li>
				<li>For GitLab CI/CD to be able to create and update files on S3, we'll need to add the relevant AWS secrets to our GitLab repo CI/CD settings. The secrets are found in the AWS management console at the <strong class="source-inline">Username</strong> dropdown | <strong class="source-inline">My Security Credentials</strong> | <strong class="source-inline">Access keys</strong> (access key ID and secret access key) | <strong class="source-inline">Create New Access Key</strong> (or pick a key to reuse). The following screenshot displays the <strong class="source-inline">CI/CD Settings</strong> page:<div id="_idContainer502" class="IMG---Figure"><img src="image/B15218_14_74.jpg" alt="Figure 14.74: The GitLab CI/CD Settings page with the Variables section open&#13;&#10;"/></div><p class="figure-caption">Figure 14.74: The GitLab CI/CD Settings page with the Variables section open</p><p>Once the <strong class="source-inline">Expand</strong> button is clicked for the <strong class="source-inline">Variables</strong> section, we add the relevant AWS environment variables: <strong class="source-inline">AWS_ACCESS_KEY_ID</strong>, <strong class="source-inline">AWS_DEFAULT_REGION</strong>, and <strong class="source-inline">AWS_SECRET_ACCESS_KEY</strong>. The <strong class="source-inline">Variables</strong> section will then look as follows:</p><div id="_idContainer503" class="IMG---Figure"><img src="image/B15218_14_75.jpg" alt="Figure 14.75: The GitLab CI/CD Settings page with the required AWS environment &#13;&#10;variables added (with values masked)&#13;&#10;"/></div><p class="figure-caption">Figure 14.75: The GitLab CI/CD Settings page with the required AWS environment variables added (with values masked)</p></li>
				<li>Next, we will want to add a <strong class="source-inline">deploy</strong> job to the <strong class="source-inline">deploy</strong> stage on GitLab CI/CD (by updating <strong class="source-inline">.gitlab-ci.yml</strong>). We will call the job <strong class="source-inline">deploy</strong>; it will need to download the <strong class="source-inline">awscli</strong> <strong class="source-inline">pip</strong> package (Python package manager), which means the Docker image that makes the most sense is <strong class="source-inline">python:latest</strong>. The <strong class="source-inline">deploy</strong> job will load the built production build from cache, install <strong class="source-inline">awscli</strong> with <strong class="source-inline">pip</strong>, and run <strong class="source-inline">aws s3 sync &lt;build_directory&gt; s3://&lt;s3-bucket-name&gt; --acl=public-read</strong>:<p class="source-code"># other jobs</p><p class="source-code">deploy:</p><p class="source-code">  image: python:latest</p><p class="source-code">  stage: deploy</p><p class="source-code">  cache:</p><p class="source-code">    key: $CI_COMMIT_REF_SLUG</p><p class="source-code">    paths:</p><p class="source-code">      - dist</p><p class="source-code">  before_script:</p><p class="source-code">    - pip install awscli</p><p class="source-code">  script:</p><p class="source-code">    - aws s3 sync ./dist s3://vue-workshop-book-search       --acl=public-read</p><p>Once we use <strong class="source-inline">git add .gitlab-ci.yml</strong> and commit and push the changes, we should see the following GitLab CI/CD pipeline run, which includes the <strong class="source-inline">deploy</strong> job in the running state:</p><div id="_idContainer504" class="IMG---Figure"><img src="image/B15218_14_76.jpg" alt="Figure 14.76: The GitLab CI/CD pipeline with the deploy job running&#13;&#10;"/></div><p class="figure-caption">Figure 14.76: The GitLab CI/CD pipeline with the deploy job running</p><p><em class="italic">Figure 14.77</em> displays the GitLab CI/CD pipeline with the <strong class="source-inline">deploy</strong> job completed successfully:</p><div id="_idContainer505" class="IMG---Figure"><img src="image/B15218_14_77.jpg" alt="Figure 14.77: The GitLab CI/CD pipeline with the deploy job passed&#13;&#10;"/></div><p class="figure-caption">Figure 14.77: The GitLab CI/CD pipeline with the deploy job passed</p><p>Once the pipeline completes, our application should be available through the S3 web endpoint, as in the following screenshot:</p><div id="_idContainer506" class="IMG---Figure"><img src="image/B15218_14_78.jpg" alt="Figure 14.78: Book search accessed through the S3 web endpoint URL&#13;&#10;"/></div><p class="figure-caption">Figure 14.78: Book search accessed through the S3 web endpoint URL</p></li>
				<li>Finally, we'll create a CloudFront distribution that acts as a CDN for the S3 web endpoint. We'll want to set <strong class="source-inline">origin</strong> to the origin of our S3 bucket's web endpoint and also make sure that we've enabled <strong class="source-inline">Redirect HTTP to HTTPS</strong>:</li>
				<li><div id="_idContainer507" class="IMG---Figure"><img src="image/B15218_14_79.jpg" alt="Figure 14.79: The CloudFront Distribution creation page with the origin &#13;&#10;domain set to the S3 bucket &#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 14.79: The CloudFront Distribution creation page with the origin domain set to the S3 bucket </p>
			<p>Once the CloudFront distribution is deployed, our application should be accessible through the CloudFront distribution's domain, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer508" class="IMG---Figure">
					<img src="image/B15218_14_80.jpg" alt="Figure 14.80: Book search accessed through the CloudFront domain, &#13;&#10;displaying results for a harry potter query&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.80: Book search accessed through the CloudFront domain, displaying results for a harry potter query</p>
			<p>With that, we've used GitLab CI/CD to add CI/CD to an existing Vue CLI project. We then deployed it to S3 using CloudFront as our CDN.</p>
		</div>
	</body></html>