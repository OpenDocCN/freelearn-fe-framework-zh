- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction to TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we learned in the previous chapter, when we built our very first Angular
    application, the code of an Angular project is written in TypeScript. Writing
    in TypeScript and leveraging its static typing gives us a remarkable advantage
    over other scripting languages. This chapter is not a thorough overview of the
    TypeScript language. Instead, we’ll focus on the core elements that will be useful
    for this book. As we will see very soon, having sound knowledge of these mechanisms
    is paramount to understanding how dependency injection works in Angular.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript essentials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is TypeScript?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with TypeScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will first refresh our knowledge of JavaScript by revisiting some essential
    features related to TypeScript, such as functions and classes. We will then investigate
    the background of TypeScript and the rationale behind its creation. We will also
    learn how to code and execute TypeScript code. We will emphasize the typing system,
    which is the main advantage of TypeScript, and learn how to use it to create basic
    types and interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**GitHub** : [https://github.com/PacktPublishing/Learning-Angular-Fifth-Edition/tree/main/ch02](https://github.com/PacktPublishing/Learning-Angular-Fifth-Edition/tree/main/ch02
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Node.js** : [https://nodejs.org](https://nodejs.org )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Git** : [https://git-scm.com](https://git-scm.com )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VSCode** : [https://code.visualstudio.com](https://code.visualstudio.com
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript essentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JavaScript is a programming language that contains many features for building
    web applications. In this section, we will revisit and refresh our knowledge of
    some of the most basic ones as they are directly correlated with TypeScript and
    Angular development. TypeScript is a syntactic superset of JavaScript, meaning
    that it adds features such as types, interfaces, and generics. We will look at
    the following JavaScript features in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: Variable declaration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrow functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional chaining
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nullish coalescing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can run all the code samples in this section in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Enter the code in a browser console window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type the code in a JavaScript file and use Node.js to execute it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are comfortable with these features, you can skip directly to the *What
    is TypeScript?* section.
  prefs: []
  type: TYPE_NORMAL
- en: Variable declaration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Traditionally, JavaScript developers have used the keyword `var` to declare
    objects, variables, and other artifacts. The reason was that the old semantics
    of the language only had a function scope where variables were unique within its
    context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding function, no other variable can be declared as `x` inside
    its body. If you do declare one, then you effectively redefine it. However, there
    are cases in which scoping is not applied, such as in loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, the `x` variable outside the loop will not affect
    the `x` variable inside because they have a different scope. To overcome the scope
    limitation, JavaScript introduced the `let` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `let` keyword allows us to change the reference of a variable multiple times
    in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to define variables in JavaScript is the `const` keyword, which
    indicates that a variable should never change. As a code base grows, changes may
    happen by mistake, which can be costly. The `const` keyword can prevent these
    types of mistakes. Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to execute it, it will throw the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding error will come up only at the top level. You need to be aware
    of this if you declare objects as constants, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Declaring the `product` variable as a constant does not prevent the entire
    object but rather its reference from being edited. So, the preceding code is valid.
    If we try to change the reference of the variable, we will get the same type of
    error as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It is preferable to use the `const` keyword when we are sure that the properties
    of an object will not change during its lifetime because it prevents the object
    from accidentally changing.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we want to combine variables, we can use the **spread parameter** syntax.
    A spread parameter uses the ellipsis ( `…` ) to expand the values of a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we combine the `categories` array and the `category`
    item to create a new array. The `categories` array still contains two items, whereas
    the new array contains three. The current behavior is called **immutability**
    , which means not changing a variable but creating a new one that comes from the
    original.
  prefs: []
  type: TYPE_NORMAL
- en: An object is not immutable if its properties can be changed or its properties
    are an object whose properties can be changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use a spread parameter on objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we didn’t change the original `product` object but
    created a merge between the two. The value of the `newProduct` object will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `newProduct` object takes the properties from the `product` object, adds
    new values on top of it, and replaces the existing ones.
  prefs: []
  type: TYPE_NORMAL
- en: Function parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functions in JavaScript are the processing machines we use to analyze input,
    digest information, and apply the necessary transformations to data. They use
    parameters to provide data for transforming the state of our application or returning
    an output that will be used to shape our application’s business logic or user
    interactivity.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can declare a function to accept default parameters so that the function
    assumes a default value when it’s not explicitly passed upon execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If we do not pass a value for the `quantity` parameter while calling the function,
    we will get a `product` object with `qty` set to `1` .
  prefs: []
  type: TYPE_NORMAL
- en: Default parameters must be defined after all *required* parameters in the function
    signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'One significant advantage of JavaScript flexibility when defining functions
    is accepting an unlimited, non-declared array of parameters called **rest parameters**
    . Essentially, we can define an additional parameter at the end of the arguments
    list prefixed by an ellipsis ( `…` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding function, we use the `join` method to create a comma-separated
    string from the `categories` parameter. We pass each parameter separately when
    calling the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Rest parameters are beneficial when we don’t know how many arguments will be
    passed as parameters. The `name` property is also set using another useful feature
    of the JavaScript language. Instead of setting the property in the `product` object
    explicitly, we used the property name directly. The following snippet is equivalent
    to the initial declaration of the `addProduct` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The shorthand syntax for assigning property values can be used only when the
    parameter name matches the property name of an object.
  prefs: []
  type: TYPE_NORMAL
- en: Arrow functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In JavaScript, we can create functions in an alternate way called **arrow functions**
    . The purpose of an arrow function is to simplify the general function syntax
    and provide a bulletproof way to handle the function scope, which is traditionally
    handled by the `this` object. Consider the following example, which calculates
    a product discount given its price:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code does not have a `function` keyword, and the function body
    is defined by an arrow ( `=>` ). Arrow functions can be simplified further using
    the following best practices:'
  prefs: []
  type: TYPE_NORMAL
- en: Omit the parentheses in the function parameters when the signature contains
    one parameter only.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Omit the curly braces in the function body and the `return` keyword if the function
    has only one statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The resulting function will look much simpler and easier to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s explain now how arrow functions are related to scope handling. The value
    of the `this` object can point to a different context, depending on where we execute
    a function. When we use it inside a callback, we lose track of the upper context,
    which usually leads us to use conventions such as assigning its value to an external
    variable. Consider the following function, which logs a product name using the
    native `setTimeout` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the `getName` function using the following snippet and observe the
    console output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding snippet will not print the `Monitor` product name as expected
    because our code modifies the scope of the `this` object when evaluating the function
    inside the `setTimeout` callback. To fix it, convert the `setTimeout` function
    to use an arrow function instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Our code is now simpler and we can use the function scope safely.
  prefs: []
  type: TYPE_NORMAL
- en: Optional chaining
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Optional chaining is a powerful feature that can help us with refactoring and
    simplifying our code. In a nutshell, it can guide our code to ignore the execution
    of a statement unless a value has been provided somewhere in that statement. Let’s
    look at optional chaining with an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we define a `getOrder` function that returns the
    product of a particular order. Next, let’s fetch the value of the `product` property,
    making sure that an `order` exists before reading it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous snippet is a precautionary step in case our object has been modified.
    If we do not check the object and it has become `undefined` , JavaScript will
    throw an error. However, we can use optional chaining to improve the previous
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The character `?` after the `order` object ensures that the `product` property
    will be accessed only if the object has a value. Optional chaining also works
    in more complicated scenarios, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we also check if the `product` object has a value
    before accessing its `name` property.
  prefs: []
  type: TYPE_NORMAL
- en: Nullish coalescing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Nullish coalescing is related to providing a default value when a variable
    is not set. Consider the following example, which assigns a value to the `quantity`
    variable only if the `qty` variable exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous statement is called a **ternary operator** and operates like a
    conditional statement. If the `qty` variable does not have a value, the `quantity`
    variable will be initialized to the default value of `1` . We can rewrite the
    previous expression using nullish coalescing as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Nullish coalescing helps us make our code readable and smaller.
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JavaScript classes allow us to structure our application code and create instances
    of each class. A class can have property members, a constructor, methods, and
    property accessors. The following code snippet illustrates what a class looks
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The class statement wraps several elements that we can break down:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Member** : The `User` class contains the `firstName` , `lastName` , and `#isActive`
    members. Class members will only be accessible from within the class itself. Instances
    of the `User` class will have access only to the public properties `firstName`
    and `lastName` . The `#isActive` property will not be available because it is
    private, as denoted by the `#` character in front of the property name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Constructor** : The `constructor` is executed when we create an instance
    of the class. It is usually used to initialize the class members inside it with
    the parameters provided in the signature. We can also provide default values for
    parameters such as the `isActive` parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Method** : A method represents a function and may return a value, such as
    the `getFullname` method, which constructs the full name of a user. It can also
    be defined as private, similar to class members.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Property accessor** : A property accessor is defined by prefixing a method
    with the `set` keyword to make it writable and the `get` keyword to make it readable,
    followed by the property name we want to expose. The `active` method is a property
    accessor that returns the value of the `#isActive` member.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A class can also extend members and functionality of other classes. We can
    make a class inherit from another by appending the `extends` keyword to the class
    definition followed by the class we want to inherit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, the `Customer` class extends the `User` class, which
    exposes `firstName` and `lastName` properties. Any instance of the `Customer`
    class can use those properties by default. We can also override methods from the
    `User` class by appending a method with the same name. The `constructor` is required
    to call the `super` method, which points to the `constructor` of the `User` class.
  prefs: []
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As our applications scale and grow, there will be a time when we need to organize
    our code better and make it sustainable and reusable. Modules are a great way
    to accomplish these tasks, so let’s look at how they work and how we can implement
    them in our application.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding section, we learned how to work with classes. Having both classes
    in the same file is not scalable, and maintaining it won’t be easy. Imagine how
    much code you must process to make a simple change in one of the classes. Modules
    allow us to separate our application code into single files, enforcing the **Single
    Responsibility** **Pattern** ( **SRP** ). Each file is a different module concerned
    with a specific feature or functionality.
  prefs: []
  type: TYPE_NORMAL
- en: A good indication to split a module into multiple files is when the module starts
    to occupy different domains. For example, a products module cannot contain logic
    for customers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s refactor the code described in the previous section so that the `User`
    and `Customer` classes belong to separate modules:'
  prefs: []
  type: TYPE_NORMAL
- en: Open VSCode and create a new JavaScript file named `user.js` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the contents of the `User` class and add the `export` keyword in the class
    definition. The `export` keyword makes the module available to other modules and
    forms the public API of the module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new JavaScript file named `customer.js` and add the contents of the
    `Customer` class. The `Customer` class cannot recognize the `User` class because
    they are in different files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the `User` class into the `customer.js` file by adding the following
    statement at the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We use the `import` keyword and the relative path of the module file without
    the extension to import the `User` class. If a module exports more than one artifact,
    we place them inside curly braces separated by a comma, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Exploring modules concludes our journey of the JavaScript essentials. In the
    following section, we will learn about TypeScript and how it helps us build web
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: What is TypeScript?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Transforming small web applications into thick monolithic clients was impossible
    due to the limitations of earlier JavaScript versions. In a nutshell, large-scale
    JavaScript applications suffered from serious maintainability and scalability
    problems as soon as they grew in size and complexity. This issue became more relevant
    as new libraries and modules required seamless integration into our applications.
    The lack of proper mechanisms for interoperability led to cumbersome solutions.
  prefs: []
  type: TYPE_NORMAL
- en: To overcome those difficulties, Microsoft built a superset of the JavaScript
    language that would help build enterprise applications with a lower error footprint
    using static type checking, better tooling, and code analysis. TypeScript 1.0
    was introduced in 2014. It ran ahead of JavaScript, implemented the same features,
    and provided a stable environment for building large-scale applications. It introduced
    optional static typing through type annotations, thereby ensuring type checking
    at compile time and catching errors early in the development process. Its support
    for declaration files also enabled developers to describe the interface of their
    modules so that other developers could better integrate them into their code workflow
    and tooling.
  prefs: []
  type: TYPE_NORMAL
- en: The official TypeScript website can be reached at [https://www.typescriptlang.org](https://www.typescriptlang.org)
    . It contains extensive language documentation and a playground that gives us
    access to a quick tutorial to get up to speed with the language in no time. It
    includes some ready-made code examples that cover some of the most common traits
    of the language.
  prefs: []
  type: TYPE_NORMAL
- en: As a superset of JavaScript, one of the main advantages of embracing TypeScript
    in your next project is the low entry barrier. If you know JavaScript, you are
    pretty much all set since all the additional features in TypeScript are optional.
    You can pick and introduce any of them to achieve your goal. Overall, there is
    a long list of solid arguments for using TypeScript in your next project, and
    all apply to Angular.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a short rundown of some of the advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Annotating your code with types ensures the consistent integration of your different
    code units and improves code readability and comprehension.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The built-in type-checker analyzes your code at compile time and helps you prevent
    errors before executing your code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of types ensures consistency across your application. Combined with
    the previous two, the overall code error footprint is minimized in the long run.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfaces ensure the smooth and seamless integration of your libraries in other
    systems and code bases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Language support across different IDEs is amazing, and you can benefit from
    features such as highlighting code, real-time type checking, and automatic compilation
    at no cost.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The syntax is familiar to developers from other OOP-based backgrounds, such
    as Java, C#, and C++.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following section, we will learn how to develop and execute a TypeScript
    application. In Angular applications, we do not need to execute TypeScript code
    manually because it is automatically handled by the Angular CLI; however, it is
    good to know how it works under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The TypeScript language is an npm package that can be installed from the npm
    registry using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding command, we chose to install TypeScript globally in our system
    so that we can use it from any path in our development environment. Let’s see
    how we can use TypeScript through a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: Open VSCode and select **File** | **New File…** from the main menu options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `app.ts` in the **New File…** dialog and press *Enter* .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά, γραμμή  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_02_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: New File… dialog'
  prefs: []
  type: TYPE_NORMAL
- en: As we have already learned, TypeScript files have a `.ts` extension.
  prefs: []
  type: TYPE_NORMAL
- en: Select the path where you want to create the new file. VSCode will then open
    that file inside the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type the following snippet into the `app.ts` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Although we have created a TypeScript file, the preceding snippet is valid JavaScript
    code. Recall that TypeScript is a superset of JavaScript that provides syntactic
    sugar through its typing system. However, writing plain JavaScript code with TypeScript
    does not give us any clear benefit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a terminal window and run the following command to compile the TypeScript
    file into JavaScript:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding command initiates a process called **transpilation** performed
    by the `tsc` executable, a compiler that is at the core of the TypeScript language.
    We need to compile TypeScript code into JavaScript because browsers do not currently
    support TypeScript out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: Angular uses a compiler that utilizes the TypeScript compiler under the hood
    to build Angular applications.
  prefs: []
  type: TYPE_NORMAL
- en: The TypeScript compiler supports extra configuration options that we can pass
    to the `tsc` executable through the terminal window or a configuration file. The
    complete list of available compiler options can be found at [https://www.typescriptlang.org/docs/handbook/compiler-options.html](https://www.typescriptlang.org/docs/handbook/compiler-options.html)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'The transpilation process will create an `app.js` file in the same folder as
    the TypeScript file. The new file will contain the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Since we have not used any specific TypeScript feature yet, the preceding snippet
    looks almost identical to the original except for the variable declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The transpilation process replaced the `const` keyword with the `var` keyword
    because the TypeScript compiler uses an old JavaScript version by default. We
    can change that by specifying a `target` in the `tsc` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding command, we specified `es2022` , which represents the most
    recent version of the JavaScript language at the time of writing. Angular applications
    that we will build throughout this book also target the same JavaScript version
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we will use the latest JavaScript version in the rest of this chapter,
    let’s define the `target` option using a TypeScript configuration file. Create
    a file named `tsconfig.json` in the current folder and add the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can find more options for the TypeScript configuration file at [https://www.typescriptlang.org/tsconfig](https://www.typescriptlang.org/tsconfig)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Run the command `tsc` in a terminal window to verify that the output JavaScript
    file remains unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: When we run the `tsc` command without options, it will compile all TypeScript
    files in the current folder using the options from the configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: The TypeScript code we have written so far does not use TypeScript-specific
    features. In the following section, we will learn how to use the typing system,
    which is the most powerful and essential feature of the TypeScript language.
  prefs: []
  type: TYPE_NORMAL
- en: Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Working with TypeScript or any other coding language means working with data,
    and this data can represent different sorts of content, called **types** . Types
    are used to represent the fact that data can be text, an integer value, or an
    array of these value types, among others.
  prefs: []
  type: TYPE_NORMAL
- en: Types disappear during transpilation and are not included in the final JavaScript
    code.
  prefs: []
  type: TYPE_NORMAL
- en: You may have already encountered types in JavaScript since we have always worked
    implicitly with them. In JavaScript, any given variable could assume (or return,
    in the case of functions) any value. Sometimes, this leads to errors and exceptions
    in our code because of type collisions between what our code returned and what
    we expected to return type-wise. However, statically typing our variables gives
    our IDE and us a good picture of what kind of data we should find in each code
    instance. It becomes an invaluable way to help debug our applications at compile
    time before the code is executed.
  prefs: []
  type: TYPE_NORMAL
- en: String
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the most widely used primitive types is the `string` , which populates
    a variable with text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The type is defined by adding a colon and the type name next to the variable.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `boolean` type defines a variable that can have a value of either `true`
    or `false` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The result of a `boolean` variable represents the fulfillment of a conditional
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: Number
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `number` type is probably the other most widely used primitive data type,
    along with `string` and `boolean` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We can use the `number` type to define a floating-point number and hexadecimal,
    decimal, binary, and octal literals.
  prefs: []
  type: TYPE_NORMAL
- en: Array
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **array** type defines a list of items that contain a certain type only.
    Handling exceptions that arise from errors, such as assigning wrong member types
    in a list, can now be easily avoided with this type. We can define arrays using
    the square bracket syntax or the `Array` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Agreeing with your team on either syntax and sticking with it during application
    development is advisable.
  prefs: []
  type: TYPE_NORMAL
- en: If we try to add a new item to the `categories` array with a type other than
    `string` , TypeScript will throw an error, ensuring our typed members remain consistent
    and that our code is error-free.
  prefs: []
  type: TYPE_NORMAL
- en: any
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In all preceding cases, typing is optional because TypeScript is smart enough
    to infer the data types of variables from their values with a certain level of
    accuracy.
  prefs: []
  type: TYPE_NORMAL
- en: Letting the typing system infer the types is very important, instead of typing
    it manually. The type system is never wrong, but the developer can be.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if it is not possible, the typing system will automatically assign
    the dynamic `any` type to the loosely typed data at the cost of reducing type
    checking to a bare minimum. Additionally, we can add the `any` type in our code
    manually when it is hard to infer the data type from the information we have at
    any given point. The `any` type includes all the other existing types, so we can
    type any data value with it and assign any value to it later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: TypeScript contains another type, similar to the `any` type, called `unknown`
    . A variable of the `unknown` type can have a value of any type. The main difference
    is that TypeScript will not let us apply arbitrary operations to unknown values,
    such as calling a method, unless we perform type checking first.
  prefs: []
  type: TYPE_NORMAL
- en: However, with great power comes great responsibility. If we bypass the convenience
    of static type checking, we open the door to type errors when piping data through
    our application. It is up to us to ensure type safety throughout our application.
  prefs: []
  type: TYPE_NORMAL
- en: Custom types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In TypeScript, you can come up with your own type if you need to by using the
    `type` keyword in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then create a variable of a specific type as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is perfectly valid as `computing` is one of the allowed values
    and works as intended. Custom types are an excellent way to add types with a finite
    number of allowed values.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we want to create a custom type from an object, we can use the `keyof`
    operator. The `keyof` operator enables us to iterate over the properties of an
    object and extract them into a new type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, the `CategoryType` produced the same result as the
    `Categories` type. We will learn how we can use the `keyof` operator to iterate
    over object properties dynamically in *Chapter 4* , *Enriching Applications Using
    Pipes and Directives* .
  prefs: []
  type: TYPE_NORMAL
- en: The typing system of TypeScript is mainly used to annotate JavaScript code with
    types. It improves the developer experience by providing intelliSense and preventing
    bugs early in development. In the following section, we will learn more about
    adding type annotations in functions.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Functions in TypeScript are not that different from regular JavaScript, except
    that, like everything else in TypeScript, they can be annotated with static types.
    Thus, they improve the compiler by providing the information it expects in their
    signature and the data type it aims to return, if any.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example showcases how a regular function is annotated in TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we annotated the returned value of the function by
    adding the `string` type to the function declaration. We can also add types in
    function parameters, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we annotated the parameters declared in the function
    signature, which makes sense since the compiler will want to check whether the
    data provided holds the correct type.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in the previous section, the TypeScript compiler is smart enough
    to infer types when no annotation is provided. In both preceding functions, we
    could omit the type because the compiler could infer it from the arguments provided
    and the returned statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a function does not return a type, we can annotate it using the `void`
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We have already learned how to use default and rest parameters in JavaScript
    functions. TypeScript extends functions’ capabilities by introducing optional
    parameters. Parameters are defined as optional by adding the character `?` after
    the parameter name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding function, we have defined `quantity` as an optional parameter.
    We have also used the nullish coalescing syntax to set the `qty` property of the
    `product` object if `quantity` is not passed.
  prefs: []
  type: TYPE_NORMAL
- en: We can invoke the `addToCart` function by passing only the `productId` parameter
    or both.
  prefs: []
  type: TYPE_NORMAL
- en: Optional parameters should be placed last in a function signature.
  prefs: []
  type: TYPE_NORMAL
- en: We have already learned how JavaScript classes can help us structure our application
    code. In the following section, we will see how to use them in TypeScript to improve
    our application further.
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider the `User` class that we defined in the `user.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We will take simple, small steps to add types throughout the class:'
  prefs: []
  type: TYPE_NORMAL
- en: Convert the file to TypeScript by renaming it `user.ts` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following types to all class properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding snippet, we also used the `private` modifier to define the
    `isActive` property as private.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `constructor` by adding types to parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternatively, we could omit class properties and have the `constructor` create
    them automatically by declaring parameters as `private` :'
  prefs: []
  type: TYPE_NORMAL
- en: '`constructor(private firstName: string, private lastName: string, private isActive:
    boolean = true) {}`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, add types in the `active` property accessor and the `getFullname`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Converting a JavaScript class into TypeScript and adding types is an important
    step toward taking advantage of the typing feature in TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another great feature of TypeScript related to classes is the `instanceOf`
    keyword. It allows us to check the class instance type and provides the correct
    properties according to the related class. Let’s explore it with the `Customer`
    class defined in the `customer.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: Convert the file to TypeScript by renaming it `customer.ts` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Rewrite the `Customer` class as follows to add types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an object outside of the class that can be of both the `User` and `Customer`
    type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now use the `instanceOf` keyword to access different properties of the
    `account` object according to the underlying class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'TypeScript is smart enough to understand that the `account` object in the `else`
    statement does not have a `taxNumber` property because it is of the `User` type.
    Even if we try to access it by mistake, VSCode will throw an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά, γραμμή  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_02_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: Property access error'
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript classes help us write well-structured code, can be instantiated,
    contain business logic, and provide static typing in our application. As applications
    scale and more classes are created, we need to find ways to ensure consistency
    and rule compliance in our code. As we will learn in the following section, one
    of the best ways to address the consistency and validation of types is to create
    **interfaces** .
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An interface is a code contract that defines a particular schema. Any artifacts
    like classes and functions implementing an interface should comply with this schema.
    Interfaces are beneficial when we want to enforce strict typing on classes generated
    by factories or when we define function signatures to ensure that a particular
    typed property is found in the payload.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces disappear during transpilation and are not included in the final
    JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following snippet, we define an interface for managing products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Interfaces are the recommended approach when working with data from a backend
    API or other source.
  prefs: []
  type: TYPE_NORMAL
- en: 'An interface can contain properties and methods. In the preceding snippet,
    the `Product` interface contained the `name` and `price` properties. It also defined
    the `getCategories` method. A class can use an interface by adding the `implements`
    keyword and the interface name in the class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, the `Keyboard` class must implement all members of
    the `Product` interface; otherwise, TypeScript will throw an error. If we do not
    want to implement an interface member, we can define it as optional using the
    `?` character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use interfaces to change the type of a variable from one type to
    another, called **type casting** . Type casting is useful when working with dynamic
    data or when TypeScript cannot infer the type of a variable automatically. In
    the following code, we instruct TypeScript to treat the `product` object as a
    `Product` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: However, type casting should be used with caution. In the preceding snippet,
    we intentionally omitted to add the `getCategories` method, but TypeScript did
    not throw an error. When we use type casting, we tell TypeScript that a variable
    *pretends* to be of a specific type.
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended to avoid type casting if possible and define types explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces can be combined with **generics** to provide a general code behavior
    regardless of the data type, as we will learn in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Generics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Generics are used when we want to use dynamic types in other TypeScript artifacts,
    such as methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that we want to create a function for saving a `Product` object in
    the local storage of the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we explicitly define the `data` parameter as a `Product`
    . If we also want to save `Keyboard` objects, we should modify the `save` method
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the preceding approach does not scale well if we would like to add
    other types in the future. Instead, we can use generics to let the consumer of
    the `save` method decide upon the data type passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the type of `T` is not evaluated until we use the
    method. We use `T` as a convention to define generics, but you can also use other
    letters. We can execute the `save` method for a `Product` object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, its type varies, depending on how you call it. It also ensures
    that you are passing the correct type of data. Suppose that the preceding method
    is called in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We specify that `T` should be a `Product` , but we insist on passing its value
    as a string. The compiler clearly states that this is not correct. If we would
    like to use more generics in our `save` method, we could use different letters,
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Generics are often used in collections because they have similar behavior, regardless
    of the type. They can, however, be used on other constructs, such as methods.
    The idea is that generics should indicate if you are about to mix types in a way
    that isn’t allowed.
  prefs: []
  type: TYPE_NORMAL
- en: Generics are powerful to use if you have a typical behavior with many different
    data types. You probably won’t be writing custom generics, at least not initially,
    but it’s good to know what is going on.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we’ll look at some utility types related to interfaces
    that will help us during Angular development.
  prefs: []
  type: TYPE_NORMAL
- en: Utility types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Utility types are types that help us to derive new types from existing ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Partial` type is used when we want to create an object from an interface
    where all its properties are optional. In the following snippet, we use the `Product`
    interface to declare a trimmed version of a product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we can see that the `mic` object does not contain
    the `getCategories` method. Alternatively, we could use the `Pick` type, which
    allows us to create an object from a subset of interface properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Some languages, such as C#, have a reserved type when defining a key-value
    pair object or dictionary, as it is known. In TypeScript, if we want to define
    such a type, we can use a `Record` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet defines the product name as a `string` and the quantity
    as a `number` .
  prefs: []
  type: TYPE_NORMAL
- en: You can find more utility types at [https://www.typescriptlang.org/docs/handbook/utility-types.html](https://www.typescriptlang.org/docs/handbook/utility-types.html)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It was a long read, but this introduction to TypeScript was necessary to understand
    the logic behind many of the most brilliant parts of Angular. It allowed us to
    introduce the language syntax and explain the rationale behind its success as
    the syntax of choice for building the Angular framework.
  prefs: []
  type: TYPE_NORMAL
- en: We reviewed the type architecture and how we can create advanced business logic
    when designing functions with various alternatives for parameterized signatures.
    We even discovered how to bypass scope-related issues using the powerful arrow
    functions. We enhanced our knowledge of TypeScript by exploring some of the most
    common features used in Angular applications.
  prefs: []
  type: TYPE_NORMAL
- en: Probably the most relevant part of this chapter encompassed our overview of
    classes, methods, properties, and accessors and how we can handle inheritance
    and better application design through interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: With all this knowledge, we can start learning how to apply it by building Angular
    applications. In the next chapter, we will learn how to use Angular components
    to create composable user interfaces to maintain our application code and make
    it more scalable.
  prefs: []
  type: TYPE_NORMAL
