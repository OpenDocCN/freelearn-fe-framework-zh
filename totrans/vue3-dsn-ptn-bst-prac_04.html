<html><head></head><body>
<div id="_idContainer030">
<h1 class="chapter-number" id="_idParaDest-78"><a id="_idTextAnchor102"/><span class="koboSpan" id="kobo.1.1">4</span></h1>
<h1 id="_idParaDest-79"><a id="_idTextAnchor103"/><span class="koboSpan" id="kobo.2.1">User Interface Composition with Components</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In this chapter, we will take a closer look at how to compose user interfaces with components. </span><span class="koboSpan" id="kobo.3.2">While we could just create our entire web page with just one component, as we did with our initial </span><em class="italic"><span class="koboSpan" id="kobo.4.1">To-Do list</span></em><span class="koboSpan" id="kobo.5.1"> application in </span><a href="B18602_03.xhtml#_idTextAnchor079"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.7.1">, </span><em class="italic"><span class="koboSpan" id="kobo.8.1">Setting Up a Working Project</span></em><span class="koboSpan" id="kobo.9.1">, this approach is not a good practice save for simple applications, partial migrations of functionality in existing web applications, or some edge cases when there could be no other option. </span><span class="koboSpan" id="kobo.9.2">Components are central to Vue’s approach to </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">building interfaces.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">In this chapter, we will do </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.13.1">Learn how to compose user interfaces with a hierarchy </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">of components</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Learn different ways in which components interact and communicate with </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">each other</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Look into special and </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">custom components</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Create an example plugin applying </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">design patterns</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">Re-write our to-do application using our plugin and </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">component composition</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.23.1">This chapter will introduce core and advanced concepts and give you the tools for building solid web applications with reusable components. </span><span class="koboSpan" id="kobo.23.2">In particular, we will apply our knowledge of design patterns from </span><a href="B18602_02.xhtml#_idTextAnchor040"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.24.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.25.1">, </span><em class="italic"><span class="koboSpan" id="kobo.26.1">Software Design Principles and Patterns</span></em><span class="koboSpan" id="kobo.27.1">, in the implementation of </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">the code.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.29.1">A note about styles</span></p>
<p class="callout"><span class="koboSpan" id="kobo.30.1">To avoid lengthy code listings, we will omit sample icons and styles in the code sample. </span><span class="koboSpan" id="kobo.30.2">The complete code, along with the styles and iconography, can be found in this book’s GitHub repository </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">at </span></span><a href="https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices"><span class="No-Break"><span class="koboSpan" id="kobo.32.1">https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.33.1">.</span></span></p>
<h1 id="_idParaDest-80"><a id="_idTextAnchor104"/><span class="koboSpan" id="kobo.34.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.35.1">The requirements to follow this chapter are the same as previously mentioned in </span><a href="B18602_03.xhtml#_idTextAnchor079"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.36.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.37.1">, </span><em class="italic"><span class="koboSpan" id="kobo.38.1">Setting Up a </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.39.1">Working Project</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.41.1">Check out the following video to see the Code in </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">Action: </span></span><a href="https://packt.link/eqm4l"><span class="No-Break"><span class="koboSpan" id="kobo.43.1">https://packt.link/eqm4l</span></span></a></p>
<p><span class="koboSpan" id="kobo.44.1">The code files of this chapter can be found on GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">here: </span></span><a href="https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter04"><span class="No-Break"><span class="koboSpan" id="kobo.46.1">https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter04</span></span></a></p>
<h1 id="_idParaDest-81"><a id="_idTextAnchor105"/><span class="koboSpan" id="kobo.47.1">Page composition with components</span></h1>
<p><a id="_idTextAnchor106"/><span class="koboSpan" id="kobo.48.1">To </span><a id="_idIndexMarker280"/><span class="koboSpan" id="kobo.49.1">create a user interface, we must have a starting </span><a id="_idIndexMarker281"/><span class="koboSpan" id="kobo.50.1">point, be it a crude sketch to a fancy full-fledged design. </span><span class="koboSpan" id="kobo.50.2">The graphic design of a web application is beyond the scope of this book, so we will consider that it has been created already. </span><span class="koboSpan" id="kobo.50.3">To translate the design into components, we could approach it as a process that answers the </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">following questions:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.52.1">How can we represent the layout and multiple elements </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">with components?</span></span></li>
<li><span class="koboSpan" id="kobo.54.1">How will these components communicate and relate to </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">each other?</span></span></li>
<li><span class="koboSpan" id="kobo.56.1">What dynamic elements will enter or leave the scene, and what events or application states will they be </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">triggered by?</span></span></li>
<li><span class="koboSpan" id="kobo.58.1">What design patterns can we apply that best serve the use case, </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">considering trade-offs?</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.60.1">Vue 3 is specially fit to create dynamic, interactive interfaces. </span><span class="koboSpan" id="kobo.60.2">These questions lead us to a repeatable approach for the implementation. </span><span class="koboSpan" id="kobo.60.3">So, let’s define a general process with well-defined stages, step </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">by step.</span></span></p>
<h2 id="_idParaDest-82"><a id="_idTextAnchor107"/><span class="koboSpan" id="kobo.62.1">Step 1 – identify layouts and user interface elements</span></h2>
<p><span class="koboSpan" id="kobo.63.1">This</span><a id="_idIndexMarker282"/><span class="koboSpan" id="kobo.64.1"> step </span><a id="_idIndexMarker283"/><span class="koboSpan" id="kobo.65.1">answers the question: </span><em class="italic"><span class="koboSpan" id="kobo.66.1">How can we represent the layout and multiple elements </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.67.1">with components?</span></em></span></p>
<p><span class="koboSpan" id="kobo.68.1">We </span><a id="_idIndexMarker284"/><span class="koboSpan" id="kobo.69.1">will take the page as a whole</span><a id="_idIndexMarker285"/><span class="koboSpan" id="kobo.70.1"> and consider what layout would work best, given the design. </span><span class="koboSpan" id="kobo.70.2">Should we use columns? </span><span class="koboSpan" id="kobo.70.3">Sections? </span><span class="koboSpan" id="kobo.70.4">Navigation menus? </span><span class="koboSpan" id="kobo.70.5">Islands of content? </span><span class="koboSpan" id="kobo.70.6">Are there dialogs or modal windows? </span><span class="koboSpan" id="kobo.70.7">A simple approach is to take the design image and mark the sections that may represent components with rectangles, from the outermost down to the singular unit of interaction. </span><span class="koboSpan" id="kobo.70.8">Iterate over this </span><em class="italic"><span class="koboSpan" id="kobo.71.1">slicing</span></em><span class="koboSpan" id="kobo.72.1"> of the page until you have a comfortable number of components. </span><span class="koboSpan" id="kobo.72.2">Considering the new To-Do application design, here is what this step may </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">look like:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer023">
<span class="koboSpan" id="kobo.74.1"><img alt=" Figure 4.1 ﻿– A slicing of the design into components with dashed boxes" src="image/Figure_4.01_B18602.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.75.1"> Figure 4.1 – A slicing of the design into components with dashed boxes</span></p>
<p><span class="koboSpan" id="kobo.76.1">Once we’ve identified the components, we must extract the relationships between them, creating a hierarchy from the topmost root component (usually, this will be our </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">App.vue</span></strong><span class="koboSpan" id="kobo.78.1">). </span><span class="koboSpan" id="kobo.78.2">New components may ap</span><a id="_idTextAnchor108"/><span class="koboSpan" id="kobo.79.1">pear because of grouping components by context or functionality. </span><span class="koboSpan" id="kobo.79.2">This is a good time to name the components. </span><span class="koboSpan" id="kobo.79.3">This initial architecture will evolve as we implement design patterns. </span><span class="koboSpan" id="kobo.79.4">Following this example, the hierarchy may look something </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer024">
<span class="koboSpan" id="kobo.81.1"><img alt="Figure 4.2 ﻿– An initial approach to the component’s hierarchy" src="image/Figure_4.02_B18602.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.82.1">Figure 4.2 – An initial approach to the component’s hierarchy</span></p>
<p><span class="koboSpan" id="kobo.83.1">Notice </span><a id="_idIndexMarker286"/><span class="koboSpan" id="kobo.84.1">how a new </span><a id="_idIndexMarker287"/><span class="koboSpan" id="kobo.85.1">component appeared, </span><strong class="source-inline"><span class="koboSpan" id="kobo.86.1">ToDoProject.vue</span></strong><span class="koboSpan" id="kobo.87.1">, from grouping other components. </span><span class="koboSpan" id="kobo.87.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">App</span></strong><span class="koboSpan" id="kobo.89.1"> component usually deals with the main layout of the application and the starting point in the hierarchy. </span><span class="koboSpan" id="kobo.89.2">Now, with our initial design in place, it is time to move on to the </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">next step.</span></span></p>
<h2 id="_idParaDest-83"><a id="_idTextAnchor109"/><span class="koboSpan" id="kobo.91.1">Step 2 – identify relationships, the data flow, interactions, and events</span></h2>
<p><span class="koboSpan" id="kobo.92.1">This step </span><a id="_idIndexMarker288"/><span class="koboSpan" id="kobo.93.1">answers the question: </span><em class="italic"><span class="koboSpan" id="kobo.94.1">How will these components communicate and relate to </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.95.1">each other?</span></em></span></p>
<p><span class="koboSpan" id="kobo.96.1">In this stage, we </span><a id="_idIndexMarker289"/><span class="koboSpan" id="kobo.97.1">need to understand the user’s interaction (with a use case, user story, or something else). </span><span class="koboSpan" id="kobo.97.2">For each component, we</span><a id="_idIndexMarker290"/><span class="koboSpan" id="kobo.98.1"> decide what information it will hold (the state), what will pass down to its children, what it needs from its</span><a id="_idIndexMarker291"/><span class="koboSpan" id="kobo.99.1"> parent, and what events it will trigger. </span><span class="koboSpan" id="kobo.99.2">In Vue, components can only relate vertically to one another. </span><span class="koboSpan" id="kobo.99.3">Siblings ignore the existence of each other for the best part. </span><span class="koboSpan" id="kobo.99.4">If a sibling component needs to share data with another, that data must be hosted by a common third party who can share it with both, usually the parent who has common visibility. </span><span class="koboSpan" id="kobo.99.5">There are other solutions for this, such as reactive state management, which we will cover in detail in </span><a href="B18602_07.xhtml#_idTextAnchor173"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.100.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.101.1">, </span><em class="italic"><span class="koboSpan" id="kobo.102.1">Data Flow Management</span></em><span class="koboSpan" id="kobo.103.1">. </span><span class="koboSpan" id="kobo.103.2">For this chapter, we will settle with the basic </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">relationship functionality.</span></span></p>
<p><span class="koboSpan" id="kobo.105.1">There </span><a id="_idIndexMarker292"/><span class="koboSpan" id="kobo.106.1">are many ways to document this information: scribbled notes in the hierarchy tree (see </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.107.1">Figure 4</span></em></span><em class="italic"><span class="koboSpan" id="kobo.108.1">.2</span></em><span class="koboSpan" id="kobo.109.1">), descriptive formal documentation, UML diagrams (</span><strong class="bold"><span class="koboSpan" id="kobo.110.1">UML</span></strong><span class="koboSpan" id="kobo.111.1"> stands for </span><strong class="bold"><span class="koboSpan" id="kobo.112.1">Universal Modeling Language</span></strong><span class="koboSpan" id="kobo.113.1">, an </span><a id="_idIndexMarker293"/><span class="koboSpan" id="kobo.114.1">iconography representation of software components), and </span><a id="_idIndexMarker294"/><span class="koboSpan" id="kobo.115.1">more. </span><span class="koboSpan" id="kobo.115.2">For simplicity, let’s write down only one segment</span><a id="_idIndexMarker295"/><span class="koboSpan" id="kobo.116.1"> of the</span><a id="_idIndexMarker296"/><span class="koboSpan" id="kobo.117.1"> tree in a </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">table format:</span></span></p>
<table class="No-Table-Style" id="table001-2">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.119.1">Component</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.120.1">Function</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold"><span class="koboSpan" id="kobo.121.1">State, </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.122.1">I/O, events</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.123.1">ToDoProject.vue</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.124.1">Hosts a list of to-do items and coordinates interaction with the user. </span><span class="koboSpan" id="kobo.124.2">This component will actively modify </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">the items.</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.126.1">State: The </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">to-do list</span></span></p>
<p><span class="koboSpan" id="kobo.128.1">Events: Open new, edit, and delete modals </span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.129.1">ToDoSummary.vue</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.130.1">Displays a summary count of to-do items </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">by state.</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.132.1">Input: The list of </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">to-do items</span></span></p>
<p><span class="koboSpan" id="kobo.134.1">State: Counters for each </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">item state</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.136.1">ToDoFilter.vue</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.137.1">Collects a string to filter the list of </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">to-do items.</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.139.1">Output: A </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">filter string</span></span></p>
<p><span class="koboSpan" id="kobo.141.1">State: An </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">auxiliary variable</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.143.1">ToDoList.vue</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.144.1">Displays the list of to-do items, and the signal operations for </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">each one.</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.146.1">Input: The to-do list, a </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">filter string</span></span></p>
<p><span class="koboSpan" id="kobo.148.1">Events: Toggle item state, edit and </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">delete item</span></span></p>
</td>
</tr>
</tbody>
</table>
<p><span class="koboSpan" id="kobo.150.1">For brevity, I have omitted the components and interactions that will make up the </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">user dialogs.</span></span><span class="koboSpan" id="kobo.152.1">
We will see them later in this chapter, but suffice it to say, it is the responsibility of </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">ToDoProject.vue</span></strong><span class="koboSpan" id="kobo.154.1"> to manage the interaction using </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">modal dialogs.</span></span></p>
<h2 id="_idParaDest-84"><a id="_idTextAnchor110"/><span class="koboSpan" id="kobo.156.1">Step 3 – identify user interactivity elements (inputs, dialogs, notifications, and more)</span></h2>
<p><span class="koboSpan" id="kobo.157.1">This step </span><a id="_idIndexMarker297"/><span class="koboSpan" id="kobo.158.1">answers the question: </span><em class="italic"><span class="koboSpan" id="kobo.159.1">What dynamic elements will enter or leave the scene, and what events or application states will they be </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.160.1">triggered by?</span></em></span></p>
<p><span class="koboSpan" id="kobo.161.1">In our application, the main CRUD operations (</span><strong class="bold"><span class="koboSpan" id="kobo.162.1">CRUD</span></strong><span class="koboSpan" id="kobo.163.1"> stands for </span><strong class="bold"><span class="koboSpan" id="kobo.164.1">Create, Read, Update, and Delete</span></strong><span class="koboSpan" id="kobo.165.1"> data) involve </span><a id="_idIndexMarker298"/><span class="koboSpan" id="kobo.166.1">using modal dialogs presented to the user. </span><span class="koboSpan" id="kobo.166.2">As previously mentioned, it is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">ToDoProject.vue</span></strong><span class="koboSpan" id="kobo.168.1"> component that controls this interaction as a response to certain events. </span><span class="koboSpan" id="kobo.168.2">This process is illustrated in this </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">sequence diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer025">
<span class="koboSpan" id="kobo.170.1"><img alt="Figure 4.3 ﻿– User interaction through modals – edit an item" src="image/Figure_4.03_B18602.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.171.1">Figure 4.3 – User interaction through modals – edit an item</span></p>
<p><span class="koboSpan" id="kobo.172.1">In this diagram, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">ToDoProject</span></strong><span class="koboSpan" id="kobo.174.1"> component shares the to-do list with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">ToDoList</span></strong><span class="koboSpan" id="kobo.176.1"> component. </span><span class="koboSpan" id="kobo.176.2">When the user triggers the </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">edit</span></strong><span class="koboSpan" id="kobo.178.1"> event, the child component notifies the parent by raising such an event. </span><span class="koboSpan" id="kobo.178.2">The parent then makes a copy of the item and opens a modal dialog, passing said copy. </span><span class="koboSpan" id="kobo.178.3">When the dialog is accepted, the parent modifies the original item with the changes. </span><span class="koboSpan" id="kobo.178.4">Then, Vue’s reactivity reflects the state change in the </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">child components.</span></span></p>
<p><span class="koboSpan" id="kobo.180.1">Often, these </span><a id="_idIndexMarker299"/><span class="koboSpan" id="kobo.181.1">interactions help us identify the need for additional components that were not evident in </span><em class="italic"><span class="koboSpan" id="kobo.182.1">Step 1</span></em><span class="koboSpan" id="kobo.183.1">, such as the implementation of design patterns... </span><span class="koboSpan" id="kobo.183.2">which is the </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">next step.</span></span></p>
<h2 id="_idParaDest-85"><a id="_idTextAnchor111"/><span class="koboSpan" id="kobo.185.1">Step 4 – identify design patterns and trade-offs</span></h2>
<p><span class="koboSpan" id="kobo.186.1">This step answers the question: </span><em class="italic"><span class="koboSpan" id="kobo.187.1">What design patterns can we apply that best serve the use case, </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.188.1">considering trade-offs?</span></em></span></p>
<p><span class="koboSpan" id="kobo.189.1">Deciding what</span><a id="_idIndexMarker300"/><span class="koboSpan" id="kobo.190.1"> patterns to use can be a very creative process. </span><span class="koboSpan" id="kobo.190.2">There is no silver bullet, and multiple solutions can provide </span><a id="_idIndexMarker301"/><span class="koboSpan" id="kobo.191.1">different results. </span><span class="koboSpan" id="kobo.191.2">It is common to make several prototypes to test </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">different approaches.</span></span></p>
<p><span class="koboSpan" id="kobo.193.1">In our new application, we have introduced the concept of modal dialogs to capture user input. </span><span class="koboSpan" id="kobo.193.2">Modal dialogs</span><a id="_idIndexMarker302"/><span class="koboSpan" id="kobo.194.1"> are used when an operation requires a user action or decision to proceed. </span><span class="koboSpan" id="kobo.194.2">The user can accept or reject the dialog, and cannot interact with any other part of the application until such a decision is made. </span><span class="koboSpan" id="kobo.194.3">Given these conditions, one possible pattern to </span><a id="_idIndexMarker303"/><span class="koboSpan" id="kobo.195.1">apply is the </span><strong class="bold"><span class="koboSpan" id="kobo.196.1">Async </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.197.1">Promise</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.198.1"> pattern.</span></span></p>
<p><span class="koboSpan" id="kobo.199.1">In our code, we want to open a modal dialog as a promise that, by definition, will provide us with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">resolve()</span></strong><span class="koboSpan" id="kobo.201.1">(accept) or </span><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">reject()</span></strong><span class="koboSpan" id="kobo.203.1"> (cancel) function. </span><span class="koboSpan" id="kobo.203.2">Moreover, we want to be able to use this solution in multiple projects, and globally </span><a id="_idIndexMarker304"/><span class="koboSpan" id="kobo.204.1">in our application. </span><span class="koboSpan" id="kobo.204.2">We can create a plugin for this purpose, and use the </span><strong class="bold"><span class="koboSpan" id="kobo.205.1">dependency injection pattern</span></strong><span class="koboSpan" id="kobo.206.1"> to access the modal functionality from any component. </span><span class="koboSpan" id="kobo.206.2">These patterns will provide us with the solution we need to make our modal </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">dialog reusable.</span></span></p>
<p><span class="koboSpan" id="kobo.208.1">At this point, we are almost ready to start implementing the components conceptually. </span><span class="koboSpan" id="kobo.208.2">However, to create a more suitable and sturdy application, and implement the aforementioned patterns, we should take a moment to learn more about </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">Vue components.</span></span></p>
<h1 id="_idParaDest-86"><a id="_idTextAnchor112"/><span class="koboSpan" id="kobo.210.1">Components in depth</span></h1>
<p><span class="koboSpan" id="kobo.211.1">Components</span><a id="_idIndexMarker305"/><span class="koboSpan" id="kobo.212.1"> are the building blocks of the framework. </span><span class="koboSpan" id="kobo.212.2">In </span><a href="B18602_01.xhtml#_idTextAnchor017"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.213.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.214.1">, </span><em class="italic"><span class="koboSpan" id="kobo.215.1">The Vue 3 Framework</span></em><span class="koboSpan" id="kobo.216.1">, we saw how to work with components, declare reactive variables, and more. </span><span class="koboSpan" id="kobo.216.2">In this section, we will explore more advanced features </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">and definitions.</span></span></p>
<h2 id="_idParaDest-87"><a id="_idTextAnchor113"/><span class="koboSpan" id="kobo.218.1">Local and global components</span></h2>
<p><span class="koboSpan" id="kobo.219.1">When we start</span><a id="_idIndexMarker306"/><span class="koboSpan" id="kobo.220.1"> our Vue 3 application, we mount the main component (</span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">App.vue</span></strong><span class="koboSpan" id="kobo.222.1">) to an HTML element in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">main.js</span></strong><span class="koboSpan" id="kobo.224.1"> file. </span><span class="koboSpan" id="kobo.224.2">After that, in the script section</span><a id="_idIndexMarker307"/><span class="koboSpan" id="kobo.225.1"> of each component, we can import other components to use locally through </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">this command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.227.1">
import MyComponent from "./MyComponent.vue"</span></pre>
<p><span class="koboSpan" id="kobo.228.1">In this manner, to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">MyComponent</span></strong><span class="koboSpan" id="kobo.230.1"> in another component, we need to import it again in such a component. </span><span class="koboSpan" id="kobo.230.2">If one</span><a id="_idIndexMarker308"/><span class="koboSpan" id="kobo.231.1"> component is used continuously in multiple components, this repetitive action breaks the development DRY principle (see </span><a href="B18602_02.xhtml#_idTextAnchor040"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.232.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.233.1">, </span><em class="italic"><span class="koboSpan" id="kobo.234.1">Software Design Principles and Patterns</span></em><span class="koboSpan" id="kobo.235.1">). </span><span class="koboSpan" id="kobo.235.2">The alternative is to declare the component as </span><strong class="bold"><span class="koboSpan" id="kobo.236.1">global</span></strong><span class="koboSpan" id="kobo.237.1">, by </span><a id="_idIndexMarker309"/><span class="koboSpan" id="kobo.238.1">attaching it directly to our Vue application instead of each component. </span><span class="koboSpan" id="kobo.238.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">main.js</span></strong><span class="koboSpan" id="kobo.240.1"> file, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">App.component()</span></strong><span class="koboSpan" id="kobo.242.1"> method for this </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">use case:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.244.1">Main.js</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.245.1">
Import { createApp } from "vue"
import App from './App.vue'
</span><strong class="bold"><span class="koboSpan" id="kobo.246.1">Import MyComponent from "./MyComponent.vue"</span></strong><span class="koboSpan" id="kobo.247.1">
createApp(App)
    </span><strong class="bold"><span class="koboSpan" id="kobo.248.1">.component('MyComponent', MyComponent)</span></strong><span class="koboSpan" id="kobo.249.1">
    .mount("#app")</span></pre>
<p><span class="koboSpan" id="kobo.250.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">component()</span></strong><span class="koboSpan" id="kobo.252.1"> method receives two arguments: a </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">String</span></strong><span class="koboSpan" id="kobo.254.1"> that represents the HTML tag for the component, and an object with the component definition (either imported or in-lined). </span><span class="koboSpan" id="kobo.254.2">After registration, it is available to all the components in our application. </span><span class="koboSpan" id="kobo.254.3">There are, however, a few drawbacks to using </span><span class="No-Break"><span class="koboSpan" id="kobo.255.1">global components:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.256.1">The component will be included in the final build, even if </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">never used</span></span></li>
<li><span class="koboSpan" id="kobo.258.1">Global registrations obscures the relationship and dependencies </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">between components</span></span></li>
<li><span class="koboSpan" id="kobo.260.1">Name collision may occur with locally </span><span class="No-Break"><span class="koboSpan" id="kobo.261.1">imported components</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.262.1">The recommendation is to globally register only those components that provide generic </span><a id="_idIndexMarker310"/><span class="koboSpan" id="kobo.263.1">functionality</span><a id="_idIndexMarker311"/><span class="koboSpan" id="kobo.264.1"> and avoid those that are an integral</span><a id="_idIndexMarker312"/><span class="koboSpan" id="kobo.265.1"> part of a </span><a id="_idIndexMarker313"/><span class="koboSpan" id="kobo.266.1">workflow or </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">specific context.</span></span></p>
<h2 id="_idParaDest-88"><a id="_idTextAnchor114"/><span class="koboSpan" id="kobo.268.1">Static, asynchronous, and dynamic imports</span></h2>
<p><span class="koboSpan" id="kobo.269.1">So far, all the components</span><a id="_idIndexMarker314"/><span class="koboSpan" id="kobo.270.1"> we have imported have been </span><em class="italic"><span class="koboSpan" id="kobo.271.1">statically</span></em><span class="koboSpan" id="kobo.272.1"> defined with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">import XYZ from "filename"</span></strong><span class="koboSpan" id="kobo.274.1"> syntax. </span><span class="koboSpan" id="kobo.274.2">Bundlers such</span><a id="_idIndexMarker315"/><span class="koboSpan" id="kobo.275.1"> as </span><strong class="bold"><span class="koboSpan" id="kobo.276.1">Vite</span></strong><span class="koboSpan" id="kobo.277.1"> include them in a single JavaScript file. </span><span class="koboSpan" id="kobo.277.2">This increases the bundle’s size and could create delays in the startup of our application as the browser needs to download, parse, and execute the bundle and all its dependencies before any user interaction may take place. </span><span class="koboSpan" id="kobo.277.3">This code may include features that are seldom used or accessed. </span><span class="koboSpan" id="kobo.277.4">The clear alternative to this is to split our bundle file into multiple smaller files and load them as needed. </span><span class="koboSpan" id="kobo.277.5">In this case, we have two approaches – one provided by Vue 3 and another one provided by the newest JavaScript syntax for </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">dynamic imports.</span></span></p>
<p><span class="koboSpan" id="kobo.279.1">Vue 3 provides a function called </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">defineAsyncComponent</span></strong><span class="koboSpan" id="kobo.281.1">. </span><span class="koboSpan" id="kobo.281.2">This function takes a parameter another function that returns a dynamic </span><a id="_idIndexMarker316"/><span class="koboSpan" id="kobo.282.1">import as an argument. </span><span class="koboSpan" id="kobo.282.2">Here is </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">an example:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.284.1">
import {</span><strong class="bold"><span class="koboSpan" id="kobo.285.1">defineAsyncComponent</span></strong><span class="koboSpan" id="kobo.286.1">} from "vue"
const MyComponent = </span><strong class="bold"><span class="koboSpan" id="kobo.287.1">defineAsyncComponent</span></strong><span class="koboSpan" id="kobo.288.1">(
                    ()=&gt;import("MyComponent.vue")
                 )</span></pre>
<p><span class="koboSpan" id="kobo.289.1">The use of this function makes it safe to use in most bundlers. </span><span class="koboSpan" id="kobo.289.2">An alternative to this syntax is used by Vue Router, which we will see in </span><a href="B18602_05.xhtml#_idTextAnchor130"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.290.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.291.1">, </span><em class="italic"><span class="koboSpan" id="kobo.292.1">Single-Page Applications</span></em><span class="koboSpan" id="kobo.293.1">: the </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">import()</span></strong><span class="koboSpan" id="kobo.295.1"> dynamic declaration provided by JavaScript (</span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import"><span class="koboSpan" id="kobo.296.1">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import</span></a><span class="koboSpan" id="kobo.297.1">), This has a very </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">similar syntax:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.299.1">
const MyComponent = () =&gt; import('./MyComponent.vue')</span></pre>
<p><span class="koboSpan" id="kobo.300.1">As you can see, this syntax is more succinct. </span><span class="koboSpan" id="kobo.300.2">However, it can only be used when defining routes with Vue Router as, internally, the way that Vue 3 and Vue Router handle lazy loading components is different. </span><span class="koboSpan" id="kobo.300.3">In the end, both approaches will split the main bundle file into multiple smaller files that will be automatically loaded when needed in </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">our application.</span></span></p>
<p><span class="koboSpan" id="kobo.302.1">However, </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">defineAsyncComponent</span></strong><span class="koboSpan" id="kobo.304.1"> has some advantages. </span><span class="koboSpan" id="kobo.304.2">We can also pass any function that returns a promise that resolves to a component. </span><span class="koboSpan" id="kobo.304.3">This allows us to implement logic to control the process dynamically at runtime. </span><span class="koboSpan" id="kobo.304.4">Here is an example where we have decided to</span><a id="_idIndexMarker317"/><span class="koboSpan" id="kobo.305.1"> load one component based on the value of </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">an input:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.307.1">
const ExampleComponent=defineAsyncComponent(()=&gt;{
    return new Promise((resolve, reject)=&gt;{
        if(some_input_value_is_true){
            import OneComponent from "OneComponent.vue"
                resolve(OneComponent)
           }else{
               import AnotherComponent from
                   "AnotherComponent.vue"
               resolve(AnotherComponent)
           }
    })
})</span></pre>
<p><span class="koboSpan" id="kobo.308.1">The third syntax </span><a id="_idIndexMarker318"/><span class="koboSpan" id="kobo.309.1">for </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">defineAsyncComponent</span></strong><span class="koboSpan" id="kobo.311.1"> is probably the most useful. </span><span class="koboSpan" id="kobo.311.2">We can pass an object with attributes as an argument, which provides more control over the </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">loading operation.</span></span><span class="koboSpan" id="kobo.313.1">
It has </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">these attributes:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">loader</span></strong><span class="koboSpan" id="kobo.316.1"> (mandatory): It must provide a function that returns a promise that loads </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">the component</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">loadingComponent</span></strong><span class="koboSpan" id="kobo.319.1">: The component to display while the asynchronous component </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">is loading</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">delay</span></strong><span class="koboSpan" id="kobo.322.1">: The number of milliseconds to wait before </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">displaying </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">loadingComponent</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">errorComponent</span></strong><span class="koboSpan" id="kobo.326.1">: The component to display if the promise rejects, or if the loading fails for </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">any reason</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">timeout</span></strong><span class="koboSpan" id="kobo.329.1">: The time in milliseconds before considering the operation to have failed and </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">displaying </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">errorComponent</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.332.1">Here is an </span><a id="_idIndexMarker319"/><span class="koboSpan" id="kobo.333.1">example that uses all </span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">these attributes:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.335.1">
const HeavyComponent = defineAsyncComponent(</span><strong class="bold"><span class="koboSpan" id="kobo.336.1">{</span></strong><span class="koboSpan" id="kobo.337.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.338.1">loader</span></strong><span class="koboSpan" id="kobo.339.1">: ()=&gt; import("./HeavyComponent"),
    </span><strong class="bold"><span class="koboSpan" id="kobo.340.1">loadingComponent</span></strong><span class="koboSpan" id="kobo.341.1">: SpinnerComponent,
    </span><strong class="bold"><span class="koboSpan" id="kobo.342.1">delay</span></strong><span class="koboSpan" id="kobo.343.1">: 200,
    </span><strong class="bold"><span class="koboSpan" id="kobo.344.1">errorComponent</span></strong><span class="koboSpan" id="kobo.345.1">: LoadingError,
    </span><strong class="bold"><span class="koboSpan" id="kobo.346.1">timeout</span></strong><span class="koboSpan" id="kobo.347.1">: 60000
</span><strong class="bold"><span class="koboSpan" id="kobo.348.1">    }</span></strong><span class="koboSpan" id="kobo.349.1">)</span></pre>
<p><span class="koboSpan" id="kobo.350.1">While the browser retrieves the component from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">loader</span></strong><span class="koboSpan" id="kobo.352.1"> attribute, we display a </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">SpinnerComponent</span></strong><span class="koboSpan" id="kobo.354.1"> to inform the user that the operation is underway. </span><span class="koboSpan" id="kobo.354.2">After 1 minute of waiting, as defined by </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">timeout</span></strong><span class="koboSpan" id="kobo.356.1">, it will display the </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">LoadingError</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.358.1">component automatically.</span></span></p>
<p><span class="koboSpan" id="kobo.359.1">With this approach, our code is better optimized. </span><span class="koboSpan" id="kobo.359.2">Now, let’s learn how to receive data and notify other components </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">through events.</span></span></p>
<h2 id="_idParaDest-89"><a id="_idTextAnchor115"/><span class="koboSpan" id="kobo.361.1">Props, events, and the v-model directive</span></h2>
<p><span class="koboSpan" id="kobo.362.1">We have seen basic uses for props and events as means of passing data in and out of a component to its parent. </span><span class="koboSpan" id="kobo.362.2">But more powerful definitions are possible with multiple syntaxes. </span><span class="koboSpan" id="kobo.362.3">Props </span><a id="_idIndexMarker320"/><span class="koboSpan" id="kobo.363.1">can be </span><a id="_idIndexMarker321"/><span class="koboSpan" id="kobo.364.1">defined in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">script setup</span></strong><span class="koboSpan" id="kobo.366.1"> syntax with </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">defineProps</span></strong><span class="koboSpan" id="kobo.368.1"> and any of the following </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">argument formats:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.370.1">As an array of strings – </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">for example:</span></span></li>
</ul>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">const $props=defineProps(</span></strong><strong class="bold"><span class="koboSpan" id="kobo.373.1">[‘name’, ‘last_name’]</span></strong><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">)</span></strong></p>
<ul>
<li><span class="koboSpan" id="kobo.375.1">As an object, whose attributes are used as a name, and the value is of the data type – </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">for example,</span></span></li>
</ul>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">const $props=defineProps(</span></strong><strong class="bold"><span class="koboSpan" id="kobo.378.1">{name: String, age: Number}</span></strong><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">)</span></strong></p>
<p><span class="koboSpan" id="kobo.380.1">As an object, whose attributes define an</span><a id="_idIndexMarker322"/><span class="koboSpan" id="kobo.381.1"> object with a type and default </span><a id="_idIndexMarker323"/><span class="koboSpan" id="kobo.382.1">value – for example,</span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">const $props=defineProps(</span></strong><strong class="bold"><span class="koboSpan" id="kobo.384.1">{</span></strong></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.385.1">    name: { type: String, default: “John”},</span></strong></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.386.1">    last_name: {type: String, default: “Doe”}</span></strong></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.387.1"> }</span></strong><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">)</span></strong></p>
<p><span class="koboSpan" id="kobo.389.1">We need to keep in mind that primitive values are passed to the component by </span><strong class="bold"><span class="koboSpan" id="kobo.390.1">value</span></strong><strong class="bold"> </strong><span class="koboSpan" id="kobo.391.1">(meaning that changing their value inside the child component will not affect their value in the parent). </span><span class="koboSpan" id="kobo.391.2">However, complex data types, such as objects and arrays, are passed as </span><strong class="bold"><span class="koboSpan" id="kobo.392.1">references</span></strong><span class="koboSpan" id="kobo.393.1">, so changes to their inner keys/values will reflect in </span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">the parent.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.395.1">A note on complex types</span></p>
<p class="callout"><span class="koboSpan" id="kobo.396.1">When defining props of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">Object</span></strong><span class="koboSpan" id="kobo.398.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">Array</span></strong><span class="koboSpan" id="kobo.400.1"> type with default values, the default attribute must be a function that returns said object or array. </span><span class="koboSpan" id="kobo.400.2">Otherwise, the reference to the object/array will be shared by all the instances of </span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">the component.</span></span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.402.1">Events</span></em> <a id="_idIndexMarker324"/><span class="koboSpan" id="kobo.403.1">are signals that our child component emits to the parent. </span><span class="koboSpan" id="kobo.403.2">This is an example of</span><a id="_idIndexMarker325"/><span class="koboSpan" id="kobo.404.1"> how to define the events for a component in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">script </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">setup</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.407.1"> syntax:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.408.1">
const $emit=</span><strong class="bold"><span class="koboSpan" id="kobo.409.1">defineEmits(</span></strong><span class="koboSpan" id="kobo.410.1">['eventName']</span><strong class="bold"><span class="koboSpan" id="kobo.411.1">)</span></strong></pre>
<p><span class="koboSpan" id="kobo.412.1">Unlike props, emits only accept an array of strings declaration. </span><span class="koboSpan" id="kobo.412.2">Events can also pass a value to the receiver. </span><span class="koboSpan" id="kobo.412.3">Here is an example of the invocation from the </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">aforementioned definition:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.414.1">
$emit('eventName', some_value)</span></pre>
<p><span class="koboSpan" id="kobo.415.1">As you can see, </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">defineEmits</span></strong><span class="koboSpan" id="kobo.417.1"> returns a function that accepts one of the same names provided in the definition array as the first argument. </span><span class="koboSpan" id="kobo.417.2">The second argument, </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">some_value</span></strong><span class="koboSpan" id="kobo.419.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">is optional.</span></span></p>
<h2 id="_idParaDest-90"><a id="_idTextAnchor116"/><span class="koboSpan" id="kobo.421.1">Custom input controllers</span></h2>
<p><span class="koboSpan" id="kobo.422.1">One special application with props</span><a id="_idIndexMarker326"/><span class="koboSpan" id="kobo.423.1"> and events acting together is to create custom input controllers. </span><span class="koboSpan" id="kobo.423.2">In the previous examples, we used the Vue </span><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">v-model</span></strong><span class="koboSpan" id="kobo.425.1"> directive on </span><a id="_idIndexMarker327"/><span class="koboSpan" id="kobo.426.1">basic HTML input elements to capture their </span><a id="_idIndexMarker328"/><span class="koboSpan" id="kobo.427.1">value. </span><span class="koboSpan" id="kobo.427.2">Props and events that follow a special naming convention allow us to create input components that </span><a id="_idIndexMarker329"/><span class="koboSpan" id="kobo.428.1">accept the </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">v-model</span></strong><span class="koboSpan" id="kobo.430.1"> directive. </span><span class="koboSpan" id="kobo.430.2">Let’s take a look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">following code:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.432.1">Parent component template</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.433.1">
&lt;MyComponent </span><strong class="bold"><span class="koboSpan" id="kobo.434.1">v-model</span></strong><span class="koboSpan" id="kobo.435.1">="parent_variable"&gt;&lt;/MyComponent&gt;</span></pre>
<p><span class="koboSpan" id="kobo.436.1">Now that we have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">MyComponent</span></strong><span class="koboSpan" id="kobo.438.1"> in use inside our parent component, let’s see how we create the </span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">tie in:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.440.1">MyComponent script setup</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.441.1">
const $props=defineProps(['</span><strong class="bold"><span class="koboSpan" id="kobo.442.1">modelValue'</span></strong><span class="koboSpan" id="kobo.443.1">]),
      $emit=defineEmits(['</span><strong class="bold"><span class="koboSpan" id="kobo.444.1">update:modelValue'</span></strong><span class="koboSpan" id="kobo.445.1">])</span></pre>
<p><span class="koboSpan" id="kobo.446.1">We are using the array definition of </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">Props</span></strong><span class="koboSpan" id="kobo.448.1"> for brevity. </span><span class="koboSpan" id="kobo.448.2">Notice that the name of the prop is </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">modelValue</span></strong><span class="koboSpan" id="kobo.450.1">, and the event is </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">update:modelValue</span></strong><span class="koboSpan" id="kobo.452.1">. </span><span class="koboSpan" id="kobo.452.2">This syntax is expected. </span><span class="koboSpan" id="kobo.452.3">When the parent assigns a variable with </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">v-model</span></strong><span class="koboSpan" id="kobo.454.1">, the value will be copied to </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">modelValue</span></strong><span class="koboSpan" id="kobo.456.1">. </span><span class="koboSpan" id="kobo.456.2">When the child emits the </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">update:modelValue</span></strong><span class="koboSpan" id="kobo.458.1"> event, the parent variable’s value will be updated. </span><span class="koboSpan" id="kobo.458.2">In this way, you can create powerful input controls. </span><span class="koboSpan" id="kobo.458.3">But there’s more – you can have </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">multiple</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.460.1"> v-models!</span></strong></span></p>
<p><span class="koboSpan" id="kobo.461.1">Let’s consider that </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">modelValue</span></strong><span class="koboSpan" id="kobo.463.1"> is the default when using </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">v-model</span></strong><span class="koboSpan" id="kobo.465.1">. </span><span class="koboSpan" id="kobo.465.2">Vue 3 has introduced a new syntax for this directive so that we can have multiple models. </span><span class="koboSpan" id="kobo.465.3">The declaration is very simple. </span><span class="koboSpan" id="kobo.465.4">Consider the following child </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">component’s declaration:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.467.1">Child component props and event</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.468.1">
const
  $props=defineProps(['modelValue', </span><strong class="bold"><span class="koboSpan" id="kobo.469.1">'title'</span></strong><span class="koboSpan" id="kobo.470.1">]),
  $emit=defineEmits(['update:modelValue',</span><strong class="bold"><span class="koboSpan" id="kobo.471.1">'update:title'</span></strong><span class="koboSpan" id="kobo.472.1">])</span></pre>
<p><span class="koboSpan" id="kobo.473.1">With the preceding props and emits definition, we can now reference both from the parent component as the following </span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">example shows:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.475.1">Parent component template</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.476.1">
&lt;ChildComponent </span><strong class="bold"><span class="koboSpan" id="kobo.477.1">v-model</span></strong><span class="koboSpan" id="kobo.478.1">="varA" </span><strong class="bold"><span class="koboSpan" id="kobo.479.1">v-model:title</span></strong><span class="koboSpan" id="kobo.480.1">="varB"&gt;&lt;/ChildComponent&gt;</span></pre>
<p><span class="koboSpan" id="kobo.481.1">As we can see, we can attach a </span><a id="_idIndexMarker330"/><span class="koboSpan" id="kobo.482.1">modifier to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">v-model:name_of_prop</span></strong><span class="koboSpan" id="kobo.484.1"> directive. </span><span class="koboSpan" id="kobo.484.2">In</span><a id="_idIndexMarker331"/><span class="koboSpan" id="kobo.485.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">Child</span></strong><span class="koboSpan" id="kobo.487.1"> component, the event’s name now has to include the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">update:</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.489.1"> prefix.</span></span></p>
<p><span class="koboSpan" id="kobo.490.1">The use of props and events allows a direct data flow to occur between parent and child components. </span><span class="koboSpan" id="kobo.490.2">This implies that if data needs to be shared with multiple children, it has to be managed at the parent level. </span><span class="koboSpan" id="kobo.490.3">One issue with this restriction appears when the parent </span><a id="_idIndexMarker332"/><span class="koboSpan" id="kobo.491.1">needs to pass data not to a child, but to a grandchild or other deeply nested component in the hierarchy tree. </span><span class="koboSpan" id="kobo.491.2">That is where the </span><em class="italic"><span class="koboSpan" id="kobo.492.1">dependency injection pattern</span></em><span class="koboSpan" id="kobo.493.1"> comes in</span><a id="_idIndexMarker333"/><span class="koboSpan" id="kobo.494.1"> to save the day. </span><span class="koboSpan" id="kobo.494.2">Vue implements this naturally with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">Provide</span></strong><span class="koboSpan" id="kobo.496.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">Inject</span></strong><span class="koboSpan" id="kobo.498.1"> functions, which we will cover in more detail in the </span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">next section.</span></span></p>
<h2 id="_idParaDest-91"><a id="_idTextAnchor117"/><span class="koboSpan" id="kobo.500.1">Dependency injection with Provide and Inject</span></h2>
<p><span class="koboSpan" id="kobo.501.1">When data in the parent needs to be available in a deeply nested child, using only props, we would have to “pass” the data </span><a id="_idIndexMarker334"/><span class="koboSpan" id="kobo.502.1">between components, even if they don’t need it or use it. </span><span class="koboSpan" id="kobo.502.2">This issue is called </span><em class="italic"><span class="koboSpan" id="kobo.503.1">props drilling</span></em><span class="koboSpan" id="kobo.504.1">. </span><span class="koboSpan" id="kobo.504.2">The same occurs with events traveling in the opposite direction, having to “bubble” upwards. </span><span class="koboSpan" id="kobo.504.3">To solve this issue, Vue offers an implementation of the </span><a id="_idIndexMarker335"/><span class="koboSpan" id="kobo.505.1">dependency injection pattern with two functions</span><a id="_idIndexMarker336"/><span class="koboSpan" id="kobo.506.1"> named </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">Provide</span></strong><span class="koboSpan" id="kobo.508.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">Inject</span></strong><span class="koboSpan" id="kobo.510.1">. </span><span class="koboSpan" id="kobo.510.2">Using these, the parent or root component </span><em class="italic"><span class="koboSpan" id="kobo.511.1">provides</span></em><span class="koboSpan" id="kobo.512.1"> data (either by value or reference, such as an object), that can be </span><em class="italic"><span class="koboSpan" id="kobo.513.1">injected</span></em><span class="koboSpan" id="kobo.514.1"> into any of its children down the hierarchy tree. </span><span class="koboSpan" id="kobo.514.2">Visually, we can represent this situation </span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer026">
<span class="koboSpan" id="kobo.516.1"><img alt="Figure 4.﻿4 – Representation of Provide/Inject" src="image/Figure_4.04_B18602.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.517.1">Figure 4.4 – Representation of Provide/Inject</span></p>
<p><span class="koboSpan" id="kobo.518.1">As you can see, the</span><a id="_idIndexMarker337"/><span class="koboSpan" id="kobo.519.1"> process is very simple, as well as the syntax to implement </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">the pattern:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.521.1">In the parent (root) component, we import the </span><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">provide</span></strong><span class="koboSpan" id="kobo.523.1"> function from Vue and create a provision with a key (name) and the data to </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">pass along:</span></span><pre class="console"><span class="koboSpan" id="kobo.525.1">
import {provide} from "vue"
provide("provision_key_name", data)</span></pre></li>
<li><span class="koboSpan" id="kobo.526.1">In the receiving component, we import the </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">inject</span></strong><span class="koboSpan" id="kobo.528.1"> function and retrieve the data by </span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">key (name):</span></span><pre class="console">
<strong class="source-inline"><span class="koboSpan" id="kobo.530.1">import {</span></strong><strong class="bold"><span class="koboSpan" id="kobo.531.1">inject</span></strong><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">} from "vue"</span></strong>
<strong class="source-inline"><span class="koboSpan" id="kobo.533.1">const $received_data = </span></strong><strong class="bold"><span class="koboSpan" id="kobo.534.1">inject</span></strong><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">("</span></strong><strong class="bold"><span class="koboSpan" id="kobo.536.1">provision_key_name”</span></strong><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">)</span></strong></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.538.1">We can also provide a resource at the application level in the </span><span class="No-Break"><span class="koboSpan" id="kobo.539.1">following manner:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.540.1">
const app = createApp({})
</span><strong class="bold"><span class="koboSpan" id="kobo.541.1">app.provide(</span></strong><span class="koboSpan" id="kobo.542.1">'provision_key_name', data_or_value</span><strong class="bold"><span class="koboSpan" id="kobo.543.1">)</span></strong></pre>
<p><span class="koboSpan" id="kobo.544.1">In this way, the </span><a id="_idIndexMarker338"/><span class="koboSpan" id="kobo.545.1">provision can be injected into any component of our application. </span><span class="koboSpan" id="kobo.545.2">It is worth mentioning that we can also provide complex data types, such as arrays, objects, and reactive variables. </span><span class="koboSpan" id="kobo.545.3">In the following example, we are providing an object with functions and references to the </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">parent methods:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.547.1">In the parent/root component</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.548.1">
import {provide} from "vue"
function logMessage(){console.log("Hi")}
const _provision_data={</span><strong class="bold"><span class="koboSpan" id="kobo.549.1">runLog</span></strong><span class="koboSpan" id="kobo.550.1">: logMessage}
provide("service_name", _provision_data)</span></pre>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.551.1">In the child component</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.552.1">
import {inject} from "vue"
const $service = inject("service_name")
$service.</span><strong class="bold"><span class="koboSpan" id="kobo.553.1">runLog</span></strong><span class="koboSpan" id="kobo.554.1">()</span></pre>
<p><span class="koboSpan" id="kobo.555.1">In this</span><a id="_idIndexMarker339"/><span class="koboSpan" id="kobo.556.1"> example, we have effectively </span><a id="_idIndexMarker340"/><span class="koboSpan" id="kobo.557.1">provided an </span><strong class="bold"><span class="koboSpan" id="kobo.558.1">application programming interface</span></strong><span class="koboSpan" id="kobo.559.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.560.1">API</span></strong><span class="koboSpan" id="kobo.561.1">) through an object system-wide. </span><span class="koboSpan" id="kobo.561.2">A good practice when naming the “provision key” (service name) is to adhere to a convention that the entire team will understand and follow to identify the functionality, context, and maybe the source of the service provided, and to avoid possible collisions. </span><span class="koboSpan" id="kobo.561.3">For example, an injectable service named </span><strong class="source-inline"><span class="koboSpan" id="kobo.562.1">Admin.Users.Individual.Profile</span></strong><span class="koboSpan" id="kobo.563.1"> is more descriptive than </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">user_data</span></strong><span class="koboSpan" id="kobo.565.1">. </span><span class="koboSpan" id="kobo.565.2">It is up to the team and the developer to define the naming convention (a path-like naming is</span><a id="_idIndexMarker341"/><span class="koboSpan" id="kobo.566.1"> just a suggestion, not a standard). </span><span class="koboSpan" id="kobo.566.2">As mentioned before in this book, once you’ve decided upon a convention, what matters is that you are consistent throughout the source code. </span><span class="koboSpan" id="kobo.566.3">Later in this chapter, we will use this method to create a plugin to display modal dialogs, but before that, we need to see a few more concepts regarding special components </span><span class="No-Break"><span class="koboSpan" id="kobo.567.1">and templates.</span></span></p>
<h1 id="_idParaDest-92"><span class="koboSpan" id="kobo.568.1">Special comp</span><a id="_idTextAnchor118"/><span class="koboSpan" id="kobo.569.1">onents</span></h1>
<p><span class="koboSpan" id="kobo.570.1">The hierarchy of components is</span><a id="_idIndexMarker342"/><span class="koboSpan" id="kobo.571.1"> very powerful but has limitations. </span><span class="koboSpan" id="kobo.571.2">We have seen how we can apply the dependency injection pattern to solve one of those, but there are other cases where we need a bit more flexibility, reusability, or power to share code or templates, or even move a component that’s rendering outside </span><span class="No-Break"><span class="koboSpan" id="kobo.572.1">the hierarchy.</span></span></p>
<h2 id="_idParaDest-93"><a id="_idTextAnchor119"/><span class="koboSpan" id="kobo.573.1">Slots, slots, and more slots...</span></h2>
<p><span class="koboSpan" id="kobo.574.1">Through the use of</span><a id="_idIndexMarker343"/><span class="koboSpan" id="kobo.575.1"> props, our component can receive JavaScript data. </span><span class="koboSpan" id="kobo.575.2">With analog reasoning, it is also possible to pass template fragments (HTML, JSX, and so on) into specific parts of a component’s template using placeholders called </span><strong class="bold"><span class="koboSpan" id="kobo.576.1">slots</span></strong><span class="koboSpan" id="kobo.577.1">. </span><span class="koboSpan" id="kobo.577.2">Just like props, they </span><a id="_idIndexMarker344"/><span class="koboSpan" id="kobo.578.1">accept several types of syntax. </span><span class="koboSpan" id="kobo.578.2">Let’s start with the most</span><a id="_idIndexMarker345"/><span class="koboSpan" id="kobo.579.1"> basic: the </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.580.1">default slot</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.581.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.582.1">Let’s assume we have a component named </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">MyMenuBar</span></strong><span class="koboSpan" id="kobo.584.1"> that acts as a placeholder for a top menu. </span><span class="koboSpan" id="kobo.584.2">We want the parent component to populate the options in the same way that we use a common HTML tag such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">header</span></strong><span class="koboSpan" id="kobo.586.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">div</span></strong><span class="koboSpan" id="kobo.588.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.589.1">like this:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.590.1">Parent component</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.591.1">
&lt;MyMenuBar&gt;
    </span><strong class="bold"><span class="koboSpan" id="kobo.592.1">&lt;button&gt;Option 1&lt;/button&gt;</span></strong><span class="koboSpan" id="kobo.593.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.594.1">&lt;button&gt;Option 2&lt;/button&gt;</span></strong><span class="koboSpan" id="kobo.595.1">
&lt;/MyMenuBar&gt;</span></pre>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.596.1">MyMenuBar component</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.597.1">
&lt;template&gt;
&lt;div class="..."&gt;
    </span><strong class="bold"><span class="koboSpan" id="kobo.598.1">&lt;slot&gt;&lt;/slot&gt;</span></strong><span class="koboSpan" id="kobo.599.1">
&lt;/div&gt;
&lt;/template&gt;</span></pre>
<p><span class="koboSpan" id="kobo.600.1">Provided that we applied the necessary styling and classes in </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">MyMenuBar</span></strong><span class="koboSpan" id="kobo.602.1">, the final rendered template may look something </span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer027">
<span class="koboSpan" id="kobo.604.1"><img alt="Figure 4.5 – A menu bar using slots" src="image/Figure_4.05_B18602.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.605.1">Figure 4.5 – A menu bar using slots</span></p>
<p><span class="koboSpan" id="kobo.606.1">The logic that’s </span><a id="_idIndexMarker346"/><span class="koboSpan" id="kobo.607.1">applied is quite straightforward. </span><span class="koboSpan" id="kobo.607.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.608.1">&lt;slot&gt;&lt;/slot&gt;</span></strong><span class="koboSpan" id="kobo.609.1"> placeholder will be replaced at runtime by whatever content is provided by the parent component inside the child tags. </span><span class="koboSpan" id="kobo.609.2">In the preceding example, if we inspect the rendered final HTML, we may find something like this (considering that we are using </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">W3.css</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.611.1"> classes):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.612.1">
&lt;div class="w3-bar w3-border w3-light-grey"&gt;
  &lt;button&gt;Option 1&lt;/button&gt;
  &lt;button&gt;Option 2&lt;/button&gt;
&lt;/div&gt;</span></pre>
<p><span class="koboSpan" id="kobo.613.1">This is a </span><a id="_idIndexMarker347"/><span class="koboSpan" id="kobo.614.1">fundamental concept in user interface design. </span><span class="koboSpan" id="kobo.614.2">Now, what if we need multiple “slots” – for example, to create a layout component? </span><span class="koboSpan" id="kobo.614.3">Here, an alternative syntax called </span><em class="italic"><span class="koboSpan" id="kobo.615.1">named slots</span></em><span class="koboSpan" id="kobo.616.1"> comes </span><a id="_idIndexMarker348"/><span class="koboSpan" id="kobo.617.1">into play. </span><span class="koboSpan" id="kobo.617.2">Consider the </span><span class="No-Break"><span class="koboSpan" id="kobo.618.1">following example:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.619.1">MyLayout component</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.620.1">
&lt;div class="layout-wrapper"&gt;
    &lt;section&gt;&lt;slot </span><strong class="bold"><span class="koboSpan" id="kobo.621.1">name="sidebar"</span></strong><span class="koboSpan" id="kobo.622.1">&gt;&lt;/slot&gt;&lt;/section&gt;
    &lt;header&gt;&lt;slot </span><strong class="bold"><span class="koboSpan" id="kobo.623.1">name="header"</span></strong><span class="koboSpan" id="kobo.624.1">&gt;&lt;/slot&gt;&lt;/header&gt;
    &lt;main&gt;&lt;slot </span><strong class="bold"><span class="koboSpan" id="kobo.625.1">name="content"</span></strong><span class="koboSpan" id="kobo.626.1">&gt;&lt;/slot&gt;&lt;/main&gt;
&lt;/div&gt;</span></pre>
<p><span class="koboSpan" id="kobo.627.1">As you can see, we have named each slot through the </span><em class="italic"><span class="koboSpan" id="kobo.628.1">name attribute</span></em><span class="koboSpan" id="kobo.629.1">. </span><span class="koboSpan" id="kobo.629.2">In the parent component, we must now use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">template</span></strong><span class="koboSpan" id="kobo.631.1"> element with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.632.1">v-slot</span></strong><span class="koboSpan" id="kobo.633.1"> directive to access each one. </span><span class="koboSpan" id="kobo.633.2">Here is how a parent component would make use </span><span class="No-Break"><span class="koboSpan" id="kobo.634.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.635.1">MyLayout</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.636.1">:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.637.1">Parent component</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.638.1">
&lt;MyLayout&gt;
    &lt;template </span><strong class="bold"><span class="koboSpan" id="kobo.639.1">v-slot="sidebar"</span></strong><span class="koboSpan" id="kobo.640.1">&gt; ... </span><span class="koboSpan" id="kobo.640.2">&lt;/template&gt;
    &lt;template </span><strong class="bold"><span class="koboSpan" id="kobo.641.1">v-slot="header"</span></strong><span class="koboSpan" id="kobo.642.1">&gt; ... </span><span class="koboSpan" id="kobo.642.2">&lt;/template&gt;
    &lt;template </span><strong class="bold"><span class="koboSpan" id="kobo.643.1">v-slot="content"</span></strong><span class="koboSpan" id="kobo.644.1">&gt; ... </span><span class="koboSpan" id="kobo.644.2">&lt;/template&gt;
&lt;/MyLayout&gt;</span></pre>
<p><span class="koboSpan" id="kobo.645.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.646.1">v-slot</span></strong><span class="koboSpan" id="kobo.647.1"> directive receives one argument, matching the slot name, with </span><span class="No-Break"><span class="koboSpan" id="kobo.648.1">these remarks:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.649.1">If the name does not match any available slot, the content is </span><span class="No-Break"><span class="koboSpan" id="kobo.650.1">not rendered.</span></span></li>
<li><span class="koboSpan" id="kobo.651.1">If no name is provided, or the name </span><strong class="source-inline"><span class="koboSpan" id="kobo.652.1">default</span></strong><span class="koboSpan" id="kobo.653.1"> is used, then the content is rendered in the default </span><span class="No-Break"><span class="koboSpan" id="kobo.654.1">nameless slot.</span></span></li>
<li><span class="koboSpan" id="kobo.655.1">If no content is provided for a template, then the default elements inside of the slot definition will be shown. </span><span class="koboSpan" id="kobo.655.2">Default content is placed in between the slot tags: </span><strong class="source-inline"><span class="koboSpan" id="kobo.656.1">&lt;slot&gt;...default </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">content here...&lt;/slot&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.658.1">.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.659.1">There is </span><a id="_idIndexMarker349"/><span class="koboSpan" id="kobo.660.1">also a shorthand notation for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">v-slot</span></strong><span class="koboSpan" id="kobo.662.1"> directive. </span><span class="koboSpan" id="kobo.662.2">We just prefix </span><a id="_idIndexMarker350"/><span class="koboSpan" id="kobo.663.1">the name of the slot with a numeral sign (</span><strong class="source-inline"><span class="koboSpan" id="kobo.664.1">#</span></strong><span class="koboSpan" id="kobo.665.1">). </span><span class="koboSpan" id="kobo.665.2">For example, the templates in the preceding parent component can be simplified </span><span class="No-Break"><span class="koboSpan" id="kobo.666.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.667.1">
&lt;template </span><strong class="bold"><span class="koboSpan" id="kobo.668.1">#sidebar</span></strong><span class="koboSpan" id="kobo.669.1">&gt; ... </span><span class="koboSpan" id="kobo.669.2">&lt;/template&gt;
&lt;template </span><strong class="bold"><span class="koboSpan" id="kobo.670.1">#header</span></strong><span class="koboSpan" id="kobo.671.1">&gt; ... </span><span class="koboSpan" id="kobo.671.2">&lt;/template&gt;
&lt;template </span><strong class="bold"><span class="koboSpan" id="kobo.672.1">#content</span></strong><span class="koboSpan" id="kobo.673.1">&gt; ... </span><span class="koboSpan" id="kobo.673.2">&lt;/template&gt;</span></pre>
<p><span class="koboSpan" id="kobo.674.1">Slots in Vue 3 are very powerful, to the point that they even admit a way to pass props to the parent if needed. </span><span class="koboSpan" id="kobo.674.2">The </span><a id="_idIndexMarker351"/><span class="koboSpan" id="kobo.675.1">syntax varies depending on whether we are using a </span><em class="italic"><span class="koboSpan" id="kobo.676.1">default slot</span></em><span class="koboSpan" id="kobo.677.1"> or </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.678.1">named slots</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.679.1">.</span></span><span class="koboSpan" id="kobo.680.1">
For </span><a id="_idIndexMarker352"/><span class="koboSpan" id="kobo.681.1">example, consider the following component </span><span class="No-Break"><span class="koboSpan" id="kobo.682.1">template definition:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.683.1">PassingPropsUpward component</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.684.1">
&lt;div&gt;
    &lt;slot </span><strong class="bold"><span class="koboSpan" id="kobo.685.1">:data="some_text"</span></strong><span class="koboSpan" id="kobo.686.1">&gt;&lt;/data&gt;
&lt;/div&gt;</span></pre>
<p><span class="koboSpan" id="kobo.687.1">Here, the slot is passing a prop to the parent, named </span><strong class="source-inline"><span class="koboSpan" id="kobo.688.1">data</span></strong><span class="koboSpan" id="kobo.689.1">. </span><span class="koboSpan" id="kobo.689.2">The parent component can then access it with the </span><span class="No-Break"><span class="koboSpan" id="kobo.690.1">following syntax:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.691.1">Parent component receiving props from the slot</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.692.1">
&lt;PassingPropsUpward </span><strong class="bold"><span class="koboSpan" id="kobo.693.1">v-slot="upwardProp"</span></strong><span class="koboSpan" id="kobo.694.1">&gt;
    </span><strong class="bold"><span class="koboSpan" id="kobo.695.1">{{upwardProp.data}} </span></strong><span class="koboSpan" id="kobo.696.1">//Renders the content of some_text
&lt;/PassingPropsUpward&gt;</span></pre>
<p><span class="koboSpan" id="kobo.697.1">In the parent component, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.698.1">v-slot</span></strong><span class="koboSpan" id="kobo.699.1"> directive and assign a local name to the props passed by the slot – in this case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">upwardProp</span></strong><span class="koboSpan" id="kobo.701.1">. </span><span class="koboSpan" id="kobo.701.2">This variable will receive an object similar in function to the props object but scoped to the element. </span><span class="koboSpan" id="kobo.701.3">Because of this, these types of slots are </span><a id="_idIndexMarker353"/><span class="koboSpan" id="kobo.702.1">called </span><em class="italic"><span class="koboSpan" id="kobo.703.1">named scoped slots</span></em><span class="koboSpan" id="kobo.704.1">, and the syntax is similar. </span><span class="koboSpan" id="kobo.704.2">Take a look at </span><span class="No-Break"><span class="koboSpan" id="kobo.705.1">this example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.706.1">
&lt;template </span><strong class="bold"><span class="koboSpan" id="kobo.707.1">#header="upwardProp"</span></strong><span class="koboSpan" id="kobo.708.1">&gt;
    {{</span><strong class="bold"><span class="koboSpan" id="kobo.709.1">upwardProp</span></strong><span class="koboSpan" id="kobo.710.1">.data}}
&lt;/template&gt;</span></pre>
<p><span class="koboSpan" id="kobo.711.1">There are </span><a id="_idIndexMarker354"/><span class="koboSpan" id="kobo.712.1">other advanced uses for slots that cover edge cases, but we will not cover those in this book. </span><span class="koboSpan" id="kobo.712.2">Instead, I encourage you to investigate the topic further in the official </span><a id="_idIndexMarker355"/><span class="koboSpan" id="kobo.713.1">documentation </span><span class="No-Break"><span class="koboSpan" id="kobo.714.1">at </span></span><a href="https://vuejs.org/guide/components/slots.html"><span class="No-Break"><span class="koboSpan" id="kobo.715.1">https://vuejs.org/guide/components/slots.html</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.716.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.717.1">There is one more concept related to this topic that we will see later in this book, in </span><a href="B18602_07.xhtml#_idTextAnchor173"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.718.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.719.1">, </span><em class="italic"><span class="koboSpan" id="kobo.720.1">Data Flow Management</span></em><span class="koboSpan" id="kobo.721.1">, that applies to reactive central state management. </span><span class="koboSpan" id="kobo.721.2">Now, let’s look at some special components that behave a bit out of </span><span class="No-Break"><span class="koboSpan" id="kobo.722.1">the ordinary.</span></span></p>
<h2 id="_idParaDest-94"><a id="_idTextAnchor120"/><span class="koboSpan" id="kobo.723.1">Composables and mixins</span></h2>
<p><span class="koboSpan" id="kobo.724.1">In Vue 2, a special </span><a id="_idIndexMarker356"/><span class="koboSpan" id="kobo.725.1">component </span><a id="_idIndexMarker357"/><span class="koboSpan" id="kobo.726.1">named </span><strong class="bold"><span class="koboSpan" id="kobo.727.1">mixin</span></strong><span class="koboSpan" id="kobo.728.1"> allowed us to share code between components, thus avoiding code repetition. </span><span class="koboSpan" id="kobo.728.2">This approach created several issues and troubling side effects, whose solution evolved into creating the Composition API in Vue 3. </span><span class="koboSpan" id="kobo.728.3">The use of mixins is still supported for backward compatibility, but strongly discouraged. </span><span class="koboSpan" id="kobo.728.4">We will not cover mixins in this book; instead, we will focus on the technology that has replaced and surpassed </span><span class="No-Break"><span class="koboSpan" id="kobo.729.1">them: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">composables</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.731.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.732.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.733.1">composable</span></strong><span class="koboSpan" id="kobo.734.1"> is</span><a id="_idIndexMarker358"/><span class="koboSpan" id="kobo.735.1"> a function that uses the Composition API to </span><a id="_idIndexMarker359"/><span class="koboSpan" id="kobo.736.1">encapsulate and reuse </span><em class="italic"><span class="koboSpan" id="kobo.737.1">stateful logic</span></em><span class="koboSpan" id="kobo.738.1"> between components. </span><span class="koboSpan" id="kobo.738.2">It is important to distinguish composables from service classes or other encapsulations of </span><em class="italic"><span class="koboSpan" id="kobo.739.1">business logic</span></em><span class="koboSpan" id="kobo.740.1">. </span><span class="koboSpan" id="kobo.740.2">The main purpose of a composable is to share </span><em class="italic"><span class="koboSpan" id="kobo.741.1">user interface or user interaction logic</span></em><span class="koboSpan" id="kobo.742.1">. </span><span class="koboSpan" id="kobo.742.2">In general, each composable does </span><span class="No-Break"><span class="koboSpan" id="kobo.743.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.744.1">Exposes a function that returns </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.745.1">reactive</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.746.1"> variables.</span></span></li>
<li><span class="koboSpan" id="kobo.747.1">Follows a naming convention prefixed with </span><strong class="source-inline"><span class="koboSpan" id="kobo.748.1">use</span></strong><span class="koboSpan" id="kobo.749.1"> in </span><em class="italic"><span class="koboSpan" id="kobo.750.1">camelCase</span></em><span class="koboSpan" id="kobo.751.1"> format – for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.752.1">useStore()</span></strong><span class="koboSpan" id="kobo.753.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.754.1">useAdmin()</span></strong><span class="koboSpan" id="kobo.755.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.756.1">useWindowsEvents()</span></strong><span class="koboSpan" id="kobo.757.1">, and </span><span class="No-Break"><span class="koboSpan" id="kobo.758.1">so on.</span></span></li>
<li><span class="koboSpan" id="kobo.759.1">It is self-contained in its </span><span class="No-Break"><span class="koboSpan" id="kobo.760.1">own module.</span></span></li>
<li><span class="koboSpan" id="kobo.761.1">It handles </span><em class="italic"><span class="koboSpan" id="kobo.762.1">stateful logic</span></em><span class="koboSpan" id="kobo.763.1">. </span><span class="koboSpan" id="kobo.763.2">This means that it manages data that persists and changes </span><span class="No-Break"><span class="koboSpan" id="kobo.764.1">over time.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.765.1">The classical example </span><a id="_idIndexMarker360"/><span class="koboSpan" id="kobo.766.1">of a composable attaches itself to environmental </span><a id="_idIndexMarker361"/><span class="koboSpan" id="kobo.767.1">events (window resizing, mouse movements, sensors, animations, and so on). </span><span class="koboSpan" id="kobo.767.2">Let’s implement a simple composable that reads the vertical scroll of </span><span class="No-Break"><span class="koboSpan" id="kobo.768.1">the document:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.769.1">DocumentScroll.js</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.770.1">
import {</span><strong class="bold"><span class="koboSpan" id="kobo.771.1">ref, onMounted, onUnmounted}</span></strong><span class="koboSpan" id="kobo.772.1"> from "vue"                //1
function </span><strong class="bold"><span class="koboSpan" id="kobo.773.1">useDocumentScroll</span></strong><span class="koboSpan" id="kobo.774.1">(){
    </span><strong class="bold"><span class="koboSpan" id="kobo.775.1">const y=ref(window.scrollY)</span></strong><span class="koboSpan" id="kobo.776.1">                                //2
    function update(){</span><strong class="bold"><span class="koboSpan" id="kobo.777.1">y.value=window.scrollY</span></strong><span class="koboSpan" id="kobo.778.1">}
    onMounted(()=&gt;{
        document.addEventListener('scroll', update)})          //3
    onUnmounted (()=&gt;{
        document.removeEventListener('scroll', update)})       //4
</span><strong class="bold"><span class="koboSpan" id="kobo.779.1">    return {y}</span></strong><span class="koboSpan" id="kobo.780.1">                                                 //5
}
export </span><strong class="bold"><span class="koboSpan" id="kobo.781.1">{useDocumentScroll}</span></strong><span class="koboSpan" id="kobo.782.1">;                                    //6</span></pre>
<p><span class="koboSpan" id="kobo.783.1">In this small composable, we start by importing component's life cycle events and the reactive constructor from Vue (</span><strong class="source-inline"><span class="koboSpan" id="kobo.784.1">//1</span></strong><span class="koboSpan" id="kobo.785.1">). </span><span class="koboSpan" id="kobo.785.2">Our main function, </span><strong class="source-inline"><span class="koboSpan" id="kobo.786.1">useDocumentScroll</span></strong><span class="koboSpan" id="kobo.787.1">, contains the entire code that we will share and export later (</span><strong class="source-inline"><span class="koboSpan" id="kobo.788.1">//6</span></strong><span class="koboSpan" id="kobo.789.1">). </span><span class="koboSpan" id="kobo.789.2">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.790.1">//2</span></strong><span class="koboSpan" id="kobo.791.1">, we create a reactive constant and initialize it to the current window vertical scroll. </span><span class="koboSpan" id="kobo.791.2">Then, we create an internal function, </span><strong class="source-inline"><span class="koboSpan" id="kobo.792.1">update</span></strong><span class="koboSpan" id="kobo.793.1">, that updates the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.794.1">y</span></strong><span class="koboSpan" id="kobo.795.1">. </span><span class="koboSpan" id="kobo.795.2">We add this function as a listener to the document scroll event in </span><strong class="source-inline"><span class="koboSpan" id="kobo.796.1">//3</span></strong><span class="koboSpan" id="kobo.797.1">, and then remove it in </span><strong class="source-inline"><span class="koboSpan" id="kobo.798.1">//4 </span></strong><span class="koboSpan" id="kobo.799.1">(principle</span><em class="italic"><span class="koboSpan" id="kobo.800.1"> “Clean after yourself,” </span></em><span class="koboSpan" id="kobo.801.1">from </span><a href="B18602_02.xhtml#_idTextAnchor040"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.802.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.803.1">, </span><em class="italic"><span class="koboSpan" id="kobo.804.1">Software Design Principles and Patterns</span></em><span class="koboSpan" id="kobo.805.1">). </span><span class="koboSpan" id="kobo.805.2">Finally, in </span><strong class="source-inline"><span class="koboSpan" id="kobo.806.1">//5</span></strong><span class="koboSpan" id="kobo.807.1">, we return our reactive constant wrapped in an object. </span><span class="koboSpan" id="kobo.807.2">Then, in a component, we use this composable in </span><span class="No-Break"><span class="koboSpan" id="kobo.808.1">this way:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.809.1">SomeComponent.js – script setup</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.810.1">
import {useDocumentScroll} from "./DocumentScroll.js"
const {y}=useDocumentScroll()
...</span></pre>
<p><span class="koboSpan" id="kobo.811.1">Once we have</span><a id="_idIndexMarker362"/><span class="koboSpan" id="kobo.812.1"> imported the reactive variable, we can use it in our code </span><a id="_idIndexMarker363"/><span class="koboSpan" id="kobo.813.1">and template as usual. </span><span class="koboSpan" id="kobo.813.2">If we need to use this bit of logic in more than one component, we </span><a id="_idIndexMarker364"/><span class="koboSpan" id="kobo.814.1">just need to import the composable (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.815.1">DRY</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.816.1"> principle).</span></span></p>
<p><span class="koboSpan" id="kobo.817.1">Finally, </span><a href="https://vueuse.org/"><span class="koboSpan" id="kobo.818.1">https://vueuse.org/</span></a><span class="koboSpan" id="kobo.819.1"> has an impressive collection of composables for </span><span class="No-Break"><span class="koboSpan" id="kobo.820.1">our projects.</span></span><span class="koboSpan" id="kobo.821.1">
It is worth </span><span class="No-Break"><span class="koboSpan" id="kobo.822.1">checking out.</span></span></p>
<h2 id="_idParaDest-95"><a id="_idTextAnchor121"/><span class="koboSpan" id="kobo.823.1">Dynamic components with “component:is”</span></h2>
<p><span class="koboSpan" id="kobo.824.1">The Vue 3 framework</span><a id="_idIndexMarker365"/><span class="koboSpan" id="kobo.825.1"> provides a special component called </span><strong class="source-inline"><span class="koboSpan" id="kobo.826.1">&lt;component&gt;</span></strong><span class="koboSpan" id="kobo.827.1"> whose job is to be a placeholder to render other components dynamically. </span><span class="koboSpan" id="kobo.827.2">It works with a special attribute, </span><strong class="source-inline"><span class="koboSpan" id="kobo.828.1">:is</span></strong><span class="koboSpan" id="kobo.829.1">, that can receive either a </span><strong class="bold"><span class="koboSpan" id="kobo.830.1">String</span></strong><span class="koboSpan" id="kobo.831.1"> with the name of a component, or a variable with the component definition. </span><span class="koboSpan" id="kobo.831.2">It also accepts some basic expressions (a line of code that resolves to a value). </span><span class="koboSpan" id="kobo.831.3">Here is a simple example using </span><span class="No-Break"><span class="koboSpan" id="kobo.832.1">an expression:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.833.1">CoinFlip component</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.834.1">
&lt;script setup&gt;
    import </span><strong class="bold"><span class="koboSpan" id="kobo.835.1">Heads </span></strong><span class="koboSpan" id="kobo.836.1">from "./heads.vue"
    import </span><strong class="bold"><span class="koboSpan" id="kobo.837.1">Tails </span></strong><span class="koboSpan" id="kobo.838.1">from "./tails.vue"
    function </span><strong class="bold"><span class="koboSpan" id="kobo.839.1">flipCoin</span></strong><span class="koboSpan" id="kobo.840.1">(){return Math.random() &gt; 0.5}
&lt;/script&gt;
&lt;template&gt;
    &lt;component </span><strong class="bold"><span class="koboSpan" id="kobo.841.1">:is="flipCoin()?Heads:Tails"</span></strong><span class="koboSpan" id="kobo.842.1">&gt;&lt;/component&gt;
&lt;/template</span></pre>
<p><span class="koboSpan" id="kobo.843.1">When this component is rendered, we will see either the </span><strong class="source-inline"><span class="koboSpan" id="kobo.844.1">Heads</span></strong><span class="koboSpan" id="kobo.845.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.846.1">Tails</span></strong><span class="koboSpan" id="kobo.847.1"> component based on the result of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.848.1">flipCoin()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.849.1"> function.</span></span></p>
<p><span class="koboSpan" id="kobo.850.1">At this point, you might be wondering, why not use a simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.851.1">v-show/v-if</span></strong><span class="koboSpan" id="kobo.852.1">? </span><span class="koboSpan" id="kobo.852.2">The power of this component becomes apparent when managing components dynamically and we don’t know which ones are available at the time of creating the template. </span><span class="koboSpan" id="kobo.852.3">The official Vue Router, which we will see in </span><a href="B18602_05.xhtml#_idTextAnchor130"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.853.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.854.1">, </span><em class="italic"><span class="koboSpan" id="kobo.855.1">Single-Page Applications</span></em><span class="koboSpan" id="kobo.856.1">, uses this special component to simulate </span><span class="No-Break"><span class="koboSpan" id="kobo.857.1">page navigation.</span></span></p>
<p><span class="koboSpan" id="kobo.858.1">There is an edge case, however, that we need to be aware of. </span><span class="koboSpan" id="kobo.858.2">While most template attributes will pass through to the dynamic component, the use of some directives such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.859.1">v-model</span></strong><span class="koboSpan" id="kobo.860.1"> will not work on </span><em class="italic"><span class="koboSpan" id="kobo.861.1">native input elements</span></em><span class="koboSpan" id="kobo.862.1">. </span><span class="koboSpan" id="kobo.862.2">This situation is so rare that we will not discuss it in detail, but it can be found in the official documentation </span><span class="No-Break"><span class="koboSpan" id="kobo.863.1">at </span></span><a href="https://vuejs.org/api/built-in-special-elements.html#component"><span class="No-Break"><span class="koboSpan" id="kobo.864.1">https://vuejs.org/api/built-in-special-elements.html#component</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.865.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.866.1">Now that we have a deeper understanding of components, let’s put this new knowledge to work in two projects: a plugin, and a new version of our </span><span class="No-Break"><span class="koboSpan" id="kobo.867.1">To-Do application.</span></span></p>
<h1 id="_idParaDest-96"><a id="_idTextAnchor122"/><span class="koboSpan" id="kobo.868.1">A real-world example – a modals plugin</span></h1>
<p><span class="koboSpan" id="kobo.869.1">We have seen multiple approaches for sharing data and functionality </span><em class="italic"><span class="koboSpan" id="kobo.870.1">within</span></em><span class="koboSpan" id="kobo.871.1"> a project. </span><span class="koboSpan" id="kobo.871.2">Plugins</span><a id="_idIndexMarker366"/><span class="koboSpan" id="kobo.872.1"> are a design pattern for sharing functionality between projects and at the same time augmenting a system’s capabilities. </span><span class="koboSpan" id="kobo.872.2">Vue 3 provides a very simple interface to create plugins and attach them to our application instance. </span><span class="koboSpan" id="kobo.872.3">Any object that exposes an </span><strong class="source-inline"><span class="koboSpan" id="kobo.873.1">install()</span></strong><span class="koboSpan" id="kobo.874.1"> method or a function that accepts the same parameters can become a plugin. </span><span class="koboSpan" id="kobo.874.2">A plugin can do </span><span class="No-Break"><span class="koboSpan" id="kobo.875.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.876.1">Register </span><a id="_idIndexMarker367"/><span class="koboSpan" id="kobo.877.1">global components </span><span class="No-Break"><span class="koboSpan" id="kobo.878.1">and directives</span></span></li>
<li><span class="koboSpan" id="kobo.879.1">Register an injectable resource at the </span><span class="No-Break"><span class="koboSpan" id="kobo.880.1">application level</span></span></li>
<li><span class="koboSpan" id="kobo.881.1">Create and attach new properties or methods to </span><span class="No-Break"><span class="koboSpan" id="kobo.882.1">the application</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.883.1">In this section, we will create a plugin that implements modal dialogs as global components. </span><span class="koboSpan" id="kobo.883.2">We will use dependency injection to provide them as a resource and leverage Vue’s reactivity to manage them </span><span class="No-Break"><span class="koboSpan" id="kobo.884.1">through promises.</span></span></p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor123"/><span class="koboSpan" id="kobo.885.1">Setting up our development project</span></h2>
<p><span class="koboSpan" id="kobo.886.1">Follow the</span><a id="_idIndexMarker368"/><span class="koboSpan" id="kobo.887.1"> instructions in </span><a href="B18602_03.xhtml#_idTextAnchor079"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.888.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.889.1">, </span><em class="italic"><span class="koboSpan" id="kobo.890.1">Setting Up a Working Project</span></em><span class="koboSpan" id="kobo.891.1">, so that you have a starting point. </span><span class="koboSpan" id="kobo.891.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.892.1">src/</span></strong><span class="koboSpan" id="kobo.893.1"> directory, create a new folder named </span><strong class="source-inline"><span class="koboSpan" id="kobo.894.1">plugins/</span></strong><span class="koboSpan" id="kobo.895.1">, with a sub-folder named </span><strong class="source-inline"><span class="koboSpan" id="kobo.896.1">modals/</span></strong><span class="koboSpan" id="kobo.897.1">. </span><span class="koboSpan" id="kobo.897.2">It is a standard approach to place our plugins in individual directories inside the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.898.1">plugins/</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.899.1"> folder.</span></span></p>
<h2 id="_idParaDest-98"><a id="_idTextAnchor124"/><span class="koboSpan" id="kobo.900.1">The design</span></h2>
<p><span class="koboSpan" id="kobo.901.1">Our plugin will install a </span><a id="_idIndexMarker369"/><span class="koboSpan" id="kobo.902.1">component globally and keep an internal reactive state to track the current modal dialog status. </span><span class="koboSpan" id="kobo.902.2">It will also provide an API to be injected as a dependency to those components that need to open a modal dialog. </span><span class="koboSpan" id="kobo.902.3">This interaction can be represented </span><span class="No-Break"><span class="koboSpan" id="kobo.903.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer028">
<span class="koboSpan" id="kobo.904.1"><img alt="Figure 4.6 ﻿– The modal plugin’s representation" src="image/Figure_4.06_B18602.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.905.1">Figure 4.6 – The modal plugin’s representation</span></p>
<p><span class="koboSpan" id="kobo.906.1">Components </span><a id="_idIndexMarker370"/><span class="koboSpan" id="kobo.907.1">will implement a modal element, and we will open the dialog through code. </span><span class="koboSpan" id="kobo.907.2">When a modal is open, it will return a promise following the async pattern. </span><span class="koboSpan" id="kobo.907.3">When the user accepts the modal, the promise will resolve, and reject upon cancellation. </span><span class="koboSpan" id="kobo.907.4">The content of the modal will be provided by the parent component through the use </span><span class="No-Break"><span class="koboSpan" id="kobo.908.1">of slots.</span></span></p>
<h2 id="_idParaDest-99"><a id="_idTextAnchor125"/><span class="koboSpan" id="kobo.909.1">The implementation</span></h2>
<p><span class="koboSpan" id="kobo.910.1">For this plugin, we will only need two</span><a id="_idIndexMarker371"/><span class="koboSpan" id="kobo.911.1"> files – one for the plugin's logic and one for our component. </span><span class="koboSpan" id="kobo.911.2">Go ahead and create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.912.1">index.js</span></strong><span class="koboSpan" id="kobo.913.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.914.1">Modal.vue</span></strong><span class="koboSpan" id="kobo.915.1"> files in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.916.1">src/plugins/modal</span></strong><span class="koboSpan" id="kobo.917.1"> folder. </span><span class="koboSpan" id="kobo.917.2">At the moment, just scaffold the component with the section’s script setup, template, and style. </span><span class="koboSpan" id="kobo.917.3">We will come back later to complete it. </span><span class="koboSpan" id="kobo.917.4">With those files in place, let’s start, step by step, with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.918.1">index.js</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.919.1"> file:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.920.1">/src/plugins/modals/index.js</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.921.1">
import { reactive } from "vue"                     //1
import Modal from "./Modal.vue"
const
    _current = reactive({}),                       //2
    api = {},                                      //3
    </span><strong class="bold"><span class="koboSpan" id="kobo.922.1">plugin = {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.923.1">        install(App, options) {</span></strong><span class="koboSpan" id="kobo.924.1">                    </span><strong class="bold"><span class="koboSpan" id="kobo.925.1">//4</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.926.1">            App.component("Modal", Modal)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.927.1">            App.provide("$modals", api)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.928.1">        }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.929.1">    }</span></strong><span class="koboSpan" id="kobo.930.1">
export default </span><strong class="bold"><span class="koboSpan" id="kobo.931.1">plugin</span></strong></pre>
<p><span class="koboSpan" id="kobo.932.1">We start in </span><strong class="source-inline"><span class="koboSpan" id="kobo.933.1">//1</span></strong><span class="koboSpan" id="kobo.934.1"> by importing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.935.1">reactive</span></strong><span class="koboSpan" id="kobo.936.1"> constructor from Vue, and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.937.1">Modal </span></strong><span class="koboSpan" id="kobo.938.1">component whose file we have not yet created. </span><span class="koboSpan" id="kobo.938.2">Then, in line </span><strong class="source-inline"><span class="koboSpan" id="kobo.939.1">//2</span></strong><span class="koboSpan" id="kobo.940.1">, we create an internal state property, </span><strong class="source-inline"><span class="koboSpan" id="kobo.941.1">_current</span></strong><span class="koboSpan" id="kobo.942.1">, and in </span><strong class="source-inline"><span class="koboSpan" id="kobo.943.1">//3</span></strong><span class="koboSpan" id="kobo.944.1">, an object that will be our API. </span><span class="koboSpan" id="kobo.944.2">For now, these are just placeholders. </span><span class="koboSpan" id="kobo.944.3">The important section is in line </span><strong class="source-inline"><span class="koboSpan" id="kobo.945.1">//4</span></strong><span class="koboSpan" id="kobo.946.1">, where we define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.947.1">install()</span></strong><span class="koboSpan" id="kobo.948.1"> function. </span><span class="koboSpan" id="kobo.948.2">This function receives two parameters </span><span class="No-Break"><span class="koboSpan" id="kobo.949.1">in order:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.950.1">The application </span><span class="No-Break"><span class="koboSpan" id="kobo.951.1">instance (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.952.1">App</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.953.1">).</span></span></li>
<li><span class="koboSpan" id="kobo.954.1">An object with options, if one was passed during the </span><span class="No-Break"><span class="koboSpan" id="kobo.955.1">installation process.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.956.1">With the application </span><a id="_idIndexMarker372"/><span class="koboSpan" id="kobo.957.1">instance, we register </span><strong class="source-inline"><span class="koboSpan" id="kobo.958.1">Modal</span></strong><span class="koboSpan" id="kobo.959.1"> as a global component and provide the API as an injectable resource under the name </span><strong class="source-inline"><span class="koboSpan" id="kobo.960.1">$modals,</span></strong><span class="koboSpan" id="kobo.961.1"> both at the application level. </span><span class="koboSpan" id="kobo.961.2">To use the plugin in our application, we must import it into </span><strong class="source-inline"><span class="koboSpan" id="kobo.962.1">main.js</span></strong><span class="koboSpan" id="kobo.963.1"> and register it with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.964.1">use</span></strong><span class="koboSpan" id="kobo.965.1"> method. </span><span class="koboSpan" id="kobo.965.2">The code looks </span><span class="No-Break"><span class="koboSpan" id="kobo.966.1">like this:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.967.1">/src/Main.js</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.968.1">
import { createApp } from 'vue'
import App from './App.vue'
</span><strong class="bold"><span class="koboSpan" id="kobo.969.1">import Modals from "./plugins/modals"</span></strong><span class="koboSpan" id="kobo.970.1">
createApp(App)</span><strong class="bold"><span class="koboSpan" id="kobo.971.1">.use(Modals)</span></strong><span class="koboSpan" id="kobo.972.1">.mount('#app')</span></pre>
<p><span class="koboSpan" id="kobo.973.1">As you can see, creating and using a plugin is rather simple. </span><span class="koboSpan" id="kobo.973.2">However, thus far, our plugin doesn’t do much. </span><span class="koboSpan" id="kobo.973.3">Let’s go back to our plugin code and complete the API. </span><span class="koboSpan" id="kobo.973.4">What we need is </span><span class="No-Break"><span class="koboSpan" id="kobo.974.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.975.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.976.1">show()</span></strong><span class="koboSpan" id="kobo.977.1"> method that takes a name that identifies a modal dialog implementation and returns a promise. </span><span class="koboSpan" id="kobo.977.2">We will then save the name and references to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.978.1">resolve()</span></strong><span class="koboSpan" id="kobo.979.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.980.1">reject()</span></strong><span class="koboSpan" id="kobo.981.1"> functions in our </span><span class="No-Break"><span class="koboSpan" id="kobo.982.1">reactive state.</span></span></li>
<li><span class="koboSpan" id="kobo.983.1">An </span><strong class="source-inline"><span class="koboSpan" id="kobo.984.1">accept()</span></strong><span class="koboSpan" id="kobo.985.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.986.1">cancel()</span></strong><span class="koboSpan" id="kobo.987.1"> methods, to resolve and reject the </span><span class="No-Break"><span class="koboSpan" id="kobo.988.1">promise, respectively.</span></span></li>
<li><span class="koboSpan" id="kobo.989.1">An </span><strong class="source-inline"><span class="koboSpan" id="kobo.990.1">active()</span></strong><span class="koboSpan" id="kobo.991.1"> method to retrieve the name of the </span><span class="No-Break"><span class="koboSpan" id="kobo.992.1">current modal.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.993.1">Following these guidelines, we can complete the code so that our </span><strong class="source-inline"><span class="koboSpan" id="kobo.994.1">index.js</span></strong><span class="koboSpan" id="kobo.995.1"> file looks </span><span class="No-Break"><span class="koboSpan" id="kobo.996.1">like this:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.997.1">/src/plugins/modals/index.js</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.998.1">
import { reactive } from "vue"
import Modal from "./Modal.vue"
const
_current = reactive({</span><strong class="bold"><span class="koboSpan" id="kobo.999.1">name:"",resolve:null,reject:null</span></strong><span class="koboSpan" id="kobo.1000.1">}),
api = {
</span><strong class="bold"><span class="koboSpan" id="kobo.1001.1">      active()</span></strong><span class="koboSpan" id="kobo.1002.1"> {return _current.name;},
</span><strong class="bold"><span class="koboSpan" id="kobo.1003.1">      show(name)</span></strong><span class="koboSpan" id="kobo.1004.1"> {
</span><strong class="bold"><span class="koboSpan" id="kobo.1005.1">           _current.name = name;</span></strong><span class="koboSpan" id="kobo.1006.1">
           return new Promise(
           (resolve = () =&gt; { }, reject = () =&gt; { }) =&gt; {
</span><strong class="bold"><span class="koboSpan" id="kobo.1007.1">                _current.resolve = resolve;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1008.1">                _current.reject = reject;</span></strong><span class="koboSpan" id="kobo.1009.1">
           })
</span><strong class="bold"><span class="koboSpan" id="kobo.1010.1">      </span></strong><span class="koboSpan" id="kobo.1011.1">},
</span><strong class="bold"><span class="koboSpan" id="kobo.1012.1">      accept()</span></strong><span class="koboSpan" id="kobo.1013.1"> {</span><strong class="bold"><span class="koboSpan" id="kobo.1014.1">_current.resolve();_current.name = "" </span></strong><span class="koboSpan" id="kobo.1015.1">},
</span><strong class="bold"><span class="koboSpan" id="kobo.1016.1">      cancel()</span></strong><span class="koboSpan" id="kobo.1017.1"> {</span><strong class="bold"><span class="koboSpan" id="kobo.1018.1">_current.reject();_current.name = "" </span></strong><span class="koboSpan" id="kobo.1019.1">}
},
plugin = {...} // Omitted for brevity
export default plugin;</span></pre>
<p><span class="koboSpan" id="kobo.1020.1">Our internal state is kept with a</span><a id="_idIndexMarker373"/> <strong class="source-inline"><span class="koboSpan" id="kobo.1021.1">reactive</span></strong><span class="koboSpan" id="kobo.1022.1"> variable and only accessed through our API. </span><span class="koboSpan" id="kobo.1022.2">In general, this is a good design for any API. </span><span class="koboSpan" id="kobo.1022.3">Now, it is time to make the magic happen in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1023.1">Modal.vue</span></strong><span class="koboSpan" id="kobo.1024.1"> component, to complete the workflow. </span><span class="koboSpan" id="kobo.1024.2">I’m omitting the classes and styles for brevity, but the full code can be found in this book’s GitHub repository </span><span class="No-Break"><span class="koboSpan" id="kobo.1025.1">at </span></span><a href="https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices"><span class="No-Break"><span class="koboSpan" id="kobo.1026.1">https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1027.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1028.1">Our modal component will have to do </span><span class="No-Break"><span class="koboSpan" id="kobo.1029.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1030.1">Cover the entire viewable area with a translucent element to block interaction with the rest of </span><span class="No-Break"><span class="koboSpan" id="kobo.1031.1">the application</span></span></li>
<li><span class="koboSpan" id="kobo.1032.1">Provide the dialog to </span><span class="No-Break"><span class="koboSpan" id="kobo.1033.1">be displayed:</span></span><ul><li><span class="koboSpan" id="kobo.1034.1">A </span><em class="italic"><span class="koboSpan" id="kobo.1035.1">prop</span></em><span class="koboSpan" id="kobo.1036.1"> to register the name of the component, as provided by </span><span class="No-Break"><span class="koboSpan" id="kobo.1037.1">the parent.</span></span></li><li><span class="koboSpan" id="kobo.1038.1">A </span><em class="italic"><span class="koboSpan" id="kobo.1039.1">header</span></em><span class="koboSpan" id="kobo.1040.1"> to display a title. </span><span class="koboSpan" id="kobo.1040.2">The title will also be </span><span class="No-Break"><span class="koboSpan" id="kobo.1041.1">a prop.</span></span></li><li><span class="koboSpan" id="kobo.1042.1">An area for the parent component to populate with </span><span class="No-Break"><span class="koboSpan" id="kobo.1043.1">custom content.</span></span></li><li><span class="koboSpan" id="kobo.1044.1">A footer with </span><em class="italic"><span class="koboSpan" id="kobo.1045.1">accept</span></em><span class="koboSpan" id="kobo.1046.1"> and </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1047.1">cancel</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1048.1"> buttons.</span></span></li><li><span class="koboSpan" id="kobo.1049.1">A reactive property that triggers when the component </span><span class="No-Break"><span class="koboSpan" id="kobo.1050.1">should appear.</span></span></li></ul></li>
</ul>
<p><span class="koboSpan" id="kobo.1051.1">With our </span><a id="_idIndexMarker374"/><span class="koboSpan" id="kobo.1052.1">definition in place, let’s work on </span><span class="No-Break"><span class="koboSpan" id="kobo.1053.1">the template:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1054.1">/src/plugins/modals/Modal.vue</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1055.1">
&lt;template&gt;
&lt;div class="viewport-wrapper" </span><strong class="bold"><span class="koboSpan" id="kobo.1056.1">v-if="_show"</span></strong><span class="koboSpan" id="kobo.1057.1">&gt;              //1
  &lt;div class="dialog-wrapper"&gt;
   &lt;header&gt;</span><strong class="bold"><span class="koboSpan" id="kobo.1058.1">{{$props.title}}</span></strong><span class="koboSpan" id="kobo.1059.1">&lt;/header&gt;                     //2
   &lt;main&gt;</span><strong class="bold"><span class="koboSpan" id="kobo.1060.1">&lt;slot&gt;&lt;/slot&gt;</span></strong><span class="koboSpan" id="kobo.1061.1">&lt;/main&gt;                            //3
   &lt;footer&gt;
     &lt;button </span><strong class="bold"><span class="koboSpan" id="kobo.1062.1">@click="closeModal(true)"</span></strong><span class="koboSpan" id="kobo.1063.1">&gt;Accept&lt;/button&gt;   //4
     &lt;button </span><strong class="bold"><span class="koboSpan" id="kobo.1064.1">@click="closeModal(false)</span></strong><span class="koboSpan" id="kobo.1065.1">"&gt;Cancel&lt;/button&gt;
   &lt;/footer&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/template&gt;</span></pre>
<p><span class="koboSpan" id="kobo.1066.1">In line </span><strong class="source-inline"><span class="koboSpan" id="kobo.1067.1">//1</span></strong><span class="koboSpan" id="kobo.1068.1">, the reactive variable, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1069.1">_show</span></strong><span class="koboSpan" id="kobo.1070.1">, controls the visibility of the dialog modal. </span><span class="koboSpan" id="kobo.1070.2">We display the prop </span><strong class="source-inline"><span class="koboSpan" id="kobo.1071.1">title </span></strong><span class="koboSpan" id="kobo.1072.1">in line </span><strong class="source-inline"><span class="koboSpan" id="kobo.1073.1">//2</span></strong><span class="koboSpan" id="kobo.1074.1">, and reserve a slot in line </span><strong class="source-inline"><span class="koboSpan" id="kobo.1075.1">//3</span></strong><span class="koboSpan" id="kobo.1076.1">. </span><span class="koboSpan" id="kobo.1076.2">The buttons in line </span><strong class="source-inline"><span class="koboSpan" id="kobo.1077.1">//4</span></strong><span class="koboSpan" id="kobo.1078.1"> will close the modal on the click event, each one with a representative </span><span class="No-Break"><span class="koboSpan" id="kobo.1079.1">Boolean value.</span></span></p>
<p><span class="koboSpan" id="kobo.1080.1">Not, it’s time to write the logic of the component. </span><span class="koboSpan" id="kobo.1080.2">In our script, we need to do </span><span class="No-Break"><span class="koboSpan" id="kobo.1081.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1082.1">Define two props: </span><strong class="source-inline"><span class="koboSpan" id="kobo.1083.1">title</span></strong><span class="koboSpan" id="kobo.1084.1"> (for display) and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1085.1">name</span></strong><span class="koboSpan" id="kobo.1086.1"> (</span><span class="No-Break"><span class="koboSpan" id="kobo.1087.1">for identification)</span></span></li>
<li><span class="koboSpan" id="kobo.1088.1">Inject the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1089.1">$modals</span></strong><span class="koboSpan" id="kobo.1090.1"> resource so that we can interact with the API and do </span><span class="No-Break"><span class="koboSpan" id="kobo.1091.1">these things:</span></span><ul><li><span class="koboSpan" id="kobo.1092.1">Check if the modal’s name matches the current component (this “opens” the </span><span class="No-Break"><span class="koboSpan" id="kobo.1093.1">modal dialog)</span></span></li><li><span class="koboSpan" id="kobo.1094.1">Close the modal by resolving or rejecting </span><span class="No-Break"><span class="koboSpan" id="kobo.1095.1">the promise</span></span></li></ul></li>
</ul>
<p><span class="koboSpan" id="kobo.1096.1">Following these</span><a id="_idIndexMarker375"/><span class="koboSpan" id="kobo.1097.1"> directions, we can complete our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1098.1">script setup:</span></strong></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1099.1">
&lt;script setup&gt;
  import { </span><strong class="bold"><span class="koboSpan" id="kobo.1100.1">inject</span></strong><span class="koboSpan" id="kobo.1101.1">, computed } from "vue"                 //1
  const
  $props = defineProps({                                 //2
      name: { type: String, default: "" },
      title: { type: String, default: "Modal dialog" }
      }),
  </span><strong class="bold"><span class="koboSpan" id="kobo.1102.1">$modals = inject("$modals")</span></strong><span class="koboSpan" id="kobo.1103.1">,                           //3
  _show = computed(() =&gt; {                               //4
      return </span><strong class="bold"><span class="koboSpan" id="kobo.1104.1">$modals.active() == $props.name</span></strong><span class="koboSpan" id="kobo.1105.1">
  })
  function closeModal(accept = false) {
</span><strong class="bold"><span class="koboSpan" id="kobo.1106.1">      accept?$modals.accept():$modals.cancel()</span></strong><span class="koboSpan" id="kobo.1107.1">           //5
  }
&lt;/script&gt;</span></pre>
<p><span class="koboSpan" id="kobo.1108.1">We begin in line </span><strong class="source-inline"><span class="koboSpan" id="kobo.1109.1">//1</span></strong><span class="koboSpan" id="kobo.1110.1"> by importing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1111.1">inject</span></strong><span class="koboSpan" id="kobo.1112.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1113.1">computed</span></strong><span class="koboSpan" id="kobo.1114.1"> functions. </span><span class="koboSpan" id="kobo.1114.2">In line </span><strong class="source-inline"><span class="koboSpan" id="kobo.1115.1">//2</span></strong><span class="koboSpan" id="kobo.1116.1">, we create the props with sensible defaults. </span><span class="koboSpan" id="kobo.1116.2">In line </span><strong class="source-inline"><span class="koboSpan" id="kobo.1117.1">//3</span></strong><span class="koboSpan" id="kobo.1118.1">, we inject the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1119.1">$modals</span></strong><span class="koboSpan" id="kobo.1120.1"> resource (dependency) that we will use in the computed property in line </span><strong class="source-inline"><span class="koboSpan" id="kobo.1121.1">//4</span></strong><span class="koboSpan" id="kobo.1122.1"> to retrieve the current active modal and compare it with the component. </span><span class="koboSpan" id="kobo.1122.2">Finally, in line </span><strong class="source-inline"><span class="koboSpan" id="kobo.1123.1">//5</span></strong><span class="koboSpan" id="kobo.1124.1">, based on the click of the buttons, we trigger the resolution or rejection of </span><span class="No-Break"><span class="koboSpan" id="kobo.1125.1">the promise.</span></span></p>
<p><span class="koboSpan" id="kobo.1126.1">To use this plugin from any component in our application, we must follow </span><span class="No-Break"><span class="koboSpan" id="kobo.1127.1">these steps:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1128.1">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.1129.1">template</span></strong><span class="koboSpan" id="kobo.1130.1">, define a modal component with the name registered in our plugin (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1131.1">Modal</span></strong><span class="koboSpan" id="kobo.1132.1">). </span><span class="koboSpan" id="kobo.1132.2">Notice the use of the attributes </span><span class="No-Break"><span class="koboSpan" id="kobo.1133.1">for props:</span></span><pre class="console"><span class="koboSpan" id="kobo.1134.1">
&lt;Modal name=</span><strong class="bold"><span class="koboSpan" id="kobo.1135.1">"myModal"</span></strong><span class="koboSpan" id="kobo.1136.1"> title="Modal example"&gt;
      Some important content here
&lt;/Modal&gt;</span></pre></li>
<li><span class="koboSpan" id="kobo.1137.1">In our script setup, inject the dependency with the </span><span class="No-Break"><span class="koboSpan" id="kobo.1138.1">following code:</span></span><pre class="console"><span class="koboSpan" id="kobo.1139.1">
const $modals = inject("$modals")</span></pre></li>
<li><span class="koboSpan" id="kobo.1140.1">Display the </span><a id="_idIndexMarker376"/><span class="koboSpan" id="kobo.1141.1">modal component by the given name with </span><span class="No-Break"><span class="koboSpan" id="kobo.1142.1">this code:</span></span><pre class="console"><span class="koboSpan" id="kobo.1143.1">
$modals.show(</span><strong class="bold"><span class="koboSpan" id="kobo.1144.1">"myModal"</span></strong><span class="koboSpan" id="kobo.1145.1">).then(() =&gt; {
      // Modal accepted.
</span><span class="koboSpan" id="kobo.1145.2">}, () =&gt; {
      // Modal cancelled
})</span></pre></li>
</ul>
<p><span class="koboSpan" id="kobo.1146.1">With this, we have completed our first plugin in Vue 3. </span><span class="koboSpan" id="kobo.1146.2">Let’s put it to good use in our new To-Do </span><span class="No-Break"><span class="koboSpan" id="kobo.1147.1">list application.</span></span></p>
<h1 id="_idParaDest-100"><a id="_idTextAnchor126"/><span class="koboSpan" id="kobo.1148.1">Implementing our new To-Do application</span></h1>
<p><span class="koboSpan" id="kobo.1149.1">At the </span><a id="_idIndexMarker377"/><span class="koboSpan" id="kobo.1150.1">beginning of this chapter, we saw a design for our new to-do application, and we sliced it into hierarchical components (see </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1151.1">Figure 4</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1152.1">.1</span></em><span class="koboSpan" id="kobo.1153.1">). </span><span class="koboSpan" id="kobo.1153.2">To follow the rest of this section, you will need a copy of the source code from this book’s GitHub repository (</span><a href="https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices"><span class="koboSpan" id="kobo.1154.1">https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices</span></a><span class="koboSpan" id="kobo.1155.1">). </span><span class="koboSpan" id="kobo.1155.2">As our code base grows, it is not possible to see each piece of implementation in detail, so we will focus on the main changes and specific bits of code. </span><span class="koboSpan" id="kobo.1155.3">With that in mind, let’s review the changes from the previous implementation, roughly in order of file execution. </span><span class="koboSpan" id="kobo.1155.4">To start, we added two new directories to </span><span class="No-Break"><span class="koboSpan" id="kobo.1156.1">our project:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1157.1">/src/plugins</span></strong><span class="koboSpan" id="kobo.1158.1">, where we placed our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1159.1">Modals</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1160.1"> plugin.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1161.1">/src/services</span></strong><span class="koboSpan" id="kobo.1162.1">, where we place modules with our business or middleware logic. </span><span class="koboSpan" id="kobo.1162.2">Here, we created a service object to handle the business logic of our To-Do list: the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1163.1">todo.js</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1164.1"> file.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1165.1">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.1166.1">main.js</span></strong><span class="koboSpan" id="kobo.1167.1">, we import and add our plugin to the application object, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1168.1">.use(Modals)</span></strong><span class="koboSpan" id="kobo.1169.1"> method to register </span><span class="No-Break"><span class="koboSpan" id="kobo.1170.1">our plugin.</span></span></p>
<p><span class="koboSpan" id="kobo.1171.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1172.1">App.vue</span></strong><span class="koboSpan" id="kobo.1173.1"> file has become primarily a layout component, without any other application logic. </span><span class="koboSpan" id="kobo.1173.2">We import and use a header, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1174.1">(MainHeader.vue)</span></strong><span class="koboSpan" id="kobo.1175.1">, and a parent component to manage our To-Do list and UI, (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1176.1">ToDoProject.vue)</span></strong><span class="koboSpan" id="kobo.1177.1">, just like in the design shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1178.1">Figure 4</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1179.1">.2</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1180.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1181.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1182.1">ToDoProject</span></strong><span class="koboSpan" id="kobo.1183.1"> component contains the state of the list through reactive variables, where we have </span><span class="No-Break"><span class="koboSpan" id="kobo.1184.1">the following:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1185.1">_items</span></strong><span class="koboSpan" id="kobo.1186.1"> is an array that contains our </span><span class="No-Break"><span class="koboSpan" id="kobo.1187.1">To-Do items</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1188.1">_item</span></strong><span class="koboSpan" id="kobo.1189.1"> is an auxiliary reactive variable that we use to create new items or edit a duplicate of </span><span class="No-Break"><span class="koboSpan" id="kobo.1190.1">an item</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1191.1">_filter</span></strong><span class="koboSpan" id="kobo.1192.1"> is another auxiliary reactive variable that we use to input a string to filter on </span><span class="No-Break"><span class="koboSpan" id="kobo.1193.1">our list</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1194.1">It is worth </span><a id="_idIndexMarker378"/><span class="koboSpan" id="kobo.1195.1">mentioning that we also declare a constant, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1196.1">$modals</span></strong><span class="koboSpan" id="kobo.1197.1">, that receives the injected </span><strong class="source-inline"><span class="koboSpan" id="kobo.1198.1">Modals</span></strong><span class="koboSpan" id="kobo.1199.1"> object API. </span><span class="koboSpan" id="kobo.1199.2">Notice how the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1200.1">showModal()</span></strong><span class="koboSpan" id="kobo.1201.1"> function opens and manages the result of the dialog for new and edited items using this object. </span><span class="koboSpan" id="kobo.1201.2">Then, the modal in question appears in the template, by the ending marked with a comment. </span><span class="koboSpan" id="kobo.1201.3">It is customary to place all the modal templates toward the end of a component, instead of being spaced all over </span><span class="No-Break"><span class="koboSpan" id="kobo.1202.1">the template.</span></span></p>
<p><span class="koboSpan" id="kobo.1203.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1204.1">ToDoProject</span></strong><span class="koboSpan" id="kobo.1205.1"> component delegates state data through props to child components to display summary and list items. </span><span class="koboSpan" id="kobo.1205.2">It also receives events from them, with instructions to manipulate the list. </span><span class="koboSpan" id="kobo.1205.3">You can consider this component as the </span><em class="italic"><span class="koboSpan" id="kobo.1206.1">root</span></em><span class="koboSpan" id="kobo.1207.1"> of functionality. </span><span class="koboSpan" id="kobo.1207.2">Our application only has one, but this begins to hint at the idea of how a web application starts to get organized </span><span class="No-Break"><span class="koboSpan" id="kobo.1208.1">by functionality.</span></span></p>
<p><span class="koboSpan" id="kobo.1209.1">There is another point worth mentioning, which is the use of </span><em class="italic"><span class="koboSpan" id="kobo.1210.1">service objects and classes</span></em><span class="koboSpan" id="kobo.1211.1">. </span><span class="koboSpan" id="kobo.1211.2">In our application, we have </span><strong class="source-inline"><span class="koboSpan" id="kobo.1212.1">todo.js</span></strong><span class="koboSpan" id="kobo.1213.1">, which we import as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1214.1">todoService</span></strong><span class="koboSpan" id="kobo.1215.1"> where needed. </span><span class="koboSpan" id="kobo.1215.2">In this case, this is a </span><em class="italic"><span class="koboSpan" id="kobo.1216.1">singleton</span></em><span class="koboSpan" id="kobo.1217.1">, but it could also be a class constructor. </span><em class="italic"><span class="koboSpan" id="kobo.1218.1">Notice that it does not contain any interface logic, only application or business logic</span></em><span class="koboSpan" id="kobo.1219.1">. </span><span class="koboSpan" id="kobo.1219.2">This is a defining factor that differentiates it from </span><em class="italic"><span class="koboSpan" id="kobo.1220.1">composables</span></em><span class="koboSpan" id="kobo.1221.1">, which we have </span><span class="No-Break"><span class="koboSpan" id="kobo.1222.1">seen before.</span></span></p>
<p><span class="koboSpan" id="kobo.1223.1">Another </span><a id="_idIndexMarker379"/><span class="koboSpan" id="kobo.1224.1">change is that the To-Do items now have multiple states, and we can cycle through them with a click. </span><span class="koboSpan" id="kobo.1224.2">We have implemented this logic in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1225.1">toggleStatus()</span></strong><span class="koboSpan" id="kobo.1226.1"> function of the service, </span><em class="italic"><span class="koboSpan" id="kobo.1227.1">not in the component</span></em><span class="koboSpan" id="kobo.1228.1">. </span><span class="koboSpan" id="kobo.1228.2">The flow between the states can be represented </span><span class="No-Break"><span class="koboSpan" id="kobo.1229.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer029">
<span class="koboSpan" id="kobo.1230.1"><img alt="Figure 4.7 ﻿– A circular finite state machine" src="image/Figure_4.07_B18602.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1231.1">Figure 4.7 – A circular finite state machine</span></p>
<p><span class="koboSpan" id="kobo.1232.1">You may recognize the design, as it</span><a id="_idIndexMarker380"/><span class="koboSpan" id="kobo.1233.1"> represents a </span><strong class="bold"><span class="koboSpan" id="kobo.1234.1">circular finite state machine</span></strong><span class="koboSpan" id="kobo.1235.1">. </span><em class="italic"><span class="koboSpan" id="kobo.1236.1">Finite state machines</span></em><span class="koboSpan" id="kobo.1237.1"> are very handy for representing the possible states of an item, and the conditions that trigger each change (in our case, a user’s click). </span><span class="koboSpan" id="kobo.1237.2">There are many ways to implement a state machine, but one of the simplest is with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1238.1">switch</span></strong><span class="koboSpan" id="kobo.1239.1"> statement, like in </span><span class="No-Break"><span class="koboSpan" id="kobo.1240.1">our example:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1241.1">Todo.js</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1242.1">
[function] toggleStatus(status){
    switch(status){
        case "not_started":     return "in_progress"
        case "in_progress":     return "completed"
        case "completed":       return "not_started"
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.1243.1">This function, given its current status, will return the next one. </span><span class="koboSpan" id="kobo.1243.2">Calling this function on each click, we can update the state of each item in a </span><span class="No-Break"><span class="koboSpan" id="kobo.1244.1">clean manner.</span></span></p>
<p><span class="koboSpan" id="kobo.1245.1">The final point to remark about this new implementation is the use of computed properties in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1246.1">ToDoSummary</span></strong><span class="koboSpan" id="kobo.1247.1"> component. </span><span class="koboSpan" id="kobo.1247.2">We use them to display summary cards with the different states of our items. </span><span class="koboSpan" id="kobo.1247.3">Notice how well the reactivity works – the moment we alter the state of an</span><a id="_idIndexMarker381"/><span class="koboSpan" id="kobo.1248.1"> item in the list, the summary is </span><span class="No-Break"><span class="koboSpan" id="kobo.1249.1">immediately updated!</span></span></p>
<p><span class="koboSpan" id="kobo.1250.1">With the new implementation in order, it is time to take a step back and view our work with a </span><span class="No-Break"><span class="koboSpan" id="kobo.1251.1">critical mind.</span></span></p>
<h1 id="_idParaDest-101"><a id="_idTextAnchor127"/><span class="koboSpan" id="kobo.1252.1">A small critique of our new To-Do application</span></h1>
<p><span class="koboSpan" id="kobo.1253.1">This new </span><a id="_idIndexMarker382"/><span class="koboSpan" id="kobo.1254.1">version of the To-Do application is a clear improvement over our first approach, but it can </span><span class="No-Break"><span class="koboSpan" id="kobo.1255.1">be improved:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1256.1">We still have only one list </span><span class="No-Break"><span class="koboSpan" id="kobo.1257.1">of tasks.</span></span></li>
<li><span class="koboSpan" id="kobo.1258.1">Everything still happens in just </span><span class="No-Break"><span class="koboSpan" id="kobo.1259.1">one page.</span></span></li>
<li><span class="koboSpan" id="kobo.1260.1">Our items are ephemeral. </span><span class="koboSpan" id="kobo.1260.2">They disappear when we close or refresh </span><span class="No-Break"><span class="koboSpan" id="kobo.1261.1">the browser.</span></span></li>
<li><span class="koboSpan" id="kobo.1262.1">There is no security, no way to have multiple users, and </span><span class="No-Break"><span class="koboSpan" id="kobo.1263.1">so on.</span></span></li>
<li><span class="koboSpan" id="kobo.1264.1">We can only add plain text. </span><span class="koboSpan" id="kobo.1264.2">How about images or </span><span class="No-Break"><span class="koboSpan" id="kobo.1265.1">rich text?</span></span></li>
<li><span class="koboSpan" id="kobo.1266.1">With a bit of </span><a id="_idIndexMarker383"/><span class="koboSpan" id="kobo.1267.1">work, we could expand our application so that it manages multiple projects, additional content, assignments, </span><span class="No-Break"><span class="koboSpan" id="kobo.1268.1">and more.</span></span></li>
<li><span class="koboSpan" id="kobo.1269.1">We have made good progress, but there is still more </span><span class="No-Break"><span class="koboSpan" id="kobo.1270.1">to do.</span></span></li>
</ul>
<h1 id="_idParaDest-102"><a id="_idTextAnchor128"/><span class="koboSpan" id="kobo.1271.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1272.1">In this chapter, we dived deep into components and learned how they can communicate, share functionality, and implement design patterns within the framework. </span><span class="koboSpan" id="kobo.1272.2">We also saw an approach to transform a rough sketch or detailed design into components. </span><span class="koboSpan" id="kobo.1272.3">We then learned about special components, created a plugin for modal dialogs using the framework’s dependency injection, and applied other patterns to make our coding easier and more congruent. </span><span class="koboSpan" id="kobo.1272.4">Furthermore, we refactored our application and expanded its capabilities while taking a glimpse at better state management, independent from the HTML element we used before. </span><span class="koboSpan" id="kobo.1272.5">We have made good progress, but there is still more </span><span class="No-Break"><span class="koboSpan" id="kobo.1273.1">to go.</span></span></p>
<p><span class="koboSpan" id="kobo.1274.1">In the next chapter, we will create a </span><strong class="bold"><span class="koboSpan" id="kobo.1275.1">single-page application</span></strong><span class="koboSpan" id="kobo.1276.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.1277.1">SPA</span></strong><span class="koboSpan" id="kobo.1278.1">) with what we learned </span><span class="No-Break"><span class="koboSpan" id="kobo.1279.1">this far.</span></span></p>
<h1 id="_idParaDest-103"><a id="_idTextAnchor129"/><span class="koboSpan" id="kobo.1280.1">Review questions</span></h1>
<p><span class="koboSpan" id="kobo.1281.1">Answer the following questions to test your knowledge of </span><span class="No-Break"><span class="koboSpan" id="kobo.1282.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1283.1">How can we start from a visual design or prototype and plan the implementation </span><span class="No-Break"><span class="koboSpan" id="kobo.1284.1">with components?</span></span></li>
<li><span class="koboSpan" id="kobo.1285.1">What are the many ways that components can communicate with </span><span class="No-Break"><span class="koboSpan" id="kobo.1286.1">each other?</span></span></li>
<li><span class="koboSpan" id="kobo.1287.1">How we can reuse code in multiple components? </span><span class="koboSpan" id="kobo.1287.2">Is there any </span><span class="No-Break"><span class="koboSpan" id="kobo.1288.1">other way?</span></span></li>
<li><span class="koboSpan" id="kobo.1289.1">What is a plugin, and how can we </span><span class="No-Break"><span class="koboSpan" id="kobo.1290.1">create one?</span></span></li>
<li><span class="koboSpan" id="kobo.1291.1">Which patterns have we applied to the new </span><span class="No-Break"><span class="koboSpan" id="kobo.1292.1">To-Do application?</span></span></li>
<li><span class="koboSpan" id="kobo.1293.1">What would you change in </span><span class="No-Break"><span class="koboSpan" id="kobo.1294.1">the implementation?</span></span></li>
</ul>
</div>
</body></html>