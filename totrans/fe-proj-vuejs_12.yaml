- en: 12\. Unit Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at approaches to unit testing Vue.js applications
    in order to improve our quality and speed of delivery. We will also look at using
    tests to drive development using T**est-Driven Development** (**TDD**).
  prefs: []
  type: TYPE_NORMAL
- en: As we proceed, you will gain an understanding of why code needs to be tested
    and what kinds of testing can be employed on different parts of a Vue.js application.
    You will see how to unit test isolated components and their methods using shallow
    rendering and `vue-test-utils`, and you will learn how to test asynchronous component
    code. Throughout the course of the chapter, you will gain familiarity with techniques
    to write efficient unit tests for **mixins** and **filters**. Toward the end of
    the chapter, you will become familiar with approaches to testing a Vue.js applications
    that includes routing and Vuex, and you will learn about using snapshot tests
    to validate your user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will look at the purpose and approaches to testing Vue.js
    applications effectively.
  prefs: []
  type: TYPE_NORMAL
- en: In previous chapters, we saw how to build reasonably complex Vue.js applications.
    This chapter is about testing them to maintain code quality and prevent defects.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing will allow us to write fast and specific tests that we can develop
    against and ensure that features don't exhibit unwanted behavior. We'll see how
    to write unit tests for different parts of a Vue.js application, such as components,
    mixins, filters, and routing. We will use tools supported by the Vue.js core team,
    such as `vue-test-utils`, and tools supported by the rest of the open source community,
    such as the Vue Testing library and the **Jest testing framework**. These different
    tools will serve to illustrate different philosophies and approaches to unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: Why We Need to Test Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing is crucial for ensuring that the code does what it's meant to do.
  prefs: []
  type: TYPE_NORMAL
- en: Quality production software is empirically correct. That means that for the
    enumerated cases that developers and testers have found, the application behaves
    as expected.
  prefs: []
  type: TYPE_NORMAL
- en: This lies in contrast with software that has *proven* to be correct, which is
    a very time-consuming endeavor and is usually part of academic research projects.
    We are still at the point where **correct software** (proven) is still being built
    to show what kinds of systems are possible to build with this constraint of correctness.
  prefs: []
  type: TYPE_NORMAL
- en: Testing prevents the introduction of defects such as bugs and regressions (that
    is, when a feature stops working as expected). In the next section, we will learn
    about the various types of testing.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Different Types of Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The testing spectrum spans from end-to-end testing (by manipulating the user
    interface) to integration tests, and finally to unit tests. End-to-end tests test
    everything, including the user interface, the underlying HTTP services, and even
    database interactions; nothing is mocked. For example, if you've got an e-commerce
    application, an end-to-end test might actually place a real order with a real
    credit card, or it might place a test order, with a test credit card.
  prefs: []
  type: TYPE_NORMAL
- en: End-to-end tests are costly to run and maintain. They require the use of full-blown
    browsers controlled through programmatic drivers such as **Selenium**, **WebdriverIO**,
    or **Cypress**. This type of test platform is costly to run, and small changes
    in the application code can cause end-to-end tests to start failing.
  prefs: []
  type: TYPE_NORMAL
- en: Integration or system-level tests ensure that a set of systems is working as
    expected. This will usually involve deciding on a limit as to where the **system
    under test** lies and allowing it to run, usually against mocked or stubbed upstream
    services and systems (which are therefore not under test). Since external data
    access is stubbed, a whole host of issues, such as timeouts and flakes, can be
    reduced (when compared to end-to-end tests). Integration test suites are usually
    fast enough to run as a continuous integration step, but the full test suite tends
    not to be run locally by engineers.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests are great at providing fast feedback during development. Unit testing
    paired with TDD is part of extreme programming practice. Unit tests are great
    at testing complicated logic or building a system from its expected output. Unit
    tests are usually fast enough to run that developers code against them before
    sending their code for review and continuous integration tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an interpretation of the pyramid of testing. It can be interpreted
    as: you should have a high number of cheap and fast unit tests, a reasonable number
    of system tests, and a few end-to-end UI tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1: Pyramid of testing diagram'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_12_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.1: Pyramid of testing diagram'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've looked at why we should be testing applications, let's start
    writing some tests.
  prefs: []
  type: TYPE_NORMAL
- en: Your First Test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To illustrate how quick and easy it is to get started with automated unit tests
    in a Vue CLI project, we will start by setting up and writing a unit test with
    Jest, `@vue-test-utils`. There is an official Vue CLI package that can be used
    to generate a setup that includes unit testing with Jest and `vue-test-utils`.
    The following command should be run in a project that has been set up with Vue
    CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Vue CLI adds Jest as the test runner, `@vue/test-utils`, the official `Vue.js`
    testing utilities, and `vue-jest`, a processor for `.vue` single-file component
    files in Jest. It adds a `test:unit` script.
  prefs: []
  type: TYPE_NORMAL
- en: By default, it creates a `tests/unit` folder, which we'll remove. Instead, we
    can create a `__tests__` folder and create an `App.test.js` file as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use `shallowMount` to render the application and test that it displays
    the correct text. For the purposes of this example, we''ll use the text: "`The
    Vue.js Workshop Blog`".'
  prefs: []
  type: TYPE_NORMAL
- en: '`shallowMount` does a **shallow render**, which means that only the top level
    of a component is rendered; all the child components are stubbed. This is useful
    for testing a component in isolation since the child components'' implementations
    are not run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This test will fail when we run `npm run test:unit` because we do not have
    `The Vue.js Workshop Blog` in the `App` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2: Blog title heading failing the test at the command line'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_12_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.2: Blog title heading failing the test at the command line'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to get the test to pass, we can implement our blog title heading in
    the `App.vue` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have got the right heading, `npm run test:unit` will pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3: Blog heading test passing'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_12_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.3: Blog heading test passing'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also check that it renders as expected in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You have just completed your first piece of TDD. This process started by writing
    a test that failed. This failure was followed by an update to the code under test
    (in this case the `App.vue` component), which made the failing test pass. The
    TDD process gives us confidence that our features have been tested properly since
    we can see that tests fail before they pass when we update the code that drives
    our feature.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Components are at the core of Vue.js applications. Writing unit tests for them
    is straightforward with `vue-test-utils` and Jest. Having tests that exercise
    the majority of your components gives you confidence that they behave as designed.
    Ideal unit tests for components run quickly and are simple.
  prefs: []
  type: TYPE_NORMAL
- en: We'll carry on building the blog application example. We have now built the
    heading, but a blog usually also needs a list of posts to display.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll create a `PostList` component. For now, it will just render a `div`
    wrapper and support a `posts` `Array` prop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add some data in the `App` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have some posts, we can pass them as a bound prop to the `PostList`
    component from the `App` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Our `PostList` component will render out each post in a `PostListItem` component,
    which we'll create as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`PostListItem` takes two props: `title` (which is a string) and `description`
    (also a string). It renders them in an `h3` tag and a `p` tag, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to loop through the posts and render out a `PostListItem` component
    with relevant props bound in the `PostList.vue` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now see the heading and the post list in the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To test the `PostListItem` component, we can shallow render with some arbitrary
    `title` and `description` props set, and check that they get rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The test output of `npm run test:unit __tests__/PostListItem.test.js` is as
    follows; the component passes the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4: PostListItem test output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_12_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.4: PostListItem test output'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll see one of the pitfalls of shallow rendering. When testing the
    `PostList` component, all we can do is test the number of `PostListItem` components
    it''s rendering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This passes, but we are testing something that the user will not directly interact
    with, the number of `PostListItem` instances rendered in `PostList`, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.5: PostList test output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_12_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.5: PostList test output'
  prefs: []
  type: TYPE_NORMAL
- en: A better solution is to use the `mount` function, which renders the full component
    tree, whereas the `shallow` function would only render out the children of the
    component being rendered. With `mount`, we can assert that the titles and descriptions
    are rendered to the page.
  prefs: []
  type: TYPE_NORMAL
- en: The drawback of this approach is that we're testing both the `PostList` component
    and the `PostListItem` component since the `PostList` component doesn't render
    the title or description; it renders a set of `PostListItem` components that in
    turn render the relevant title and description.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The new tests pass as per the following output of `npm run test:unit __tests__/PostList.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.6: Test run for PostList with both shallow and mounted tests'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_12_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.6: Test run for PostList with both shallow and mounted tests'
  prefs: []
  type: TYPE_NORMAL
- en: We have now seen how to write unit tests for Vue.js components using Jest and
    `vue-test-utils`. These tests can be run often, and test runs complete within
    seconds, which gives us near-immediate feedback while working on new or existing components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.01: Building and Unit Testing a Tag List Component'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When creating the fixture for `posts`, we populated a `tags` field with `vue`,
    `angularjs`, and `react` but did not display them. To make tags useful, we will
    display the tags in the post list.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access the code files for this exercise, refer to [https://packt.live/2HiTFQ1](https://packt.live/2HiTFQ1):'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start by writing a unit test that will explain what we expect a `PostListItem`
    component to do when passed a set of tags as props. It expects that each tag will
    be rendered with a hashtag prepended to it; for example, the `react` tag will
    be shown as `#react`. In the `__tests__/PostListItem.test.js` file, we can add
    a new `test`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This test fails when run with `npm run test:unit __tests__/PostListItem.test.js`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.7: Tag test for PostListItem failing'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_12_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.7: Tag test for PostListItem failing'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we should implement the tag list rendering in `src/components/PostListItem.vue`.
    We''ll add tags as props of the `Array` type and use `v-for` to render out the
    tags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the `PostListItem` component implemented, the unit test should now pass:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.8: PostListItem unit test passing'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_12_08.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.8: PostListItem unit test passing'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'However, the tags are not displayed in the application:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.9: PostList displaying without tags despite'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the correct PostListItem implementation
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_12_09.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.9: PostList displaying without tags despite the correct PostListItem
    implementation'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can write a unit test for `PostList` that would show this behavior. In essence,
    we''ll be passing some tags in our `posts` list and running the same assertions
    as are already present in the `PostListItem.test.js` file. We''ll do this in `__tests__/PostList.test.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As per our application output, the test is failing when run with `npm run test:unit
    __tests__/PostList.test.js`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.10: PostList tags test failing'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_12_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.10: PostList tags test failing'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In order to fix this test, we can find the issue in `src/components/PostList.vue`,
    where the `tags` prop for `PostListItem` is not bound. By updating `src/components/PostList.vue`
    to bind the `tags` prop, we can fix the unit test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The failing unit test now passes, as shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.11: PostList tags test passing'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_12_11.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.11: PostList tags test passing'
  prefs: []
  type: TYPE_NORMAL
- en: 'The tags also appear in the application, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.12: Blog list rendering with tags'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_12_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.12: Blog list rendering with tags'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have now seen how we can test rendered component output with both the shallow
    rendering and mounting of components. Let''s briefly understand what each of these
    terms means:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Shallow rendering**: This renders at a depth of 1, meaning that if children
    are components, they will just be rendered as the component tag; their template
    will not be run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mounting**: This renders the full component tree in a similar fashion as
    would be rendered in the browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we'll look at how to test component methods.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Methods, Filters and Mixins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since `click`, `input change`, `focus change`, and `scroll`).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a filter that truncates its input to eight characters would be
    implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two options to test it. We could test it directly by importing the
    component and calling `truncate` on some input, as per the `truncate.test.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The alternative is to check where it''s being used in the `PostListItem` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can test `truncate` by checking what happens when we pass a long title
    into the `PostListItem` component in the `PostListItem.test.js` file, which we
    do in the following test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will generate the output shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.13: PostListItem test for the title failing because'
  prefs: []
  type: TYPE_NORMAL
- en: the content of the title is truncated
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_12_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.13: PostListItem test for the title failing because the content of
    the title is truncated'
  prefs: []
  type: TYPE_NORMAL
- en: To fix this, we could update the failing test to expect `Blog pos` instead of
    `Blog post title`.
  prefs: []
  type: TYPE_NORMAL
- en: These two approaches are great for testing filters. As we saw before with `filters.truncate()`
    test since it directly accesses the `truncate` filter. The looser unit test is
    the test using passed props and validating the component output. A tighter unit
    will usually mean tests are simpler, but it comes at the cost of sometimes testing
    functionality in a fashion that is very removed from how the end user perceives
    it. For example, the user would never call `filters.truncate()` directly.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how to test an arbitrary `truncate` filter. We will now implement
    an `ellipsis` filter and test it.
  prefs: []
  type: TYPE_NORMAL
- en: The `ellipsis` filter will be applied to the post description and will limit
    its length to `40` characters plus `…`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.02: Building and Testing an ellipsis Filter'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen how to test an arbitrary `truncate` filter; we will now implement
    an `ellipsis` filter and test it.
  prefs: []
  type: TYPE_NORMAL
- en: To access the code files for this exercise, refer to [https://packt.live/2UK9Mcs](https://packt.live/2UK9Mcs).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s look at the steps to build and test an `ellipsis` filter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start by writing a set of tests for the `ellipsis` filter (which will
    live in `src/components/PostListItem.vue`). One test should check that the filter
    does nothing if the passed value is less than `50` characters; another should
    check that if the passed value is more than `50` characters, it truncates to `50`
    and appends `…`. We will do this in a `__tests__/ellipsis.test.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now implement the logic for `ellipsis` in `src/components/PostListItem.vue`.
    We will add a `filters` object with `ellipsis`, which will use `String#slice`
    if the passed value is longer than `50` characters and do nothing otherwise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this case, the test now passes `npm run test:unit __tests__/ellipsis.test.js`,
    as shown in *Figure 12.14*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.14: The ellipsis filter unit test passing'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_12_14.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.14: The ellipsis filter unit test passing'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We now need to integrate our `ellipsis` filter into the component. To check
    whether this will work, we can first write the test in `__tests__/PostListItem.test.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This test fails since we don''t use the filter in the component template. The
    output will be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.15: PostListItem ellipsis test failing'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_12_15.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.15: PostListItem ellipsis test failing'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To get the test to pass, we need to pipe the `description` property into the
    `ellipsis` filter in `src/components/PostListItem.vue`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, the test will pass, as displayed in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.16: PostListItem ellipsis test passing'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_12_16.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.16: PostListItem ellipsis test passing'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the descriptions being truncated in the application interface in
    the browser, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.17: Blog post item descriptions being truncated to 50 characters'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_12_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.17: Blog post item descriptions being truncated to 50 characters'
  prefs: []
  type: TYPE_NORMAL
- en: We have now seen how to test filters and other properties of a Vue.js component
    not only by testing directly against the object but also by testing the functionality
    where it is being used in component-level tests.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will see how to deal with an application that uses Vue.js routing.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Vue Routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have currently got an application that renders what is our blog home page
    or **feed view**.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we should have post pages. To do this, we will use Vue Router, as covered
    in previous chapters, and ensure that our routing works as designed with unit
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Vue Router is installed using `npm`, specifically, `npm install vue-router`,
    and wiring it up in the `main.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `router.js` file registers `vue-router` with Vue using `Vue.use` and instantiates
    a `VueRouter` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'A router with no routes isn''t very useful. We''ll define the root path (`/`)
    to display the `PostList` component in the `router.js` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''ve got our initial route, we should update the `App.vue` file
    to leverage the component being rendered by the router. We''ll render `render-view`
    instead of directly using `PostList`. The `posts` binding, however, stays the
    same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our posts in the `App.vue` file are missing a bit of core data to render
    a `SinglePost` component. We need to make sure to have the `slug` and `content`
    properties to render something useful on our `SinglePost` page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now start working on a `SinglePost` component. For now, we''ll just
    have some placeholders in the template. Also, `SinglePost` will receive `posts`
    as a prop, so we can fill that in as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will register `SinglePost` in `router.js`, with the `/:postId` path
    (which will be available to the component under `this.$route.params.postId`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If we switch back to implementing the `SinglePost` component, we''ve got access
    to `postId`, which will map to the slug in the `posts` array, and we''ve also
    got access to `posts` since it''s being bound onto `render-view` by `App`. Now
    we can create a computed property, `post`, which finds posts based on `postId`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'From this computed `post` property, we can extract `title` and `content` if
    `post` exists (we have to watch out for posts that don''t exist). So, still in
    `SinglePost`, we can add the following computed properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then replace the placeholders in the template with the value of the
    computed properties. So, our template ends up as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we should make the whole post item a `router-link` that points to
    the right slug in the `PostListItem.vue` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '`router-link` is a Vue Router-specific link, which means that on the `PostList`
    page, upon clicking on a post list item, we are taken to the correct post''s URL,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.18: Post list view displayed in the browser'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_12_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.18: Post list view displayed in the browser'
  prefs: []
  type: TYPE_NORMAL
- en: We'll be redirected to the correct URL, the post's slug, which will render the
    right post by `slug`, as shown in *Figure 12.19*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.19: Single post view displaying in the browser'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_12_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.19: Single post view displaying in the browser'
  prefs: []
  type: TYPE_NORMAL
- en: To test `vue-router`, we will explore a new library that's better suited to
    testing applications with routing and a Vuex store, the Vue Testing library, which
    is accessible on `npm` as `@testing-library/vue`.
  prefs: []
  type: TYPE_NORMAL
- en: We can install it with `npm install --save-dev @testing-library/vue`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test `SinglePost` routing and rendering, we do the following. First of all,
    we should be able to access the `SinglePost` view by clicking on a post title
    in the `PostList` view. In order to do this, we check that we''re on the home
    page by examining the content (we''ll see two posts with the titles). Then we''ll
    click a post title and check that the content from the home page is gone and the
    post content is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We should check that navigating directly to a valid post URL will yield the
    correct result. In order to do this, we''ll use `router.replace(''/'')` to clear
    any state that''s set, and then use `router.push()` with a post slug. We will
    then use the assertions from the previous code snippet to validate that we are
    on the `SinglePost` page, not the home page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Those two tests work as expected when run with `npm run test:unit __tests__/SinglePost.test.js`.
    The following screenshot displays the desired output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.20: Routing tests passing for SinglePost'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_12_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.20: Routing tests passing for SinglePost'
  prefs: []
  type: TYPE_NORMAL
- en: We have now seen how to use the Vue.js Testing library to test an application
    that uses `vue-router`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.03: Building a Tag Page and Testing Its Routing'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Much like we have built a single-post page, we'll now build a tag page, which
    is similar to the `PostList` component except only posts with a certain tag are
    displayed and each post is a link to a relevant single-post view.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access the code files for this exercise, refer to [https://packt.live/39cJqZd](https://packt.live/39cJqZd):'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start by creating a new `TagPage` component in `src/components/TagPage.vue`.
    We know it will receive `posts` as a prop and that we will want to render a `PostList`
    component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we want to wire the `TagPage` component into the router in `src/router.js`.
    We''ll import it and add it as part of `routes` with the `/tags/:tagName` path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now use `$route.params.tagName` in a computed property and create a
    `tagPosts` computed property that filters posts by tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have access to `tagPosts` and `tagName`, we can replace the placeholders
    in the template. We will render `#{{ tagName }}` and bind `tagPosts` to the `posts`
    prop of `PostList`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, the page displays as follows if we navigate, for example, to `/tags/angularjs`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.21: Tag page for angularjs'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_12_21.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.21: Tag page for angularjs'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step is to convert the tag anchors (`a`) in `PostListItem` to `router-link`
    that points to `/tags/${tagName}` (in `src/components/PostListItem.vue`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now it is time to write some tests. We will first check that being on the home
    page and clicking on `#angularjs` puts us on the `angularjs` tag page. We''ll
    write it as follows in `__tests__/TagPage.test.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We should also test that going directly to the tag URL works as expected; that
    is, we do not see irrelevant content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The tests pass since the application is working as expected. Therefore, the
    output will be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.22: TagPage routing tests passing on the command line'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_12_22.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.22: TagPage routing tests passing on the command line'
  prefs: []
  type: TYPE_NORMAL
- en: We've now seen how to implement and test an application that includes `vue-router`.
    In the next section, we will learn about testing Vuex in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Vuex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To show how to test a component that relies on Vuex (Vue.js's official global
    state management solution), we'll implement and test a newsletter subscription
    banner.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, we should create the banner template. The banner will contain
    a `Subscribe to the newsletter` call to action and a close icon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We can display the `NewsletterBanner` component in the `App.vue` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll then install Vuex with the `npm install --save vuex` command. Once Vuex
    is installed, we can initialize our store in a `store.js` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Our Vuex store is also registered in the `main.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to decide whether the newsletter banner should be displayed or not,
    we need to add an initial state to our store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'To close the banner, we need a mutation that will set `dismissedSubscribeBanner`
    to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use the store state and the `dismissSubscribeBanner` mutation to
    decide whether to show the banner (using `v-if`) and whether to close it (binding
    to a click on the `close` button):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, the banner looks like this in a browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.23: Newsletter banner displayed in a browser'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_12_23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.23: Newsletter banner displayed in a browser'
  prefs: []
  type: TYPE_NORMAL
- en: To write unit tests, we will use the Vue Testing library, which provides a facility
    for injecting a Vuex store. We'll need to import the store and the `NewsletterBanner` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start with a sanity check that, by default, the newsletter banner is
    displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The next check should be that if the store has `dismissedSubscribeBanner: true`,
    the banner should not be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The final test we''ll write is to make sure that clicking the banner''s close
    button commits a mutation to the store. We can do this by injecting a stub as
    the `dismissSubscribeBanner` mutation and checking that it is called when clicking
    the close button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The tests will now pass when run with `npm run test:unit __tests__/NewsletterBanner.test.js`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.24: Unit tests for NewsletterBanner passing on the command line'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_12_24.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.24: Unit tests for NewsletterBanner passing on the command line'
  prefs: []
  type: TYPE_NORMAL
- en: We've now seen how the Vue.js Testing library can be used to test application
    functionality driven by Vuex.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.04: Building and Testing a Cookie Disclaimer Banner (Vuex)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll now look at how to implement a cookie disclaimer banner using Vuex and
    how to test it with the Vue.js Testing library.
  prefs: []
  type: TYPE_NORMAL
- en: We will store whether the cookie banner is showing in Vuex (the default is `true`);
    when the banner is closed, we will store it in Vuex.
  prefs: []
  type: TYPE_NORMAL
- en: 'Test this opening/closing with a mock Vuex store. To access the code files
    for this exercise, refer to [https://packt.live/36UzksP](https://packt.live/36UzksP):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a green cookie banner with a `Cookies Disclaimer` title in bold, the
    disclaimer, and an `I agree` button. We will create this in `src/components/CookieBanner.vue`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will import, register, and render `CookieBanner` below `router-view`
    in `src/App.vue`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a `state` slice to control whether to display the cookie banner. In our
    Vuex store, we will initialize this `acceptedCookie` field as `false`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will also need an `acceptCookie` mutation to close the banner:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will expose store state as an `acceptedCookie` computed property.
    We will create an `acceptCookie` function that triggers the `acceptCookie` mutation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will use `v-if` to show the banner when cookies have not been accepted yet.
    The `I agree` button will close the banner when it''s clicked by toggling `acceptCookie`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have now got a cookie banner that shows until `I agree` is clicked, as shown
    in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.25: Cookie banner displayed in the browser'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_12_25.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.25: Cookie banner displayed in the browser'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will now write a test that checks that the `CookieBanner` component is displayed
    by default:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will also write a test to check that if `acceptedCookie` is true in the
    store, the cookie banner won''t be displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we want to check that when the `I agree` button is clicked, the `acceptCookie`
    mutation is triggered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The three tests we wrote pass when run with `npm run test:unit __tests__/CookieBanner.test.js`,
    as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.26: Tests for the cookie banner passing'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_12_26.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.26: Tests for the cookie banner passing'
  prefs: []
  type: TYPE_NORMAL
- en: We've now seen how to test components that rely on Vuex for state and updates.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll look at snapshot testing and see how it simplifies the testing of
    render output.
  prefs: []
  type: TYPE_NORMAL
- en: Snapshot Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Snapshot tests** provide a way to write tests for fast-changing pieces of
    code without keeping the assertion data inline with the test. They store snapshots
    instead.'
  prefs: []
  type: TYPE_NORMAL
- en: Changes to a snapshot reflect changes to the output, which is quite useful for
    code reviews.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can add a snapshot test to the `PostList.test.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'When we next run this test file, with `npm run test:unit __tests__/PostList.test.js`,
    we will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.27: Snapshot test run for the first time'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_12_27.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.27: Snapshot test run for the first time'
  prefs: []
  type: TYPE_NORMAL
- en: 'The snapshot was written to `__tests__/__snapshots__/PostList.test.js.snap`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This makes it easy to quickly see what the changes mean in terms of concrete
    output.
  prefs: []
  type: TYPE_NORMAL
- en: We've now seen how to use snapshot tests. Next, we'll put all the tools we learned
    in the chapter together to add a new page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 12.01: Adding a Simple Search by Title Page with Tests'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already built a post list page, a single-post view page, and a posts-by-tag page.
  prefs: []
  type: TYPE_NORMAL
- en: 'A great way to resurface old content on a blog is by implementing a good search
    functionality. We will add search to the `PostList` page:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the search form with an input and a button in a new file at `src/components/SearchForm.vue`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We'll now get the form to display by importing, registering, and rendering it
    in `src/App.vue`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We are now able to see the search form in the application, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.28: The post list view with a search form'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_12_28.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.28: The post list view with a search form'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We're now ready to add a snapshot test for the search form. In `__tests__/SearchForm.test.js`,
    we should add `SearchForm should match expected HTML`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want to track the contents of the search form input using `v-model` to two-way
    bind the `searchTerm` instance variable and the contents of the input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the search form is submitted, we'll need to update the URL with the right
    parameter. This can be done with `this.$router.push()`. We will store the search
    in a `q` query parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will want to reflect the state of the `q` query parameter in the search form
    input. We can do this by reading `q` from `this.$route.query` and setting it as
    the initial value for the `searchTerm` data field in the `SearchForm` component state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we'll want to filter the posts passed to `PostList` on the home page.
    We'll use `this.$route.query.q` in a computed property that filters posts by their
    title. This new computed property will then be used instead of `posts` in `src/App.vue`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we should add a test that changes the search query parameter and check
    that the app shows the right result. To do this, we can import `src/App.vue, src/store.js`
    and `src/router.js`, and render the app with the store and the router. We can
    then update the search field contents by using the fact that the placeholder for
    the field is `Search`. Finally, we can submit the form by clicking the element
    where `test id` is `Search` (which is the `search` button).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The solution for this activity can be found via [this link](B15218_Solution_Final_SZ_ePub.xhtml#_idTextAnchor405).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we've looked at different approaches to testing different
    types of Vue.js applications.
  prefs: []
  type: TYPE_NORMAL
- en: Testing in general is useful for empirically showing that the system is working.
    Unit tests are the cheapest to build and maintain and should be the base of testing
    functionality. System tests are the next level up in the testing pyramid and allow
    you to gain confidence that the majority of features are working as expected.
    End-to-end tests show that the main flows of the full system work.
  prefs: []
  type: TYPE_NORMAL
- en: We've seen how to unit test components, filters, component methods, and mixins,
    as well as testing through the layers, and testing component output in a black
    box fashion instead of inspecting component internals to test functionality. Using
    the Vue.js Testing library, we have tested advanced functionality, such as routing
    and applications, that leverage Vuex.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked at snapshot testing and saw how it can be an effective way
    to write tests for template-heavy chunks of code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at end-to-end testing techniques that can
    be applied to Vue.js applications.
  prefs: []
  type: TYPE_NORMAL
