- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Rendering with JSX
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JSX 渲染
- en: This chapter will introduce you to **JSX**, which is the XML/HTML markup syntax
    that’s embedded in your JavaScript code and used to declare your React components.
    At the lowest level, you’ll use HTML markup to describe the pieces of your UI.
    Building React applications involves organizing these pieces of HTML markup into
    components. In React, creating a component allows you to define custom elements
    that extend beyond basic HTML markup. These custom elements, or components, are
    defined using JSX, which then translates them into standard HTML elements for
    the browser. This ability to create and reuse custom components is a core feature
    of React, enabling more dynamic and complex UIs. This is where React gets interesting
    – having your own JSX tags that can use JavaScript expressions to bring your components
    to life. JSX is the language used to describe UIs built using React.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您介绍 **JSX**，这是一种嵌入在您的 JavaScript 代码中的 XML/HTML 标记语法，用于声明您的 React 组件。在最基本的层面上，您将使用
    HTML 标记来描述您的 UI 的各个部分。构建 React 应用程序涉及将这些 HTML 标记片段组织成组件。在 React 中，创建一个组件允许您定义超出基本
    HTML 标记的自定义元素。这些自定义元素或组件使用 JSX 定义，然后将其转换为浏览器可以识别的标准 HTML 元素。能够创建和重用自定义组件是 React
    的核心特性，它使得更动态和复杂的 UI 成为可能。这正是 React 引人入胜的地方——拥有自己的 JSX 标签，可以使用 JavaScript 表达式使您的组件生动起来。JSX
    是用于描述使用 React 构建的 UI 的语言。
- en: 'In this chapter, we’ll cover the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Your first JSX content
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的第一个 JSX 内容
- en: Rendering HTML
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染 HTML
- en: Creating your own JSX elements
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建您自己的 JSX 元素
- en: Using JavaScript expressions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JavaScript 表达式
- en: Building fragments of JSX
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 JSX 片段
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code for this chapter can be found in the following directory of the accompanying
    GitHub repository: [https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter02](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter02).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在配套 GitHub 仓库的以下目录中找到：[https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter02](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter02)。
- en: Your first JSX content
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您的第一个 JSX 内容
- en: In this section, we’ll implement the obligatory `Hello World` JSX application.
    This initial dive is just the beginning – it’s a simple yet effective way to get
    acquainted with the syntax and its capabilities. As we progress, we’ll delve into
    more complex and nuanced examples, demonstrating the power and flexibility of
    JSX in building React applications. We’ll also discuss what makes this syntax
    work well for declarative UI structures.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现必做的 `Hello World` JSX 应用程序。这个初步的探索只是开始——这是一个简单而有效的方法来熟悉语法及其功能。随着我们的进展，我们将深入研究更复杂和细微的示例，展示
    JSX 在构建 React 应用程序中的强大和灵活性。我们还将讨论是什么使得这种语法适用于声明式 UI 结构。
- en: Hello JSX
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Hello JSX
- en: 'Without further ado, here’s your first JSX application:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 不再拖延，这是您的第一个 JSX 应用程序：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let’s walk through what’s happening here.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这里发生了什么。
- en: The `render()` function takes JSX as an argument and renders it to the DOM node
    passed to `ReactDOM.createRoot()`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`render()` 函数接受 JSX 作为参数，并将其渲染到传递给 `ReactDOM.createRoot()` 的 DOM 节点。'
- en: The actual JSX content in this example renders a paragraph with some bold text
    inside. There’s nothing fancy going on here, so we could have just inserted this
    markup into the DOM directly as a plain string. However, the aim of this example
    is to show the basic steps involved in getting JSX rendered onto the page.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，实际的 JSX 内容渲染了一个包含一些粗体文本的段落。这里没有发生什么特别的事情，所以我们完全可以直接将这个标记作为纯字符串插入到 DOM
    中。然而，此示例的目的是展示将 JSX 渲染到页面上的基本步骤。
- en: 'Under the hood, JSX is not directly understood by web browsers and needs to
    be transformed into standard JavaScript code that browsers can execute. This transformation
    is typically done using a tool like **Vite** or **Babel**. When Vite processes
    JSX code, it compiles the JSX down to `React.createElement()` calls. These calls
    create JavaScript objects that represent the virtual DOM elements. For example,
    the JSX expression in the example above is compiled into this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，JSX 并不是由网络浏览器直接理解的，需要转换成浏览器可以执行的标准的 JavaScript 代码。这种转换通常使用像 **Vite** 或 **Babel**
    这样的工具来完成。当 Vite 处理 JSX 代码时，它会将 JSX 编译成 `React.createElement()` 调用。这些调用创建代表虚拟 DOM
    元素的 JavaScript 对象。例如，上面示例中的 JSX 表达式被编译成这样：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first argument to `React.createElement` is the type of the element (such
    as a string like `div` or `p` for DOM elements, or a React component for composite
    components). The second argument is an object containing the props for this element,
    and any subsequent arguments are the children of this element. This transformation
    is done by Vite under the hood, and you never write such code.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`React.createElement` 的第一个参数是元素的类型（例如，用于 DOM 元素的字符串 `div` 或 `p`，或用于复合组件的 React
    组件）。第二个参数是一个包含此元素属性的对象，任何后续参数都是此元素的子元素。这种转换由 Vite 在幕后完成，你永远不会编写这样的代码。'
- en: These objects created by `React.createElement()`, known as **React elements**,
    describe the structure and properties of a UI component in an object format that
    React can work with. React then uses these objects to construct the actual DOM
    and keep it up to date. This process involves a reconciliation algorithm that
    efficiently updates the DOM to match the React elements. When the state of a component
    changes, React calculates the minimal set of changes required to update the DOM,
    rather than re-rendering the entire component. This makes updates much more efficient
    and is one of the key advantages of using React.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由 `React.createElement()` 创建的这些对象，称为 **React 元素**，以对象格式描述了 UI 组件的结构和属性，React
    可以处理这些对象。然后，React 使用这些对象构建实际的 DOM 并保持其更新。这个过程涉及一个协调算法，它以高效的方式更新 DOM 以匹配 React
    元素。当组件的状态发生变化时，React 计算出更新 DOM 所需的最小更改集，而不是重新渲染整个组件。这使得更新更加高效，也是使用 React 的关键优势之一。
- en: Before we move forward with more in-depth code examples, let’s take a moment
    to reflect on our `Hello World` example. The JSX content was short and simple.
    It was also declarative because it described *what* to render, not *how* to render
    it. Specifically, by looking at the JSX, you can see that this component will
    render a paragraph and some bold text within it. If this were done imperatively,
    there would probably be some more steps involved, and they would probably need
    to be performed in a specific order.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续更深入的代码示例之前，让我们花一点时间回顾一下我们的 `Hello World` 示例。JSX 内容简短且简单。它也是声明性的，因为它描述了要渲染的内容，而不是如何渲染。具体来说，通过查看
    JSX，你可以看到这个组件将渲染一个段落和一些粗体文本。如果以命令式方式完成，可能需要更多步骤，并且它们可能需要按特定顺序执行。
- en: The example we just implemented should give you a feel for what declarative
    React is all about. As we move forward in this chapter and throughout the book,
    the JSX markup will grow more elaborate. However, it’s always going to describe
    what is in the UI.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚实现的示例应该让你对声明性 React 有一定的感觉。随着我们在本章以及整本书的进展，JSX 标记将变得更加复杂。然而，它始终会描述 UI 中的内容。
- en: The `render()` function tells React to take your JSX markup and update the UI
    in the most efficient way possible. This is how React enables you to declare the
    structure of your UI without having to think about carrying out ordered steps
    to update elements on the screen, an approach that often leads to bugs. Out of
    the box, React supports the standard HTML tags that you would find on any HTML
    page, such as `div`, `p`, `h1`, `ul`, `li`, and others.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`render()` 函数告诉 React 以最有效的方式将你的 JSX 标记更新到 UI 上。这就是 React 如何让你能够声明 UI 的结构，而无需考虑执行更新屏幕上元素的有序步骤，这种方法往往会导致错误。React
    默认支持任何 HTML 页面上都能找到的标准 HTML 标签，例如 `div`、`p`、`h1`、`ul`、`li` 等。'
- en: Now that we have discovered what JSX is, how it works, and what declarative
    idea it follows, let’s explore how we can render plain HTML markup and what conventions
    we should follow.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经发现了 JSX 是什么，它是如何工作的，以及它遵循的声明性理念，让我们探索如何渲染纯 HTML 标记，以及我们应该遵循哪些约定。
- en: Rendering HTML
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染 HTML
- en: At the end of the day, the job of a React component is to render HTML in the
    DOM browser. This is why JSX has support for HTML tags out of the box. In this
    section, we’ll look at some code that renders a few of the available HTML tags.
    Then, we’ll cover some of the conventions that are typically followed in React
    projects when HTML tags are used.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，React 组件的职责是在 DOM 浏览器中渲染 HTML。这就是为什么 JSX 默认支持 HTML 标签。在本节中，我们将查看一些渲染可用 HTML
    标签的代码。然后，我们将介绍在 React 项目中使用 HTML 标签时通常遵循的一些约定。
- en: Built-in HTML tags
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内置 HTML 标签
- en: When we render JSX, element tags reference React components. Since it would
    be tedious to have to create components for HTML elements, React comes with HTML
    components. We can render any HTML tag in our JSX, and the output will be just
    as we’d expect.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们渲染 JSX 时，元素标签引用 React 组件。由于为 HTML 元素创建组件会很麻烦，React 提供了 HTML 组件。我们可以在 JSX
    中渲染任何 HTML 标签，输出将正如我们所期望的那样。
- en: 'Now, let’s try rendering some of these tags:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试渲染一些这些标签：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Don’t worry about the formatting of the rendered output for this example. We’re
    making sure that we can render arbitrary HTML tags, and they render as expected,
    without any special definitions and imports.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，不必担心渲染输出的格式。我们确保可以渲染任意 HTML 标签，并且它们会按照预期渲染，无需任何特殊的定义和导入。
- en: You may have noticed the surrounding `<div>` tag, grouping together all of the
    other tags as its children. This is because React needs a root element to render.
    Later in the chapter, you’ll learn how to render adjacent elements without wrapping
    them in a parent element.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了周围的 `<div>` 标签，它将所有其他标签作为其子元素分组。这是因为 React 需要一个根元素来渲染。在章节的后面，你将学习如何在不将相邻元素包裹在父元素中的情况下渲染它们。
- en: HTML elements rendered using JSX closely follow regular HTML element syntax,
    with a few subtle differences regarding case-sensitivity and attributes.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 JSX 渲染的 HTML 元素紧密遵循常规 HTML 元素语法，但在大小写敏感性和属性方面有一些细微的差异。
- en: HTML tag conventions
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTML 标签约定
- en: When you render HTML tags in JSX markup, the expectation is that you’ll use
    lowercase for the tag name. In fact, capitalizing the name of an HTML tag will
    fail. Tag names are case-sensitive and non-HTML elements are capitalized. This
    way, it’s easy to scan the markup and spot the built-in HTML elements versus everything
    else.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 JSX 标记中渲染 HTML 标签时，预期你会使用小写字母来表示标签名。实际上，将 HTML 标签名称大写将会失败。标签名是区分大小写的，并且非
    HTML 元素名称是大写的。这样，就可以轻松地扫描标记并区分内置的 HTML 元素和其他所有元素。
- en: 'You can also pass HTML elements any of their standard properties. When you
    pass them something unexpected, a warning about the unknown property is logged.
    Here’s an example that illustrates these ideas:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以传递 HTML 元素任何它们的标准属性。当你传递它们意料之外的东西时，会记录一条关于未知属性的警告。以下是一个说明这些概念的示例：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When you run this example, it will fail to compile because React doesn’t know
    about the `<Button>` element; it only knows about `<button>`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个示例时，它将无法编译，因为 React 不了解 `<Button>` 元素；它只知道 `<button>`。
- en: You can use any valid HTML tags as JSX tags, as long as you remember that they’re
    case-sensitive and that you need to pass the correct attribute names. In addition
    to simple HTML tags that only have attribute values, you can use more semantic
    HTML tags to describe the structure of your page content.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用任何有效的 HTML 标签作为 JSX 标签，只要你记住它们是区分大小写的，并且需要传递正确的属性名称。除了只有属性值的简单 HTML 标签外，你还可以使用更语义化的
    HTML 标签来描述页面内容的结构。
- en: Describing UI structures
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述 UI 结构
- en: 'JSX is capable of describing screen elements in a way that ties them together
    to form a complete UI structure. Let’s look at some JSX markup that declares a
    more elaborate structure than a single paragraph:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: JSX 能够以将它们组合在一起形成完整 UI 结构的方式描述屏幕元素。让我们看看一些声明比单个段落更复杂结构的 JSX 标记：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This JSX markup describes a fairly sophisticated UI structure. Yet, it’s easier
    to read than imperative code because it’s HTML, and HTML is good for concisely
    expressing a hierarchical structure. This is how we want to think of our UI when
    it needs to change – not as an individual element or property but the UI as a
    whole.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 JSX 标记描述了一个相当复杂的 UI 结构。然而，由于它是 HTML，HTML 适合简洁地表达层次结构，因此它比命令式代码更容易阅读。这就是我们希望在
    UI 需要改变时如何思考——不是作为一个单独的元素或属性，而是作为一个整体 UI。
- en: 'Here is what the rendered content looks like:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是渲染后的内容看起来像什么：
- en: '![](img/B19636_02_01.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19636_02_01.png)'
- en: 'Figure 2.1: Describing HTML tag structures using JSX syntax'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1：使用 JSX 语法描述 HTML 标签结构
- en: There are a lot of semantic elements in this markup describing the structure
    of the UI. For example, the `<header>` element describes the top part of the page
    where the title is, and the `<main>` element describes where the main page content
    goes. This type of complex structure makes it clearer for developers to reason
    about. But before we start implementing dynamic JSX markup, let’s create some
    of our own JSX components.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个标记中有许多描述 UI 结构的语义元素。例如，`<header>` 元素描述了标题所在的页面顶部部分，而 `<main>` 元素描述了主要页面内容所在的位置。这种复杂结构使开发者更容易推理。但在我们开始实现动态
    JSX 标记之前，让我们创建一些自己的 JSX 组件。
- en: Creating your own JSX elements
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自己的 JSX 元素
- en: Components are the fundamental building blocks of React. In fact, they can be
    thought of as the vocabulary of JSX markup, allowing you to create complex interfaces
    through reusable, encapsulated elements. In this section, we’ll delve into how
    to create your own components and encapsulate HTML markup within them.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是 React 的基本构建块。实际上，它们可以被看作是 JSX 标记的词汇表，允许你通过可重用、封装的元素创建复杂界面。在本节中，我们将深入了解如何创建自己的组件并在其中封装
    HTML 标记。
- en: Encapsulating HTML
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 封装 HTML
- en: 'We create new JSX elements so that we can encapsulate larger structures. This
    means that instead of having to type out complex markup, you can use your custom
    tag. The React component returns the JSX that goes where the tag is used. Let’s
    look at the following example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建新的 JSX 元素，以便我们可以封装更大的结构。这意味着我们不需要输入复杂的标记，可以使用自定义标签。React 组件返回用于标签位置的 JSX。让我们看看以下示例：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here’s what the rendered output looks like:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是渲染后的输出效果：
- en: '![](img/B19636_02_02.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19636_02_02.png)'
- en: 'Figure 2.2: A component rendering encapsulated HTML markup'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2：一个渲染封装 HTML 标记的组件
- en: This is the first React component that we’ve implemented, so let’s take a moment
    to dissect what’s going on here. We created a function called `MyComponent`, in
    the return statement of which we put our HTML tags. This is how we create a React
    component that is used as a new JSX element. As you can see in the call to `render()`,
    you’re rendering a `<MyComponent>` element.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在 React 中实现的第一个组件，所以让我们花点时间分析一下这里发生了什么。我们创建了一个名为 `MyComponent` 的函数，在它的返回语句中我们放置了我们的
    HTML 标签。这就是我们创建一个用作新 JSX 元素的 React 组件的方法。正如你在对 `render()` 的调用中看到的那样，你正在渲染一个 `<MyComponent>`
    元素。
- en: The HTML that this component encapsulates is returned from the function we created.
    In this case, when the JSX is rendered by `react-dom`, it’s replaced by a `<section>`
    element and everything within it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件封装的 HTML 是从我们创建的函数中返回的。在这种情况下，当 JSX 由 `react-dom` 渲染时，它被一个 `<section>` 元素和它内部的所有内容所替换。
- en: When React renders JSX, any custom elements that you use must have their corresponding
    React component within the same scope. In the preceding example, the `MyComponent`
    function was declared in the same scope as the call to `render()`, so everything
    worked as expected. Usually, you’ll import components, adding them to the appropriate
    scope. You’ll see more of this as you progress through the book.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当 React 渲染 JSX 时，你使用的任何自定义元素都必须在相同的作用域内有相应的 React 组件。在前面的示例中，`MyComponent` 函数是在与
    `render()` 调用相同的作用域中声明的，所以一切按预期工作。通常，你会导入组件，将它们添加到适当的作用域中。随着你通过本书的进展，你会看到更多关于这一点的内容。
- en: HTML elements such as `<div>` often take nested child elements. Let’s see whether
    we can do the same with JSX elements, which we create by implementing components.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 元素如 `<div>` 常常包含嵌套子元素。让我们看看我们是否可以用我们创建的 JSX 元素做到同样的事情，这些元素是通过实现组件来创建的。
- en: Nested elements
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套元素
- en: 'Using JSX markup is useful for describing UI structures that have parent-child
    relationships. Child elements are created by nesting them within another component:
    the parent.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 JSX 标记描述具有父子关系的 UI 结构是有用的。子元素是通过在另一个组件（父组件）内部嵌套它们来创建的。
- en: 'For example, a `<li>` tag is only valid as the child of a `<ul>` tag or a `<ol>`
    tag – you’re probably going to make similar nested structures with your own React
    components. For this, you need to use the `children` property. Let’s see how this
    works. Here’s the JSX markup:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个 `<li>` 标签仅当它是 `<ul>` 标签或 `<ol>` 标签的子元素时才是有效的 – 你可能也会用你自己的 React 组件创建类似的嵌套结构。为此，你需要使用
    `children` 属性。让我们看看这是如何工作的。以下是 JSX 标记：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You’re importing two of your own React components: `MySection` and `MyButton`.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在导入你自己的两个 React 组件：`MySection` 和 `MyButton`。
- en: Now, if you look at the JSX markup, you’ll notice that `<MyButton>` is a child
    of `<MySection>`. You’ll also notice that the `MyButton` component accepts text
    as its child, instead of more JSX elements.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how these components work, starting with `MySection`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This component renders a standard `<section>` HTML element, a heading, and then
    `{props.children}`. It’s this last piece that allows components to access nested
    elements or text and render them.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: The two braces used in the preceding example are used for JavaScript expressions.
    I’ll touch on more details of the JavaScript expression syntax found in JSX markup
    in the following section.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at the `MyButton` component:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This component uses the exact same pattern as `MySection`; it takes the `{props.children}`
    value and surrounds it with markup. React handles the details for you. In this
    example, the button text is a child of `MyButton`, which is, in turn, a child
    of `MySection`. However, the button text is transparently passed through `MySection`.
    In other words, we didn’t have to write any code in `MySection` to make sure that
    `MyButton` got its text. *Pretty cool, right?* Here’s what the rendered output
    looks like:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19636_02_03.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: A button element rendered using child JSX values'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: You now know how to build your own React components that introduce new JSX tags
    in your markup. The components that we’ve looked at so far in this chapter have
    been static. That is, once we rendered them, they were never updated. JavaScript
    expressions are the dynamic pieces of JSX that give different output based on
    conditions.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Using JavaScript expressions
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you saw in the preceding section, JSX has a special syntax that allows you
    to embed JavaScript expressions. Any time React renders JSX content, expressions
    in the markup are evaluated. This feature is at the heart of JSX’s dynamism; it
    enables the content and attributes of your components to change in response to
    different data or state conditions. Each time React renders or re-renders JSX
    content, these embedded expressions are evaluated, allowing the displayed UI to
    reflect current data and state. You’ll also learn how to map collections of data
    to JSX elements.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic property values and text
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some HTML property or text values are static, meaning that they don’t change
    as JSX markup is re-rendered. Other values, the values of properties or text,
    are based on data that is found elsewhere in the application. Remember, React
    is just the view layer. Let’s look at an example so that you can get a feel for
    what the JavaScript expression syntax looks like in JSX markup:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Anything that is a valid JavaScript expression, including nested JSX, can go
    in between the curly braces: `{}`. For properties and text, this is often a variable
    name or object property. Notice, in this example, that the `!enabled` expression
    computes a Boolean value. Here’s what the rendered output looks like:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19636_02_04.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.4: Dynamically changing the property value of a button'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4：动态更改按钮的属性值
- en: 'If you’re following along with the downloadable companion code, which I strongly
    recommend doing, try playing around with these values and seeing how the rendered
    HTML changes: [https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter02](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter02)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在跟随可下载的配套代码，我强烈推荐这样做，请尝试调整这些值，看看渲染的 HTML 如何变化：[https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter02](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter02)
- en: Primitive JavaScript values are straightforward to use in JSX syntax. Obviously,
    we can use more complex values such as objects and arrays in the JSX, as well
    as functions to handle events. Let’s explore this.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的 JavaScript 值在 JSX 语法中使用起来非常直接。显然，我们可以在 JSX 中使用更复杂的数据类型，例如对象和数组，以及函数来处理事件。让我们来探讨一下。
- en: Handling events
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件处理
- en: In React, you can easily pass functions to components’ properties to handle
    user interactions such as button clicks, form submissions, and mouse movements.
    This allows you to create interactive and responsive UIs. React provides a convenient
    way to attach event handlers directly to components using a syntax, similar to
    how you would use the `addEventListener` and `removeEventListener` methods in
    traditional JavaScript.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 中，你可以轻松地将函数传递给组件的属性，以处理用户交互，如按钮点击、表单提交和鼠标移动。这允许你创建交互式和响应式的用户界面。React
    提供了一种方便的方法，可以直接使用类似 `addEventListener` 和 `removeEventListener` 方法在传统 JavaScript
    中使用的语法将事件处理器附加到组件上。
- en: 'To illustrate this, let’s consider an example where we want to handle a button-click
    event in a React component:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们考虑一个例子，其中我们想在 React 组件中处理一个按钮点击事件：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, we define a function called `handleClick` that will be called
    when the button is clicked. We then attach this function as an event handler to
    the `onClick` property of the `<button>` component. Whenever the button is clicked,
    React will invoke the `handleClick` function.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们定义了一个名为 `handleClick` 的函数，当按钮被点击时会调用该函数。然后我们将这个函数作为事件处理器附加到 `<button>`
    组件的 `onClick` 属性上。每当按钮被点击时，React 将调用 `handleClick` 函数。
- en: Compared to using `addEventListener` and `removeEventListener` in traditional
    JavaScript, React abstracts away some of the complexities. With React’s event
    handling, you don’t have to worry about manually attaching and detaching event
    listeners to/from DOM elements. React manages the **event delegation** and provides
    a more **declarative** approach to handling events within components.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 与在传统 JavaScript 中使用 `addEventListener` 和 `removeEventListener` 相比，React 抽象掉了一些复杂性。使用
    React 的事件处理，你不必担心手动将事件监听器附加到或从 DOM 元素中移除。React 管理着**事件委托**，并为组件内部的事件处理提供了一种更**声明式**的方法。
- en: React implements event delegation by default to optimize performance. Instead
    of attaching event handlers to each individual element, React attaches a single
    event handler to the root of the application (or a parent component). When an
    event is triggered on a child element, it bubbles up the component tree until
    it reaches the parent with the event handler. React’s synthetic event system then
    determines which component should handle the event based on the target property
    of the event object. This allows React to efficiently manage events without needing
    to attach handlers to every single element.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: React 默认实现事件委托以优化性能。它不是将事件处理器附加到每个单独的元素上，而是将单个事件处理器附加到应用程序的根（或父组件）上。当一个事件在子元素上触发时，它会在组件树中向上冒泡，直到达到具有事件处理器的父组件。然后
    React 的合成事件系统根据事件对象的 target 属性确定哪个组件应该处理该事件。这允许 React 高效地管理事件，而无需将处理器附加到每个元素上。
- en: By using this approach, you can easily pass events to child components, handle
    them in parent components, or even propagate events through multiple levels of
    nested components. This helps in building a modular and reusable component architecture.
    We’ll get to see this in action in the next chapter.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这种方法，你可以轻松地将事件传递给子组件，在父组件中处理它们，甚至通过多层嵌套组件传播事件。这有助于构建模块化和可重用的组件架构。我们将在下一章中看到这一点。
- en: In addition to the `onClick` event, React supports a wide range of other events,
    such as `onChange`, `onSubmit`, `onMouseOver`, and all standard events. You can
    attach event handlers to various elements like buttons, input fields, checkboxes,
    and so on.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`onClick`事件外，React还支持许多其他事件，如`onChange`、`onSubmit`、`onMouseOver`以及所有标准事件。你可以将事件处理器附加到各种元素上，如按钮、输入字段、复选框等。
- en: Note that React promotes a unidirectional data flow, which means that data flows
    from parent components to child components. To pass data or information from child
    components back to the parent component, you can define callbacks as props and
    invoke them with the necessary data. In the upcoming chapters of this book, we
    will delve deeper into event handling in React and how to create custom callbacks.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，React提倡单向数据流，这意味着数据从父组件流向子组件。要从子组件向父组件传递数据或信息，你可以定义回调作为props，并用必要的数据调用它们。在本书的后续章节中，我们将更深入地探讨React中的事件处理以及如何创建自定义回调。
- en: Mapping collections to elements
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将集合映射到元素
- en: Sometimes, you need to write JavaScript expressions that change the structure
    of your markup. In the preceding section, you learned how to use JavaScript expression
    syntax to dynamically change the property values of JSX elements. What about when
    you need to add or remove elements based on JavaScript collections?
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你需要编写JavaScript表达式来改变你的标记结构。在前面的章节中，你学习了如何使用JavaScript表达式语法动态更改JSX元素的属性值。那么，当你需要根据JavaScript集合添加或删除元素时怎么办呢？
- en: Throughout the book, when I refer to a JavaScript collection, I’m referring
    to both plain objects and arrays, or, more generally, anything that’s *iterable*.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，当我提到JavaScript集合时，我指的是普通对象和数组，或者更普遍地说，任何可*迭代*的东西。
- en: 'The best way to dynamically control JSX elements is to map them from a collection.
    Let’s look at an example of how this is done:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 动态控制JSX元素的最佳方式是将它们从集合中映射出来。让我们看看如何做到这一点的一个例子：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first collection is an array called `array`, populated with string values.
    Moving down to the JSX markup, you can see the call to `array.map()`, which returns
    a new array. The mapping function actually returns a JSX element (`<li>`), meaning
    that each item in the array is now represented in the markup.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个集合是一个名为`array`的数组，其中包含字符串值。向下到JSX标记，你可以看到对`array.map()`的调用，它返回一个新数组。映射函数实际上返回一个JSX元素（`<li>`），这意味着数组中的每个项目现在都在标记中表示。
- en: The result of evaluating this expression is an array. Don’t worry – JSX knows
    how to render arrays of elements. For enhanced performance, it is crucial to assign
    a unique `key` prop to each component within the array, enabling React to efficiently
    manage updates during subsequent re-renders.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 评估这个表达式的结果是数组。不用担心——JSX知道如何渲染元素数组。为了提高性能，给数组中的每个组件分配一个唯一的`key` prop至关重要，这样React就可以在后续的重新渲染中高效地管理更新。
- en: The object collection uses the same technique, except that you have to call
    `Object.keys()` and then map this array. What’s nice about mapping collections
    to JSX elements on the page is that you can control the structure of React components
    based on the collected data.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对象集合使用相同的技巧，但你必须调用`Object.keys()`然后映射这个数组。将集合映射到页面上的JSX元素的好处是，你可以根据收集到的数据来控制React组件的结构。
- en: This means that you don’t have to rely on imperative logic to control the UI.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你不必依赖于命令式逻辑来控制UI。
- en: 'Here’s what the rendered output looks like:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是渲染输出的样子：
- en: '![](img/B19636_02_05.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19636_02_05.png)'
- en: 'Figure 2.5: The result of mapping JavaScript collections to HTML elements'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5：将JavaScript集合映射到HTML元素的结果
- en: JavaScript expressions bring JSX content to life. React evaluates expressions
    and updates the HTML content based on what has already been rendered and what
    has changed. Understanding how to utilize these expressions is important because
    it’s one of the most common day-to-day activities of any React developer.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript表达式让JSX内容生动起来。React评估表达式，并根据已经渲染的内容和变化更新HTML内容。理解如何利用这些表达式非常重要，因为这是任何React开发者日常活动中最常见的事情之一。
- en: Now, it’s time to learn how to group together JSX markup without relying on
    HTML tags to do so.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候学习如何在不依赖HTML标签的情况下将JSX标记分组在一起了。
- en: Building fragments of JSX
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建JSX片段
- en: Fragments are a way to group together chunks of markup without having to add
    unnecessary structure to your page. For example, a common approach is to have
    a React component return content wrapped in a `<div>` element. This element serves
    no real purpose and adds clutter to the DOM.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 片段是一种将标记块组合在一起的方法，而无需向你的页面添加不必要的结构。例如，一个常见的做法是让 React 组件返回被 `<div>` 元素包裹的内容。这个元素没有任何实际用途，只会给
    DOM 增加杂乱。
- en: 'Let’s look at an example. Here are two versions of a component. One uses a
    wrapper element, and the other uses the new fragment feature:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子。这里有组件的两个版本。一个使用包装元素，另一个使用新的片段功能：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The two elements rendered are `<WithoutFragments>` and `<WithFragments>`. Here’s
    what they look like when rendered:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染的两个元素是 `<WithoutFragments>` 和 `<WithFragments>`。以下是它们渲染后的样子：
- en: '![](img/B19636_02_06.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19636_02_06.png)'
- en: 'Figure 2.6: Fragments help render fewer HTML tags without any visual difference'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6：片段有助于渲染更少的 HTML 标签，而没有任何视觉差异
- en: Let’s compare the two approaches now.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们比较这两种方法。
- en: Using wrapper elements
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用包装元素
- en: 'The first approach is to wrap sibling elements in `<div>`. Here’s what the
    source looks like:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是将兄弟元素包裹在 `<div>` 中。以下是源代码的样子：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The essence of this component is the `<h1>` and `<p>` tags. Yet, in order to
    return them from `render()`, you have to wrap them with `<div>`. Indeed, inspecting
    the DOM using your browser dev tools reveals that `<div>` does nothing but add
    another level of structure:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件的本质是 `<h1>` 和 `<p>` 标签。然而，为了从 `render()` 方法中返回它们，你必须用 `<div>` 标签将它们包裹起来。实际上，使用浏览器开发者工具检查
    DOM 会发现 `<div>` 标签除了添加另一个结构层级外，并没有做任何事情：
- en: '![](img/B19636_02_07.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19636_02_07.png)'
- en: 'Figure 2.7: Another level of structure in the DOM'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7：DOM 中的另一个结构层级
- en: Now, imagine an app with lots of these components—that’s a lot of pointless
    elements! Let’s see how to use fragments to avoid unnecessary tags.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一个包含大量这些组件的应用——那将有很多无用的元素！让我们看看如何使用片段来避免不必要的标签。
- en: Using fragments
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用片段
- en: 'Let’s take a look at the `WithFragments` component, where we have avoided using
    unnecessary tags:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `WithFragments` 组件，其中我们避免了使用不必要的标签：
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Instead of wrapping the component content in `<div>`, the `<>` element is used.
    This is a special type of element that indicates that only its children need to
    be rendered. The `<>` is a shorthand for `React.Fragment component`. If you need
    to pass a key property to the fragment, you can’t use `<>` syntax.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 与将组件内容包裹在 `<div>` 中的做法不同，这里使用的是 `<>` 元素。这是一个特殊的元素类型，表示只需要渲染其子元素。`<>` 是 `React.Fragment`
    组件的简写。如果你需要向片段传递一个键属性，就不能使用 `<>` 语法。
- en: 'You can see the difference compared to the `WithoutFragments` component if
    you inspect the DOM:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查 DOM，可以看到与 `WithoutFragments` 组件相比的差异。
- en: '![](img/B19636_02_08.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19636_02_08.png)'
- en: 'Figure 2.8: Less HTML in the fragment'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8：片段中的更少 HTML
- en: With the advent of fragments in JSX markup, we have less HTML rendered on the
    page because we don’t have to use tags such as `<div>` for the sole purpose of
    grouping elements together. Instead, when a component renders a fragment, React
    knows to render the fragment’s child element wherever the component is used.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 随着在 JSX 标记中使用片段的出现，页面上渲染的 HTML 更少了，因为我们不需要使用 `<div>` 等标签来仅仅是为了将元素组合在一起。相反，当组件渲染片段时，React
    会知道在组件被使用的地方渲染片段的子元素。
- en: So fragments enable React components to render only the essential elements;
    no more will elements that serve no purpose appear on the rendered page.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，片段使 React 组件能够仅渲染必要的元素；不再会有无用的元素出现在渲染的页面上。
- en: Summary
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you learned about the basics of JSX, including its declarative
    structure, which leads to more maintainable code. Then, you wrote some code to
    render some basic HTML and learned about describing complex structures using JSX;
    every React application has at least some structure.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了 JSX 的基础知识，包括其声明性结构，这有助于编写更易于维护的代码。然后，你编写了一些代码来渲染基本的 HTML，并学习了如何使用
    JSX 描述复杂结构；每个 React 应用至少包含一些结构。
- en: Then, you spent some time learning about extending the vocabulary of JSX markup
    by implementing your own React components, which is how you design your UI as
    a series of smaller pieces and glue them together to form the whole. Then, you
    learned how to bring dynamic content into JSX element properties and how to map
    JavaScript collections to JSX elements, eliminating the need for imperative logic
    to control the UI display. Finally, you learned how to render fragments of JSX
    content, which prevents unnecessary HTML elements from being used.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你花了一些时间学习如何通过实现自己的React组件来扩展JSX标记的词汇量，这就是你如何将UI设计为一系列较小的部分并将它们粘合在一起形成一个整体的方式。接着，你学习了如何将动态内容引入JSX元素属性，以及如何将JavaScript集合映射到JSX元素，从而消除了控制UI显示的命令式逻辑的需求。最后，你学习了如何渲染JSX内容的片段，这可以防止使用不必要的HTML元素。
- en: Now that you have a feel for what it’s like to render UIs by embedding declarative
    XML in your JavaScript modules, it’s time to move on to the next chapter, where
    we’ll take a deeper look at components, properties, and state.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对通过在JavaScript模块中嵌入声明性XML来渲染UI的感觉有了了解，是时候进入下一章了，我们将更深入地探讨组件、属性和状态。
