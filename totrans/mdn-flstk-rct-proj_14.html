<html><head></head><body>
<div id="_idContainer108" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-210"><a id="_idTextAnchor213" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1.1">11</span></h1>
<h1 id="_idParaDest-211" class="calibre5"><a id="_idTextAnchor214" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.2.1">Building a Backend with a GraphQL API</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.3.1">Up until now, we have only been interfacing with REST APIs. </span><span class="kobospan" id="kobo.3.2">For more complex APIs that have deeply nested objects, we can use GraphQL to allow selective access to certain parts of large objects. </span><span class="kobospan" id="kobo.3.3">In this chapter, we are first going to learn what GraphQL is and when it is useful. </span><span class="kobospan" id="kobo.3.4">Then, we are going to experiment with making GraphQL queries and mutations. </span><span class="kobospan" id="kobo.3.5">After that, we are going to implement GraphQL in a backend. </span><span class="kobospan" id="kobo.3.6">Finally, we are going to briefly cover advanced </span><span><span class="kobospan" id="kobo.4.1">GraphQL concepts.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.5.1">In this chapter, we are going to cover the following </span><span><span class="kobospan" id="kobo.6.1">main topics:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.7.1">What </span><span><span class="kobospan" id="kobo.8.1">is GraphQL?</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.9.1">Implementing a GraphQL API in </span><span><span class="kobospan" id="kobo.10.1">a backend</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.11.1">Implementing GraphQL authentication </span><span><span class="kobospan" id="kobo.12.1">and mutations</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.13.1">Overview of advanced </span><span><span class="kobospan" id="kobo.14.1">GraphQL concepts</span></span></li>
</ul>
<h1 id="_idParaDest-212" class="calibre5"><a id="_idTextAnchor215" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.15.1">Technical requirements</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.16.1">Before we start, please install all requirements from </span><a href="B19385_01.xhtml#_idTextAnchor016" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.17.1">Chapter 1</span></em></span></a><em class="italic"><span class="kobospan" id="kobo.18.1">, Preparing for Full-Stack Development</span></em><span class="kobospan" id="kobo.19.1">, and </span><a href="B19385_02.xhtml#_idTextAnchor028" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.20.1">Chapter 2</span></em></span></a><em class="italic"><span class="kobospan" id="kobo.21.1">, Getting to Know Node.js </span></em><span><em class="italic"><span class="kobospan" id="kobo.22.1">and MongoDB</span></em></span><span><span class="kobospan" id="kobo.23.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.24.1">The versions listed in those chapters are the ones used in the book. </span><span class="kobospan" id="kobo.24.2">While installing a newer version should not be an issue, please note that certain steps might work differently on a newer version. </span><span class="kobospan" id="kobo.24.3">If you are having an issue with the code and steps provided in this book, please try using the versions mentioned in </span><em class="italic"><span class="kobospan" id="kobo.25.1">Chapters 1 </span></em><span><span class="kobospan" id="kobo.26.1">and</span></span><span><em class="italic"><span class="kobospan" id="kobo.27.1"> 2.</span></em></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.28.1">You can find the code for this chapter on </span><span><span class="kobospan" id="kobo.29.1">GitHub: </span></span><a href="https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch11" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.30.1">https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch11</span></span></a><span><span class="kobospan" id="kobo.31.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.32.1">If you cloned the full repository for the book, Husky may not find the </span><strong class="source-inline"><span class="kobospan" id="kobo.33.1">.git</span></strong><span class="kobospan" id="kobo.34.1"> directory when running </span><strong class="source-inline"><span class="kobospan" id="kobo.35.1">npm install</span></strong><span class="kobospan" id="kobo.36.1">. </span><span class="kobospan" id="kobo.36.2">In that case, just run </span><strong class="source-inline"><span class="kobospan" id="kobo.37.1">git init</span></strong><span class="kobospan" id="kobo.38.1"> in the root of the corresponding </span><span><span class="kobospan" id="kobo.39.1">chapter folder.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.40.1">The CiA video for this chapter can be found </span><span><span class="kobospan" id="kobo.41.1">at: </span></span><a href="https://youtu.be/6gP0uM-XaVo" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.42.1">https://youtu.be/6gP0uM-XaVo</span></span></a><span><span class="kobospan" id="kobo.43.1">.</span></span></p>
<h1 id="_idParaDest-213" class="calibre5"><a id="_idTextAnchor216" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.44.1">What is GraphQL?</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.45.1">Before we start learning how to use </span><a id="_idIndexMarker678" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.46.1">GraphQL, let’s first focus on what GraphQL is. </span><span class="kobospan" id="kobo.46.2">Like REST, it is a way to query APIs. </span><span class="kobospan" id="kobo.46.3">However, it is also much more than that. </span><span class="kobospan" id="kobo.46.4">GraphQL includes a server-side runtime for executing queries and a type system to define your data. </span><span class="kobospan" id="kobo.46.5">It works with many database engines and can be integrated into your </span><span><span class="kobospan" id="kobo.47.1">existing backend.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.48.1">GraphQL services are created by defining types (such as a </span><strong class="source-inline"><span class="kobospan" id="kobo.49.1">User</span></strong><span class="kobospan" id="kobo.50.1"> type), fields on types (such as a </span><strong class="source-inline"><span class="kobospan" id="kobo.51.1">username</span></strong><span class="kobospan" id="kobo.52.1"> field), and functions to resolve values of fields. </span><span class="kobospan" id="kobo.52.2">Let’s assume we have defined the following </span><strong class="source-inline"><span class="kobospan" id="kobo.53.1">User</span></strong><span class="kobospan" id="kobo.54.1"> type with a function to get </span><span><span class="kobospan" id="kobo.55.1">a username:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.56.1">
type User {
  username: String
}
function User_username(user) {
  return user.getUsername()
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.57.1">We could then define a </span><strong class="source-inline"><span class="kobospan" id="kobo.58.1">Query</span></strong><span class="kobospan" id="kobo.59.1"> type and a function to get the </span><span><span class="kobospan" id="kobo.60.1">current user:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.61.1">
type Query {
  currentUser: User
}
function Query_currentUser(req) {
  return req.auth.user
}</span></pre> <p class="callout-heading"><span class="kobospan" id="kobo.62.1">Info</span></p>
<p class="callout"><span class="kobospan" id="kobo.63.1">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.64.1">Query</span></strong><span class="kobospan" id="kobo.65.1"> type is a special type that defines the “entry point” into the GraphQL schema. </span><span class="kobospan" id="kobo.65.2">It allows us to define which fields are allowed to be queried using the </span><span><span class="kobospan" id="kobo.66.1">GraphQL API.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.67.1">Now that we have defined types with fields and functions to resolve those fields, we can make a </span><a id="_idIndexMarker679" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.68.1">GraphQL query to get the username of the current user. </span><span class="kobospan" id="kobo.68.2">GraphQL queries look like JavaScript objects, but they only list the field names that you want to query. </span><span class="kobospan" id="kobo.68.3">The GraphQL API will then return a JavaScript object that has the same structure as the query, but with the values filled in. </span><span class="kobospan" id="kobo.68.4">Let’s find out how a query to get the username of the current user would </span><span><span class="kobospan" id="kobo.69.1">look like:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.70.1">
{
  currentUser {
    username
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.71.1">That query would then return a JSON result that looks </span><span><span class="kobospan" id="kobo.72.1">like this:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.73.1">
{
  "data": {
    "currentUser": {
      "username": "dan"
    }
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.74.1">As you can see, the result has the same shape as the query. </span><span class="kobospan" id="kobo.74.2">This is one of the essential concepts of GraphQL: the client can specifically ask for the fields that it needs, and the server will return exactly those fields. </span><span class="kobospan" id="kobo.74.3">If we need more data about a user, we can just add new fields to the type </span><span><span class="kobospan" id="kobo.75.1">and query.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.76.1">GraphQL validates</span><a id="_idIndexMarker680" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.77.1"> queries and results against the defined types. </span><span class="kobospan" id="kobo.77.2">This ensures that we do not break the contract between the client and server. </span><span class="kobospan" id="kobo.77.3">The GraphQL types serve as that contract between the client and server. </span><span class="kobospan" id="kobo.77.4">After validating the query, it is executed by a GraphQL server, which then returns a result that looks exactly like the shape requested by the query. </span><span class="kobospan" id="kobo.77.5">Each requested field executes a function on the server. </span><span class="kobospan" id="kobo.77.6">These functions are </span><span><span class="kobospan" id="kobo.78.1">called </span></span><span><strong class="bold"><span class="kobospan" id="kobo.79.1">resolvers</span></strong></span><span><span class="kobospan" id="kobo.80.1">.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer103">
<span class="kobospan" id="kobo.81.1"><img alt="Figure 11.1 – Interaction between GraphQL client and server" src="image/B19385_11_1.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.82.1">Figure 11.1 – Interaction between GraphQL client and server</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.83.1">Types and queries can also be deeply nested. </span><span class="kobospan" id="kobo.83.2">For example, a user could have a field that returns all the posts that this user is an author of. </span><span class="kobospan" id="kobo.83.3">We can then make a sub-selection of fields in those post objects as well. </span><span class="kobospan" id="kobo.83.4">This works for objects within objects and even arrays of objects within objects, in multiple nesting levels. </span><span class="kobospan" id="kobo.83.5">GraphQL will keep resolving fields until only simple values (scalars), such as strings and numbers are left. </span><span class="kobospan" id="kobo.83.6">For example, the following query could fetch the IDs and titles of all posts that the current </span><span><span class="kobospan" id="kobo.84.1">user created:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.85.1">
{
  currentUser {
    username
    posts {
      id
      title
    }
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.86.1">Additionally, GraphQL allows us to define arguments for fields, which will be passed to the functions that resolve our fields. </span><span class="kobospan" id="kobo.86.2">We can use arguments to, for example, get all posts with a certain tag. </span><span class="kobospan" id="kobo.86.3">In GraphQL we can pass arguments to any field, even when they are deeply nested. </span><span class="kobospan" id="kobo.86.4">Arguments can even be passed to single value fields, for instance, to transform a value. </span><span class="kobospan" id="kobo.86.5">For example, the following query would get a post by ID and return the </span><span><span class="kobospan" id="kobo.87.1">post title:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.88.1">
{
  postById(id: "1234") {
    title
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.89.1">GraphQL is </span><a id="_idIndexMarker681" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.90.1">especially useful if you build the backend yourself or with it in mind, as it can allow for patterns where deeply nested and interconnected data can be queried easily. </span><span class="kobospan" id="kobo.90.2">However, if there are existing REST backends that you are not in control of, it is usually not worth it to add GraphQL as a separate, independent layer, due to its </span><span><span class="kobospan" id="kobo.91.1">schema-based restrictions.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.92.1">Having learned about queries, let’s move on </span><span><span class="kobospan" id="kobo.93.1">to mutations.</span></span></p>
<h2 id="_idParaDest-214" class="calibre7"><a id="_idTextAnchor217" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.94.1">Mutations</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.95.1">In REST, any request could </span><a id="_idIndexMarker682" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.96.1">cause a side effect (such as writing data to the database). </span><span class="kobospan" id="kobo.96.2">But, as we</span><a id="_idIndexMarker683" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.97.1"> have learned, GET requests should only return data, and should not cause such side effects. </span><span class="kobospan" id="kobo.97.2">Only POST/PUT/PATCH/DELETE requests should cause data in the database to change. </span><span class="kobospan" id="kobo.97.3">In GraphQL, there is a similar concept: theoretically, any field function could cause the database state to change. </span><span class="kobospan" id="kobo.97.4">However, in GraphQL, we define a mutation instead of a query to explicitly state that we want to change the database state. </span><span class="kobospan" id="kobo.97.5">Besides being defined with the </span><strong class="source-inline"><span class="kobospan" id="kobo.98.1">mutation</span></strong><span class="kobospan" id="kobo.99.1"> keyword, mutations have the same structure as queries. </span><span class="kobospan" id="kobo.99.2">There is one difference, though: queries fetch fields in parallel, while mutations run in series, executing the first field function first, then the next, and so on. </span><span class="kobospan" id="kobo.99.3">This behavior ensures that</span><a id="_idIndexMarker684" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.100.1"> we do not end up with race </span><a id="_idIndexMarker685" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.101.1">conditions </span><span><span class="kobospan" id="kobo.102.1">in mutations.</span></span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.103.1">Info</span></p>
<p class="callout"><span class="kobospan" id="kobo.104.1">In addition to the built-in </span><strong class="source-inline1"><span class="kobospan" id="kobo.105.1">Query</span></strong><span class="kobospan" id="kobo.106.1"> type, there is also a </span><strong class="source-inline1"><span class="kobospan" id="kobo.107.1">Mutation</span></strong><span class="kobospan" id="kobo.108.1"> type to define the allowed </span><span><span class="kobospan" id="kobo.109.1">mutation fields.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.110.1">Now that we have learned the basics of what GraphQL is and how it works, let’s get started using it in practice by implementing GraphQL in our blog </span><span><span class="kobospan" id="kobo.111.1">application backend!</span></span></p>
<h1 id="_idParaDest-215" class="calibre5"><a id="_idTextAnchor218" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.112.1">Implementing a GraphQL API in a backend</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.113.1">We are now going to set up</span><a id="_idIndexMarker686" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.114.1"> GraphQL in our existing blog application backend in addition to the REST API. </span><span class="kobospan" id="kobo.114.2">Doing so will allow us to see how GraphQL compares to and differs from a REST API. </span><span class="kobospan" id="kobo.114.3">Follow these steps to get started setting up GraphQL on </span><span><span class="kobospan" id="kobo.115.1">the backend:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.116.1">Copy the existing </span><strong class="source-inline1"><span class="kobospan" id="kobo.117.1">ch10</span></strong><span class="kobospan" id="kobo.118.1"> folder to a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.119.1">ch11</span></strong><span class="kobospan" id="kobo.120.1"> folder, </span><span><span class="kobospan" id="kobo.121.1">as follows:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.122.1">$ cp -R ch10 ch11</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.123.1">Open the </span><strong class="source-inline1"><span class="kobospan" id="kobo.124.1">ch11</span></strong><span class="kobospan" id="kobo.125.1"> folder in </span><span><span class="kobospan" id="kobo.126.1">VS Code.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.127.1">First, let’s install a VS Code extension to add GraphQL language support. </span><span class="kobospan" id="kobo.127.2">Go to the </span><strong class="bold"><span class="kobospan" id="kobo.128.1">Extensions</span></strong><span class="kobospan" id="kobo.129.1"> tab and search for the </span><strong class="source-inline1"><span class="kobospan" id="kobo.130.1">GraphQL.vscode-graphql</span></strong><span class="kobospan" id="kobo.131.1"> extension developed by the GraphQL Foundation. </span><span class="kobospan" id="kobo.131.2">Install </span><span><span class="kobospan" id="kobo.132.1">the extension.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.133.1">Next, install the </span><strong class="source-inline1"><span class="kobospan" id="kobo.134.1">graphql</span></strong><span class="kobospan" id="kobo.135.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.136.1">@apollo/server</span></strong><span class="kobospan" id="kobo.137.1"> libraries in the backend using the </span><span><span class="kobospan" id="kobo.138.1">following commands:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.139.1">$ cd backend/</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.140.1">$ npm install graphql@16.8.1 @apollo/server@4.10.0</span></strong></pre><p class="calibre3"><span class="kobospan" id="kobo.141.1">Apollo Server</span><a id="_idIndexMarker687" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.142.1"> is a production-ready GraphQL server implementation that supports multiple backend web frameworks, </span><span><span class="kobospan" id="kobo.143.1">including Express.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.144.1">Create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.145.1">backend/src/graphql/</span></strong><span class="kobospan" id="kobo.146.1"> folder. </span><span class="kobospan" id="kobo.146.2">Inside it, create a </span><strong class="source-inline1"><span class="kobospan" id="kobo.147.1">backend/src/graphql/query.js</span></strong><span class="kobospan" id="kobo.148.1"> file, inside which we define a </span><strong class="source-inline1"><span class="kobospan" id="kobo.149.1">Query</span></strong><span class="kobospan" id="kobo.150.1"> schema, which is the entry point of our GraphQL API (listing all supported queries for our backend), </span><span><span class="kobospan" id="kobo.151.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.152.1">
export const querySchema = `#graphql
  type Query {
    test: String
  }
`</span></pre><p class="calibre3"><span class="kobospan" id="kobo.153.1">It is important to add a </span><strong class="source-inline"><span class="kobospan" id="kobo.154.1">#graphql</span></strong><span class="kobospan" id="kobo.155.1"> directive at the beginning of the template string, so that the string is recognized as GraphQL syntax and properly highlighted in a code editor. </span><span class="kobospan" id="kobo.155.2">Inside our schema, we defined a </span><strong class="source-inline"><span class="kobospan" id="kobo.156.1">test</span></strong><span class="kobospan" id="kobo.157.1"> field, for which we </span><a id="_idIndexMarker688" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.158.1">define a </span><span><span class="kobospan" id="kobo.159.1">resolver now.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.160.1">Define a </span><strong class="source-inline1"><span class="kobospan" id="kobo.161.1">queryResolver</span></strong><span class="kobospan" id="kobo.162.1"> object which contains a function to resolve the </span><strong class="source-inline1"><span class="kobospan" id="kobo.163.1">test</span></strong><span class="kobospan" id="kobo.164.1"> field to a </span><span><span class="kobospan" id="kobo.165.1">static string:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.166.1">
export const queryResolver = {
  Query: {
    test: () =&gt; {
      return 'Hello World from GraphQL!'
</span><span class="kobospan1" id="kobo.166.2">    },
  },
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.167.1">Create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.168.1">backend/src/graphql/index.js</span></strong><span class="kobospan" id="kobo.169.1"> file and import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.170.1">querySchema</span></strong><span class="kobospan" id="kobo.171.1"> and </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.172.1">queryResolver</span></strong></span><span><span class="kobospan" id="kobo.173.1"> there:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.174.1">
import { querySchema, queryResolver } from './query.js'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.175.1">Then, export an array called </span><strong class="source-inline1"><span class="kobospan" id="kobo.176.1">typeDefs</span></strong><span class="kobospan" id="kobo.177.1">, which includes all schemas (for now, only the query schema) and an array called </span><strong class="source-inline1"><span class="kobospan" id="kobo.178.1">resolvers</span></strong><span class="kobospan" id="kobo.179.1">, which contains all resolvers (for now, only the </span><span><span class="kobospan" id="kobo.180.1">query resolver):</span></span><pre class="source-code"><span class="kobospan1" id="kobo.181.1">
export const typeDefs = [querySchema]
export const resolvers = [queryResolver]</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.182.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.183.1">backend/src/app.js</span></strong><span class="kobospan" id="kobo.184.1"> and import </span><strong class="source-inline1"><span class="kobospan" id="kobo.185.1">ApolloServer</span></strong><span class="kobospan" id="kobo.186.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.187.1">expressMiddleware</span></strong><span class="kobospan" id="kobo.188.1"> from the </span><strong class="source-inline1"><span class="kobospan" id="kobo.189.1">@</span></strong><span><strong class="source-inline1"><span class="kobospan" id="kobo.190.1">apollo/server</span></strong></span><span><span class="kobospan" id="kobo.191.1"> library:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.192.1">
import { ApolloServer } from '@apollo/server'
import { expressMiddleware } from '@apollo/server/express4'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.193.1">Then, import </span><strong class="source-inline1"><span class="kobospan" id="kobo.194.1">typeDefs</span></strong> <span><span class="kobospan" id="kobo.195.1">and </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.196.1">resolvers</span></strong></span><span><span class="kobospan" id="kobo.197.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.198.1">
import { typeDefs, resolvers } from './graphql/index.js'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.199.1">After all other </span><a id="_idIndexMarker689" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.200.1">middleware and before the route definitions, create a new Apollo server using the schema type definitions and </span><span><span class="kobospan" id="kobo.201.1">defined resolvers:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.202.1">
const apolloServer = new ApolloServer({
  typeDefs,
  resolvers,
})</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.203.1">Then, after the server is ready, mount </span><strong class="source-inline1"><span class="kobospan" id="kobo.204.1">expressMiddleware</span></strong><span class="kobospan" id="kobo.205.1"> to a </span><strong class="source-inline1"><span class="kobospan" id="kobo.206.1">/graphql</span></strong><span class="kobospan" id="kobo.207.1"> route, </span><span><span class="kobospan" id="kobo.208.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.209.1">
apolloServer
  .start()
  .then(() =&gt; app.use('/graphql', expressMiddleware(apolloServer)))</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.210.1">Start the backend in development mode by running the </span><span><span class="kobospan" id="kobo.211.1">following command:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.212.1">$ npm run dev</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.213.1">Go to </span><strong class="source-inline1"><span class="kobospan" id="kobo.214.1">http://localhost:3001/graphql</span></strong><span class="kobospan" id="kobo.215.1"> in your browser; you should see the Apollo interface to input a query on the left side, and the results on the </span><span><span class="kobospan" id="kobo.216.1">right side.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.217.1">Remove all comments from the editor on the left and input the following </span><span><span class="kobospan" id="kobo.218.1">GraphQL query:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.219.1">
query ExampleQuery {
  test
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.220.1">Press the </span><strong class="bold"><span class="kobospan" id="kobo.221.1">Play</span></strong><span class="kobospan" id="kobo.222.1"> button to </span><a id="_idIndexMarker690" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.223.1">run the query, and you will see the </span><span><span class="kobospan" id="kobo.224.1">following result:</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer104">
<span class="kobospan" id="kobo.225.1"><img alt="Figure 11.2 – Successful execution of our first GraphQL query!" src="image/B19385_11_2.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.226.1">Figure 11.2 – Successful execution of our first GraphQL query!</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.227.1">As you can see, our query for the </span><strong class="source-inline"><span class="kobospan" id="kobo.228.1">test</span></strong><span class="kobospan" id="kobo.229.1"> field returns our previously defined </span><span><span class="kobospan" id="kobo.230.1">static string!</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.231.1">After implementing a basic field, let’s implement some fields that access our service functions and retrieve data </span><span><span class="kobospan" id="kobo.232.1">from MongoDB.</span></span></p>
<h2 id="_idParaDest-216" class="calibre7"><a id="_idTextAnchor219" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.233.1">Implementing fields that query posts</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.234.1">Follow </span><a id="_idIndexMarker691" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.235.1">these steps to implement the fields to </span><span><span class="kobospan" id="kobo.236.1">query posts:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.237.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.238.1">backend/src/graphql/query.js</span></strong><span class="kobospan" id="kobo.239.1"> and import the relevant </span><span><span class="kobospan" id="kobo.240.1">service functions:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.241.1">
import {
  getPostById,
  listAllPosts,
  listPostsByAuthor,
  listPostsByTag,
} from '../services/posts.js'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.242.1">Adjust the schema to include a </span><strong class="source-inline1"><span class="kobospan" id="kobo.243.1">posts</span></strong><span class="kobospan" id="kobo.244.1"> field, which returns an array </span><span><span class="kobospan" id="kobo.245.1">of posts:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.246.1">
export const querySchema = `#graphql
  type Query {
    test: String
</span><strong class="bold1"><span class="kobospan1" id="kobo.247.1">    posts: [Post!]!</span></strong></pre><p class="calibre3"><span class="kobospan" id="kobo.248.1">In GraphQL, the </span><strong class="source-inline"><span class="kobospan" id="kobo.249.1">[Type]</span></strong><span class="kobospan" id="kobo.250.1"> syntax means that something is an array of </span><strong class="source-inline"><span class="kobospan" id="kobo.251.1">Type</span></strong><span class="kobospan" id="kobo.252.1">. </span><span class="kobospan" id="kobo.252.2">We will define the </span><strong class="source-inline"><span class="kobospan" id="kobo.253.1">Post</span></strong><span class="kobospan" id="kobo.254.1"> type later. </span><strong class="source-inline"><span class="kobospan" id="kobo.255.1">Type!</span></strong><span class="kobospan" id="kobo.256.1"> is the non-null modifier and means that a type is not null (required), so </span><strong class="source-inline"><span class="kobospan" id="kobo.257.1">[Type!]</span></strong><span class="kobospan" id="kobo.258.1"> means that each element is a </span><strong class="source-inline"><span class="kobospan" id="kobo.259.1">Type</span></strong><span class="kobospan" id="kobo.260.1">, and not </span><strong class="source-inline"><span class="kobospan" id="kobo.261.1">null</span></strong><span class="kobospan" id="kobo.262.1"> (the array can still be empty, though). </span><strong class="source-inline"><span class="kobospan" id="kobo.263.1">[Type!]!</span></strong><span class="kobospan" id="kobo.264.1"> means that the array will always exist and never be </span><strong class="source-inline"><span class="kobospan" id="kobo.265.1">null</span></strong><span class="kobospan" id="kobo.266.1"> (but the array can still </span><span><span class="kobospan" id="kobo.267.1">be empty).</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.268.1">Additionally, define fields for querying posts by </span><strong class="source-inline1"><span class="kobospan" id="kobo.269.1">author</span></strong><span class="kobospan" id="kobo.270.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.271.1">tag</span></strong><span class="kobospan" id="kobo.272.1">, both of which accept a </span><span><span class="kobospan" id="kobo.273.1">required argument:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.274.1">
    postsByAuthor(username: String!): [Post!]!
</span><span class="kobospan1" id="kobo.274.2">    postsByTag(tag: String!): [Post!]!</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.275.1">Lastly, define a field to query a post </span><span><span class="kobospan" id="kobo.276.1">by </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.277.1">id</span></strong></span><span><span class="kobospan" id="kobo.278.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.279.1">
    postById(id: ID!): Post
  }
`</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.280.1">Now that we have defined the schema, we still need to provide resolvers for all those fields. </span><span class="kobospan" id="kobo.280.2">Thanks to our service functions, this is quite straightforward: we can simply call our service functions with the relevant arguments in </span><strong class="source-inline1"><span class="kobospan" id="kobo.281.1">async</span></strong><span class="kobospan" id="kobo.282.1"> functions, </span><span><span class="kobospan" id="kobo.283.1">as</span></span><span><a id="_idIndexMarker692" class="calibre6 pcalibre1 pcalibre"/></span><span><span class="kobospan" id="kobo.284.1"> follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.285.1">
export const queryResolver = {
  Query: {
    test: () =&gt; {
      return 'Hello World from GraphQL!'
</span><span class="kobospan1" id="kobo.285.2">    },
</span><strong class="bold1"><span class="kobospan1" id="kobo.286.1">    posts: async () =&gt; {</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.287.1">      return await listAllPosts()</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.288.1">    },</span></strong><span class="kobospan1" id="kobo.289.1">
    postsByAuthor: async (</span><strong class="bold1"><span class="kobospan1" id="kobo.290.1">parent</span></strong><span class="kobospan1" id="kobo.291.1">, { </span><strong class="bold1"><span class="kobospan1" id="kobo.292.1">username</span></strong><span class="kobospan1" id="kobo.293.1"> }) =&gt; {
</span><strong class="bold1"><span class="kobospan1" id="kobo.294.1">      return await listPostsByAuthor(username)</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.295.1">    },</span></strong><span class="kobospan1" id="kobo.296.1">
    postsByTag: async (</span><strong class="bold1"><span class="kobospan1" id="kobo.297.1">parent</span></strong><span class="kobospan1" id="kobo.298.1">, { </span><strong class="bold1"><span class="kobospan1" id="kobo.299.1">tag</span></strong><span class="kobospan1" id="kobo.300.1"> }) =&gt; {
</span><strong class="bold1"><span class="kobospan1" id="kobo.301.1">      return await listPostsByTag(tag)</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.302.1">    },</span></strong><span class="kobospan1" id="kobo.303.1">
    postById: async (</span><strong class="bold1"><span class="kobospan1" id="kobo.304.1">parent</span></strong><span class="kobospan1" id="kobo.305.1">, { </span><strong class="bold1"><span class="kobospan1" id="kobo.306.1">id</span></strong><span class="kobospan1" id="kobo.307.1"> }) =&gt; {
</span><strong class="bold1"><span class="kobospan1" id="kobo.308.1">      return await getPostById(id)</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.309.1">    },</span></strong><span class="kobospan1" id="kobo.310.1">
  },
}</span></pre><p class="calibre3"><span class="kobospan" id="kobo.311.1">The resolver functions always receive the </span><strong class="source-inline"><span class="kobospan" id="kobo.312.1">parent</span></strong><span class="kobospan" id="kobo.313.1"> object as the first argument and an </span><a id="_idIndexMarker693" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.314.1">object with all arguments as a </span><span><span class="kobospan" id="kobo.315.1">second argument.</span></span></p></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.316.1">Now we have successfully defined fields to query posts. </span><span class="kobospan" id="kobo.316.2">However, the </span><strong class="source-inline"><span class="kobospan" id="kobo.317.1">Post</span></strong><span class="kobospan" id="kobo.318.1"> type is not defined yet, so our GraphQL queries will not work yet. </span><span class="kobospan" id="kobo.318.2">Let’s do </span><span><span class="kobospan" id="kobo.319.1">that next.</span></span></p>
<h2 id="_idParaDest-217" class="calibre7"><a id="_idTextAnchor220" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.320.1">Defining the Post type</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.321.1">After defining the </span><strong class="source-inline"><span class="kobospan" id="kobo.322.1">Query</span></strong><span class="kobospan" id="kobo.323.1"> type, we</span><a id="_idIndexMarker694" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.324.1"> continue by defining the </span><strong class="source-inline"><span class="kobospan" id="kobo.325.1">Post</span></strong><span class="kobospan" id="kobo.326.1"> type, </span><span><span class="kobospan" id="kobo.327.1">as follows:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.328.1">Create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.329.1">backend/src/graphql/post.js</span></strong><span class="kobospan" id="kobo.330.1"> file, where we import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.331.1">getUserInfoById</span></strong><span class="kobospan" id="kobo.332.1"> function to resolve the author of a </span><span><span class="kobospan" id="kobo.333.1">post later:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.334.1">
import { getUserInfoById } from '../services/users.js'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.335.1">Then, define </span><strong class="source-inline1"><span class="kobospan" id="kobo.336.1">postSchema</span></strong><span class="kobospan" id="kobo.337.1">. </span><span class="kobospan" id="kobo.337.2">Note that </span><strong class="source-inline1"><span class="kobospan" id="kobo.338.1">Post</span></strong><span class="kobospan" id="kobo.339.1"> consists of </span><strong class="source-inline1"><span class="kobospan" id="kobo.340.1">id</span></strong><span class="kobospan" id="kobo.341.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.342.1">title</span></strong><span class="kobospan" id="kobo.343.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.344.1">author</span></strong><span class="kobospan" id="kobo.345.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.346.1">contents</span></strong><span class="kobospan" id="kobo.347.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.348.1">tags</span></strong><span class="kobospan" id="kobo.349.1">, and the </span><strong class="source-inline1"><span class="kobospan" id="kobo.350.1">createdAt</span></strong><span class="kobospan" id="kobo.351.1"> and </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.352.1">updatedAt</span></strong></span><span><span class="kobospan" id="kobo.353.1"> timestamps:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.354.1">
export const postSchema = `#graphql
  type Post {
    id: ID!
</span><span class="kobospan1" id="kobo.354.2">    title: String!
</span><span class="kobospan1" id="kobo.354.3">    author: User
    contents: String
    tags: [String!]
    createdAt: Float
    updatedAt: Float
  }
`</span></pre><p class="calibre3"><span class="kobospan" id="kobo.355.1">In this case, we use </span><strong class="source-inline"><span class="kobospan" id="kobo.356.1">[String!]</span></strong><span class="kobospan" id="kobo.357.1"> for the tags, and not </span><strong class="source-inline"><span class="kobospan" id="kobo.358.1">[String!]!</span></strong><span class="kobospan" id="kobo.359.1">, because the </span><strong class="source-inline"><span class="kobospan" id="kobo.360.1">tags</span></strong><span class="kobospan" id="kobo.361.1"> field can also </span><span><span class="kobospan" id="kobo.362.1">be non-existent/</span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.363.1">null</span></strong></span><span><span class="kobospan" id="kobo.364.1">.</span></span></p><p class="calibre3"><span class="kobospan" id="kobo.365.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.366.1">createdAt</span></strong><span class="kobospan" id="kobo.367.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.368.1">updatedAt</span></strong><span class="kobospan" id="kobo.369.1"> timestamps are too large to fit into a 32-bit signed integer, so their type needs to be </span><strong class="source-inline"><span class="kobospan" id="kobo.370.1">Float</span></strong><span class="kobospan" id="kobo.371.1"> instead </span><span><span class="kobospan" id="kobo.372.1">of </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.373.1">Int</span></strong></span><span><span class="kobospan" id="kobo.374.1">.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.375.1">Next, define a resolver for the </span><strong class="source-inline1"><span class="kobospan" id="kobo.376.1">author</span></strong><span class="kobospan" id="kobo.377.1"> field that gets the user using the </span><span><span class="kobospan" id="kobo.378.1">service function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.379.1">
export const postResolver = {
  Post: {
    author: async (post) =&gt; {
      return await getUserInfoById(post.author)
    },
  },
}</span></pre><p class="calibre3"><span class="kobospan" id="kobo.380.1">The resolvers for getting posts are already part of the </span><strong class="source-inline"><span class="kobospan" id="kobo.381.1">Query</span></strong><span class="kobospan" id="kobo.382.1"> schema, so we do not need to define how to get a post here. </span><span class="kobospan" id="kobo.382.2">GraphQL knows that the query fields return </span><strong class="source-inline"><span class="kobospan" id="kobo.383.1">Post</span></strong><span class="kobospan" id="kobo.384.1"> arrays and then allows us to resolve further fields on </span><span><span class="kobospan" id="kobo.385.1">the posts.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.386.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.387.1">backend/src/graphql/index.js</span></strong><span class="kobospan" id="kobo.388.1"> and </span><a id="_idIndexMarker695" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.389.1">add the </span><strong class="source-inline1"><span class="kobospan" id="kobo.390.1">postSchema</span></strong> <span><span class="kobospan" id="kobo.391.1">and </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.392.1">postResolver</span></strong></span><span><span class="kobospan" id="kobo.393.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.394.1">
import { querySchema, queryResolver } from './query.js'
</span><strong class="bold1"><span class="kobospan1" id="kobo.395.1">import { postSchema, postResolver } from './post.js'</span></strong><span class="kobospan1" id="kobo.396.1">
export const typeDefs = [querySchema</span><strong class="bold1"><span class="kobospan1" id="kobo.397.1">, postSchema</span></strong><span class="kobospan1" id="kobo.398.1">]
export const resolvers = [queryResolver</span><strong class="bold1"><span class="kobospan1" id="kobo.399.1">, postResolver</span></strong><span class="kobospan1" id="kobo.400.1">]</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.401.1">After defining the </span><strong class="source-inline"><span class="kobospan" id="kobo.402.1">Post</span></strong><span class="kobospan" id="kobo.403.1"> type, let’s continue with the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.404.1">User</span></strong></span><span><span class="kobospan" id="kobo.405.1"> type.</span></span></p>
<h2 id="_idParaDest-218" class="calibre7"><a id="_idTextAnchor221" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.406.1">Defining the User type</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.407.1">When defining</span><a id="_idIndexMarker696" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.408.1"> the </span><strong class="source-inline"><span class="kobospan" id="kobo.409.1">Post</span></strong><span class="kobospan" id="kobo.410.1"> type, we used the </span><strong class="source-inline"><span class="kobospan" id="kobo.411.1">User</span></strong><span class="kobospan" id="kobo.412.1"> type to define the author of a post. </span><span class="kobospan" id="kobo.412.2">However, we have not defined the </span><strong class="source-inline"><span class="kobospan" id="kobo.413.1">User</span></strong><span class="kobospan" id="kobo.414.1"> type yet. </span><span class="kobospan" id="kobo.414.2">Let’s do </span><span><span class="kobospan" id="kobo.415.1">that now:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.416.1">Create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.417.1">backend/src/graphql/user.js</span></strong><span class="kobospan" id="kobo.418.1"> file and import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.419.1">listPostsByAuthor</span></strong><span class="kobospan" id="kobo.420.1"> function here, as we are going to add a way to resolve the posts of a user when getting a user object, to show how GraphQL can deal with deeply </span><span><span class="kobospan" id="kobo.421.1">nested relations:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.422.1">
import { listPostsByAuthor } from '../services/posts.js'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.423.1">Define </span><strong class="source-inline1"><span class="kobospan" id="kobo.424.1">userSchema</span></strong><span class="kobospan" id="kobo.425.1">. </span><span class="kobospan" id="kobo.425.2">Each </span><strong class="source-inline1"><span class="kobospan" id="kobo.426.1">User</span></strong><span class="kobospan" id="kobo.427.1"> in our GraphQL schema has </span><strong class="source-inline1"><span class="kobospan" id="kobo.428.1">username</span></strong><span class="kobospan" id="kobo.429.1"> and a </span><strong class="source-inline1"><span class="kobospan" id="kobo.430.1">posts</span></strong><span class="kobospan" id="kobo.431.1"> field, in which we will resolve all posts that the user </span><span><span class="kobospan" id="kobo.432.1">has written:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.433.1">
export const userSchema = `#graphql
  type User {
    username: String!
</span><span class="kobospan1" id="kobo.433.2">    posts: [Post!]!
</span><span class="kobospan1" id="kobo.433.3">  }
`</span></pre></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.434.1">Info</span></p>
<p class="callout"><span class="kobospan" id="kobo.435.1">We do not specify any other properties here, as we are only returning the username in our </span><strong class="source-inline1"><span class="kobospan" id="kobo.436.1">getUserInfoById</span></strong><span class="kobospan" id="kobo.437.1"> service function. </span><span class="kobospan" id="kobo.437.2">If we wanted to get the user ID here too, we would have to return it from that function. </span><span class="kobospan" id="kobo.437.3">We are not just returning the full user object, as that could be a potential security vulnerability, exposing internal data such as the password (or billing info in </span><span><span class="kobospan" id="kobo.438.1">some apps).</span></span></p>
<ol class="calibre15">
<li value="3" class="calibre11"><span class="kobospan" id="kobo.439.1">Next, define </span><strong class="source-inline1"><span class="kobospan" id="kobo.440.1">userResolver</span></strong><span class="kobospan" id="kobo.441.1">, which gets all posts from the </span><span><span class="kobospan" id="kobo.442.1">current user:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.443.1">
export const userResolver = {
  User: {
    posts: async (user) =&gt; {
      return await listPostsByAuthor(user.username)
    },
  },
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.444.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.445.1">backend/src/graphql/index.js</span></strong><span class="kobospan" id="kobo.446.1"> and </span><a id="_idIndexMarker697" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.447.1">add the </span><strong class="source-inline1"><span class="kobospan" id="kobo.448.1">userSchema</span></strong> <span><span class="kobospan" id="kobo.449.1">and </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.450.1">userResolver</span></strong></span><span><span class="kobospan" id="kobo.451.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.452.1">
import { querySchema, queryResolver } from './query.js'
import { postSchema, postResolver } from './post.js'
</span><strong class="bold1"><span class="kobospan1" id="kobo.453.1">import { userSchema, userResolver } from './user.js'</span></strong><span class="kobospan1" id="kobo.454.1">
export const typeDefs = [querySchema, postSchema</span><strong class="bold1"><span class="kobospan1" id="kobo.455.1">, userSchema</span></strong><span class="kobospan1" id="kobo.456.1">]
export const resolvers = [queryResolver, postResolver</span><strong class="bold1"><span class="kobospan1" id="kobo.457.1">, userResolver</span></strong><span class="kobospan1" id="kobo.458.1">]</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.459.1">After defining the </span><strong class="source-inline"><span class="kobospan" id="kobo.460.1">User</span></strong><span class="kobospan" id="kobo.461.1"> type, let’s try out some deeply </span><span><span class="kobospan" id="kobo.462.1">nested queries!</span></span></p>
<h2 id="_idParaDest-219" class="calibre7"><a id="_idTextAnchor222" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.463.1">Trying out deeply nested queries</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.464.1">Now that we have </span><a id="_idIndexMarker698" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.465.1">successfully defined our GraphQL schemas and resolvers, we can start querying our database </span><span><span class="kobospan" id="kobo.466.1">using GraphQL!</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.467.1">For example, we can now get a full list of all posts, with their ID, title, and the username of the author, </span><span><span class="kobospan" id="kobo.468.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.469.1">
query GetPostsOverview {
  posts {
    id
    title
    author {
      username
    }
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.470.1">Execute the </span><a id="_idIndexMarker699" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.471.1">preceding query in the Apollo interface. </span><span class="kobospan" id="kobo.471.2">As we can see, the query gets all posts, selects </span><strong class="source-inline"><span class="kobospan" id="kobo.472.1">id</span></strong><span class="kobospan" id="kobo.473.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.474.1">title</span></strong><span class="kobospan" id="kobo.475.1">, and </span><strong class="source-inline"><span class="kobospan" id="kobo.476.1">author</span></strong><span class="kobospan" id="kobo.477.1"> for each post, and then resolves </span><strong class="source-inline"><span class="kobospan" id="kobo.478.1">username</span></strong><span class="kobospan" id="kobo.479.1"> for each </span><strong class="source-inline"><span class="kobospan" id="kobo.480.1">author</span></strong><span class="kobospan" id="kobo.481.1"> instance. </span><span class="kobospan" id="kobo.481.2">This query allows us to get all the data we need on the overview page in a single request, and we do not need to make separate requests to resolve the author </span><span><span class="kobospan" id="kobo.482.1">usernames anymore!</span></span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.483.1">Info</span></p>
<p class="callout"><span class="kobospan" id="kobo.484.1">We did not specify the </span><strong class="source-inline1"><span class="kobospan" id="kobo.485.1">password</span></strong><span class="kobospan" id="kobo.486.1"> field on the </span><strong class="source-inline1"><span class="kobospan" id="kobo.487.1">User</span></strong><span class="kobospan" id="kobo.488.1"> type, so GraphQL will not allow us to access it, even if the resolver function returns a user object that contains </span><span><span class="kobospan" id="kobo.489.1">the password.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.490.1">Now, let’s try out a query that gets a post by ID and then finds other posts by the same author. </span><span class="kobospan" id="kobo.490.2">This could be used to, for example, recommend other articles to view from the same author after someone has finished reading </span><span><span class="kobospan" id="kobo.491.1">a post:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.492.1">We can automatically generate a query in the Apollo interface by clearing the contents of the </span><strong class="bold"><span class="kobospan" id="kobo.493.1">Operation</span></strong><span class="kobospan" id="kobo.494.1"> textbox and then selecting </span><strong class="bold"><span class="kobospan" id="kobo.495.1">Query</span></strong><span class="kobospan" id="kobo.496.1"> from </span><strong class="bold"><span class="kobospan" id="kobo.497.1">Root Types</span></strong><span class="kobospan" id="kobo.498.1"> in the </span><strong class="bold"><span class="kobospan" id="kobo.499.1">Documentation</span></strong><span class="kobospan" id="kobo.500.1"> sidebar on the left. </span><span class="kobospan" id="kobo.500.2">Now click on the </span><strong class="bold"><span class="kobospan" id="kobo.501.1">+</span></strong><span class="kobospan" id="kobo.502.1"> button next to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.503.1">postById</span></strong><span class="kobospan" id="kobo.504.1"> field on the left, which automatically defines a query variable for us, which looks </span><span><span class="kobospan" id="kobo.505.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.506.1">
query PostById($postByIdId: ID!) {
  postById(id: $postByIdId) {</span></pre></li> </ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer105">
<span class="kobospan" id="kobo.507.1"><img alt="Figure 11.﻿3 – Automatically generating a query using the Apollo interface" src="image/B19385_11_3.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.508.1">Figure 11.3 – Automatically generating a query using the Apollo interface</span></p>
<ol class="calibre15">
<li value="2" class="calibre11"><span class="kobospan" id="kobo.509.1">Within the </span><a id="_idIndexMarker700" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.510.1">post, we can now get the </span><strong class="source-inline1"><span class="kobospan" id="kobo.511.1">title</span></strong><span class="kobospan" id="kobo.512.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.513.1">contents</span></strong><span class="kobospan" id="kobo.514.1">, and </span><strong class="source-inline1"><span class="kobospan" id="kobo.515.1">author</span></strong><span class="kobospan" id="kobo.516.1"> values of </span><span><span class="kobospan" id="kobo.517.1">the post:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.518.1">
    title
    contents
    author {</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.519.1">Inside the </span><strong class="source-inline1"><span class="kobospan" id="kobo.520.1">author</span></strong><span class="kobospan" id="kobo.521.1"> field, we get </span><strong class="source-inline1"><span class="kobospan" id="kobo.522.1">username</span></strong><span class="kobospan" id="kobo.523.1"> and the IDs and titles of </span><span><span class="kobospan" id="kobo.524.1">their posts:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.525.1">
      username
      posts {
        id
        title
      }
    }
  }
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.526.1">At the bottom of the Apollo interface, there is a </span><strong class="bold"><span class="kobospan" id="kobo.527.1">Variables</span></strong><span class="kobospan" id="kobo.528.1"> section, which we need to fill with an ID that exists in </span><span><span class="kobospan" id="kobo.529.1">our database:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.530.1">
{
  "postByIdId": "&lt;ENTER ID FROM DATABASE&gt;"
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.531.1">Run the query, and </span><a id="_idIndexMarker701" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.532.1">you will see that the post and author are resolved, and all posts written by that same author are also listed properly, as shown in the </span><span><span class="kobospan" id="kobo.533.1">following screenshot:</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer106">
<span class="kobospan" id="kobo.534.1"><img alt="Figure 11.﻿4 – Running deeply nested queries in GraphQL" src="image/B19385_11_4.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.535.1">Figure 11.4 – Running deeply nested queries in GraphQL</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.536.1">Next, let’s learn how to provide arguments to fields by defining </span><span><span class="kobospan" id="kobo.537.1">input types.</span></span></p>
<h2 id="_idParaDest-220" class="calibre7"><a id="_idTextAnchor223" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.538.1">Implementing input types</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.539.1">We have already learned how to </span><a id="_idIndexMarker702" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.540.1">define regular types in GraphQL, but what if we have a common way to provide arguments to fields? </span><span class="kobospan" id="kobo.540.2">For example, the options to query posts are always the same (</span><strong class="source-inline"><span class="kobospan" id="kobo.541.1">sortBy</span></strong><span class="kobospan" id="kobo.542.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.543.1">sortOrder</span></strong><span class="kobospan" id="kobo.544.1">). </span><span class="kobospan" id="kobo.544.2">We cannot use a regular type for this, instead, we need to define an input type. </span><span class="kobospan" id="kobo.544.3">Follow these steps to implement query options </span><span><span class="kobospan" id="kobo.545.1">in GraphQL:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.546.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.547.1">backend/src/graphql/query.js</span></strong><span class="kobospan" id="kobo.548.1"> and define an input type in </span><span><span class="kobospan" id="kobo.549.1">the schema:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.550.1">
export const querySchema = `#graphql
</span><strong class="bold1"><span class="kobospan1" id="kobo.551.1">  input PostsOptions {</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.552.1">    sortBy: String</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.553.1">    sortOrder: String</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.554.1">  }</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.555.1">Then, use the input type as an argument to fields, </span><span><span class="kobospan" id="kobo.556.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.557.1">
  type Query {
    test: String
    posts(options: PostsOptions): [Post!]!
</span><span class="kobospan1" id="kobo.557.2">    postsByAuthor(username: String!</span><strong class="bold1"><span class="kobospan1" id="kobo.558.1">, options: PostsOptions</span></strong><span class="kobospan1" id="kobo.559.1">): [Post!]!
</span><span class="kobospan1" id="kobo.559.2">    postsByTag(tag: String!</span><strong class="bold1"><span class="kobospan1" id="kobo.560.1">, options: PostsOptions</span></strong><span class="kobospan1" id="kobo.561.1">): [Post!]!
</span><span class="kobospan1" id="kobo.561.2">    postById(id: ID!</span><strong class="bold1"><span class="kobospan1" id="kobo.562.1">, options: PostsOptions</span></strong><span class="kobospan1" id="kobo.563.1">): Post
  }
`</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.564.1">Now, edit the resolvers to pass on </span><strong class="source-inline1"><span class="kobospan" id="kobo.565.1">options</span></strong><span class="kobospan" id="kobo.566.1"> to the </span><span><span class="kobospan" id="kobo.567.1">service functions:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.568.1">
    posts: async (</span><strong class="bold1"><span class="kobospan1" id="kobo.569.1">parent, { options }</span></strong><span class="kobospan1" id="kobo.570.1">) =&gt; {
      return await listAllPosts(</span><strong class="bold1"><span class="kobospan1" id="kobo.571.1">options</span></strong><span class="kobospan1" id="kobo.572.1">)
    },
    postsByAuthor: async (parent, { username</span><strong class="bold1"><span class="kobospan1" id="kobo.573.1">, options</span></strong><span class="kobospan1" id="kobo.574.1"> }) =&gt; {
      return await listPostsByAuthor(username</span><strong class="bold1"><span class="kobospan1" id="kobo.575.1">, options</span></strong><span class="kobospan1" id="kobo.576.1">)
    },
    postsByTag: async (parent, { tag</span><strong class="bold1"><span class="kobospan1" id="kobo.577.1">, options</span></strong><span class="kobospan1" id="kobo.578.1"> }) =&gt; {
      return await listPostsByTag(tag</span><strong class="bold1"><span class="kobospan1" id="kobo.579.1">, options</span></strong><span class="kobospan1" id="kobo.580.1">)
    },</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.581.1">Try out the</span><a id="_idIndexMarker703" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.582.1"> following query to see whether the posts are </span><span><span class="kobospan" id="kobo.583.1">sorted properly:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.584.1">
query SortedPosts($options: PostsOptions) {
  posts(options: $options) {
    id
    title
    createdAt
    updatedAt
  }
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.585.1">Set the </span><span><span class="kobospan" id="kobo.586.1">following variables:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.587.1">
{
  "options": {
    "sortBy": "updatedAt",
    "sortOrder": "ascending"
  }
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.588.1">Run the</span><a id="_idIndexMarker704" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.589.1"> query by pressing the </span><strong class="bold"><span class="kobospan" id="kobo.590.1">Play</span></strong><span class="kobospan" id="kobo.591.1"> button, and you should see that the response is sorted by the </span><strong class="source-inline1"><span class="kobospan" id="kobo.592.1">updatedAt</span></strong> <span><span class="kobospan" id="kobo.593.1">timestamp ascending!</span></span></li>
</ol>
<p class="calibre3"><span class="kobospan" id="kobo.594.1">Now that we have successfully implemented functionality to query our database using GraphQL, let’s move on to implementing a way to create a new post using </span><span><span class="kobospan" id="kobo.595.1">GraphQL Mutations.</span></span></p>
<h1 id="_idParaDest-221" class="calibre5"><a id="_idTextAnchor224" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.596.1">Implementing GraphQL authentication and mutations</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.597.1">We are now going to implement a way to create new posts using GraphQL. </span><span class="kobospan" id="kobo.597.2">To define fields that change the database state, we need to create them under the </span><strong class="source-inline"><span class="kobospan" id="kobo.598.1">mutation</span></strong><span class="kobospan" id="kobo.599.1"> type. </span><span class="kobospan" id="kobo.599.2">Before we can do that, however, we first need to implement authentication in GraphQL, so that we can access the currently logged-in user when creating </span><span><span class="kobospan" id="kobo.600.1">a post.</span></span></p>
<h2 id="_idParaDest-222" class="calibre7"><a id="_idTextAnchor225" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.601.1">Adding authentication to GraphQL</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.602.1">Because we are using </span><a id="_idIndexMarker705" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.603.1">GraphQL with Express, we can use any Express </span><a id="_idIndexMarker706" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.604.1">middleware with GraphQL and pass it to our resolvers as </span><strong class="source-inline"><span class="kobospan" id="kobo.605.1">context</span></strong><span class="kobospan" id="kobo.606.1">. </span><span class="kobospan" id="kobo.606.2">As such, we can use the existing </span><strong class="source-inline"><span class="kobospan" id="kobo.607.1">express-jwt</span></strong><span class="kobospan" id="kobo.608.1"> middleware to parse the JWT. </span><span class="kobospan" id="kobo.608.2">Let’s get started adding authentication to </span><span><span class="kobospan" id="kobo.609.1">GraphQL now:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.610.1">Our current configuration of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.611.1">requireAuth</span></strong><span class="kobospan" id="kobo.612.1"> middleware ensures that the user is logged in and throws an error if they are not. </span><span class="kobospan" id="kobo.612.2">However, this is an issue when passing the </span><strong class="source-inline1"><span class="kobospan" id="kobo.613.1">auth</span></strong><span class="kobospan" id="kobo.614.1"> context to GraphQL, because not all queries require authentication. </span><span class="kobospan" id="kobo.614.2">We are now going to create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.615.1">optionalAuth</span></strong><span class="kobospan" id="kobo.616.1"> middleware that does not require credentials to process a request. </span><span class="kobospan" id="kobo.616.2">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.617.1">backend/src/middleware/jwt.js</span></strong><span class="kobospan" id="kobo.618.1"> and define the following </span><span><span class="kobospan" id="kobo.619.1">new middleware:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.620.1">
export const optionalAuth = expressjwt({
  secret: () =&gt; process.env.JWT_SECRET,
  algorithms: ['HS256'],
  credentialsRequired: false,
})</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.621.1">Now, edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.622.1">backend/src/app.js</span></strong><span class="kobospan" id="kobo.623.1"> and import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.624.1">optionalAuth</span></strong> <span><span class="kobospan" id="kobo.625.1">middleware there:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.626.1">
import { optionalAuth } from './middleware/jwt.js'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.627.1">Edit the </span><strong class="source-inline1"><span class="kobospan" id="kobo.628.1">app.use()</span></strong><span class="kobospan" id="kobo.629.1"> call </span><a id="_idIndexMarker707" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.630.1">where we defined the </span><strong class="source-inline1"><span class="kobospan" id="kobo.631.1">/graphql</span></strong><span class="kobospan" id="kobo.632.1"> route and add the </span><strong class="source-inline1"><span class="kobospan" id="kobo.633.1">optionalAuth</span></strong><span class="kobospan" id="kobo.634.1"> middleware to it, similarly to how we did it </span><span><span class="kobospan" id="kobo.635.1">for</span></span><span><a id="_idIndexMarker708" class="calibre6 pcalibre1 pcalibre"/></span><span><span class="kobospan" id="kobo.636.1"> routes:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.637.1">
apolloServer.start().then(() =&gt;
  app.use(
    '/graphql',
</span><strong class="bold1"><span class="kobospan1" id="kobo.638.1">    optionalAuth,</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.639.1">Then, add a second argument to the Apollo </span><strong class="source-inline1"><span class="kobospan" id="kobo.640.1">expressMiddleware</span></strong><span class="kobospan" id="kobo.641.1">, defining a </span><strong class="source-inline1"><span class="kobospan" id="kobo.642.1">context</span></strong><span class="kobospan" id="kobo.643.1"> function that provides </span><strong class="source-inline1"><span class="kobospan" id="kobo.644.1">req.auth</span></strong><span class="kobospan" id="kobo.645.1"> to the GraphQL resolvers </span><span><span class="kobospan" id="kobo.646.1">as context:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.647.1">
    expressMiddleware(apolloServer</span><strong class="bold1"><span class="kobospan1" id="kobo.648.1">, {</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.649.1">      context: async ({ req }) =&gt; {</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.650.1">        return { auth: req.auth }</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.651.1">      },</span></strong><span class="kobospan1" id="kobo.652.1">
    </span><strong class="bold1"><span class="kobospan1" id="kobo.653.1">}</span></strong><span class="kobospan1" id="kobo.654.1">),
  ),
)</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.655.1">Next, let’s move on to implementing mutations </span><span><span class="kobospan" id="kobo.656.1">in GraphQL.</span></span></p>
<h2 id="_idParaDest-223" class="calibre7"><a id="_idTextAnchor226" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.657.1">Implementing mutations</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.658.1">Now that we have added</span><a id="_idIndexMarker709" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.659.1"> authentication to GraphQL, we can define our mutations. </span><span class="kobospan" id="kobo.659.2">Follow these steps to create mutations for signup, login, and </span><span><span class="kobospan" id="kobo.660.1">creating posts:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.661.1">Create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.662.1">backend/src/graphql/mutation.js</span></strong><span class="kobospan" id="kobo.663.1"> file and import </span><strong class="source-inline1"><span class="kobospan" id="kobo.664.1">GraphQLError</span></strong><span class="kobospan" id="kobo.665.1"> (for throwing an </span><strong class="source-inline1"><span class="kobospan" id="kobo.666.1">UNAUTHORIZED</span></strong><span class="kobospan" id="kobo.667.1"> error when the user is not logged in), as well as the </span><strong class="source-inline1"><span class="kobospan" id="kobo.668.1">createUser</span></strong><span class="kobospan" id="kobo.669.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.670.1">loginUser</span></strong><span class="kobospan" id="kobo.671.1">, and </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.672.1">createPost</span></strong></span><span><span class="kobospan" id="kobo.673.1"> functions:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.674.1">
import { GraphQLError } from 'graphql'
import { createUser, loginUser } from '../services/users.js'
import { createPost } from '../services/posts.js'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.675.1">Define </span><strong class="source-inline1"><span class="kobospan" id="kobo.676.1">mutationSchema</span></strong><span class="kobospan" id="kobo.677.1">, in which we first define fields to sign up and log in users. </span><span class="kobospan" id="kobo.677.2">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.678.1">signupUser</span></strong><span class="kobospan" id="kobo.679.1"> field returns a user object, and the </span><strong class="source-inline1"><span class="kobospan" id="kobo.680.1">loginUser</span></strong><span class="kobospan" id="kobo.681.1"> field returns </span><span><span class="kobospan" id="kobo.682.1">a JWT:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.683.1">
export const mutationSchema = `#graphql
type Mutation {
      signupUser(username: String!, password: String!): User
      loginUser(username: String!, password: String!): String</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.684.1">Then, define a field to create a new post from some given </span><strong class="source-inline1"><span class="kobospan" id="kobo.685.1">title</span></strong><span class="kobospan" id="kobo.686.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.687.1">contents</span></strong><span class="kobospan" id="kobo.688.1"> (optional), and </span><strong class="source-inline1"><span class="kobospan" id="kobo.689.1">tags</span></strong><span class="kobospan" id="kobo.690.1"> (optional). </span><span class="kobospan" id="kobo.690.2">It returns a newly </span><span><span class="kobospan" id="kobo.691.1">created post:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.692.1">
      createPost(title: String!, contents: String, tags: [String]): Post
    }
`</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.693.1">Define the resolver, in which we first define the </span><strong class="source-inline1"><span class="kobospan" id="kobo.694.1">signupUser</span></strong><span class="kobospan" id="kobo.695.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.696.1">loginUser</span></strong><span class="kobospan" id="kobo.697.1"> fields, which are </span><span><span class="kobospan" id="kobo.698.1">quite straightforward:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.699.1">
export const mutationResolver = {
  Mutation: {
    signupUser: async (parent, { username, password }) =&gt; {
      return await createUser({ username, password })
    },
    loginUser: async (parent, { username, password }) =&gt; {
      return await loginUser({ username, password })
    },</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.700.1">Next, we define </span><a id="_idIndexMarker710" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.701.1">the </span><strong class="source-inline1"><span class="kobospan" id="kobo.702.1">createPost</span></strong><span class="kobospan" id="kobo.703.1"> field. </span><span class="kobospan" id="kobo.703.2">Here, we first access the arguments passed to the field, and as a third argument to the resolver function, we get the context we </span><span><span class="kobospan" id="kobo.704.1">created earlier:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.705.1">
    createPost: async (parent, { title, contents, tags }, { auth }) =&gt; {</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.706.1">If the user is not logged in, the </span><strong class="source-inline1"><span class="kobospan" id="kobo.707.1">auth</span></strong><span class="kobospan" id="kobo.708.1"> context will be </span><strong class="source-inline1"><span class="kobospan" id="kobo.709.1">null</span></strong><span class="kobospan" id="kobo.710.1">. </span><span class="kobospan" id="kobo.710.2">We throw an error in that case and do not create a </span><span><span class="kobospan" id="kobo.711.1">new post:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.712.1">
      if (!auth) {
        throw new GraphQLError(
          'You need to be authenticated to perform this action.',
          {
            extensions: {
              code: 'UNAUTHORIZED',
            },
          },
        )
      }</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.713.1">Otherwise, we </span><a id="_idIndexMarker711" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.714.1">use </span><strong class="source-inline1"><span class="kobospan" id="kobo.715.1">auth.sub</span></strong><span class="kobospan" id="kobo.716.1"> (which contains the user ID) and the provided arguments to create a </span><span><span class="kobospan" id="kobo.717.1">new post:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.718.1">
      return await createPost(auth.sub, { title, contents, tags })
    },
  },
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.719.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.720.1">backend/src/graphql/index.js</span></strong><span class="kobospan" id="kobo.721.1"> and add the </span><strong class="source-inline1"><span class="kobospan" id="kobo.722.1">mutationSchema</span></strong> <span><span class="kobospan" id="kobo.723.1">and </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.724.1">mutationResolver</span></strong></span><span><span class="kobospan" id="kobo.725.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.726.1">
import { querySchema, queryResolver } from './query.js'
import { postSchema, postResolver } from './post.js'
import { userSchema, userResolver } from './user.js'
</span><strong class="bold1"><span class="kobospan1" id="kobo.727.1">import { mutationSchema, mutationResolver } from './mutation.js'</span></strong><span class="kobospan1" id="kobo.728.1">
export const typeDefs = [querySchema, postSchema, userSchema</span><strong class="bold1"><span class="kobospan1" id="kobo.729.1">, mutationSchema</span></strong><span class="kobospan1" id="kobo.730.1">]
export const resolvers = [
  queryResolver,
  postResolver,
  userResolver,
</span><strong class="bold1"><span class="kobospan1" id="kobo.731.1">  mutationResolver,</span></strong><span class="kobospan1" id="kobo.732.1">
]</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.733.1">After implementing mutations, let’s learn how to </span><span><span class="kobospan" id="kobo.734.1">use them.</span></span></p>
<h2 id="_idParaDest-224" class="calibre7"><a id="_idTextAnchor227" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.735.1">Using mutations</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.736.1">After defining the possible</span><a id="_idIndexMarker712" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.737.1"> mutations, we can use them by running them in the Apollo interface. </span><span class="kobospan" id="kobo.737.2">Follow these steps to first sign up a user, then log them in, and finally create a post – all </span><span><span class="kobospan" id="kobo.738.1">using GraphQL:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.739.1">Go to </span><strong class="source-inline1"><span class="kobospan" id="kobo.740.1">http://localhost:3001/graphql</span></strong><span class="kobospan" id="kobo.741.1"> to view the Apollo interface. </span><span class="kobospan" id="kobo.741.2">Define a new mutation that signs up a user with a given username and password, and returns the username if the signup </span><span><span class="kobospan" id="kobo.742.1">was successful:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.743.1">
mutation SignupUser($username: String!, $password: String!) {
  signupUser(username: $username, password: $password) {
    username
  }
}</span></pre></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.744.1">Tip</span></p>
<p class="callout"><span class="kobospan" id="kobo.745.1">You can use the </span><strong class="bold"><span class="kobospan" id="kobo.746.1">Documentation</span></strong><span class="kobospan" id="kobo.747.1"> section on the left by going back to </span><strong class="bold"><span class="kobospan" id="kobo.748.1">Root Types</span></strong><span class="kobospan" id="kobo.749.1">, clicking on </span><strong class="bold"><span class="kobospan" id="kobo.750.1">Mutation</span></strong><span class="kobospan" id="kobo.751.1">, and then clicking on the </span><strong class="bold"><span class="kobospan" id="kobo.752.1">+</span></strong><span class="kobospan" id="kobo.753.1"> icon next to </span><strong class="bold"><span class="kobospan" id="kobo.754.1">signupUser</span></strong><span class="kobospan" id="kobo.755.1">. </span><span class="kobospan" id="kobo.755.2">Then, click on the </span><strong class="bold"><span class="kobospan" id="kobo.756.1">+</span></strong><span class="kobospan" id="kobo.757.1"> icon next to the </span><strong class="bold"><span class="kobospan" id="kobo.758.1">username</span></strong><span class="kobospan" id="kobo.759.1"> field. </span><span class="kobospan" id="kobo.759.2">This will automatically create the </span><span><span class="kobospan" id="kobo.760.1">preceding code.</span></span></p>
<ol class="calibre15">
<li value="2" class="calibre11"><span class="kobospan" id="kobo.761.1">Edit the variables at the bottom and enter a username </span><span><span class="kobospan" id="kobo.762.1">and password:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.763.1">
{
  "username": "graphql",
  "password": "gql"
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.764.1">Execute the </span><strong class="source-inline1"><span class="kobospan" id="kobo.765.1">SignupUser</span></strong><span class="kobospan" id="kobo.766.1"> mutation by pressing the </span><span><span class="kobospan" id="kobo.767.1">play button.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.768.1">Next, create a new mutation to log in </span><span><span class="kobospan" id="kobo.769.1">a user:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.770.1">
mutation LoginUser($username: String!, $password: String!) {
  loginUser(username: $username, password: $password)
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.771.1">Enter the same variables as before and press the play button, the response contains a JWT. </span><span class="kobospan" id="kobo.771.2">Copy and store the JWT somewhere for </span><span><span class="kobospan" id="kobo.772.1">later use.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.773.1">Define a new </span><a id="_idIndexMarker713" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.774.1">mutation to create a post. </span><span class="kobospan" id="kobo.774.2">This mutation returns </span><strong class="source-inline1"><span class="kobospan" id="kobo.775.1">Post</span></strong><span class="kobospan" id="kobo.776.1">, so we can get the </span><strong class="source-inline1"><span class="kobospan" id="kobo.777.1">id</span></strong><span class="kobospan" id="kobo.778.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.779.1">title</span></strong><span class="kobospan" id="kobo.780.1">, and </span><strong class="source-inline1"><span class="kobospan" id="kobo.781.1">username</span></strong><span class="kobospan" id="kobo.782.1"> values </span><span><span class="kobospan" id="kobo.783.1">for </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.784.1">author</span></strong></span><span><span class="kobospan" id="kobo.785.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.786.1">
mutation CreatePost($title: String!, $contents: String, $tags: [String]) {
  createPost(title: $title, contents: $contents, tags: $tags) {
    id
    title
    author {
      username
    }
  }
}</span></pre><p class="calibre3"><span class="kobospan" id="kobo.787.1">This is an example of where GraphQL really shines. </span><span class="kobospan" id="kobo.787.2">We can resolve the username of the author after creating the post to see whether it was really created with the correct user, because we can access the resolvers defined for </span><strong class="source-inline"><span class="kobospan" id="kobo.788.1">Post</span></strong><span class="kobospan" id="kobo.789.1">, even in mutations! </span><span class="kobospan" id="kobo.789.2">As you can see, GraphQL is </span><span><span class="kobospan" id="kobo.790.1">very flexible.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.791.1">Enter the </span><span><span class="kobospan" id="kobo.792.1">following variables:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.793.1">
{
  "title": "GraphQL Post",
  "contents": "This is posted from GraphQL!"
</span><span class="kobospan1" id="kobo.793.2">}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.794.1">Select the </span><strong class="bold"><span class="kobospan" id="kobo.795.1">Headers</span></strong><span class="kobospan" id="kobo.796.1"> tab, press </span><a id="_idIndexMarker714" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.797.1">the </span><strong class="bold"><span class="kobospan" id="kobo.798.1">New header</span></strong><span class="kobospan" id="kobo.799.1"> button, enter </span><strong class="source-inline1"><span class="kobospan" id="kobo.800.1">Authorization</span></strong><span class="kobospan" id="kobo.801.1"> for </span><strong class="source-inline1"><span class="kobospan" id="kobo.802.1">header key</span></strong><span class="kobospan" id="kobo.803.1">, and </span><strong class="source-inline1"><span class="kobospan" id="kobo.804.1">Bearer &lt;Paste previously copied JWT here&gt;</span></strong><span class="kobospan" id="kobo.805.1"> for </span><strong class="source-inline1"><span class="kobospan" id="kobo.806.1">value</span></strong><span class="kobospan" id="kobo.807.1">. </span><span class="kobospan" id="kobo.807.2">Then press the </span><strong class="bold"><span class="kobospan" id="kobo.808.1">Play</span></strong><span class="kobospan" id="kobo.809.1"> button to submit </span><span><span class="kobospan" id="kobo.810.1">the mutation.</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer107">
<span class="kobospan" id="kobo.811.1"><img alt="Figure 11.5 – Adding the Authorization header in the Apollo interface" src="image/B19385_11_5.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.812.1">Figure 11.5 – Adding the Authorization header in the Apollo interface</span></p>
<ol class="calibre15">
<li value="9" class="calibre11"><span class="kobospan" id="kobo.813.1">In the</span><a id="_idIndexMarker715" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.814.1"> response, you can see that the post was successfully created, and the author is set and </span><span><span class="kobospan" id="kobo.815.1">resolved correctly!</span></span></li>
</ol>
<p class="calibre3"><span class="kobospan" id="kobo.816.1">Having implemented GraphQL queries and mutations for our blog applications, let’s wrap up the chapter by giving an overview of advanced </span><span><span class="kobospan" id="kobo.817.1">GraphQL concepts.</span></span></p>
<h1 id="_idParaDest-225" class="calibre5"><a id="_idTextAnchor228" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.818.1">Overview of advanced GraphQL concepts</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.819.1">Out of the box, GraphQL comes </span><a id="_idIndexMarker716" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.820.1">with a set of </span><span><span class="kobospan" id="kobo.821.1">scalar types:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.822.1">Int</span></strong><span class="kobospan" id="kobo.823.1">: A signed </span><span><span class="kobospan" id="kobo.824.1">32-bit integer</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.825.1">Float</span></strong><span class="kobospan" id="kobo.826.1">: A signed double-precision </span><span><span class="kobospan" id="kobo.827.1">floating-point value</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.828.1">String</span></strong><span class="kobospan" id="kobo.829.1">: A UTF-8 encoded </span><span><span class="kobospan" id="kobo.830.1">character sequence</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.831.1">Boolean</span></strong><span class="kobospan" id="kobo.832.1">: Can be true </span><span><span class="kobospan" id="kobo.833.1">or false</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.834.1">ID</span></strong><span class="kobospan" id="kobo.835.1">: A unique identifier, serialized as a </span><strong class="source-inline1"><span class="kobospan" id="kobo.836.1">String</span></strong><span class="kobospan" id="kobo.837.1">, but meant to signify that it is not </span><span><span class="kobospan" id="kobo.838.1">human readable</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.839.1">GraphQL also </span><a id="_idIndexMarker717" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.840.1">allows the definition of enums, which are a special kind of scalar. </span><span class="kobospan" id="kobo.840.2">They are restricted to certain values. </span><span class="kobospan" id="kobo.840.3">For example, we could have the following enum to distinguish different types </span><span><span class="kobospan" id="kobo.841.1">of posts:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.842.1">
enum PostType {
  UNPUBLISHED,
  UNLISTED,
  PUBLIC
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.843.1">In Apollo, enums will be handled as strings that can only have certain values, but this may be different in other </span><span><span class="kobospan" id="kobo.844.1">GraphQL implementations.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.845.1">Many GraphQL implementations also allow defining custom scalar types. </span><span class="kobospan" id="kobo.845.2">Apollo, for example, supports the definition of custom </span><span><span class="kobospan" id="kobo.846.1">scalar types.</span></span></p>
<h2 id="_idParaDest-226" class="calibre7"><a id="_idTextAnchor229" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.847.1">Fragments</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.848.1">When the same kind</span><a id="_idIndexMarker718" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.849.1"> of fields </span><a id="_idIndexMarker719" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.850.1">are regularly accessed, we can create a fragment to simplify and standardize access to them. </span><span class="kobospan" id="kobo.850.2">For example, if we often resolve users, and users have fields such as </span><strong class="source-inline"><span class="kobospan" id="kobo.851.1">username</span></strong><span class="kobospan" id="kobo.852.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.853.1">profilePicture</span></strong><span class="kobospan" id="kobo.854.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.855.1">fullName</span></strong><span class="kobospan" id="kobo.856.1">, and </span><strong class="source-inline"><span class="kobospan" id="kobo.857.1">biography</span></strong><span class="kobospan" id="kobo.858.1">, we could create the </span><span><span class="kobospan" id="kobo.859.1">following fragment:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.860.1">
fragment UserInfo on User {
  username
  profilePicture
  fullName
  biography
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.861.1">This fragment can then be used in queries. </span><span class="kobospan" id="kobo.861.2">For example, see </span><span><span class="kobospan" id="kobo.862.1">this snippet:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.863.1">
{
  posts {
    author {
      ...UserInfo
    }
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.864.1">Fragments are </span><a id="_idIndexMarker720" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.865.1">especially useful when the same kind of field </span><a id="_idIndexMarker721" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.866.1">structure is used multiple times in the same query. </span><span class="kobospan" id="kobo.866.2">For example, if an author had </span><strong class="source-inline"><span class="kobospan" id="kobo.867.1">followedBy</span></strong><span class="kobospan" id="kobo.868.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.869.1">follows</span></strong><span class="kobospan" id="kobo.870.1"> fields, we could resolve all users </span><span><span class="kobospan" id="kobo.871.1">like this:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.872.1">
{
  posts {
    author {
      ...UserInfo
      followedBy {
        ...UserInfo
      }
      follows {
        ...UserInfo
      }
    }
  }
}</span></pre> <h2 id="_idParaDest-227" class="calibre7"><a id="_idTextAnchor230" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.873.1">Introspection</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.874.1">Introspection </span><a id="_idIndexMarker722" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.875.1">allows us to query the defined schemas themselves to get a </span><a id="_idIndexMarker723" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.876.1">feeling for the data that the server can provide for us. </span><span class="kobospan" id="kobo.876.2">It is essentially querying the schemas defined by the GraphQL server. </span><span class="kobospan" id="kobo.876.3">We can use the </span><strong class="source-inline"><span class="kobospan" id="kobo.877.1">__schema</span></strong><span class="kobospan" id="kobo.878.1"> field to get all schemas. </span><span class="kobospan" id="kobo.878.2">A schema consists of </span><strong class="source-inline"><span class="kobospan" id="kobo.879.1">types</span></strong><span class="kobospan" id="kobo.880.1">, which have </span><span><strong class="source-inline"><span class="kobospan" id="kobo.881.1">name</span></strong></span><span><span class="kobospan" id="kobo.882.1"> values.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.883.1">For example, we can use the following query to get all types defined by </span><span><span class="kobospan" id="kobo.884.1">our server:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.885.1">
{
  __schema {
    types {
      name
    }
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.886.1">If you execute this query on our server, you will get (among other types) our defined </span><strong class="source-inline"><span class="kobospan" id="kobo.887.1">Query</span></strong><span class="kobospan" id="kobo.888.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.889.1">Post</span></strong><span class="kobospan" id="kobo.890.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.891.1">User</span></strong><span class="kobospan" id="kobo.892.1">, and </span><span><strong class="source-inline"><span class="kobospan" id="kobo.893.1">Mutation</span></strong></span><span><span class="kobospan" id="kobo.894.1"> types.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.895.1">Introspection queries are very powerful, and you can get a lot of information about the possible queries and mutations from it. </span><span class="kobospan" id="kobo.895.2">Actually, the Apollo interface uses introspection to render the </span><strong class="bold"><span class="kobospan" id="kobo.896.1">Documentation</span></strong><span class="kobospan" id="kobo.897.1"> sidebar and to auto-complete fields </span><span><span class="kobospan" id="kobo.898.1">for us!</span></span></p>
<h1 id="_idParaDest-228" class="calibre5"><a id="_idTextAnchor231" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.899.1">Summary</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.900.1">In this chapter, we learned what GraphQL is and how it can be more flexible than REST while requiring less boilerplate code, especially when querying deeply nested objects. </span><span class="kobospan" id="kobo.900.2">Then, we implemented GraphQL in our backend and created various types, queries, and mutations. </span><span class="kobospan" id="kobo.900.3">We also learned how to integrate JWT authentication in GraphQL. </span><span class="kobospan" id="kobo.900.4">Finally, we wrapped up the chapter by learning about advanced concepts, such as the type system, fragments, </span><span><span class="kobospan" id="kobo.901.1">and introspection.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.902.1">In the next chapter, </span><a href="B19385_12.xhtml#_idTextAnchor232" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.903.1">Chapter 12</span></em></span></a><em class="italic"><span class="kobospan" id="kobo.904.1">, Interfacing with GraphQL on the Frontend Using Apollo Client</span></em><span class="kobospan" id="kobo.905.1">, we are going to learn how to access and integrate GraphQL in our frontend using React and the Apollo </span><span><span class="kobospan" id="kobo.906.1">Client library.</span></span></p>
</div>
</body></html>