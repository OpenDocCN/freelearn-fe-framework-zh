<html><head></head><body>
  <div id="_idContainer426">
    <h1 class="chapterNumber">8</h1>
    <h1 class="chapterTitle" id="_idParaDest-274">Designing Authentication and Authorization</h1>
    <p class="normal">Designing a high-quality authentication and authorization system without frustrating the end user is a difficult problem to solve. Authentication is the act of verifying the identity of a user, and authorization specifies the privileges that a user must have to access a resource. Both processes, auth for short, must seamlessly work in tandem to address the needs of users with varying roles, needs, and job functions.</p>
    <p class="normal">On today's web, users have a high baseline level of expectations from any auth system they encounter through the browser, so this is an important part of your application to get absolutely right the first time. The user should always be aware of what they can and can't do in your application. If there are errors, failures, or mistakes, the user should be clearly informed about why they occurred. As your application grows, it will be easy to miss all the ways that an error condition could be triggered. Your implementation should be easy to extend or maintain, otherwise this basic backbone of your application will require a lot of maintenance. In this chapter, we will walk through the various challenges of creating a great auth UX and implement a solid baseline experience.</p>
    <p class="normal">We will continue the router-first approach to designing SPAs by implementing the auth experience of LemonMart. In <em class="italics">Chapter 7</em>, <em class="italics">Creating a Router-First Line-of-Business App</em>, we defined user roles, finished our build-out of all major routing, and completed a rough walking-skeleton navigation experience of LemonMart. This means that we are well prepared to implement a role-based conditional navigation experience that captures the nuances of a seamless auth experience.</p>
    <p class="normal">In this chapter, we will implement a token-based auth scheme around the User entity that we defined in the last chapter. For a robust and maintainable implementation, we will deep dive into <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>) with abstraction, inheritance, and factories, along with implementing a cache service, a UI service, and two different auth schemes: an in-memory fake auth service for educational purposes and a Google Firebase auth service that you can leverage in real-world applications.</p>
    <p class="normal">In this chapter, you will learn about the following topics: </p>
    <ul>
      <li class="list">Designing an auth workflow</li>
      <li class="list">TypeScript operators for safe data handling</li>
      <li class="list">Reusable services leveraging OOP concepts</li>
      <li class="list">Dynamic UI components and navigation</li>
      <li class="list">Role-based routing using guards</li>
      <li class="list">Firebase authentication recipe</li>
      <li class="list">Providing a service using a factory</li>
    </ul>
    <p class="normal">The most up-to-date versions of the sample code for the book are on GitHub at the linked repository that follows. The repository contains the final and completed state of the code. You can verify your progress at the end of this chapter by looking for the end-of-chapter snapshot of code under the <code class="Code-In-Text--PACKT-">projects</code> folder.</p>
    <p class="normal">For <em class="italics">Chapter 8</em>:</p>
    <ol>
      <li class="list">Clone the repository <a href="https://github.com/duluca/lemon-mart "><span class="url">https://github.com/duluca/lemon-mart</span></a></li>
      <li class="list">Execute <code class="Code-In-Text--PACKT-">npm install</code> on the root folder to install dependencies</li>
      <li class="list">The code sample for this chapter is under the sub-folder
        <pre class="programlisting"><code class="hljs">projects/ch8
</code></pre>
      </li>
      <li class="list">To run the Angular application for this chapter, execute
        <pre class="programlisting"><code class="hljs nginx"><span class="hljs-attribute">npx</span> ng serve ch8
</code></pre>
      </li>
      <li class="list">To run the Angular unit tests for this chapter, execute
        <pre class="programlisting"><code class="hljs bash">npx ng <span class="hljs-built_in">test</span> ch8 --watch=<span class="hljs-literal">false</span>
</code></pre>
      </li>
      <li class="list">To run Angular e2e tests for this chapter, execute
        <pre class="programlisting"><code class="hljs nginx"><span class="hljs-attribute">npx</span> ng e2e ch8
</code></pre>
      </li>
      <li class="list" value="7">To build a production-ready Angular application for this chapter, execute
        <pre class="programlisting"><code class="hljs ada">npx ng build ch8 <span class="hljs-comment">--prod</span>
</code></pre>
      </li>
    </ol>
    <div class="packt_tip">
      <p>Note that the <code class="Code-In-Text--PACKT-">dist/ch8</code> folder at the root of the repository will contain the compiled result.</p>
    </div>
    <div class="note">
      <p class="Information-Box--PACKT-">Be aware that the source code in the book or on GitHub may not always match the code generated by Angular CLI. There may also be slight differences in implementation between the code in the book and what's on GitHub because the ecosystem is ever-evolving. It is natural for the sample code to change over time. Also, on GitHub, expect to find corrections, fixes to support newer versions of libraries, or side-by-side implementations of multiple techniques for you to observe. You are only expected to implement the ideal solution recommended in the book. If you find errors or have questions, please create an issue or submit a pull request on GitHub for the benefit of all readers. </p>
    </div>
    <p class="normal">Let's start with going over how a token-based auth workflow functions.</p>
    <h1 class="title" id="_idParaDest-275">Designing an auth workflow</h1>
    <p class="normal">A well-designed authentication workflow is stateless so that there's no concept of an expiring session. Users are <a id="_idIndexMarker730"/>free to interact with your stateless REST APIs from as many devices and tabs as they wish, simultaneously or over time. <strong class="bold">JSON Web Token</strong> (<strong class="bold">JWT</strong>) implements <a id="_idIndexMarker731"/>distributed claims-based authentication that can be digitally signed or integration that is protected and/or encrypted using a <strong class="bold">Message Authentication Code</strong> (<strong class="bold">MAC</strong>). This means that once a user's identity <a id="_idIndexMarker732"/>is authenticated (that is, a password challenge on a login form), they receive an encoded claim ticket or a token, which can then be used to make future requests to the system without having to reauthenticate the identity of the user.</p>
    <p class="normal">The server can independently verify the validity of this claim and process the requests without requiring any prior knowledge of having interacted with this user. Thus, we don't have to store session information regarding a user, making our solution stateless and easy to scale. Each token will expire after a predefined period and due to their distributed nature, they can't be remotely or individually revoked; however, we can bolster real-time security by interjecting custom account and user role status checks to ensure that <a id="_idIndexMarker733"/>the authenticated user is authorized to access server-side resources.</p>
    <div class="packt_tip">
      <p>JWTs <a id="_idIndexMarker734"/>implement the <strong class="bold">Internet Engineering Task Force</strong> (<strong class="bold">IETF</strong>) industry standard RFC 7519, found at <a href="https://tools.ietf.org/html/rfc7519"><span class="url">https://tools.ietf.org/html/rfc7519</span></a>.</p>
    </div>
    <p class="normal">A good authorization workflow enables conditional navigation based on a user's role so that users are automatically taken to the optimal landing screen; they are not shown routes or elements that are not suitable for their roles and if, by mistake, they try to access a restricted path, they are prevented from doing so. You must remember that any client-side role-based navigation is merely a convenience and is not meant for security. This means that every call made to the server should contain the necessary header information, with the secure token, so that the user can be reauthenticated by the server <a id="_idIndexMarker735"/>and their role independently verified. Only then will they be allowed to retrieve secured data. Client-side authentication can't be trusted, which is why password reset screens must be built with a server-side rendering technology so that both the user and the server can verify that the intended user is interacting with the system.</p>
    <h2 class="title" id="_idParaDest-276">JWT life cycle</h2>
    <p class="normal">JWTs complement a stateless REST API architecture with an encrypted token mechanism that allows <a id="_idIndexMarker736"/>convenient, distributed, and high-performance authentication and authorization of requests sent by clients. There are three main components of a token-based authentication scheme:</p>
    <ul>
      <li class="list"><strong class="bold">Client-side</strong>: Captures <a id="_idIndexMarker737"/>login information and hides disallowed actions for a good UX</li>
      <li class="list"><strong class="bold">Server-side</strong>: Validates <a id="_idIndexMarker738"/>that every request is both authenticated and has the proper authorization</li>
      <li class="list"><strong class="bold">Auth service</strong>: Generates <a id="_idIndexMarker739"/>and validates encrypted tokens, and independently verifies the auth status of user requests from a data store</li>
    </ul>
    <p class="normal">A secure system presumes that data sent/received between clients (applications and browsers), systems (servers and services), and databases is encrypted using <strong class="bold">transport layer security</strong> (<strong class="bold">TLS</strong>), which <a id="_idIndexMarker740"/>is essentially a newer version of <strong class="bold">secure sockets layer</strong> (<strong class="bold">SSL</strong>). This means that your REST API must be hosted with a <a id="_idIndexMarker741"/>properly configured SSL certificate, serving all API calls over HTTPS, so that user credentials are never exposed between the client and the server. Similarly, any database or third-party service call should happen over TLS. This ensures the security of the data in transit.</p>
    <p class="normal">At-rest (when the data is sitting in the database) passwords should be stored using a secure one-way hashing algorithm with good salting practices.</p>
    <div class="packt_tip">
      <p>Did all the talk of hashing and salting make you think of breakfast? Unfortunately, they're cryptography-related terms. If you're interested in learning more, check out this article: <a href="https://crackstation.net/hashing-security.htm"><span class="url">https://crackstation.net/hashing-security.htm</span></a>.</p>
    </div>
    <p class="normal">Sensitive <a id="_idIndexMarker742"/>user information, such as <strong class="bold">personally identifiable information</strong> (<strong class="bold">PII</strong>), should be encrypted at rest with a secure two-way encryption algorithm, unlike passwords. Passwords are hashed, so we verify that the user is <a id="_idIndexMarker743"/>providing the same password without the system knowing what the password is. With PII, we must be able to decrypt the data so that we can display it to the user. But since the data is encrypted at rest, if the database is compromised then the hacked data is worthless.</p>
    <p class="normal">Following a layered approach to security is critical, because attackers will need to accomplish the unlikely feat of compromising all layers of your security at the same time to cause meaningful harm to your business.</p>
    <div class="packt_tip">
      <p><strong class="screen-text">Fun fact</strong>: When you hear about massive data breaches from major corporations, most of the time the root cause is a lack of proper implementation of in-transit or at-rest security. Sometimes this is because it is too computationally expensive to continually encrypt/decrypt data, so engineers rely on being behind firewalls. In that case, once the outer perimeter is breached, as they say, the fox has access to the hen house.</p>
    </div>
    <p class="normal">Consider the following sequence diagram, which highlights the life cycle of JWT-based authentication:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_08_01.png"/></figure>
    <p class="packt_figref">Figure 8.1: The life cycle of JWT-based authentication</p>
    <p class="normal">Initially, a user logs in by providing their username and password. Once validated, the user's authentication status and role are encrypted in a JWT with an expiration date and time, and it is <a id="_idIndexMarker744"/>sent back to the browser.</p>
    <p class="normal">Our Angular (or any other) application can cache this token in local or session storage securely so that the user isn't forced to log in with every request. This way, we don't resort to insecure practices like storing user credentials in cookies to provide a good UX.</p>
    <p class="normal">You will get a better understanding of the JWT life cycle when you implement your own auth service later in this chapter. In the following sections, we will design a fully featured auth workflow around the <strong class="bold">User</strong> data entity, as follows:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_08_02.png"/></figure>
    <p class="packt_figref">Figure 8.2: The User entity</p>
    <p class="normal">The User entity described <a id="_idIndexMarker745"/>is slightly different to our initial entity model. The entity model reflects how data is stored in the database. The entity is a flattened (or simplified) representation of the user record. Even a flattened entity has complex objects, like <strong class="bold">name</strong>, which has properties for first, middle, and last. Furthermore, not all properties are required. Additionally, when interacting with auth systems and other APIs, we may receive incomplete, incorrect, or maliciously formed data, so our <a id="_idIndexMarker746"/>code will have to effectively deal with <code class="Code-In-Text--PACKT-">null</code> and <code class="Code-In-Text--PACKT-">undefined</code> variables.</p>
    <p class="normal">Next, let's see how we can leverage TypeScript operators to effectively deal with unexpected data.</p>
    <h1 class="title" id="_idParaDest-277">TypeScript operators for safe data handling</h1>
    <p class="normal">JavaScript is a dynamically typed language. At runtime, the JavaScript engine executing our code, like Chrome's V8, doesn't know the type of the variable we're using. As a result, the <a id="_idIndexMarker747"/>engine must infer the type. We can have basic types like <code class="Code-In-Text--PACKT-">boolean</code>, <code class="Code-In-Text--PACKT-">number</code>, <code class="Code-In-Text--PACKT-">array</code>, or <code class="Code-In-Text--PACKT-">string</code>, or we can have a complex type, which is <a id="_idIndexMarker748"/>essentially a JSON object. In addition, variables can be <code class="Code-In-Text--PACKT-">null</code> or <code class="Code-In-Text--PACKT-">undefined</code>. In broad terms, <code class="Code-In-Text--PACKT-">undefined</code> represents something that hasn't been initialized and <code class="Code-In-Text--PACKT-">null</code> represents something that isn't currently available.</p>
    <p class="normal">In strongly typed languages, the concept of <code class="Code-In-Text--PACKT-">undefined</code> doesn't exist. Basic types have default values, like a <code class="Code-In-Text--PACKT-">number</code> is a zero or a <code class="Code-In-Text--PACKT-">string</code> is an empty string. However, complex types can be <code class="Code-In-Text--PACKT-">null</code>. A <code class="Code-In-Text--PACKT-">null</code> reference means that the variable is defined, but there's no value behind it.</p>
    <div class="packt_tip">
      <p>The inventor of the <code class="Code-In-Text--PACKT-">null</code> reference, Tony Hoare, called it his "billion-dollar mistake."</p>
    </div>
    <p class="normal">TypeScript brings the concepts of strongly typed languages to JavaScript, so it must bridge the gap between the two worlds. As a result, TypeScript defines types like <code class="Code-In-Text--PACKT-">null</code>, <code class="Code-In-Text--PACKT-">undefined</code>, <code class="Code-In-Text--PACKT-">any</code>, and <code class="Code-In-Text--PACKT-">never</code> to make sense of JavaScript's type semantics. I've added links to relevant TypeScript documentation in the <em class="italics">Further reading</em> section for a deeper dive into TypeScript types.</p>
    <p class="normal">As the TypeScript <a id="_idIndexMarker749"/>documentation puts it, TypeScript treats <code class="Code-In-Text--PACKT-">null</code> and <code class="Code-In-Text--PACKT-">undefined</code> differently in order to match the JavaScript semantics. For example, the union type <code class="Code-In-Text--PACKT-">string | null</code> is a different type than <code class="Code-In-Text--PACKT-">string | undefined</code> and <code class="Code-In-Text--PACKT-">string | undefined | null</code>.</p>
    <p class="normal">There's another <a id="_idIndexMarker750"/>nuance: checking to see whether a value equals <code class="Code-In-Text--PACKT-">null</code> using <code class="Code-In-Text--PACKT-">==</code> versus <code class="Code-In-Text--PACKT-">===</code>. Using the double equals operator, checking that <code class="Code-In-Text--PACKT-">foo != null</code> means that <code class="Code-In-Text--PACKT-">foo</code> is defined and not <code class="Code-In-Text--PACKT-">null</code>. However, using the triple equals operator, <code class="Code-In-Text--PACKT-">foo !== null</code> means that <code class="Code-In-Text--PACKT-">foo</code> is not <code class="Code-In-Text--PACKT-">null</code>, but could be <code class="Code-In-Text--PACKT-">undefined</code>. However, these two operators don't consider the truthiness of the variable, which includes the case of an empty string.</p>
    <p class="normal">These subtle differences have a great impact on how you write code, especially when using the strict TypeScript rules that are applied when you create your Angular application using the <code class="Code-In-Text--PACKT-">--strict</code> option. It is important to remember that TypeScript is a development time tool and not a runtime tool. At runtime, we're still dealing with the realities of a dynamically typed language. Just because we declared a type to be a string, it doesn't mean that we will receive a string.</p>
    <p class="normal">Next, let's see how we can deal with issues related to working with unexpected values.</p>
    <h2 class="title" id="_idParaDest-278">Null and undefined checking</h2>
    <p class="normal">When <a id="_idIndexMarker751"/>working with other libraries <a id="_idIndexMarker752"/>or dealing with information sent or received outside of your application, you must deal with the fact that the variable you receive might be <code class="Code-In-Text--PACKT-">null</code> or <code class="Code-In-Text--PACKT-">undefined</code>. </p>
    <p class="normal">Outside of your application means dealing with user input, reading from a cookie or <code class="Code-In-Text--PACKT-">localStorage</code>, URL parameters from the router, or an API call over HTTP, to name a few examples.</p>
    <p class="normal">In our code, we <a id="_idIndexMarker753"/>mostly care about the truthiness of a variable. This means that a variable is defined, not null, and if it's a basic type, it has a non-default <a id="_idIndexMarker754"/>value. Given a <code class="Code-In-Text--PACKT-">string</code>, we can check whether the <code class="Code-In-Text--PACKT-">string</code> is truthy with a simple <code class="Code-In-Text--PACKT-">if</code> statement:</p>
    <pre class="programlisting"><code class="hljs typescript"><strong>example</strong>
<span class="hljs-keyword">const</span> foo: <span class="hljs-built_in">string</span> = <span class="hljs-literal">undefined</span>
<span class="hljs-keyword">if</span>(foo) {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'truthy'</span>)
} <span class="hljs-keyword">else</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'falsy'</span>)
}
</code></pre>
    <p class="normal">If <code class="Code-In-Text--PACKT-">foo</code> is <code class="Code-In-Text--PACKT-">null</code>, <code class="Code-In-Text--PACKT-">undefined</code>, or an empty string, the variable will be evaluated as <code class="Code-In-Text--PACKT-">falsy</code>. For certain situations, you may want to use the conditional or ternary operator instead of <code class="Code-In-Text--PACKT-">if-else</code>.</p>
    <h2 class="title" id="_idParaDest-279">The conditional or ternary operator</h2>
    <p class="normal">The conditional or ternary operator has the <code class="Code-In-Text--PACKT-">?:</code> syntax. On the left-hand side of the question mark, the operator takes a conditional statement. On the right-hand side, we provide the <a id="_idIndexMarker755"/>outcomes for true and false around the colon: <code class="Code-In-Text--PACKT-">conditional ? true-outcome : false-outcome</code>. The conditional <a id="_idIndexMarker756"/>or ternary operator is a compact way to represent <code class="Code-In-Text--PACKT-">if-else</code> conditions, and can be very useful for increasing the readability of your code base. This operator is not a replacement for an <code class="Code-In-Text--PACKT-">if-else</code> block, but it is great when you're using the output of the <code class="Code-In-Text--PACKT-">if-else</code> condition.</p>
    <p class="normal">Consider the following example:</p>
    <pre class="programlisting"><code class="hljs isbl"><strong><span class="hljs-variable">example</span></strong>
<span class="hljs-variable">const</span> <span class="hljs-variable">foo</span>: <span class="hljs-variable">string</span> = <span class="hljs-variable">undefined</span>
<span class="hljs-variable">let</span> <span class="hljs-variable"><span class="hljs-class">result</span></span> = <span class="hljs-string">''</span>
<span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-variable">foo</span>) {
  <span class="hljs-variable"><span class="hljs-class">result</span></span> = <span class="hljs-string">'truthy'</span>
} <span class="hljs-variable"><span class="hljs-keyword">else</span></span> {
  <span class="hljs-variable"><span class="hljs-class">result</span></span> = <span class="hljs-string">'falsy'</span>
}
<span class="hljs-variable">console.log</span>(<span class="hljs-variable"><span class="hljs-class">result</span></span>)</span>
</code></pre>
    <p class="normal">The preceding <code class="Code-In-Text--PACKT-">if-else</code> block can be re-written as:</p>
    <pre class="programlisting"><code class="hljs qml"><strong>example</strong>
<span class="hljs-keyword">const</span> <span class="hljs-attribute">foo</span>: <span class="hljs-built_in">string</span> = <span class="hljs-literal">undefined</span>
<span class="hljs-built_in">console</span>.log(foo ? <span class="hljs-string">'truthy'</span> : <span class="hljs-string">'falsy'</span>)
</code></pre>
    <p class="normal">In this case, the <a id="_idIndexMarker757"/>conditional or ternary operator makes <a id="_idIndexMarker758"/>the code more compact and easier to understand at a glance. Another common scenario is returning a default value, where the variable is <code class="Code-In-Text--PACKT-">falsy</code>.</p>
    <p class="normal">We will consider the null coalescing operator next.</p>
    <h2 class="title" id="_idParaDest-280">The null coalescing operator</h2>
    <p class="normal">The null coalescing operator is <code class="Code-In-Text--PACKT-">||</code>. This operator saves us from repetition, when the truthy <a id="_idIndexMarker759"/>result of the conditional is the same as the conditional itself.</p>
    <p class="normal">Consider the <a id="_idIndexMarker760"/>example where if <code class="Code-In-Text--PACKT-">foo</code> is defined, we would like to use the value of <code class="Code-In-Text--PACKT-">foo</code>, but if it is <code class="Code-In-Text--PACKT-">undefined</code>, we need a default value of <code class="Code-In-Text--PACKT-">'bar'</code>:</p>
    <pre class="programlisting"><code class="hljs qml"><strong>example</strong>
<span class="hljs-keyword">const</span> <span class="hljs-attribute">foo</span>: <span class="hljs-built_in">string</span> = <span class="hljs-literal">undefined</span>
<span class="hljs-built_in">console</span>.log(foo ? <span class="hljs-attribute">foo</span> : <span class="hljs-string">'bar'</span>)
</code></pre>
    <p class="normal">As you can see, <code class="Code-In-Text--PACKT-">foo</code> is repeated twice. We can avoid the duplication by using the null coalescing operator:</p>
    <pre class="programlisting"><code class="hljs qml"><strong>example</strong>
<span class="hljs-keyword">const</span> <span class="hljs-attribute">foo</span>: <span class="hljs-built_in">string</span> = <span class="hljs-literal">undefined</span>
<span class="hljs-built_in">console</span>.log(foo || <span class="hljs-string">'bar'</span>)
</code></pre>
    <p class="normal">So, if <code class="Code-In-Text--PACKT-">foo</code> is <code class="Code-In-Text--PACKT-">undefined</code>, <code class="Code-In-Text--PACKT-">null</code> or an empty string, <code class="Code-In-Text--PACKT-">bar</code> will be output. Otherwise, the value of <code class="Code-In-Text--PACKT-">foo</code> will be used. But in some cases, we need to only use the default value if the value is <code class="Code-In-Text--PACKT-">undefined</code> or <code class="Code-In-Text--PACKT-">null</code>. We will consider the nullish coalescing operator next.</p>
    <h2 class="title" id="_idParaDest-281">The nullish coalescing operator</h2>
    <p class="normal">The nullish <a id="_idIndexMarker761"/>coalescing operator is <code class="Code-In-Text--PACKT-">??</code>. This operator is like the null coalescing operator, with one crucial difference. Checking the <a id="_idIndexMarker762"/>truthiness of a variable is not enough when dealing with data received from an API or user input, where an empty string may be a valid value. As we covered earlier in this section, checking for <code class="Code-In-Text--PACKT-">null</code> and <code class="Code-In-Text--PACKT-">undefined</code> is not as straightforward as it seems. But we know that by using the double equals operator, we can ensure that <code class="Code-In-Text--PACKT-">foo</code> is defined and not null:</p>
    <pre class="programlisting"><code class="hljs qml"><strong>example</strong>
<span class="hljs-keyword">const</span> <span class="hljs-attribute">foo</span>: <span class="hljs-built_in">string</span> = <span class="hljs-literal">undefined</span>
<span class="hljs-built_in">console</span>.log(foo != <span class="hljs-literal">null</span> ? <span class="hljs-attribute">foo</span> : <span class="hljs-string">'bar'</span>)
</code></pre>
    <p class="normal">In the preceding case, if <code class="Code-In-Text--PACKT-">foo</code> is an empty string or another value, we will get the value of <code class="Code-In-Text--PACKT-">foo</code> output. If it is <code class="Code-In-Text--PACKT-">null</code> or <code class="Code-In-Text--PACKT-">undefined</code>, we will get <code class="Code-In-Text--PACKT-">'bar'</code>. A more compact way to do this is by <a id="_idIndexMarker763"/>using the nullish coalescing operator:</p>
    <pre class="programlisting"><code class="hljs qml"><strong>example</strong>
<span class="hljs-keyword">const</span> <span class="hljs-attribute">foo</span>: <span class="hljs-built_in">string</span> = <span class="hljs-literal">undefined</span>
<span class="hljs-built_in">console</span>.log(foo ?? <span class="hljs-string">'bar'</span>)
</code></pre>
    <p class="normal">The preceding <a id="_idIndexMarker764"/>code will yield the same result as the previous example. However, when dealing with complex objects, we need to consider whether their properties are <code class="Code-In-Text--PACKT-">null</code> or <code class="Code-In-Text--PACKT-">undefined</code> as well. For this, we will consider the optional chaining operator.</p>
    <h2 class="title" id="_idParaDest-282">Optional chaining</h2>
    <p class="normal">The optional chaining operator is <code class="Code-In-Text--PACKT-">?</code>. It is like Angular's safe navigation operator, which was covered in <em class="italics">Chapter 3</em>, <em class="italics">Creating a Basic Angular App</em>. Optional chaining ensures that a variable <a id="_idIndexMarker765"/>or property is defined and not <a id="_idIndexMarker766"/><code class="Code-In-Text--PACKT-">null</code> before attempting to access a child property or invoke a function. So the statement <code class="Code-In-Text--PACKT-">foo?.bar?.callMe()</code> executes without throwing an error, even if <code class="Code-In-Text--PACKT-">foo</code> or <code class="Code-In-Text--PACKT-">bar</code> is <code class="Code-In-Text--PACKT-">null</code> or <code class="Code-In-Text--PACKT-">undefined</code>.</p>
    <p class="normal">Consider <a id="_idIndexMarker767"/>the <strong class="bold">User</strong> entity, which has a <code class="Code-In-Text--PACKT-">name</code> object with properties for <code class="Code-In-Text--PACKT-">first</code>, <code class="Code-In-Text--PACKT-">middle</code>, and <code class="Code-In-Text--PACKT-">last</code>. Let's see what it would take to safely provide a default value of an empty string for a middle name using the nullish coalescing operator:</p>
    <pre class="programlisting"><code class="hljs routeros"><strong>example</strong>
const<span class="hljs-built_in"> user </span>= {
  name: {
    first: <span class="hljs-string">'Doguhan'</span>,
    middle: <span class="hljs-literal">null</span>,
    last: <span class="hljs-string">'Uluca'</span>
  } 
}
console.log((user &amp;&amp; user.name &amp;&amp; user.name.middle) ?? <span class="hljs-string">''</span>)
</code></pre>
    <p class="normal">As you can see, we need to check whether a parent object is truthy before accessing a child property. If <code class="Code-In-Text--PACKT-">middle</code> is <code class="Code-In-Text--PACKT-">null</code>, an empty string is output. Optional chaining makes this task simpler:</p>
    <pre class="programlisting"><code class="hljs pgsql"><strong>example</strong>
console.log(<span class="hljs-keyword">user</span>?.name?.middle ?? <span class="hljs-string">''</span>)
</code></pre>
    <p class="normal">Using optional chaining and the nullish coalescing operator together, we can eliminate repetition and deliver robust code that can effectively deal with the realities of JavaScript's dynamic runtime.</p>
    <p class="normal">So, when designing your code, you have to make decisions on whether to introduce the concept of <a id="_idIndexMarker768"/>null to your logic or work with default values like empty strings. In the next section, as we implement the User entity, you will see <a id="_idIndexMarker769"/>how these choices play out. So far, we have only used interfaces to define the shape of our data. Next, let's build the User entity, leveraging OOP concepts like classes, enums, and abstraction to implement it, along with an auth service.</p>
    <h1 class="title" id="_idParaDest-283">Reusable services leveraging OOP concepts</h1>
    <p class="normal">As mentioned, we have only worked with interfaces to represent data. We still want to continue using interfaces when passing data around various components and services. Interfaces <a id="_idIndexMarker770"/>are great for describing the kind of properties or functions an implementation has, but they suggest nothing about the behavior of these properties or functions.</p>
    <p class="normal">With ES2015 (ES6), JavaScript gained native support for classes, which is a crucial concept of the OOP paradigm. Classes are actual implementations of behavior. As opposed to just having a collection of functions in a file, a class can properly encapsulate behavior. A class can then be instantiated as an object using the new keyword.</p>
    <p class="normal">TypeScript takes the ES2015 (and beyond) implementation of classes and introduces necessary concepts like abstract classes, private, protected, and public properties, and interfaces to make it possible to implement OOP patterns.</p>
    <div class="packt_tip">
      <p>OOP is an imperative programming style, compared to the reactive programming style that RxJS enables. Classes form the bedrock of OOP, whereas observables do the same for reactive programming using RxJS.</p>
    </div>
    <p class="normal">I encourage you to become familiar with OOP terminology. Please see the <em class="italics">Further reading</em> section for some useful resources. You should become familiar with:</p>
    <ol>
      <li class="list" value="1">Classes versus objects</li>
      <li class="list">Composition (interfaces)</li>
      <li class="list">Encapsulation (private, protected, and public properties, and property getters and setters)</li>
      <li class="list" value="4">Polymorphism (inheritance, abstract classes, and method overriding)</li>
    </ol>
    <p class="normal">As you know, Angular uses OOP patterns to implement components and services. For example, interfaces are used to implement life cycle hooks such as <code class="Code-In-Text--PACKT-">OnInit</code>. Let's see how these patterns <a id="_idIndexMarker771"/>are implemented within the context of JavaScript classes.</p>
    <h2 class="title" id="_idParaDest-284">JavaScript classes</h2>
    <p class="normal">In this section, I will demonstrate how you can use classes in your own code design to define and <a id="_idIndexMarker772"/>encapsulate the behavior of your models, such as the <code class="Code-In-Text--PACKT-">User</code> class. Later in this chapter, you will see examples of class inheritance with abstract base classes, which allows us to standardize our implementation and reuse base functionality in a clean and easy-to-maintain manner.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">I must point out that OOP has very useful patterns that can increase the quality of your code; however, if you overuse it then you will start losing the benefits of the dynamic, flexible, and functional nature of JavaScript.</p>
      <p class="Information-Box--PACKT-">Sometimes all you need are a bunch of functions in a file, and you'll see examples of that throughout the book.</p>
    </div>
    <p class="normal">A great way to demonstrate the value of classes would be to standardize the creation of a default <code class="Code-In-Text--PACKT-">User</code> object. We need this because a <code class="Code-In-Text--PACKT-">BehaviorSubject</code> object needs to be initialized with a default object. It is best to do this in one place, rather than copy-paste the same implementation in multiple places. It makes a lot of sense for the <code class="Code-In-Text--PACKT-">User</code> object to own this functionality instead of an Angular service creating default <code class="Code-In-Text--PACKT-">User</code> objects. So, let's implement a <code class="Code-In-Text--PACKT-">User</code> class to achieve this goal.</p>
    <p class="normal">Let's <a id="_idIndexMarker773"/>begin by defining <a id="_idIndexMarker774"/>our interfaces and enums: </p>
    <ol>
      <li class="list" value="1">Define user roles as an <code class="Code-In-Text--PACKT-">enum</code> at the location <code class="Code-In-Text--PACKT-">src/app/auth/auth.enum.ts</code>:
        <pre class="programlisting"><code class="hljs crystal"><strong>src/app/auth/auth<span class="hljs-class">.<span class="hljs-keyword">enum</span>.<span class="hljs-title">ts</span></span></strong>
export <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Role</span> {</span>
  None = <span class="hljs-string">'none'</span>,
  Clerk = <span class="hljs-string">'clerk'</span>,
  Cashier = <span class="hljs-string">'cashier'</span>,
  Manager = <span class="hljs-string">'manager'</span>,
}
</code></pre>
      </li>
      <li class="list">Create a <code class="Code-In-Text--PACKT-">user.ts</code> file under the <code class="Code-In-Text--PACKT-">src/app/user/user</code> folder.</li>
      <li class="list">Define a new interface named <code class="Code-In-Text--PACKT-">IUser</code> in the <code class="Code-In-Text--PACKT-">user.ts</code> file:
        <pre class="programlisting"><code class="hljs typescript"><strong>src/app/user/user/user.ts</strong>
<span class="hljs-keyword">import</span> { Role } <span class="hljs-keyword">from</span> <span class="hljs-string">'../../auth/auth.enum'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> IUser {
  _id: <span class="hljs-built_in">string</span>
  email: <span class="hljs-built_in">string</span>
  name: IName
  picture: <span class="hljs-built_in">string</span>
  role: Role | <span class="hljs-built_in">string</span>
  userStatus: <span class="hljs-built_in">boolean</span>
  dateOfBirth: <span class="hljs-built_in">Date</span> | <span class="hljs-literal">null</span> | <span class="hljs-built_in">string</span>
  level: <span class="hljs-built_in">number</span>
  address: {
    line1: <span class="hljs-built_in">string</span>
    line2?: <span class="hljs-built_in">string</span>
    city: <span class="hljs-built_in">string</span>
    state: <span class="hljs-built_in">string</span>
    zip: <span class="hljs-built_in">string</span>
  }
  phones: IPhone[]
}
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">Note that <a id="_idIndexMarker775"/>every complex property that is defined on the interface can also be represented as a <code class="Code-In-Text--PACKT-">string</code>. In transit, all objects are converted to strings using <code class="Code-In-Text--PACKT-">JSON.stringify()</code>. No type information is included. We also leverage interfaces to represent <code class="Code-In-Text--PACKT-">Class</code> objects in-memory, which can have complex types. So, our interface properties must reflect both cases using union types. For example, <code class="Code-In-Text--PACKT-">role</code> can either be of type <code class="Code-In-Text--PACKT-">Role</code> or <code class="Code-In-Text--PACKT-">string</code>. Similarly, <code class="Code-In-Text--PACKT-">dateOfBirth</code> can be a <code class="Code-In-Text--PACKT-">Date</code> or a <code class="Code-In-Text--PACKT-">string</code>.</p>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">We define <code class="Code-In-Text--PACKT-">address</code> as an inline type, because we don't use the concept of an address outside of this class. In contrast, we define <code class="Code-In-Text--PACKT-">IName</code> as its own interface, because in <em class="italics">Chapter 11</em>, <em class="italics">Recipes – Reusability, Routing, and Caching</em>, we will implement a separate component for names. We also define a separate interface for phones, because they are represented as an array. When developing a form, we need to be able to address individual array elements, like <code class="Code-In-Text--PACKT-">IPhone</code>, in the template code.</p>
        <div class="packt_tip">
          <p>It is the norm to insert a capital <code class="Code-In-Text--PACKT-">I</code> in front of interface names so they are easy to identify. Don't worry, there are no compatibility issues with using the <code class="Code-In-Text--PACKT-">IPhone</code> interface on Android phones!</p>
        </div>
      </li>
      <li class="list">In <code class="Code-In-Text--PACKT-">user.ts</code>, define the <code class="Code-In-Text--PACKT-">IName</code> and <code class="Code-In-Text--PACKT-">IPhone</code> interfaces, and implement the <code class="Code-In-Text--PACKT-">PhoneType</code> enum:
        <pre class="programlisting"><code class="hljs routeros"><strong>src/app/user/user/user.ts</strong>
<span class="hljs-builtin-name">export</span><span class="hljs-built_in"> interface </span>IName {
  first: string
  middle?: string
  last: string
}
<span class="hljs-builtin-name">export</span> enum PhoneType {
  None = <span class="hljs-string">'none'</span>,
  Mobile = <span class="hljs-string">'mobile'</span>,
  Home = <span class="hljs-string">'home'</span>,
  Work = <span class="hljs-string">'work'</span>,
}
<span class="hljs-builtin-name">export</span><span class="hljs-built_in"> interface </span>IPhone {
  type: PhoneType
  digits: string
  id: number
}
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">Note that in the <code class="Code-In-Text--PACKT-">PhoneType</code> enum, we explicitly defined <code class="Code-In-Text--PACKT-">string</code> values. By default, <code class="Code-In-Text--PACKT-">enum</code> values are converted into strings as they're typed, which can lead to issues with values stored in a database falling out of sync with how a developer chooses to spell a variable name. With explicit and all lowercase values, we reduce the risk of bugs.</p>
      </li>
      <li class="list">Finally, define <a id="_idIndexMarker776"/>the <code class="Code-In-Text--PACKT-">User</code> class, which implements the <code class="Code-In-Text--PACKT-">IUser</code> interface:
        <pre class="programlisting"><code class="hljs pgsql"><strong>src/app/<span class="hljs-keyword">user</span>/<span class="hljs-keyword">user</span>/<span class="hljs-keyword">user</span>.ts</strong>
export <span class="hljs-keyword">class</span> <span class="hljs-keyword">User</span> implements IUser {
  constructor(
    // tslint:<span class="hljs-keyword">disable</span>-next-<span class="hljs-type">line</span>: variable-<span class="hljs-type">name</span>
    <span class="hljs-built_in">public</span> _id = <span class="hljs-string">''</span>,
    <span class="hljs-built_in">public</span> email = <span class="hljs-string">''</span>,
    <span class="hljs-built_in">public</span> <span class="hljs-type">name</span> = { first: <span class="hljs-string">''</span>, middle: <span class="hljs-string">''</span>, last: <span class="hljs-string">''</span> } <span class="hljs-keyword">as</span> IName,
    <span class="hljs-built_in">public</span> picture = <span class="hljs-string">''</span>,
    <span class="hljs-built_in">public</span> <span class="hljs-keyword">role</span> = <span class="hljs-keyword">Role</span>.<span class="hljs-keyword">None</span>,
    <span class="hljs-built_in">public</span> dateOfBirth: <span class="hljs-type">Date</span> | <span class="hljs-keyword">null</span> = <span class="hljs-keyword">null</span>,
    <span class="hljs-built_in">public</span> userStatus = <span class="hljs-keyword">false</span>,
    <span class="hljs-built_in">public</span> <span class="hljs-keyword">level</span> = <span class="hljs-number">0</span>,
    <span class="hljs-built_in">public</span> address = {
      line1: <span class="hljs-string">''</span>,
      city: <span class="hljs-string">''</span>,
      state: <span class="hljs-string">''</span>,
      zip: <span class="hljs-string">''</span>,
    },
    <span class="hljs-built_in">public</span> phones: IPhone[] = []
  ) {}
  static Build(<span class="hljs-keyword">user</span>: IUser) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">user</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> <span class="hljs-keyword">User</span>()
    }
    <span class="hljs-keyword">if</span> (typeof <span class="hljs-keyword">user</span>.dateOfBirth === <span class="hljs-string">'string'</span>) {
      <span class="hljs-keyword">user</span>.dateOfBirth = <span class="hljs-built_in">new</span> <span class="hljs-type">Date</span>(<span class="hljs-keyword">user</span>.dateOfBirth)
    }
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> <span class="hljs-keyword">User</span>(
      <span class="hljs-keyword">user</span>._id,
      <span class="hljs-keyword">user</span>.email,
      <span class="hljs-keyword">user</span>.name,
      <span class="hljs-keyword">user</span>.picture,
      <span class="hljs-keyword">user</span>.<span class="hljs-keyword">role</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">Role</span>,
      <span class="hljs-keyword">user</span>.dateOfBirth,
      <span class="hljs-keyword">user</span>.userStatus,
      <span class="hljs-keyword">user</span>.<span class="hljs-keyword">level</span>,
      <span class="hljs-keyword">user</span>.address,
      <span class="hljs-keyword">user</span>.phones
    )
  }
}
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">Note that by <a id="_idIndexMarker777"/>defining all properties with default values in the constructors as <code class="Code-In-Text--PACKT-">public</code> properties, we hit two birds with one stone; otherwise, we would need to define properties and initialize them separately. This way, we achieve a concise implementation.</p>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">Using a static <code class="Code-In-Text--PACKT-">Build</code> function, we can quickly hydrate the object with data received from the server. We can also implement the <code class="Code-In-Text--PACKT-">toJSON()</code> function to customize the serialization behavior of our object before sending the data up to the server. But before that, let's add a calculated property.</p>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">We can use calculated properties in templates or in toast messages to conveniently display values assembled from multiple parts. A great example is extracting a full name from the <code class="Code-In-Text--PACKT-">name</code> object as a property in the <code class="Code-In-Text--PACKT-">User</code> class. </p>
        <div class="packt_tip">
          <p>A calculated property for assembling a full name encapsulates the logic for combining a first, middle, and last name, so you don't have to rewrite this logic in multiple places, adhering to the DRY principle!</p>
        </div>
      </li>
      <li class="list">Implement <a id="_idIndexMarker778"/>a <code class="Code-In-Text--PACKT-">fullName</code> property getter in the <code class="Code-In-Text--PACKT-">User </code>class:
        <pre class="programlisting"><code class="hljs kotlin"><strong>src/app/user/user/user.ts</strong>
export <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-title">implements</span> <span class="hljs-title">IUser</span> </span>{
  ...
  <strong><span class="hljs-keyword">public</span> <span class="hljs-keyword">get</span> fullName(): string {</strong>
<strong>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.name) {</strong>
<strong>      <span class="hljs-keyword">return</span> <span class="hljs-string">''</span></strong>
<strong>    }</strong>
<strong>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.name.middle) {</strong>
<strong>      <span class="hljs-keyword">return</span> `${<span class="hljs-keyword">this</span>.name.first} ${<span class="hljs-keyword">this</span>.name.middle} ${<span class="hljs-keyword">this</span>.name.last}`</strong>
<strong>    }</strong>
<strong>    <span class="hljs-keyword">return</span> `${<span class="hljs-keyword">this</span>.name.first} ${<span class="hljs-keyword">this</span>.name.last}`</strong>
<strong>  }</strong>
}
</code></pre>
      </li>
      <li class="list">Add <code class="Code-In-Text--PACKT-">fullName</code> <code class="Code-In-Text--PACKT-">IUser</code> as <code class="Code-In-Text--PACKT-">readonly</code> and an optional property:
        <pre class="programlisting"><code class="hljs routeros"><strong>src/app/user/user/user.ts</strong>
<span class="hljs-builtin-name">export</span><span class="hljs-built_in"> interface </span>IUser {
  <span class="hljs-built_in">..</span>.
  readonly fullName?: string
}
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">You can now use the <code class="Code-In-Text--PACKT-">fullName</code> property through the <code class="Code-In-Text--PACKT-">IUser</code> interface.</p>
      </li>
      <li class="list" value="8">Implement the <code class="Code-In-Text--PACKT-">toJSON</code> function:
        <pre class="programlisting"><code class="hljs routeros"><strong>src/app/user/user/user.ts</strong>
<span class="hljs-builtin-name">export</span> class<span class="hljs-built_in"> User </span>implements IUser {
  <span class="hljs-built_in">..</span>.
  
<strong>toJSON(): object {</strong>
<strong>    const serialized = Object.assign(this)</strong>
<strong>    delete serialized._id</strong>
<strong>    delete serialized.fullName</strong>
<strong>    return serialized</strong>
<strong>  }</strong>
}
</code></pre>
      </li>
    </ol>
    <p class="normal">Note that when <a id="_idIndexMarker779"/>serializing the object, we delete the <code class="Code-In-Text--PACKT-">_id</code> and <code class="Code-In-Text--PACKT-">fullName</code> fields. These are values that we don't want to be stored in the database. The <code class="Code-In-Text--PACKT-">fullName</code> field is a calculated property, so it doesn't need to be stored. The <code class="Code-In-Text--PACKT-">_id</code> is normally passed as a parameter in a <code class="Code-In-Text--PACKT-">GET</code> or a <code class="Code-In-Text--PACKT-">PUT</code> call to locate the record. This avoids mistakes that may result in overwriting the <code class="Code-In-Text--PACKT-">id</code> fields of existing objects.</p>
    <p class="normal">Now that we have the <code class="Code-In-Text--PACKT-">User data</code> entity implemented, next let's implement the auth service.</p>
    <h2 class="title" id="_idParaDest-285">Abstraction and inheritance</h2>
    <p class="normal">We aim to design <a id="_idIndexMarker780"/>a flexible auth service that can implement multiple auth providers. In this chapter, we will implement an in-memory provider and a Google Firebase provider. In <em class="italics">Chapter 10</em>, <em class="italics">RESTful APIs and Full-Stack Implementation</em>, we will implement a <a id="_idIndexMarker781"/>custom provider to interact with our backend. </p>
    <p class="normal">By declaring an abstract base class, we can describe the common login and logout behavior of our application, so when we implement another auth provider, we don't have to re-engineer our application.</p>
    <p class="normal">In addition, we can declare abstract functions, which the implementors of our base class would have to implement, enforcing our design. Any class that implements the base class would also get the benefit of the code implemented in the base class, so we wouldn't need to repeat the same logic in two different places.</p>
    <p class="normal">The following class diagram reflects the architecture and inheritance hierarchy of our abstract <code class="Code-In-Text--PACKT-">AuthService</code>:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_08_03.png"/></figure>
    <p class="packt_figref">Figure 8.3: The AuthService inheritance structure</p>
    <p class="normal"><code class="Code-In-Text--PACKT-">AuthService</code> implements <a id="_idIndexMarker782"/>the <a id="_idIndexMarker783"/>interface <code class="Code-In-Text--PACKT-">IAuthService</code>, as shown:</p>
    <pre class="programlisting"><code class="hljs routeros"><span class="hljs-builtin-name">export</span><span class="hljs-built_in"> interface </span>IAuthService {
  readonly authStatus$: BehaviorSubject&lt;IAuthStatus&gt;
  readonly currentUser$: BehaviorSubject&lt;IUser&gt;
  login(email: string, password: string): Observable&lt;void&gt;
  logout(clearToken?: boolean): void
  getToken(): string
}
</code></pre>
    <p class="normal">The interface reflects the public properties that the service exposes. The service provides the authentication status as the <code class="Code-In-Text--PACKT-">authStatus$</code> observable and the current user as <code class="Code-In-Text--PACKT-">currentUser$</code>, and it provides three functions to <code class="Code-In-Text--PACKT-">login</code>, <code class="Code-In-Text--PACKT-">logout</code>, and <code class="Code-In-Text--PACKT-">getToken</code>.</p>
    <p class="normal"><code class="Code-In-Text--PACKT-">AuthService</code> inherits caching functionality from another abstract class called <code class="Code-In-Text--PACKT-">CacheService</code>. Since <code class="Code-In-Text--PACKT-">AuthService</code> is an abstract class, it can't be used on its own, so we implement three auth providers, <code class="Code-In-Text--PACKT-">InMemoryAuthService</code>, <code class="Code-In-Text--PACKT-">FirebaseAuthService</code>, and <code class="Code-In-Text--PACKT-">CustomAuthService</code>, as seen at the bottom of the diagram.</p>
    <p class="normal">Note that all <a id="_idIndexMarker784"/>three auth services implement all abstract functions. In addition, the <code class="Code-In-Text--PACKT-">FirebaseAuthService</code> overrides the base <code class="Code-In-Text--PACKT-">logout</code> function to implement its own behavior. All three <a id="_idIndexMarker785"/>classes inherit from the same abstract class and expose the same public interface. All three will execute the same auth workflow against different auth servers.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">The in-memory auth service doesn't communicate with a server. The service is for demonstration purposes only. It implements fake JWT encoding, so we can demonstrate how the JWT life cycle works.</p>
    </div>
    <p class="normal">Let's start by creating the auth service. </p>
    <h3 class="title" id="_idParaDest-286">Create the auth service</h3>
    <p class="normal">We will start by <a id="_idIndexMarker786"/>creating the abstract auth service and the in-memory service:</p>
    <ol>
      <li class="list" value="1">Add an auth service:
        <pre class="programlisting"><code class="hljs jboss-cli">$ npx ng g s auth <span class="hljs-params">--flat</span> <span class="hljs-literal">false</span> <span class="hljs-params">--lintFix</span> 
$ npx ng g s auth/inMemoryAuth <span class="hljs-params">--lintFix</span> <span class="hljs-params">--skipTests</span>
</code></pre>
      </li>
      <li class="list">Rename <code class="Code-In-Text--PACKT-">in-memory-auth.service.ts</code> to <code class="Code-In-Text--PACKT-">auth.inmemory.service.ts</code> so the different auth providers visually group together in File Explorer.</li>
      <li class="list">Remove the config object <code class="Code-In-Text--PACKT-">{ providedIn: 'root' }</code> from the <code class="Code-In-Text--PACKT-">@Injectable()</code> decorator of <code class="Code-In-Text--PACKT-">auth.service.ts</code> and <code class="Code-In-Text--PACKT-">auth.inmemory.service.ts</code>.</li>
      <li class="list" value="4">Ensure that <code class="Code-In-Text--PACKT-">authService</code> is provided in <code class="Code-In-Text--PACKT-">app.module.ts</code>, but the <code class="Code-In-Text--PACKT-">InMemoryAuthService</code> is actually used and not the abstract class:
        <pre class="programlisting"><code class="hljs clean"><strong>src/app/app.<span class="hljs-keyword">module</span>.ts</strong>
<strong><span class="hljs-keyword">import</span> { AuthService } <span class="hljs-keyword">from</span> <span class="hljs-string">'./auth/auth.service'</span></strong>
<strong><span class="hljs-keyword">import</span> { InMemoryAuthService } <span class="hljs-keyword">from</span> <span class="hljs-string">'./auth/auth.inmemory.service'</span></strong>
...
  providers: [
    <strong>{</strong>
<strong>      provide: AuthService,</strong>
<strong>      useClass: InMemoryAuthService</strong>
<strong>    },</strong>
    ...
]
</code></pre>
      </li>
    </ol>
    <p class="normal">Creating a <a id="_idIndexMarker787"/>separate folder for the service organizes various components related to auth, such as the <code class="Code-In-Text--PACKT-">enum</code> definition for the user role. Additionally, we will be able to add an <code class="Code-In-Text--PACKT-">authService</code> fake to the same folder for automated testing.</p>
    <h3 class="title" id="_idParaDest-287">Implement an abstract auth service</h3>
    <p class="normal">Now, let's build an abstract auth service that will orchestrate logins and logouts, while encapsulating <a id="_idIndexMarker788"/>the logic of how to manage JWTs, auth status, and information regarding the current user. By leveraging the abstract class, we should be able to implement our own auth service against any auth provider without modifying the internal behavior of our application.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">The abstract auth service that is being demonstrated enables rich and intricate workflows. It is a solution that you can drop into your applications without modifying the internal logic. As a result, it is a complicated solution.</p>
    </div>
    <p class="normal">This auth service will enable us to demonstrate logging in with an email and password, caching, and conditional navigation concepts based on authentication status and a user's role:</p>
    <ol>
      <li class="list" value="1">Start by installing a JWT decoding library, and, for faking authentication, a JWT encoding library:
        <pre class="programlisting"><code class="hljs sql">$ npm <span class="hljs-keyword">install</span> jwt-<span class="hljs-keyword">decode</span> 
$ npm <span class="hljs-keyword">install</span> -D @types/jwt-<span class="hljs-keyword">decode</span>
</code></pre>
      </li>
      <li class="list">Implement an <code class="Code-In-Text--PACKT-">IAuthStatus</code> interface to store decoded user information, a helper interface, and the secure by default <code class="Code-In-Text--PACKT-">defaultAuthStatus</code>:
        <pre class="programlisting"><code class="hljs routeros"><strong>src/app/auth/auth.service.ts</strong>
import { Role } <span class="hljs-keyword">from</span> <span class="hljs-string">'./auth.enum'</span>
<span class="hljs-built_in">..</span>.
<span class="hljs-builtin-name">export</span><span class="hljs-built_in"> interface </span>IAuthStatus {
  isAuthenticated: boolean
  userRole: Role
  userId: string
}
<span class="hljs-builtin-name">export</span><span class="hljs-built_in"> interface </span>IServerAuthResponse {
  accessToken: string
}
<span class="hljs-builtin-name">export</span> const defaultAuthStatus: IAuthStatus = {
  isAuthenticated: <span class="hljs-literal">false</span>,
  userRole: Role.None,
  userId: <span class="hljs-string">''</span>,
}
<span class="hljs-built_in">..</span>.
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-"><code class="Code-In-Text--PACKT-">IAuthStatus</code> is an interface that represents the shape of a typical JWT that you may receive from your authentication service. It contains minimal information about the user and the user's role. The auth status object can be attached to the header of every REST call to APIs to verify the user's identity. The auth status can be optionally cached in <code class="Code-In-Text--PACKT-">localStorage</code> to remember the user's login state; otherwise, they would have to re-enter their password with every page refresh.</p>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">In the preceding implementation, we're assuming the default role of <code class="Code-In-Text--PACKT-">None</code>, as defined in the <code class="Code-In-Text--PACKT-">Role</code> enum. By not giving any role to the user by default, we're following a least-privileged access model. The user's correct role will be set after they log in successfully with the information received from the auth API.</p>
      </li>
      <li class="list">Define <a id="_idIndexMarker789"/>the <code class="Code-In-Text--PACKT-">IAuthService</code> interface in <code class="Code-In-Text--PACKT-">auth.service.ts</code>:
        <pre class="programlisting"><code class="hljs routeros"><strong>src/app/auth/auth.service.ts</strong>
<span class="hljs-builtin-name">export</span><span class="hljs-built_in"> interface </span>IAuthService {
  readonly authStatus$: BehaviorSubject&lt;IAuthStatus&gt;
  readonly currentUser$: BehaviorSubject&lt;IUser&gt;
  login(email: string, password: string): Observable&lt;void&gt;
  logout(clearToken?: boolean): void
  getToken(): string
}
</code></pre>
      </li>
      <li class="list">Make <code class="Code-In-Text--PACKT-">AuthService</code> an <code class="Code-In-Text--PACKT-">abstract</code> class, as shown:
        <pre class="programlisting"><code class="hljs coffeescript"><span class="hljs-keyword">export</span> <strong>abstract</strong> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthService</span></span>
</code></pre>
      </li>
      <li class="list">Implement the interface, <code class="Code-In-Text--PACKT-">IAuthService</code>, using VS Code's quick fix functionality:
        <pre class="programlisting"><code class="hljs typescript"><strong>src/app/auth/auth.service.ts</strong>
<span class="hljs-meta">@Injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> AuthService <strong><span class="hljs-keyword">implements</span> IAuthService</strong> {
  authStatus$: BehaviorSubject&lt;IAuthStatus&gt;
  currentUser$: BehaviorSubject&lt;IUser&gt;
  
  <strong><span class="hljs-keyword">constructor</span>(<span class="hljs-params"/>) {}</strong>
  
  login(email: <span class="hljs-built_in">string</span>, password: <span class="hljs-built_in">string</span>): Observable&lt;<span class="hljs-built_in">void</span>&gt; {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Method not implemented.'</span>)
  }
  logout(clearToken?: <span class="hljs-built_in">boolean</span>): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Method not implemented.'</span>)
  }
  getToken(): <span class="hljs-built_in">string</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Method not implemented.'</span>)
  }
}
</code></pre>
      </li>
      <li class="list" value="6">Implement <a id="_idIndexMarker790"/>the <code class="Code-In-Text--PACKT-">authStatus$</code> and <code class="Code-In-Text--PACKT-">currentUser$</code> properties as <code class="Code-In-Text--PACKT-">readonly</code> and initialize our data anchors with their default values:
        <pre class="programlisting"><code class="hljs dart"><strong>src/app/auth/auth.service.ts</strong>
<span class="hljs-keyword">import</span> { IUser, <strong>User</strong> } from <span class="hljs-string">'../user/user/user'</span>
...
<span class="hljs-meta">@Injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IAuthService</span> </span>{
  <strong>readonly</strong> authStatus$ = 
    <strong><span class="hljs-keyword">new</span> BehaviorSubject&lt;IAuthStatus&gt;(defaultAuthStatus)  </strong>
  <strong>readonly</strong> currentUser$ = 
    <strong><span class="hljs-keyword">new</span> BehaviorSubject&lt;IUser&gt;(<span class="hljs-keyword">new</span> User())</strong>
  ...
}
</code></pre>
      </li>
    </ol>
    <div class="note">
      <p class="Information-Box--PACKT-">Note that we removed the type definitions of the properties. Instead, we're letting TypeScript infer the type from the initialization.</p>
    </div>
    <div class="packt_tip">
      <p>You must always declare your data anchors as <code class="Code-In-Text--PACKT-">readonly</code>, so you don't accidentally overwrite the data stream by re-initializing a data anchor as a new <code class="Code-In-Text--PACKT-">BehaviorSubject</code>. Doing so would render any prior subscribers orphaned, leading to memory leaks, and have many unintended consequences.</p>
    </div>
    <p class="normal">All implementors of <code class="Code-In-Text--PACKT-">IAuthService</code> need to be able to log the user in, transform the token we get back from the server so we can read it and store it, support access to the current user, and the auth status, and provide a way to log the user out. We have successfully <a id="_idIndexMarker791"/>put in the functions for our public methods and implemented default values for our data anchors to create hooks for the rest of our application to use. But so far, we have only defined what our service can do, and not how it can do it.</p>
    <p class="normal">As always, the devil is in the details, and the hard part is the "how." Abstract functions can help us to complete the implementation of a workflow in a service within our application, while leaving the portions of the service that must implement external APIs undefined.</p>
    <h3 class="title" id="_idParaDest-288">Abstract functions</h3>
    <p class="normal">Auth services that implement the abstract class should be able to support any kind of auth provider, and any kind of token transformation, while being able to modify behaviors like user retrieval logic. We must be able to implement login, logout, token, and auth status management without implementing calls to specific services.</p>
    <p class="normal">By defining <a id="_idIndexMarker792"/>abstract functions, we can declare a series of methods that must implement a given set of inputs and outputs—a signature without an implementation. We can then use these abstract functions to orchestrate the implementation of our auth workflow.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">Our design goal here is driven by the Open/Closed principle. The <code class="Code-In-Text--PACKT-">AuthService</code> will be open to extension through its ability to be extended to work with any kind of token-based auth provider, but closed to modification. Once we're done implementing the <code class="Code-In-Text--PACKT-">AuthService</code>, we won't need to modify its code to add additional auth providers.</p>
    </div>
    <p class="normal">Now we need to define the abstract functions that our auth providers must implement, as shown in <em class="italics">Figure 8.3</em> from earlier in the chapter:</p>
    <ul>
      <li class="list"><code class="Code-In-Text--PACKT-">authProvider(email, password)</code>: <code class="Code-In-Text--PACKT-">Observable&lt;IServerAuthResponse&gt;</code> can log us in via a provider and return a standardized <code class="Code-In-Text--PACKT-">IServerAuthResponse</code></li>
      <li class="list"><code class="Code-In-Text--PACKT-">transformJwtToken(token)</code>: <code class="Code-In-Text--PACKT-">IAuthStatus</code> can normalize the token a provider returns to the interface of <code class="Code-In-Text--PACKT-">IAuthStatus</code></li>
      <li class="list"><code class="Code-In-Text--PACKT-">getCurrentUser()</code>: <code class="Code-In-Text--PACKT-">Observable&lt;User&gt;</code> can retrieve the user profile of the logged-in user</li>
    </ul>
    <p class="normal">We can <a id="_idIndexMarker793"/>then use these functions in our <code class="Code-In-Text--PACKT-">login</code>, <code class="Code-In-Text--PACKT-">logout</code>, and <code class="Code-In-Text--PACKT-">getToken</code> methods to implement the auth workflow: </p>
    <ol>
      <li class="list" value="1">Define the abstract methods that the derived classes should implement as protected properties, so they're accessible in the derived class, but not publicly:
        <pre class="programlisting"><code class="hljs groovy"><strong>src<span class="hljs-regexp">/app/</span>auth/auth.service.ts</strong>
...
<strong>export <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IAuthService</span> {</span></strong>
<strong>     <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> authProvider(</strong>
<strong><span class="hljs-symbol">       email:</span> string,</strong>
<strong><span class="hljs-symbol">       password:</span> string</strong>
<strong>     ): Observable&lt;IServerAuthResponse&gt;</strong>
<strong>     <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> transformJwtToken(<span class="hljs-string">token:</span> unknown):</strong>
<strong>       IAuthStatus</strong>
<strong>     <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> getCurrentUser(): Observable&lt;User&gt;</strong>
     ...
}
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">Leveraging these stubbed out methods, we can now implement a <code class="Code-In-Text--PACKT-">login</code> method that performs a login and retrieves the currently logged-in user, making sure to update the <code class="Code-In-Text--PACKT-">authStatus$</code> and <code class="Code-In-Text--PACKT-">currentUser$</code> data streams.</p>
      </li>
      <li class="list">Before we move on, implement a <code class="Code-In-Text--PACKT-">transformError</code> function to handle errors of different types like <code class="Code-In-Text--PACKT-">HttpErrorResponse</code> and <code class="Code-In-Text--PACKT-">string</code>, providing them in an observable stream. In a new file named <code class="Code-In-Text--PACKT-">common.ts</code> under <code class="Code-In-Text--PACKT-">src/app/common</code> create the <code class="Code-In-Text--PACKT-">transformError</code> function:
        <pre class="programlisting"><code class="hljs aspectj"><strong>src/app/common/common.ts</strong>
<span class="hljs-keyword">import</span> { HttpErrorResponse } from <span class="hljs-string">'@angular/common/http'</span>
<span class="hljs-keyword">import</span> { throwError } from <span class="hljs-string">'rxjs'</span>
export <span class="hljs-function">function <span class="hljs-title">transformError</span><span class="hljs-params">(<span class="hljs-keyword">error</span>: HttpErrorResponse | string)</span> </span>{
  let errorMessage = <span class="hljs-string">'An unknown error has occurred'</span>
  <span class="hljs-keyword">if</span> (typeof <span class="hljs-keyword">error</span> === <span class="hljs-string">'string'</span>) {
    errorMessage = <span class="hljs-keyword">error</span>
  } <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(<span class="hljs-keyword">error</span>.<span class="hljs-keyword">error</span> <span class="hljs-keyword">instanceof</span> ErrorEvent)</span> </span>{
    errorMessage = `Error! ${<span class="hljs-keyword">error</span>.<span class="hljs-keyword">error</span>.message}`
  } <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(<span class="hljs-keyword">error</span>.status)</span> </span>{
    errorMessage = 
      `Request failed with ${<span class="hljs-keyword">error</span>.status} ${<span class="hljs-keyword">error</span>.statusText}`
  } <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(<span class="hljs-keyword">error</span> <span class="hljs-keyword">instanceof</span> Error)</span> </span>{
    errorMessage = <span class="hljs-keyword">error</span>.message
  }
  <span class="hljs-keyword">return</span> throwError(errorMessage)
}
</code></pre>
      </li>
      <li class="list">In <code class="Code-In-Text--PACKT-">auth.service.ts</code>, implement <a id="_idIndexMarker794"/>the <code class="Code-In-Text--PACKT-">login</code> method:
        <pre class="programlisting"><code class="hljs typescript"><strong>src/app/auth/auth.service.ts</strong>
<strong><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> decode <span class="hljs-keyword">from</span> <span class="hljs-string">'jwt-decode'</span></strong>
<strong><span class="hljs-keyword">import</span> { transformError } <span class="hljs-keyword">from</span> <span class="hljs-string">'../common/common'</span></strong>
...
  login(email: <span class="hljs-built_in">string</span>, password: <span class="hljs-built_in">string</span>): Observable&lt;<span class="hljs-built_in">void</span>&gt; {
    <strong><span class="hljs-keyword">const</span> loginResponse$ = <span class="hljs-keyword">this</span>.authProvider(email, password)</strong>
<strong>      .pipe(</strong>
<strong>        map(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> {</strong>
<strong>          <span class="hljs-keyword">const</span> token = decode(value.accessToken)</strong>
<strong>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.transformJwtToken(token)</strong>
<strong>        }),</strong>
<strong>        tap(<span class="hljs-function">(<span class="hljs-params">status</span>) =&gt;</span> <span class="hljs-keyword">this</span>.authStatus$.next(status)),</strong>
<strong>        filter(<span class="hljs-function">(<span class="hljs-params">status: IAuthStatus</span>) =&gt;</span> status.isAuthenticated),</strong>
<strong>        flatMap(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.getCurrentUser()),</strong>
<strong>        map(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> <span class="hljs-keyword">this</span>.currentUser$.next(user)),</strong>
<strong>        catchError(transformError)</strong>
<strong>      )</strong>
<strong>    loginResponse$.subscribe({</strong>
<strong>      error: <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {</strong>
<strong>        <span class="hljs-keyword">this</span>.logout()</strong>
<strong>        <span class="hljs-keyword">return</span> throwError(err)</strong>
<strong>      },</strong>
<strong>    })</strong>
<strong>    <span class="hljs-keyword">return</span> loginResponse$</strong>
  }
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">The <code class="Code-In-Text--PACKT-">login</code> method encapsulates the correct order of operations by calling the <code class="Code-In-Text--PACKT-">authProvider</code> with the <code class="Code-In-Text--PACKT-">email</code> and <code class="Code-In-Text--PACKT-">password</code> information, then decoding the received JWT, transforming it, and updating <code class="Code-In-Text--PACKT-">authStatus$</code>. Then <code class="Code-In-Text--PACKT-">getCurrentUser()</code> is called only if <code class="Code-In-Text--PACKT-">status.isAuthenticated</code> is <code class="Code-In-Text--PACKT-">true</code>. Later, <code class="Code-In-Text--PACKT-">currentUser$</code> is updated and, finally, we catch any errors using our custom <code class="Code-In-Text--PACKT-">transformError</code> function.</p>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">We activate the observable stream by calling <code class="Code-In-Text--PACKT-">subscribe</code> on it. In the case of an error, we call <code class="Code-In-Text--PACKT-">logout()</code> to maintain the correct status of our application and bubble up errors to consumers of <code class="Code-In-Text--PACKT-">login</code> by re-throwing the error using <code class="Code-In-Text--PACKT-">throwError</code>.</p>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">Now, the corresponding <code class="Code-In-Text--PACKT-">logout</code> function needs to be implemented. Logout is triggered by the <strong class="screen-text">Logout</strong> button from the application toolbar in the case of a failed login attempt, as shown earlier, or if an unauthorized access attempt is detected. We can detect unauthorized access attempts by using a router auth guard as the user is navigating the application, which is a topic covered later in the chapter.</p>
      </li>
      <li class="list" value="4">Implement the <code class="Code-In-Text--PACKT-">logout</code> method:
        <pre class="programlisting"><code class="hljs typescript"><strong>src/app/auth/auth.service.ts</strong>
  ...
  logout(clearToken?: <span class="hljs-built_in">boolean</span>): <span class="hljs-built_in">void</span> {
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.authStatus$.next(defaultAuthStatus), <span class="hljs-number">0</span>)
  }
</code></pre>
      </li>
    </ol>
    <p class="normal">We log out <a id="_idIndexMarker795"/>by pushing out the <code class="Code-In-Text--PACKT-">defaultAuthStatus</code> as the next value in the <code class="Code-In-Text--PACKT-">authStatus$</code> stream. Note the use of <code class="Code-In-Text--PACKT-">setTimeout</code>, which allows us to avoid timing issues when core elements of the application are all changing statuses at once.</p>
    <div class="packt_tip">
      <p>Think about how the <code class="Code-In-Text--PACKT-">login</code> method adheres to the Open/Closed principle. The method is open to extension through the abstract functions <code class="Code-In-Text--PACKT-">authProvider</code>, <code class="Code-In-Text--PACKT-">transformJwtToken</code>, and <code class="Code-In-Text--PACKT-">getCurrentUser</code>. By implementing these functions in a derived class, we maintain the ability to externally supply different auth providers without having to modify the <code class="Code-In-Text--PACKT-">login</code> method. As a result, the implementation of the method remains closed to modification, thus adhering to the Open/Closed principle.</p>
    </div>
    <div class="note">
      <p class="Information-Box--PACKT-">The true value of creating abstract classes is the ability to encapsulate common functionality in an extensible way.</p>
    </div>
    <p class="normal">You may <a id="_idIndexMarker796"/>ignore the <code class="Code-In-Text--PACKT-">getToken</code> function for now, as we are not yet caching our JWT. Without caching, the user would have to log in with every page refresh. Let's implement caching next.</p>
    <h3 class="title" id="_idParaDest-289">Abstract caching service using localStorage</h3>
    <p class="normal">We must <a id="_idIndexMarker797"/>be able to cache the authentication <a id="_idIndexMarker798"/>status of the logged-in user. As mentioned, otherwise, with every page refresh, the user will have to go through the login routine. We need to update <code class="Code-In-Text--PACKT-">AuthService</code> so that it persists the auth status.</p>
    <p class="normal">There are three main ways to store data:</p>
    <ul>
      <li class="list"><code class="Code-In-Text--PACKT-">cookie</code></li>
      <li class="list"><code class="Code-In-Text--PACKT-">localStorage</code></li>
      <li class="list"><code class="Code-In-Text--PACKT-">sessionStorage</code></li>
    </ul>
    <p class="normal">Cookies should <a id="_idIndexMarker799"/>not be used to store secure data because they can be sniffed <a id="_idIndexMarker800"/>or stolen by bad actors. In addition, cookies can store only 4 KB of data and can be set to expire.</p>
    <p class="normal"><code class="Code-In-Text--PACKT-">localStorage</code> and <code class="Code-In-Text--PACKT-">sessionStorage</code> are similar <a id="_idIndexMarker801"/>to each other. They are protected and isolated browser-side stores that allow the storage of larger amounts of data for your application. Unlike cookies, you can't set an expiration date-time on values stored in either store. Values stored in either store survive page reloads and restores, making them better candidates than cookies for caching information. </p>
    <p class="normal">The major difference between <code class="Code-In-Text--PACKT-">localStorage</code> and <code class="Code-In-Text--PACKT-">sessionStorage</code> is that the values are removed when the browser window is closed. In most cases, user logins are cached anywhere from minutes to a month or more depending on your business, so relying on whether the user closes the browser window isn't very useful. Through this process of elimination, I prefer <code class="Code-In-Text--PACKT-">localStorage</code> because of the isolation it provides and long-term storage capabilities.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">JWTs can be encrypted and include a timestamp for expiration. In theory, this counters the weaknesses of both cookies and <code class="Code-In-Text--PACKT-">localStorage</code>. If implemented correctly, either option should be secure for use with JWTs, but <code class="Code-In-Text--PACKT-">localStorage</code> is still preferred.</p>
    </div>
    <p class="normal">Let's start <a id="_idIndexMarker802"/>by implementing a caching service that can abstract away our method of caching. We can then derive from this service <a id="_idIndexMarker803"/>to cache our authentication information:</p>
    <ol>
      <li class="list" value="1">Start by creating an abstract <code class="Code-In-Text--PACKT-">cacheService</code> that encapsulates the method of caching:
        <pre class="programlisting"><code class="hljs sql"><strong>src/app/auth/cache.service.ts</strong>
<span class="hljs-keyword">export</span> abstract <span class="hljs-keyword">class</span> CacheService {
  protected getItem&lt;T&gt;(<span class="hljs-keyword">key</span>: <span class="hljs-keyword">string</span>): T | <span class="hljs-literal">null</span> {
    const <span class="hljs-keyword">data</span> = localStorage.getItem(<span class="hljs-keyword">key</span>)
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">data</span> != <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">return</span> JSON.parse(<span class="hljs-keyword">data</span>)
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
  }
  protected setItem(<span class="hljs-keyword">key</span>: <span class="hljs-keyword">string</span>, <span class="hljs-keyword">data</span>: <span class="hljs-keyword">object</span> | <span class="hljs-keyword">string</span>) {
    <span class="hljs-keyword">if</span> (typeof <span class="hljs-keyword">data</span> === <span class="hljs-string">'string'</span>) {
      localStorage.setItem(<span class="hljs-keyword">key</span>, <span class="hljs-keyword">data</span>)
    }
    localStorage.setItem(<span class="hljs-keyword">key</span>, JSON.stringify(<span class="hljs-keyword">data</span>))
  }
  protected removeItem(<span class="hljs-keyword">key</span>: <span class="hljs-keyword">string</span>) {
    localStorage.removeItem(<span class="hljs-keyword">key</span>)
  }
  protected <span class="hljs-keyword">clear</span>() {
    localStorage.clear()
  }
}
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">This cache service base class can be used to give caching capabilities to any service. It is not the same as creating a centralized cache service that you inject into another service. By avoiding a centralized value store, we avoid interdependencies between various services.</p>
      </li>
      <li class="list" value="2">Update <code class="Code-In-Text--PACKT-">AuthService</code> to extend the <code class="Code-In-Text--PACKT-">CacheService</code>, which will enable us to implement caching of the JWT in the next section:
        <pre class="programlisting"><code class="hljs dart"><strong>src/app/auth/auth.service.ts</strong>
...
<span class="hljs-keyword">export</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthService</span> 
  </span><strong><span class="hljs-class"><span class="hljs-keyword">extends</span> <span class="hljs-title">CacheService</span></span></strong><span class="hljs-class"> <span class="hljs-keyword">implements</span> <span class="hljs-title">IAuthService</span> </span>{ 
  constructor() {
    <strong><span class="hljs-keyword">super</span>()</strong>
  }
  ... 
}
</code></pre>
      </li>
    </ol>
    <p class="normal">Note that <a id="_idIndexMarker804"/>we must call the constructor of the base class from the derived class's constructor using the <code class="Code-In-Text--PACKT-">super</code> method.</p>
    <p class="normal">Let's go <a id="_idIndexMarker805"/>over an example of how to use the base class's functionality by caching the value of the <code class="Code-In-Text--PACKT-">authStatus</code> object:</p>
    <pre class="programlisting"><code class="hljs oxygene"><strong>example</strong>
authStatus$ = <span class="hljs-keyword">new</span> BehaviorSubject&lt;IAuthStatus&gt;(
  this.getItem(<span class="hljs-string">'authStatus'</span>) ?? defaultAuthStatus
)
<span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">()</span> <span class="hljs-comment">{
  super()
  this.authStatus$.pipe(
    tap(authStatus =&gt; this.setItem('authStatus', authStatus))
  )
}</span>
</span></code></pre>
    <p class="normal">The technique demonstrated in the example leverages RxJS observable streams to update the cache whenever the value of <code class="Code-In-Text--PACKT-">authStatus$</code> changes. You can use this pattern to persist any kind of data without having to litter your business logic with caching code. In this case, we wouldn't need to update the <code class="Code-In-Text--PACKT-">login</code> function to call <code class="Code-In-Text--PACKT-">setItem</code>, because it already calls <code class="Code-In-Text--PACKT-">this.authStatus.next</code>, and we can just tap into the data stream. This helps with staying stateless and avoiding side effects by decoupling functions from each other.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">Note that we also initialize the <code class="Code-In-Text--PACKT-">BehaviorSubject</code> using the <code class="Code-In-Text--PACKT-">getItem</code> function. Using the nullish coalescing operator, we only use cached data if it is not <code class="Code-In-Text--PACKT-">undefined</code> or <code class="Code-In-Text--PACKT-">null</code>. Otherwise, we provide the default value.</p>
    </div>
    <div class="packt_tip">
      <p>You can implement your own custom cache expiration scheme in the <code class="Code-In-Text--PACKT-">setItem</code> and <code class="Code-In-Text--PACKT-">getItem</code> functions, or leverage a service created by a third party.</p>
    </div>
    <p class="normal">However, for an additional layer of security, we won't cache the <code class="Code-In-Text--PACKT-">authStatus</code> object. Instead, we will only cache the encoded JWT, which contains just enough information, so we can <a id="_idIndexMarker806"/>authenticate requests sent to the server. It is important to understand how token-based authentication works to avoid <a id="_idIndexMarker807"/>revealing compromising secrets. Review the JWT life cycle from earlier in this chapter to improve your understanding.</p>
    <p class="normal">Next, let's cache the token.</p>
    <h3 class="title" id="_idParaDest-290">Caching the JWT</h3>
    <p class="normal">Let's update <a id="_idIndexMarker808"/>the authentication service so that it can cache the token.</p>
    <ol>
      <li class="list" value="1">Update <code class="Code-In-Text--PACKT-">AuthService</code> to be able to set, get, and clear the token, as shown:
        <pre class="programlisting"><code class="hljs cs"><strong>src/app/auth/auth.service.ts</strong>
...
  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">setToken</span>(<span class="hljs-params">jwt: <span class="hljs-keyword">string</span></span>)</span> {
    <span class="hljs-keyword">this</span>.setItem(<span class="hljs-string">'jwt'</span>, jwt)
  }
  getToken(): <span class="hljs-keyword">string</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getItem(<span class="hljs-string">'jwt'</span>) ?? <span class="hljs-string">''</span>
  }
  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">clearToken</span>(<span class="hljs-params"/>)</span> {
    <span class="hljs-keyword">this</span>.removeItem(<span class="hljs-string">'jwt'</span>)
  }
</code></pre>
      </li>
      <li class="list" value="2">Call <code class="Code-In-Text--PACKT-">clearToken</code> and <code class="Code-In-Text--PACKT-">setToken</code> during <code class="Code-In-Text--PACKT-">login</code>, and <code class="Code-In-Text--PACKT-">clearToken</code> during <code class="Code-In-Text--PACKT-">logout</code>, as shown:
        <pre class="programlisting"><code class="hljs typescript"><strong>src/app/auth/auth.service.ts</strong>
...
  login(email: <span class="hljs-built_in">string</span>, password: <span class="hljs-built_in">string</span>): Observable&lt;<span class="hljs-built_in">void</span>&gt; {
    <strong><span class="hljs-keyword">this</span>.clearToken()</strong>
    <span class="hljs-keyword">const</span> loginResponse$ = <span class="hljs-keyword">this</span>.authProvider(email, password)
      .pipe(
        map(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
          <strong><span class="hljs-keyword">this</span>.setToken(value.accessToken)</strong>
          <span class="hljs-keyword">const</span> token = decode(value.accessToken)
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.transformJwtToken(token)
        }),
        tap(<span class="hljs-function">(<span class="hljs-params">status</span>) =&gt;</span> <span class="hljs-keyword">this</span>.authStatus$.next(status)),
        ...
  }
  logout(clearToken?: <span class="hljs-built_in">boolean</span>) {
    <strong><span class="hljs-keyword">if</span> (clearToken) {</strong>
<strong>      <span class="hljs-keyword">this</span>.clearToken()</strong>
<strong>    }</strong>
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.authStatus$.next(defaultAuthStatus), <span class="hljs-number">0</span>)
  }
</code></pre>
      </li>
    </ol>
    <p class="normal">Every subsequent request will contain the JWT in the request header. You should secure every API to check for and validate the token received. For example, if a user wants to access their profile, the <code class="Code-In-Text--PACKT-">AuthService</code> will validate the token to check whether the user is authenticated or not; however, a further database call will still be required to check whether the user is also authorized to view the data. This ensures an independent confirmation of the user's access to the system and prevents any abuse of an unexpired token.</p>
    <p class="normal">If an authenticated <a id="_idIndexMarker809"/>user makes a call to an API where they don't have the proper authorization, say if a clerk wants to get access to a list of all users, then the <code class="Code-In-Text--PACKT-">AuthService</code> will return a <code class="Code-In-Text--PACKT-">falsy</code> status, and the client will receive a <strong class="bold">403 Forbidden</strong> response, which will <a id="_idIndexMarker810"/>be displayed as an error message to the user.</p>
    <p class="normal">A user can make a request with an expired token; when this happens, a <strong class="bold">401 Unauthorized</strong> response is <a id="_idIndexMarker811"/>sent to the client. As a good UX practice, we should automatically prompt the user to log in again and let them resume their workflow without any data loss.</p>
    <p class="normal">In summary, true security is achieved with robust server-side implementation. Any client-side implementation is largely there to enable a good UX around good security practices.</p>
    <h2 class="title" id="_idParaDest-291">Implement an in-memory auth service</h2>
    <p class="normal">Now, let's <a id="_idIndexMarker812"/>implement a concrete version of the auth service that we can actually use:</p>
    <ol>
      <li class="list" value="1">Start by installing a JWT decoding library and, for faking authentication, a JWT encoding library:
        <pre class="programlisting"><code class="hljs gams"><span class="hljs-symbol">$</span> npm install fake-jwt-<span class="hljs-built-in">sign</span>
</code></pre>
      </li>
      <li class="list">Extend the abstract <code class="Code-In-Text--PACKT-">AuthService</code>:
        <pre class="programlisting"><code class="hljs scala"><strong>src/app/auth/auth.inmemory.service.ts</strong>
<span class="hljs-keyword">import</span> { <span class="hljs-type">AuthService</span> } from './auth.service'
<span class="hljs-meta">@Injectable</span>()
export <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InMemoryAuthService</span> </span><strong><span class="hljs-class"><span class="hljs-keyword">extends</span> <span class="hljs-title">AuthService</span></span></strong><span class="hljs-class"> </span>{
  constructor() {
    <strong><span class="hljs-keyword">super</span>()</strong>
<strong>    console.warn(</strong>
<strong>      <span class="hljs-string">"You're using the InMemoryAuthService. Do not use this service in production."</span></strong>
<strong>    )</strong>
  }
  ...
}
</code></pre>
      </li>
      <li class="list">Implement a fake <code class="Code-In-Text--PACKT-">authProvider</code> function that simulates the authentication process, including <a id="_idIndexMarker813"/>creating a fake JWT on the fly:
        <pre class="programlisting"><code class="hljs kotlin"><strong>src/app/auth/auth.inmemory.service.ts</strong>
  <span class="hljs-keyword">import</span> { sign } from <span class="hljs-string">'fake-jwt-sign'</span><span class="hljs-comment">//For InMemoryAuthService only</span>
...
  <span class="hljs-keyword">protected</span> authProvider(
    email: string,
    password: string
  ): Observable&lt;IServerAuthResponse&gt; {
    email = email.toLowerCase()
    <span class="hljs-keyword">if</span> (!email.endsWith(<span class="hljs-string">'@test.com'</span>)) {
      <span class="hljs-keyword">return</span> throwError(<span class="hljs-string">'Failed to login! Email needs to end with @test.com.'</span>)
    }
    <span class="hljs-keyword">const</span> authStatus = {
      isAuthenticated: <span class="hljs-literal">true</span>,
      userId: <span class="hljs-keyword">this</span>.defaultUser._id,
      userRole: email.includes(<span class="hljs-string">'cashier'</span>)
        ? Role.Cashier
        : email.includes(<span class="hljs-string">'clerk'</span>)
        ? Role.Clerk
        : email.includes(<span class="hljs-string">'manager'</span>)
        ? Role.Manager
        : Role.None,
    } <span class="hljs-keyword">as</span> IAuthStatus
    <span class="hljs-keyword">this</span>.defaultUser.role = authStatus.userRole
    <span class="hljs-keyword">const</span> authResponse = {
      accessToken: sign(authStatus, <span class="hljs-string">'secret'</span>, {
        expiresIn: <span class="hljs-string">'1h'</span>,
        algorithm: <span class="hljs-string">'none'</span>,
      }),
    } <span class="hljs-keyword">as</span> IServerAuthResponse
    <span class="hljs-keyword">return</span> of(authResponse)
  }
...
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">The <code class="Code-In-Text--PACKT-">authProvider</code> implements what would otherwise be a server-side method right in the service, so we can conveniently experiment with the code while fine-tuning our auth workflow. The provider creates and signs a JWT with the temporary <code class="Code-In-Text--PACKT-">fake-jwt-sign</code> library so that I can also demonstrate how to handle a properly formed JWT.</p>
        <div class="note">
          <p class="Information-Box--PACKT-">Do not ship your Angular application with the <code class="Code-In-Text--PACKT-">fake-jwt-sign</code> dependency, since it is meant to be server-side code.</p>
        </div>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">In contrast, a real <a id="_idIndexMarker814"/>auth provider would include a <code class="Code-In-Text--PACKT-">POST</code> call to a server. See the example code that follows: </p>
        <pre class="programlisting"><code class="hljs typescript"><strong>example</strong>
<span class="hljs-keyword">private</span> exampleAuthProvider(
  email: <span class="hljs-built_in">string</span>,
  password: <span class="hljs-built_in">string</span>
): Observable&lt;IServerAuthResponse&gt; { <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.httpClient.post&lt;IServerAuthResponse&gt;(
    <span class="hljs-string">`<span class="hljs-subst">${environment.baseUrl}</span>/v1/login`</span>, 
    { email: email, password: password }
  )
}
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">It is pretty straightforward, since the hard work is done on the server side. This call can also be made to a third-party auth provider, which I cover in the Firebase authentication recipe later in this chapter.</p>
        <div class="packt_tip">
          <p>Note that the API version, <code class="Code-In-Text--PACKT-">v1</code>, in the URL path is defined at the service and not as part of the <code class="Code-In-Text--PACKT-">baseUrl</code>. This is because each API can change versions independently. Login may remain <code class="Code-In-Text--PACKT-">v1</code> for a long time, while other APIs may be upgraded to <code class="Code-In-Text--PACKT-">v2</code>, <code class="Code-In-Text--PACKT-">v3</code>, and so on.</p>
        </div>
      </li>
      <li class="list">Implementing <code class="Code-In-Text--PACKT-">transformJwtToken</code> will be trivial, because the login function provides us with a token that adheres to <code class="Code-In-Text--PACKT-">IAuthStatus</code>:
        <pre class="programlisting"><code class="hljs groovy"><strong>src<span class="hljs-regexp">/app/</span>auth/auth.inmemory.service.ts</strong>
<span class="hljs-keyword">protected</span> transformJwtToken(<span class="hljs-string">token:</span> IAuthStatus): 
  IAuthStatus {
    <span class="hljs-keyword">return</span> token
  }
</code></pre>
      </li>
      <li class="list">Finally, implement <code class="Code-In-Text--PACKT-">getCurrentUser</code>, which should return some default user:
        <pre class="programlisting"><code class="hljs kotlin"><strong>src/app/auth/auth.inmemory.service.ts</strong>
<span class="hljs-keyword">protected</span> getCurrentUser(): Observable&lt;User&gt; {
  <span class="hljs-keyword">return</span> of(<span class="hljs-keyword">this</span>.defaultUser)
}
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">Next, provide a <code class="Code-In-Text--PACKT-">defaultUser</code> as a private property to the class; what follows is one that I've created.</p>
      </li>
      <li class="list" value="6">Add a <a id="_idIndexMarker815"/>private <code class="Code-In-Text--PACKT-">defaultUser</code> property to the <code class="Code-In-Text--PACKT-">InMemoryAuthService</code> class:
        <pre class="programlisting"><code class="hljs yaml"><strong><span class="hljs-string">src/app/auth/auth.inmemory.service.ts</span></strong>
<span class="hljs-string">import</span> <span class="hljs-string">{</span> <span class="hljs-string">PhoneType,</span> <span class="hljs-string">User</span> <span class="hljs-string">}</span> <span class="hljs-string">from</span> <span class="hljs-string">'../user/user/user'</span>
<span class="hljs-string">...</span>
<span class="hljs-string">private</span> <span class="hljs-string">defaultUser</span> <span class="hljs-string">=</span> <span class="hljs-string">User.Build({</span>
  <span class="hljs-attr">_id:</span> <span class="hljs-string">'5da01751da27cc462d265913'</span><span class="hljs-string">,</span>
  <span class="hljs-attr">email:</span> <span class="hljs-string">'duluca@gmail.com'</span><span class="hljs-string">,</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">{</span> <span class="hljs-attr">first:</span> <span class="hljs-string">'Doguhan'</span><span class="hljs-string">,</span> <span class="hljs-attr">last:</span> <span class="hljs-string">'Uluca'</span> <span class="hljs-string">},</span>
  <span class="hljs-attr">picture:</span> <span class="hljs-string">'https://secure.gravatar.com/avatar/7cbaa9afb5ca78d97f3c689f8ce6c985'</span><span class="hljs-string">,</span>
  <span class="hljs-attr">role:</span> <span class="hljs-string">Role.Manager,</span>
  <span class="hljs-attr">dateOfBirth:</span> <span class="hljs-string">new</span> <span class="hljs-string">Date(1980,</span> <span class="hljs-number">1</span><span class="hljs-string">,</span> <span class="hljs-number">1</span><span class="hljs-string">),</span>
  <span class="hljs-attr">userStatus:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span>
  <span class="hljs-attr">address:</span> <span class="hljs-string">{</span>
    <span class="hljs-attr">line1:</span> <span class="hljs-string">'101 Sesame St.'</span><span class="hljs-string">,</span>
    <span class="hljs-attr">city:</span> <span class="hljs-string">'Bethesda'</span><span class="hljs-string">,</span>
    <span class="hljs-attr">state:</span> <span class="hljs-string">'Maryland'</span><span class="hljs-string">,</span>
    <span class="hljs-attr">zip:</span> <span class="hljs-string">'20810'</span><span class="hljs-string">,</span>
  <span class="hljs-string">},</span>
  <span class="hljs-attr">level:</span> <span class="hljs-number">2</span><span class="hljs-string">,</span>
  <span class="hljs-attr">phones:</span> <span class="hljs-string">[</span>
    <span class="hljs-string">{</span>
      <span class="hljs-attr">id:</span> <span class="hljs-number">0</span><span class="hljs-string">,</span>
      <span class="hljs-attr">type:</span> <span class="hljs-string">PhoneType.Mobile,</span>
      <span class="hljs-attr">digits:</span> <span class="hljs-string">'5555550717'</span><span class="hljs-string">,</span>
    <span class="hljs-string">},</span>
  <span class="hljs-string">],</span>
<span class="hljs-string">})</span>
</code></pre>
      </li>
    </ol>
    <p class="normal">Congratulations, you've implemented a concrete, but still fake, auth service. Now that you have <a id="_idIndexMarker816"/>the in-memory auth service in place, be sure to run your Angular application and ensure that there are no errors.</p>
    <p class="normal">Let's test our auth service by implementing a simple login and logout functionality accessible through the UI.</p>
    <h3 class="title" id="_idParaDest-292">Simple login</h3>
    <p class="normal">Before we <a id="_idIndexMarker817"/>implement a fully-featured <code class="Code-In-Text--PACKT-">login</code> component, let's wire up pre-baked login behavior to the <strong class="screen-text">Login as manager</strong> button we have in the <code class="Code-In-Text--PACKT-">HomeComponent</code>. We can test the behavior of our auth service before getting into the details of delivering a rich UI component.</p>
    <p class="normal">Our goal is to simulate logging in as a manager. To accomplish this, we need to hard code an e mail address and a password to log in, and upon successful login, maintain the functionality of navigating to the <code class="Code-In-Text--PACKT-">/manager</code> route.</p>
    <div class="packt_tip">
      <p>Note that on GitHub the code sample for this section resides in a file named <code class="Code-In-Text--PACKT-">home.component.simple.ts</code> under the folder structure of <code class="Code-In-Text--PACKT-">projects/ch8</code>. The alternate file exists for reference purposes only, since the code from this section dramatically changes later in the chapter. Ignore the file name difference, as it will not impact your coding for this section.</p>
    </div>
    <p class="normal">Let's implement a simple login mechanism:</p>
    <ol>
      <li class="list" value="1">In the <code class="Code-In-Text--PACKT-">HomeComponent</code>, implement a <code class="Code-In-Text--PACKT-">login</code> function that uses the <code class="Code-In-Text--PACKT-">AuthService</code>:
        <pre class="programlisting"><code class="hljs typescript"><strong>src/app/home/home.component.ts</strong>
<span class="hljs-keyword">import</span> { AuthService } <span class="hljs-keyword">from</span> <span class="hljs-string">'../auth/auth.service'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> HomeComponent <span class="hljs-keyword">implements</span> OnInit {
  <span class="hljs-keyword">constructor</span>(<strong><span class="hljs-params"><span class="hljs-keyword">private</span> authService: AuthService</span></strong>) {}
  ngOnInit(): <span class="hljs-built_in">void</span> {}
  <strong>login() {</strong>
<strong>    <span class="hljs-keyword">this</span>.authService.login(<span class="hljs-string">'manager@test.com'</span>, <span class="hljs-string">'12345678'</span>)</strong>
<strong>  }</strong>
}
</code></pre>
      </li>
      <li class="list">Update the <a id="_idIndexMarker818"/>template to remove the <code class="Code-In-Text--PACKT-">routerLink</code> and instead call the <code class="Code-In-Text--PACKT-">login</code> function:
        <pre class="programlisting"><code class="hljs stylus"><strong>src/app/home/home<span class="hljs-selector-class">.component</span><span class="hljs-selector-class">.ts</span></strong>
template: `
    &lt;<span class="hljs-selector-tag">div</span> fxLayout=<span class="hljs-string">"column"</span> fxLayoutAlign=<span class="hljs-string">"center center"</span>&gt;
      &lt;<span class="hljs-selector-tag">span</span> class=<span class="hljs-string">"mat-display-2"</span>&gt;Hello, Limoncu!&lt;/span&gt;
      &lt;<span class="hljs-selector-tag">button</span> mat-raised-<span class="hljs-selector-tag">button</span> <span class="hljs-attribute">color</span>=<span class="hljs-string">"primary"</span> <strong>(click)=<span class="hljs-string">"login()"</span></strong>&gt;
        Login as Manager
      &lt;/button&gt;
    &lt;/div&gt;
  `,
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">On successful login, we need to navigate to the <code class="Code-In-Text--PACKT-">/manager</code> route. We can verify that we're successfully logged in by listening to the <code class="Code-In-Text--PACKT-">authStatus$</code> and <code class="Code-In-Text--PACKT-">currentUser$</code> observables exposed by the <code class="Code-In-Text--PACKT-">AuthService</code>. If <code class="Code-In-Text--PACKT-">authStatus$.isAuthenticated</code> is <code class="Code-In-Text--PACKT-">true</code> and <code class="Code-In-Text--PACKT-">currentUser$._id</code> is a non-empty string, that means that we have a valid login. We can listen to both observables by using RxJS's <code class="Code-In-Text--PACKT-">combineLatest</code> operator. Given a valid login condition, we can then use the <code class="Code-In-Text--PACKT-">filter</code> operator to reactively navigate to the <code class="Code-In-Text--PACKT-">/manager</code> route.</p>
      </li>
      <li class="list">Update the <code class="Code-In-Text--PACKT-">login()</code> function to implement the login conditional and upon success, navigate to the <code class="Code-In-Text--PACKT-">/manager</code> route:
        <pre class="programlisting"><code class="hljs typescript"><strong>src/app/home/home.component.ts</strong>
<span class="hljs-keyword">constructor</span>(<span class="hljs-params">
  <span class="hljs-keyword">private</span> authService: AuthService,
  </span><strong><span class="hljs-params"><span class="hljs-keyword">private</span> router: Router</span></strong><span class="hljs-params">
</span>) {}
  
login() {
  <span class="hljs-keyword">this</span>.authService.login(<span class="hljs-string">'manager@test.com'</span>, <span class="hljs-string">'12345678'</span>)
<strong>combineLatest([</strong>
<strong>  <span class="hljs-keyword">this</span>.authService.authStatus$, <span class="hljs-keyword">this</span>.authService.currentUser$</strong>
<strong>]) </strong>
<strong>  .pipe(</strong>
<strong>    filter(<span class="hljs-function">(<span class="hljs-params">[authStatus, user]</span>) =&gt;</span> </strong>
<strong>      authStatus.isAuthenticated &amp;&amp; user?._id !== <span class="hljs-string">''</span></strong>
<strong>    ),</strong>
<strong>    tap(<span class="hljs-function">(<span class="hljs-params">[authStatus, user]</span>) =&gt;</span> {</strong>
<strong>      <span class="hljs-keyword">this</span>.router.navigate([<span class="hljs-string">'/manager'</span>])</strong>
<strong>    })</strong>
<strong>  )</strong>
<strong>  .subscribe()</strong>
}
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">Note that we subscribe to the <code class="Code-In-Text--PACKT-">combineLatest</code> operator at the end, which is critical in activating the observable streams. Otherwise, our login action will remain dormant unless some other component subscribes to the stream. You only need to activate a stream once.</p>
      </li>
      <li class="list" value="4">Now test <a id="_idIndexMarker819"/>out the new <code class="Code-In-Text--PACKT-">login</code> functionality. Verify that the JWT is created and stored in <code class="Code-In-Text--PACKT-">localStorage</code> using the <strong class="screen-text">Chrome DevTools| Application</strong> tab, as shown here:
      <figure class="mediaobject"><img alt="" src="../Images/B14094_08_04.png"/></figure>
      <p class="packt_figref">Figure 8.4: DevTools showing Application Local Storage</p></li>
    </ol>
    <p class="normal">You can view <strong class="screen-text">Local Storage</strong> under the <strong class="screen-text">Application</strong> tab. Make sure that the URL of your application is highlighted. In step 3, you can see that we have a key named <code class="Code-In-Text--PACKT-">jwt</code> with a valid-looking token.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">Note steps 4 and 5 highlighting two warnings, which advise us not to use the <code class="Code-In-Text--PACKT-">InMemoryAuthService</code> and the <code class="Code-In-Text--PACKT-">fake-jwt-sign</code> package in production code.</p>
    </div>
    <div class="packt_tip">
      <p>Use breakpoints to debug and step through the code to get a more concrete understanding of how <code class="Code-In-Text--PACKT-">HomeComponent</code>, <code class="Code-In-Text--PACKT-">InMemoryAuthService</code>, and <code class="Code-In-Text--PACKT-">AuthService</code> work together to log the user in. </p>
    </div>
    <p class="normal">When you <a id="_idIndexMarker820"/>refresh the page, note that you're still logged in, because we're caching the token in local storage.</p>
    <p class="normal">Since we're caching the login status, we also need to implement a logout experience to complete the auth workflow.</p>
    <h3 class="title" id="_idParaDest-293">Logout</h3>
    <p class="normal">The logout <a id="_idIndexMarker821"/>button on the application toolbar is already wired up to navigate to the <code class="Code-In-Text--PACKT-">logout</code> component we created before. Let's update this component so it can log the user out when navigated to:</p>
    <ol>
      <li class="list" value="1">Implement the <code class="Code-In-Text--PACKT-">logout</code> component:
        <pre class="programlisting"><code class="hljs typescript"><strong>src/app/user/logout/logout.component.ts</strong>
<span class="hljs-keyword">import</span> { Component, OnInit } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span> 
<span class="hljs-keyword">import</span> { Router } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/router'</span>
<span class="hljs-keyword">import</span> { AuthService } <span class="hljs-keyword">from</span> <span class="hljs-string">'../../auth/auth.service'</span>
<span class="hljs-meta">@Component</span>({
  selector: <span class="hljs-string">'app-logout'</span>, 
  template: <span class="hljs-string">`&lt;p&gt;Logging out...&lt;/p&gt;`</span>,
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> LogoutComponent <span class="hljs-keyword">implements</span> OnInit { 
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> router: Router, <span class="hljs-keyword">private</span> authService: AuthService</span>) {}
  ngOnInit() { 
    <span class="hljs-keyword">this</span>.authService.logout(<span class="hljs-literal">true</span>)
    <span class="hljs-keyword">this</span>.router.navigate([<span class="hljs-string">'/'</span>])
  }
}
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">Note that we are explicitly clearing the JWT by passing in <code class="Code-In-Text--PACKT-">true</code> to the <code class="Code-In-Text--PACKT-">logout</code> function. After we call <code class="Code-In-Text--PACKT-">logout</code>, we navigate the user back to the home page.</p>
      </li>
      <li class="list">Test out the <code class="Code-In-Text--PACKT-">logout</code> button.</li>
      <li class="list" value="3">Verify that local storage is cleared after logout.</li>
    </ol>
    <p class="normal">We have <a id="_idIndexMarker822"/>nailed a solid login and logout implementation. However, we're not yet done with the fundamentals of our auth workflow.</p>
    <p class="normal">Next, we need to consider the expiration status of our JWT.</p>
    <h2 class="title" id="_idParaDest-294">Resuming a JWT session</h2>
    <p class="normal">It wouldn't be a great UX if you had to log in to Gmail or Amazon every single time you visited the site. This is why we cache the JWT, but it would be an equally bad UX to keep you logged in forever. A JWT has an expiration date policy, where the provider can select a number <a id="_idIndexMarker823"/>of minutes or even months to allow your token to be valid for depending on security needs. The in-memory service creates tokens that expire in one hour, so if a user refreshes their browser window within that frame, we should honor the valid token and let the user continue using the application without asking them to log back in. </p>
    <p class="normal">On the flip side, if the token is expired, we should automatically navigate the user to the login screen for a smooth UX.</p>
    <p class="normal">Let's get started:</p>
    <ol>
      <li class="list" value="1">Update the <code class="Code-In-Text--PACKT-">AuthService</code> class to implement a function named <code class="Code-In-Text--PACKT-">hasExpiredToken</code> to check whether the token is expired, and a helper function named <code class="Code-In-Text--PACKT-">getAuthStatusFromToken</code> to decode the token, as shown:
        <pre class="programlisting"><code class="hljs kotlin"><strong>src/app/auth/auth.service.ts</strong>
...
  <span class="hljs-keyword">protected</span> hasExpiredToken(): boolean {
    <span class="hljs-keyword">const</span> jwt = <span class="hljs-keyword">this</span>.getToken()
    <span class="hljs-keyword">if</span> (jwt) {
      <span class="hljs-keyword">const</span> payload = decode(jwt) <span class="hljs-keyword">as</span> any
      <span class="hljs-keyword">return</span> Date.now() &gt;= payload.exp * <span class="hljs-number">1000</span>
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
  }
  <span class="hljs-keyword">protected</span> getAuthStatusFromToken(): IAuthStatus {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.transformJwtToken(decode(<span class="hljs-keyword">this</span>.getToken()))
  }
</code></pre>
        <div class="packt_tip">
          <p>Keep your code DRY! Update the <code class="Code-In-Text--PACKT-">login()</code> function to use <code class="Code-In-Text--PACKT-">getAuthStatusFromToken()</code> instead.</p>
        </div>
      </li>
      <li class="list">Update <a id="_idIndexMarker824"/>the constructor of <code class="Code-In-Text--PACKT-">AuthService</code> to check the status of the token:
        <pre class="programlisting"><code class="hljs kotlin"><strong>src/app/auth/auth.service.ts</strong>
...
<span class="hljs-keyword">constructor</span>() {
    <span class="hljs-keyword">super</span>()
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.hasExpiredToken()) {
      <span class="hljs-keyword">this</span>.logout(<span class="hljs-literal">true</span>)
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">this</span>.authStatus$.next(<span class="hljs-keyword">this</span>.getAuthStatusFromToken())
    }
}
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">If the token has expired, we log the user out and clear the token from <code class="Code-In-Text--PACKT-">localStorage</code>. Otherwise, we decode the token and push the auth status to the data stream.</p>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">A corner case to consider here is to also trigger the reloading of the current user in the event of a resumption. We can do this by implementing a new pipe that reloads the current user if activated.</p>
      </li>
      <li class="list">First, let's refactor the existing user update logic in the <code class="Code-In-Text--PACKT-">login()</code> function to a private property named <code class="Code-In-Text--PACKT-">getAndUpdateUserIfAuthenticated</code> so we can reuse it:
        <pre class="programlisting"><code class="hljs typescript"><strong>src/app/auth/auth.service.ts</strong>
...
  <span class="hljs-meta">@Injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> AuthService <span class="hljs-keyword">extends</span> CacheService <span class="hljs-keyword">implements</span> IAuthService {
  <strong><span class="hljs-keyword">private</span> getAndUpdateUserIfAuthenticated = pipe(</strong>
<strong>    filter(<span class="hljs-function">(<span class="hljs-params">status: IAuthStatus</span>) =&gt;</span> status.isAuthenticated),</strong>
<strong>    flatMap(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.getCurrentUser()),</strong>
<strong>    map(<span class="hljs-function">(<span class="hljs-params">user: IUser</span>) =&gt;</span> <span class="hljs-keyword">this</span>.currentUser$.next(user)),</strong>
<strong>    catchError(transformError)</strong>
<strong>  )</strong>
  ...
  login(email: <span class="hljs-built_in">string</span>, password: <span class="hljs-built_in">string</span>): Observable&lt;<span class="hljs-built_in">void</span>&gt; {
    <span class="hljs-keyword">this</span>.clearToken()
    <span class="hljs-keyword">const</span> loginResponse$ = <span class="hljs-keyword">this</span>.authProvider(email, password)
      .pipe(
        map(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> {
          <span class="hljs-keyword">this</span>.setToken(value.accessToken)
          <span class="hljs-keyword">const</span> token = decode(value.accessToken)
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.transformJwtToken(token)
        }),
        tap(<span class="hljs-function">(<span class="hljs-params">status</span>) =&gt;</span> <span class="hljs-keyword">this</span>.authStatus$.next(status)),
        <strong><span class="hljs-keyword">this</span>.getAndUpdateUserIfAuthenticated</strong>
      )
    ...
  }
  ...
}
</code></pre>
      </li>
      <li class="list">In <code class="Code-In-Text--PACKT-">AuthService</code>, define an observable property named <code class="Code-In-Text--PACKT-">resumeCurrentUser$</code> as a fork of <code class="Code-In-Text--PACKT-">authStatus$</code>, and use the <code class="Code-In-Text--PACKT-">getAndUpdateUserIfAuthenticated</code> logic:
        <pre class="programlisting"><code class="hljs kotlin"><strong>src/app/auth/auth.service.ts</strong>
...
  <span class="hljs-keyword">protected</span> readonly resumeCurrentUser$ = <span class="hljs-keyword">this</span>.authStatus$.pipe(
    <span class="hljs-keyword">this</span>.getAndUpdateUserIfAuthenticated 
  )
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">Once <code class="Code-In-Text--PACKT-">resumeCurrentUser$</code> is activated and <code class="Code-In-Text--PACKT-">status.isAuthenticated</code> is <code class="Code-In-Text--PACKT-">true</code>, then <code class="Code-In-Text--PACKT-">this.getCurrentUser()</code> will be invoked and <code class="Code-In-Text--PACKT-">currentUser$</code> will be updated.</p>
      </li>
      <li class="list" value="5">Update the <a id="_idIndexMarker825"/>constructor of <code class="Code-In-Text--PACKT-">AuthService</code> to activate the pipeline if the token is unexpired:
        <pre class="programlisting"><code class="hljs typescript"><strong>src/app/auth/auth.service.ts</strong>
...
<span class="hljs-keyword">constructor</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">super</span>()
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.hasExpiredToken()) {
    <span class="hljs-keyword">this</span>.logout(<span class="hljs-literal">true</span>)
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">this</span>.authStatus$.next(<span class="hljs-keyword">this</span>.getAuthStatusFromToken())
    <span class="hljs-comment">// To load user on browser refresh,</span>
    <span class="hljs-comment">// resume pipeline must activate on the next cycle</span>
    <span class="hljs-comment">// Which allows for all services to constructed properly</span>
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.resumeCurrentUser$.subscribe(), <span class="hljs-number">0</span>)
  }
}
</code></pre>
      </li>
    </ol>
    <p class="normal">Using the <a id="_idIndexMarker826"/>preceding technique, we can retrieve the latest user profile data without having to deal with caching issues. </p>
    <div class="packt_tip">
      <p>To experiment with token expiration, I recommend that you create a faster-expiring token in <code class="Code-In-Text--PACKT-">InMemoryAuthService</code>.</p>
    </div>
    <div class="note">
      <p class="Information-Box--PACKT-">As demonstrated earlier in the caching section, it is possible to cache the user profile data using <code class="Code-In-Text--PACKT-">this.setItem</code> and the profile data from cache on first launch. This would provide a faster UX and cover cases where users may be offline. After the application launches, you could then asynchronously fetch fresh user data and update <code class="Code-In-Text--PACKT-">currentUser$</code> when new data comes in. You would need to add additional caching and tweak the <code class="Code-In-Text--PACKT-">getCurrentUser()</code> logic to get such functionality working. Oh, and you would need a whole lot of testing! It takes a lot of testing to create a high-quality auth experience.</p>
    </div>
    <p class="normal">Congratulations, we're done implementing a robust auth workflow! Next, we need to integrate auth with Angular's HTTP client so we can attach the token to the HTTP header of every request.</p>
    <h2 class="title" id="_idParaDest-295">HTTP interceptor</h2>
    <p class="normal">Implement an <a id="_idIndexMarker827"/>HTTP interceptor to inject the JWT into the header of every request sent to the user and gracefully handle authentication failures by asking the user to log back in:</p>
    <ol>
      <li class="list" value="1">Create an <code class="Code-In-Text--PACKT-">AuthHttpInterceptor</code> under <code class="Code-In-Text--PACKT-">auth</code>:
        <pre class="programlisting"><code class="hljs typescript"><strong>src/app/auth/auth-http-interceptor.ts</strong>
<span class="hljs-keyword">import</span> {
  HttpEvent,
  HttpHandler,
  HttpInterceptor,
  HttpRequest,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/common/http'</span>
<span class="hljs-keyword">import</span> { Injectable } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>
<span class="hljs-keyword">import</span> { Router } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/router'</span>
<span class="hljs-keyword">import</span> { Observable, throwError } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>
<span class="hljs-keyword">import</span> { catchError } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs/operators'</span>
<span class="hljs-keyword">import</span> { AuthService } <span class="hljs-keyword">from</span> <span class="hljs-string">'./auth.service'</span>
<span class="hljs-meta">@Injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AuthHttpInterceptor <span class="hljs-keyword">implements</span> HttpInterceptor {
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> authService: AuthService, <span class="hljs-keyword">private</span> router: Router</span>) {}
  intercept(req: HttpRequest&lt;<span class="hljs-built_in">any</span>&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;<span class="hljs-built_in">any</span>&gt;&gt; {
    <span class="hljs-keyword">const</span> jwt = <span class="hljs-keyword">this</span>.authService.getToken()
    <span class="hljs-keyword">const</span> authRequest = req.clone({ setHeaders: { authorization: <span class="hljs-string">`Bearer <span class="hljs-subst">${jwt}</span>`</span> } })
    <span class="hljs-keyword">return</span> next.handle(authRequest).pipe(
      catchError(<span class="hljs-function">(<span class="hljs-params">err, caught</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (err.status === <span class="hljs-number">401</span>) {
          <span class="hljs-keyword">this</span>.router.navigate(
            [<span class="hljs-string">'/login'</span>], { queryParams: {
              redirectUrl: <span class="hljs-keyword">this</span>.router.routerState.snapshot.url},}
          )
        }
        <span class="hljs-keyword">return</span> throwError(err)
      })
    )
  }
}
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">Note that <code class="Code-In-Text--PACKT-">AuthService</code> is leveraged to retrieve the token, and the <code class="Code-In-Text--PACKT-">redirectUrl</code> is set for the <code class="Code-In-Text--PACKT-">login</code> component after a <code class="Code-In-Text--PACKT-">401</code> error.</p>
      </li>
      <li class="list">Update <a id="_idIndexMarker828"/><code class="Code-In-Text--PACKT-">app.module.ts</code> to provide the interceptor:
        <pre class="programlisting"><code class="hljs yaml"><strong><span class="hljs-string">src/app/app.module.ts</span></strong>
  <span class="hljs-attr">providers:</span> <span class="hljs-string">[</span>
    <span class="hljs-string">...</span>
    <span class="hljs-string">{</span>
      <span class="hljs-attr">provide:</span> <span class="hljs-string">HTTP_INTERCEPTORS,</span>
      <span class="hljs-attr">useClass:</span> <span class="hljs-string">AuthHttpInterceptor,</span>
      <span class="hljs-attr">multi:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span>
    <span class="hljs-string">},</span>
  <span class="hljs-string">],</span>
</code></pre>
      </li>
      <li class="list" value="3">Ensure that the interceptor is adding the token to requests. To do this, open the <strong class="screen-text">Chrome DevTools | Network</strong> tab, log in, and then refresh the page:
      <figure class="mediaobject"><img alt="" src="../Images/B14094_08_05.png"/></figure>
      <p class="packt_figref">Figure 8.5: The request header for lemon.svg</p></li>
    </ol>
    <p class="normal">In step <strong class="bold">4</strong>, you can <a id="_idIndexMarker829"/>now observe the interceptor in action. The request for the <code class="Code-In-Text--PACKT-">lemon.svg</code> file has the bearer token in the request header.</p>
    <p class="normal">Now that we have our auth mechanisms in place, let's take advantage of all the supporting code we have written with dynamic UI components and a conditional navigation system for a role-based UX.</p>
    <h1 class="title" id="_idParaDest-296">Dynamic UI components and navigation</h1>
    <p class="normal"><code class="Code-In-Text--PACKT-">AuthService</code> provides asynchronous auth status and user information, including a user's name <a id="_idIndexMarker830"/>and role. We can use all this information to create <a id="_idIndexMarker831"/>a friendly and personalized experience for users. In this next section, we will implement the <code class="Code-In-Text--PACKT-">LoginComponent</code> so that users can enter their username and password information and attempt a login.</p>
    <h2 class="title" id="_idParaDest-297">Implementing the login component</h2>
    <p class="normal">The <code class="Code-In-Text--PACKT-">login</code> component leverages the <code class="Code-In-Text--PACKT-">AuthService</code> that we just created and implements <a id="_idIndexMarker832"/>validation errors using reactive forms.</p>
    <div class="packt_tip">
      <p>Remember that in <code class="Code-In-Text--PACKT-">app.module.ts</code> we provided <code class="Code-In-Text--PACKT-">AuthService</code> using the class <code class="Code-In-Text--PACKT-">InMemoryAuthService</code>. So, during run time, when <code class="Code-In-Text--PACKT-">AuthService</code> is injected into the <code class="Code-In-Text--PACKT-">login</code> component, the in-memory service will be the one in use.</p>
    </div>
    <p class="normal">The <code class="Code-In-Text--PACKT-">login</code> component should be designed to be rendered independently of any other component, because during a routing event, if we discover that the user is not properly authenticated or authorized, we will navigate them to this component. We can capture this origination URL as a <code class="Code-In-Text--PACKT-">redirectUrl</code> so that once a user logs in successfully, we can navigate them back to it.</p>
    <p class="normal">Let's begin:</p>
    <ol>
      <li class="list" value="1">Install the <code class="Code-In-Text--PACKT-">SubSink</code> package.</li>
      <li class="list">Create a new component named <code class="Code-In-Text--PACKT-">login</code> in the root of your application with inline styles.</li>
      <li class="list">Let's start with implementing the routes to the <code class="Code-In-Text--PACKT-">login</code> component:
        <pre class="programlisting"><code class="hljs groovy"><strong>src<span class="hljs-regexp">/app/</span>app-routing.modules.ts</strong>
...
  { <span class="hljs-string">path:</span> <span class="hljs-string">'login'</span>, <span class="hljs-string">component:</span> LoginComponent },
  { <span class="hljs-string">path:</span> <span class="hljs-string">'login/:redirectUrl'</span>, <span class="hljs-string">component:</span> LoginComponent },
...
</code></pre>
        <div class="packt_tip">
          <p>Remember that the <code class="Code-In-Text--PACKT-">'**'</code> path must be the last one defined.</p>
        </div>
      </li>
      <li class="list">Using a similar <code class="Code-In-Text--PACKT-">login</code> logic to the one we implemented in <code class="Code-In-Text--PACKT-">HomeComponent</code>, now <a id="_idIndexMarker833"/>implement the <code class="Code-In-Text--PACKT-">LoginComponent</code> with some styles:<div class="note">
          <p class="Information-Box--PACKT-">Don't forget to import the requisite dependent modules into your Angular application for the upcoming steps. This is intentionally left as an exercise for you to locate and import the missing modules.</p>
        </div>
        <pre class="programlisting"><code class="hljs typescript"><strong>src/app/login/login.component.ts</strong>
…
<span class="hljs-keyword">import</span> { AuthService } <span class="hljs-keyword">from</span> <span class="hljs-string">'../auth/auth.service'</span>
<span class="hljs-keyword">import</span> { Role } <span class="hljs-keyword">from</span> <span class="hljs-string">'../auth/role.enum'</span>
<span class="hljs-meta">@Component</span>({
  selector: <span class="hljs-string">'app-login'</span>,
  templateUrl: <span class="hljs-string">'login.component.html'</span>,
  styles: [
    <span class="hljs-string">`
      .error {
        color: red
      }
    `</span>,
    <span class="hljs-string">`
      div[fxLayout] {
        margin-top: 32px;
      }
    `</span>,
  ],
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> LoginComponent <span class="hljs-keyword">implements</span> OnInit { 
  <span class="hljs-keyword">private</span> subs = <span class="hljs-keyword">new</span> SubSink()
  loginForm: FormGroup
  loginError = <span class="hljs-string">''</span>
  redirectUrl: <span class="hljs-built_in">string</span>
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">
    <span class="hljs-keyword">private</span> formBuilder: FormBuilder,
    <span class="hljs-keyword">private</span> authService: AuthService,
    <span class="hljs-keyword">private</span> router: Router,
    <span class="hljs-keyword">private</span> route: ActivatedRoute
  </span>) {
    <span class="hljs-keyword">this</span>.subs.sink = route.paramMap.subscribe(
      <span class="hljs-function"><span class="hljs-params">params</span> =&gt;</span> (<span class="hljs-keyword">this</span>.redirectUrl = 
        params.get(<span class="hljs-string">'redirectUrl'</span>) ?? <span class="hljs-string">''</span>
      )
    )
  }
  ngOnInit() {
    <span class="hljs-keyword">this</span>.authService.logout()
    <span class="hljs-keyword">this</span>.buildLoginForm()
  }
  buildLoginForm() {
    <span class="hljs-keyword">this</span>.loginForm = <span class="hljs-keyword">this</span>.formBuilder.group({
      email: [<span class="hljs-string">''</span>, [Validators.required, Validators.email]],
      password: [<span class="hljs-string">''</span>, [
        Validators.required,
        Validators.minLength(<span class="hljs-number">8</span>),
        Validators.maxLength(<span class="hljs-number">50</span>),
      ]],
    })
  }
  <span class="hljs-keyword">async</span> login(submittedForm: FormGroup) {
    <span class="hljs-keyword">this</span>.authService
      .login(
        submittedForm.value.email,
        submittedForm.value.password
      )
      .pipe(catchError(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> (<span class="hljs-keyword">this</span>.loginError = err)))
    <span class="hljs-keyword">this</span>.subs.sink = combineLatest([
      <span class="hljs-keyword">this</span>.authService.authStatus$,
      <span class="hljs-keyword">this</span>.authService.currentUser$,
    ])
      .pipe(
        filter(
          <span class="hljs-function">(<span class="hljs-params">[authStatus, user]</span>) =&gt;</span>
            authStatus.isAuthenticated &amp;&amp; user?._id !== <span class="hljs-string">''</span>
        ),
        tap(<span class="hljs-function">(<span class="hljs-params">[authStatus, user]</span>) =&gt;</span> {
          <span class="hljs-keyword">this</span>.router.navigate([<span class="hljs-keyword">this</span>.redirectUrl || <span class="hljs-string">'/manager'</span>])
        })
      )
      .subscribe()
  } 
}
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">We are using <code class="Code-In-Text--PACKT-">SubSink</code> to manage our subscriptions. We ensure that we are <a id="_idIndexMarker834"/>logged out when <code class="Code-In-Text--PACKT-">ngOnInit</code> is called. We build the reactive form in a standard manner. Finally, the <code class="Code-In-Text--PACKT-">login</code> method calls <code class="Code-In-Text--PACKT-">this.authService.login</code> to initiate the login process.</p>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">We listen to the <code class="Code-In-Text--PACKT-">authStatus$</code> and <code class="Code-In-Text--PACKT-">currentUser$</code> data streams simultaneously using <code class="Code-In-Text--PACKT-">combineLatest</code>. Every time there's a change in each stream, our pipe gets executed. We filter out unsuccessful login attempts. As the result of a successful login attempt, we leverage the router to navigate an authenticated user to their profile. In the case of an error sent from the server via the service, we assign that error to <code class="Code-In-Text--PACKT-">loginError</code>.</p>
      </li>
      <li class="list">Here's an <a id="_idIndexMarker835"/>implementation for a login form to capture and validate a user's <code class="Code-In-Text--PACKT-">email</code> and <code class="Code-In-Text--PACKT-">password</code>, and if there are any server errors, display them:
      <div class="packt_tip">
        <p>Don't forget to import <code class="Code-In-Text--PACKT-">ReactiveFormsModule</code> in <code class="Code-In-Text--PACKT-">app.modules.ts</code>.</p>
      </div>
      <pre class="programlisting"><code class="hljs stata"><strong>src/<span class="hljs-keyword">app</span>/login/login.component.html</strong>
&lt;div fxLayout=<span class="hljs-string">"row"</span> fxLayoutAlign=<span class="hljs-string">"center"</span>&gt;
  &lt;<span class="hljs-keyword">mat</span>-card fxFlex=<span class="hljs-string">"400px"</span>&gt;
    &lt;<span class="hljs-keyword">mat</span>-card-header&gt;
      &lt;<span class="hljs-keyword">mat</span>-card-title&gt;
        &lt;div <span class="hljs-keyword">class</span>=<span class="hljs-string">"mat-headline"</span>&gt;Hello, Limoncu!&lt;/div&gt;
      &lt;/<span class="hljs-keyword">mat</span>-card-title&gt;
    &lt;/<span class="hljs-keyword">mat</span>-card-header&gt;
    &lt;<span class="hljs-keyword">mat</span>-card-content&gt;
      &lt;<span class="hljs-keyword">form</span> [formGroup]=<span class="hljs-string">"loginForm"</span> (ngSubmit)=<span class="hljs-string">"login(loginForm)"</span> fxLayout=<span class="hljs-string">"column"</span>&gt;
        &lt;div fxLayout=<span class="hljs-string">"row"</span> fxLayoutAlign=<span class="hljs-string">"start center"</span> fxLayoutGap=<span class="hljs-string">"10px"</span>&gt;
          &lt;<span class="hljs-keyword">mat</span>-icon&gt;email&lt;/<span class="hljs-keyword">mat</span>-icon&gt;
          &lt;<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">form</span>-field fxFlex&gt;
            &lt;<span class="hljs-keyword">input</span> matInput placeholder=<span class="hljs-string">"E-mail"</span> aria-<span class="hljs-keyword">label</span>=<span class="hljs-string">"E- mail"</span> formControlName=<span class="hljs-string">"email"</span>&gt;
            &lt;<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">error</span> *ngIf=<span class="hljs-string">"loginForm.get('email')?.hasError('required')"</span>&gt;
              <span class="hljs-keyword">E</span>-mail is required
            &lt;/<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">error</span>&gt;
            &lt;<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">error</span> *ngIf=<span class="hljs-string">"loginForm.get('email')?.hasError('email')"</span>&gt;
              <span class="hljs-keyword">E</span>-mail is not valid
            &lt;/<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">error</span>&gt;
          &lt;/<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">form</span>-field&gt;
        &lt;/div&gt;
        &lt;div fxLayout=<span class="hljs-string">"row"</span> fxLayoutAlign=<span class="hljs-string">"start center"</span> fxLayoutGap=<span class="hljs-string">"10px"</span>&gt;
          &lt;<span class="hljs-keyword">mat</span>-icon matPrefix&gt;vpn_key&lt;/<span class="hljs-keyword">mat</span>-icon&gt;
          &lt;<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">form</span>-field fxFlex&gt;
            &lt;<span class="hljs-keyword">input</span> matInput placeholder=<span class="hljs-string">"Password"</span> aria- <span class="hljs-keyword">label</span>=<span class="hljs-string">"Password"</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">"password"</span> formControlName=<span class="hljs-string">"password"</span>&gt;
            &lt;<span class="hljs-keyword">mat</span>-hint&gt;Minimum 8 characters&lt;/<span class="hljs-keyword">mat</span>-hint&gt;
            &lt;<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">error</span> *ngIf=<span class="hljs-string">"loginForm.get('password')?.hasError('required')"</span>&gt;
              Password is required
            &lt;/<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">error</span>&gt;
            &lt;<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">error</span> *ngIf=<span class="hljs-string">"loginForm.get('password')?.hasError('minlength')"</span>&gt;
              Password is at least 8 characters long
            &lt;/<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">error</span>&gt;
            &lt;<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">error</span> *ngIf=<span class="hljs-string">"loginForm.get('password')?.hasError('maxlength')"</span>&gt;
              Password cannot be longer than 50 characters
            &lt;/<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">error</span>&gt;
          &lt;/<span class="hljs-keyword">mat</span>-<span class="hljs-keyword">form</span>-field&gt;
        &lt;/div&gt;
        &lt;div fxLayout=<span class="hljs-string">"row"</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">"margin-top"</span>&gt;
          &lt;div *ngIf=<span class="hljs-string">"loginError"</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">"mat-caption error"</span>&gt;{{loginError}}&lt;/div&gt;
          &lt;div <span class="hljs-keyword">class</span>=<span class="hljs-string">"flex-spacer"</span>&gt;&lt;/div&gt;
          &lt;button <span class="hljs-keyword">mat</span>-raised-button <span class="hljs-keyword">type</span>=<span class="hljs-string">"submit"</span> color=<span class="hljs-string">"primary"</span> [disabled]=<span class="hljs-string">"loginForm.invalid"</span>&gt;Login&lt;/button&gt;
        &lt;/div&gt;
      &lt;/<span class="hljs-keyword">form</span>&gt;
    &lt;/<span class="hljs-keyword">mat</span>-card-content&gt;
  &lt;/<span class="hljs-keyword">mat</span>-card&gt;
&lt;/div&gt;
</code></pre>
      <div class="note">
        <p class="Information-Box--PACKT-">The <strong class="screen-text">Login</strong> button is disabled until the email and password meet client site validation rules. Additionally, <code class="Code-In-Text--PACKT-">&lt;mat-form-field&gt;</code> will only display one <code class="Code-In-Text--PACKT-">mat-error</code> at a time, unless you create more space for more errors, so be sure to place your error conditions in the correct order.</p>
      </div>
      <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">Once you're <a id="_idIndexMarker836"/>done implementing the <code class="Code-In-Text--PACKT-">login</code> component, you can now update the home screen to conditionally display or hide the new component we created.</p></li>
      <li class="list" value="6">Update the <code class="Code-In-Text--PACKT-">HomeComponent</code> to clean up the code we added previously, so we can display the <code class="Code-In-Text--PACKT-">LoginComponent</code> when users land on the home page of the app:
        <pre class="programlisting"><code class="hljs applescript"><strong>src/app/home/home.component.ts</strong>
  ...
  template: `
    &lt;<span class="hljs-keyword">div</span> *ngIf=<span class="hljs-string">"displayLogin"</span>&gt;
      &lt;app-login&gt;&lt;/app-login&gt;
    &lt;/<span class="hljs-keyword">div</span>&gt;
    &lt;<span class="hljs-keyword">div</span> *ngIf=<span class="hljs-string">"!displayLogin"</span>&gt;
      &lt;span <span class="hljs-built_in">class</span>=<span class="hljs-string">"mat-display-3"</span>&gt;You <span class="hljs-keyword">get</span> a lemon, you <span class="hljs-keyword">get</span> a lemon, you <span class="hljs-keyword">get</span> a lemon...&lt;/span&gt;
    &lt;/<span class="hljs-keyword">div</span>&gt;
  `,
}) 
export <span class="hljs-built_in">class</span> HomeComponent {
  displayLogin = <span class="hljs-literal">true</span>
  constructor() {
  }
}
</code></pre>
      </li>
    </ol>
    <p class="normal">Your <a id="_idIndexMarker837"/>application should look similar to this screenshot:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_08_06.png"/></figure>
    <p class="packt_figref">Figure 8.6: LemonMart with login</p>
    <p class="normal">There's still <a id="_idIndexMarker838"/>some work to be done in terms of implementing and showing/hiding the <code class="Code-In-Text--PACKT-">sidenav</code> menu, profile, and logout icons given the user's authentication status.</p>
    <h2 class="title" id="_idParaDest-298">Conditional navigation</h2>
    <p class="normal">Conditional navigation is necessary for creating a frustration-free UX. By selectively showing the <a id="_idIndexMarker839"/>elements that the user has access to and hiding the ones they don't have access to, we allow the user to confidently navigate through the application.</p>
    <p class="normal">Let's start by hiding the <code class="Code-In-Text--PACKT-">login</code> component after a user logs in to the application:</p>
    <ol>
      <li class="list" value="1">On the <code class="Code-In-Text--PACKT-">HomeComponent</code>, inject the <code class="Code-In-Text--PACKT-">AuthService</code> into the constructor as a <code class="Code-In-Text--PACKT-">public</code> variable:
        <pre class="programlisting"><code class="hljs typescript"><strong>src/app/home/home.component.simple.ts</strong>
...
<span class="hljs-keyword">import</span> { AuthService } <span class="hljs-keyword">from</span> <span class="hljs-string">'../auth/auth.service'</span>
...
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> HomeComponent { 
  <span class="hljs-keyword">constructor</span>(<strong><span class="hljs-params"><span class="hljs-keyword">public</span></span></strong><span class="hljs-params"> authService: AuthService</span>) {}
}
</code></pre>
      </li>
      <li class="list">Remove the local variable <code class="Code-In-Text--PACKT-">displayLogin</code>, because we can directly tap into the auth status in the template using the <code class="Code-In-Text--PACKT-">async</code> pipe.</li>
      <li class="list">Implement a new template using the <code class="Code-In-Text--PACKT-">ngIf; else</code> syntax, along with the <code class="Code-In-Text--PACKT-">async</code> pipe, as shown here:
        <pre class="programlisting"><code class="hljs applescript"><strong>src/app/home/home.component.ts</strong>
...
  template: `
    &lt;<span class="hljs-keyword">div</span> *ngIf= 
<span class="hljs-string">"(authService.authStatus$ | async)?.isAuthenticated; else doLogin"</span>&gt;
      &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">"mat-display-4"</span>&gt;
        This <span class="hljs-keyword">is</span> LemonMart! The place <span class="hljs-keyword">where</span>
      &lt;/<span class="hljs-keyword">div</span>&gt;
      &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">"mat-display-4"</span>&gt;
        You <span class="hljs-keyword">get</span> a lemon, you <span class="hljs-keyword">get</span> a lemon, you <span class="hljs-keyword">get</span> a lemon...
      &lt;/<span class="hljs-keyword">div</span>&gt;
      &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">"mat-display-4"</span>&gt;
        Everybody gets a lemon.
      &lt;/<span class="hljs-keyword">div</span>&gt;
    &lt;/<span class="hljs-keyword">div</span>&gt;
    &lt;ng-template <span class="hljs-comment">#doLogin&gt;</span>
      &lt;app-login&gt;&lt;/app-login&gt;
    &lt;/ng-template&gt;  
  `,
</code></pre>
        <div class="note">
          <p class="Information-Box--PACKT-">Using the <code class="Code-In-Text--PACKT-">async</code> pipe avoids errors like <code class="Code-In-Text--PACKT-">Error: ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked</code>. Whenever you see this error, stop using local variables and instead use the <code class="Code-In-Text--PACKT-">async</code> pipe. It is the reactive thing to do!</p>
        </div>
      </li>
      <li class="list">On the <code class="Code-In-Text--PACKT-">AppComponent</code>, we will follow a similar pattern by injecting <code class="Code-In-Text--PACKT-">AuthService</code> as a <code class="Code-In-Text--PACKT-">public</code> variable:
        <pre class="programlisting"><code class="hljs typescript"><strong>src/app/app.component.ts</strong>
<span class="hljs-keyword">import</span> { Component, OnInit } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>
<span class="hljs-keyword">import</span> { AuthService } <span class="hljs-keyword">from</span> <span class="hljs-string">'./auth/auth.service'</span>
...
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AppComponent <span class="hljs-keyword">implements</span> OnInit { 
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">..., </span><strong><span class="hljs-params"><span class="hljs-keyword">public</span> authService: AuthService</span></strong>) {
  }
  ngOnInit(): <span class="hljs-built_in">void</span> {}
  ...
}
</code></pre>
      </li>
      <li class="list">Update <code class="Code-In-Text--PACKT-">mat-toolbar</code> in the template, so that we monitor both <code class="Code-In-Text--PACKT-">authStatus$</code> and <code class="Code-In-Text--PACKT-">currentUser$</code> using the <code class="Code-In-Text--PACKT-">async</code> pipe:
        <pre class="programlisting"><code class="hljs 1c">      &lt;mat-toolbar ...
        <strong>*ngIf=<span class="hljs-string">"{</span></strong>
<strong>          status: authService.authStatus$ <span class="hljs-string">| async,</span></strong>
<strong>          user: authService.currentUser$ <span class="hljs-string">| async</span></strong>
<strong>        } as auth;<span class="hljs-string">"</span></strong><span class="hljs-string">&gt;</span>
</code></pre>
      </li>
      <li class="list" value="6">Use <code class="Code-In-Text--PACKT-">*ngIf</code> to hide <a id="_idIndexMarker840"/>all buttons meant for logged-in users:
        <pre class="programlisting"><code class="hljs stylus"><strong>src/app/app<span class="hljs-selector-class">.component</span><span class="hljs-selector-class">.ts</span></strong>
&lt;<span class="hljs-selector-tag">button</span> <strong>*ngIf=<span class="hljs-string">"auth?.status?.isAuthenticated"</span></strong> ... &gt;
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">Now, when a user is logged out, your toolbar should look all clean, with no buttons, as shown here:</p>
        <figure class="mediaobject"><img alt="" src="../Images/B14094_08_07.png"/></figure>
        <p class="packt_figref">Figure 8.7: The LemonMart toolbar before a user logs in</p>
      </li>
      <li class="list">We can <a id="_idIndexMarker841"/>also swap out the generic <code class="Code-In-Text--PACKT-">account_circle</code> icon in the <code class="Code-In-Text--PACKT-">profile</code> button if the user has a picture:
        <pre class="programlisting"><code class="hljs stylus"><strong>src/app/app<span class="hljs-selector-class">.component</span><span class="hljs-selector-class">.ts</span></strong>
styles: [
`
  <span class="hljs-selector-class">.image-cropper</span> {
    <span class="hljs-attribute">width</span>: <span class="hljs-number">40px</span>;
    <span class="hljs-attribute">height</span>: <span class="hljs-number">40px</span>;
    <span class="hljs-attribute">position</span>: relative;
    <span class="hljs-attribute">overflow</span>: hidden;
    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span>;
    <span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">8px</span>;
  }
`],
template: `
  ...
  &lt;<span class="hljs-selector-tag">button</span>
    *ngIf=<span class="hljs-string">"auth?.status?.isAuthenticated"</span>
    mat-mini-fab
    routerLink=<span class="hljs-string">"/user/profile"</span>
    matTooltip=<span class="hljs-string">"Profile"</span>
    aria-label=<span class="hljs-string">"User Profile"</span>
  &gt;
    &lt;<span class="hljs-selector-tag">img</span> *ngIf=<span class="hljs-string">"auth?.user?.picture"</span> class=<span class="hljs-string">"image-cropper"</span>
      [src]=<span class="hljs-string">"auth?.user?.picture"</span> /&gt;
    &lt;mat-<span class="hljs-attribute">icon</span> *ngIf=<span class="hljs-string">"!auth?.user?.picture"</span>&gt;account_circle&lt;/mat-icon&gt;
  &lt;/button&gt;
</code></pre>
      </li>
    </ol>
    <p class="normal">We now have a highly functional toolbar that reacts to the auth status of the application and is additionally able to display information that belongs to the logged-in user.</p>
    <h2 class="title" id="_idParaDest-299">Common validations for forms</h2>
    <p class="normal">Before we move on, we need to refactor the validations for <code class="Code-In-Text--PACKT-">LoginComponent</code>. As we implement more forms in <em class="italics">Chapter 11</em>, <em class="italics">Recipes – Reusability, Routing, and Caching</em>, you will <a id="_idIndexMarker842"/>realize that it gets tedious, fast, to repeatedly type out form validations in either template or reactive forms. Part of the allure of reactive forms is <a id="_idIndexMarker843"/>that they are driven by code, so we can easily extract the validations to a shared class, unit test, and reuse them, as follows:</p>
    <ol>
      <li class="list" value="1">Create a <code class="Code-In-Text--PACKT-">validations.ts</code> file under the <code class="Code-In-Text--PACKT-">common</code> folder.</li>
      <li class="list">Implement email and password validations:
        <pre class="programlisting"><code class="hljs javascript"><strong>src/app/common/validations.ts</strong>
<span class="hljs-keyword">import</span> { Validators } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/forms'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> EmailValidation = [
  Validators.required, Validators.email
]
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> PasswordValidation = [
  Validators.required,
  Validators.minLength(<span class="hljs-number">8</span>),
  Validators.maxLength(<span class="hljs-number">50</span>),
]
</code></pre>
      </li>
    </ol>
    <div class="note">
      <p class="Information-Box--PACKT-">Depending on your password validation needs, you can use a <code class="Code-In-Text--PACKT-">RegEx</code> pattern with the <code class="Code-In-Text--PACKT-">Validations.pattern()</code> function to enforce password complexity rules or leverage the OWASP npm package, <code class="Code-In-Text--PACKT-">owasp-password-strength-test</code>, to enable pass-phrases, as well as set more flexible password requirements. See the link to the OWASP authentication general guidelines in the <em class="italics">Further reading</em> section.</p>
    </div>
    <ol>
      <li class="list" value="3">Update the <code class="Code-In-Text--PACKT-">login</code> component with the new validations:
        <pre class="programlisting"><code class="hljs kotlin"><strong>src/app/login/login.component.ts</strong>
<span class="hljs-keyword">import</span> { EmailValidation, PasswordValidation } from <span class="hljs-string">'../common/validations'</span>
  ...
    <span class="hljs-keyword">this</span>.loginForm = <span class="hljs-keyword">this</span>.formBuilder.group({
      email: [<span class="hljs-string">''</span>, EmailValidation],
      password: [<span class="hljs-string">''</span>, PasswordValidation],
    })
</code></pre>
      </li>
    </ol>
    <p class="normal">Next, let's encapsulate some common UI behavior in an Angular service.</p>
    <h2 class="title" id="_idParaDest-300">UI service</h2>
    <p class="normal">As we start dealing with complicated workflows, such as the auth workflow, it is important to <a id="_idIndexMarker844"/>be able to programmatically display a toast notification for the user. In other cases, we may want to ask for a confirmation before executing a destructive action with a more intrusive pop-up notification.</p>
    <p class="normal">No matter what component library you use, it gets tedious to recode the same boilerplate just to display a quick notification. A UI service can neatly encapsulate a default implementation that can also be customized as needed.</p>
    <p class="normal">In the UI service, we will implement a <code class="Code-In-Text--PACKT-">showToast</code> and a <code class="Code-In-Text--PACKT-">showDialog</code> function that can trigger notifications or prompt users for a decision, in such a manner that we can use it within the code that implements our business logic.</p>
    <p class="normal">Let's get started:</p>
    <ol>
      <li class="list" value="1">Create a new service named <code class="Code-In-Text--PACKT-">ui</code> under <code class="Code-In-Text--PACKT-">common</code>.</li>
      <li class="list">Implement a <code class="Code-In-Text--PACKT-">showToast</code> function using <code class="Code-In-Text--PACKT-">MatSnackBar</code>:<div class="packt_tip">
          <p>Check <a id="_idIndexMarker845"/>out the documentation for <code class="Code-In-Text--PACKT-">MatSnackBar</code> at <a href="https://material.angular.io"><span class="url">https://material.angular.io</span></a>.</p>
        </div>
        <div class="note">
          <p class="Information-Box--PACKT-">Don't forget to update <code class="Code-In-Text--PACKT-">app.module.ts</code> and <code class="Code-In-Text--PACKT-">material.module.ts</code> with the various dependencies as they are introduced.</p>
        </div>
        <pre class="programlisting"><code class="hljs groovy"><strong>src<span class="hljs-regexp">/app/</span>common/ui.service.ts</strong>
<span class="hljs-meta">@Injectable</span>({
<span class="hljs-symbol">  providedIn:</span> <span class="hljs-string">'root'</span>,
})
export <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UiService</span> {</span>
  constructor(<span class="hljs-keyword">private</span> <span class="hljs-string">snackBar:</span> MatSnackBar, <span class="hljs-keyword">private</span> <span class="hljs-string">dialog:</span> MatDialog) {}
  showToast(<span class="hljs-string">message:</span> string, action = <span class="hljs-string">'Close'</span>, config?: MatSnackBarConfig) {
    <span class="hljs-keyword">this</span>.snackBar.open( message,
    action,
    config || { <span class="hljs-string">duration:</span> <span class="hljs-number">7000</span>}
    )
  }
...
}
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">For a <code class="Code-In-Text--PACKT-">showDialog</code> function using <code class="Code-In-Text--PACKT-">MatDialog</code>, we must implement a basic <code class="Code-In-Text--PACKT-">dialog</code> component.</p>
        <div class="packt_tip">
          <p>Check <a id="_idIndexMarker846"/>out the documentation for <code class="Code-In-Text--PACKT-">MatDialog</code> at <a href="https://material.angular.io"><span class="url">https://material.angular.io</span></a>.</p>
        </div>
      </li>
      <li class="list">Add a <a id="_idIndexMarker847"/>new component named <code class="Code-In-Text--PACKT-">simpleDialog</code> under the <code class="Code-In-Text--PACKT-">common</code> folder provided in <code class="Code-In-Text--PACKT-">app.module.ts</code> with inline templates and styling, skip testing, and a flat folder structure:
        <pre class="programlisting"><code class="hljs dust"><strong><span class="xml">app/common/simple-dialog.component.ts</span></strong><span class="xml">
import </span><span class="hljs-template-variable">{ Component, Inject }</span><span class="xml"> from '@angular/core'
import </span><span class="hljs-template-variable">{ MAT_DIALOG_DATA, MatDialogRef }</span><span class="xml"> from '@angular/material/dialog'
@Component(</span><span class="hljs-template-variable">{
  // prettier-ignore
  template: `
    &lt;h2 mat-dialog-title&gt;{{ data.title }</span><span class="xml">}<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mat-dialog-content</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-variable">{{ data.content }</span><span class="xml">}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">mat-dialog-content</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mat-dialog-actions</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"flex-spacer"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">mat-button</span> <span class="hljs-attr">mat-dialog-close</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">"data.cancelText"</span>&gt;</span>
        </span><span class="hljs-template-variable">{{ data.cancelText }</span><span class="xml">}
      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">mat-button</span> <span class="hljs-attr">mat-button-raised</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"primary"</span> [<span class="hljs-attr">mat-dialog-close</span>]=<span class="hljs-string">"true"</span>
        <span class="hljs-attr">cdkFocusInitial</span>&gt;</span>
        </span><span class="hljs-template-variable">{{ data.okText }</span><span class="xml">}
      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">mat-dialog-actions</span>&gt;</span>
  `
})
export class SimpleDialogComponent </span><span class="hljs-template-variable">{
  constructor(
    public dialogRef: MatDialogRef&lt;SimpleDialogComponent, boolean&gt;,
    @Inject(MAT_DIALOG_DATA) public data: any
  ) {}</span><span class="xml">
}
</span></code></pre>
        <div class="note">
          <p class="Information-Box--PACKT-">Note that <code class="Code-In-Text--PACKT-">SimpleDialogComponent</code> should not have an application selector like <code class="Code-In-Text--PACKT-">selector: 'app-simple-dialog'</code> since we only plan to use it with <code class="Code-In-Text--PACKT-">UiService</code>. Remove this property from your component.</p>
        </div>
      </li>
      <li class="list">Then, implement a <code class="Code-In-Text--PACKT-">showDialog</code> function using <code class="Code-In-Text--PACKT-">MatDialog</code> to display <a id="_idIndexMarker848"/>the <code class="Code-In-Text--PACKT-">SimpleDialogComponent</code>:
        <pre class="programlisting"><code class="hljs vim"><strong>app/common/ui.service.<span class="hljs-keyword">ts</span></strong>
...
showDialog(
  title: <span class="hljs-built_in">string</span>,
  conten<span class="hljs-variable">t:</span> <span class="hljs-built_in">string</span>,
  okText = <span class="hljs-string">'OK'</span>,
  cancelText?: <span class="hljs-built_in">string</span>,
  customConfig?: MatDialogConfig
): Observable<span class="hljs-symbol">&lt;boolean&gt;</span> {
  const dialogRef = this.dialog.<span class="hljs-keyword">open</span>(
    SimpleDialogComponent,
    customConfig || {
      width: <span class="hljs-string">'300px'</span>,
      dat<span class="hljs-variable">a:</span> { title, content, okText, cancelText },
    }
  )
  <span class="hljs-keyword">return</span> dialogRef.afterClosed()
}
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-"><code class="Code-In-Text--PACKT-">ShowDialog</code> returns an <code class="Code-In-Text--PACKT-">Observable&lt;boolean&gt;</code>, so you can implement a follow-on action, depending on what selection the user makes. Clicking on <strong class="screen-text">OK</strong> will return <code class="Code-In-Text--PACKT-">true</code>, and <strong class="screen-text">Cancel</strong> will return <code class="Code-In-Text--PACKT-">false</code>.</p>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">In <code class="Code-In-Text--PACKT-">SimpleDialogComponent</code>, using <code class="Code-In-Text--PACKT-">@Inject</code>, we're able to use all variables sent by <code class="Code-In-Text--PACKT-">showDialog</code> to customize the content of the dialog.</p>
      </li>
      <li class="list">In <code class="Code-In-Text--PACKT-">app.module.ts</code>, declare <code class="Code-In-Text--PACKT-">SimpleDialogComponent</code> as an <code class="Code-In-Text--PACKT-">entry</code> component:
        <pre class="programlisting"><code class="hljs ruby"><strong>src/app/app<span class="hljs-class">.<span class="hljs-keyword">module</span>.<span class="hljs-title">ts</span></span></strong>
@NgModule({
  ...
  <span class="hljs-symbol">bootstrap:</span> [AppComponent],
  <strong><span class="hljs-symbol">entryComponents:</span> [SimpleDialogComponent],</strong>
})
Export <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppModule</span> {}</span>
</code></pre>
        <div class="note">
          <p class="Information-Box--PACKT-">Note that with the Ivy rendering engine, <code class="Code-In-Text--PACKT-">entryComponents</code> should be unnecessary and is deprecated in Angular 9. However, at the time of publishing, it is still required to declare this component as an <code class="Code-In-Text--PACKT-">entry</code> component.</p>
        </div>
      </li>
      <li class="list">Update <a id="_idIndexMarker849"/>the <code class="Code-In-Text--PACKT-">login()</code> function on the <code class="Code-In-Text--PACKT-">LoginComponent</code> to display a toast message after login:
        <pre class="programlisting"><code class="hljs oxygene"><strong>src/app/login/login.component.ts</strong>
import <span class="hljs-comment">{ UiService }</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'../common/ui.service'</span>
...
<span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">(... , </span></span><strong><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">private</span> uiService: UiService</span></span></strong><span class="hljs-function"><span class="hljs-params">)</span>
  ...
  <span class="hljs-title">async</span> <span class="hljs-title">login</span><span class="hljs-params">(submittedForm: FormGroup)</span> <span class="hljs-comment">{
    ...
    tap(([authStatus, user]) =&gt; {
      </span></span><strong><span class="hljs-function"><span class="hljs-comment">this.uiService.showToast(</span></span></strong><span class="hljs-function"><span class="hljs-comment">
</span></span><strong><span class="hljs-function"><span class="hljs-comment">        `Welcome ${user.fullName}</span>! <span class="hljs-title">Role</span>:</span> $<span class="hljs-comment">{user.role}</span>`</strong>
<strong>      )</strong>
      ...
    })
 ...
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">Now, a toast message will appear after a user logs in, as shown:</p>
      
      <figure class="mediaobject"><img alt="" src="../Images/B14094_08_08.png"/></figure>
      <p class="packt_figref">Figure 8.8: Material snackbar</p>
      <div class="packt_tip">
        <p>The <code class="Code-In-Text--PACKT-">snackBar</code> will either take up the full width of the screen or a portion, depending on the size of the browser.</p>
      </div></li>
      <li class="list" value="7">Experiment with displaying a dialog instead:
        <pre class="programlisting"><code class="hljs pgsql"><strong>src/app/<span class="hljs-keyword">login</span>/<span class="hljs-keyword">login</span>.component.ts</strong>
this.uiService.showDialog(
  `Welcome ${<span class="hljs-keyword">user</span>.fullName}!`, `<span class="hljs-keyword">Role</span>: ${<span class="hljs-keyword">user</span>.<span class="hljs-keyword">role</span>}`
)
</code></pre>
      </li>
    </ol>
    <p class="normal">Now that you've verified that both <code class="Code-In-Text--PACKT-">showToast</code> and <code class="Code-In-Text--PACKT-">showDialog</code> work, which one do you prefer? My rule of thumb is that unless the user is about to take an irreversible action, you should choose toast messages over dialogs, so you don't interrupt the user's workflow.</p>
    <p class="normal">Next, let's implement <a id="_idIndexMarker850"/>an application-wide side navigation experience as an alternative to the toolbar-based navigation we already have, so that users can switch between modules with ease.</p>
    <h2 class="title" id="_idParaDest-301">Side navigation</h2>
    <p class="normal">Enable mobile-first workflows and provide an easy navigation mechanism to quickly jump to the <a id="_idIndexMarker851"/>desired functionality. Using the authentication service, given a user's current role, only display the links for features they can access. We will be implementing the side navigation mock-up as follows:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_08_09.png"/></figure>
    <p class="packt_figref">Figure 8.9: Side navigation mock-up</p>
    <p class="normal">Let's implement the code for the side navigation as a separate component, so that it is easier to maintain:</p>
    <ol>
      <li class="list" value="1">In the root of the application, create a component named <code class="Code-In-Text--PACKT-">NavigationMenu</code> with inline templates and styles.<div class="packt_tip">
          <p>The side navigation isn't technically required until after a user is logged in. However, in order to be able to launch the side navigation menu from the toolbar, we need to be able to trigger it from <code class="Code-In-Text--PACKT-">AppComponent</code>. Since this component will be simple, we will eagerly load it. To do this lazily, Angular does have a Dynamic Component Loader pattern, which has a high implementation overhead that will only make sense if multi-hundred kilobyte savings are made.</p>
        </div>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-"><code class="Code-In-Text--PACKT-">SideNav</code> will be triggered from the toolbar, and it comes with a <code class="Code-In-Text--PACKT-">&lt;mat-sidenav-container&gt;</code> parent container that hosts the <code class="Code-In-Text--PACKT-">SideNav</code> itself and the content of the application. So, we will need to render all application content by placing the <code class="Code-In-Text--PACKT-">&lt;router-outlet&gt;</code> inside <code class="Code-In-Text--PACKT-">&lt;mat-sidenav-content&gt;</code>.</p>
      </li>
      <li class="list">In <code class="Code-In-Text--PACKT-">AppComponent</code>, define some styles that will ensure that the web application <a id="_idIndexMarker852"/>will expand to fill the entire page and remain properly scrollable for desktop and mobile scenarios:
        <pre class="programlisting"><code class="hljs yaml"><strong><span class="hljs-string">src/app/app.component.ts</span></strong>
<span class="hljs-attr">styles:</span> <span class="hljs-string">[</span>
  <span class="hljs-string">`</span>
    <span class="hljs-string">.app-container</span> <span class="hljs-string">{</span>
      <span class="hljs-attr">display:</span> <span class="hljs-string">flex;</span>
      <span class="hljs-attr">flex-direction:</span> <span class="hljs-string">column;</span>
      <span class="hljs-attr">position:</span> <span class="hljs-string">absolute;</span>
      <span class="hljs-attr">top:</span> <span class="hljs-number">0</span><span class="hljs-string">;</span>
      <span class="hljs-attr">bottom:</span> <span class="hljs-number">0</span><span class="hljs-string">;</span>
      <span class="hljs-attr">left:</span> <span class="hljs-number">0</span><span class="hljs-string">;</span>
      <span class="hljs-attr">right:</span> <span class="hljs-number">0</span><span class="hljs-string">;</span>
    <span class="hljs-string">}</span>
    <span class="hljs-string">.app-is-mobile</span> <span class="hljs-string">.app-toolbar</span> <span class="hljs-string">{</span>
      <span class="hljs-attr">position:</span> <span class="hljs-string">fixed;</span>
      <span class="hljs-attr">z-index:</span> <span class="hljs-number">2</span><span class="hljs-string">;</span>
    <span class="hljs-string">}</span>
    <span class="hljs-string">.app-sidenav-container</span> <span class="hljs-string">{</span>
      <span class="hljs-attr">flex:</span> <span class="hljs-number">1</span><span class="hljs-string">;</span>
    <span class="hljs-string">}</span>
    <span class="hljs-string">.app-is-mobile</span> <span class="hljs-string">.app-sidenav-container</span> <span class="hljs-string">{</span>
      <span class="hljs-attr">flex:</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-string">auto;</span>
    <span class="hljs-string">}</span>
    <span class="hljs-string">mat-sidenav</span> <span class="hljs-string">{</span>
      <span class="hljs-attr">width:</span> <span class="hljs-string">200px;</span>
    <span class="hljs-string">}</span>
    <span class="hljs-string">.image-cropper</span> <span class="hljs-string">{</span>
      <span class="hljs-attr">width:</span> <span class="hljs-string">40px;</span>
      <span class="hljs-attr">height:</span> <span class="hljs-string">40px;</span>
      <span class="hljs-attr">position:</span> <span class="hljs-string">relative;</span>
      <span class="hljs-attr">overflow:</span> <span class="hljs-string">hidden;</span>
      <span class="hljs-attr">border-radius:</span> <span class="hljs-number">50</span><span class="hljs-string">%;</span>
      <span class="hljs-attr">margin-top:</span> <span class="hljs-string">-8px;</span>
    <span class="hljs-string">}</span>
  <span class="hljs-string">`,</span>
<span class="hljs-string">],</span>
</code></pre>
      </li>
      <li class="list">Inject the <code class="Code-In-Text--PACKT-">MediaObserver</code> service from Angular Flex Layout in <code class="Code-In-Text--PACKT-">AppComponent</code>. Also, implement <code class="Code-In-Text--PACKT-">OnInit</code> and <code class="Code-In-Text--PACKT-">OnDestory</code>, initialize <code class="Code-In-Text--PACKT-">SubSink</code>, and add <a id="_idIndexMarker853"/>a Boolean property named <code class="Code-In-Text--PACKT-">opened</code>:
        <pre class="programlisting"><code class="hljs typescript"><strong>src/app/app.component.ts</strong>
<span class="hljs-keyword">import</span> { MediaObserver } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/flex-layout'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AppComponent <span class="hljs-keyword">implements</span> <strong>OnInit, OnDestroy</strong> {
  <strong><span class="hljs-keyword">private</span> subs = <span class="hljs-keyword">new</span> SubSink()</strong>
<strong>  opened: <span class="hljs-built_in">boolean</span></strong>
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">
    ...
</span><strong><span class="hljs-params">    <span class="hljs-keyword">public</span> media: MediaObserver</span></strong><span class="hljs-params">
  </span>) {
  ...
  }
  ngOnDestroy() {
    <span class="hljs-keyword">this</span>.subs.unsubscribe()
  }
  ngOnInit(): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Method not implemented.'</span>)
  }
}
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">To automatically determine the open/closed status of the side navigation, we need to monitor the media observer and the auth status. When the user logs in, we would like to show the side navigation, and hide it when the user logs out. We can do this with settings <code class="Code-In-Text--PACKT-">opened</code> to the value of <code class="Code-In-Text--PACKT-">authStatus$.isAuthenticated</code>. However, if we only consider <code class="Code-In-Text--PACKT-">isAuthenticated</code>, and the user is on a mobile device, we will create a less than ideal UX. Watching for the media observer's <code class="Code-In-Text--PACKT-">mediaValue</code>, we can check to see whether the screen size is set to extra small, or <code class="Code-In-Text--PACKT-">xs</code>; if so, we can keep the side navigation closed.</p>
      </li>
      <li class="list">Update <code class="Code-In-Text--PACKT-">ngOnInit</code> to implement the dynamic side navigation open/closed logic:
        <pre class="programlisting"><code class="hljs kotlin"><strong>src/app/app.component.ts</strong>
  ngOnInit() {
    <span class="hljs-keyword">this</span>.subs.sink = combineLatest([
      <span class="hljs-keyword">this</span>.media.asObservable(),
      <span class="hljs-keyword">this</span>.authService.authStatus$,
    ])
      .pipe(
        tap(([mediaValue, authStatus]) =&gt; {
          <span class="hljs-keyword">if</span> (!authStatus?.isAuthenticated) {
            <span class="hljs-keyword">this</span>.opened = <span class="hljs-literal">false</span>
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (mediaValue[<span class="hljs-number">0</span>].mqAlias === <span class="hljs-string">'xs'</span>) {
              <span class="hljs-keyword">this</span>.opened = <span class="hljs-literal">false</span>
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">this</span>.opened = <span class="hljs-literal">true</span>
            }
          }
        })
      )
      .subscribe()
  }
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">By monitoring both the media and <code class="Code-In-Text--PACKT-">authStatus$</code> streams, we can consider unauthenticated scenarios where the side navigation should not be opened even if there's enough screen space.</p>
      </li>
      <li class="list">Update the <a id="_idIndexMarker854"/>template with a responsive <code class="Code-In-Text--PACKT-">SideNav</code> that will slide over the content in mobile or push the content aside in desktop scenarios:
        <pre class="programlisting"><code class="hljs stata"><strong>src/<span class="hljs-keyword">app</span>/<span class="hljs-keyword">app</span>.component.ts</strong>
...
<span class="hljs-comment">// prettier-ignore</span>
template: `
  <strong>&lt;div <span class="hljs-keyword">class</span>=<span class="hljs-string">"app-container"</span>&gt;</strong>
  &lt;<span class="hljs-keyword">mat</span>-toolbar color=<span class="hljs-string">"primary"</span> fxLayoutGap=<span class="hljs-string">"8px"</span>
    <strong><span class="hljs-keyword">class</span>=<span class="hljs-string">"app-toolbar"</span></strong>
    <strong>[<span class="hljs-keyword">class</span>.<span class="hljs-keyword">app</span>-is-mobile]=<span class="hljs-string">"media.isActive('xs')"</span></strong>
<span class="hljs-comment">    *ngIf="{</span>
      status: authService.authStatus$ | async,
      user: authService.currentUser$ | async
    } <span class="hljs-keyword">as</span> auth;"
  &gt;
    &lt;button *ngIf=<span class="hljs-string">"auth?.status?.isAuthenticated"</span>
      <span class="hljs-keyword">mat</span>-icon-button <strong>(click)=<span class="hljs-string">"sidenav.toggle()"</span></strong>
    &gt;
      &lt;<span class="hljs-keyword">mat</span>-icon&gt;menu&lt;/<span class="hljs-keyword">mat</span>-icon&gt;
    &lt;/button&gt;
    ...
  &lt;/<span class="hljs-keyword">mat</span>-toolbar&gt;
  <strong>&lt;<span class="hljs-keyword">mat</span>-sidenav-container <span class="hljs-keyword">class</span>=<span class="hljs-string">"app-sidenav-container"</span>&gt;</strong>
    <strong>&lt;<span class="hljs-keyword">mat</span>-sidenav #sidenav</strong>
      <strong>[mode]=<span class="hljs-string">"media.isActive('xs') ? 'over' : 'side'"</span></strong>
      <strong>[fixedInViewport]=<span class="hljs-string">"media.isActive('xs')"</span></strong>
      <strong>fixedTopGap=<span class="hljs-string">"56"</span> [(opened)]=<span class="hljs-string">"opened"</span></strong>
    <strong>&gt;</strong>
      <strong>&lt;<span class="hljs-keyword">app</span>-navigation-menu&gt;&lt;/<span class="hljs-keyword">app</span>-navigation-menu&gt;</strong>
<strong>    &lt;/<span class="hljs-keyword">mat</span>-sidenav&gt;</strong>
<strong>    &lt;<span class="hljs-keyword">mat</span>-sidenav-content&gt;</strong>
      &lt;router-outlet&gt;&lt;/router-outlet&gt;
    <strong>&lt;/<span class="hljs-keyword">mat</span>-sidenav-content&gt;</strong>
<strong>  &lt;/<span class="hljs-keyword">mat</span>-sidenav-container&gt;</strong>
<strong>  &lt;/div&gt;</strong>
`,
</code></pre>
      
      <div class="note">
        <p>The preceding template leverages the Angular Flex Layout media observer that was injected earlier for a responsive implementation.</p>
      </div>
      <div class="packt_tip">
        <p>You can use the <code class="Code-In-Text--PACKT-">// prettier-ignore</code> directive above your template to prevent Prettier from breaking up your template into too many lines, which can hurt readability in certain conditions similar to this one.</p>
      </div>
      <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">We will implement <a id="_idIndexMarker855"/>navigational links in <code class="Code-In-Text--PACKT-">NavigationMenuComponent</code>. The number of links in our application will likely grow over time and be subject to various role-based business rules. Therefore, if we were to implement these links in <code class="Code-In-Text--PACKT-">app.component.ts</code>, we would risk that file getting too large. In addition, we don't want <code class="Code-In-Text--PACKT-">app.component.ts</code> to change very often, since changes made there can impact the entire application. It is a good practice to implement the links in a separate component.</p></li>
      <li class="list" value="6">Implement navigational links in <code class="Code-In-Text--PACKT-">NavigationMenuComponent</code>:
        <pre class="programlisting"><code class="hljs xml"><strong>src/app/navigation-menu/navigation-menu.component.ts</strong>
...
  styles: [
    `
      .active-link {
        font-weight: bold;
        border-left: 3px solid green;
      }
    `,
  ],
  template: `
    <span class="hljs-tag">&lt;<span class="hljs-name">mat-nav-list</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">matSubheader</span>&gt;</span>Manager<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">mat-list-item</span>
        <span class="hljs-attr">routerLinkActive</span>=<span class="hljs-string">"active-link"</span>
        <span class="hljs-attr">routerLink</span>=<span class="hljs-string">"/manager/users"</span>&gt;</span>
          Users
      <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">mat-list-item</span>
        <span class="hljs-attr">routerLinkActive</span>=<span class="hljs-string">"active-link"</span>
        <span class="hljs-attr">routerLink</span>=<span class="hljs-string">"/manager/receipts"</span>&gt;</span>
          Receipts
      <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">matSubheader</span>&gt;</span>Inventory<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">mat-list-item</span>
        <span class="hljs-attr">routerLinkActive</span>=<span class="hljs-string">"active-link"</span>
        <span class="hljs-attr">routerLink</span>=<span class="hljs-string">"/inventory/stockEntry"</span>&gt;</span>
          Stock Entry
      <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">mat-list-item</span>
        <span class="hljs-attr">routerLinkActive</span>=<span class="hljs-string">"active-link"</span>
        <span class="hljs-attr">routerLink</span>=<span class="hljs-string">"/inventory/products"</span>&gt;</span>
          Products
      <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">mat-list-item</span>
        <span class="hljs-attr">routerLinkActive</span>=<span class="hljs-string">"active-link"</span>
        <span class="hljs-attr">routerLink</span>=<span class="hljs-string">"/inventory/categories"</span>&gt;</span>
          Categories
      <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">matSubheader</span>&gt;</span>Clerk<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">mat-list-item</span>
        <span class="hljs-attr">routerLinkActive</span>=<span class="hljs-string">"active-link"</span>
        <span class="hljs-attr">routerLink</span>=<span class="hljs-string">"/pos"</span>&gt;</span>
          POS
      <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">mat-nav-list</span>&gt;</span>
  `,
...
</code></pre>
      </li>
    </ol>
    <p class="normal"><code class="Code-In-Text--PACKT-">&lt;mat-nav-list&gt;</code> is functionally <a id="_idIndexMarker856"/>equivalent to <code class="Code-In-Text--PACKT-">&lt;mat-list&gt;</code>, so you can use the documentation of <code class="Code-In-Text--PACKT-">MatList</code> for layout purposes. Observe the <code class="Code-In-Text--PACKT-">subheaders</code> for <strong class="screen-text">Manager</strong>, <strong class="screen-text">Inventory</strong>, and <strong class="screen-text">Clerk</strong> here:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_08_10.png"/></figure>
    <p class="packt_figref">Figure 8.10: The Manager dashboard showing Receipt Lookup on desktop</p>
    <p class="normal"><code class="Code-In-Text--PACKT-">routerLinkActive="active-link"</code> highlights the selected <strong class="screen-text">Receipts</strong> route, as shown in the preceding screenshot.</p>
    <p class="normal">Additionally, you <a id="_idIndexMarker857"/>can see the difference in appearance and behavior on mobile devices as follows:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_08_11.png"/></figure>
    <p class="packt_figref">Figure 8.11: The Manager dashboard showing Receipt Lookup on mobile</p>
    <p class="normal">Next, let's <a id="_idIndexMarker858"/>implement role-based routing.</p>
    <h1 class="title" id="_idParaDest-302">Role-based routing using guards</h1>
    <p class="normal">This is the most elemental and important part of your application. With lazy loading, we have ensured <a id="_idIndexMarker859"/>that only the bare minimum number of assets will be loaded to enable a user to log in.</p>
    <p class="normal">Once a <a id="_idIndexMarker860"/>user logs in, they should be routed to the appropriate landing screen as per their user role, so they're not guessing how they need to use the application. For example, a cashier needs to only access the point of sale (POS) to check out customers, so they can automatically be routed to that screen.</p>
    <p class="normal">The following is a mock-up of the POS screen:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_08_12.png"/></figure>
    <p class="packt_figref">Figure 8.12: A POS screen mock-up</p>
    <p class="normal">Let's ensure that users get routed to the appropriate page after logging in by updating the <code class="Code-In-Text--PACKT-">LoginComponent</code>.</p>
    <p class="normal">Update the <code class="Code-In-Text--PACKT-">login</code> logic to route per role in the function named <code class="Code-In-Text--PACKT-">homeRoutePerRole</code>:</p>
    <pre class="programlisting"><code class="hljs groovy"><strong>app<span class="hljs-regexp">/src/</span>login/login.component.ts</strong>
async login(<span class="hljs-string">submittedForm:</span> FormGroup) {
  ...
    <span class="hljs-keyword">this</span>.router.navigate([
      <span class="hljs-keyword">this</span>.redirectUrl ||
      <strong><span class="hljs-keyword">this</span>.homeRoutePerRole(user.role <span class="hljs-keyword">as</span> Role)</strong>
    ])
  ...
}
<strong><span class="hljs-keyword">private</span> homeRoutePerRole(<span class="hljs-string">role:</span> Role) {</strong>
<strong>  <span class="hljs-keyword">switch</span> (role) {</strong>
<strong>    <span class="hljs-keyword">case</span> Role.<span class="hljs-string">Cashier:</span></strong>
<strong>      <span class="hljs-keyword">return</span> <span class="hljs-string">'/pos'</span></strong>
<strong>    <span class="hljs-keyword">case</span> Role.<span class="hljs-string">Clerk:</span></strong>
<strong>      <span class="hljs-keyword">return</span> <span class="hljs-string">'/inventory'</span></strong>
<strong>    <span class="hljs-keyword">case</span> Role.<span class="hljs-string">Manager:</span></strong>
<strong>      <span class="hljs-keyword">return</span> <span class="hljs-string">'/manager'</span></strong>
<strong><span class="hljs-symbol">    default:</span></strong>
<strong>      <span class="hljs-keyword">return</span> <span class="hljs-string">'/user/profile'</span></strong>
<strong>  }</strong>
<strong>}</strong>
</code></pre>
    <p class="normal">Similarly, clerks <a id="_idIndexMarker861"/>and managers are routed to their landing screens to access the features they need to accomplish their tasks, as shown earlier. Since we <a id="_idIndexMarker862"/>have implemented a default manager role, the corresponding landing experience will be launched automatically. The other side of the coin is intentional and unintentional attempts to access routes that a user isn't meant to have access to. In the next section, you will learn about router guards that can help to check authentication and even load requisite data before the form is rendered.</p>
    <h2 class="title" id="_idParaDest-303">Router guards</h2>
    <p class="normal">Router guards enable <a id="_idIndexMarker863"/>the further decoupling and reuse of logic, and greater control over the component life cycle.</p>
    <p class="normal">Here are the four major guards you will most likely use:</p>
    <ol>
      <li class="list" value="1"><code class="Code-In-Text--PACKT-">CanActivate</code> and <code class="Code-In-Text--PACKT-">CanActivateChild</code><code class="Code-In-Text--PACKT-"><a id="_idIndexMarker864"/></code>: Used <a id="_idIndexMarker865"/>for checking auth access to a route</li>
      <li class="list"><code class="Code-In-Text--PACKT-">CanDeactivate</code>: Used to <a id="_idIndexMarker866"/>ask permission before navigating away from a route</li>
      <li class="list"><code class="Code-In-Text--PACKT-">Resolve</code>: Allows <a id="_idIndexMarker867"/>the pre-fetching of data from route parameters</li>
      <li class="list"><code class="Code-In-Text--PACKT-">CanLoad</code>: Allows <a id="_idIndexMarker868"/>custom logic to execute before loading feature module assets</li>
    </ol>
    <p class="normal">Refer to the following sections to discover how to leverage <code class="Code-In-Text--PACKT-">CanActivate</code> and <code class="Code-In-Text--PACKT-">CanLoad</code>. The <code class="Code-In-Text--PACKT-">Resolve</code> guard will be covered in <em class="italics">Chapter 11</em>, <em class="italics">Recipes – Reusability, Routing, and Caching</em>.</p>
    <h2 class="title" id="_idParaDest-304">Auth guards</h2>
    <p class="normal">Auth guards enable a good UX by allowing or disallowing accidental navigation to a feature module or <a id="_idIndexMarker869"/>a component before the module has loaded or before any improper data requests have been made to the server. For example, when a manager logs in, they're automatically routed to the <code class="Code-In-Text--PACKT-">/manager/home</code> path. The browser will cache this URL, and it would be completely plausible for a clerk to accidentally navigate to the same URL. Angular doesn't know whether a particular route is accessible to a user or not and, without an <code class="Code-In-Text--PACKT-">AuthGuard</code>, it will happily render the manager's home page and trigger server requests that will end up failing.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">Regardless of the robustness of your frontend implementation, every REST API you implement should be properly secured server-side.</p>
    </div>
    <p class="normal">Let's update the router so that <code class="Code-In-Text--PACKT-">ProfileComponent</code> can't be activated without an authenticated user and the <code class="Code-In-Text--PACKT-">ManagerModule</code> won't load unless a manager is logging in using an <code class="Code-In-Text--PACKT-">AuthGuard</code>:</p>
    <ol>
      <li class="list" value="1">Implement an <code class="Code-In-Text--PACKT-">AuthGuard</code> service:
        <pre class="programlisting"><code class="hljs typescript"><strong>src/app/auth/auth-guard.service.ts</strong>
<span class="hljs-keyword">import</span> { Injectable } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>
<span class="hljs-keyword">import</span> {
  ActivatedRouteSnapshot,
  CanActivate,
  CanActivateChild,
  CanLoad,
  Route,
  Router,
  RouterStateSnapshot,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/router'</span>
<span class="hljs-keyword">import</span> { Observable } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>
<span class="hljs-keyword">import</span> { map, take } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs/operators'</span>
<span class="hljs-keyword">import</span> { UiService } <span class="hljs-keyword">from</span> <span class="hljs-string">'../common/ui.service'</span>
<span class="hljs-keyword">import</span> { Role } <span class="hljs-keyword">from</span> <span class="hljs-string">'./auth.enum'</span>
<span class="hljs-keyword">import</span> { AuthService } <span class="hljs-keyword">from</span> <span class="hljs-string">'./auth.service'</span>
<span class="hljs-meta">@Injectable</span>({
  providedIn: <span class="hljs-string">'root'</span>,
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AuthGuard <span class="hljs-keyword">implements</span> CanActivate, CanActivateChild, CanLoad {
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">
    <span class="hljs-keyword">protected</span> authService: AuthService,
    <span class="hljs-keyword">protected</span> router: Router,
    <span class="hljs-keyword">private</span> uiService: UiService
  </span>) {}
  canLoad(route: Route):
    <span class="hljs-built_in">boolean</span> | Observable&lt;<span class="hljs-built_in">boolean</span>&gt; | <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">boolean</span>&gt; {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.checkLogin()
  }
  canActivate(
    route: ActivatedRouteSnapshot,
    state: RouterStateSnapshot
  ): <span class="hljs-built_in">boolean</span> | Observable&lt;<span class="hljs-built_in">boolean</span>&gt; | <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">boolean</span>&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.checkLogin(route)
  }
  canActivateChild(
    childRoute: ActivatedRouteSnapshot,
    state: RouterStateSnapshot
  ): <span class="hljs-built_in">boolean</span> | Observable&lt;<span class="hljs-built_in">boolean</span>&gt; | <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">boolean</span>&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.checkLogin(childRoute)
  }
  <span class="hljs-keyword">protected</span> checkLogin(route?: ActivatedRouteSnapshot):
    Observable&lt;<span class="hljs-built_in">boolean</span>&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.authService.authStatus$.pipe(
      map(<span class="hljs-function">(<span class="hljs-params">authStatus</span>) =&gt;</span> {
        <span class="hljs-keyword">const</span> roleMatch = <span class="hljs-keyword">this</span>.checkRoleMatch(
          authStatus.userRole, route
        )
        <span class="hljs-keyword">const</span> allowLogin = authStatus.isAuthenticated &amp;&amp; roleMatch
        <span class="hljs-keyword">if</span> (!allowLogin) {
          <span class="hljs-keyword">this</span>.showAlert(authStatus.isAuthenticated, roleMatch)
          <span class="hljs-keyword">this</span>.router.navigate([<span class="hljs-string">'login'</span>], {
            queryParams: {
              redirectUrl: <span class="hljs-keyword">this</span>.getResolvedUrl(route),
            },
          })
        }
        <span class="hljs-keyword">return</span> allowLogin
      }),
      take(<span class="hljs-number">1</span>) <span class="hljs-comment">// complete the observable for the guard to work</span>
    )
  }
  <span class="hljs-keyword">private</span> checkRoleMatch(
    role: Role,
    route?: ActivatedRouteSnapshot
  ) {
    <span class="hljs-keyword">if</span> (!route?.data?.expectedRole) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
    }
    <span class="hljs-keyword">return</span> role === route.data.expectedRole
  }
  <span class="hljs-keyword">private</span> showAlert(isAuth: <span class="hljs-built_in">boolean</span>, roleMatch: <span class="hljs-built_in">boolean</span>) {
    <span class="hljs-keyword">if</span> (!isAuth) {
      <span class="hljs-keyword">this</span>.uiService.showToast(<span class="hljs-string">'You must login to continue'</span>)
    }
    <span class="hljs-keyword">if</span> (!roleMatch) {
      <span class="hljs-keyword">this</span>.uiService.showToast(
        <span class="hljs-string">'You do not have the permissions to view this resource'</span>
      )
    }
  }
  getResolvedUrl(route?: ActivatedRouteSnapshot): <span class="hljs-built_in">string</span> {
    <span class="hljs-keyword">if</span> (!route) {
      <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>
    }
    <span class="hljs-keyword">return</span> route.pathFromRoot
      .map(<span class="hljs-function">(<span class="hljs-params">r</span>) =&gt;</span> r.url.map(<span class="hljs-function">(<span class="hljs-params">segment</span>) =&gt;</span> segment.toString())
      .join(<span class="hljs-string">'/'</span>))
      .join(<span class="hljs-string">'/'</span>)
      .replace(<span class="hljs-string">'//'</span>, <span class="hljs-string">'/'</span>)
  }
}
</code></pre>
      </li>
      <li class="list">Use the <code class="Code-In-Text--PACKT-">CanLoad</code> guard <a id="_idIndexMarker870"/>to prevent the loading of a lazily loaded module, such as the manager's module:
        <pre class="programlisting"><code class="hljs coffeescript"><strong>src/app/app-routing.<span class="hljs-built_in">module</span>.ts</strong>
...
{
  path: <span class="hljs-string">'manager'</span>,
  loadChildren: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./manager/manager.module'</span>)
    .<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">(m)</span> =&gt;</span> m.ManagerModule), 
  <strong>canLoad: [AuthGuard],</strong>
},
...
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">In this instance, when the <code class="Code-In-Text--PACKT-">ManagerModule</code> is being loaded, <code class="Code-In-Text--PACKT-">AuthGuard</code> will be activated during the <code class="Code-In-Text--PACKT-">canLoad</code> event, and the <code class="Code-In-Text--PACKT-">checkLogin</code> function will verify the authentication status of the user. If the guard returns <code class="Code-In-Text--PACKT-">false</code>, the module will not be loaded. At this point, we don't have the metadata to check the role of the user.</p>
      </li>
      <li class="list">Use the <code class="Code-In-Text--PACKT-">CanActivate</code> guard to prevent the activation of individual components, such as the user's <code class="Code-In-Text--PACKT-">profile</code>:
        <pre class="programlisting"><code class="hljs less"><strong><span class="hljs-selector-tag">src</span>/<span class="hljs-selector-tag">app</span>/<span class="hljs-selector-tag">user</span>/<span class="hljs-selector-tag">user-routing</span><span class="hljs-selector-class">.module</span><span class="hljs-selector-class">.ts</span></strong>
...
{ 
  <span class="hljs-attribute">path</span>: <span class="hljs-string">'profile'</span>, <span class="hljs-attribute">component</span>: ProfileComponent, 
  <strong><span class="hljs-attribute">canActivate</span>: [AuthGuard] </strong>
},
...
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">In the case of <code class="Code-In-Text--PACKT-">user-routing.module.ts</code>, <code class="Code-In-Text--PACKT-">AuthGuard</code> is activated during the <code class="Code-In-Text--PACKT-">canActivate</code> event, and the <code class="Code-In-Text--PACKT-">checkLogin</code> function controls where this route can be navigated to. Since the user is viewing their own profile, there's no need to check the user's role here.</p>
      </li>
      <li class="list" value="4">Use <code class="Code-In-Text--PACKT-">CanActivate</code> or <code class="Code-In-Text--PACKT-">CanActivateChild</code> with an <code class="Code-In-Text--PACKT-">expectedRole</code> property to <a id="_idIndexMarker871"/>prevent the activation of components by other users, such as <code class="Code-In-Text--PACKT-">ManagerHomeComponent</code>:
        <pre class="programlisting"><code class="hljs less"><strong><span class="hljs-selector-tag">src</span>/<span class="hljs-selector-tag">app</span>/<span class="hljs-selector-tag">mananger</span>/<span class="hljs-selector-tag">manager-routing</span><span class="hljs-selector-class">.module</span><span class="hljs-selector-class">.ts</span></strong>
...
  {
    <span class="hljs-attribute">path</span>: <span class="hljs-string">'home'</span>,
    <span class="hljs-attribute">component</span>: ManagerHomeComponent,
    <strong><span class="hljs-attribute">canActivate</span>: [AuthGuard],</strong>
<strong>    <span class="hljs-attribute">data</span>: {</strong>
<strong>      <span class="hljs-attribute">expectedRole</span>: Role.Manager,</strong>
<strong>    },</strong>
  },
  {
    <span class="hljs-attribute">path</span>: <span class="hljs-string">'users'</span>,
    <span class="hljs-attribute">component</span>: UserManagementComponent,
    <strong><span class="hljs-attribute">canActivate</span>: [AuthGuard],</strong>
<strong>    <span class="hljs-attribute">data</span>: {</strong>
<strong>      <span class="hljs-attribute">expectedRole</span>: Role.Manager,</strong>
<strong>    },</strong>
  },
  {
    <span class="hljs-attribute">path</span>: <span class="hljs-string">'receipts'</span>,
    <span class="hljs-attribute">component</span>: ReceiptLookupComponent,
    <strong><span class="hljs-attribute">canActivate</span>: [AuthGuard],</strong>
<strong>    <span class="hljs-attribute">data</span>: {</strong>
<strong>      <span class="hljs-attribute">expectedRole</span>: Role.Manager,</strong>
<strong>    },</strong>
  },
...
</code></pre>
      </li>
    </ol>
    <p class="normal">Inside <code class="Code-In-Text--PACKT-">ManagerModule</code>, we can verify whether the user is authorized to access a particular route. We can do this by defining some metadata in the route definition, like <code class="Code-In-Text--PACKT-">expectedRole</code>, which will be <a id="_idIndexMarker872"/>passed into the <code class="Code-In-Text--PACKT-">checkLogin</code> function by the <code class="Code-In-Text--PACKT-">canActivate</code> event. If a user is authenticated but their role doesn't match <code class="Code-In-Text--PACKT-">Role.Manager</code>, <code class="Code-In-Text--PACKT-">AuthGuard</code> will return <code class="Code-In-Text--PACKT-">false</code> and the navigation will be prevented.</p>
    <p class="normal">Next, we will go over some techniques to get our tests passing.</p>
    <h2 class="title" id="_idParaDest-305">Auth service fake and common testing providers</h2>
    <p class="normal">We need to <a id="_idIndexMarker873"/>provide mocked versions of services like <code class="Code-In-Text--PACKT-">AuthService</code> or <code class="Code-In-Text--PACKT-">UiService</code> using the <code class="Code-In-Text--PACKT-">commonTestingProviders</code> function in <code class="Code-In-Text--PACKT-">common.testing.ts</code>, using a pattern similar to <code class="Code-In-Text--PACKT-">commonTestingModules</code>, which was mentioned in <em class="italics">Chapter 7</em>, <em class="italics">Creating a Router-First Line-of-Business App</em>. This way, we won't have to <a id="_idIndexMarker874"/>mock the same objects over and over again.</p>
    <p class="normal">Let's create the spy objects using the <code class="Code-In-Text--PACKT-">autoSpyObj</code> function from <code class="Code-In-Text--PACKT-">angular-unit-test-helper</code> and go over some less obvious changes we need to implement to get our tests passing:</p>
    <ol>
      <li class="list" value="1">Update <code class="Code-In-Text--PACKT-">commonTestingProviders</code> in <code class="Code-In-Text--PACKT-">common.testing.ts</code>:
        <pre class="programlisting"><code class="hljs groovy"><strong>src<span class="hljs-regexp">/app/</span>common/common.testing.ts</strong>
<span class="hljs-keyword">import</span> { autoSpyObj } from <span class="hljs-string">'angular-unit-test-helper'</span>
export const <span class="hljs-string">commonTestingProviders:</span> any[] = [
  { <span class="hljs-string">provide:</span> AuthService, <span class="hljs-string">useValue:</span> autoSpyObj(AuthService) },
  { <span class="hljs-string">provide:</span> UiService, <span class="hljs-string">useValue:</span> autoSpyObj(UiService) }, 
]
</code></pre>
      </li>
      <li class="list">Observe the fake being provided for the <code class="Code-In-Text--PACKT-">MediaObserver</code> in <code class="Code-In-Text--PACKT-">app.component.spec.ts</code> and update it to use <code class="Code-In-Text--PACKT-">commonTestingModules</code>:
        <pre class="programlisting"><code class="hljs less"><strong><span class="hljs-selector-tag">src</span>/<span class="hljs-selector-tag">app</span>/<span class="hljs-selector-tag">app</span><span class="hljs-selector-class">.component</span><span class="hljs-selector-class">.spec</span><span class="hljs-selector-class">.ts</span></strong>
...
  <span class="hljs-selector-tag">TestBed</span><span class="hljs-selector-class">.configureTestingModule</span>({
    <strong><span class="hljs-attribute">imports</span>: commonTestingModules,</strong>
    <span class="hljs-attribute">providers</span>: commonTestingProviders.concat([
      <strong>{ <span class="hljs-attribute">provide</span>: MediaObserver, <span class="hljs-attribute">useClass</span>: MediaObserverFake },</strong>
...
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">See how the <code class="Code-In-Text--PACKT-">commonTestingProviders</code> array is being concatenated with fakes that are specific to <code class="Code-In-Text--PACKT-">app.component.ts</code>; our new mocks should apply automatically.</p>
      </li>
      <li class="list">Update <a id="_idIndexMarker875"/>the spec file for <code class="Code-In-Text--PACKT-">LoginComponent</code> to leverage <code class="Code-In-Text--PACKT-">commonTestingModules</code> and <code class="Code-In-Text--PACKT-">commonTestingProviders</code>:
        <pre class="programlisting"><code class="hljs dts"><strong>src<span class="hljs-meta-keyword">/app/</span>login/login.component.spec.ts</strong>
...
  TestBed.configureTestingModule({
<span class="hljs-symbol">    </span><strong><span class="hljs-symbol">imports:</span> commonTestingModules,</strong>
<strong><span class="hljs-symbol">    providers:</span> commonTestingProviders,</strong>
<span class="hljs-symbol">    declarations:</span> [LoginComponent],
  }).compileComponents()
</code></pre>
      </li>
      <li class="list">Go ahead <a id="_idIndexMarker876"/>and apply this technique to all spec files that have a dependency on <code class="Code-In-Text--PACKT-">AuthService</code> and <code class="Code-In-Text--PACKT-">UiService</code>.</li>
      <li class="list">The notable exception is services, as in <code class="Code-In-Text--PACKT-">auth.service.spec.ts</code>, where you do <em class="italics">not</em> want to use a test double. Since <code class="Code-In-Text--PACKT-">AuthService</code> is the class under test, make sure it is configured as follows:
        <pre class="programlisting"><code class="hljs less"><strong><span class="hljs-selector-tag">src</span>/<span class="hljs-selector-tag">app</span>/<span class="hljs-selector-tag">auth</span>/<span class="hljs-selector-tag">auth</span><span class="hljs-selector-class">.service</span><span class="hljs-selector-class">.spec</span><span class="hljs-selector-class">.ts</span></strong>
...
<span class="hljs-selector-tag">TestBed</span><span class="hljs-selector-class">.configureTestingModule</span>({
  <strong><span class="hljs-attribute">imports</span>: [HttpClientTestingModule],</strong>
<strong>  <span class="hljs-attribute">providers</span>: [AuthService, </strong>
<strong>  { <span class="hljs-attribute">provide</span>: UiService, <span class="hljs-attribute">useValue</span>: autoSpyObj(UiService) }],</strong>
})
</code></pre>
      </li>
      <li class="list" value="6">Update <code class="Code-In-Text--PACKT-">ui.service.spec.ts</code> with similar considerations.</li>
    </ol>
    <p class="normal">Remember, don't move on until all your tests are passed!</p>
    <h1 class="title" id="_idParaDest-306">Firebase authentication recipe</h1>
    <p class="normal">We can leverage our current authentication setup and integrate it with a real authentication <a id="_idIndexMarker877"/>service. For this section, you need a free Google and Firebase account. Firebase is Google's comprehensive mobile development <a id="_idIndexMarker878"/>platform: <a href="https://firebase.google.com"><span class="url">https://firebase.google.com</span></a>. You can create a free account to host your application and leverage the Firebase authentication system.</p>
    <p class="normal">The Firebase <a id="_idIndexMarker879"/>console, found at <a href="https://console.firebase.google.com"><span class="url">https://console.firebase.google.com</span></a>, allows you to manage users and send a password reset email without having to implement a backend for your application. Later on, you can leverage Firebase functions to implement APIs in a serverless manner.</p>
    <p class="normal">Start by adding your project to Firebase using the Firebase console:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_08_13.png"/></figure>
    <p class="packt_figref">Figure 8.13: The Firebase console</p>
    <ol>
      <li class="list" value="1">Click on <strong class="screen-text">Add project</strong></li>
      <li class="list">Provide your project name</li>
      <li class="list" value="3">Enable Google Analytics for your project</li>
    </ol>
    <p class="normal">It helps to create a Google Analytics account before attempting this, but it should still work. Once your project is created, you should see your project dashboard:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_08_14.png"/></figure>
    <p class="packt_figref">Figure 8.14: The Firebase project overview</p>
    <p class="normal">On the <a id="_idIndexMarker880"/>left-hand side, marked with step <strong class="bold">1</strong>, you can see a menu of tools and services that you can add to your project. At the top, marked with step <strong class="bold">2</strong>, you can quickly jump between your projects. First, you need to add an application to your project.</p>
    <h2 class="title" id="_idParaDest-307">Add an application</h2>
    <p class="normal">Your project <a id="_idIndexMarker881"/>can include multiple distributions of your application, like web, iOS, and Android versions. In this chapter, we're only interested in adding a web application.</p>
    <p class="normal">Let's get started:</p>
    <ol>
      <li class="list" value="1">On your project dashboard, click on the web application button to add an application, which is marked with step <strong class="bold">3</strong> in <em class="italics">Figure 8.14</em></li>
      <li class="list">Provide an application nickname</li>
      <li class="list">Select the option to set up <strong class="screen-text">Firebase Hosting</strong></li>
      <li class="list">Continue by hitting the <strong class="bold">Register app</strong> button</li>
      <li class="list">Skip over the <strong class="bold">Add Firebase SDK</strong> section </li>
      <li class="list">Install the Firebase CLI as instructed:
        <pre class="programlisting"><code class="hljs cmake">$ npm <span class="hljs-keyword">install</span> -g firebase-tools
</code></pre>
      </li>
      <li class="list">Sign in:
        <pre class="programlisting"><code class="hljs elixir"><span class="hljs-variable">$ </span>firebase login
</code></pre>
        <div class="packt_tip">
          <p>Make sure your current directory is your project's root folder.</p>
        </div>
      </li>
      <li class="list">Initialize your project:
        <pre class="programlisting"><code class="hljs elixir"><span class="hljs-variable">$ </span>firebase init
</code></pre>
      </li>
      <li class="list">Select the <strong class="screen-text">Hosting</strong> option; don't worry, you can add more features later</li>
      <li class="list">Select the project you created as the default, that is, <strong class="screen-text">lemon-mart-007</strong></li>
      <li class="list">For the public directory enter <code class="Code-In-Text--PACKT-">dist/lemon-mart</code> or the <code class="Code-In-Text--PACKT-">outputPath</code> defined in your <code class="Code-In-Text--PACKT-">angular.json</code> file</li>
      <li class="list">Say <strong class="bold">yes</strong> to configure it as a single-page application.<p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">This will create two new files: <code class="Code-In-Text--PACKT-">firebase.json</code> and <code class="Code-In-Text--PACKT-">.firebaserc</code>.</p>
      </li>
      <li class="list">Build your project for production:
        <pre class="programlisting"><code class="hljs gams"><span class="hljs-symbol">$</span> npx ng build --<span class="hljs-keyword">prod</span>
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">or </p>
        <pre class="programlisting"><code class="hljs dockerfile">$ npm <span class="hljs-keyword">run</span><span class="bash"> build:prod</span>
</code></pre>
      </li>
      <li class="list" value="14">Now you <a id="_idIndexMarker882"/>can deploy your Angular application by executing the following command:
        <pre class="programlisting"><code class="hljs elixir"><span class="hljs-variable">$ </span>firebase deploy
</code></pre>
      </li>
    </ol>
    <p class="normal">Your website <a id="_idIndexMarker883"/>should be available on a URL similar to <a href="https://lemon-mart-007.firebaseapp.com"><span class="url">https://lemon-mart-007.firebaseapp.com</span></a>, as shown in the terminal.</p>
    <div class="packt_tip">
      <p>Add the <code class="Code-In-Text--PACKT-">.firebase</code> folder to <code class="Code-In-Text--PACKT-">.gitignore</code> so you don't check in your cache files. The other two files, <code class="Code-In-Text--PACKT-">firebase.json</code> and <code class="Code-In-Text--PACKT-">.firebaserc</code>, are safe to commit.</p>
    </div>
    <p class="normal">Optionally, connect a custom domain name that you own to the account using the Firebase console.</p>
    <h2 class="title" id="_idParaDest-308">Configure authentication</h2>
    <p class="normal">Now, let's <a id="_idIndexMarker884"/>configure authentication.</p>
    <p class="normal">In the Firebase console:</p>
    <ol>
      <li class="list" value="1">Select <strong class="screen-text">Authentication</strong> from the side navigation:<figure class="mediaobject"><img alt="" src="../Images/B14094_08_15.png"/></figure>
        <p class="packt_figref">Figure 8.15: The Firebase Authentication page</p>
      </li>
      <li class="list">Select <strong class="screen-text">Email/Password</strong> as the provider</li>
      <li class="list">Enable it</li>
      <li class="list">Do not enable the email link</li>
      <li class="list" value="5">Save your configuration</li>
    </ol>
    <p class="normal">You can <a id="_idIndexMarker885"/>now see the user management console:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_08_16.png"/></figure>
    <p class="packt_figref">Figure 8.16: The Firebase user management console</p>
    <p class="normal">It is fairly <a id="_idIndexMarker886"/>straightforward and intuitive to operate, so I will leave the configuration of it as an exercise for you.</p>
    <h2 class="title" id="_idParaDest-309">Implement Firebase authentication</h2>
    <p class="normal">Let's start <a id="_idIndexMarker887"/>by adding Angular Fire, the official Firebase library for Angular, to our application:</p>
    <pre class="programlisting"><code class="hljs dockerfile">$ npx ng <span class="hljs-keyword">add</span><span class="bash"> @angular/fire</span>
</code></pre>
    <div class="note">
      <p class="Information-Box--PACKT-">Follow Angular Fire's quickstart guide to finish setting up the library with your Angular project, which you can find linked from the readme file on GitHub at <a href="https://github.com/angular/angularfire2"><span class="url">https://github.com/angular/angularfire2</span></a>.</p>
    </div>
    <ol>
      <li class="list" value="1">Ensure Firebase modules are provided in <code class="Code-In-Text--PACKT-">app.module.ts</code> as per the documentation.</li>
      <li class="list">Ensure your Firebase config object is in all your <code class="Code-In-Text--PACKT-">environment.ts</code> files.<div class="note">
          <p class="Information-Box--PACKT-">Note that any information provided in <code class="Code-In-Text--PACKT-">environment.ts</code> is public information. So, when you place your Firebase API key in this file, it will be publicly available. There's a small chance that another developer could abuse your API key and run up your bill. To protect yourself from any such attack, check out this blog post by paachu: <em class="italics">How to secure your Firebase project even when your API key is publicly available</em> at <a href="https://medium.com/@impaachu/how-to-secure-your-firebase-project-even-when-your-api-key-is-publicly-"><span class="url">https://medium.com/@impaachu/how-to-secure-your-firebase-project-even-when-your-api-key-is-publicly-available-a462a2a58843</span></a>.</p>
        </div>
      </li>
      <li class="list">Create a new <code class="Code-In-Text--PACKT-">FirebaseAuthService</code>:
        <pre class="programlisting"><code class="hljs ada">$ npx ng g s auth/firebaseAuth <span class="hljs-comment">--lintFix</span>
</code></pre>
      </li>
      <li class="list">Rename the service file to <code class="Code-In-Text--PACKT-">auth.firebase.service.ts</code>.</li>
      <li class="list">Be sure to remove <code class="Code-In-Text--PACKT-">{ providedIn: 'root' }</code>.</li>
      <li class="list">Implement Firebase auth by extending the abstract auth service:
        <pre class="programlisting"><code class="hljs typescript"><strong>src/app/auth/auth.firebase.service.ts</strong>
<span class="hljs-keyword">import</span> { Injectable } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>
<span class="hljs-keyword">import</span> { AngularFireAuth } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/fire/auth'</span>
<span class="hljs-keyword">import</span> { User <span class="hljs-keyword">as</span> FirebaseUser } <span class="hljs-keyword">from</span> <span class="hljs-string">'firebase'</span>
<span class="hljs-keyword">import</span> { Observable, Subject } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>
<span class="hljs-keyword">import</span> { map } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs/operators'</span>
<span class="hljs-keyword">import</span> { IUser, User } <span class="hljs-keyword">from</span> <span class="hljs-string">'../user/user/user'</span>
<span class="hljs-keyword">import</span> { Role } <span class="hljs-keyword">from</span> <span class="hljs-string">'./auth.enum'</span>
<span class="hljs-keyword">import</span> {
  AuthService,
  IAuthStatus,
  IServerAuthResponse,
  defaultAuthStatus,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'./auth.service'</span>
<span class="hljs-keyword">interface</span> IJwtToken {
  email: <span class="hljs-built_in">string</span>
  iat: <span class="hljs-built_in">number</span>
  exp: <span class="hljs-built_in">number</span>
  sub: <span class="hljs-built_in">string</span>
}
<span class="hljs-meta">@Injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> FirebaseAuthService <span class="hljs-keyword">extends</span> AuthService {
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> afAuth: AngularFireAuth</span>) {
    <span class="hljs-keyword">super</span>()
  }
  <span class="hljs-keyword">protected</span> authProvider(
    email: <span class="hljs-built_in">string</span>,
    password: <span class="hljs-built_in">string</span>
  ): Observable&lt;IServerAuthResponse&gt; {
    <span class="hljs-keyword">const</span> serverResponse$ = <span class="hljs-keyword">new</span> Subject&lt;IServerAuthResponse&gt;()
    <span class="hljs-keyword">this</span>.afAuth.signInWithEmailAndPassword(email, password).then(
      <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {
        <span class="hljs-keyword">const</span> firebaseUser: FirebaseUser | <span class="hljs-literal">null</span> = res.user
        firebaseUser?.getIdToken().then(
          <span class="hljs-function">(<span class="hljs-params">token</span>) =&gt;</span> serverResponse$.next(
            { accessToken: token } <span class="hljs-keyword">as</span> IServerAuthResponse
          ),
          <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> serverResponse$.error(err)
        )
      },
      <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> serverResponse$.error(err)
    )
    <span class="hljs-keyword">return</span> serverResponse$
  }
  <span class="hljs-keyword">protected</span> transformJwtToken(token: IJwtToken): IAuthStatus {
    <span class="hljs-keyword">if</span> (!token) {
      <span class="hljs-keyword">return</span> defaultAuthStatus
    }
    <span class="hljs-keyword">return</span> {
      isAuthenticated: token.email ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>,
      userId: token.sub,
      userRole: Role.None,
    }
  }
  <span class="hljs-keyword">protected</span> getCurrentUser(): Observable&lt;User&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.afAuth.user.pipe(map(<span class="hljs-keyword">this</span>.transformFirebaseUser))
  }
  <span class="hljs-keyword">private</span> transformFirebaseUser(firebaseUser: FirebaseUser): User
  {
    <span class="hljs-keyword">if</span> (!firebaseUser) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User()
    }
    <span class="hljs-keyword">return</span> User.Build({
      name: {
        first: firebaseUser?.displayName?.split(<span class="hljs-string">' '</span>)[<span class="hljs-number">0</span>] ||
          <span class="hljs-string">'Firebase'</span>,
        last: firebaseUser?.displayName?.split(<span class="hljs-string">' '</span>)[<span class="hljs-number">1</span>] || <span class="hljs-string">'User'</span>,
      },
      picture: firebaseUser.photoURL,
      email: firebaseUser.email,
      _id: firebaseUser.uid,
      role: Role.None,
    } <span class="hljs-keyword">as</span> IUser)
  }
  logout() {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.afAuth) {
      <span class="hljs-keyword">this</span>.afAuth.signOut()
    }
    <span class="hljs-keyword">this</span>.clearToken()
    <span class="hljs-keyword">this</span>.authStatus$.next(defaultAuthStatus)
  }
}
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">As you can see, we only had to implement the delta between our already established authentication code and Firebase's authentication methods. We didn't have to duplicate any code and we even transformed a Firebase <code class="Code-In-Text--PACKT-">user</code> object into our application's internal user object.</p>
      </li>
      <li class="list">To use <a id="_idIndexMarker888"/>Firebase authentication instead of in-memory authentication, update the <code class="Code-In-Text--PACKT-">AuthService</code> provider in <code class="Code-In-Text--PACKT-">app.module.ts</code>:
        <pre class="programlisting"><code class="hljs dts"><strong>src<span class="hljs-meta-keyword">/app/</span>app.module.ts</strong>
  {
<span class="hljs-symbol">    provide:</span> AuthService,
<span class="hljs-symbol">    useClass:</span> <strong>FirebaseAuthService</strong>,
  }, 
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">Once you've completed the steps, add a new user from the Firebase authentication console and you should be able to log in using real authentication.</p>
      
      <div class="packt_tip">
        <p>Always <a id="_idIndexMarker889"/>make sure that you're using HTTPS when transmitting any kind of <strong class="bold">personally identifiable information</strong> (<strong class="bold">PII</strong>) or sensitive information (like passwords) over the Internet. Otherwise, your information will get logged on third-party servers or captured by bad actors.</p>
      </div></li>
      <li class="list" value="8">Once again, be sure to update your unit tests before moving on:
        <pre class="programlisting"><code class="hljs groovy"><strong>src<span class="hljs-regexp">/app/</span>auth/auth.firebase.service.spec.ts</strong>
<span class="hljs-keyword">import</span> { AngularFireAuth } from <span class="hljs-string">'@angular/fire/auth'</span>
<span class="hljs-keyword">import</span> { UiService } from <span class="hljs-string">'../common/ui.service'</span>
<span class="hljs-keyword">import</span> { FirebaseAuthService } from <span class="hljs-string">'./auth.firebase.service'</span>
TestBed.configureTestingModule({
<span class="hljs-symbol">  imports:</span> [<strong>HttpClientTestingModule</strong>],
<span class="hljs-symbol">  providers:</span> [
    <strong>FirebaseAuthService,</strong>
<strong>    { <span class="hljs-string">provide:</span> UiService, <span class="hljs-string">useValue:</span> autoSpyObj(UiService) },</strong>
<strong>    { <span class="hljs-string">provide:</span> AngularFireAuth, </strong>
<strong><span class="hljs-symbol">      useValue:</span> autoSpyObj(AngularFireAuth) </strong>
<strong>    },</strong>
  ],
})
</code></pre>
      </li>
    </ol>
    <div class="note">
      <p class="Information-Box--PACKT-">Stop! Remove the <code class="Code-In-Text--PACKT-">fake-jwt-sign</code> package from your project before deploying a real authentication method.</p>
    </div>
    <p class="normal">Congratulations, your <a id="_idIndexMarker890"/>application is integrated with Firebase! Next, let's cover service factories, which can help you to switch the providers of your abstract classes dynamically.</p>
    <h1 class="title" id="_idParaDest-310">Providing a service using a factory</h1>
    <p class="normal">You can dynamically choose providers during load time, so instead of having to change code to <a id="_idIndexMarker891"/>switch between authentication methods, you can parametrize environment variables, so different kinds of builds can have different authentication methods. This is especially useful when writing automated UI tests against your application, where real authentication can be difficult, if not impossible, to deal with.</p>
    <p class="normal">First, we will create an <code class="Code-In-Text--PACKT-">enum</code> in <code class="Code-In-Text--PACKT-">environment.ts</code> to help define our options, and then we will use that <code class="Code-In-Text--PACKT-">enum</code> to choose an auth provider during our application's bootstrap process.</p>
    <p class="normal">Let's get started:</p>
    <ol>
      <li class="list" value="1">Create a new <code class="Code-In-Text--PACKT-">enum</code> called <code class="Code-In-Text--PACKT-">AuthMode</code>:
        <pre class="programlisting"><code class="hljs crystal"><strong>src/app/auth/auth<span class="hljs-class">.<span class="hljs-keyword">enum</span>.<span class="hljs-title">ts</span></span></strong>
export <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">AuthMode</span> {</span>
  InMemory = <span class="hljs-string">'In Memory'</span>,
  CustomServer = <span class="hljs-string">'Custom Server'</span>,
  Firebase = <span class="hljs-string">'Firebase'</span>,
}
</code></pre>
      </li>
      <li class="list">Add an <code class="Code-In-Text--PACKT-">authMode</code> property in <code class="Code-In-Text--PACKT-">environment.ts</code>:
        <pre class="programlisting"><code class="hljs stylus"><strong>src/environments/environment<span class="hljs-selector-class">.ts</span></strong>
...
  authMode: AuthMode<span class="hljs-selector-class">.</span><strong><span class="hljs-selector-class">InMemory</span></strong>,
...
<strong>src/environments/environment<span class="hljs-selector-class">.prod</span><span class="hljs-selector-class">.ts</span></strong>
...
  authMode: AuthMode<span class="hljs-selector-class">.</span><strong><span class="hljs-selector-class">Firebase</span></strong>,
...
</code></pre>
      </li>
      <li class="list">Create an <code class="Code-In-Text--PACKT-">authFactory</code> function in a new file under <code class="Code-In-Text--PACKT-">auth/auth.factory.ts</code>:
        <pre class="programlisting"><code class="hljs groovy"><strong>src<span class="hljs-regexp">/app/</span>auth/auth.factory.ts</strong>
export function authFactory(<span class="hljs-string">afAuth:</span> AngularFireAuth) {
  <span class="hljs-keyword">switch</span> (environment.authMode) {
    <span class="hljs-keyword">case</span> AuthMode.<span class="hljs-string">InMemory:</span>
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> InMemoryAuthService()
    <span class="hljs-keyword">case</span> AuthMode.<span class="hljs-string">Firebase:</span>
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FirebaseAuthService(afAuth)
    <span class="hljs-keyword">case</span> AuthMode.<span class="hljs-string">CustomServer:</span>
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">'Not yet implemented'</span>)
  }
}
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">Note that the factory has to import any dependent service.</p>
      </li>
      <li class="list" value="4">Update the <code class="Code-In-Text--PACKT-">AuthService</code> provider in <code class="Code-In-Text--PACKT-">app.module.ts</code> to use the factory instead:
        <pre class="programlisting"><code class="hljs dts"><strong>src<span class="hljs-meta-keyword">/app/</span>app.module.ts</strong>
<span class="hljs-symbol">  providers:</span> [
    {
<span class="hljs-symbol">      provide:</span> AuthService,
<span class="hljs-symbol">      </span><strong><span class="hljs-symbol">useFactory:</span> authFactory,</strong>
<strong><span class="hljs-symbol">      deps:</span> [AngularFireAuth],</strong>
    }, 
</code></pre>
      </li>
    </ol>
    <p class="normal">Note that <a id="_idIndexMarker892"/>you can remove imports of <code class="Code-In-Text--PACKT-">InMemoryAuthService</code> and <code class="Code-In-Text--PACKT-">FirebaseAuthService</code> from <code class="Code-In-Text--PACKT-">AppModule</code>.</p>
    <p class="normal">With this configuration in place, whenever you build your application for local development, you will be using the in-memory auth service and production (or prod) builds will use the Firebase auth service.</p>
    <h1 class="title" id="_idParaDest-311">Summary</h1>
    <p class="normal">You should now be familiar with how to create high-quality auth experiences. In this chapter, we defined a User object that we can hydrate from or serialize to JSON objects, applying object-oriented class design and TypeScript operators for safe data handling.</p>
    <p class="normal">We leveraged OOP design principals, using inheritance and abstract classes to implement a base auth service that demonstrates the Open/Closed principle.</p>
    <p class="normal">We covered the fundamentals of token-based authentication and JWTs so that you don't leak any critical user information. You learned that caching and HTTP interceptors are necessary so that users don't have to input their login information with every request. Following that, we implemented two distinct auth providers, one in-memory and one with Firebase. </p>
    <p class="normal">We then designed a great conditional navigation experience that you can use in your own applications by copying the base elements to your project and implementing your own auth provider. We created a reusable UI service so that you can conveniently inject alerts into the flow-control logic of your application.</p>
    <p class="normal">Finally, we covered router guards to prevent users from stumbling onto screens they are not authorized to use, and we reaffirmed the point that the real security of your application should be implemented on the server side. You saw how you can use a factory to dynamically provide different auth providers for different environments.</p>
    <p class="normal">In the next chapter, we will shift gears a bit and learn about containerization using Docker. Docker allows powerful workflows that can greatly improve development experiences, while allowing you to implement your server configuration as code, putting a final nail in the coffin of the developer's favorite excuse when their software breaks: "But it works on my machine!"</p>
    <h1 class="title" id="_idParaDest-312">Further reading</h1>
    <ul>
      <li class="list"><em class="italics">Salted Password Hashing - Doing it Right, Defuse Security</em>, 2019, <a href="https://crackstation.net/hashing-security.htm"><span class="url">https://crackstation.net/hashing-security.htm</span></a>.</li>
      <li class="list"><em class="italics">Object-oriented programming</em>, <a href="https://en.wikipedia.org/wiki/Object-oriented_programming"><span class="url">https://en.wikipedia.org/wiki/Object-oriented_programming</span></a>.</li>
      <li class="list"><em class="italics">TypeScript Classes</em>, <a href="https://www.typescriptlang.org/docs/handbook/classes.html"><span class="url">https://www.typescriptlang.org/docs/handbook/classes.html</span></a>.</li>
      <li class="list"><em class="italics">TypeScript Basic Types</em>, <a href="https://www.typescriptlang.org/docs/handbook/basic-types.html"><span class="url">https://www.typescriptlang.org/docs/handbook/basic-types.html</span></a>.</li>
      <li class="list"><em class="italics">TypeScript Advanced Types</em>, <a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html"><span class="url">https://www.typescriptlang.org/docs/handbook/advanced-types.html</span></a>.</li>
      <li class="list"><em class="italics">TypeScript 3.7 Features</em>, <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html"><span class="url">https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html</span></a>.</li>
      <li class="list"><em class="italics">Angular NgIf Directive</em>, <a href="https://angular.io/api/common/NgIf"><span class="url">https://angular.io/api/common/NgIf</span></a>.</li>
      <li class="list"><em class="italics">Authentication General Guidelines</em>, <a href="https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Authentication_Cheat_Sheet.md"><span class="url">https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Authentication_Cheat_Sheet.md</span></a>.</li>
      <li class="list"><em class="italics">How to secure your Firebase project even when your API key is publicly available</em>, paachu, 2019, <a href="https://medium.com/@impaachu/how-to-secure-your-firebase-project-even-when-your-api-key-is-publicly-available-a462a2a58843"><span class="url">https://medium.com/@impaachu/how-to-secure-your-firebase-project-even-when-your-api-key-is-publicly-available-a462a2a58843</span></a>.</li>
    </ul>
    <h1 class="title" id="_idParaDest-313">Questions</h1>
    <p class="normal">Answer the following questions as best as you can to ensure that you've understood the key concepts from this chapter without Googling. Do you need help answering the questions? See <em class="italics">Appendix D</em>, <em class="italics">Self-Assessment Answers</em> online at <a href="https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf"><span class="url">https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf</span></a> or visit <a href="https://expertlysimple.io/angular-self-assessment"><span class="url">https://expertlysimple.io/angular-self-assessment</span></a>.</p>
    <ol>
      <li class="list">What's in-transit and at-rest security?</li>
      <li class="list">What's the difference between authentication and authorization?</li>
      <li class="list">Explain inheritance and polymorphism.</li>
      <li class="list">What is an abstract class?</li>
      <li class="list">What is an abstract method?</li>
      <li class="list">Explain how the <code class="Code-In-Text--PACKT-">AuthService</code> adheres to the Open/Closed principle.</li>
      <li class="list">How does JWT verify your identity?</li>
      <li class="list">What is the difference between RxJS's <code class="Code-In-Text--PACKT-">combineLatest</code> and <code class="Code-In-Text--PACKT-">merge</code> operators?</li>
      <li class="list">What is a router guard?</li>
      <li class="list">What does a service factory allow you to do?</li>
    </ol>
  </div>
</body></html>