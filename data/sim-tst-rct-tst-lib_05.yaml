- en: '*Chapter 5*: Refactoring Legacy Applications with React Testing Library'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第五章*：使用 React Testing Library 重构遗留应用程序'
- en: In the previous chapter, we learned how to test components in isolation separate
    from dependencies. We learned how the benefits of testing components can be integrated
    with other components. We also learned how to test components that use popular
    third-party **User Interface** (**UI**) and state management tools. By the end
    of this chapter, you will learn strategies for dealing with breaking changes while
    refactoring legacy React applications. You will learn how to update production
    packages while using React Testing Library tests to guide you in resolving breaking
    changes. You will also learn how to convert tests written in Enzyme or ReactTestUtils
    to React Testing Library.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何测试与依赖项分离的独立组件。我们学习了测试组件的好处如何与其他组件集成。我们还学习了如何测试使用流行的第三方 **用户界面**
    （**UI**） 和状态管理工具的组件。在本章结束时，您将学习处理重构遗留 React 应用程序时断开更改的策略。您将学习如何在更新生产包的同时使用 React
    Testing Library 测试来引导您解决断开更改。您还将学习如何将使用 Enzyme 或 ReactTestUtils 编写的测试转换为 React
    Testing Library。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Using tests to catch regressions when updating dependencies
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用测试来捕捉更新依赖项时的回归
- en: Refactoring tests written with Enzyme
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构使用 Enzyme 编写的测试
- en: Refactoring tests written with ReactTestUtils
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构使用 ReactTestUtils 编写的测试
- en: Refactoring tests to comply with common testing best practices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构测试以符合常见的测试最佳实践
- en: The skills acquired in this chapter will enable you to reduce the burden of
    refactoring legacy applications.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章获得的技术将使您能够减轻重构遗留应用程序的负担。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For the examples in this chapter, you will need to have Node.js installed on
    your machine. We will be using the `create-react-app` CLI tool for all code examples.
    Please familiarize yourself with the tool if required before starting the chapter.
    Also, a basic understanding of the Material UI library will be helpful.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的示例，您需要在您的机器上安装 Node.js。我们将使用 `create-react-app` CLI 工具来处理所有代码示例。如果需要，请在开始本章之前熟悉该工具。此外，对
    Material UI 库的基本了解将有所帮助。
- en: 'Code snippets will be provided throughout the chapter to help you understand
    the code under test, but the objective is understanding how to test the code.
    You can find the code examples for this chapter here: [https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter05](https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter05).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将提供代码片段，以帮助您理解待测试的代码，但目标是理解如何测试代码。您可以在以下位置找到本章的代码示例：[https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter05](https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter05)。
- en: Using tests to catch regressions when updating dependencies
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用测试来捕捉更新依赖项时的回归
- en: 'In this section, we will learn how to use tests to drive the updating of application
    dependencies. The tests will help verify that the application code continues to
    work as expected and allow us to quickly catch regressions if they occur after
    updating dependencies. The budgeting application renders the following when the
    application is running:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用测试来驱动应用程序依赖项的更新。这些测试将帮助验证应用程序代码是否继续按预期工作，并在更新依赖项后快速捕捉到回归。当应用程序运行时，预算应用程序将渲染以下内容：
- en: '![Figure 5.1 – Budget application](img/Figure_5.1_B16887.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – 预算应用](img/Figure_5.1_B16887.jpg)'
- en: Figure 5.1 – Budget application
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 预算应用
- en: 'The preceding screenshot shows a summary section that includes **Income**,
    **Spending**, and **Left over** amounts based on user input. A user can click
    the **SET INCOME** button to update the value for **Income**:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图显示了一个包含基于用户输入的 **收入**、**支出** 和 **剩余** 金额的摘要部分。用户可以点击 **设置收入** 按钮来更新 **收入**
    的值：
- en: '![Figure 5.2 – Setting the budget income](img/Figure_5.2_B16887.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 设置预算收入](img/Figure_5.2_B16887.jpg)'
- en: Figure 5.2 – Setting the budget income
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 设置预算收入
- en: 'The preceding screenshot shows a model that allows the user to enter and submit
    a number to update the value for **Income**. A user can also create budgets for
    various categories:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图显示了一个允许用户输入并提交数字以更新 **收入** 值的模型。用户还可以为各种类别创建预算：
- en: '![Figure 5.3 – Adding a budget category](img/Figure_5.3_B16887.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – 添加预算类别](img/Figure_5.3_B16887.jpg)'
- en: Figure 5.3 – Adding a budget category
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 添加预算类别
- en: 'The preceding screenshot shows a model that allows the user to select **Category**
    and **Amount** and add the new budget. The model also displays a message informing
    the user of acceptable values for the budget. Once the user creates a new budget,
    the budget is added to the screen:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图显示了一个允许用户选择**类别**和**金额**并添加新预算的模型。该模型还显示了一条消息，告知用户预算的可接受值。一旦用户创建了一个新的预算，该预算就会被添加到屏幕上：
- en: '![Figure 5.4 – Budget category details'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.4 – 预算类别详情'
- en: '](img/Figure_5.4_B16887.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.4_B16887.jpg)'
- en: Figure 5.4 – Budget category details
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – 预算类别详情
- en: The preceding screenshot shows a **Shopping** budget of **$200** added to the
    screen. An associated bar graph and a spending progress bar are added to the budget.
    A user can click the triangle buttons to add amounts to the budget or click the
    trashcan icon to delete the budget.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图显示了一个屏幕上添加了**购物**预算**$200**。预算中添加了相关的条形图和支出进度条。用户可以点击三角形按钮向预算中添加金额，或者点击垃圾桶图标删除预算。
- en: 'The budgeting application has the following production dependencies:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 预算应用程序有以下生产依赖项：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code shows the current versions of all project dependencies. We
    will update `"@material-ui/core"` to version `"4.11.3"`, `"@material-ui/icons"`
    to version `"4.11.2"`, and `"recharts"` to version `"2.0.4"`, so the application
    has up-to-date dependency code. The approach we will use to update the dependencies
    will involve having a suite of automated tests running to help catch any regressions
    after each dependency is updated. The budgeting application does not have any
    existing tests.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码显示了所有项目依赖项的当前版本。我们将更新`"@material-ui/core"`到版本`"4.11.3"`，`"@material-ui/icons"`到版本`"4.11.2"`，以及`"recharts"`到版本`"2.0.4"`，以便应用程序具有最新的依赖项代码。我们将使用的更新依赖项的方法将涉及运行一系列自动化测试，以帮助在更新每个依赖项后捕捉任何回归。预算应用程序没有现有的测试。
- en: In situations where a legacy application has no existing tests, a great way
    to get started is by writing automated UI end-to-end tests for critical workflows
    before adding tests at other test levels. Please refer to [*Chapter 7*](B16887_07_Final_PG_ePub.xhtml#_idTextAnchor109),
    *End-to-End UI Testing with Cypress*, for related content.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有现有测试的遗留应用程序的情况下，一个很好的开始方式是在其他测试级别添加测试之前，为关键工作流程编写自动化的 UI 端到端测试。请参阅[*第 7 章*](B16887_07_Final_PG_ePub.xhtml#_idTextAnchor109)，*使用
    Cypress 进行端到端 UI 测试*，了解相关内容。
- en: This chapter will teach you how to write automated component tests with React
    Testing Library before starting the dependency refactor task. Please see [*Chapter
    2*](B16887_02_Final_PG_ePub.xhtml#_idTextAnchor029), *Working with React Testing
    Library*, for installation instructions. Now that you have learned about the application
    and the approach to updating dependencies, we will get down to writing regression
    tests in the next section.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将教会你如何在开始依赖项重构任务之前，使用 React Testing Library 编写自动化的组件测试。请参阅[*第 2 章*](B16887_02_Final_PG_ePub.xhtml#_idTextAnchor029)，*使用
    React Testing Library 工作*，了解安装说明。现在你已经了解了应用程序和更新依赖项的方法，我们将在下一节中着手编写回归测试。
- en: Creating the regression test suite
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建回归测试套件
- en: 'In this section, we will write several integration tests with React Testing
    Library to add confidence that we can catch regressions while updating application
    dependencies. Please refer to [*Chapter 4*](B16887_04_Final_PG_ePub.xhtml#_idTextAnchor062),
    *Integration Testing and Third-Party Libraries in Your Application*, for content
    related to writing integration testing. We will write tests for the following
    major functionalities: setting the income, deleting a budget, creating a budget,
    and budget details. For the first test, we will target the *setting the income*
    functionality by verifying that a user can enter an amount for `income`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 React Testing Library 编写几个集成测试，以增加我们在更新应用程序依赖项时能够捕捉回归的信心。请参阅[*第 4
    章*](B16887_04_Final_PG_ePub.xhtml#_idTextAnchor062)，*在您的应用程序中编写集成测试和第三方库*，了解相关内容。我们将为以下主要功能编写测试：设置收入、删除预算、创建预算和预算详情。对于第一个测试，我们将针对*设置收入*功能，通过验证用户是否可以输入`income`的金额来进行测试：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the previous code, we create a function, `setOneDollarIncome`, to set an
    `income` amount of *$1*. The `setOneDollarIncome` function will reduce repetitive
    code in successive tests. Next, we will write the main test code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个名为`setOneDollarIncome`的函数，用于设置`income`金额为**$1**。`setOneDollarIncome`函数将减少后续测试中的重复代码。接下来，我们将编写主要的测试代码：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding code, first, we render the `App` component in the DOM. Next,
    we set an `income` amount of *$1* via the `setOneDollarIncome` function. Next,
    we grab the `left over` text and use the `within` method from React Testing Library
    to access the dollar amount text. The `within` method can be used in situations
    where we want to access the child elements of a parent element. When we run the
    application, the resulting HTML element output for the **Left Over** section on
    the screen is as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先，我们在DOM中渲染`App`组件。接下来，我们通过`setOneDollarIncome`函数设置`income`金额为*$1*。然后，我们获取`left
    over`文本并使用React Testing Library的`within`方法访问金额文本。`within`方法可用于我们想要访问父元素子元素的情况。当我们运行应用程序时，屏幕上**Left
    Over**部分的最终HTML元素输出如下：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, a `p` element has the text `Left over` as child content.
    In the test code, we grab the `p` element via the `Left Over` text and store it
    in the `leftOverBudget` variable. Then, we use `within` to grab the `span` element
    with the text `$1` and store it in the `leftOverBudgetAmount` variable.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，一个`p`元素作为子内容拥有文本`Left over`。在测试代码中，我们通过`Left Over`文本获取`p`元素并将其存储在`leftOverBudget`变量中。然后，我们使用`within`获取文本为`$1`的`span`元素并将其存储在`leftOverBudgetAmount`变量中。
- en: 'Finally, we assert that `leftOverBudgetAmount` is in the DOM. For the next
    test, we will target the *creating a budget* functionality by verifying the resulting
    amount in the *Budget Summary* section once a user sets a budget:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们断言`leftOverBudgetAmount`在DOM中。对于下一个测试，我们将针对*创建预算*功能，通过验证用户设置预算后*预算摘要*部分的结果金额：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the previous code, we create a function, `createCarBudget`, to reduce the
    repetitive steps of creating a budget that will be used in multiple test cases.
    A default value of `5` will be used if no value for the `amount` parameter is
    passed as an argument to the function. Next, we will write the main test code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个函数`createCarBudget`，以减少在多个测试用例中使用的创建预算的重复步骤。如果没有为函数的`amount`参数传递值，将使用默认值`5`。接下来，我们将编写主要测试代码：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the preceding code, we use the `each` method from Jest to allow the same
    test to be run multiple times with different values. The `budgetAmount`, `spending`,
    and `leftOver` variables represent the test''s values for each test iteration.
    We have three rows of data under the variables to pass into the variables for
    each of the three test runs. Next, we arrange and perform actions in the test:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用Jest的`each`方法允许相同的测试在多个不同的值上多次运行。`budgetAmount`、`spending`和`leftOver`变量代表每个测试迭代的测试值。我们在变量下有三行数据，用于传递给每个测试运行中的变量。接下来，我们在测试中安排和执行操作：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the preceding code, first we render the app in the DOM and invoke the `setOneDollarIncome`
    function. Next, we invoke the `createCarBudget` function and pass in the value
    of `budgetAmount` for the current test iteration. Next, we grab the element associated
    with the `leftOverBudget` variable, similar to what we did in the previous test.
    Finally, we make the following assertions:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先我们在DOM中渲染应用并调用`setOneDollarIncome`函数。接下来，我们调用`createCarBudget`函数并传入当前测试迭代的`budgetAmount`值。然后，我们获取与`leftOverBudget`变量关联的元素，类似于之前的测试。最后，我们进行以下断言：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the previous code, first, we assert that `leftOverBudgetAmount` is in the
    DOM. Finally, we assert that the heading element for the current value of `name`
    is in the DOM. By way of a challenge, write a test that verifies that a budget
    chart is displayed for a created budget.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先，我们断言`leftOverBudgetAmount`在DOM中。最后，我们断言当前`name`值的标题元素在DOM中。作为一个挑战，编写一个测试来验证创建的预算是否显示预算图表。
- en: The solution for the previous scenario can be found in the code samples for
    [*Chapter 5*](B16887_05_Final_PG_ePub.xhtml#_idTextAnchor083), *Refactoring Legacy
    Applications with React Testing Library*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 之前场景的解决方案可以在[*第五章*](B16887_05_Final_PG_ePub.xhtml#_idTextAnchor083)的代码示例中找到，*使用React
    Testing Library重构遗留应用程序*。
- en: 'For the next test, we will target the *deleting a budget* functionality by
    verifying that a deleted budget has been removed from the screen:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下一个测试，我们将针对*删除预算*功能，通过验证已删除的预算是否已从屏幕上移除：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code, first, we arrange our test by rendering the `App` component
    in the DOM and invoking the `setOneDollarIncome` and `createCarBudget` functions.
    Next, we click the trash can icon. Finally, we assert that no `listitem` elements
    are in the DOM.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先，我们通过在 DOM 中渲染 `App` 组件并调用 `setOneDollarIncome` 和 `createCarBudget`
    函数来安排我们的测试。然后，我们点击垃圾桶图标。最后，我们断言 DOM 中没有 `listitem` 元素。
- en: 'Since the `listitem` elements render the budgets on the screen, we can be confident
    that the functionality works as expected if none are found in the DOM. For the
    last test, we will target the *budget details* functionality by verifying that
    adding expenses updates the budget''s progress:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `listitem` 元素在屏幕上渲染预算，我们可以确信如果没有在 DOM 中找到任何元素，功能将按预期工作。对于最后一个测试，我们将通过验证添加支出是否更新预算进度来针对
    *预算详细信息* 功能：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code, first, we arrange our test by rendering the `App` component
    in the DOM and invoking the `setOneDollarIncome` and `createCarBudget` functions
    similar to the previous test. Next, we click the right arrow icon. Finally, we
    assert that the text, `$5 of $5`, is present on the screen.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先，我们通过在 DOM 中渲染 `App` 组件并调用与上一个测试类似的 `setOneDollarIncome` 和 `createCarBudget`
    函数来安排我们的测试。然后，我们点击右箭头图标。最后，我们断言屏幕上存在文本 `$5 of $5`。
- en: 'As a challenge, try to write the code for the following test scenario: `Budget,
    given budget, displays details`. The solutions for this test scenario can be found
    in the code samples for [*Chapter 5*](B16887_05_Final_PG_ePub.xhtml#_idTextAnchor083),
    *Refactoring Legacy Applications with React Testing Library*.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项挑战，尝试编写以下测试场景的代码：`Budget，给定预算，显示详细信息`。此测试场景的解决方案可以在 [*第 5 章*](B16887_05_Final_PG_ePub.xhtml#_idTextAnchor083)，*使用
    React 测试库重构遗留应用程序* 的代码示例中找到。
- en: 'When we run our tests, we receive the following output:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行我们的测试时，我们收到以下输出：
- en: '![Figure 5.5 – Budget app test results](img/Figure_5.5_B16887.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5 – 预算应用测试结果](img/Figure_5.5_B16887.jpg)'
- en: Figure 5.5 – Budget app test results
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – 预算应用测试结果
- en: The preceding screenshot shows that all the tests pass. Now that we have a passing
    regression test suite, we will upgrade the production dependencies for the application
    in the next section. It should be noted that our tests are automatically set up
    to run in **watch mode**, a Jest feature that automatically re-runs tests any
    time an associated component file is changed.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的屏幕截图显示所有测试都通过。现在我们有一个通过回归测试套件，我们将在下一节中升级应用程序的生产依赖项。需要注意的是，我们的测试自动设置为在 **观察模式**
    下运行，这是一个 Jest 功能，在关联的组件文件更改时自动重新运行测试。
- en: The watch mode feature provides you with confidence that we can quickly discover
    regressions as code changes are implemented. For projects not automatically set
    up to run Jest in watch mode, simply pass the `--watch` flag when you execute
    Jest from the command line.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 观察模式功能为您提供信心，我们可以在代码更改实施时快速发现回归。对于未自动设置在观察模式下运行 Jest 的项目，只需在命令行执行 Jest 时传递 `--watch`
    标志。
- en: Upgrading the Material UI dependencies
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 升级 Material UI 依赖项
- en: In the previous section, we created a regression test suite. In this section,
    we will delete all highlighted text and get the latest dependency code by upgrading
    the `@material-ui/icons` and `@material-ui/core` dependencies. The `@material-ui/icons`
    package depends on `@material-ui/core`, so we will update both dependencies simultaneously.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们创建了一个回归测试套件。在本节中，我们将删除所有突出显示的文本，并通过升级 `@material-ui/icons` 和 `@material-ui/core`
    依赖项来获取最新的依赖项代码。`@material-ui/icons` 包依赖于 `@material-ui/core`，因此我们将同时更新这两个依赖项。
- en: 'Inside the `package.json` file, replace the current version of `@material-ui/icons`
    `2.0.1` with `4.11.2`, `@material-ui/core` with `4.11.3`, and reinstall all dependencies.
    Now, when we run our tests, we receive the following output:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `package.json` 文件中，将 `@material-ui/icons` 的当前版本 `2.0.1` 替换为 `4.11.2`，将 `@material-ui/core`
    替换为 `4.11.3`，并重新安装所有依赖项。现在，当我们运行我们的测试时，我们收到以下输出：
- en: '![Figure 5.6 – Budget app failed test results](img/Figure_5.6_B16887.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6 – 预算应用失败的测试结果](img/Figure_5.6_B16887.jpg)'
- en: Figure 5.6 – Budget app failed test results
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – 预算应用失败的测试结果
- en: 'In the previous screenshot, the test results indicate that the dependency updates
    broke our tests. The results provide detailed information related to why each
    test failed. The following is a high-level version of the test results information
    displayed in the console:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，测试结果表明依赖项更新破坏了我们的测试。结果提供了有关为什么每个测试失败的相关详细信息。以下是在控制台显示的测试结果信息的概述：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the previous console output, the test results inform us of specific tests
    that failed due to not being able to find targeted `heading` elements in the DOM.
    When we updated the dependencies, a regression occurred in our source code. Error
    messages are also displayed in the console, providing information to pinpoint
    the problems in the source code. The following is a high-level version of the
    error messages displayed in the console:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的控制台输出中，测试结果告诉我们由于无法在 DOM 中找到目标 `heading` 元素而失败的特定测试。当我们更新依赖项时，我们的源代码中发生了回归。控制台中也显示了错误信息，提供了定位源代码中问题的信息。以下是在控制台中显示的错误信息的概要版本：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The error messages inform us that our source code is now using outdated property
    values from the material UI dependencies in the previous console output, which
    resulted in our tests not finding specific `heading` elements and failing. The
    error message output also tells us in which individual component file the error
    occurred under each error message. For example, the source of the error, `Material-UI:
    theme.spacing.unit usage has been deprecated.`, can be found here:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '错误信息告诉我们，我们的源代码现在正在使用来自先前控制台输出的材料 UI 依赖项中的过时属性值，这导致我们的测试无法找到特定的 `heading` 元素并失败。错误信息输出还告诉我们每个错误信息下错误发生的确切组件文件。例如，错误来源
    `Material-UI: theme.spacing.unit 使用已被弃用。` 可以在这里找到：'
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding console output informs us that the error source is on space `26`
    of line `27` of the `SetIncome` component file. Now that we know the specifics
    of why each test failed, we can update the source code appropriately.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 上述控制台输出告诉我们错误来源位于 `SetIncome` 组件文件的第 27 行的第 26 个空格。现在我们知道了每个测试失败的具体原因，我们可以相应地更新源代码。
- en: 'We will keep our tests running in watch mode while updating the source code
    to add confidence we will catch any new regressions that may occur due to updating
    the code. Once we update the code in our component files based on the error messages,
    we receive the following output when we run our tests:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新源代码以添加信心，确保我们会捕捉到由于更新代码可能发生的任何新回归时，我们将保持测试在监视模式下运行。一旦我们根据错误信息在我们的组件文件中更新了代码，当我们运行测试时，我们会收到以下输出：
- en: '![Figure 5.7 – Budget app updated dependency test results](img/Figure_5.7_B16887.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.7 – 预算应用更新依赖测试结果](img/Figure_5.7_B16887.jpg)'
- en: Figure 5.7 – Budget app updated dependency test results
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 – 预算应用更新依赖测试结果
- en: The preceding screenshot shows that all tests are now passing after updating
    the source code based on the error messages. Now you know how to update production
    dependencies and add tests to legacy applications. The great thing about using
    React Testing Library during this task is knowing that we never need to update
    our test code while we update the source code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图显示，在根据错误信息更新源代码后，所有测试现在都已通过。现在你知道了如何更新生产依赖项并向旧应用程序添加测试。在使用 React Testing
    Library 完成此任务时的好处是，我们知道在更新源代码时我们永远不需要更新我们的测试代码。
- en: Our test code does not depend on the components' implementation details, we
    are free to change the source code however necessary as long as the resulting
    DOM output and behavior do not change. In the next section, we will learn how
    to refactor tests for legacy code that uses Enzyme.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试代码不依赖于组件的实现细节，只要最终的 DOM 输出和行为不改变，我们就可以自由地更改源代码。在下一节中，我们将学习如何重构使用 Enzyme
    的旧代码的测试。
- en: Refactoring tests written with Enzyme
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构使用 Enzyme 编写的测试
- en: In the previous section, we learned how to update production dependencies and
    add component tests to legacy applications. In this section, we will learn how
    to replace existing legacy tests written in **Enzyme** with React Testing Library.
    Before React Testing Library was created, Enzyme was a popular library to test
    the UI of React components. Enzyme is a great tool, but the design of the API
    allows the implementation details of components to be tested, resulting in developers
    having to update test code frequently as they update their source code. We will
    replace legacy Enzyme tests with React Testing Library to resolve the problem
    of having to update tests that focus on implementation details continually.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何更新生产依赖项并向旧应用程序添加组件测试。在本节中，我们将学习如何用 React Testing Library 替换现有用
    **Enzyme** 编写的旧测试。在 React Testing Library 创建之前，Enzyme 是一个流行的库，用于测试 React 组件的 UI。Enzyme
    是一个伟大的工具，但 API 的设计允许测试组件的实现细节，导致开发者在更新源代码时必须频繁更新测试代码。我们将用 React Testing Library
    替换旧 Enzyme 测试，以解决需要不断更新关注实现细节的测试的问题。
- en: 'We will use this approach to refactor legacy Enzyme tests to keep the current
    tests while installing and incrementally refactoring them with React Testing Library.
    Please refer to [*Chapter 2*](B16887_02_Final_PG_ePub.xhtml#_idTextAnchor029),
    *Working with React Testing Library*, for installation instructions. Once we are
    finished refactoring the legacy code and all tests are passing, we will remove
    Enzyme from the application. The tests will be refactored to tests created in
    the *Creating the regression test suite* section of this chapter. The first test
    we will refactor verifies that a user can set an income amount:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这种方法重构遗留的Enzyme测试，以保留当前测试，并在安装和逐步重构它们的同时使用React Testing Library。请参阅[*第2章*](B16887_02_Final_PG_ePub.xhtml#_idTextAnchor029)，*使用React
    Testing Library*，以获取安装说明。一旦我们完成遗留代码的重构并且所有测试都通过，我们将从应用程序中移除Enzyme。测试将被重构为本章*创建回归测试套件*部分中创建的测试。我们将重构的第一个测试是验证用户可以设置收入金额：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding code, the `mount` method from Enzyme is used to render the
    `App` component in the DOM. Next, the `find` method is used to locate the `SetIncome`
    component and invoke the `setIncome` method with the value `1`. Finally, an assertion
    is made to verify that the text value of the `h3` element with the `id` of `income`
    equals `Income: $1`.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的代码中，使用了Enzyme的`mount`方法来在DOM中渲染`App`组件。接下来，使用`find`方法定位到`SetIncome`组件，并使用值`1`调用`setIncome`方法。最后，进行断言以验证具有`id`为`income`的`h3`元素的文本值等于`Income:
    $1`。'
- en: 'There are many implementation details that would break the test if changed.
    For example, if the names of the `SetIncome` component or the `setIncome` method
    are changed, the test would break. A change to `income id` would also break the
    test. We can refactor the test to focus on the user''s perspective like so:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多实现细节，如果更改这些细节将破坏测试。例如，如果`SetIncome`组件或`setIncome`方法的名称更改，测试将失败。对`income
    id`的更改也会破坏测试。我们可以重构测试，使其从用户的角度出发，如下所示：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the preceding code, we refactored the Enzyme test code that verifies that
    a user can set an income amount with React Testing Library. The next test that
    we will refactor verifies that the *Budget summary* section is updated when a
    user creates a budget:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们重构了使用React Testing Library验证用户可以使用React Testing Library设置收入金额的Enzyme测试代码。接下来，我们将重构的测试验证当用户创建预算时，*预算摘要*部分是否更新：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding code, first we render the `App` component in the DOM. Next,
    we use the `ceil` method from the `Math` object and the `parseInt` method to round
    the passed-in budget amount of `5` to the nearest multiple of `5`. Next, we use
    the `find` method to call the `addNewBudget` method inside the `CreateNewBudget`
    component with an object representing the budget.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先我们在DOM中渲染了`App`组件。接下来，使用`Math`对象中的`ceil`方法和`parseInt`方法将传入的预算金额`5`四舍五入到最接近的`5`的倍数。然后，使用`find`方法调用`CreateNewBudget`组件内部的`addNewBudget`方法，并传入一个表示预算的对象。
- en: 'Then, we call the `setTotalSpending` method in the same component with the
    result of the `budgetAmount` variable. Next, we will make assertions:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在同一组件中调用`setTotalSpending`方法，并传入`budgetAmount`变量的结果。接下来，我们将进行断言：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the previous code, we assert that the text value of the `h3` element with
    the `id` of `spending` is equal to `Spending: $5`. Finally, we assert that the
    text value of the `span` element with the `id` of `leftover` is equal to `$-5`.
    We can refactor the previous code with React Testing Library like so:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '在之前的代码中，我们断言具有`id`为`spending`的`h3`元素的文本值等于`Spending: $5`。最后，我们断言具有`id`为`leftover`的`span`元素的文本值等于`$-5`。我们可以使用React
    Testing Library重构之前的代码，如下所示：'
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the preceding code, we refactored the Enzyme test code that verifies that
    the *Budget summary* section is updated when a user creates a budget with React
    Testing Library. The next test that we will refactor verifies that a chart is
    displayed when a user creates a budget:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们重构了使用React Testing Library验证当用户使用React Testing Library创建预算时，*预算摘要*部分是否更新的Enzyme测试代码。接下来，我们将重构的测试验证当用户创建预算时是否显示图表：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding code, we render the `App` component in the DOM using the `mount`
    method and create a `budgetAmount` variable to convert the budget into a multiple
    of five similar to the previous test. Next. We use the `find` method to call the
    `addNewBudget` method inside the `CreateNewBudget` component and pass in a `budget`
    object.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用`mount`方法在DOM中渲染`App`组件，并创建一个`budgetAmount`变量将预算转换为与之前测试中类似的五的倍数。接下来，我们使用`find`方法在`CreateNewBudget`组件内部调用`addNewBudget`方法，并传入一个`budget`对象。
- en: 'Then, we call the `setTotalSpending` method inside `CreateNewBudget` and pass
    in the budget amount. Next, we call the `update` method to sync our test with
    the code created by the `Chart` component. Next, we can make assertions:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在 `CreateNewBudget` 中调用 `setTotalSpending` 方法并传入预算金额。接下来，我们调用 `update`
    方法以同步我们的测试与 `Chart` 组件创建的代码。接下来，我们可以进行断言：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding code, we assert that the `div` element with the `id` of `chart`
    is `truthy`, meaning it was found in the DOM. As we saw in the *Creating the regression
    test suite* section of this chapter, all the test cases for the budget application
    written in React Testing Library will pass as expected when run.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们断言具有 `id` 为 `chart` 的 `div` 元素是 `truthy`，这意味着它在 DOM 中被找到。正如我们在本章的
    *创建回归测试套件* 部分中看到的，使用 React 测试库编写的预算应用程序的所有测试用例在运行时都将按预期通过。
- en: 'Now that all the Enzyme tests have been refactored to React Testing Library,
    we can remove the `enzyme` and `enzyme-adapter-react-16` dependencies from the
    `package.json` file. We can also remove the following code from the `setupTests.js`
    file:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有酶测试都已重构为 React 测试库，我们可以从 `package.json` 文件中移除 `enzyme` 和 `enzyme-adapter-react-16`
    依赖。我们还可以从 `setupTests.js` 文件中移除以下代码：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding code is used to configure Enzyme to work in the test files. The
    code is no longer needed after removing Enzyme from the application. Now you know
    how to refactor legacy tests created with Enzyme to React Testing Library. The
    React Testing Library tests provide greater confidence and reduce the chances
    of tests breaking when we refactor the source code.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码用于配置 Enzyme 在测试文件中工作。在从应用程序中移除 Enzyme 之后，这段代码就不再需要了。现在你知道如何将使用 Enzyme 创建的遗留测试重构为
    React 测试库。React 测试库的测试提供了更大的信心，并减少了在重构源代码时测试中断的风险。
- en: In the next section, we will learn how to refactor tests created with `ReactTestUtils`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何重构使用 `ReactTestUtils` 创建的测试。
- en: Refactoring tests written with ReactTestUtils
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构使用 ReactTestUtils 编写的测试
- en: 'In the previous section, we learned how to convert tests written in Enzyme
    to React Testing Library. The process involved refactoring existing tests and
    then uninstalling the Enzyme library. In this section, we will use a similar process,
    only we will not have to uninstall an existing testing library. The `ReactTestUtils`
    module is included with React, so we can simply not import the module in our test
    file when we don''t want to use it. Since the refactoring process is similar to
    the previous section, we will only look at one example in this section. The test
    we will refactor verifies that a user can set an income amount:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何将使用 Enzyme 编写的测试转换为 React 测试库。这个过程涉及重构现有测试然后卸载 Enzyme 库。在本节中，我们将使用类似的过程，只是我们不需要卸载现有的测试库。`ReactTestUtils`
    模块包含在 React 中，因此当我们不想使用它时，我们只需在测试文件中不导入该模块即可。由于重构过程与上一节类似，我们本节将只查看一个示例。我们将重构的测试用于验证用户可以设置收入金额：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the preceding code, we import `React`, `ReactDOM`, and the `act` method.
    The `act` method imported from the `test-utils` module is used to sync component
    updates and ensure that our tests behave in ways similar to how React does in
    the browser. Next, we will arrange the code needed for the test:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们导入了 `React`、`ReactDOM` 和 `act` 方法。从 `test-utils` 模块导入的 `act` 方法用于同步组件更新并确保我们的测试行为与
    React 在浏览器中的行为相似。接下来，我们将安排测试所需的代码：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the preceding code, we create a `div` element to render in the DOM and assign
    it to the `container` variable. Next, we attach the `container` variable to the
    `body` element of the DOM. Then, we render the `App` component in `container`,
    wrapped in the `act` method. Next, we will grab DOM elements and assert on their
    text values:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建一个 `div` 元素以在 DOM 中渲染并将其分配给 `container` 变量。接下来，我们将 `container` 变量附加到
    DOM 的 `body` 元素上。然后，我们在 `container` 中渲染 `App` 组件，并用 `act` 方法包裹。接下来，我们将获取 DOM 元素并对其文本值进行断言：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the preceding code, we use the `querySelector` method to access the `income`,
    `spending`, and `leftover` elements in the DOM. Then, we assert the values of
    the previous three elements using the `textContent` property. Finally, we will
    add code to clean up the test:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用 `querySelector` 方法访问 DOM 中的 `income`、`spending` 和 `leftover` 元素。然后，我们使用
    `textContent` 属性断言前三个元素的值。最后，我们将添加代码来清理测试：
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the preceding code, we remove the container element from the DOM. Removing
    the container will ensure that we can start successive tests from a clean slate.
    We can refactor the previous test using React Testing Library:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们从 DOM 中移除了容器元素。移除容器将确保我们可以从一张干净的纸开始连续的测试。我们可以使用 React Testing Library
    对之前的测试进行重构：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the preceding code, we refactored the `SetIncome, given initial render,
    displays budget summary values` test using React Testing Library. The React Testing
    Library version of the test is cleaner and is more resilient to source code changes
    because it does not select DOM elements using implementation details. When we
    run the test, we get the following output:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用 React Testing Library 对 `SetIncome, given initial render, displays
    budget summary values` 测试进行了重构。React Testing Library 版本的测试更简洁，并且对源代码更改更具弹性，因为它不使用实现细节选择
    DOM 元素。当我们运行测试时，会得到以下输出：
- en: '![Figure 5.8 – Passing the set income test'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.8 – 通过设置收入测试'
- en: '](img/Figure_5.8_B16887.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 5.8](img/Figure_5.8_B16887.jpg)'
- en: Figure 5.8 – Passing the set income test
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8 – 通过设置收入测试
- en: The results show that the `SetIncome, given initial render, displays budget
    summary values` test passes as expected in the previous code. Now you know how
    to refactor tests created with the `ReactTestUtils` module. The skills learned
    in this section will arm you with the knowledge to refactor legacy test code to
    use modern testing tools.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示，`SetIncome, given initial render, displays budget summary values` 测试在之前的代码中按预期通过。现在你已了解如何使用
    `ReactTestUtils` 模块重构测试。本节学到的技能将帮助你将遗留的测试代码重构为使用现代测试工具。
- en: Refactoring tests to comply with common testing best practices
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构测试以符合常见的测试最佳实践
- en: 'In the previous section, we learned how to refactor tests created with ReactTestUtils.
    In this section, we will cover a few scenarios where we can refactor existing
    test code to be more robust and maintainable. We will use the following feedback
    form application to illustrate examples:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何使用 ReactTestUtils 重构测试。在本节中，我们将介绍一些场景，其中我们可以重构现有的测试代码，使其更健壮和易于维护。我们将使用以下反馈表单应用程序来展示示例：
- en: '![Figure 5.9 – Feedback form](img/Figure_5.9_B16887.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.9 – 反馈表单](img/Figure_5.9_B16887.jpg)'
- en: Figure 5.9 – Feedback form
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9 – 反馈表单
- en: 'In the preceding screenshot, we have a form for users to complete the **Name**
    and **Email** fields, as well as select a rating, enter comments, and finally,
    submit their information. If a user tries to submit the form with blank values
    for the required fields, an error message is displayed:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们有一个表单，用户可以填写 **姓名** 和 **电子邮件** 字段，以及选择评分、输入评论，最后提交他们的信息。如果用户尝试提交包含必填字段空白值的表单，则会显示错误消息：
- en: '![Figure 5.10 – Feedback form error validation'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.10 – 反馈表单错误验证'
- en: '](img/Figure_5.10_B16887.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 5.10](img/Figure_5.10_B16887.jpg)'
- en: Figure 5.10 – Feedback form error validation
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10 – 反馈表单错误验证
- en: 'In the preceding screenshot, form validation errors are displayed under each
    input with blank values. Finally, when a user submits the form with valid input
    data, a **Thank you** message is displayed:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，每个带有空值的输入下都显示了表单验证错误。最后，当用户提交包含有效输入数据的表单时，会显示一条**感谢**信息：
- en: '![Figure 5.11 – Submitted feedback form](img/Figure_5.11_B16887.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.11 – 提交反馈表单](img/Figure_5.11_B16887.jpg)'
- en: Figure 5.11 – Submitted feedback form
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11 – 提交反馈表单
- en: 'In the preceding screenshot, the message **We appreciate your responses John
    Doe!** is displayed. The **John Doe** part of the message is the value entered
    for the **Name** input element in the form. The first test we will refactor verifies
    that an error message is displayed when invalid emails are entered:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，显示了消息 **我们感谢您的回复，John Doe！** 消息中的 **John Doe** 部分是表单中 **姓名** 输入元素的输入值。我们将重构的第一个测试是验证当输入无效电子邮件时，会显示错误消息：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the preceding code, first, the `each` method from Jest was used to run the
    same test with different values: `a`, `a@b`, and `a@b.c`. Next, we see the test
    name, `displays error message`. The test name is vague because it does not provide
    enough details regarding the context of the test. It is common to use test naming
    conventions to eliminate issues with vague test names. There are many popular
    naming conventions, such as `when_stateUnderTest_expect_expectedBehavior` and
    `given_preconditions_when_stateUnderTest_then_expectedBehavior`, that describe
    the code under test, the actions performed on the code, and finally, the expected
    result. The important thing to remember is to use a naming convention in agreement
    with your project team.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先，使用了Jest的`each`方法用不同的值运行相同的测试：`a`、`a@b`和`a@b.c`。接下来，我们看到测试名称，`displays
    error message`。测试名称比较模糊，因为它没有提供足够的细节来描述测试的上下文。使用测试命名约定来消除模糊测试名称的问题是很常见的。有许多流行的命名约定，例如`when_stateUnderTest_expect_expectedBehavior`和`given_preconditions_when_stateUnderTest_then_expectedBehavior`，它们描述了被测试的代码、对代码执行的操作以及最终的预期结果。重要的是要记住使用与您的项目团队一致的命名约定。
- en: 'We will use the following convention, `component under test, given preconditions,
    expected results`, in our refactoring efforts. We can refactor the current test
    name like so:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的重构工作中，我们将使用以下约定，`组件，给定先决条件，预期结果`。我们可以像这样重构当前的测试名称：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding code, we refactor the current test name to `Form, given invalid
    email value "$value", displays error message`. When reading the test name, it
    is clear now that we are testing a `Form` component, the given preconditions are
    invalid values, and the expected result is to see an error message on the screen.
    Notice the `$value` variable in the test name. The variable will be replaced with
    the name of the current value for each test iteration, further providing context
    to understand the specific test code.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将当前的测试名称重构为`Form, given invalid email value "$value", displays error
    message`。当阅读测试名称时，现在很清楚我们正在测试一个`Form`组件，给定的先决条件是无效的值，预期的结果是屏幕上显示错误消息。注意测试名称中的`$value`变量。该变量将在每个测试迭代中替换为当前值的名称，从而进一步提供上下文以理解特定的测试代码。
- en: 'Next, we will analyze and refactor the main test code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将分析和重构主要测试代码：
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the preceding code, the object destructuring approach was used to access
    the `getByRole` and `getByText` query methods. However, the destructing approach
    requires you to manually keep track of which queries to add or remove as you build
    out the test code. As mentioned in [*Chapter 1*](B16887_01_Final_PG_ePub.xhtml#_idTextAnchor013),
    *Exploring React Testing Library*, we can use the `screen` object to access query
    methods starting in version **9** of React Testing Library.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，使用了对象解构方法来访问`getByRole`和`getByText`查询方法。然而，解构方法需要您手动跟踪在构建测试代码时添加或删除哪些查询。如[*第1章*](B16887_01_Final_PG_ePub.xhtml#_idTextAnchor013)中提到的，*探索React测试库*，从React测试库的**9**版本开始，我们可以使用`screen`对象来访问查询方法。
- en: 'Using the `screen` object to access query methods is easier to maintain and
    results in cleaner code than the destructuring approach. The `waitFor` method
    is also used to grab and verify that the error message is displayed asynchronously
    in the DOM. However, the `findBy*` queries of the `screen` object are also asynchronous
    and are easier-to-use options than `waitFor` when you need to query elements that
    take time to appear on the screen. We can refactor the current test code like
    so:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`screen`对象访问查询方法比解构方法更容易维护，并产生更简洁的代码。`waitFor`方法也用于异步抓取和验证错误消息是否在DOM中显示。然而，`screen`对象的`findBy*`查询也是异步的，并且当您需要查询在屏幕上需要时间才能出现元素时，它们是比`waitFor`更容易使用的选项。我们可以像这样重构当前的测试代码：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the preceding code, we replaced the destructured queries to access via the
    screen object. We also replaced the `waitFor` method with an asynchronous `findByText`
    query. Now the test code is cleaner and easier to maintain.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将解构查询替换为通过屏幕对象访问。我们还用异步的`findByText`查询替换了`waitFor`方法。现在测试代码更简洁，更容易维护。
- en: 'The next test we will refactor verifies that an error message is displayed
    when a user doesn''t enter a value for any required form input:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个我们将重构的测试验证了当用户未为任何必填表单输入输入值时，会显示错误消息：
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the preceding code, first, the application is rendered in the DOM. Next,
    the test is arranged by grabbing all the form `input` elements and storing them
    in respective values. Next, actions are performed on the form elements:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先，应用程序被渲染到 DOM 中。接下来，通过获取所有表单 `input` 元素并将它们存储在相应的值中，对测试进行了安排。接下来，对表单元素执行以下操作：
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the preceding code, each `input` element is clicked. Then, pressing the
    *Tab* key on the keyboard simulates to move the focus away from the actively selected
    `ratingSelect` element. Finally, four assertions are made:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，每个 `input` 元素都被点击。然后，按键盘上的 *Tab* 键模拟将焦点从活动选择的 `ratingSelect` 元素移开。最后，进行了四个断言：
- en: '[PRE32]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding code, an assertion is made to verify that specific error messages
    are displayed for empty form values. However, if, for example, the first assertion
    for the **name required** error message fails, the test fails and none of the
    other assertions will be made. This approach of multiple assertions in the same
    test is not a good practice because we will not know whether the code for the
    remaining assertions works as expected.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，有一个断言用于验证在表单值为空时显示特定的错误消息。然而，例如，如果对于**姓名必填**错误消息的第一个断言失败，测试将失败，并且不会执行其他任何断言。在同一个测试中进行多个断言的方法不是一种好的实践，因为我们无法知道剩余断言的代码是否按预期工作。
- en: 'Each assertion in the test is independent of other assertions, and therefore,
    should live inside their own individual test. We can refactor the test like so:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 测试中的每个断言都是独立的，因此应该位于它们自己的单独测试中。我们可以这样重构测试：
- en: '[PRE33]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the preceding code, first, we use the `each` method to create individual
    tests for the `input` element names. The input names will be passed to the `inputLabel`
    variable for each test run. Next, we will write the main test code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先，我们使用 `each` 方法为 `input` 元素名称创建单独的测试。输入名称将传递给每个测试运行的 `inputLabel`
    变量。接下来，我们将编写主要的测试代码：
- en: '[PRE34]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the preceding code, first, we render the `App` component in the DOM. Next,
    we click the input label using `getByText`. Then, we simulate pressing the *Tab*
    key to move the focus away from the `input` element. Finally, we grab the element
    with the error message, store it in the `errorMessage` variable, and verify that
    it is in the DOM. We get the following output when we run the refactored tests:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先，我们在 DOM 中渲染 `App` 组件。接下来，我们使用 `getByText` 点击输入标签。然后，我们模拟按下 *Tab*
    键将焦点从 `input` 元素移开。最后，我们获取带有错误消息的元素，将其存储在 `errorMessage` 变量中，并验证它是否在 DOM 中。当我们运行重构后的测试时，我们得到以下输出：
- en: '![Figure 5.12 – Feedback form test results'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.12 – 反馈表单测试结果'
- en: '](img/Figure_5.12_B16887.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.12_B16887.jpg)'
- en: Figure 5.12 – Feedback form test results
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.12 – 反馈表单测试结果
- en: In the preceding screenshot, all refactored test cases pass as expected. Now
    you know how to refactor tests to use testing best practices of naming conventions
    and splitting multiple assertions from one test into individual tests. You also
    learned how to refactor legacy tests written in React Testing Library to modern
    approaches.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，所有重构的测试用例都按预期通过。现在你知道如何重构测试以使用命名约定和将多个断言从单个测试中拆分到单独测试中的测试最佳实践。你还学习了如何将用
    React 测试库编写的遗留测试重构为现代方法。
- en: Summary
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have learned how to reduce the burden of updating production
    dependencies of legacy applications. You learned how to refactor legacy tests
    using the modern React Testing Library tool. You also learned a few testing best
    practices. The skills acquired in this chapter should give you the confidence
    that you can successfully refactor outdated code to current versions without significant
    issues. You should also be able to refactor test code to be more maintainable.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何减轻遗留应用程序更新生产依赖项的负担。你学习了如何使用现代 React 测试库工具重构遗留测试。你还学习了一些测试最佳实践。本章获得的知识应该让你有信心，你可以成功重构过时的代码到当前版本而不会出现重大问题。你也应该能够重构测试代码以使其更易于维护。
- en: In the next chapter, we will learn about additional tools and plugins for testing.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习关于测试的额外工具和插件。
- en: Questions
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Explain the benefits of using React Testing Library compared to tools such as
    Enzyme or `ReactTestUtils`.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释与 Enzyme 或 `ReactTestUtils` 等工具相比使用 React 测试库的好处。
- en: Explain the benefits of running tests in Jest's watch mode.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释在 Jest 的监视模式下运行测试的好处。
- en: When should you use the `each` method from Jest when writing tests?
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你在编写测试时应该何时使用 Jest 的 `each` 方法？
