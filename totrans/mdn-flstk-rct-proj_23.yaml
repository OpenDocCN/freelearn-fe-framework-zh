- en: '18'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Advanced Next.js Concepts and Optimizations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we’ve learned about the essential features of Next.js and **React Server
    Components** (**RSCs**), let’s dive a bit deeper into the Next.js framework. In
    this chapter, we are going to learn how caching works in Next.js and how it can
    be used to optimize our applications. We are also going to learn how to implement
    API routes in Next.js. Then, we are going to learn how to optimize a Next.js app
    for search engines and social media by adding metadata. Finally, we are going
    to learn how to optimally load images and fonts in Next.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining API routes in Next.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caching in Next.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Search engine optimization** (**SEO**) with Next.js'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimized image and font loading in Next.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start, please install all the requirements from [*Chapter 1*](B19385_01.xhtml#_idTextAnchor016),
    *Preparing For Full-Stack Development*, and [*Chapter 2*](B19385_02.xhtml#_idTextAnchor028),
    *Getting to Know Node.js* *and MongoDB*.
  prefs: []
  type: TYPE_NORMAL
- en: The versions listed in those chapters are the ones used in this book. While
    installing a newer version should not be an issue, please note that certain steps
    might work differently. If you are having an issue with the code and steps provided
    in this book, please try using the versions mentioned in [*Chapter 1*](B19385_01.xhtml#_idTextAnchor016)
    and *2*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the code for this chapter on GitHub: [https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch18](https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch18).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The CiA video for this chapter can be found at: [https://youtu.be/jzCRoJPGoG0](https://youtu.be/jzCRoJPGoG0).'
  prefs: []
  type: TYPE_NORMAL
- en: Defining API routes in Next.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we used RSCs to access our database via a data layer;
    no API routes were needed for that! However, sometimes, it still makes sense to
    expose an external API. As an example, we might want to allow third-party apps
    to query blog posts. Thankfully, Next.js also has a feature to define API routes,
    called Route Handlers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Route Handlers are also defined inside the `src/app/` directory but in a `route.js`
    file instead of a `page.js` file (a path can only be either a route or a page,
    so only one of these files should be placed inside a folder). Instead of exporting
    a page component, we need to export functions that handle various types of requests
    there. For example, to handle a `GET` request, we must define and export the following
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next.js supports the following HTTP methods for Route Handlers: `GET`, `POST`,
    `PUT`, `PATCH`, `DELETE`, `HEAD`, and `OPTIONS`. For unsupported methods, Next.js
    will return a `405 Method Not` `Allowed` response.'
  prefs: []
  type: TYPE_NORMAL
- en: Next.js supports the native `Request` ([https://developer.mozilla.org/en-US/docs/Web/API/Request](https://developer.mozilla.org/en-US/docs/Web/API/Request))
    and `Response` ([https://developer.mozilla.org/en-US/docs/Web/API/Response](https://developer.mozilla.org/en-US/docs/Web/API/Response))
    web APIs but extends them into `NextRequest` and `NextResponse` APIs, which make
    handling cookies and headers easier. We used the `cookies()` function from Next.js
    to easily create, get, and delete a cookie for the JWT in the previous chapter.
    The `headers()` function makes it easy to get headers from a request. These functions
    can be used in the same way in RSCs and Route Handlers.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an API route for listing blog posts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start by defining an API route for listing blog posts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the existing **ch17** folder to a new **ch18** folder, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the **ch18** folder in VS Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make the API routes easier to distinguish from pages on our app, create a
    new **src/app/api/** folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the **src/app/api/** folder, create a new **src/app/api/v1/** folder
    to make sure our API is versioned for potential changes to the API later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, create a **src/app/api/v1/posts/** folder for the **/****api/v1/posts**
    route.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new **src/app/api/posts/route.js** file, where we import the **initDatabase**
    function and the **listAllPosts** function from the data layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, define and export a **GET** function. This is going to handle HTTP GET
    requests to the **/****api/v1/posts** route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside it, we must initialize the database and get a list of all posts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the **Response** web API to generate a JSON response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure Docker and the MongoDB container are running properly!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start the Next.js app, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, go to **http://localhost:3000/api/v1/posts** to see the posts being returned
    as JSON, as shown in the following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 18.1 – JSON response with posts generated from the Next.js Route Handler](img/B19385_18_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18.1 – JSON response with posts generated from the Next.js Route Handler
  prefs: []
  type: TYPE_NORMAL
- en: Now, third-party apps can also get the posts via our API! Let’s continue by
    learning more about caching in Next.js.
  prefs: []
  type: TYPE_NORMAL
- en: Caching in Next.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have always been using Next.js in dev mode. In dev mode, most of
    the caching that Next.js does is turned off to make it easy for us to develop
    our apps with hot reloading and always up-to-date data. However, once we switch
    to production mode, static rendering and caching are turned on by default. Static
    rendering means that if a page only contains static components (such as an “About
    Us” or “Imprint” page, which only contains static content), it will be statically
    rendered and served as HTML, or as static text/JSON for routes. Additionally,
    Next.js will try to cache data and server-side rendered components as much as
    possible to keep your app performant.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next.js has four main types of cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data cache**: A server-side cache for storing data across user requests and
    deployments. This is persistent but can be revalidated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Request memoization**: A server-side cache for return values of functions
    if they are called multiple times in a single request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Full route cache**: A server-side cache of Next.js routes. This cache is
    persistent but can be revalidated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Router cache**: A client-side cache of routes to reduce server requests on
    navigation, for a single user session or time-based.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first two types of cache (data cache and request memoization) mainly apply
    to using the `fetch()` function on the server side to, for example, pull data
    from a third-party API. However, recently, it is also possible to use these two
    types of caches for any function by wrapping them with the `unstable_cache()`
    function. Despite its name, this function can already safely be used in production.
    It is only called “unstable” because the API might change and require code changes
    when new Next.js versions are released. See [https://nextjs.org/docs/app/api-reference/functions/unstable_cache](https://nextjs.org/docs/app/api-reference/functions/unstable_cache)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, the React **cache()** function could be used to memoize return
    values of functions, but the Next.js **unstable_cache()** function is more flexible,
    allowing us to dynamically revalidate the cache via a path or tag. We are going
    to learn more about cache revalidation later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: The full route cache is an additional cache that makes sure that when data doesn’t
    change, we don’t even need to re-render pages on the server side so that Next.js
    can directly return pre-rendered static HTML and the RSC payload. However, invalidating
    the data cache will also invalidate the corresponding full route cache and trigger
    a re-render.
  prefs: []
  type: TYPE_NORMAL
- en: The router cache is a client-side cache and is mainly used when the user navigates
    between pages, allowing us to instantly show pages that they have already visited
    without having to fetch them from the server again.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, if Next.js detects that a page or route only contains static content,
    it will pre-render and store it as static content. Static content cannot be revalidated
    anymore, so we need to be careful and ensure that all dynamic content on our apps
    is considered “dynamic” by Next.js and not accidentally detected as “static” content.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we call this process **static rendering**. However, on other resources,
    it may also be called “automatic static optimization” or “static site generation.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Next.js will opt out of static rendering and consider a page or route dynamic
    in the following instances:'
  prefs: []
  type: TYPE_NORMAL
- en: When using a dynamic function, such as **cookies()**, **headers()**, or **searchParams**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When setting **export const dynamic = 'force-dynamic'** or **export const revalidate
    = 0**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a Route Handler handles a non-GET request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For more in-depth information on the different types of caching, have a look
    at the Next.js documentation on caching: [https://nextjs.org/docs/app/building-your-application/caching](https://nextjs.org/docs/app/building-your-application/caching).'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s explore how static rendering works in practice by looking at how
    our route behaves in a production build of our app.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring static rendering in API routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter, we implemented a Route Handler for getting blog posts. Now,
    let’s explore how this route behaves in dev and production mode:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit **src/app/api/v1/posts/route.js** and add a **currentTime** value with
    **Date.now()** to the response, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Refresh the page on **http://localhost:3000/api/v1/posts** a couple of times;
    you will see that **currentTime** is always the latest timestamp.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Quit the Next.js development server by using *Ctrl* + *C*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Build the Next.js app for production and start it, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Refresh the page on **http://localhost:3000/api/v1/posts** a couple of times.
    Now, **currentTime** doesn’t change at all! Even if we restart the Next.js server,
    **currentTime** still doesn’t change. The response of the **GET /api/v1/posts**
    route is statically rendered during build time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Static rendering works similarly for routes and pages, so pages will also be
    statically rendered by default. This means that RSCs do *not* require a server,
    per se; they can also run during build time. We only need a Node.js server if
    we want to have dynamic pages/routes. This means we could, for example, create
    a blog or website in Next.js and export a static bundle, allowing us to host it
    on a simple web server.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Exporting a Next.js app as a static bundle can be achieved by specifying the
    **output: ''export''** option in the **next.config.js** file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Interestingly, if we create a new blog post, our home page *does* get updated.
    However, that is only the case because `RootLayout` uses `cookies()` to check
    if the user is logged in, making all pages on our blog app dynamic (and thus not
    statically rendered). This can also be seen by looking at the output of `npm`
    `run build`:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 18.2 – Seeing which routes are statically and dynamically \uFEFFrendered\
    \ in the build output](img/B19385_18_2.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 18.2 – Seeing which routes are statically and dynamically rendered in
    the build output
  prefs: []
  type: TYPE_NORMAL
- en: As can be seen from *Figure 18**.2*, the `/api/v1/posts` route is “prerendered
    as static content,” while all other routes are “server-rendered on demand using
    Node.js.”
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If we wanted to statically render some pages in our blog, we would have to make
    sure the user bar isn’t visible on those pages. For example, we could create a
    **route group** ([https://nextjs.org/docs/app/building-your-application/routing/route-groups](https://nextjs.org/docs/app/building-your-application/routing/route-groups))
    for all pages that have a user bar, with a separate layout that contains the user
    bar. Then, we can remove the user bar from the root layout. That way, we could
    create, for example, an About page that is statically rendered while keeping the
    rest of the blog dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen, in Next.js, pages and routes are statically rendered by default
    (if possible). However, in the case of our API route, this is not what we want!
    We want to be able to dynamically fetch posts from the API. Static rendering and
    caching in Next.js can be confusing when we’re starting out developing apps with
    it, but it becomes a powerful tool for keeping our apps optimized.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s learn how to properly handle the cache to make our pages and routes
    dynamic when they need to be while keeping them cached whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: Making the route dynamic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To make the route dynamic, we need to set the `export const dynamic = ''force-dynamic''`
    flag on it. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit **src/app/api/v1/posts/route.js** and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Quit the currently running Next.js server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Build the Next.js app for production and start it, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Refresh the page on **http://localhost:3000/api/v1/posts** a couple of times.
    Now, the API route behaves the same way as it did on the development server!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unfortunately, we now have completely disabled the cache, so we also don’t get
    any of the benefits of using a cache. Next, we’ll learn how to turn on the cache
    for specific functions.
  prefs: []
  type: TYPE_NORMAL
- en: Caching functions in the data layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To cache functions from our data layer, we can use the `unstable_cache()` function
    from Next.js. The `unstable_cache(fetchData, keyParts, options)` function accepts
    three arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '**fetchData**: The first argument is the function to be called. The function
    can also have arguments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**keyParts**: The second argument is an array of unique keys that identify
    the function in the cache. Arguments that are passed to the function in the first
    argument will automatically be added to this array as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**options**: The third argument is an object containing options for the cache,
    where we can specify **tags** to revalidate the cache later, and a **revalidate**
    timeout to automatically revalidate the cache after a certain number of seconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let’s enable this cache for all functions where it makes sense. Follow
    these steps to get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit **src/data/posts.js** and import the **unstable_cache()** function, aliasing
    it as **cache()**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Wrap the **listAllPosts** function with **cache()**, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, wrap the **getPostById** function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You may notice that there is now an error when getting posts because **ObjectId**
    from MongoDB is getting serialized into a string by the cache. Edit **src/components/Post.jsx**
    and adjust **propType**, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit **src/data/users.js** and import **unstable_cache** there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Wrap the **getUserInfoById** function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Quit the currently running Next.js server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Rebuild and start the app in production. You will notice that after creating
    a new post, it does not update the home page (or the API route) anymore:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That’s because our posts are now cached!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This cache even works in dev mode. Quit the Next.js server and start it again,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a new post; you will see that neither the home page nor the API route
    has the newly created post in the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that caching has been configured, let’s learn how to deal with revalidating
    the cache (causing data in the cache to be updated).
  prefs: []
  type: TYPE_NORMAL
- en: Revalidating the cache via Server Actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The best way of dealing with stale data is to revalidate the cache when new
    data comes in, for example, via Server Actions. To do this, we have two options:'
  prefs: []
  type: TYPE_NORMAL
- en: Revalidating all route segments at a specific path by using the **revalidatePath**
    function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Revalidating with a specific tag (and thus potentially revalidating multiple
    paths) by using the **revalidateTag** function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Revalidation means that the next time data is requested from the cached function,
    the function will be called, and new data will be returned and cached (instead
    of returning previously cached data). Both functions revalidate the data cache
    and thus revalidate the full router cache and the client-side router cache as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to call the `revalidateTag` function after creating new
    posts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit **src/app/create/page.js** and import the **revalidateTag** function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside **createPostAction**, call the **revalidateTag** function on the **posts**
    tag after creating the new post:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, create a new post and go to the home page. You will see that the newly
    created post appears in the list! The API route will also show the newly created
    post now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Revalidating the cache when data is changed via Server Actions is the most direct
    way of updating the cache. However, sometimes, we will be fetching data from third-party
    APIs, where revalidating is not possible. We’ll explore this case now.
  prefs: []
  type: TYPE_NORMAL
- en: Revalidating the cache via a Webhook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the data comes from a third-party source, we can revalidate the cache via
    a Webhook. Webhooks are APIs that can be used as callbacks. For example, when
    data changes, the third-party source calls our API endpoint to let us know that
    we need to re-fetch the data.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating a third-party API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we can start implementing a Webhook, let’s integrate a third-party API
    into our app. For this example, we are going to use the WorldTimeAPI ([https://worldtimeapi.org/](https://worldtimeapi.org/)),
    but feel free to use any API of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start implementing a page that fetches from a third-party API:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new **src/app/time/** folder. Inside it, create a new **src/app/time/page.js**
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit **src/app/time/page.js** and define an asynchronous page component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the component, fetch the current time from the WorldTimeAPI and parse
    the response as JSON:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Render the current timestamp:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you go to the **http://localhost:3000/time** page in your browser, you will
    see that it shows the current time. However, when refreshing, the time never updates.
    That is because requests with **fetch** are cached by default, similar to what
    happened after we added **unstable_cache()** to our data layer functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementing the Webhook
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let’s create a Webhook API endpoint in our app that, when called, revalidates
    the cache for the third-party data:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new **src/app/api/v1/webhook/** folder. Inside it, create a new **src/app/api/v1/webhook/route.js**
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit **src/app/api/v1/webhook/route.js** and import the **revalidatePath**
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, define a new **GET** Route Handler that calls **revalidatePath** on the
    **/time** page and then returns a response telling us that it was successful:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Usually, Webhooks are defined as `POST` Route Handlers (because they influence
    the state of the app), but to make it simpler to trigger the Webhook by visiting
    the page in our browser, we defined it as a `GET` Route Handler. A `POST` route
    would opt out of static rendering, but a `GET` route does not, so we need to specify
    `force-dynamic`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Visit **http://localhost:3000/api/v1/webhook** in your browser, then visit **http://localhost:3000/time**
    again; you should see that the time has been updated! In the real world, we would
    be adding our Webhook URL to the interface of the third-party website that provides
    the API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we could add a tag to the request by passing the **next.tags**
    option in the **fetch()** function, as follows: **fetch(''https://worldtimeapi.org/api/timezone/UTC'',
    { next: { tags: [''time''] } })**. Then, we could revalidate the cache by calling
    **revalidateTag(''time'')**.'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, revalidating the cache using Webhooks works great. However, sometimes,
    we cannot even add a Webhook to a third-party API. Let’s explore what to do when
    we have no control over the third-party API.
  prefs: []
  type: TYPE_NORMAL
- en: Revalidating the cache periodically
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we have no control whatsoever over the third-party data source, we can tell
    Next.js to periodically revalidate the cache. Let’s set that up now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit **src/app/time/page.js** and adjust the **fetch()** function, adding the
    **next.revalidate** option to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this case, we told Next.js to revalidate the data cache the next time the
    API is requested if at least 10 seconds have passed since the last request.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: With **unstable_cache()**, we can pass the **revalidate** option in the third
    argument. For routes and pages, we can specify **export const revalidate = 10**,
    which will revalidate the corresponding route/page.
  prefs: []
  type: TYPE_NORMAL
- en: Refresh the **http://localhost:3000/time** page in your browser. You will see
    the time update. Refresh the page again; the time will not update again. If you
    refresh after at least 10 seconds, the time will update again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have learned about revalidating the cache periodically, let’s learn
    about opting out of caching.
  prefs: []
  type: TYPE_NORMAL
- en: Opting out of caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, you may want to opt out of caching completely for certain requests.
    To do this, pass the following option to the `fetch` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: export const metadata = {
  prefs: []
  type: TYPE_NORMAL
- en: 'title: ''Full-Stack Next.js Blog'','
  prefs: []
  type: TYPE_NORMAL
- en: 'description: ''A blog about React and Next.js'','
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: export async function generateMetadata({ params }) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: const id = params.id
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: const post = await getPostById(id)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if (!post) notFound()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: return {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'title: `${post.title} | Full-Stack Next.js Blog`,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'description: `Written by ${post.author.username}`,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'User-agent: *'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Allow: /'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: export default async function ViewPostPage({ params }) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: await initDatabase()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: const [id] = params.path
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: const post = await getPostById(id)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: export async function generateMetadata({ params }) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: const [id] = params.path
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ npm install slug@8.2.3
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: import slug from 'slug'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <Link href={`/posts/${_id}/${slug(title)}`}>{title}</Link>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: BASE_URL=http://localhost:3000
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: import { initDatabase } from '@/db/init'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: import { listAllPosts } from '@/data/posts'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: import slug from 'slug'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: export default async function sitemap() {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: const staticPages = [
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'url: `${process.env.BASE_URL}`,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '},'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'url: `${process.env.BASE_URL}/create`,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '},'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'url: `${process.env.BASE_URL}/login`,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '},'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'url: `${process.env.BASE_URL}/signup`,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '},'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'url: `${process.env.BASE_URL}/time`,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '},'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ']'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: await initDatabase()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: const posts = await listAllPosts()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: const postsPages = posts.map((post) => ({
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'url: `${process.env.BASE_URL}/posts/${post._id}/${slug(post.title)}`,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'lastModified: post.updatedAt,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}))'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: return [...staticPages, ...postsPages]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: import { Inter } from 'next/font/google'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: const inter = Inter({
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'subsets: [''latin''],'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'display: ''swap'','
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '})'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <html lang='en' className={inter.className}>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: import Image from 'next/image'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: import logo from './logo.png'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: return (
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <html lang='en' className={inter.className}>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <body>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <Image
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: src={logo}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: alt='Full-Stack Next.js Blog Logo'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: width={500}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: height={47}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: />
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <nav>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <Navigation username={user?.username} logoutAction={logoutAction} />
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </nav>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
