<html><head></head><body>
		<div id="_idContainer067">
			<h1 id="_idParaDest-178" class="chapter-number"><a id="_idTextAnchor410"/>12</h1>
			<h1 id="_idParaDest-179"><a id="_idTextAnchor411"/>Automated Testing for React Native Apps</h1>
			<p><a id="_idTextAnchor412"/><a id="_idTextAnchor413"/>Automating tests is one of the most important things you must do when your project grows. It can help ensure a certain level of quality of your application and can enable you to run faster release cycles without introducing bugs in every release. I recommend writing automated tests for your application as soon as possible.</p>
			<p>It is much easier to start writing tests right from the beginning because then, you are forced to structure your code in a way that works for automated testing. It can be hard to refactor an application to use automated testing when this wasn’t in focus at the beginning.</p>
			<p>In this chapter, you will learn about automated testing in general and how to use automated testing in React Native apps. You will learn about the different tools and frameworks for different types of automated testing. These tools and frameworks are used in production by some of the most widely used apps in the world, so I recommend using them.</p>
			<p>To give you a good overview of all these topics, this chapter will cover the following topics. If you are already familiar with automated testing in general, you can skip the first section:</p>
			<ul>
				<li><a id="_idTextAnchor414"/>U<a id="_idTextAnchor415"/>nderstanding automated testing</li>
				<li>Working with unit and integration tests in React Native</li>
				<li><a id="_idTextAnchor416"/>W<a id="_idTextAnchor417"/>orking with component tests</li>
				<li>Understanding end-to-end tests</li>
			</ul>
			<h1 id="_idParaDest-180"><a id="_idTextAnchor418"/>Technical requirements</h1>
			<p>To be able to run the code in this chapter, you must set up the following:</p>
			<ul>
				<li>A working React Native environment (<a href="https://bit.ly/prn-setup-rn">bit.ly/prn-setup-rn</a> – React Native CLI Quickstart).</li>
				<li>While most of this chapter should also work on Windows, I recommend working on a Mac. You need to work on a Mac to run Detox end-to-end tests on iOS simulators.</li>
				<li>An AWS account for accessing AWS Device Farm.</li>
			</ul>
			<h1 id="_idParaDest-181"><a id="_idTextAnchor419"/>U<a id="_idTextAnchor420"/>nderstanding automated testing</h1>
			<p>There are different forms of <a id="_idIndexMarker681"/>automated testing. The following forms of automated testing are the most common ones and will be covered in this chapter:</p>
			<ul>
				<li><strong class="bold">Unit tests</strong>: Unit tests cover the<a id="_idIndexMarker682"/> smallest parts of your business logic, such as single functions.</li>
				<li><strong class="bold">Integration tests</strong>: This form of testing <a id="_idIndexMarker683"/>works very similar to unit tests in React Native, but it covers multiple pieces of your business logic and tests whether the integration of these parts works as expected.</li>
				<li><strong class="bold">Component tests</strong>: These tests cover your React Native UI components and check whether they do what they are <a id="_idIndexMarker684"/>expected to do. You can also check for (unexpected) changes in your components with this form of testing.</li>
				<li><strong class="bold">End-to-end tests</strong>: This form of <a id="_idIndexMarker685"/>testing simulates end user behavior and checks whether your whole application behaves like it is expected to do.</li>
			</ul>
			<p>To get the most out of automated testing, you should implement all four types of tests. All of them cover different areas of your application and can help you find different types of errors that the other types of testing can’t find.</p>
			<p>When working with automated testing, you should<a id="_idIndexMarker686"/> try to have high <strong class="bold">code coverage</strong>. Code coverage describes the percentage of your code that is covered by your automated tests. While it is a good metric to get an idea of whether automated tests are used in a project and that you didn’t forget any parts of your application, it has little significance on its own.</p>
			<p>This is because it doesn’t help to <a id="_idIndexMarker687"/>write one test for every line of code you have. When working with automated tests, especially unit tests, integration tests, and component tests, you should always write multiple tests for the part you want to test, covering the most common use cases as well as important edge cases. This means you have to think a lot before writing your tests.</p>
			<p>With unit tests, integration tests, and component tests, you typically test small parts of your application. This also means you have to create an environment where these small parts can work on their own. This can be achieved by mocking dependencies that are used in the tested part.</p>
			<p><strong class="bold">Mocking</strong> means writing your <a id="_idIndexMarker688"/>own implementation of a dependency for the testing environment, to ensure it behaves as expected and to rule out that an error in the dependency leads to an error in the test.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">It’s not always clear which parts of an application should be mocked in a test. I would recommend mocking more rather than less in unit tests because you want to test whether a very small part of your code behaves as it is expected to. In integration and component tests, I recommend mocking less rather than more because you want to test larger parts of your application and see whether the whole combination works.</p>
			<p>Because unit tests, integration tests, and component tests run in a test environment and use only parts of your application, they are very reliable. There aren’t many things that can interfere with these t<a id="_idTextAnchor421"/>e<a id="_idTextAnchor422"/>sts to distort the test results. This is different compared to working with end-to-end tests.</p>
			<p>These tests run on your real application on a simulator or real device and depend on things such as network connectivity or other device behavior. This <a id="_idIndexMarker689"/>can lead to <strong class="bold">test fl<a id="_idTextAnchor423"/>a<a id="_idTextAnchor424"/>kiness</strong>. A flaky test is a test that passes and fails on different test runs without any code changes.</p>
			<p>This is a real problem because it results in you having to manually check whether the test fails only because it is flaky or because it found a bug in your application. We’ll cover test flakiness in more detail in the <em class="italic">Understanding end-to-end tests</em> section.</p>
			<p>But first, we’ll start <a id="_idIndexMarker690"/>by testing the business logic parts of our application automatically by using unit and integration tests.</p>
			<h1 id="_idParaDest-182"><a id="_idTextAnchor425"/>Working with unit and integration tests in React Native</h1>
			<p>When you start a new <a id="_idIndexMarker691"/>React Native project, it comes with a testing framework called <strong class="bold">Jest</strong> preconfigured. This is the<a id="_idIndexMarker692"/> recommended framework for unit tests, integration tests, and component tests. We’ll use it in the following sections.</p>
			<p>Let’s start with unit testing. We’ll use our example project again, but we will go back a few commits to use the local movie service implementation. You can have a look at the complete code by selecting the <strong class="source-inline">chapter-12-unit-testing</strong> branch in the example repository.</p>
			<p>This local service implementation is very suitable as an example for unit testing because it has no dependencies. We know the data it is working on and can write tests very easily. In this example, we’ll test two API calls: <strong class="source-inline">getMovies</strong> and <strong class="source-inline">getMovieById</strong>.</p>
			<p>The following code shows our first unit tests:</p>
			<pre class="source-code">
import {getMovies,getMovi<a id="_idTextAnchor426"/>eById} from '../src/services/mov<a id="_idTextAnchor427"/>ieService';
describe('testing getMovies AP<a id="_idTextAnchor428"/>I', () =&gt; {
  test('getMovies returns values', () =&gt; {
    expect(getMovies()).toBeTrut<a id="_idTextAnchor429"/>hy();
  });
  test('getMovies returns an array', () =&gt; {
    expect(getMovies()).toBeInstanceOf(Ar<a id="_idTextAnchor430"/>ray);
  });
  test('getMovies returns three results', () =&gt; {
    expect(getMovies()).toHaveLength(46)<a id="_idTextAnchor431"/>;
  });
});
describe('testing getMovieById AP<a id="_idTextAnchor432"/>I', () =&gt; {
  test('getMovies retur<a id="_idTextAnchor433"/>ns movie if id exists', () =&gt; {
    expect(getMovieById(892153)).toBeTrut<a id="_idTextAnchor434"/>hy();
  });
  test('getMovies returns movie with correct information,
  () =&gt; {
    const movie = getMovieById(892153);
    expect(movie?.title).toBe('Tom and Jerry Cowboy Up!');
    expect(movie?.release_date).toBe('2022-01-<a id="_idTextAnchor435"/>24');
  });
  test('getMovies returns<a id="_idTextAnchor436"/> nothing if id does not exist', ()
  =&gt; {
    expect(getMovieById(0)).toBeFalsy();
  });
});</pre>
			<p>The preceding <a id="_idIndexMarker693"/>code contains six tests grouped into two sections. The first section contains all tests regarding the <strong class="source-inline">getMovies</strong> API call. With the first test, we ensure that the <strong class="source-inline">getMovies</strong> call returns a <a id="_idIndexMarker694"/>value. The second test checks whether <strong class="source-inline">getMovies</strong> returns an array, while the last test validates that the returned array has the length we expect.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You might be wondering why we need three tests here when the last one fails as soon as one of the first two fails. This is because it gives us useful information so that we can see which tests fail. This makes debugging and searching for changes or bugs a lot easier.</p>
			<p>In the second section <a id="_idIndexMarker695"/>of the code example, we test the <strong class="source-inline">getMoviesById</strong> block. Again, we have<a id="_idIndexMarker696"/> three tests. The first one verifies that the API call returns a value for a movie ID we know exists. The second test checks that the correct movie is returned. The third test ensures that the <strong class="source-inline">getMovieById</strong> API call does not return anything for an ID we know doesn’t exist.</p>
			<p>As you can see, you shouldn’t only write one unit test when testing a function; you should try to cover at least the following areas:</p>
			<ul>
				<li>Check for existing and non-existing return values</li>
				<li>Check for expected data types</li>
				<li>Check whether the returned values match your expected data</li>
				<li>If you work with ranges, write tests for the edge cases</li>
				<li>If you experienced a bug, reproduce it with a unit test to ensure it will never be encountered again</li>
			</ul>
			<p>Writing integration tests with Jest work pretty much the same as unit tests. The difference is that you test larger parts of your application. While the terminology is not always consistent, you can find a good definition in the React <a id="_idIndexMarker697"/>Native documentation (<a href="https://bit.ly/prn-integration-tests">https://bit.ly/prn-integration-tests</a>). It counts as an integration test when at least one of the following four points is true:</p>
			<ul>
				<li>Combines several modules of your app</li>
				<li>Uses an external system</li>
				<li>Makes a network call to other applications (such as the weather service API)</li>
				<li>Does any kind of file or database I/O</li>
			</ul>
			<p>One thing that is quite important <a id="_idIndexMarker698"/>when working with integration tests is mocking. When running tests using Jest as your test runner, you don’t have any native parts of your application<a id="_idIndexMarker699"/> available; your tests run your JavaScript code in a JavaScript-only environment.</p>
			<p>This means you<a id="_idIndexMarker700"/> have to <em class="italic">mock</em> at least all native parts of your application. Jest comes with advanced support for mocking different parts of your code. You can check out the detailed documentation here: <a href="https://bit.ly/prn-jest-mocking">https://bit.ly/prn-jest-mocking</a>.</p>
			<p>While unit and integration testing work pretty much similar to tests on server applications or applications written in other languages, component tests are a frontend-only test type. This is what we’ll look at next.</p>
			<h1 id="_idParaDest-183"><a id="_idTextAnchor437"/>Working with component tests</h1>
			<p>When working with component tests in React Native, the<a id="_idIndexMarker701"/> recommended solution is to use <strong class="source-inline">react-native-testing-library</strong>. This library is compatible with Jest, adds a rendering environment for your JavaScript application, and provides multiple useful selectors and other functions.</p>
			<p>The easiest type of component test is to check for (unexpected) changes. This is called <strong class="bold">snapshot testing</strong>. The component will <a id="_idIndexMarker702"/>be rendered and transformed into an XML or JSON <a id="_idIndexMarker703"/>representation, called a snapshot. This snapshot is stored with the tests. The next time the test runs, it is used to check for changes.</p>
			<p>The following code example shows a snapshot test for the <strong class="source-inline">HomeView</strong> component of our example application:</p>
			<pre class="source-code">
import React from 'react';
import HomeView from '../src/views/home/Home.view';
import {render} from '@testing-library/react-native';
const genres = require('../asse<a id="_idTextAnchor438"/>ts/data/genres.json');
describe('test<a id="_idTextAnchor439"/>ing HomeView', () =&gt; {
  test('HomeView has not changed', ()<a id="_idTextAnchor440"/> =&gt; {
    const view = render(
      &lt;HomeView genres={genres}
                name={'John'}
        <a id="_idTextAnchor441"/>         onGenrePress={()=&gt;{}}/&gt;,
    );
    expect(view).toMatchSnapshot();
  });
});</pre>
			<p>This code example shows how important it is to take testing into account when structuring your code. We can simply import the <strong class="source-inline">HomeView</strong> component from <strong class="source-inline">Home.view</strong> and pass properties to it when rendering it.</p>
			<p>We don’t have to mock any stores or external dependencies. This makes it very easy to create the first snapshot test. We <a id="_idIndexMarker704"/>use the <strong class="source-inline">render</strong> function from <strong class="source-inline">react-native-testing-library</strong> to create a snapshot representation of the component. Then, we expect it to match our stored snapshot.</p>
			<p>While snapshot testing can be very useful to realize unexpected changes, it only gives us information if anything has changed. To get more information about what changed and check whether everything works as expected, we have to create more advanced component tests.</p>
			<p>The following code example shows how we can check whether the component<a id="_idTextAnchor442"/> renders valid content:</p>
			<pre class="source-code">
  test('all list<a id="_idTextAnchor443"/> items exist', () =&gt; {
    render(&lt;HomeView genres={genres}
                     name={'John'}
                     onGenrePress={() =&gt; {}} /&gt;);
    expect(screen.getByText('Action')).toBeTruthy();
    expect(screen.getByText('Adventure')).toBeTruthy();
    expect(screen.getByText('Animation')).toBeTruthy();
  });</pre>
			<p>In this test, we pass all three genres we have in our <strong class="source-inline">genres.json</strong> file to the <strong class="source-inline">HomeView</strong> component. Again, we render it using the <strong class="source-inline">render</strong> function from <strong class="source-inline">react-native-testing-library</strong>. After rendering, we use another function from the testing library called <strong class="source-inline">screen</strong>.</p>
			<p>With this function, we can query <a id="_idIndexMarker705"/>values that are rendered to the simulated screen. This is how we try to find the titles of our three genres, which we expect to be there by checking for them with <strong class="source-inline">toBeTruthy</strong>.</p>
			<p>Next, we’ll go one step further and check whether we can <a id="_idTextAnchor444"/>click on the list items:</p>
			<pre class="source-code">
  test('all list items are clickable', () =&gt; {
    co<a id="_idTextAnchor445"/>nst mockFn = jest.fn();
    render(&lt;HomeView genres={genres}
                     name={'John'}
                     onGenrePress={mockFn} /&gt;);
    fireEvent.press(screen.getByText('Action'));
    fireEvent.press(screen.getByText('Adventure'));
    fireEvent.press(screen.getByText('Animation'));
    expect(mockFn).toBeCalledTimes(3);
  });</pre>
			<p>In this test, we use the <strong class="source-inline">fireEvent</strong> function from <strong class="source-inline">react-native-testing-library</strong> to create a press event on every list item. To be able to check whether the press event triggers our <strong class="source-inline">onGenrePress</strong> function, we pass a Jest mock function, created with <strong class="source-inline">jest.fn()</strong>, to the component.</p>
			<p>This mock function collects a lot of information during the test, including how often it was called during the test. This is what we check for in this test. However, we can go one step further.</p>
			<p>Not only can we check whether the mock function was called, but also whether it was called with<a id="_idTextAnchor446"/> the correct parameters:</p>
			<pre class="source-code">
  test('click returns valid value', () =&gt; {
    co<a id="_idTextAnchor447"/>nst mockFn = jest.fn();
    render(&lt;HomeView genres={genres}
                     name={'John'}
                     onGenrePress={mockFn} /&gt;);
    fireEvent.press(screen.getByText('Action'));
    expec<a id="_idTextAnchor448"/>t(mockFn).toBeCalledWith(genres[0]);
  });</pre>
			<p>This example fires only on a press event but then checks whether the arguments that were passed to the function are correct. Since the <strong class="source-inline">Action</strong> genre is the first in the <strong class="source-inline">genres</strong> array, we expect the <strong class="source-inline">onGenrePress</strong> function to be called with it.</p>
			<p>Again, these types of tests are only that easy because we have a good code structure. If we hadn’t split our home<a id="_idIndexMarker706"/> page into a business logic and view, we would have to deal with our navigation library, as well as our global state management solution. While this is possible for most cases, it makes your component tests a lot more complex.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">It’s a good idea to integrate unit tests, integration tests, and component tests into your CI development process. You should at least run these tests when opening pull requests. If your setup allows, you could also run them on every commit for a faster feedback loop.</p>
			<p class="callout">I also recommend requiring a certain level of code coverage for the pipelines to pass, to ensure all developers write tests for their code.</p>
			<p>All the test types you have learned about so far only use and test parts of your application in a<a id="_idIndexMarker707"/> simulated environment. However, that changes when it comes to end-to-end tests.</p>
			<h1 id="_idParaDest-184"><a id="_idTextAnchor449"/>Understanding end-to-end tests</h1>
			<p>The idea of end-to-end tests is <a id="_idIndexMarker708"/>very simple: these tests try to simulate real-world user behavior and verify that the application behaves as expected. Normally, end-to-end tests work as black-box tests.</p>
			<p>This means that the testing framework does not know the inner functionality of the application that is being tested. It runs against the release build of the application, which will be shipped.</p>
			<h2 id="_idParaDest-185"><a id="_idTextAnchor450"/>Understanding the role of end-to-end testing</h2>
			<p>At first sight, end-to-end tests seem to be a silver<a id="_idIndexMarker709"/> bullet for automated testing. Shouldn’t it be enough to simply test all scenarios of our application with end-to-end tests? Do we even need other test types, such as unit tests, integration tests, or component tests?</p>
			<p>The answers to these questions are very simple. End-to-end tests are power<a id="_idTextAnchor451"/>f<a id="_idTextAnchor452"/>ul, but they also have some traits that make them only cover certain scenarios very well. First, end-to-end tests run for a long time, so testing all the functionality of a more complex application with end-to-end tests can take up to multiple hours.</p>
			<p>This means they can’t be run on every commit, which makes the feedback loop much longer. So, this scenario can’t be integrated into the CI development process, such as the one described in <a href="B16694_11.xhtml#_idTextAnchor376"><em class="italic">Chapter 11</em></a>, <em class="italic">Creating and Automating Workflows</em>. Second, end-to-end tests are flaky by nature.</p>
			<p>This means that these tests can pass and fail on different test runs without any code changes. One reason for this is that applications can behave differently internally, on different test runs. For example, multiple network requests can be resolved in different orders on different test runs.</p>
			<p>This is no problem for end users, but it can be for automated end-to-end tests, where you try to run interactions as fast as possible. Another reason for test flakiness is the real-world conditions the tests are running in.</p>
			<p>When the testing device has issues with network connectivity while the test runs, the test will fail, even if it should pass. Modern test frameworks try to reduce these problems as much as possible, but they haven’t been solved completely.</p>
			<p>I recommend using end-to-end tests for the most used paths in your application. This can include account creation and login, as well as the core functionality of your product.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">As a developer, you should always ensure there’s a balance between ensuring the quality of the product and keeping development speed. Too many end-to-end tests can increase the quality but significantly decrease the speed of your development or release process.</p>
			<p>Now that we’ve looked at <a id="_idIndexMarker710"/>end-to-end tests in general, let’s start writing our first tests.</p>
			<h2 id="_idParaDest-186"><a id="_idTextAnchor453"/>Writing end-to-end tests with Detox</h2>
			<p>Detox is an end-to-end<a id="_idIndexMarker711"/> testing framework that was initially developed for React Native applications. It isn’t a real black-box testing framework because it injects its <a id="_idIndexMarker712"/>own client into the application, which gets tested. This is done to reduce test flakiness, which works quite well but also can’t prevent flaky tests completely.</p>
			<p>This also means that you don’t ship the same binary that was tested. Normally, this should be no problem because you would simply build another binary with the same code and configuration except you would bundle it with the Detox client into your binary, but I wanted to mention it here anyway.</p>
			<p>The normal Detox testing process is shown in the following diagram:</p>
			<div>
				<div id="_idContainer062" class="IMG---Figure">
					<img src="image/B16694_12_01.jpg" alt="Figure 12.1 – Detox testing process&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – Detox testing process</p>
			<p>As you can see, you have to create a production bundle of your application before running your tests. Depending on the machine you create your builds on, as well as the size of your application, this can take some time. Next, you run your tests. After doing so, the testing environment will be torn down so that you can work with the test results.</p>
			<p>While this process works fine for running tests, it can be quite annoying while writing tests. Detox works best when<a id="_idIndexMarker713"/> using test IDs to identify elements you want to interact with. This means you <a id="_idIndexMarker714"/>have to touch your code and add test IDs to these elements.</p>
			<p>This also means you have to create a new build every time you have to change anything regarding the test IDs in your code. Fortunately, there is another process you can use while writing your tests. You can also use Detox on development builds, which leads to the following process:</p>
			<div>
				<div id="_idContainer063" class="IMG---Figure">
					<img src="image/B16694_12_02.jpg" alt="Figure 12.2 – Detox process for writing tests&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2 – Detox process for writing tests</p>
			<p>When working with development builds, you only have to create your native development build once. As you already know, the JavaScript bundle will be fetched from the Metro server running on your computer during development.</p>
			<p>This means you can run your tests. If you realize you have to make changes t<a id="_idTextAnchor454"/>o your test IDs, you can simply apply them and restart your tests. Then, the development build will fetch the new JavaScript bundle from the Metro server and run the tests. This can save a lot of time.</p>
			<p>Now that you know Detox in general, let’s start working with it. This book does not include a detailed step-by-step guide for installing it since the installation steps changed quite frequently in the past. So, please look at the official installation guide in the Detox documentation here: <a href="https://bit.ly/prn-detox-start">https://bit.ly/prn-detox-start</a>.</p>
			<p>If you have trouble getting your Detox tests to work, you can have a look at the example project on GitHub at <strong class="source-inline">chapter-12-detox-testing</strong>.</p>
			<p>Writing Detox tests is very similar to writing component tests because Detox uses Jest as its recommended test runner. However, with Detox, we run the test against the real application in a real-world scenario. This means we don’t have to work with mocking because everything <a id="_idIndexMarker715"/>we need is available. Before we start writing our <a id="_idIndexMarker716"/>test, we have to add test IDs to the components we want to interact with.</p>
			<p>The following example shows a snippet from <strong class="source-inline">Home.view.tsx</strong>:</p>
			<pre class="source-code">
&lt;Pressable
  key={genre.name}
  onPress={() =&gt; props.onGenrePress(genre)}
  testID={'test' + genre.name}&gt;
  &lt;Text style={styles.genreTitle}&gt;{genre.name}&lt;/Text&gt;
&lt;/Pressable&gt;</pre>
			<p>Here, you can see the <strong class="source-inline">Pressable</strong> component, which is used to display the genres. We added a <strong class="source-inline">testID</strong> property to this component, which makes it identifiable in our tests.</p>
			<p>The following code example shows a simple Detox test for our application. You can also find it in the example project r<a id="_idTextAnchor455"/>epository under <strong class="source-inline">e2e/movie.e2e.js</strong>:</p>
			<pre class="source-code">
describ<a id="_idTextAnchor456"/>e('Movie selection flow', () =&gt; {
  it('should navigate to movie and show movie details',
  async () =&gt; {
    await device.launchApp();
    awaitexpect(element(by.id('testAction'))).
      toBeVisible();
    await element(by.id('testAction')).tap();
    await expect(element(by.id('testmovie0'))).
      toBeVisible();
    await element(by.id('testmovie0')).tap();
    await expect(element(by.id('movieoverview'))).
      toBeVisible();
  });
});</pre>
			<p>First, we tell Detox to launch our app. Next, we wait for the genre with the <strong class="source-inline">testAction</strong> ID to be visible. Next, we tap the <strong class="source-inline">Pressable</strong> component. The same is done with the movies, except we don’t use the movie names as IDs but the list index. Finally, we verify that the overview text of the movie is shown.</p>
			<p>This example shows the<a id="_idIndexMarker717"/> advantages and disadvantages of end-to-end testing<a id="_idIndexMarker718"/> very well. On the one hand, we only needed a couple of lines of code to navigate to three different screens and verify the content. This means we can be quite confident that the application will not crash on these screens. On the other hand, it takes a lot of time to build the application, load it into a simulator, start it, and run the test.</p>
			<p>While Detox can run on real devices, it’s mostly used with simulators. These simulators can run in CI environments and therefore be integrated into an automated workflow easily.</p>
			<p>But you can even go one step further with end-to-end test integration in your automated workflow. While it is useful to run these tests on simulators, it’s even better to run them on real devices. Especially on Android, where you have thousands of different devices, you should at least test the most common ones.</p>
			<p>It’s not unlikely that some errors will only occur on specific devices or OS versions. Since you don’t want to buy hundreds of devices for testing, you can use device farms such as AWS Device Farm. Unfortunately, Detox does not work in these environ<a id="_idTextAnchor457"/>ments, so you have to use Appium as the testing framework. This is what we’ll look at next.</p>
			<h2 id="_idParaDest-187"><a id="_idTextAnchor458"/>Understanding Appium and AWS Device Farm</h2>
			<p>Unlike Detox, Appium is<a id="_idIndexMarker719"/> a real black-box testing framework. It works on your release binary and therefore tests the code you want to ship. It wasn’t primarily designed for React Native, but for native Android and iOS testing. Nevertheless, you can use it for React Native apps very well.</p>
			<p>Appium is a very mature framework. At the time of writing, version 2 of Appium is still in progress and not ready to use, so the examples here refer to<a id="_idTextAnchor459"/> <a id="_idTextAnchor460"/>version 1 of Appium.</p>
			<p>The framework consists of multiple parts, which you have to understand when working with Appium. The following diagram shows these different parts:</p>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
			<div>
				<div id="_idContainer064" class="IMG---Figure">
					<img src="image/B16694_12_03.jpg" alt="Figure 12.3 – Appium framework components&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.3 – Appium framework components</p>
			<p>The core of Appium is a<a id="_idIndexMarker720"/> Node.js server, which takes test orders from an Appium client. This client is where you will write your tests. It can be written in different languages such as JavaScript, Java, C#, or Python.</p>
			<p>Since you don’t want to introduce another language only for writing tests, I recommend going with the JavaScript implementation here. The server then uses an Appium driver to talk to the native testing frameworks, which are used to run the test on real Android and iOS devices.</p>
			<p>Appium also provides a desktop application, which has a very useful inspector mode. You can use this mode to find identifiers to write your tests when you don’t work with test IDs.</p>
			<p>Since the Appium installation process will change significantly with Appium version 2, this book does not contain a detailed step-by-step guide for the installation. You can find these instructions in the official Appium documentation here: <a href="https://bit.ly/prn-appium-installation">https://bit.ly/prn-appium-installation</a>.</p>
			<p>In my opinion, using Appium with React Native is only interesting when it’s combined with a device farm to run your tests on multiple real devices. Otherwise, I would recommend sticking to Detox because it’s easier to install, configure, and maintain. But unfortunately, Detox has no support for running on device farms. So, again, you have to use Appium there.</p>
			<p>One of these <a id="_idIndexMarker721"/>device farms is AWS Device Farm. It is an Amazon service that gives you access to hundreds of different real mobile device models. You can either upload and install your application and use the devices manually via your web browser or you can run automated tests on these devices.</p>
			<p>This automated testing is exactly what we’ll do. The following diagram shows how the process of running Appium tests on AWS Device Farm integrates with your automated workflow:</p>
			<div>
				<div id="_idContainer065" class="IMG---Figure">
					<img src="image/B16694_12_04.jpg" alt="Figure 12.4 – Running automated tests on AWS Device Farm&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.4 – Running automated tests on AWS Device Farm</p>
			<p>AWS Device Farm can be accessed programmatically from your workflow automation or CI tool (such as Bitrise) or manually via your web browser. In both scenarios, you have to upload an Android APK or iOS IPA file, which should be tested, and a test bundle.</p>
			<p>This bundle is a <strong class="source-inline">.zip</strong> file, which contains the tests as well as some configurations for AWS Device Farm. You can also <a id="_idIndexMarker722"/>choose which <strong class="bold">device pool</strong> should be used for testing. A device pool is a collection of devices that you can create in the AWS Device Farm console.</p>
			<p>AWS then runs your tests on every device that is part of your device pool and collects the test results. These results are displayed in the AWS Device Farm console and can also be passed back to your workflow automation or CI tool.</p>
			<p>The following screenshot shows the overview of a test run in AWS Device Farm:</p>
			<div>
				<div id="_idContainer066" class="IMG---Figure">
					<img src="image/B16694_12_05_New.jpg" alt="Figure 12.5 – AWS Device Farm result screen&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.5 – AWS Device Farm result screen</p>
			<p>This overview shows a test run that executed three tests on every device of the chosen device pool. All tests passed except two. This means there is either an error that makes two tests fail on one device type, or that two of the tests are flaky.</p>
			<p>This is something<a id="_idIndexMarker723"/> you would have to investigate. Fortunately, AWS Device Farm provides logs, screenshots, and video recordings of every test run so that you can find out what is happening with ease.</p>
			<p>Since the installation and configuration process for using Appium locally and on AWS Device Farm isn’t trivial, I created a demo repository that you can start from. It also contains a detailed setup and installation guide, as well as useful scripts for running Appium tests locally and creating bundles for running them on AWS Device Farm. You can find it here: <a href="https://bit.ly/prn-appium-aws-repo">https://bit.ly/prn-appium-aws-repo</a>.</p>
			<p>Now, let’s summarize this chapter.</p>
			<h1 id="_idParaDest-188"><a id="_idTextAnchor461"/>Summary</h1>
			<p>First, you learned why automated testing is important and which types of tests exist for React Native apps. Then, you learned how to write unit and integration tests, as well as component tests, with Jest and <strong class="source-inline">react-native-testing</strong>.</p>
			<p>Finally, you learned about end-to-end testing while covering two different frameworks: Detox and Appium. After completing this chapter, you should understand that automated testing is an essential part of large-scale projects and that every test type is important because it covers different areas.</p>
			<p>Now that you have learned about the basics of writing large-scale applications with React Native, in the last chapter of this book, I will provide some tips from my experience as well as an outlook for the next few years regarding React Native.</p>
		</div>
		<div>
			<div id="_idContainer068">
			</div>
		</div>
	</body></html>