- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Exploring the Book’s Layout and Companion App
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索书籍布局和配套应用程序
- en: Vue.js is an enormously popular framework in the **JavaScript** (**JS**) ecosystem.
    In recent years, it has gained lots of popularity thanks to its simplicity, its
    great documentation, and, finally, its fantastic community. If you are starting
    web development now, or are transitioning from a different framework or language,
    Vue.js is a great choice.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js是JavaScript（JS）生态系统中的一个极其流行的框架。近年来，由于其简洁性、出色的文档以及最终其出色的社区，它获得了大量的关注。如果你现在开始网页开发，或者是从其他框架或语言过渡过来，Vue.js是一个很好的选择。
- en: Before we can jump into the main content of the book, it is important to learn
    how the book is structured and what methods will be used to explain the different
    topics of this fantastic framework.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入本书的主要内容之前，了解书籍的结构以及将用于解释这个出色框架不同主题的方法非常重要。
- en: To simplify the learning of Vue.js and make the book more interesting and interactive,
    the book has been built around the creation and enhancement of a Companion App.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化Vue.js的学习，并使书籍更加有趣和互动，本书围绕配套应用程序的创建和增强而构建。
- en: '*Vue.js 3 for Beginners* is going to focus mainly on the framework and its
    core libraries, and it will not cover basic development knowledge such as HTML,
    CSS, JS, and Git. To understand the content of this book, basic knowledge of these
    four topics is required.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 《*Vue.js 3入门*》将主要关注框架及其核心库，并且不会涵盖HTML、CSS、JS和Git等基本开发知识。为了理解本书的内容，需要具备这些四个主题的基本知识。
- en: The first part of this book is going to cover an important aspect of our learning
    journey and will provide you with important theoretical information that is needed
    for you to make the most of the book’s content; we will then jump into the specifics
    of Vue by introducing the framework and its core concepts in [*Chapter 2*](B21130_02.xhtml#_idTextAnchor028).
    Finally, from [*Chapter 3*](B21130_03.xhtml#_idTextAnchor039) onward, we will
    start to work on our application, one component at a time.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的第一部分将涵盖我们学习旅程的一个重要方面，并为你提供利用本书内容所需的重要理论知识；然后，我们将通过介绍框架及其核心概念在[*第二章*](B21130_02.xhtml#_idTextAnchor028)中跳入Vue的具体细节。最后，从[*第三章*](B21130_03.xhtml#_idTextAnchor039)开始，我们将逐个组件地开始构建我们的应用程序。
- en: 'In this chapter, we’ll cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The Companion App
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配套应用程序
- en: The core areas of a web application
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络应用程序的核心区域
- en: Component-based architecture
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件化架构
- en: By the end of this chapter, you will learn about what we are going to build
    during the course of the book, and cover some theoretical aspects required for
    us to make the most of the Vue.js framework, such as component-based architecture
    and the architectural decisions behind the Companion App.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解在本书的学习过程中我们将要构建的内容，并涵盖一些理论方面，这些方面是我们充分利用Vue.js框架所必需的，例如组件化架构和配套应用程序背后的架构决策。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The application that accompanies the book has been built using free software
    and APIs and will not require you to purchase anything. However, there are some
    specific technical requirements needed for you to follow along:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 伴随本书的应用程序是使用免费软件和API构建的，不会要求你购买任何东西。然而，有一些特定的技术要求需要你遵循：
- en: Visual Studio Code or another equivalent IDE (integrated development Environment)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code或另一个等效的IDE（集成开发环境）
- en: Volar Visual Studio code extension
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Volar Visual Studio代码扩展
- en: A browser updated to the latest version (I suggest Chrome or Firefox)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新到最新版本的浏览器（我建议使用Chrome或Firefox）
- en: Node 16+
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node 16+
- en: GIT or a Git **GUI** (**Graphic user interface**) such as GitKraken installed
    on your machine
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的机器上安装了GIT或Git **GUI**（**图形用户界面**）例如GitKraken
- en: The companion app
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配套应用程序
- en: Learning a new language or framework is not an easy task. There are plenty of
    free resources, such as documentation, blogs, and YouTube videos on the internet,
    but I believe learning a new tech requires practice, and there is no better way
    to achieve this than by building a production-ready, performant, scalable social
    media application together.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 学习一门新的语言或框架并非易事。互联网上有许多免费资源，例如文档、博客和YouTube视频，但我相信学习新技术需要实践，而最好的方式就是一起构建一个生产就绪、性能良好、可扩展的社会媒体应用程序。
- en: The application is going to be very similar to the social media platform X (formerly
    Twitter). We will start from a clean canvas and slowly add more features and functionality
    until the app is fully working and ready to be added to your portfolio and showcased
    at your next job interview.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将非常类似于社交媒体平台 X（以前称为 Twitter）。我们将从一个干净的画布开始，逐渐添加更多功能和功能，直到应用程序完全工作并准备好添加到你的作品集并在你下一次求职面试中展示。
- en: Each chapter will have a set of sections that will help you navigate the book.
    This will not only ensure that you can always follow along and have a clear understanding
    of the scope of the chapter, but it also allows you to use the book as a reference
    after you have read it all and allows you to jump to a specific chapter if you
    need to do so.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 每章都将有一组部分，帮助你导航本书。这不仅确保你始终能够跟随并清楚地理解章节的范围，而且在你阅读完本书后，还可以作为参考使用，如果你需要的话，可以跳转到特定的章节。
- en: 'Each chapter includes the following sections:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 每章都包括以下部分：
- en: Starting branch for the chapter
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 章节开始的分支
- en: The current state of the Companion App
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 伴侣应用程序的当前状态
- en: Definition of what will be added and achieved within the current chapter
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义当前章节将添加和实现的内容
- en: Multiple sections of explanation and coding
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个解释和编码部分
- en: Summary of what Vue.js topics we have learned in this chapter with a glossary
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章我们学习到的 Vue.js 主题总结以及术语表
- en: The Companion App features
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 伴侣应用程序的功能
- en: As mentioned previously, the application that we are about to build will be
    very similar to an existing social media application. To make sure we cover most
    of the Vue.js features and its ecosystem, we may at times over-architect a specific
    component or feature, but when this happens, it will be called out so that you
    will have full knowledge of whether it is a good practice to follow in the future
    and what would be the correct implementation.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们即将构建的应用程序将非常类似于现有的社交媒体应用程序。为了确保我们涵盖 Vue.js 的大多数特性和其生态系统，我们有时可能会过度设计特定的组件或功能，但在此情况下，将会指出，以便你全面了解是否是未来遵循的良好实践以及正确的实现方式。
- en: 'By following the book, you will learn the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通过跟随本书，你将学习以下内容：
- en: How to structure a web application using a component-based architecture
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用基于组件的架构来构建网页应用程序
- en: How to create simple and complex HTML using Vue.js
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Vue.js 创建简单和复杂的 HTML
- en: How to make the right decision to make your app performant and scalable
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何做出正确的决策，使你的应用程序具有性能和可扩展性
- en: How to communicate between components
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在组件之间进行通信
- en: How to use external APIs to load dynamic data
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用外部 API 加载动态数据
- en: How to use state management using Pinia
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Pinia 进行状态管理
- en: How to implement multiple pages (routing) using vue-router
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 vue-router 实现多页面（路由）
- en: How to test your application using Vitest and Cypress
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Vitest 和 Cypress 测试你的应用程序
- en: How to create forms effectively using Vue.js
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Vue.js 有效地创建表单
- en: How to debug your application using the Vue debugger
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Vue 调试器调试你的应用程序
- en: The preceding list is just an overview of what we will be achieving in the book,
    and we are going to make this learning fun and interactive by building using the
    Companion App together.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 上述列表只是本书我们将实现内容的概述，我们将通过构建伴侣应用程序来使学习变得有趣和互动。
- en: The application code
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序代码
- en: 'The code for the application can be found in this repository: [https://github.com/PacktPublishing/Vue.js-3-for-Beginners](https://github.com/PacktPublishing/Vue.js-3-for-Beginners).
    If you do not know what a repository is or how to use it, I suggest you learn
    the basics, even if all the information and commands you require to use the code
    will be provided in each chapter.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的代码可以在本仓库中找到：[https://github.com/PacktPublishing/Vue.js-3-for-Beginners](https://github.com/PacktPublishing/Vue.js-3-for-Beginners)。如果你不知道什么是仓库或如何使用它，我建议你学习基础知识，即使每个章节都会提供使用代码所需的所有信息和命令。
- en: The repository has multiple branches for each chapter. This will be the starting
    point for each chapter and will be specified at the start of each chapter, as
    mentioned before.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库为每个章节有多个分支。这将是每个章节的起点，并在每个章节的开始处指定，如前所述。
- en: The main branch of the repository is the latest commit, and it includes the
    complete application. If you have some time, I suggest you run the full application
    to try and browse it to see what we will achieve in the course of the book.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库的主要分支是最新提交，其中包含完整的应用程序。如果你有时间，我建议你运行完整的应用程序来尝试浏览，看看我们在本书的进程中会实现什么。
- en: To run the application, you can simply follow the instructions available in
    the `README.md` file that is available at the root of the project.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行应用，你可以简单地遵循项目根目录中可用的`README.md`文件中的说明。
- en: 'As it is the first time that we are running the application, I will also provide
    the information required here to get the application up and running:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是我们第一次运行应用，我还会提供这里所需的信息，以便让应用启动并运行：
- en: 'First, we need to get a copy of the remote repository on our machine. To do
    so, run the following command in the terminal:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要在我们的机器上获取远程仓库的副本。为此，请在终端中运行以下命令：
- en: '[PRE0]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, we need to navigate into our newly created project folder:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要导航到我们新创建的项目文件夹：
- en: '[PRE1]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Before we can run the project, we need to install all its dependencies using
    a package manager. A package manager is a piece of software that is used to install
    and manage the packages, in our case Node.js and JS, for which the project depends.
    The application shared in the repository supports all major package managers,
    such as npm, yarn, and pnpm. In the following example, we are going to use npm:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们能够运行项目之前，我们需要使用包管理器安装所有依赖项。包管理器是一种用于安装和管理包的软件，在我们的案例中，是Node.js和JS，项目依赖于它们。存储库中共享的应用支持所有主要的包管理器，如npm、yarn和pnpm。在以下示例中，我们将使用npm：
- en: '[PRE2]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, it is time to run the project. The following command will run a development
    version of the project:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，是时候运行项目了。以下命令将运行项目的开发版本：
- en: '[PRE3]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After a few seconds, the local instance of the application will start, and you
    should be able to access it by opening the browser at `HTTP://localhost:5173`.
    The application should look like this.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 几秒钟后，应用的本地实例将启动，你应该可以通过在浏览器中打开`HTTP://localhost:5173`来访问它。应用应该看起来像这样。
- en: '![Figure 1.1: Screenshot of the Companion App dashboard](img/B21130_01_01.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1：伴随应用仪表板的截图](img/B21130_01_01.jpg)'
- en: 'Figure 1.1: Screenshot of the Companion App dashboard'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1：伴随应用仪表板的截图
- en: Spend some time navigating the application, both in the browser and within the
    code base, to see what we will build in the course of the book.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用中花些时间进行导航，既在浏览器中，也在代码库中，看看我们在本书的过程中将构建什么。
- en: In this section, we have learned about the Companion Application, how it is
    going to be used to support our learning, its core features, and finally, the
    commands required to run the application locally. In the next section, we will
    spend a few moments on the core areas of web applications and explain which technologies/libraries
    we are going to use in our application.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了伴随应用，它是如何支持我们的学习的，其核心功能，以及最后，在本地运行应用所需的命令。在下一节中，我们将花几分钟时间讨论网络应用的核心领域，并解释我们将使用哪些技术/库在我们的应用中。
- en: The core areas of a web application
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络应用的核心领域
- en: The JS ecosystem is not shy of frameworks and libraries, but even with this
    extensive choice, they mostly share the same core values and areas. These are
    the core parts of a web application and no matter which framework you use to write
    your application, you will have to know this and have a basic understanding of
    what they mean.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: JS生态系统并不羞于使用框架和库，但即使有如此广泛的选择，它们大多共享相同的核心理念和领域。这些是网络应用的核心部分，无论你使用哪个框架来编写你的应用，你都必须了解这一点，并对其含义有一个基本的理解。
- en: 'The pillars of a web application are as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 网络应用的基础如下：
- en: '**User interface (UI)**: This refers to the elements displayed on the screen
    from which a user can interact. In simple words, anything you can see or interact
    with on the internet is part of the UI. This core area of web development is usually
    achieved with basic HTML/CSS, vanilla JS (that is a different way to say plain
    JS), or a framework such as React, Vue, or Angular. In our case, this will be
    achieved using Vue.js 3.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户界面（UI）**：这指的是用户可以与之交互的屏幕上的元素。简单来说，你可以在互联网上看到或与之交互的任何东西都是UI的一部分。网络开发的核心领域通常使用基本的HTML/CSS、纯JS（这是另一种说纯JS的方式），或者像React、Vue或Angular这样的框架来实现。在我们的案例中，这将使用Vue.js
    3来实现。'
- en: '`fetch` method.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetch`方法。'
- en: '**State management**: Unless your website is a static blog post, you will need
    to handle some data. This could be the current state of a form or information
    about a logged-in user. Small applications can easily achieve this directly with
    the existing tool that a framework provides, but at times, this needs to be expanded
    to use full-blown “state management.” In Vue.js, two main libraries help you handle
    your data. Vuex the state management of choice for Vue 2 and Pinia, which is the
    suggested library to be used for Vue 3 (Pinia is just a newer version of Vuex,
    but it was renamed due to the fact that it went through a full rewrite with many
    breaking changes).Because we will be writing our Companion App in Vue 3, we will
    use Pinia.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态管理**：除非你的网站是一个静态博客文章，否则你需要处理一些数据。这可能是表单的当前状态或登录用户的详细信息。小型应用程序可以轻松地直接使用框架提供的现有工具来实现这一点，但有时这需要扩展到使用完整的“状态管理”。在Vue.js中，有两个主要的库可以帮助你处理你的数据。Vuex是Vue
    2的首选状态管理库，而Pinia是Vue 3建议使用的库（Pinia是Vuex的一个更新版本，但由于它经历了一次全面的重写并带来了许多破坏性变化，因此被重新命名）。由于我们将使用Vue
    3编写我们的Companion App，我们将使用Pinia。'
- en: '**Routing**: Even if by definition most of today’s websites are called **single-page
    applications** (**SPAs**), in reality, they make use of more than one page. The
    definition of “single page” is just used because the application does not fully
    reload during navigation, but it does not imply that the application will not
    have more than one route. For this reason, most web applications will require
    a way to handle routing between multiple pages. For the scope of this book, we
    will be using vue-router, which is the official routing library.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由**：尽管按照定义，今天的大多数网站都被称为**单页应用（SPAs**），但实际上它们使用了不止一个页面。对“单页”的定义只是因为应用程序在导航期间不会完全重新加载，但这并不意味着应用程序不会有超过一个的路由。因此，大多数Web应用程序将需要一个处理多个页面之间路由的方法。在本书的范围内，我们将使用vue-router，这是官方的路由库。'
- en: '**Forms and validation**: Forms are probably one of the main reasons why JS
    frameworks and SPAs have become so successful. The possibility of handling complex
    forms and client interaction without the need to refresh the page has improved
    **user experience** (**UX**) massively. Even if Vue.js is more than capable of
    handling forms and their validation, we will be using an external library called
    VeeValidate for client-side validation.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表单和验证**：表单可能是JS框架和单页应用（SPAs）之所以如此成功的主要原因之一。无需刷新页面即可处理复杂表单和客户端交互的可能性，极大地提升了用户体验（UX）。即使Vue.js完全能够处理表单及其验证，我们仍将使用一个名为VeeValidate的外部库来进行客户端验证。'
- en: '**Debugging**: Building is not always straightforward and debugging an application
    is a must-have skill. Even if this is not really a real part of the application
    (as it is more a skill than an actual part of the application itself), I still
    want to include it as part of a web application core area, as debugging helps
    us make the application secure and performant. In our case, we will be using plain
    JS techniques and a browser extension called Vue.js devtools to help us analyze,
    study, and improve our application.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试**：构建并不总是直截了当的，调试应用程序是一项必备技能。尽管这并不是应用程序的真正部分（因为它更多的是一项技能，而不是应用程序本身的实际部分），但我仍希望将其包括在Web应用程序的核心领域之一，因为调试有助于我们使应用程序更加安全和高效。在我们的案例中，我们将使用纯JS技术和一个名为Vue.js
    devtools的浏览器扩展来帮助我们分析、研究和改进我们的应用程序。'
- en: In this section, we explained the different areas that make a web application.
    We also explained the architectural decision behind the technology stack that
    is going to be used within our Companion App. It is now time to learn about a
    fundamental methodology called **component-based architecture**. This is the foundation
    for most frontend frameworks.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们解释了构成Web应用程序的不同区域。我们还解释了将在我们的Companion App中使用的技术栈背后的架构决策。现在是时候了解一个名为**组件化架构**的基本方法论了。这是大多数前端框架的基础。
- en: Component-based architecture
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件化架构
- en: We have reached the final section of our introductory discussion and we are
    almost ready to start coding. This section is going to introduce the concept of
    component-based architecture. Even if you are already familiar with this topic,
    I suggest you continue reading this chapter as it will support some of the decisions
    we will make later in the course of the book.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到达了介绍性讨论的最后一部分，我们几乎准备好开始编码了。本节将介绍组件化架构的概念。即使你已经熟悉这个主题，我也建议你继续阅读本章，因为它将支持我们在本书后续部分将做出的某些决策。
- en: In this section, we are going to cover how web development worked before this
    concept was introduced and we will then discuss how component-based architecture
    has shaped the web development industry as we know it.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍在引入这个概念之前网络开发是如何工作的，然后我们将讨论组件化架构是如何塑造我们今天所了解的网络开发行业的。
- en: One page at a time
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一次一个页面
- en: 'If you have been a developer for as long as I have been, you have probably
    worked with languages and frameworks that were not flexible in the way the pages
    were defined and developed. Using .NET and PHP a few years ago would have meant
    that each web page was created using a single file (disclaimer: some languages
    had the definition of “partials”.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你像我一样做了这么多年的开发者，你可能已经使用过那些在页面定义和开发方面不够灵活的语言和框架。几年前使用.NET和PHP意味着每个网页都是使用单个文件创建的（免责声明：一些语言有“部分”的定义）。
- en: This worked well until JS started to be used in the frontend and shook the ecosystem.
    JS changed sites from static pages to very dynamic entities and in doing so pushed
    for something more dynamic that would not work with the previous development tools.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法一直有效，直到JavaScript在前端开始使用并动摇了生态系统。JavaScript将网站从静态页面变成了非常动态的实体，并在这样做的同时推动了需要更动态的工具，而这些工具与之前的发展工具不兼容。
- en: 'Let’s take into consideration a standard website homepage, such as the following
    one:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个标准的网站主页，例如以下这个：
- en: '![Figure 1.2: Wireframe of a standard homepage](img/B21130_01_02.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图1.2：标准主页的线框图](img/B21130_01_02.jpg)'
- en: 'Figure 1.2: Wireframe of a standard homepage'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2：标准主页的线框图
- en: This site follows a standard layout with a header and a footer, a banner, some
    featured content, and a **Contact Us** form. Imagine having all this in one single
    HTML file. Back in the day, this was probably all held in one single HTML file
    with a shared stylesheet, for example a CSS (Cascading Style Sheet) file. As mentioned
    previously, things started to change in the industry and JS started to be used
    more and more.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个网站遵循一个标准的布局，包括头部和底部，横幅，一些特色内容，以及一个**联系我们**表单。想象一下，所有这些都在一个单独的HTML文件中。在那些日子里，这可能是所有内容都放在一个单独的HTML文件中，例如一个共享的样式表文件，比如CSS（层叠样式表）文件。如前所述，行业中的事情开始发生变化，JavaScript的使用越来越多。
- en: In the preceding scenario, JS was probably just used to add some basic interactivity
    like slideshow animation in the banner, some fancy scrolling i products list or
    to handle form submission in the **Contact** **Us** form.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的场景中，JavaScript可能只是用来添加一些基本的交互性，比如横幅中的幻灯片动画，产品列表中的花哨滚动，或者在**联系我们**表单中处理表单提交。
- en: Long story short, this change slowly shaped the industry toward frontend libraries
    and frameworks. These libraries and frameworks aimed to help manage and simplify
    the hundreds of lines of code produced in JS and they did so by introducing component-based
    architecture.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这个变化逐渐将行业引导向前端库和框架。这些库和框架旨在帮助管理和简化在JavaScript中产生的数百行代码，它们通过引入组件化架构来实现这一点。
- en: Breaking things down into small units was not something new in the industry,
    as the backend framework already had this notion with the use of **object-oriented
    programming**, but it was an innovation in the frontend side of the industry.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 将事物分解成小的单元在行业中并不是什么新鲜事，因为后端框架已经通过使用**面向对象编程**有了这个概念，但在行业的前端方面是一个创新。
- en: From one page to many components
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从一个页面到多个组件
- en: The term **component-based development** (**CBD**) is a pattern in which the
    UI of a given application is broken down into multiple “components.” Breaking
    down big pages into small individual units reduces the complexity of the application
    and helps the developer focus on the individual scope and responsibility of each
    section.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**组件化开发**（CBD）是一种模式，其中给定应用程序的UI被分解成多个“组件”。将大页面分解成小的独立单元可以减少应用程序的复杂性，并帮助开发者专注于每个部分的个别范围和责任。'
- en: All of today’s frontend frameworks are built on top of this pattern and today’s
    frontend development is driven by architecture based on CBD.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 所有当今的前端框架都是基于这个模式构建的，而今天的前端开发是由基于CBD（组件化开发）的架构驱动的。
- en: Let’s look at the previous example of the home page and see how we could split
    this into small isolated components.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看之前的主页示例，看看我们如何将其拆分成小的独立组件。
- en: 'The home page would be broken down into the following components:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 主页将被分解成以下组件：
- en: '**Header**: A component that will include the logo and the logic used to display
    account information such as the avatar'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**头部**：一个将包括标志和用于显示账户信息（如头像）的逻辑的组件'
- en: '**The slideshow**: A reusable component used to display slideshow images'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**幻灯片**：一个可重用的组件，用于显示幻灯片图像'
- en: '**Featured**: A component used to display featured articles'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**特色**：用于显示特色文章的组件'
- en: '**Contact Us**: A component including all the logic required to validate and
    submit our form'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**联系我们**：一个包含所有验证和提交我们表单所需逻辑的组件'
- en: '**Footer**: A static component that will include some copy and social links'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**页脚**：一个静态组件，将包含一些文本和社交媒体链接'
- en: '![Figure 1.3: Wireframe of a dashboard divided into different sections, such
    as header, slideshow, featured, Contact Us, and footer](img/B21130_01_03.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.3：分为不同部分（如标题、幻灯片、特色、联系我们和页脚）的仪表板线框图](img/B21130_01_03.jpg)'
- en: 'Figure 1.3: Wireframe of a dashboard divided into different sections, such
    as header, slideshow, featured, Contact Us, and footer'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3：分为不同部分（如标题、幻灯片、特色、联系我们和页脚）的仪表板线框图
- en: As we will see in a few minutes, the components displayed in *Figure 1**.3*
    are just an example, as a fully defined CBD will actually break things even further
    all the way to the single HTML element. What this means is that not only the page
    is made of components, but components are made up of smaller components too.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们将在几分钟内看到的，*图 1.3* 中显示的组件只是一个示例，因为一个完全定义的 CBD 实际上会将事物分解得更细，直至单个 HTML 元素。这意味着不仅页面由组件组成，组件本身也由更小的组件组成。
- en: 'Breaking down things into smaller units has many benefits. Let’s analyze some
    of these characteristics:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 将事物分解成更小的单元有许多好处。让我们分析一些这些特性：
- en: '**Reusability**: CBD provides you with the possibility to create components
    that can be reused within your application. (In our example we could reuse the
    header, footer, slideshow, and even the featured component.)'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重用性**：CBD 为您提供了创建可在应用程序内部重用组件的可能性。（在我们的例子中，我们可以重用标题、页脚、幻灯片，甚至特色组件。）'
- en: '**Encapsulation**: Encapsulation is defined as the ability for each component
    to be “self-contained.” All styles, HTML, and JS logic are “encapsulated” within
    the scope of a given component.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**封装**：封装被定义为每个组件能够“自包含”。所有样式、HTML 和 JS 逻辑都被“封装”在给定组件的作用域内。'
- en: '**Independence**: Due to encapsulation, each component is independent and does
    not share (or is not supposed to share) responsibility with other components.
    This allows components to be used in different contexts (for example, the ability
    to use the feature component on a different page of the site).'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**独立性**：由于封装，每个组件都是独立的，并且不与其他组件共享（或不应共享）责任。这允许组件在不同的上下文中使用（例如，在网站的不同页面上使用功能组件的能力）。'
- en: '**Extensibility**: Due to the component being “self-contained” and independent,
    we are able to extend it with limited risk.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：由于组件是“自包含”和独立的，我们能够以有限的风险对其进行扩展。'
- en: '**Replaceability**: The component can easily be swapped out with other components
    or be removed without risk.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可替换性**：组件可以轻松地与其他组件或移除，而不会带来风险。'
- en: It is clear from the preceding list that using CBD brings many benefits to the
    hands of a frontend developer. As we will experience in the course of this book,
    the ability to break an application down into small units is extremely beneficial
    for new developers as it allows the individual topics to be broken down and really
    focuses our attention on what matters the most.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的列表中可以看出，使用 CBD 为前端开发者带来了许多好处。正如我们将在本书的学习过程中体验到的，将应用程序分解成小单元的能力对于新开发者来说极为有益，因为它允许将各个主题分解开来，并真正关注最重要的方面。
- en: Vue.js implements component-based architecture with the use of a `.vue` extension
    and encapsulate styles, HTML, and logic (JS or Typescript) in the same file. SFC
    will be clearly introduced later in the book.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js 使用 `.vue` 扩展实现基于组件的架构，并将样式、HTML 和逻辑（JS 或 TypeScript）封装在同一文件中。SFC 将在本书稍后详细介绍。
- en: Atomic design
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原子设计
- en: In this last section, we are going to understand how we will structure our components
    during the course of the book.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的最后，我们将了解在整个书籍过程中我们将如何构建我们的组件。
- en: The folder structure of components is something that has not been standardized
    yet around the industry and this can differ from developer to developer.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的文件夹结构在行业内尚未标准化，这可能会因开发者而异。
- en: 'In our case, we are going to follow what is known in the industry as “atomic
    design.” This is described as:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们将遵循业界所知的“原子设计”。这被描述为：
- en: '*The Atomic Design methodology created by Brad Frost (https://bradfrost.com/)
    is a design methodology for crafting robust design systems with an explicit order
    and hierarchy -* [blog.kamathrohan.com](http://blog.kamathrohan.com)*.*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*布拉德·弗罗斯特（Brad Frost，https://bradfrost.com/）创建的原子设计方法是一种设计方法，用于构建具有明确顺序和层次结构的设计系统*
    [blog.kamathrohan.com](http://blog.kamathrohan.com)*.*'
- en: 'The atomic design pattern follows the same concept described in chemistry and
    the composition of matter. If you want to go into more detail on this subject,
    I suggest you read the following article: [https://blog.kamathrohan.com/atomic-design-methodology-for-building-design-systems-f912cf714f53](https://blog.kamathrohan.com/atomic-design-methodology-for-building-design-systems-f912cf714f53).'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 原子设计模式遵循在化学和物质组成中描述的相同概念。如果您想深入了解这个主题，我建议您阅读以下文章：[https://blog.kamathrohan.com/atomic-design-methodology-for-building-design-systems-f912cf714f53](https://blog.kamathrohan.com/atomic-design-methodology-for-building-design-systems-f912cf714f53)。
- en: In this book, we are going to follow the hierarchy proposed in this methodology
    by breaking down our applications into “sub-atomic,” atoms, molecules, organisms,
    templates and pages.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将遵循该方法中提出的方法论层次结构，将我们的应用程序分解为“亚原子”、“原子”、“分子”、“有机体”、“模板”和“页面”。
- en: '![Figure 1.4: Visual explanation of the different levels offered by atomic
    design (source: https://blog.kamathrohan.com/atomic-design-methodology-for-building-design-systems-f912cf714f53)](img/B21130_01_04.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图1.4：原子设计提供的不同级别的视觉解释（来源：https://blog.kamathrohan.com/atomic-design-methodology-for-building-design-systems-f912cf714f53）](img/B21130_01_04.jpg)'
- en: 'Figure 1.4: Visual explanation of the different levels offered by atomic design
    (source: [https://blog.kamathrohan.com/atomic-design-methodology-for-building-design-systems-f912cf714f53](https://blog.kamathrohan.com/atomic-design-methodology-for-building-design-systems-f912cf714f53))'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4：原子设计提供的不同级别的视觉解释（来源：[https://blog.kamathrohan.com/atomic-design-methodology-for-building-design-systems-f912cf714f53](https://blog.kamathrohan.com/atomic-design-methodology-for-building-design-systems-f912cf714f53)）
- en: 'Atomic design layers are as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 原子设计层如下：
- en: '**Sub-atomic**: The sub-atomic layers include all the variables and settings
    that will be used within the application. These are not going to be “components,”
    but just CSS variables that will be shared globally within our application. In
    the sub-atomic layer, we find colors, typography, and spacing.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**亚原子层**: 亚原子层包括将在应用程序中使用的所有变量和设置。这些不是“组件”，而是将在我们的应用程序中全局共享的CSS变量。在亚原子层中，我们可以找到颜色、字体和间距。'
- en: '**Atoms**: These are components that will define individual HTML elements,
    so, for example, a button, an icon, and an input text are all part of atoms.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原子**: 这些是定义单个HTML元素的组件，例如，按钮、图标和输入文本都属于原子。'
- en: '**Molecules**: Molecules are made up of two or more atoms or plain HTML elements.
    For example, an input field with a label and an error is a molecule.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分子**: 分子由两个或更多原子或纯HTML元素组成。例如，带有标签和错误的输入字段就是一个分子。'
- en: '**Organism**: There are UI components that make up a standalone section that
    can be used on the site. For example, a login form is an organism, a slideshow
    is an organism, and so is a footer.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有机体**: 有一些UI组件组成一个可以用于网站的独立部分。例如，登录表单是一个有机体，幻灯片也是一个有机体，页脚也是如此。'
- en: '**Templates:** These are commonly called layouts within the frontend ecosystem
    and are used to define a reusable structure used by multiple pages. An example
    could be a template with a hero image, a sidebar, main content area and a footer.
    This template would be used by many pages within the application and abstracting
    it into its own template reduces duplication.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模板**: 在前端生态系统中，这些通常被称为布局，用于定义多个页面使用的可重用结构。一个例子可能是一个包含英雄图片、侧边栏、主要内容区域和页脚的模板。这个模板将在应用程序的许多页面中使用，将其抽象成自己的模板可以减少重复。'
- en: '**Pages**: Lastly, we have pages. These are used to define our web application
    page or subpage. A page is going to be the place in which our data is loaded,
    and it will include HTML elements, organisms, molecules, and atoms.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**页面**: 最后，我们有页面。这些用于定义我们的Web应用程序页面或子页面。页面将是我们的数据加载的地方，它将包括HTML元素、有机体、分子和原子。'
- en: Even if this separation may seem complicated to understand from the preceding
    description, we will touch base on this topic multiple times during the book and
    this will help you understand the main difference between the layers available.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 即使从前面的描述中理解这种分离可能看起来很复杂，我们将在本书中多次涉及这个话题，这将有助于您理解可用的层之间的主要区别。
- en: Spend some time going through the folder structure of the application and read
    the components’ names to try and understand how we will break up our application.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 花些时间查看应用程序的文件夹结构，并阅读组件的名称，以尝试理解我们将如何拆分我们的应用程序。
- en: Separation of concern
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关注点分离
- en: So far, we have learned that the modern framework offers the ability to break
    up the application into small chunks called components and that there is a hierarchy
    within the component itself.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解到现代框架提供了将应用程序拆分成称为组件的小块的能力，并且组件本身也存在层次结构。
- en: In this section, we are going to quickly touch base on why this hierarchy was
    introduced in the first place and understand how this is going to help our development.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将简要介绍为什么最初引入这种层次结构，并了解这将如何帮助我们进行开发。
- en: Atomic design not only supports us in breaking up components by their visual
    complexity, but it also helps us to break up the application logic to create highly
    performance and scalable applications.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 原子设计不仅帮助我们根据视觉复杂度拆分组件，还帮助我们拆分应用程序逻辑，以创建高性能和可扩展的应用程序。
- en: As the component definitions get more complex, so does the logic expected to
    be attached to it.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 随着组件定义的复杂度增加，与之关联的预期逻辑也变得更加复杂。
- en: '![Figure 1.5: Illustration of the level of UI and Logic complexity for each
    layer](img/B21130_01_05_BW.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图1.5：每个层级的UI和逻辑复杂度示意图](img/B21130_01_05_BW.jpg)'
- en: 'Figure 1.5: Illustration of the level of UI and Logic complexity for each layer'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5：每个层级的UI和逻辑复杂度示意图
- en: What do we mean by logic complexity? Logic complexity can be described as the
    amount of JS required for the component to function correctly.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所说的逻辑复杂度是什么意思？逻辑复杂度可以描述为组件正常工作所需的JS数量。
- en: For example, a component with low logic complexity such as a button will have
    very limited JS, while a more complex component such as an input field will need
    to handle field validation and error placement; furthermore, a page will have
    to take ownership of loading the data from the API, format the data to ensure
    that it is in the right format, and handle the visibility of its children.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，逻辑复杂度低的组件，如按钮，将拥有非常有限的JS，而更复杂的组件，如输入字段，则需要处理字段验证和错误放置；此外，页面还需要负责从API加载数据，格式化数据以确保其处于正确的格式，并处理其子组件的可见性。
- en: In this section, we have introduced how an application is structured using the
    component-based architecture. We introduced the different layers that make up
    a component library and finally defined the advantages that this methodology when
    used in conjunction with a frontend framework such as Vue.js. Let’s now recap
    the chapter in the *Summary* section.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了如何使用组件化架构来构建应用程序。我们介绍了构成组件库的不同层级，并最终定义了当与Vue.js等前端框架结合使用时，这种方法的优势。现在，让我们在*总结*部分回顾本章内容。
- en: Summary
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: It is now the end of the chapter and at this stage, you should have gained some
    knowledge of what we will achieve in this book and the methods that we will be
    using.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是本章的结尾，在这个阶段，你应该已经了解了我们在这本书中将要实现的内容以及我们将使用的方法。
- en: We have learned about our Companion App and what that will include. We have
    quickly touched upon the chapters’ structure and how they will support you in
    your learning journey, and we have finally introduced important topics such as
    component-based architecture, atomic design, and the core areas of web development
    that are the foundation of any frontend project.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了我们的伴侣应用程序以及它将包含的内容。我们简要介绍了章节的结构以及它们将如何支持你的学习之旅，并最终介绍了重要主题，如组件化架构、原子设计和构成任何前端项目基础的前端开发的核心领域。
- en: In the next chapter, we will start to learn about the foundation of Vue.js and
    its core fundamentals and start to give life to our Companion Application.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始学习Vue.js的基础和其核心原理，并开始为我们的伴侣应用程序赋予生命。
