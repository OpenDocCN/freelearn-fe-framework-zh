- en: '*Chapter 5*: Using CSS Custom Properties'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now dive into the practical details of how to implement the features
    you encountered in *Part 1 A Quick and Functional Guide to Angular Ivy* in the
    Angular Academy application, which will allow you to browse and select a curriculum
    of available Angular video courses on YouTube.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by describing the Angular Academy application while covering the
    following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Building a theme picker using custom CSS properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the theme service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling CSS Grid templates using custom CSS properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will have gained practical experience in using
    custom CSS properties in a real-world application.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Combining and using all the new features in the Angular Academy application
    will involve a series of practical choices that are usually hidden in the descriptions
    in *Part 1*, *A Quick and Functional Guide to Angular Ivy* which means we will
    need to provide an overview of the application as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: So, before we dive into an in-depth description of all the details, let's check
    out the code first and have it available for inspection while reading the in-depth
    description in the upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the terminal and issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The demo project source code will be placed in `projects`/`demo` and can be
    started on your development machine, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you go to [http://localhost:4200](http://localhost:4200) on your browser,
    you should now be able to see the Angular Academy app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – In the Angular Academy application, you can see a list of YouTube
    video courses'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.1_B16295.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 – In the Angular Academy application, you can see a list of YouTube
    video courses
  prefs: []
  type: TYPE_NORMAL
- en: When the Angular Academy application is started, you will see a list of YouTube
    courses on the default page (as illustrated in *Figure 5.1*). Feel free to browse
    to get a feel of what we will be covering in the upcoming chapters. As an example,
    try clicking the **Edit Theme** menu entry to open the theme picker. We will be
    looking at this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Building a theme picker using custom CSS properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having a theme available for your application is a common and important use
    case that is already covered by popular Angular libraries. You may be aware that
    Angular Material already supports several available themes (for example, the popular
    **deeppurple-amber** and **indigo-pink**). The common approach of using preprocessor
    variables when using SCSS has been available for some time. But now, you can support
    dynamic theming using custom CSS properties without having to generate the CSS
    files using a preprocessor. This adds new options for interactive theming that
    we will cover in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given that further CSS rules can be built using CSS Custom Properties, we can
    now change several styling rules in one go, directly from one of the components
    in the application. Here, one or more CSS classes can be calculated on the fly
    via the `--headerbackground` custom property or simply by attaching the value
    of the property as the CSS class, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `headerbackground` color can be picked by the user using a theme picker
    construct, similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: For interactive use, the value of the `headerbackground` custom property could
    be a variable stored in `localStorage` that's available during use. `headergroundcolor`
    could then affect the styling of the elements inside the specific tile component.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Angular Academy application, we will wrap it with an Angular Material
    form field in the theme component template, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the Material form input field in the theme picker component will look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – You can use the theme picker component to select the header''s
    background color'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.2_B16295.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.2 – You can use the theme picker component to select the header's background
    color
  prefs: []
  type: TYPE_NORMAL
- en: We can apply the chosen color *directly* from the custom SCSS properties to
    the relevant component SCSS files in the application or directly at the app scope
    using the style syntax precedence works implemented in Ivy.
  prefs: []
  type: TYPE_NORMAL
- en: 'For practical purposes, we will use a `@HostBinding` to bind each theme setting
    to a theme variable for the application scope, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The values for the CSS properties can be retrieved in the theme component via
    a getter, which retrieves the value via the theme service, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `update($event)` callback on the theme component could refer to the theme
    service, which would update the chosen value behind the scenes. Additionally,
    the theme component would allow access to the chosen values for the custom CSS
    properties by binding them to the application''s scope, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the app component, we are referring to the same theme service for handling
    data updates related to the theme component. By separating handling data updates
    into a service, we can abstract the details of how to store and retrieve the theme
    settings for later.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the theme service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The theme service has the responsibility of retrieving the dynamic theme settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with a simple implementation by using `localStorage`. In this
    implementation, we will also provide default settings if the value is not available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, we will provide example settings if the setting has no previous value.
    For example, if `headerBackground` has not previously been set, then we will set
    it to `#00aa00`.
  prefs: []
  type: TYPE_NORMAL
- en: One of the benefits of using the theme service from the theme picker component
    is that you, at a later stage, could choose to implement the theme service to
    use another mechanism for storing and retrieving settings (for example, you could
    choose to retrieve values from a corporate design token system that may contain
    the default settings). Additionally, you can also use a provider scope for the
    service to share data related to the usage scenario, as you will see later in
    [*Chapter 8*](B16295_08_ePub_RK.xhtml#_idTextAnchor094), *Additional Provider
    Scopes*. Another aspect of theming is controlling the relative sizes and placement
    of items on the screen, depending on user preferences. A modern approach to this
    is using CSS Grids – and it turns out that we can encapsulate these settings well
    using custom CSS properties. We will cover how to do this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling CSS Grid templates using custom CSS properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that you want to emphasize the importance of the textual descriptions
    of videos, so you would like to increase the amount of space for text, and most
    likely decrease the amount of space used for the video. This could be implemented
    using a dynamic viewer using some TypeScript logic, which could perform the sizing
    calculations on the fly. Given that you would like to be able to view the content
    on your mobile phone as well, you would need to implement considerations for the
    grid layout on smaller screens. This additional requirement would be complex enough
    that custom theming would be required. However, as it turns out, we can combine
    media queries with inline custom CSS properties in a manner that is both compact
    and easy to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we introduce the `video` and `text` CSS classes for the course video tiles,
    then we can style them using custom CSS properties and CSS Grid techniques while
    referencing the `container` grid-columns, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `videosize` and `textsize` CSS properties would then control how many columns
    are assigned to `video` and `text`. The declaration of the `container` grid looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'These new CSS classes could be combined in the `Course` component to render
    the videos alongside accompanying text descriptions, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To control the sizing inside the course tiles, we will introduce two new variables
    to the theme component: **video size** and **text size**. These two variables
    will be bound in their range by the available columns in the CSS Grid (in this
    case, 12). Additionally. it would make sense that they sum up to the number of
    columns.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **video size** and **text size** sliders could be implemented as part of
    the theme picker. This would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Using sliders for video and text size'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.3_B16295.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.3 – Using sliders for video and text size
  prefs: []
  type: TYPE_NORMAL
- en: 'For practical purposes, we will bound the `3` and `7` (to allow for a max of
    `5` for **text size**). This should leave sufficient room for both the video and
    the text inside the grid. This simple approach can be implemented via a Material
    Slider, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `setSize` callback will update the variable using the theme service
    in the same manner as the other variables – just with the added complexity that
    we have received a `MatSliderChange`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Every time we change the value in one of the sliders, the layout of components
    inside the grid could be changed. We should pay attention when including output
    from external components that have their own layout systems (for example, the
    YouTube Player). We will learn about integrating the YouTube Player in the next
    chapter, but for now, let's just settle with a simple `location.reload()`. This
    should illustrate how to force a render of the grid (and all the other components
    too).
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we leave the topic of using custom CSS properties from Angular, let''s
    remember that we want to support smaller screens as well. It turns out that we
    can introduce an elegant solution by combining custom CSS properties and media
    queries without referring to Angular code, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see one of the strengths of adding support for using custom CSS
    properties directly from within Angular in the application scope: by using a combination
    of CSS Custom Properties and media queries outside the Angular components, we
    can rely on the expertise of dedicated designers that can work with little or
    no knowledge about Angular code. Additionally, we would also have the option of
    creating integrations that could retrieve theme settings from corporate design
    token systems, without requiring the application to be redeployed when the design
    tokens change.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you encountered the Angular Academy application for the first
    time and learned how CSS Custom Properties can be used to implement the theme
    picker using a theme service. Along the way, you also had a brief first encounter
    with the YouTube Player in the course list.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will dig deeper into how to use the YouTube Player and
    how you can combine a curriculum of YouTube videos using the Angular components
    you learned about in *Part 1, A Quick and Functional Guide to Angular Ivy*.
  prefs: []
  type: TYPE_NORMAL
