- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Test-Driving React Router
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动 React Router
- en: '**React Router** is a popular library of components that integrate with the
    browser’s own navigation system. It manipulates the browser’s address bar so that
    changes in your UI appear as page transitions. To the user, it seems like they
    are navigating between separate pages. In reality, they remain on the same page
    and avoid an expensive page reload.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**React Router** 是一个流行的组件库，它与浏览器的自身导航系统集成。它操作浏览器的地址栏，使得你的 UI 变化看起来像是页面转换。对于用户来说，他们似乎在导航到不同的页面。实际上，他们仍然停留在同一个页面上，避免了昂贵的页面重新加载。'
- en: In this chapter, we’ll refactor our example appointments system to make use
    of React Router. Unlike the rest of the book, this chapter is not a walkthrough.
    That’s because the refactoring process is quite long and laborious. Instead, we’ll
    look at each of the main changes in turn.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重构我们的示例预约系统以使用 React Router。与本书的其余部分不同，本章不是一个逐步指南。这是因为重构过程相当长且费力。相反，我们将依次查看每个主要更改。
- en: 'This chapter covers the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下内容：
- en: Designing React Router applications from a test-first perspective
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从测试优先的角度设计 React Router 应用程序
- en: Testing components within a router
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在路由器内测试组件
- en: Testing router links
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试路由链接
- en: Testing programmatic navigation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试编程式导航
- en: By the end of the chapter, you’ll have learned all the necessary techniques
    for test-driving React Router integrations.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将学会所有测试驱动 React Router 集成所必需的技术。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code files for this chapter can be found here:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在以下位置找到：
- en: '[https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter11](https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter11)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter11](https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter11)'
- en: Designing React Router applications from a test-first perspective
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从测试优先的角度设计 React Router 应用程序
- en: This section is a run-down of all the major pieces of the React Router ecosystem,
    just in case you’re not familiar with it. It also contains guidance on how to
    test a system that relies on React Router.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本节是对 React Router 生态系统所有主要部分的概述，以防你不熟悉它。它还包含了如何测试依赖于 React Router 的系统的指导。
- en: A list of all the React Router pieces
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 所有 React Router 组件的列表
- en: 'Here’s what you’ll be working with from the React Router library:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用 React Router 库中的以下内容：
- en: A `Router` component. You’ll generally have one of these, and there are a bunch
    of different types. The basic one is `BrowserRouter` but you’ll undoubtedly upgrade
    to `HistoryRouter` if you need to manipulate history outside of the router, which,
    since you’re writing tests, you will. In [*Chapter 12*](B18423_12.xhtml#_idTextAnchor231),
    *Test-Driving Redux*, you’ll also see how this is necessary if you’re causing
    page transitions to occur within Redux actions.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `路由器` 组件。你通常会有一个这样的组件，并且有很多不同的类型。基本的是 `BrowserRouter`，但如果你需要在外部路由器中操作历史记录，你无疑会升级到
    `HistoryRouter`，因为你正在编写测试。在 [*第 12 章*](B18423_12.xhtml#_idTextAnchor231) *测试驱动
    Redux* 中，你也会看到这是在 Redux 动作中引起页面转换所必需的。
- en: A `Routes` component. This is analogous to the `switch` statement in our existing
    `App` component. It has a list of `Route` children and will choose just one of
    those children to display at one time.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `路由` 组件。这类似于我们现有 `App` 组件中的 `switch` 语句。它有一个 `路由` 子组件列表，并且一次只会选择其中一个子组件来显示。
- en: A set of `Route` components with the `Routes` parent. Each `Route` has a path
    property, for example, `/addCustomer`, that the `Router` component uses to compare
    with the window’s current location. The route that matches is the one that is
    displayed.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组带有 `路由` 父组件的 `路由` 组件。每个 `路由` 都有一个路径属性，例如 `/addCustomer`，`路由器` 组件会使用它来与窗口的当前位置进行比较。匹配的路由就是显示的那个。
- en: One or more `Link` components. These display like normal HTML hyperlinks, but
    they don’t act like them; React Router stops the browser from receiving these
    navigation events and instead sends them back to the `Routes` component, meaning
    a page transition doesn’t occur.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个或多个 `链接` 组件。这些显示得像正常的 HTML 超链接，但它们的行为不同；React Router 会阻止浏览器接收这些导航事件，并将它们发送回
    `路由` 组件，这意味着不会发生页面转换。
- en: The `useNavigate` hook. This is used to perform a page transition as part of
    a React side effect or event handler.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useNavigate` 钩子。这用于在 React 侧效应或事件处理程序中执行页面转换。'
- en: The `useLocation` and `useSearchParams` hooks. These are used to get parts of
    the current window location within your components.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useLocation`和`useSearchParams`钩子。这些用于在组件中获取当前窗口位置的某些部分。'
- en: Splitting tests when the window location changes
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当窗口位置改变时拆分测试
- en: You can see from this list that React Router’s core function is to manipulate
    the window location and modify your application’s behavior based on that location.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从这个列表中看到，React Router的核心功能是操作窗口位置并根据该位置修改您应用程序的行为。
- en: One way to think about this is that we will utilize the window location as a
    form of application state that is accessible to all our components. Importantly,
    this state persists across web requests, because a user can save or bookmark links
    for use later.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这一点的一种思考方式是，我们将利用窗口位置作为应用程序状态的一种形式，这种状态对所有我们的组件都是可访问的。重要的是，这种状态在Web请求之间持续存在，因为用户可以保存或收藏链接以供以后使用。
- en: 'A consequence of this is that we must now split apart some of our unit tests.
    Take, for example, the **Create appointment** button that was previously used
    to switch out the main component on display on the page. With React Router in
    place, this button will become a link. Previously, we had a single unit test named
    as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这的结果是我们现在必须将一些单元测试分开。以之前用于切换页面上显示的主要组件的**创建预约**按钮为例。在React Router到位后，这个按钮将变成一个链接。之前，我们有一个名为以下内容的单个单元测试：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'But now, we’ll split that into two tests:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在，我们将它拆分为两个测试：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can see that the first test stops at the moment the window location changes.
    The second test begins at the moment the browser navigates to the same location.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，第一个测试在窗口位置改变时停止。第二个测试在浏览器导航到相同位置时开始。
- en: 'It’s important to make this change because React Router isn’t just refactoring,
    it’s adding a new feature: the URL is now accessible as an entry point into your
    application.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 进行这项更改很重要，因为React Router不仅仅是重构，它还在添加一个新功能：URL现在可以作为您应用程序的入口点。
- en: That is, in essence, the most important thing you need to know before introducing
    React Router into your projects.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，在本质上，这是在将React Router引入您的项目之前您需要知道的最重要的事情。
- en: Up-front design for our new routes
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为我们新的路由进行前期设计
- en: 'Before launching into this refactor, let’s take a look at the routes we’ll
    be introducing:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始重构之前，让我们看看我们将要引入的路由：
- en: The default route, `/`, will remain as our `AppointmentsDayViewLoader` together
    with navigation buttons. This is extracted out as a new component named `MainScreen`.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认路由`/`将保持为我们的`AppointmentsDayViewLoader`，以及导航按钮。这被提取出来作为一个名为`MainScreen`的新组件。
- en: A route to add a new customer, at `/addCustomer`.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于添加新客户的路由，位于`/addCustomer`。
- en: A route to add a new appointment for a given customer, at `/addAppointment?customer=<id>`.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于为特定客户添加新预约的路由，位于`/addAppointment?customer=<id>`。
- en: 'A route to search for customers at `/searchCustomers`. This can receive a set
    of query string values: `searchTerm`, `limit`, and `previousRowIds`. For example,
    the query string might look as follows:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于在`/searchCustomers`搜索客户的路由。它可以接收一组查询字符串值：`searchTerm`、`limit`和`previousRowIds`。例如，查询字符串可能如下所示：
- en: '[PRE2]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next, we’ll look at test-driving a `Router` component along with its `Route`
    children.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看如何测试`Router`组件及其`Route`子组件。
- en: Testing components within a router
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在路由器内测试组件
- en: In this section, we’ll look at how to use the primary `Router`, `Routes`, and
    `Route` components.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何使用主要的`Router`、`Routes`和`Route`组件。
- en: No walkthrough in this chapter
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 本章没有演练内容
- en: As mentioned in the chapter introduction, this chapter does not follow the usual
    walkthrough approach. The examples shown here are taken from the completed refactoring
    of our Appointments code base, which you’ll find in the `Chapter11/Complete` directory
    of the GitHub repository.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如章节介绍中所述，本章不遵循通常的演练方法。这里显示的示例是从我们Appointments代码库的完成重构中提取的，您可以在GitHub仓库的`Chapter11/Complete`目录中找到。
- en: The Router component and its test equivalent
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由器组件及其测试等效组件
- en: This is a top-level component that hooks into your browser’s location mechanics.
    We do not generally test drive this because JSDOM doesn’t deal with page transitions,
    or have full support for the `window.location` API.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个顶级组件，它连接到您浏览器的位置机制。我们通常不进行测试驱动，因为JSDOM不处理页面转换，也没有对`window.location` API的完全支持。
- en: 'Instead, we put it in the `src/index.js` file:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将其放在`src/index.js`文件中：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is necessary because if you try to use any of the other React Router components
    outside of a child of a `Router` component, it will blow up. The same is true
    for our tests: our components need to be rendered inside of a router. So, we introduce
    a new render helper called `renderWithRouter`.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为如果你尝试在`Router`组件的子组件之外使用任何其他React Router组件，它将会崩溃。对于我们的测试也是如此：我们的组件需要在路由器内部渲染。因此，我们引入了一个新的渲染辅助函数，称为`renderWithRouter`。
- en: 'This definition is within `test/reactTestExtensions.js`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义在`test/reactTestExtensions.js`中：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: MemoryRouter versus HistoryRouter
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: MemoryRouter与HistoryRouter
- en: The React Router documentation will suggest you use `MemoryRouter`, which is
    often good enough. Using `HistoryRouter` allows you to control the history instance
    that is passed in, meaning you can manipulate it from within your tests.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: React Router文档建议你使用`MemoryRouter`，这通常足够好。使用`HistoryRouter`允许你控制传入的历史实例，这意味着你可以在测试中操作它。
- en: For more information, take a look at [https://reacttdd.com/memory-router-vs-history-router](https://reacttdd.com/unpublished/memory-router-vs-history-router/).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请参阅[https://reacttdd.com/memory-router-vs-history-router](https://reacttdd.com/unpublished/memory-router-vs-history-router/)。
- en: It’s important to export the `history` variable itself if you want to manipulate
    the window location from within your own tests. A special case of this is if you
    want to set the window location before mounting the component; in this situation,
    you can simply pass a `location` property to the `renderWithRouter` function.
    You’ll see how this works next.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在测试中操作窗口位置，那么导出`history`变量本身是很重要的。这种情况的一个特例是，如果你想在挂载组件之前设置窗口位置；在这种情况下，你可以简单地将一个`location`属性传递给`renderWithRouter`函数。你将在下一节中看到它是如何工作的。
- en: Using the Routes component to replace a switch statement
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`Routes`组件替换switch语句
- en: Now let’s look at using the `Routes` component to switch components depending
    on the window location. This component is generally at the top of the application
    component hierarchy, and in our case, it is indeed the first component within
    `App`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用`Routes`组件根据窗口位置切换组件。这个组件通常位于应用程序组件层次结构的顶部，在我们的例子中，它确实是`App`中的第一个组件。
- en: The `Routes` component is analogous to the `switch` statement that existed in
    the original app. The `switch` statement was using a state variable to determine
    which component should be shown. The `Routes` component relies on the parent `Router`
    to feed it the window location as context.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`Routes`组件与原始应用程序中存在的`switch`语句类似。`switch`语句使用状态变量来确定应该显示哪个组件。`Routes`组件依赖于父`Router`来提供窗口位置作为上下文。'
- en: 'Here’s what the original `switch` statement looked like in the `App` component:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`App`组件中原始的`switch`语句的样子：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Its `Router` replacement looks like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 它的`Router`替代品看起来像这样：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `view` state variable is no longer needed. Notice how we have a couple of
    new components with a `Route` suffix. These components are small wrappers that
    pull out the customer ID and other parameters from the window location before
    passing it to the original components. We’ll look at those soon.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`view`状态变量不再需要。注意我们有几个带有`Route`后缀的新组件。这些组件是小的包装器，在将它们传递给原始组件之前，从窗口位置中提取客户ID和其他参数。我们很快就会看到它们。'
- en: But first, how do the tests look for these new routes?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，这些新路由的测试看起来是怎样的？
- en: 'For the default route, the tests are simple, and are updates to the tests that
    were there before:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于默认路由，测试很简单，是对之前存在的测试的更新：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The only difference is that we use the `renderWithRouter` helper, not `render`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是我们使用`renderWithRouter`辅助函数，而不是`render`。
- en: 'The other routes are similar, except that they use the `location` property
    to set the initial window location, and their assertions are based on mocked components:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 其他路由类似，只是它们使用`location`属性设置初始窗口位置，并且它们的断言基于模拟组件：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Using intermediate components to translate URL state
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用中间组件来转换URL状态
- en: Let’s take a closer look at `AppointmentFormRoute` and `CustomerSearchRoute`.
    What are these components doing?
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看`AppointmentFormRoute`和`CustomerSearchRoute`。这些组件在做什么？
- en: 'Here’s the definition of `AppointmentFormRoute`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`AppointmentFormRoute`的定义：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This component is an intermediate component that sits between the `Route` component
    instance for `/addAppointment` and the `AppointmentFormLoader` component instance.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件是一个中间组件，位于`/addAppointment`的`Route`组件实例和`AppointmentFormLoader`组件实例之间。
- en: It would have been possible to simply reference the `useSearchParams` function
    from within `AppointmentFormLoader` itself, but by using this intermediate class,
    we can avoid modifying that component and keep the two responsibilities separate.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 本可以直接在`AppointmentFormLoader`内部引用`useSearchParams`函数，但通过使用这个中间类，我们可以避免修改该组件，并保持两个职责的分离。
- en: Having a single responsibility per component helps with comprehension. It also
    means that should we ever wish to rip out React Router at a later date, `AppointmentFormLoader`
    doesn’t need to be touched.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 每个组件只负责一个任务有助于理解。这也意味着，如果我们以后希望移除React Router，`AppointmentFormLoader`就不需要被修改。
- en: 'There are a couple of interesting tests for this component. The first is the
    check for parsing the `customer` search parameter:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个组件有一些有趣的测试。第一个是检查解析`customer`搜索参数：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `location` property sent to `renderWithRouter` is just a standard query
    string: `?customer=123`. We could have entered a full URL here, but the test is
    clearer by focusing purely on the query string portion of the URL.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 发送到`renderWithRouter`的`location`属性只是一个标准的查询字符串：`?customer=123`。我们本可以在这里输入一个完整的URL，但通过仅关注URL的查询字符串部分，测试会更清晰。
- en: 'The second test is for the remainder of the props:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个测试是对剩余的props：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The test is important because the `Route` element passes through an `onSave`
    property that is for `AppointmentFormLoader`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试很重要，因为`Route`元素传递了一个`onSave`属性，它是为`AppointmentFormLoader`准备的：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We’ll look at what the `transitionToDayView` function does in the *Testing navigation*
    section a little further on.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后的*测试导航*部分看看`transitionToDayView`函数做了什么。
- en: 'Now let’s see `CustomerSearchRoute`. This is a little more complicated because
    it parses some of the query string parameters, using a function called `convertParams`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看`CustomerSearchRoute`。这稍微复杂一些，因为它使用名为`convertParams`的函数解析了一些查询字符串参数：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This function replaces the three state variables that were used in the existing
    `CustomerSearch` component. Since all query string parameters are strings, each
    value needs to be parsed into the right format. These values are then passed into
    `CustomerSearch` as props:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数替换了现有`CustomerSearch`组件中使用的三个状态变量。由于所有查询字符串参数都是字符串，每个值都需要解析成正确的格式。然后这些值作为props传递给`CustomerSearch`：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This parameter parsing functionality could have been put into `CustomerSearch`,
    but keeping that logic in a separate component helps with readability.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个参数解析功能原本可以放入`CustomerSearch`中，但将这个逻辑放在一个单独的组件中有助于提高可读性。
- en: This example also shows the use of `useNavigate`, which is passed through to
    `CustomerSearch`. Passing this hook function return value as a prop means we can
    test `CustomerSearch` with a standard Jest spy function for the value of `navigate`,
    avoiding the need to render the test component within a router.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子还展示了`useNavigate`的使用，它被传递给`CustomerSearch`。将这个钩子函数的返回值作为prop传递意味着我们可以使用标准的Jest
    spy函数测试`navigate`的值，从而避免在路由中渲染测试组件。
- en: 'The tests for this component are straightforward. Let’s take a look at one
    example:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件的测试很简单。让我们看看一个例子：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You’ve now learned all there is to working with the three components: `Router`,
    `Routes`, and `Route`. Next up is the `Link` component.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经了解了如何与三个组件一起工作：`Router`、`Routes`和`Route`。接下来是`Link`组件。
- en: Testing router links
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试路由链接
- en: In this section, you’ll learn how to use and test the `Link` component. This
    component is React Router’s version of the humble HTML anchor (or `a`) tag.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何使用和测试`Link`组件。这个组件是React Router对谦逊的HTML锚点（或`a`）标签的版本。
- en: 'There are two forms of the `Link` component that we use. The first uses the
    `to` prop as a string, for example, `/addCustomer`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了两种形式的`Link`组件。第一种使用`to`属性作为字符串，例如，`/addCustomer`：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The second sets the `to` prop to an object with a `search` property:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个设置`to`属性为一个具有`search`属性的`object`：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This object form also takes a `pathname` property, but we can avoid setting
    that since the path remains the same for our use case.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象形式也接受一个`pathname`属性，但我们可以避免设置它，因为对于我们的用例，路径保持不变。
- en: 'We’ll look at two different ways of testing links: the standard way (by checking
    for hyperlinks), and the slightly more painful way of using mocks.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨两种不同的测试链接的方法：标准方法（通过检查超链接），以及稍微痛苦一些的模拟方法。
- en: Checking the page for hyperlinks
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查页面中的超链接
- en: 'Here’s the `MainScreen` component in `src/App.js`, which shows the navigation
    links and the appointments day view:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`src/App.js`中的`MainScreen`组件，它显示了导航链接和预约日视图：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Extracted component
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 提取组件
- en: The `MainScreen` component has been extracted out of `App`. The same code previously
    lived in the `switch` statement as the default case.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainScreen`组件已被从`App`中提取出来。相同的代码之前位于`switch`语句的默认情况下。'
- en: 'The `Link` component generates a standard HTML anchor tag. This means we create
    a helper to find a specific link by looking for an anchor tag with a matching
    `href` attribute. This is in `test/reactTestExtensions.js`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`Link`组件生成一个标准的HTML锚标签。这意味着我们创建了一个辅助工具，通过查找具有匹配`href`属性的锚标签来找到特定的链接。这位于`test/reactTestExtensions.js`中：'
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'That can be then used to test for the presence of a link and its caption:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以用来测试链接的存在及其标题：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Another way to test this would be to click the link and check that it works,
    as shown in the following test. However, as mentioned at the beginning of this
    chapter, this test isn’t necessary because you’ve already tested the two “halves”
    of this test: that the link is displayed, and that navigating to the URL renders
    the right component:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 测试这个问题的另一种方法是通过点击链接并检查其是否正常工作，如下面的测试所示。然而，正如本章开头提到的，这个测试是不必要的，因为你已经测试了测试的两个“部分”：链接是否显示，以及导航到URL是否渲染了正确的组件：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: That covers the main way to test `Link` components. Another way to test links
    is to mock the `Link` component, which we’ll cover next.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了测试`Link`组件的主要方法。另一种测试链接的方法是模拟`Link`组件，我们将在下一节中介绍。
- en: Mocking the Link component
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟`Link`组件
- en: This method is slightly more complicated than simply testing for HTML hyperlinks.
    However, it does mean you can avoid rendering your component under test within
    a `Router` component.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法比简单地测试HTML超链接要复杂一些。然而，这意味着你可以避免在`Router`组件内渲染你的测试组件。
- en: 'The `src/CustomerSearch/RouterButton.js` file contains this component:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/CustomerSearch/RouterButton.js`文件包含这个组件：'
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To test this using plain `render`, instead of `renderWithRouter`, we’ll need
    to mock out the `Link` component. Here’s how that looks in `test/CustomerSearch/RouterButton.test.js`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用普通的`render`测试而不是`renderWithRouter`，我们需要模拟`Link`组件。以下是`test/CustomerSearch/RouterButton.test.js`中的样子：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, you can happily use that mock in your test:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在测试中愉快地使用这个模拟：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: There’s one final piece to think about. Sometimes, you have a single mocked
    component that has multiple rendered instances on the same page, and this happens
    frequently with `Link` instances.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个最后的要点需要考虑。有时候，你有一个单个的模拟组件在同一页面上有多个渲染实例，这种情况在`Link`实例中经常发生。
- en: 'In our case, this is the `SearchButtons` component, which contains a list of
    `RouterButton` and `ToggleRouterButton` components:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，这是`SearchButtons`组件，它包含一个`RouterButton`和`ToggleRouterButton`组件的列表：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When it comes to testing these links, the simplest approach is to use `renderWithRouter`
    to render the `SearchButtons` components and then check the rendered HTML hyperlinks.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到测试这些链接时，最简单的方法是使用`renderWithRouter`来渲染`SearchButtons`组件，然后检查渲染的HTML超链接。
- en: However, if you’ve decided to mock, then you need a way to easily find the element
    you’ve rendered.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你已经决定模拟，那么你需要一种方法来轻松地找到你渲染的元素。
- en: 'First, you’d specify the mock to include an `id` property:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要指定模拟包括一个`id`属性：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, you can use a new test extension called `propsMatching` to find the specific
    instance. Here’s the definition from `test/reactTestExtensions.js`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用一个新的测试扩展`propsMatching`来找到特定的实例。以下是来自`test/reactTestExtensions.js`的定义：
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You can then write your test to make use of that, as shown in the following
    code. Remember though, it’s probably going to be easier not to mock this component
    and simply use `renderWithRouter`, and then check the HTML hyperlinks directly:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以编写测试来利用这一点，如下面的代码所示。但请记住，可能更容易不模拟这个组件，而直接使用`renderWithRouter`，然后直接检查HTML超链接：
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'That’s everything there is to testing the `Link` component. In the next section,
    we’ll look at the final aspect of testing React Router: navigating programmatically.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是测试`Link`组件的所有内容。在下一节中，我们将探讨测试React Router的最后一个方面：程序化导航。
- en: Testing programmatic navigation
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试程序化导航
- en: Sometimes, you’ll want to trigger a location change programmatically—in other
    words, without waiting for a user to click a link.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能想要程序化地触发位置变化——换句话说，不等待用户点击链接。
- en: 'There are two ways to do this: one using the `useNavigate` hook, and the second
    using a `history` instance that you pass into your top-level router.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以做到这一点：一种使用`useNavigate`钩子，另一种使用传递给顶级路由器的`history`实例。
- en: Navigation inside and outside of components
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 组件内外的导航
- en: In this chapter, we’ll look at just the first method, using the hook. Later,
    in [*Chapter 12*](B18423_12.xhtml#_idTextAnchor231), *Test-Driving Redux*, we’ll
    use the second method to change the location within a Redux action.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将仅探讨第一种方法，即使用钩子。稍后，在[*第12章*](B18423_12.xhtml#_idTextAnchor231)“测试驱动Redux”中，我们将使用第二种方法来更改Redux动作中的位置。
- en: The `useNavigate` hook is the appropriate method when you’re able to navigate
    from within a React component.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当你能够在React组件内部进行导航时，`useNavigate`钩子是适当的方法。
- en: In the Appointments application, this happens in two places. The first is after
    a customer has been added and we want to move the user on to the `/addAppointment`
    route. The second is after that form has been completed and the appointment has
    been created—then we want to move them back to the default route.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在预约应用程序中，这发生在两个地方。第一个是在客户被添加后，我们希望将用户移动到`/addAppointment`路由。第二个是在表单填写完成并且预约被创建后——然后我们希望将他们移回默认路由。
- en: Since these are very similar, we’ll look at just the first.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些非常相似，我们只需查看第一个。
- en: 'Here’s how the `/addCustomer` route definition looks in `src/App.js`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`/addCustomer`路由定义在`src/App.js`中的样子：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Notice the `onSave` prop; this is the callback that gets called once the customer
    form submission is completed. Here’s that callback definition, together with the
    bits relevant for the `useNavigate` hook:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`onSave`属性；这是在客户表单提交完成后被调用的回调。以下是该回调定义，以及与`useNavigate`钩子相关的部分：
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'When it comes to testing this, clearly, we can’t simply rely on the presence
    of a `Link` component, because there isn’t one. Instead, we must call the `onSave`
    callback:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到测试这一点时，显然，我们不能仅仅依赖于`Link`组件的存在，因为并没有。相反，我们必须调用`onSave`回调：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The expectation is to test that the history is updated correctly. This history
    is the exported constant from `test/reactTestExtensions.js` that is set in the
    `renderWithRouter` function that we defined in the *Testing components within
    a router* section.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 预期是要测试历史记录是否正确更新。这个历史记录是来自`test/reactTestExtensions.js`的导出常量，它在我们在*在路由器中测试组件*部分定义的`renderWithRouter`函数中被设置。
- en: 'There is a variation of this. Instead of using the `history` import, you could
    also simply use the `window.location` instance:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一个变体。你不仅可以使用`history`导入，还可以简单地使用`window.location`实例：
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You’ve now learned how to test programmatic React Router navigation.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经学会了如何测试程序化的React Router导航。
- en: In the next chapter, *Test-Driving Redux*, we’ll see how we can use this same
    history instance from a Redux saga.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章“测试驱动Redux”中，我们将看到如何使用这个相同的历史实例从Redux sagas中。
- en: Summary
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has shown you how to use React Router in a testable fashion. You
    have learned how to test-drive the `Router`, `Routes`, `Route`, and `Link` components.
    You have seen how to use the React Router `useSearchParams` and `useNavigate`
    hooks.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您展示了如何以可测试的方式使用React Router。你已经学会了如何测试驱动`Router`、`Routes`、`Route`和`Link`组件。你已经看到了如何使用React
    Router的`useSearchParams`和`useNavigate`钩子。
- en: 'Most importantly, you’ve seen that because routes give an extra level of entry
    into your application, you must split your existing navigation tests into two
    parts: one to test that a link exists (or is followed), and one to check that
    if you visit that URL, the right component is displayed.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，你已经看到，由于路由为你的应用程序提供了额外的入口级别，你必须将现有的导航测试分成两部分：一部分测试链接是否存在（或被跟随），另一部分检查如果你访问该URL，是否显示正确的组件。
- en: 'Now that we’ve successfully integrated one library, the next one shouldn’t
    be too tricky, right? In the next chapter, we’ll apply all the skills we’ve learned
    in this chapter to the integration of another library: Redux.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功集成了一个库，下一个库应该不会太棘手，对吧？在下一章中，我们将把本章学到的所有技能应用到另一个库的集成中：Redux。
- en: Exercise
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: In this chapter, there was no walkthrough because the refactoring process is
    quite involved and would have taken up a decent chunk of time and space.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，没有进行详细说明，因为重构过程相当复杂，会占用相当的时间和空间。
- en: Use this opportunity to try refactoring yourself. Use a *systematic refactoring*
    approach to break down the change to React Router into many small steps. At each
    step, you should still have working software.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 利用这个机会尝试自我重构。使用*系统化重构*方法将React Router的更改分解成许多小步骤。在每一步中，你仍然应该有可工作的软件。
- en: You can find a guide on how to approach this type of refactoring at [https://reacttdd.com/refactoring-to-react-router](https://reacttdd.com/unpublished/refactoring-to-react-router/).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://reacttdd.com/refactoring-to-react-router](https://reacttdd.com/unpublished/refactoring-to-react-router/)找到如何处理此类重构的指南。
- en: Further reading
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The official React Router documentation can be found at the following link:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 官方 React Router 文档可以在以下链接找到：
- en: '[https://reacttraining.com/react-router/](https://reacttraining.com/react-router/)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://reacttraining.com/react-router/](https://reacttraining.com/react-router/)'
