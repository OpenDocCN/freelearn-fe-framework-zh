- en: Manipulating the DOM
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操纵 DOM
- en: The Web experience is a partnership between web servers and web browsers. Traditionally,
    it has been the domain of the server to produce an HTML document that is ready
    for consumption by the browser. The techniques we have seen in this book have
    shifted this arrangement slightly, using CSS techniques to alter the appearance
    of the HTML document on the fly. To really flex our JavaScript muscles, though,
    you'll need to learn to alter the document itself.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Web 经验是 Web 服务器和 Web 浏览器之间的合作伙伴关系。传统上，生成可供浏览器使用的 HTML 文档一直是服务器的职责。我们在本书中看到的技术略微改变了这种安排，使用
    CSS 技术实时改变 HTML 文档的外观。但要真正发挥我们的 JavaScript 实力，你需要学会修改文档本身。
- en: 'In this chapter, we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Modifying the document using the interface provided by the **Document Object
    Model** (**DOM**)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**文档对象模型**（**DOM**）提供的接口修改文档
- en: Creating elements and text on a page
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在页面上创建元素和文本
- en: Moving or deleting elements
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动或删除元素
- en: Transforming a document by adding, removing, or modifying attributes and properties
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过添加、删除或修改属性和属性，转换文档
- en: Manipulating attributes and properties
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操纵属性和属性
- en: Throughout the first four chapters of this book, we have been using the `.addClass()`
    and `.removeClass()` methods to demonstrate how we can change the appearance of
    elements on a page. Although we discussed these methods informally in terms of
    manipulating the `class` attribute, jQuery actually modifies a DOM property called
    `className`. The `.addClass()` method creates or adds to the property, while `.removeClass()`
    deletes or shortens it. Add to these the `.toggleClass()` method, which alternates
    between adding and removing class names, and we have an efficient and robust way
    of handling classes. These methods are particularly helpful in that they avoid
    adding a class if it already exists on an element (so we don't end up with `<div
    class="first first">`, for example), and correctly handle cases where multiple
    classes are applied to a single element, such as `<div class="first second">`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前四章中，我们一直在使用`.addClass()`和`.removeClass()`方法来演示如何在页面上更改元素的外观。尽管我们非正式地讨论了这些方法，提到了操纵`class`属性，但
    jQuery 实际上修改了一个名为`className`的 DOM 属性。`.addClass()`方法创建或添加到该属性，而`.removeClass()`删除或缩短它。再加上`.toggleClass()`方法，它在添加和删除类名之间切换，我们就有了一种高效而健壮的处理类的方式。这些方法特别有帮助，因为它们在元素上添加类时避免了添加已经存在的类（所以我们不会得到`<div
    class="first first">`，例如），并且正确处理应用于单个元素的多个类的情况，例如`<div class="first second">`。
- en: Non-class attributes
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非类属性
- en: We may need to access or change several other attributes or properties from
    time to time. For manipulating attributes such as `id`, `rel`, and `href`, jQuery
    provides the `.attr()` and `.removeAttr()` methods. These methods make changing
    an attribute a simple matter. In addition, jQuery lets us modify more than one
    attribute at a time, similar to the way we worked with multiple CSS properties
    using the `.css()` method in [Chapter 4](6544cf68-239c-4a0b-99f6-2d128dc5f7b1.xhtml),
    *Styling and Animating*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能需要不时访问或更改其他几个属性或属性。对于操纵诸如`id`、`rel`和`href`之类的属性，jQuery 提供了`.attr()`和`.removeAttr()`方法。这些方法使更改属性变得简单。此外，jQuery
    还允许我们一次修改多个属性，类似于我们使用`.css()`方法在[第 4 章](6544cf68-239c-4a0b-99f6-2d128dc5f7b1.xhtml)*样式和动画*中处理多个
    CSS 属性的方式。
- en: 'For example, we can easily set the `id`, `rel`, and `title` attributes for
    links all at once. Let''s start with some sample HTML:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以轻松地一次设置链接的`id`、`rel`和`title`属性。让我们从一些示例 HTML 开始：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Getting the example code
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 获取示例代码
- en: You can access the example code from the following GitHub repository: [https://github.com/PacktPublishing/Learning-jQuery-3](https://github.com/PacktPublishing/Learning-jQuery-3).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从以下 GitHub 存储库访问示例代码：[https://github.com/PacktPublishing/Learning-jQuery-3](https://github.com/PacktPublishing/Learning-jQuery-3)。
- en: 'Now, we can iterate through each of the links inside `<div class="chapter">`
    and apply attributes to them one by one. If we need to set a single attribute
    value for all of the links, we can do so with a single line of code within our
    `$(() => {})` handler:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以迭代`<div class="chapter">`内的每个链接，并逐个应用属性。如果我们需要为所有链接设置单个属性值，我们可以在我们的`$(()
    => {})`处理程序中用一行代码完成：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Listing 5.1
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.1
- en: 'Much like the `.css()` method, `.attr()` can accept a pair of parameters, the
    first specifying the attribute name and the second being its new value. More typically,
    though, we supply an object of key-value pairs, as we have in *Listing 5.1*. The
    following syntax allows us to easily expand our example to modify multiple attributes
    at once:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`.css()`方法一样，`.attr()`也可以接受一对参数，第一个指定属性名，第二个是其新值。不过，更典型的是，我们提供一个键值对的对象，就像在
    *清单 5.1* 中所做的那样。以下语法允许我们轻松地扩展我们的示例以一次修改多个属性：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Listing 5.2
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5.2
- en: Value callbacks
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值回调
- en: The straightforward technique for passing `.attr()` a simple object is sufficient
    when we want the attribute or attributes to have the same value for each matched
    element. Often, though, the attributes we add or change must have different values
    each time. One common example is that for any given document, each `id` value
    must be unique if we want our JavaScript code to behave predictably. To set a
    unique `id` value for each link, we can harness another feature of jQuery methods
    such as `.css()` and `.each()`--**value callbacks**.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个简单对象传递给`.attr()`是一个直接的技巧，当我们希望每个匹配的元素具有相同的值时，它就足够了。然而，通常情况下，我们添加或更改的属性必须每次具有不同的值。一个常见的例子是，对于任何给定的文档，如果我们希望我们的
    JavaScript 代码表现可预测，那么每个`id`值必须是唯一的。为每个链接设置唯一的`id`值，我们可以利用 jQuery 方法的另一个特性，如`.css()`和`.each()`--**值回调**。
- en: 'A value callback is simply a function that is supplied instead of the value
    for an argument. This function is then invoked once per element in the matched
    set. Whatever data is returned from the function is used as the new value for
    the attribute. For example, we can use the following technique to generate a different
    `id` value for each element:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 值回调只是一个提供给参数的函数，而不是值。然后，对匹配集合中的每个元素调用此函数一次。从函数返回的任何数据都将用作属性的新值。例如，我们可以使用以下技术为每个元素生成不同的`id`值：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Listing 5.3
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5.3
- en: Each time our value callback is fired, it is passed an integer indicating the
    iteration count; we're using it here to give the first link an `id` value of `wikilink-0`,
    the second `wikilink-1`, and so on.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用我们的值回调时，都会传递一个整数，指示迭代计数；在这里，我们正在使用它为第一个链接赋予一个`id`值`wikilink-0`，第二个`wikilink-1`，依此类推。
- en: 'We are using the `title` attribute to invite people to learn more about the
    linked term at Wikipedia. In the HTML tags we have used so far, all of the links
    point to Wikipedia. However, to account for other types of links, we should make
    the selector expression a little more specific:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用`title`属性邀请人们在维基百科了解更多有关链接术语的信息。到目前为止，我们使用的 HTML 标签中，所有链接都指向维基百科。但是，为了考虑到其他类型的链接，我们应该使选择器表达式更具体一些：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Listing 5.4
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5.4
- en: 'To complete our tour of the `.attr()` method, we''ll enhance the `title` attribute
    of these links to be more specific about the link destination. Once again, a value
    callback is the right tool for the job:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成我们对`.attr()`方法的介绍，我们将增强这些链接的`title`属性，使其更具体地描述链接目标。再次，值回调是完成工作的正确工具：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Listing 5.5
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5.5
- en: 'This time we''ve taken advantage of the context of value callbacks. Just as
    with event handlers, the keyword `this` points to the DOM element we''re manipulating
    each time the callback is invoked. Here, we''re wrapping the element in a jQuery
    object so that we can use the `.text()` method (introduced in [Chapter 4](6544cf68-239c-4a0b-99f6-2d128dc5f7b1.xhtml),
    *Styling and Animating*) to retrieve the textual content of the link. This makes
    each link title different from the rest, as we can see in the following screenshot:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们利用了值回调的上下文。就像事件处理程序一样，关键字`this`每次调用回调时都指向我们正在操作的 DOM 元素。在这里，我们将元素包装在一个 jQuery
    对象中，以便我们可以使用`.text()`方法（在[第四章](6544cf68-239c-4a0b-99f6-2d128dc5f7b1.xhtml)中介绍的
    *Styling and Animating*）来检索链接的文本内容。这使得每个链接标题与其他链接不同，如下面的屏幕截图所示：
- en: '![](img/5297_05_01.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_05_01.png)'
- en: Data attributes
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据属性
- en: HTML5 data attributes allow us to attach arbitrary data values to page elements.
    Our jQuery code can then use these values, as well as modify them. The reason
    for using data attributes is so that we can separate DOM attributes that control
    how they're displayed and how they behave, from data that's specific to our application.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5 数据属性允许我们将任意数据值附加到页面元素。然后，我们的 jQuery 代码可以使用这些值，以及修改它们。使用数据属性的原因是我们可以将控制它们的显示和行为的
    DOM 属性与特定于我们的应用程序的数据分开。
- en: 'You''ll use the `data()` jQuery method to read data values and to change data
    values. Let''s add some new functionality that allows the user to mark a paragraph
    as read by clicking on it. We''ll also need a checkbox that hides paragraphs that
    have been marked as read. We''ll use data attributes to help us remember which
    paragraphs have been marked as read:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`data()` jQuery方法来读取数据值并更改数据值。让我们添加一些新功能，允许用户通过点击来标记段落为已读。我们还需要一个复选框，用于隐藏已标记为已读的段落。我们将使用数据属性来帮助我们记住哪些段落已标记为已读：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Listing 5.6
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.6
- en: 'When you click on a paragraph, the text is marked with a like through it to
    indicate that it has been read:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当您单击段落时，文本将被标记为已读：
- en: '![](img/Screen-Shot-2017-01-08-at-12.21.23-PM.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Screen-Shot-2017-01-08-at-12.21.23-PM.png)'
- en: As you can see, the click event handler changes the visual appearance of paragraphs
    when they're clicked on. But the handler does something else too--it toggles the
    `read` data for the element: `data('read', !$(e.target).data('read'))` . This
    lets us tie application-specific data to the element, in a way that doesn't interfere
    with other HTML attributes that we might set.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，点击事件处理程序在段落被点击时改变其视觉外观。但处理程序还做了其他事情--它切换了元素的`read`数据：`data('read', !$(e.target).data('read'))`。这让我们能够以一种不干扰我们可能设置的其他HTML属性的方式将应用程序特定的数据与元素绑定。
- en: 'The change handler for the Hide read paragraphs checkbox looks for paragraphs
    that have this data. The `filter((i, p) => $(p).data(''read''))` call will only
    return paragraphs that have a `read` data attribute with a value of `true`. We''re
    now able to filter elements based on specific application data. Here''s what the
    page looks like with read paragraphs hidden:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏已读段落复选框的更改处理程序寻找具有此数据的段落。`filter((i, p) => $(p).data('read'))`调用只会返回具有值为`true`的`read`数据属性的段落。我们现在能够根据特定的应用程序数据来过滤元素。以下是隐藏已读段落后页面的外观：
- en: '![](img/Screen-Shot-2017-01-08-at-12.33.01-PM.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Screen-Shot-2017-01-08-at-12.33.01-PM.png)'
- en: We'll revisit some advanced usage scenarios of data handling with jQuery later
    in the book.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的后期重新讨论一些使用jQuery处理数据的高级用法。
- en: DOM element properties
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DOM元素属性
- en: 'As mentioned previously, there is a subtle distinction between HTML **attributes**
    and DOM **properties**. Attributes are the values given in quotation marks in
    the HTML source for the page, while properties are the values as accessed by JavaScript.
    We can observe attributes and properties easily in a developer tool like Chrome''s:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，HTML **属性** 和DOM **属性** 之间存在微妙的区别。属性是页面HTML源代码中用引号括起来的值，而属性是JavaScript访问时的值。我们可以在Chrome等开发者工具中轻松观察属性和属性：
- en: '![](img/Screen-Shot-2017-01-08-at-5.29.42-PM.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Screen-Shot-2017-01-08-at-5.29.42-PM.png)'
- en: The Chrome Developer Tool's elements inspector shows us that the highlighted
    `<p>` element has an attribute called `class` with the value `square`. In the
    right panel, we can see that this element has a corresponding property called
    `className` with the value `square`. This illustrates one of the rare situations
    in which an attribute and its equivalent property have different names.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome开发者工具的元素检查器向我们展示了高亮显示的`<p>`元素具有名为`class`的属性，其值为`square`。在右侧面板中，我们可以看到该元素具有一个名为`className`的对应属性，其值为`square`。这说明了属性及其等效属性具有不同名称的情况之一。
- en: 'In most cases, attributes and properties are functionally interchangeable,
    and jQuery takes care of the naming inconsistencies for us. However, at times
    we do need to be mindful of the differences between the two. Some DOM properties,
    such as `nodeName`, `nodeType`, `selectedIndex`, and `childNodes`, have no equivalent
    attribute and therefore are not accessible via `.attr()`. Moreover, data types
    may differ: the `checked` attribute, for example, has a string value, while the
    `checked` property has a Boolean value. For these Boolean attributes, it is best
    to test and set the *property* rather than the *attribute* to ensure consistent
    cross-browser behavior.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，属性和属性在功能上是可以互换的，并且jQuery会为我们处理命名不一致性。然而，有时我们确实需要注意两者之间的区别。一些DOM属性，如`nodeName`，`nodeType`，`selectedIndex`和`childNodes`，没有等效的属性，因此无法通过`.attr()`访问。此外，数据类型可能不同：例如，`checked`属性具有字符串值，而`checked`属性具有布尔值。对于这些布尔属性，最好测试和设置*属性*而不是*属性*，以确保跨浏览器行为的一致性。
- en: 'We can get and set properties from jQuery using the `.prop()` method:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`.prop()`方法从jQuery获取和设置属性：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `.prop()` method has all the same features as `.attr()`, such as accepting
    an object of multiple values to set at the same time and taking value callback
    functions.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`.prop()`方法具有与`.attr()`相同的所有功能，例如接受一次设置多个值的对象和接受值回调函数。'
- en: The value of form controls
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表单控件的值
- en: Perhaps the most troublesome difference between attributes and properties arises
    when trying to get or set the value of a form control. For text inputs, the `value`
    attribute is equivalent to the `defaultValue` property, not the `value` property.
    For `select` elements, the value is usually obtained via the element's `selectedIndex`
    property or the `selected` property of its `option` elements.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试获取或设置表单控件的值时，属性和属性之间最麻烦的差异也许就是最为令人头疼的。对于文本输入，`value`属性等同于`defaultValue`属性，而不是`value`属性。对于`select`元素，通常通过元素的`selectedIndex`属性或其`option`元素的`selected`属性来获取值。
- en: 'Because of these discrepancies, we should avoid using `.attr()`--and, in the
    case of `select` elements, even `.prop()`--to get or set form element values.
    Instead, we can use the `.val()` method, which jQuery provides for these occasions:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些差异，我们应该避免使用`.attr()`——在`select`元素的情况下，甚至避免使用`.prop()`——来获取或设置表单元素的值。相反，我们可以使用jQuery为这些场合提供的`.val()`方法：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As with `.attr()` and `.prop()`, `.val()` can take a function for its setter
    argument. With its multipurpose `.val()` method, jQuery yet again makes developing
    for the web much easier.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 与`.attr()`和`.prop()`一样，`.val()`方法可以接受一个函数作为其设置器参数。借助其多功能的`.val()`方法，jQuery再次让Web开发变得更加容易。
- en: DOM tree manipulation
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DOM树操作
- en: The `.attr()` and `.prop()` methods are very powerful tools, and with them we
    can make targeted changes to the document. We still haven't seen ways to change
    the overall structure of the document though. To actually manipulate the DOM tree,
    you'll need to learn a bit more about the function that lies at the very heart
    of the `jQuery` library.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`.attr()`和`.prop()`方法是非常强大的工具，借助它们，我们可以对文档进行有针对性的更改。尽管如此，我们仍然没有看到如何更改文档的整体结构。要真正操作DOM树，你需要更多地了解位于`jQuery`库核心的函数。'
- en: The $() function revisited
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`$()`函数再探讨'
- en: From the start of this book, we've been using the `$()` function to access elements
    in a document. As we've seen, this function acts as a factory, producing new jQuery
    objects that point to the elements described by CSS selectors.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 从本书的开头，我们一直在使用`$()`函数来访问文档中的元素。正如我们所见，这个函数充当了一个工厂的角色，产生了指向由CSS选择器描述的元素的新的jQuery对象。
- en: This isn't all that the `$()` function can do. It can also change the contents
    of a page. Simply by passing a snippet of HTML code to the function, we can create
    an entirely new DOM structure.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`$()`函数的功能远不止于此。它还可以改变页面的内容。只需将一小段HTML代码传递给函数，我们就可以创建一个全新的DOM结构。'
- en: Accessibility reminder
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助功能提醒
- en: We should keep in mind, once again, the inherent danger in making certain functionality,
    visual appeal, or textual information available only to those with web browsers
    capable of (and enabled for) using JavaScript. Important information should be
    accessible to all, not just people who happen to be using the right software.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该再次牢记，将某些功能、视觉吸引力或文本信息仅提供给那些能够（并启用了）使用JavaScript的Web浏览器的人，存在固有的危险。重要信息应该对所有人可访问，而不仅仅是那些使用正确软件的人。
- en: Creating new elements
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新元素
- en: 'A feature commonly seen on FAQ pages is the back to top link that appears after
    each question-and-answer pair. It could be argued that these links serve no semantic
    purpose, and therefore they can be legitimately included via JavaScript as an
    enhancement for a subset of the visitors to a page. For our example, we''ll add
    a back to top link after each paragraph, as well as the anchor to which the back
    to top links will take us. To begin, we simply create the new elements:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 常见于FAQ页面的功能之一是在每个问题和答案对之后显示返回顶部链接。可以说这些链接没有任何语义作用，因此它们可以通过JavaScript合法地作为页面访问者子集的增强功能。在我们的示例中，我们将在每个段落后面添加一个返回顶部链接，以及返回顶部链接将指向的锚点。首先，我们简单地创建新元素：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Listing 5.7
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.7
- en: We've created a back to top link in the first line of code and a target anchor
    for the link in the second line. However, no back to top links appear on the page
    yet.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第一行代码中创建了一个返回顶部链接，在第二行创建了链接的目标锚点。然而，页面上还没有出现返回顶部的链接。
- en: '![](img/5297_05_05.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_05_05.png)'
- en: While the two lines of code that we've written do indeed create the elements,
    they don't yet add the elements to the page. We need to tell the browser where
    these new elements should go. To do that, we can use one of the many jQuery **insertion
    methods**.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们编写的两行代码确实创建了元素，但它们还没有将元素添加到页面上。我们需要告诉浏览器这些新元素应该放在哪里。为此，我们可以使用众多 jQuery **插入方法**之一。
- en: Inserting new elements
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入新元素
- en: 'The `jQuery` library has a number of methods available for inserting elements
    into the document. Each one dictates the relationship the new content will have
    to the existing content. For example, we will want our back to top links to appear
    after each paragraph, so we''ll use the appropriately named `.insertAfter()` method
    to accomplish this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`jQuery` 库有许多可用于将元素插入文档的方法。每个方法都规定了新内容与现有内容的关系。例如，我们希望我们的返回顶部链接出现在每个段落后面，因此我们将使用适当命名的
    `.insertAfter()` 方法来实现这一点：'
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Listing 5.8
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.8
- en: 'So, now that we''ve actually inserted the links into the page (and into the
    DOM) after each paragraph that appears within `<div class="chapter">`, the back
    to top links will appear:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们实际上已经将链接插入到页面中（并插入到 DOM 中），它们将出现在 `<div class="chapter">` 中的每个段落之后：
- en: '![](img/5297_05_06.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_05_06.png)'
- en: Note that the new links appear on their own line, not within the paragraph.
    This is because the `.insertAfter()` method, and its counterpart `.insertBefore()`,
    add content *outside* the specified element.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，新链接出现在自己的一行上，而不是在段落内部。这是因为 `.insertAfter()` 方法及其对应的 `.insertBefore()` 方法会在指定元素*外部*添加内容。
- en: 'Unfortunately, the links won''t work yet. We still need to insert the anchor
    with `id="top"`. This time, we''ll use one of the methods that insert elements
    *inside* of other elements:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，链接还不能使用。我们仍然需要插入带有 `id="top"` 的锚点。这一次，我们将使用一个在其他元素*内部*插入元素的方法：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Listing 5.9
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.9
- en: This additional code inserts the anchor right at the beginning of the `<body>`
    tag; in other words, at the top of the page. Now, with the `.insertAfter()` method
    for the links and the `.prependTo()` method for the anchor, we have a fully functioning
    set of back to top links for the page.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这段额外的代码将锚点插入在 `<body>` 标签的开头；换句话说，位于页面顶部。现在，使用链接的 `.insertAfter()` 方法和锚点的 `.prependTo()`
    方法，我们有了一个完全功能的返回顶部链接集合。
- en: 'Once we add the corresponding `.appendTo()` method, we now have a complete
    set of options for inserting new elements before and after other elements:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们添加了相应的 `.appendTo()` 方法，我们现在就有了一个完整的选项集，用于在其他元素之前和之后插入新元素：
- en: '`.insertBefore()`: Adds content *outside of* and *before* existing elements'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.insertBefore()`: 在现有元素之外并且在其*前面*添加内容'
- en: '`.prependTo()`: Adds content *inside of* and *before* existing elements'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.prependTo()`: 在现有元素之内并且在其*前面*添加内容'
- en: '`.appendTo()`: Adds content *inside of* and *after* existing elements'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.appendTo()`: 在现有元素之内并且在其*后面*添加内容'
- en: '`.insertAfter()`: Adds content *outside of* and *after* existing elements'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.insertAfter()`: 在现有元素之外并且在其*后面*添加内容'
- en: Moving elements
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动元素
- en: 'When adding the back to top links, we created new elements and inserted them
    on the page. It''s also possible to take elements from one place on the page and
    insert them into another place. A practical application of this type of insertion
    is the dynamic placement and formatting of footnotes. One footnote already appears
    in the original *Flatland* text that we are using for this example, but we''ll
    also designate a couple of other portions of the text as footnotes for the purpose
    of this demonstration:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加返回顶部链接时，我们创建了新的元素并将它们插入到页面中。还可以将页面上的元素从一个地方移动到另一个地方。这种插入的实际应用是动态放置和格式化脚注。一个脚注已经出现在我们用于此示例的原始
    *Flatland* 文本中，但为了演示目的，我们还将指定文本的另外几部分作为脚注：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Our HTML document contains three footnotes; the previous paragraph contains
    one example. The footnote text is inside the paragraph text, set apart using `<span
    class="footnote"></span>`. By marking up the HTML document in this way, we can
    preserve the context of the footnote. A CSS rule applied in the stylesheet italicizes
    the footnotes, so an affected paragraph initially looks like the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 HTML 文档包含三个脚注；上一个段落包含一个示例。脚注文本位于段落文本内部，使用 `<span class="footnote"></span>`
    进行分隔。通过以这种方式标记 HTML 文档，我们可以保留脚注的上下文。样式表中应用的 CSS 规则使脚注变为斜体，因此受影响的段落最初看起来像下面这样：
- en: '![](img/5297_05_07.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_05_07.png)'
- en: Now, we need to grab the footnotes and move them to the bottom of the document.
    Specifically, we'll insert them in between `<div class="chapter">` and `<div id="footer">`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要抓取脚注并将它们移动到文档底部。具体来说，我们将它们插入在`<div class="chapter">`和`<div id="footer">`之间。
- en: Keep in mind that even in cases of implicit iteration, the order in which elements
    are processed is precisely defined, starting at the top of the DOM tree and working
    down. Since it's important to maintain the correct order of the footnotes in their
    new place on the page, we should use `.insertBefore('#footer')`. This will place
    each footnote directly before the `<div id="footer">` element so that the first
    footnote is placed between `<div class="chapter">` and `<div id="footer">`, the
    second footnote is placed between the first footnote and `<div id="footer">`,
    and so on. Using `.insertAfter('div.chapter')`, on the other hand, would cause
    the footnotes to appear in reverse order.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，即使在隐式迭代的情况下，处理元素的顺序也是精确定义的，从 DOM 树的顶部开始并向下工作。由于在页面上保持脚注的正确顺序很重要，我们应该使用`.insertBefore('#footer')`。这将使每个脚注直接放在`<div
    id="footer">`元素之前，以便第一个脚注放在`<div class="chapter">`和`<div id="footer">`之间，第二个脚注放在第一个脚注和`<div
    id="footer">`之间，依此类推。另一方面，使用`.insertAfter('div.chapter')`会导致脚注以相反的顺序出现。
- en: 'So far, our code looks like the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的代码看起来像下面这样：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Listing 5.10
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10
- en: 'The footnotes are in `<span>` tags, which means they display inline by default,
    one right after the other with no separation. However, we''ve anticipated this
    in the CSS, giving `span.footnote` elements a `display` value of `block` when
    they are outside of `<div class="chapter">`. So, the footnotes are now beginning
    to take shape:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 脚注位于`<span>`标签中，默认情况下显示为内联，一个紧挨着另一个，没有分隔。但是，我们在 CSS 中已经预料到了这一点，在`span.footnote`元素处于`<div
    class="chapter">`之外时，给予了`display`值为`block`。因此，脚注现在开始成形：
- en: '![](img/5297_05_08.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_05_08.png)'
- en: 'The footnotes are in the proper position now, yet there is still a lot of work
    that can be done to them. A more robust footnote solution should do the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，脚注已经位于正确的位置，但是仍然有很多工作可以做。一个更健壮的脚注解决方案应该执行以下操作：
- en: Number each footnote.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对每个脚注编号。
- en: Mark the location in the text from which each footnote is pulled using the number
    of the footnote.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用脚注的编号标记从文本中提取每个脚注的位置。
- en: Create a link from the text location to its matching footnote, and from the
    footnote back to the location in the text from which each footnote is pulled using
    the number of the footnote.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从文本位置创建到其匹配脚注的链接，并从脚注返回到从文本中提取每个脚注的位置，使用脚注的编号。
- en: Wrapping elements
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包装元素
- en: To number the footnotes, we could explicitly add numbers in the markup, but
    here we can take advantage of the standard ordered list element that takes care
    of numbering for us. To do this, we need to create a containing `<ol>` element
    surrounding all of the footnotes and an `<li>` element surrounding each one individually.
    To achieve this, we'll use **wrapping methods**.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给脚注编号，我们可以在标记中显式添加数字，但是在这里我们可以利用标准的有序列表元素，它会为我们自动编号。为此，我们需要创建一个包含所有脚注的`<ol>`元素和一个单独包含每个脚注的`<li>`元素。为了实现这一点，我们将使用**包装方法**。
- en: 'When wrapping elements in another element, we need to be clear about whether
    we want each element wrapped in its own container or all elements wrapped in a
    single container. For our footnote numbering, we need both types of wrapper:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在将元素包装在另一个元素中时，我们需要明确我们是想让每个元素都包装在自己的容器中，还是所有元素都包装在一个单一的容器中。对于我们的脚注编号，我们需要两种类型的包装器：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Listing 5.11
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11
- en: 'Once we have inserted the footnotes before the footer, we wrap the entire set
    inside a single `<ol>` element using `.wrapAll()`. We then proceed to wrap each
    individual footnote inside its own `<li>` element using `.wrap()`. We can see
    that this has created properly numbered footnotes:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在页脚之前插入了脚注，我们就使用`.wrapAll()`将整个集合包装在一个单独的`<ol>`元素内。然后，我们继续使用`.wrap()`将每个单独的脚注包装在其自己的`<li>`元素内。我们可以看到这样创建了正确编号的脚注：
- en: '![](img/5297_05_09.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_05_09.png)'
- en: Now, we're ready to mark and number the place from which we're pulling the footnote.
    To do this in a straightforward manner, though, we need to rewrite our existing
    code so that it doesn't rely on implicit iteration.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好标记并编号我们提取脚注的位置。为了以简单直接的方式做到这一点，我们需要重写我们现有的代码，使其不依赖于隐式迭代。
- en: Explicit iteration
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显式迭代
- en: The `.each()` method, which acts as an **explicit iterator**, is very similar
    to the `forEach` array iterator that was recently added to the JavaScript language.
    The `.each()` method can be employed when the code we want to use on each of the
    matched elements is too complex for the implicit iteration syntax. It is passed
    a callback function that will be called once for each element in the matched set.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`.each()`方法充当**显式迭代器**，与最近添加到 JavaScript 语言中的`forEach`数组迭代器非常相似。当我们想要对匹配的每个元素使用的代码过于复杂时，可以使用`.each()`方法。它接受一个回调函数，该函数将对匹配集合中的每个元素调用一次。'
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Listing 5.12
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单 5.12**'
- en: The motivation for our change here will become clear shortly. First, we need
    to understand the information that's provided to our `.each()` callback.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里的更改动机很快就会变得清晰。首先，我们需要了解传递给我们的`.each()`回调的信息。
- en: In *Listing 5.12*, we use the `span` parameter to create a jQuery object pointing
    to a single footnote, `<span>`, then we append the element to the notes `<ol>`,
    and finally wrap the footnote inside an `<li>` element.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在*清单 5.12*中，我们使用`span`参数创建一个指向单个脚注`<span>`的 jQuery 对象，然后将该元素追加到脚注 `<ol>` 中，最后将脚注包装在一个
    `<li>` 元素中。
- en: 'To mark the locations in the text from which the footnotes were pulled, we
    can take advantage of the `.each()` callback''s parameter. This parameter provides
    the iteration count, starting at `0` and incrementing each time the callback is
    invoked. Therefore, this counter will always be 1 less than number of the footnote.
    We''ll account for this fact when producing the appropriate labels in the text:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了标记从中提取脚注的文本位置，我们可以利用`.each()`回调的参数。该参数提供了迭代计数，从`0`开始，并在每次调用回调时递增。因此，该计数器始终比脚注的数量少
    1。在生成文本中的适当标签时，我们将考虑到这一事实：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Listing 5.13
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单 5.13**'
- en: Now, before each footnote is pulled out of the text to be placed at the bottom
    of the page, we create a new `<sup>` element containing the footnote's number
    and insert it into the text. The order of actions is important here; we need to
    make sure that the marker is inserted before the footnote is moved, or else we
    lose track of its initial position.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在每个脚注被从文本中取出并放置在页面底部之前，我们创建一个包含脚注编号的新 `<sup>` 元素，并将其插入到文本中。这里的操作顺序很重要；我们需要确保标记被插入到移动脚注之前，否则我们将丢失其初始位置的追踪。
- en: 'Looking at our page again, now we can see footnote markers where the inline
    footnotes used to be:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 再次查看我们的页面，现在我们可以看到脚注标记出现在原来的内联脚注位置上：
- en: '![](img/5297_05_10.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_05_10.png)'
- en: Using inverted insertion methods
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用反向插入方法
- en: In *Listing 5.13*, we inserted content before an element, then appended that
    same element to another place in the document. Typically, when working with elements
    in jQuery, we can use chaining to perform multiple actions succinctly and efficiently.
    We weren't able to do that here, though, because `this` is the *target* of `.insertBefore()`
    and the *subject* of `.appendTo()`. The **inverted insertion methods** will help
    us get around this limitation.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在*清单 5.13*中，我们在一个元素之前插入内容，然后将该元素追加到文档的另一个位置。通常，在 jQuery 中处理元素时，我们可以使用链式操作来简洁高效地执行多个操作。但是在这里，我们无法做到这一点，因为`this`是`.insertBefore()`的*目标*，同时也是`.appendTo()`的*主语*。**反向插入方法**将帮助我们克服这个限制。
- en: 'Each of the insertion methods, such as `.insertBefore()` or `.appendTo()`,
    has a corresponding inverted method. The inverted methods perform exactly the
    same task as the standard ones, but the subject and target are reversed. For example:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 每个插入方法，如`.insertBefore()`或`.appendTo()`，都有一个对应的反向方法。反向方法执行的任务与标准方法完全相同，但主语和目标被颠倒了。例如：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'is the same as:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 与下面相同：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Using `.before()`, the inverted form of `.insertBefore()`, we can now re-factor
    our code to exploit chaining:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`.before()`，即`.insertBefore()`的反向形式，现在我们可以重构我们的代码以利用链式操作：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Listing 5.14
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单 5.14**'
- en: Insertion method callbacks
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 插入方法回调
- en: The inverted insertion methods can accept a function as an argument, much like
    `.attr()` and `.css()` can. This function is invoked once per target element,
    and should return the HTML string to be inserted. We could use this technique
    here, but since we will encounter several such situations for each footnote, the
    single `.each()` call will end up being the cleaner solution.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 反向插入方法可以接受一个函数作为参数，就像`.attr()`和`.css()`一样。这个函数会针对每个目标元素调用一次，并且应返回要插入的 HTML 字符串。我们可以在这里使用这种技术，但由于我们将遇到每个脚注的几种这样的情况，因此单个的`.each()`调用最终将成为更清晰的解决方案。
- en: 'We''re now ready to take care of the final step in our checklist: create a
    link from the text location to its matching footnote, and from the footnote back
    to the text location. We''ll need four pieces of markup per footnote to achieve
    this: two links, one in the text and one after the footnote, and two `id` attributes
    in those same locations. Because the argument to the `.before()` method is about
    to get complex, this is a good time to introduce a new notation for string creation.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备处理我们清单中的最后一步：为文本位置创建到相应脚注的链接，以及从脚注返回到文本位置。为了实现这一点，我们需要每个脚注四个标记：在文本中和脚注之后各一个链接，以及在相同位置的两个`id`属性。因为`.before()`方法的参数即将变得复杂，这是一个引入新的字符串创建的好时机。
- en: 'In *Listing 5.14,* we prepare our footnote marker using a **template string**.
    This is a very useful technique, but for joining a large number of strings it
    can start to look cluttered. Instead, we can use the array method `.join()` to
    construct the larger string. The following statements have the same effect:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在*清单 5.14* 中，我们使用**模板字符串**准备了我们的脚注标记。这是一种非常有用的技术，但是当连接大量字符串时，它可能开始显得混乱。相反，我们可以使用数组方法`.join()`来构建更大的字符串。以下语句具有相同的效果：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'While it requires a few more characters to type in this example, the `.join()`
    method can add clarity when otherwise difficult to read string concatenation or
    string templates. Let''s look at our code again, this time using `.join()` to
    create the string:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在这个例子中需要输入更多的字符，但`.join()`方法可以在原本难以阅读的字符串连接或字符串模板时提供清晰度。让我们再次看一下我们的代码，这次使用`.join()`来创建字符串：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Listing 5.15
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 项目清单 5.15
- en: 'Using this technique, we can augment the footnote marker with a link to the
    bottom of the page as well as a unique `id` value. While we''re at it, we''ll
    also add an `id` for the `<li>` element, so the link has a destination to point
    at, as shown in the following code snippet:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种技术，我们可以为脚注标记增加一个到页面底部的链接，以及一个唯一的`id`值。一边做这些，我们还将为`<li>`元素添加一个`id`，这样链接就有了一个目标，如下面的代码片段所示：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Listing 5.16
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 项目清单 5.16
- en: 'With the additional markup in place, each footnote marker now links down to
    the corresponding footnote at the bottom of the document. All that remains is
    to create a link back from the footnote to its context. For this, we can employ
    the inverse of the `.appendTo()` method, `.append()`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '在额外的标记放置后，每个脚注标记现在都链接到文档底部的对应脚注。 现在唯一剩下的就是创建一个从脚注返回到其上下文的链接。为此，我们可以使用`.appendTo()`方法的反向，即`.append()`:'
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Listing 5.17
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 项目清单 5.17
- en: 'Note that the `href` tag points back to the `id` value of the corresponding
    marker. In the following screenshot, you can see the footnotes again, except this
    time with the new link appended to each:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`href`标签指向了对应标记的`id`值。在下面的屏幕截图中，您可以再次看到脚注，不同的是这次每个脚注后都附加了新链接：
- en: '![](img/5297_05_11.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5297_05_11.png)'
- en: Copying elements
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制元素
- en: So far in this chapter, we have inserted newly created elements, moved elements
    from one location in the document to another, and wrapped new elements around
    existing ones. Sometimes, though, we may want to copy elements. For example, a
    navigation menu that appears in the page's header could be copied and placed in
    the footer as well. Whenever elements can be copied to enhance a page visually,
    we can let jQuery do the heavy lifting.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们已经插入了新创建的元素，将元素从文档中的一个位置移动到另一个位置，并将新元素包裹在现有元素周围。但是，有时，我们可能想要复制元素。例如，出现在页面页眉中的导航菜单也可以复制并放置在页脚中。每当元素可以被复制以增强页面的视觉效果时，我们可以让
    jQuery 承担繁重的工作。
- en: For copying elements, jQuery's `.clone()` method is just what we need; it takes
    any set of matched elements and creates a copy of them for later use. As in the
    case of the `$()` function's element creation process we explored earlier in this
    chapter, the copied elements will not appear in the document until we apply one
    of the insertion methods.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对于复制元素，jQuery的`.clone()`方法正是我们需要的；它接受任何匹配元素集并为以后使用创建它们的副本。就像我们前面在本章中探讨过的`$()`函数的元素创建过程一样，复制的元素在应用插入方法之前不会出现在文档中。
- en: 'For example, the following line creates a copy of the first paragraph inside
    `<div class="chapter">`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下面的行创建了`<div class="chapter">`中第一个段落的副本：
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This alone is not enough to change the content of the page. We can make the
    cloned paragraph appear before `<div class="chapter">` with an insertion method:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 光靠这些还不足以改变页面的内容。我们可以使克隆的段落出现在`<div class="chapter">`之前用插入方法：
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This will cause the first paragraph to appear twice. So, to use a familiar analogy,
    `.clone()` is related to the insertion methods just as *copy* is to *paste*.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致第一个段落出现两次。因此，使用一个熟悉的类比，`.clone()` 与插入方法的关系就像 *复制* 与 *粘贴* 一样。
- en: Clone with events
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 带事件的克隆
- en: The `.clone()` method, by default, does not copy any events that are bound to
    the matching element or any of its descendants. However, it can take a single
    Boolean parameter that, when set to true (`.clone(true)`), clones events as well.
    This convenient event cloning allows us to avoid having to deal with manually
    rebinding events, as was discussed in [Chapter 3](2036c6b0-e8c5-405a-b54b-b3f31eab404c.xhtml),
    *Handling Events*.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`.clone()` 方法不会复制绑定到匹配元素或其任何后代的任何事件。然而，它可以接受一个布尔参数（当设置为 true（`.clone(true)`）时），也会克隆事件。这种方便的事件克隆使我们避免了手动重新绑定事件，正如
    [第 3 章](2036c6b0-e8c5-405a-b54b-b3f31eab404c.xhtml) 中讨论的那样，*处理事件*。
- en: Cloning for pull quotes
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于引文的克隆
- en: 'Many websites, like their print counterparts, use **pull quotes** to emphasize
    small portions of text and attract the reader''s eye. A pull quote is simply an
    excerpt from the main document that is presented with a special graphical treatment
    alongside the text. We can easily accomplish this embellishment with the `.clone()`
    method. First, let''s take another look at the third paragraph of our example
    text:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 许多网站，就像它们的印刷对应物一样，使用 **引文** 来强调文本的小部分并吸引读者的注意。引文简单地是主文档的摘录，它以特殊的图形处理与文本一起呈现。我们可以通过
    `.clone()` 方法轻松实现这种修饰。首先，让我们再次看一下示例文本的第三段：
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that the paragraph begins with `<span class="pull-quote">`. This is the
    class we will be targeting for cloning. Once the copied text inside that `<span>`
    tag is pasted into another place, we need to modify its style properties to set
    it apart from the rest of the text.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 注意段落以 `<span class="pull-quote">` 开始。这是我们将要复制的类。一旦在另一个位置粘贴了该 `<span>` 标签中的复制文本，我们就需要修改其样式属性以使其与其余文本区分开。
- en: 'To accomplish this type of styling, we''ll add a `pulled` class to the copied
    `<span>`. In our stylesheet, that class receives the following style rule:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这种类型的样式，我们将在复制的 `<span>` 中添加一个 `pulled` 类。在我们的样式表中，该类接收以下样式规则：
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: An element with this class is visually differentiated from the main content
    by applying style rules for background, border, font, and so on. Most importantly,
    it's absolutely positioned, 20 pixels above and 20 pixels to the right of the
    nearest (`absolute` or `relative`) positioned ancestor in the DOM. If no ancestor
    has positioning (other than `static`) applied, the pull quote will be positioned
    relative to the document `<body>`. Because of this, we need to make sure in the
    jQuery code that the cloned pull quote's parent element has `position:relative`
    set.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 具有此类的元素通过应用背景、边框、字体等样式规则在视觉上与主内容区分开来。最重要的是，它是绝对定位的，距离 DOM 中最近的（`absolute` 或
    `relative`）定位的祖先元素的顶部 20 像素，并且向右偏移 20 像素。如果没有祖先元素应用了定位（除了 `static` 之外），引用的引用将相对于文档
    `<body>` 定位。因此，在 jQuery 代码中，我们需要确保克隆的引文的父元素设置了 `position:relative`。
- en: CSS position calculation
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 定位计算
- en: While the top positioning is fairly intuitive, it may not be clear at first
    how the pull quote box will be located 20 pixels to the right of its positioned
    parent. We derive the number first from the total width of the pull-quote box,
    which is the value of the `width` property plus the left and right padding, or
    `145px + 5px + 10px = 160px`. We then set the `right` property of the pull quote.
    A value of `0` would align the pull quote's right side with that of its parent.
    Therefore, to place its left side 20 pixels to the right of the parent, we need
    to move it in a negative direction 20 pixels more than its total width, or `-180px`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管顶部定位相当直观，但可能一开始不清楚引文框将如何定位到其定位父级的右侧 20 像素。我们首先从引文框的总宽度推导数字，这是 `width` 属性的值加上左右填充的值，或
    `145px + 5px + 10px = 160px`。然后，我们设置引文的 `right` 属性。一个值为 `0` 将使引文的右侧与其父元素的右侧对齐。因此，为了将其左侧定位到父元素的右侧
    20 像素处，我们需要将其向负方向移动超过其总宽度的 20 像素，即 `-180px`。
- en: 'Now, we can consider the jQuery code needed to apply this style. We''ll start
    with a selector expression to find all of the `<span class="pull-quote">` elements
    and apply the `position: relative` style to each parent element as we just discussed:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，我们可以考虑应用此样式所需的 jQuery 代码。我们将从选择器表达式开始，找到所有 `<span class="pull-quote">` 元素，并像我们刚讨论的那样为每个父元素应用
    `position: relative` 样式：'
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Listing 5.18
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.18
- en: 'Next, we need to create the pull quote itself, taking advantage of the CSS
    we''ve prepared. We need to clone each `<span>` tag, add the `pulled` class to
    the copy, and insert it into the beginning of its parent paragraph:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建引用本身，利用我们准备好的 CSS。我们需要克隆每个 `<span>` 标签，将 `pulled` 类添加到副本，并将其插入到其父段落的开头：
- en: '[PRE29]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Listing 5.19
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.19
- en: Because we're using absolute positioning for the pull quote, the placement of
    it within the paragraph is irrelevant. As long as it remains inside the paragraph,
    it will be positioned in relation to the top and the right of the paragraph, based
    on our CSS rules.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在引用处使用了绝对定位，所以它在段落中的位置是无关紧要的。只要它保持在段落内部，根据我们的 CSS 规则，它将相对于段落的顶部和右侧定位。
- en: 'The pull quote now appears alongside its originating paragraph, as intended:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 引用现在出现在其原始段落旁边，正如预期的那样：
- en: '![](img/5297_05_12.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_05_12.png)'
- en: This is a good start. For our next enhancement, we'll clean up the content of
    the pull quotes a bit.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个不错的开始。对于我们的下一个改进，我们将稍微清理引用内容。
- en: Content getter and setter methods
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内容获取器和设置器方法
- en: It would be nice to be able to modify the pull quote a bit by dropping some
    words and replacing them with ellipses to keep the content brief. To demonstrate
    this, we have wrapped a few words of the example text in a `<span class="drop">`
    tag.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 修改引用并使用省略号来保持内容简洁将是很好的。为了演示这一点，我们在示例文本中的几个单词中包裹了一个 `<span class="drop">` 标签。
- en: 'The easiest way to accomplish this replacement is to directly specify the new
    HTML entity that is to replace the old one. The `.html()` method is perfect for
    this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此替换的最简单方法是直接指定要替换旧实体的新 HTML 实体。`.html()` 方法非常适合这个目的：
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Listing 5.20
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.20
- en: The new lines in *Listing 5.20* rely on the DOM traversal techniques we learned
    in [Chapter 2](195342ed-f533-42e7-8a8d-f9a3462382b7.xhtml), *Selecting Elements*.
    We use `.find()` to search inside the pull quote for any `<span class="drop">`
    elements, operate on them, and then return to the pull quote itself by calling
    `.end()`. In between these methods, we invoke `.html()` to change the content
    into an ellipsis (using the appropriate HTML entity).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5.20* 中的新行依赖于我们在[第 2 章](https://example.org/chapter_2)中学到的 DOM 遍历技巧，*选择元素*。我们使用
    `.find()` 在引用中搜索任何 `<span class="drop">` 元素，对它们进行操作，然后通过调用 `.end()` 返回到引用本身。在这些方法之间，我们调用
    `.html()` 将内容更改为省略号（使用适当的 HTML 实体）。'
- en: When called without arguments, `.html()` returns a string representation of
    the HTML entity inside the matched element. With an argument, the contents of
    the element are replaced by the supplied HTML entity. We must take care to only
    specify a valid HTML entity, escaping special characters properly when using this
    technique.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有参数的情况下调用 `.html()` 会返回匹配元素内的 HTML 实体的字符串表示。有了参数，元素的内容将被提供的 HTML 实体替换。当使用此技术时，我们必须小心只指定一个有效的
    HTML 实体，并正确地转义特殊字符。
- en: 'The specified words have now been replaced by an ellipsis:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 指定的单词现已被省略号替换：
- en: '![](img/5297_05_13.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_05_13.png)'
- en: Pull quotes typically do not retain their original font formatting, such as
    the boldfaced one more side text in this example. What we really want to display
    is the text of `<span class="pull-quote">` stripped of any `<strong>`, `<em>`,
    `<a href>`, or other inline tags. To replace all of the pull-quote HTML entities
    with a stripped, text-only version, we can employ the`.html()` method's companion
    method, `.text()`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 引用通常不保留其原始字体格式，比如这个示例中的粗体文本。我们真正想显示的是 `<span class="pull-quote">` 的文本，不包含任何
    `<strong>`、`<em>`、`<a href>` 或其他内联标签。为了将所有引用的 HTML 实体替换为剥离后的仅文本版本，我们可以使用 `.html()`
    方法的伴随方法 `.text()`。
- en: 'Like `.html()`, the `.text()` method can either retrieve the content of the
    matched element or replace its content with a new string. Unlike `.html()`, however,
    `.text()` always gets or sets a plain text string. When `.text()` retrieves content,
    all of the included tags are ignored, and HTML entities are translated into plain
    characters. When it sets content, special characters such as `<` are translated
    into their HTML entity equivalents:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 像 `.html()` 一样，`.text()` 方法可以检索匹配元素的内容或用新字符串替换其内容。但与 `.html()` 不同的是，`.text()`
    总是获取或设置纯文本字符串。当 `.text()` 检索内容时，所有包含的标签都将被忽略，HTML 实体将被转换为普通字符。当它设置内容时，特殊字符如 `<`
    将被转换为它们的 HTML 实体等价物：
- en: '[PRE31]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Listing 5.21
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.21
- en: When you retrieve values using `text()`, the markup is removed. This is exactly
    what we're trying to accomplish with this example. As with some of the other jQuery
    functions that you've learned about so far, `text()` accepts a function. The return
    value is used to set the text of the element, while the current text is passed
    in as the second argument. So to strip tags from element text, just call `text((i,
    text) => text)`. Awesome!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`text()`检索值时，会去除标记。这正是我们尝试实现的内容。与你目前学习的其他一些jQuery函数一样，`text()`接受一个函数。返回值用于设置元素的文本，而当前文本则作为第二个参数传入。因此，要从元素文本中删除标记，只需调用`text((i,
    text) => text)`。太棒了！
- en: 'Here''s the results of this approach:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这种方法的结果：
- en: '![](img/5297_05_14.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_05_14.png)'
- en: DOM manipulation methods in a nutshell
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DOM操作方法简介
- en: 'The extensive DOM manipulation methods that jQuery provides vary according
    to their task and their target location. We haven''t covered them all here, but
    most are analogous to the ones we''ve seen, and more will be discussed in [Chapter
    12](0446c068-e7fd-426a-ab8b-0157b1387e1f.xhtml), *Advanced DOM Manipulation*.
    The following outline can serve as a reminder of which method we can use to accomplish
    which task:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery提供的大量DOM操作方法根据任务和目标位置而异。我们在这里没有涵盖所有内容，但大多数都类似于我们已经见过的方法，更多内容将在[第12章](0446c068-e7fd-426a-ab8b-0157b1387e1f.xhtml)，*高级DOM操作*中讨论。以下概要可作为我们可以使用哪种方法来完成哪种任务的提醒：
- en: To *create* new elements from HTML, use the `$()` function
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 若要*从HTML中创建*新元素，请使用`$()`函数
- en: 'To *insert* new elements *inside* every matched element, use the following
    functions:'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 若要*在*每个匹配元素*内部*插入新元素，请使用以下函数：
- en: '`.append()`'
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.append()`'
- en: '`.appendTo()`'
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.appendTo()`'
- en: '`.prepend()`'
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.prepend()`'
- en: '`.prependTo()`'
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.prependTo()`'
- en: 'To *insert* new elements *adjacent to* every matched element, use the following
    functions:'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 若要*在*每个匹配元素*旁边*插入新元素，请使用以下函数：
- en: '`.after()`'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.after()`'
- en: '`.insertAfter()`'
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.insertAfter()`'
- en: '`.before()`'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.before()`'
- en: '`.insertBefore()`'
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.insertBefore()`'
- en: 'To *insert* new elements *around* every matched element, use the following
    functions:'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 若要*在*每个匹配元素*周围*插入新元素，请使用以下函数：
- en: '`.wrap()`'
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.wrap()`'
- en: '`.wrapAll()`'
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.wrapAll()`'
- en: '`.wrapInner()`'
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.wrapInner()`'
- en: 'To *replace* every matched element with new elements or text, use the following
    functions:'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 若要*用新元素或文本替换*每个匹配元素，请使用以下函数：
- en: '`.html()`'
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.html()`'
- en: '`.text()`'
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.text()`'
- en: '`.replaceAll()`'
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.replaceAll()`'
- en: '`.replaceWith()`'
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.replaceWith()`'
- en: 'To *remove* elements inside every matched element, use the following function:'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 若要*在每个匹配元素内部删除*元素，请使用以下函数：
- en: '`.empty()`'
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.empty()`'
- en: 'To *remove* every matched element and descendants from the document without
    actually deleting them, use the following functions:'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 若要*删除*文档中*每个匹配元素及其后代*，而实际上不删除它们，请使用以下函数：
- en: '`.remove()`'
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.remove()`'
- en: '`.detach()`'
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.detach()`'
- en: Summary
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have created, copied, reassembled, and embellished content
    using jQuery's DOM modification methods. We've applied these methods to a single
    web page, transforming a handful of generic paragraphs to a footnoted, pull-quoted,
    linked, and stylized literary excerpt. This chapter has shown us just how easy
    it is to add, remove, and rearrange the contents of a page with jQuery. In addition,
    you have learned how to make any changes we want to the CSS and DOM properties
    of page elements.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用jQuery的DOM修改方法创建、复制、重新组装和美化内容。我们将这些方法应用于单个网页，将一些通用段落转换为带有脚注、拉引用、链接和样式化的文学摘录。这一章向我们展示了使用jQuery添加、删除和重新排列页面内容是多么容易。此外，你已经学会了如何对页面元素的CSS和DOM属性进行任何想要的更改。
- en: Next up, we'll take a round-trip journey to the server via jQuery's Ajax methods.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过jQuery的Ajax方法进行一次往返旅程到服务器。
- en: Further reading
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: The topic of DOM manipulation will be explored in more detail in [Chapter 12](0446c068-e7fd-426a-ab8b-0157b1387e1f.xhtml),
    *Advanced DOM Manipulation*. A complete list of DOM manipulation methods is available
    in [Appendix B](d9485d2d-4300-48c1-825b-1c26c9b57a66.xhtml)*, Quick Reference*, of
    this book, or in the official jQuery documentation at [http://api.jquery.com/](http://api.jquery.com/).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: DOM操作的主题将在[第12章](0446c068-e7fd-426a-ab8b-0157b1387e1f.xhtml)，*高级DOM操作*中进行更详细的探讨。DOM操作方法的完整列表可在本书的[附录B](d9485d2d-4300-48c1-825b-1c26c9b57a66.xhtml)*，快速参考*，或在官方jQuery文档[http://api.jquery.com/](http://api.jquery.com/)中找到。
- en: Exercises
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: The challenge exercises may require the use of the official jQuery documentation
    at `http://api.jquery.com/`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战练习可能需要使用官方jQuery文档`http://api.jquery.com/`。
- en: Alter the code that introduces the back to top links, so that the links only
    appear after the fourth paragraph.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 改变引入回到顶部链接的代码，使得链接只在第四段后出现。
- en: When a back to top link is clicked on, add a new paragraph after the link containing
    the message You were here. Ensure that the link still works.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当点击回到顶部链接时，在链接后添加一个新段落，其中包含消息“你已经在这里了”。确保链接仍然可用。
- en: When the author's name is clicked, turn it bold (by adding an element, rather
    than manipulating classes or CSS attributes).
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当点击作者的名字时，将其加粗（通过添加元素，而不是操作类或 CSS 属性）。
- en: 'Challenge: On a subsequent click of the bolded author''s name, remove the `<b>`
    element that was added (thereby toggling between bold and normal text).'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 挑战：在对加粗的作者名字进行后续点击时，移除已添加的`<b>`元素（从而在加粗和正常文本之间切换）。
- en: 'Challenge: Add a class of `inhabitants` to each of the chapter''s paragraphs
    without calling `.addClass()`. Make sure to preserve any existing classes.'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 挑战：对每个章节段落添加一个`inhabitants`类，而不调用`.addClass()`。确保保留任何现有的类。
