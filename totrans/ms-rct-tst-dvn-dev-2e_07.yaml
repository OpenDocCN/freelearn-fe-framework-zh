- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Testing useEffect and Mocking Components
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 useEffect 和模拟组件
- en: In the previous chapter, you saw how test doubles can be used to verify network
    requests that occur upon user actions, such as clicking a submit button. We can
    also use them to verify side effects when our components mount, like when we're
    fetching data from the server that the component needs to function. In addition,
    test doubles can be used to verify the rendering of child components. Both use
    cases often occur together with **container components**, which are responsible
    for simply loading data and passing it to another component for display.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你看到了如何使用测试替身来验证用户操作（如点击提交按钮）时发生的网络请求。我们还可以使用它们来验证组件挂载时的副作用，例如当我们从服务器获取组件需要的数据时。此外，测试替身可以用来验证子组件的渲染。这两种用例通常与
    **容器组件** 一起发生，容器组件负责简单地加载数据并将其传递给另一个组件进行显示。
- en: In this chapter, we’ll build a new component, `AppointmentsDayViewLoader`, that
    loads the day’s appointments from the server and passes them to the `AppointmentsDayView`
    component that we implemented in [*Chapter 2*](B18423_02.xhtml#_idTextAnchor038),
    *Rendering Lists and Detail Views*. By doing so, the user can view a list of appointments
    occurring today.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个新的组件，`AppointmentsDayViewLoader`，它从服务器加载当天的预约并将其传递给我们在 [*第2章*](B18423_02.xhtml#_idTextAnchor038)
    中实现的 `AppointmentsDayView` 组件，*渲染列表和详情视图*。通过这样做，用户可以查看今天发生的预约列表。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Mocking child components
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟子组件
- en: Fetching data on mount with `useEffect`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `useEffect` 在挂载时获取数据
- en: Variants of the `jest.mock` call
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jest.mock` 调用的变体'
- en: These are likely the most difficult tasks you’ll encounter while test-driving
    React components.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可能是你在测试驱动 React 组件时遇到的最困难的任务。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code files for this chapter can be found here: [https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter07](https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter07)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在以下位置找到：[https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter07](https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter07)
- en: Mocking child components
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟子组件
- en: In this section, we’re going to use the `jest.mock` test helper to replace the
    child component with a dummy implementation. Then, we’ll write expectations that
    check whether we passed the right props to the child component and that it is
    correctly rendered on the screen.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 `jest.mock` 测试辅助函数来用模拟实现替换子组件。然后，我们将编写期望来检查我们是否向子组件传递了正确的属性，并且它是否正确地渲染在屏幕上。
- en: But first, let’s take a detailed look at how mocked components work.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，让我们详细了解一下模拟组件是如何工作的。
- en: How to mock components, and why?
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何模拟组件，以及为什么？
- en: 'The component we’re going to build in this chapter has the following shape:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将构建的组件具有以下形状：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Its purpose is to display all the current appointments for a given day. This
    information is then passed into the component as the `today` prop. The component’s
    job is to fetch data from the server and then pass it to the `AppointmentsDayView`
    component, which we built previously and already tested.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 其目的是显示给定日期的所有当前预约。然后，这些信息作为 `today` 属性传递给组件。组件的职责是从服务器获取数据，然后将其传递给之前构建并已测试过的
    `AppointmentsDayView` 组件。
- en: Think about the tests we may need. First, we’d want a test to prove that `AppointmentsDayView`
    loads with no appointments shown initially. Then, we’d want some tests that verify
    our `global.fetch` call is called successfully, and the returned data is passed
    into `AppointmentsDayView`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们可能需要的测试。首先，我们想要一个测试来证明 `AppointmentsDayView` 在没有显示任何预约的情况下加载。然后，我们想要一些测试来验证我们的
    `global.fetch` 调用是否成功调用，并且返回的数据被传递到 `AppointmentsDayView`。
- en: How do we test that `AppointmentsDayView` is called with the right data? We
    could repeat some of the tests we have already written in the test suite for `AppointmentsDayView`
    – for example, by testing that a list of appointments is displayed, and that the
    relevant appointment data is shown.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何测试 `AppointmentsDayView` 是否以正确数据调用？我们可以在 `AppointmentsDayView` 的测试套件中重复一些已经编写的测试
    – 例如，通过测试是否显示了一个预约列表，以及显示的相关预约数据。
- en: However, we’d then be introducing repetition into our test suites. If we modify
    how `AppointmentsDayView` works, we’ll have two places to update tests.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这样我们就会在我们的测试套件中引入重复。如果我们修改`AppointmentsDayView`的工作方式，我们将有两个地方需要更新测试。
- en: 'An alternative is to mock the component with a spy object. For this, we can
    use the `jest.mock` function, in tandem with a spy. This is how it will look:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是使用间谍对象模拟组件。为此，我们可以使用`jest.mock`函数，与间谍一起使用。这将是这样看起来：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The first argument to the function is the file path that is being mocked. It
    must match the path that’s passed to the `import` statement. This function is
    mocking the entire module:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的第一个参数是要模拟的文件路径。它必须与传递给`import`语句的路径匹配。这个函数正在模拟整个模块：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code, Jest hoists this call to the top of the file and hooks
    into import logic so that when the `import` statement is run, your mock is returned
    instead.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，Jest将这个调用提升到文件顶部，并挂钩到导入逻辑，以便当`import`语句运行时，你的模拟会被返回。
- en: Any time `AppointmentsDayView` is referenced in either the test suite or the
    component under test, you’ll get this mock value rather than the real component.
    Instead of rendering our day view, we’ll get a single `div` with an `id` value
    of `AppointmentsDayView`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时在测试套件或被测试的组件中引用`AppointmentsDayView`，你都会得到这个模拟值而不是真实的组件。而不是渲染我们的日视图，我们会得到一个具有`AppointmentsDayView`的`id`值的单个`div`。
- en: The second parameter is the `AppointmentsDayView`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是`AppointmentsDayView`。
- en: 'Because the mock definition is hoisted to the top of the file, you can’t reference
    any variables in this function: they won’t have been defined by the time your
    function is run. However, you can write JSX, as we have done here!'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因为模拟定义被提升到文件顶部，所以你无法在这个函数中引用任何变量：它们在你运行函数之前还没有被定义。然而，你可以编写JSX，就像我们在这里所做的那样！
- en: The complexity of component mock setup
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 组件模拟设置的复杂性
- en: This code is super cryptic, I know. Thankfully, you generally just need to write
    it once. I often find myself copy-pasting mocks when I need to introduce a new
    one into a test suite. I’ll look up a previous one I wrote in some other test
    suite and copy it across, changing the relevant details.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码非常晦涩难懂，我知道。幸运的是，你通常只需要写一次。当我需要在一个测试套件中引入一个新的模拟时，我经常发现自己是在复制粘贴模拟。我会查找我在其他测试套件中写的上一个模拟，并将其复制过来，更改相关细节。
- en: 'So, now comes the big question: why would you want to do this?'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在有一个大问题：你为什么要这样做？
- en: Firstly, using mocks can improve test organization by encouraging multiple test
    suites with independent surface areas. If both a parent component and its child
    component are non-trivial components, then having two separate test suites for
    those components can help reduce the complexity of your test suites.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用模拟可以通过鼓励具有独立表面的多个测试套件来改进测试组织。如果父组件和其子组件都是非平凡组件，那么为这些组件提供两个单独的测试套件可以帮助减少测试套件的复杂性。
- en: The parent component’s test suite will contain just a handful of tests to prove
    that the child component was rendered and passed the expected prop value.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 父组件的测试套件将只包含少量测试，以证明子组件已被渲染并传递了预期的属性值。
- en: By mocking out the child component in the parent component’s test suite, you
    are effectively saying, “*I want to ignore this child component right now, but
    I promise I’ll test its functionality elsewhere!*”
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在父组件的测试套件中模拟子组件，你实际上是在说，“*我现在想忽略这个子组件，但我保证我会在其他地方测试其功能!*”
- en: 'A further reason is that you may already have tests for the child component.
    This is the scenario we find ourselves in: we already have tests for `AppointmentsDayView`,
    so unless we want to repeat ourselves, it makes sense to mock out the component
    wherever it’s used.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个原因是，你可能已经对子组件进行了测试。这就是我们发现自己所处的场景：我们已经有`AppointmentsDayView`的测试，所以除非我们想要重复，否则在它被使用的地方模拟组件是有意义的。
- en: An extension of this reason is the use of library components. Because someone
    else built them, you have reason to trust that they’ve been tested and do the
    right thing. And since they’re library components, chances are they do something
    quite complex anyway, so rendering them within your tests may have unintended
    side effects.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原因的扩展是使用库组件。因为它们是由别人构建的，所以你有理由相信它们已经过测试并且能正确工作。而且由于它们是库组件，它们可能已经执行了一些相当复杂的操作，所以在你的测试中渲染它们可能会产生意外的副作用。
- en: Perhaps you have a library component that builds all sorts of elaborate HTML
    widgets and you don’t want your test code to know that. Instead, you can treat
    it as a **black box**. In that scenario, it’s preferable to verify the prop values
    that are passed to the component, again trusting that the component works as advertised.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 可能你有一个库组件，它可以构建各种复杂的HTML小部件，而你不想让测试代码知道这一点。相反，你可以将其视为**黑盒**。在这种情况下，最好是验证传递给组件的属性值，再次相信该组件按预期工作。
- en: Library components often have complex component APIs that allow the component
    to be configured in many ways. Mocking the component allows you to write contract
    tests that ensure you’re setting up props correctly. We’ll see this later in [*Chapter
    11*](B18423_11.xhtml#_idTextAnchor207), *Test-Driving React Router*, when we mock
    out React Router’s `Link` component.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 库组件通常具有复杂的组件API，允许以多种方式配置组件。模拟组件允许你编写合同测试，确保你正确设置了属性。我们将在[*第11章*](B18423_11.xhtml#_idTextAnchor207)
    *测试驱动React Router*中看到这一点，当我们模拟React Router的`Link`组件时。
- en: The final reason to mock components is if they have side effects on mount, such
    as performing network requests to pull in data. By mocking out the component,
    your test suite does not need to account for those side effects. We’ll do this
    in [*Chapter 8*](B18423_08.xhtml#_idTextAnchor147), *Building an Application Component*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟组件的最后一个原因是它们在挂载时可能有副作用，例如执行网络请求以拉取数据。通过模拟组件，你的测试套件不需要考虑这些副作用。我们将在[*第8章*](B18423_08.xhtml#_idTextAnchor147)
    *构建应用程序组件*中这样做。
- en: With all that said, let’s start building our new component.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 说了这么多，让我们开始构建我们的新组件。
- en: Testing the initial component props
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试初始组件属性
- en: 'We’ll start by building a test suite for the new component:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先为新的组件构建一个测试套件：
- en: 'Create a new file, `test/AppointmentsDayViewLoader.js`, and add all the following
    imports. We’re importing not just the component under test (`AppointmentsDayViewLoader`)
    but also the child component we’ll be mocking (`AppointmentsDayView`):'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件，`test/AppointmentsDayViewLoader.js`，并添加以下所有导入。我们不仅导入正在测试的组件（`AppointmentsDayViewLoader`），还导入我们将要模拟的子组件（`AppointmentsDayView`）：
- en: '[PRE3]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add the mock setup, just below the imports:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在导入下面添加模拟设置：
- en: '[PRE4]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Start with the first test, as shown here. This checks that the component we
    just mocked out is rendered. The mock renders a `div` element with an `id` value
    of `AppointmentsDayView`. The test looks up the `id` value using the `element`
    helper and checks that it isn’t null:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这里显示的第一个测试开始。这检查我们刚刚模拟的组件是否被渲染。模拟渲染一个具有`id`值为`AppointmentsDayView`的`div`元素。测试使用`element`辅助函数查找`id`值，并检查它不为空：
- en: '[PRE5]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Use of the ID attribute
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ID属性
- en: If you have experience with `data-testid` for identifying components. If you
    want to use these mocking techniques with React Testing Library, then you can
    use `data-testid` instead of the `id` attribute, and then find your element using
    the `queryByTestId` function.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉用于识别组件的`data-testid`。如果你想使用这些模拟技术与React Testing Library一起使用，那么你可以使用`data-testid`而不是`id`属性，然后使用`queryByTestId`函数查找你的元素。
- en: Although it’s generally recommended not to rely on `data-testid` for selecting
    elements within your test suites, that doesn’t apply to mock components. You need
    IDs to be able to tell them apart because you could end up with more than a few
    mocked components all rendered by the same parent. Giving an ID to each component
    is the simplest way to find them for these DOM presence tests. Remember that the
    mocks will never make it outside of your unit testing environment, so there’s
    no harm in using IDs.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然通常建议不要在测试套件中选择元素时依赖`data-testid`，但这并不适用于模拟组件。你需要ID来区分它们，因为你可能会遇到多个由同一父组件渲染的模拟组件。给每个组件分配ID是找到这些DOM存在性测试的最简单方法。记住，模拟永远不会超出你的单元测试环境，所以使用ID没有害处。
- en: For more discussions on mocking strategies with React Testing Library, head
    over to [https://reacttdd.com/mocking-with-react-testing-library](https://reacttdd.com/component-mocks-with-react-testing-library/).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于使用React Testing Library的模拟策略的讨论，请访问[https://reacttdd.com/mocking-with-react-testing-library](https://reacttdd.com/component-mocks-with-react-testing-library/)。
- en: 'Let’s make that test pass. Create a new file, `src/AppointmentsDayViewLoader.js`,
    and go ahead and fill in the implementation, as follows. It does nothing but render
    the component, which is all the test asked for:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让这个测试通过。创建一个新文件，`src/AppointmentsDayViewLoader.js`，并继续填写实现，如下所示。它只是渲染组件，这正是测试所要求的：
- en: '[PRE6]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Time for the next test. We’ll check whether the initial value of the props sent
    to
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下次测试的时间到了。我们将检查发送给函数的props的初始值。
- en: '`AppointmentsDayView` is what we expect. We’ll do this by using the `toBeCalledWith`
    matcher, which we’ve used already. Notice the second parameter value of `expect.anything()`:
    that’s needed because React passes a second parameter to the component function
    when it’s rendered. You’ll never need to be concerned with this in your code –
    it’s an internal detail of React’s implementation – so we can safely ignore it.
    We’ll use `expect.anything` to assert that we don’t care what that parameter is:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppointmentsDayView`是我们期望的结果。我们将通过使用`toBeCalledWith`匹配器来实现这一点，我们已经使用过它了。注意`expect.anything()`的第二个参数值：这是必需的，因为React在渲染组件函数时传递第二个参数。你永远不会需要在你的代码中关心这个参数——这是React实现的一个内部细节——因此我们可以安全地忽略它。我们将使用`expect.anything`来断言我们不在乎那个参数是什么：'
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Verifying props and their presence in the DOM
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 验证props及其在DOM中的存在
- en: It’s important to test both props that were passed to the mock and that the
    stubbed value is rendered in the DOM, as we have done in these two tests. In [*Chapter
    8*](B18423_08.xhtml#_idTextAnchor147), *Building an Application Component*, we’ll
    see a case where we want to check that a mocked component is unmounted after a
    user action.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个测试中，测试传递给模拟的props以及模拟值是否渲染在DOM中非常重要，正如我们所做的。在[*第8章*](B18423_08.xhtml#_idTextAnchor147)
    *构建应用程序组件*中，我们将看到一个案例，其中我们想要检查在用户操作后模拟组件是否已卸载。
- en: 'Make that pass by updating your component definition, as shown here:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过更新你的组件定义来通过测试，如下所示：
- en: '[PRE8]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You’ve just used your first mocked component! You’ve seen how to create the
    mock, and the two types of tests needed to verify its use. Next, we’ll add a `useEffect`
    hook to load data when the component is mounted and pass it through to the `appointments`
    prop.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚使用了你的第一个模拟组件！你已经看到了如何创建模拟，以及验证其使用的两种类型的测试。接下来，我们将添加一个`useEffect`钩子，在组件挂载时加载数据，并通过`appointments`
    prop传递它。
- en: Fetching data on mount with useEffect
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`useEffect`在挂载时获取数据
- en: 'The appointment data we’ll load comes from an endpoint that takes start and
    end dates. These values filter the result to a specific time range:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将加载的预约数据来自一个接受开始和结束日期的端点。这些值将结果过滤到特定的时间范围：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Our new component is passed a `today` prop that is a `Date` object with the
    value of the current time. We will calculate the `from` and `to` dates from the
    `today` prop and construct a URL to pass to `global.fetch`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新组件接收一个`today` prop，它是一个包含当前时间值的`Date`对象。我们将从`today` prop计算`from`和`to`日期，并构建一个URL传递给`global.fetch`。
- en: To get there, first, we’ll cover a bit of theory on testing the `useEffect`
    hook. Then, we’ll implement a new `renderAndWait` function, which we’ll need because
    we’re invoking a promise when the component is mounted. Finally, we’ll use that
    function in our new tests, building out the complete `useEffect` implementation.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要达到这个目标，首先，我们将简要介绍一些关于测试`useEffect`钩子的理论。然后，我们将实现一个新的`renderAndWait`函数，因为我们将在组件挂载时调用一个promise。最后，我们将使用这个函数在我们的新测试中，构建完整的`useEffect`实现。
- en: Understanding the useEffect hook
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解`useEffect`钩子
- en: The `useEffect` hook is React’s way of running side effects. The idea is that
    you provide a function that will run each time any of the hook’s dependencies
    change. That dependency list is specified as the second parameter to the `useEffect`
    call.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`useEffect`钩子是React执行副作用的方式。想法是，你提供一个函数，该函数将在钩子的任何依赖项更改时运行。这个依赖项列表是`useEffect`调用的第二个参数。'
- en: 'Let’s take another look at our example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看我们的示例：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The hook code will run any time the `today` prop changes. This includes when
    the component first mounts. When we test-drive this, we’ll start with an empty
    dependency list and then use a specific test to force a refresh when the component
    is remounted with a new `today` prop value.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当`today` prop改变时，钩子代码将运行。这包括当组件首次挂载时。当我们进行测试驱动时，我们将从一个空的依赖项列表开始，然后使用一个特定的测试来强制在组件使用新的`today`
    prop值重新挂载时刷新。
- en: 'The function you pass to `useEffect` should return another function. This function
    performs teardown: it is called any time the value changes, especially *before*
    the hook function is invoked again, enabling you to cancel any running tasks.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你传递给`useEffect`的函数应该返回另一个函数。这个函数执行清理操作：它在值改变时被调用，尤其是在钩子函数再次被调用之前，这使你能够取消任何正在运行的任务。
- en: 'We’ll explore this return function in detail in [*Chapter 15*](B18423_15.xhtml#_idTextAnchor306),
    *Adding Animation*. However, for now, you should be aware that this affects how
    we call promises. We can’t do this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [*第15章*](B18423_15.xhtml#_idTextAnchor306) *添加动画* 中详细探讨这个返回函数。然而，现在你应该知道这会影响我们调用
    Promise 的方式。我们不能这样做：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Defining the outer function as `async` would mean it returns a promise, not
    a function. We must do this instead:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 将外部函数定义为 `async` 意味着它返回一个 Promise，而不是一个函数。我们必须这样做：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When running tests, if you were to call `global.fetch` directly from within
    the `useEffect` hook, you’d receive a warning from React. It would alert you that
    the `useEffect` hook should not return a promise.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行测试时，如果你在 useEffect Hook 内直接调用 `global.fetch`，你会收到 React 的警告。它会提醒你 `useEffect`
    Hook 不应该返回一个 Promise。
- en: Using setters inside useEffect Hook functions
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在 useEffect Hook 函数中使用设置器
- en: React guarantees that setters such as `setAppointments` remain static. This
    means they don’t need to appear in the `useEffect` dependency list.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: React 保证像 `setAppointments` 这样的设置器保持静态。这意味着它们不需要出现在 useEffect 依赖列表中。
- en: To get started with our implementation, we’ll need to ensure our tests are ready
    for render calls that run promises.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始我们的实现，我们需要确保我们的测试为运行 Promise 的 render 调用做好准备。
- en: Adding the renderAndWait helper
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 renderAndWait 辅助函数
- en: Just as we did with `clickAndWait` and `submitAndWait`, now, we need `renderAndWait`.
    This will render the component and then wait for our `useEffect` hook to run,
    including any promise tasks.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们对 clickAndWait 和 submitAndWait 所做的那样，现在我们需要 renderAndWait。这将渲染组件，然后等待我们的
    useEffect Hook 运行，包括任何 Promise 任务。
- en: 'To be clear, this function is necessary not because of the `useEffect` hook
    itself – just a normal sync `act` call would ensure that it runs – because of
    the promise that `useEffect` runs:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，这个函数的必要性不是因为 useEffect Hook 本身——一个普通的同步 act 调用就能确保它运行——而是因为 useEffect
    运行的 Promise：
- en: 'In `test/reactTestExtensions.js`, add the following function below the definition
    of `render`:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `test/reactTestExtensions.js` 中，在 `render` 定义下方添加以下函数：
- en: '[PRE13]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Update the import in your test suite so that it references this new function:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新测试套件中的导入，使其引用这个新函数：
- en: '[PRE14]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, update the first test:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，更新第一个测试：
- en: '[PRE15]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add the second test, which checks that we send an empty array of appointments
    to `AppointmentsDayView` before the server has returned any data:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加第二个测试，检查在服务器返回任何数据之前，我们是否向 `AppointmentsDayView` 发送了一个空的预约数组：
- en: '[PRE16]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Make sure to check that these tests are passing before you continue.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请确保这些测试通过。
- en: Adding the useEffect hook
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 useEffect Hook
- en: 'We’re about to introduce a `useEffect` hook with a call to `global.fetch`.
    We’ll start by mocking that call using `jest.spyOn`. Then, we’ll continue with
    the test:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将引入一个带有对 `global.fetch` 调用的 useEffect Hook。我们首先将使用 `jest.spyOn` 模拟这个调用。然后，我们继续进行测试：
- en: 'Add the following new imports to the top of the test suite:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试套件的顶部添加以下新的导入：
- en: '[PRE17]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Define a sample set of appointments at the top of the `describe` block:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `describe` 块的顶部定义一组示例预约：
- en: '[PRE18]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To set up `global.fetch` so that it returns this sample array, modify the test
    suite’s `beforeEach` block, as shown here:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要设置 `global.fetch` 以返回此示例数组，修改测试套件的 `beforeEach` 块，如下所示：
- en: '[PRE19]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It’s time for our test. We assert that when the component is mounted, we should
    expect to see a call to `global.fetch` being made with the right parameters. Our
    test calculates what the right parameter values should be – it should be from
    midnight today to midnight tomorrow:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候进行我们的测试了。我们断言当组件挂载时，我们应该看到带有正确参数的 `global.fetch` 调用。我们的测试计算了正确的参数值——应该是从今晚午夜到明天午夜：
- en: '[PRE20]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To make this test pass, first, we’ll need to introduce a `useEffect` hook into
    the component file:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使这个测试通过，首先，我们需要在组件文件中引入一个 useEffect Hook：
- en: '[PRE21]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we can update the component to make the call, as follows. Although this
    is a lot of code already, notice how we aren’t making use of the `return` value
    yet: there’s no state being stored and `AppointmentsDayView` still has its `appointments`
    prop set to an empty array. We’ll fill that in later:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以更新组件以进行调用，如下所示。尽管代码已经很多了，但请注意我们还没有使用 `return` 返回值：没有存储任何状态，`AppointmentsDayView`
    仍然将 `appointments` 属性设置为空数组。我们稍后会填充它：
- en: '[PRE22]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Before continuing with the next test, let’s set a default value for the `today`
    prop so that any callers don’t need to specify this:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续下一个测试之前，让我们为 `today` 属性设置一个默认值，这样任何调用者都不需要指定这个值：
- en: '[PRE23]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The next test will ensure we use the return value of our `global.fetch` call.
    Notice how we use the `toHaveBeenLastCalledWith` matcher. This is important because
    the first render of the component will be an empty array. It’s the second call
    that will contain data:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个测试将确保我们使用`global.fetch`调用的返回值。注意我们如何使用`toHaveBeenLastCalledWith`匹配器。这很重要，因为组件的第一次渲染将是一个空数组。包含数据的是第二次调用：
- en: '[PRE24]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To make that pass, first, update your component’s `import` to pull in the `useState`
    function:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使其通过，首先，更新你的组件的`import`以引入`useState`函数：
- en: '[PRE25]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, update your component’s definition, as shown here:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，更新你的组件定义，如下所示：
- en: '[PRE26]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This completes the basic `useEffect` implementation – our component is now loading
    data. However, there’s a final piece we must address with the `useEffect` implementation.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了基本的`useEffect`实现——我们的组件现在正在加载数据。然而，我们必须用`useEffect`实现来解决最后一个问题。
- en: Testing the useEffect dependency list
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试`useEffect`依赖列表
- en: The second parameter to the `useEffect` call is a dependency list that defines
    the variables that should cause the effect to be re-evaluated. In our case, the
    `today` prop is the important one. If the component is re-rendered with a new
    value for `today`, then we should pull down new appointments from the server.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`useEffect`调用的第二个参数是一个依赖列表，它定义了应该导致效果重新评估的变量。在我们的例子中，`today`属性是重要的。如果组件以新的`today`值重新渲染，那么我们应该从服务器拉取新的预约。'
- en: 'We’ll write a test that renders a component twice. This kind of test is very
    important any time you’re using the `useEffect` hook. To support that, we’ll need
    to adjust our render functions to ensure they only create one root:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个渲染组件两次的测试。这种测试在任何使用`useEffect`钩子的时候都非常重要。为了支持这一点，我们需要调整我们的渲染函数，确保它们只创建一个根：
- en: 'In `test/reactTestExtensions.js`, add a new top-level variable called `reactRoot`
    and update `initializeReactContainer` to set this variable:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`test/reactTestExtensions.js`中，添加一个名为`reactRoot`的新顶级变量，并更新`initializeReactContainer`以设置此变量：
- en: '[PRE27]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, update the definitions of `render` and `renderAndWait` so that they use
    this `reactRoot` variable. After making this change, you’ll be able to re-mount
    components within a single test:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，更新`render`和`renderAndWait`的定义，使它们使用这个`reactRoot`变量。在做出这个更改后，你将能够在单个测试中重新挂载组件：
- en: '[PRE28]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Back in your test suite, update `import` so that it includes `today`, `tomorrow`,
    and `tomorrowAt`. We’ll use these in the next test:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的测试套件中，更新`import`以包含`today`、`tomorrow`和`tomorrowAt`。我们将在下一个测试中使用这些：
- en: '[PRE29]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, add the test. This renders the component twice, with two separate values
    for the `today` prop. Then, it checks whether `global.fetch` was called twice:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加测试。这会渲染组件两次，`today`属性有两个不同的值。然后，它检查`global.fetch`是否被调用两次：
- en: '[PRE30]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If you run the test now, you’ll see that `global.fetch` is only being called
    once:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在运行测试，你会看到`global.fetch`只被调用了一次：
- en: '[PRE31]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Making it pass is a one-word change. Find the second parameter of the `useEffect`
    call and change it from an empty array, as shown here:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使其通过只需一个单词的更改。找到`useEffect`调用的第二个参数，并将其从空数组更改为如下所示：
- en: '[PRE32]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: That’s it for the implementation of this component. In the next section, we’ll
    clean up our test code with a new matcher.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是本组件实现的全部内容。在下一节中，我们将使用一个新的匹配器清理我们的测试代码。
- en: Building matchers for component mocks
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为组件模拟构建匹配器
- en: In this section, we’ll introduce a new matcher, `toBeRenderedWithProps`, that
    simplifies the expectations for our mock spy object.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍一个新的匹配器`toBeRenderedWithProps`，它简化了我们对模拟间谍对象的期望。
- en: 'Recall that our expectations look like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们的期望看起来是这样的：
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Imagine if you were working on a team that had tests like this. Would a new
    joiner understand what that second argument, `expect.anything()`, is doing? Will
    *you* understand what this is doing if you don’t go away for a while and forget
    how component mocks work?
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果你在一个有这种测试的团队中工作。新加入的人能理解第二个参数`expect.anything()`在做什么吗？如果你一段时间不回来，忘记了组件模拟的工作方式，你会理解这个吗？
- en: Let’s wrap that into a matcher that allows us to hide the second property.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将它包装成一个匹配器，允许我们隐藏第二个属性。
- en: We need *two* matchers to cover the common use cases. The first, `toBeRenderedWithProps`,
    is the one we’ll work through in this chapter. The second, `toBeFirstRenderedWithProps`,
    is left as an exercise for you.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要两个匹配器来覆盖常见的用例。第一个，`toBeRenderedWithProps`，是我们将在本章中解决的问题。第二个，`toBeFirstRenderedWithProps`，留作你的练习。
- en: The matcher, `toBeRenderedWithProps`, will pass if the component is *currently
    rendered* with the given props. This function will be equivalent to using the
    `toHaveBeenLastCalledWith` matcher.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配器 `toBeRenderedWithProps` 将在组件当前使用给定属性渲染时通过。这个函数将与使用 `toHaveBeenLastCalledWith`
    匹配器等效。
- en: 'The essential part of this matcher is when it pulls out the last element of
    the `mock.calls` array:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个匹配器的关键部分是当它从 `mock.calls` 数组中提取最后一个元素时：
- en: '[PRE34]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The mock.calls array
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: mock.calls 数组
- en: Recall that every mock function that’s created with `jest.spyOn` or `jest.fn`
    will have a `mock.calls` property, which is an array of all the calls. This was
    covered in [*Chapter 6*](B18423_06.xhtml#_idTextAnchor099), *Exploring Test Doubles*.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，每个使用 `jest.spyOn` 或 `jest.fn` 创建的模拟函数都将有一个 `mock.calls` 属性，它是一个包含所有调用的数组。这一点在
    [*第6章*](B18423_06.xhtml#_idTextAnchor099) 中有介绍，*探索测试替身*。
- en: 'The second matcher is `toBeFirstRenderedWithProps`. This will be useful for
    any test that checks the initial value of the child props and before any `useEffect`
    hooks have run. Rather than picking the last element of the `mock.calls` array,
    we’ll just pick the first:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个匹配器是 `toBeFirstRenderedWithProps`。这对于任何检查子属性初始值并且在任何 `useEffect` 钩子运行之前的测试都很有用。我们不会选择
    `mock.calls` 数组的最后一个元素，而是直接选择第一个：
- en: '[PRE35]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let’s get started with `toBeRenderedWithProps`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `toBeRenderedWithProps` 开始：
- en: 'Create a new matcher test file at `test/matchers/toBeRenderedWithProps.test.js`.
    Add the following imports:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `test/matchers/toBeRenderedWithProps.test.js` 创建一个新的匹配器测试文件。添加以下导入：
- en: '[PRE36]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Add the following test setup. Since our tests will be operating on a spy function,
    we can set that up in our `beforeEach` block, as shown here:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下测试设置。由于我们的测试将在一个间谍函数上操作，我们可以在 `beforeEach` 块中设置它，如下所示：
- en: '[PRE37]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As usual, our first test is to check that `pass` returns `true`. Notice how
    we must render the component before we call the matcher:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如同往常，我们的第一个测试是检查 `pass` 返回 `true`。注意我们必须在调用匹配器之前渲染组件：
- en: '[PRE38]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To make this pass, create a new file for the matcher, `test/matchers/toBeRenderedWithProps.js`,
    and add the following implementation:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使这个测试通过，创建一个新的匹配器文件 `test/matchers/toBeRenderedWithProps.js`，并添加以下实现：
- en: '[PRE39]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'It’s time to triangulate. For the next test, let’s check that `pass` is `false`
    when we don’t render the component before calling it:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候进行三角测量了。对于下一个测试，让我们检查在调用组件之前没有渲染它时，`pass` 是否为 `false`：
- en: '[PRE40]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To get the test to green, all we’ve got to do is check that the mock was called
    at least once:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让测试通过，我们只需检查模拟至少被调用了一次：
- en: '[PRE41]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, we’ll need to check that `pass` is `false` if the props don’t match.
    We can’t write the opposite test – that `pass` is `true` if the props match –
    because that test would already pass, given our current implementation:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要检查如果属性不匹配，`pass` 是否为 `false`。我们无法编写相反的测试——即如果属性匹配，则 `pass` 为 `true`——因为根据我们当前的实现，这个测试已经通过了：
- en: '[PRE42]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'For the component code, we’ll use the `equals` function from inside the `expect-utils`
    package, which is already installed as part of Jest. This tests for deep equality
    but also allows you to make use of `expect` helpers such as `expect.anything`
    and `expect.objectContaining`:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于组件代码，我们将使用 `expect-utils` 包内的 `equals` 函数，这个包已经作为 Jest 的一部分安装。这个函数测试深度相等，同时也允许你使用
    `expect` 辅助函数，如 `expect.anything` 和 `expect.objectContaining`：
- en: '[PRE43]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'For our final test, we want an example that shows that this matcher works that
    the expectation will match on the last rendering of the mock:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的最终测试，我们想要一个例子来展示这个匹配器可以在模拟的最后渲染上匹配期望：
- en: '[PRE44]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'To make that pass, we need to update the implementation so that it chooses
    the last element of the `mock.calls` array, rather than the first:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使这个测试通过，我们需要更新实现，使其选择 `mock.calls` 数组的最后一个元素，而不是第一个：
- en: '[PRE45]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We’ll leave our implementation here. Completing the tests for the message property
    is left as an exercise for you, but they follow the same order as the tests shown
    in [*Chapter 3*](B18423_03.xhtml#_idTextAnchor053), *Refactoring the Test Suite*.
    For now, move to `test/domMatchers.js` and register your new matcher:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在这里留下我们的实现。完成消息属性的测试留作你的练习，但它们的顺序与 [*第3章*](B18423_03.xhtml#_idTextAnchor053)
    中显示的测试相同，*重构测试套件*。现在，转到 `test/domMatchers.js` 并注册你的新匹配器：
- en: '[PRE46]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Finally, back in your test suite, update the test that checks the `appointments`
    prop. It should look as follows; it’s much nicer now that the `expect.anything`
    parameter value has gone:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，回到你的测试套件中，更新检查 `appointments` 属性的测试。它应该看起来像这样；现在 `expect.anything` 参数值已经移除，它看起来更简洁了：
- en: '[PRE47]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: With that, you’ve learned how to build a matcher for component mocks, which
    reduces the verbiage that we originally had when we used the built-in `toBeCalledWith`
    matcher.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，你已经学会了如何为组件模拟构建一个匹配器，这减少了我们最初使用内置的`toBeCalledWith`匹配器时所拥有的冗余。
- en: The other test in this test suite needs a second matcher, `toBeFirstRenderedWithProps`.
    The implementation of this is left as an exercise for you.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试套件中的另一个测试需要一个第二个匹配器，`toBeFirstRenderedWithProps`。这个实现的细节留给你作为练习。
- en: In the next section, we’ll look at a variety of ways that component mocks can
    become more complicated.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨组件模拟可以变得更加复杂的各种方式。
- en: Variants of the jest.mock call
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: jest.mock 调用的变体
- en: Before we finish up this chapter, let’s take a look at some variations on the
    `jest.mock` call that you may end up using.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成本章之前，让我们看看一些你可能最终会使用的`jest.mock`调用的变体。
- en: The key thing to remember is to *keep your mocks as simple as possible*. If
    you start to feel like your mocks need to become more complex, you should treat
    that as a sign that your components are overloaded and should be broken apart
    in some way.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的关键点是*尽可能保持你的模拟简单*。如果你开始觉得你的模拟需要变得更加复杂，你应该将其视为一个信号，表明你的组件过载了，并且应该以某种方式拆分。
- en: That being said, there are cases where you must use different forms of the basic
    component mock.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，有些情况下你必须使用基本组件模拟的不同形式。
- en: Removing the spy function
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除间谍函数
- en: 'To begin with, you can simplify your `jest.mock` calls by not using `jest.fn`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以通过不使用`jest.fn`来简化你的`jest.mock`调用：
- en: '[PRE48]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: With this form, you’ve set a stub return value, but you won’t be able to spy
    on any props. This is sometimes useful if, for example, you’ve got multiple files
    that are testing this same component but only some of them verify the mocked component
    props. It can also be useful with third-party components.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种形式，你已经设置了一个存根返回值，但你将无法监视任何属性。如果，例如，你有多个文件正在测试同一个组件，但只有其中一些验证了模拟组件的属性，这有时是有用的。它也可以与第三方组件一起使用。
- en: Rendering the children of mocked components
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染模拟组件的子组件
- en: 'Sometimes, you’ll want to render grandchild components, skipping out the child
    (their parent). This often happens, for example, when a third-party component
    renders a complex UI that is difficult to test: perhaps it loads elements via
    the shadow DOM, for example. In that case, you can pass `children` through your
    mock:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能想要渲染孙组件，跳过子组件（它们的父组件）。这种情况经常发生，例如，当第三方组件渲染一个复杂且难以测试的UI时：例如，它可能通过阴影DOM加载元素。在这种情况下，你可以通过你的模拟传递`children`：
- en: '[PRE49]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We will see examples of this in [*Chapter 11*](B18423_11.xhtml#_idTextAnchor207),
    *Test-Driving React Router*.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第11章*](B18423_11.xhtml#_idTextAnchor207)中看到这个例子，*测试驱动React Router*。
- en: Checking multiple instances of the rendered component
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查渲染组件的多个实例
- en: 'There are occasions when you’ll want to mock a component that has been rendered
    multiple times into the document. How can you tell them apart? If they have a
    unique ID prop (such as `key`), you can use that in the `id` field:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能想要模拟一个被多次渲染到文档中的组件。你如何区分它们？如果它们有一个唯一的ID属性（如`key`），你可以在`id`字段中使用它：
- en: '[PRE50]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Approach with caution!
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 小心行事！
- en: One of the biggest issues with mocking components is that mock definitions can
    get out of control. But mock setup is complicated and can be very confusing. Because
    of this, you should avoid writing anything but the simplest mocks.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟组件的最大问题之一是模拟定义可能会失控。但是模拟设置很复杂，可能会非常令人困惑。因此，你应该避免编写除了最简单的模拟之外的内容。
- en: Thankfully, most of the time, the plain form of component mock is all you’ll
    need. These variants are useful occasionally but should be avoided.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，大多数时候，组件模拟的普通形式就足够了。这些变体偶尔是有用的，但应该避免使用。
- en: We’ll see this variation in action in [*Chapter 11*](B18423_11.xhtml#_idTextAnchor207),
    *Test-Driving React Router*.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第11章*](B18423_11.xhtml#_idTextAnchor207)中看到这个变体的实际应用，*测试驱动React Router*。
- en: Alternatives to module mocks
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块模拟的替代方案
- en: 'Mocking out an entire module is fairly heavy-handed. The mock you set up must
    be used for all the tests in the same test module: you can’t mix and match tests,
    some using the mock and some not. If you wanted to do this with `jest.mock`, you’d
    have to create two test suites. One would have the mock and the other wouldn’t.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟整个模块相当直接。你设置的模拟必须用于同一测试模块中的所有测试：你不能混合使用测试，一些使用模拟，一些不使用。如果你想要使用`jest.mock`来做这件事，你必须创建两个测试套件。一个会有模拟，另一个则不会。
- en: You also have the issue that the mock is at the module level. You can’t just
    mock out one part of the module. Jest has functions that allow you to reference
    the original implementation called `requireActual`. For me, that involves moving
    into the danger zone of overly complex test doubles, so I refrain from using it
    – I have encountered a use case that needed it.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 您还遇到了模拟处于模块级别的问题。您不能只是模拟模块的一部分。Jest有允许您引用原始实现的函数，称为`requireActual`。对我来说，这涉及到进入过于复杂的测试替身的风险区域，所以我避免使用它——我遇到了一个需要它的用例。
- en: However, there are alternatives to using `jest.mock`. One is shallow rendering,
    which utilizes a special renderer that renders a single parent component, ignoring
    all child components other than standard HTML elements. In a way, this is even
    more heavy-handed because *all* your components end up mocked out.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用`jest.mock`有替代方案。一个是浅渲染，它使用一个特殊的渲染器，只渲染单个父组件，忽略所有非标准HTML元素的子组件。从某种意义上说，这甚至更加直接，因为*所有*您的组件最终都会被模拟。
- en: For `CommonJS` modules, you can also overwrite specific exports inside modules,
    simply by assigning new values to them! This gives you a much more granular way
    of setting mocks at the test level. However, this is not supported in **ECMAScript**,
    so in the interests of maximum capability, you may want to avoid this approach.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`CommonJS`模块，您也可以通过简单地给它们赋新值来覆盖模块内的特定导出！这为您在测试级别设置模拟提供了一个更细粒度的方法。然而，这在**ECMAScript**中不受支持，因此为了最大程度地发挥能力，您可能希望避免这种方法。
- en: For examples of these alternative approaches and a discussion on when you may
    want to use them, take a look at [https://reacttdd.com/alternatives-to-module-mocks](https://reacttdd.com/alternatives-to-module-mocks).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解这些替代方法的示例以及何时可能需要使用它们，请参阅[https://reacttdd.com/alternatives-to-module-mocks](https://reacttdd.com/alternatives-to-module-mocks)。
- en: Summary
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter covered the most complex form of mocking: setting up component
    mocks with `jest.mock`.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了最复杂的模拟形式：使用`jest.mock`设置组件模拟。
- en: Since mocking is a complex art form, it’s best to stick with a small set of
    established patterns, which I’ve shown in this chapter. You can also refer to
    the code in [*Chapter 11*](B18423_11.xhtml#_idTextAnchor207), *Test-Driving React
    Router*, for examples that show some of the variations that have been described
    in this chapter.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 由于模拟是一项复杂的艺术，因此最好坚持使用一组已建立的模式，我在本章中展示了这些模式。您还可以参考[*第11章*](B18423_11.xhtml#_idTextAnchor207)，*测试驱动React
    Router*中的代码，以了解本章中描述的一些变体。
- en: You also learned how to test-drive a `useEffect` hook before writing another
    matcher.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 您还学习了如何在编写另一个匹配器之前测试驱动`useEffect`钩子。
- en: You should now feel confident with testing child components by using component
    mocks, Including loading data into those components through `useEffect` actions.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该对使用组件模拟测试子组件感到自信，包括通过`useEffect`动作将这些组件加载数据。
- en: In the next chapter, we’ll extend this technique further by pulling out `callback`
    props from mock components and invoking them within our tests.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过从模拟组件中提取`callback`属性并在测试中调用它们来进一步扩展这项技术。
- en: Exercises
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'The following are some exercises for you to try out:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些供您尝试的练习：
- en: Complete the message property tests on the `toBeRenderedWithProps` matcher.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成`toBeRenderedWithProps`匹配器上的消息属性测试。
- en: Add the `toBeFirstRenderedWithProps` matcher and update your test suite to use
    this matcher. Since this matcher is very similar to `toBeRenderedWithProps`, you
    can add it to the same module file that contains the `toBeRenderedWithProps` matcher.
    You can also try to factor out any shared code into its own function that both
    matchers can use.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`toBeFirstRenderedWithProps`匹配器，并更新您的测试套件以使用此匹配器。由于此匹配器与`toBeRenderedWithProps`非常相似，您可以将它添加到包含`toBeRenderedWithProps`匹配器的同一模块文件中。您还可以尝试将任何共享代码提取到其自己的函数中，这两个匹配器都可以使用。
- en: Add a `toBeRendered` matcher that checks if a component was rendered without
    checking its props.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`toBeRendered`匹配器，该匹配器检查一个组件是否已渲染，而不检查其属性。
- en: Complete the matchers you’ve written so that they throw an exception if the
    passed argument is not a Jest mock.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成您编写的匹配器，以便在传递的参数不是Jest模拟时抛出异常。
- en: Create a new component, `AppointmentFormLoader`, that calls the `GET /availableTimeSlots`
    endpoint when mounted. It should render an `AppointmentForm` component with its
    `appointments` prop set to the data returned from the server.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的组件，`AppointmentFormLoader`，当组件挂载时调用`GET /availableTimeSlots`端点。它应该渲染一个`AppointmentForm`组件，并将其`appointments`属性设置为从服务器返回的数据。
- en: Further reading
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: To learn how to mock components without relying on `jest.mock`, please check
    out [https://reacttdd.com/alternatives-to-module-mocks](https://reacttdd.com/alternatives-to-module-mocks).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何在不依赖 `jest.mock` 的情况下模拟组件，请查看[https://reacttdd.com/alternatives-to-module-mocks](https://reacttdd.com/alternatives-to-module-mocks)。
