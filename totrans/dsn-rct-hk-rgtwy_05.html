<html><head></head><body>
		<div id="_idContainer048">
			<h1 id="_idParaDest-87"><em class="italic"><a id="_idTextAnchor157"/>Chapter 5</em>: Use Effect to Handle Side Effects</h1>
			<p>In the previous chapter, we learned how <strong class="source-inline">useState</strong> is designed and how to use it to manage state changes in <strong class="bold">React</strong>. In this chapter, we will learn about using <strong class="source-inline">useEffect</strong> for managing <em class="italic">side effects</em>. We will first introduce what a <em class="italic">side effect</em> is, and then we will walk through the data structure and source code behind <strong class="source-inline">useEffect</strong> and provide various scenarios for invoking effects. We will also demonstrate a couple of pitfalls of using <strong class="source-inline">useEffect</strong> and discuss some ways to avoid them. At the end of this chapter, we'll use <strong class="source-inline">useEffect</strong> in two practical examples: <em class="italic">Finding the window size</em> and <em class="italic">Fetching an API resource</em>. The chapter also includes three bonus topics in the <em class="italic">Appendix</em> section: <em class="italic">React side</em> <em class="italic">effects, Flushing the passive effects,</em> and <em class="italic">Is a dispatch async</em>.</p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>What is a side effect?</li>
				<li><strong class="source-inline">Understanding</strong> <strong class="source-inline">useEffect</strong> design</li>
				<li>Creating effects</li>
				<li>Test driving <strong class="source-inline">useEffect</strong></li>
				<li><strong class="source-inline">useEffect</strong> examples</li>
				<li>Questions and answers</li>
				<li>Appendix</li>
			</ul>
			<h1 id="_idParaDest-88"><a id="_idTextAnchor158"/>What is a side effect?</h1>
			<p>The following function<a id="_idIndexMarker178"/> has no side effect: </p>
			<p class="source-code"><strong class="bold">function</strong> add(a, b) {</p>
			<p class="source-code">  <strong class="bold">return</strong> a + b</p>
			<p class="source-code">}</p>
			<p>This function is quite pure, in the sense that if it is invoked with the same set of input arguments, we should get the same result – that is, <strong class="source-inline">add(1, 1)</strong> will return <strong class="source-inline">2</strong>. This type of <em class="italic">pure</em> function is easy<a id="_idIndexMarker179"/> to understand, test, and develop. The reason for this is that the function only depends on the input arguments and has no additional hidden dependency. </p>
			<p>You might wonder what a hidden<a id="_idIndexMarker180"/> dependency could be? Believe it or not, it's quite easy to have one. In the following code, we'll intentionally introduce two lines and each will add a hidden dependency:</p>
			<p class="source-code"><strong class="bold">let</strong> c = 3</p>
			<p class="source-code"><strong class="bold">function</strong> add(a, b) {</p>
			<p class="source-code">  console.log(a, b)</p>
			<p class="source-code">  <strong class="bold">return</strong> a + b + c</p>
			<p class="source-code">}</p>
			<p>The first line adds an external dependency from the <strong class="source-inline">c</strong> variable. Because <strong class="source-inline">c</strong> is a global variable, it bypasses the input argument list. If we invoke the <strong class="source-inline">add(1, 1)</strong> function now, it can return any number (or even a non-number). That's because <strong class="source-inline">c</strong> can be anything at the time when <strong class="source-inline">add</strong> is invoked. This applies to all <em class="italic">global</em> instances. </p>
			<p>Let's take a look at another hidden dependency. Inside the <strong class="source-inline">add</strong> function, the first line adds an external dependency from the <strong class="source-inline">console.log</strong> function. Our intention here is to log the <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong> variables to the screen. However, the <strong class="source-inline">console.log</strong> function could be anything at the runtime. For instance, if <strong class="source-inline">console</strong> doesn't exist, we could get an error when invoking <strong class="source-inline">console.log</strong>. </p>
			<p>From these preceding examples, we can see that we could work with an <em class="italic">impure</em> function without knowing it. There's one important<a id="_idIndexMarker181"/> thing to bear in mind about impure functions – that is, they are prone to errors. For instance, in the preceding example, if someone changed any of the hidden dependencies, it would be difficult for the developer to know that. This can become a nightmare when it comes to refactoring the code.</p>
			<p>To make our code robust, we tend to develop strategies to <em class="italic">avoid</em> hidden dependencies, either by removing them or containing their impact as much as possible so that we can be confident when developing and maintaining our code.</p>
			<p>In general, there are two strategies to remedy impurity of functions. One way is to remove it by adding the dependencies<a id="_idIndexMarker182"/> to the input arguments so that they are not <em class="italic">hidden</em> anymore:</p>
			<p class="source-code"><strong class="bold">function</strong> add(a, b, c, log) {</p>
			<p class="source-code">  log(a, b)</p>
			<p class="source-code">  <strong class="bold">return</strong> a + b + c</p>
			<p class="source-code">}</p>
			<p>This can be a very effective approach. With the preceding code change, the <strong class="source-inline">c</strong> variable and the <strong class="source-inline">log</strong> function are explicitly written as input arguments. It should take less effort to test this in the case of <strong class="source-inline">add(1, 1, 0, console.log)</strong>. The only downside to this approach is that to implement it, you need to know the dependencies and declare them explicitly. This means the list of input arguments could get very long and impact the effectiveness of the function.</p>
			<p>This brings us to the second strategy. Instead of removing the impurity, we can package and defer it to a later stage until we actually need to execute it. The following is an example of how we can <em class="italic">defer</em> an impurity:</p>
			<p class="source-code"><strong class="bold">function</strong> addFunc(c, log) {</p>
			<p class="source-code">  <strong class="bold">function</strong> add(a, b) {</p>
			<p class="source-code">    log(a, b)</p>
			<p class="source-code">    <strong class="bold">return</strong> a + b + c</p>
			<p class="source-code">  }  </p>
			<p class="source-code">  <strong class="bold">return</strong> add</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">addFunc</strong> function returns an <strong class="source-inline">add</strong> function. To use the <strong class="source-inline">add</strong> function,, we invoke <strong class="source-inline">addFunc</strong> to get a handle (also called a callback) of our <strong class="source-inline">add</strong> function back:</p>
			<p class="source-code"><strong class="bold">const</strong> add = addFunc(3, console.log)</p>
			<p>So, what difference does this make? The dependency for <strong class="source-inline">c</strong> and <strong class="source-inline">log</strong> appears in the input arguments, so <strong class="source-inline">addFunc</strong> is a <em class="italic">pure</em> function. Essentially, we package any impurities and declare them one level up, so within the context of <strong class="source-inline">addFunc</strong>, the new <strong class="source-inline">add</strong> function looks and works a bit purer. </p>
			<p>In a sense, we keep the original code, but we wrap it up to get a callback function so that we can execute it later. This helps protect<a id="_idIndexMarker183"/> the integrity of the main code while relocating the impurity. This deferred strategy is normally referred to as a <em class="italic">side effect</em>:</p>
			<p class="source-code"><strong class="bold">let</strong> c = 1, d = 2</p>
			<p class="source-code"><strong class="bold">function</strong> add() {</p>
			<p class="source-code">  c = 2</p>
			<p class="source-code">  const a <a id="_idTextAnchor159"/>= d</p>
			<p class="source-code">}</p>
			<p>In the preceding code, the assignment of the <strong class="source-inline">c</strong> variable inside <strong class="source-inline">add</strong> is a side effect because it <em class="italic">changes</em> a global value; the assignment of the <strong class="source-inline">a</strong> variable is another side effect because it <em class="italic">reads from</em> a global value. From here, you can see that <strong class="source-inline">console</strong> is a solid side effect because it's an external service that writes to a terminal screen. </p>
			<p>In a loosely connected open system, such as the web, a side effect is unavoidable. If you want to perform a range of actions and one action happens to not be defined by the internal system, then the action involves accessing an external system. Although we cannot avoid the side effect, we can package<a id="_idIndexMarker184"/> the side effect so that it accesses the external system at the right time.</p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor160"/>Introducing passive effects</h2>
			<p>In React, a <em class="italic">side effect</em> refers to a case where<a id="_idIndexMarker185"/> we attempt to either <em class="italic">read from</em> or <em class="italic">write to</em> an <em class="italic">external system</em>. The external system can be<a id="_idIndexMarker186"/> a DOM element, an object such as a <strong class="source-inline">document</strong> or <strong class="source-inline">window</strong> object, or a fetch to a web server.</p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="image/Figure_5.01_B17963.jpg" alt="Figure 5.1 – React passive effects&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.1 – React passive effects</p>
			<p>Upon a user action, a <em class="italic">dispatch</em> is scheduled to trigger a <em class="italic">render</em> that is followed by a <em class="italic">commit</em> to form<a id="_idIndexMarker187"/> an update (as illustrated in <em class="italic">Figure 5.1</em>). During the update, React doesn't allow custom side effects to be invoked right away. Instead, React waits until the end of the commit before invoking them. </p>
			<p>If there are two side effects encountered during the update, both are deferred and then invoked one by one after the <em class="italic">commit</em>. Effects such as these are referred to as the passive effects internally. Passive effects are one of several types of effects supported by React. If you are interested in the other types of effects, please refer to the <em class="italic">Appendix A – React side effects</em> section at the end of this chapter.</p>
			<p>It is referred to as <em class="italic">passive</em> due to the way it's invoked during the update. React allows us to invoke a passive effect<a id="_idIndexMarker188"/> in each update or to conditionally invoke it when responding to a value change. Therefore, the effect isn't actively tied as in the case of a user event, but instead, upon a value change, the effect gets created, queued, and then invoked later. In a way, the effect can be invoked through a passive "event".</p>
			<p>A passive effect is modeled as a callback function. In this instance, let's say it's called <strong class="source-inline">create</strong>. Invoking the <strong class="source-inline">create</strong> function executes the effect and returns a <strong class="source-inline">destroy</strong> function to perform the cleanup job associated with the effect. </p>
			<p>Now that we know what a React effect is, let's dive in and see how a <strong class="source-inline">useEffect</strong> hook is designed to facilitate this process.</p>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor161"/>Understanding useEffect design</h1>
			<p>React provides a <strong class="source-inline">useEffect</strong> hook<a id="_idIndexMarker189"/> to set up a callback to be invoked after an update:</p>
			<p class="source-code"><strong class="bold">const</strong> Title = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  useEffect(() <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    window.title = "Hello World"</p>
			<p class="source-code">    <strong class="bold">return</strong> () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">      window.title = "Notitle"</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }, [])</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">useEffect</strong> function takes a callback function called <strong class="source-inline">create</strong> as its first input argument to define the effect. In the preceding example, the effect sets the <strong class="source-inline">window.title</strong> to be <strong class="source-inline">Hello World</strong> when the component is mounted. </p>
			<p>A <strong class="source-inline">create</strong> function can return a function called <strong class="source-inline">destroy</strong> to perform the cleanup. The interesting thing here is that the <strong class="source-inline">destroy</strong> function is provided by the <strong class="source-inline">create</strong> function as a return<a id="_idIndexMarker190"/> value. In the preceding example, the cleanup reverts the <strong class="source-inline">window.title</strong> object back to <strong class="source-inline">NoTitle</strong> when it is unmounted.</p>
			<p>The second parameter in the <strong class="source-inline">useEffect</strong> argument list is a dependency<a id="_idIndexMarker191"/> array called <strong class="source-inline">deps</strong>. If <strong class="source-inline">deps</strong> is <em class="italic">not given</em>, the effect gets invoked each time during each update, whereas when <strong class="source-inline">deps</strong> <em class="italic">is given</em>, the effect only gets invoked upon a change from the<a id="_idTextAnchor162"/> <strong class="source-inline">deps</strong> array.</p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor163"/>The useEffect hook's data structure</h2>
			<p>In this section, we are going<a id="_idIndexMarker192"/> to explain how <strong class="source-inline">useEffect</strong> is designed by taking a stripped-down version of the source code as an example. First, let's take a look at the data structure that makes it happen.</p>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="image/Figure_5.2_B17963.jpg" alt="Figure 5.2 – The data structure for the useEffect hook&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.2 – The data structure for the <strong class="source-inline">useEffect</strong> hook</p>
			<p>To keep track of effects, React creates<a id="_idIndexMarker193"/> an <strong class="source-inline">updateQueue</strong> property under a fiber of the <strong class="source-inline">UpdateQueue</strong> type (as illustrated in <em class="italic">Figure 5.2</em>). Inside this queue, a list of effects is stored under the <strong class="source-inline">lastEffect</strong> property. Effects are linked together using a circular linked list (see <em class="italic">Figure 5.3</em>), similar to the pending queue that we see in <strong class="source-inline">useState</strong>: </p>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="image/Figure_5.03_B17963.jpg" alt="Figure 5.3 – A fiber's update queue for useEffect&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.3 – A fiber's update queue for useEffect</p>
			<p>Each effect in the list, it stores the effect function in the <strong class="source-inline">create</strong> property and the cleanup function in the <strong class="source-inline">destro<a id="_idTextAnchor164"/>y</strong> property. </p>
			<p>The <strong class="source-inline">useEffect</strong> hook follows a typical hook setup where it takes the path of either <strong class="source-inline">mountEffect</strong> or <strong class="source-inline">updateEffect</strong>, depending on whether the fiber is under mount or update, via the <strong class="source-inline">isFiberMounting</strong> flag (as explained in <a href="B17963_03_Epub.xhtml#_idTextAnchor080"><em class="italic">Chapter 3</em></a>, <em class="italic">Hooking into React</em>).</p>
			<p class="source-code"><strong class="bold">function</strong> useEffect(create, deps) {</p>
			<p class="source-code">  <strong class="bold">if</strong> (isFiberMounting) {</p>
			<p class="source-code">    mountEffect(create, deps)</p>
			<p class="source-code">  } </p>
			<p class="source-code">  <strong class="bold">else</strong> {</p>
			<p class="source-code">    updateEffect(create, deps)</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">useEffect</strong> hook takes the <strong class="source-inline">create</strong> function<a id="_idIndexMarker194"/> as well as the <strong class="source-inline">deps</strong> array and it does not retu<a id="_idTextAnchor165"/>rn any value.</p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor166"/>Mounting an effect</h2>
			<p>When the component is under<a id="_idIndexMarker195"/> mount, the <strong class="source-inline">mountEffect</strong> function first creates a hook:</p>
			<p class="source-code"><strong class="bold">function</strong> mountEffect(create, deps) {</p>
			<p class="source-code">  <strong class="bold">const</strong> hook = mountHook()</p>
			<p class="source-code">  hook.state = pushEffect(</p>
			<p class="source-code">    create,</p>
			<p class="source-code">    <strong class="bold">undefined</strong>,</p>
			<p class="source-code">    deps,</p>
			<p class="source-code">  )</p>
			<p class="source-code">}</p>
			<p>Once it gets a hook, it stores the effect under the hook's <strong class="source-inline">state</strong>. The effect is created with the <strong class="source-inline">pushEffect</strong> function:</p>
			<p class="source-code"><strong class="bold">function</strong> pushEffect(create, destroy, deps) {</p>
			<p class="source-code">  <strong class="bold">const</strong> effect = {</p>
			<p class="source-code">    create,</p>
			<p class="source-code">    destroy,</p>
			<p class="source-code">    deps,</p>
			<p class="source-code">    next: <strong class="bold">null</strong>,</p>
			<p class="source-code">  }</p>
			<p class="source-code">  <strong class="bold">let</strong> queue =  updatingFiber.updateQueue </p>
			<p class="source-code">  <strong class="bold">if</strong> (queue === <strong class="bold">null</strong>) {</p>
			<p class="source-code">    queue = { lastEffect: <strong class="bold">null</strong> }</p>
			<p class="source-code">    updatingFiber.updateQueue = queue</p>
			<p class="source-code">    queue.lastEffect = effect.next = effect</p>
			<p class="source-code">  } </p>
			<p class="source-code">  <strong class="bold">else</strong> { …</p>
			<p class="source-code">    queue.lastEffect = effect</p>
			<p class="source-code">  }</p>
			<p class="source-code">  <strong class="bold">return</strong> effect</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">pushEffect</strong> function creates an effect with all of the effect information, such as <strong class="source-inline">create</strong>, <strong class="source-inline">destroy</strong>, <strong class="source-inline">deps</strong>, and <strong class="source-inline">next</strong>. Then, it finds the <strong class="source-inline">updateQueue</strong> function under the currently updating fiber. If the queue is empty, the new effect gets attached. Otherwise, the new effect is appended to<a id="_idIndexMarker196"/> the queue. Either way, it appends the new effect as the <strong class="source-inline">lastEffect</strong> object in the queue. Since it's a circular linked list, after all of the previous pointer operations have taken place, it makes sure the <strong class="source-inline">lastEffect.next</strong> object still points to the first effe<a id="_idTextAnchor167"/>ct in the list.</p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor168"/>Updating an effect</h2>
			<p>After the component is mounted, the next<a id="_idIndexMarker197"/> time it gets updated and reaches in the <strong class="source-inline">useEffect</strong> hook, it goes into <strong class="source-inline">updateEffect</strong> and gets the hook by cloning one:</p>
			<p class="source-code"><strong class="bold">function</strong> updateEffect(create, deps) {</p>
			<p class="source-code">  <strong class="bold">const</strong> hook = updateHook()</p>
			<p class="source-code">  <strong class="bold">let</strong> destroy = <strong class="bold">undefined</strong></p>
			<p class="source-code">  <strong class="bold">const</strong> prevEffect = hook.state</p>
			<p class="source-code">  destroy = prevEffect.destroy</p>
			<p class="source-code">  <strong class="bold">if</strong> (deps) {</p>
			<p class="source-code">    <strong class="bold">const</strong> prevDeps = prevEffect.deps</p>
			<p class="source-code">    <strong class="bold">if</strong> (areDepsEqual(deps, prevDeps)) {</p>
			<p class="source-code">      <strong class="bold">return</strong></p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">  hook.state = pushEffect(</p>
			<p class="source-code">    create,</p>
			<p class="source-code">    destroy,</p>
			<p class="source-code">    deps,</p>
			<p class="source-code">  )</p>
			<p class="source-code">}</p>
			<p>Once we have the hook, we can check the previous effect set in the mount and compare whether the <strong class="source-inline">deps</strong> array has changed. If the <strong class="source-inline">deps</strong> array hasn't changed from the <strong class="source-inline">prevDeps</strong> object stored in <strong class="source-inline">prevEffect</strong>, it returns without pushing the effect to <strong class="source-inline">updateQueue</strong>.</p>
			<p>A utility function called <strong class="source-inline">areDepsEqual</strong> is used to compare the current and previous dependency arrays. We will examine<a id="_idIndexMarker198"/> this function in detail in the <em class="italic">Creating effects</em> section later in this chapter. </p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor169"/>Scheduling effects</h2>
			<p>There's something very special<a id="_idIndexMarker199"/> about effects: effects are pushed into <strong class="source-inline">queue</strong> under each fiber, but they are scheduled around the time the screen is about to change.</p>
			<p>For each effect, there are two callback functions that need to be scheduled: one is <strong class="source-inline">create</strong> and one is <strong class="source-inline">destroy</strong>. Taking <strong class="source-inline">create</strong> as an example, each <strong class="source-inline">create</strong> function is collected into a list via the <strong class="source-inline">enqueueEffect</strong> function:</p>
			<p class="source-code"><strong class="bold">function</strong> enqueueEffect(fiber, effect) {</p>
			<p class="source-code">  effectCreateList.push(effect)</p>
			<p class="source-code">  <strong class="bold">if</strong> (!rootDoesHaveEffects) {</p>
			<p class="source-code">    rootDoesHaveEffects = <strong class="bold">true</strong></p>
			<p class="source-code">    scheduleCallback(() <strong class="bold">=&gt;</strong> { flushEffects() })</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>The preceding <strong class="source-inline">enqueueEffect</strong> function takes the fiber and the effect and pushes it into the <strong class="source-inline">effectsCreateList</strong> array. It then schedules the <strong class="source-inline">flushEffects</strong> callback. The reason why the array doesn't get processed (or flushed out) the right away is that it has to wait until the end of the update. Here, React uses a global flag (<strong class="source-inline">rootDoesHaveEffects</strong>) to make sure it only triggers this schedule once.</p>
			<p>The same process happens to each <strong class="source-inline">destroy</strong> function as well. For each update, we end up with two lists of effects: one for <strong class="source-inline">effectCreateList</strong> and one for <strong class="source-inline">effectDestroyList</strong>. Although similar, these two lists don't necessarily contain the same list of effects because some effects don't have the <strong class="source-inline">destroy</strong> callback. Moreover, when the component gets unmounted, the <strong class="source-inline">destroy</strong> callback needs to be added to <strong class="source-inline">effectDestroyList</strong>. </p>
			<p>The <strong class="source-inline">scheduleCallback</strong> function is quite interesting. Instead of flushing and executing the effects right away, it does this a bit later, just like an asynchronous task in a new <strong class="bold">JavaScript</strong> task. If you are interested in the details of this, please refer to the <em class="italic">Appendix B – Flushing passive effects</em> section at the end of this chapter.</p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor170"/>Flushing effects</h2>
			<p>It is only after the screen has been updated with the DOM<a id="_idIndexMarker200"/> changes that React can visit the effects lists again:</p>
			<p class="source-code"><strong class="bold">function</strong> flushEffects() {</p>
			<p class="source-code">  effectDestroyList.forEach(effect <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    <strong class="bold">const</strong> destroy = effect.destroy</p>
			<p class="source-code">    effect.destroy = undefined</p>
			<p class="source-code">    <strong class="bold">if</strong> (typeof destroy <strong class="bold">===</strong> 'function') {</p>
			<p class="source-code">      destroy()</p>
			<p class="source-code">    }</p>
			<p class="source-code">  })</p>
			<p class="source-code">  ...</p>
			<p class="source-code">}</p>
			<p>The preceding code goes over <strong class="source-inline">effectDestroyList</strong>, and each <strong class="source-inline">destroy</strong> function found, it gets invoked. After all of the <strong class="source-inline">destroy</strong> functions have been invoked, React flushes<a id="_idIndexMarker201"/> out the effects list for <strong class="source-inline">create</strong>:</p>
			<p class="source-code"><strong class="bold">function</strong> flushEffects() {</p>
			<p class="source-code">  ...</p>
			<p class="source-code">  effectCreateList.forEach(effect <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    <strong class="bold">const</strong> create = effect.create</p>
			<p class="source-code">    effect.destroy = create()</p>
			<p class="source-code">  })  </p>
			<p class="source-code">}</p>
			<p>In the preceding code, <strong class="source-inline">effectCreateList</strong> gets flushed out by invoking the <strong class="source-inline">create</strong> function under each <strong class="source-inline">effect</strong> object. The result of the <strong class="source-inline">create</strong> function is then taken as the <strong class="source-inline">destroy</strong> function. </p>
			<p>Notice the order in which React goes through both lists – it starts with <strong class="source-inline">destroy</strong> and then goes to <strong class="source-inline">create</strong>. Since both lists are collected from all of the fibers, there's a chance that the <strong class="source-inline">create</strong> function could contain a reference to a variable of a component that is going to be destroyed or cleaned up. In order to give the <strong class="source-inline">create</strong> function a chance to be fully aware of this situation, <strong class="source-inline">destroy</strong> functions need to be called before this happens. In short, all previous effects need to be cleaned up before new effe<a id="_idTextAnchor171"/>c<a id="_idTextAnchor172"/>ts<a id="_idIndexMarker202"/> can be considered.</p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor173"/>A walk-through of the useEffect hook</h2>
			<p>This is hard work, and we have just gone through a stripped-down version of the <strong class="source-inline">useEffect</strong> hook's source code. To help us understand this from a higher level, the following diagram<a id="_idIndexMarker203"/> outlines the <strong class="source-inline">useEffect</strong> hook in terms<a id="_idIndexMarker204"/> of the effects workflow in React (see <em class="italic">Figure 5.4</em>):</p>
			<div>
				<div id="_idContainer042" class="IMG---Figure">
					<img src="image/Figure_5.04_B17963.jpg" alt="Figure 5.4 – The useEffect hook and the React effects workflow&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.4 – The useEffect hook and the React effects workflow</p>
			<p>Let's do a quick run-through of <em class="italic">Figure 5.4</em>. In an update, as a <strong class="source-inline">useEffect</strong> hook is invoked, if the component is under mount, it creates the effect. If the component is under update, it creates the effect depending on whether there are any dependency changes. If there's no change to the dependency array, the effect is skipped. In all cases when the effect is created, it gets appended to the fiber's <strong class="source-inline">updateQueue</strong> and stored under the hooks' <strong class="source-inline">state</strong>.</p>
			<p>Right before the screen update, React takes all of the effects from all of the fibers and schedules a flush (denoted by the dotted line in <em class="italic">Figure 5.4</em>). After all of the fiber changes are applied to the DOM, React flushes<a id="_idIndexMarker205"/> them out by invoking them one by one, starting<a id="_idIndexMarker206"/> with the previous <strong class="source-inline">destroy</strong> effects and following them wit<a id="_idTextAnchor174"/>h the new <strong class="source-inline">create</strong> effects.</p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor175"/>Creating effects</h1>
			<p>An effect can be skipped. As a matter of fact, an effect needs to be created in an update for it to take effect. This behavior<a id="_idIndexMarker207"/> is captured by a dependency array called <strong class="source-inline">deps</strong>. React uses a utility function called <strong class="source-inline">areDepsEqual</strong> to help decide whetherthis array changes. Let's take a closer look at this function:</p>
			<p class="source-code"><strong class="bold">function</strong> areDepsEqual(deps, prevDeps) {</p>
			<p class="source-code">  <strong class="bold">if</strong> (!prevDeps) {</p>
			<p class="source-code">    <strong class="bold">return</strong> <strong class="bold">false</strong></p>
			<p class="source-code">  }</p>
			<p class="source-code">  <strong class="bold">for</strong> (<strong class="bold">let</strong> i = 0; </p>
			<p class="source-code">       i &lt; prevDeps.length &amp;&amp; i &lt; nextDeps.length; </p>
			<p class="source-code">       i++)</p>
			<p class="source-code">  {</p>
			<p class="source-code">    <strong class="bold">if</strong> (Object.is(deps[i], prevDeps[i])) {</p>
			<p class="source-code">      <strong class="bold">continue</strong></p>
			<p class="source-code">    }</p>
			<p class="source-code">    <strong class="bold">return</strong> <strong class="bold">false</strong></p>
			<p class="source-code">  }</p>
			<p class="source-code">  <strong class="bold">return</strong> <strong class="bold">true</strong></p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">areDepsEqual</strong> function is used to compare two dependency<a id="_idIndexMarker208"/> arrays between the previous <strong class="source-inline">prevDeps</strong> array and the current <strong class="source-inline">deps</strong> array and returns <strong class="source-inline">true</strong> if all of the elements match. Though this sounds easy to carry out, it can run into various scenarios depending on the elements of the dependency arrays. We'll explain all of the scenarios in the following list:</p>
			<ul>
				<li><strong class="bold">No dependency</strong>:<p>This is the default<a id="_idIndexMarker209"/> case for when <strong class="source-inline">prevDeps</strong> is not provided and the usage omits the array:</p><p class="source-code">  useEffect(fn) </p><p>When this happens, the <strong class="source-inline">areDepsEqual</strong> function always returns <strong class="source-inline">false</strong>, and so the effect gets created in each update.</p></li>
				<li><strong class="bold">Empty dependency</strong>:<p>When a dependency array is provided but with no elements in it – this means the effect doesn't depend on anything: </p><p class="source-code">  useEffect(fn, [])</p><p>In the case of an empty dependency, it makes <strong class="source-inline">areDepsEqual</strong> return <strong class="source-inline">true</strong> for all updates except<a id="_idIndexMarker210"/> the first one because, for the mount, the <strong class="source-inline">deps</strong> array still is considered to be changed from <strong class="source-inline">undefined</strong>. Therefore, the effect gets created once and after this, it does not get created anymore.</p></li>
				<li><strong class="bold">Some dependencies</strong>:<p>When the elements of <strong class="source-inline">deps</strong> are not empty, each element between the previous and current<a id="_idIndexMarker211"/> dependencies performs an <strong class="source-inline">Object.is</strong> comparison. We have already discussed the <strong class="source-inline">Object.is</strong> function in detail in <a href="B17963_04_Epub.xhtml#_idTextAnchor113"><em class="italic">Chapter 4</em></a>, <em class="italic">Use State to</em><em class="italic"> Jumpstart Components</em>. Here, each element pair goes through this comparison to determine whether the array changes:</p><p class="source-code">  useEffect(fn, [a, b])</p><p>Other than the mount, if any of the elements change, such as <strong class="source-inline">a</strong> <a id="_idTextAnchor176"/>or <strong class="source-inline">b</strong>, the effect gets created.</p></li>
			</ul>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor177"/>Creating and destroying</h2>
			<p>If a <strong class="source-inline">destroy</strong> function is given from the effect <strong class="source-inline">create</strong> function, this case also needs to be taken into consideration. Remember, we have two separate arrays keeping track of both mounted and unmounted cases. In general, the <strong class="source-inline">destroy</strong> function is invoked before<a id="_idIndexMarker212"/> the <strong class="source-inline">create</strong> function is invoked.  </p>
			<p>So, here's a quick list to summarize all of these cases.</p>
			<ul>
				<li>It runs <strong class="source-inline">create</strong> once after the mount.</li>
				<li>For any <strong class="source-inline">deps</strong> changes, it runs <strong class="source-inline">destroy</strong> and <strong class="source-inline">create</strong> once.</li>
				<li>It runs <strong class="source-inline">destroy</strong> once after the unmount.</li>
				<li>If the <strong class="source-inline">destroy</strong> function is not provided, this process reduces to a single case below.</li>
				<li>It runs for any <strong class="source-inline">deps</strong> change, including the mount.</li>
			</ul>
			<p>Now that we have gone through the <strong class="source-inline">useEffect</strong> hook's design as well as all of the scenarios of invoking the callback, let's take the <a id="_idTextAnchor178"/><strong class="source-inline">useEffect</strong> hook for a test drive.</p>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor179"/>Test driving the useEffect hook</h1>
			<p>The effect callback<a id="_idIndexMarker213"/> is defined in the <strong class="source-inline">useEffect</strong> hook's first input argument:</p>
			<p class="source-code"><strong class="bold">function</strong> Title() {</p>
			<p class="source-code">  useEffect(() <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    window.title = "" </p>
			<p class="source-code">  })  </p>
			<p class="source-code">}</p>
			<p>The most common<a id="_idIndexMarker214"/> way of using the <strong class="source-inline">create</strong> function can be defined by using the <strong class="bold">JavaScript</strong> <strong class="bold">ES6</strong> syntax with an inline function, (<strong class="source-inline">() =&gt; {}</strong>). For readers interested in learning more about <em class="italic">JavaScript ES6</em>, please see the Embracing <em class="italic">JavaScript ES6</em> section in <a href="B17963_10_Epub.xhtml#_idTextAnchor363"><em class="italic">Chapter 10</em></a>, <em class="italic">Building a Website with React</em>.</p>
			<p>One of the interesting facts about this effect function is that, thanks to JavaScript <em class="italic">closures</em>, it can access all of the variables defined in the functional component: </p>
			<p class="source-code"><strong class="bold">function</strong> Title({ text }) {</p>
			<p class="source-code">  <strong class="bold">const</strong> a = 2</p>
			<p class="source-code">  useEffect(() <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">     console.log(a)</p>
			<p class="source-code">     console.log(text)</p>
			<p class="source-code">  })</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">create</strong> callback function in the preceding code references both the <strong class="source-inline">a</strong> variable and <strong class="source-inline">text</strong>. Without the JavaScript closure, both variables would have to be passed into the inline function through the input arguments explicitly. </p>
			<p>Another interesting fact about the <strong class="source-inline">useEffect</strong> hook is that the effect is a callback where it's quite common to see an effect involving a state changed inside. Let's take a look at one example:</p>
			<div>
				<div id="_idContainer043" class="IMG---Figure">
					<img src="image/Figure_5.05_B17963.jpg" alt="Figure 5.5 – A button with clickable text&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.5 – A button with clickable text</p>
			<p>Let's say we have a <strong class="source-inline">Title</strong> component that gets a <strong class="source-inline">text</strong> prop. Inside, it has a button. When this gets clicked, it can increment a <strong class="source-inline">count</strong> state. Initially, the <strong class="source-inline">count</strong> value is set to <strong class="source-inline">0</strong>, and whenever the <strong class="source-inline">text</strong> prop changes, it can reset the <strong class="source-inline">count</strong> value back to <strong class="source-inline">0</strong>. Notice that the user clicking and the <strong class="source-inline">text</strong> prop change could be entirely unrelated and driven by different<a id="_idIndexMarker215"/> mechanisms. The former comes from the user action, whereas the latter comes from the change from the parent components::</p>
			<p class="source-code"><strong class="bold">const</strong> Title = ({ text }) <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> [count, setCount] = useState(0)</p>
			<p class="source-code">     useEffect(() <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    setCount(0)</p>
			<p class="source-code">  }, [text])</p>
			<p class="source-code">  </p>
			<p class="source-code">  <strong class="bold">const</strong> onClick = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    setCount(count + 1)</p>
			<p class="source-code">  }</p>
			<p class="source-code">  </p>
			<p class="source-code">  <strong class="bold">  console.log('count', count)</strong></p>
			<p class="source-code"><strong class="bold">    return (</strong></p>
			<p class="source-code">    <strong class="bold">&lt;button</strong> onClick={onClick}<strong class="bold">&gt;</strong></p>
			<p class="source-code">      {text}: {count}</p>
			<p class="source-code">    <strong class="bold">&lt;/button&gt;</strong></p>
			<p class="source-code">  )</p>
			<p class="source-code">}</p>
			<p>To implement the described behavior, we apply <strong class="source-inline">useEffect</strong> to dispatch <strong class="source-inline">setCount</strong> with the <strong class="source-inline">deps</strong> <a id="_idIndexMarker216"/>array set to the <strong class="source-inline">text</strong> prop. The following code example shows the timeline sketch for two clicks and one text change from the <strong class="source-inline">a</strong> letter to the <strong class="source-inline">b</strong> letter:</p>
			<p class="source-code">|-----x-----x------------&gt; click</p>
			<p class="source-code">a-----------------b------&gt; text</p>
			<p class="source-code">R-----R-----R-----RR-----&gt; update </p>
			<p class="source-code">0-----1-----2-----20-----&gt; count</p>
			<p>As the mount starts, the first update starts with the text as <strong class="source-inline">a</strong> and the <strong class="source-inline">count</strong> as <strong class="source-inline">0</strong>. It also creates an effect, but since the <strong class="source-inline">count</strong> value is already <strong class="source-inline">0</strong>, the <strong class="source-inline">setCount</strong> dispatch is skipped. </p>
			<p>As the user makes the first click, the <strong class="source-inline">onClick</strong> event handler is invoked, therefore setting <strong class="source-inline">count</strong> to <strong class="source-inline">1</strong>. The same applies to the second click in order to arrive at the <strong class="source-inline">count</strong> value of <strong class="source-inline">2</strong>. When the parent component changes the <strong class="source-inline">text</strong> prop from <strong class="source-inline">a</strong> to <strong class="source-inline">b</strong>, it raises another update. </p>
			<p>In the same update, the unchanged <strong class="source-inline">count</strong> value is printed out again. But this time, the dependency array of <strong class="source-inline">useEffect</strong> detects the change due to <strong class="source-inline">[text]</strong>. Therefore, it creates an effect to invoke <strong class="source-inline">setCount(0)</strong>. As we know that the <strong class="source-inline">setCount</strong> schedules another update, it will bring the <strong class="source-inline">count</strong> back to <strong class="source-inline">0</strong> afterward.</p>
			<p class="callout-heading">Playground – Button with parent text</p>
			<p class="callout">Feel free to play with this example online at <a href="https://codepen.io/windmaomao/pen/rNGOVor">https://codepen.io/windmaomao/pen/rNGOVor</a>.</p>
			<p>Wow! This is how <strong class="source-inline">useEffect</strong> works. By using <strong class="source-inline">setState</strong> inside the callback, an additional update can be requested to update the screen. So, the effect takes effect in a different update. Also, to make the effect work, the <strong class="source-inline">deps</strong> array needs to be wired with the right state change because if we miss it, the effect<a id="_idIndexMarker217"/> can be stalled. Let's t<a id="_idTextAnchor180"/>ake a look at one example when this happens. </p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor181"/>Missing dependencies</h2>
			<p>Let's go back<a id="_idIndexMarker218"/> to a simple setup:</p>
			<p class="source-code"><strong class="bold">const</strong> Title = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> [count, setCount] = useState(0)</p>
			<p class="source-code">  </p>
			<p class="source-code">  useEffect(() <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    console.log(count)</p>
			<p class="source-code">  }, [])</p>
			<p class="source-code">}</p>
			<p>If you intend to print out <strong class="source-inline">count</strong> every time it changes, the preceding code misses the right dependency – the correct one should be <strong class="source-inline">[count]</strong> instead of <strong class="source-inline">[]</strong>.</p>
			<p>If this example<a id="_idIndexMarker219"/> is too obvious, let's try a less obvious one:</p>
			<p class="source-code"><strong class="bold">const</strong> Title = ({ text }) <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> [count, setCount] = useState(0)</p>
			<p class="source-code">  </p>
			<p class="source-code">  useEffect(() <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    console.log(text + count)</p>
			<p class="source-code">  }, [text])</p>
			<p class="source-code">}</p>
			<p>In the preceding code, we introduce a <strong class="source-inline">text</strong> prop and put it in the <strong class="source-inline">deps</strong> array. In this case, what we get is that when the <strong class="source-inline">text</strong> changes, it prints out <strong class="source-inline">text + count</strong>. However, if the <strong class="source-inline">count</strong> value changes due to a user's click, the screen wouldn't change. To fix this, we can add the <strong class="source-inline">count</strong> value to the dependency array:</p>
			<p class="source-code">  useEffect(() <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    console.log(text + count)</p>
			<p class="source-code">  }, [count, text])</p>
			<p>A pattern seems to emerge here – if an effect callback uses a variable, that variable needs to be in the <strong class="source-inline">deps</strong> array. This statement is practically 99.9% true. If you intentionally do not want to update the screen when a variable changes, you can skip adding it to the<a id="_idIndexMarker220"/> dependency array. However, this is not recommended by React. React<a id="_idIndexMarker221"/> even adds an <strong class="bold">ESLint</strong> plugin (<strong class="source-inline">eslint-plugin-react-hooks</strong>) to help us spot the cases where we have missed a potential dependency.</p>
			<p>You might wonder why React doesn't want us to miss any dependencies. This is because in React, every value (or state) should be in-sync with the current screen and there can't be exceptions to this rule by default.. In <a href="B17963_08_Epub.xhtml#_idTextAnchor278"><em class="italic">Chapter 8</em></a>, <em class="italic">Use Ref to Hide Stuff</em>, we will show you a recommended way if you insist on keeping things hidden from React.</p>
			<p>Now that we have seen cases that have used both effects and states , let's take a look at another example of when we might run into problems with them.</p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor182"/>Infinite loops</h2>
			<p>Combining <em class="italic">state </em>and <em class="italic">effects</em> can cause another interesting problem because an effect can change a state and therefore schedule a new update, and then the new update can create a new effect and change<a id="_idIndexMarker222"/> a state, and this can continue indefinitely. This could lead to an <em class="italic">infinite loop</em>.</p>
			<p>We can demonstrate this with a quick example:</p>
			<p class="source-code"><strong class="bold">function</strong> Title() {</p>
			<p class="source-code">  <strong class="bold">const</strong> [count, setCount] = useState(0)</p>
			<p class="source-code">  useEffect(() <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    setCount(count+1)</p>
			<p class="source-code">  }, [count])</p>
			<p class="source-code">  <strong class="bold">return &lt;h1&gt;</strong>{count}<strong class="bold">&lt;/h1&gt;</strong></p>
			<p class="source-code">}</p>
			<p>In the preceding code, there's an effect that increments a <strong class="source-inline">count</strong> state after any <strong class="source-inline">count</strong> change. After invoking <strong class="source-inline">setCount</strong>, in the next update, <strong class="source-inline">useEffect</strong> would detect a change from the dependency array and thereby invoke <strong class="source-inline">setCount</strong> again. Because every time this happens we get a new <strong class="source-inline">count</strong> number, this process wouldn't stop, as you can see in the following timeline sketch:</p>
			<p class="source-code">RRRRRRRRRR&gt; update </p>
			<p class="source-code">0123456789&gt; count</p>
			<p>Normally, we wouldn't do this intentionally, but we can accidentally run into exactly this scenario in a more complex setup, especially when many different states and effects are involved. It's our job to avoid an infinite loop whenever possible since this isn't accounted for by React.</p>
			<p>So, how do we deal with an infinite loop in code? We can break out of a loop with an <strong class="source-inline">if</strong> statement, and this is normally the most cost-effective<a id="_idIndexMarker223"/> approach:</p>
			<p class="source-code">  useEffect(() <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    <strong class="bold">if</strong> (count &gt;= 1) <strong class="bold">return</strong></p>
			<p class="source-code">    setCount(count+1)</p>
			<p class="source-code">  }, [count])</p>
			<p>In the preceding code, after we add the <strong class="source-inline">if</strong> statement on the first line inside the effect, the timeline confirms that we don't have an infinite loop any<a id="_idTextAnchor183"/>more:</p>
			<p class="source-code">RR--------&gt; update </p>
			<p class="source-code">01--------&gt; count</p>
			<p>As you can see, it's not too difficult to break out of a loop. You can think of this as an equilibrium state that you want to reach – the effect does need to be triggered for a state change, but once an equilibrium state is reached,<a id="_idIndexMarker224"/> it stops without continuing the loop.</p>
			<p>Now that we have gone over how <strong class="source-inline">useEffect</strong> is used, let's take a look at two practical cases for applying it.</p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor184"/>useEffect examples</h1>
			<p>The <strong class="source-inline">useEffect</strong> hook is normally used for any side effect – whether that is to read from an external object<a id="_idIndexMarker225"/> or write to an external object. In the following<a id="_idIndexMarker226"/> sections, we are going to see two more examples: <em class="italic">Finding the window size</em> and <em class="italic">Fet<a id="_idTextAnchor185"/>ching an API resource</em>.</p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor186"/>Finding the window size</h2>
			<p>Let's say that we want<a id="_idIndexMarker227"/> to know the current browser window size at runtime<a id="_idIndexMarker228"/> so that a greeting title can fit perfectly onto the screen (see <em class="italic">Figure 5.6</em>):</p>
			<div>
				<div id="_idContainer044" class="IMG---Figure">
					<img src="image/Figure_5.06_B17963.jpg" alt="Figure 5.6 – Finding the window size&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.6 – Finding the window size</p>
			<p>This can be done normally with a <strong class="bold">CSS</strong> media query, but this time, we want to do it via <em class="italic">JavaScript</em>, as a runtime <em class="italic">JavaScript</em> variable obtained can be sent for purposes other than CSS usage:</p>
			<p class="source-code"><strong class="bold">const</strong> Greeting = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> [width, setWidth] = useState(0)</p>
			<p class="source-code">  </p>
			<p class="source-code">  useEffect(() <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    <strong class="bold">function</strong> handleResize() {</p>
			<p class="source-code">      setWidth(window.innerWidth)</p>
			<p class="source-code">    }    </p>
			<p class="source-code">    window.addEventListener("resize", handleResize)</p>
			<p class="source-code">    handleResize()</p>
			<p class="source-code">   </p>
			<p class="source-code">    <strong class="bold">return</strong> () <strong class="bold">=&gt;</strong> { </p>
			<p class="source-code">      window.removeEventListener("resize", handleResize)</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }, [setWidth])  </p>
			<p class="source-code">  <strong class="bold">const</strong> on = width &gt; 600</p>
			<p class="source-code">  <strong class="bold">return</strong> <strong class="bold">&lt;h1&gt;</strong>{on ? "Hello World" : "Hello"}<strong class="bold">&lt;/h1&gt;</strong></p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">useEffect</strong> hook is a good fit here. After the component is mounted, we can listen for a <strong class="source-inline">resize</strong> event provided by the <strong class="source-inline">window</strong> object. Once it starts to listen to the event, every time the window resizes, it kicks off a <strong class="source-inline">handleResize</strong> function that sets the <strong class="source-inline">width</strong> state to the new<a id="_idIndexMarker229"/> window size. We also invoke <strong class="source-inline">handleResize</strong> at the mount<a id="_idIndexMarker230"/> to get the initial window size.</p>
			<p>In this example, if the current width is greater than 600 px, we know that it can fit the <strong class="source-inline">Hello World</strong> string on screen. Otherwise, the <strong class="source-inline">Hello</strong> string will be used. This shows that we can control the display based on the window size on the fly with J<em class="italic">avaScript. </em></p>
			<p class="callout-heading">Playground – Finding the Window Size</p>
			<p class="callout">Feel free to play with this online example at <a href="https://codepen.io/windmaomao/pen/BadRoNN">https://codepen.io/windmaomao/pen/BadRoNN</a>.</p>
			<p>In order to prevent a memory leak, we return a <strong class="source-inline">destroy</strong> function from the <strong class="source-inline">useEffect</strong> callback where the registered event listener is removed when the component is unmounted. </p>
			<p>There's a subtle detail to be aware of here – the dependency array has <strong class="source-inline">setWidth</strong> in it because we reference <strong class="source-inline">setWidth</strong> inside the <strong class="source-inline">useEffect</strong> function. If you remember from <a href="B17963_04_Epub.xhtml#_idTextAnchor113"><em class="italic">Chapter 4</em></a>, <em class="italic">Use State to Jumpstart Components</em>, we know the <strong class="source-inline">setWidth</strong> function instance doesn't get changed after the mount, so actually, <strong class="source-inline">[setWidth]</strong> can be optional here. But React insists that we add this because when <strong class="source-inline">setWidt<a id="_idTextAnchor187"/>h</strong> changes, the effect needs to be re-created. </p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor188"/>Fetching an API resource</h2>
			<p>One popular use<a id="_idIndexMarker231"/> of <strong class="source-inline">useEffect</strong> is to fetch an API resource<a id="_idIndexMarker232"/> and display the data on screen: </p>
			<div>
				<div id="_idContainer045" class="IMG---Figure">
					<img src="image/Figure_5.07_B17963.jpg" alt="Figure 5.7 – Fetching an API resource, loading status&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.7 – Fetching an API resource, loading status</p>
			<p>The idea here is to use the <strong class="source-inline">fetch</strong> JavaScript function to get the resource. During loading, the screen should say <strong class="source-inline">loading...</strong> (as in <em class="italic">Figure 5.7</em>). And after the resource is successfully fetched, the <strong class="source-inline">loading...</strong>  string should be dismissed and replaced with the fetched text on the screen:</p>
			<p class="source-code"><strong class="bold">const</strong> Title = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> [text, setText] = useState("")</p>
			<p class="source-code">  <strong class="bold">const</strong> [loading, setLoading] = useState(<strong class="bold">true</strong>)</p>
			<p class="source-code">  useEffect(() <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    fetch("https://google.com").then(res <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">      setText(res.title)</p>
			<p class="source-code">      setLoading(<strong class="bold">false</strong>)</p>
			<p class="source-code">    })</p>
			<p class="source-code">  }, [setText, setLoading])</p>
			<p class="source-code">  <strong class="bold">if</strong> (loading) <strong class="bold">return</strong> "loading..."</p>
			<p class="source-code">  <strong class="bold">return</strong> (<strong class="bold">&lt;h1&gt;</strong>{text}<strong class="bold">&lt;/h1&gt;</strong>)</p>
			<p class="source-code">}</p>
			<p>In the preceding code, we use a <strong class="source-inline">text</strong> state to store the fetched text and a state <strong class="source-inline">loading</strong> flag to store the loading status. A <strong class="source-inline">useEffect</strong> hook is used to fetch the resource and when it's successful, it updates the <strong class="source-inline">text</strong> and <strong class="source-inline">loading</strong> flag. </p>
			<p class="callout-heading">Playground – Fetching an API Resource</p>
			<p class="callout">Feel free to play with this online example at <a href="https://codepen.io/windmaomao/pen/ZEJKbev">https://codepen.io/windmaomao/pen/ZEJKbev</a>.</p>
			<p>In this case, the effect doesn't return anything. There's actually a cleanup to do in this case, but we will wait until <a href="B17963_08_Epub.xhtml#_idTextAnchor278"><em class="italic">Chapter 8</em></a>, <em class="italic">Use Ref to Hide Stuff</em>,to explore that in detail.</p>
			<p>Notice that an <strong class="source-inline">if</strong> statement is used before the <strong class="source-inline">return</strong> statement. In <a href="B17963_03_Epub.xhtml#_idTextAnchor080"><em class="italic">Chapter 3</em></a>, <em class="italic">Hooking into React</em>, we mentioned that <strong class="source-inline">if</strong> cannot be used in between hook statements. So, in this case, we move it after all of the hook statements and put it right before the last return statement. </p>
			<p>In this case, the <strong class="source-inline">if</strong> statement acts as a short-circuit. If the <strong class="source-inline">loading</strong> status is <strong class="source-inline">true</strong>, it does not go any further other than returning a <strong class="source-inline">loading...</strong> string. This <strong class="source-inline">if</strong> statement approach is one of the most cost-effective<a id="_idIndexMarker233"/> ways to make sure th<a id="_idTextAnchor189"/>e screen<a id="_idIndexMarker234"/> only renders material when it's available. </p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor190"/>Summary</h1>
			<p>We really did a lot in this chapter. First, we got to know what a side effect is, and we dug deeper into the <strong class="source-inline">useEffect</strong> hook's design. We discovered how an effect can be created and then later invoked after a UI update. We also learned about various scenarios for creating effects based on dependency arrays. After that, we walked through the pitfalls of using <strong class="source-inline">useEffect</strong> with missing dependencies, staled values, and infinite loops. Last but not least, we learned to apply <strong class="source-inline">useEffect</strong> in practical components, such as the examples of finding the window size in a browser and fetching API resources from an online server.</p>
			<p>In the next chapter, we will discover our next hook in the React family and focus on how to apply an optimization to boos<a id="_idTextAnchor191"/>t performance by using values from a previous update.</p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor192"/>Questions and answers</h1>
			<p>Here are <a id="_idTextAnchor193"/>some questions and answers to refresh your knowledge:</p>
			<ol>
				<li>What is a side effect?<p>A side effect is when a function relies on or modifies something outside of its input arguments. A very common sid<a id="_idTextAnchor194"/>e effect is the use of <strong class="source-inline">console.log</strong> inside a function.</p></li>
				<li>What is <strong class="source-inline">useEffect</strong>?<p>The <strong class="source-inline">useEffect</strong> hook is a way of defining a side effect callback to be invoked after a screen update in React. The effect can be invoked every time or when one of its dependencies changes. Therefore, the <strong class="source-inline">useEffect</strong> h<a id="_idTextAnchor195"/>ook can be also used for listening for value changes.</p></li>
				<li>What are the most common uses of <strong class="source-inline">useEffect</strong>?<p>The <strong class="source-inline">useEffect</strong> hook is a common hook in the React family. If used along with the <strong class="source-inline">useState</strong> hook, it can easily communicate with external resources and bring results on screen. External resources can be web servers, DOM elements, <strong class="source-inline">window</strong> ob<a id="_idTextAnchor196"/>jects, <strong class="source-inline">document</strong> objects, or any third-party entities.</p></li>
			</ol>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor197"/>Appendix</h1>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor198"/>Appendix A – React side effects</h2>
			<p>When it comes to React, the most well-known effects are passive effects, as introduced and explained in detail in this chapter. However, React supports different kinds of effects, and in the future, it might add more. The two others currently are <em class="italic">mutation effects</em> and <em class="italic">layout effects</em>.</p>
			<p>All effects are shared with certain features, such as getting collected from the fibers before the screen gets updated. But they<a id="_idIndexMarker235"/> also differ in some ways. Take the <em class="italic">mutation effects</em> as a first example. Under the engine, these kind of effects are the most important effects because each mutation effect tracks the addition, removal, or change of a DOM element. Therefore, all fiber reconciliation ends up with mutation effects that get committed<a id="_idIndexMarker236"/> to the screen. The mutation of the DOM elements is also part of the update, or more accurately, the <em class="italic">commit</em> phrase of the update. While the passive effects run after the update, all mutation effects happen before the passive effects.</p>
			<p>To remedy the fact that passive effects run after the update (because by then it might be too late to perform a certain action), the <em class="italic">layout effect</em> is created to be invoked a bit earlier. Everything about the layout effect<a id="_idIndexMarker237"/> is similar to the passive effect, except it gets invoked right after the mutation effect and flushes out before the end of the update. The relationships and timing between all three kinds of effects can be summarized in the following commit stage outlined in <em class="italic">Figure 5.8</em>:</p>
			<div>
				<div id="_idContainer046" class="IMG---Figure">
					<img src="image/Figure_5.08_B17963.jpg" alt="Figure 5.8 – React effects during the commit phase&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.8 – React effects during the commit phase</p>
			<p>Note that during the commit stage, only the mutation and layout effects get flushed out.. The passive effects get scheduled initially and later enqueued, but not flushed out until after the commit. Please read on to the <em class="italic">Appendix<a id="_idTextAnchor199"/> B – Flushing passive effects</em> section for more details.</p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor200"/>Appendix B - Flushing passive effects</h2>
			<p>In order to understand how passive effects<a id="_idIndexMarker238"/> are scheduled and flushed, we need to first mention<em class="italic"> JavaScript</em> <em class="italic">tasks</em>. </p>
			<div>
				<div id="_idContainer047" class="IMG---Figure">
					<img src="image/Figure_5.09_B17963.jpg" alt="Figure 5.9 – JavaScript tasks&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.9 – JavaScript tasks</p>
			<p>In <em class="italic">Figure 5.9</em>, we can see three<em class="italic"> JavaScript</em> tasks. What is a task? A <em class="italic">task</em> is any <em class="italic">JavaScript</em> code that is scheduled<a id="_idIndexMarker239"/> to run by the standard mechanism. In the first task on the left, we finished one update. Normally, that's all we need to know about running <em class="italic">JavaScript</em> code.</p>
			<p>However, because <em class="italic">JavaScript</em><a id="_idIndexMarker240"/> is a single-thread engine, during the execution of the current task, there can be more work added to the pending queue. A typical example is a <strong class="source-inline">setTimeout</strong> call, which adds the callback to the queue instead of invoking it right away in the same task. API calls (like promises) normally fall into this category as well. This is the main reason why<a id="_idIndexMarker241"/> these callbacks are referred to as <em class="italic">asynchronous operations</em>. </p>
			<p>There's no specification for how long each task should take. When one task finishes, it looks for all the work in the pending queue and then invokes it one task at a time, and after everything is done, it looks at the pending queue again. This process repeats itself forever. This is what the<em class="italic"> JavaScript</em> engine does.</p>
			<p>In our case, we have a very short-lived task (middle task in <em class="italic">Figure 5.9</em>) followed by a third task. Guess what – this is when the flushing out of passive effects begins. From this, we can be sure that the callback in the <strong class="source-inline">useEffect</strong> callback is invoked asynchronously.</p>
			<p>We mentioned that the multiple state dispatches are also bundled and executed in a deferred way – so is a <strong class="source-inline">setState</strong> dispatch also an<a id="_idIndexMarker242"/> asynchronous call? To answer that question, please read <a id="_idTextAnchor201"/>on to the <em class="italic">Appendix C – Is a dispatch asynchronous?</em> section.</p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor202"/>Appendix C – Is a dispatch asynchronous?</h2>
			<p>Since passive effects are invoked in a new task, at this point, you might wonder whether a <strong class="source-inline">setState</strong> dispatch is run in the same task<a id="_idIndexMarker243"/> or in a new task. This is a very good question. </p>
			<p>To answer this, we need to have a reference point in time. Let's say we have an event handler, and inside it, we have a <strong class="source-inline">setState</strong> dispatch call:</p>
			<p class="source-code">  onClick = () =&gt; { setState(1) }</p>
			<p>The <strong class="source-inline">onClick</strong> event is an event that is requested as a callback via a user action. Let's say that the task that invokes the <strong class="source-inline">onClick</strong> event is called <em class="italic">Task 1</em>.</p>
			<p>In React 17 (not the current version), the <strong class="source-inline">setState</strong> code is sync, which means it runs in the same <em class="italic">Task 1</em> for the entire update. React decides it's more efficient to finish them all in the same task. So, why do we say the <strong class="source-inline">setState</strong> object is normally deferred?</p>
			<p class="source-code">  onClick = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    setState(1)</p>
			<p class="source-code">    // state value isn't changed yet</p>
			<p class="source-code">  }</p>
			<p>That's because right after <strong class="source-inline">setState</strong>, the value hasn't been changed yet. Only the next update will set the state to the new version. But calling <strong class="source-inline">setState</strong> an async operation isn't exactly accurate (if not wrong) because all of this process is performed in the same <em class="italic">JavaScript</em> task.</p>
			<p>What if we put <strong class="source-inline">setState</strong> in a <strong class="source-inline">useEffect</strong> hook? Does this passive effect change the sync or async discussion?</p>
			<p class="source-code">  useEffect = (() <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    setState(1)</p>
			<p class="source-code">  }, [])</p>
			<p>By now, we know that the <strong class="source-inline">useEffect</strong> callback gets invoked in a new <em class="italic">JavaScript</em> task – let's say this task is called <em class="italic">Task 1</em>. And<a id="_idIndexMarker244"/> the <strong class="source-inline">setState</strong> runs in the same <em class="italic">Task 1</em>. This makes it behave in quite a similar way to an event handler, such as in the case of <strong class="source-inline">onClick</strong> discussed previously. For this reason, we could also think of a passive effect as an <em class="italic">"event"</em> that is more passive than an event handler. </p>
			<p>This doesn't prevent us from making<a id="_idIndexMarker245"/> an async dispatch if we really want to. Let's take a look at one example: </p>
			<p class="source-code">  const [state, dispatch] = useState(1)</p>
			<p class="source-code">  const onClick = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    setTimeout(() <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">      dispatch(3)</p>
			<p class="source-code">    }, 0)</p>
			<p class="source-code">    dispatch(5)</p>
			<p class="source-code">  }</p>
			<p>In the preceding example, <strong class="source-inline">setTimeout</strong> is used to fire a callback in an async way. After the mouse click, <strong class="source-inline">dispatch(5)</strong> is invoked first. And after the update, <strong class="source-inline">dispatch(3)</strong> is invoked, even though the timeout duration is set to <strong class="source-inline">0</strong>. </p>
			<p>Keep in mind, if you do that, you are not only running the callback in an async way, but you also break out of the React scheduling cycle. The reason you might want to do this is that there can be conflicts during DOM changes, for example, during drag-and-drop handling. In order to finish our code before making the state change, we can push the dispatch to the next <em class="italic">JavaScript</em> task queue.</p>
		</div>
	</body></html>