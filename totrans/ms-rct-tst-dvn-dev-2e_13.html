<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer040">
<h1 class="chapter-number" id="_idParaDest-224"><a id="_idTextAnchor258"/>13</h1>
<h1 id="_idParaDest-225"><a id="_idTextAnchor259"/>Test-Driving GraphQL</h1>
<p><strong class="bold">GraphQL</strong> offers an alternative<a id="_idIndexMarker1214"/> to HTTP requests for fetching data. It offers a whole bunch of additional features that can be added to data requests.</p>
<p>As with Redux, GraphQL systems can seem complicated, but TDD helps to provide an approach to understanding and learning.</p>
<p>In this chapter, we’ll use the <strong class="bold">Relay</strong> library to connect to<a id="_idIndexMarker1215"/> our backend. We’re going to build a new <strong class="source-inline">CustomerHistory</strong> component that displays details of a single customer and their appointment history.</p>
<p>This is a bare-bones GraphQL implementation that shows the fundamentals of test-driving the technology. If you’re using other GraphQL libraries instead of Relay, the techniques we’ll explore in this chapter will also apply.</p>
<p>Here’s what the new <strong class="source-inline">CustomerHistory</strong> component looks like:</p>
<div>
<div class="IMG---Figure" id="_idContainer039">
<img alt="Figure 13.1 – The new CustomerHistory component " height="417" src="image/Figure_13.01_B18423.jpg" width="880"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.1 – The new CustomerHistory component</p>
<p>This chapter covers the following topics:</p>
<ul>
<li>Compiling the schema before you begin</li>
<li>Test-driving the Relay environment</li>
<li>Fetching GraphQL data from within a component</li>
</ul>
<p>By the end of the chapter, you’ll have explored the test-driven approach to GraphQL.</p>
<h1 id="_idParaDest-226"><a id="_idTextAnchor260"/>Technical requirements</h1>
<p>The code files for this chapter can be found here: </p>
<p><a href="https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter13">https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter13<span id="_idTextAnchor261"/></a></p>
<h1 id="_idParaDest-227"><a id="_idTextAnchor262"/>Compiling the schema before you begin</h1>
<p>The code samples<a id="_idIndexMarker1216"/> for this chapter already contain some additions:</p>
<ul>
<li>The <strong class="source-inline">react-relay</strong>, <strong class="source-inline">relay-compiler</strong>, and <strong class="source-inline">babel-plugin-relay</strong> packages.</li>
<li>Babel configuration to ensure your build understands the new GraphQL syntax.</li>
<li>Relay configuration in the <strong class="source-inline">relay.config.json</strong> file. The primary piece of configuration is the location of the schema.</li>
<li>A GraphQL schema in the file <strong class="source-inline">src/schema.graphql</strong>.</li>
<li>A server endpoint at <strong class="source-inline">POST/graphql</strong>, which services incoming GraphQL requests.</li>
</ul>
<p>It’s beyond the scope of this book to go into each of these, but you will need to compile the schema before you begin, which can be done by typing the following command:</p>
<p class="source-code">npx relay-compile<a id="_idTextAnchor263"/>r</p>
<p>The <strong class="source-inline">npm run build</strong> command has also been modified to run this command for you, just in case you forget. Once everything is compiled, you’re ready to write some tests.</p>
<h1 id="_idParaDest-228"><a id="_idTextAnchor264"/>Testing the Relay environment</h1>
<p>There are a few different ways <a id="_idIndexMarker1217"/>to approach the integration of Relay into a React <a id="_idIndexMarker1218"/>application. The method we’ll use in this book is the <strong class="source-inline">fetchQuery</strong> function, which is analogous to the <strong class="source-inline">global.fetch</strong> function we’ve already used for standard HTTP requests.</p>
<p>However, Relay’s <strong class="source-inline">fetchQuery</strong> function has a much more complicated setup than <strong class="source-inline">global.fetch</strong>. </p>
<p>One of the parameters of the <strong class="source-inline">fetchQuery</strong> function is the <em class="italic">environment</em>, and in this section, we’ll see what that is and how to construct it.</p>
<p class="callout-heading">Why Do We Need to Construct an Environment?</p>
<p class="callout">The Relay environment is an extension point where all manner of functionality can be added. Data caching is one example. If you’re interested in how to do that, check out the <em class="italic">Further reading</em> section at the end of this chapter.</p>
<p>We will build a function named <strong class="source-inline">buildEnvironment</strong>, and then another named <strong class="source-inline">getEnvironment</strong> that provides a singleton instance of this environment so that the initialization only needs to be done once. Both functions return an object of type <strong class="source-inline">Environment</strong>.</p>
<p>One of the arguments that the <strong class="source-inline">Environment</strong> constructor requires is a function named <strong class="source-inline">performFetch</strong>. This function, unsurprisingly, is the bit that actually fetches data – in our case, from the <strong class="source-inline">POST /graphql</strong> server endpoint.</p>
<p>In a separate test, we'll check whether <strong class="source-inline">performFetch</strong> is passed to the new <strong class="source-inline">Environment</strong> object. We need to treat <strong class="source-inline">performFetch</strong> as its own unit because we’re not going to be testing the behavior of the resulting environment, only its construction.</p>
<h2 id="_idParaDest-229"><a id="_idTextAnchor265"/>Building a performFetch function</h2>
<p>Let’s begin by <a id="_idIndexMarker1219"/>creating our<a id="_idIndexMarker1220"/> own <strong class="source-inline">performFetch</strong> function:</p>
<ol>
<li>Create a new file, <strong class="source-inline">test/relayEnvironment.test.js</strong>, and add the following setup. This sets up our <strong class="source-inline">global.fetch</strong> spy in the same way as usual. There are two new constants here, <strong class="source-inline">text</strong> and <strong class="source-inline">variables</strong>, which we’ll use soon:<p class="source-code">import {</p><p class="source-code">  fetchResponseOk,</p><p class="source-code">  fetchResponseError</p><p class="source-code">} from "./builders/fetch";</p><p class="source-code">import {</p><p class="source-code">  performFetch</p><p class="source-code">} from "../src/relayEnvironment";</p><p class="source-code">describe("performFetch", () =&gt; {</p><p class="source-code">  let response = { data: { id: 123 } };</p><p class="source-code">  const text = "test";</p><p class="source-code">  const variables = { a: 123 };</p><p class="source-code">  beforeEach(() =&gt; {</p><p class="source-code">    jest</p><p class="source-code">      .spyOn(global, "fetch")</p><p class="source-code">      .mockResolvedValue(fetchResponseOk(response));</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>Then, add the first test, checking that we make the appropriate HTTP request. The call to <strong class="source-inline">performFetch</strong> takes two<a id="_idIndexMarker1221"/> parameters that contain <strong class="source-inline">text</strong> (wrapped in an object) and <strong class="source-inline">variables</strong>. This mimics how the Relay environment will <a id="_idIndexMarker1222"/>call the <strong class="source-inline">performFetch</strong> function for each request:<p class="source-code">it("sends HTTP request to POST /graphql", () =&gt; {</p><p class="source-code">  performFetch({ text }, variables);</p><p class="source-code">  expect(global.fetch).toBeCalledWith(</p><p class="source-code">    "/graphql",</p><p class="source-code">    expect.objectContaining({</p><p class="source-code">      method: "POST",</p><p class="source-code">    })</p><p class="source-code">  );</p><p class="source-code">});</p></li>
<li>Create a new file, <strong class="source-inline">src/relayEnvironment.js</strong>, and make the test pass with the following code:<p class="source-code">export const performFetch = (operation, variables) =&gt;</p><p class="source-code">  global</p><p class="source-code">    .fetch("/graphql", {</p><p class="source-code">      method: "POST",</p><p class="source-code">    });</p></li>
<li>Add the second of our tests for the HTTP request dance, which ensures we pass the correct request configuration:<p class="source-code">it("calls fetch with the correct configuration", () =&gt; {</p><p class="source-code">  performFetch({ text }, variables);</p><p class="source-code">  expect(global.fetch).toBeCalledWith(</p><p class="source-code">    "/graphql",</p><p class="source-code">    expect.objectContaining({</p><p class="source-code">      credentials: "same-origin",</p><p class="source-code">      headers: { "Content-Type": "application/json" },</p><p class="source-code">    })</p><p class="source-code">  );</p><p class="source-code">});</p></li>
<li>Make that pass by <a id="_idIndexMarker1223"/>adding the two lines <a id="_idIndexMarker1224"/>highlighted here:<p class="source-code">export const performFetch = (operation, variables) =&gt;</p><p class="source-code">  global</p><p class="source-code">    .fetch("/graphql", {</p><p class="source-code">      method: "POST",</p><p class="source-code"><strong class="bold">      credentials: "same-origin",</strong></p><p class="source-code"><strong class="bold">      headers: { "Content-Type": "application/json" },</strong></p><p class="source-code">    });</p></li>
<li>Then, add the third and final test of our HTTP request dance. This one checks that we pass the right request data – the required <strong class="source-inline">text</strong> query and the <strong class="source-inline">variables</strong> argument included within it:<p class="source-code">it("calls fetch with query and variables as request body", async () =&gt; {</p><p class="source-code">  performFetch({ text }, variables);</p><p class="source-code">  expect(global.fetch).toBeCalledWith(</p><p class="source-code">    "/graphql",</p><p class="source-code">    expect.objectContaining({</p><p class="source-code">      body: JSON.stringify({</p><p class="source-code">        query: text,</p><p class="source-code">        variables,</p><p class="source-code">      }),</p><p class="source-code">    })</p><p class="source-code">  );</p><p class="source-code">});</p></li>
<li>Make that pass by defining <a id="_idIndexMarker1225"/>the <strong class="source-inline">body</strong> property for<a id="_idIndexMarker1226"/> the <strong class="source-inline">fetch</strong> request, as shown here:<p class="source-code">export const performFetch = (operation, variables) =&gt;</p><p class="source-code">  global</p><p class="source-code">    .fetch("/graphql", {</p><p class="source-code">      method: "POST",</p><p class="source-code">      headers: { "Content-Type": "application/json" },</p><p class="source-code"><strong class="bold">      body: JSON.stringify({</strong></p><p class="source-code"><strong class="bold">        query: operation.text,</strong></p><p class="source-code"><strong class="bold">        variables</strong></p><p class="source-code"><strong class="bold">      })</strong></p><p class="source-code">    });</p></li>
</ol>
<p class="callout-heading">Understanding Operation, Text, and Variables</p>
<p class="callout">The <strong class="source-inline">text</strong> property of the <strong class="source-inline">operation</strong> argument is a static piece of data that defines the query, and the <strong class="source-inline">variables</strong> argument will be the piece that is relevant to this specific request.</p>
<p class="callout">The tests we’re writing in this chapter do not go as far as checking the <em class="italic">behavior</em> of this Relay plumbing code. When writing this type of unit test, which doesn’t exercise behavior, it’s important to note that some kind of <strong class="bold">end-to-end test</strong> will be necessary. That will ensure your unit tests have the right specification.</p>
<ol>
<li value="8">The next test checks that<a id="_idIndexMarker1227"/> we return the right data from the function. Relay expects our <strong class="source-inline">performFetch</strong> function to return <a id="_idIndexMarker1228"/>a promise that will either resolve or reject. In this case, we’re resolving it to the <strong class="source-inline">fetch</strong> response:<p class="source-code">it("returns the request data", async () =&gt; {</p><p class="source-code">  const result = await performFetch(</p><p class="source-code">     { text }, variables</p><p class="source-code">  );</p><p class="source-code">  expect(result).toEqual(response);</p><p class="source-code">});</p></li>
<li>Make that pass:<p class="source-code">export const performFetch = (operation, variables) =&gt;</p><p class="source-code">  global</p><p class="source-code">  .fetch("/graphql", ...)</p><p class="source-code"><strong class="bold">  .then(result =&gt; result.json())</strong>;</p></li>
<li>Now, we need to handle the error cases. We need the promise to reject if an HTTP error occurred. We use a new form of the <strong class="source-inline">expect</strong> function that we haven’t seen before; it takes a promise and expects it to reject:<p class="source-code">it("rejects when the request fails", () =&gt; {</p><p class="source-code">  global.fetch.mockResolvedValue(</p><p class="source-code">    fetchResponseError(500)</p><p class="source-code">  );</p><p class="source-code">  return expect(</p><p class="source-code">    performFetch({ text }, variables)</p><p class="source-code">  ).rejects.toEqual(new Error(500));</p><p class="source-code">});</p></li>
<li>In our production code, we’ll test <a id="_idIndexMarker1229"/>whether the fetch response’s <strong class="source-inline">ok</strong> property is <strong class="source-inline">false</strong>, and reject the <a id="_idIndexMarker1230"/>promise if it is. Add the following function:<p class="source-code">const verifyStatusOk = result =&gt; {</p><p class="source-code">  if (!result.ok) {</p><p class="source-code">    return Promise.reject(new Error(500));</p><p class="source-code">  } else {</p><p class="source-code">    return result;</p><p class="source-code">  }</p><p class="source-code">};</p></li>
<li>Call that function within your promise chain. After this, our <strong class="source-inline">performFetch</strong> function is complete:<p class="source-code">export const performFetch = (operation, variables) =&gt;</p><p class="source-code">  global</p><p class="source-code">    .fetch("/graphql", ...)</p><p class="source-code"><strong class="bold">    .then(verifyStatusOk)</strong></p><p class="source-code">    .then(result =&gt; result.json());</p></li>
</ol>
<p>You’ve now learned how to specify and test the <strong class="source-inline">performFetch</strong> function required for the <strong class="source-inline">Environment</strong> constructor. Now, we’re ready to do that construction.</p>
<h2 id="_idParaDest-230"><a id="_idTextAnchor266"/>Test-driving the Environment object construction</h2>
<p>We’re going to build a function named <strong class="source-inline">buildEnvironment</strong>, that takes all the various pieces we <a id="_idIndexMarker1231"/>need to build an <strong class="source-inline">Environment</strong> object. The reason there are so many pieces is that they are all <a id="_idIndexMarker1232"/>extension points that enable the configuration of the Relay connection.</p>
<p>These pieces are our <strong class="source-inline">performFetch</strong> function and a bunch of other Relay types that come directly from the <strong class="source-inline">relay-runtime</strong> package. We’ll use <strong class="source-inline">jest.mock</strong> to mock all these out in one fell swoop.</p>
<p>Let’s get started:</p>
<ol>
<li value="1">In the same test file, <strong class="source-inline">test/relayEnvironment.test.js</strong>, update your import to include the new function:<p class="source-code">import {</p><p class="source-code">  performFetch<strong class="bold">,</strong></p><p class="source-code"><strong class="bold">  buildEnvironment</strong></p><p class="source-code">} from "../src/relayEnvironment";</p></li>
<li>Now, it’s time to import all the relevant pieces we need from the <strong class="source-inline">relay-runtime</strong> package and mock them out. Add the following to the top of the file:<p class="source-code">import {</p><p class="source-code">  Environment,</p><p class="source-code">  Network,</p><p class="source-code">  Store,</p><p class="source-code">  RecordSource</p><p class="source-code">} from "relay-runtime";</p><p class="source-code">jest.mock("relay-runtime");</p></li>
<li>For our first test, we need to test that the <strong class="source-inline">Environment</strong> constructor was called:<p class="source-code">describe("buildEnvironment", () =&gt; {</p><p class="source-code">  const environment = { a: 123 };</p><p class="source-code">  beforeEach(() =&gt; {</p><p class="source-code">    Environment.mockImplementation(() =&gt; environment);</p><p class="source-code">  });</p><p class="source-code">  it("returns environment", () =&gt; {</p><p class="source-code">    expect(buildEnvironment()).toEqual(environment);</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>Start by adding<a id="_idIndexMarker1233"/> all the imports in<a id="_idIndexMarker1234"/> the production code in <strong class="source-inline">src/relayEnvironment.js</strong>:<p class="source-code">import {</p><p class="source-code">  Environment,</p><p class="source-code">  Network,</p><p class="source-code">  RecordSource,</p><p class="source-code">  Store</p><p class="source-code">} from "relay-runtime";</p></li>
<li>Make the test pass by adding this code at the bottom of the file:<p class="source-code">export const buildEnvironment = () =&gt;</p><p class="source-code">    new Environment();</p></li>
<li>The second test makes sure we pass the right arguments to <strong class="source-inline">Environment</strong>. Its first argument is the result of calling <strong class="source-inline">Network.create</strong>, and the second argument is the result of constructing a <strong class="source-inline">Store</strong> object. The tests need to mock those out and then <a id="_idIndexMarker1235"/>check the return<a id="_idIndexMarker1236"/> values:<p class="source-code">describe("buildEnvironment", () =&gt; {</p><p class="source-code">  const environment = { a: 123 };</p><p class="source-code"><strong class="bold">  const network = { b: 234 };</strong></p><p class="source-code"><strong class="bold">  const store = { c: 345 };</strong></p><p class="source-code">  beforeEach(() =&gt; {</p><p class="source-code">    Environment.mockImplementation(() =&gt; environment);</p><p class="source-code"><strong class="bold">    Network.create.mockReturnValue(network);</strong></p><p class="source-code"><strong class="bold">    Store.mockImplementation(() =&gt; store);</strong></p><p class="source-code">  });</p><p class="source-code">  it("returns environment", () =&gt; {</p><p class="source-code">    expect(buildEnvironment()).toEqual(environment);</p><p class="source-code">  });</p><p class="source-code"><strong class="bold">  it("calls Environment with network and store", () =&gt; {</strong></p><p class="source-code"><strong class="bold">    expect(Environment).toBeCalledWith({</strong></p><p class="source-code"><strong class="bold">      network,</strong></p><p class="source-code"><strong class="bold">      store</strong></p><p class="source-code"><strong class="bold">    });</strong></p><p class="source-code"><strong class="bold">});</strong></p><p class="source-code">});</p></li>
</ol>
<p class="callout-heading">Mocking Constructors</p>
<p class="callout">Note the difference in how we mock <a id="_idIndexMarker1237"/>out constructors and function calls. To mock out a new <strong class="source-inline">Store</strong> and a new <strong class="source-inline">Environment</strong>, we need to use <strong class="source-inline">mockImplementation(fn)</strong>. To mock out <strong class="source-inline">Network.create</strong>, we need to use <strong class="source-inline">mockReturnValue(returnValue)</strong>.</p>
<ol>
<li value="7">Make the test pass<a id="_idIndexMarker1238"/> by updating the <a id="_idIndexMarker1239"/>function to pass those arguments to the <strong class="source-inline">Environment</strong> constructor:<p class="source-code">export const buildEnvironment = () =&gt;</p><p class="source-code">  new Environment(<strong class="bold">{</strong></p><p class="source-code"><strong class="bold">    network: Network.create(),</strong></p><p class="source-code"><strong class="bold">    store: new Store()</strong></p><p class="source-code"><strong class="bold">  }</strong>);</p></li>
<li>Next up, we need to ensure that <strong class="source-inline">Network.create</strong> gets a reference to our <strong class="source-inline">performFetch</strong> function:<p class="source-code">it("calls Network.create with performFetch", () =&gt; {</p><p class="source-code">  expect(Network.create).toBeCalledWith(performFetch);</p><p class="source-code">});</p></li>
<li>Make that pass by passing <strong class="source-inline">performFetch</strong> to the <strong class="source-inline">Network.create</strong> function:<p class="source-code">export const buildEnvironment = () =&gt;</p><p class="source-code">  new Environment({</p><p class="source-code">    network: Network.create(<strong class="bold">performFetch</strong>),</p><p class="source-code">    store: new Store()</p><p class="source-code">  });</p></li>
<li>The <strong class="source-inline">Store</strong> constructor needs a <strong class="source-inline">RecordSource</strong> object. Add a new mock implementation<a id="_idIndexMarker1240"/> for <strong class="source-inline">RecordSource</strong> in your test setup:<p class="source-code">describe("buildEnvironment", () =&gt; {</p><p class="source-code">  ...</p><p class="source-code"><strong class="bold">  const recordSource = { d: 456 };</strong></p><p class="source-code">  beforeEach(() =&gt; {</p><p class="source-code">    ...</p><p class="source-code"><strong class="bold">    RecordSource.mockImplementation(</strong></p><p class="source-code"><strong class="bold">      () =&gt; recordSource</strong></p><p class="source-code"><strong class="bold">    );</strong></p><p class="source-code">  });</p><p class="source-code">  ...</p><p class="source-code">});</p></li>
<li>Add the following test to <a id="_idIndexMarker1241"/>specify the behavior we want:<p class="source-code">it("calls Store with RecordSource", () =&gt; {</p><p class="source-code">  expect(Store).toBeCalledWith(recordSource);</p><p class="source-code">});</p></li>
<li>Make that pass by constructing a new <strong class="source-inline">RecordSource</strong> object:<p class="source-code">export const buildEnvironment = () =&gt;</p><p class="source-code">  new Environment({</p><p class="source-code">    network: Network.create(performFetch),</p><p class="source-code">    store: new Store(<strong class="bold">new RecordSource()</strong>)</p><p class="source-code">  });</p></li>
</ol>
<p>And that, would <a id="_idIndexMarker1242"/>you believe, is it for <strong class="source-inline">buildEnvironment</strong>! At this stage, you will have a valid <strong class="source-inline">Environment</strong> object.</p>
<h2 id="_idParaDest-231"><a id="_idTextAnchor267"/>Test-driving a singleton instance of Environment</h2>
<p>Because <a id="_idIndexMarker1243"/>creating <strong class="source-inline">Environment</strong> takes a substantial <a id="_idIndexMarker1244"/>amount of plumbing, it’s common to construct it once and then use that value for the rest of the application.</p>
<p class="callout-heading">An Alternative Approach Using RelayEnvironmentProvider</p>
<p class="callout">There is an alternative approach to using the singleton instance shown here, which is to use React Context. The <strong class="source-inline">RelayEnvironmentProvider</strong> component provided by Relay can help you with that. For more information, see the <em class="italic">Further reading</em> section at the end of the chapter.</p>
<p>Let’s build the <strong class="source-inline">getEnvironment</strong> function:</p>
<ol>
<li value="1">Import the new function at the top of <strong class="source-inline">test/relayEnvironment.test.js</strong>:<p class="source-code">import {</p><p class="source-code">  performFetch<strong class="bold">,</strong></p><p class="source-code">  buildEnvironment,</p><p class="source-code"><strong class="bold">  getEnvironment</strong></p><p class="source-code">} from "../src/relayEnvironment";</p></li>
<li>At the bottom of the file, add a third <strong class="source-inline">describe</strong> block with the one and only one test for this function:<p class="source-code">describe("getEnvironment", () =&gt; {</p><p class="source-code">  it("constructs the object only once", () =&gt; {</p><p class="source-code">    getEnvironment();</p><p class="source-code">    getEnvironment();</p><p class="source-code">    expect(Environment.mock.calls.length).toEqual(1);</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>In <strong class="source-inline">src/relayEnvironment.js</strong>, make that pass by introducing a top-level variable that stores <a id="_idIndexMarker1245"/>the result of <strong class="source-inline">getEnvironment</strong> if it hasn’t yet been called:<p class="source-code">let environment = null;</p><p class="source-code">export const getEnvironment = () =&gt;</p><p class="source-code">  environment || (environment = buildEnvironment());</p></li>
</ol>
<p>That’s all f<a id="_idTextAnchor268"/>or the environment <a id="_idIndexMarker1246"/>boilerplate. We now have a shiny <strong class="source-inline">getEnvironment</strong> function that we can use within our React components.</p>
<p>In the next section, we’ll start on the <strong class="source-inline">CustomerHistory</strong> component.</p>
<h1 id="_idParaDest-232"><a id="_idTextAnchor269"/>Fetching GraphQL data from within a component</h1>
<p>Now that we have a <a id="_idIndexMarker1247"/>Relay environment, we can begin to build out our feature. Recall from the introduction that we’re building a new <strong class="source-inline">CustomerHistory</strong> component that displays customer details and a list of the customer’s appointments. A GraphQL query to return this information already exists in our server, so we just need to call it in the right way. The query looks like this:</p>
<pre class="source-code">
customer(id: $id) {
  id
  firstName
  lastName
  phoneNumber
  appointments {
    startsAt
    stylist
    service
    notes
  }
}</pre>
<p>This says we get a customer record for a given customer ID (specified by the <strong class="source-inline">$id</strong> parameter), together <a id="_idIndexMarker1248"/>with a list of their appointments.</p>
<p>Our component will perform this query when it’s mounted. We’ll jump right in with that functionality, by testing the call<a id="_idIndexMarker1249"/> to <strong class="source-inline">fetchQuery</strong>: </p>
<ol>
<li value="1">Create a new file, <strong class="source-inline">test/CustomerHistory.test.js</strong>, and add the following setup. We’re going to break this setup into parts, as it’s long! First up is our import, and the call to mock <strong class="source-inline">relay-runtime</strong> again, so that we can stub <strong class="source-inline">fetchQuery</strong>:<p class="source-code">import React from "react";</p><p class="source-code">import { act } from "react-dom/test-utils";</p><p class="source-code">import {</p><p class="source-code">  initializeReactContainer,</p><p class="source-code">  render,</p><p class="source-code">  renderAndWait,</p><p class="source-code">  container,</p><p class="source-code">  element,</p><p class="source-code">  elements,</p><p class="source-code">  textOf,</p><p class="source-code">} from "./reactTestExtensions";</p><p class="source-code">import { fetchQuery } from "relay-runtime";</p><p class="source-code">import {</p><p class="source-code">  CustomerHistory,</p><p class="source-code">  query</p><p class="source-code">} from "../src/CustomerHistory";</p><p class="source-code">import {</p><p class="source-code">  getEnvironment</p><p class="source-code">} from "../src/relayEnvironment";</p><p class="source-code">jest.mock("relay-runtime");</p><p class="source-code">jest.mock("../src/relayEnvironment");</p></li>
<li>Now, let’s define <a id="_idIndexMarker1250"/>some sample<a id="_idIndexMarker1251"/> data:<p class="source-code">const date = new Date("February 16, 2019");</p><p class="source-code">const appointments = [</p><p class="source-code">  {</p><p class="source-code">    startsAt: date.setHours(9, 0, 0, 0),</p><p class="source-code">    stylist: "Jo",</p><p class="source-code">    service: "Cut",</p><p class="source-code">    notes: "Note one"</p><p class="source-code">  },</p><p class="source-code">  {</p><p class="source-code">    startsAt: date.setHours(10, 0, 0, 0),</p><p class="source-code">    stylist: "Stevie",</p><p class="source-code">    service: "Cut &amp; color",</p><p class="source-code">    notes: "Note two"</p><p class="source-code">  }</p><p class="source-code">];</p><p class="source-code">const customer = {</p><p class="source-code">  firstName: "Ashley",</p><p class="source-code">  lastName: "Jones",</p><p class="source-code">  phoneNumber: "123",</p><p class="source-code">  appointments</p><p class="source-code">};</p></li>
<li>Next, let’s get <strong class="source-inline">beforeEach</strong> in place. This<a id="_idIndexMarker1252"/> stubs out <strong class="source-inline">fetchQuery</strong> with a <a id="_idIndexMarker1253"/>special <strong class="source-inline">sendCustomer</strong> fake, mimicking<a id="_idIndexMarker1254"/> the return value of a <strong class="source-inline">fetchQuery</strong> request:<p class="source-code">describe("CustomerHistory", () =&gt; {</p><p class="source-code">  let unsubscribeSpy = jest.fn();</p><p class="source-code">  const sendCustomer = ({ next }) =&gt; {</p><p class="source-code">    act(() =&gt; next({ customer }));</p><p class="source-code">    return { unsubscribe: unsubscribeSpy };</p><p class="source-code">  };</p><p class="source-code">  beforeEach(() =&gt; {</p><p class="source-code">    initializeReactContainer();</p><p class="source-code">    fetchQuery.mockReturnValue(</p><p class="source-code">      { subscribe: sendCustomer }</p><p class="source-code">    );</p><p class="source-code">  });</p><p class="source-code">});</p></li>
</ol>
<p class="callout-heading">The Return Value of fetchQuery</p>
<p class="callout">This function has a relatively complex usage<a id="_idIndexMarker1255"/> pattern. A call to <strong class="source-inline">fetchQuery</strong> returns an object with <strong class="source-inline">subscribe</strong> and <strong class="source-inline">unsubscribe</strong> function properties We call <strong class="source-inline">subscribe</strong> with an object with a <strong class="source-inline">next</strong> callback property. That callback is called by Relay’s <strong class="source-inline">fetchQuery</strong> each time the query returns a result set. We can use that callback to set our component state. Finally, the <strong class="source-inline">unsubscribe</strong> function is returned from the <strong class="source-inline">useEffect</strong> block so that it’s called when the component is unmounted or the relevant props change.</p>
<ol>
<li value="4">Finally, add the <a id="_idIndexMarker1256"/>test, which checks that we call <strong class="source-inline">fetchQuery</strong> in the expected way:<p class="source-code">it("calls fetchQuery", async () =&gt; {</p><p class="source-code">  await renderAndWait(&lt;CustomerHistory id={123} /&gt;);</p><p class="source-code">  expect(fetchQuery).toBeCalledWith(</p><p class="source-code">    getEnvironment(), query, { id: 123 }</p><p class="source-code">  );</p><p class="source-code">});</p></li>
<li>Let’s make that pass. Create a new file, <strong class="source-inline">src/CustomerHistory.js</strong>, and start it off with the<a id="_idIndexMarker1257"/> imports and the exported <strong class="source-inline">query</strong> definition:<p class="source-code">import React, { useEffect } from "react";</p><p class="source-code">import { fetchQuery, graphql } from "relay-runtime";</p><p class="source-code">import { getEnvironment } from "./relayEnvironment";</p><p class="source-code">export const query = graphql`</p><p class="source-code">  query CustomerHistoryQuery($id: ID!) {</p><p class="source-code">    customer(id: $id) {</p><p class="source-code">      id</p><p class="source-code">      firstName</p><p class="source-code">      lastName</p><p class="source-code">      phoneNumber</p><p class="source-code">      appointments {</p><p class="source-code">        startsAt</p><p class="source-code">        stylist</p><p class="source-code">        service</p><p class="source-code">        notes</p><p class="source-code">      }</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">`;</p></li>
<li>Add the <a id="_idIndexMarker1258"/>component, together with a <strong class="source-inline">useEffect</strong> Hook:<p class="source-code">export const CustomerHistory = ({ id }) =&gt; {</p><p class="source-code">  useEffect(() =&gt; {</p><p class="source-code">    fetchQuery(getEnvironment(), query, { id });</p><p class="source-code">  }, [id]);</p><p class="source-code">  return null;</p><p class="source-code">};</p></li>
<li>If you run tests <a id="_idIndexMarker1259"/>now, you might see an error, as shown here:<p class="source-code"><strong class="bold">    Cannot find module './__generated__/CustomerHistoryQuery.graphql' from 'src/CustomerHistory.js'</strong></p></li>
</ol>
<p>To fix this, run the following command to compile your GraphQL query:</p>
<p class="source-code"><strong class="bold">npx relay-compiler</strong></p>
<ol>
<li value="8">Next, we can add a <a id="_idIndexMarker1260"/>test to show what happens when we pull out some data:<p class="source-code">it("unsubscribes when id changes", async () =&gt; {</p><p class="source-code">  await renderAndWait(&lt;CustomerHistory id={123} /&gt;);</p><p class="source-code">  await renderAndWait(&lt;CustomerHistory id={234} /&gt;);</p><p class="source-code">  expect(unsubscribeSpy).toBeCalled();</p><p class="source-code">});</p></li>
<li>To make that pass, update the <strong class="source-inline">useEffect</strong> block to return the <strong class="source-inline">unsubscribe</strong> function property:<p class="source-code">useEffect(() =&gt; {</p><p class="source-code"><strong class="bold">  const subscription =</strong> fetchQuery(</p><p class="source-code">    getEnvironment(), query, { id }</p><p class="source-code">  );</p><p class="source-code"><strong class="bold">  return subscription.unsubscribe;</strong></p><p class="source-code">}, [id]);</p></li>
<li>Then, update your component to render that data, pulling in the customer data:<p class="source-code">it("renders the first name and last name together in a h2", async () =&gt; {</p><p class="source-code">  await renderAndWait(&lt;CustomerHistory id={123} /&gt;);</p><p class="source-code">  await new Promise(setTimeout);</p><p class="source-code">  expect(element("h2")).toContainText("Ashley Jones");</p><p class="source-code">});</p></li>
<li>Then, update<a id="_idIndexMarker1261"/> your component to include a new state variable, <strong class="source-inline">customer</strong>. This is set by calling <strong class="source-inline">setCustomer</strong> in our definition of the next callback:<p class="source-code">export const CustomerHistory = ({ id }) =&gt; {</p><p class="source-code"><strong class="bold">  const [customer, setCustomer] = useState(null);</strong></p><p class="source-code">  useEffect(() =&gt; {</p><p class="source-code">    const subscription = fetchQuery(</p><p class="source-code">      getEnvironment(), query, { id }</p><p class="source-code">    )<strong class="bold">.subscribe({</strong></p><p class="source-code"><strong class="bold">      next: ({ customer }) =&gt; setCustomer(customer),</strong></p><p class="source-code"><strong class="bold">    });</strong></p><p class="source-code">    return subscription.unsubscribe;</p><p class="source-code">  }, [id]);</p></li>
<li>Make the test pass by<a id="_idIndexMarker1262"/> extending your JSX to render the customer data:<p class="source-code">const { firstName, lastName } = customer;</p><p class="source-code">return (</p><p class="source-code">  &lt;&gt;</p><p class="source-code">    &lt;h2&gt;</p><p class="source-code">      {firstName} {lastName}</p><p class="source-code">    &lt;/h2&gt;</p><p class="source-code">  &lt;/&gt;</p><p class="source-code">);</p></li>
<li>Now, add a test to also render the customer’s phone number:<p class="source-code">it("renders the phone number", async () =&gt; {</p><p class="source-code">  await renderAndWait(&lt;CustomerHistory id={123} /&gt;);</p><p class="source-code">  expect(document.body).toContainText("123");</p><p class="source-code">});</p></li>
<li>Make that pass <a id="_idIndexMarker1263"/>with the change shown here:<p class="source-code">const { firstName, lastName<strong class="bold">, phoneNumber</strong> } = customer;</p><p class="source-code">return (</p><p class="source-code">  &lt;&gt;</p><p class="source-code">    &lt;h2&gt;</p><p class="source-code">      {firstName} {lastName}</p><p class="source-code">    &lt;/h2&gt;</p><p class="source-code"><strong class="bold">    &lt;p&gt;{phoneNumber}&lt;/p&gt;</strong></p><p class="source-code">  &lt;/&gt;</p><p class="source-code">);</p></li>
<li>Now, let’s get started on rendering the appointments:<p class="source-code">it("renders a Booked appointments heading", async () =&gt; {</p><p class="source-code">  await renderAndWait(&lt;CustomerHistory id={123} /&gt;);</p><p class="source-code">  expect(element("h3")).not.toBeNull();</p><p class="source-code">  expect(element("h3")).toContainText(</p><p class="source-code">    "Booked appointments"</p><p class="source-code">  );</p><p class="source-code">});</p></li>
<li>That’s a quick one to fix; add in the <strong class="source-inline">h3</strong> element, as shown here:<p class="source-code">const { firstName, lastName, phoneNumber } = customer;</p><p class="source-code">return (</p><p class="source-code">  &lt;&gt;</p><p class="source-code">    &lt;h2&gt;</p><p class="source-code">      {firstName} {lastName}</p><p class="source-code">    &lt;/h2&gt;</p><p class="source-code">    &lt;p&gt;{phoneNumber}&lt;/p&gt;</p><p class="source-code"><strong class="bold">    &lt;h3&gt;Booked appointments&lt;/h3&gt;</strong></p><p class="source-code">  &lt;/&gt;</p><p class="source-code">);</p></li>
<li>Next, we’ll render <a id="_idIndexMarker1264"/>a table for each of the appointments available:<p class="source-code">it("renders a table with four column headings", async () =&gt; {</p><p class="source-code">  await renderAndWait(&lt;CustomerHistory id={123} /&gt;);</p><p class="source-code">  const headings = elements(</p><p class="source-code">    "table &gt; thead &gt; tr &gt; th"</p><p class="source-code">  );</p><p class="source-code">  expect(textOf(headings)).toEqual([</p><p class="source-code">    "When",</p><p class="source-code">    "Stylist",</p><p class="source-code">    "Service",</p><p class="source-code">    "Notes",</p><p class="source-code">  ]);</p><p class="source-code">});</p></li>
<li>Add that table:<p class="source-code">const { firstName, lastName, phoneNumber } = customer;</p><p class="source-code">return (</p><p class="source-code">  &lt;&gt;</p><p class="source-code">    &lt;h2&gt;</p><p class="source-code">      {firstName} {lastName}</p><p class="source-code">    &lt;/h2&gt;</p><p class="source-code">    &lt;p&gt;{phoneNumber}&lt;/p&gt;</p><p class="source-code">    &lt;h3&gt;Booked appointments&lt;/h3&gt;</p><p class="source-code"><strong class="bold">    &lt;table&gt;</strong></p><p class="source-code"><strong class="bold">      &lt;thead&gt;</strong></p><p class="source-code"><strong class="bold">        &lt;tr&gt;</strong></p><p class="source-code"><strong class="bold">          &lt;th&gt;When&lt;/th&gt;</strong></p><p class="source-code"><strong class="bold">          &lt;th&gt;Stylist&lt;/th&gt;</strong></p><p class="source-code"><strong class="bold">          &lt;th&gt;Service&lt;/th&gt;</strong></p><p class="source-code"><strong class="bold">          &lt;th&gt;Notes&lt;/th&gt;</strong></p><p class="source-code"><strong class="bold">        &lt;/tr&gt;</strong></p><p class="source-code"><strong class="bold">      &lt;/thead&gt;</strong></p><p class="source-code"><strong class="bold">    &lt;/table&gt;</strong></p><p class="source-code">  &lt;/&gt;</p><p class="source-code">);</p></li>
<li>For the next set of tests, we’ll use a <strong class="source-inline">columnValues</strong> helper, which will find a rendered table <a id="_idIndexMarker1265"/>element and pull out an array of all the values in a column. We can use this to test that our code displays data for a list of appointments, rather than just one:<p class="source-code">const columnValues = (columnNumber) =&gt;</p><p class="source-code">  elements("tbody &gt; tr").map(</p><p class="source-code">    (tr) =&gt; tr.childNodes[columnNumber]</p><p class="source-code">  );</p><p class="source-code">it("renders the start time of each appointment in the correct format", async () =&gt; {</p><p class="source-code">  await renderAndWait(&lt;CustomerHistory id={123} /&gt;);</p><p class="source-code">  expect(textOf(columnValues(0))).toEqual([</p><p class="source-code">    "Sat Feb 16 2019 09:00",</p><p class="source-code">    "Sat Feb 16 2019 10:00",</p><p class="source-code">  ]);</p><p class="source-code">});</p></li>
<li>Add a new <strong class="source-inline">tbody</strong> element<a id="_idIndexMarker1266"/> here, just below <strong class="source-inline">thead</strong>. This makes a reference to a new <strong class="source-inline">AppointmentRow</strong> component, which we haven’t built yet, but we will do so in the next step:<p class="source-code">&lt;table&gt;</p><p class="source-code">  &lt;thead&gt;</p><p class="source-code">    ...</p><p class="source-code">  &lt;/thead&gt;</p><p class="source-code"><strong class="bold">  &lt;tbody&gt;</strong></p><p class="source-code"><strong class="bold">    {customer.appointments.map((appointment, i) =&gt; (</strong></p><p class="source-code"><strong class="bold">      &lt;AppointmentRow</strong></p><p class="source-code"><strong class="bold">        appointment={appointment}</strong></p><p class="source-code"><strong class="bold">        key={i}</strong></p><p class="source-code"><strong class="bold">      /&gt;</strong></p><p class="source-code"><strong class="bold">    ))}</strong></p><p class="source-code"><strong class="bold">  &lt;/tbody&gt;</strong></p><p class="source-code">&lt;/table&gt;</p></li>
<li>Now, let’s define <strong class="source-inline">AppointmentRow</strong>. Add this above the <strong class="source-inline">CustomerHistory</strong> definition. After<a id="_idIndexMarker1267"/> this, your test should pass:<p class="source-code">const toTimeString = (startsAt) =&gt;</p><p class="source-code">  new Date(Number(startsAt))</p><p class="source-code">    .toString()</p><p class="source-code">    .substring(0, 21);</p><p class="source-code">const AppointmentRow = ({ appointment }) =&gt; (</p><p class="source-code">  &lt;tr&gt;</p><p class="source-code">    &lt;td&gt;{toTimeString(appointment.startsAt)}&lt;/td&gt;</p><p class="source-code">  &lt;/tr&gt;</p><p class="source-code">);</p></li>
<li>Let’s add in the other columns, starting with the stylist:<p class="source-code">it("renders the stylist", async () =&gt; {</p><p class="source-code">  await renderAndWait(&lt;CustomerHistory id={123} /&gt;);</p><p class="source-code">  expect(textOf(columnValues(1))).toEqual([</p><p class="source-code">    "Jo", "Stevie"</p><p class="source-code">  ]);</p><p class="source-code">});</p></li>
<li>Add that as the next column in <strong class="source-inline">AppointmentRow</strong>:<p class="source-code">const AppointmentRow = ({ appointment }) =&gt; (</p><p class="source-code">  &lt;tr&gt;</p><p class="source-code">    &lt;td&gt;{toTimeString(appointment.startsAt)}&lt;/td&gt;</p><p class="source-code"><strong class="bold">    &lt;td&gt;{appointment.stylist}&lt;/td&gt;</strong></p><p class="source-code">  &lt;/tr&gt;</p><p class="source-code">);</p></li>
<li>Next is<a id="_idIndexMarker1268"/> the <strong class="source-inline">service</strong> field:<p class="source-code">it("renders the service", async () =&gt; {</p><p class="source-code">  await renderAndWait(&lt;CustomerHistory id={123} /&gt;);</p><p class="source-code">  expect(textOf(columnValues(2))).toEqual([</p><p class="source-code">    "Cut",</p><p class="source-code">    "Cut &amp; color",</p><p class="source-code">  ]);</p><p class="source-code">});</p></li>
<li>Again, that involves simply adding a further <strong class="source-inline">td</strong> element to <strong class="source-inline">AppointmentRow</strong>:<p class="source-code">const AppointmentRow = ({ appointment }) =&gt; (</p><p class="source-code">  &lt;tr&gt;</p><p class="source-code">    &lt;td&gt;{toTimeString(appointment.startsAt)}&lt;/td&gt;</p><p class="source-code">    &lt;td&gt;{appointment.stylist}&lt;/td&gt;</p><p class="source-code"><strong class="bold">    &lt;td&gt;{appointment.service}&lt;/td&gt;</strong></p><p class="source-code">  &lt;/tr&gt;</p><p class="source-code">);</p></li>
<li>Finally, for rendering information, we’ll show the <strong class="source-inline">notes</strong> field too.<p class="source-code">it("renders notes", async () =&gt; {</p><p class="source-code">  await renderAndWait(&lt;CustomerHistory id={123} /&gt;);</p><p class="source-code">  expect(textOf(columnValues(3))).toEqual([</p><p class="source-code">    "Note one",</p><p class="source-code">    "Note two",</p><p class="source-code">  ]);</p><p class="source-code">});</p></li>
<li>Complete the <strong class="source-inline">AppointmentRow</strong> component, as <a id="_idIndexMarker1269"/>shown here:<p class="source-code">const AppointmentRow = ({ appointment }) =&gt; (</p><p class="source-code">  &lt;tr&gt;</p><p class="source-code">    &lt;td&gt;{toTimeString(appointment.startsAt)}&lt;/td&gt;</p><p class="source-code">    &lt;td&gt;{appointment.stylist}&lt;/td&gt;</p><p class="source-code">    &lt;td&gt;{appointment.service}&lt;/td&gt;</p><p class="source-code"><strong class="bold">    &lt;td&gt;{appointment.notes}&lt;/td&gt;</strong></p><p class="source-code">  &lt;/tr&gt;</p><p class="source-code">);</p></li>
<li>We’re almost done. Let’s display a <strong class="bold">Loading</strong> message when data is being submitted to the server. This test should be a new nested <strong class="source-inline">describe</strong> block, just below the test that we’ve just completed. It uses<a id="_idIndexMarker1270"/> a <strong class="source-inline">noSend</strong> fake that does nothing; there’s no call to <strong class="source-inline">next</strong>. This can be used to mimic the scenario when data is still<a id="_idIndexMarker1271"/> loading:<p class="source-code">describe("submitting", () =&gt; {</p><p class="source-code">  const noSend = () =&gt; unsubscribeSpy;</p><p class="source-code">  beforeEach(() =&gt; {</p><p class="source-code">    fetchQuery.mockReturnValue({ subscribe: noSend });</p><p class="source-code">  });</p><p class="source-code">  it("displays a loading message", async () =&gt; {</p><p class="source-code">    await renderAndWait(&lt;CustomerHistory id={123} /&gt;);</p><p class="source-code">    expect(element("[role=alert]")).toContainText(</p><p class="source-code">      "Loading"</p><p class="source-code">    );</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>To make that pass, introduce<a id="_idIndexMarker1272"/> a conditional just before the JSX:<p class="source-code">export const CustomerHistory = ({ id }) =&gt; {</p><p class="source-code">  const [customer, setCustomer] = useState(null);</p><p class="source-code">  useEffect(() =&gt; {</p><p class="source-code">    ...</p><p class="source-code">  }, [id]);</p><p class="source-code"><strong class="bold">  if (!customer) {</strong></p><p class="source-code"><strong class="bold">    return &lt;p role="alert"&gt;Loading&lt;/p&gt;;</strong></p><p class="source-code"><strong class="bold">  }</strong></p><p class="source-code">  ...</p><p class="source-code">};</p></li>
<li>Finally, let’s handle the case<a id="_idIndexMarker1273"/> when there’s an error fetching data. This uses another fake, <strong class="source-inline">errorSend</strong>, that<a id="_idIndexMarker1274"/> invokes the error callback. It’s like the <strong class="source-inline">next</strong> callback and can be used to set state, which we’ll see in the next step:<p class="source-code">describe("when there is an error fetching data", () =&gt; {</p><p class="source-code">  const errorSend = ({ error }) =&gt; {</p><p class="source-code">    act(() =&gt; error());</p><p class="source-code">    return { unsubscribe: unsubscribeSpy };</p><p class="source-code">  };</p><p class="source-code">  beforeEach(() =&gt; {</p><p class="source-code">    fetchQuery.mockReturnValue(</p><p class="source-code">      { subscribe: errorSend }</p><p class="source-code">    );</p><p class="source-code">  });</p><p class="source-code">  it("displays an error message", async () =&gt; {</p><p class="source-code">    await renderAndWait(&lt;CustomerHistory /&gt;);</p><p class="source-code">    expect(element("[role=alert]")).toContainText(</p><p class="source-code">      "Sorry, an error occurred while pulling data from the server."</p><p class="source-code">    );</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>To make that pass, you’ll need to introduce a new <strong class="source-inline">status</strong> state variable. Initially, this has the <strong class="source-inline">loading</strong> value. When successful, it changes to <strong class="source-inline">loaded</strong>, and when an error occurs, it changes to <strong class="source-inline">failed</strong>. For the <strong class="source-inline">failed</strong> state, we render the <a id="_idIndexMarker1275"/>specified error message:<p class="source-code">const [customer, setCustomer] = useState(null);</p><p class="source-code"><strong class="bold">const [status, setStatus] = useState("loading");</strong></p><p class="source-code">useEffect(() =&gt; {</p><p class="source-code">  const subscription = fetchQuery(</p><p class="source-code">    getEnvironment(), query, { id }</p><p class="source-code">  ).subscribe({</p><p class="source-code">    next: ({ customer }) =&gt; {</p><p class="source-code">      setCustomer(customer);</p><p class="source-code"><strong class="bold">      setStatus("loaded");</strong></p><p class="source-code">    },</p><p class="source-code"><strong class="bold">    error: (_) =&gt; setStatus("failed"),</strong></p><p class="source-code">  })</p><p class="source-code">  return subscription.unsubscribe;</p><p class="source-code">}, [id]);</p><p class="source-code">if (<strong class="bold">status === "loading"</strong>) {</p><p class="source-code">  return &lt;p role="alert"&gt;Loading&lt;/p&gt;;</p><p class="source-code">}</p><p class="source-code"><strong class="bold">if (status === "failed") {</strong></p><p class="source-code"><strong class="bold">  return (</strong></p><p class="source-code"><strong class="bold">    &lt;p role="alert"&gt;</strong></p><p class="source-code"><strong class="bold">      Sorry, an error occurred while pulling data from</strong></p><p class="source-code"><strong class="bold">the server.</strong></p><p class="source-code"><strong class="bold">    &lt;/p&gt;</strong></p><p class="source-code"><strong class="bold">  );</strong></p><p class="source-code"><strong class="bold">}</strong></p><p class="source-code">const { firstName, lastName, phoneNumber } = customer;</p><p class="source-code">...</p></li>
</ol>
<p>That completes the new <strong class="source-inline">CustomerHistory</strong> component. You have now learned how to test-drive the <a id="_idIndexMarker1276"/>use of Relay’s <strong class="source-inline">fetchQuery</strong> function in your application, and this component is <a id="_idTextAnchor270"/>now ready to integrate with <strong class="source-inline">App</strong>. This is left as an exercise.</p>
<h1 id="_idParaDest-233"><a id="_idTextAnchor271"/>Summary</h1>
<p>This chapter has explored how to test-drive the integration of a GraphQL endpoint using Relay. You have seen how to test-drive the building of the Relay environment, and how to build a component that uses the <strong class="source-inline">fetchQuery</strong> API.</p>
<p>In <em class="italic">Part 3</em>, <em class="italic">Interactivity</em>, we’ll begin work in a new code base that will allow us to explore more complex use cases involving undo/redo, animation, and WebSocket manipulation.</p>
<p>In <a href="B18423_14.xhtml#_idTextAnchor277"><em class="italic">Chapter 14</em></a>, <em class="italic">Building a Logo Interpreter</em>, we’ll begin <a id="_idTextAnchor272"/>by writing new Redux middleware to handle undo/redo behavior.</p>
<h1 id="_idParaDest-234"><a id="_idTextAnchor273"/>Exercises</h1>
<p>Integrate the <strong class="source-inline">CustomerHistory</strong> component into the rest of your application by taking the following steps:</p>
<ol>
<li value="1">Add a new route at <strong class="source-inline">/viewHistory?customer=&lt;customer id&gt;</strong> that displays the <strong class="source-inline">CustomerHistory</strong> component, using a new intermediate <strong class="source-inline">CustomerHistoryRoute</strong> component.</li>
<li>Add a new <strong class="source-inline">Link</strong> to the search actions on the <strong class="source-inline">CustomerSearch</strong> screen, titled <a id="_idTextAnchor274"/><strong class="bold">View history</strong>, that, when pressed, navigates to the new route.</li>
</ol>
<h1 id="_idParaDest-235"><a id="_idTextAnchor275"/>Further reading</h1>
<p>The <strong class="source-inline">RelayEnvironmentProvider</strong> component:</p>
<p><a href="https://relay.dev/docs/api-reference/relay-environment-provider/">https://relay.dev/docs/api-reference/relay-environment-provider/</a></p>
</div>
<div>
<div id="_idContainer041">
</div>
</div>
</div>

<div id="sbo-rt-content"><div class="Content" id="_idContainer042">
<h1 id="_idParaDest-236"><a id="_idTextAnchor276"/>Part 3 – Interactivity</h1>
<p>This part introduces a new code base that allows us to explore more complex scenarios where TDD can be applied. You’ll take a deep dive into Redux middleware, animation, and WebSockets. The goal is to show how complex tasks are approached using the TDD workflow.</p>
<p>This part includes the following chapters:</p>
<ul>
<li><a href="B18423_14.xhtml#_idTextAnchor277"><em class="italic">Chapter 14</em></a>, <em class="italic">Building a Logo Interpreter</em></li>
<li><a href="B18423_15.xhtml#_idTextAnchor306"><em class="italic">Chapter 15</em></a>, <em class="italic">Adding Animation</em></li>
<li><a href="B18423_16.xhtml#_idTextAnchor322"><em class="italic">Chapter 16</em></a>, <em class="italic">Working with WebSockets</em></li>
</ul>
</div>
</div></body></html>