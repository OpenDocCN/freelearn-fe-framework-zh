- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exploring Popular Composition Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to make components communicate with each
    other effectively, which is a crucial part of building complex React applications
    using small, testable, and maintainable components. By mastering the popular composition
    patterns and tools in React, you will be able to take control of every single
    part of your application and build scalable and extensible software.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s dive in and explore how we can leverage these patterns and tools to build
    better React applications. We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How components communicate with each other using props and children
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The container and presentational patterns and how they can make our code more
    maintainable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What **higher-order components** (**HOCs**) are and how, thanks to them, we
    can structure our applications in a better way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What the function of the child component pattern is and what its benefits are
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Node.js 19+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the code for this chapter in the book’s GitHub repository at [https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter04).
  prefs: []
  type: TYPE_NORMAL
- en: Communicating components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Composing React components is one of the key benefits of building applications
    with React. By creating small, **reusable components** with clean interfaces,
    you can easily compose them together to create complex applications that are both
    powerful and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: Small components with a clean interface can be composed together to create complex
    applications that are powerful and maintainable at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Composing React components is straightforward; you just have to include them
    in the render:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: For example, you can create a `Profile` component by simply composing a `Picture`
    component to display the profile image and a `UserName` component to display the
    name and the screen name of the user.
  prefs: []
  type: TYPE_NORMAL
- en: In this way, you can produce new parts of the user interface very quickly, writing
    only a few lines of code. Whenever you compose components, as in the preceding
    example, you share data between them using props. Props are the way a parent component
    can pass its data down the tree to every component that needs it (or part of it).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, you will learn about the `children` prop and how to use
    it correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Using the children prop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a special prop that can be passed from the owners to the components
    defined inside their render—`children`.
  prefs: []
  type: TYPE_NORMAL
- en: In the React documentation, it is described as `opaque` because it is a property
    that does not tell you anything about the value it contains. Subcomponents defined
    inside the render of a parent component usually receive props that are passed
    as attributes of the component itself in JSX, or as a second parameter of the
    `_jsx` function. Components can also be defined with nested components inside
    them, and they can access those children using the `children` prop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider that we have a `Button` component that has a text property representing
    the text of the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The component can be used in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And this will render the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, suppose we want to use the same button with the same class name in multiple
    parts of our application, and we also want to be able to display more than a simple
    string. Our UI consists of buttons with text, buttons with text and icons, and
    buttons with text and labels.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, a good solution would be to add multiple parameters to `Button`
    or to create different versions of `Button`, each one with its single specialization,
    for example, `IconButton`.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we should realize that `Button` could just be a wrapper, and we are
    able to render any element inside it and use the `children` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: By passing the `children` prop, we are not limited to a simple single text property,
    but we can pass any element to `Button`, and it is rendered in place of the `children`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, any element that we wrap inside the `Button` component will be
    rendered as a child of the button element with `btn` as the class name.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we want to render an image inside the button and some text
    wrapped in a `span` tag, we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding snippet gets rendered in the browser as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is a pretty convenient way to allow components to accept any children elements
    and wrap those elements inside a predefined parent.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can pass images, labels, and even other React components inside the
    `Button` component, and they will be rendered as its children. As you can see
    in the preceding example, we defined the `children` property as an array, which
    means that we can pass any number of elements as the component’s children.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can pass a single child, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Let’s now explore the container and the presentational pattern in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the container and presentational patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we saw how to take a coupled component and make it reusable
    step by step. Now we will see how to apply a similar pattern to our components
    to make them clearer and more maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: React components typically contain a mix of *logic* and *presentation*. By logic,
    we refer to anything that is unrelated to the UI, such as API calls, data manipulation,
    and event handlers. The presentation is the part of the render where we create
    the elements to be displayed on the UI.
  prefs: []
  type: TYPE_NORMAL
- en: In React, there are simple and powerful patterns, known as `container` and `presentational`,
    which we can apply when creating components that help us to separate those two
    concerns.
  prefs: []
  type: TYPE_NORMAL
- en: Creating well-defined boundaries between logic and presentation not only makes
    components more reusable, but also provides many other benefits, which you will
    learn about in this section. Again, one of the best ways to learn new concepts
    is by seeing practical examples, so let’s delve into some code.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we have a component that uses geolocation APIs to get the position of
    the user and displays the latitude and longitude on the page in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create a `Geolocation.tsx` file in our `components` folder and define
    the `Geolocation` component using a functional component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We then define our states:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can use the `useEffect` Hook to fire the request to the APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When the browser returns the data, we store the result in the state using the
    following function (place this function before the `useEffect` Hook):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we show the latitude and longitude values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note that, during the first render, the latitude and longitude
    are null because we asked the browser for the coordinates when the component was
    mounted. In a real-world component, you might want to display a spinner until
    the data gets returned. To do that, you can use one of the conditional techniques
    we saw in *Chapter 3*, *Cleaning Up Your Code*.
  prefs: []
  type: TYPE_NORMAL
- en: Now, this component does not have any problems, and it works as expected. Wouldn’t
    it be nice to separate it from the part where the position gets requested and
    loaded to iterate faster on it?
  prefs: []
  type: TYPE_NORMAL
- en: We will use the container and presentational patterns to isolate the presentational
    part. In this pattern, every component is split into two smaller ones, each one
    with its clear responsibilities. The container knows everything about the logic
    of the component and is where the APIs are called. It also deals with data manipulation
    and event handling.
  prefs: []
  type: TYPE_NORMAL
- en: The presentational component is where the UI is defined, and it receives data
    in the form of props from the container. Since the presentational component is
    usually logic-free, we can create it as a functional, stateless component.
  prefs: []
  type: TYPE_NORMAL
- en: There are no rules that say that the presentational component must not have
    a state (for example, it could keep a UI state inside it). In this case, we need
    a component to display the latitude and longitude, so we are going to use a simple
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we should rename our `Geolocation` component `GeolocationContainer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We will also change the filename from `Geolocation.tsx` to `GeolocationContainer.tsx`.
  prefs: []
  type: TYPE_NORMAL
- en: This rule is not strict, but it is a best practice that’s widely used in the
    React community to append `Container` to the end of the `Container` component
    name and give the original name to the presentational one.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have to change the implementation of `render` and remove all the UI
    parts of it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding snippet, instead of creating the HTML elements
    inside the return of the container, we just use the presentational one (which
    we will create next), and we pass the state to it. The states are the latitude
    and longitude, which are null by default, and they contain the real position of
    the user when the browser fires the callback.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a new file, called `Geolocation.tsx`, where we define the functional
    component as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Functional components are an incredibly elegant way to define UIs. They are
    pure functions that, given a state, return the elements of it. In this case, our
    function receives the latitude and longitude from the owner, and it returns the
    markup structure to display it.
  prefs: []
  type: TYPE_NORMAL
- en: The first time you run the components in the browser, the browser will require
    your permission to allow it to know your location.
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application  Description automatically generated](img/B18414_04_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: Browser will require your permission to access your location'
  prefs: []
  type: TYPE_NORMAL
- en: 'After you allow the browser to know your location, you will see something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application  Description automatically generated](img/B18414_04_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: Displaying latitude and longitude'
  prefs: []
  type: TYPE_NORMAL
- en: In adherence to the container and presentational pattern, we have created a
    “dumb” or presentational component that is reusable and can be effortlessly integrated
    into our components. This enables us to conveniently pass mock coordinates for
    testing or demonstration purposes. If a similar data structure is needed elsewhere
    in the application, it eliminates the necessity of building a new component from
    scratch. Instead, we can encapsulate this existing component within a new container.
    This container could, for example, be designed to retrieve latitude and longitude
    information from a separate endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, other developers in our team can improve the container that
    uses geolocation by adding some error-handling logic, without affecting its presentation.
    They can even build a temporary presentational component just to display and debug
    data and then replace it with the real presentational component when it is ready.
  prefs: []
  type: TYPE_NORMAL
- en: Being able to work in parallel on the same component is a big win for teams,
    especially for those companies where building interfaces is an iterative process.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern is simple but very powerful, and when applied to big applications,
    it can make a difference when it comes to the speed of development and the maintainability
    of the project. On the other hand, applying this pattern without a real reason
    can give us the opposite problem and make the code base less useful as it involves
    the creation of more files and components.
  prefs: []
  type: TYPE_NORMAL
- en: So, we should think carefully when we decide that a component has to be refactored
    following the container and presentational patterns. In general, the right path
    to follow is starting with a single component and splitting it only when the logic
    and the presentation become too coupled where they shouldn’t be.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we began with a single component, and we realized that we could
    separate the API call from the markup. Deciding what to put in the container and
    what goes into the presentation is not always straightforward; the following points
    should help you make that decision:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the characteristics of container components:'
  prefs: []
  type: TYPE_NORMAL
- en: They are more concerned with behavior.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They render their presentational components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They make API calls and manipulate data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They define event handlers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are the characteristics of presentational components:'
  prefs: []
  type: TYPE_NORMAL
- en: They are more concerned with the visual representation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They render the HTML markup (or other components).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They receive data from the parents in the form of props.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are often written as stateless functional components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, these patterns form a really powerful tool that will help you
    to develop your web applications faster. Let’s see what HOCs are in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding HOCs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *functional programming* section of *Chapter 3*, *Cleaning Up Your Code*,
    we introduced the concept of **higher-order functions** (**HOFs**). HOFs are functions
    that accept another function as an argument, enhance its behavior, and return
    a new function. Applying the idea of HOFs to components results in **higher-order
    components** (**HOCs**).
  prefs: []
  type: TYPE_NORMAL
- en: 'An HOC looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: HOCs are functions that take a component as input and return an enhanced component
    as output. Let’s start with a simple example to understand what an enhanced component
    looks like.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you need to attach the same `className` property to every component.
    You could manually add the `className` property to each render method, or you
    could write an HOC like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the React community, it’s common to use the `with` prefix for HOCs.
  prefs: []
  type: TYPE_NORMAL
- en: The code above might be confusing at first, so let’s break it down. We declare
    a `withClassName` function that takes a `Component` and returns another function.
    The returned function is a functional component that receives some props and renders
    the original component. The collected props are spread, and a `className` property
    with the `"my-class"` value is passed to the functional component.
  prefs: []
  type: TYPE_NORMAL
- en: HOCs typically spread the props they receive on the component because they aim
    to be transparent and only add new behavior.
  prefs: []
  type: TYPE_NORMAL
- en: While this example is simple and not particularly useful, it should give you
    a better understanding of what HOCs are and what they look like. Now, let’s see
    how we can use the `withClassName` HOC in our components.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a stateless functional component that receives the `className`
    and applies it to a `div` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of using the component directly, we pass it to an HOC like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Wrapping our components in the `withClassName` function ensures that they receive
    the `className` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s create a more exciting HOC to detect the `innerWidth`. First, create
    a function that receives a `Component`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: It’s common practice to prefix HOCs that provide information to the components
    they enhance using the `with` pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, define the `innerWidth` state and the `handleResize` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the effects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, render the original component like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here, we spread the props as before, but we also pass the `innerWidth` state.
  prefs: []
  type: TYPE_NORMAL
- en: We store the `innerWidth` value as a state to achieve the original behavior
    without polluting the component’s state. Instead, we use props. Using props is
    an excellent way to promote reusability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, using an HOC and getting the `innerWidth` value is straightforward. The
    new React Hooks can easily replace an HOC by creating custom Hooks. Create a functional
    component that expects `innerWidth` as a property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Enhance it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: By using HOCs, we avoid polluting any state and don’t require the component
    to implement any function. This means the component and HOC are not coupled, and
    both can be reused throughout the application.
  prefs: []
  type: TYPE_NORMAL
- en: Using props instead of state allows us to create a “dumb” component that can
    be used in our style guide, ignoring complex logic and just passing down the props.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this specific case, we could create a component for each of the different
    `innerWidth` sizes we support. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Or the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, by using HOCs, we can pass a component and then return a new
    component with additional functionalities. Some common HOCs are `connect` from
    Redux and `createFragmentContainer` from Relay.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding FunctionAsChild
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `FunctionAsChild`pattern is gaining consensus within the React community.
    It is widely used in popular libraries like **react-motion**, which we will explore
    in *Chapter 5*, *Writing Code for the Browser*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main concept is that instead of passing a child as a component, we define
    a function that can receive parameters from the parent. Let’s see what it looks
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `FunctionAsChild` is a component with a children property defined
    as a function. Instead of being used as a JSX expression, it gets called.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding component can be used like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This example is quite simple: the children function is executed within the
    parent’s render method, returning the `Hello, World!` text wrapped in a `div`
    tag, which is displayed on the screen.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s explore a more meaningful example where the parent component passes
    some parameters to the children function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `Name` component that expects a function as children and passes it
    the `''World''` string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding component can be used like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The primary advantage is the ability to encapsulate components, delivering
    variables dynamically, as opposed to utilizing static properties, which is a common
    practice with HOCs. An excellent illustration of this is a `Fetch` component,
    designed to retrieve data from a specific API endpoint and subsequently return
    it to its child function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Secondly, composing components with this approach does not force children to
    use predefined prop names. Since the function receives variables, developers who
    use the component can decide on their names. This flexibility makes the Function
    as Child solution more versatile.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, the wrapper is highly reusable because it does not make any assumptions
    about the children it receives—it just expects a function. Due to this, the same
    `FunctionAsChild` component can be used in different parts of the application
    to serve various children components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By adopting the Function as Child pattern, you can create more flexible, versatile,
    and reusable components in your React applications.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to effectively compose and communicate between
    our reusable components using props. By using props, we can create well-defined
    interfaces and decouple our components from each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also explored two popular composition patterns: the container and presentational
    pattern, which help us separate our logic and presentation for more specialized
    and focused components. Additionally, we discovered **Higher-Order Components**
    (**HOCs**) as a way to handle context without tightly coupling our components
    to it, and the Function as Child pattern for composing components dynamically.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will dive into controlled vs. uncontrolled components,
    refs, handling events, and animations in React.
  prefs: []
  type: TYPE_NORMAL
