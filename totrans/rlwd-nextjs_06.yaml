- en: '*Chapter 4*: Organizing the Code Base and Fetching Data in Next.js'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next.js initially became popular thanks to its ability to make it easy to render
    React pages on the server instead of the client only. However, to render specific
    components, we often need some data coming from external sources such as APIs
    and databases.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will first see how to organize our folder structure, as
    this will be the determinant for keeping the Next.js dataflow neat when managing
    the application state (as we will see in [*Chapter 5*](B16985_05_Final_SB_epub.xhtml#_idTextAnchor068),
    *Managing Local and Global States in Next.js*), and then we will see how to integrate
    external REST and GraphQL APIs, both on client and server-side.
  prefs: []
  type: TYPE_NORMAL
- en: As our application grows, its complexity will inevitably increase, and we need
    to be prepared for this since the bootstrapping phase of the project. As soon
    as we implement new features, we will need to add new components, utilities, styles,
    and pages. For that reason, we will take a closer look at organizing our components
    on the basis of the atomic design principles, utility functions, styles, and how
    to make your code base ready for handling the application state quickly and neatly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: Organizing our components using the atomic design principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizing our utility functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizing static assets neatly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to organizing styling files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What `lib` files are and how to organize them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consuming REST APIs on the server side only
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consuming REST APIs on the client side only
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting Apollo to consume GraphQL APIs both on client and server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will know how to organize your code base by
    following the atomic design principles for your components and how to split up
    different utility files logically. You will also learn how to consume REST and
    GraphQL APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To run the code examples in this chapter, you need to have both Node.js and
    npm installed on your local machine. If you prefer, you can use an online IDE
    such as [https://repl.it](https://repl.it) or [https://codesandbox.io](https://codesandbox.io),
    as they both support Next.js and you don't need to install any dependency on your
    computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the code base for this chapter on GitHub: [https://github.com/PacktPublishing/Real-World-Next.js](https://github.com/PacktPublishing/Real-World-Next.js).'
  prefs: []
  type: TYPE_NORMAL
- en: Organizing the folder structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Organizing your new project's folder structure neatly and clearly is incredibly
    important in terms of keeping your code base scalable and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: As we've already seen, Next.js forces you to place some files and folders in
    particular locations of your code base (think of `_app.js` and `_documents.js`
    files, the `pages/` and `public/` directories, and so on), but it also provides
    a way to customize their placement inside your project repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve already seen that, but let''s do a quick recap on a default Next.js
    folder structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Reading from top to bottom, when we create a new Next.js app using `create-next-app`,
    we get the following folders:'
  prefs: []
  type: TYPE_NORMAL
- en: '`node_modules/`: The default folder for Node.js project dependencies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pages/`: The directory where we place our pages and build the routing system
    for our web app'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public/`: The directory where we place files to be served as static assets
    (compiled CSS and JavaScript files, images, and icons)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`styles/`: The directory where we place our styling modules, regardless of
    their format (CSS, SASS, LESS)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From here, we can start customizing our repository structure to make it easier
    to navigate through. The first thing to know is that Next.js allows us to move
    our `pages/` directory inside an `src/` folder. We can also move all the other
    directories (except for the `public/` one and `node_modules`, of course) inside
    `src/`, making our root directory a bit tidier.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Remember that if you have both `pages/` and `src/pages/` directories in your
    project, Next.js will ignore `src/pages/`, as the root level `pages/` directory
    takes precedence.
  prefs: []
  type: TYPE_NORMAL
- en: We will now take a look at some popular conventions for organizing the whole
    code base, starting with React components, in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing the components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's see an example of a real-world folder structure, including some styling
    assets ([*Chapter 6*](B16985_06_Final_SB_epub.xhtml#_idTextAnchor075), *CSS and
    Built-In Styling Methods)* and test files ([*Chapter 9*](B16985_09_Final_SB_epub.xhtml#_idTextAnchor096),
    *Testing Next.js*).
  prefs: []
  type: TYPE_NORMAL
- en: As for now, we will only discuss a folder structure that can help us write and
    find configuration files, components, tests, and styles with ease. We will dig
    into the previously quoted technologies in their respective chapters.
  prefs: []
  type: TYPE_NORMAL
- en: We have different ways of setting up our folder structure. We can start by separating
    components into three different categories and then putting styles and tests in
    the same folder for each component.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, create a new `components/` folder inside our root directory. Then,
    by moving inside it, create the following folders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you may have noticed, we're following the *atomic design principle*, where
    we want to divide our components into different levels so as to organize our code
    base better. This is just a popular convention, and you're free to follow any
    other approach for organizing your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will divide our components into four categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '`atoms`: These are the most basic components that we will ever write in our
    code base. Sometimes, they act as a wrapper for standard HTML elements such as
    `button`, `input`, and `p`, but we can also add animations, color palettes, and
    so on, to this category of components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`molecules`: These are a small group of atoms combined to create slightly more
    complex structures with a minimum of utility. The input atom and the label atom
    together can be a straightforward example of what a molecule is.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`organisms`: Molecules and atoms combine to create complex structures, such
    as a registration form, a footer, and a carousel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`templates`: We can think of templates as the skeleton of our pages. Here,
    we decide where to put organisms, atoms, and molecules together to create the
    final page that the user will browse.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you''re interested in learning more about atomic design, here''s a good
    article explaining it in detail: [https://bradfrost.com/blog/post/atomic-web-design](https://bradfrost.com/blog/post/atomic-web-design).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s pretend that we want to create a `Button` component. When we create
    a new component, we often need at least three different files: the component itself,
    its style, and a test file. We can create those files by moving inside `components/atoms/`
    and then creating a new folder called `Button/`. Once we create this folder, we
    can move on to creating the components'' files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Organizing our components that way will help us a lot when we need to search,
    update, or fix a given component. Let's say that we spot a bug in production that
    involves our `Button` component. We can easily find the component inside our code
    base, find its test and styling files, and fix them.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, following the atomic design principle is not a must, but I'd personally
    recommend it as it helps keep the project structure tidy and easy to maintain
    over time.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing utilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are specific files that don't export any component; they're just modular
    scripts used for many different purposes. We're talking here about the utility
    scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Let's pretend that we have several components whose purpose is to check whether
    a particular hour of the day has passed to display certain information. It wouldn't
    make any sense to write the same function inside every component. We can therefore
    write a generic utility function and then import it inside every component that
    needs that kind of feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can put all of our utility functions inside a `utility/` folder and then
    divide our utilities into different files according to their purpose. For example,
    let''s say that we need four utility functions: the first one will make computations
    based on the current time, the second will execute certain operations on `localStorage`,
    the third will work with **JWT (JSON Web Token)**, and the last one will help
    us to write better logs for our applications.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can proceed by creating four different files inside the `utilities/` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''ve created our files, we can proceed by creating their respective
    test files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we have our utilities grouped by their scope, which makes it
    easy to remember from which file we need to import a specific function during
    the development process.
  prefs: []
  type: TYPE_NORMAL
- en: There might be other approaches for organizing utility files. You may want to
    create a folder for each utility file so that you can put tests, styles, and other
    stuff inside it, thereby making your code base even more organized. It's totally
    up to you!
  prefs: []
  type: TYPE_NORMAL
- en: Organizing static assets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As seen in the previous chapter, Next.js makes it easy to serve static files,
    as you only need to put them inside the `public/` folder, and the framework will
    do the rest.
  prefs: []
  type: TYPE_NORMAL
- en: From this point, we need to figure out which static files we need to serve from
    our Next.js application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a standard website, we may want to serve at least the following static assets:'
  prefs: []
  type: TYPE_NORMAL
- en: Images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiled JavaScript files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiled CSS files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Icons (including favicon and web app icons)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`manifest.json`, `robot.txt`, and other static files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Moving inside our `public/` folder, we can create a new directory called `assets/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'And inside that newly created directory, we will be creating a new folder for
    each type of static asset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We will place our compiled vendor JavaScript files inside the `js/` directory
    and do the same with compiled vendor CSS files (inside the `css/` directory, of
    course). When starting our Next.js server, we will be able to reach those public
    files under http://localhost:3000/assets/js/<any-js-file> and http://localhost:3000/assets/css/<any-css-file>.
    We will also be able to reach every public image by calling the following URL,
    http://localhost:3000/assets/image/<any-image-file>, but I suggest that you serve
    those kinds of assets using the built-in `Image` component, as seen in the previous
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The `icons/` directory will primarily be used to serve our *web app manifest*
    icons. The web app manifest is a JSON file that includes some useful information
    about the progressive web app that you're building, such as the app name and the
    icons to use when installing it on a mobile device. You can learn more about the
    web app manifest on [https://web.dev/add-manifest](https://web.dev/add-manifest).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can easily create this manifest file by entering the `public/` folder and
    adding a new file called `manifest.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we can fill the JSON file with some basic information. Let''s
    take the following JSON as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can include that file using an HTML meta tag, as seen in [*Chapter 3*](B16985_03_Final_SB_epub.xhtml#_idTextAnchor038),
    *Next.js Basics and Built-In Components*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: That way, users browsing your Next.js app from a mobile device will be able
    to install it on their smartphones or tablets.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing styles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Style organization can really depend on the stack you want to use to style your
    Next.js application.
  prefs: []
  type: TYPE_NORMAL
- en: Starting from *CSSinJS* frameworks such as *Emotion*, *styled-components*, *JSS*,
    and similar ones, one common approach is to create a specific styling file for
    each component; that way, it will be easier for us to find a particular component
    style inside our code base when we need to make some changes.
  prefs: []
  type: TYPE_NORMAL
- en: However, even though separating styling files depending on their respective
    components can help us keep our code base organized, we may need to create some
    common styles or utility files, such as color palettes, themes, and media queries.
  prefs: []
  type: TYPE_NORMAL
- en: In that case, it can be useful to reuse the default `styles/` directory shipped
    with a default Next.js installation. We can put our common styles inside that
    folder and import them inside other styling files only when we need them.
  prefs: []
  type: TYPE_NORMAL
- en: That said, there isn't really a standard way to organize styling files. We will
    take a closer look at those files in both [*Chapter 6*](B16985_06_Final_SB_epub.xhtml#_idTextAnchor075),
    *CSS and Built-In Styling Methods*, and [*Chapter 7*](B16985_07_Final_SB_epub.xhtml#_idTextAnchor081),
    *Using UI Frameworks*.
  prefs: []
  type: TYPE_NORMAL
- en: Lib files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When talking about lib files, we refer to scripts that explicitly wrap third-party
    libraries as lib files. While the utility scripts are very generic and can be
    used by many different components and libraries, the lib files are specific for
    a certain library. To make the concept clearer, let's talk about GraphQL for a
    moment.
  prefs: []
  type: TYPE_NORMAL
- en: As we're going to see in *Data fetching*, the last section of this chapter,
    we will need to initialize a GraphQL client, save some GraphQL queries and mutations
    locally, and so on. To make those scripts more modular, we will store them inside
    a new folder called `graphql/`, which lies inside a `lib/` directory, at the root
    of our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try to visualize the folder structure for the preceding example, we will
    end up with the following schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Other lib scripts can include all those files connecting and making queries
    to Redis, RabbitMQ, and so on, or functions specific to any external library.
  prefs: []
  type: TYPE_NORMAL
- en: While an organized folder structure seems out of context when talking about
    the Next.js data flow, it can actually help us to manage the application state,
    as we will see in [*Chapter 5*](B16985_05_Final_SB_epub.xhtml#_idTextAnchor068),
    *Managing Local and Global States in Next.js*
  prefs: []
  type: TYPE_NORMAL
- en: But talking about the application state, we want our components to be dynamic
    most of the time, meaning that they can render content and behave differently
    depending on the global application state or the data coming from external services.
    In fact, we need to call external APIs to retrieve our web app content dynamically
    in many cases. In the next section, we will see how to fetch data on the client
    and server sides, using both GraphQL and REST clients.
  prefs: []
  type: TYPE_NORMAL
- en: Data fetching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As seen in the previous chapters, Next.js allows us to fetch data on both the
    client and server sides. Server-side data fetching could happen in two different
    moments: at build time (using `getStaticProps` for static pages), and at runtime
    (using `getServerSideProps` for server-side rendered pages).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Data can come from several resources: databases, search engines, external APIs,
    filesystems, and many other sources. Even if it''s technically possible for Next.js
    to access a database and query for specific data, I''d personally discourage that
    approach as Next.js should only care about the frontend of our application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take an example: we''re building a blog, and we want to display an author
    page showing their name, job title, and biography. In that example, the data is
    stored in a MySQL database, and we could easily access it using any MySQL client
    for Node.js.'
  prefs: []
  type: TYPE_NORMAL
- en: Even though accessing that data from Next.js can be relatively easy, it would
    make our app less secure. A malicious user could potentially find a way to exploit
    our data using an unknown framework vulnerability, injecting malicious code, and
    using other techniques to steal our data.
  prefs: []
  type: TYPE_NORMAL
- en: For that reason, I strongly suggest delegating database connections and queries
    to external systems (in other words, CMSes such as *WordPress*, *Strapi*, and
    *Contentful*) or backend frameworks (in other words, *Spring*, *Laravel*, and
    *Ruby on Rails*), which will make sure that the data is coming from a trusted
    source, will sanitize the user input detecting potentially malicious code, and
    will establish a secure connection between your Next.js application and their
    APIs.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will see how to integrate *REST* and *GraphQL*
    APIs from both the client side and the server side.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching data on the server side
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we've seen so far, Next.js allows us to fetch data on the server side by
    using its built-in `getStaticProps` and `getServerSideProps` functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given that Node.js doesn''t support JavaScript `fetch` APIs like browsers do,
    we have two options for making HTTP requests on the server:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the Node.js'' built-in `http` library: We can use this module without
    installing any external dependency, but even if its APIs are really simple and
    well made, it would require a bit of extra work when compared to third-party HTTP
    clients.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using HTTP client libraries: There are several great HTTP clients for Next.js,
    making it really straightforward to make HTTP requests from the server. Popular
    libraries include *isomorphic-unfetch* (this renders the JavaScript `fetch` API
    available on Node.js), *Undici* (an official Node.js HTTP 1.1 client), and *Axios*
    (a very popular HTTP client that runs both on client and server with the same
    APIs).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next section, we will be using *Axios* to make REST requests, as it is
    probably one of the most frequently used HTTP clients for both client and server
    (with ~17,000,000 downloads per week on npm), and there's a high chance that you
    will be using it sooner or later.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming REST APIs on the server side
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When discussing the integration of REST APIs, we need to divide them into *public*
    and *private* APIs. The public ones are accessible by anyone without any kind
    of authorization, and the private ones always need to be authorized to return
    some data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, the authorization method is not always the same (and different APIs might
    require different authorization methods), as it depends on who developed the APIs
    and the choices they made. For instance, if you want to consume any of the *Google*
    APIs, you would need to go into a process called *OAuth 2.0*, which is an industry
    standard for securing APIs under user authentication. You can read more about
    OAuth 2.0 in the official Google documentation: [https://developers.google.com/identity/protocols/oauth2](https://developers.google.com/identity/protocols/oauth2).'
  prefs: []
  type: TYPE_NORMAL
- en: Other APIs, such as the *Pexels* APIs ([https://www.pexels.com/api/documentation](https://www.pexels.com/api/documentation)),
    allow you to consume their contents using an *API key*, which is basically an
    authorization token that you'll need to send within your request.
  prefs: []
  type: TYPE_NORMAL
- en: There may be other ways in which to authorize your requests, but Oauth 2.0,
    JWT, and API Key are the most common ways that you'll likely encounter while developing
    your Next.js applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'If, after reading this section, you want to experiment with different APIs
    and authorization methods, here''s an awesome GitHub repository containing a list
    of free REST APIs: https://github.com/public-apis/public-apis.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, we will be using a custom API explicitly made for this book: [https://api.realworldnextjs.com](https://api.realworldnextjs.com)
    (or, if you prefer: https://api.rwnjs.com). We can start by creating a new Next.js
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the Next.js initialization script, we can add `axios` as a dependency,
    as we''ll use it as an HTTP client for making REST requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we can easily edit the default Next.js index page. Here, we will
    list some users using a public API exposing just their usernames and personal
    IDs. After we click on one of the usernames, we will be redirected to a detail
    page to see more personal details for our users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating the `pages/index.js` page layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to run the preceding code, we will see an error, as we don''t yet
    have our users'' data. We need to call a REST API from the built-in `getServerSideProps`
    and pass the request result as a prop to the `HomePage` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the server and then go to `http://localhost:3000`. We should see the
    following list of users to appear on the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – API result rendered on the browser'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.01_B16985.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.1 – API result rendered on the browser
  prefs: []
  type: TYPE_NORMAL
- en: If we now try to click on one of the listed users, we will be redirected to
    a 404 page, as we haven't created a single page user yet.
  prefs: []
  type: TYPE_NORMAL
- en: We can solve that problem by creating a new file, `pages/users/[username].js`,
    and calling another REST API to get the single user data.
  prefs: []
  type: TYPE_NORMAL
- en: To get the single user data, we can call the following URL, https://api.rwnjs.com/04/users/[username],
    where `[username]` is a route variable representing the user we want to get the
    data of.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move to the `pages/users/[username].js` file and add the following content,
    starting with the `getServerSideProps` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, inside the same file, let''s add a `UserPage` function, which will be
    the page template for our `/users/[username]` route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'But there''s still a problem: if we try to render a single user page, we will
    get an error on the server side as we are not authorized to get the data from
    that API. Remember what we said at the beginning of this section? Not all APIs
    are public, which makes a lot of sense as there are times where we want to access
    very private information and companies and developers protect this information
    by restricting access to their APIs to authorized people only.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In that case, we need to pass a valid token as an HTTP authorization header
    while making the API request, such that the server will know that we are authorized
    to access this information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `axios` makes it really easy to add an HTTP header to the request,
    as we only need to pass an object as the second argument of its `get` method,
    containing a property called `headers`, which is an object including all the HTTP
    headers we want to send to the server within our request.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may be wondering what `process.env.API_TOKEN` stands for. While it is possible
    to pass a hardcoded string as a value for that header, it is bad practice for
    the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: When committing your code using Git or any other version control system, everyone
    having access to that repository will be able to read private information such
    as the authorization token (even outside collaborators). Consider this as a password
    that should be kept secret.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Most of the time, API tokens change depending on the stage at which we''re
    running our application: running our app locally, we may want to access APIs using
    a test token, and use a production one when deploying it. Using an environment
    variable will make it easier for us to use different tokens depending on the environment.
    The same is valid for API endpoints, but we will see that later on in this section.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If an API token changes for any reason, you can easily edit it using a shared
    environment file for the whole app instead of changing the token value in every
    HTTP request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, instead of manually writing sensitive data inside our files, we can create
    a new file called `.env` inside our project's root and add all the information
    we need for our application to run.
  prefs: []
  type: TYPE_NORMAL
- en: Never Commit Your .env File
  prefs: []
  type: TYPE_NORMAL
- en: The `.env` file contains sensitive and private information and should never
    be committed using any version control software. Make sure to add `.env` to your
    `.gitignore`, `.dockerignore`, and other similar files before deploying or committing
    your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create and edit the `.env` file by adding the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Next.js has built-in support for `.env` and `.env.local` files, so you don't
    have to install external libraries to access those environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we''ve edited the file, we can restart the Next.js server and click on
    any user listed on the home page, thereby accessing the user detail page, which
    should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – The user detail page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4_02_B16985.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.2 – The user detail page
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try to reach a page such as `http://localhost:3000/users/mitch`, we will
    get an error, as a user with `mitch` as their username does not exist, and the
    REST API will return a `404` status code. We can easily catch this error and return
    the Next.js default 404 page by just adding the following script to the `getServerSideProps`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: That way, Next.js will automatically redirect us to its default `404` page with
    no other configuration needed.
  prefs: []
  type: TYPE_NORMAL
- en: So, we've seen how Next.js allows us to fetch data exclusively on the server
    side by using its built-in `getServerSideProps` function. We could have used the
    `getStaticProps` function instead, meaning that the page would have been statically
    rendered at build time, as seen in [*Chapter 2*](B16985_02_Final_SB_epub.xhtml#_idTextAnchor029),
    *Exploring Different Rendering Strategies*.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will see how to fetch data on the client side only.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching data on the client side
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Client-side data fetching is a crucial part of any dynamic web application.
    While server-side data fetching can be relatively secure (when done with caution),
    fetching data on the browser can add some extra complexities and vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Making HTTP requests on the server hides the API endpoint, parameters, HTTP
    headers, and possibly the authorization tokens from the users. However, doing
    so from the browser can reveal that private information, making it easy for malicious
    users to perform a plethora of possible attacks that exploit your data.
  prefs: []
  type: TYPE_NORMAL
- en: 'When making HTTP requests on browsers, some specific rules are not optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Make HTTP requests to trusted sources only*. You should always do some research
    about who is developing the APIs you''re using and their security standards.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Call HTTP APIs only when secured with an SSL certificate*. If a remote API
    is not secured under HTTPS, you''re exposing yourself and your users to many attacks,
    such as man-in-the-middle, where a malicious user could sniff all the data passing
    from the client and the server using a simple proxy.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Never connect to a remote database from the browser*. It may seem obvious,
    but it is technically possible for JavaScript to access remote databases. This
    exposes you and your users to high risk, as anyone could potentially exploit a
    vulnerability and gain access to your database.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next section, we will take a closer look at consuming REST APIs on the
    client side.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming REST APIs on the client side
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to the server side, fetching data on the client side is relatively easy,
    and if you already have experience in React or any other JavaScript framework
    or library, you can re-use your current knowledge for making REST requests from
    the browser without any complications.
  prefs: []
  type: TYPE_NORMAL
- en: While the server-side data fetching phase in Next.js only occurs when declared
    inside its built-in `getServerSideProps` and `getStaticProps` functions, if we
    make a fetch request inside a given component, it will be executed on the client
    side by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'We usually want our client-side requests to run in two cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Right after the component has mounted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After a particular event occurs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In both cases, Next.js doesn't force you to execute those requests differently
    than React, so you can basically make an HTTP request using the browser's built-in
    `fetch` API or an external library such as `axios`, just like we saw in the previous
    section. Let's try to recreate the same simple Next.js application from the previous
    section, but move all the API calls to the client side.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Next.js project and edit the `pages/index.js` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Can you spot the differences between this component and its SSR counterpart?
  prefs: []
  type: TYPE_NORMAL
- en: The HTML generated on the server side contains the `Loading users...` text,
    as it is the initial state of our `HomePage` component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be able to see a list of users only after React hydration occurs. We
    will need to wait for the component to mount on the client side and the HTTP request
    to be spawned using the browser's `fetch` API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we need to implement the single user page as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new file, `pages/users/[username].js`, and start writing the
    `getServerSideProps` function, where we fetch the `[username]` variable from the
    route and the authorization token from the `.env` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, inside the same file, let''s create the `UserPage` component, where we''ll
    execute the client-side data fetching function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you may have noticed, once we set the data using the `setData` hook function,
    we render a `<UserData />` component.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create that last component, always inside the same `pages/users/[username].js`
    component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, we're using the same approach as we did for the home page, making
    an HTTP request as soon as the component mounts on the client side. We're also
    passing the `API_TOKEN` from the server to the client using `getServerSideProps`
    so that we can use it for making an authorized request. However, if you try to
    run the preceding code, you will see at least two problems.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The first one is related to **CORS**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`HomePage` component, we''ve been able to call the `https://api.rwnjs.com/04/users`
    API from a different domain (localhost, a replit.co domain, CodeSandbox domain,
    and so on) as the server allowed any domain to access its resources for that specific
    route.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In that case, however, the browser makes some restrictions on the `https://api.rwnjs.com/04/users/[username]`
    endpoint, and we''re not able to call this API directly from the client as we
    get blocked by CORS policy. CORS can be tricky sometimes, and I encourage you
    to read more about it on the Mozilla Developer Network page dedicated to this
    security policy: [https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second problem relates to exposing the authorization token to the client.
    In fact, if we open the Google Chrome developer tools and go to **Network**, we
    can select the HTTP request for the endpoint and see the authorization token in
    plain text in the **Request Headers** section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – The HTTP Request Headers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4_03_B16985.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.3 – The HTTP Request Headers
  prefs: []
  type: TYPE_NORMAL
- en: So, what's wrong with that?
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that you're paying for a service exposing live weather updates via an
    API and pretend that it costs $1 for every 100 requests.
  prefs: []
  type: TYPE_NORMAL
- en: A malicious user who wants to use that same service without paying could easily
    find your private authorization token in the request header and use it to power
    their weather web app. That way, if the malicious user makes 1,000 requests, you'll
    be paying $10 without actually using their services.
  prefs: []
  type: TYPE_NORMAL
- en: We can quickly solve both problems thanks to the Next.js API pages, which allows
    us to quickly create a REST API, making the HTTP request for use on the server
    side and returning the result to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new folder inside `pages/` called `api/` and a new file, `pages/api/singleUser.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, in this case, we''re exposing a simple function taking two
    arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`req`: An instance of Node.js'' `http.IncomingMessage` ([https://nodejs.org/api/http.html#http_class_http_incomingmessage](https://nodejs.org/api/http.html#http_class_http_incomingmessage))
    merged with some pre-built middlewares such as `req.cookies`, `req.query`, and
    `req.body`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`res`: An instance of Node.js'' `http.serverResponse` ([https://nodejs.org/api/http.html#http_class_http_serverresponse](https://nodejs.org/api/http.html#http_class_http_serverresponse)),
    merged with some pre-built middleware such as `res.status(code)` for setting the
    HTTP status code, `res.json(json)` for returning a valid JSON, `res.send(body)`
    for sending an HTTP response containing a `string`, an `object`, or a `Buffer`,
    and `res.redirect([status,] path)` for redirecting to a specific page with a given
    (and optional) status code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every file inside the `pages/api/` directory will be considered by Next.js as
    an API route.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can refactor our `UserPage` component by changing the API endpoint to
    the newly created one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If we now try to run our website, we will see that both our problems are solved!
  prefs: []
  type: TYPE_NORMAL
- en: But there's still something we need to pay attention to. We've hidden the API
    token by writing a kind of *proxy* for the single user API, but a malicious user
    would still be able to use the `/api/singleUser` route to access private data
    with ease.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve that specific problem, we can act in a variety of different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Render the component list exclusively on the server, just like in the previous
    section: That way, a malicious user won''t call a private API or steal a secret
    API token. However, there are cases where you cannot run those kinds of API calls
    on the server only; if you need to make a REST request after the user clicks on
    a button, you''re forced to make it on the client side.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use an authentication method to let authenticated users only access a specific
    API (JWT, API key, and so on).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use a backend framework such as **Ruby on Rails**, **Spring,** **Laravel**,
    **Nest.js**, and **Strapi**: They all provide different ways of securing your
    API calls from the client, making it way more comfortable for us to create secure
    Next.js applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [*Chapter 13*](B16985_13_Final_SB_epub.xhtml#_idTextAnchor131), *Building
    an E-commerce Website with Next.js and GraphCMS*, we will see how to use Next.js
    as a frontend for different CMSes and e-commerce platforms, and we'll also cover
    user authentication and secure API calls. For now, in this chapter, we will only
    focus on how to make HTTP requests from both the server and client.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will see how to adopt GraphQL as a REST alternative
    for fetching data in Next.js.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming GraphQL APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GraphQL has been a game-changer in the API world, and it is increasing its popularity
    thanks to its ease of use, modularity, and flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: For those who are not very familiar with GraphQL, it is basically a query language
    for APIs first invented by *Facebook* back in 2012\. It improves many key aspects
    of data fetching and manipulation compared to other web service architectures
    such as REST or SOAP. In fact, it allows you to avoid data over-fetching (you
    can simply query the data fields you need), get multiple resources within a single
    request, obtain a strongly and statically typed interface for your data, avoid
    API versioning, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will be using Apollo Client ([https://www.apollographql.com/docs/react](https://www.apollographql.com/docs/react)),
    a very popular GraphQL client with built-in support for both React and Next.js
    for building a very simple online signbook.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a new project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add a couple of dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We will need now to create an Apollo client for our Next.js application. We
    will do that by creating a new file inside `lib/apollo/index.js` and then writing
    the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can assume, by setting `ssrMode: typeof window === "undefined"`, we
    will use the same Apollo instance for both client and server. Also, `ApolloClient`
    uses the browser `fetch` API to make HTTP requests, so we''ll need to import a
    polyfill to make it work on the server side; in that case, we''ll be using `isomorphic-unfetch`.'
  prefs: []
  type: TYPE_NORMAL
- en: If you try to run [https://api.realworldnextjs.com/04/signbook/graphql](https://api.realworldnextjs.com/04/signbook/graphql)
    on a browser, it will redirect you to a public *GraphCMS* GraphQL editor. In fact,
    we will be using that headless CMS as the data source for the application we're
    currently writing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the same `lib/apollo/index.js` file, let''s add a new function to initialize
    the Apollo client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This function will allow us to avoid recreating a new Apollo client for each
    page. In fact, we will store a client instance on the server (inside the previously
    written `apolloClient` variable), where we can pass an initial state as an argument.
    If we pass that parameter to the `initApollo` function, it will be merged with
    the local cache to restore a full representation of the state once we move to
    another page.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve that, we will first need to add another `import` statement to the
    `lib/apollo/index.js` file. Given that re-initializing the Apollo client with
    a complex initial state can be an expensive task in terms of performance, we will
    use the React `useMemo` hook to speed up the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, we will `export` one last function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Moving to our `pages/` directory, we can now create a new `_app.js` file, as
    seen in *Chapter 3*, *Next.js Basics and Built-In Components*. Here, we will wrap
    the whole app using the official Apollo context provider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We can finally start to write our queries!
  prefs: []
  type: TYPE_NORMAL
- en: We will organize our queries inside a new folder called `lib/apollo/queries/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a new file, `lib/apollo/queries/getLatestSigns.js`,
    exposing the following GraphQL query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now `import` this query inside our `pages/index.js` file and try to
    make our first GraphQL request using Apollo and Next.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the Apollo client is incredibly easy to use. Thanks to the
    `useQuery` hook, we will have access to three different states:'
  prefs: []
  type: TYPE_NORMAL
- en: '`loading`: As the name suggests, it only returns `true` or `false` when a request
    is fulfilled or is still pending.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`error`: If the request fails for any reason, we will be able to catch the
    error and send a nice message to the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data`: Contains the data we asked for with our query.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's move back to our home page page for a moment. For simplicity, we
    will just add a remote *TailwindCSS* dependency for styling our demo app. In [*Chapter
    6*](B16985_06_Final_SB_epub.xhtml#_idTextAnchor075), *CSS and Built-In Styling
    Methods*, and [*Chapter 7*](B16985_07_Final_SB_epub.xhtml#_idTextAnchor081), *Using
    UI Frameworks*, we will see how to optimize and integrate UI frameworks, but for
    now, we will keep things simple as we want to focus just on the data-fetching
    part of our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `pages/index.js` file and edit it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can create a new file, `components/Loading.js`. We will render it while
    we''re fetching the signs from `GraphCMS`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have successfully fetched the desired data, we need to display it on
    the home page. To do that, we will create a new component inside the `components/Sign.js`
    file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s integrate those two new components inside our home page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: If we now try to browse the home page, we will see a list of signs!
  prefs: []
  type: TYPE_NORMAL
- en: 'We could also create a simple route for adding a new sign by creating a new
    page under `pages/new-sign.js`. Let''s start by adding the required `imports`
    for that page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we're importing a bunch of functions from different libraries.
    We will use the `useState` React hook to keep track of the changes in our form
    for submitting the sign, Next.js' `useRouter` hook for redirecting the user to
    the home page once they have created a new sign, and Apollo's `useMutation` hook
    for creating a new sign on GraphCMS. We also `import` a new GraphQL mutation called
    `ADD_SIGN`, and we will see this in detail after we have created this page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on, we create the page structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Reading from top to bottom, we can see that we're using Apollo's `useMutation`
    hook to create a new sign. Once the sign has been created correctly, it will run
    the `onCompleted` callback, where we will redirect the user to the home page.
  prefs: []
  type: TYPE_NORMAL
- en: Moving to the next function declared inside the component body, we can clearly
    see that we'll use the `handleInput` function to dynamically set the form state
    using the React `useState` hook as soon as the user types something in any form
    input.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to render the actual HTML containing a form with just three inputs:
    the user''s `nickname`, a message to be written in the `signbook`, and (optionally)
    the `country` where the user is writing from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a closer look at how we create a mutation by clicking the submit
    button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we''re taking the entire state stored inside the `formState`
    variable coming from the `useState` hook and passing it as a value for the `variables`
    property used by the `addSign` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The `addSign` function represents the mutation that will add a new sign to
    GraphCMS, and we can add dynamic data by passing an object matching the mutation
    variables written inside the `lib/apollo/queries/addSign.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ADD_SIGN` mutation, in fact, takes three argument variables: `$nickname`,
    `$content`, and `$country`. Using form field names that reflect the naming of
    the mutation variables, we can simply pass the whole form state as a value to
    our mutation.'
  prefs: []
  type: TYPE_NORMAL
- en: You can now try to create a new sign. After submitting the form, you will be
    automatically redirected to the home page and you will see your sign at the top
    of the page.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ve taken a look at two crucial topics when talking about
    Next.js: the project structure organization and the different ways of fetching
    data. Even if these two topics seem unrelated, being able to logically separate
    components and utilities, and fetching data in different ways, are essential skills
    that will allow you to better understand the next chapter, [*Chapter 5*](B16985_05_Final_SB_epub.xhtml#_idTextAnchor068)*,*
    *Managing Local and Global States in Next.js*. As we''ve seen in this chapter,
    the complexity of any application can only grow over time as we add more features,
    bug fixes, and suchlike. Having a well-organized folder structure and a clear
    data flow can help us keep track of our application''s state.'
  prefs: []
  type: TYPE_NORMAL
- en: We've also taken a look at how to fetch data using GraphQL. This is an exciting
    topic as, in the next chapter, we will see how to use Apollo Client as a state
    manager other than a GraphQL client.
  prefs: []
  type: TYPE_NORMAL
