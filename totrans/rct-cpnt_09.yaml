- en: Chapter 9. Thinking of Plugins
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章. 考虑插件
- en: In the previous chapter, we looked at a couple of design patterns that we could
    use to build our applications. There are reasons for and against the use of Flux
    and Redux, but they generally improve the structure of React applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了我们可以用来构建应用程序的一些设计模式。使用Flux和Redux有理由和反对的理由，但它们通常可以提高React应用程序的结构。
- en: A good structure is essential for any large-scale application. Cobbling things
    together may work for small experiments, but design patterns are an integral part
    of maintaining anything larger. They do not say much in the way of creating extendable
    components, though. In this chapter, we're going to look at a few ways that we
    can use to make our components extendable by replacing them, injecting functionality,
    and composing interfaces from dynamic lists of components.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的结构对于任何大型应用程序都是必不可少的。对于小型实验，拼凑东西可能可行，但设计模式是维护任何更大规模事物的组成部分。尽管如此，它们并没有太多关于创建可扩展组件的内容。在本章中，我们将探讨一些我们可以用来使我们的组件通过替换、注入功能以及从组件动态列表中组合接口来扩展组件的方法。
- en: We're going to review a few related software design concepts and take a look
    at how they can assist us (and others) when we want to replace parts of our application
    with modified components and alternative implementations.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将回顾一些相关的软件设计概念，并看看它们如何帮助我们（以及其他人）在想要用修改后的组件和替代实现替换应用程序的部分时提供帮助。
- en: Dependency injection and service location
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入和服务定位
- en: '*Dependency injection* and *service location* are interesting concepts that
    are not limited to React development. To really understand them, let''s move away
    from components for a while. For a moment, imagine that we wanted to create a
    sitemap. To do this, we could perhaps use code resembling the following code:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*依赖注入*和*服务定位*是两个有趣的概念，它们并不仅限于React开发。要真正理解它们，让我们暂时远离组件。想象一下，如果我们想创建一个网站地图。为此，我们可能可以使用类似于以下代码：'
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, `createSitemap` has two dependencies. Firstly, we fetch pages
    from `backend`. This is a kind of global storage object. We used something similar
    to this when we looked at the Flux architecture.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`createSitemap`有两个依赖。首先，我们从`backend`获取页面。这是一个全球存储对象。当我们查看Flux架构时，我们使用过类似的东西。
- en: The second dependency is to the `SitemapFormatter` implementation. We use it
    to take a list of pages and return some kind of markup, summarizing these pages
    in the list. We're hardcoding both of these dependencies in a way that is okay
    in small doses, but they are problematic as the application expands.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个依赖是`SitemapFormatter`实现。我们使用它来获取页面列表并返回某种形式的标记，总结列表中的这些页面。我们以某种方式硬编码了这两个依赖，这在小剂量下是可以接受的，但随着应用程序的扩展，它们会变得有问题。
- en: For instance, what if we wanted to use this sitemap generator with multiple
    backends? What if we also wanted to try alternative implementations of the formatter?
    Right now, we've coupled the sitemap generator to a single backend and a single
    formatter implementation.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想使用这个网站地图生成器与多个后端？如果我们还想尝试格式化器的替代实现？目前，我们已经将网站地图生成器耦合到单个后端和单个格式化器实现。
- en: Dependency injection and service location are two possible solutions to this
    problem.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入和服务定位是解决这个问题的两种可能方案。
- en: Dependency injection
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖注入
- en: 'We''ve already used dependency injection, in subtle ways. This looks like the
    following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经以微妙的方式使用了依赖注入。这看起来如下所示：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Dependency injection is all about moving dependencies out of the functions and
    classes that use them. This is not about avoiding their use; but rather it is
    creating new instances outside and passing them in through function parameters.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入的全部内容是将依赖项从使用它们的函数和类中移出。这并不是要避免它们的使用；而是创建外部的新实例，并通过函数参数传递它们。
- en: 'There are two kinds of dependency injection: constructor injection and setter
    injection. This may illustrate the difference:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种依赖注入：构造函数注入和设置器注入。这可以说明它们之间的区别：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can inject dependencies through the constructor and assign them to properties,
    or we can create setters for them. We saw constructor injection a few times already,
    but setter injection is another valid means of injecting dependencies. We could
    also use normal functions to inject dependencies, but then we wouldn't be able
    to set or get them through object properties.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过构造函数注入依赖项并将它们分配给属性，或者为它们创建设置器。我们已经多次看到了构造函数注入，但设置器注入是另一种有效的注入依赖项的方式。我们也可以使用普通函数来注入依赖项，但那样我们就无法通过对象属性来设置或获取它们。
- en: Similarly, when we define component properties, we're essentially injecting
    these property values as constructor dependencies.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，当我们定义组件属性时，我们实际上是将这些属性值作为构造函数依赖项注入。
- en: Factories and service locators
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工厂和服务定位器
- en: 'An alternative solution would be to encapsulate the logic to create new instances
    and use references to this factory-like object when looking for dependencies:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个解决方案是将创建新实例的逻辑封装起来，并在查找依赖项时使用对这种类似工厂对象的引用：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can then pass around an instance of the `Factory` class, or even inject this
    as a dependency. In other dynamic languages, such as PHP, this has become a common
    practice. We can then use these factories to create new instances that are based
    on some initial criteria. We can have a factory to create new database connections
    and connect to MySQL or SQLite, which is based on a connection type that we specify.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以传递 `Factory` 类的实例，甚至将其作为依赖项注入。在其他动态语言中，如 PHP，这已成为一种常见做法。然后我们可以使用这些工厂来创建基于某些初始标准的新实例。我们可以有一个工厂来创建新的数据库连接，并连接到
    MySQL 或 SQLite，这取决于我们指定的连接类型。
- en: 'An alternative would be to create a number of objects and store them inside
    a common service locator object:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是创建多个对象并将它们存储在一个公共服务定位器对象中：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Likewise, we can inject the locator as a dependency and fetch the actual dependencies,
    as needed:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以将定位器作为依赖项注入，并根据需要获取实际的依赖项：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Fold
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Fold
- en: Fortunately, we do not need to build and maintain factories, dependency injectors,
    and service locators. There are already many to choose from, especially in JavaScript.
    We will discuss one in particular. Remember when we discussed rendering React
    components on the server? We looked at an MVC application framework, called AdonisJS.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们不需要构建和维护工厂、依赖注入器和服务定位器。JavaScript 中已经有了很多可供选择，我们将特别讨论其中一个。记得我们讨论在服务器上渲染
    React 组件的时候吗？我们查看了一个名为 AdonisJS 的 MVC 应用程序框架。
- en: The creator of AdonisJS also maintains a dependency injection container, called
    *Fold*. Some of the things that Fold does is interesting, and we want to share
    them with you.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: AdonisJS 的创建者也维护了一个依赖注入容器，称为 *Fold*。Fold 做的一些事情很有趣，我们希望与您分享。
- en: 'We can install Fold using the following command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令安装 Fold：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In previous chapters, we created a workflow to run ES6 code through Node.js.
    We recommend that you re-create this setup for some of the code in this chapter.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们创建了一个工作流程来运行 ES6 代码通过 Node.js。我们建议您为本章的一些代码重新创建此设置。
- en: 'We can then start to use it to register and resolve objects:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以开始使用它来注册和解析对象：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Fold introduces a global `use` function, so we could use it without needing
    to import `Ioc` each time.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Fold 引入了一个全局的 `use` 函数，因此我们可以在不需要每次都导入 `Ioc` 的情况下使用它。
- en: 'We use `bind` to assign an alias to a factory-like function. When this alias
    is *used*, this factory function will be called and the result returned. This
    becomes even more powerful when we have large dependency graphs:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `bind` 为类似工厂的函数分配别名。当这个别名被 *使用* 时，这个工厂函数将被调用，并返回结果。当我们拥有大型依赖图时，这变得更加强大：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can compose calls to `bind` and `use`. In this example, creating a new `App/Authenticator`
    will in turn resolve `App/UserRepository` and `App/Crypto` from the container.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以组合对 `bind` 和 `use` 的调用。在这个例子中，创建一个新的 `App/Authenticator` 将会从容器中解析出 `App/UserRepository`
    和 `App/Crypto`。
- en: 'What''s more is that we can use Fold to load class files automatically. So,
    let''s suppose that we have an `Authenticator` class file resembling the following
    (in `src/Authenticator.js`):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，我们可以使用 Fold 自动加载类文件。所以，假设我们有一个类似于以下内容的 `Authenticator` 类文件（在 `src/Authenticator.js`
    中）：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Usually we export classes or functions with `export default ...`; but in this
    case, we're just assigning the class to `module.exports`. This makes it easier
    for Fold to do more interesting things with our code.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通常我们使用 `export default ...` 来导出类或函数；但在这个情况下，我们只是将类分配给 `module.exports`。这使得 Fold
    能够对我们的代码做更多有趣的事情。
- en: 'We can autoload this with the following code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用以下代码来自动加载：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can also use regular classes as singletons with a slightly different binding
    syntax:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用常规类作为单例，只需稍微不同的绑定语法：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `use` works in the same way, whether you use `bind` or `singleton`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`use`无论您使用`bind`还是`singleton`，都按相同的方式工作。'
- en: 'Fold really shines when it comes to resolving dependencies recursively. Let''s
    change `Authenticator`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到递归解析依赖关系时，折叠功能特别出色。让我们改变`Authenticator`：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can use getters (a feature of ES6) to overload property access for a static
    `inject` property. This just means that a function will be run whenever we write
    `Authenticator.inject`. Fold uses this static array property to work out which
    dependencies to resolve. Therefore, we can create `Repository` (in `src/Repository.js`),
    as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用getter（ES6的一个特性）来重载静态`inject`属性的属性访问。这仅仅意味着每当我们在`Authenticator.inject`中写入时，都会运行一个函数。Fold使用这个静态数组属性来确定要解析哪些依赖项。因此，我们可以创建`Repository`（在`src/Repository.js`中），如下所示：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can also create `Crypto` (in `src/Crypto.js`), as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以创建`Crypto`（在`src/Crypto.js`中），如下所示：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The function of these classes isn''t important. What is important is how Fold
    connects them together:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类的作用并不重要。重要的是Fold如何将它们连接起来：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first line creates a link between the `App/` class prefix and the class
    files that we want to load. Therefore, a class in `src/Foo/Bar.js` will be loaded
    when we create `App/Foo/Bar`. Similarly, aliases defined in the static inject
    array property will be connected to their relevant constructor parameters when
    we use `Ioc.make`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行在`App/`类前缀和我们要加载的类文件之间创建了一个链接。因此，当创建`App/Foo/Bar`时，`src/Foo/Bar.js`中的类将被加载。同样，当使用`Ioc.make`时，在静态注入数组属性中定义的别名将与它们的相应构造函数参数连接起来。
- en: Why this matters
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么这很重要
- en: If we inject dependencies, we can easily replace one part of an application
    with another because dependencies aren't named within the classes that depend
    on them. These classes aren't responsible for creating new instances, only receiving
    instances created on the outside.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们注入依赖项，我们可以轻松地用另一个部分替换应用程序的一部分，因为依赖项没有在依赖它们的类中命名。这些类不负责创建新实例，只接收外部创建的实例。
- en: If we use a service locator (especially one that resolves dependencies recursively),
    we can avoid a lot of boilerplate during a bootstrapping phase.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用服务定位器（特别是递归解析依赖项的那种），我们可以在引导阶段避免很多样板代码。
- en: What do we gain from being able to replace parts of our application?
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够替换应用程序的部分，我们能从中得到什么？
- en: 'We allow other developers to inject behavior into our application by replacing
    core parts of the application. Imagine we have the following `Authenticator` method:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们允许其他开发者通过替换应用程序的核心部分来将行为注入我们的应用程序。想象一下我们有以下`Authenticator`方法：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now imagine that we want to add logging to all authentication. We can change
    the `Authenticator` class directly. This is easy if we *own* the code, but we
    often use third-party libraries. We can create a decorator (in `src/AuthenticatorLogger.js`):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，我们想要为所有认证添加日志记录。我们可以直接更改`Authenticator`类。如果我们*拥有*代码，这很容易，但我们经常使用第三方库。我们可以在`src/AuthenticatorLogger.js`中创建一个装饰器：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Decorators are classes that augment the functionality of other classes, usually
    by composing an instance of the class that they augment. You can learn more about
    this pattern at [https://en.wikipedia.org/wiki/Decorator_pattern](https://en.wikipedia.org/wiki/Decorator_pattern).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器是增强其他类功能的类，通常是通过组合它们增强的类的实例。您可以在[https://en.wikipedia.org/wiki/Decorator_pattern](https://en.wikipedia.org/wiki/Decorator_pattern)了解更多关于这种模式的信息。
- en: 'This new class expects an `Authenticator` dependency and adds transparent logging
    to the `authenticate` method. We can override the default (autoload) behavior
    by rebinding `App/Authenticator`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新类期望一个`Authenticator`依赖项，并为`authenticate`方法添加了透明的日志记录。我们可以通过重新绑定`App/Authenticator`来覆盖默认（自动加载）行为：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s think about this in terms of components. Imagine that we have a list
    of pages that are presented to us by a `PagesComponent` component (in `src/Page.js`):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从这个组件的角度来思考这个问题。想象一下，我们有一个页面列表，这些页面是由`PagesComponent`组件（在`src/Page.js`中）展示给我们的：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can autoload this using Fold, as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用折叠来自动加载，如下所示：
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, imagine that another developer came along and wanted to add some extra
    chrome around the list of pages. They could dig into the `node_modules` folder
    and directly edit the component, but this would be messy. Instead (and as we''re
    using a dependency injection container), they can override the alias to `App/PagesComponent`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下，另一位开发者出现了，并想围绕页面列表添加一些额外的装饰。他们可以深入到 `node_modules` 文件夹并直接编辑组件，但这会很混乱。相反（并且因为我们使用依赖注入容器），他们可以覆盖到
    `App/PagesComponent` 的别名：
- en: '[PRE21]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Things get a bit tricky when it comes to the `React.Component` subclasses versus
    instances of these subclasses. The `ReactDOM.render` and `ReactDOMServer.renderToString`
    expect instances are created when we use `<SomeComponent/>` in JSX. This may be
    helpful to register both forms in the container: bindings for a class reference
    and bindings for factory functions that create instances of these classes. We''ve
    suffixed the latter with `{}`, which we can use directly in a `render` method.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到 `React.Component` 子类与这些子类的实例时，事情会变得有点棘手。`ReactDOM.render` 和 `ReactDOMServer.renderToString`
    期望实例是在我们使用 `<SomeComponent/>` 在 JSX 中创建时。这可能有助于在容器中注册这两种形式：类引用的绑定和创建这些类实例的工厂函数的绑定。我们给后者添加了
    `{}` 后缀，我们可以在 `render` 方法中直接使用它。
- en: 'It may be a little easier to understand this last part by making the following
    small change:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通过进行以下小的更改，可能更容易理解最后一部分：
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this way, we allow other developers to replace parts of the application with
    custom classes or component decorators. There's definitely some work to be done
    in terms of creating a team standard for this pattern, but the basic idea is solid.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，我们允许其他开发者用自定义类或组件装饰器替换应用程序的部分。在创建团队标准方面肯定有一些工作要做，但基本想法是稳固的。
- en: Note
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can learn more about Fold at [http://adonisjs.com/docs/2.0/ioc-container](http://adonisjs.com/docs/2.0/ioc-container).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [http://adonisjs.com/docs/2.0/ioc-container](http://adonisjs.com/docs/2.0/ioc-container)
    上了解更多关于 Fold 的信息。
- en: Extending with callbacks
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过回调扩展
- en: 'Another method to create more pluggable components is to expose (and act on)
    event callbacks. We saw something similar already, but let''s take a look at this
    anyway. Suppose we have a `PageEditorComponent` class, as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 创建更多可插拔组件的另一种方法是公开（并操作）事件回调。我们已经看到了类似的东西，但让我们再看一看。假设我们有一个 `PageEditorComponent`
    类，如下所示：
- en: '[PRE23]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This is another bit of code that would run best through one of the workflows
    that we created earlier (that allow rendering components in the browser) or [https://jsbin.com](https://jsbin.com).
    We're interested in looking at some dynamic behavior, so it's important that we
    can click on things!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一段代码，最好通过我们之前创建的工作流程之一（允许在浏览器中渲染组件）或 [https://jsbin.com](https://jsbin.com)
    来运行。我们感兴趣的是查看一些动态行为，因此我们能够点击东西非常重要！
- en: As we saw earlier, we can pass `onSave` and `onCancel` callbacks through properties
    from some higher component. Each React component can have a `ref` callback. A
    reference to the DOM node is passed to this callback, so we can use methods such
    as `focus` and properties such as `value`. This works well to synchronize state
    with a common backend or store. However, what can we do to add some custom validation?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，我们可以通过属性从某些更高组件传递 `onSave` 和 `onCancel` 回调。每个 React 组件都可以有一个 `ref` 回调。将
    DOM 节点的引用传递给此回调，因此我们可以使用 `focus` 等方法以及 `value` 等属性。这对于与公共后端或存储同步状态非常有用。然而，我们该如何添加一些自定义验证呢？
- en: 'We can add optional callback properties (and `propTypes`) and incorporate these
    in our `onSave` and `onCancel` methods:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加可选的回调属性（和 `propTypes`），并将这些属性纳入我们的 `onSave` 和 `onCancel` 方法中：
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can then define additional steps at key points in the component''s behavior:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在组件行为的要点处定义额外的步骤：
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `onSave` method checks whether an optional `onBeforeSave` property is defined.
    If so, this callback is run. If the callback returns `false`, we can use this
    as a way to prevent the default component save behavior. We still need the default
    save or cancel behavior to work, so these properties are required. The others
    are optional but useful.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`onSave` 方法检查是否定义了可选的 `onBeforeSave` 属性。如果是这样，则运行此回调。如果回调返回 `false`，我们可以将其用作防止默认组件保存行为的一种方式。我们仍然需要默认的保存或取消行为正常工作，因此这些属性是必需的。其他属性是可选的但很有用。'
- en: Stores, reducers, and components
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储、reducer 和组件
- en: Building on these concepts, the final thing that we want you to look at is how
    this all fits together inside a Redux architecture.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些概念的基础上，我们想要你查看的最后一件事是所有这些如何在 Redux 架构内部结合在一起。
- en: Note
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you've skipped ahead to this chapter, make sure that you have a firm understanding
    of Redux by reading the previous chapter.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你跳到了这一章，请确保你已经通过阅读上一章对Redux有了牢固的理解。
- en: 'Let''s begin with a `PageComponent` class (for individual pages, in a list):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`PageComponent`类开始（用于列表中的单个页面）：
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `Dummy*Component` classes can be anything, really. We created a few "empty"
    components in the source code that goes with this chapter. The main thing is that
    `PageComponent` composes a few other components.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dummy*Component`类可以是任何东西。我们在与本章相关的源代码中创建了一些“空”组件。主要的事情是`PageComponent`组合了几个其他组件。'
- en: 'Nothing too fancy here: we compose a few components and hook into the usual
    Redux stuff. This is complemented by some new service location stuff:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有太多花哨的东西：我们组合了一些组件，并将其连接到常规的Redux功能。这由一些新的服务位置功能补充：
- en: '[PRE27]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We''re using a new `combineReducers` method, which takes an array of reducers
    and produces a new mega-reducer. Let''s make the order and inclusion of the child
    components configurable:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用一个新的`combineReducers`方法，它接受一个reducer数组并生成一个新的超级reducer。让我们使子组件的顺序和包含变得可配置：
- en: '[PRE28]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Two interesting things are happening here:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这里正在发生两个有趣的事情：
- en: In ES6, the `Array.prototype.map` method passes a second parameter to the callback.
    This is the numeric index for the current iteration of the array that is being
    mapped. We can use this as the `key` parameter when we're creating a list of child
    components.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在ES6中，`Array.prototype.map`方法将第二个参数传递给回调。这是正在映射的数组的当前迭代的数字索引。我们可以将其用作创建子组件列表时的`key`参数。
- en: We can use dynamic component names. Pay careful attention to the capitalization
    of `Component`. If the component name variable starts with a lowercase letter,
    React will assume a literal value.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用动态组件名称。请注意`Component`的字母大小写。如果组件名称变量以小写字母开头，React将假设它是一个字面量值。
- en: 'Now that we''re building a dynamic list of components, we can move the default
    list out of this component:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在构建一个动态的组件列表，我们可以将默认列表从这个组件中移除：
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can then replace this list in `PageComponent.render`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在`PageComponent.render`中替换这个列表：
- en: '[PRE30]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Building on what we learned earlier about Fold, we can override this list when
    we want to add plugins! We can include a plugin to e-mail a snapshot of a page
    to someone:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 建立在之前关于Fold学习的知识之上，当我们想要添加插件时，我们可以覆盖这个列表！我们可以包含一个插件，将页面的快照通过电子邮件发送给某人：
- en: '[PRE31]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This new plugin configuration can be miles away from the core definition of
    `PageComponent`, and we don''t have to change any core code to make this work.
    We can add new reducers in exactly the same way (thereby altering our store or
    dispatcher behavior):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的插件配置可能远离`PageComponent`的核心定义，我们不需要更改任何核心代码来使它工作。我们可以以完全相同的方式添加新的reducer（从而改变我们的存储或分发器行为）：
- en: '[PRE32]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this way, other developers can create entirely new components and reducers
    and apply them effortlessly to the system that we've already built.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，其他开发者可以创建全新的组件和reducer，并且可以轻松地将它们应用到我们已构建的系统上。
- en: Summary
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at a few methods that we could use to make our components
    (and general architecture) open to extension without requiring core modification.
    There's a lot to take in here and not nearly enough community standardization
    for this to be the final word on pluggable components. Hopefully, there's enough
    here for you to design the right plugin architecture for your application.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了我们可以使用的一些方法，使我们的组件（和通用架构）易于扩展，而无需修改核心代码。这里有很多东西需要吸收，而且社区标准化远远不够，这不能成为插件组件的最终结论。希望这里的内容足以让你为你的应用程序设计正确的插件架构。
- en: In the next chapter, we will look at various ways to test the components and
    classes that we've built so far. We'll continue to see the benefits of things,
    such as dependency injection and service location, while also learning about a
    few new tools.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨测试我们迄今为止构建的组件和类的方法。我们将继续看到诸如依赖注入和服务位置等事物的优势，同时也会了解一些新工具。
