["```js\n// Class that represents a tag\nexport class Tag {\n  constructor(textTag, title, link, type) {\n    // The textTag property is the text representation of the tag\n this.textTag = textTag;\n this.title = title;\n this.link = link;\n this.type = type;\n  }\n}\n```", "```js\nimport {Tag} from './tag';\nimport {limitWithEllipsis} from '../utilities/string-utilities';\nexport const TAG_TYPE_PROJECT = 'project';\n\n// The generateTag function is responsible for generating new tag \n// objects depending on the passed subject\nexport function generateTag(subject) {\n  if (subject.type === TAG_TYPE_PROJECT) {\n    // If we're dealing with a project here, we generate the \n    // according tag object\n    const openTaskCount = subject.tasks.filter((task) => !task.done).length;\n    return new Tag(\n `#${subject._id}`,\n `${limitWithEllipsis(subject.title, 20)} (${openTaskCount} open tasks)`,\n `#/projects/${subject._id}/tasks`,\n TAG_TYPE_PROJECT\n );\n  }\n}\n\n```", "```js\n// Utility function to replace all text occurrences in a string\nfunction replaceAll(target, search, replacement) {\n  return target.split(search).join(replacement);\n}\n```", "```js\n// Function to find any tags within a string and return an array \n// of discovered tags\nfunction findTags(str) {\n  const result = [];\n const regex = /#[\\w\\/-]+/g;\n  let match;\n while (match = regex.exec(str)) {\n result.push(match[0]);\n }\n  return result;\n}\n```", "```js\n@Injectable()\nexport class TagsService {\n...\n}\n```", "```js\nconstructor(@Inject(ProjectService) projectService) {\n  // If the available tags within the system changes, we will \n  // emit this event\n this.change = new ReplaySubject(1);\n  // In order to generate project tags, we're making use of the \n  // ProjectService\n  this.projectService = projectService;\n this.projectService.change.subscribe((projects) => {\n    // On project changes we store the new project list and re-\n    // initialize our tags\n    this.projects = projects;\n this.initializeTags();\n });\n}\n```", "```js\n// This method is used internally to initialize all available tags\ninitializeTags() {\n  // We're creating tags from all projects using the generateTag \n  // function\n  this.tags = this.projects.map(generateTag);\n  // Since we've updated the list of available tags we need to \n  // emit a change event\n this.change.next(this.tags);\n}\n```", "```js\nrenderTag(tag) {\n if (tag instanceof Tag) {\n return `<a class=\"tags__tag tags__tag--${tag.type}\" href=\"${tag.link}\">${tag.title}</a>`;\n } else {\n return tag;\n }\n}\n```", "```js\n// This method will lookup a tag via its text representation or \n// return the input argument if not found\nparseTag(textTag) {\n return this.tags.find(\n (tag) => tag.textTag === textTag\n ) || textTag;\n}\n```", "```js\n// This method takes some text input and replaces any found and \n// valid text representations of tags with the generated HTML \n// representation of those tags\nparse(value) {\n  // First we find all possible tags within the text\n const tags = findTags(value);\n  // For each found text tag, we're parsing and rendering them \n  // while replacing the text tag with the HTML representation \n  // if applicable\n tags.forEach(\n (tag) => value = replaceAll(value, tag, \n this.renderTag(this.parseTag(tag))));\n );\n  // After all tags have been rendered, we're using a sanitizer \n  // to ensure some basic security\n return value;\n}\n```", "```js\nimport {Pipe, Inject} from '@angular/core';\nimport {TagsService} from '../tags/tags-service';\n\n@Pipe({\n  name: 'tags',\n  // Since our pipe is depending on services, we're dealing with a \n  // stateful pipe and therefore set the pure flag to false\n pure: false\n})\nexport class TagsPipe {\n  constructor(@Inject(TagsService) tagsService) {\n this.tagsService = tagsService;\n  }\n  // The transform method will be called when the pipe is used within a template\n  transform(value) {\n    if (typeof value !== 'string') {\n      return value;\n    }\n    // The pipe is using the TagsService to parse the entire text\n return this.tagsService.parse(value);\n  }\n}\n```", "```js\n...\nimport {TagsPipe} from '../../pipes/tags';\n\n@Component({\n  selector: 'ngc-editor',\n  ...\n pipes: [TagsPipe]\n})\nexport class Editor {\n  ...\n @Input() enableTags;\n  ...\n}\n```", "```js\n...\n<div *ngIf=\"enableTags\" class=\"editor__output\" \n [innerHtml]=\"(content || '-') | tags\"></div>\n<div *ngIf=\"!enableTags\" class=\"editor__output\">\n  {{content || '-'}}\n</div>\n...\n```", "```js\n// This function can be used to find the screen coordinates of the \n// input cursor position\nfunction getRangeBoundlingClientRect() {\n  const selection = window.getSelection();\n  if (!selection.rangeCount) return;\n\n  const range = selection.getRangeAt(0);\n\n  if (!range.collapsed) {\n    return range.getBoundingClientRect();\n  }\n\n  const dummy = document.createElement('span');\n  range.insertNode(dummy);\n  const pos = dummy.getBoundingClientRect();\n  dummy.parentNode.removeChild(dummy);\n  return pos;\n}\n```", "```js\nexport class TagInputManager {\n  constructor() {\n    this.reset();\n  }\n  ...\n```", "```js\nreset() {\n  this.textTag = '';\n  this.position = null;\n}\n```", "```js\nhasTextTag() {\n  return this.textTag[0] === '#';\n}\n```", "```js\nupdateTextTag(textTag, position = this.position) {\n  this.textTag = textTag;\n  this.position = position;\n}\n```", "```js\nonKeyDown(event) {\n  // If we receive a backspace (key code is 8), we need to \n  // remove the last character from the text tag\n  if (event.which === 8 && this.hasTextTag()) {\n    this.updateTextTag(this.textTag.slice(0, -1));\n  }\n}\n```", "```js\nonKeyPress(event) {\n  const char = String.fromCharCode(event.which);\n  if (char === '#') {\n    // If the current character from user input is a hash symbol \n    // we can initiate a new text tag and set the current \n    // position\n    this.updateTextTag('#', getRangeBoundlingClientRect());\n  } else if ((/[\\w-]/i).test(this.textTag[0])) {\n    // If the current character is not a valid tag character we \n    // reset our state and assume the tag entry was canceled\n    this.reset();\n  } else if (this.hasTextTag()) {\n    // If we have any other valid tag character input, we're \n    // updating our text tag\n    this.updateTextTag(this.textTag + char);\n  }\n}\n```", "```js\n...\n@Component({\n  selector: 'ngc-tags-select',\n  ...\n})\nexport class TagsSelect {\n  ...\n}\n```", "```js\n@Input() filter;\n```", "```js\n@Input() limit;\n```", "```js\n@Input() position;\n```", "```js\n@Output() tagSelected = new EventEmitter();\n```", "```js\n@HostBinding('style.display')\nget isVisible() {\n  if (this.filter[0] === '#' && this.filteredTags.length > 0) {\n    return 'block';\n  } else {\n    return 'none';\n  }\n}\n```", "```js\n@HostBinding('style.top')\nget topPosition() {\n  return this.position ? `${this.position.top}px` : 0;\n}\n\n@HostBinding('style.left')\nget leftPosition() {\n  return this.position ? `${this.position.left}px` : 0;\n}\n```", "```js\nconstructor(@Inject(TagsService) tagsService) {\n  this.tagsService = tagsService;\n  // This member is storing the filtered tag list\n  this.filteredTags = [];\n  this.filter = '';\n}\n```", "```js\nngOnInit() {\n  // The TagsService is providing us with all available tags \n  // within the application\n  this.tagsSubscription = this.tagsService.change.subscribe(\n    (tags) => {\n      // If the available tags change we store the new list and \n      // execute filtering again\n      this.tags = tags;\n this.filterTags();\n    }\n  );\n}\n```", "```js\nonTagClick(tag) {\n this.tagSelected.next(tag);\n}\n```", "```js\nfilterTags() {\n  this.filteredTags = this.tags\n    .filter((tag) => {\n      return tag.textTag.indexOf(this.filter.slice(1)) !== -1 ||\n tag.title.indexOf(this.filter.slice(1)) !== -1;\n    })\n    .slice(0, this.limit);\n}\n```", "```js\nngOnChanges(changes) {\n  // If the filter or the limit input changes, we're filtering the \n  // available tags again\n if (this.tags && (changes.filter || changes.limit)) {\n this.filterTags();\n }\n}\n```", "```js\nngOnDestroy() {\n  this.tagsSubscription.unsubscribe();\n}\n```", "```js\n<ul class=\"tags-select__list\">\n  <li *ngFor=\"let tag of filteredTags\"\n (click)=\"onTagClick(tag)\"\n      class=\"tags-select__item\">{{tag.title}}</li>\n</ul>\n```", "```js\n...\nimport {TagsSelect} from '../../tags/tags-select/tags-select';\nimport {TagInputManager} from '../../tags/tag-input-manager';\n\n@Component({\n  selector: 'ngc-editor',\n  ...\n directives: [TagsSelect]\n})\nexport class Editor {\n  ...\n    // We're using a TagInputManager to help us dealing with tag \n    // creation\n this.tagInputManager = new TagInputManager();\n  }\n  ...\n  // This method is called when the editable element receives a \n  // keydown event\n  onKeyDown(event) {\n    // We're delegating the keydown event to the TagInputManager\n this.tagInputManager.onKeyDown(event);\n  }\n\n  // This method is called when the editable element receives a \n  // keypress event\n  onKeyPress(event) {\n    // We're delegating the keypress event to the TagInputManager\n this.tagInputManager.onKeyPress(event);\n  }\n\n  // This method is called if the child TagSelect component is \n  // emitting an event for a selected tag\n  onTagSelected(tag) {\n    // We replace the partial text tag within the editor with the \n    // text representation of the tag that was selected in the \n    // TagSelect component.\n this.setEditableContent(\n this.getEditableContent().replace(\n this.tagInputManager.textTag, tag.textTag\n )\n );\n this.tagInputManager.reset();\n  }\n  ...\n}\n```", "```js\n...\n<ngc-tags-select *ngIf=\"enableTags\"\n [filter]=\"tagInputManager.textTag\"\n [position]=\"tagInputManager.position\"\n [limit]=\"5\"\n (tagSelected)=\"onTagSelected($event)\">\n</ngc-tags-select>\n```", "```js\n...\n@Directive({\n  selector: '[draggable]',\n  host: {\n    class: 'draggable',\n    // Additionally to the class we also need to set the HTML \n    // attribute draggable to enable draggable browser behavior\n draggable: 'true'\n  }\n})\nexport class Draggable {\n  ...\n}\n```", "```js\n@Input() draggableData;\n```", "```js\n@Input() draggableType;\n```", "```js\n@HostBinding('class.draggable--dragging') dragging;\n```", "```js\n// We're listening for the dragstart event and initialize the \n// dataTransfer object\n@HostListener('dragstart', ['$event'])\nonDragStart(event) {\n  event.dataTransfer.effectAllowed = 'move';\n  // Serialize our data to JSON and set it on our dataTransfer \n  // object\n event.dataTransfer.setData(\n 'application/json', \n JSON.stringify(this.draggableData));\n  // By adding the draggableType as a data type key within our \n  // The dataTransfer object, we enable drop zones to observe the type \n  // before receiving the actual drop.\n  event.dataTransfer.setData(\n\n `draggable-type:${this.draggableType}`, '');\n this.dragging = true;\n}\n```", "```js\n@HostListener('dragend')\nonDragEnd() {\n this.dragging = false;\n}\n```", "```js\n@Directive({\n  selector: '[draggableDropZone]'\n})\nexport class DraggableDropZone {\n  ...\n}\n```", "```js\n@Input() dropAcceptType;\n```", "```js\n@Output() dropDraggable = new EventEmitter();\n```", "```js\n@HostBinding('class.draggable--over') over;\n```", "```js\ntypeIsAccepted(event) {\n  const draggableType = \n Array.from(event.dataTransfer.types).find(\n (key) => key.indexOf('draggable-type') === 0\n );\n return draggableType && \n draggableType.split(':')[1] === this.dropAcceptType;\n}\n```", "```js\nconstructor() {\n  // We need this counter to know if a draggable is still over our \n  // drop zone\n this.dragEnterCount = 0;\n}\n\n// The dragenter event is captured when a draggable is dragged \n// into our drop zone\n@HostListener('dragenter', ['$event'])\nonDragEnter(event) {\n  // Only handle event if the draggable is accepted by our drop \n  // zone\n if (this.typeIsAccepted(event)) {\n this.over = true;\n    // We use this counter to determine if we loose focus because \n    // of child element or because of final leave\n this.dragEnterCount++;\n }\n}\n\n// The dragleave event is captured when the draggable leaves our \n// drop zone\n@HostListener('dragleave', ['$event'])\nonDragLeave(event) {\n  // Using dragEnterCount, we determine if the dragleave event is \n  // because of child elements or because the draggable was moved \n  // outside the drop zone\n if (this.typeIsAccepted(event) && --this.dragEnterCount === 0) {\n this.over = false;\n }\n}\n```", "```js\n@HostListener('dragover', ['$event'])\nonDragOver(event) {\n  // Only handle event if the draggable is accepted by our drop \n  // zone\n  if (this.typeIsAccepted(event)) {\n    // Prevent any default drag action of the browser and set the \n    // dropEffect of the dataTransfer object\n event.preventDefault();\n event.dataTransfer.dropEffect = 'move';\n  }\n}\n```", "```js\n// This event will be captured if a draggable element is dropped \n// onto our drop zone\n@HostListener('drop', ['$event'])\nonDrop(event) {\n  // Only handle event if the draggable is accepted by our drop \n  // zone\n  if (this.typeIsAccepted(event)) {\n    // First obtain the data object that comes with the drop event\n const data = JSON.parse(\n event.dataTransfer.getData('application/json')\n );\n    // After successful drop, we can reset our state and emit an \n    // event with the data\n this.over = false;\n this.dragEnterCount = 0;\n this.dropDraggable.next(data);\n  }\n}\n```", "```js\n<div class=\"task-list__l-container\">\n  ...\n  <ngc-task *ngFor=\"let task of filteredTasks\"\n            line:[task]=\"task\n            (taskUpdated)=\"onTaskUpdated(task, $event)\"\n            (taskDeleted)=\"onTaskDeleted(task)\"\n draggable\n draggableType=\"task\"\n [draggableData]=\"task\"\n draggableDropZone\n dropAcceptType=\"task\"\n (dropDraggable)=\"onTaskDrop($event, task)\">\n  </ngc-task>\n  ...\n</div>\n```", "```js\n...\nimport {Draggable} from '../draggable/draggable';\nimport {DraggableDropZone} from '../draggable/draggable-drop-zone';\n\n@Component({\n  selector: 'ngc-task-list',\n  ...\n directives: [..., Draggable, DraggableDropZone]\n})\nexport class TaskList {\n  ...\n  onTaskDrop(source, target) {\n if (source.position === target.position) {\n return;\n }\n\n let tasks = this.tasks.slice();\n const sourceIndex = tasks.findIndex(\n (task) => task.position === source.position\n );\n const targetIndex = tasks.findIndex(\n (task) => task.position === target.position\n );\n tasks.splice(targetIndex, \n 0, \n tasks.splice(sourceIndex, 1)[0]);\n tasks = tasks.map((task, index) => {\n return Object.assign({}, task, {\n position: index\n });\n });\n this.tasksUpdated.next(tasks);\n  }\n  ...\n}\n```", "```js\n<div *ngFor=\"let i of [1, 2, 3]\">{{i}}</div>\n```", "```js\n<template ngFor #i [ngForOf]=\"[1, 2, 3]\">\n  <div>{{i}}</div>\n</template>\n```", "```js\n<div *test=\"let variable withSugar true\">{{variable}}</div>\n```", "```js\n<template test #variable [testWithSugar]=\"true\">\n  <div>{{variable}}</div>\n</template>\n```", "```js\n<div *ngFor=\"let n of [1, 2, 3]; let i = index\">{{i}}: {{n}}</div>\n```", "```js\n<template ngFor #n #i=\"index\" [ngForOf]=\"[1, 2, 3]\">\n  <div>{{i}}: {{n}}</div>\n</template>\n```", "```js\n<template ngFor #n=\"$implicit\" #i=\"index\" [ngForOf]=\"[1, 2, 3]\">\n  <div>{{i}}: {{n}}</div>\n</template>\n```", "```js\n...\n@Directive({\n  selector: '[ngcInfiniteScroll]'\n})\nexport class InfiniteScroll {\n  ...\n  // This input will be set by the for of template syntax\n @Input('ngcInfiniteScrollOf')\n  set infiniteScrollOfSetter(value) {\n    this.infiniteScrollOf = value;\n    ...\n  }\n  ...\n\n  applyChanges(changes) {\n    ...\n    this.bulkInsert(insertTuples).forEach((tuple) =>\n      tuple.view.context.$implicit = tuple.record.item);\n  }\n  ...\n}\n```", "```js\n<div *ngcInfiniteScroll=\"#item of items\">{{item}}</div>\n```", "```js\n<template ngcInfiniteScroll #item [ngcInfiniteScrollOf]=\"items\">\n  <div>{{item}}</div>\n</template>\n```", "```js\nconstructor(@Inject(ViewContainerRef) viewContainerRef,\n @Inject(TemplateRef) templateRef,\n @Inject(IterableDiffers) iterableDiffers,\n @Inject(ChangeDetectorRef) cdr) {\n  // Using Object.assign we can easily add all constructor \n  // arguments to our instance\n Object.assign(this, \n {viewContainerRef, templateRef, iterableDiffers, cdr});\n  // How many items will be shown initially\n this.shownItemCount = 3;\n  // How many items should be displayed additionally, when we \n  // scroll to the bottom\n this.increment = 3;\n}\n```", "```js\n  ngOnInit() {\n    this.scrollableElement = findScrollableParent(\n      this.viewContainerRef.element.nativeElement.parentElement);\n    this.scrollableElement.addEventListener('scroll', this._onScrollListener);\n  }\n```", "```js\n@Input('ngcInfiniteScrollOf')\nset infiniteScrollOfSetter(value) {\n  this.infiniteScrollOf = value;\n  // Create a new iterable differ for the iterable `value`, if the \n  // differ is not already present\n  if (value && !this.differ) {\n this.differ = this.iterableDiffers.find(value).create(this.cdr);\n    }\n}\n```", "```js\nonScroll() {\n  // If the scrollable parent is scrolled to the bottom, we will \n  // increase the count of displayed items\n  if (this.scrollableElement && isScrolledBottom(this.  scrollableElement)) {\n this.shownItemCount = Math.min(this.infiniteScrollOf.length, this.shownItemCount + this.increment);\n    // After incrementing the number of items displayed, we need \n    // to tell the change detection to revalidate\n this.cdr.markForCheck();\n  }\n}\n```", "```js\nngDoCheck() {\n  if (this.differ) {\n    // We are creating a new slice based on the displayed item \n    // count and then create a changes object containing the \n    // differences using the IterableDiffer\n const updatedList = this.infiniteScrollOf\n .slice(0, this.shownItemCount);\n const changes = this.differ.diff(updatedList);\n    if (changes) {\n      // If we have any changes, we call our `applyChanges` method\n this.applyChanges(changes);\n    }\n  }\n}\n```", "```js\napplyChanges(changes) {\n  // First we create a record list that contains all moved and \n  // removed change records\n const recordViewTuples = [];\n changes.forEachRemovedItem((removedRecord) => \n recordViewTuples.push({record: removedRecord}));\n changes.forEachMovedItem((movedRecord) => \n recordViewTuples.push({record: movedRecord}));\n\n  // We can now bulk remove all moved and removed views and as a \n  // result we get all moved records only\n const insertTuples = this.bulkRemove(recordViewTuples);\n  // In addition to all moved records we also add a record for all \n  // newly added records\n changes.forEachAddedItem((addedRecord) => \n insertTuples.push({record: addedRecord}));\n\n  // Now we have stored all moved and added records within `\n  // insertTuples` which we use to do a bulk insert. As a result \n  // we get the list of the newly created views. On those views \n  // we're then creating a view local variable `$implicit` that \n  // will bind the list items to the variable name used within the \n  // for of template syntax.\n this.bulkInsert(insertTuples).forEach((tuple) =>\n tuple.view.context.$implicit = tuple.record.item);\n}\n```", "```js\nbulkRemove(tuples) {\n  ...\n  // Reducing the change records so we can return only moved \n  // records\n  return tuples.reduceRight((movedTuples, tuple) => {\n    // If an index is present on the change record, it means that \n    // its of type \"moved\"\n if (tuple.record.currentIndex != null) {\n      // For moved records we only detach the view from the view \n      // container and push it into the reduced record list\n tuple.view = this.viewContainerRef.detach(tuple.record.previousIndex);\n movedTuples.push(tuple);\n    } else {\n      // If we're dealing with a record of type \"removed\", we \n      // completely remove the view\n this.viewContainerRef.remove(tuple.record.previousIndex);\n    }\n    return movedTuples;\n  }, []);\n}\n```", "```js\nbulkInsert(tuples) {\n  ...\n  tuples.forEach((tuple) => {\n    if (tuple.view) {\n      // We're inserting back the detached view at the new positionwithin the view container\n this.viewContainerRef.insert(tuple.view, \n tuple.record.currentIndex);\n    } else {\n      // We're dealing with a newly created view so we create a new embedded view on the view container and store it in the change record\n tuple.view = \n this.viewContainerRef.createEmbeddedView(\n this.templateRef, \n {},\n tuple.record.currentIndex);\n    }\n  });\n  return tuples;\n}\n```", "```js\n...\nimport {InfiniteScroll} from '../infinite-scroll/infinite-scroll';\n\n@Component({\n  selector: 'ngc-task-list',\n  ...\n directives: [..., InfiniteScroll]\n})\nexport class TaskList {\n  ...\n}\n```", "```js\n<ngc-task *ngcInfiniteScroll=\"let task of filteredTasks\"\n          [[task]=\"task\"\n          (taskUpdated)=\"onTaskUpdated(task, $event)\"\n          (taskDeleted)=\"onTaskDeleted(task)\"\n          draggable\n          draggableType=\"task\"\n          [draggableData]=\"task\"\n          draggableDropZone\n          dropAcceptType=\"task\"\n          (dropDraggable)=\"onTaskDrop($event, task)\"></ngc-task>\n```"]