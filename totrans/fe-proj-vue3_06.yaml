- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Global Component Composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to use Composition API to create component
    logic and how to write custom reusable composables in a Vue application. There
    are many approaches to sharing similar logic between other components besides
    composables. In this chapter, we will learn how to use mixins, plugins, and how
    to render dynamic components.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be ready to organize your code using mixins
    and plugins, achieve global composition, and keep code **DRY** (**Don’t Repeat
    Yourself**) in any project. You will also understand the advantages and drawbacks
    of global composition, thus deciding the right approach to maximize a component’s
    flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding mixins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registering components globally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding component tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing functional components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you need to set up a basic Vue project following the instructions
    in [*Chapter 1*](B18645_01.xhtml#_idTextAnchor015), *Starting Your First Vue Project*.
    It’s recommended to create a single-file Vue component to practice the examples
    and concepts mentioned easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find this chapter’s source code here: [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter06](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter06).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding mixins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With mixins, we can add additional methods, data properties, and life cycle
    methods to a component’s `option` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we first define a mixin that contains a `greet` method
    and a `greeting` data field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can use the `greeter` mixin by importing and assigning it as part of
    the `mixins` field in the component’s `option` object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`mixins` is an array that accepts any mixin as its element, while a `mixin`
    is in fact a component’s `option` object. Mixins allow multiple components to
    share common data and logic definitions independently.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we add a mixin to a component, Vue will merge all the data and methods
    into the existing data and methods (mix in). A `mixin`’s properties and methods
    are then available in the component for use as its own data and methods, like
    how we use the `greet` method from the `greeter` mixin in the following template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And in the browser, we will see the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Display Hello World using a greeter mixin](img/B18645_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – Display Hello World using a greeter mixin
  prefs: []
  type: TYPE_NORMAL
- en: When there is an overlapping of naming data properties or methods, Vue will
    prioritize the component’s own options. We can explain this mechanism as the component
    adopting the mixin as its default options unless a similar declaration already
    exists. In this case, the instance will ignore the mixin’s definition and take
    the component’s definition instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s add a `data()` initializer, which returns `greeting` data
    with the value `Hi` to the component that uses the `greeter` mixin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`greeter` also defines `greeting`, but so does the component. In this case,
    the component *wins*, and we will see `Hi` displayed instead of `Hello` (as defined
    in the mixin), as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Component displays Hi World with overridden greeting data value](img/B18645_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – Component displays Hi World with overridden greeting data value
  prefs: []
  type: TYPE_NORMAL
- en: However, this mechanism doesn’t apply to life cycle hooks. The hooks defined
    in the mixins will take priority in execution, and Vue always triggers the component’s
    hooks last. If there is more than one mixin added to the component, the execution
    order follows their order of appearance in the `mixins` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can observe this execution order in the following example. Let’s create
    two mixins that implement the `mounted` life cycle hook – `firstMixin` and `secondMixin`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we also implement the same hook in the component, as shown in the following
    code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The full code will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The browser’s console output for this component will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 6.3 – Console log outputs demonstrate the order of execution for the\
    \ hooks of mixins and components\uFEFF](img/B18645_06_03.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – Console log outputs demonstrate the order of execution for the
    hooks of mixins and components
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s practice what we have learned so far by implementing your first mixin
    in the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 6.01 – creating your mixin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will create a mixin called `debugger`. It contains a `debug`
    method that receives `Object` as its argument and returns a string representing
    its structure using the `JSON.stringify()` function. This method is handy for
    printing data in a readable format when debugging Vue.js on the browser instead
    of the console.
  prefs: []
  type: TYPE_NORMAL
- en: To access the code file for this exercise, refer to [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter06/Exercise6.01](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter06/Exercise6.01).
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the application generated with `npm init vue@3` as a starting point, or
    within the root folder of the code repository, navigate to the `Chapter06/Exercise6.01`
    folder, by using the following commands in order:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the exercise project in your VS Code (by using the `code .` command within
    the project directory), or your preferred IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new `src/mixins` folder and a `src/mixins/debugger.js` file where
    we will define the skeleton of our mixin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We add a `debug` method under `methods`. The `debug` method will take an `obj`
    parameter and return the output of `JSON.stringify` for that input parameter.
    We will use `JSON.stringify(obj, null, 2)` to output two-space pretty-printed
    JSON:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We are now able to import the `debugger` mixin in `src/App.vue` and register
    it under the `mixins` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To see the `debug` method in action, we will add a `data` method that returns
    a `myObj` data property and a `created` hook where we will compute the output
    of `debug` for `myObj`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Browser console output due to the created hook](img/B18645_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – Browser console output due to the created hook
  prefs: []
  type: TYPE_NORMAL
- en: '`debug` is also available in the template. We can display its output wrapped
    with a `pre` tag so that whitespace is respected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The application, as well as this template, will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – Browser printing myObj using the debug method from the mixin](img/B18645_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – Browser printing myObj using the debug method from the mixin
  prefs: []
  type: TYPE_NORMAL
- en: We have learned how we can use mixins to inject shared logic and data into multiple
    components in a manner that is quite explicit (a `mixins` property). However,
    due to the mechanism of data overriding and executing for hooks, mixins can lead
    to potential bugs and unwanted behaviors in a large code base. *Thus, we recommend
    considering creating shared logic and data as composable with Composition API
    whenever* *possible instead*.
  prefs: []
  type: TYPE_NORMAL
- en: We will now look at how to inject instance and global functionality and distribute
    it through plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vue plugins are a way to add custom functionality to Vue.js globally. Classic
    examples of plugin candidates are translation/internationalization libraries (such
    as `i18n-next`) and HTTP clients (such as the `axios`, `fetch`, and `GraphQL`
    clients). The plugin initializer has access to the `Vue` instance, so it can be
    a good way to wrap global directives and components and inject resources across
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Vue plugin is an object that exposes an `install` method. The `install` function
    is called with an `app` instance and `options`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the `install` method, we can register directives and components and
    add global and instance properties and methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We can register a plugin using the `use` instance method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We can pass an options as the second argument to the `use()` method. These
    options are passed to the plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '`use()` does not allow you to register the same plugin twice, avoiding edge
    case behavior when attempting to instantiate or install the same plugin multiple
    times.'
  prefs: []
  type: TYPE_NORMAL
- en: A popular HTTP client to use in combination with Vue is Axios. It is common
    to configure Axios with interceptors or Axios options to achieve things such as
    retries, passing cookies, or following redirects.
  prefs: []
  type: TYPE_NORMAL
- en: Axios can be installed using `npm install –save axios`. In the next exercise,
    we will create a plugin wrapping Axios inside our application.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 6.02 – creating a custom Axios plugin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to avoid having to add `import axios from 'axios'` or having to wrap
    our custom Axios instance under an `http` or `transport` internal module, we’ll
    inject our custom Axios instance into the Vue object and Vue component instances
    under `Vue.axios` and `this.axios`. This will make it easier and more ergonomic
    to use in our application, which needs to call out to an API using Axios as the
    HTTP client.
  prefs: []
  type: TYPE_NORMAL
- en: To access the code file for this exercise, refer to [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter06/Exercise6.02](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter06/Exercise6.02).
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the application generated with `npm init vue@3` as a starting point, or
    within the root folder of the code repository, navigate into the `Chapter06/Exercise6.02`
    folder, by using the following commands in order:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the exercise project in VS Code (by using the `code .` command within the
    project directory) or your preferred IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To organize our code properly, we will create a new folder in `src/plugins`
    and a new file for our `axios` plugin at `src/plugins/axios.js`. In the new file,
    we will scaffold the `axios` plugin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now register our `axios` plugin on the Vue.js instance in `src/main.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now install Axios through npm using the following command. This will
    allow us to import Axios and expose it on Vue through a plugin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now add Axios to Vue as a global property in `src/plugins/axios.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Axios is now available on Vue. In `src/App.vue`, we can make a request to an
    API that will populate a list of `todos`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – Global this.$axios todo display sample](img/B18645_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6 – Global this.$axios todo display sample
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also provide Axios as an injectable when necessary, instead of making
    it available in every component, by using `app.provide()` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can access Axios through `this.axios` in `src/App.vue` if we inject
    `''axios''` into this component by using the `inject` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The output of the above code stays the same as in *Figure 6**.6*.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have used a plugin to inject both global and instance-level properties
    and methods.
  prefs: []
  type: TYPE_NORMAL
- en: We will now look at how globally registering components can help reduce boilerplate
    for high-usage components in a code base.
  prefs: []
  type: TYPE_NORMAL
- en: Globally registering components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A reason for using plugins is to reduce boilerplate in all Vue application files
    by removing `imports` and replacing it with access to `this`.
  prefs: []
  type: TYPE_NORMAL
- en: Vue.js components are usually defined in a single-file component and imported
    explicitly. Much for the same reasons as we define global methods and properties,
    we might want to register components globally. This will allow us to use these
    components in all our other component templates without having to import them
    and register them under the `components` property.
  prefs: []
  type: TYPE_NORMAL
- en: A situation where this can be very useful is when using a design system or when
    a component is used across the code base.
  prefs: []
  type: TYPE_NORMAL
- en: Globally registering a component helps with some types of updates, such as if
    the filename is not exposed to the consumer so that when changing the filename,
    there is only one path to update as opposed to one per user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume we have a `CustomButton` component in the `CustomButton.vue` file
    that looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'We can register `CustomButton` globally as follows (this is usually done in
    the `main.js` file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use it in the `App.vue` file without locally registering it or importing
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'This renders as expected, with a button called **Click Me**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7 – CustomButton rendering with a Click Me button](img/B18645_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.7 – CustomButton rendering with a Click Me button
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have explored how globally registering components can cut down
    on boilerplate when components are used often across a code base.
  prefs: []
  type: TYPE_NORMAL
- en: The next section is dedicated to deepening our understanding of Vue.js components
    by learning how to use them without `.``vue` files.
  prefs: []
  type: TYPE_NORMAL
- en: Using non-SFC Vue components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the examples we have seen of Vue.js components have leveraged `.vue`
    single-file components. This is not the only way to define a Vue.js component.
    In this section, we will look at four different ways to define Vue.js components
    without using a `.``vue` file.
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating these options will help us understand what a Vue.js component is
    at its core.
  prefs: []
  type: TYPE_NORMAL
- en: Runtime definition with a string template
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A component can use a `template` property that accepts a string value. This
    is commonly called a **string template**. This template is evaluated at runtime
    (in the browser).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define a component in the `StringTemplate.js` file by defining an object
    with a `template` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'This can then be consumed from the `App.vue` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, the browser won’t display the content of `StringTemplate`, and
    in the console log, you will find the following Vue warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8 – Vue runtime compiler missing warning](img/B18645_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.8 – Vue runtime compiler missing warning
  prefs: []
  type: TYPE_NORMAL
- en: For this component to work, we need to include the Vue runtime compiler. We
    can do so by manually adding `'vue/dist/vue.esm-bundler.js'` as a `vue` alias
    for the Vite engine to resolve.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `vite.config.js` file should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'After re-starting the development server, a message from the `StringTemplate`
    component appears in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s explore how to create components using the `render` function.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the render function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Behind the scenes, the `template` section gets compiled into a `render` function
    at build time.
  prefs: []
  type: TYPE_NORMAL
- en: Starting from Vue 3, a `render` method in a component’s options no longer takes
    a `createElement` argument and then returns a virtual DOM node received from the
    execution of `createElement`. Instead, Vue provides an `h` function, which performs
    the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define a component in a JavaScript file (`RenderFunction.js`) with a
    `render` property like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be rendered in the `App.vue` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'This component displays an `h2` with the text `Render Function Component` in
    the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: Beyond writing components in non `.vue` files, `render` functions can be useful
    for highly dynamic components.
  prefs: []
  type: TYPE_NORMAL
- en: JSX
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**JSX** is a superset of JavaScript that allows HTML-style tags and interpolation
    using braces in React, like SFC to Vue.'
  prefs: []
  type: TYPE_NORMAL
- en: React, like Vue, does not render the raw JSX to the DOM. React also use `render`
    to render a component’s content to the Virtual DOM. The Virtual DOM is then *reconciled*
    (synced) with the real DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Vite and Vue CLI both support the JSX compiler out of the box for the Vue application.
    You just need to turn on JSX support during the installation configuration when
    using `create-vue`. This means we can write the following `JSXRender.js` file,
    which is the equivalent of the `RenderFunction` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'The equivalent `render` function without JSX looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'The following `App.vue` file renders `JSXRender` to the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can see `h2` from `JSXRender` on the screen with the expected content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: We will now look at how components can be rendered dynamically from runtime
    data using the Vue.js `component` tag.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSX and `render` functions are great for situations where the component being
    rendered needs to be very dynamic. We can also achieve this capability using the
    Vue `component`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To render a dynamic component, we use a `component` tag with a bound `is` property
    (here, we are using the shorthand `:is`, which is equivalent to `v-bind:is`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: We will now learn how to render dynamic components using a name or component
    reference.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering dynamic components by name or component reference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s say we have a grid that contains items whose display can be toggled between
    a card display (a design element with an image and text) or an image-only view.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to import the relevant components and register them as components.
    We will also set some fixture data to loop through for the grid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then reference the components by name – that is, `Card` and `ImageEntry`
    – and set `itemComponent` as the value for `is`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, Vue will render the `Card` component since we set the
    `itemComponent` value as `card`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we set `itemComponent` to `image-entry`, Vue renders the `ImageEntry` component.
    This switch can be made as follows using `v-model`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also pass components to `is` using the component reference itself (instead
    of using the name). For example, we could set `itemComponent` to `Card`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: In this case, switching between card and image views would be more difficult
    since we would need to use component references instead of using names.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can pass props to components that have been dynamically rendered with `component`
    like we would pass regular props either with `v-bind:prop-name` or the `:``prop-name`
    shorthand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: Given the following `Card` and `ImageEntry` components, we get an application
    that has toggleable views for grid items.
  prefs: []
  type: TYPE_NORMAL
- en: '`Card.vue` renders the image and the title and has a `150px` maximum width:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'Your output will display the entries in the card view, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9 – Grid rendering entries in the card view](img/B18645_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.9 – Grid rendering entries in the card view
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `ImageEntry.vue` to render only the image at double the width of the card
    view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'You will now see the entries in the image view, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10 – Grid rendering entries in the image view](img/B18645_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.10 – Grid rendering entries in the image view
  prefs: []
  type: TYPE_NORMAL
- en: A caveat of the `component` tag is that the rendered dynamic component gets
    completely torn down when it is not displayed anymore. In this example, the dynamic
    components being rendered do not have any state, so this teardown does not create
    any issues.
  prefs: []
  type: TYPE_NORMAL
- en: We will now learn how a dynamic component state is cached.
  prefs: []
  type: TYPE_NORMAL
- en: Caching a dynamic component state with keep-alive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Components that are dynamically rendered through the `component` tag can have
    state, such as in a multipart form, with a `name` field and an `address` field
    on the next page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s implement this with a `component` tag, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'And in the `FirstStep` component, we will implement an `input` field that requires
    the user’s name, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'And for `SecondStep.vue`, we will implement another input field with two buttons
    to navigate back and forward, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'By doing this, we can enter data in the **Name** field:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11 – “My name is” is entered in the name field](img/B18645_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.11 – “My name is” is entered in the name field
  prefs: []
  type: TYPE_NORMAL
- en: 'If we navigate, using **Next**, to the address part of the form and then use
    **Back**, the name will disappear, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.12 – Empty Name field upon clicking Next and then Back in the address
    step](img/B18645_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.12 – Empty Name field upon clicking Next and then Back in the address
    step
  prefs: []
  type: TYPE_NORMAL
- en: This is due to the component being unmounted when it is not the currently rendered
    dynamic component.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this, we can use the `keep-alive` element around the `component` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'In this manner, filling out the name and going back from the address section
    of the form shows the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.12 – “My name is” is still the value in the Name field after navigation](img/B18645_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.12 – “My name is” is still the value in the Name field after navigation
  prefs: []
  type: TYPE_NORMAL
- en: We have learned how to use the `component` tag to denote an area within which
    we can dynamically display a component based on a string or the component itself
    (as imported). We have also explored how to work around the main gotcha of `component`;
    namely, how to use `keep-alive` to maintain the component state when it is not
    the component being actively used in the `component` tag.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s practice what we learned in the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 6.03 – creating a dynamic card layout with the component tag
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A modern application layout is a grid with cards. Card layouts have the benefit
    of being well suited to mobile, desktop, and tablet displays. In this exercise,
    we will create a dynamic card layout with three different modes and a way to select
    between the three of them. This layout will allow the user to select how much
    information is displayed on the screen to suit their preference:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Rich` view will display all the details for an item, including the image,
    the title, and the description
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Compressed` view will display all the details but not the image preview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `List` view will only display the title and should be a vertical layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of the card views will be implemented as a separate component that will
    then be dynamically rendered using the `component` tag.
  prefs: []
  type: TYPE_NORMAL
- en: To access the code file for this exercise, refer to [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter06/Exercise6.03](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter06/Exercise6.03).
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the application generated with `npm init vue@3` as a starting point, or
    within the root folder of the code repository, navigate into the `Chapter06/Exercise6.03`
    folder, by using the following commands in order:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE142]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the exercise project in your VS Code (by using the `code .` command within
    the project directory) or your preferred IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the rich layout at `src/components/Rich.vue`. It contains three props
    called `url` (the image URL), `title`, and `description` and renders the image,
    the title, and the description, respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE144]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE145]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE146]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE147]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE148]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE149]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE150]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE151]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE152]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE153]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE154]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE155]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE156]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE157]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE158]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE159]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE160]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE161]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE162]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE163]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE164]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE165]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE166]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE167]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set up `src/App.vue` with some fixture data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE169]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE170]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE171]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE172]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE173]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE174]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE175]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE176]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE177]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE178]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE179]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE180]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE181]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE182]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE183]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE184]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE185]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE186]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE187]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE188]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE189]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE190]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE191]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import the `Rich` view component into `src/App.vue` and register it locally:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE193]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE194]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE195]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once we have got the `Rich` view component, wire it into the application in
    `src/App.vue`, render it with `component`, and pass the relevant props through:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE197]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE198]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE199]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE200]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE201]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE202]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE203]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE204]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE205]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE206]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE207]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE208]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE209]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE210]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE211]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE212]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is a good point to add a bit of styling to make the grid look like a grid:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE214]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE215]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE216]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE217]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE218]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE219]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE220]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE221]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE222]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE223]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE224]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE225]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE226]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE227]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE228]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE229]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE230]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE231]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This displays the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.14 – Rich component rendering dynamically](img/B18645_06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.14 – Rich component rendering dynamically
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, implement the `Compressed` view, which is just the `Rich` view without
    the image in the `Compressed.vue` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE233]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE234]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE235]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE236]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE237]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE238]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE239]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE240]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE241]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE242]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE243]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE244]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE245]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE246]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE247]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE248]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE249]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE250]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE251]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE252]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE253]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE254]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE255]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE256]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE257]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import and register the `Compressed` component in `src/App.vue`. Then create
    our `layoutOptions` array with two elements. Each has two fields: `name` of the
    layout and the `component` instance for the two components – `Rich` and `Compressed`
    respectively, as shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE259]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE260]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE261]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE262]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE263]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE264]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE265]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE266]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE267]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE268]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE269]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add `select` to switch between views. It will take options from the `layoutOptions`
    array using `v-for`, and bind its selected value to `layout` using `v-model`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE270]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE271]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE272]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE273]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE274]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE275]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE276]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE277]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE278]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE279]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE280]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using `select`, we can switch to the **Compressed** layout, which looks as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.15 – Compressed layout with options dropdown for selection](img/B18645_06_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.15 – Compressed layout with options dropdown for selection
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `List` layout to `src/components/List.vue`. The `List` view is the
    compressed view but without the description:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE281]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE282]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE283]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE284]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE285]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE286]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE287]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE288]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE289]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE290]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE291]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE292]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE293]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import the `List` component into `src/App.vue` and register it locally:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE294]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE295]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE296]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE297]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE298]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE299]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE300]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE301]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE302]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE303]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE304]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE305]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE306]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE307]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE308]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When switching to the **List** layout, the items are displayed in a horizontal
    row, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.16 – List view with incorrect horizontal stacking](img/B18645_06_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.16 – List view with incorrect horizontal stacking
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this horizontal stacking, create a new `grid-column` class that sets
    `flex-direction: column` (as opposed to `row`, which is the default) and conditionally
    applies it when the layout is `List`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE309]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE310]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE311]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE312]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE313]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE314]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE315]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE316]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE317]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE318]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE319]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE320]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE321]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE322]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our **List** layout now looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.17 – List view with vertical stacking](img/B18645_06_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.17 – List view with vertical stacking
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have learned how to use the `component` tag to dynamically render
    different components both by name and by using the component object itself. We
    have also explored the pitfalls of stateful dynamic components, namely the teardown
    of components when they are not displayed anymore and how to circumvent them using
    the `keep-alive` element.
  prefs: []
  type: TYPE_NORMAL
- en: We will now look at how simple components can be implemented using only a `render`
    function or `template` tag using functional components.
  prefs: []
  type: TYPE_NORMAL
- en: Writing functional components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Vue 2.0, you can declare a component as a functional one by setting the
    `functional` field to `true` in the component’s options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: 'This can also be done by setting `functional` directly on the `template` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: And you can set how to render the component using the `render()` method of the
    component or the `template` section. However, if both fields exist, Vue takes
    the `render()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Vue 3.0 onward, however, Vue removed the `functional` attribute and you
    can only declare a functional component using a JavaScript function, which is
    the `render` function Vue will trigger to create the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: 'Once declared as functional, the component does not have any reactive state,
    and you can’t access `this` instance since it is not available. Instead, Vue triggers
    the `render` function and passes to it the component’s props and necessary context
    including `attrs`, `slots`, and the passed event handler’s `emit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also define the accepted props and events by directly setting its field
    `props` and `emits`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: 'To start using JSX code, you will need to create the Vue project with JSX support
    enabled using Vite. Otherwise, in `vite.config.js`, you will need to manually
    import `vueJsx` from the `''@vitejs/plugin-vue-jsx''` package, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: 'And then add the imported `vueJsx` plugin to the `plugins` array, as seen in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: With the preceding configuration, your Vue project created by Vite now supports
    functional components with JSX, which we will demonstrate in the following example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block is an example of how we define a functional component,
    `GreetComponent.jsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: 'We also declare `props` and `emits` explicitly for `GreetComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: Note that here, since we use JSX syntax to define the component, we need to
    make sure the file extension of `GreetComponent` is `.jsx` and not `.js` (`GreetComponent.jsx`).
    Also, we need to make sure we turn on JSX support when creating the project with
    the `create-vue` command (Vite).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can import and use `GreetComponent` in `App.vue` as a regular component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: 'This renders the following to the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.18 – Functional component rendering](img/B18645_06_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.18 – Functional component rendering
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also combine with Composition API to create functional components with
    states. In the following example, we create a `Message` component with a reactive
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: Note that here, we display the `message` value by using `message.value`, not
    `message` directly.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have learned how to write functional components – stateless
    or stateful – using Composition API. We will now build a to-do application that
    uses all the patterns we have looked at throughout this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Activity 6.01 – building a Vue.js application with plugins and reusable components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To access the code file for this activity, refer to [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter06/Activity6.01](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter06/Activity6.01)
  prefs: []
  type: TYPE_NORMAL
- en: In this activity, we will build a to-do app that integrates `jsonplaceholder`
    as a data source.
  prefs: []
  type: TYPE_NORMAL
- en: Our to-do app will load todos and display them as a list. It will display a
    checkbox based on whether the to-do has been completed, as well as the name of
    the to-do.
  prefs: []
  type: TYPE_NORMAL
- en: When checking off a to-do, the application will sync it to the API.
  prefs: []
  type: TYPE_NORMAL
- en: We will inject Axios as a plugin to query against [https://jsonplaceholder.typicode.com](https://jsonplaceholder.typicode.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Install `axios` in the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To inject `axios` as a property into `this` component instances, create a `src/plugins/axios.js`
    plugin file that, on install, will mean component instances have an injectable
    `axios` property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the plugin to work, import and register it in `src/main.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also want to inject our API’s `$baseUrl` into all our components as a global
    scope. We will create a plugin inline with the `src/main.js` file to do this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now want to fetch all the to-dos from `src/App.vue`. A good place to do this
    is in the `mounted` life cycle method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To display the to-do list, we will create a `TodoList` component in `src/components/TodoList.vue`
    that takes a `todos` prop, loops through the items, and defers rendering of the
    to-do under a `todo` scoped slot that binds the to-do.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can now use the `TodoList` component to render out the *todos* we have already
    fetched in `src/App.vue`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now need to create a `TodoEntry` component where we will implement most of
    the to-do-specific logic. A good practice for components is to have the props
    be very specific to the component’s role. In this case, the properties of the
    `todo` object we will tackle are `id`, `title`, and `completed`, so those should
    be the props that our `TodoEntry` component receives. We will not make `TodoEntry`
    a functional component since we will need a component instance to create HTTP
    requests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will then update `src/App.vue` so that it consumes `TodoEntry` (making sure
    to bind `id`, `title`, and `completed`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the ability to toggle the `todo`. We will implement the majority of this
    in `src/components/TodoEntry.vue`. We will listen to the `input` change event.
    On changing, we will want to read the new value and send a `PATCH` request to
    `/todos/{todoId}` with an object containing `completed` set to the new value.
    We will also want to emit a `completedChange` event in Vue.js so that the `App`
    component can update the data that’s in memory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `App.vue`, we will want to update the relevant `todo` when `completeChange`
    is triggered. Since `completeChange` does not include the ID of the `todo`, we
    will need to read that from the context when setting the `handleCompleteChange`
    function to listen to `completeChange`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.19 – Our to-do app using jsonplaceholder data](img/B18645_06_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.19 – Our to-do app using jsonplaceholder data
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we have looked at global composition patterns and advanced
    component setups that we can take advantage of to create a reusable code base
    for a Vue.js application. We learned about mixins, plugins, how to use component
    tags for dynamic component rendering, and functional components, both stateful
    and stateless.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have learned how to build applications in terms of components, mixins,
    and plugins. To build applications that span multiple pages, we need to implement
    routing. This is what we will tackle in the next chapter.
  prefs: []
  type: TYPE_NORMAL
