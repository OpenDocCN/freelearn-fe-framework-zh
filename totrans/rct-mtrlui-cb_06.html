<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Lists - Display Simple Collection Data</h1>
                </header>
            
            <article>
                
<p>In this chapter, you'll cover the following recipes:</p>
<ul>
<li>Using state to render list items</li>
<li>List icons</li>
<li>List avatars and text</li>
<li>List sections</li>
<li>Nested lists</li>
<li>List controls</li>
<li>Scrolling lists</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p><span>The </span><kbd>List</kbd><span> component in Material-UI is used to render data collections. Lists are like tables, only simpler. If you need to display an array of users, </span><span>for example, </span><span>you can render them in a list, showing only the most relevant data, instead of several properties in a tabular format. Material-UI lists are generic and provide a lot of flexibility.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using state to render list items</h1>
                </header>
            
            <article>
                
<p>The data source used to render <kbd>List</kbd> components often comes from the state of your component. A collection—usually an array of objects—is mapped to <kbd>ListItem</kbd> components. As the objects in this array change, the Material-UI list items change on the screen.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let's say that you have an array of three objects that you need to display as a list on one of your screens. You can add this array to the state of your component, then map each array item to a <kbd>ListItem</kbd> component. Here's the code:</p>
<pre>import React, { useState } from 'react';<br/><br/>import List from '@material-ui/core/List';<br/>import ListItem from '@material-ui/core/ListItem';<br/>import ListItemText from '@material-ui/core/ListItemText';<br/><br/>export default function UsingStatetoRenderListItems() {<br/>  const [items, setItems] = useState([<br/>    { name: 'First Item', timestamp: new Date() },<br/>    { name: 'Second Item', timestamp: new Date() },<br/>    { name: 'Third Item', timestamp: new Date() }<br/>  ]);<br/><br/>  return (<br/>    &lt;List&gt;<br/>      {items.map((item, index) =&gt; (<br/>        &lt;ListItem key={index} button dense&gt;<br/>          &lt;ListItemText<br/>            primary={item.name}<br/>            secondary={item.timestamp.toLocaleString()}<br/>          /&gt;<br/>        &lt;/ListItem&gt;<br/>      ))}<br/>    &lt;/List&gt;<br/>  );<br/>}</pre>
<p>Here's what you'll see when you first load the screen:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-medium wp-image-1252 image-border" src="assets/94276506-36f9-41c5-80a9-64c12c56496a.png" style="width:14.00em;height:12.08em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Let's start by looking at the <kbd>items</kbd> state:</p>
<pre>const [items, setItems] = useState([<br/>  { name: 'First Item', timestamp: new Date() },<br/>  { name: 'Second Item', timestamp: new Date() },<br/>  { name: 'Third Item', timestamp: new Date() }<br/>]);</pre>
<p>The <kbd>name</kbd> property is the <kbd>primary</kbd> text, and the <kbd>timestamp</kbd> property is the <kbd>secondary</kbd> text <span>for each list item. Next, let's look at the <kbd>List</kbd> markup that transforms this state into rendered list items:</span></p>
<pre>&lt;List&gt;<br/>  {items.map((item, index) =&gt; (<br/>    &lt;ListItem key={index} button dense&gt;<br/>      &lt;ListItemText<br/>        primary={item.name}<br/>        secondary={item.timestamp.toLocaleString()}<br/>      /&gt;<br/>    &lt;/ListItem&gt;<br/>  ))}<br/>&lt;/List&gt;</pre>
<p>The <kbd>ListItem</kbd> component has two Boolean properties passed to it – <kbd>button</kbd> and <kbd>dense</kbd>. The <kbd>button</kbd> property makes the list item behave like a button. For example, if you move your mouse pointer over an item in the list, you'll see the hover styles applied to it. The <kbd>dense</kbd> property removes extra padding from the list item. Without this property, the list takes up more space on the screen.</p>
<p>The <kbd>ListItemText</kbd> component uses the <kbd>primary</kbd> and <kbd>secondary</kbd> properties to render the <kbd>name</kbd> and <kbd>timestamp</kbd> properties respectively. The <kbd>primary</kbd> text is meant to stand out relative to the <kbd>secondary</kbd> information displayed in the item – in this case, the <kbd>timestamp</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>This example could have used props instead of state, because the items never changed. Let's modify it so that the user can select items from the list. Here's what the new <kbd>List</kbd> markup looks like:</p>
<pre>&lt;List&gt;<br/>  {items.map((item, index) =&gt; (<br/>    &lt;ListItem<br/>      key={index}<br/>      button<br/>      dense<br/>      selected={item.selected}<br/>      onClick={onClick(index)}<br/>    &gt;<br/>      &lt;ListItemText<br/>        primary={item.name}<br/>        secondary={item.timestamp.toLocaleString()}<br/>        primaryTypographyProps={{<br/>          color: item.selected ? 'primary' : undefined<br/>        }}<br/>      /&gt;<br/>    &lt;/ListItem&gt;<br/>  ))}<br/>&lt;/List&gt;</pre>
<p>The <kbd>selected</kbd> property passed to the <kbd>ListItem</kbd> component will apply selected styles to the item when <kbd>true</kbd>. This value comes from the <kbd>item.selected</kbd> state, which is <kbd>false</kbd> by default for every item (nothing is selected). Next, the <kbd>ListItem</kbd> component has an <kbd>onClick</kbd> handler.</p>
<p>The <kbd>ListItemText</kbd> component also has styles applied to it based on the selected state of the item. Behind the scenes, item text is rendered using the <kbd>Typography</kbd> component. You can use the <kbd>primaryTypographyProps</kbd> property to pass properties to the <kbd>Typography</kbd> component. In this case, you're changing the <kbd>color</kbd> of the text to <kbd>primary</kbd> when it's selected.</p>
<p>Let's look at the <kbd>onClick()</kbd> handler as follows:</p>
<pre>const onClick = index =&gt; () =&gt; {<br/>  const item = items[index];<br/>  const newItems = [...items];<br/><br/>  newItems[index] = { ...item, selected: !item.selected };<br/>  setItems(newItems);<br/>};</pre>
<p>This is a higher-order function, which returns an event handler function based on the <kbd>index</kbd> argument. It toggles the selected state for the item at the given index.</p>
<div class="packt_tip">The <kbd>onClick</kbd> property isn't a <kbd>ListItem</kbd> property. It's a <kbd>button</kbd> property. Since you've set the <kbd>button</kbd> property to <kbd>true</kbd>, <kbd>ListItem</kbd> uses a <kbd>button</kbd> property and passes it to your <kbd>onClick</kbd> property.</div>
<p class="CDPAlignCenter CDPAlign">Here's what the list looks like when <span class="packt_screen">First Item</span> is selected:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-medium wp-image-1250 image-border" src="assets/7ae5643d-2472-454a-bd5a-0104eea6d755.png" style="width:17.42em;height:11.42em;"/></p>
<p>The change to the background color is caused by the selected property of <kbd>ListItem</kbd>. The change to the text color is caused by the <kbd>primaryTypographyProps</kbd> property of <kbd>ListItemText</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><kbd>List</kbd> demos: <a href="https://material-ui.com/demos/lists/">https://material-ui.com/demos/lists/</a></li>
<li><kbd>Typography</kbd> API documentation: <a href="https://material-ui.com/api/typography/">https://material-ui.com/api/typography/</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">List icons</h1>
                </header>
            
            <article>
                
<p><kbd>ListItem</kbd> components have first-class support for icons. By rendering icons in each list item, you can make it clear to the user what types of objects are displayed in the list.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let's say that you have an array of user objects that you want to render in a <kbd>List</kbd>. You could render each item with a user icon to make it clear what each item in the list is. The code for this is as follows:</p>
<pre>import React, { useState } from 'react';<br/><br/>import List from '@material-ui/core/List';<br/>import ListItem from '@material-ui/core/ListItem';<br/>import ListItemText from '@material-ui/core/ListItemText';<br/>import ListItemIcon from '@material-ui/core/ListItemIcon';<br/><br/>import AccountCircleIcon from '@material-ui/icons/AccountCircle';<br/><br/>export default function ListIcons() {<br/>  const [items, setItems] = useState([<br/>    { name: 'First User' },<br/>    { name: 'Second User' },<br/>    { name: 'Third User' }<br/>  ]);<br/><br/>  return (<br/>    &lt;List&gt;<br/>      {items.map((item, index) =&gt; (<br/>        &lt;ListItem key={index} button&gt;<br/>          &lt;ListItemIcon&gt;<br/>            &lt;AccountCircleIcon /&gt;<br/>          &lt;/ListItemIcon&gt;<br/>          &lt;ListItemText primary={item.name} /&gt;<br/>        &lt;/ListItem&gt;<br/>      ))}<br/>    &lt;/List&gt;<br/>  );<br/>}</pre>
<p>When you load the screen, this is what the list should look like:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-medium wp-image-1251 image-border" src="assets/8a97d33c-9391-4968-8c8a-f40ec04cd137.png" style="width:12.17em;height:9.33em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>ListItemIcon</kbd> component can be used as a child of <kbd>ListItem</kbd> components. In the previous example, it comes before the text, so it ends up to the left of the item text:</p>
<pre>&lt;ListItem button key={index}&gt;<br/>  &lt;ListItemIcon&gt;<br/>    &lt;AccountCircleIcon /&gt;<br/>  &lt;/ListItemIcon&gt;<br/>  &lt;ListItemText primary={item.name} /&gt;<br/>&lt;/ListItem&gt;</pre>
<p>You could place the icon after the text as well:</p>
<pre>&lt;ListItem button key={index}&gt;<br/>  &lt;ListItemText primary={item.name} /&gt;<br/>  &lt;ListItemIcon&gt;<br/>    &lt;AccountCircleIcon /&gt;<br/>  &lt;/ListItemIcon&gt;<br/>&lt;/ListItem&gt;</pre>
<p>Here's how it looks:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2e1235f3-5d00-43c5-923e-004d4bb25ea5.png" style="width:31.92em;height:9.67em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>You can mark <kbd>ListItem</kbd> components as selected by setting the <kbd>selected</kbd> property to <kbd>true</kbd>. You can also change the icon to give a better visual indication that an item has been selected. Here's the updated code:</p>
<pre>import React, { useState } from 'react';<br/><br/>import List from '@material-ui/core/List';<br/>import ListItem from '@material-ui/core/ListItem';<br/>import ListItemText from '@material-ui/core/ListItemText';<br/>import ListItemIcon from '@material-ui/core/ListItemIcon';<br/><br/>import AccountCircleIcon from '@material-ui/icons/AccountCircle';<br/>import CheckCircleOutlineIcon from '@material-ui/icons/CheckCircleOutline';<br/><br/>const MaybeSelectedIcon = ({ selected, Icon }) =&gt;<br/>  selected ? &lt;CheckCircleOutlineIcon /&gt; : &lt;Icon /&gt;;<br/><br/>export default function ListIcons() {<br/>  const [items, setItems] = useState([<br/>    { name: 'First User' },<br/>    { name: 'Second User' },<br/>    { name: 'Third User' }<br/>  ]);<br/><br/>  const onClick = index =&gt; () =&gt; {<br/>    const item = items[index];<br/>    const newItems = [...items];<br/><br/>    newItems[index] = { ...item, selected: !item.selected };<br/>    setItems(newItems);<br/>  };<br/><br/>  return (<br/>    &lt;List&gt;<br/>      {items.map((item, index) =&gt; (<br/>        &lt;ListItem<br/>          key={index}<br/>          button<br/>          selected={item.selected}<br/>          onClick={onClick(index)}<br/>        &gt;<br/>          &lt;ListItemText primary={item.name} /&gt;<br/>          &lt;ListItemIcon&gt;<br/>            &lt;MaybeSelectedIcon<br/>              selected={item.selected}<br/>              Icon={AccountCircleIcon}<br/>            /&gt;<br/>          &lt;/ListItemIcon&gt;<br/>        &lt;/ListItem&gt;<br/>      ))}<br/>    &lt;/List&gt;<br/>  );<br/>}</pre>
<p>Here's what the list looks like with <span class="packt_screen">First User</span> selected:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/62929b69-1f2a-4163-8a45-8201860a0956.png" style="width:31.92em;height:8.67em;"/></p>
<p>The icon for the selected items changes into a circled checkmark. Let's break down the changes that were introduced to make this happen, starting with the <kbd>MaybeSelectedIcon</kbd> component:</p>
<pre>const MaybeSelectedIcon = ({ selected, Icon }) =&gt;<br/>  selected ? &lt;CheckCircleOutlineIcon /&gt; : &lt;Icon /&gt;;</pre>
<p>This component will render either <kbd>CheckCircleOutlineIcon</kbd> or the <kbd>Icon</kbd> component that is passed in as a property. This depends on the <kbd>selected</kbd> property. Next, let's look at how this component is used inside <kbd>ListItemIcon</kbd>:</p>
<pre>&lt;ListItemIcon&gt;<br/>  &lt;MaybeSelectedIcon<br/>    selected={item.selected}<br/>    Icon={AccountCircleIcon}<br/>  /&gt;<br/>&lt;/ListItemIcon&gt;</pre>
<p>When a list item is clicked on, the <kbd>selected</kbd> state for that item is toggled. Then, the <kbd>selected</kbd> state is passed to <kbd>MaybeSelectedIcon</kbd>. The <kbd>AccountCircleIcon</kbd> component is the icon that's rendered when the list item isn't selected, because it's passed to the <kbd>Icon</kbd> property.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><kbd>List</kbd> demos: <a href="https://material-ui.com/demos/lists/">https://material-ui.com/demos/lists/</a></li>
<li><kbd>ListItemIcon</kbd> API documentation: <a href="https://material-ui.com/api/list-item-icon/">https://material-ui.com/api/list-item-icon/</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">List avatars and text</h1>
                </header>
            
            <article>
                
<p>If your list items have <kbd>primary</kbd> and <kbd>secondary</kbd> text, using an icon on its own can be less visually appealing than with an avatar surrounding the icon. It fills the space within the list item better.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let's say that you have four categories of messages that can be displayed by your app. To access a given category, the user clicks on one of the list items. To help the user understand the categories, you'll use icons. And to make the icons stand out against the <kbd>primary</kbd> and <kbd>secondary</kbd> text of the list item, you'll wrap it with an <kbd>Avatar</kbd> component. Here's the code:</p>
<pre>import React, { useState } from 'react';<br/>import clsx from 'clsx';<br/><br/>import Avatar from '@material-ui/core/Avatar';<br/>import List from '@material-ui/core/List';<br/>import ListItem from '@material-ui/core/ListItem';<br/>import ListItemText from '@material-ui/core/ListItemText';<br/>import ListItemIcon from '@material-ui/core/ListItemIcon';<br/><br/>import MarkunreadIcon from '@material-ui/icons/Markunread';<br/>import PriorityHighIcon from '@material-ui/icons/PriorityHigh';<br/>import LowPriorityIcon from '@material-ui/icons/LowPriority';<br/>import DeleteIcon from '@material-ui/icons/Delete';<br/><br/>export default function ListAvatarsAndText({ classes }) {<br/>  const [items] = useState([<br/>    {<br/>      name: 'Unread',<br/>      updated: '2 minutes ago',<br/>      Icon: MarkunreadIcon,<br/>      notifications: 1<br/>    },<br/>    {<br/>      name: 'High Priority',<br/>      updated: '30 minutes ago',<br/>      Icon: PriorityHighIcon<br/>    },<br/>    {<br/>      name: 'Low Priority',<br/>      updated: '3 hours ago',<br/>      Icon: LowPriorityIcon<br/>    },<br/>    { name: 'Junk', updated: '6 days ago', Icon: DeleteIcon }<br/>  ]);<br/><br/>  return (<br/>    &lt;List&gt;<br/>      {items.map(({ Icon, ...item }, index) =&gt; (<br/>        &lt;ListItem button&gt;<br/>          &lt;ListItemIcon&gt;<br/>            &lt;Avatar&gt;<br/>              &lt;Icon /&gt;<br/>            &lt;/Avatar&gt;<br/>          &lt;/ListItemIcon&gt;<br/>          &lt;ListItemText<br/>            primary={item.name}<br/>            secondary={item.updated}<br/>          /&gt;<br/>        &lt;/ListItem&gt;<br/>      ))}<br/>    &lt;/List&gt;</pre>
<pre><br/>  );<br/>}</pre>
<p>Here's what the list looks like when rendered:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d61c49f7-3d39-4b51-8fbc-ca11ddcf042b.png" style="width:35.75em;height:18.00em;"/></p>
<p>The circle that surrounds the icon is the <kbd>Avatar</kbd> component, and it helps the icon stand out. Here's what this list looks like without avatars:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/696b5773-89c1-45a4-a07f-45fc82433fac.png" style="width:35.92em;height:18.25em;"/></p>
<p>It's the same content and the same icons, but because of the height of the list item text, there's a lot of excess space surrounding the icon. The <kbd>Avatar</kbd> component helps fill this space while drawing attention to the icon.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>Avatar</kbd> component is used on icons with a circular shape. The color of the circle comes from the theme palette – the shade of grey used depends on whether the theme is light or dark. The icon itself is passed as the child element:</p>
<pre>&lt;ListItemIcon&gt;<br/>  &lt;Avatar&gt;<br/>    &lt;Icon /&gt;<br/>  &lt;/Avatar&gt;<br/>&lt;/ListItemIcon&gt;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>If you use an <kbd>Avatar</kbd> with the icons in your list items, you can change the color of the <kbd>Avatar</kbd> and you can apply a badge to indicate unacknowledged actions to be taken. Let's modify the example so that each item in the items state can have a <kbd>notifications</kbd> property; that is, a number representing the number of unread messages for the category. If this number is greater than 0, you can change the <kbd>Avatar</kbd> color and display number of <kbd>notifications</kbd> in a badge. Here's what the result looks like:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d35471a6-7ea4-4786-89ea-fae941c44423.png" style="width:34.75em;height:17.75em;"/></p>
<p>The first item in the list has an <kbd>Avatar</kbd> that's using the primary <kbd>theme</kbd> color and a badge showing the number of <kbd>notifications</kbd>. The rest of the items don't have any <kbd>notifications</kbd>, so the <kbd>Avatar</kbd> color uses the default, and the badge isn't displayed.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Let's see how this is done, starting with the styles:</p>
<pre>const styles = theme =&gt; ({<br/>  activeAvatar: {<br/>    backgroundColor: theme.palette.primary[theme.palette.type]<br/>  }<br/>});</pre>
<p>The <kbd>activeAvatar</kbd> style is applied to the <kbd>Avatar</kbd> component when the <kbd>notifications</kbd> state is a number greater than 0. It looks up the primary <kbd>theme</kbd> color based on the theme type (light or dark). Next, let's look at the state of the first item in the items array:</p>
<pre>{<br/>  name: 'Unread',<br/>  updated: '2 minutes ago',<br/>  Icon: MarkunreadIcon,<br/>  notifications: 1<br/>}</pre>
<p>Because the <kbd>notifications</kbd> value is <kbd>1</kbd>, the color of the avatar changes, and the badge is displayed. Lastly, let's see how all of this comes together in the component markup using the <kbd>Badge</kbd> and <kbd>Avatar</kbd> components:</p>
<pre>&lt;Badge<br/>  color={item.notifications ? 'secondary' : undefined}<br/>  badgeContent={<br/>    item.notifications ? item.notifications : null<br/>  }<br/>&gt;<br/>  &lt;Avatar<br/>    className={clsx({<br/>      [classes.activeAvatar]: item.notifications<br/>    })}<br/>  &gt;<br/>    &lt;Icon /&gt;<br/>  &lt;/Avatar&gt;<br/>&lt;/Badge&gt;</pre>
<p>The <kbd>color</kbd> property of <kbd>Badge</kbd> is based on the <kbd>notifications</kbd> state of the item being greater than 0. If it is, the primary color is used. If it isn't, <kbd>undefined</kbd> is passed to <kbd>Badge</kbd>. In this case, this is necessary so that an empty badge circle doesn't show up when there aren't any notifications.</p>
<div class="packt_tip">Passing <kbd>undefined</kbd> as a property value is equivalent to not setting the property at all.</div>
<p>Next, the <kbd>badgeContent</kbd> property is set based on the <kbd>notifications</kbd> state of the item. If it's not greater than 0, then you don't want any value set. Finally, setting the color of the <kbd>Avatar</kbd> component uses <kbd>clsx()</kbd> to apply the <kbd>activeAvatar</kbd> class if the <kbd>notifications</kbd> state for the item is greater than 0.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><kbd>Badge</kbd> demos: <a href="https://material-ui.com/demos/badges/">https://material-ui.com/demos/badges/</a></li>
<li><kbd>Avatar</kbd> demos: <a href="https://material-ui.com/demos/avatars/">https://material-ui.com/demos/avatars/</a></li>
<li><kbd>List</kbd> demos: <a href="https://material-ui.com/demos/lists/">https://material-ui.com/demos/lists/</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">List sections</h1>
                </header>
            
            <article>
                
<p>Once your lists have more than just a few items in them, you might want to consider organizing the items into sections. To do this, you split your lists into several smaller lists, which are stacked on top of one another with a divider in between them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let's say that you have several list items that can be divided into three sections. You can use three <kbd>List</kbd> components to group your items into their respective sections, and use a <kbd>Divider</kbd> component to visually indicate the section boundary for the user. Here's what the code looks like:</p>
<pre>import React, { Fragment } from 'react';<br/><br/>import List from '@material-ui/core/List';<br/>import ListItem from '@material-ui/core/ListItem';<br/>import ListItemText from '@material-ui/core/ListItemText';<br/>import Divider from '@material-ui/core/Divider';<br/><br/>const ListSections = () =&gt; (<br/>  &lt;Fragment&gt;<br/>    &lt;List&gt;<br/>      &lt;ListItem&gt;<br/>        &lt;ListItemText primary="First" /&gt;<br/>      &lt;/ListItem&gt;<br/>      &lt;ListItem&gt;<br/>        &lt;ListItemText primary="Second" /&gt;<br/>      &lt;/ListItem&gt;<br/>    &lt;/List&gt;<br/>    &lt;Divider /&gt;<br/>    &lt;List&gt;<br/>      &lt;ListItem&gt;<br/>        &lt;ListItemText primary="Third" /&gt;<br/>      &lt;/ListItem&gt;<br/>      &lt;ListItem&gt;<br/>        &lt;ListItemText primary="Fourth" /&gt;<br/>      &lt;/ListItem&gt;<br/>    &lt;/List&gt;<br/>    &lt;Divider /&gt;<br/>    &lt;List&gt;<br/>      &lt;ListItem&gt;<br/>        &lt;ListItemText primary="Fifth" /&gt;<br/>      &lt;/ListItem&gt;<br/>      &lt;ListItem&gt;<br/>        &lt;ListItemText primary="Sixth" /&gt;<br/>      &lt;/ListItem&gt;<br/>    &lt;/List&gt;<br/>  &lt;/Fragment&gt;<br/>));<br/><br/>export default ListSections;</pre>
<p>Here's what the rendered list looks like:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-medium wp-image-1255 image-border" src="assets/ec27a12f-f55d-421a-b5e3-8991cbf43b87.png" style="width:8.25em;height:16.67em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Each section is its own <kbd>List</kbd> component, with its own <kbd>ListItem</kbd> components. The <kbd>Divider</kbd> component separates the lists. For example, the first section looks like this:</p>
<pre>&lt;List&gt;<br/>  &lt;ListItem&gt;<br/>    &lt;ListItemText primary="First" /&gt;<br/>  &lt;/ListItem&gt;<br/>  &lt;ListItem&gt;<br/>    &lt;ListItemText primary="Second" /&gt;<br/>  &lt;/ListItem&gt;<br/>&lt;/List&gt;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Instead of having a <kbd>Divider</kbd> component separate your list sections, you can use <kbd>Typography</kbd> to label your sections. This could help your users make sense of the items in each section:</p>
<pre>&lt;Fragment&gt;<br/>  &lt;Typography variant="title"&gt;First Section&lt;/Typography&gt;<br/>  &lt;List&gt;<br/>    &lt;ListItem&gt;<br/>      &lt;ListItemText primary="First" /&gt;<br/>    &lt;/ListItem&gt;<br/>    &lt;ListItem&gt;<br/>      &lt;ListItemText primary="Second" /&gt;<br/>    &lt;/ListItem&gt;<br/>  &lt;/List&gt;<br/>  &lt;Typography variant="title"&gt;Second Section&lt;/Typography&gt;<br/>  &lt;List&gt;<br/>    &lt;ListItem&gt;<br/>      &lt;ListItemText primary="Third" /&gt;<br/>    &lt;/ListItem&gt;<br/>    &lt;ListItem&gt;<br/>      &lt;ListItemText primary="Fourth" /&gt;<br/>    &lt;/ListItem&gt;<br/>  &lt;/List&gt;<br/>  &lt;Typography variant="title"&gt;Third Section&lt;/Typography&gt;<br/>  &lt;List&gt;<br/>    &lt;ListItem&gt;<br/>      &lt;ListItemText primary="Fifth" /&gt;<br/>    &lt;/ListItem&gt;<br/>    &lt;ListItem&gt;<br/>      &lt;ListItemText primary="Sixth" /&gt;<br/>    &lt;/ListItem&gt;<br/>  &lt;/List&gt;<br/>&lt;/Fragment&gt;</pre>
<p>Here's what the list looks like now:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0b49890e-e663-4f48-ad56-a0cbd12cf698.png" style="width:32.67em;height:23.00em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><kbd>List</kbd> demos: <a href="https://material-ui.com/demos/lists/">https://material-ui.com/demos/lists/</a></li>
<li><kbd>Typography</kbd> API documentation: <a href="https://material-ui.com/api/typography/">https://material-ui.com/api/typography/</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Nested lists</h1>
                </header>
            
            <article>
                
<p>Lists can be nested. This is useful when you have a large number of items to render. Instead of showing everything all at once, you can only display those item categories. Then the user can click on these categories to display the items.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let's say that you have two item categories. When the user clicks on a category, the items in that category should be displayed. Here's the code to do this, by using the <kbd>List</kbd> component:</p>
<pre>import React, { useState, Fragment } from 'react';<br/><br/>import List from '@material-ui/core/List';<br/>import ListItem from '@material-ui/core/ListItem';<br/>import ListItemText from '@material-ui/core/ListItemText';<br/>import ListItemIcon from '@material-ui/core/ListItemIcon';<br/>import Collapse from '@material-ui/core/Collapse';<br/><br/>import ExpandLessIcon from '@material-ui/icons/ExpandLess';<br/>import ExpandMoreIcon from '@material-ui/icons/ExpandMore';<br/>import InboxIcon from '@material-ui/icons/Inbox';<br/>import MailIcon from '@material-ui/icons/Mail';<br/>import ContactsIcon from '@material-ui/icons/Contacts';<br/>import ContactMailIcon from '@material-ui/icons/ContactMail';<br/><br/>const ExpandIcon = ({ expanded }) =&gt;<br/>  expanded ? &lt;ExpandLessIcon /&gt; : &lt;ExpandMoreIcon /&gt;;<br/><br/>export default function NestedLists() {<br/>  const [items, setItems] = useState([<br/>    {<br/>      name: 'Messages',<br/>      Icon: InboxIcon,<br/>      expanded: false,<br/>      children: [<br/>        { name: 'First Message', Icon: MailIcon },<br/>        { name: 'Second Message', Icon: MailIcon }<br/>      ]<br/>    },<br/>    {<br/>      name: 'Contacts',<br/>      Icon: ContactsIcon,<br/>      expanded: false,<br/>      children: [<br/>        { name: 'First Contact', Icon: ContactMailIcon },<br/>        { name: 'Second Contact', Icon: ContactMailIcon }<br/>      ]<br/>    }<br/>  ]);<br/><br/>  const onClick = index =&gt; () =&gt; {<br/>    const newItems = [...items];<br/>    const item = items[index];<br/><br/>    newItems[index] = { ...item, expanded: !item.expanded };<br/><br/>    setItems(newItems);<br/>  };<br/><br/>  return (<br/>    &lt;List&gt;<br/>      {items.map(({ Icon, ...item }, index) =&gt; (<br/>        &lt;Fragment key={index}&gt;<br/>          &lt;ListItem button onClick={onClick(index)}&gt;<br/>            &lt;ListItemIcon&gt;<br/>              &lt;Icon /&gt;<br/>            &lt;/ListItemIcon&gt;<br/>            &lt;ListItemText primary={item.name} /&gt;<br/>            &lt;ExpandIcon expanded={item.expanded} /&gt;<br/>          &lt;/ListItem&gt;<br/>          &lt;Collapse in={item.expanded}&gt;<br/>            {item.children.map(child =&gt; (<br/>              &lt;ListItem key={child.name} button dense&gt;<br/>                &lt;ListItemIcon&gt;<br/>                  &lt;child.Icon /&gt;<br/>                &lt;/ListItemIcon&gt;<br/>                &lt;ListItemText primary={child.name} /&gt;<br/>              &lt;/ListItem&gt;<br/>            ))}<br/>          &lt;/Collapse&gt;<br/>        &lt;/Fragment&gt;<br/>      ))}<br/>    &lt;/List&gt;<br/>  );<br/>}</pre>
<p>When you first load the screen, you'll see the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b3b01e21-0be0-4c9c-a1aa-082685c016e1.png" style="width:31.00em;height:6.83em;"/></p>
<p>If you click on each of these categories, you'll see the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8f278173-7b83-4634-bcc2-b76537911c8b.png" style="width:33.75em;height:18.58em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>When you click on a category, the down arrow icon changes to an up arrow. Beneath the category, the list items belonging to that category are displayed. Let's break down what's happening in this code, starting with the component state:</p>
<pre>const [items, setItems] = useState([<br/>  {<br/>    name: 'Messages',<br/>    Icon: InboxIcon,<br/>    expanded: false,<br/>    children: [<br/>      { name: 'First Message', Icon: MailIcon },<br/>      { name: 'Second Message', Icon: MailIcon }<br/>    ]<br/>  },<br/>  {<br/>    name: 'Contacts',<br/>    Icon: ContactsIcon,<br/>    expanded: false,<br/>    children: [<br/>      { name: 'First Contact', Icon: ContactMailIcon },<br/>      { name: 'Second Contact', Icon: ContactMailIcon }<br/>    ]<br/>  }<br/>]);</pre>
<p>Each object in the items array represents a list category. In this case, the categories are <kbd>Messages</kbd> and <kbd>Contacts</kbd>. The <kbd>Icon</kbd> property is the icon component to render for the category. The <kbd>expanded</kbd> property determines the state of the expand arrow icon, and whether or not the items in the category should be displayed.</p>
<p>The <kbd>children</kbd> array contains the items that belong to the category. They have a <kbd>name</kbd> and an <kbd>Icon</kbd> property just like the category items, because they're all rendered using <kbd>ListItem</kbd> components.</p>
<p>Next, let's look at the markup used to render each category and its child items:</p>
<pre>&lt;Fragment key={index}&gt;<br/>  &lt;ListItem button onClick={onClick(index)}&gt;<br/>    &lt;ListItemIcon&gt;<br/>      &lt;Icon /&gt;<br/>    &lt;/ListItemIcon&gt;<br/>    &lt;ListItemText primary={item.name} /&gt;<br/>    &lt;ExpandIcon expanded={item.expanded} /&gt;<br/>  &lt;/ListItem&gt;<br/>  &lt;Collapse in={item.expanded}&gt;<br/>    {item.children.map(child =&gt; (<br/>      &lt;ListItem key={child.name} button dense&gt;<br/>        &lt;ListItemIcon&gt;<br/>          &lt;child.Icon /&gt;<br/>        &lt;/ListItemIcon&gt;<br/>        &lt;ListItemText primary={child.name} /&gt;<br/>      &lt;/ListItem&gt;<br/>    ))}<br/>  &lt;/Collapse&gt;<br/>&lt;/Fragment&gt;</pre>
<p>The category <kbd>ListItem</kbd> component has an <kbd>onClick</kbd> handler that toggles the <kbd>expanded</kbd> state of the category. Next, the <kbd>Collapse</kbd> component is used to control the visibility of the child items of the category, based on the value of <kbd>expanded</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>You can improve on the appearance of your nested list by differentiating the appearance of the sub-items. Right now, the only difference between the category items and subitems is that the category items have expand and collapse arrows.</p>
<p class="mce-root"/>
<p>Typically, list items are indented to indicate that they're part of another item in the hierarchy. Let's create a style that will allow you to indent subitems:</p>
<pre>const useStyles = makeStyles(theme =&gt; ({<br/>  subItem: { paddingLeft: theme.spacing(3) }<br/>}));</pre>
<p>The <kbd>paddingLeft</kbd> style property will shift everything in the list item to the right. Now, let's apply this class to <kbd>subItem</kbd> while also making the item smaller than the category items:</p>
<pre>&lt;ListItem<br/>  key={child.name}<br/>  className={classes.subItem}<br/>  button<br/>  dense<br/>&gt;<br/>  &lt;ListItemIcon&gt;<br/>    &lt;child.Icon /&gt;<br/>  &lt;/ListItemIcon&gt;<br/>  &lt;ListItemText primary={child.name} /&gt;<br/>&lt;/ListItem&gt;</pre>
<p>By adding the <kbd>dense</kbd> and the <kbd>className</kbd> properties to <kbd>ListItem</kbd>, your users should be more easily able to differentiate between the category and its subitems:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ca35d0b4-d02d-4886-b3e2-743e689d23ad.png" style="width:38.42em;height:18.92em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><kbd>List</kbd> demos: <a href="https://material-ui.com/demos/lists/">https://material-ui.com/demos/lists/</a></li>
<li><kbd>Collapse</kbd> API documentation: <a href="https://material-ui.com/api/collapse/">https://material-ui.com/api/collapse/</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">List controls</h1>
                </header>
            
            <article>
                
<p>List items can be clickable, resulting in a change in state, or a link being followed, or something else entirely. This is the primary action of the item. You can have secondary actions on lists called controls. These are common actions that you might perform, depending on the type of item.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let's say that you have a list of devices. When you click on a list item, it might take you to a details page for the device. Each device has Bluetooth connectivity that can be toggled on or off. This is a good candidate secondary action to render in the item. Here's the code to do this:</p>
<pre>import React, { useState } from 'react';<br/><br/>import List from '@material-ui/core/List';<br/>import ListItem from '@material-ui/core/ListItem';<br/>import ListItemText from '@material-ui/core/ListItemText';<br/>import ListItemIcon from '@material-ui/core/ListItemIcon';<br/>import ListItemSecondaryAction from '@material-ui/core/ListItemSecondaryAction';<br/>import IconButton from '@material-ui/core/IconButton';<br/><br/>import BluetoothIcon from '@material-ui/icons/Bluetooth';<br/>import BluetoothDisabledIcon from '@material-ui/icons/BluetoothDisabled';<br/>import DevicesIcon from '@material-ui/icons/Devices';<br/><br/>const MaybeBluetoothIcon = ({ bluetooth }) =&gt;<br/>  bluetooth ? &lt;BluetoothIcon /&gt; : &lt;BluetoothDisabledIcon /&gt;;<br/><br/>export default function ListControls() {<br/>  const [items, setItems] = useState([<br/>    {<br/>      name: 'Device 1',<br/>      bluetooth: true,<br/><br/>      Icon: DevicesIcon<br/>    },<br/>    {<br/>      name: 'Device 2',<br/>      bluetooth: true,<br/><br/>      Icon: DevicesIcon<br/>    },<br/>    {<br/>      name: 'Device 3',<br/>      bluetooth: true,<br/><br/>      Icon: DevicesIcon<br/>    }<br/>  ]);<br/><br/>  const onBluetoothClick = index =&gt; () =&gt; {<br/>    const newItems = [...items];<br/>    const item = items[index];<br/><br/>    newItems[index] = { ...item, bluetooth: !item.bluetooth };<br/><br/>    setItems(newItems);<br/>  };<br/><br/>  return (<br/>    &lt;List&gt;<br/>      {items.map(({ Icon, ...item }, index) =&gt; (<br/>        &lt;ListItem key={index} button&gt;<br/>          &lt;ListItemIcon&gt;<br/>            &lt;Icon /&gt;<br/>          &lt;/ListItemIcon&gt;<br/>          &lt;ListItemText primary={item.name} /&gt;<br/>          &lt;ListItemSecondaryAction&gt;<br/>            &lt;IconButton<br/>              onClick={onBluetoothClick(index, 'bluetooth')}<br/>            &gt;<br/>              &lt;MaybeBluetoothIcon bluetooth={item.bluetooth} /&gt;<br/>            &lt;/IconButton&gt;<br/>          &lt;/ListItemSecondaryAction&gt;<br/>        &lt;/ListItem&gt;<br/>      ))}<br/>    &lt;/List&gt;<br/>  );<br/>}</pre>
<p>Here's what the screen looks like when it first loads:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/84d6128b-bdbc-489d-a004-910521d8d36d.png" style="width:36.17em;height:11.42em;"/></p>
<p>You can toggle the Bluetooth state of one of the items by clicking on the icon buttons. Here's what it looks like after toggling the Bluetooth state of the first item:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/18e9886d-4239-4341-b5e0-863729df9965.png" style="width:36.17em;height:11.33em;"/></p>
<p>The Bluetooth icon has changed to indicate the <kbd>disabled</kbd> state. Clicking on the icon again will enable Bluetooth.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Let's look at the markup that's used to render each list item:</p>
<pre>&lt;ListItem key={index} button&gt;<br/>  &lt;ListItemIcon&gt;<br/>    &lt;Icon /&gt;<br/>  &lt;/ListItemIcon&gt;<br/>  &lt;ListItemText primary={item.name} /&gt;<br/>  &lt;ListItemSecondaryAction&gt;<br/>    &lt;IconButton<br/>      onClick={onBluetoothClick(index, 'bluetooth')}<br/>    &gt;<br/>      &lt;MaybeBluetoothIcon bluetooth={item.bluetooth} /&gt;<br/>    &lt;/IconButton&gt;<br/>  &lt;/ListItemSecondaryAction&gt;<br/>&lt;/ListItem&gt;</pre>
<p>The <kbd>ListItemSecondaryAction</kbd> component is used as a container for any controls in your list item. In this example, an <kbd>IconButton</kbd> is used as the control. It shows a different icon depending on the state of the item, using the <kbd>MaybeBluetoothIcon</kbd> component. The <kbd>onBluetoothClick()</kbd> function is used to return the event handler function for the item. Let's take a look at this function:</p>
<pre>const onBluetoothClick = index =&gt; () =&gt; {<br/>  const newItems = [...items];<br/>  const item = items[index];<br/><br/>  newItems[index] = { ...item, bluetooth: !item.bluetooth };<br/><br/>  setItems(newItems);<br/>};</pre>
<p>The device item is looked up in the <kbd>items</kbd> array. Then, the Bluetooth state is toggled, and the new <kbd>items</kbd> array is returned to set as the new state. This results in the updated icon in the list item control.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>You can have more than one control in your list item. For example, let's say that in addition to toggling the Bluetooth state of a device, another common action for your users is toggling the <kbd>power</kbd> state of the device. When the device is powered off, the list item and the Bluetooth control should be displayed.</p>
<p>Avoid having too many controls as secondary actions in your list items. Doing so detracts from the convenience of having one or two common actions easily accessible by your users.</p>
<p>Let's start by adding a new <kbd>power</kbd> state to each item in your component state:</p>
<pre>const [items, setItems] = useState([<br/>  {<br/>    name: 'Device 1',<br/>    bluetooth: true,<br/>    power: true,<br/>    Icon: DevicesIcon<br/>  },<br/>  {<br/>    name: 'Device 2',<br/>    bluetooth: true,<br/>    power: true,<br/>    Icon: DevicesIcon<br/>  },<br/>  {<br/>    name: 'Device 3',<br/>    bluetooth: true,<br/>    power: true,<br/>    Icon: DevicesIcon<br/>  }<br/>]);</pre>
<p>Next, let's create a toggle click handler that can handle updating both the Bluetooth and the <kbd>power</kbd> state of items:</p>
<pre>const onToggleClick = (index, prop) =&gt; () =&gt; {<br/>  const newItems = [...items];<br/>  const item = items[index];<br/><br/>  newItems[index] = { ...item, [prop]: !item[prop] };<br/><br/>  setItems(newItems);<br/>};</pre>
<p>This is very similar to the <kbd>onBluetoothClick()</kbd> handler. Now, it accepts an additional <kbd>prop</kbd> argument. This is used to tell the function which property to update – <kbd>bluetooth</kbd> or <kbd>power</kbd>. Finally, let's look at the updated <kbd>ListItem</kbd> markup:</p>
<pre>&lt;ListItem key={index} disabled={!item.power} button&gt;<br/>  &lt;ListItemIcon&gt;<br/>    &lt;Icon /&gt;<br/>  &lt;/ListItemIcon&gt;<br/>  &lt;ListItemText primary={item.name} /&gt;<br/>  &lt;ListItemSecondaryAction&gt;<br/>    &lt;IconButton<br/>      onClick={onToggleClick(index, 'bluetooth')}<br/>      disabled={!item.power}<br/>    &gt;<br/>      &lt;MaybeBluetoothIcon bluetooth={item.bluetooth} /&gt;<br/>    &lt;/IconButton&gt;<br/>    &lt;IconButton onClick={onToggleClick(index, 'power')}&gt;<br/>      &lt;PowerSettingsNewIcon /&gt;<br/>    &lt;/IconButton&gt;<br/>  &lt;/ListItemSecondaryAction&gt;<br/>&lt;/ListItem&gt;</pre>
<p>The changes can be summarized as follows:</p>
<ul>
<li>The <kbd>disabled</kbd> property of <kbd>ListItem</kbd> depends on  the <kbd>power</kbd> state of the item.</li>
<li>There's another <kbd>IconButton</kbd> control for toggling the <kbd>power</kbd> state of the item.</li>
<li>The <kbd>onToggleClick()</kbd> function is used by both controls to toggle the state of the item.</li>
</ul>
<p>Here's how the screen looks now, when first loaded:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a24567fe-1600-4059-a6b3-b60dd23d470e.png" style="width:32.67em;height:9.50em;"/></p>
<p>When you click on the power icon, the list item and the Bluetooth button become disabled. Here's what it looks like when the first item is powered off:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a714fd66-3ce9-44a2-9b34-e0f5b5f22682.png" style="width:33.75em;height:10.00em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><kbd>ListItemSecondaryAction</kbd> API documentation: <a href="https://material-ui.com/api/list-item-secondary-action/">https://material-ui.com/api/list-item-secondary-action/</a></li>
<li><kbd>IconButton</kbd> API documentation: <a href="https://material-ui.com/api/icon-button/">https://material-ui.com/api/icon-button/</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Scrolling lists</h1>
                </header>
            
            <article>
                
<p>When your lists contain a limited number of items in them, you're safe to just iterate over the item data, and render <kbd>ListItem</kbd> components. This becomes a problem when you have the potential for lists with over 1,000 items in them. You can render these items fast enough, but having this many items in the <span><strong>Document Object Model</strong> (</span><strong>DOM</strong>) eats a lot of browser resources, and can lead to unpredictable performance challenges for the user. The solution is to virtualize your Material-UI lists using <kbd>react-virtualized</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let's say that you have a list of 1,000 items in it. You want to render these items inside a list with a fixed height. In order to provide predictable performance characteristics for your users, you only want to render items that are actually visible to the user as they scroll through the list. Here's the code:</p>
<pre>import React, { useState } from 'react';<br/>import { List as VirtualList, AutoSizer } from 'react-virtualized';<br/><br/>import { makeStyles } from '@material-ui/styles';<br/>import List from '@material-ui/core/List';<br/>import ListItem from '@material-ui/core/ListItem';<br/>import ListItemText from '@material-ui/core/ListItemText';<br/>import Paper from '@material-ui/core/Paper';<br/><br/>const useStyles = makeStyles(theme =&gt; ({<br/>  list: {<br/>    height: 300<br/>  },<br/>  paper: {<br/>    margin: theme.spacing(3)<br/>  }<br/>}));<br/><br/>function* genItems() {<br/>  for (let i = 1; i &lt;= 1000; i++) {<br/>    yield `Item ${i}`;<br/>  }<br/>}<br/><br/>export default function ScrollingLists() {<br/>  const classes = useStyles();<br/>  const [items] = useState([...genItems()]);<br/><br/>  const rowRenderer = ({ index, isScrolling, key, style }) =&gt; {<br/>    const item = items[index];<br/><br/>    return (<br/>      &lt;ListItem button key={key} style={style}&gt;<br/>        &lt;ListItemText primary={isScrolling ? '...' : item} /&gt;<br/>      &lt;/ListItem&gt;<br/>    );<br/>  };<br/><br/>  return (<br/>    &lt;Paper className={classes.paper}&gt;<br/>      &lt;List className={classes.list}&gt;<br/>        &lt;AutoSizer disableHeight&gt;<br/>          {({ width }) =&gt; (<br/>            &lt;VirtualList<br/>              width={width}<br/>              height={300}<br/>              rowHeight={50}<br/>              rowCount={items.length}<br/>              rowRenderer={rowRenderer}<br/>            /&gt;<br/>          )}<br/>        &lt;/AutoSizer&gt;<br/>      &lt;/List&gt;<br/>    &lt;/Paper&gt;<br/>  );<br/>}</pre>
<p>When you first load the screen, you'll see the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/968263e2-fde7-4907-9cee-79eafd2ab234.png" style="width:38.17em;height:18.92em;"/></p>
<p>As you scroll through the list, here's what you'll see:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/165daa3f-47fc-46df-bdf3-00593ab6c915.png" style="width:37.33em;height:18.67em;"/></p>
<p>Lastly, here's what the bottom of the list looks like:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c148fa82-2065-4378-ac8f-0dc5585ff994.png" style="width:6.92em;height:15.17em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>First, let's take a look at how the <kbd>items</kbd> state is generated. First, there's a <kbd>genItems()</kbd> generator function:</p>
<pre>function* genItems() {<br/>  for (let i = 1; i &lt;= 1000; i++) {<br/>    yield `Item ${i}`;<br/>  }<br/>}</pre>
<p>Then, the spread operator is used to turn the generated <kbd>items</kbd> into an array for the component state:</p>
<pre>const [items] = useState([...genItems()]);</pre>
<p>Next, let's look at the <kbd>rowRenderer()</kbd> function:</p>
<pre>const rowRenderer = ({ index, isScrolling, key, style }) =&gt; {<br/>  const item = items[index];<br/><br/>  return (<br/>    &lt;ListItem button key={key} style={style}&gt;<br/>      &lt;ListItemText primary={isScrolling ? '...' : item} /&gt;<br/>    &lt;/ListItem&gt;<br/>  );<br/>};</pre>
<p>This function returns the <kbd>ListItem</kbd> component that should be rendered at the given index. Instead of manually mapping this component to <kbd>items</kbd>, the <kbd>List</kbd> component from <kbd>react-virtualized</kbd> orchestrates when to call it for you, based on how the user scrolls through the list.</p>
<p>The <kbd>key</kbd> and the <kbd>style</kbd> values that are passed to this function are required by <kbd>react-virtualized</kbd> in order to work correctly. For example, the <kbd>style</kbd> value is used to control the visibility of the item as scrolling happens. The <kbd>isScrolling</kbd> value is used to render different data while the list is actively being scrolled. For example, imagine that instead of just a text label within the list item, you also had an icon, along with other controls that are all based on state. Trying to render these things while scrolling is going on is expensive and wasteful. Instead, you can render something that's less resource intensive, such as a placeholder string: <kbd>'...'</kbd>.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Finally, let's examine the markup used to render this list:</p>
<pre>&lt;List className={classes.list}&gt;<br/>  &lt;AutoSizer disableHeight&gt;<br/>    {({ width }) =&gt; (<br/>      &lt;VirtualList<br/>        width={width}<br/>        height={300}<br/>        rowHeight={50}<br/>        rowCount={items.length}<br/>        rowRenderer={rowRenderer}<br/>      /&gt;<br/>    )}<br/>  &lt;/AutoSizer&gt;<br/>&lt;/List&gt;</pre>
<p>The <kbd>List</kbd> component is the container for everything else. Next, the <kbd>AutoSizer</kbd> component from <kbd>react-virtualized</kbd> figures out the width of the list, which is needed as a <kbd>VirtualList</kbd> property.</p>
<div class="packt_tip"><kbd>List</kbd> is imported from <kbd>react-virtualized</kbd> using the alias <kbd>VirtualList</kbd>. This is to avoid the naming conflict with <kbd>List</kbd> from <kbd>material-ui</kbd>. You could import <kbd>List</kbd> from <kbd>material-ui</kbd> as an alias instead, if you prefer.</div>
<p>The <kbd>List</kbd> component from <kbd>react-virtualized</kbd> also takes the height of the list, the height of each row, and the row count, in order to determine which rows to render. With this in place, you never have to worry about the performance of your application because of a list component with too many items.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>React Virtualized documentation: <a href="https://bvaughn.github.io/react-virtualized/">https://bvaughn.github.io/react-virtualized/</a></li>
<li><kbd>List</kbd> demos: https://material-ui.com/demos/lists/</li>
</ul>


            </article>

            
        </section>
    </body></html>