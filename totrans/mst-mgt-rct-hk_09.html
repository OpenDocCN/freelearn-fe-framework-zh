<html><head></head><body>
		<div id="_idContainer016">
			<h1 id="_idParaDest-80"><em class="italic"><a id="_idTextAnchor080"/><span class="koboSpan" id="kobo.1.1">Chapter 6</span></em><span class="koboSpan" id="kobo.2.1">: Introducing Global State Libraries</span></h1>
			<p><span class="L2-L3-bullet-characters"><span class="koboSpan" id="kobo.3.1">We have learned about several patterns used to share state among components so far. </span><span class="koboSpan" id="kobo.3.2">The rest of this book will introduce various global state libraries that use such patterns.</span></span></p>
			<p><span class="L2-L3-bullet-characters"><span class="koboSpan" id="kobo.4.1">Before diving into the libraries, we will recap the challenges associated with global states and discuss two aspects of libraries: where the state resides and how to control re-renders. </span><span class="koboSpan" id="kobo.4.2">With this in hand, we will be able to understand the characteristics of global state libraries.</span></span></p>
			<p><span class="L2-L3-bullet-characters"><span class="koboSpan" id="kobo.5.1">In this chapter, we will cover the following topics:</span></span></p>
			<ul>
				<li><span class="L2-L3-bullet-characters"><span class="koboSpan" id="kobo.6.1">Working with global state management issues</span></span></li>
				<li><span class="L2-L3-bullet-characters"><span class="koboSpan" id="kobo.7.1">Using the data-centric and component-centric approaches</span></span></li>
				<li><span class="L2-L3-bullet-characters"><span class="koboSpan" id="kobo.8.1">Optimizing re-renders</span></span></li>
			</ul>
			<h1 id="_idParaDest-81"><a id="_idTextAnchor081"/><span class="koboSpan" id="kobo.9.1">Technical requirements</span></h1>
			<p><span class="koboSpan" id="kobo.10.1">You are expected to have moderate knowledge of React, including React hooks. </span><span class="koboSpan" id="kobo.10.2">Refer to the official site at </span><a href="https://reactjs.org"><span class="koboSpan" id="kobo.11.1">https://reactjs.org</span></a><span class="koboSpan" id="kobo.12.1"> to learn more.</span></p>
			<p><span class="koboSpan" id="kobo.13.1">To run the code snippets, you need a React environment, for example, Create React App (</span><a href="https://create-react-app.dev"><span class="koboSpan" id="kobo.14.1">https://create-react-app.dev</span></a><span class="koboSpan" id="kobo.15.1">) or CodeSandbox (</span><a href="https://codesandbox.io"><span class="koboSpan" id="kobo.16.1">https://codesandbox.io</span></a><span class="koboSpan" id="kobo.17.1">).</span></p>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor082"/><span class="koboSpan" id="kobo.18.1">Working with global state management issues</span></h1>
			<p><span class="koboSpan" id="kobo.19.1">React is designed around the concept of components. </span><span class="koboSpan" id="kobo.19.2">In the component model, everything is expected to be reusable. </span><span class="koboSpan" id="kobo.19.3">Global state is something that exists outside of components. </span><span class="koboSpan" id="kobo.19.4">It's often true that we should avoid using a global state where possible because it requires an extra dependency on a component. </span><span class="koboSpan" id="kobo.19.5">However, a global state is sometimes very handy and </span><a id="_idIndexMarker223"/><span class="koboSpan" id="kobo.20.1">allows us to be more productive. </span><span class="koboSpan" id="kobo.20.2">For some app requirements, global state fits well.</span></p>
			<p><span class="koboSpan" id="kobo.21.1">There are two challenges when designing a global state:</span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.22.1">The first challenge is how to read a global state. </span><p><span class="koboSpan" id="kobo.23.1">Global state tends to have multiple values. </span><span class="koboSpan" id="kobo.23.2">It's often the case that a component using a global state doesn't need all the values in it. </span><span class="koboSpan" id="kobo.23.3">If a component re-renders when a global state is changed but the changed values are not relevant to the component, it's an extra re-render. </span><span class="koboSpan" id="kobo.23.4">Extra re-renders are not desirable, and global state libraries should provide a solution for them. </span><span class="koboSpan" id="kobo.23.5">There are several approaches to avoiding extra re-renders, and we will discuss them in more detail in the </span><em class="italic"><span class="koboSpan" id="kobo.24.1">Optimizing re-renders</span></em><span class="koboSpan" id="kobo.25.1"> section.</span></p></li>
				<li><span class="koboSpan" id="kobo.26.1">The second challenge is how to write or update a global state. </span><p><span class="koboSpan" id="kobo.27.1">Again, global</span><a id="_idIndexMarker224"/><span class="koboSpan" id="kobo.28.1"> state is likely to have multiple values, some of which may be nested objects. </span><span class="koboSpan" id="kobo.28.2">It might not be a good idea to have a single global variable and accept arbitrary mutations. </span><span class="koboSpan" id="kobo.28.3">The following code block shows an example of a global variable and one arbitrary mutation:</span></p><p class="source-code"><span class="koboSpan" id="kobo.29.1">let globalVariable = {</span></p><p class="source-code"><span class="koboSpan" id="kobo.30.1">  a: 1,</span></p><p class="source-code"><span class="koboSpan" id="kobo.31.1">  b: {</span></p><p class="source-code"><span class="koboSpan" id="kobo.32.1">    c: 2,</span></p><p class="source-code"><span class="koboSpan" id="kobo.33.1">    d: 3,</span></p><p class="source-code"><span class="koboSpan" id="kobo.34.1">  },</span></p><p class="source-code"><span class="koboSpan" id="kobo.35.1">  e: [4, 5, 6],</span></p><p class="source-code"><span class="koboSpan" id="kobo.36.1">};</span></p><p class="source-code"><span class="koboSpan" id="kobo.37.1">globalVariable.b.d = 9;</span></p><p><span class="koboSpan" id="kobo.38.1">The mutation </span><strong class="source-inline"><span class="koboSpan" id="kobo.39.1">globalVariable.b.d = 9</span></strong><span class="koboSpan" id="kobo.40.1"> in the example may not work for a global state because there's no way to detect the change and trigger React components to re-render.</span></p></li>
			</ul>
			<p><span class="koboSpan" id="kobo.41.1">To have more control over how to write a global state, we often provide functions to update a global state. </span><span class="koboSpan" id="kobo.41.2">It's also often necessary to hide a variable in a closure so that the variable can't be </span><a id="_idIndexMarker225"/><span class="koboSpan" id="kobo.42.1">mutated directly. </span><span class="koboSpan" id="kobo.42.2">The following code block shows an example of creating two functions for reading and writing a variable in a closure:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.43.1">const createContainer = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.44.1">  let state = { a: 1, b: 2 };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.45.1">  const geState = () =&gt; state;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.46.1">  const setState = (...) =&gt; { ...  };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.47.1">  return { getState, setState };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.48.1">};</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.49.1">const globalContainer = createContainer();</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.50.1">globalContainer.setState(...);</span></p>
			<p><span class="koboSpan" id="kobo.51.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.52.1">createContainer</span></strong><span class="koboSpan" id="kobo.53.1"> function creates </span><strong class="source-inline"><span class="koboSpan" id="kobo.54.1">globalContainer</span></strong><span class="koboSpan" id="kobo.55.1">, which holds </span><strong class="source-inline"><span class="koboSpan" id="kobo.56.1">getState</span></strong><span class="koboSpan" id="kobo.57.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">setState</span></strong><span class="koboSpan" id="kobo.59.1"> functions. </span><strong class="source-inline"><span class="koboSpan" id="kobo.60.1">getState</span></strong><span class="koboSpan" id="kobo.61.1"> is a function to read a global state and </span><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">setState</span></strong><span class="koboSpan" id="kobo.63.1"> is a function to update a global state. </span><span class="koboSpan" id="kobo.63.2">There are several ways to implement functions such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">setState</span></strong><span class="koboSpan" id="kobo.65.1"> to update a global state. </span><span class="koboSpan" id="kobo.65.2">We will look at concrete examples in the following chapters.</span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.66.1">Global versus General State Management</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.67.1">This book focuses on </span><em class="italic"><span class="koboSpan" id="kobo.68.1">global</span></em><span class="koboSpan" id="kobo.69.1"> state management; </span><em class="italic"><span class="koboSpan" id="kobo.70.1">general</span></em><span class="koboSpan" id="kobo.71.1"> state management is out of scope. </span><span class="koboSpan" id="kobo.71.2">In the field of general state management, popular approaches include the one-way data flow approach, as in </span><a id="_idIndexMarker226"/><span class="koboSpan" id="kobo.72.1">Redux (</span><a href="https://redux.js.org"><span class="koboSpan" id="kobo.73.1">https://redux.js.org</span></a><span class="koboSpan" id="kobo.74.1">), and the</span><a id="_idIndexMarker227"/><span class="koboSpan" id="kobo.75.1"> state machine-based approach, as in XState (</span><a href="https://xstate.js.org"><span class="koboSpan" id="kobo.76.1">https://xstate.js.org</span></a><span class="koboSpan" id="kobo.77.1">). </span><span class="koboSpan" id="kobo.77.2">General state management approaches are useful not only for a global state but also for a local state.</span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.78.1">Notes about Redux and React Redux</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.79.1">Redux has been a big player in a global state management. </span><span class="koboSpan" id="kobo.79.2">Redux solves state management with one-way data flow with a global state in mind. </span><span class="koboSpan" id="kobo.79.3">However, Redux itself has nothing to do with React. </span><span class="koboSpan" id="kobo.79.4">It's </span><a id="_idIndexMarker228"/><span class="koboSpan" id="kobo.80.1">React Redux (</span><a href="https://react-redux.js.org"><span class="koboSpan" id="kobo.81.1">https://react-redux.js.org</span></a><span class="koboSpan" id="kobo.82.1">) that binds React and Redux. </span><span class="koboSpan" id="kobo.82.2">While Redux itself doesn't have a capability or a notion to avoid extra re-renders, React Redux has such a capability. </span></p>
			<p class="callout"><span class="koboSpan" id="kobo.83.1">Because Redux and React Redux were so popular, some people overused them in the past. </span><span class="koboSpan" id="kobo.83.2">This was due to the lack of React Context before React 16.3, and there were no other popular options. </span><span class="koboSpan" id="kobo.83.3">Such people (mis-)used React Redux mainly for (legacy) Context, without needing the one-way data flow. </span><span class="koboSpan" id="kobo.83.4">With React Context since React 16.3 and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">useContext</span></strong><span class="koboSpan" id="kobo.85.1"> hook since React 16.8, we can easily solve use cases to avoid prop drilling and extra re-renders. </span><span class="koboSpan" id="kobo.85.2">That brings us to microstate management – our focus in this book. </span></p>
			<p class="callout"><span class="koboSpan" id="kobo.86.1">Hence, technically speaking, React Redux minus Redux is within the scope of this book. </span><span class="koboSpan" id="kobo.86.2">Redux itself is a great solution for general state management, and along with React Redux, it solves the global state issues we discussed in this section.</span></p>
			<p><span class="koboSpan" id="kobo.87.1">In this section, we discussed the general challenges when it comes to global state libraries. </span><span class="koboSpan" id="kobo.87.2">Next up, we will learn about where state resides.</span></p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor083"/><span class="koboSpan" id="kobo.88.1">Using the data-centric and component-centric approaches</span></h1>
			<p><span class="koboSpan" id="kobo.89.1">Global state can technically be divided into two types: data-centric and component-centric.</span></p>
			<p><span class="koboSpan" id="kobo.90.1">In the following sections, we will discuss both these approaches in detail. </span><span class="koboSpan" id="kobo.90.2">Then, we will also talk about some exceptions.</span></p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor084"/><span class="koboSpan" id="kobo.91.1">Understanding the data-centric approach</span></h2>
			<p><span class="koboSpan" id="kobo.92.1">When you</span><a id="_idIndexMarker229"/><span class="koboSpan" id="kobo.93.1"> design an app, you may have a data model as a singleton in your app and you may already have the data to deal with. </span><span class="koboSpan" id="kobo.93.2">In this case, you would define components and connect the data and the components. </span><span class="koboSpan" id="kobo.93.3">The data can be changed from the outside, such as by other libraries or from other servers.</span></p>
			<p><span class="koboSpan" id="kobo.94.1">For the data-centric approach, module state would fit better, because module state resides in </span><a id="_idIndexMarker230"/><span class="koboSpan" id="kobo.95.1">JavaScript memory outside React. </span><span class="koboSpan" id="kobo.95.2">Module state can exist before React starts rendering or even after all React components are unmounted.</span></p>
			<p><span class="koboSpan" id="kobo.96.1">Global state libraries using the data-centric approach would provide APIs to create module state and to connect the module state to React components. </span><span class="koboSpan" id="kobo.96.2">Module state is usually wrapped in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">store</span></strong><span class="koboSpan" id="kobo.98.1"> object, which has methods to access and update a </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">state</span></strong><span class="koboSpan" id="kobo.100.1"> variable.</span></p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor085"/><span class="koboSpan" id="kobo.101.1">Understanding the component-centric approach</span></h2>
			<p><span class="koboSpan" id="kobo.102.1">Unlike the</span><a id="_idIndexMarker231"/><span class="koboSpan" id="kobo.103.1"> data-centric approach, with the component-centric approach, you can design components first. </span><span class="koboSpan" id="kobo.103.2">At some point, some components may need to access shared information. </span><span class="koboSpan" id="kobo.103.3">As we discussed in the </span><em class="italic"><span class="koboSpan" id="kobo.104.1">Effectively using local states</span></em><span class="koboSpan" id="kobo.105.1"> section in </span><a href="B17780_02_Final_VK_ePub.xhtml#_idTextAnchor035"><em class="italic"><span class="koboSpan" id="kobo.106.1">Chapter 2</span></em></a><span class="koboSpan" id="kobo.107.1">, </span><em class="italic"><span class="koboSpan" id="kobo.108.1">Using Local and Global States</span></em><span class="koboSpan" id="kobo.109.1">, we can lift state and pass it down with props (a.k.a. </span><span class="koboSpan" id="kobo.109.2">prop drilling). </span><span class="koboSpan" id="kobo.109.3">If prop drilling won't work as a solution, that's when we can introduce a global state. </span><span class="koboSpan" id="kobo.109.4">Certainly, we can start by designing a data model first, but in the component-centric approach, the data model is fairly tied to components.</span></p>
			<p><span class="koboSpan" id="kobo.110.1">For the component-centric approach, component state, which holds a global state in the component lifecycle, fits better. </span><span class="koboSpan" id="kobo.110.2">This is because when all the corresponding components are unmounted, a global state is gone too. </span><span class="koboSpan" id="kobo.110.3">This capability allows us to have two or more global states that exist in JavaScript memory because they are in different component subtrees (or different portals).</span></p>
			<p><span class="koboSpan" id="kobo.111.1">Global state libraries using a data-centric approach provide a factory function to create functions that initialize a global state for use in React components. </span><span class="koboSpan" id="kobo.111.2">A factory function doesn't directly create a global state, but by using the generated functions, we let React handle a global state lifecycle.</span></p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor086"/><span class="koboSpan" id="kobo.112.1">Exploring the exceptions of both approaches</span></h2>
			<p><span class="koboSpan" id="kobo.113.1">What we have </span><a id="_idIndexMarker232"/><span class="koboSpan" id="kobo.114.1">described are typical use cases, and </span><a id="_idIndexMarker233"/><span class="koboSpan" id="kobo.115.1">there are always some exceptions. </span><span class="koboSpan" id="kobo.115.2">The data-centric approach and the component-centric approach are not really two sides of the same coin. </span><span class="koboSpan" id="kobo.115.3">In reality, you can use one of two approaches or a hybrid of the two approaches.</span></p>
			<p><span class="koboSpan" id="kobo.116.1">Module state is often used as a singleton pattern, but you can create multiple module states for subtrees. </span><span class="koboSpan" id="kobo.116.2">You can even control the lifecycles of them.</span></p>
			<p><span class="koboSpan" id="kobo.117.1">Component state</span><a id="_idIndexMarker234"/><span class="koboSpan" id="kobo.118.1"> is often used to provide a state in a subtree, but if you put the provider component at the root of the tree and there's only one tree in JavaScript memory, it can be treated like a singleton pattern.</span></p>
			<p><span class="koboSpan" id="kobo.119.1">Component state </span><a id="_idIndexMarker235"/><span class="koboSpan" id="kobo.120.1">is often implemented with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">useState</span></strong><span class="koboSpan" id="kobo.122.1"> hook, but if we need to have a mutable variable or </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">store</span></strong><span class="koboSpan" id="kobo.124.1">, an implementation with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">useRef</span></strong><span class="koboSpan" id="kobo.126.1"> hook is possible. </span><span class="koboSpan" id="kobo.126.2">The implementation might be more complicated than using </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">useState</span></strong><span class="koboSpan" id="kobo.128.1">, but it still comes under the component lifecycle.</span></p>
			<p><span class="koboSpan" id="kobo.129.1">In this section, we learned about two approaches for using a global state. </span><span class="koboSpan" id="kobo.129.2">Module state is mainly for use with the data-centric approach, and component state is mainly for use with the component-centric approach. </span><span class="koboSpan" id="kobo.129.3">Next, we will learn about several patterns to optimize re-renders.</span></p>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor087"/><span class="koboSpan" id="kobo.130.1">Optimizing re-renders</span></h1>
			<p><span class="koboSpan" id="kobo.131.1">Avoiding</span><a id="_idIndexMarker236"/><span class="koboSpan" id="kobo.132.1"> extra re-renders is a major challenge when it comes to a global state. </span><span class="koboSpan" id="kobo.132.2">This is a big point to consider when designing a global state library for React.</span></p>
			<p><span class="koboSpan" id="kobo.133.1">Typically, a global state has multiple properties, and they can be nested objects. </span><span class="koboSpan" id="kobo.133.2">See the following, for example:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.134.1">let state = {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.135.1">  a: 1,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.136.1">  b: { c: 2, d: 3 },</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.137.1">  e: { f: 4, g: 5 },</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.138.1">};</span></p>
			<p><span class="koboSpan" id="kobo.139.1">With this </span><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">state</span></strong><span class="koboSpan" id="kobo.141.1"> object, let's assume two components </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">ComponentA</span></strong><span class="koboSpan" id="kobo.143.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">ComponentB</span></strong><span class="koboSpan" id="kobo.145.1">, which use </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">state.b.c</span></strong><span class="koboSpan" id="kobo.147.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">state.e.g</span></strong><span class="koboSpan" id="kobo.149.1">, respectively. </span><span class="koboSpan" id="kobo.149.2">The following is pseudocode of the two components:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.150.1">const ComponentA = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.151.1">  return &lt;&gt;value: {state.b.c}&lt;/&gt;;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.152.1">};</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.153.1">const ComponentB = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.154.1">  return &lt;&gt;value: {state.e.g}&lt;/&gt;;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.155.1">};</span></p>
			<p><span class="koboSpan" id="kobo.156.1">Now, let's suppose we change </span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">state</span></strong><span class="koboSpan" id="kobo.158.1"> as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.159.1">++state.a;</span></p>
			<p><span class="koboSpan" id="kobo.160.1">This changes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">a</span></strong><span class="koboSpan" id="kobo.162.1"> property of </span><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">state</span></strong><span class="koboSpan" id="kobo.164.1">, but it doesn't change either </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">state.b.c</span></strong><span class="koboSpan" id="kobo.166.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">state.e.g</span></strong><span class="koboSpan" id="kobo.168.1">. </span><span class="koboSpan" id="kobo.168.2">In this case, the two components don't need to re-render.</span></p>
			<p><span class="koboSpan" id="kobo.169.1">The goal of optimizing</span><a id="_idIndexMarker237"/><span class="koboSpan" id="kobo.170.1"> re-renders is to specify which part of </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">state</span></strong><span class="koboSpan" id="kobo.172.1"> is used in a component. </span><span class="koboSpan" id="kobo.172.2">We have several approaches to specify the part of </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">state</span></strong><span class="koboSpan" id="kobo.174.1">. </span><span class="koboSpan" id="kobo.174.2">This section describes three approaches:</span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.175.1">Using a selector function</span></li>
				<li><span class="koboSpan" id="kobo.176.1">Detecting property access</span></li>
				<li><span class="koboSpan" id="kobo.177.1">Using atoms</span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.178.1">We will discuss each of these now.</span></p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor088"/><span class="koboSpan" id="kobo.179.1">Using a selector function</span></h2>
			<p><span class="koboSpan" id="kobo.180.1">One </span><a id="_idIndexMarker238"/><span class="koboSpan" id="kobo.181.1">approach is using a selector function. </span><span class="koboSpan" id="kobo.181.2">A selector function takes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">state</span></strong><span class="koboSpan" id="kobo.183.1"> variable and returns a part of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">state</span></strong><span class="koboSpan" id="kobo.185.1"> variable.</span></p>
			<p><span class="koboSpan" id="kobo.186.1">For example, let's suppose we have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">useSelector</span></strong><span class="koboSpan" id="kobo.188.1"> hook that takes a selector function and returns part of </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">state</span></strong><span class="koboSpan" id="kobo.190.1">:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.191.1">const Component = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.192.1">  const value = useSelector((state) =&gt; state.b.c);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.193.1">  return &lt;&gt;{value}&lt;/&gt;;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.194.1">};</span></p>
			<p><span class="koboSpan" id="kobo.195.1">If </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">state.b.c</span></strong><span class="koboSpan" id="kobo.197.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">2</span></strong><span class="koboSpan" id="kobo.199.1">, then </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">Component</span></strong><span class="koboSpan" id="kobo.201.1"> will show </span><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">2</span></strong><span class="koboSpan" id="kobo.203.1">. </span><span class="koboSpan" id="kobo.203.2">Now that we know that this component cares only about </span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">state.b.c</span></strong><span class="koboSpan" id="kobo.205.1">, we can avoid extra re-renders only when </span><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">state.a</span></strong><span class="koboSpan" id="kobo.207.1"> is changed.</span></p>
			<p><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">useSelector</span></strong><span class="koboSpan" id="kobo.209.1"> will </span><a id="_idIndexMarker239"/><span class="koboSpan" id="kobo.210.1">be used to compare the selector function's result every time </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">state</span></strong><span class="koboSpan" id="kobo.212.1"> is changed. </span><span class="koboSpan" id="kobo.212.2">Hence, it's important that the selector function returns the referentially equal result when given the same input.</span></p>
			<p><span class="koboSpan" id="kobo.213.1">The selector function is so flexible that it can return not only a part of </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">state</span></strong><span class="koboSpan" id="kobo.215.1">, but also any derived value. </span><span class="koboSpan" id="kobo.215.2">For example, it can return a doubled value, like here:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.216.1">const Component = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.217.1">  const value = useSelector((state) =&gt; state.b.c * 2);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.218.1">  return &lt;&gt;{value}&lt;/&gt;;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.219.1">};</span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.220.1">A Note about Selector and Memoization</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.221.1">If a value returned by the selector function is a primitive value such as a number, there are no issues. </span><span class="koboSpan" id="kobo.221.2">However, if the selector function returns a derived object value, we need to make sure to return a referentially equal object with the </span><a id="_idIndexMarker240"/><span class="koboSpan" id="kobo.222.1">so-called memoization technique. </span><span class="koboSpan" id="kobo.222.2">You </span><a id="_idIndexMarker241"/><span class="koboSpan" id="kobo.223.1">can read more about memoization at </span><a href="https://en.wikipedia.org/wiki/Memoization"><span class="koboSpan" id="kobo.224.1">https://en.wikipedia.org/wiki/Memoization</span></a><span class="koboSpan" id="kobo.225.1">.</span></p>
			<p><span class="koboSpan" id="kobo.226.1">As a selector function is a means to explicitly specify which part of a component will be used, we call this a manual optimization.</span></p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor089"/><span class="koboSpan" id="kobo.227.1">Detecting property access</span></h2>
			<p><span class="koboSpan" id="kobo.228.1">Can we do </span><a id="_idIndexMarker242"/><span class="koboSpan" id="kobo.229.1">render optimization automatically, without using a selector function to explicitly specify which part of a state is to be used in a component? </span><span class="koboSpan" id="kobo.229.2">There is something called state usage tracking, which is used to detect property access and use the detected information for render optimization.</span></p>
			<p><span class="koboSpan" id="kobo.230.1">For example, let's suppose we have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">useTrackedState</span></strong><span class="koboSpan" id="kobo.232.1"> hook that has the state usage tracking capability:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.233.1">const Component = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.234.1">  const trackedState = useTrackedState();</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.235.1">  return &lt;p&gt;{trackedState.b.c}&lt;/p&gt;;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.236.1">};</span></p>
			<p><span class="koboSpan" id="kobo.237.1">This works as </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">trackedState</span></strong><span class="koboSpan" id="kobo.239.1"> can detect that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">.b.c</span></strong><span class="koboSpan" id="kobo.241.1"> property is accessed, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">useTrackedState</span></strong><span class="koboSpan" id="kobo.243.1"> only triggers re-renders when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">.b.c</span></strong><span class="koboSpan" id="kobo.245.1"> property value is changed. </span><span class="koboSpan" id="kobo.245.2">This is automatic render optimization, whereas </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">useSelector</span></strong><span class="koboSpan" id="kobo.247.1"> is manual render optimization.</span></p>
			<p><span class="koboSpan" id="kobo.248.1">For </span><a id="_idIndexMarker243"/><span class="koboSpan" id="kobo.249.1">simplicity, the previous code block example is contrived. </span><span class="koboSpan" id="kobo.249.2">This example can easily be implemented with </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">useSelector</span></strong><span class="koboSpan" id="kobo.251.1">, the manual render optimization. </span><span class="koboSpan" id="kobo.251.2">Let's look at another example using two values:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.252.1">const Component = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.253.1">  const trackedState = useTrackedState();</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.254.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.255.1">    &lt;&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.256.1">      &lt;p&gt;{trackedState.b.c}&lt;/p&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.257.1">      &lt;p&gt;{trackedState.e.g}&lt;/p&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.258.1">    &lt;/&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.259.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.260.1">};</span></p>
			<p><span class="koboSpan" id="kobo.261.1">Now, this is surprisingly difficult to implement with a single </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">useSelector</span></strong><span class="koboSpan" id="kobo.263.1"> hook. </span><span class="koboSpan" id="kobo.263.2">If we were to write a selector, it would require memoization or a custom equality function, which are complicated techniques. </span><span class="koboSpan" id="kobo.263.3">However, if we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">useTrackedState</span></strong><span class="koboSpan" id="kobo.265.1">, it works without such complicated techniques.</span></p>
			<p><span class="koboSpan" id="kobo.266.1">The implementation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">useTrackedState</span></strong><span class="koboSpan" id="kobo.268.1"> requires Proxy (</span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy"><span class="koboSpan" id="kobo.269.1">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy</span></a><span class="koboSpan" id="kobo.270.1">) to trap the property access to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">state</span></strong><span class="koboSpan" id="kobo.272.1"> object. </span><span class="koboSpan" id="kobo.272.2">If this is implemented properly, it can replace most use cases of </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">useSelector</span></strong><span class="koboSpan" id="kobo.274.1"> and </span><a id="_idIndexMarker244"/><span class="koboSpan" id="kobo.275.1">can do the automatic render optimization. </span><span class="koboSpan" id="kobo.275.2">However, there's a subtle case where the automatic render optimization doesn't work perfectly. </span><span class="koboSpan" id="kobo.275.3">Let's take a closer look in the next section.</span></p>
			<h3><span class="koboSpan" id="kobo.276.1">The difference between useSelector and useTrackedState</span></h3>
			<p><span class="koboSpan" id="kobo.277.1">There</span><a id="_idIndexMarker245"/><span class="koboSpan" id="kobo.278.1"> are some use cases in which </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">useSelector</span></strong><span class="koboSpan" id="kobo.280.1"> works better than </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">useTrackedState</span></strong><span class="koboSpan" id="kobo.282.1">. </span><span class="koboSpan" id="kobo.282.2">Because </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">useSelector</span></strong><span class="koboSpan" id="kobo.284.1"> can create any derived values, it can derive state into simpler values. </span></p>
			<p><span class="koboSpan" id="kobo.285.1">The difference </span><a id="_idIndexMarker246"/><span class="koboSpan" id="kobo.286.1">between the working of </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">useSelector</span></strong><span class="koboSpan" id="kobo.288.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">useTrackedState</span></strong><span class="koboSpan" id="kobo.290.1"> can be seen with the help of a simple example. </span><span class="koboSpan" id="kobo.290.2">The following is an example component with </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">useSelector</span></strong><span class="koboSpan" id="kobo.292.1">: </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.293.1">const Component = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.294.1">  const isSmall = useSelector((state) =&gt; state.a &lt; 10);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.295.1">  return &lt;&gt;{isSmall ? </span><span class="koboSpan" id="kobo.295.2">'small' : 'big'}&lt;/&gt;;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.296.1">};</span></p>
			<p><span class="koboSpan" id="kobo.297.1">If we were to create the same component with </span><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">useTrackedState</span></strong><span class="koboSpan" id="kobo.299.1">, it would be the following:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.300.1">const Component = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.301.1">  const isSmall = useTrackedState().a &lt; 10;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.302.1">  return &lt;&gt;{isSmall ? </span><span class="koboSpan" id="kobo.302.2">'small' : 'big'}&lt;/&gt;;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.303.1">};</span></p>
			<p><span class="koboSpan" id="kobo.304.1">Functionality-wise, this component with </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">useTrackedState</span></strong><span class="koboSpan" id="kobo.306.1"> works fine, but it will trigger re-renders every time </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">state.a</span></strong><span class="koboSpan" id="kobo.308.1"> is changed. </span><span class="koboSpan" id="kobo.308.2">On the contrary, with </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">useSelector</span></strong><span class="koboSpan" id="kobo.310.1">, it will trigger re-renders only when </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">isSmall</span></strong><span class="koboSpan" id="kobo.312.1"> is changed, which means it's better render optimized.</span></p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor090"/><span class="koboSpan" id="kobo.313.1">Using atoms</span></h2>
			<p><span class="koboSpan" id="kobo.314.1">There's another </span><a id="_idIndexMarker247"/><span class="koboSpan" id="kobo.315.1">approach, which we call using atoms. </span><span class="koboSpan" id="kobo.315.2">An atom is a minimal unit of state used to trigger re-renders. </span><span class="koboSpan" id="kobo.315.3">Instead of subscribing to the whole global state and trying to avoid extra re-renders, atoms allow you to subscribe granularly.</span></p>
			<p><span class="koboSpan" id="kobo.316.1">For example, let's suppose we have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">useAtom</span></strong><span class="koboSpan" id="kobo.318.1"> hook that only subscribes to an atom. </span><span class="koboSpan" id="kobo.318.2">An </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">atom</span></strong><span class="koboSpan" id="kobo.320.1"> function would create such a unit (that is, </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">atom</span></strong><span class="koboSpan" id="kobo.322.1">) of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">state</span></strong><span class="koboSpan" id="kobo.324.1"> object:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.325.1">const globalState = {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.326.1">  a: atom(1),</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.327.1">  b: atom(2),</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.328.1">  e: atom(3),</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.329.1">};</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.330.1">const Component = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.331.1">  const value = useAtom(globalState.a);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.332.1">  return &lt;&gt;{value}&lt;/&gt;;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.333.1">};</span></p>
			<p><span class="koboSpan" id="kobo.334.1">If atoms are completely separated, it's almost equivalent to having separate global states. </span><span class="koboSpan" id="kobo.334.2">However, we could create a derived value with atoms. </span><span class="koboSpan" id="kobo.334.3">For example, say we would like to sum the </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">globalState</span></strong><span class="koboSpan" id="kobo.336.1"> values. </span><span class="koboSpan" id="kobo.336.2">The pseudocode would be the following:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.337.1">const sum = globalState.a + globalState.b + globalState.c;</span></p>
			<p><span class="koboSpan" id="kobo.338.1">To make this work, we need to track the dependency and re-evaluate the derived value when a dependency atom is updated. </span><span class="koboSpan" id="kobo.338.2">We will look closely at how such an API is implemented in </span><a href="B17780_08_Final_VK_ePub.xhtml#_idTextAnchor100"><em class="italic"><span class="koboSpan" id="kobo.339.1">Chapter 8</span></em></a><span class="koboSpan" id="kobo.340.1">, </span><em class="italic"><span class="koboSpan" id="kobo.341.1">Use Case Scenario 2 – Jotai</span></em><span class="koboSpan" id="kobo.342.1">.</span></p>
			<p><span class="koboSpan" id="kobo.343.1">The approach using atoms can be seen as something between a manual approach and an automatic approach. </span><span class="koboSpan" id="kobo.343.2">While the definition of atoms and derived values is explicit (manual), the dependency tracking is automatic.</span></p>
			<p><span class="koboSpan" id="kobo.344.1">In this section, we learned about the various patterns for optimizing re-renders. </span><span class="koboSpan" id="kobo.344.2">It's important for a global state library to design how to optimize re-renders. </span><span class="koboSpan" id="kobo.344.3">It often affects the library API, and understanding how to optimize re-renders is also worthwhile for library users.</span></p>
			<h1 id="_idParaDest-91"><a id="_idTextAnchor091"/><span class="koboSpan" id="kobo.345.1">Summary</span></h1>
			<p><span class="koboSpan" id="kobo.346.1">In this chapter, before diving into the actual implementation of global state libraries, we learned about some basic challenges associated with it, and some categories to differentiate global state libraries. </span><span class="koboSpan" id="kobo.346.2">When choosing a global state library, we can see how the library lets us read a global state and write a global state, where the library stores a global state, and how the library optimizes re-renders. </span><span class="koboSpan" id="kobo.346.3">These are important aspects to understand which libraries work well for certain use cases, and they should help you to choose a library that suits your needs.</span></p>
			<p><span class="koboSpan" id="kobo.347.1">In the next chapter, we will learn about the Zustand library, a library that takes a data-centric approach and optimizes re-renders with selector functions.</span></p>
		</div>
	</body></html>