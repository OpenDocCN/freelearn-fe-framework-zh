- en: Chapter 1. Component-Based User Interfaces
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. 基于组件的用户界面
- en: Although we'll cover a lot of Angular-related topics in this book, the focus
    will be mainly on creating component-based user interfaces. It's one thing to
    understand a framework, such as Angular 2, but it's a whole different thing to
    establish an effective workflow using a component-based architecture. In this
    book, I'll try to explain the core concepts behind Angular 2 components and how
    we can leverage this architecture to create modern, efficient, and maintainable
    user interfaces.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在这本书中我们将涵盖许多与Angular相关的主题，但重点将主要放在创建基于组件的用户界面。理解一个框架，比如Angular 2，是一回事，但使用基于组件的架构建立有效的流程则是另一回事。在这本书中，我将尝试解释Angular
    2组件背后的核心概念以及我们如何利用这种架构来创建现代、高效和可维护的用户界面。
- en: Besides learning all the necessary concepts behind Angular 2, we will together
    create a task-management application from scratch. This will allow us to explore
    different approaches to solve common UI problems using the component system that
    is provided by Angular 2.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 除了学习Angular 2背后的所有必要概念，我们还将一起从头创建一个任务管理应用。这将使我们能够探索使用Angular 2提供的组件系统解决常见UI问题的不同方法。
- en: '![Component-Based User Interfaces](img/image00298.jpeg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![基于组件的用户界面](img/image00298.jpeg)'
- en: A preview of the task management application that we are going to build
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建的任务管理应用预览
- en: 'In this chapter, we will take a look at how component-based user interfaces
    help us build greater applications. Over the course of this book, we will build
    an Angular 2 application together, where we will use the component-based approach
    to its full potential. This chapter will also introduce you to the technologies
    that are used in this book. The topics that we will cover in this chapter are
    as follows:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将探讨基于组件的用户界面如何帮助我们构建更强大的应用。在这本书的整个过程中，我们将一起构建一个Angular 2应用，我们将充分利用基于组件的方法。本章还将介绍本书中使用的科技。本章我们将涵盖以下主题：
- en: An introduction to component-based user interfaces
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于组件的用户界面简介
- en: Encapsulation and composition using component-based user interfaces
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基于组件的用户界面进行封装和组合
- en: Evolution of UI frameworks
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI框架的演变
- en: The standard and Web components
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准和Web组件
- en: An introduction to the Angular 2 component system
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 2组件系统的简介
- en: Writing your first Angular 2 component
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写你的第一个Angular 2组件
- en: An overview and history of ECMAScript and TypeScript
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECMAScript和TypeScript的概述和历史
- en: ECMAScript 7 decorators as meta annotations
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECMAScript 7装饰器作为元注释
- en: An introduction to Node.js-based tooling using JSPM and SystemJS
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JSPM和SystemJS的Node.js工具简介
- en: Thinking of organisms
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑有机体
- en: Today's user interfaces do not consist of just a bunch of form elements that
    are cobbled together onto a screen. Modern users experience design and innovative
    visual presentations of interactive content challenges technology more than ever.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的用户界面不仅仅是一堆拼凑到屏幕上的表单元素。现代用户体验设计和创新的内容交互视觉呈现比以往任何时候都更考验技术。
- en: Sadly, we almost always tend to think in pages when we flesh out concepts for
    web applications, such as the pages within a printed book. Well, this is probably
    the most efficient way to convey information for this kind of content and medium.
    You can skim through the pages one by one without any real physical effort, read
    paragraph by paragraph, and just scan through the chapters that you don't find
    interesting.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，当我们为Web应用构思概念时，我们几乎总是倾向于按页面来思考，比如印刷书籍中的页面。嗯，这可能是传达此类内容和媒介信息最有效的方式。你可以逐页浏览，无需任何真正的体力劳动，逐段阅读，只需扫描那些你不感兴趣的部分。
- en: The problem with thinking in pages too much is that this concept, which is borrowed
    from books, does not really translate well to how things work in the real world.
    The world is created from organisms that form a system of organisms together.
    This system itself forms an organism again, just on a higher level.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 过度思考页面的问题在于，这个从书籍中借用的概念并没有很好地转化为现实世界中的运作方式。世界是由形成有机体系统的有机体创造的。这个系统本身又形成了一个有机体，只是在更高的层面上。
- en: Take our bodies as an example. We mostly consist of independent organs that
    interact with each other using electrical and chemical signals. Organs themselves
    consist of proteins that on their own work like a machine to form a system. Down
    to the molecules, atoms, protons, and quarks, we can't really tell where one starts
    and where it ends. What we can tell for sure is that it's all about systems of
    organisms with interdependencies, and it is not about pages.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以我们的身体为例。我们主要由独立的器官组成，这些器官通过电信号和化学信号相互交互。器官本身由蛋白质组成，这些蛋白质本身就像一台机器一样工作，形成一个系统。从分子、原子、质子和夸克来看，我们实际上无法真正判断哪里开始，哪里结束。我们可以肯定的是，这全部都是关于具有相互依赖性的生物系统，而不是关于页面。
- en: I like to view user interfaces as systems of organisms. Whether if, where, and
    how they are distributed to pages is subordinate while designing them. Also, they
    should work independently, and they should interact with each other on an interdependent
    level.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢将用户界面视为生物系统。在它们被分配到页面、在哪里以及如何分配时，这些都是次要的。此外，它们应该能够独立工作，并且应该在相互依赖的水平上相互交互。
- en: Components – The organs of user interfaces
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件 – 用户界面的器官
- en: '|   | *"We''re not designing pages, we''re designing systems of components."*
    |   |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '|   | *"我们不是在设计页面，我们是在设计组件系统。"* |   |'
- en: '|   | --*Stephen Hay* |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '|   | --*Stephen Hay* |'
- en: This quote by Stephen Hay from BDConf in Orlando 2012 brings it to the point.
    Interface design is really not about pages. To create efficient user interfaces
    for not only the users but also the developers who maintain them, we need to think
    in systems of components. Components are independent, but they can interact with
    each other and create larger components when they are arranged together. We need
    to look at user interfaces holistically and using components enables us to do
    this.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这句话来自Stephen Hay在2012年奥兰多的BDConf上的发言，它指出了关键点。界面设计实际上根本不是关于页面。为了为用户以及维护它们的开发者创建高效的用户界面，我们需要从组件系统的角度思考。组件是独立的，但当它们组合在一起时，它们可以相互交互并创建更大的组件。我们需要从整体上看待用户界面，而使用组件使我们能够做到这一点。
- en: In the following topics, we're going to explore a few fundamental aspects of
    components. Some of these are already known from other concepts, such as **object-oriented
    programming** (**OOP**), but they appear in a slightly different light when thinking
    about components.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下主题中，我们将探讨组件的一些基本方面。其中一些已经从其他概念中了解，例如**面向对象编程**（**OOP**），但在考虑组件时，它们呈现出略微不同的光景。
- en: Encapsulation
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 封装
- en: Encapsulation is a very important factor when thinking about maintenance in
    a system. Having a classical OOP background, I've learned that encapsulation means
    bundling logic and data together into an isolated container. This way, we can
    operate on the container from the outside and treat it like a closed system.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 封装在考虑系统维护时是一个非常重要的因素。拥有经典的OOP背景，我了解到封装意味着将逻辑和数据捆绑到一个隔离的容器中。这样，我们可以从外部操作容器，并把它当作一个封闭的系统。
- en: There are many positive aspects of this approach when it comes to maintainability
    and accessibility. Dealing with closed systems is important for the organization
    of our code. However, this is even more importantly because we can organize ourselves
    while working with code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在可维护性和可访问性方面，这种方法有许多积极方面。处理封闭系统对于我们的代码组织很重要。然而，这甚至更为重要，因为我们可以在编写代码的同时组织自己。
- en: '![Encapsulation](img/image00299.jpeg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![封装](img/image00299.jpeg)'
- en: I have a pretty bad memory, and it's very important for me to find the right
    focus level when working on code. Immediate memory research told us that the human
    brain can remember about seven items at once on an average. Therefore, it's crucial
    for us to write code in such a way that it allows us to focus on fewer and smaller
    pieces at once.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我有一个相当差的记忆力，对我来说，在编写代码时找到正确的关注水平非常重要。立即进行的记忆研究告诉我们，人类大脑平均一次可以记住大约七个项目。因此，对我们来说，以这种方式编写代码至关重要，这样我们就可以一次关注更少、更小的部分。
- en: A clear encapsulation helps us in organizing our code. We can maybe forget all
    the internals of the closed system and about the kind of logic and data that we've
    put into it. We can focus only on its surface, which allows us to work on a higher-abstraction
    level. Similar to the previous figure, without using a hierarchy of encapsulated
    components, we'd have all our code cobbled together on the same level.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 清晰的封装帮助我们组织代码。我们可能忘记了封闭系统的所有内部细节以及我们放入其中的逻辑和数据类型。我们可以只关注其表面，这使我们能够在一个更高的抽象级别上工作。类似于前面的图示，如果不使用封装组件的层次结构，我们的所有代码都会在同一级别上拼凑在一起。
- en: Encapsulation encourages us to isolate small and concise components and build
    a system of components. During development, we can focus on the internals of one
    component and only deal with the interface of other components.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 封装鼓励我们将小型且简洁的组件隔离开来，并构建一个组件系统。在开发过程中，我们可以专注于一个组件的内部，而只需处理其他组件的接口。
- en: Sometimes, we forget that all the organization of the coding we actually perform
    is for ourselves and not for the computer that runs this code. If this was for
    the computer, then we would probably all start writing in machine language again.
    A strong encapsulation helps us access specific code easily, focus on one layer
    of the code, and trust the underlying implementations within capsules.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们会忘记我们实际进行的所有代码组织都是为了我们自己，而不是运行这些代码的计算机。如果是为计算机，那么我们可能都会重新开始用机器语言编写。强大的封装帮助我们轻松访问特定代码，专注于代码的一层，并信任胶囊中的底层实现。
- en: 'The following JavaScript example shows you how to use encapsulation to write
    maintainable applications. Let''s assume that we are in a T-shirt factory, and
    we need some code to produce T-shirts with a background and foreground color.
    This example uses some new language features of ECMAScript 6\. If you''re not
    familiar with the language features of ECMAScript 6, don''t worry too much at
    this point. We will learn about these later in this chapter:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下JavaScript示例展示了如何使用封装来编写可维护的应用程序。假设我们在一个T恤工厂，我们需要一些代码来生产带有背景和前景颜色的T恤。此示例使用了ECMAScript
    6的一些新特性。如果你不熟悉ECMAScript 6的语言特性，在这个阶段不必过于担心。我们将在本章后面学习这些内容：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Using a clean encapsulation, we can now work with the abstraction of color in
    our T-shirt. We don't need to worry about how to calculate the hexadecimal representation
    of colors at the T-shirt level because this is already done by the `Colour` class.
    This makes your application maintainable and keeps it very open for change.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用干净的封装，我们现在可以处理T恤中的颜色抽象。我们不需要担心如何在T恤级别计算颜色的十六进制表示，因为这是由`Colour`类完成的。这使得你的应用程序易于维护，并且非常开放，便于更改。
- en: I really recommend that you read about the SOLID principles if you haven't done
    so already. As the name already suggests, this assembly of principles is a solid
    power tool that can change the way you organize code tremendously. You can learn
    more about the SOLID principles in the book, *Agile Principles, Patterns*, *and
    Practices,* by Robert C. Martin.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，我强烈建议您阅读有关SOLID原则的内容。正如其名称所暗示的，这个原则的集合是一个强大的工具，可以极大地改变您组织代码的方式。您可以在罗伯特·C·马丁的《敏捷原则、模式和实践》一书中了解更多关于SOLID原则的内容。
- en: Composability
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可组合性
- en: Composition is a special kind of reusability. You don't extend an existing component,
    but you create a new larger component by composing many smaller components together
    into a system of components.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 组合是一种特殊的可重用性。你不是扩展现有的组件，而是通过将许多较小的组件组合在一起形成一个组件系统，从而创建一个新的更大的组件。
- en: In OOP languages, composition is often used to get around the multiple inheritance
    issues that most OOP languages have. Subclass polymorphism is always great until
    you reach the point where your design does not match the latest requirements in
    your project. Let's look at a simple example that illustrates this problem.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程语言中，组合通常被用来解决大多数面向对象编程语言都存在的多重继承问题。子类多态性一直很好，直到你达到你的设计不再符合项目最新要求的地步。让我们看看一个简单的例子，说明这个问题。
- en: 'You have a `Fisher` class and a `Developer` class, both of which hold specific
    behaviors. Now, you''d want to create a `FishingDeveloper` class that inherits
    both from `Fisher` and `Developer`. Unless you''re using a language that supports
    multiple inheritance (such as C++ does to a certain extent), you will not be able
    to reuse this functionality using inheritance. There is no way to tell the language
    that your new class should inherit from both super classes. Using composition,
    you can easily solve this problem. Instead of using inheritance, you''re composing
    a new `FishingDeveloper` class that delegates all behavior to an internal `Developer`
    and `Fisher` instance:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你有一个`Fisher`类和一个`Developer`类，它们都包含特定的行为。现在，你想要创建一个继承自`Fisher`和`Developer`的`FishingDeveloper`类。除非你使用支持多重继承的语言（例如C++在一定程度上支持），否则你将无法通过继承重用此功能。没有方法告诉语言你的新类应该从这两个超类继承。使用组合，你可以轻松解决这个问题。你不需要使用继承，而是通过组合一个新的`FishingDeveloper`类，将所有行为委托给内部的`Developer`和`Fisher`实例：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Experience has taught us that composition is probably the most efficient way
    to reuse code. In contrast to inheritance, decoration, and other approaches to
    gain reusability, composition is probably the least intrusive and the most flexible.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 经验告诉我们，组合可能是重用代码最有效的方式。与继承、装饰和其他提高可重用性的方法相比，组合可能是最不侵入性和最灵活的。
- en: Recent versions of some languages also support a pattern called traits, that
    is, `mixins`. Traits allow you to reuse certain functionality and attributes from
    other classes in a way that is similar to multiple inheritance.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言的最新版本也支持一种称为特质的模式，即混合（mixins）。特质允许你以类似于多重继承的方式，从其他类中重用某些功能属性。
- en: If we think about the concept of composition, it's nothing more than designing
    organisms. We have the two `Developer` and `Fisher` organisms, and we unify their
    behaviors into a single `FishingDeveloper` organism.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们考虑组合的概念，它不过是设计生物体。我们有`Developer`和`Fisher`这两个生物体，我们将它们的行为统一到一个单一的`FishingDeveloper`生物体中。
- en: Components, invented by nature
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自然创造的组件
- en: Components, embracing encapsulation, and composition are an effective way to
    build maintainable applications. Composed from components, applications are very
    resistant to the negative implications of change, and change is a necessary thing
    that will happen to every application. It's only a matter of time until your design
    will be challenged by the effects of change; therefore, it's very important to
    write code that can handle change as smoothly as possible.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 组件、封装和组合是构建可维护应用程序的有效方式。由组件组成的应用程序对变化的负面影响具有很强的抵抗力，而变化是每个应用程序都会发生的事情。你的设计最终将受到变化效应的挑战，这只是时间问题；因此，编写能够尽可能平滑地处理变化的代码非常重要。
- en: Nature is the best teacher. Almost all the achievements in technological developments
    have their origin in observations of how nature solves problems. If we look at
    evolution, it's an ongoing redesign of matter by adapting to outer forces and
    constraints. Nature solves this by constant change using mutation and natural
    selection.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 自然是最好的老师。几乎所有在技术发展中的成就都源于对自然界如何解决问题的观察。如果我们看看进化，它是对物质不断进行重新设计的过程，通过适应外部力量和约束。自然界通过突变和自然选择不断地进行变化来解决这一问题。
- en: If we project the concept of evolution onto developing an application, we can
    say that nature does actually refactor its code in every single moment. This is
    actually the dream of every product manager—an application that can undergo constant
    change but does not lose any of its efficiency.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将进化的概念投射到开发应用程序上，我们可以说自然界实际上在每一刻都在重构其代码。这是每个产品经理的梦想——一个可以经历持续变化但不会失去任何效率的应用程序。
- en: I believe that there are two key concepts that play a major role in nature that
    allows it to apply constant change in its design without losing much efficiency.
    This uses encapsulation and composition. Coming back to the example of our bodies,
    we can actually tell that our organs use a very clear encapsulation. They use
    membranes to create isolation, veins to transport nutrition, and synapses to send
    messages. Also, they have interdependencies, and they communicate with electrical
    and chemical messages. Most obviously, they form larger systems, which is the
    core concept of composition.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为有两个关键概念在自然界中起着重要作用，使得它能够在设计中不断应用变化而不损失太多效率。这使用了封装和组合。回到我们身体的例子，我们实际上可以告诉我们的器官使用了一种非常清晰的封装。它们使用膜来创建隔离，使用静脉来输送营养，使用突触来发送信息。此外，它们有相互依赖性，并且通过电化学信息进行交流。最明显的是，它们形成了更大的系统，这是组合的核心概念。
- en: Of course, there are many other factors, and I'm not a professor in biology.
    However, I think it's a fascinating thing to see that we have learned to organize
    our code very similarly to how nature organizes matter.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有许多其他因素，我并不是生物学的教授。然而，我认为看到我们学会了以与自然界组织物质非常相似的方式组织我们的代码，这是一件非常有趣的事情。
- en: The idea of creating reusable UI components is quite old, and it was implemented
    in various languages and frameworks. One of the earliest systems that used UI
    components was probably the Xerox Alto system back in 1970s. It used reusable
    UI components that allowed developers to create an application by composing them
    on a screen where users could interact with them.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 创建可重用UI组件的想法相当古老，并且在各种语言和框架中得到了实现。可能使用UI组件的最早系统之一是20世纪70年代的Xerox Alto系统。它使用了可重用的UI组件，允许开发者通过在用户可以与之交互的屏幕上组合它们来创建应用程序。
- en: '![Components, invented by nature](img/image00300.jpeg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![自然界中发明的组件](img/image00300.jpeg)'
- en: The user interface of file manager on the Xerox Alto system from the 1970s.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 20世纪70年代Xerox Alto系统上的文件管理器用户界面。
- en: Early frontend UI frameworks, such as DHTMLX, Ext JS, or jQuery UI implemented
    components in a more limited fashion that didn't provide great flexibility or
    extensibility. Most of these frameworks just provided widget libraries. The problem
    with UI widgets is that they mostly don't embrace the pattern of composition enough.
    You can arrange widgets on a page and they provide encapsulation, but with most
    toolkits, you can't create larger components by nesting them inside each other.
    Some toolkits solve this by providing a special kind of widget which was mostly
    called a container. However, this is not the same as a full-fledged component
    tree that allows you to create systems within systems. Containers were actually
    meant to provide a visual layout container rather than a composite container to
    form a larger system.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 早期的前端UI框架，如DHTMLX、Ext JS或jQuery UI，以更有限的方式实现了组件，这并没有提供很大的灵活性和可扩展性。这些框架中的大多数只是提供了小部件库。UI小部件的问题在于它们大多数没有充分拥抱组合模式。你可以在页面上排列小部件，并且它们提供了封装，但大多数工具包中，你不能通过嵌套来创建更大的组件。一些工具包通过提供一种特殊类型的小部件来解决此问题，这通常被称为容器。然而，这并不等同于一个完整的组件树，它允许你在系统中创建系统。实际上，容器是为了提供一个视觉布局容器，而不是一个复合容器来形成一个更大的系统。
- en: Usually when working with widgets on a page of our application, we'd have a
    large controller that controls all these widgets, user input, and states. However,
    we are left with two levels of composition, and there's no way that we can structure
    our code more granularly. There is the page and there are the widgets. Having
    a bunch of UI widgets is simply not enough, and we are almost back to the state
    where we create pages plastered with form elements.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在我们应用页面上与小部件一起工作时，我们会有一个大控制器来控制所有这些小部件、用户输入和状态。然而，我们只剩下两层组合，我们无法更细致地结构化我们的代码。这里有页面和小部件。拥有大量UI小部件远远不够，我们几乎回到了创建贴满表单元素的页面的状态。
- en: I've been a user of JavaServer Faces for years, and besides all its problems,
    the concept of having reusable custom elements was groundbreaking. Using XHTML,
    one could write so-called composite components that consisted of other composite
    components or native HTML elements. A developer could gain a fantastic level of
    reusability using composition. The big issue in my view with this technology was
    that it did not address the concerns in the frontend enough to become really usable
    for complex user interactions. In fact, a framework like this should live completely
    within the frontend.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经使用 JavaServer Faces 多年了，尽管它存在许多问题，但拥有可重用自定义元素的概念是开创性的。使用 XHTML，可以编写所谓的复合组件，这些组件由其他复合组件或原生
    HTML 元素组成。开发者可以通过组合获得极高的重用性。在我看来，这个技术的最大问题是它没有足够解决前端的问题，以至于无法真正用于复杂的用户交互。实际上，这样的框架应该完全存在于前端。
- en: My UI framework wishlist
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我的 UI 框架愿望清单
- en: 'Usually when UI frameworks get compared, they get measured against each other
    based on metrics, such as widget count, theming capabilities, and asynchronous
    data retrieval features. Every framework has its strengths and weaknesses, but
    leaving all the extra features aside and reducing it to the core concerns of a
    UI framework, I only have a few metrics left that I''d like to be assessed. These
    metrics are, of course, not the only ones that are important in today''s UI development,
    but they also are the main factors toward building a clean architecture that supports
    the principle of change:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在比较 UI 框架时，它们会根据指标相互比较，例如小部件数量、主题功能和异步数据检索功能。每个框架都有其优势和劣势，但抛开所有额外功能，将其简化为
    UI 框架的核心关注点，我只剩下几个想要评估的指标。当然，这些指标并不是今天 UI 开发中唯一重要的指标，但它们也是构建支持变化原则的清晰架构的主要因素：
- en: I can create encapsulated components with clear interfaces
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我可以创建具有清晰界面的封装组件
- en: I can create larger components by composition
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我可以通过组合创建更大的组件
- en: I can make components interact with each other within their hierarchy
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我可以让组件在其层次结构内相互交互
- en: If you're looking for a framework which enables you to take full advantage of
    component-based UI development, you should look for these three key measures.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在寻找一个能够让你充分利用基于组件的 UI 开发的框架，你应该寻找这三个关键指标。
- en: First of all, I think it's very important to understand the main purpose of
    the web and how it evolved. If we think of the web in its early days in the 1990s,
    it was probably only about hypertext. There were very basic semantics that could
    be used to structure information and display them to a user. HTML was created
    to hold structure and information. The need for custom visual presentation of
    information led to the development of CSS right after HTML started being widely
    used.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我认为了解网络的主要目的及其如何演变非常重要。如果我们回想一下 1990 年代的网络早期，它可能只是关于超文本。有一些非常基本的语义可以用来结构化信息并向用户展示。HTML
    的创建是为了持有结构和信息。对信息自定义视觉展示的需求导致了 CSS 在 HTML 开始广泛使用后不久的发展。
- en: 'It was in the mid 1990s when Brendan Eich invented JavaScript, and it was first
    implemented in Netscape Navigator. By providing a way to implement behavior and
    state, JavaScript was the last missing piece for a full web customization:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1990 年代中期，布兰登·艾奇发明了 JavaScript，并在 Netscape Navigator 中首次实现。通过提供实现行为和状态的方式，JavaScript
    成为了全网页定制的最后一块缺失的拼图：
- en: '| Technology | Concern |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 技术 | 关注点 |'
- en: '| --- | --- |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| HTML | Structure and information |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| HTML | 结构和信息 |'
- en: '| CSS | Presentation |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| CSS | 展示 |'
- en: '| JavaScript | Behavior and state |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| JavaScript | 行为和状态 |'
- en: We have learned to keep these concerns as separate as possible in order to maintain
    a clean architecture. Although there are different opinions on this and some recent
    technologies also move away from this principle, I believe that a clean separation
    of these concerns is very important to create a maintainable application.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了尽可能地将这些关注点分开，以保持清晰的架构。尽管对此有不同的看法，并且一些最近的技术也开始偏离这个原则，但我相信，这些关注点的清晰分离对于创建可维护的应用程序非常重要。
- en: Leaving this view aside, the standard definition of encapsulation from OOP is
    just concerned about coupling and isolation of logic and data. This probably applies
    well to classic software components. However, as soon as we consider a user interface
    as part of an architecture, there is a new dimension that is added.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 把这个视图放在一边，面向对象编程中封装的标准定义只是关注逻辑和数据耦合与隔离。这可能很好地适用于经典的软件组件。然而，一旦我们把用户界面视为架构的一部分，就会增加一个新的维度。
- en: Classical MVC frameworks are view centric, and developers organize their code
    based on pages. You'll probably go ahead and create a new view that represents
    a page. Of course, your view needs a controller and model, so you'll also create
    them. The problem with organization by pages is that there's little to no gain
    of reusability. Once you've created a page and you'd like to reuse only some parts
    of the page, you will need a way to encapsulate only a specific part of this model—the
    view and the controller.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的MVC框架以视图为中心，开发者根据页面组织代码。你可能会继续创建一个新的视图来表示一个页面。当然，你的视图需要一个控制器和模型，所以你也会创建它们。按页面组织的问题在于，几乎没有重用性的收益。一旦你创建了一个页面，你只想重用页面的一些部分，你需要一种方法来封装这个模型的具体部分——视图和控制器。
- en: 'UI components solve this problem nicely. I like to see them as a modular approach
    to MVC. Although they still embrace the MVC pattern, they also establish encapsulation
    and composability. This way a view is a component itself, but it also consists
    of components. By composing views of components, one can gain a maximum amount
    of reusability:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: UI组件很好地解决了这个问题。我喜欢把它们看作是MVC的模块化方法。尽管它们仍然采用MVC模式，但它们也建立了封装和可组合性。这样，视图本身就是一个组件，但它也由组件组成。通过组合组件的视图，可以最大限度地提高重用性：
- en: '![My UI framework wishlist](img/image00301.jpeg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![我的UI框架愿望清单](img/image00301.jpeg)'
- en: UI components embrace MVC, but they also support encapsulation and composition
    on a much lower level
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: UI组件采用MVC，但它们也支持在更低的级别上实现封装和组合
- en: Technically, there are some challenges when implementing components with web
    technologies. JavaScript was always flexible enough to implement different patterns
    and paradigms. Working with encapsulation and composition isn't an issue at all,
    and the controlling part and the model of components can easily be implemented.
    Approaches, such as the revealing module pattern, namespaces, prototypes, or the
    recent ECMAScript 6 modules, provide all the tools that are needed from the JavaScript
    side.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，在用Web技术实现组件时有一些挑战。JavaScript始终足够灵活，可以实现不同的模式和范式。与封装和组合一起工作根本不是问题，组件的控制部分和模型可以很容易地实现。例如，揭示模块模式、命名空间、原型或最近的ECMAScript
    6模块等方法，都提供了从JavaScript方面需要的所有工具。
- en: However, for the view part of our components, we face some limitations. Although
    HTML supports great flexibility in terms of composability because the DOM tree
    is nothing else than a big composition, we have no way to reuse these compositions.
    We can only create one large composition, which is the page itself. HTML being
    only the final view that was delivered from the server, this was never really
    a real concern. Today's applications are much more demanding, and we need to have
    a fully-encapsulated component running in the browser, which also consists of
    a partial view.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于我们的组件的视图部分，我们面临一些限制。尽管HTML在可组合性方面支持很大的灵活性，因为DOM树本质上就是一个大组合，但我们无法重用这些组合。我们只能创建一个大的组合，即页面本身。HTML只是从服务器端交付的最终视图，这从来就不是真正的问题。今天的应用程序要求更高，我们需要在浏览器中运行一个完全封装的组件，它也包含部分视图。
- en: We face the same problem with CSS. There is no real modularization and encapsulation
    while writing CSS, and we need to use namespaces and prefixes in order to segregate
    our CSS styles. Still, the whole cascading nature of CSS can easily destroy all
    encapsulation that we try to bring in place using CSS-structuring patterns.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在CSS上也面临同样的问题。在编写CSS时没有真正的模块化和封装，我们需要使用命名空间和前缀来隔离我们的CSS样式。尽管如此，CSS的整个级联性质很容易破坏我们试图通过CSS-structuring模式引入的任何封装。
- en: Time for new standards
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新标准的时机
- en: Web standards have been evolving immensely in the last couple of years. There
    are so many new standards, and the browser became such a big multimedia framework,
    that it's hard for other platforms to compete with this.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，Web标准发生了巨大的演变。有如此多的新标准，浏览器已经成为一个如此大的多媒体框架，以至于其他平台很难与之竞争。
- en: I'd even go as far as to say that web technology will actually replace other
    frameworks in the future, and it probably will be renamed to multimedia technology
    or something similar. There's no reason why we need to use different native frameworks
    to create user interfaces and presentations. Web technologies embed so many features
    that it's hard to find a reason not to use them for any kind of application. Just
    look at the Firefox OS or the Chrome OS, which are designed to run with web technologies.
    I think it's only a matter of time until more operating systems and embedded devices
    make use of web technologies to implement their software. This is why I believe
    that at some point it will be questionable whether the term *web technologies*
    is still appropriate or whether we should replace it with a more general term.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我甚至可以说，Web技术实际上将在未来取代其他框架，并且它可能将被重新命名为多媒体技术或类似的东西。我们没有理由需要使用不同的本地框架来创建用户界面和演示。Web技术集成了许多功能，很难找到不使用它们进行任何类型应用的理由。只需看看Firefox
    OS或Chrome OS，它们都是设计用来使用Web技术运行的。我认为这只是时间问题，直到更多操作系统和嵌入式设备开始利用Web技术来实现它们的软件。这就是为什么我相信在某个时刻，*Web技术*这个术语是否仍然合适，或者我们是否应该用更通用的术语来替代它，将变得可疑。
- en: Although we usually just see new features appear in browsers, there is a very
    open and long-winded standardization process behind them. It's very important
    to standardize features, but this takes a lot of time, especially when people
    disagree about different approaches to solving problems.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们通常只看到浏览器中新功能的出现，但它们背后有一个非常开放且冗长的标准化过程。标准化功能非常重要，但这需要很多时间，尤其是在人们就解决问题的不同方法存在分歧时。
- en: Coming back to the concept of components, this is something where we really
    need support from web standards to break the current limitations. Fortunately,
    the W3C thought the same, and a group of developers started to work on specifications
    under the hood of an umbrella specification called *web components*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 回到组件的概念，这是我们真正需要Web标准支持来突破当前限制的地方。幸运的是，W3C也有同样的想法，一群开发者开始在名为*Web组件*的伞形规范下制定规范。
- en: The following topics will give you a brief overview over two specifications
    that also play a role in Angular 2 components. One of Angular 2's core strengths
    is that it acts more like a superset of web standards rather than being a complete
    isolated framework.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下主题将为您简要概述两个在Angular 2组件中也扮演角色的规范。Angular 2的核心优势之一是它更像是一个Web标准的超集，而不是一个完全独立的框架。
- en: Template elements
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模板元素
- en: Template elements allow you to define regions within your HTML, which will not
    be rendered by the browser. You can then instantiate these document fragments
    with JavaScript and then place the resulting DOM within your document.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 模板元素允许你在HTML中定义区域，这些区域不会被浏览器渲染。然后你可以使用JavaScript实例化这些文档片段，并将生成的DOM放置到你的文档中。
- en: 'While the browser is actually parsing the template content, it only does so
    in order to validate the HTML. Any immediate actions that the parser would usually
    execute will not be taken. Within the content of template elements, images will
    not be loaded and scripts won''t be executed. Only after a template is instantiated,
    the parser will take the necessary actions, as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器实际上正在解析模板内容时，它只是为了验证HTML。解析器通常执行的所有即时操作都不会被执行。在模板元素的内容中，图片不会加载，脚本也不会执行。只有当模板被实例化后，解析器才会采取必要的行动，如下所示：
- en: '[PRE2]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This simple HTML example of a template element won''t display the heading on
    your page. As the heading is inside a template element, we first need to instantiate
    the template and add the resulting DOM into our document:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的HTML模板元素示例不会在你的页面上显示标题。因为标题位于模板元素中，我们首先需要实例化模板，然后将生成的DOM添加到我们的文档中：
- en: '[PRE3]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using these three lines of JavaScript, we can instantiate the template and append
    it into our document.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这三行JavaScript代码，我们可以实例化模板并将其附加到我们的文档中。
- en: Shadow DOM
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 影子DOM
- en: This part of the web components specification was the missing piece to create
    proper DOM encapsulation and composition. With shadow DOM, we can create isolated
    parts of the DOM that are protected against regular DOM operations from the outside.
    Also, CSS will not reach into shadow DOM automatically, and we can create local
    CSS within our component.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分Web组件规范是创建适当的DOM封装和组合所缺失的部分。有了影子DOM，我们可以创建受保护的DOM独立部分，防止外部常规DOM操作。此外，CSS不会自动进入影子DOM，我们可以在组件内部创建局部CSS。
- en: Tip
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you add a `style` tag inside shadow DOM, the styles are scoped to the root
    within the shadow DOM, and they will not leak outside. This enables a very strong
    encapsulation for CSS.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将一个`style`标签添加到阴影DOM内部，这些样式将仅限于阴影DOM的根元素，并且它们不会泄露到外部。这为CSS提供了一种非常强大的封装。
- en: Content insertion points make it easy to control content from the outside of
    a shadow DOM component, and it provides some kind of an interface to pass in content.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 内容插入点使得从阴影DOM组件的外部控制内容变得容易，并且它提供了一种接口来传递内容。
- en: At the time of writing this book, shadow DOM is supported by most browsers although
    it still needs to be enabled in Firefox.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写这本书的时候，大多数浏览器都支持阴影DOM，尽管在Firefox中仍然需要启用它。
- en: Angular's component architecture
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular的组件架构
- en: For me, the concept of directives from the first version of Angular changed
    the game in frontend UI frameworks. This was the first time that I felt that there
    was a simple yet powerful concept that allowed the creation of reusable UI components.
    Directives could communicate with DOM events or messaging services. They allowed
    you to follow the principle of composition, and you could nest directives and
    create larger directives that solely consisted of smaller directives arranged
    together. Actually, directives were a very nice implementation of components for
    the browser.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，Angular第一个版本的指令概念改变了前端UI框架的游戏规则。这是我第一次感觉到有一个简单而强大的概念，允许创建可重用的UI组件。指令可以与DOM事件或消息服务进行通信。它们允许你遵循组合原则，你可以嵌套指令并创建仅由较小指令组合在一起的大指令。实际上，指令是浏览器中组件的一个非常好的实现。
- en: In this section, we'll look into the component-based architecture of Angular
    2 and how the things we've learned about components will fit into Angular.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨Angular 2的基于组件的架构以及我们关于组件所学的知识如何适应Angular。
- en: Everything is a component
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一切都是组件
- en: As an early adopter of Angular 2 and while talking to other people about it,
    I got frequently asked what the biggest difference is to the first version. My
    answer to this question was always the same. Everything is a component.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Angular 2的早期采用者，在与其他人讨论它的时候，我经常被问及与第一个版本最大的区别是什么。我对这个问题的回答总是相同的。一切都是组件。
- en: '![Everything is a component](img/image00302.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![一切都是组件](img/image00302.jpeg)'
- en: For me, this paradigm shift was the most relevant change that both simplified
    and enriched the framework. Of course, there are a lot of other changes with Angular
    2\. However, as an advocate of component-based user interfaces, I've found that
    this change is the most interesting one. Of course, this change also came with
    a lot of architectural changes.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，这种范式转变是简化并丰富了框架的最相关变化。当然，Angular 2还带来了许多其他变化。然而，作为一个基于组件的用户界面倡导者，我发现这个变化是最有趣的一个。当然，这个变化也伴随着许多架构上的变化。
- en: Angular 2 supports the idea of looking at the user interface holistically and
    supporting composition with components. However, the biggest difference to its
    first version is that now your pages are no longer global views, but they are
    simply components that are assembled from other components. If you've been following
    this chapter, you'll notice that this is exactly what a holistic approach to user
    interfaces demands. No more pages but systems of components.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2支持从整体上查看用户界面的想法，并支持组件的组合。然而，与它的第一个版本相比，最大的区别是现在你的页面不再是全局视图，而是由其他组件组装的简单组件。如果你一直在跟随这一章节，你会注意到这正是整体用户界面方法所要求的。不再有页面，而是组件系统。
- en: Tip
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Angular 2 still uses the concept of directives, although directives are now
    really what the name suggests. They are orders for the browser to attach a given
    behavior to an element. Components are a special kind of directives that come
    with a view.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2仍然使用指令的概念，尽管现在的指令确实如其名称所暗示的那样。它们是浏览器将特定行为附加到元素上的命令。组件是一种特殊的指令，它带有视图。
- en: Your first component
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您的第一个组件
- en: 'Keeping up the tradition, before we start building a real application together,
    we should write our first `hello world` component with Angular:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 沿袭传统，在我们开始一起构建真实的应用程序之前，我们应该使用Angular编写我们的第一个`hello world`组件：
- en: '[PRE4]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is already a fully-working Angular 2 application. We used ECMAScript 6
    classes to create the necessary encapsulation required for a component. You can
    also see a meta-annotation that is used to declaratively configure our component.
    This statement, which looks like a function call that is prefixed with an *at*
    symbol actually comes from the ECMAScript 7 decorator proposal.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经是一个完全工作的Angular 2应用程序了。我们使用了ECMAScript 6类来创建组件所需的封装。你还可以看到一个用于声明性配置我们的组件的元注解。这个看起来像是一个以*at*符号为前缀的函数调用的语句，实际上来自ECMAScript
    7装饰器提案。
- en: Note
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: ECMAScript 7 decorators are still very experimental at the time of writing this
    book. For the code in this book, we actually use the TypeScript transpiler version
    1.5 that already implements decorators with a slight twist to the original specification.
    TypeScript 1.5 is also used by the Angular 2 team to develop the core of Angular.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 到本书写作时，ECMAScript 7装饰器仍然非常实验性。对于本书中的代码，我们实际上使用了TypeScript编译器版本1.5，它已经实现了装饰器，与原始规范略有不同。TypeScript
    1.5也被Angular 2团队用于开发Angular的核心。
- en: It's important to understand that an element can only be bound to one single
    component. As a component always comes with a view, there is no way that we can
    bind more than one component to an element. On the other hand, an element can
    be bound to many directives, as directives don't come with a view but they only
    attach behavior.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，一个元素只能绑定到一个单一组件。因为组件总是带有视图，所以我们无法将多个组件绑定到一个元素上。另一方面，一个元素可以绑定到多个指令，因为指令不带有视图，它们只附加行为。
- en: In the `Component` decorator, we need to configure everything that is relevant
    to describe our component for Angular. This, of course, also includes our template
    for the view. In the preceding example, we are specifying our template directly
    within JavaScript as a string. We can also use the `templateUrl` property to specify
    a URL where the template should be loaded from.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Component`装饰器中，我们需要配置所有与描述我们的组件相关的信息，以便于Angular。这当然也包括我们的视图模板。在前面的例子中，我们直接在JavaScript中以字符串的形式指定我们的模板。我们也可以使用`templateUrl`属性来指定模板应该从哪个URL加载。
- en: 'Now, let''s enhance our example a little bit so that we can see how we can
    compose our application from smaller components:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们稍微增强我们的例子，以便我们可以看到我们如何从更小的组件中组合我们的应用程序：
- en: '[PRE5]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can see that we have now created a small component that allows us to shout
    out words as we like. In our *Hello World* application, we make use of this component
    to shout out **Hello, World!**
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我们现在已经创建了一个小组件，允许我们像我们喜欢的那样大声喊出词语。在我们的*Hello World*应用程序中，我们利用这个组件来大声喊出**Hello,
    World**！
- en: Tip
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Every directive or component that is used inside a components view template
    needs to be explicitly declared in the directives property of the view annotation.
    Otherwise, the compiler will not recognize the directive when it encounters the
    element in the template.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件视图模板内部使用的每个指令或组件都必须在视图注解的指令属性中显式声明。否则，编译器在遇到模板中的元素时将无法识别指令。
- en: Over the course of this book and while writing our task management application,
    we will learn a lot more about the configuration and implementation of components.
    However, before we start with this in the second chapter, we should take a look
    at some tools and language features that we'll use during this book.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书的整个过程中，以及我们在编写任务管理应用程序时，我们将学习更多关于组件的配置和实现。然而，在我们开始第二章之前，我们应该看看一些我们在这本书中会使用的工具和语言特性。
- en: JavaScript of the future
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 未来JavaScript
- en: It was not so long ago that somebody asked me whether we should really use the
    bind function of ECMAScript 5.1, as then we'd probably run into browser compatibility
    issues. The web moves very fast, and we need to keep up the pace. We can't write
    code that does not use the latest features even if this would cause issues in
    old browsers.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 不久前，有人问我我们是否真的应该使用ECMAScript 5.1的bind函数，因为这样我们可能会遇到浏览器兼容性问题。网络发展非常快，我们需要跟上节奏。我们不能编写不使用最新特性的代码，即使这会在旧浏览器中引起问题。
- en: The fantastic people from TC39, the technical committee that is responsible
    for writing the ECMAScript specification, have done a great job progressively
    enhancing the JavaScript language. This, and the fact that JavaScript is so flexible,
    allows us to use so-called polyfills and shims to make our code run in older browsers.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 来自TC39的技术委员会的杰出人士，该委员会负责编写ECMAScript规范，他们已经出色地逐步增强了JavaScript语言。这一点，加上JavaScript的灵活性，使我们能够使用所谓的polyfills和shims来使我们的代码在旧浏览器上运行。
- en: ECMAScript 6 (also referred to as ECMAScript 2015) was published in June 2015,
    exactly four years after its predecessor. There is a massive amount of new API
    additions as well as a whole bunch of new language features. The language features
    are syntactic sugar, and ECMAScript 6 can be transpiled to its previous version
    where it runs perfectly in older browsers. At the time of writing this book, none
    of the current browser versions have fully implemented ECMAScript 6, but there's
    absolutely no reason not to use it for production applications.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 6（也称为ECMAScript 2015）于2015年6月发布，正好是其前身之后的四年。新增了大量的API以及许多新的语言特性。这些语言特性是语法糖，ECMAScript
    6可以被转换为其前一个版本，在旧浏览器上运行得很好。在撰写本书时，当前没有任何浏览器版本完全实现了ECMAScript 6，但完全没有理由不将其用于生产应用。
- en: Tip
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Syntactic sugar is a design approach where we evolve a programming language
    while not breaking backwards compatibility. This allows language designers to
    come up with new syntax, which enriches developer experience but does not break
    the web. Every new feature needs to be translatable to the old syntax. This way,
    so-called transpilers can be used to convert code to older versions.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 语法糖是一种设计方法，我们在不破坏向后兼容性的同时演进编程语言。这允许语言设计者提出新的语法，这丰富了开发者的体验，但不会破坏网络。每个新特性都需要转换成旧语法。这样，所谓的转换器就可以用来将代码转换为旧版本。
- en: I speak JavaScript, translate, please!
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我说的是JavaScript，请翻译！
- en: While compilers compile from a higher-level language to a lower-level language,
    a transpiler or transcompiler acts more like a converter. It is a source-to-source
    compiler that translates code to run in a different interpreter.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器将高级语言编译为低级语言时，转换器或转换编译器更像是一个转换器。它是一种源到源的编译器，可以将代码转换为在另一个解释器中运行。
- en: Recently, there's a real battle among new languages that are transpiled to JavaScript
    and can run in the browser. I used Google Dart for quite some time, and I must
    admit, I really loved the language features. The problem with nonstandardized
    languages is that they depend heavily on community adoption and the hype. Also,
    it's almost certain that they will never run natively within the browser. This
    is also the reason why I prefer standard JavaScript, and the JavaScript of the
    future uses transpilers that allow me to do this.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，在将新语言转换为JavaScript并能在浏览器中运行的新语言之间，确实存在一场真正的战斗。我使用Google Dart有一段时间了，我必须承认，我真的很喜欢这门语言的特点。非标准化语言的问题在于它们严重依赖于社区采用和炒作。此外，它们几乎肯定永远不会在浏览器中本地运行。这也是我为什么更喜欢标准JavaScript，以及未来的JavaScript使用转换器，这使我能够做到这一点。
- en: Some people argue that transpilers introduce code that does not run very performant
    and, therefore, recommend that you do not use ECMAScript 6 and transpilers at
    all. I don't agree with this because of many reasons. Usually, this is about performance
    in micro or even nanosecond areas where this often really does not matter for
    most applications.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人认为转换器引入的代码运行性能不佳，因此建议不要使用ECMAScript 6和转换器。我不赞同这一点，因为有很多原因。通常，这关乎微秒甚至纳秒级别的性能，而这对于大多数应用程序通常并不重要。
- en: I don't say performance doesn't matter, but performance needs to always be discussed
    within a context. If you're trying to optimize a loop within your application
    by reducing processing time from 10 microseconds to five microseconds where you'd
    never iterate over more than 100 items, then you're probably spending your time
    on the wrong things.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不是说性能不重要，但性能需要在一定的背景下进行讨论。如果你试图通过将处理时间从10微秒减少到五微秒来优化应用程序中的循环，而你永远不会迭代超过100个项目，那么你很可能是在做错事情。
- en: Also, a very important fact is that transpiled code is designed by people who
    understand micro performance optimization much better than I do, and I'm sure
    their code runs faster than mine. On top of this, a transpiler is probably also
    the right place where you'd want to do performance optimization because this code
    is automatically generated and you don't lose maintainability of your code through
    performance quirks.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，一个非常重要的是事实是，被转换的代码是由那些比我更了解微性能优化的人设计的，我确信他们的代码运行得比我快。除此之外，转换器可能也是你想要进行性能优化的正确地方，因为这段代码是自动生成的，你不会因为性能问题而失去代码的可维护性。
- en: I'd like to quote Donald Knuth here and say that premature optimization is the
    root of all evil. I really recommend that you read his paper on this topic (Donald
    Knuth, December 1974, *Structured Programming with go to Statements*). Just because
    the `goto` statements got banished from all modern programming languages, it doesn't
    mean this is less of a good read.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我想在这里引用唐纳德·克努特的话，并说过早优化是万恶之源。我真心推荐你阅读他关于这个主题的论文（唐纳德·克努特，1974年12月，*使用goto语句的结构化编程*）。仅仅因为goto语句被从所有现代编程语言中禁止，并不意味着这就不值得一读。
- en: Later on in this chapter, you'll learn about tools that help you use transpilers
    easily within your project, and we'll take a look at the decisions and directions
    Angular went with their source code.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，你将了解到一些工具，它们可以帮助你轻松地在项目中使用转换器，我们还将看看Angular在源代码中做出的决策和方向。
- en: Let's look at a few language features that come with ECMAScript 6 and make our
    life much easier.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看ECMAScript 6带来的一些语言特性，它们让我们的生活变得更加容易。
- en: Classes
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类
- en: Classes were among one the most requested features in JavaScript, and I was
    one of the people voting for it. Well, coming from an OOP background and being
    used to organizing everything within classes, it was hard for me to let go. Although,
    after working with modern JavaScript for some time, you'll reduce their use to
    the bare minimum and to exactly what they are made for—inheritance.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 类是JavaScript中最受欢迎的特性之一，我也是投票支持它的人之一。嗯，作为一个有面向对象编程背景的人，并且习惯于在类中组织一切，对我来说很难放手。然而，在一段时间使用现代JavaScript之后，你会将它们的使用减少到最低限度，并且只用于它们本应发挥的作用——继承。
- en: 'Classes in ECMAScript 6 provide you with syntactic sugar to deal with prototypes,
    constructor functions, super calls, and object property definitions in a way that
    you have the illusion that JavaScript could be a class-based OOP language:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 6中的类为你提供了处理原型、构造函数、super调用和对象属性定义的语法糖，让你产生一种错觉，认为JavaScript可以是一个基于类的面向对象编程语言：
- en: '[PRE6]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As we learned in the previous topic about transpilers, ECMAScript 6 can be
    de-sugared to ECMAScript 5\. Let''s take a look at what a transpiler would produce
    from this simple example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在关于转换器的上一个主题中学到的，ECMAScript 6可以被转换为ECMAScript 5。让我们看看一个转换器会从这个简单的例子中产生什么：
- en: '[PRE7]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This simple example can easily be built using ECMAScript 5\. However, once we
    use the more complex features of class-based object-oriented languages, the de-sugaring
    gets quite complicated.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的例子可以很容易地使用ECMAScript 5构建。然而，一旦我们使用基于类的面向对象语言的更复杂特性，去糖化过程就变得相当复杂了。
- en: ECMAScript 6 classes introduce simplified syntax to write class member functions
    (static functions), the use of the super keyword, and inheritance using the `extends`
    keyword.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 6类引入了简化的语法来编写类成员函数（静态函数）、使用super关键字，以及使用extends关键字进行继承。
- en: If you would like to read more about the features in classes and ECMAScript
    6, I highly recommend that you read the articles of Dr. Axel Rauschmayer ([http://www.2ality.com/](http://www.2ality.com/)).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要了解更多关于类和ECMAScript 6中的特性，我强烈推荐你阅读Axel Rauschmayer博士的文章（[http://www.2ality.com/](http://www.2ality.com/))。
- en: Modules
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块
- en: Modules provide a way to encapsulate your code and create privacy. In object-oriented
    languages, we usually use classes for this. However, I actually believe this is
    an antipattern rather than a good practice. Classes should be used where inheritance
    is desired and not just to structure your code.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 模块提供了一种封装你的代码并创建隐私的方法。在面向对象的语言中，我们通常使用类来做这件事。然而，我实际上认为这更像是一个反模式，而不是一个好的实践。类应该用于需要继承的地方，而不仅仅是用来结构化你的代码。
- en: I'm sure that you've encountered a lot of different module patterns in JavaScript
    already. One of the most popular ones that creates privacy using a function closure
    of an **immediately invoked function expression** (**IIFE**) is probably the revealing
    module pattern. If you'd like to read more about this and may be other great patterns,
    I recommend the book, *Learning JavaScript Design Patterns,* by Addy Osmani.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你已经遇到了很多不同的JavaScript模块模式。其中最流行的一种，通过使用**立即执行函数表达式**（**IIFE**）的函数闭包来创建隐私，可能是揭示模块模式。如果你想了解更多关于这个以及其他一些优秀的模式，我推荐阅读Addy
    Osmani所著的《Learning JavaScript Design Patterns》这本书。
- en: Within ECMAScript 6, we can now use modules to serve this purpose. We simply
    create one file per module, and then we use the import and export keywords to
    connect our modules together.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在ECMAScript 6中，我们现在可以使用模块来达到这个目的。我们只需为每个模块创建一个文件，然后使用import和export关键字将我们的模块连接起来。
- en: 'Within the ECMAScript 6 module specification, we can actually export as many
    things as we like from each module. We can then import these named exports from
    any other module. We can have one default export per module, which is especially
    easy to import. Default exports don''t need to be named, and we don''t need to
    know their name when importing them:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在ECMAScript 6模块规范中，我们实际上可以从每个模块中导出我们喜欢的东西。然后我们可以从任何其他模块中导入这些命名的导出。每个模块可以有一个默认导出，这特别容易导入。默认导出不需要命名，导入时也不需要知道它们的名称：
- en: '[PRE8]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There are many combinations on how to use modules. We will discover some of
    these together while working on our task management application during the upcoming
    chapters. If you'd like to see more examples on how to use modules, I can recommend
    the Mozilla Developer Network documentation ([https://developer.mozilla.org](https://developer.mozilla.org))
    on the `import` and `export` keywords.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多种使用模块的组合方式。在我们接下来的章节中，通过构建我们的任务管理应用，我们将一起发现其中的一些。如果你想看到更多关于如何使用模块的例子，我可以推荐Mozilla开发者网络上的文档（[https://developer.mozilla.org](https://developer.mozilla.org)）关于`import`和`export`关键字。
- en: Template strings
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模板字符串
- en: 'Template strings are a very simple, but they are an extremely useful addition
    to the JavaScript syntax. They serve three main purposes:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 模板字符串非常简单，但它们是JavaScript语法的极其有用的补充。它们有三个主要用途：
- en: Writing multiline strings
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写多行字符串
- en: String interpolation
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串插值
- en: Tagged template strings
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签模板字符串
- en: 'Before template strings, it was quite verbose to write multiline strings. You
    needed to concatenate pieces of strings and append a new-line character yourself
    to the line endings:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板字符串之前，编写多行字符串相当冗长。你需要自己拼接字符串片段并添加换行符到行尾：
- en: '[PRE9]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Using template strings, we can simplify this example a lot. We can write multiline
    strings, and we can also use the string interpolation functionality for our title
    variable that we used to concatenate earlier:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模板字符串，我们可以大大简化这个例子。我们可以编写多行字符串，也可以使用我们之前用来连接的字符串插值功能来为我们的标题变量编写：
- en: '[PRE10]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note the back ticks instead of the previous single quotes. Template strings
    are always written between back ticks, and the parser will interpret all characters
    in between them as part of the resulting string. This way, the new-line characters
    present in our source file will also be part of the string automatically.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用反引号而不是之前的单引号。模板字符串总是写在反引号之间，解析器会将它们之间的所有字符解释为结果字符串的一部分。这样，我们源文件中存在的换行符也会自动成为字符串的一部分。
- en: You can also see that we have used the dollar sign, followed by curly brackets
    to interpolate our strings. This allows us to write arbitrary JavaScript within
    strings and helps a lot while constructing HTML template strings.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以看到我们使用了美元符号，后面跟着花括号来插值我们的字符串。这允许我们在字符串中写入任意JavaScript代码，这在构建HTML模板字符串时非常有帮助。
- en: You can read more about template strings on the Mozilla Developer Network.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Mozilla开发者网络上了解更多关于模板字符串的信息。
- en: ECMAScript or TypeScript?
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ECMAScript或TypeScript？
- en: TypeScript was created in 2012 by Anders Hejlsberg with the intention to implement
    the future standard of ECMAScript 6 but also to provide a superset of syntax and
    features that was not part of the specification.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript是由Anders Hejlsberg于2012年创建的，旨在实现ECMAScript 6的未来标准，同时也提供了一个包含但不限于语法和特性的超集。
- en: 'There are many features in TypeScript as a superset to the ECMAScript 6 standard,
    including, but not limited to the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript作为ECMAScript 6标准的超集，有很多特性，包括但不限于以下内容：
- en: Optional static typing with type annotations
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的静态类型与类型注解
- en: Interfaces
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口
- en: Enum types
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举类型
- en: Generics
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型
- en: It's important to understand that all of the features that TypeScript provides
    as a superset are optional. You can write pure ECMAScript 6 and not take advantage
    of the additional features that TypeScript provides. The TypeScript compiler will
    still transcompile pure ECMAScript 6 code to ECMAScript 5 without any errors.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解 TypeScript 提供的所有作为超集的功能都是可选的。你可以编写纯 ECMAScript 6 代码，而不必利用 TypeScript
    提供的附加功能。TypeScript 编译器仍然会将纯 ECMAScript 6 代码无错误地转换为 ECMAScript 5。
- en: Note
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Most of the features that are seen in TypeScript are actually already present
    in other languages, such as Java and C#. One goal of TypeScript was to provide
    language features that support workflows and better maintainability for large-scale
    applications.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 中看到的大多数功能实际上在其他语言中已经存在，例如 Java 和 C#。TypeScript 的一个目标是为大型应用程序提供支持工作流程和更好的可维护性的语言功能。
- en: The problem with any nonstandard language is that nobody can tell how long the
    language will be maintained and how fast the momentum of the language will be
    in the future. In terms of support, the chances are high that TypeScript, with
    its sponsor Microsoft, will actually have a long life. However, there's still
    no guarantee that the momentum and trend of the language will keep moving at a
    reasonable pace. This problem does obviously not exist for standard ECMAScript
    6 because it's what the web of the future is made of and what browsers will speak
    natively.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 任何非标准语言的问题在于，没有人能说清楚这种语言将维持多久，未来的语言势头会多快。就支持而言，TypeScript，凭借其赞助商微软，实际上可能会拥有很长的一生。然而，仍然没有保证语言的势头和趋势将以合理的速度持续发展。显然，对于标准
    ECMAScript 6 来说，这个问题并不存在，因为它是未来网络的基础，也是浏览器将原生支持的语言。
- en: 'Still, there are valid reasons to use the extended features of TypeScript if
    you''d want to address the following concerns that clearly outweigh the negative
    implications of an uncertain future in your project:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，如果你想要解决以下明显超过项目未来不确定性的负面影响的担忧，使用 TypeScript 的扩展功能是有合理理由的：
- en: Large applications that undergo a huge amount of changes and refactoring
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经历了大量更改和重构的大型应用程序
- en: Large teams that require a strict governance while working on code
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编写代码时需要严格治理的大型团队
- en: In this book, we'll use a TypeScript compiler, but we will work with standard
    ECMAScript 6 code with one exception that is covered in the next topic about decorators.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将使用 TypeScript 编译器，但我们将使用标准 ECMAScript 6 代码，除了下一节关于装饰器的主题中提到的例外。
- en: Decorators
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 装饰器
- en: Decorators are not part of the ECMAScript 6 specification, but they were proposed
    to the ECMAScript 7 standard for 2016\. They provide us with a way to decorate
    classes and properties during design time. This allows a developer to use meta-annotations
    while writing classes, and declaratively attach functionality to the class and
    its properties.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器不是 ECMAScript 6 规范的一部分，但它们被提议纳入 2016 年的 ECMAScript 7 标准。它们为我们提供了一种在设计时装饰类和属性的方法。这允许开发者在使用类时使用元注解，并声明性地将功能附加到类及其属性上。
- en: 'Decorators are named after the decorator pattern that was initially described
    in the book *Design Patterns: Elements of Reusable Object-Oriented Software* of
    Erich Gamma and his colleagues, also known as the **Gang of Four** (**GoF**).'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器是以最初在 Erich Gamma 和他的同事（也称为“四人帮”**GoF**）的书中描述的装饰器模式命名的，即《设计模式：可复用面向对象软件元素》。
- en: The principle of decoration is that an existing procedure is intercepted and
    the decorator has the chance to either delegate, provide an alternative procedure,
    or do a mix from both.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰的原则是拦截现有的过程，装饰器有机会委托、提供替代过程，或者从两者中混合。
- en: '![Decorators](img/image00303.jpeg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![装饰器](img/image00303.jpeg)'
- en: Visualization of decoration in a dynamic environment with the example of a simple
    access procedure
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 使用简单访问过程的示例在动态环境中可视化装饰
- en: Decorators in ECMAScript 7 can be used to annotate classes and class properties.
    Note that this also includes class methods, as class methods are also properties
    of the class prototype object. Decorators get defined as regular functions, and
    they can be attached to classes or class properties with the *at* symbol. Our
    decorator function will then be called with contextual information about the location
    of inclusion every time that the decorator is placed.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 7 中的装饰器可以用来注解类和类属性。请注意，这也包括类方法，因为类方法也是类原型对象的属性。装饰器被定义为常规函数，并且可以用
    *at* 符号附加到类或类属性上。每次放置装饰器时，我们的装饰器函数将使用包含包含位置上下文信息作为第一个参数调用。我们的装饰器函数将使用上下文信息关于包含位置每次放置装饰器时被调用。
- en: 'Let''s take a look at a simple example that illustrates the use of a decorator:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的例子，它说明了装饰器的使用：
- en: '[PRE11]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We have created a `logAccess` decorator that will log all function calls that
    are tagged with the decorator. If we look at the `MoneySafe` class, you can see
    that we have decorated the `openSafe` method with our `logAccess` decorator.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个 `logAccess` 装饰器，它将记录所有带有装饰器的函数调用。如果我们查看 `MoneySafe` 类，我们可以看到我们已经用我们的
    `logAccess` 装饰器装饰了 `openSafe` 方法。
- en: The `logAccess` decorator function will be executed for each annotated property
    within our code. This enables us to intercept the property definition of the given
    property. Let's take a look at the signature of our decorator function. Decorator
    functions that are placed on class properties will be called with the target object
    of the property definition as a first parameter. The second parameter is the actual
    property name that is defined, followed by the last parameter, which is the descriptor
    object that is supposed to be applied to the object.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`logAccess` 装饰器函数将为我们的代码中每个注解属性执行。这使我们能够拦截给定属性的属性定义。让我们看看我们的装饰器函数的签名。放置在类属性上的装饰器函数将使用属性定义的目标对象作为第一个参数调用。第二个参数是实际定义的属性名称，然后是最后一个参数，即应该应用于对象的描述符对象。'
- en: The decorator gives us the opportunity to intercept the property definition.
    In our case, we use this ability to exchange the descriptor value (which is the
    annotated function) with a proxy function that will log the function call before
    calling the origin function (delegation). For simplification purposes, we've implemented
    a very simple yet incomplete function proxy. For real-world scenarios, it would
    be advisable to use a better proxy implementation, such as the ECMAScript 6 proxy
    object.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器为我们提供了拦截属性定义的机会。在我们的例子中，我们使用这种能力来交换描述符值（即注解函数）与一个代理函数，该代理函数在调用原始函数之前记录函数调用（委托）。为了简化起见，我们实现了一个非常简单但又不完整的函数代理。对于现实世界的场景，建议使用更好的代理实现，例如
    ECMAScript 6 代理对象。
- en: Decorators are a great feature to leverage aspect-oriented concepts and declaratively
    add behavior to our code at design time.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器是利用面向方面概念并声明式地在设计时向我们的代码添加行为的强大功能。
- en: 'Let''s look at a second example where we use an alternative way to declare
    and use decorators. We can treat decorators like function expressions where our
    decorator function is rewritten as a factory function. This form of usage is especially
    useful when you need to pass along configuration to the decorator, which is made
    available in the decorator factory function:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看第二个例子，我们将使用一种不同的方式来声明和使用装饰器。我们可以将装饰器视为函数表达式，其中我们的装饰器函数被重写为一个工厂函数。这种使用形式在需要将配置传递给装饰器时特别有用，装饰器工厂函数提供了这种配置：
- en: '[PRE12]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We have now learned how ECMAScript 7 decorators can help you to write declarative
    code that has an aspect-oriented twist to it. This simplifies development a lot
    because we can now think of behavior that we add to our classes during design
    time when we actually think about the class as a whole and write the initial stub
    of the class.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经学会了如何使用 ECMAScript 7 装饰器来帮助我们编写具有面向方面特性的声明式代码。这大大简化了开发过程，因为我们现在可以在设计时考虑添加到我们类中的行为，当我们实际上将类作为一个整体来思考并编写类的初始框架时。
- en: 'Decorators in TypeScript are slightly different than the decorators from ECMAScript
    7\. They are not limited to classes and class properties, but they can also be
    placed on parameters within the class methods. This allows you to annotate function
    parameters, which can be useful in some cases:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 中的装饰器与 ECMAScript 7 中的装饰器略有不同。它们不仅限于类和类属性，还可以放置在类方法内的参数上。这允许你注解函数参数，这在某些情况下可能很有用：
- en: '[PRE13]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Angular uses this feature to simplify dependency injection on class constructors.
    As all directive, component, and service classes get instantiated from Angular
    dependency injection and not by us directly, these annotations help Angular find
    the correct dependencies. For this use-case, function parameter decorators actually
    make a lot of sense.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Angular使用这个特性来简化类构造函数上的依赖注入。由于所有指令、组件和服务类都是由Angular依赖注入而不是直接由我们实例化，这些注解帮助Angular找到正确的依赖。对于这个用例，函数参数装饰器实际上非常有意义。
- en: Note
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Currently, there are still issues with the implementation of decorators on class
    method parameters, which is also why ECMAScript 7 does not support it. As this
    feature is crucial to build an Angular 2 application, we'll use the TypeScript
    compiler to transpile the code of our application. This is the only TypeScript-specific
    feature that we'll use in this book.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，类方法参数上装饰器的实现仍然存在问题，这也是为什么ECMAScript 7不支持它的原因。由于这个特性对于构建Angular 2应用程序至关重要，我们将使用TypeScript编译器来转译我们应用程序的代码。这是我们在这本书中将使用的唯一TypeScript特定功能。
- en: Tools
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具
- en: In order to make use of all these future technologies, we need some tools to
    support us. We were already talking about ECMAScript 6 and decorators, where we
    actually prefer TypeScript decorators, as they support the function parameter
    decorators that are used by Angular 2\. Although the ECMAScript 6 syntax supports
    modules, we still need some sort of a module loader that will actually load the
    required modules in the browser or help us generate an executable bundle.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用所有这些未来的技术，我们需要一些工具来支持我们。我们之前已经讨论了ECMAScript 6和装饰器，实际上我们更倾向于使用TypeScript装饰器，因为它们支持Angular
    2使用的函数参数装饰器。尽管ECMAScript 6语法支持模块，我们仍然需要一个模块加载器来实际加载浏览器中所需的模块或帮助我们生成可执行包。
- en: Node.js and NPM
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Node.js和NPM
- en: Node.js is JavaScript on steroids. Initially, a fork of the V8 JavaScript engine
    from the Google Chrome browser, Node.js was extended with more functionality,
    specifically to make JavaScript useful on the server-side. File handling, streams,
    system APIs, and a huge ecosystem of user-generated packages are just some of
    the facts that make this technology an outstanding partner for your web development.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js是增强版的JavaScript。最初，Node.js是Google Chrome浏览器中V8 JavaScript引擎的一个分支，它被扩展了更多的功能，特别是为了使JavaScript在服务器端有用。文件处理、流、系统API以及庞大的用户生成包生态系统只是使这项技术成为您网络开发杰出伙伴的一些事实。
- en: The node package manager, NPM, is a door to over 200,000 packages and libraries
    that help you build your own application or library. The Node.js philosophy is
    very similar to the UNIX philosophy, where packages should stay small and sharp,
    but they should use composition to achieve greater goals.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 节点包管理器NPM是通往超过200,000个包和库的大门，这些包和库可以帮助您构建自己的应用程序或库。Node.js的哲学与UNIX哲学非常相似，即包应该保持小巧而锋利，但它们应该使用组合来实现更高的目标。
- en: To build our application, we will rely on Node.js as the host for the tools
    that we're going to use. We should, therefore, make sure that we install Node.js
    on our machine so that we are prepared for the next chapter, where we start to
    craft our task management application.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建我们的应用程序，我们将依赖Node.js作为我们将要使用的工具的主机。因此，我们应该确保在我们的机器上安装Node.js，以便为下一章做准备，在那里我们将开始构建我们的任务管理应用程序。
- en: Note
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can get Node.js from their website at [https://nodejs.org](https://nodejs.org),
    and it should be a breeze to install this on any kind of operating system by following
    the instructions on their website.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从他们的网站[https://nodejs.org](https://nodejs.org)获取Node.js，并且按照他们网站上的说明安装应该非常简单。
- en: 'Once you''ve installed Node.js, we can perform a simple test to check whether
    everything is up and running. Open a terminal console and execute the following
    command:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了Node.js，我们可以执行一个简单的测试来检查一切是否正常运行。打开终端控制台并执行以下命令：
- en: '[PRE14]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: SystemJS and JSPM
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SystemJS和JSPM
- en: There are many module formats and module loaders out there, but there's one
    that rules them all in my opinion. SystemJS is built on top of an ES6 module loader
    polyfill and, therefore, moves very close to an upcoming standard. I strongly
    believe in standardization and, therefore, prefer SystemJS over other module loaders,
    such as RequireJS, Browserify, or webpack. We should stop using libraries where
    possible and rely on polyfills that make our browser capable of running the code
    of the future.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: SystemJS is a universal module loader that is capable of loading many different
    module formats, such as AMD, CommonJS, and ECMAScript 6, and it also supports
    a very flexible shiming mechanism to modularize global JavaScript.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: SystemJS also supports the most popular transpilers, including ECMAScript 6
    and TypeScript. This means that you can actually load ECMAScript 6 code directly
    in your browser, where it's transpiled by SystemJS in runtime. This is great during
    development, especially because you're allowed to load modules from any location,
    including remote HTTP locations, such as GitHub or the NPM repository.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: JSPM
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The JavaScript package manager is not just another package manager for JavaScript.
    This is basically a mediator and manager for SystemJS that helps you look up packages
    from package repositories, such as Bower or NPM, and it creates the necessary
    configuration for SystemJS. JSPM is written in Node.js and does not come with
    its own remote package repository. As SystemJS needs URLs and module mappings
    to know where to load modules from, JSPM is your tool to create this necessary
    configuration and simplify package installation.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with JSPM
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s create a simple application together using JSPM. First of all, we need
    to install two global modules with NPM. Besides JSPM, we''ll also install a tool
    called live-server, which will help us during development by providing an HTTP
    server that serves static files. It also has file change detection built-in, and
    it will reload your browser automatically once a file change has been detected.
    This provides a very short feedback loop and makes development a very fast process:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command on your command line:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Tip
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that on UNIX-like systems, such as Linux or Mac OS X, it's sometimes required
    to run NPM as a super user. It's also recommended that you use the **Node Version
    Manager** (**NVM**) to get around those issues ([https://github.com/creationix/nvm](https://github.com/creationix/nvm)).
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After installing JSPM and the `live-server` package, we can go ahead and create
    our first application using JSPM.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new directory for the application, and open a terminal console within
    this directory.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can now execute the following command on your terminal console to install
    JSPM locally and initialize a new JSPM project:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: JSPM will start a wizard that guides you though the initialization steps. You
    can answer all questions with the default answer (just hit *Enter*) except for
    the question about which transpiler you'd like to use that you should answer with
    TypeScript.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JSPM将启动一个向导，引导您完成初始化步骤。您可以用默认答案（只需按*Enter*键）回答所有问题，除了关于您想使用哪种编译器的问题，您应该回答TypeScript。
- en: 'After JSPM installs all the necessary packages, we can go ahead and create
    our `index.html` file. Navigate to your project folder and create a new file,
    `index.html`, in your favorite editor:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在JSPM安装所有必要的包之后，我们可以继续创建我们的`index.html`文件。导航到您的项目文件夹，并在您最喜欢的编辑器中创建一个新的文件，`index.html`：
- en: '[PRE17]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This very minimalistic HTML is already the foundation for our JSPM Hello World
    application. After including the `SystemJS` library and the `config.js` file that
    was generated by JSPM, we only need to bootstrap our application by telling `SystemJS`
    which file to import.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这非常简约的HTML已经是我们的JSPM Hello World应用程序的基础。在包含`SystemJS`库和由JSPM生成的`config.js`文件之后，我们只需要通过告诉`SystemJS`要导入哪个文件来引导我们的应用程序。
- en: 'Before we create our main application file, we will quickly install jQuery
    as a package, just to demonstrate how easily third-party libraries can be installed
    and used with `SystemJS` and JSPM:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们创建主应用程序文件之前，我们将快速安装jQuery作为包，只是为了演示第三方库如何容易地使用`SystemJS`和JSPM进行安装和使用。
- en: '[PRE18]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After installing jQuery, we can go ahead and create our `main.js` file inside
    of the application folder:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在安装jQuery之后，我们可以在应用程序文件夹内创建我们的`main.js`文件：
- en: '[PRE19]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In order to run this example in the browser, we can now start our live server
    with the following command executed inside of the application folder:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在浏览器中运行此示例，我们现在可以在应用程序文件夹内执行以下命令来启动我们的实时服务器：
- en: '[PRE20]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: After following the preceding steps, you should have a working example with
    ECMAScript 6 and SystemJS using the TypeScript transpiler. Using LiveReload, your
    browser should automatically open and display our Hello World application. You
    can also try now to modify the code a bit and change the sentence that is written
    to the DOM. You'll notice that once you save your changes, the browser will immediately
    reload the page.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在遵循前面的步骤之后，您应该有一个使用ECMAScript 6和SystemJS以及TypeScript编译器的可工作示例。使用LiveReload，您的浏览器应该会自动打开并显示我们的Hello
    World应用程序。您现在也可以尝试稍微修改一下代码，并更改写入DOM的句子。您会注意到，一旦您保存更改，浏览器将立即重新加载页面。
- en: Summary
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at a component-based approach to structure user interfaces,
    and we talked about the necessary aspects of its background to understand why
    we are moving in this direction with the web standard and frameworks, such as
    Angular. We also ensured that we are prepared with all the technology that we
    will use in the upcoming chapters in this book. You created your first simple
    example using JSPM, SystemJS, ECMAScript 6, and the TypeScript transpiler. Now,
    we are ready to start building our task-management system using a component-based
    architecture to its full potential.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了基于组件的方法来构建用户界面，并讨论了其背景的必要方面，以便理解为什么我们要随着网络标准和框架，如Angular，向这个方向发展。我们还确保了我们为本书后续章节中将要使用的所有技术都做好了准备。您使用JSPM、SystemJS、ECMAScript
    6和TypeScript编译器创建了自己的第一个简单示例。现在，我们准备利用组件化架构的潜力来构建我们的任务管理系统。
- en: In the next chapter, we're going to start building our task management application
    using Angular 2 components. We'll look at the initial steps that are required
    to create an Angular 2 application from scratch and flesh out the first few components
    in order to build a task list.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始使用Angular 2组件构建我们的任务管理应用程序。我们将查看从头创建Angular 2应用程序所需的初始步骤，并详细说明前几个组件，以便构建任务列表。
