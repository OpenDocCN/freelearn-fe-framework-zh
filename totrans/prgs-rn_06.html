<html><head></head><body>
		<div id="_idContainer033">
			<h1 id="_idParaDest-90" class="chapter-number"><a id="_idTextAnchor130"/>6</h1>
			<h1 id="_idParaDest-91"><a id="_idTextAnchor131"/>Working with Animations</h1>
			<p>Animations are part of every mobile app. Smooth animations can make the difference between whether a user feels comfortable using an app or not. Essentially, an animation is just the screen rendering again and again, transitioning from one state to another.</p>
			<p>This rendering should happen so quickly that the user doesn’t realize the single states of the animation but perceives it as a smooth animation. To take this one step further, animations not only transform from state A to state B over time, but they also react to user interactions such as scrolling, pressing, or swiping.</p>
			<p>Most devices have a screen frame rate of 60 <strong class="bold">frames per second</strong> (<strong class="bold">fps</strong>), and modern devices already have 120 fps (at the time of writing, React Native only supports 60 fps, which you can learn about on GitHub at <a href="http://bit.ly/prn-rn-fps">bit.ly/prn-rn-fps</a>). This means that when running an animation, the screen has to be re-rendered at 60 fps.</p>
			<p>This is quite challenging because calculating complex animations and re-rendering the screen are some of the most compute-intense operations. Especially on low-end devices, the computing of the animation can become too slow, and the screen refresh rate drops below 60/120 fps. This then makes the animation and the app feel sluggish and slow.</p>
			<p>Essentially, you can group animations into two different types: </p>
			<ul>
				<li><strong class="bold">On-screen animations</strong>: These animations only apply<a id="_idIndexMarker390"/> to a part of the screen. There are a lot of different use cases for this type of animation such as grabbing user attention, giving touch feedback, showing indications of progress or loading, or improving the scrolling experience.</li>
				<li><strong class="bold">Full-screen animations</strong>: These animations transition the <a id="_idIndexMarker391"/>whole screen. Most of the time, this type of animation is used to navigate to another screen.</li>
			</ul>
			<p>Since full-screen animations are handled internally by all popular navigation libraries, this chapter will focus on on-screen animations. Full-screen animations have been covered in the <em class="italic">Navigating in React Native apps</em> section of <a href="B16694_04.xhtml#_idTextAnchor079"><em class="italic">Chapter 4</em></a><em class="italic">, Styling, Storage, and Navigation, Section Navigation</em>.</p>
			<p>There are multiple ways to achieve smooth animations in React Native. Depending on the type of project and animations you want to build, you can choose from a wide range of solutions, each with its own advantages and disadvantages. We will discuss the best and most widely used solutions in this chapter.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Understanding the architectural challenge of animations in React Native</li>
				<li>Using the internal React Native Animated API</li>
				<li>Creating simple animations with <strong class="source-inline">react-native-animatable</strong></li>
				<li>Exploring Reanimated 2 – the most complete animation framework for React Nativ<a id="_idTextAnchor132"/>e<a id="_idTextAnchor133"/></li>
				<li>Using Lottie animations in React Native</li>
			</ul>
			<p class="callout-heading">Info</p>
			<p class="callout">There have been some interesting developments about using the Skia rendering engine (which powers Chrome, Firefox, Android, and Flutter) to render animations in React Native, but at the time of writing, this approach is not production ready.</p>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor134"/>Technical requirements</h1>
			<p>To be able to run the code in this chapter, you have to set up the following things:</p>
			<ul>
				<li>A working React Native environment (<a href="http://bit.ly/prn-setup-rn">bit.ly/prn-setup-rn</a> – React Native CLI Quickstart)</li>
				<li>An iOS/Android simulator or a real device (a real device is preferred)</li>
			</ul>
			<h1 id="_idParaDest-93"><a id="_idTextAnchor135"/>Understanding the architectural challenge of animations in React Native</h1>
			<p>The current architecture<a id="_idIndexMarker392"/> of React Native is suboptimal when it comes to animation<a id="_idTextAnchor136"/>s<a id="_idTextAnchor137"/>. Think of an animation that scales or moves a title image based on the vertical scroll value of a <strong class="source-inline">ScrollView</strong>; this animation has to be calculated based on the scroll value of the <strong class="source-inline">ScrollView</strong> and immediately re-render the image. The following diagram shows what would happen when using the plain React Native architecture:</p>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="image/B16694_06_01.jpg" alt="Figure 6.1 – The React Native architecture while animating based on scroll values&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – The React Native architecture while animating based on scroll values</p>
			<p>Here, you can see the general React<a id="_idIndexMarker393"/> Native architecture. The JavaScript thread is where you write your code. Every command will be serialized and sent via the bridge to the native thread. In this thread, the command is deserialized and executed. The same happens with the user input, but it occurs the other way around.</p>
			<p>For our animation, this means that the scroll value would have to be serialized, sent via the bridge, deserialized, transferred via a complex calculation to an animation value, serialized, transferred back via the bridge, deserialized, and then rendered. This whole process has to be done every 16 milliseconds (or 60 times a second).</p>
			<p>This round-trip leads to multiple problems:</p>
			<ul>
				<li>The serialization/deserialization process consumes unnecessary compute power</li>
				<li>In most cases, the calculation in JavaScript is slower than in native code</li>
				<li>The calculation can block the JavaScript thread and make the app unresponsive</li>
				<li>The round-trip can lead to frame drops and make the animation look sluggish and slow</li>
			</ul>
			<p>Because of these problems, it is not a good idea to write animations in your own plain React Native code (for example, by setting a state in a loop). Fortunately, there are multiple production-ready solutions to avoid these problems and achieve high-quality animations.</p>
			<p>In the following sections, we will have<a id="_idIndexMarker394"/> a look at four different solutions. Every solution has advantages and disadvantages, and which solution should be preferred depends on the project and the use case. Let’s start with the built-in Animated A<a id="_idTextAnchor138"/>P<a id="_idTextAnchor139"/>I.</p>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor140"/>Using the internal Animated API of React Native</h1>
			<p>React Native comes<a id="_idIndexMarker395"/> with a built-in Animated API. This API is quite powerful, and you can achieve a lot of different animation goals with it. In this section, we will have a brief look at how it works and what advantages and limitations the internal Animated API has. </p>
			<p>For a complete tutorial, please have a look at the official documentatio<a id="_idTextAnchor141"/>n<a id="_idTextAnchor142"/> at <a href="http://bit.ly/prn-animated-api">bit.ly/prn-animated-api</a>.</p>
			<p>To understand how the Animated API works, let’s start with a simple example.</p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor143"/>Starting with a simple example</h2>
			<p>The following code implements<a id="_idIndexMarker396"/> a simple fade-in animation, which makes a view appear over the duration of 2 sec<a id="_idTextAnchor144"/>o<a id="_idTextAnchor145"/>n<a id="_idTextAnchor146"/>ds:</p>
			<pre class="source-code">
import React, { useRef } from "react";
import { Animated, View, Button } from "react-native";
const App = () =&gt; {
  <a id="_idTextAnchor147"/>c<a id="_idTextAnchor148"/>o<a id="_idTextAnchor149"/>n<a id="_idTextAnchor150"/>s<a id="_idTextAnchor151"/>t opacityValue = useRef(new Animated.Value(0)).
      current;
  <a id="_idTextAnchor152"/>c<a id="_idTextAnchor153"/>onst showView = () =&gt; {
    Animated.timing(opacityValue, {
        toValue: 1,
        duration: 2000
        }).start();
    };
  return (
    &lt;&gt;
      &lt;Animated.View
        style={{
          backgroundColor: 'red',
              opacity: opacityValue
        }}
       /&gt;
      &lt;Button title="Show View" onPress={showView} /&gt;
    &lt;/&gt;
  );
}
export default App;</pre>
			<p>The Animated API<a id="_idIndexMarker397"/> is based on animated values. These values are changed over time and are used as part of the application styling. In this example, we init<a id="_idTextAnchor154"/>i<a id="_idTextAnchor155"/>alize <strong class="source-inline">opacityValue</strong> as an <strong class="source-inline">Animated.Value</strong> component with the initial value of <strong class="source-inline">0</strong>.</p>
			<p>As you can see, the JSX code contains an <strong class="source-inline">Animated.View</strong> component whose style uses <strong class="source-inline">opacityValue</strong> as the opacity property. When running this code, the <strong class="source-inline">Animated.View</strong> component is completely hidden at the beginning; this is because the opacity is set to <strong class="source-inline">0</strong>. When pressing the <strong class="bold">Show View</strong> button, <strong class="source-inline">showView</strong> is called, which starts an <strong class="source-inline">Animated.timing</strong> function.</p>
			<p>This <strong class="source-inline">Animated.timing</strong> function expects an <strong class="source-inline">Animated.Value</strong> component as the first property and a config object as the second parameter. The <strong class="source-inline">Animated.Value</strong> component is the value that should be changed during the animation. With the config object, you can define the general conditions of the animation.</p>
			<p>In this example, we want to change the <strong class="source-inline">Animated.Value</strong> component to 1 over the duration of 2 seconds (2,000 ms). Then, the <strong class="source-inline">Animated.timing</strong> function calculates the different states of the animation and takes care of the rendering of the <strong class="source-inline">Animated.View</strong> component. </p>
			<p class="callout-heading">Good to know</p>
			<p class="callout">Essentially, you can animate every part of your UI. The Animated API exports some components directly, such as <strong class="source-inline">Animated.View</strong>, <strong class="source-inline">Animated.Image</strong>, <strong class="source-inline">Animated.ScrollView</strong>, <strong class="source-inline">Animated.Text</strong>, and <strong class="source-inline">Animated.FlatList</strong>. But you can animate any component by using <strong class="source-inline">Animated.createAnimatedComponent()</strong>.</p>
			<p>While the Animated API does not completely solve the problem of the React Native architecture, it is an improvement over just setting the state again and again and again, as it greatly reduces the payload that has to be transferred from the JavaScript thread to the native thread, but this transfer has to be done every frame. To prevent this transfer in every frame, you have<a id="_idIndexMarker398"/> to use the native driver, as shown in the following subs<a id="_idTextAnchor156"/>e<a id="_idTextAnchor157"/>ction.</p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor158"/>Using the native driver</h2>
			<p>When configuring the animation<a id="_idIndexMarker399"/> with the config object, you can set a property called <strong class="source-inline">useNativeDriver</strong>. This is very important and should be done whenever possible. </p>
			<p>When using the native driver with <strong class="source-inline">useNativeDriver: true</strong>, React Native sends everything to the native thread before starting the animation. This means that the animation runs completely on the native thread, which guarantees a smooth-running animation and no frame drops.</p>
			<p>Unfortunately, the native driver is currently limited to non-layout properties. So, things such as transform and opacity can be used in an animation with the native driver, whereas all the Flexbox and position properties, such as <strong class="source-inline">height</strong>, <strong class="source-inline">width</strong>, <strong class="source-inline">top</strong>, or <strong class="source-inline">left</strong>, can’t <a id="_idTextAnchor159"/>b<a id="_idTextAnchor160"/>e used.</p>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor161"/>Interpolate animated values</h2>
			<p>In some cases, you don’t want<a id="_idIndexMarker400"/> to use the <strong class="source-inline">Animated.Value</strong> component directly. This is where interpolation comes into play. Interpolation is a simple mapping of input and output ranges. In the following code example, you can see an interpolation, which adds a position change to the simple example from before:</p>
			<pre class="source-code">
style={{
    <a id="_idTextAnchor162"/>opacity: opacit<a id="_idTextAnchor163"/>yVa<a id="_idTextAnchor164"/>lue,
    transform: [{
      translateY: opacityValue.interpolate({
        inputRange: [0, 1],
        outputRange: [50, 0]
      }),
    }],
  }}</pre>
			<p>In this code example, we added a transform <strong class="source-inline">translateY</strong> property to the <strong class="source-inline">style</strong> object. This property transforms the vertical position of an object. We don’t set a fixed value, nor do we bind <strong class="source-inline">opacityValue</strong> directly.</p>
			<p>We use an interpolate function with a defined <strong class="source-inline">inputRange</strong> value of <strong class="source-inline">[0,1]</strong> and a defined <strong class="source-inline">outputRange</strong> value of <strong class="source-inline">[50,0]</strong>. Essentially, this means that the <strong class="source-inline">translateY</strong> value will be <strong class="source-inline">50</strong> when <strong class="source-inline">opacityValue</strong> (which is our <strong class="source-inline">AnimatedValue</strong>) is <strong class="source-inline">0</strong> and will be <strong class="source-inline">0</strong> when <strong class="source-inline">opacityValue</strong> is <strong class="source-inline">1</strong>. This results in our <strong class="source-inline">AnimatedView</strong> moving up <strong class="source-inline">50px</strong> to its original position while fading in.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Try to use interpolation to reduce the number of animated values you have to use in your application. Most of the time, you can use one animated value and just interpolate on it, even in complex animations.</p>
			<p>The Animated API interpolate function<a id="_idIndexMarker401"/> is quite powerful. You can have multiple values to define the range, extrapolate or clamp beyond the ranges, or specify the easing function of the animation. </p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor165"/>Getting to know the advanced options of the Animated API</h2>
			<p>The Animated API brings<a id="_idIndexMarker402"/> a lot of different options, which give you the possibility to create almost every animation you can imagine: </p>
			<ul>
				<li>You can do mathematical operations on animated values such as <strong class="source-inline">add()</strong>, <strong class="source-inline">subtract()</strong>, <strong class="source-inline">divide()</strong>, <strong class="source-inline">multiply()</strong>, <strong class="source-inline">modulo()</strong>, and more.</li>
				<li>You can combine animations sequentially using <strong class="source-inline">Animated.sequence()</strong>, or combine them at the same time using <strong class="source-inline">Animated.parallel()</strong> (you can even combine these options, too).</li>
				<li>You can also work with delayed animations with <strong class="source-inline">Animated.delay()</strong> or loop animations with <strong class="source-inline">Animated.loop()</strong>.</li>
				<li>There are also other options to change an <strong class="source-inline">Animated.Value</strong> component aside from <strong class="source-inline">Animated.timing()</strong>. One of them is to use <strong class="source-inline">Animated.event()</strong> to bind the scroll value of a <strong class="source-inline">ScrollView</strong> to an <strong class="source-inline">AnimatedValue</strong>. </li>
			</ul>
			<p>The following example is very similar<a id="_idIndexMarker403"/> to the example in the <em class="italic">Understanding the architectural challenge of animations in React Native</em> section of this chapter. The code shows you how to use a scroll value as the driver of an animation:</p>
			<pre class="source-code">
const A<a id="_idTextAnchor166"/>pp <a id="_idTextAnchor167"/>= () =&gt; {
  const scrolling = useRef(new Animated.Value(<a id="_idTextAnchor168"/>0<a id="_idTextAnchor169"/>)).current;
  const interpolatedScale = scrolling.interpolate({
    inputRange: [-300, 0],
    outputRange: [3, 1],
    extrapolate: 'clamp',
  });
  const interpolatedTranslate<a id="_idTextAnchor170"/> <a id="_idTextAnchor171"/>= scrolling.interpolate({
    inputRange: [0, 300],
    outputRange: [0, -300],
    extrapolate: 'clamp',
  });
  return (
    &lt;&gt;
      &lt;Animated.Image 
        source={require('sometitleimage.jpg')}
        style={{
          ...styles.header,
          transform: [
            {translateY: interpolatedTranslate}, 
            {scaleY: interpolatedScale}, 
            {scaleX: interpolatedScale}
          ]
        }} 
      /&gt;
      &lt;Animated.ScrollView
        onScroll={
          An<a id="_idTextAnchor172"/>i<a id="_idTextAnchor173"/>mated.event([{n<a id="_idTextAnchor174"/>a<a id="_idTextAnchor175"/>tiveEvent: {contentOffset: {y: 
              scrolling,},},}],
              { useNativeDriver: true },
          )
    <a id="_idTextAnchor176"/>    }
      &gt;
        &lt;View style={styles.headerPlaceholder} /&gt;
        &lt;View style={styles.content}&gt;
        &lt;/View&gt; 
      &lt;/Animated.ScrollView&gt;
    &lt;/&gt;  
  );
}</pre>
			<p>In this example, the native<a id="_idIndexMarker404"/> scroll event of the <strong class="source-inline">ScrollView</strong> is connected directly to the <strong class="source-inline">Animated.Value</strong> component. With the <strong class="source-inline">useNativeDriver: true</strong> property, the native driver is used; this means that the animation, which is driven by the scroll value, runs completely on the native thread.</p>
			<p>The preceding example contains two interpolations of the scroll value: the first one scales the image when the <strong class="source-inline">ScrollView</strong> has been over-scrolled (which means the <strong class="source-inline">ScrollView</strong> returns negative scroll values), while the second one moves the image up while scrolling.</p>
			<p>Again, due to the use of the native driver, all this interpolation is done on the native thread. This makes the Animated API very performant in this use case. You can read more about running animations based on user gestures in <a href="B16694_07.xhtml#_idTextAnchor236"><em class="italic">Chapter 7</em></a><em class="italic">, Handling Gestures in React Native</em>.</p>
			<p>The Animated API also provides different easing methods alongside complex spring models. For more detailed information, please take a look at the official documentation at <a href="http://bit.ly/prn-animated-api">bit.ly/prn-animated-api</a>.</p>
			<p>As you can see, the Animated API <a id="_idIndexMarker405"/>is really powerful, and you can achieve nearly every animation goal with it. So, why are there even other solutions on the market when this very good animation library is built in? Well, the Animated API is far from perfect for every use case. </p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor177"/>Understanding the pros and cons of the Animated API</h2>
			<p>The internal React Native<a id="_idIndexMarker406"/> Animated API is a very good solution for simple to mid-complexity animations. These are the most important pros of the Animated API:</p>
			<ul>
				<li><strong class="bold">Powerful API</strong>: You can build nearly every animation.</li>
				<li><strong class="bold">No external library needed</strong>: You don’t have to add any dependencies to your project to use the Animated API. This means no additional maintenance effort or larger bundle size.</li>
				<li><strong class="bold">Smooth animations with the native driver</strong>: When using the native driver, you can be sure that your animation runs at 60 fps.</li>
			</ul>
			<p>There are also some cons<a id="_idIndexMarker407"/> of the Animated API, which you have to keep in mind when choosing the best animation solution for your project: </p>
			<ul>
				<li><strong class="bold">Complex animations become quite confusing</strong>: Due to the structure of the Animated API, animations with lots of elements or very high complexity can get very confusing, and the code can become very hard to read and understand.</li>
				<li><strong class="bold">The native driver does not support all style properties</strong>: When using the Animated API, you should definitely use the native driver. Since this driver does not support position or Flexbox properties, the Animated API is, essentially, limited to non-layout properties.</li>
				<li><strong class="bold">Animated.Value only supports numeric and string values</strong>: It is not possible to work with objects or arrays as animation values. If the animation value is more<a id="_idIndexMarker408"/> complex, multiple <strong class="source-inline">Animated.Value</strong> components have to be used.</li>
			</ul>
			<p>All in all, I would recommend the Animated API for small to medium complexity animations, when you don’t already have other animation libraries in your project. However, let’s look at another option: <strong class="source-inline">react-n<a id="_idTextAnchor178"/>a<a id="_idTextAnchor179"/>tive-animatable</strong>.</p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor180"/>Creating simple animations with react-native-animatable</h1>
			<p>There are a lot of animations<a id="_idIndexMarker409"/> that are reused in nearly<a id="_idIndexMarker410"/> every app. This is what <strong class="source-inline">react-native-animatable</strong> is all about. This library is built on top of the internal React Native Animated API and provides a very simple declarative and imperative API to use simple, predefined animations.</p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor181"/>Starting with a simple example</h2>
			<p>The following code example describes<a id="_idIndexMarker411"/> a simple fade-in animation with <strong class="source-inline">react-native-animatable</strong> using the declarative method, along with a simple fade-out animation with <strong class="source-inline">react-native-animatable</strong> using th<a id="_idTextAnchor182"/>e<a id="_idTextAnchor183"/> imperative method:</p>
			<pre class="source-code">
import React from "react";
import { View, Text, Pressable } from "react-native";
import * as Animatable from 'react-native-animatable';
const App = () =&gt; {
  const handleRef = ref =&gt; this.view = ref;
  const hideView = () =&gt; {
    this.view.fadeOutDown(2000);
  }
  return (
    &lt;&gt;
      &lt;Animatable.View
        style={{
          backgroundColor: 'red'
        }}
        ref={handleRef}
        animation="fadeInUp"
        d<a id="_idTextAnchor184"/>u<a id="_idTextAnchor185"/>ration=2000
      /&gt;
      &lt;Pressable onPress={hideView}&gt;
        &lt;Text&gt;Hide View&lt;/Text&gt;
      &lt;/Pressable&gt;
    &lt;/&gt;
  );
}
export default App;</pre>
			<p>In this example, <strong class="source-inline">Animatable.View</strong> is given one of the predefined <strong class="source-inline">Animatable</strong> animations as the animation property, and a duration that defines how long the animation runs. That is all you have to do to have an entrance animation.</p>
			<p>As stated before, Animatable also supports imperative usage, which means that you can call Animatable functions on Animatable components. In this example, <strong class="source-inline">this.view</strong> contains a reference to <strong class="source-inline">Animatable.View</strong>, which makes it possible to call Animatable functions on it.</p>
			<p>This is done<a id="_idIndexMarker412"/> when pressing the <strong class="source-inline">Pressable</strong>. Here, <strong class="source-inline">hideView</strong> is called, which then calls the predefined <strong class="source-inline">fadeOutDown</strong> Animatable function, which makes the view disappear over 2 seconds (2,000 ms). </p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor186"/>Using the native driver</h2>
			<p>As we learned in the <em class="italic">Using the internal Animated API of React Native</em> section, using the native driver is crucial<a id="_idIndexMarker413"/> for achieving smooth animations. Since <strong class="source-inline">react-native-animatable</strong> is based on the Animated API, you should also configure your animations to use the native driver.</p>
			<p>With <strong class="source-inline">react-native-animatable</strong>, this is done by adding <strong class="source-inline">useNativeDriver={true}</strong> as a property to the component you run the animation on. </p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Please check whether the predefined animation you want to use supports the native driver before using it with the native driver. </p>
			<p>The <strong class="source-inline">react-native-animatable</strong> library is not limited to predefined animations. It also supports defining custom animations with a very simple API. Let’s take a look at how this is done.</p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor187"/>Working with custom animations</h2>
			<p>The following example<a id="_idIndexMarker414"/> shows you how to create a simple fade-in and move-up animation, just as we did in the previous section:</p>
			<pre class="source-code">
const fadeInUpCustom = {
  0:<a id="_idTextAnchor188"/> {
    opacity: 0,
    translateY: 50,
  },
  1: {
    opacity: 1,
    translateY: 0,
  },
};</pre>
			<p>The custom animations of <strong class="source-inline">react-native-animatable</strong> map the styles to the keyframes. In this example, we start with the first keyframe (<strong class="source-inline">0</strong>), and set the <strong class="source-inline">opacity</strong> value to <strong class="source-inline">0</strong> and the <strong class="source-inline">translateY</strong> value to <strong class="source-inline">50</strong>. With the last keyframe (<strong class="source-inline">1</strong>), the <strong class="source-inline">opacity</strong> value should be <strong class="source-inline">1</strong> and the <strong class="source-inline">translateY</strong> value should be <strong class="source-inline">0</strong>. Now this animation can be used<a id="_idIndexMarker415"/> as the animation property value of any Animatable component instead of the predefined string values. </p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor189"/>Understanding the pros and cons of react-native-animatable</h2>
			<p>Built on the React Native Animated API, all pros<a id="_idIndexMarker416"/> and cons of the Animated API also apply to <strong class="source-inline">react-native-animatable</strong>. In addition to that, the following pros are worth mentioning:</p>
			<ul>
				<li><strong class="bold">Very easy to use</strong>: <strong class="source-inline">react-native-animatable</strong> is by far the easiest library to create and use high-quality animations.</li>
				<li><strong class="bold">Declarative approach</strong>: The declarative approach creates code that is easy to read and understand.</li>
			</ul>
			<p>Since <strong class="source-inline">react-native-animatable</strong> is a library built on top of the Animated API, this additional layer<a id="_idIndexMarker417"/> also brings some cons:</p>
			<ul>
				<li><strong class="bold">Additional dependency</strong>: You have to add <strong class="source-inline">react-native-animatable</strong> as an additional dependency to your project. This is especially important because, at the time of writing, the project wasn’t maintained very actively. This means that if anything changes in the underlying Animated API, it can prevent you from upgrading your React Native project. </li>
				<li><strong class="bold">Limited API</strong>: The predefined animations and the possibilities to create custom animations are limited. If you want<a id="_idIndexMarker418"/> to create complex animations, you should use another option.</li>
			</ul>
			<p>Essentially, <strong class="source-inline">react-native-animatable</strong> is a simple library on top of the React Native Animated API. It simplifies working with animations and works best with simple, predefined animations. If you need these simple or standard animations and you are very limited in time to create your animations, <strong class="source-inline">react-native-animatable</strong> is the best option for you.</p>
			<p>If you’d like to create more complex animations<a id="_idTextAnchor190"/>,<a id="_idTextAnchor191"/> please take a loo<a id="_idTextAnchor192"/>k<a id="_idTextAnchor193"/> at the following section.</p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor194"/>Exploring Reanimated 2 – the most complete animation solution for React Native</h1>
			<p>Reanimated is by far the most<a id="_idIndexMarker419"/> complete and mature animation solution for React Native. It was an improved reimplementation of the React Native Animated API in the first place, but with ve<a id="_idTextAnchor195"/>r<a id="_idTextAnchor196"/>sion 2, the API changed and the library’s capabilities increased greatly.</p>
			<p>This section covers the following topics: </p>
			<ul>
				<li>Getting to know the Reanimat<a id="_idTextAnchor197"/>e<a id="_idTextAnchor198"/>d API with a simple example</li>
				<li>Understanding the <a id="_idTextAnchor199"/>a<a id="_idTextAnchor200"/>rchitecture of Reanimated 2</li>
				<li>Understanding the pros and cons of Reanimated</li>
			</ul>
			<p>Let’s get started.</p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor201"/>Getting to know the Reanimated API with a simple example</h2>
			<p>Essentially, the core concept<a id="_idIndexMarker420"/> of Reanimated 2 is as simple as the Animated API. There are animation values that can be changed, and these animation values power the animations. </p>
			<p>The following code shows an animation tha<a id="_idTextAnchor202"/>t<a id="_idTextAnchor203"/> scales in a <strong class="source-inline">View</strong> component:</p>
			<pre class="source-code">
import React<a id="_idTextAnchor204"/> <a id="_idTextAnchor205"/>from "react";
import { Text, Pressable } from "react-native";
import Animated, { useSharedValue, useAnimatedStyle, 
    Easing, withTiming } from 'react-native-reanimated';
<a id="_idTextAnchor206"/>c<a id="_idTextAnchor207"/>onst A<a id="_idTextAnchor208"/>p<a id="_idTextAnchor209"/>p = () =&gt; {
    const size = useSharedValue(0);
    const showView = () =&gt; {
      size.value = withTiming(100, {
        duration: 2000,
        easing: Easing.out(Easing.exp),
      });
  }
    const animatedStyles = useAnimatedStyle(() =&gt; {
      return {
        width: size.value,
        height: size.value,
        backgroundColor: 'red'
      };
  });
  return (
    &lt;&gt;
      &lt;Animated.View style={animatedStyles} /&gt;
      &lt;Pressable onPress={showView}&gt;
        &lt;Text&gt;Show View&lt;/Text&gt;
      &lt;/Pressable&gt;
    &lt;/&gt;
  );
}</pre>
			<p>When looking at this code, we realize three things:</p>
			<ul>
				<li>The structure is quite similar to the Animated API. There is a <strong class="source-inline">sharedValue</strong>, which is <strong class="source-inline">Animated.Value</strong> in <strong class="source-inline">Animated</strong>, and a <strong class="source-inline">withTiming</strong> function, which is the equivalent to <strong class="source-inline">Animated.timing</strong> in <strong class="source-inline">Animated</strong>. The style object for the <strong class="source-inline">Animated.View</strong> component is created using a <strong class="source-inline">useAnimatedStyle</strong> function and is then used as a style property. </li>
				<li>There is no <strong class="source-inline">useNativeDriver</strong> property.</li>
				<li>We are changing width and height values in the animation, so the layout properties get changed, which wasn’t possible with the React Native internal Animated API. </li>
			</ul>
			<p>One of the cool things about Reanimated<a id="_idIndexMarker421"/> is that you don’t have to care about the native driver. Every animation with Reanimated is processed on the UI thread. Another cool thing is that every style property can be used.</p>
			<p>If you compare this to the limitations of the Animated API, you immediately see how much more powerful<a id="_idIndexMarker422"/> Reanimated is. </p>
			<p>To understand how this is done, let’s take a look at the Reanimated architecture.</p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor210"/>Understanding the architecture of Reanimated 2</h2>
			<p>Reanimated 2 is based on animation<a id="_idIndexMarker423"/> worklets. In this context, a <strong class="bold">worklet</strong> is a JavaScript function that runs<a id="_idIndexMarker424"/> on the UI thread. Reanimated 2 spawns a second, very minimalistic, JavaScript environment on the UI thread that handles these animation worklets.</p>
			<p>This means it runs completely independently from the React Native JavaScript thread and the React Native bridge, which guarantees awesome performance even for complex animations. This worklet context uses the new React Native architecture.</p>
			<p>Let’s start with gaining an unde<a id="_idTextAnchor211"/>r<a id="_idTextAnchor212"/>standing of how to use worklets.</p>
			<h3>Starting to work with worklets</h3>
			<p>Let’s take a look<a id="_idIndexMarker425"/> at the example from<a id="_idIndexMarker426"/> the <em class="italic">Understanding the architectural challenge of animations in React Native</em> section of this chapter. We have an animation that resizes or moves a title image based on the <em class="italic">Y</em> scroll value of a <strong class="source-inline">ScrollView</strong>. The following figure shows what’s happening when implementing this example with Reanimated 2:</p>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
			<div>
				<div id="_idContainer031" class="IMG---Figure">
					<img src="image/B16694_06_02.jpg" alt="Figure 6.2 – Animation based on the scroll value in Reanimated 2&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – Animation based on the scroll value in Reanimated 2</p>
			<p>In Reanimated 2, the animation<a id="_idIndexMarker427"/> is created as a worklet on the JavaScript thread. But the whole<a id="_idIndexMarker428"/> animation worklet is executed in the worklet context on the UI thread. So, every time a new scroll event is received, it doesn’t have to cross the bridge; instead, it’s processed directly in the worklet context, and the new animation state is passed back to the UI thread for rendering. </p>
			<p>To achieve this kind of architecture, Reanimated 2 comes with its own Babel plugin. This Babel plugin extracts every function that is annotated as <strong class="source-inline">worklet</strong> from the react-native code and makes it runnable in this separate worklet context on the UI thread. The following code example shows you how to annotate a function as a worklet:</p>
			<pre class="source-code">
function myWorklet() {
  'worklet';
  console.log("Hey I'm running on the UI thread");
}</pre>
			<p>This is a simple JavaScript function that contains the <strong class="source-inline">worklet</strong> annotation in line 2. Based on this annotation, the Reanimated 2 Babel plugin knows that it has to process this function. </p>
			<p>Now, this can be run as a standard function on the JavaScript thread, but it can also be run as a worklet on the UI thread, depending on how it is called. If the function is called like a normal function in the JavaScript code, it runs on the JavaScript thread, and if it is called using the Reanimated 2 <strong class="source-inline">runOnUI</strong> function, it runs asynchronously on the UI thread. </p>
			<p>Of course, it is possible to pass<a id="_idIndexMarker429"/> parameters to these worklet functions, no matter<a id="_idIndexMarker430"/> where it runs.</p>
			<h3>Understanding the connection between the JavaScript thread and the worklet context</h3>
			<p>Understanding this connection<a id="_idIndexMarker431"/> is crucial to prevent a lot of errors<a id="_idIndexMarker432"/> from happening. Essentially, the JavaScript thread and the worklet context run in completely different environments. This means it is not possible to simply access everything from the JavaScript thread while being in a worklet. The following connections are possible when it comes to worklets:</p>
			<ul>
				<li><strong class="bold">The JavaScript thread can start worklets and pass parameters</strong>: As mentioned earlier, it is possible to run a function as a worklet when it has been annotated with <strong class="source-inline">worklet</strong> and is called with <strong class="source-inline">runOnUI</strong>. This runs the function in the worklet context on the UI thread. Every parameter that is passed is copied to the worklet context on the UI thread. </li>
				<li><strong class="bold">Worklets can access constants from the JavaScript thread</strong>: Reanimated 2 processes the worklet code and copies the used constants and their values to the worklet context. This means constants can also be used in worklets without having to fear performance drops.</li>
				<li><strong class="bold">Worklets can invoke other worklet functions synchronously</strong>: Worklets can call other worklets synchronously because they run in the same environment.</li>
				<li><strong class="bold">Worklets can call non-worklet functions asynchronously</strong>: When functions on the JavaScript thread are called from within a worklet, this call has to be asynchronous because the invoked function runs in another environment.</li>
			</ul>
			<p>For more information<a id="_idIndexMarker433"/> on worklets, you<a id="_idIndexMarker434"/> can take a look<a id="_idIndexMarker435"/> at the worklet part of the official documentation at <a href="https://bit.ly/prn-reanimated-worklets">https://bit.ly/prn-reanimated-worklets</a>.</p>
			<h4>Using shared values</h4>
			<p>Like in the internal Animated API of React Native, Reanimated 2 works with animation values to drive the<a id="_idIndexMarker436"/> animation. These animation values are called <strong class="bold">Shared Values</strong> in Reanimated 2. They are called Shared Values<a id="_idIndexMarker437"/> because they can be accessed from both JavaScript environments – the JavaScript thread and the worklet context on the UI thread. </p>
			<p>Since these Shared Values are used to drive animations, and these animations run in the worklet context on the UI thread, they are optimized to be updated and read from the worklet context. This means reads and writes of Shared Values from worklets are synchronous, while reads and writes from the JavaScript thread are asynchronous.</p>
			<p>You can take a deeper look at Shared Values<a id="_idIndexMarker438"/> in the official documentation at <a href="https://bit.ly/prn-reanimated-shared-values">https://bit.ly/prn-reanimated-shared-values</a>.</p>
			<h3>Working with Reanimated 2 Hooks and functions</h3>
			<p>When working with Reanimated 2, there<a id="_idIndexMarker439"/> is no need to create worklets for most<a id="_idIndexMarker440"/> use cases. Reanimated 2 provides an excellent set of Hooks and functions that can be used to create, run, change, interrupt, and cancel animations. These Hooks take care of transferring the executions of the animation to the worklet context automatically.</p>
			<p>This is what was used in the example at the beginning of this section. In that scenario, we created a Shared Value with the <strong class="source-inline">useSharedValue</strong> Hook, connected the View’s style with the <strong class="source-inline">useAnimatedStyle</strong> Hook, and started the animation with the <strong class="source-inline">withTiming</strong> function. </p>
			<p>Of course, you can also handle scroll values with Reanimated 2. The following code example shows you how to connect a <strong class="source-inline">ScrollView</strong> to a Shared Value, to scale and move an i<a id="_idTextAnchor213"/>m<a id="_idTextAnchor214"/>age with an animation dr<a id="_idTextAnchor215"/>i<a id="_idTextAnchor216"/>ven by user scrolling:</p>
			<pre class="source-code">
function App() {
  const scrolli<a id="_idTextAnchor217"/>n<a id="_idTextAnchor218"/>g = useSharedValue(0);
  const scrollHandler = useAnimatedScrollHandler((event) =&gt; 
  {
    scrolling.value = <a id="_idTextAnchor219"/>e<a id="_idTextAnchor220"/>vent.contentOffset.y;
  });
  const imgStyle = useAnimatedStyle(() =&gt; {
    const interpolatedScale = interpolate(
      scrolling.value,[-300, 0],[3, 1],Extrapolate.CLAMP
    );
    const interpolatedTranslate = interpolate(
      scrolling.value,[0, 300],[0, -300],Extrapolate.CLAMP
    );
    return {
      transform: [
        {translateY: interpolatedTranslate}, 
        {scaleY: interpolatedScale}, 
        {scaleX: interpolatedScale}
      ]
    };
  });
  return (
    &lt;&gt;
      &lt;Animated.Image 
        source={require('som<a id="_idTextAnchor221"/>e<a id="_idTextAnchor222"/>titleimage.jpg')}
        style={[styles.header,imgStyle]} 
      /&gt;
      &lt;Animated.ScrollView
        onScroll={scrollHandler}      &gt;
        &lt;View style={styles.headerPlaceholder} /&gt;
        &lt;View style={styles.content} /&gt; 
      &lt;/Animated.ScrollView&gt;
    &lt;/&gt;  
  );
}</pre>
			<p>In this example, the <strong class="source-inline">ScrollView</strong> binds the <em class="italic">Y</em> scroll value (content offset) to the animation value using Reanimated’s <strong class="source-inline">useAnimatedScrollHandler</strong> Hook. This animation value is then interpolated with the interpolate function of Reanimated 2. This is done inside a <strong class="source-inline">useAnimatedStyle</strong> hook.</p>
			<p>This setup makes the animation work, without ever having to send scroll values over the bridge to the JavaScript thread. The whole animation runs inside the worklet context on the UI thread. This makes the animation extremely performant.</p>
			<p>Of course, Reanimated 2 offers a wide range of other options. It is possible to use spring-based animations, velocity-based animations, delay or repeat animations, and run animations in sequence, just to name a few. </p>
			<p>Since a complete<a id="_idIndexMarker441"/> guide on Reanimated 2 <a id="_idIndexMarker442"/>would go beyond the scope<a id="_idIndexMarker443"/> of this book, please have a look<a id="_idIndexMarker444"/> at the official documentation (<a href="https://bit.ly/prn-reanimated-docs">https://bit.ly/prn-reanimated-docs</a>) and the API reference (<a href="https://bit.ly/prn-reanimated-api-reference">https://bit.ly/prn-reanimated-api-reference</a>).</p>
			<p>To complete this section, we wi<a id="_idTextAnchor223"/>l<a id="_idTextAnchor224"/>l have a look at the pros and cons of Reanimated 2.</p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor225"/>Understanding the pros and cons of Reanimated</h2>
			<p>Reanimated 2 is, by far, the most advanced and complete solution for animations in React Native. There are a lot of reasons<a id="_idIndexMarker445"/> to use Reanimated 2. Here is a list of the most important ones: </p>
			<ul>
				<li><strong class="bold">Easy-to-use API</strong>: The Reanimated 2 API with Hooks and functions is easy to learn, read, and understand. </li>
				<li><strong class="bold">Awesome performance out of the box</strong>: Animations with Reanimated 2 run smoothly and are performant on all devices out of the box. </li>
				<li><strong class="bold">Animation of layout properties</strong>: All style values can be used in animations. There is no limitation like in the Animated API.</li>
				<li><strong class="bold">Interrupting, changing, and canceling animations</strong>: Animations with Reanimated 2 can be interrupted, changed, or canceled while they run, without causing frame drops or sluggish behavior. </li>
			</ul>
			<p>Reanimated 2 is a very good library, but before using it, you should have a look at the following cons:</p>
			<ul>
				<li><strong class="bold">Complicated installation</strong>: Since Reanimated 2 deeply<a id="_idIndexMarker446"/> intervenes in the architecture of React Native, the installation is quite complicated. You have to make some changes to the native code and add the Reanimated 2 Babel plugin. This is not a big problem because it only has to be done once, but it will take some time. This will change when the new architecture, including the new Fabric renderer, is out.</li>
				<li><strong class="bold">Reanimated 2 makes you bundle larger</strong>: While the internal Animated API is part of React Native, Reanimated 2 is an external dependency. This means your bundle will grow. </li>
			</ul>
			<p>If you have an app with a lot of animations, more complex animations, and/or animated layout properties, I would definitely recommend using Reanimated 2. If you only use basic animations, which can be achieved with the internal Animated API, you don’t need Reanimated and can stick to the Animated API.</p>
			<p>While Reanimated 2, the<a id="_idIndexMarker447"/> Animated API, and even <strong class="source-inline">react-native-animatable</strong> have a very similar approach, the next library we will get to know works completely differently. Let’s take a look at Lottie.</p>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor226"/>Using Lottie animations in React Native</h1>
			<p>Lottie is a completely different<a id="_idIndexMarker448"/> approach to animations in app and web development. It allows<a id="_idIndexMarker449"/> you to render and control prebuilt vector animations. The following figure shows the process of how a Lottie animation is created and played:</p>
			<div>
				<div id="_idContainer032" class="IMG---Figure">
					<img src="image/B16694_06_03.jpg" alt="Figure 6.3 – The workflow when animating with Lottie&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – The workflow when animating with Lottie</p>
			<p>Essentially, Lottie consists of a player, which in the case of React Native is the <strong class="source-inline">lottie-react-native</strong> library. This library expects a JSON file of a Lottie animation. This file is created with Adobe After Effects (a professional animation software) and exported to JSON with the Bodymovin plugin. </p>
			<p>This process completely changes the way we work with animations in apps. The developer is no longer responsible for creating the animations; they only have to include the JSON file. This can save a huge amount of time when working with very complex animations. </p>
			<p>All of this becomes clearer when looking at a simple Lottie animation.</p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor227"/>Starting with a simple example</h2>
			<p>The following code example shows<a id="_idIndexMarker450"/> the implementation of a loading animation with Lottie:</p>
			<pre class="source-code">
import React from 'react';
import { View, StyleSheet } from 'react-native';
import LottieView from 'lottie-react-native';
const App = () =&gt; {
    return (
        &lt;View style={styles.center}&gt;
            &lt;LottieView
                source={require('loading-animation.json')}
                style={styles.animation}
                autoPlay/&gt;
        &lt;/View&gt;
    );
};
const styles = StyleSheet.create({
    center: {
        flex: 1,
          alignItems: 'center',
            justifyContent: 'center'
    },
    animation: {
        width: 150,
        height: 150
    }
});
export default App;</pre>
			<p>This is all the code that is needed to include a loading animation, no matter how complex the animation is. <strong class="source-inline">LottieView</strong> is imported from the <strong class="source-inline">lottie-react-native</strong> library and is placed where the animation should occur. The Lottie JSON file is passed as source to <strong class="source-inline">LottieView</strong>, which can be styled via the style property like a regular React Native view. </p>
			<p>However, <strong class="source-inline">lottie-react-native</strong> is not just a simple player. It gives you programmatic control over <a id="_idIndexMarker451"/>the animation. You can start and stop the animation, autoplay it when it loads, and loop it so that it starts again after completion. The last one is especially useful for loading animations. </p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor228"/>Combining Lottie animations with the React Native Animated API</h2>
			<p>The best feature of <strong class="source-inline">lottie-react-native</strong> is that it is possible<a id="_idIndexMarker452"/> to bind the progress of an animation to an <strong class="source-inline">Animated.Value</strong> component<a id="_idIndexMarker453"/> of the React Native Animated API. This opens up a lot of different use cases such as Lottie animations running time or spring-based. You can also use easing or create Lottie animations running based on user interaction. </p>
			<p>The following code example shows you how to create a Lottie animation driven by an <strong class="source-inline">Animated.Value</strong> component that is bound to the <em class="italic">Y</em> scroll value of a React Native <strong class="source-inline">ScrollView</strong>:</p>
			<pre class="source-code">
const App = () =&gt; {
  const scrolling = useRef(new Animated.Value(0)).current;
  let interpolatedProgress = scrolling.interpolate({
    inputRange: [-1000, 0, 1000],
    outputRange: [1, 0, 1],
    extrapolate: 'clamp',
  });
  return (
    &lt;View style={styles.container}&gt;
      &lt;Animated.ScrollView
        onScroll={Animated.event(
          [{
            nativeEvent: {
              contentOffset: {
                y: scrolling,
              },
            },
          }],
          { useNativeDriver: true },
        )}
        scrollEventThrottle={16}&gt;
          &lt;LottieView 
            source={require('looper.json')}
            style={styles.animation}
            progress={interpolatedProgress}/&gt;
      &lt;/Animated.ScrollView&gt;
    &lt;/View&gt;
  )
}</pre>
			<p>In this example, the <em class="italic">Y</em> scroll value of the <strong class="source-inline">ScrollView</strong> is bound to an <strong class="source-inline">Animated.Value</strong> component in the <strong class="source-inline">onScroll</strong> function of the <strong class="source-inline">ScrollView</strong>. Then, the <strong class="source-inline">Animated.Value</strong> component is interpolated to get an <strong class="source-inline">interpolatedProgress</strong> between <strong class="source-inline">0</strong> and <strong class="source-inline">1</strong>. This <strong class="source-inline">interpolatedProgess</strong> is passed to <strong class="source-inline">LottieView</strong> as a progress property. </p>
			<p>Lottie also supports animations<a id="_idIndexMarker454"/> of the React Native Animated<a id="_idIndexMarker455"/> API, that use the native driver. This is very important for performance reasons. For more on this, please read the <em class="italic">Using the internal Animated API of React Native</em> section of this chapter. </p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor229"/>Finding or creating Lottie animations</h2>
			<p>While Lottie animations<a id="_idIndexMarker456"/> are very easy to include for the developer, someone has to create the Lottie JSON files that contain the animations. There are three ways to get Lottie animation files: </p>
			<ul>
				<li><strong class="bold">Find Lottie files on the internet</strong>: There are a lot of talented animation artists out there who <a id="_idIndexMarker457"/>share their work on the internet. A lot of the files are free, but it is also possible to purchase premium animation conte<a id="_idTextAnchor230"/>nt. The best place to st<a id="_idTextAnchor231"/>art<a id="_idIndexMarker458"/> your search for Lottie animations is <a href="https://lottiefiles.com/">https://lottiefiles.com/</a>.</li>
				<li><strong class="bold">Learn to create animations with After Effects</strong>: There are a lot of good beginner tutorials, and even if it seems overwhelming to begin with, After Effects is an awesome software, and it is quite easy to create your first animations with it. If you are interested in learning After Effects, you can start with the tutorial at <a href="http://bit.ly/prn-lottie-tutorial">bit.ly/prn-lottie-tutorial</a>.</li>
				<li><strong class="bold">Hire an animation artist</strong>: This is, by far, the best solution from my point of view. An experienced animation artist will only need some hours to create a bunch of individual animations for your project. It will save you time and money to work with an animation artist, and it will greatly improve the quality of your app when having individual animations that exactly fit your UI concept. You can find and contact animation artists at <a href="https://lottiefiles.com/">https://lottiefiles.com/</a>.</li>
			</ul>
			<p>Now that we have a good understanding of how Lottie animations in React Native work, let’s have a look at the pros and cons.</p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor232"/>Understanding the pros and cons of Reanimated</h2>
			<p>Since the Lottie approach is completely different, there are huge pros and cons you should keep in mind when you consider using Lottie as the animation solution for your project. </p>
			<p>The following pros<a id="_idIndexMarker459"/> stand out when using Lottie:</p>
			<ul>
				<li><strong class="bold">Lottie is the easiest solution for developers</strong>: When working with <strong class="source-inline">lottie-react-native</strong>, it just takes a few lin<a id="_idTextAnchor233"/>e<a id="_idTextAnchor234"/>s of code to integrate an animation, no matter how complex it is. </li>
				<li><strong class="bold">Animations are much smaller than GIFs or Sprites</strong>: Another approach when it comes to animated files is GIFs or Sprites. Lottie files are much smaller and consume far less memory than these solutions.</li>
				<li><strong class="bold">Programmatic control over the animation progress</strong>: Unlike when working with GIFs, you have programmatic control over the animation. You can even bind the animation progress to the animation values of React Native Animated. </li>
			</ul>
			<p>However, Lottie also comes<a id="_idIndexMarker460"/> with the following cons: </p>
			<ul>
				<li><strong class="bold">No full control over the animation</strong>: When working with Lottie animations, you are able to control the progress of the animation, but only the progress. You cannot change the paths of the animations based on user interaction like you can when completely scripting the animation. </li>
				<li><strong class="bold">The large size of the Lottie library</strong>: Lottie for React Native increases the bundle size. Depending on what platform an app is exported to, not only does <strong class="source-inline">lottie-react-native</strong> has to be included in the app but also the Lottie module for the native platform. </li>
				<li><strong class="bold">External dependency</strong>: Lottie is an external dependency, and you have to keep in mind that this could slow down your update capabilities for new React Native versions. Since Lottie is not a React Native-only solution but also working on native apps and the web and React Native is a smaller platform compared to the other platforms Lottie<a id="_idIndexMarker461"/> is working on, it is kind of a second class citizen. This means it is not guaranteed that <strong class="source-inline">lottie-react-native</strong> will immediately work with every new React Native version. </li>
			</ul>
			<p>Lottie is an awesome option to include high-quality animations in a React Native project. Especially for complex loading animations, micro-animations, or any animation where no complete programmatic control is needed, Lottie is a great solution. </p>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor235"/>Summary</h1>
			<p>In this chapter, you learned about the general architectural challenge when it comes to animations in React Native. You understood that there are different solutions to overcome this challenge and create high-quality and performant animations. With Animated, <strong class="source-inline">react-native-animatable</strong>, Reanimated, and Lottie, we looked at the best and the most widely used animation solutions for React Native’s on-screen animations. </p>
			<p>This is important because you will have to use animations in your app to create a high-quality product, and such animation libraries are the only way to create high-quality and performant animations in React Native.</p>
			<p>In the next chapter, you will learn how to handle user gestures and also work with more complex user gestures to do different things – for example, to drive animations.</p>
		</div>
	</body></html>