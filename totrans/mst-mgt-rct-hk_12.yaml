- en: '*Chapter 9*: Use Case Scenario 3 – Valtio'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 9 章*：用例场景 3 – Valtio'
- en: Valtio ([https://github.com/pmndrs/valtio](https://github.com/pmndrs/valtio))
    is yet another library for global state. Unlike Zustand and Jotai, it's based
    on the mutating update model. It's primarily for module states like Zustand. It
    utilizes proxies to get an immutable snapshot, which is required to integrate
    with React.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Valtio ([https://github.com/pmndrs/valtio](https://github.com/pmndrs/valtio))
    是另一个用于全局状态的库。与 Zustand 和 Jotai 不同，它基于可变更新模型。它主要用于模块状态，如 Zustand。它利用代理获取不可变快照，这是与
    React 集成所需的。
- en: The API is just JavaScript and everything works behind the scenes. It also leverages
    proxies to automatically optimize re-renders. It doesn't require a selector to
    control re-renders. The automatic render optimization is based on a technique
    called **state usage tracking**. Using state usage tracking, it can detect which
    part of the state is used, and it can let a component re-render only if the used
    part of the state is changed. In the end, developers need to write less code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: API 只是 JavaScript，所有操作都在幕后进行。它还利用代理自动优化重新渲染。它不需要选择器来控制重新渲染。自动渲染优化基于一种称为 **状态使用跟踪**
    的技术。使用状态使用跟踪，它可以检测状态中哪些部分被使用，并且只有当状态的使用部分发生变化时，它才会让组件重新渲染。最终，开发者需要编写的代码更少。
- en: In this chapter, we will learn about the basic usage of the Valtio library and
    how it deals with mutating updates. Snapshots are a key feature to create an immutable
    state. We will also discuss how snapshots and proxies allow us to optimize re-renders.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解 Valtio 库的基本用法以及它如何处理可变更新。快照是创建不可变状态的关键特性。我们还将讨论快照和代理如何帮助我们优化重新渲染。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Exploring Valtio, another module state library
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 Valtio，另一个模块状态库
- en: Utilizing proxies to detect mutations and create an immutable state
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用代理检测突变并创建不可变状态
- en: Using proxies to optimize re-renders
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用代理优化重新渲染
- en: Creating small application code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建小型应用程序代码
- en: The pros and cons of this approach
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种方法的优缺点
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You are expected to have moderate knowledge of React, including React Hooks.
    Refer to the official site, [https://reactjs.org](https://reactjs.org), to learn
    more.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 预期你具备一定的 React 知识，包括 React Hooks。请参考官方网站 [https://reactjs.org](https://reactjs.org)
    了解更多。
- en: In some code, we use TypeScript ([https://www.typescriptlang.org](https://www.typescriptlang.org)),
    and you should have basic knowledge of it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些代码中，我们使用 TypeScript ([https://www.typescriptlang.org](https://www.typescriptlang.org))，你应该对其有基本了解。
- en: 'The code in this chapter is available on GitHub: [https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_09](https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_09).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码可在 GitHub 上找到：[https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_09](https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_09)。
- en: To run the code snippets, you need a React environment, for example, Create
    React App ([https://create-react-app.dev](https://create-react-app.dev)) or CodeSandbox
    ([https://codesandbox.io](https://codesandbox.io)).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行代码片段，你需要一个 React 环境，例如，Create React App ([https://create-react-app.dev](https://create-react-app.dev))
    或 CodeSandbox ([https://codesandbox.io](https://codesandbox.io))。
- en: Exploring Valtio, another module state library
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Valtio，另一个模块状态库
- en: Valtio is a library primarily used for module state, which is the same as Zustand.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Valtio 是一个主要用于模块状态的库，与 Zustand 相同。
- en: 'As we learned in [*Chapter 7*](B17780_07_Final_VK_ePub.xhtml#_idTextAnchor092),
    *Use Case Scenario 1 – Zustand*, we create a store in Zustand as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 [*第 7 章*](B17780_07_Final_VK_ePub.xhtml#_idTextAnchor092) 中学到的，*用例场景 1
    – Zustand*，我们在 Zustand 中创建存储的方式如下：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `store` variable has some properties, one of which is `setState`. With
    `setState`, we can update the state. For example, the following is incrementing
    the `count` value:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`store` 变量有一些属性，其中之一是 `setState`。使用 `setState`，我们可以更新状态。例如，以下代码是增加 `count`
    值：'
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Why do we need to use `setState` to update a state value? Because we want to
    update the state immutably. Internally, the previous `setState` works like the
    following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们需要使用 `setState` 来更新状态值？因为我们希望以不可变的方式更新状态。内部，之前的 `setState` 工作方式如下：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is the way to update an object immutably.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是更新对象的不变方式。
- en: 'Let''s imagine a case where we don''t need to follow the immutable update rule.
    In this case, the code to increment the `count` value in `moduleState` would be
    the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一个不需要遵循不可变更新规则的情况。在这种情况下，增加 `moduleState` 中 `count` 值的代码如下：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Wouldn't it be nice if we could write code like that and make it work with React?
    Actually, we can implement this with proxies.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够编写这样的代码并且让它与 React 一起工作，那岂不是很好？实际上，我们可以使用代理来实现这一点。
- en: 'A proxy is a special object in JavaScript ([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)).
    We can define some handlers to trap object operations. For example, you can add
    a `set` handler to trap object mutations:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 代理是 JavaScript 中的一个特殊对象（[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)）。我们可以定义一些处理器来捕获对象操作。例如，你可以添加一个
    `set` 处理器来捕获对象变更：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We create `proxyObject` with `new Proxy` with two arguments. The first argument
    is an object itself. The second argument is a collection object of handlers. In
    this case, we have a `set` handler, which traps the `set` operation and adds `console.log`
    statements.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `new Proxy` 和两个参数创建 `proxyObject`。第一个参数是一个对象本身。第二个参数是一个包含处理器的集合对象。在这种情况下，我们有一个
    `set` 处理器，它捕获 `set` 操作并添加 `console.log` 语句。
- en: '`proxyObject` is a special object and when you set a value, it will log to
    the console before and after setting the value. The following is the screen output
    if you run the code in the Node.js REPL ([https://nodejs.dev/learn/how-to-use-the-nodejs-repl](https://nodejs.dev/learn/how-to-use-the-nodejs-repl)):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`proxyObject` 是一个特殊对象，当你设置一个值时，它将在设置值前后向控制台记录日志。以下是在 Node.js REPL 中运行代码的屏幕输出（[https://nodejs.dev/learn/how-to-use-the-nodejs-repl](https://nodejs.dev/learn/how-to-use-the-nodejs-repl)）：'
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Conceptually, as a proxy can detect any mutations, we could technically use
    similar behavior to `setState` in Zustand. Valtio is a library that utilizes proxies
    to detect state mutations.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，由于代理可以检测任何变更，我们可以技术上使用与 Zustand 中的 `setState` 相似的行为。Valtio 是一个利用代理来检测状态变更的库。
- en: In this section, we learned that Valtio is a library that uses the mutating
    update model. Next up, we will learn how Valtio creates immutable states with
    mutations.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解到 Valtio 是一个使用变更更新模型的库。接下来，我们将学习 Valtio 如何通过变更创建不可变状态。
- en: Utilizing proxies to detect mutations and create an immutable state
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用代理检测变更并创建不可变状态
- en: Valtio creates immutable objects from mutable objects with proxies. We call
    the immutable object a **snapshot**.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Valtio 使用代理从可变对象创建不可变对象。我们称这个不可变对象为 **快照**。
- en: To create a mutable object wrapped in a proxy object, we use the `proxy` function
    exported by Valtio.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个被代理对象包装的可变对象，我们使用 Valtio 导出的 `proxy` 函数。
- en: 'The following example is to create an object with a `count` property:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例是创建一个具有 `count` 属性的对象：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `state` object returned by the `proxy` function is a proxy object that detects
    mutations. This allows you to create an immutable object.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`proxy` 函数返回的 `state` 对象是一个检测变更的代理对象。这允许你创建一个不可变对象。'
- en: 'To create an immutable object, we use the `snapshot` function exported by Valtio,
    as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个不可变对象，我们使用 Valtio 导出的 `snapshot` 函数，如下所示：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Though the `state` variable is `{ count: 0 }` and the `snap1` variable is `{
    count: 0 }`, `state` and `snap1` have different references. `state` is a mutable
    object wrapped in a proxy, whereas `snap1` is an immutable object frozen with
    `Object.freeze` ([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '虽然变量 `state` 是 `{ count: 0 }` 并且 `snap1` 变量也是 `{ count: 0 }`，但 `state` 和 `snap1`
    有不同的引用。`state` 是一个被代理包装的可变对象，而 `snap1` 是使用 `Object.freeze` 冻结的不可变对象（[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)）。'
- en: 'Let''s see how snapshots work. We mutate the `state` object and create another
    snapshot, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看快照是如何工作的。我们变更 `state` 对象并创建另一个快照，如下所示：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `state` variable is `{ count: 1 }` and has the same reference as before.
    The `snap2` variable is `{ count: 1 }` and has a new reference. Because `snap1`
    and `snap2` are immutable, we can check the equality with `snap1 === snap2`, and
    know whether anything in the objects differs.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '变量 `state` 是 `{ count: 1 }` 并且与之前有相同的引用。变量 `snap2` 是 `{ count: 1 }` 并且有新的引用。因为
    `snap1` 和 `snap2` 是不可变的，我们可以使用 `snap1 === snap2` 来检查它们的相等性，并知道对象中是否有任何差异。'
- en: 'The `proxy` and `snapshot` functions work for nested objects and optimize snapshot
    creation. That means the `snapshot` function will create a new snapshot only if
    necessary, that is, when any of its properties are changed. Let''s look at another
    example. `state2` has two nested `c` properties:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`proxy` 和 `snapshot` 函数适用于嵌套对象，并优化了快照的创建。这意味着只有在其属性发生变化时，`snapshot` 函数才会创建新的快照。让我们看看另一个例子。`state2`
    有两个嵌套的 `c` 属性：'
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this case, the `snap21` variable is `{ obj1: { c: 0 }, obj2: { c: 0 } }`
    and the `snap22` variable is `{ obj1: { c: 1 }, obj2: { c: 0 } }`. `snap21` and
    `snap22` have difference references, hence `snap21 !== snap22` holds.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '在这种情况下，`snap21` 变量是 `{ obj1: { c: 0 }, obj2: { c: 0 } }`，而 `snap22` 变量是 `{
    obj1: { c: 1 }, obj2: { c: 0 } }`。`snap21` 和 `snap22` 有不同的引用，因此 `snap21 !== snap22`
    成立。'
- en: How about nested objects? `snap21.obj1` and `snap22.obj1` are different, but
    `snap21.obj2` and `snap22.obj2` are the same. This is because the value of the
    internal `c` property of `obj2` isn't changed. `obj2` doesn't need to be changed,
    hence `snap21.obj2 === snap22.obj2` holds.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 关于嵌套对象呢？`snap21.obj1` 和 `snap22.obj1` 是不同的，但 `snap21.obj2` 和 `snap22.obj2` 是相同的。这是因为
    `obj2` 的内部 `c` 属性的值没有改变。`obj2` 不需要改变，因此 `snap21.obj2 === snap22.obj2` 成立。
- en: This snapshot optimization is an important feature. The fact that `snap21.obj2`
    and `snap22.obj2` have the same reference means they share memory. Valtio creates
    snapshots only if necessary, optimizing memory usage. This optimization can be
    done in Zustand, but it's the developer's responsibility to properly create new
    immutable states. In contrast, Valtio does the optimization behind the scenes.
    In Valtio, developers are free from the responsibility of creating new immutable
    states.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这种快照优化是一个重要特性。`snap21.obj2` 和 `snap22.obj2` 有相同的引用意味着它们共享内存。Valtio 只在必要时创建快照，优化内存使用。这种优化可以在
    Zustand 中完成，但开发者有责任正确创建新的不可变状态。相比之下，Valtio 在幕后进行优化。在 Valtio 中，开发者无需承担创建新不可变状态的责任。
- en: Important Note
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Valtio's optimization is based on caching with a previous snapshot. In other
    words, the cache size is 1\. If we increment the count with `++state.count` and
    then decrement it with `--state.count`, a new snapshot will be created.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Valtio 的优化基于与先前快照的缓存。换句话说，缓存大小为 1。如果我们使用 `++state.count` 增加计数，然后使用 `--state.count`
    减少它，将创建一个新的快照。
- en: In this section, we learned how Valtio creates immutable state "snapshots" automatically.
    Next up, we will learn about Valtio's hooks for React.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了 Valtio 如何自动创建不可变状态“快照”。接下来，我们将学习 Valtio 为 React 提供的钩子。
- en: Using proxies to optimize re-renders
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用代理优化重新渲染
- en: Valtio uses proxies to optimize re-renders, as well as detecting mutations.
    This is the pattern of optimizing re-renders we learned about in the *Detecting
    property access* section of [*Chapter 6*](B17780_06_Final_VK_ePub.xhtml#_idTextAnchor080),
    *Introducing Global State Libraries*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Valtio 使用代理来优化重新渲染，以及检测突变。这是我们学习到的优化重新渲染的模式，在 [*第6章*](B17780_06_Final_VK_ePub.xhtml#_idTextAnchor080)
    的 *检测属性访问* 部分，*介绍全局状态库*。
- en: Let's learn about the usage and behavior of Valtio hooks with a counter app.
    The hook is called `useSnapshot`. The implementation of `useSnapshot` is based
    on the `snapshot` function and another proxy to wrap it. This `snapshot` proxy
    has a different purpose from the proxy used in the `proxy` function. The `snapshot`
    proxy is used to detect the property access of a snapshot object. We will see
    how render optimization works, thanks to the `snapshot` proxy.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个计数器应用程序来了解 Valtio 钩子的使用和行为。这个钩子叫做 `useSnapshot`。`useSnapshot` 的实现基于 `snapshot`
    函数和另一个代理来包装它。这个 `snapshot` 代理与 `proxy` 函数中使用的代理有不同的目的。`snapshot` 代理用于检测快照对象的属性访问。我们将看到渲染优化是如何通过
    `snapshot` 代理来实现的。
- en: 'We start with importing functions from Valtio to create a counter app:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从导入 Valtio 的函数开始创建计数器应用程序：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`proxy` and `useSnapshot` are two main functions provided by Valtio and they
    cover most use cases.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`proxy` 和 `useSnapshot` 是 Valtio 提供的两个主要函数，它们涵盖了大多数用例。'
- en: 'We then create a `state` object with `proxy`. In our counter app, there are
    two counts – `count1` and `count2`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后使用 `proxy` 创建一个 `state` 对象。在我们的计数器应用程序中，有两个计数器 - `count1` 和 `count2`：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `proxy` function takes an initial object and returns a new proxy object.
    We can mutate the `state` object as we like.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`proxy` 函数接受一个初始对象并返回一个新的代理对象。我们可以像喜欢的那样修改 `state` 对象。'
- en: 'Next, we define the `Counter1` component, which uses the `state` object and
    shows the `count1` property:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义 `Counter1` 组件，它使用 `state` 对象并显示 `count1` 属性：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It's our convention to set the name of the return value of `useSnapshot` to
    `name`. The `inc` action is a function to mutate the `state` object. We mutate
    the `state` proxy object; `snap` is only to read. The `snap` object is frozen
    with `Object.freeze` ([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze))
    and it can't be mutated technically. Without `Object.freeze`, JavaScript objects
    are always mutable and we can only treat it as immutable by convention. `snap.count1`
    is accessing the `count1` property of the `state` object. The access is detected
    by the `useSnapshot` hook as tracking information, and based on the tracking information,
    the `useSnapshot` hook triggers re-renders only when necessary.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的习惯是将 `useSnapshot` 的返回值命名为 `name`。`inc` 动作是一个用于修改 `state` 对象的函数。我们修改 `state`
    代理对象；`snap` 仅用于读取。`snap` 对象使用 `Object.freeze` 冻结（[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)）并且技术上不能被修改。没有
    `Object.freeze`，JavaScript 对象始终是可变的，我们只能按照惯例将其视为不可变。`snap.count1` 是访问 `state`
    对象的 `count1` 属性。这种访问被 `useSnapshot` 钩子检测为跟踪信息，并且基于跟踪信息，`useSnapshot` 钩子仅在必要时触发重新渲染。
- en: 'We define the `Counter2` component likewise:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们同样定义 `Counter2` 组件：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The difference from `Counter1` is it uses the `count2` property instead of the
    `count1` property. If we want to define a shared component, we can define a single
    component and take the property name in `props`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `Counter1` 的区别在于它使用 `count2` 属性而不是 `count1` 属性。如果我们想定义一个共享组件，我们可以定义一个单独的组件并在
    `props` 中取属性名。
- en: 'Finally, we define the `App` component. As we don''t use Context, there are
    no providers:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义 `App` 组件。由于我们不使用 Context，因此没有提供者：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'How does this app work? On the initial render, the `state` object is `{ count1:
    0, count2: 0 }` and so is its snapshot object. The `Counter1` component accesses
    the `count1` property of the snapshot object and the `Counter2` component accesses
    the `count2` property of the snapshot object. Each `useSnapshot` hook knows and
    remembers tracking information. The tracking information represents which property
    is accessed.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '这个应用是如何工作的呢？在初始渲染时，`state` 对象是 `{ count1: 0, count2: 0 }`，其快照对象也是如此。`Counter1`
    组件访问快照对象的 `count1` 属性，而 `Counter2` 组件访问快照对象的 `count2` 属性。每个 `useSnapshot` 钩子都知道并记住跟踪信息。跟踪信息表示访问了哪个属性。'
- en: 'When we click the button in the `Counter1` component (the first button in *Figure
    9.1*), it increments the `count1` property of the `state` object:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 `Counter1` 组件（*图 9.1* 中的第一个按钮）中点击按钮时，它增加 `state` 对象的 `count1` 属性：
- en: '![Figure 9.1 – First screenshot of the counter app ](img/Figure_9.01_B17780.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1 – 计数器应用的第一张截图](img/Figure_9.01_B17780.jpg)'
- en: Figure 9.1 – First screenshot of the counter app
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – 计数器应用的第一张截图
- en: 'Thus, the `state` object becomes `{ count1: 1, count2: 0 }`. The `Counter1`
    component re-renders with the new number `1`. However, the `Counter2` component
    doesn''t re-render, because `count2` is still `0` and not changed (*Figure 9.2*):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '因此，`state` 对象变为 `{ count1: 1, count2: 0 }`。`Counter1` 组件使用新的数字 `1` 重新渲染。然而，`Counter2`
    组件不会重新渲染，因为 `count2` 仍然是 `0` 并且没有变化（*图 9.2*）：'
- en: '![Figure 9.2 – Second screenshot of the counter app ](img/Figure_9.02_B17780.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2 – 计数器应用的第二张截图](img/Figure_9.02_B17780.jpg)'
- en: Figure 9.2 – Second screenshot of the counter app
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – 计数器应用的第二张截图
- en: Re-renders are optimized with tracking information.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用跟踪信息优化重新渲染。
- en: 'In our counter app, the `state` object is simple with two properties with number
    values. Valtio supports nested objects and arrays. A contrived example is the
    following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的计数器应用中，`state` 对象很简单，有两个具有数值属性的属性。Valtio 支持嵌套对象和数组。一个虚构的例子如下：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Basically, any objects containing plain objects and arrays are fully supported
    even though they are nested deeply. For more information, please refer to the
    project site: [https://github.com/pmndrs/valtio](https://github.com/pmndrs/valtio).'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，任何包含普通对象和数组的对象都完全支持，即使它们嵌套得很深。更多信息，请参阅项目网站：[https://github.com/pmndrs/valtio](https://github.com/pmndrs/valtio)。
- en: In this section, we learned how Valtio optimizes re-renders with snapshots and
    proxies. In the next section, we will learn how to structure an app with an example.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了 Valtio 如何通过快照和代理优化重新渲染。在下一节中，我们将通过示例学习如何构建一个应用。
- en: Creating small application code
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建小型应用程序代码
- en: We will learn how to create a small app. Our example app is a to-do app. Valtio
    is unopinionated about how to structure apps. This is one of the typical patterns.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何创建一个小型应用。我们的示例应用是一个待办事项应用。Valtio对应用的结构没有特定意见。这是其中一种典型模式。
- en: 'Let''s look at how a to-do app can be structured. First, we define the `Todo`
    type:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看待办应用可以如何构建。首先，我们定义`Todo`类型：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: A `Todo` item has an `id` string value, a `title` string value, and a `done`
    Boolean value.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`Todo`项目有一个字符串类型的`id`值，一个字符串类型的`title`值，以及一个布尔类型的`done`值。
- en: 'We then define a `state` object using the defined `Todo` type:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用定义的`Todo`类型定义一个`state`对象：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `state` object is created by wrapping an initial object with `proxy`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`state`对象是通过用`proxy`包装一个初始对象来创建的。'
- en: 'To manipulate the `state` object, we define some helper functions – `addTodo`
    to add a new to-do item, `removeTodo` to remove it, and `toggleTodo` to toggle
    the `done` status:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了操作`state`对象，我们定义了一些辅助函数 – `addTodo`用于添加一个新的待办事项，`removeTodo`用于删除它，以及`toggleTodo`用于切换`完成`状态：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`nanoid` is a small function to generate a unique ID ([https://www.npmjs.com/package/nanoid](https://www.npmjs.com/package/nanoid)).
    Notice these three functions are based on normal JavaScript syntax. They treat
    `state` just like a normal JavaScript object. This is accomplished with proxies.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`nanoid`是一个用于生成唯一ID的小函数（[https://www.npmjs.com/package/nanoid](https://www.npmjs.com/package/nanoid)）。注意这三个函数都是基于正常的JavaScript语法。它们将`state`当作一个正常的JavaScript对象来处理。这是通过代理实现的。'
- en: 'The following is the `TodoItem` component, which has a checkbox toggle with
    the `done` status, text with a different style with the `done` status, and a button
    to remove the item:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个`TodoItem`组件，它具有与`完成`状态相关的复选框切换、具有不同样式的文本，以及一个用于删除项目的按钮：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice this component receives the `id`, `title`, and `done` properties separately,
    instead of receiving the `todo` object. This is because we use the `memo` function
    and create the `MemoedTodoItem` component. Our state usage tracking detects property
    access, and if we pass an object to a memoed component, the property access is
    omitted.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个组件分别接收`id`、`title`和`done`属性，而不是接收`todo`对象。这是因为我们使用了`memo`函数并创建了`MemoedTodoItem`组件。我们的状态使用跟踪检测属性访问，如果我们向memoed组件传递一个对象，属性访问将被省略。
- en: 'To use the `MemoedTodoItem` component, the `TodoList` component is defined
    with `useSnapshot`, as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`MemoedTodoItem`组件，`TodoList`组件使用`useSnapshot`定义，如下所示：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This component takes `todos` from the result of `useSnapshot` and accesses all
    properties in objects in the `todos` array. Hence, `useSnapshot` triggers a re-render
    if any part of `todos` is changed. It's not a big issue and this is a valid pattern
    because the `MemoedTodoItem` component won't re-render unless `id`, `title`, or
    `done` is changed. We will learn about another pattern later in this section.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件从`useSnapshot`的结果中获取`todos`，并访问`todos`数组中对象的全部属性。因此，如果`todos`的任何部分发生变化，`useSnapshot`将触发重新渲染。这不是一个大问题，这是一个有效的模式，因为`MemoedTodoItem`组件只有在`id`、`title`或`done`发生变化时才会重新渲染。我们将在本节稍后学习另一种模式。
- en: 'To create a new to-do item, the following is a small component that has a local
    state for the input field and invokes `createTodo` when the **Add** button is
    clicked:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的待办事项，以下是一个小的组件，它具有输入字段的本地状态，并在点击**添加**按钮时调用`createTodo`：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, we combine the defined components in the `App` component:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在`App`组件中组合定义的组件：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s look at how this app works:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个应用是如何工作的：
- en: At first, it has only a text field and an **Add** button (*Figure 9.3*):![Figure
    9.3 – First screenshot of the todos app ](img/Figure_9.03_B17780.jpg)
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 起初，它只有一个文本字段和一个**添加**按钮（*图9.3*）：![图9.3 – todos应用的第一次截图](img/Figure_9.03_B17780.jpg)
- en: Figure 9.3 – First screenshot of the todos app
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.3 – todos应用的第一次截图
- en: If we click the **Add** button, a new item is added (*Figure 9.4*):![Figure
    9.4 – Second screenshot of the todos app ](img/Figure_9.04_B17780.jpg)
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们点击**添加**按钮，将添加一个新的项目（*图9.4*）：![图9.4 – todos应用的第二次截图](img/Figure_9.04_B17780.jpg)
- en: Figure 9.4 – Second screenshot of the todos app
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.4 – todos应用的第二次截图
- en: We can add as many items as we want (*Figure 9.5*):![Figure 9.5 – Third screenshot
    of the todos app ](img/Figure_9.05_B17780.jpg)
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以添加尽可能多的项目（*图9.5*）：![图9.5 – todos应用的第三张截图](img/Figure_9.05_B17780.jpg)
- en: Figure 9.5 – Third screenshot of the todos app
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.5 – todos应用的第三张截图
- en: Clicking a checkbox will toggle the `done` status (*Figure 9.6*):![Figure 9.6
    – Fourth screenshot of the todos app ](img/Figure_9.06_B17780.jpg)
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击复选框将切换`完成`状态（*图9.6*）：![图9.6 – todos应用的第四次截图](img/Figure_9.06_B17780.jpg)
- en: Figure 9.6 – Fourth screenshot of the todos app
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.6 – todos应用的第四张截图
- en: 'Clicking the **Delete** button will delete the item (*Figure 9.7*):'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**删除**按钮将删除项目（*图9.7*）：
- en: '![Figure 9.7 – Fifth screenshot of the todos app ](img/Figure_9.07_B17780.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图9.7 – todos应用的第五张截图](img/Figure_9.07_B17780.jpg)'
- en: Figure 9.7 – Fifth screenshot of the todos app
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 – todos应用的第五张截图
- en: The app we created so far works pretty well. But there is room for improvement
    in terms of extra re-renders. When we toggle the `done` state of an existing item,
    not only the corresponding `TodoItem` component but also the `TodoList` component
    will re-render. As noted, this is not a big issue as long as the `TodoList` component
    itself is fairly lightweight.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止创建的应用程序运行得相当好。但在额外重新渲染方面仍有改进的空间。当我们切换现有项目的 `done` 状态时，不仅相应的 `TodoItem`
    组件，而且 `TodoList` 组件也会重新渲染。正如所提到的，只要 `TodoList` 组件本身相对较轻量，这并不是一个大问题。
- en: We have another pattern to eliminate the extra re-render in the `TodoList` component.
    This doesn't mean the overall performance can always be improved. Which approach
    we should take depends on the app in question.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个模式来消除 `TodoList` 组件中的额外重新渲染。这并不意味着整体性能总能得到提升。我们应该采取哪种方法取决于具体的应用程序。
- en: 'In the new approach, we use `useSnapshot` in each `TodoItem` component. The
    `TodoItem` component only receives the `id` property. The following is the modified
    `TodoItem` component:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的方法中，我们在每个 `TodoItem` 组件中使用 `useSnapshot`。`TodoItem` 组件只接收 `id` 属性。以下是被修改的
    `TodoItem` 组件：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Based on the `id` property, it finds `todoState`, uses `useSnapshot` with `todoState`,
    and gets the `title` and `done` properties. This component will re-render only
    if the `id`, `title`, or `done` properties are changed.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 `id` 属性，它找到 `todoState`，使用 `useSnapshot` 与 `todoState`，并获取 `title` 和 `done`
    属性。只有当 `id`、`title` 或 `done` 属性发生变化时，此组件才会重新渲染。
- en: 'Now, let''s look at the modified `TodoList` component. Unlike the previous
    one, it only needs to pass the `id` properties:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看修改后的 `TodoList` 组件。与之前的版本不同，它只需要传递 `id` 属性：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: So, `todoIds` is created from the `id` property of each `todo` object. This
    component will only re-render if the order of `id` is changed, or if some `id`
    is added or removed. If only the `done` status of an existing item is changed,
    this component won't re-render. Hence, the extra re-render is eliminated.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`todoIds` 是从每个 `todo` 对象的 `id` 属性创建的。只有当 `id` 的顺序发生变化，或者添加或删除某些 `id` 时，此组件才会重新渲染。如果只是更改现有项目的
    `done` 状态，此组件不会重新渲染。因此，消除了额外的重新渲染。
- en: In medium-sized apps, the change in the two approaches is subtle in terms of
    performance. The two approaches are more meaningful for different coding patterns.
    Developers can choose the one that is more comfortable with their mental model.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在中等大小的应用程序中，两种方法在性能方面的变化是微妙的。这两种方法对不同的编码模式更有意义。开发者可以选择他们更熟悉的那个。
- en: In this section, we learned about `useSnapshot` use cases with a small app.
    Next up, we will discuss some pros and cons of this library and the approach in
    general.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们通过一个小型应用学习了 `useSnapshot` 的使用场景。接下来，我们将讨论这个库以及一般方法的优缺点。
- en: The pros and cons of this approach
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这种方法的优缺点
- en: We have seen how Valtio works and one question is when we should use it and
    when we should not.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了 Valtio 的工作原理，一个问题是我们在什么时候应该使用它，在什么时候不应该使用它。
- en: One big aspect is the mental model. We have two state-updating models. One is
    for immutable updates and the other for mutable updates. While JavaScript itself
    allows mutable updates, React is built around immutable states. Hence, if we mix
    the two models, we should be careful not to confuse ourselves. One possible solution
    would be to clearly separate the Valtio state and React state so that the mental
    model switch is reasonable. If it works, Valtio can fit in. Otherwise, maybe stick
    with immutable updates.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很大的方面是心理模型。我们有两种状态更新模型。一个是不可变更新，另一个是可变更新。虽然JavaScript本身允许可变更新，但React是围绕不可变状态构建的。因此，如果我们混合这两种模型，我们应该小心不要让自己困惑。一个可能的解决方案是将
    Valtio 状态和 React 状态明确分开，以便心理模型切换是合理的。如果它有效，Valtio 就可以适应。否则，也许我们应该坚持不可变更新。
- en: The major benefit of mutable updates is we can use native JavaScript functions.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 可变更新的主要好处是我们可以使用原生JavaScript函数。
- en: 'For example, removing an item from an array with an `index` value can be written
    as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可以使用以下方式从数组中删除具有 `index` 值的项目：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In immutable updates, this is not so easy. For example, it can be written with
    `slice`, as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在不可变更新中，这并不那么容易。例如，可以使用 `slice` 来编写，如下所示：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Another example is to change the value in a deeply nested object. It can be
    done in mutable updates as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是更改深层嵌套对象中的值。可以在可变更新中这样做：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In immutable updates, it has to be something like the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在不可变更新中，它必须类似于以下内容：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is not very pleasant to write. Valtio helps to reduce application code
    with mutable updates.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这样写并不愉快。Valtio帮助减少具有可变更新的应用程序代码。
- en: Valtio also helps to reduce application code with proxy-based render optimization.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Valtio还帮助减少基于代理的渲染优化的应用程序代码。
- en: 'Suppose we have a state with the `count` and `text` properties, as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个具有`count`和`text`属性的状态，如下所示：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If we use only `count` in a component, we can write the following in Valtio:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只在一个组件中使用`count`，我们可以在Valtio中写出以下内容：
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In comparison, with Zustand, this will be something like the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，使用Zustand，它将类似于以下内容：
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The difference is trivial, but we have `count` in two places.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 差异微不足道，但我们有两个地方都有`count`。
- en: 'Let''s look at a contrived scenario. Suppose we want to show the `text` value
    if the `showText` property is truthy. With `useSnapshot`, it can be done as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个假设的场景。假设我们想在`showText`属性为真时显示`text`值。使用`useSnapshot`，可以这样做：
- en: '[PRE32]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Implementing the same behavior with selector-based hooks is tough. One solution
    is to use a hook twice. With Zustand, it will be like the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于选择器的钩子实现相同的行为很困难。一个解决方案是使用钩子两次。使用Zustand，它将类似于以下内容：
- en: '[PRE33]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This means if we have more conditions, we need more hooks.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果我们有更多条件，我们需要更多钩子。
- en: On the other hand, a disadvantage of proxy-based render optimization can be
    less predictability. Proxies take care of render optimization behind the scenes
    and sometimes it's hard to debug the behavior. Some may prefer explicit selector-based
    hooks.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，基于代理的渲染优化的一个缺点可能是可预测性较低。代理在幕后处理渲染优化，有时很难调试行为。有些人可能更喜欢显式的基于选择器的钩子。
- en: In summary, there's no one-size-fits-all solution. It's up to developers to
    choose the solution that fits their needs.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，没有一种适合所有情况的解决方案。选择适合他们需求的解决方案取决于开发者。
- en: In this section, we discussed the approach taken in the Valtio library.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了Valtio库采用的方法。
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about a library called Valtio. It utilizes proxies
    extensively. We've seen examples and learned how it can be used. It allows mutating
    state, which feels like using normal JavaScript objects, and the proxy-based render
    optimization helps reduce application code. It depends on developers' requirements
    whether this approach is a good choice.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了一个名为Valtio的库。它广泛使用代理。我们已经看到了示例，并学习了如何使用它。它允许修改状态，感觉就像使用正常的JavaScript对象一样，并且基于代理的渲染优化有助于减少应用程序代码。这种方法是否是一个好的选择取决于开发者的需求。
- en: In the next chapter, we will learn about another library, called React Tracked,
    which is a library that is based on Context and has proxy-based render optimization
    like Valtio.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将了解另一个名为React Tracked的库，这是一个基于Context的库，类似于Valtio，具有基于代理的渲染优化。
