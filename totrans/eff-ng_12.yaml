- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deploying Angular Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this last chapter, you will deploy the demo application we created to GitHub
    Pages. You will learn to lint and build Angular applications and libraries inside
    your Nx monorepo. We will explore what Angular and Nx create for you when you
    build an Angular application and what it is you deploy to your hosting platform.
    When you know how to build your Angular applications, we will inspect the application
    build and analyze the different bundles inside our build to determine where we
    can make some improvements to reduce the size of our application bundles. After
    analyzing the application bundles, we will first host the production build of
    our application locally. Next, we will dive into GitHub Pages and GitHub Actions
    to create an automated deployment process. GitHub Pages is a static website hosting
    service that allows you to host your static websites and applications for free.
    GitHub actions are used to set up **continuous integration and continuous delivery**
    (**CI/CD**) flows to automate your linting, testing, and deployment process. The
    CI/CD process you create will automatically lint, test, and deploy your Angular
    app inside the Nx monorepo to GitHub Pages when you merge code to your main GitHub
    branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Building and linting Angular applications inside your Nx monorepo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing your build output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatically deploying Angular applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building and linting Angular applications inside your Nx monorepo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will explore the steps required to build and lint Angular applications
    within an Nx monorepo. We start by learning how to lint projects inside your Nx
    monorepo. Next, we will explore different configurations for the linting process
    and how to apply them. Once you know how and why to lint your projects before
    you create a build, we will learn about building projects inside the Nx monorepo.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we’ll explore how Nx enhances the build process by leveraging advanced
    caching and parallel task execution to optimize build times. Nx’s incremental
    builds significantly reduce the build times for large and complex projects, ensuring
    that only necessary parts of the application are rebuilt. The incremental builds
    and Nx cache will speed up your CI/CD pipelines and the overall deployment process.
    Let’s start at the beginning and learn about linting projects inside your Nx monorepo.
  prefs: []
  type: TYPE_NORMAL
- en: Linting Nx projects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Linting** is a crucial step in the software development process. It involves
    analyzing your code for potential errors, enforcing coding standards, and maintaining
    code quality. Linting helps catch issues early in the development cycle, reducing
    the likelihood of bugs and ensuring that your code base adheres to best practices.'
  prefs: []
  type: TYPE_NORMAL
- en: Linting improves the maintainability and readability of your code and enhances
    collaboration within your team by providing a consistent coding style. We already
    talked about linting in [*Chapter 1*](B21625_01.xhtml#_idTextAnchor014). Depending
    on your setup, you will be notified about linting errors during your development
    process by ESLint. Still, it’s important to always run the linting process in
    your CI/CD pipelines before your code is merged or deployed. Running the linting
    process inside your CI/CD pipelines ensures code that doesn’t adhere to your configured
    guidelines is not merged. By integrating linting into your pipelines, you can
    ensure that your projects are robust, reliable, and ready for production, leading
    to more efficient and error-free builds.
  prefs: []
  type: TYPE_NORMAL
- en: As with all other tasks such as testing and building, you can perform linting
    using the Nx console or by running a terminal command.
  prefs: []
  type: TYPE_NORMAL
- en: Linting using the Nx console
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to lint a project using the Nx console, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the Nx logo on the left side of VS Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the project you wish to lint under the **PROJECTS** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hover over `lint`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click the play button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.1: Nx console lint](img/B21625_12_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.1: Nx console lint'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 12**.1* shows a visual representation of the Nx console and where to
    find the `lint` task. When you click the play button for the `lint` task, a terminal
    will open inside VS Code, where you can see the result of the linting process.
    In the case of the *finance-expenses-registration application*, the linting process
    will pass without any error or warning regarding your linting rules. There will
    be a warning for Nx Cloud, but this can be ignored because we aren’t using Nx
    Cloud. When using the Nx console, you can only lint your projects individually.
    Alternatively, with the Nx console, you can lint your projects using terminal
    commands.'
  prefs: []
  type: TYPE_NORMAL
- en: Linting using the terminal command
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can lint a single project by running the following terminal command at
    the root of your Nx monorepo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding terminal command, you need to replace `<project name>` with
    the name of the project you want to lint. This project name can be found inside
    the `project.json` file of the project you want to target. So, to lint the *finance-expenses-registration
    application*, you run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Running the linting process for a second time was a lot faster due to the Nx
    cache. Inside the terminal, you’ll find Nx read the output from the cache instead
    of running the command for 1 out of 1 tasks, indicating Nx took the linting output
    from the cache because it detected nothing changed since we last linted the project.
    When running the linting process for multiple projects, the Nx cache can significantly
    reduce the time needed for your linting to complete, greatly improving your development
    process and experience.
  prefs: []
  type: TYPE_NORMAL
- en: Linting multiple projects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the preceding examples, we’ve seen how to run linting for a single project,
    but in most cases, especially inside your CI/CD pipelines, you want to lint multiple
    projects. When you run linting in a CI pipeline (a pipeline you run before each
    code merge), you commonly wish to lint projects that are affected by the changes
    you’re about to merge; alternatively, when running a CD pipeline that deploys
    your system, you commonly run linting on all projects inside your monorepo or
    all projects related to the deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run linting for all projects affected by your changes, you can utilize the
    `nx affected` command. The terminal command is similar to the `affected` command
    we used when running tests for affected projects; you only change the target job
    from `test` to `lint`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding command, you use the `affected` keyword, add
    the `-t` flag, and define the target task you want to run. In this scenario, it
    is `lint`. After defining the task, we also need to configure the `–base` flag
    and provide it with the base branch to compare the changes with; commonly, this
    will be your main branch. Instead of manually defining the `–base` flag, you can
    also configure the `defaultBase` property inside your `nx.json` file. To configure
    your default base branch, add the following inside the root of your `nx.json`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: After adding the preceding code, you can run the `affected` command without
    providing the `–base` flag. Currently, if you run the `affected` command, you’ll
    notice all projects inside the monorepo are linted. All projects are linted because
    Nx doesn’t have an affected lint cached for your `defaultBase` property. Besides
    all projects being linted, you will also notice that the linting process fails
    for 4 out of 13 projects.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing linting errors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we continue, let’s fix the linting errors so that all linted projects
    succeed.
  prefs: []
  type: TYPE_NORMAL
- en: The --fix flag
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can manually go through all the errors in the terminal output and fix them
    one by one, but most linting errors are easy to fix, and the Nx linting process
    provides a way to solve all easy linting errors for you. Simply append the `–-fix`
    flag to your terminal command, and Nx will automatically fix the issues it can
    fix for you. To get the best result when using the `--fix` flag, you need to run
    the linting process for each project individually. So, let’s take the projects
    with linting errors and run them one by one with the `–-fix` flag appended to
    the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: After running the aforementioned commands, all your linting errors are fixed.
    You can now rerun the affected `lint` command, and the linting for all projects
    will succeed.
  prefs: []
  type: TYPE_NORMAL
- en: The fix option
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As you might imagine, running the linting command for each project with linting
    errors can become cumbersome, especially when your monorepo grows. Alternatively,
    you can configure the `fix` option inside the `project.json` file of individual
    projects. Inside the `project.json` file, you’ll find a `lint` section, and inside
    this section, you can add the `fix` option like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: After adding the preceding configuration to each project’s `project.json` file,
    you can simply run the `lint affected` command, and Nx will fix the linting issues
    it can for each project.
  prefs: []
  type: TYPE_NORMAL
- en: Other configurations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Besides the `--fix` flag and configuration, there are other useful configurations,
    such as allowing a maximum number of warnings before the linting process fails,
    outputting your lint results to a file, or passing the linting process even if
    there are linting errors. You can find all configurations in the official Nx documentation
    at the following URL: [https://nx.dev/nx-api/eslint/executors/lint](https://nx.dev/nx-api/eslint/executors/lint).'
  prefs: []
  type: TYPE_NORMAL
- en: Targeting multiple projects when running a linting command
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After looking into the remaining configuration options, I will briefly explain
    how you can target multiple projects simultaneously when running a linting command.
    You can use the `run-many` command to do this, similar to what we did in [*Chapter
    11*](B21625_11.xhtml#_idTextAnchor200) when testing multiple projects with a single
    command. You use the `run-many` command combined with the `-p` flag. The `run-many`
    command allows you to run tasks for many projects, whereas the `-p` flag will
    enable you to specify specific projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, you perform linting for `project1` and `project2`.
    Alternatively, you can run the linting process for projects with a specific tag
    by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding command, instead of defining project names,
    we defined the tag we wanted to target.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to lint specific projects and how to configure the linting
    process, let’s dive into the next topic: building your projects inside the Nx
    monorepo.'
  prefs: []
  type: TYPE_NORMAL
- en: Building your Angular libraries and applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To deploy your Angular projects, you need to create an application build. When
    you create an application build, the build process creates a bundle of code that
    your runtime can execute and run. In the case of Angular applications, the browser
    will be the runtime that interprets and runs the application code. So, to deploy
    the demo application we created, you first need to make an application build using
    the `nx` `build` command.
  prefs: []
  type: TYPE_NORMAL
- en: Behind the scenes of creating an application build
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before running the `nx build` command for our *expenses-registration application*,
    let’s examine in detail what happens when we run a `build` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`project.json` files of the projects you’re about to build. This is similar
    to the standard Angular CLI but with support for multiple projects in a monorepo,
    and Nx analyzes the `project.json` files instead of the `angular.json` file in
    a regular Angular project.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`project.json` file. If you configured file replacements for the build targets,
    Nx will replace the files before continuing the build process.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ngc`, to transpile TypeScript code into JavaScript, handling Angular decorators
    and templates.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Ahead-of-time (AOT) compilation**: As with the Angular CLI, Nx performs AOT
    compilation for production builds (unless configured differently), converting
    Angular templates and components into efficient JavaScript code that can be executed
    by the browser without the need to compile the code before it can be rendered.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Bundling phase**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Module resolution**: Nx uses the configured build tool for module resolution
    and creating a dependency graph, starting from the entry point(s).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tree shaking**: Nx performs tree shaking to remove unused code, reducing
    the final bundle size.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code splitting**: Nx splits different parts of your application into multiple
    JavaScript bundles that can be lazy loaded by the browser.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Asset optimization**: Nx optimizes CSS, HTML, images, and other assets, similar
    to the Angular CLI.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Minification** **and uglification**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**JavaScript minification**: Nx minifies JavaScript code to reduce file size.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Uglification**: Nx further obfuscates the JavaScript code.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hashing and** **cache busting**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**File hashing**: Nx appends hashes to filenames of generated bundles and assets
    for cache busting.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index.html` file, including references to the hashed JavaScript and CSS bundles.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`dist` folder or some other configured output path.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The preceding steps resemble the regular build flow when using the Angular CLI.
    Yet, Nx has some additional features such as affected builds, the `run-many` command,
    incremental builds, and caching, making it easier to create application builds
    for multiple projects inside a monorepo and speeding up build times. Now that
    you have a better grasp of what is happening when building your projects, let’s
    create an application build for the expense registration application.
  prefs: []
  type: TYPE_NORMAL
- en: Important notice!
  prefs: []
  type: TYPE_NORMAL
- en: The *expenses-registration application* we made is just a simple demo application
    and not really meant for production purposes. There are still plenty of improvements
    to make, pages to add, and code to clean up before you actually deploy the application.
    For demonstration purposes, we will be deploying the application to GitHub Pages,
    but it’s not meant to be used for anything other than demonstration purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Running the build command
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can run the `build` command for the *expenses-registration application*
    in the terminal or Nx console. As shown in *Figure 12**.2*, you can find the `build`
    command in the Nx console above the `lint` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2: Nx console build](img/B21625_12_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.2: Nx console build'
  prefs: []
  type: TYPE_NORMAL
- en: To run the `build` command, click the play button next to the `build` keyword
    in the Nx console. Nx configures the production build as your default; if you
    want to target another build configuration, you can expand `build` inside the
    Nx console to see all build configurations you have. You can then run a specific
    build configuration by clicking on the play button next to the name of the build
    configuration you want to run. For each project, Nx creates a production and development
    build configuration for you inside the `project.json` files. When needed, you
    can create additional build configurations; for example, when you have multiple
    staging environments such as test and acceptance that require a deviation from
    the production or development build.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Nx console is an extension for your code editor, and as such, it isn’t
    available inside your CI/CD pipelines. Because the Nx console isn’t available,
    you need to use the Nx CLI inside your pipelines to create application builds
    and perform other tasks such as building and testing your applications. The syntax
    for the `nx build` command is similar to the `test` and `lint` commands we used
    earlier; you only change the build target from `lint` or `test` to `build`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the aforementioned command, we type `nx` to target the Nx
    CLI, followed by the task we want to run, and lastly, add the project name of
    the project we want to target. Nx will use the default build configuration, which
    is production unless you change it. If you want to target a different build configuration,
    you can add the `–-configuration` flag to the `build` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'By adding the preceding flag at the end of your CLI command, you’ll use the
    `development` build configuration instead of the production configuration. Alternatively,
    you can use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command runs the production build for the `finance-expenses-registration`
    project. As we’ve seen with the `lint` and `test` commands, you can also use `affected`
    and `run-many` to build multiple projects or projects affected by your changes.
    Now that you know how to run `build` commands using the Nx console and the Nx
    CLI, go ahead and run the production build for the `finance-expenses-registration`
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing failing builds
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After running the production build for the `finance-expenses-registration`
    project, you’ll notice Nx tries to build the `finance-expenses-registration` project
    and all projects it depends on – in our case, three other libraries (`shared-ui-common-components`,
    `finance-data-access-expenses`, and `shared-util-form-validator`) – in our Nx
    monorepo. You’ll also notice that three out of four builds fail. The three failing
    builds are the three libraries, and they all have the same error: `''updateBuildableProjectDepsInPackageJson''
    is not found` `in schema`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix your builds, you need to remove the following configuration inside the
    `project.json` files of your libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'After removing the preceding configuration inside your `project.json` files,
    you can run the `build` command for the `finance-expenses-registration` project
    again, and your build process will now succeed. After the build is finished, you’ll
    notice a `dist` folder has been created in the root of your Nx monorepo. The build
    output for the `finance-expenses-registration` project and all dependent buildable
    projects are located inside this `dist` folder. The build output for the `finance-expenses-registration`
    project can be found at this path: `dist/apps/finance/expenses-registration`.'
  prefs: []
  type: TYPE_NORMAL
- en: When you deploy your application, you upload the output inside `dist/apps/finance/expenses-registration`
    to your hosting service. In the case of an Angular application, you can use a
    static hosting service such as GitHub Pages, Azure Blob Storage, Amazon **Simple
    Storage Service** (**S3**), or any other static website hosting service you prefer.
    If you are using Angular Universal and **server-side rendering** (**SSR**), you
    need a different hosting service, such as Azure App Service, but we will not cover
    that in this book.
  prefs: []
  type: TYPE_NORMAL
- en: In the last section of this chapter, we will use GitHub Actions to automatically
    deploy and host our demo application on GitHub Pages, but for now, let’s see how
    we can serve our production build locally on our machine using `http-server`.
  prefs: []
  type: TYPE_NORMAL
- en: Locally serving the production build
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To serve our production build, we need a server that can host our static files.
    There are many services out there that can do this, but we will be using `http-server`.
    To start, you need to install `http-server` on your machine using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: After installing `http-server`, you can use it to host the production build
    of your Angular application locally. If you don’t have staging environments such
    as test and acceptance, using something such as `http-server` allows you to test
    if your build works as expected before deploying it to your production environment;
    still, in a professional setting, I would always recommend using a testing and
    acceptance environment where you can test your application in an environment that
    mimics the production environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'To locally host your application using `http-server`, you need to run the following
    terminal command at the root of your Nx monorepo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: After running the preceding command, a server will be created, hosting the static
    files inside the `dist\apps\finance\expenses-registration` folder. Inside the
    terminal, you’ll find two URLs starting with your private IP addresses and ending
    with the `8080` port. You can visit either of these URLs inside your browser to
    see your application. When you visit the application in your browser, you’ll see
    the requests that are made by your application inside the terminal. You may notice
    that the `api/expenses` request is failing; the reason for the failing API request
    is that we don’t have a running API, and the mock API interceptor is disabled
    in a production build.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we disabled the mock data interceptor and we don’t have a running API,
    you don’t see any data inside the application when you visit it in the browser.
    For testing purposes, you can enable the mock interceptor for your production
    build by removing the following inside the `mock.interceptor.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: After removing the preceding code, the mock interceptor will also work for your
    production build. Create a new application build, serve the build using `http-server`,
    and revisit the application inside your browser (you probably need to remove the
    browser cache by opening the developer tools, right-clicking on the reload symbol
    in the browser, and selecting `api/expenses` request succeeds. Don’t forget to
    revert the changes inside the `mock.interceptor.ts` file, as this is just for
    testing purposes; in a real production application, you want to use a real API.
  prefs: []
  type: TYPE_NORMAL
- en: So, to summarize, you learned how to lint projects inside your Nx monorepo and
    how you can automatically fix basic lint errors by using the `–-fix` flag. You
    learned what happens behind the scenes when you create an application build for
    your Angular applications. You also learned how to run the `build` command for
    specific build configurations and where to find the output of your application
    build. Lastly, you hosted the build output locally using the `http-server` `npm`
    package. In the next section, you will learn how to analyze your application build
    so that you can easily identify which sections of your build can be worked on
    to reduce your bundle sizes.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing your build output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inside your build output, you’ll find different JavaScript files. Some of these
    files are your application bundles, which the browser will load to render the
    application for the end user. The size of these bundles directly impacts the performance
    of your application. JavaScript is slow to load for a browser, so the bigger your
    bundle size, the longer it takes for the browser to download the files, render
    something on the screen, and make the web page respond so that the user can interact
    with it.
  prefs: []
  type: TYPE_NORMAL
- en: To reduce your bundle sizes, you need an effective way to analyze your bundles.
    If you run the `build` command for the `finance-expenses-registration` project,
    you’ll see a small report inside the terminal
  prefs: []
  type: TYPE_NORMAL
- en: The build report inside your terminal includes a list of the created bundles
    and the size of each bundle. While this list gives you some indication of the
    size of your bundles, you don’t see what the bundles are made up of and where
    you can make some improvements to reduce the bundle sizes.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a tool named `npm` packages with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'After installing the package globally, you need to install it as a dev dependency
    inside your Nx monorepo. You add the Webpack Bundle Analyzer tool as a dev dependency
    by running the following command in the root of your Nx monorepo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the preceding `npm` commands, you can start using Webpack Bundle
    Analyzer. The first step is creating a new production build for your application
    and including a `–-stats-json` flag with the `build` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'By adding the `–-stats-json` flag, Webpack Bundle Analyzer will create a `stats.json`
    file inside the build output. The `stats.json` file is located inside the `dist\apps\finance\expenses-registration`
    folder, next to the rest of your application build. To inspect the `stats.json`
    file, you can run the following command at the root of your Nx monorepo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding command will give you a visual and detailed overview
    of your application bundles. The overview is opened in the browser and should
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3: Webpack Bundle Analyzer](img/B21625_12_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.3: Webpack Bundle Analyzer'
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 12**.3*, the Webpack Bundle Analyzer tool gives you a detailed
    and easy-to-read overview of your bundles and what is in each bundle. You can
    easily identify the large parts of each bundle so that you can see where you can
    make improvements. Because we have a simple application, there isn’t much to adjust,
    but you can, for instance, see that the `ngrx-store` and `transloco` bundles are
    one of the largest elements we’ve added to our project. If your bundle sizes are
    becoming too large, you can try to find replacements for large `npm` packages
    you import, only import small sub-modules if they are available, or move code
    and other resources to lazy-loaded modules so that the browser can first render
    the page and lazy load additional resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in *Figure 12**.3*, in the sidebar of Webpack Bundle Analyzer,
    you can control which bundles you show on the screen; this makes it easier to
    focus on specific bundles in your build output. Additionally, you can see the
    bundle sizes in three different formats – the **Stat**, **Parsed**, and **Gzipped**
    formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stat** is the largest; this indicates the raw size of your bundle without
    any compressions or optimizations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parsed** is the same size as shown in the build output report of your terminal.
    This is the size of your bundles after some optimizations and compressions are
    applied.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content-Encoding: Gzip` header, you know your hosting service enabled Gzipping
    for you; if the header is not included, you need to add Gzipping yourself. How
    to add Gzipping yourself falls out of the scope of this book. GitHub Pages will
    Gzip your Angular application for you.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To summarize, you now know how to analyze your application bundles effectively
    using Webpack Bundle Analyzer. If bundles are too large, you can try to move code
    to lazy-loaded modules and find replacements for large `npm` packages you import.
    You also learned that Gzipping your content significantly reduces your bundle
    sizes and that most modern hosting services handle Gzipping and the necessary
    configuration for you. In this book’s next and last section, we will use GitHub
    Actions to create a CI/CD process that automatically deploys our demo application
    to GitHub Pages.
  prefs: []
  type: TYPE_NORMAL
- en: Automatically deploying Angular applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this last section, you will learn how to automatically deploy Angular applications
    inside your Nx monorepo to GitHub Pages. You will set up a CI/CD pipeline using
    GitHub Actions that deploys the demo application we’ve created whenever you merge
    code to your main branch on GitHub. We will create a `.yml` file containing all
    the steps necessary for the deployment. Inside the `.yml` file, we will use the
    YAML language, which is commonly used to create configuration files for various
    DevOps tools and programs.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an access token
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you start creating a `.yml` file, you need to create an access token
    inside your GitHub account. GitHub needs to know you’re authenticated to deploy
    applications to GitHub Pages before it can perform the deployment. You provide
    the necessary authentication to GitHub, providing an access token to the deployment
    step inside your `.yml` file. So, the first thing you need to do is create an
    access token inside your GitHub account. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by clicking on your account icon in GitHub and select **Settings**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the profile settings page, you need to scroll down and select **Develop settings**
    on the left side of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, again on the left side of the screen, click on **Personal access tokens**
    and then select **Tokens (classic)** in the drop-down menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you need to click on the **Generate new token** button, and in the drop-down
    menu, you select **Generate new** **token (classic)**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After following *steps 1* to *4*, you should land on the page shown in *Figure
    12**.4*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.4: GitHub personal access token](img/B21625_12_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.4: GitHub personal access token'
  prefs: []
  type: TYPE_NORMAL
- en: Now, on the `GH_PAGES` under the `GH_PAGES` name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the **Expiration** field, select **No expiration**. In a real production
    environment, you might want an expiration date for security reasons, but this
    means you need to renew your token for the set expiration interval.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under the `gist`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After selecting the checkboxes under **Select scopes**, you can scroll down
    and select **Generate token**. After clicking on **Generate token**, you will
    see the key of your personal access token; it will look similar to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Copy the key to your access token and store it safely; you will need it in the
    next step of your automated deployment configuration.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After copying and saving your key, go to the GitHub repository where you stored
    the code you created during the course of this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, you need to navigate to the repository settings by clicking on **Settings**
    in your navigation items, as shown in *Figure 12**.5*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.5: GitHub repository settings](img/B21625_12_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.5: GitHub repository settings'
  prefs: []
  type: TYPE_NORMAL
- en: Now, on the left side of the screen under **Security**, click on **Secrets and
    variables**, and in the dropdown, click on **Actions**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This will bring you to the **Actions secrets and variables** page, as shown
    in *Figure 12**.6*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.6: Actions secrets and variables](img/B21625_12_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.6: Actions secrets and variables'
  prefs: []
  type: TYPE_NORMAL
- en: On the **Actions secrets and variables** page, you need to click on the **New
    repository** **secret** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you’ll be asked to provide a name and secret. Inside the `GH_PAGES` again,
    and in the **Secret** field, paste the key you saved from the personal access
    token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After entering the necessary values, click on the **Add secret** button to save
    your repository secret.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If successful, you should now see your `GH_PAGES` secret under the **Repository
    secrets** section on the **Actions secrets and** **variables** page.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a .yml file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you’ve created a personal access token and a repository secret, we
    can continue by creating a `.``yml` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a `.yml` file, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by clicking on **Actions** inside your repository navigation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, click on **Set up a** **workflow yourself**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This will bring you to a page as shown in *Figure 12**.7*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.7: main.yml](img/B21625_12_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.7: main.yml'
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 12**.7*, GitHub created an empty `main.yml` file for you
    inside the `.github/workflows` folder. You can directly edit the `main.yml` file
    in GitHub, alternatively, you can commit the file and edit it inside VS Code.
    For now, we will simply edit the file inside GitHub and start to add the necessary
    steps to deploy our demo application to GitHub Pages.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a trigger
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You start by adding a trigger to the `.yml` file. In our case, we want our
    `.yml` file to be triggered when we push changes to the main branch of our GitHub
    repository. You add this trigger by adding the following content to the `.``yml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet starts with a comment; next, we give a name to the
    step we’re declaring, then we use the `on:` keyword to indicate we’re defining
    a trigger, and underneath it, we define the configuration of our trigger – in
    this case, on push of the main branch. The indentation in `.yml` files is important,
    so make sure each line has an extra tab compared to the line above it.
  prefs: []
  type: TYPE_NORMAL
- en: Defining jobs to run and the related steps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After defining the trigger, you need to define jobs to run and the steps for
    the jobs you want to run.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we only have one job, which is a `build` job consisting of multiple
    steps. Start by defining `jobs` and `build` keywords, followed by defining the
    OS for the VM the build job will run on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Underneath the `runs-on` configuration of the build job, we will define the
    steps needed to perform the build job. The first step you need to perform is to
    check out the GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding snippet, the indentation for this step starts
    at the same place as the `runs-on` configuration. We start by defining a comment;
    next, we define a name for the step and what action the step uses. Lastly, we
    provide additional configurations for the step – in this case, `fetch-depth: 0`,
    which indicates the fetch history of all branches and tags inside your GitHub
    repository.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After fetching the GitHub repository, you need to install NodeJS on the Ubuntu
    machine with the following step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'After installing NodeJS, you need to install `node_modules`. To speed up the
    build job, we will use `pnpm` instead of `npm`. Simply add the following step
    to your `.yml` file to install `node_modules` for your Nx monorepo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step in our process will be linting all affected projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we added a new flag to the command we haven’t seen before.
    We’ve added the `–-no-cloud` flag to indicate we’re not using Nx Cloud; otherwise,
    your pipeline will fail by trying to connect with Nx Cloud. Next, we will add
    an extra step to unit test our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'For simplicity, we will skip `finance-expenses-registration` project. If you
    already fixed all unit tests within the monorepo, you can change the `.yml` file
    to run tests for all affected projects. After running the `lint` and `test` commands,
    we will build the `finance-expenses-registration` project with the following step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As you may have noticed, we added the `–-base-href` flag to the `build` command.
    We need to add a base `href` attribute because GitHub will deploy your application
    to `<GitHub account name>.github.io/<repository name>`. If you don’t use `Effective-Angular`
    as your repository name, you need to change the value of the `–-base-href` flag
    to your own repository name.
  prefs: []
  type: TYPE_NORMAL
- en: 'After building the repository, you need to initialize Git on the VM so that
    you can deploy it to GitHub Pages. Simply add the following step to your `.``yml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: After adding the preceding step, we can move to the last step inside our build
    job, this being the deployment of our application to GitHub Pages.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the application to GitHub Pages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will be using an `npm` package named `angular-cli-ghpages` to do the deployment
    of the application. Add the following step to your `.``yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code, we run a terminal command using `angular-cli-ghpages`
    to deploy the application, and we need to provide the `GH_PAGES` token we created
    earlier so that GitHub knows we have the necessary authorization to do the deployment.
    After adding the deployment step, you’ve added all steps needed to automatically
    deploy your demo application to GitHub Pages.
  prefs: []
  type: TYPE_NORMAL
- en: You can now click on the `.yml` file to your main branch, the `.yml` file will
    immediately be triggered. You can see this by navigating back to the **Actions**
    tab of your repository, and there you should see your running workflow. Unfortunately,
    the workflow currently fails.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing workflow fails
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The GitHub Actions workflow failed because of multiple reasons, so let’s fix
    the problems one by one. First, you need to install the `angular-cli-ghpages`
    packages inside your Nx monorepo. Simply run the following command to install
    the package in your monorepo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we use `pnpm` instead of `npm` in our GitHub Actions workflow. Because
    of this, we need to commit a `pnpm-lock.yaml` file to our GitHub repository. To
    generate this `pnpm-lock.yaml` file, start by globally installing `pnpm` with
    the following `npm` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'After installing `pnpm`, you can start using `pnpm` instead of `npm` for all
    `npm` commands you normally run. I would advise using `pnpm` as it’s a lot faster
    compared to `npm`. Now, to generate your `pnpm-lock.yaml` file, simply run the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The aforementioned command is similar to the `npm install` command, only using
    `pnpm` instead of `npm`. After running the `pnpm install` command, you can commit
    your changes and merge them with your main branch on GitHub to trigger the workflow
    again. As shown in *Figure 12**.8*, under the **Actions** tab of your repository,
    you should now see two workflow runs, and the second run should succeed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.8: GitHub Actions workflow runs](img/B21625_12_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.8: GitHub Actions workflow runs'
  prefs: []
  type: TYPE_NORMAL
- en: 'You now have a successful build, yet you still need to handle the deployment
    step. Go to your repository settings, and on the left side, click on **Pages**
    and add the configuration as shown in *Figure 12**.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.9: Build and deployment](img/B21625_12_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.9: Build and deployment'
  prefs: []
  type: TYPE_NORMAL
- en: After configuring the branch to `gh-pages`, as shown in *Figure 12**.9*, the
    deployment process will automatically start, and after a couple of minutes, you
    can find the URL of your application at the top of this GitHub page. Each time
    your workflow runs successfully, the deployment will now be done automatically.
    When you visit the demo application on the deployed URL, you’ll notice nothing
    but your navbar is shown, because the application is deployed on the `<GitHub
    account name>.github.io/<repository name>` URL, and we need to account for the
    repository name when fetching the language files inside our application, so there
    is one last fix to be made.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the `app.config.ts` file of the `finance-expenses-registration` project,
    and add the following provider at the top of your `providers` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, go to your `transloco-loader.ts` file and adjust it to contain the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we injected the `APP_BASE_HREF` injectable into the file and
    included the `baseHref` property into the URL used to fetch the translations.
    You can now push the changes and merge them with your main branch to trigger the
    workflow again. After your workflow run succeeds, you can click on **Deployments**,
    as shown in *Figure 12**.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.10: Deployments](img/B21625_12_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.10: Deployments'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you click on **Deployments**, as shown in *Figure 12**.10*, you’ll be
    navigated to a page where you can see all deployments of your application. On
    this same page, you’ll also find the URL of your deployed application and when
    it was last updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.11: Deployments list](img/B21625_12_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.11: Deployments list'
  prefs: []
  type: TYPE_NORMAL
- en: When your new deployment is ready, as shown in *Figure 12**.11*, you can navigate
    to your deployed application in the browser again, and now you should see a working
    application, including a table and translated values. There is no data inside
    the table because the mock interceptor is disabled for your production build,
    and there is no API your application can connect with. You now have everything
    in place, and your application is linted, tested, built, and deployed automatically
    each time you push changes to your main GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned before, this is just a demo application, and there are still plenty
    of improvements to make. So, if you want, you can add more pages, create separate
    library components for the table and other features you want to have, and create
    and convert the application into something truly suited for production purposes.
    You now have all the building blocks needed to effectively use Nx and the Angular
    framework to develop robust and scalable applications.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve reached the end of this book, and first of all, I want to thank you for
    reading the book and congratulate you on finishing it! You learned and did a lot
    during the course of this book. You created your own Nx monorepo, ready to scale
    to hundreds of Angular applications and libraries. You know how to configure the
    Nx monorepo to your personal needs and add the first libraries and applications
    inside your monorepo. After creating the monorepo and adding projects, you learned
    about built-in and custom Nx generators and how to use them to generate boilerplate
    code and bring consistency into your monorepo.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we moved on to Angular and learned about the latest developments of the
    framework, as well as how to utilize powerful features such as component communication,
    Angular routes, and **dependency injection** (**DI**). You learned about pipes,
    directives, and animation after exploring the framework’s newest and most powerful
    features. You saw how to create custom pipes and directives, learned about directive
    composition, and created reusable animation to make your application more appealing
    to the end user.
  prefs: []
  type: TYPE_NORMAL
- en: Further, we did a deep dive into the Angular `forms` module, learning about
    template-driven, reactive, and dynamic forms. Among other things, you learned
    about form validations, the form builder, error handling and creating dynamic
    forms, and form fields. After finishing with Angular forms, we returned to theoretical
    knowledge, exploring different best practices, conventions, and design patterns
    commonly used within Angular applications. You learned about some design patterns
    and best practices, setting you up for the next section of this book, which focused
    on reactive programming and state management. You also learned how to utilize
    RxJS and Signals to create reactive code. You learned about Observable streams,
    pipeable operators, and handling nested data streams. We converted code from RxJS
    to Signals to demonstrate the difference between the two and explained when to
    use which tool to reach the desired outcome. We also explored combining RxJS and
    Signals to get the best of both worlds. When we finished with the basics of RxJS
    and Signals, we used both tools to create a custom state management solution and
    connected it with the component layer of our application using a facade service.
    To finish our state management journey, we converted our custom state management
    solution to an implementation using NgRx, the Angular ecosystem’s most powerful
    and popular state management solution.
  prefs: []
  type: TYPE_NORMAL
- en: When we finished with reactive programming and state management, we moved on
    to the last section of this book. You learned how to develop applications accessible
    to people from all over the world and of all abilities. You used `transloco` to
    add localization and internationalization to your applications so that people
    of different countries and languages can use your application with their preferred
    formats and languages. Next, you created unit and e2e tests using Jest and Cypress.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we finished the book by creating an automated deployment process that
    uses GitHub Actions to deploy your application to GitHub Pages. After finishing
    this book, you will have all the knowledge needed to develop robust and scalable
    Angular applications using Nx and the latest Angular techniques. You can continue
    with the demo application we created by adding more pages, abstracting the table
    into its own component, creating a feature component for the expenses registration
    so that the page only has to declare one component, adding new features such as
    grouping expenses, planning expenses, uploading receipts, and whatever you seem
    fit. You can also start creating multiple applications within the Nx monorepo
    or start from scratch with your own project. Whatever you want to develop, you
    now have the tools and knowledge to effectively use Angular for applications of
    any scale.
  prefs: []
  type: TYPE_NORMAL
