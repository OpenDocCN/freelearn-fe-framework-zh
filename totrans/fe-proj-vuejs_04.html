<html><head></head><body>
		<div>
			<div id="_idContainer127" class="Content">
			</div>
		</div>
		<div id="_idContainer128" class="Content">
			<h1 id="_idParaDest-81"><a id="_idTextAnchor128"/>4. Nesting Components (Modularity) </h1>
		</div>
		<div id="_idContainer162" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">In this chapter, you will discover how to modularize a Vue.js application using component hierarchies and nesting. This chapter introduces concepts such as props, events, prop validation, and slots. You will learn how to contrast them and identify which concept should be applied based on the situation. You will then practice implementing a component that encapsulates direct DOM manipulation using refs. You will also learn how to identify component composition scenarios where slots, named slots, and scoped slots can be used. You will then identify when to abstract functionality into filters.</p>
			<p class="callout">By the end of this chapter, you will be able to define communication interfaces between components using props, events, and validators. You will be exposed to refs to wrap JavaScript libraries as Vue.js components and identify the pitfalls of the Vue.js context when using components.</p>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor129"/>Introduction</h1>
			<p>In the previous chapter, we learned how to initialize, build, and debug a simple Vue.js application. In this chapter, we will have a closer look at how to leverage component composition to enable code re-usability.</p>
			<p>Reusable and extensible components are core to building products around a component library. A component library allows a team to build a project with high velocity and high consistency.</p>
			<p>If a component library in Vue.js does not expose the right extension points, what often happens is that the component from the library is copied over into the application's code base. This leads to duplicated code and reduced cohesion from a design point of view.</p>
			<p>In <em class="italic">Chapter 3</em>, <em class="italic">Vue CLI</em>, we learned how to create simple components in Vue. Components are Vue instances that can be instantiated and rendered multiple times. Since there can only be one root component, most components in an application are rendered by another component. For parent components to communicate with their children, we use props and prop passing.</p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor130"/>Passing Props</h1>
			<p><strong class="bold">Props</strong> in the context of Vue.js are fields, defined in a child component, that are accessible on that component's instance (<strong class="source-inline">this</strong>) and in the component's <strong class="source-inline">template</strong>.</p>
			<p>The value of a prop depends on what the parent passes in its <strong class="source-inline">template</strong> to the child component at render time.</p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor131"/>Defining a Simple Component That Takes Props</h2>
			<p>Let's look at a simple <strong class="source-inline">Hello</strong> single-file component. This can be found in a <strong class="source-inline">./src/components/Hello.vue</strong> file (in a <em class="italic">Vue CLI-generated</em> project). Note how the <strong class="source-inline">who</strong> value is set in the <strong class="source-inline">props</strong> array and that it is interpolated as a value using <strong class="source-inline">{{ who }}</strong>. The <strong class="source-inline">props</strong> property of a Vue.js component can be an array of strings or an object literal.</p>
			<p>When a value is defined in <strong class="source-inline">props</strong>, it is then accessible as an instance variable in the <strong class="source-inline">template</strong> section of the Vue.js component:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div&gt;</p>
			<p class="source-code">    &lt;h1&gt;Hello {{ who }}&lt;/h1&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  props: ['who']</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>We will now learn how to render a component using props.</p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor132"/>Rendering a Component with Props </h2>
			<p>What follows is a demonstration of how to use the <strong class="source-inline">Hello</strong> component in our Vue.js application.</p>
			<p>First, we need to import and then set it in the <strong class="source-inline">components</strong> property of the Vue.js component that wants to render this imported component.</p>
			<p>Then, in the <strong class="source-inline">template</strong> section, we need to render <strong class="source-inline">&lt;Hello&gt;</strong> with the <strong class="source-inline">who</strong> attribute set to <strong class="source-inline">"Vue.js"</strong>, as follows:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div id="app"&gt;</p>
			<p class="source-code">    &lt;Hello who="Vue.js"/&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">import Hello from './components/Hello.vue'</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  components: {</p>
			<p class="source-code">    Hello</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>This will render the following on the page:</p>
			<p class="source-code">Hello Vue.js</p>
			<p>We have now seen how to use a component and pass it with props in a Vue.js application. This is useful for code reuse and for abstracting application behavior into component-sized chunks.</p>
			<p>Next, we will learn how to work with registered components.</p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor133"/>Component Registration Tricks </h2>
			<p>There are a few things to note with regard to the <strong class="source-inline">components</strong> property.</p>
			<p>Registered components are available both as <strong class="source-inline">CamelCaseName</strong> and as <strong class="source-inline">kebab-case-name</strong>, so if we changed the template section shown in the previous example to use <strong class="source-inline">&lt;hello /&gt;</strong> instead of <strong class="source-inline">&lt;Hello /&gt;</strong>, it would work without any issues:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div id="app"&gt;</p>
			<p class="source-code">    &lt;hello who="Vue.js"/&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p>The updated template renders the same in the browser, as shown in the following output:</p>
			<p class="source-code">Hello Vue.js</p>
			<p>The <strong class="source-inline">components</strong> property tends to leverage ES6 shorthand property syntax. Shorthand property syntax means that instead of writing <strong class="source-inline">{ Hello: Hello }</strong>, we can write <strong class="source-inline">{ Hello }</strong>. We can see it in action in the following example, which registers the <strong class="source-inline">Hello</strong> component:</p>
			<p class="source-code">import Hello from './components/Hello.vue'</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  components: {</p>
			<p class="source-code">    Hello</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>Vue's <strong class="source-inline">components</strong> declaration is not aware of the component name. It uses the key in the <strong class="source-inline">components</strong> object to register it against both the camelCase and kebab-case names:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div id="app"&gt;</p>
			<p class="source-code">    &lt;Hey who="Vue.js"/&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">import Hello from './components/Hello.vue'</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  components: {</p>
			<p class="source-code">  Hey: Hello</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>The preceding code will generate the following output:</p>
			<p class="source-code">Hello Vue.js</p>
			<p><a id="_idTextAnchor134"/>We have now learned how to register components in Vue.js using the <strong class="source-inline">components</strong> property and ES6 shorthand object property syntax.</p>
			<p>Next, we will look at a practical example of a <strong class="source-inline">Greeting</strong> component.</p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor135"/>Exercise 4.01: Implementing a Greeting Component</h2>
			<p>Using our knowledge of how props can be passed from a parent component to a child component, we will create a component that lets you customize both the greeting (for example, <strong class="source-inline">Hello</strong>, <strong class="source-inline">Hey</strong>, or <strong class="source-inline">Hola</strong>) and who is addressed (for example, <strong class="source-inline">World</strong>, <strong class="source-inline">Vue.js</strong>, or <strong class="source-inline">JavaScript developers</strong>).</p>
			<p>To access the code files for this exercise, refer to <a href="https://packt.live/35jGd7B">https://packt.live/35jGd7B</a>.</p>
			<p>Follow these steps to complete this exercise:</p>
			<ol>
				<li value="1">Create a new file named <strong class="source-inline">Greeting.vue</strong> in the <strong class="source-inline">./src/components</strong> directory. This will be our single-file component.</li>
				<li>Start by scaffolding the component with empty <strong class="source-inline">template</strong> and <strong class="source-inline">script</strong> tags:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div&gt;Empty&lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">export default {}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>Next, we need to tell Vue.js that our component expects props. For this, we will add a <strong class="source-inline">props</strong> property to our component definition (the object that's set to <strong class="source-inline">export default</strong> in the <strong class="source-inline">script</strong> section) and add a <strong class="source-inline">greeting</strong> and <strong class="source-inline">who</strong> prop to it:<p class="source-code">export default {</p><p class="source-code">  props: ['greeting', 'who']</p><p class="source-code">}</p></li>
				<li>Now, we want to render <strong class="source-inline">greeting</strong> and <strong class="source-inline">who</strong>. As we have seen, when values are defined in <strong class="source-inline">props</strong>, they are available at the top level of <strong class="source-inline">template</strong>:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div&gt;{{ greeting }} {{ who }}&lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p>We can now render the <strong class="source-inline">Greeting</strong> component from <strong class="source-inline">App.vue</strong>.</p></li>
				<li>Open the <strong class="source-inline">src/App.vue</strong> file and import the <strong class="source-inline">Greeting</strong> component from <strong class="source-inline">./src/components/Greeting.vue</strong> into the <strong class="source-inline">script</strong> section:<p class="source-code">&lt;script&gt;</p><p class="source-code">import Greeting from './components/Greeting.vue'</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>Next, register the <strong class="source-inline">Greeting</strong> component in <strong class="source-inline">components</strong>:<p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  components: {</p><p class="source-code">    Greeting</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>Now that the component has been registered, we can render it in <strong class="source-inline">template</strong>:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div id="app"&gt;</p><p class="source-code">    &lt;Greeting greeting="Hey" who="JavaScript"/&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p>You will see the following in your browser (make sure you have run <strong class="source-inline">npm install</strong> and <strong class="source-inline">npm run serve</strong> in the <strong class="source-inline">Exercise4.01</strong> directory):</p><p class="source-code">Hey JavaScript</p></li>
				<li>Modify the <strong class="source-inline">greeting</strong> and <strong class="source-inline">who</strong> prop using the attribute values in <strong class="source-inline">template</strong>:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div id="app"&gt;</p><p class="source-code">    &lt;Greeting greeting="Hi" who="Everyone"/&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p>Upon running the preceding code, you should see an output similar to the following in your browser (make sure you have run <strong class="source-inline">npm install</strong>, followed by <strong class="source-inline">npm run serve</strong>, in the <strong class="source-inline">Exercise4.01</strong> directory):</p><p class="callout-heading">Note</p><p class="callout">Yarn includes an equivalent of <strong class="source-inline">npm run</strong> command under <strong class="source-inline">yarn</strong>. For example, instead of <strong class="source-inline">npm install</strong> and <strong class="source-inline">npm run serve</strong>, we could use <strong class="source-inline">yarn install</strong> and <strong class="source-inline">yarn serve</strong> commands respectively.</p><p class="source-code">Hi Everyone</p></li>
			</ol>
			<p>In this exercise, we have learned how props and prop passing can be used to increase reuse scenarios of a component by generalizing it. Instead of the component rendering static data, its parent passes it the data to render.</p>
			<p>In the next section, we will learn how to set prop values dynamically.</p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor136"/>Dynamic Props with Data Binding </h2>
			<p>The examples we have seen up to now have used hard-coded attribute values as props. But what if we want to pass parent instance data from the parent to child?</p>
			<p>This is where <strong class="bold">binding</strong> comes in. The prop/attribute binding syntax in Vue.js is <strong class="source-inline">v-bind:</strong>, but you can use <strong class="source-inline">:</strong> for shorthand; they are equivalent.</p>
			<p>The <strong class="source-inline">who</strong> prop of <strong class="source-inline">Greeting</strong> is bound to the <strong class="source-inline">appWho</strong> app component's instance property:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div id="app"&gt;</p>
			<p class="source-code">    &lt;Hello v-bind:who="appWho"/&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">import Hello from './components/Hello.vue'</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  components: {</p>
			<p class="source-code">    Hello</p>
			<p class="source-code">  },</p>
			<p class="source-code">  data() {</p>
			<p class="source-code">    return {</p>
			<p class="source-code">      appWho: 'Vue.js'</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>In shorthand, <strong class="source-inline">template</strong> would look as follows:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div id="app"&gt;</p>
			<p class="source-code">    &lt;Hello :who="appWho"/&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p>Both versions will output the following view to the browser:</p>
			<p class="source-code">Hello Vue.js</p>
			<p class="callout-heading">Note</p>
			<p class="callout"><strong class="source-inline">v-bind:prop-name</strong> and <strong class="source-inline">:prop-name</strong> have a striking similarity since the delimiter between <strong class="source-inline">v-bind</strong> and <strong class="source-inline">prop-name</strong> is <strong class="source-inline">:</strong> (a semicolon). In Vue.js single-file components, since templates are compiled at build time, they are functionally equivalent.</p>
			<p>An example to showcase that the values have been <strong class="bold">synced</strong> (propagated) from the parent component (<strong class="source-inline">App</strong>) to the child (<strong class="source-inline">Hello</strong>) is as follows, with two buttons that change the audience of the <strong class="source-inline">Hello</strong> message.</p>
			<p>The buttons call a component method called <strong class="source-inline">setWho</strong> with <strong class="bold">JavaScript</strong> or <strong class="bold">Everyone</strong>, depending on the button. This <strong class="source-inline">setWho</strong> function updates the <strong class="source-inline">appWho</strong> instance property:</p>
			<p class="source-code">&lt;template&gt; </p>
			<p class="source-code">  &lt;div id="app"&gt;</p>
			<p class="source-code">    &lt;Hello :who="appWho"/&gt;</p>
			<p class="source-code">    &lt;button @click="setWho('JavaScript')"&gt;JavaScript&lt;/button&gt;</p>
			<p class="source-code">    &lt;button @click="setWho('Everyone')"&gt;Everyone&lt;/button&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">import Hello from './components/Hello.vue'</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  components: {</p>
			<p class="source-code">    Hello</p>
			<p class="source-code">  },</p>
			<p class="source-code">  data() {</p>
			<p class="source-code">    return {</p>
			<p class="source-code">      appWho: 'Vue.js'</p>
			<p class="source-code">    }</p>
			<p class="source-code">  },</p>
			<p class="source-code">  methods: {</p>
			<p class="source-code">    setWho(newWho) {</p>
			<p class="source-code">      this.appWho = newWho</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>The initial output to the browser displays <strong class="source-inline">Hello Vue.js</strong>, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer129" class="IMG---Figure">
					<img src="image/B15218_04_01.jpg" alt="Figure 4.1: Initial Hello Vue.js output in the browser&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.1: Initial Hello Vue.js output in the browser</p>
			<p>When clicking the <strong class="source-inline">JavaScript </strong>button, the <strong class="source-inline">appWho</strong> variable updates, as does the bound <strong class="source-inline">Hello</strong> component's <strong class="source-inline">who</strong> prop. Thus, <strong class="source-inline">Hello JavaScript</strong> is displayed, as follows:</p>
			<div>
				<div id="_idContainer130" class="IMG---Figure">
					<img src="image/B15218_04_02.jpg" alt="Figure 4.2: Hello JavaScript after clicking the JavaScript button&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.2: Hello JavaScript after clicking the JavaScript button</p>
			<p>When clicking the <strong class="source-inline">Everyone</strong> button, the <strong class="source-inline">appWho</strong> variable updates, as does the bound <strong class="source-inline">Hello</strong> component's <strong class="source-inline">who</strong> prop. Thus, <strong class="source-inline">Hello Everyone</strong> is displayed, as follows:</p>
			<div>
				<div id="_idContainer131" class="IMG---Figure">
					<img src="image/B15218_04_03.jpg" alt="Figure 4.3: Hello Everyone after clicking the Everyone button&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.3: Hello Everyone after clicking the Everyone button</p>
			<p>We have now seen how to bind props to values so that they are kept in sync. </p>
			<p>The majority of Vue.js applications leverage components beyond modularizing the rendered components (as we did with the <strong class="source-inline">Greeting</strong> and <strong class="source-inline">Hello</strong> components).</p>
			<p>As we have seen, we are able to bind props so that any update that's made to a value in the parent will cause an update in the child component.</p>
			<h2 id="_idParaDest-89">Exe<a id="_idTextAnchor137"/>rcise 4.02: Passing Props That Change Over Time </h2>
			<p>To know which greeting to use, we will implement a <strong class="bold">greeter</strong> app that has multiple greetings and cycles through them.</p>
			<p>To access the code files for this exercise, refer to <a href="https://packt.live/3kovKfo">https://packt.live/3kovKfo</a>.</p>
			<p>Follow these steps to complete this exercise:</p>
			<ol>
				<li value="1">Create a <strong class="source-inline">./src/components/Greeting.vue</strong> component and initialize it with our previously implemented <strong class="source-inline">Greeting</strong> component. This is how we'll display the greetings:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div&gt;{{ greeting }} {{ who }}&lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  props: ['greeting', 'who']</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>In the <strong class="source-inline">./src/App.vue</strong> component, import <strong class="source-inline">./src/components/Greeting.vue</strong> as a <strong class="source-inline">Greeting</strong> and register it as a component so that you can render it:<p class="source-code">&lt;script&gt;</p><p class="source-code">import Greeting from './components/Greeting.vue'</p><p class="source-code">export default {</p><p class="source-code">  components: {</p><p class="source-code">    Greeting</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>In the <strong class="source-inline">script</strong> section, create a <strong class="source-inline">data</strong> top-level method that returns an initial <strong class="source-inline">greeting</strong> and <strong class="source-inline">who</strong>:<p class="source-code">export default {</p><p class="source-code">  data() {</p><p class="source-code">    return {</p><p class="source-code">      greeting: 'Hello',</p><p class="source-code">      who: 'Vue.js'</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>Render the current <strong class="source-inline">greeting</strong> and <strong class="source-inline">who</strong> using the <strong class="source-inline">Greeting</strong> component:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div id="app"&gt;</p><p class="source-code">    &lt;Greeting :greeting="greeting" :who="who"/&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p>Your browser will display a message, as follows (make sure you have run <strong class="source-inline">npm install</strong> and <strong class="source-inline">npm run serve</strong> in the <strong class="source-inline">Exercise4.02</strong> directory):</p><p class="callout-heading">Note</p><p class="callout">The following code requires that you have knowledge of computed properties, which we covered in <em class="italic">Chapter 2</em>, <em class="italic">Working with Data</em>. Please go back to that chapter now if you need a refresher.</p></li>
				<li>We will now add some <strong class="source-inline">greeting/who</strong> pairings as an array to the <strong class="source-inline">script</strong> section:<p class="source-code">&lt;script&gt;</p><p class="source-code">// imports</p><p class="source-code">const possibleGreetings = [</p><p class="source-code">    { greeting: 'Hello', who: 'Vue.js' },</p><p class="source-code">    { greeting: 'Hey', who: 'Everyone' },</p><p class="source-code">    { greeting: 'Hi', who: 'JavaScript' }</p><p class="source-code">]</p><p class="source-code">// components export</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>Let's refactor the <strong class="source-inline">data</strong> method so that it only stores the default index and creates computed properties that look up the index to generate a <strong class="source-inline">greeting</strong> and <strong class="source-inline">who</strong> based on the current index (with an intermediary <strong class="source-inline">currentGreeting</strong> computed property):<p class="source-code">&lt;script&gt;</p><p class="source-code">// imports and greetings</p><p class="source-code">export default {</p><p class="source-code">  // components definition</p><p class="source-code">  data() {</p><p class="source-code">    return {</p><p class="source-code">      currentIndex: 0</p><p class="source-code">    }</p><p class="source-code">  },</p><p class="source-code">  computed: {</p><p class="source-code">    currentGreeting() {</p><p class="source-code">      return possibleGreetings[this.currentIndex]</p><p class="source-code">    },</p><p class="source-code">    greeting() {</p><p class="source-code">      return this.currentGreeting.greeting</p><p class="source-code">    },</p><p class="source-code">    who() {</p><p class="source-code">      return this.currentGreeting.who</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p><p>At this point, the application should still display the same greeting in the browser, as shown in the following output:</p><p class="source-code">Hello Vue.js</p><p class="callout-heading">Note</p><p class="callout">As computed properties clean the code up, we did not need to update our template. Instead, we have replaced the <strong class="source-inline">greeting</strong> and <strong class="source-inline">who</strong> instance properties with computed properties of the same name.</p></li>
				<li>Let's add a way to cycle through these <strong class="source-inline">greetings</strong>. This will involve a button that, upon being clicked, will call a <strong class="source-inline">newGreeting</strong> function in our <strong class="source-inline">template</strong>:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div id="app"&gt;</p><p class="source-code">    &lt;Greeting :greeting="greeting" :who="who"/&gt;</p><p class="source-code">    &lt;button @click="newGreeting()"&gt;New Greeting&lt;/button&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p></li>
				<li>Next, we need to implement <strong class="source-inline">newGreeting</strong> in <strong class="source-inline">script</strong>. <strong class="source-inline">newGreeting</strong> should move to the next greeting (by incrementing <strong class="source-inline">currentIndex</strong>). Alternatively, if we have already reached the end of the <strong class="source-inline">possibleGreetings</strong> array, it should reset <strong class="source-inline">currentIndex</strong>:<p class="source-code">&lt;script&gt;</p><p class="source-code">  // imports and greetings</p><p class="source-code">export default {</p><p class="source-code">    // other component properties</p><p class="source-code">  methods: {</p><p class="source-code">    newGreeting() {</p><p class="source-code">      this.currentIndex = this.currentIndex ===         possibleGreetings.length – 1</p><p class="source-code">        ? 0</p><p class="source-code">        : this.currentIndex + 1</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p><p>On initial load and after <strong class="source-inline">3n</strong> clicks of the <strong class="source-inline">New Greeting</strong> button, the application displays <strong class="source-inline">Hello Vue.js</strong>, as shown in the following screenshot:</p><div id="_idContainer132" class="IMG---Figure"><img src="image/B15218_04_04.jpg" alt="Figure 4.4: Hello Vue.js after 3n button clicks&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 4.4: Hello Vue.js after 3n button clicks</p>
			<p>After the first click and after <strong class="source-inline">3n + 1</strong> clicks of the <strong class="source-inline">New Greeting</strong> button, the application displays <strong class="source-inline">Hey Everyone</strong>, as follows:</p>
			<div>
				<div id="_idContainer133" class="IMG---Figure">
					<img src="image/B15218_04_05.jpg" alt="Figure 4.5: Hey Everyone after 3n + 1 button clicks&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.5: Hey Everyone after 3n + 1 button clicks</p>
			<p>After the second click and after <strong class="source-inline">3n + 2</strong> clicks of the <strong class="source-inline">New Greeting</strong> button, the application displays <strong class="source-inline">Hi JavaScript</strong>, as follows:</p>
			<div>
				<div id="_idContainer134" class="IMG---Figure">
					<img src="image/B15218_04_06.jpg" alt="Figure 4.6: Hi JavaScript after 3n + 2 button clicks&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.6: Hi JavaScript after 3n + 2 button clicks</p>
			<p class="callout-heading">Note</p>
			<p class="callout">This code can be improved further; for example, <strong class="source-inline">possibleGreetings.length - 1</strong> is constant since we never add or remove greetings. Instead of computing on every <strong class="source-inline">newGreeting</strong> call, we could compute it once, outside of the <strong class="source-inline">newGreeting</strong> method. Reading the length of an array and simple arithmetic (<strong class="source-inline">-1</strong>) is not too costly but this is a good refresher on thinking in terms of mutable versus constant values.</p>
			<p>With that, we have seen how props and prop binding can be used to communicate about changing data from parent components to child components they render. To scale a code base or share code widely, it is helpful to give hints to the consumer of the code when they are using it incorrectly.</p>
			<p>Next, we will learn how to add type hints to our component's props to ensure they are used correctly.</p>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor138"/>Prop Typing and Validation</h1>
			<p><strong class="bold">Props</strong> define the interface of Vue.js components. As JavaScript is a dynamically typed language, Vue.js provides a tool we can use to validate the shape and types of props.</p>
			<p>To validate prop types, the <strong class="source-inline">props</strong> component property in its object literal form should be used (as opposed to the simpler array form).</p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor139"/>Primitive Prop Validation </h2>
			<p>Say we want a <strong class="source-inline">Repeat.vue</strong> component that takes a <strong class="source-inline">times</strong> prop, as well as a <strong class="source-inline">content</strong> prop. We can define the following:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div&gt;</p>
			<p class="source-code">    &lt;span v-for="r in repetitions" :key="r"&gt;</p>
			<p class="source-code">      {{ content }}</p>
			<p class="source-code">    &lt;/span&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  props: ['times', 'content'],</p>
			<p class="source-code">  computed: {</p>
			<p class="source-code">    repetitions() {</p>
			<p class="source-code">      return Array.from({ length: this.times });</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>Our <strong class="source-inline">Repeat</strong> component would be consumed as follows:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div id="app"&gt;</p>
			<p class="source-code">    &lt;Repeat :times="count" content="Repeat." /&gt;</p>
			<p class="source-code">    &lt;button @click="increment()"&gt;Repeat&lt;/button&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">import Repeat from './components/Repeat.vue'</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  components: {</p>
			<p class="source-code">    Repeat</p>
			<p class="source-code">  },</p>
			<p class="source-code">  data() {</p>
			<p class="source-code">    return { count: 1 }</p>
			<p class="source-code">  },</p>
			<p class="source-code">  methods: {</p>
			<p class="source-code">    increment() {</p>
			<p class="source-code">      this.count += 1</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>The preceding code will lead to the following output in the browser:</p>
			<div>
				<div id="_idContainer135" class="IMG---Figure">
					<img src="image/B15218_04_07.jpg" alt="Figure 4.7: Output of the repeat example in action (no clicks)&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.7: Output of the repeat example in action (no clicks)</p>
			<p>After clicking the <strong class="source-inline">Repeat</strong> button a few times, the <strong class="source-inline">Repeat</strong> component will repeat an additional time for every click generating an output, as follows:</p>
			<div>
				<div id="_idContainer136" class="IMG---Figure">
					<img src="image/B15218_04_08.jpg" alt="Figure 4.8: Output of the repeat example after five clicks&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.8: Output of the repeat example after five clicks</p>
			<p>For this component to work properly, we need <strong class="source-inline">times</strong> to be a <strong class="source-inline">Number</strong>, and ideally <strong class="source-inline">content</strong> to be a <strong class="source-inline">String</strong>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Now is a good time to remind students of the JavaScript primitive types: <strong class="source-inline">String</strong>, <strong class="source-inline">Number</strong>,<strong class="source-inline"> Boolean</strong>, <strong class="source-inline">Array</strong>, <strong class="source-inline">Object</strong>, <strong class="source-inline">Date</strong>, <strong class="source-inline">Function</strong>, and <strong class="source-inline">Symbol</strong>.</p>
			<p>Vue.js supports all the JavaScript primitive type constructors as type hints in the <strong class="source-inline">props</strong> field.</p>
			<p>In this instance, we are defining the <strong class="source-inline">times</strong> prop as a <strong class="source-inline">Number</strong> and the <strong class="source-inline">content</strong> props as a <strong class="source-inline">String</strong>:</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  props: {</p>
			<p class="source-code">    times: {</p>
			<p class="source-code">      type: Number</p>
			<p class="source-code">    },</p>
			<p class="source-code">    content: {</p>
			<p class="source-code">      type: String</p>
			<p class="source-code">    }</p>
			<p class="source-code">  },</p>
			<p class="source-code">  // rest of component definition</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>To consume this component, we can update the <strong class="source-inline">script</strong> section as follows:</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">import Repeat from './components/RepeatTyped.vue'</p>
			<p class="source-code">// no other changes</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>The component still behaves the same in the <strong class="bold">happy path</strong> case, where the props being passed for <strong class="source-inline">times</strong> and <strong class="source-inline">content</strong> are a <strong class="source-inline">Number</strong> and a <strong class="source-inline">String</strong>, respectively.</p>
			<p>If we update <strong class="source-inline">App</strong> so that it wilfully passes props of the wrong type. In this case, <strong class="source-inline">times</strong> is a <strong class="source-inline">String</strong> and <strong class="source-inline">content</strong> is a <strong class="source-inline">Number</strong>.</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div id="app"&gt;</p>
			<p class="source-code">    &lt;Repeat :times="count" :content="55" /&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">// no changes to imports</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  data() {</p>
			<p class="source-code">    return { count: 'no-number-here' }</p>
			<p class="source-code">  },</p>
			<p class="source-code">  // other properties</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>Here, the <strong class="source-inline">Repeat</strong> component will fail to render, and the following errors will be logged to the console:</p>
			<div>
				<div id="_idContainer137" class="IMG---Figure">
					<img src="image/B15218_04_09.jpg" alt="Figure 4.9: Mistyping Vue.js prop errors&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.9: Mistyping Vue.js prop errors</p>
			<p>The <strong class="source-inline">times</strong> prop check fails with a message that explains that we passed a <strong class="source-inline">String</strong> as a prop that was supposed to be a <strong class="source-inline">Number</strong>: </p>
			<p class="source-code">Invalid prop: type check failed for prop "times". Expected Number with value NaN, got String with value "no-number-here"</p>
			<p>The <strong class="source-inline">content</strong> prop check fails with a message that explains that we passed a <strong class="source-inline">Number</strong> as a prop that was supposed to be a <strong class="source-inline">String</strong>:</p>
			<p class="source-code">Invalid prop: type check failed for prop "content". Expected String with value "55", got Number with value 55</p>
			<p class="callout-heading">Note</p>
			<p class="callout">As per the Vue.js documentation, <em class="italic">null and undefined values will pass any type validation</em>, which means that the type validations are not foolproof and that it can make sense to add custom validation to a component.</p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor140"/>Union and Custom Prop Types </h2>
			<p>In the previous example, we were just rendering the content, so it didn't matter what type it was.</p>
			<p>Vue.js supports union types. A union type is a type that can be one of many other types. For example, <strong class="source-inline">String</strong> or <strong class="source-inline">Number</strong> is a <strong class="source-inline">union</strong> type.</p>
			<p>Union types in Vue.js are represented using an array for the prop's <strong class="source-inline">type</strong> property, for example, to support numbers and strings as <strong class="source-inline">content</strong>:</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  props: {</p>
			<p class="source-code">    // other prop definitions</p>
			<p class="source-code">    content: {</p>
			<p class="source-code">      type: [String, Number]</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">  // rest of component definition</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>In this case, we can consume the <strong class="source-inline">RepeatTyped</strong> component as follows without errors:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div id="app"&gt;</p>
			<p class="source-code">    &lt;Repeat :times="3" :content="55" /&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p>This displays <strong class="source-inline">55</strong> three times. Here, <strong class="source-inline">55</strong> was passed as a <strong class="source-inline">Number</strong>, which our component now supports. This can be seen in the following output:</p>
			<p class="source-code">55 55 55</p>
			<p>Any valid constructor can be used as the prop type. For example, <strong class="source-inline">Promise</strong> or a <strong class="source-inline">custom User</strong> constructor can be used. In the following example, we are defining a <strong class="source-inline">TodoList</strong> component prop interface:</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">import User from './user.js'</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  props: {</p>
			<p class="source-code">    todoListPromise: {</p>
			<p class="source-code">      type: Promise</p>
			<p class="source-code">    },</p>
			<p class="source-code">    currentUser: {</p>
			<p class="source-code">      type: User</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>The prop interface that's exposed by this component can be used as follows:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div&gt;</p>
			<p class="source-code">    &lt;template v-if="todosPromise &amp;&amp; !error"&gt;</p>
			<p class="source-code">      &lt;TodoList</p>
			<p class="source-code">        :todoListPromise="todosPromise"</p>
			<p class="source-code">        :currentUser="currentUser"</p>
			<p class="source-code">      /&gt;</p>
			<p class="source-code">    &lt;/template&gt;</p>
			<p class="source-code">    {{ error }}</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">import TodoList from './components/TodoList.vue'</p>
			<p class="source-code">import User from './components/user.js'</p>
			<p class="source-code">const currentUser = new User()</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  components: {</p>
			<p class="source-code">    TodoList</p>
			<p class="source-code">  },</p>
			<p class="source-code">  mounted() {</p>
			<p class="source-code">    this.todosPromise = fetch('/api/todos').then(res =&gt; {</p>
			<p class="source-code">      if (res.ok) {</p>
			<p class="source-code">        return res.json()</p>
			<p class="source-code">      }</p>
			<p class="source-code">      throw new Error('Could not fetch todos')</p>
			<p class="source-code">    }).catch(error =&gt; {</p>
			<p class="source-code">      this.error = error</p>
			<p class="source-code">    })</p>
			<p class="source-code">  },</p>
			<p class="source-code">  data() {</p>
			<p class="source-code">    return { currentUser, error: null }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>We have now seen how to use the <strong class="source-inline">union</strong> and <strong class="source-inline">custom</strong> types to validate Vue.js props.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Vue.js uses <strong class="source-inline">instanceof</strong> internally, so make sure any custom types are instantiated using the relevant constructor.</p>
			<p class="callout">Passing <strong class="source-inline">null</strong> or <strong class="source-inline">undefined</strong> will fail the <strong class="source-inline">instanceof</strong> check for <strong class="source-inline">Array</strong> and <strong class="source-inline">Object</strong>.</p>
			<p class="callout">Passing an array will pass the <strong class="source-inline">instanceof</strong> check for <strong class="source-inline">Object</strong> since, in JavaScript, <strong class="source-inline">Array</strong> instances are also <strong class="source-inline">Object</strong> instances.</p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor141"/>Custom Validation of Arrays, Object Shapes, and More with Validators </h2>
			<p>Vue.js allows custom validators to be used as props using the <strong class="source-inline">validator</strong> property. This allows us to implement deep checks regarding object and array shape as custom logic for primitive types.</p>
			<p>To illustrate this, let's look at a <strong class="source-inline">CustomSelect</strong> component. On a basic level, the prop interface for a <strong class="source-inline">select</strong> comprises an array of <strong class="source-inline">options</strong> and a <strong class="source-inline">selected</strong> option. Each option should have a <strong class="source-inline">label</strong> that represents what is displayed in the select and a <strong class="source-inline">value</strong> that corresponds to the value passed to an API. For example, the <strong class="source-inline">selected</strong> option can be empty or should correspond to the <strong class="source-inline">value</strong> field for one of our <strong class="source-inline">options</strong>.</p>
			<p>Our <strong class="source-inline">CustomSelect</strong> can be implemented as follows in a naive way (no validation of the inputs):</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;select&gt;</p>
			<p class="source-code">    &lt;option</p>
			<p class="source-code">      :selected="selected === o.value"</p>
			<p class="source-code">      v-for="o in options"</p>
			<p class="source-code">      :key="o.value"</p>
			<p class="source-code">    &gt;</p>
			<p class="source-code">      {{ o.label }}</p>
			<p class="source-code">    &lt;/option&gt;</p>
			<p class="source-code">  &lt;/select&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  props: {</p>
			<p class="source-code">    selected: {</p>
			<p class="source-code">      type: String</p>
			<p class="source-code">    },</p>
			<p class="source-code">    options: {</p>
			<p class="source-code">      type: Array</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p><strong class="source-inline">CustomSelect</strong> can then be used to display a list of <strong class="bold">British Crisp flavors</strong> (in <strong class="source-inline">src/App.vue</strong>):</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div id="app"&gt;</p>
			<p class="source-code">    &lt;CustomSelect :selected="selected" :options="options" /&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">import CustomSelect from './components/CustomSelect.vue'</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  components: {</p>
			<p class="source-code">    CustomSelect</p>
			<p class="source-code">  },</p>
			<p class="source-code">  data() {</p>
			<p class="source-code">    return {</p>
			<p class="source-code">      selected: 'salt-vinegar',</p>
			<p class="source-code">      options: [</p>
			<p class="source-code">        {</p>
			<p class="source-code">          value: 'ready-salted',</p>
			<p class="source-code">          label: 'Ready Salted'</p>
			<p class="source-code">        },</p>
			<p class="source-code">        {</p>
			<p class="source-code">          value: 'cheese-onion',</p>
			<p class="source-code">          label: 'Cheese &amp; Onion'</p>
			<p class="source-code">        },</p>
			<p class="source-code">        {</p>
			<p class="source-code">          value: 'salt-vinegar',</p>
			<p class="source-code">          label: 'Salt &amp; Vinegar'</p>
			<p class="source-code">        },</p>
			<p class="source-code">      ]</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>The preceding application outputs a select where <strong class="source-inline">Salt &amp; Vinegar</strong> is the default selected option, as shown in the following screenshot: </p>
			<div>
				<div id="_idContainer138" class="IMG---Figure">
					<img src="image/B15218_04_10.jpg" alt="Figure 4.10: Collapsed CustomSelect with Salt &amp; Vinegar selected&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.10: Collapsed CustomSelect with Salt &amp; Vinegar selected</p>
			<p>The following screenshot displays three flavor options, out of which one is selected:</p>
			<div>
				<div id="_idContainer139" class="IMG---Figure">
					<img src="image/B15218_04_11.jpg" alt="Figure 4.11: Open CustomSelect with flavor options and Salt &amp; Vinegar selected&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.11: Open CustomSelect with flavor options and Salt &amp; Vinegar selected</p>
			<p>To further validate our business logic around what shape options are, we can implement the following prop validator:</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  // other component properties</p>
			<p class="source-code">  props: {</p>
			<p class="source-code">    // other prop definitions</p>
			<p class="source-code">    options: {</p>
			<p class="source-code">      type: Array,</p>
			<p class="source-code">      validator(options) {</p>
			<p class="source-code">        return options.every(o =&gt; Boolean(o.value &amp;&amp; o.label))</p>
			<p class="source-code">      }</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>If we pass an option with a missing <strong class="source-inline">value</strong> or <strong class="source-inline">label</strong>, we will get the following message in the console:</p>
			<div>
				<div id="_idContainer140" class="IMG---Figure">
					<img src="image/B15218_04_12.jpg" alt="Figure 4.12: Vue.js warning when a custom validator fails&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.12: Vue.js warning when a custom validator fails</p>
			<p>With that, we have learned how to use a custom Vue.js validator to do in-depth checks of complex props. Next, we will learn how the <strong class="source-inline">required</strong> prop type property works.</p>
			<h2 id="_idParaDest-94">Required Pro<a id="_idTextAnchor142"/>ps</h2>
			<p>To mark a Vue.js prop as required, we can use the <strong class="source-inline">required</strong> prop type property.</p>
			<p>In the <strong class="source-inline">CustomSelect</strong> example, we can make <strong class="source-inline">selected</strong> a required prop.</p>
			<p>To do this, we need to amend the prop definition so that it includes <strong class="source-inline">required: true</strong>, as follows:</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  // other component properties</p>
			<p class="source-code">  props: {</p>
			<p class="source-code">    selected: {</p>
			<p class="source-code">      type: String,</p>
			<p class="source-code">      required: true</p>
			<p class="source-code">    }</p>
			<p class="source-code">    // other prop definitions</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>Now, if we amend the consumer of <strong class="source-inline">CustomSelect</strong> so that it does <em class="italic">not</em> pass a <strong class="source-inline">selected</strong> prop, we will see the following error:</p>
			<div>
				<div id="_idContainer141" class="IMG---Figure">
					<img src="image/B15218_04_13.jpg" alt="Figure 4.13: Vue.js warning when the selected required prop is missing&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.13: Vue.js warning when the selected required prop is missing</p>
			<p>With that, we have learned how to mark Vue.js props as required and what happens when a required prop is not passed. Next, we will learn how defaulting a prop can be the best choice.</p>
			<h2 id="_idParaDest-95">Defaulting Pr<a id="_idTextAnchor143"/>ops </h2>
			<p>There are situations where defaulting a prop is the best interface for a component.</p>
			<p>An example of this is a <strong class="source-inline">PaginatedList</strong> component that takes a list and displays a subset of this list based on the <strong class="source-inline">limit</strong> and <strong class="source-inline">offset</strong> parameters. In this scenario, instead of making <strong class="source-inline">limit</strong> and <strong class="source-inline">offset</strong>, it might be better to default <strong class="source-inline">limit</strong> to something such as <strong class="source-inline">25</strong> and <strong class="source-inline">offset</strong> to <strong class="source-inline">0</strong> (by default, we show the first page, which contains <strong class="source-inline">25</strong> results).</p>
			<p>This is how we would implement such a <strong class="source-inline">PaginatedList</strong> component without defaults:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;ul&gt;</p>
			<p class="source-code">    &lt;li</p>
			<p class="source-code">      v-for="el in currentWindow"</p>
			<p class="source-code">      :key="el.id"</p>
			<p class="source-code">    &gt;</p>
			<p class="source-code">      {{ el.content }}</p>
			<p class="source-code">    &lt;/li&gt;        </p>
			<p class="source-code">  &lt;/ul&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  props: {</p>
			<p class="source-code">    items: {</p>
			<p class="source-code">      type: Array</p>
			<p class="source-code">    },</p>
			<p class="source-code">    limit: {</p>
			<p class="source-code">      type: Number</p>
			<p class="source-code">    },</p>
			<p class="source-code">    offset: {</p>
			<p class="source-code">      type: Number</p>
			<p class="source-code">    }</p>
			<p class="source-code">  },</p>
			<p class="source-code">  computed: {</p>
			<p class="source-code">    currentWindow() {</p>
			<p class="source-code">      return this.items.slice(this.offset, this.limit)</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>We can consume this using the following code:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div id="app"&gt;</p>
			<p class="source-code">    &lt;PaginatedList :items="snacks" :offset="offset" :      limit="limit"/&gt;</p>
			<p class="source-code">    &lt;button @click="offset++"&gt;</p>
			<p class="source-code">      Increment Offset (current: {{ offset }})</p>
			<p class="source-code">    &lt;/button&gt;</p>
			<p class="source-code">    &lt;button @click="limit++"&gt;</p>
			<p class="source-code">      Increment Limit (current: {{ limit }})</p>
			<p class="source-code">    &lt;/button&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">import PaginatedList from './components/PaginatedList.vue'</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  components: {</p>
			<p class="source-code">    PaginatedList</p>
			<p class="source-code">  },</p>
			<p class="source-code">  data() {</p>
			<p class="source-code">    return {</p>
			<p class="source-code">      offset: 0,</p>
			<p class="source-code">      limit: 0,</p>
			<p class="source-code">      snacks: [</p>
			<p class="source-code">        {</p>
			<p class="source-code">          id: 'ready-salted',</p>
			<p class="source-code">          content: 'Ready Salted'</p>
			<p class="source-code">        },</p>
			<p class="source-code">        {</p>
			<p class="source-code">          id: 'cheese-onion',</p>
			<p class="source-code">          content: 'Cheese &amp; Onion'</p>
			<p class="source-code">        },</p>
			<p class="source-code">        {</p>
			<p class="source-code">          id: 'salt-vinegar',</p>
			<p class="source-code">          content: 'Salt &amp; Vinegar'</p>
			<p class="source-code">        },</p>
			<p class="source-code">      ]</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>By incrementing the limit to 3, we can display the whole list, as follows:</p>
			<p class="source-code">Hello Vue.js</p>
			<p>Then, by incrementing the offset, we can skip the first <em class="italic">X</em> elements in the list. The following screenshot shows <strong class="source-inline">PaginatedList</strong>:</p>
			<div>
				<div id="_idContainer142" class="IMG---Figure">
					<img src="image/B15218_04_14.jpg" alt="Figure 4.14: PaginatedList with limit 3 and offset 1&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.14: PaginatedList with limit 3 and offset 1</p>
			<p>Now, to make our <strong class="source-inline">PaginatedList</strong> is resilient, we will default <strong class="source-inline">limit</strong> to <strong class="source-inline">25</strong> and <strong class="source-inline">offset</strong> to <strong class="source-inline">0</strong>. To do so, we can set the <strong class="source-inline">default</strong> property for the relevant props:</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  props: {</p>
			<p class="source-code">    // other props</p>
			<p class="source-code">    limit: {</p>
			<p class="source-code">      type: Number,</p>
			<p class="source-code">      default: 25,</p>
			<p class="source-code">    },</p>
			<p class="source-code">    offset: {</p>
			<p class="source-code">      type: Number,</p>
			<p class="source-code">      default: 0,</p>
			<p class="source-code">    }</p>
			<p class="source-code">  },</p>
			<p class="source-code">  // other component properties</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>With these defaults, we will show <strong class="source-inline">25</strong> items from the start of the list by default.</p>
			<p>There is a gotcha with <strong class="source-inline">default</strong> in the case of arrays and objects (for example, if we wanted to default <strong class="source-inline">items</strong>), as per the Vue.js documentation; that is, <em class="italic">"Object or array defaults must be returned from a factory function"</em>.</p>
			<p><strong class="source-inline">factory function</strong> is a function—in this case, called <strong class="source-inline">default</strong>—that returns the default value we want.</p>
			<p>In the case of <strong class="source-inline">items</strong>, we can write the following:</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  props: {</p>
			<p class="source-code">    items: {</p>
			<p class="source-code">      type: Array,</p>
			<p class="source-code">      default() {</p>
			<p class="source-code">        return []</p>
			<p class="source-code">      }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    // other props</p>
			<p class="source-code">  },</p>
			<p class="source-code">  // other component properties</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>With that, we have learned how to default Vue.js component props. This can be helpful when we wish to provide values for optional parameters so that the Vue.js component implementation does not need to handle defaulting prop values. </p>
			<h2 id="_idParaDest-96">Exercise 4.03:<a id="_idTextAnchor144"/> Validating an Object Property </h2>
			<p>In this exercise, we will rewrite the <strong class="source-inline">Repeat</strong> component so that it supports a single <strong class="source-inline">config</strong> prop for passing <strong class="source-inline">times</strong>, which is a <strong class="source-inline">Number</strong>, and <strong class="source-inline">content</strong>, which is a <strong class="source-inline">String</strong>.</p>
			<p>We will have to write a custom validator to make sure <strong class="source-inline">times</strong> and <strong class="source-inline">content</strong> exist and are of the correct type.</p>
			<p>To access the code files for this exercise, refer to <a href="https://packt.live/2Ui1hVU">https://packt.live/2Ui1hVU</a>.</p>
			<p>Follow these steps to complete this exercise:</p>
			<ol>
				<li value="1">We will want our <strong class="source-inline">src/components/Repeat.vue</strong> component to support a <strong class="source-inline">config</strong> prop. This will be an <strong class="source-inline">Object</strong> that yields the following <strong class="source-inline">&lt;script&gt;</strong>:<p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  props: {</p><p class="source-code">    config: {</p><p class="source-code">      type: Object</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>Next, we want something to render when <strong class="source-inline">config</strong> is passed. To do this, we will create an array to <strong class="source-inline">v-for</strong> over a computer property. The array length will be based on the value of <strong class="source-inline">config.times</strong>:<p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  // other component properties</p><p class="source-code">  computed: {</p><p class="source-code">    repetitions() {</p><p class="source-code">      return Array.from({ length: this.config.times })</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>The next step is to set up <strong class="source-inline">&lt;template&gt;</strong> so that it renders <strong class="source-inline">config.content</strong> for each of the <strong class="source-inline">repetitions</strong> items:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div&gt;</p><p class="source-code">    &lt;span v-for="r in repetitions" :key="r"&gt;</p><p class="source-code">      {{ config.content }}</p><p class="source-code">    &lt;/span&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p></li>
				<li>Currently, we are ensuring that <strong class="source-inline">content</strong> and <strong class="source-inline">times</strong> have been set and are of the correct type. To do so, we will implement <strong class="source-inline">typeof</strong> checks in the config prop's <strong class="source-inline">validator</strong>:<p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  props: {</p><p class="source-code">    config: {</p><p class="source-code">      type: Object,</p><p class="source-code">      validator(value) {</p><p class="source-code">        return typeof value.times === 'number' &amp;&amp;</p><p class="source-code">          typeof value.content === 'string'</p><p class="source-code">      }</p><p class="source-code">    }</p><p class="source-code">  },</p><p class="source-code">  // other component properties</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>Finally, we can consume <strong class="source-inline">Repeat</strong> from <strong class="source-inline">src/App.vue</strong>. We need to import it, register it (in <strong class="source-inline">script</strong>), and render it in <strong class="source-inline">template</strong>:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div id="app"&gt;</p><p class="source-code">    &lt;Repeat :config="{}" /&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">import Repeat from './components/Repeat.vue'</p><p class="source-code">export default {</p><p class="source-code">  components: {</p><p class="source-code">    Repeat</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p><p>This will unfortunately not render anything since <strong class="source-inline">config</strong> is an empty object. You will observe a warning, as follows:</p><div id="_idContainer143" class="IMG---Figure"><img src="image/B15218_04_15.jpg" alt="Figure 4.15: Vue.js warning due to the config prop's custom validator check failing&#13;&#10;"/></div><p class="figure-caption">Figure 4.15: Vue.js warning due to the config prop's custom validator check failing</p><p>We will see this same error in the following cases:</p><p>a) We only add a <strong class="source-inline">times</strong> property; that is, <strong class="source-inline">&lt;Repeat :config="{ times: 3 }" /&gt;</strong>.</p><p>b) We only add a <strong class="source-inline">content</strong> property; that is, <strong class="source-inline">&lt;Repeat :config="{ content: 'Repeat me.' }" /&gt;</strong>.</p><p>c) <strong class="source-inline">times</strong> is of the wrong type; that is, <strong class="source-inline">&lt;Repeat :config="{ times: '3', content: 'Repeat me.' }" /&gt;</strong>.</p><p>d) <strong class="source-inline">content</strong> is of the wrong type property; that is, <strong class="source-inline">&lt;Repeat :config="{ times: 3, content: 42 }" /&gt;</strong>.</p></li>
				<li>For <strong class="source-inline">Repeat</strong> to work correctly, we can amend the line consuming it in <strong class="source-inline">template</strong> to the following:<p class="source-code">&lt;Repeat :config="{ times: 3, content: 'Repeat me.' }" /&gt;</p><p>This shows no errors in the console and renders <strong class="source-inline">Repeat me.</strong> three times, as follows:</p><p class="source-code">Repeat me. Repeat me. Repeat me.</p></li>
			</ol>
			<p>With that, we've shown how we might go about validating props to better define the interface of a Vue.js component.</p>
			<p>What follows is a deep dive into slots, a mechanism we can use to compose our components by deferring template logic.</p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor145"/>Slots, Named Slots, and Scoped Slots</h1>
			<p>Another component composition pattern that enables reusability in Vue.js is <strong class="source-inline">slots</strong>.</p>
			<p><strong class="bold">Slots</strong> are sections of a component where the template/rendering is delegated back to the consumer of the component.</p>
			<p>Here, props can be thought of as data that is passed from a parent to a child for said child to run some logic or to render it.</p>
			<p>Slots can be thought of as templates or markup that's passed from a parent to a child for said child to render.</p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor146"/>Passing Markup to Be Rendered in a Child Component </h2>
			<p>The simplest type of slot is the default <strong class="source-inline">child</strong> slot.</p>
			<p>We can define a <strong class="source-inline">Box</strong> component with a slot as follows. Note that this <strong class="source-inline">Box</strong> component does very little:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div&gt;</p>
			<p class="source-code">    &lt;slot /&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p>The following markup is for the parent component (<strong class="source-inline">src/App.vue</strong>):</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div&gt;</p>
			<p class="source-code">    &lt;Box&gt;</p>
			<p class="source-code">      &lt;h3&gt;This whole h3 is rendered in the slot&lt;/h3&gt;</p>
			<p class="source-code">    &lt;/Box&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">import Box from './components/Box.vue'</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  components: {</p>
			<p class="source-code">    Box</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>The preceding code will look as follows in the browser:</p>
			<p class="source-code">This whole h3 is rendered in the slot</p>
			<p>The <strong class="source-inline">template</strong> section in the Vue Single File Component for the scope is compiled with the parent component's scope.</p>
			<p>Consider the following example:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div&gt;</p>
			<p class="source-code">    &lt;Box&gt;</p>
			<p class="source-code">      &lt;h3&gt;This whole h3 is rendered in the slot with parent count {{         count }}&lt;/h3&gt;</p>
			<p class="source-code">    &lt;/Box&gt;</p>
			<p class="source-code">    &lt;button @click="count++"&gt;Increment&lt;/button&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">import Box from './components/Box.vue'</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  components: {</p>
			<p class="source-code">    Box</p>
			<p class="source-code">  },</p>
			<p class="source-code">  data() {</p>
			<p class="source-code">    return { count: 0 }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>The preceding code will render <strong class="source-inline">count</strong> as per its value in the parent component. It does not have access to the <strong class="source-inline">Box</strong> instance data or props and will generate the following output:</p>
			<div>
				<div id="_idContainer144" class="IMG---Figure">
					<img src="image/B15218_04_16.jpg" alt="Figure 4.16: Initial h3 with a count of 0, as per the initial data in the parent component&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.16: Initial h3 with a count of 0, as per the initial data in the parent component</p>
			<p>Incrementing the count does indeed update the template, as we would expect if the variable in the template was bound to data on the parent. This will generate the following output:</p>
			<div>
				<div id="_idContainer145" class="IMG---Figure">
					<img src="image/B15218_04_17.jpg" alt="Figure 4.17: h3 with a count of 5 after five increments of the count in the parent component's scope&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.17: h3 with a count of 5 after five increments of the count in the parent component's scope</p>
			<p>Slots are a way to delegate rendering a section of a child component to the parent component. Any references to instance properties, data, or methods will use the parent component instance. This type of slot does not have access to the child component's properties, props, or data.</p>
			<p>In the next section, we will look at how to use named slots to render multiple sections.</p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor147"/>Using Named Slots to Delegate Rendering of Multiple Sections</h2>
			<p><strong class="bold">Named slots</strong> are used when the child component needs to be able to delegate the template of multiple sections to the parent.</p>
			<p>For example, an <strong class="source-inline">Article</strong> component might delegate rendering of <strong class="source-inline">header</strong> and <strong class="source-inline">excerpt</strong> to its parent.</p>
			<p>In this case, this would look as follows in the <strong class="source-inline">Article.vue</strong> file. Named slots are <strong class="source-inline">slot</strong> entries with <strong class="source-inline">name</strong> attributes that denote the slot's name:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;article&gt;</p>
			<p class="source-code">    &lt;div&gt;Title: &lt;slot name="title" /&gt;&lt;/div&gt;</p>
			<p class="source-code">    &lt;div&gt;Excerpt: &lt;slot name="excerpt" /&gt;&lt;/div&gt;</p>
			<p class="source-code">  &lt;/article&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p>By doing this, you can consume this component in another component.</p>
			<p>For passing the slot's contents, we use the <strong class="source-inline">v-slot:name</strong> directive (where <strong class="source-inline">name</strong> should be replaced with the slot's name).</p>
			<p>For example, for the slot named <strong class="source-inline">title</strong>, we will use <strong class="source-inline">v-slot:title</strong>, while for the <strong class="source-inline">excerpt</strong> slot, we will use <strong class="source-inline">v-slot:excerpt</strong>:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div&gt;</p>
			<p class="source-code">    &lt;Article&gt;</p>
			<p class="source-code">      &lt;template v-slot:title&gt;</p>
			<p class="source-code">        &lt;h3&gt;My Article Title&lt;/h3&gt;</p>
			<p class="source-code">      &lt;/template&gt;</p>
			<p class="source-code">      &lt;template v-slot:excerpt&gt;</p>
			<p class="source-code">        &lt;p&gt;First paragraph of content&lt;/p&gt;</p>
			<p class="source-code">        &lt;p&gt;Second paragraph of content&lt;/p&gt;</p>
			<p class="source-code">      &lt;/template&gt;</p>
			<p class="source-code">    &lt;/Article&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">import Article from './components/Article.vue'</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  components: {</p>
			<p class="source-code">    Article</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>When the preceding application is seen in the browser, it will look as follows:</p>
			<div>
				<div id="_idContainer146" class="IMG---Figure">
					<img src="image/B15218_04_18.jpg" alt="Figure 4.18: Article using named slots rendering templates defined by the parent&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.18: Article using named slots rendering templates defined by the parent</p>
			<p>As you can see, the named slots do indeed render the expected content. </p>
			<p>The shorthand syntax for <strong class="source-inline">v-slot:slot-name</strong> is <strong class="source-inline">#slot-name</strong>. We could refactor our template that consumes <strong class="source-inline">Article</strong> as follows:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div&gt;</p>
			<p class="source-code">    &lt;Article&gt;</p>
			<p class="source-code">      &lt;template #title&gt;</p>
			<p class="source-code">        &lt;h3&gt;My Article Title&lt;/h3&gt;</p>
			<p class="source-code">      &lt;/template&gt;</p>
			<p class="source-code">      &lt;template #excerpt&gt;</p>
			<p class="source-code">        &lt;p&gt;First paragraph of content&lt;/p&gt;</p>
			<p class="source-code">        &lt;p&gt;Second paragraph of content&lt;/p&gt;</p>
			<p class="source-code">      &lt;/template&gt;</p>
			<p class="source-code">    &lt;/Article&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p><strong class="source-inline">v-slot</strong> cannot be used with native elements. It can only use <strong class="source-inline">template</strong> and components. For example, the following <strong class="source-inline">&lt;template&gt;</strong> section attempts to set a <strong class="source-inline">v-slot</strong> on a <strong class="source-inline">h3</strong> element:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div&gt;</p>
			<p class="source-code">    &lt;Article&gt;</p>
			<p class="source-code">      &lt;h3 v-slot:title&gt;My Article Title&lt;/h3&gt;</p>
			<p class="source-code">    &lt;/Article&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p>This template will fail with a compilation error of <strong class="source-inline">v-slot can only be used on components or &lt;template&gt;</strong>, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer147" class="IMG---Figure">
					<img src="image/B15218_04_19.jpg" alt="Figure 4.19: v-slot on a native element – compilation error&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.19: v-slot on a native element – compilation error</p>
			<p>Earlier versions of Vue.js allowed an alternative syntax to be used for denoting named slot contents (this was deprecated in Vue 2.6.0+). Instead of the <strong class="source-inline">v-slot:slot-name</strong> directive style, <strong class="source-inline">slot="slot-name"</strong> was used. The <strong class="source-inline">slot</strong> syntax was allowed on native elements, as well as on templates and components.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Everything that applies to the default slot applies to named slots. In fact, the default slot is a named slot called <strong class="source-inline">default</strong>. This means that named slots also have access to the parent instance but not the child instance.</p>
			<p>The default slot is just a slot named <strong class="source-inline">default</strong> and gets special treatment by Vue.js as it is used by default in a <strong class="source-inline">slot</strong> with no <strong class="source-inline">name</strong>.</p>
			<p>The <strong class="source-inline">default</strong> slot is implicitly inferred as follows:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;MyComponent&gt;</p>
			<p class="source-code">    &lt;template&gt;Default template&lt;/template&gt;</p>
			<p class="source-code">  &lt;/MyComponent&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p>The default slot can be denoted with shorthand slot notation.</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;MyComponent&gt;</p>
			<p class="source-code">    &lt;template #default&gt;Default template&lt;/template&gt;</p>
			<p class="source-code">  &lt;/MyComponent&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="source-code">The default slot can be denoted with longhand slot notation.</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;MyComponent&gt;</p>
			<p class="source-code">    &lt;template v-slot:default&gt;Default template&lt;/template&gt;</p>
			<p class="source-code">  &lt;/MyComponent&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p>We have now seen how named slots allow components to delegate templating of certain sections to a consumer, as well as how these named slots can have a default template to cater for cases where a named slot is optional. </p>
			<p>In the next section, we will learn how scoped slots are used to wrap prop passing logic.</p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor148"/>Using Scoped Slots to Wrap Prop Passing Logic </h2>
			<p>The types of slots we have explored so far only have access to the component instance in which they are declared.</p>
			<p>Sometimes, it is useful to let the parent component dictate the rendering while letting the child component transform the data in some way. This is what scoped slots are used for.</p>
			<p>A <strong class="bold">scoped slot</strong> starts with the child component's slots, where the <strong class="source-inline">slot</strong> element has some attributes bound to it via the use of <strong class="source-inline">v-bind</strong> or the shorthand, <strong class="source-inline">:</strong>.</p>
			<p>In this case, <strong class="source-inline">item</strong> is bound to <strong class="source-inline">el</strong>. <strong class="source-inline">el</strong> is an element of the <strong class="source-inline">items</strong> prop that has been passed to this <strong class="source-inline">PaginatedList</strong> component:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;ul&gt;</p>
			<p class="source-code">    &lt;li</p>
			<p class="source-code">      v-for="el in currentWindow"</p>
			<p class="source-code">      :key="el.id"</p>
			<p class="source-code">    &gt;</p>
			<p class="source-code">      &lt;slot :item="el" /&gt;</p>
			<p class="source-code">    &lt;/li&gt;</p>
			<p class="source-code">  &lt;/ul&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  props: ['items', 'limit', 'offset'],</p>
			<p class="source-code">  computed: {</p>
			<p class="source-code">    currentWindow() {</p>
			<p class="source-code">      return this.items.slice(this.offset, this.limit)</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>On the consumer side (the parent component), we can think of the slot template as being called with an object containing all the data bound to the slot in the child component. Hence, these slots are referred to as <strong class="source-inline">scoped</strong>; they are passed through a <strong class="source-inline">scope</strong> object, as defined by the child component.</p>
			<p>In this case, we can consume <strong class="source-inline">PaginatedList</strong> as follows:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div&gt;</p>
			<p class="source-code">    &lt;PaginatedList :items="snacks"&gt;</p>
			<p class="source-code">      &lt;template #default="{ item }"&gt;</p>
			<p class="source-code">        {{ item.content }}</p>
			<p class="source-code">      &lt;/template&gt;</p>
			<p class="source-code">    &lt;/PaginatedList&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p><strong class="source-inline">#default="{ item }"</strong> is the shorthand notation for the default scoped slot and allows us to destructure the slot's scope into <strong class="source-inline">item</strong>.</p>
			<p>The longhand version of the slot's template definition is as follows:</p>
			<p class="source-code">&lt;template v-slot="slotProps"&gt;</p>
			<p class="source-code">  {{ slotProps.item.content }}</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p><strong class="source-inline">item</strong> is then used to render <strong class="source-inline">{{ item.content }}</strong>. The <strong class="source-inline">script</strong> section (with snacks to render) will be as follows:</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">import PaginatedList from './components/PaginatedList.vue'</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  components: {</p>
			<p class="source-code">    PaginatedList</p>
			<p class="source-code">  },</p>
			<p class="source-code">  data() {</p>
			<p class="source-code">    return {</p>
			<p class="source-code">      snacks: [</p>
			<p class="source-code">        {</p>
			<p class="source-code">          id: 'ready-salted',</p>
			<p class="source-code">          content: 'Ready Salted'</p>
			<p class="source-code">        },</p>
			<p class="source-code">        {</p>
			<p class="source-code">          id: 'cheese-onion',</p>
			<p class="source-code">          content: 'Cheese &amp; Onion'</p>
			<p class="source-code">        },</p>
			<p class="source-code">        {</p>
			<p class="source-code">          id: 'salt-vinegar',</p>
			<p class="source-code">          content: 'Salt &amp; Vinegar'</p>
			<p class="source-code">        },</p>
			<p class="source-code">      ]</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>We get the following output in the browser:</p>
			<div>
				<div id="_idContainer148" class="IMG---Figure">
					<img src="image/B15218_04_20.jpg" alt="Figure 4.20: Snacks displayed using a scoped slot, meaning the rendering logic is in the parent component&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.20: Snacks displayed using a scoped slot, meaning the rendering logic is in the parent component</p>
			<p>With that, we have learned how scoped slots give components increased flexibility to delegate templating logic to consumers.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Scoped slots also have a deprecated (as of Vue.js 2.6.0+) <strong class="source-inline">slot-scope</strong> syntax. The deprecated equivalent of <strong class="source-inline">v-slot:name="slotProps"</strong> would be <strong class="source-inline">slot="name" slot-scope="slotProps"</strong>. For more information, see the Vue.js documentation: <a href="https://vuejs.org/v2/guide/components-slots.html#Scoped-Slots-with-the-slot-scope-Attribute">https://vuejs.org/v2/guide/components-slots.html#Scoped-Slots-with-the-slot-scope-Attribute</a>.</p>
			<p>Now, let's learn how<a id="_idTextAnchor149"/> to implement a card component with the help of these named slots.</p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor150"/>Exercise 4.04: Implementing a Card Component Using Named Slots </h2>
			<p>In this exercise, we will implement a card component using named slots. The card will have a title, image, and description sections. We will use slots to allow <strong class="source-inline">title</strong>, <strong class="source-inline">image</strong>, and <strong class="source-inline">description</strong> to be defined by a parent component.</p>
			<p>To access the code files for this exercise, refer to <a href="https://packt.live/2UhLxlK">https://packt.live/2UhLxlK</a>.</p>
			<p>Follow these steps to complete this exercise:</p>
			<ol>
				<li value="1">We will start by creating a new <strong class="source-inline">src/components/Card.vue</strong> component that has a template that supports three slots – <strong class="source-inline">title</strong>, <strong class="source-inline">image</strong>, and <strong class="source-inline">description</strong>:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div&gt;</p><p class="source-code">    &lt;slot name="image" /&gt;</p><p class="source-code">    &lt;slot name="title" /&gt;</p><p class="source-code">    &lt;slot name="description" /&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p></li>
				<li>We will then import our <strong class="source-inline">Card.vue</strong> component into the <strong class="source-inline">script</strong> section of a new <strong class="source-inline">src/App.vue</strong> file:<p class="source-code">&lt;script&gt;</p><p class="source-code">import Card from './components/Card.vue'</p><p class="source-code">export default {</p><p class="source-code">  components: {</p><p class="source-code">    Card</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>We can now use <strong class="source-inline">Card</strong> in our <strong class="source-inline">template</strong>:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div id="app"&gt;</p><p class="source-code">    &lt;Card&gt;</p><p class="source-code">      &lt;template #image&gt;</p><p class="source-code">        &lt;img src="https://picsum.photos/id/1015/300" /&gt;</p><p class="source-code">      &lt;/template&gt;</p><p class="source-code">      &lt;template #title&gt;</p><p class="source-code">        &lt;h2&gt;My Holiday picture&lt;/h2&gt;</p><p class="source-code">      &lt;/template&gt;</p><p class="source-code">      &lt;template #description&gt;</p><p class="source-code">        &lt;p&gt;Here I can describe the contents of the picture.&lt;/p&gt;</p><p class="source-code">        &lt;p&gt;For example what we can see in the photo is a nice           landscape.&lt;/p&gt;</p><p class="source-code">      &lt;/template&gt;</p><p class="source-code">    &lt;/Card&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p>Now, we can fire up the <strong class="source-inline">vue-cli dev</strong> server using <strong class="source-inline">npm run serve</strong> and see the <strong class="source-inline">Card</strong> component in action. The output will be as follows:</p><div id="_idContainer149" class="IMG---Figure"><img src="image/B15218_04_21.jpg" alt="Figure 4.21: Card component with image, title, and description&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 4.21: Card component with image, title, and description</p>
			<p>With that, we have learned how different types of slots can help to create more generic components. Slots allow child components to defer the rendering of certain parts of themselves to their parent component (<strong class="source-inline">consumer</strong>).</p>
			<p>To reuse functionality within a single template, we can use filters. We'll learn how to use them in the next section.</p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor151"/>Template Logic Sharing with Filters </h1>
			<p>To share template logic, Vue.js has <strong class="bold">filters</strong>.</p>
			<p>Filters can be used in mustache interpolations (<strong class="source-inline">{{ interpolatingSomething }}</strong>) or in expressions (for example, when binding a value). <strong class="source-inline">filter</strong> is a function that takes a value and outputs something that can be rendered (usually a <strong class="source-inline">String</strong> or a <strong class="source-inline">Number</strong>).</p>
			<p>So, an example filter called <strong class="source-inline">truncate</strong> would be used in a template as follows (here, we have put some long placeholder text):</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div id="app"&gt;</p>
			<p class="source-code">    {{ message | truncate }}</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  data() {</p>
			<p class="source-code">    return {</p>
			<p class="source-code">      message: 'Lorem ipsum dolor sit amet, consectetur adipiscing         elit, sed do eiusmod tempor incididunt ut labore et dolore         magna aliqua. Ut enim ad minim veniam, quis nostrud         exercitation llamco laboris nisi ut aliquip ex ea commodo         consequat. Duis aute irure dolor in reprehenderit in         voluptate velit esse cillum dolore eu fugiat nulla         pariatur. Excepteur sint occaecat cupidatat non proident,         sunt in culpa qui officia deserunt mollit anim id         est laborum.'</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p><strong class="source-inline">truncate</strong> could also be used in a Vue.js bind expression. For example, <strong class="source-inline">&lt;MessageComponent :msg="message | truncate"&gt;</strong> would bind the truncated output of <strong class="source-inline">message</strong> to <strong class="source-inline">msg</strong>.</p>
			<p>To define the <strong class="source-inline">truncate</strong> filter, we can define it in a component's <strong class="source-inline">filters</strong> property in the <strong class="source-inline">script</strong> section.</p>
			<p><strong class="source-inline">truncate</strong> filter will truncate the text down to <strong class="source-inline">120</strong> characters:</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  filters: {</p>
			<p class="source-code">    truncate(value) {</p>
			<p class="source-code">      return value.slice(0, 120)</p>
			<p class="source-code">    }</p>
			<p class="source-code">  },</p>
			<p class="source-code">  // other component properties</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>Without the truncation filter, we get <strong class="source-inline">446</strong> characters of <em class="italic">lorem ipsum</em>, as follows:</p>
			<div>
				<div id="_idContainer150" class="IMG---Figure">
					<img src="image/B15218_04_22.jpg" alt="Figure 4.22: Lorem ipsum without truncation&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.22: Lorem ipsum without truncation</p>
			<p>With the <strong class="source-inline">truncate</strong> filter, we are down to <strong class="source-inline">120</strong> characters, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer151" class="IMG---Figure">
					<img src="image/B15218_04_23.jpg" alt="Figure 4.23: Lorem ipsum with the truncate filter&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.23: Lorem ipsum with the truncate filter</p>
			<p>The more defensive way to write this <strong class="source-inline">truncate</strong> filter would be to do an early return if <strong class="source-inline">val</strong> is false, then <strong class="source-inline">toString</strong> it (this will convert numbers into strings, for example) before doing the output of <strong class="source-inline">.slice</strong>:</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  filters: {</p>
			<p class="source-code">    truncate(value) {</p>
			<p class="source-code">      if (!value) return</p>
			<p class="source-code">      const val = value.toString()</p>
			<p class="source-code">      return val.slice(0, 120)</p>
			<p class="source-code">    }</p>
			<p class="source-code">  },</p>
			<p class="source-code">  // other component properties</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>With that, we have learned how to register and implement Vue.js filters for a component. We have also learned how to use filters in the component's template with the interpolation expression's pipe syntax.</p>
			<p>In the following exercise, we will learn how to implement an ellipsis filter.</p>
			<h2 id="_idParaDest-103">Exercise 4.05: Implemen<a id="_idTextAnchor152"/>ting an Ellipsis Filter </h2>
			<p>Filters are excellent for repeated text processing tasks. In this exercise, we will implement an <strong class="source-inline">ellipsis</strong> filter that works as follows.</p>
			<p>If the passed text is more than <strong class="source-inline">14</strong> characters, it should be truncated down to <strong class="source-inline">11</strong> characters and an ellipsis (<strong class="source-inline">…</strong>) should be added to the end of the text.</p>
			<p>When the passed text is empty or not a <strong class="source-inline">String</strong>, we should be quite permissive and either return nothing or convert it into a <strong class="source-inline">String</strong> before doing our processing.</p>
			<p>To access the code files for this exercise, refer to <a href="https://packt.live/2IsZyuv">https://packt.live/2IsZyuv</a>.</p>
			<p>Follow these steps to complete this exercise:</p>
			<ol>
				<li value="1">First, we need to set up the template so that it will pipe <em class="italic">a string less than 14 characters</em>, <em class="italic">a string with 14 characters</em>, and <em class="italic">a string with more than 14 characters</em> through <strong class="source-inline">ellipsis</strong> to check if it works as expected under all possible conditions (we'll do this in <strong class="source-inline">src/App.vue</strong>, as per the standard Vue CLI setup). We should also pipe a number and an empty value (<strong class="source-inline">null</strong>) through <strong class="source-inline">ellipsis</strong>:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div id="app"&gt;</p><p class="source-code">    &lt;p&gt;{{ '7 char' | ellipsis }}&lt;/p&gt;</p><p class="source-code">    &lt;p&gt;{{ '14 characters' | ellipsis }}&lt;/p&gt;</p><p class="source-code">    &lt;p&gt;{{ 'More than 14 characters' | ellipsis }}&lt;/p&gt;</p><p class="source-code">    &lt;p&gt;{{ null | ellipsis }}&lt;/p&gt;</p><p class="source-code">    &lt;p&gt;{{ 55 | ellipsis }}&lt;/p&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p>At this stage, the application should just display the text in the console. There should be some warnings that the <strong class="source-inline">ellipsis</strong> filter has not defined, as shown in the following screenshot:</p><div id="_idContainer152" class="IMG---Figure"><img src="image/B15218_04_24.jpg" alt="Figure 4.24: Application displaying unchanged text&#13;&#10;"/></div><p class="figure-caption">Figure 4.24: Application displaying unchanged text</p><p>The following screenshot shows the warning:</p><div id="_idContainer153" class="IMG---Figure"><img src="image/B15218_04_25.jpg" alt="Figure 4.25: Vue.js warning that the ellipsis filter is missing&#13;&#10;"/></div><p class="figure-caption">Figure 4.25: Vue.js warning that the ellipsis filter is missing</p></li>
				<li>Next, we will implement an initial version of the filter in the <strong class="source-inline">script</strong> section of the component. This will check the length of the passed value, truncate it to <strong class="source-inline">11</strong>, and add <strong class="source-inline">…</strong> if it is longer than <strong class="source-inline">14</strong> characters:<p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  filters: {</p><p class="source-code">    ellipsis(value) {</p><p class="source-code">      return value.length &gt; 14 ? `${value.slice(0, 11)}...` :         value</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p><p>At this stage, the component fails to render and Vue.js logs an error since <strong class="source-inline">Cannot read property 'length' of null</strong>, as shown in the following screenshot: </p><div id="_idContainer154" class="IMG---Figure"><img src="image/B15218_04_26.jpg" alt="Figure 4.26: null piped into the application&#13;&#10;"/></div><p class="figure-caption">Figure 4.26: null piped into the application</p></li>
				<li>Next, we need to amend the <strong class="source-inline">ellipsis</strong> implementation so that it short-circuits when the passed value is <strong class="source-inline">false</strong> (to avoid the issue with <strong class="source-inline">null</strong>):<p class="source-code">    ellipsis(value) {</p><p class="source-code">      if (!value) return</p><p class="source-code">      // rest of the function</p><p class="source-code">}</p><p>We now have the <strong class="source-inline">ellipsis</strong> filter working; it works for all the test cases we have included. The output will be as follows:</p><div id="_idContainer155" class="IMG---Figure"><img src="image/B15218_04_27.jpg" alt="Figure 4.27: Ellipsis filter working for given inputs&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 4.27: Ellipsis filter working for given inputs</p>
			<p>Filters are useful for sharing simple text processing logic in components. A filter is a Vue.js primitive that keeps templating and formatting concerns in the template, such as truncating content and adding an ellipsis.</p>
			<p>Vue.js provides an abstraction over the DOM Web API. However, when it becomes necessary to access the DOM directly, such as to integrate a DOM library, Vue.js provides a first-class way to do so with refs. We will learn about Vue.js references in the next section.</p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor153"/>Vue.js refs</h1>
			<p>In Vue.js, <strong class="bold">refs<a id="_idTextAnchor154"/></strong> are references to DOM elements or other components. This occurs programmatically.</p>
			<p>A large use case for refs is direct DOM manipulation and integration with DOM-based libraries (that usually take a DOM node they should mount to).</p>
			<p>Refs are defined using <strong class="source-inline">ref="name"</strong> on a native element or child component in the template. In the following instance, the input will be stored in a <strong class="source-inline">theInput</strong> ref:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div id="app"&gt;</p>
			<p class="source-code">    &lt;input ref="theInput" /&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p>Refs can be accessed from the Vue.js component instance through <strong class="source-inline">this.$refs[name]</strong>. So, in the previous example, where we had a ref defined as <strong class="source-inline">ref="theInput"</strong>, we can access it through <strong class="source-inline">this.$refs.theInput</strong>.</p>
			<p>To focus the input when a button is clicked, we could write the following:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div id="app"&gt;</p>
			<p class="source-code">    &lt;input ref="theInput" /&gt;</p>
			<p class="source-code">    &lt;button @click="focus()"&gt;Focus Input&lt;/button&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  methods: {</p>
			<p class="source-code">    focus() {</p>
			<p class="source-code">      this.$refs.theInput.focus()</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>When clicking the <strong class="source-inline">Focus Input</strong> button, the input will be focused, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer156" class="IMG---Figure">
					<img src="image/B15218_04_28.jpg" alt="Figure 4.28: Input focused on a button click&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.28: Input focused on a button click</p>
			<p>With that, we have learned how to use <strong class="source-inline">$refs</strong> to abstract DOM manipulation logic in a Vue.js component. Where it makes sense to select a DOM node directly in Vue.js, it is recommended to use a <strong class="source-inline">ref</strong> instead of using the DOM selection API (<strong class="source-inline">querySelector</strong>/<strong class="source-inline">querySelectorAll</strong>). </p>
			<p>In the following exercise, we will learn how the <strong class="source-inline">Countable</strong> library helps increase the interactivity in a project.</p>
			<h2 id="_idParaDest-105">Exercise 4.06: Wrapping Coun<a id="_idTextAnchor155"/>table.js with Vue.js </h2>
			<p><strong class="source-inline">Countable</strong> is a library that, given an element (usually an HTML <strong class="source-inline">textarea</strong> or input), will add live counts of paragraphs, words, and characters. Live metrics on the text being captured can be quite useful to increase interactivity in a project where editing text is a core concern.</p>
			<p>One of the large use cases for using refs in Vue.js is to be able to integrate with libraries that act directly on the DOM.</p>
			<p>In this exercise, we will create a component with paragraph/word/character counting for content in a <strong class="source-inline">textarea</strong> by using <strong class="source-inline">Countable.js</strong> and Vue.js refs.</p>
			<p>To access the code files for this exercise, refer to <a href="https://packt.live/36oOuGz">https://packt.live/36oOuGz</a>.</p>
			<p>Follow these steps to complete this exercise:</p>
			<ol>
				<li value="1">Install <strong class="source-inline">countable</strong> from <strong class="source-inline">npm</strong>. We will run <strong class="source-inline">npm install --save countable</strong> here, which will add it to our dependencies</li>
				<li>Next, we will create a new <strong class="source-inline">src/components/TextEditorWithCount.vue</strong> component with a <strong class="source-inline">textarea</strong> that we will have a <strong class="source-inline">ref</strong> to:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div&gt;</p><p class="source-code">    &lt;textarea</p><p class="source-code">      ref="textArea"</p><p class="source-code">      cols="50"</p><p class="source-code">      rows="7"</p><p class="source-code">    &gt;</p><p class="source-code">    &lt;/textarea&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p></li>
				<li>Next, we will import and render the component in <strong class="source-inline">src/App.vue</strong>:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div id="app"&gt;</p><p class="source-code">    &lt;TextEditorWithCount /&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">import TextEditorWithCount from './components/  TextEditorWithCount.vue'</p><p class="source-code">export default {</p><p class="source-code">  components: {</p><p class="source-code">    TextEditorWithCount</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p><p>The application renders a <strong class="source-inline">textarea</strong>, as follows:</p><div id="_idContainer157" class="IMG---Figure"><img src="image/B15218_04_29.jpg" alt="Figure 4.29: A bare textarea, as rendered by the application&#13;&#10;"/></div><p class="figure-caption">Figure 4.29: A bare textarea, as rendered by the application</p></li>
				<li>We now need to integrate <strong class="source-inline">Countable</strong>. We will import it and initialize it with <strong class="source-inline">this.$refs.textArea</strong>. We will also store the counts on the instance as <strong class="source-inline">this.count</strong>:<p class="source-code">&lt;script&gt;</p><p class="source-code">import * as Countable from 'countable'</p><p class="source-code">export default {</p><p class="source-code">  mounted() {</p><p class="source-code">    Countable.on(this.$refs.textArea, (count) =&gt; {</p><p class="source-code">      this.count = count</p><p class="source-code">    })</p><p class="source-code">  },</p><p class="source-code">  data() {</p><p class="source-code">    return {</p><p class="source-code">      count: null</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>With a small update to the <strong class="source-inline">template</strong>, we can display the counts we care about:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div id="app"&gt;</p><p class="source-code">    &lt;!-- textarea --&gt;</p><p class="source-code">    &lt;ul v-if="count"&gt;</p><p class="source-code">      &lt;li&gt;Paragraphs: {{ count.paragraphs }}&lt;/li&gt;</p><p class="source-code">      &lt;li&gt;Sentences: {{ count.sentences }}&lt;/li&gt;</p><p class="source-code">      &lt;li&gt;Words: {{ count.words }}&lt;/li&gt;</p><p class="source-code">    &lt;/ul&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p>Now, we can see the counts set to <strong class="source-inline">0</strong> when <strong class="source-inline">textarea</strong> is empty, as follows:</p><div id="_idContainer158" class="IMG---Figure"><img src="image/B15218_04_30.jpg" alt="Figure 4.30: Textarea with counts set to 0 when empty&#13;&#10;"/></div><p class="figure-caption">Figure 4.30: Textarea with counts set to 0 when empty</p><p>If we drop some <em class="italic">Lorem ipsum</em> into our <strong class="source-inline">textarea</strong>, the counts will update accordingly, as follows:</p><div id="_idContainer159" class="IMG---Figure"><img src="image/B15218_04_31.jpg" alt="Figure 4.31: Textarea with counts updated when filled&#13;&#10;"/></div><p class="figure-caption">Figure 4.31: Textarea with counts updated when filled</p></li>
				<li>One last thing we need to do is remove the <strong class="source-inline">Countable</strong> event listener when the component is destroyed:<p class="source-code">&lt;script&gt;</p><p class="source-code">// imports</p><p class="source-code">export default {</p><p class="source-code">  mounted() {</p><p class="source-code">    Countable.on(this.$refs.textArea, (count) =&gt; {</p><p class="source-code">      this.count = count</p><p class="source-code">    })</p><p class="source-code">    this.$once('hook:beforeDestroy', function () {</p><p class="source-code">      Countable.off(this.$refs.textArea)</p><p class="source-code">    })</p><p class="source-code">  },</p><p class="source-code">  // other component properties</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p><p class="callout-heading">Note</p><p class="callout">We have achieved this with programmatic listeners, though we could have achieved the same with the <strong class="source-inline">beforeDestroy</strong> life cycle method.</p></li>
			</ol>
			<p>This integration of a JavaScript/DOM library inside of Vue.js is a key application of Vue.js refs. Refs allow us to pick from the existing ecosystem of libraries and wrap or integrate them into a component.</p>
			<p>Vue.js refs are useful for integrating DOM libraries or for accessing DOM APIs directly.</p>
			<p>To round off our learning of component composition, we need to know how to pass data from child components to parent components.</p>
			<h1 id="_idParaDest-106">Vue.js Events for Child-Parent <a id="_idTextAnchor156"/>Communication</h1>
			<p>We have already seen that props are used to pass data from a parent component to a child component.</p>
			<p>To pass data from a child component back to a parent component, Vue.js has custom events.</p>
			<p>In a component, an event can be emitted using the <strong class="source-inline">$emit</strong> instance method. It can be used from within the <strong class="source-inline">script</strong> section using <strong class="source-inline">this.$emit('eventName', /* payload */)</strong>, but it is also exposed within the <strong class="source-inline">template</strong> section as <strong class="source-inline">$emit</strong>.</p>
			<p>Assuming we have got a reactive instance property, <strong class="source-inline">this.message</strong>, we could emit a <strong class="source-inline">send</strong> event with the <strong class="source-inline">message</strong> value in the <strong class="source-inline">script</strong> section using <strong class="source-inline">this.$emit</strong>. This could be the basis for a <strong class="source-inline">MessageEditor</strong> component:</p>
			<p class="source-code">&lt;script&gt; </p>
			<p class="source-code">export default {</p>
			<p class="source-code">  data () {</p>
			<p class="source-code">        return {</p>
			<p class="source-code">            message: null</p>
			<p class="source-code">        }</p>
			<p class="source-code">    },</p>
			<p class="source-code">  methods: {</p>
			<p class="source-code">    send() {</p>
			<p class="source-code">      this.$emit('send', this.message);</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>In the same scenario, we could trigger a <strong class="source-inline">send</strong> event from the <strong class="source-inline">template</strong> section:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div&gt;</p>
			<p class="source-code">    &lt;input v-model="message" /&gt;</p>
			<p class="source-code">    &lt;button @click="$emit('send', message)"&gt;Emit inline&lt;/button&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p>From a parent component, we can use <strong class="source-inline">v-on:event-name</strong> or the shorthand <strong class="source-inline">@event-name</strong>. <strong class="source-inline">event-name</strong> must match the name passed to <strong class="source-inline">$emit</strong>; <strong class="source-inline">eventName</strong> and <strong class="source-inline">event-name</strong> are not equivalent.</p>
			<p>For example, a parent component would be how we listen to the <strong class="source-inline">send</strong> event using <strong class="source-inline">@send</strong> and save the event payload contained in the <strong class="source-inline">$event</strong> magic value. To use the event payload in a method call, we can use <strong class="source-inline">@eventName="methodToCall($event)"</strong>:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div id="app"&gt;</p>
			<p class="source-code">    &lt;p&gt;Message: {{ message }}&lt;/p&gt;</p>
			<p class="source-code">    &lt;MessageEditor @send="message = $event" /&gt;</p>
			<p class="source-code">    &lt;button @click="message = null"&gt;Reset&lt;/button&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">import MessageEditor from './components/MessageEditor.vue'</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  components: {</p>
			<p class="source-code">    MessageEditor</p>
			<p class="source-code">  },</p>
			<p class="source-code">  data() {</p>
			<p class="source-code">    return {</p>
			<p class="source-code">      message: null</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>Using the inline and method versions of <strong class="source-inline">$emit</strong> yields the same result. The full <strong class="source-inline">MessageEditor</strong> app should look as follows:</p>
			<div>
				<div id="_idContainer160" class="IMG---Figure">
					<img src="image/B15218_04_32.jpg" alt="Figure 4.32: Hello World! message being emitted from child-parent&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.32: Hello World! message being emitted from child-parent</p>
			<p>Vue.js custom events support passing any JavaScript type as the payload. The event name, however, must be a <strong class="source-inline">String</strong>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Binding a listener to Vue.js custom events is very similar to binding to native events such as <strong class="source-inline">click</strong>.</p>
			<p>Now, let's complete an activity <a id="_idTextAnchor157"/>based on what we've learned about so far.</p>
			<h2 id="_idParaDest-107">Activity 4.01: A Local Message V<a id="_idTextAnchor158"/>iew with Reusable Components</h2>
			<p>This activity aims to leverage components, props, events, and refs to render a <strong class="bold">chat</strong> interface where the user can add messages and they are displayed. </p>
			<p>Follow these steps to complete this activity:</p>
			<ol>
				<li value="1">Create a <strong class="source-inline">MessageEditor</strong> component (in <strong class="source-inline">src/components/MessageEditor.vue</strong>) that displays a <strong class="source-inline">textarea</strong> to the user.</li>
				<li>Add a <strong class="source-inline">message</strong> reactive instance variable to <strong class="source-inline">MessageEditor</strong>, defaulted to <strong class="source-inline">''</strong>.</li>
				<li>Listen to <strong class="source-inline">change</strong> events for <strong class="source-inline">textarea</strong> and set the value of <strong class="source-inline">message</strong> to the value of the content of <strong class="source-inline">textarea</strong> (it is exposed as the value of the event).</li>
				<li>Add a <strong class="source-inline">Send</strong> button that, on <strong class="source-inline">click</strong>, emits a <strong class="source-inline">send</strong> event with <strong class="source-inline">message</strong> as the payload.</li>
				<li>Add a <strong class="source-inline">main</strong> <strong class="source-inline">App</strong> component to <strong class="source-inline">src/App.vue</strong> that renders <strong class="source-inline">MessageEditor</strong>.</li>
				<li>In <strong class="source-inline">App</strong>, listen to <strong class="source-inline">send</strong> events from <strong class="source-inline">MessageEditor</strong> and store each message in a <strong class="source-inline">messages</strong> reactive instance variable (<strong class="source-inline">messages</strong> is an array).</li>
				<li>Create a <strong class="source-inline">MessageFeed</strong> (in <strong class="source-inline">src/components/MessageFeed.vue</strong>) that has a required <strong class="source-inline">messages</strong> prop, which is an <strong class="source-inline">Array</strong>.</li>
				<li>In <strong class="source-inline">MessageFeed</strong>, render each passed message from the <strong class="source-inline">messages</strong> prop in a paragraph (the <strong class="source-inline">p</strong> element).</li>
				<li>Import and render <strong class="source-inline">MessageFeed</strong> into <strong class="source-inline">App</strong>, binding the <strong class="source-inline">messages</strong> app instance variable as the <strong class="source-inline">messages</strong> prop of <strong class="source-inline">MessageFeed</strong>.</li>
				<li>Improve <strong class="source-inline">MessageEditor</strong> so that the message is reset when it is sent. To do this, we will need to set <strong class="source-inline">textarea.value</strong> using a Vue.js ref and reset the <strong class="source-inline">message</strong> instance variable.<p class="callout-heading">Note</p><p class="callout">The easier way to reset <strong class="source-inline">textarea</strong> would have been to use <strong class="source-inline">v-model="message"</strong> in the first place instead of binding <strong class="source-inline">@change</strong> and manually syncing <strong class="source-inline">textarea.value</strong> to <strong class="source-inline">message</strong>.</p><p>The expected output is as follows:</p><div id="_idContainer161" class="IMG---Figure"><img src="image/B15218_04_33.jpg" alt="Figure 4.33: Message app with Hello World! and Hello JavaScript sent&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 4.33: Message app with Hello World! and Hello JavaScript sent</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found via <a href="B15218_Solution_Final_SZ_ePub.xhtml#_idTextAnchor387">this link</a>.</p>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor159"/>Summary</h1>
			<p>Throughout this chapter, <a id="_idTextAnchor160"/>we have looked at Vue.js primitives that allow us to build components in such a way that they can be composed efficiently.</p>
			<p>Props and slots are used to defer behavior within a component to whichever parent component is rendering them. Props, with their ability to be validated, are great for passing data into nested components. Slots are geared toward yielding control of rendering back to the parent component. Events enable child components to send data back to their parent, thus completing the parent-child communication cycle (props down, events up).</p>
			<p>Global templating helpers can be encapsulated in filters to reduce boilerplate and increase code reuse. Refs unlock integration opportunities with third-party JavaScript or DOM libraries by allowing us to access DOM elements directly.</p>
			<p>We're now able to compose and create components that clearly define their interfaces with inputs (props and slots) and outputs (rendered templates and events), while also visiting commonly faced use cases (wrapping a DOM library, abstracting templating concerns in a filter, and so on).</p>
			<p>In the next chapter, we'll look at advanced component composition patterns and techniques that enable better code reuse.</p>
		</div>
		<div>
			<div id="_idContainer163" class="Content">
			</div>
		</div>
	</body></html>