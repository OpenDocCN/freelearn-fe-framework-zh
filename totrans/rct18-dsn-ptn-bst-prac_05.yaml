- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Writing Code for the Browser
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为浏览器编写代码
- en: There are some specific operations we can conduct when we work with React and
    the browser. For example, we can ask our users to enter some information using
    forms. In this chapter, we will look at how we can apply different techniques
    to deal with forms. We can implement **uncontrolled components** and let the fields
    keep their internal states, or we can use controlled ones where we have full control
    over the state of the fields.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们与React和浏览器一起工作时，我们可以执行一些特定的操作。例如，我们可以要求我们的用户通过表单输入一些信息。在本章中，我们将探讨如何应用不同的技术来处理表单。我们可以实现**非受控组件**，让字段保持其内部状态，或者我们可以使用受控组件，其中我们可以完全控制字段的状态。
- en: In this chapter, we will also look at how events in React work and how the library
    implements some advanced techniques to give us a consistent interface across different
    browsers. We will look at some interesting solutions that the React team has implemented
    to make the event system very performant.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们还将探讨React中的事件是如何工作的，以及库如何实现一些高级技术，以在不同浏览器之间提供一致的接口。我们将探讨React团队实施的一些有趣的解决方案，以使事件系统非常高效。
- en: After events, we will jump into **refs** to look at how we can access the underlying
    **DOM** nodes in our React components. This represents a powerful feature, but
    it should be used carefully because it breaks some of the conventions that make
    React easy to work with.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 事件发生后，我们将跳转到**refs**来查看我们如何在React组件中访问底层**DOM**节点。这代表了一个强大的功能，但应该谨慎使用，因为它打破了使React易于工作的某些约定。
- en: After refs, we will look at how we can implement animations easily with the
    React add-ons. Finally, we will learn how easy it is to work with **Scalable Vector
    Graphics** (**SVG**) in React, and how we can create dynamically configurable
    icons for our applications.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在refs之后，我们将探讨如何使用React插件轻松实现动画。最后，我们将学习如何在React中与**可缩放矢量图形**（**SVG**）一起工作有多容易，以及我们如何为我们的应用程序创建动态可配置的图标。
- en: 'In this chapter, we will go through the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将讨论以下主题：
- en: Using different techniques to create forms with React
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不同的技术用React创建表单
- en: Listening to DOM events and implementing custom handlers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监听DOM事件并实现自定义处理程序
- en: A way of performing imperative operations on DOM nodes using refs
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用refs在DOM节点上执行命令式操作的方法
- en: Creating simple animations that work across different browsers
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建在不同浏览器上都能工作的简单动画
- en: The React way of generating SVG
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React生成SVG的方式
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete this chapter, you will need the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章，你需要以下内容：
- en: Node.js 19+
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 19+
- en: Visual Studio Code
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code
- en: 'You can find the code for this chapter in the book’s GitHub repository: [https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter05).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的GitHub仓库中找到本章的代码：[https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter05)。
- en: Understanding and implementing forms
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解和实现表单
- en: In this section, we are going to learn how to implement forms with React. As
    soon as we start building a real application with React, we need to interact with
    the users. If we want to ask for information from our users within the browser,
    forms are the most common solution. Due to the way the library works and its declarative
    nature, dealing with input fields and other form elements is non-trivial with
    React, but as soon as we understand its logic, it will become clear. In the next
    sections, we are going to learn how to use uncontrolled and controlled components.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用React实现表单。一旦我们开始用React构建真实的应用程序，我们就需要与用户交互。如果我们想在浏览器中从我们的用户那里获取信息，表单是最常见的解决方案。由于库的工作方式和其声明性特性，使用React处理输入字段和其他表单元素并不简单，但一旦我们理解了其逻辑，它就会变得清晰。在下一节中，我们将学习如何使用非受控和受控组件。
- en: Uncontrolled components
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非受控组件
- en: '**Uncontrolled components** are like regular HTML form inputs for which you
    will not be able to manage the value yourself but instead, the DOM will take care
    of handling the value and you can get this value by using a React ref. Let’s start
    with a basic example—displaying a form with an input field and a `Submit` button.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**非受控组件**类似于常规HTML表单输入，对于这些输入，你将无法自行管理其值，而是DOM将负责处理该值，你可以通过使用React ref来获取这个值。让我们从一个基本示例开始——显示一个带有输入字段和`提交`按钮的表单。'
- en: 'The code is pretty straightforward:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 代码相当简单：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If we run the preceding snippet in the browser, we will see exactly what we
    expect—an input field in which we can write something and a clickable button.
    This is an example of an uncontrolled component, where we do not set the value
    of the input field, but we let the component manage its own internal state.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中运行前面的代码片段，我们会看到我们预期的结果——一个可以写入内容的输入框和一个可点击的按钮。这是一个未受控组件的例子，我们并没有设置输入框的值，而是让组件管理其自身的内部状态。
- en: Most likely, we want to do something with the value of the element when the
    `Submit` button is clicked. For example, we may want to send the data to an API
    endpoint.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能，我们想在点击 `Submit` 按钮时对元素的值做些处理。例如，我们可能想将数据发送到 API 端点。
- en: We can do this easily by adding an `onChange` listener (we will talk more about
    event listeners later in this chapter). Let’s look at what it means to add a listener.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加一个 `onChange` 监听器轻松做到这一点（我们将在本章后面更多地讨论事件监听器）。让我们看看添加监听器意味着什么。
- en: 'We need to create the `handleChange` function:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建 `handleChange` 函数：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The event listener is receiving an event object, where the target represents
    the field that generated the event, and we are interested in its value. We start
    by just logging it because it is important to proceed with small steps, but we
    will store the value into the state soon.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 事件监听器接收一个事件对象，其中目标表示生成事件的字段，我们对其值感兴趣。我们首先只是记录它，因为重要的是要从小步骤开始，但很快我们会将值存储到状态中。
- en: 'Finally, we render the form:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们渲染表单：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If we render the component inside the browser and type the word `React` into
    the form field, we will see something like the following inside the console:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中渲染组件并将单词 `React` 输入到表单字段中，我们将在控制台看到如下内容：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `handleChange` listener is fired every time the value of the input changes.
    Therefore, our function is called once for each typed character. The next step
    is to store the value that’s entered by the user and make it available when the
    user clicks the `Submit` button.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`handleChange` 监听器会在输入框的值每次改变时被触发。因此，我们的函数会在每个输入字符时被调用一次。下一步是存储用户输入的值，并在用户点击
    `Submit` 按钮时使其可用。'
- en: 'We just have to change the implementation of the handler to store it in the
    state instead of logging it, as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需更改处理程序的实施方式，将其存储在状态中而不是记录它，如下所示：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Getting notified of when the form is submitted is very similar to listening
    to the change event of the input field; they are both events that are called by
    the browser when something happens.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当表单提交时得到通知与监听输入字段的变化事件非常相似；它们都是浏览器在发生某些事情时调用的事件。
- en: 'Let’s define the `handleSubmit` function, where we just log the value. In a
    real-world scenario, you could send the data to an API endpoint or pass it to
    another component:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义 `handleSubmit` 函数，其中我们只是记录值。在现实世界的场景中，你可以将数据发送到 API 端点或传递给另一个组件：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This handler is pretty straightforward; we just log the value currently stored
    in the state. We also want to overcome the default behavior of the browser when
    the form is submitted, to perform a custom action. This seems reasonable, and
    it works very well for a single field. The question now is, *what if we have multiple
    fields? Suppose we have tens of different fields?*
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个处理程序相当简单；我们只是记录当前存储在状态中的值。我们还想克服表单提交时浏览器默认行为，执行自定义操作。这似乎是合理的，并且对于单个字段来说效果很好。现在的问题是，如果我们有多个字段怎么办？假设我们有数十个不同的字段？
- en: Let’s start with a basic example, where we create each field and handler manually
    and look at how we can improve it by applying different levels of optimization.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基本示例开始，手动创建每个字段和处理程序，并看看我们如何通过应用不同的优化级别来改进它。
- en: 'Let’s create a new form with first and last name fields. We can reuse the `Uncontrolled`
    component and add some new states:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的表单，包含姓氏和名字字段。我们可以重用 `Uncontrolled` 组件并添加一些新的状态：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We initialize the two fields inside the state, and we define an event handler
    for each one of the fields as well. As you may have noticed, this does not scale
    very well when there are lots of fields, but it is important to understand the
    problem clearly before moving to a more flexible solution.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在状态中初始化两个字段，并为每个字段定义一个事件处理程序。正如你可能已经注意到的，当有很多字段时，这并不很好地扩展，但在转向更灵活的解决方案之前，清楚地理解问题是重要的。
- en: 'Now, we implement the new handlers:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们实现新的处理程序：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We also have to change the submit handler a little bit so that it displays
    the first and the last name when it gets clicked:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须稍微更改提交处理程序，以便在点击时显示姓名的首尾：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, we render the form:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们渲染表单：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We are ready to go: if we run the preceding component in the browser, we will
    see two fields, and if we type `Carlos` into the first one and `Santana` into
    the second one, we will see the full name displayed in the browser console when
    the form is submitted.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备就绪：如果我们将在浏览器中运行前面的组件，我们将看到两个字段，如果我们将在第一个字段中输入`Carlos`，在第二个字段中输入`Santana`，当表单提交时，我们将在浏览器控制台中看到完整的姓名显示。
- en: Again, this works fine, and we can do some interesting things this way, but
    it does not handle complex scenarios without requiring us to write a lot of boilerplate
    code.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这种方法效果良好，我们可以通过这种方式做一些有趣的事情，但它无法处理复杂场景，除非我们编写大量的模板代码。
- en: Let’s look at how we can optimize it a little bit. Our goal is to use a single
    change handler so that we can add an arbitrary number of fields without creating
    new listeners.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何对其进行一点优化。我们的目标是使用单个更改处理程序，这样我们就可以添加任意数量的字段，而无需创建新的监听器。
- en: 'Let’s go back to the component and let’s change our states:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到组件，并更改我们的状态：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We may still want to initialize the values, and later in this section, we will
    look at how to provide prefilled values for the form.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能仍然想要初始化值，在本节的后面部分，我们将探讨如何为表单提供预填充值。
- en: 'Now, the interesting bit is the way in which we can modify the `onChange` handler
    implementation to make it work in different fields:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有趣的部分在于我们可以如何修改`onChange`处理程序实现，使其在不同的字段中工作：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As we have seen previously, the `target` property of the event we receive represents
    the input field that has fired the event, so we can use the name of the field
    and its value as variables.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，我们接收的事件的`target`属性代表了触发事件的输入字段，因此我们可以使用字段的名称及其值作为变量。
- en: 'We then have to set the name for each field:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须为每个字段设置名称：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: That’s it! We can now add as many fields as we want without creating additional
    handlers.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们现在可以添加任意多的字段，而无需创建额外的处理程序。
- en: Controlled components
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 受控组件
- en: A controlled component is a React component that controls the values of input
    elements in a form by using the component state.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 受控组件是React组件，它通过使用组件状态来控制表单中输入元素的值。
- en: Here we are going to look at how we can prefill the form fields with some values,
    which we may receive from the server or as props from the parent. To understand
    this concept fully, we will start again from a very simple stateless function
    component, and we will improve it step by step.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将探讨如何使用一些值预先填充表单字段，这些值可能来自服务器或作为父组件的props。为了完全理解这个概念，我们将从一个非常简单的无状态函数组件开始，并逐步改进它。
- en: 'The first example shows a predefined value inside the input field:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例显示了输入字段内的预定义值：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If we run this component inside the browser, we realize that it shows the default
    value as expected, but it does not let us change the value or type anything else
    inside it.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中运行此组件，我们会发现它按预期显示了默认值，但它不允许我们更改值或在其内部输入其他内容。
- en: The reason it does this is that in React, we declare what we want to see on
    the screen, and setting a fixed-value attribute always results in rendering that
    value, no matter what other actions are taken. This is unlikely to be a behavior
    we want in a real-world application.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 原因在于，在React中，我们声明了希望在屏幕上显示的内容，设置固定值属性总会导致渲染该值，无论采取其他什么操作。这在实际应用中可能不是我们希望的行为。
- en: 'If we open the console, we get the following error message. React itself is
    telling us that we are doing something wrong:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打开控制台，我们会得到以下错误消息。React本身告诉我们我们做错了什么：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, if we just want the input field to have a default value and we want to
    be able to change it by typing, we can use the `defaultValue` property:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们只想让输入字段有一个默认值，并且我们想要能够通过输入来更改它，我们可以使用`defaultValue`属性：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this way, the field is going to show `Hello React` when it is rendered,
    but then the user can type anything inside it and change its value. Now let’s
    add some states:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，当字段被渲染时，它将显示`Hello React`，然后用户可以在其中输入任何内容并更改其值。现在让我们添加一些状态：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The handlers are the same as the previous ones:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序与之前相同：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In fact, we will use the value attributes of the input fields to set their
    initial values, as well as the updated one:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们将使用输入字段的值属性来设置它们的初始值以及更新后的值：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first time the form is rendered, React uses the initial values from the
    state as the value of the input fields. When the user types something into the
    field, the `handleChange` function is called and the new value for the field is
    stored in the state.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当表单第一次渲染时，React使用状态中的初始值作为输入字段的值。当用户在字段中输入某些内容时，`handleChange`函数被调用，并将字段的新值存储在状态中。
- en: When the state changes, React re-renders the component and uses it again to
    reflect the current values of the input fields. We now have full control over
    the values of the fields, and we call this pattern **controlled components**.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当状态发生变化时，React会重新渲染组件并再次使用它来反映输入字段的当前值。我们现在完全控制字段的值，我们称这种模式为**受控组件**。
- en: In the next section, we are going to work with events, which are a fundamental
    part of React to handle data coming from forms.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将处理事件，这是React处理来自表单的数据的基本部分。
- en: Handling events
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理事件
- en: '`Events` work in a slightly different way across various browsers. React tries
    to abstract the way events work and give developers a consistent interface to
    deal with. This is a great feature of React because we can forget about the browsers
    we are targeting and write event handlers and functions that are *vendor-agnostic*.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`事件`在不同的浏览器中工作方式略有不同。React试图抽象事件的工作方式，并为开发者提供一个一致的接口来处理。这是React的一个伟大特性，因为我们可以忘记我们正在针对的浏览器，并编写事件处理程序和函数，它们是*供应商无关的*。'
- en: To offer this feature, React introduced the concept of the synthetic event.
    A synthetic event is an object that wraps the original event object provided by
    the browser, and it has the same properties, no matter where it is created.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供这个功能，React引入了合成事件的概念。合成事件是一个对象，它包装了浏览器提供的原始事件对象，并且无论在哪里创建，都具有相同的属性。
- en: To attach an event listener to a node and get the event object when the event
    is fired, we can use a simple convention that recalls the way events are attached
    to the DOM nodes. In fact, we can use the word on plus the `camelCased` event
    name (for example, `onKeyDown`) to define the callback to be fired when the events
    happen. A popular convention is to name the event handler functions after the
    event name and prefix them using `handle` (for example, `handleKeyDown`).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要将事件监听器附加到节点并在事件触发时获取事件对象，我们可以使用一个简单的约定，它回忆了事件附加到DOM节点的方式。实际上，我们可以使用单词on加上`camelCased`事件名称（例如，`onKeyDown`）来定义在事件发生时被触发的回调。一个流行的约定是将事件处理程序函数命名为事件名称，并使用`handle`作为前缀（例如，`handleKeyDown`）。
- en: 'We have seen this pattern in action in the previous examples, where we were
    listening to the `onChange` event of the form fields. Let’s reiterate a basic
    event listener example to see how we can organize multiple events inside the same
    component in a nicer way. We are going to implement a simple button, and we start,
    as usual, by creating a component:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的示例中已经看到了这种模式的实际应用，当时我们正在监听表单字段的`onChange`事件。让我们再次回顾一个基本的事件监听器示例，看看我们如何以更优雅的方式在同一个组件内部组织多个事件。我们将实现一个简单的按钮，并且像往常一样，首先创建一个组件：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then we define the event handler:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们定义事件处理程序：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As you can see here, we are doing a very simple thing: we just check the type
    of the event object we receive from React and the type of native event attached
    to it. We expect the first to return false and the second to return true.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在这里所看到的，我们正在做一件非常简单的事情：我们只是检查从React接收的事件对象的类型以及附加到其上的原生事件类型。我们期望第一个返回false，第二个返回true。
- en: 'You should never need to access the original native event, but it is good to
    know you can do it if you need to. Finally, we define the button with the `onClick`
    attribute to which we attach our event listener:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您永远不需要访问原始的本地事件，但了解您可以在需要时这样做是好的。最后，我们使用`onClick`属性定义按钮，并将事件监听器附加到它：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, suppose we want to attach a second handler to the button that listens
    to the double-click event. One solution would be to create a new separate handler
    and attach it to the button using the `onDoubleClick` attribute, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想要将第二个处理程序附加到按钮，以便监听双击事件。一个解决方案是创建一个新的单独的处理程序，并使用`onDoubleClick`属性将其附加到按钮，如下所示：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Remember that we always aim to write less boilerplate and avoid duplicating
    code. For that reason, a common practice is to write a `single event handler`
    for each component, which can trigger different actions according to the event
    type.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们总是力求编写更少的样板代码并避免代码重复。因此，一个常见的做法是为每个组件编写一个`单个事件处理程序`，它可以根据事件类型触发不同的操作。
- en: 'This technique is described in a collection of patterns by Michael Chan:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术由Michael Chan在一系列模式中描述：
- en: '[http://reactpatterns.com/#event-switch](http://reactpatterns.com/#event-switch)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://reactpatterns.com/#event-switch](http://reactpatterns.com/#event-switch)'
- en: 'Let’s implement the generic event handler:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现通用事件处理器：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The generic event handler receives the event object and switches on the event
    type to fire the right action. This is particularly useful if we want to call
    a function on each event (for example, analytics) or if some events share the
    same logic.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通用事件处理器接收事件对象并根据事件类型切换以触发正确的动作。如果我们想在每个事件上调用一个函数（例如，分析）或者某些事件共享相同的逻辑，这特别有用。
- en: 'Finally, we attach the new event listener to the `onClick` and `onDoubleClick`
    attributes:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将新的事件监听器附加到`onClick`和`onDoubleClick`属性：
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: From this point on, whenever we need to create a new event handler for the same
    component, instead of creating a new method and binding it, we can just add a
    new case to the switch.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点开始，每当我们需要为同一组件创建一个新的事件处理器时，我们只需向switch添加一个新的情况，而不是创建一个新的方法和绑定它。
- en: A couple more interesting things to know about events in React are that synthetic
    events are reused and that there is a **single global handler**. The first concept
    means that we cannot store a synthetic event and reuse it later because it becomes
    null right after the action. This technique is very good in terms of performance,
    but it can be problematic if we want to store the event inside the state of the
    component for some reason. To solve this problem, React gives us a persist method
    on the synthetic events, which we can call to make the event persistent so that
    we can store it and retrieve it later.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 关于React中事件的一些有趣的事情是，合成事件会被重用，并且存在一个**全局处理器**。第一个概念意味着我们不能存储一个合成事件并在之后重用它，因为事件在动作之后立即变为null。这种技术在性能方面非常好，但如果出于某种原因我们想在组件的状态中存储事件，可能会遇到问题。为了解决这个问题，React为我们提供了一个在合成事件上的持久化方法，我们可以调用它来使事件持久化，以便我们可以存储和稍后检索它。
- en: The second very interesting implementation detail is again about performance,
    and it is to do with the way React attaches the event handlers to the DOM.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个非常有趣的具体实现细节又是关于性能的，这涉及到React将事件处理器附加到DOM的方式。
- en: Whenever we use the on attribute, we are describing to React the behavior we
    want to achieve, but the library does not attach the actual event handler to the
    underlying DOM nodes.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们使用on属性时，我们都在向React描述我们想要实现的行为，但库不会将实际的事件处理器附加到底层的DOM节点。
- en: What it does instead attaches a single event handler to the root element, which
    listens to all the events, thanks to **event bubbling**. When an event we are
    interested in is fired by the browser, React calls the handler on the specific
    components on its behalf. This technique is called **event delegation** and is
    used for memory and speed optimization.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 它所做的相反，是将单个事件处理器附加到根元素，该处理器监听所有事件，这要归功于**事件冒泡**。当浏览器触发我们感兴趣的事件时，React代表它调用特定组件上的处理器。这种技术称为**事件委托**，用于内存和速度优化。
- en: In our next section, we are going to explore React refs and see how we can take
    advantage of them.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探索React refs并了解如何利用它们。
- en: Exploring refs
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索refs
- en: One of the reasons people love React is that it is declarative. Being declarative
    means that you just describe what you want to be displayed on the screen at any
    point in time and React takes care of the communications with the browser. This
    feature makes React very easy to reason about and very powerful at the same time.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 人们喜欢React的一个原因是因为它是声明式的。声明式意味着你只需描述在任何时刻你想在屏幕上显示的内容，React会负责与浏览器的通信。这个特性使得React在推理上非常容易，同时也很强大。
- en: However, there might be some cases where you need to access the underlying DOM
    nodes to perform some imperative operations. This should be avoided because, in
    most cases, there is a more React-compliant solution to achieve the same result,
    but it is important to know that we have the option to do it and to know how it
    works so that we can make the right decision.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，可能有一些情况下你需要访问底层的DOM节点来执行一些命令式操作。这应该被避免，因为在大多数情况下，有更符合React的解决方案来实现相同的结果，但了解我们有这个选项并且知道它是如何工作的，以便我们可以做出正确的决定。
- en: Suppose we want to create a simple form with an input element and a button,
    and we want it to behave in such a way that when the button is clicked, the input
    field gets focused. What we want to do is call the focus method on the input node,
    the actual DOM instance of the input, inside the browser’s window.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要创建一个简单的表单，其中包含一个输入元素和一个按钮，并且我们希望它以这样的方式运行：当按钮被点击时，输入字段会获得焦点。我们想要做的是在浏览器窗口中调用输入节点（即输入的实际DOM实例）的focus方法。
- en: 'Let’s create a component called `Focus`; you need to import `useRef` and create
    an `inputRef` constant:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`Focus`的组件；你需要导入`useRef`并创建一个`inputRef`常量：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, we implement the `handleClick` method:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们实现`handleClick`方法：
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, we are referencing the current attribute of `inputRef` and calling
    the focus method on it.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们正在引用`inputRef`的当前属性，并在其上调用focus方法。
- en: 'To understand where it comes from, you just have to check the implementation
    of the render:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解其来源，你只需检查`render`的实现：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here comes the core of the logic. We create a form with an input element inside
    it and we define a function on its `ref` attribute.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是逻辑的核心。我们在表单内部创建一个带有输入元素的表单，并在其`ref`属性上定义一个函数。
- en: The callback we defined is called when the component gets mounted, and the element
    parameter represents the DOM instance of the input. It is important to know that,
    when the component gets unmounted, the same callback is called with a null parameter
    to free the memory.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件挂载时，我们定义的回调会被调用，其中的element参数代表输入的DOM实例。重要的是要知道，当组件卸载时，相同的回调会被带有null参数调用，以释放内存。
- en: What we are doing in the callback is storing the reference of the element to
    be able to use it in the future (for example, when the `handleClick` method is
    fired). Then, we have the button with its event handler. Running the preceding
    code in a browser will show the form with the field and the button, and clicking
    on the button will focus the input field, as expected.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在回调中我们所做的是存储元素的引用，以便将来使用（例如，当`handleClick`方法被触发时）。然后，我们有带有其事件处理器的按钮。在浏览器中运行前面的代码将显示带有字段和按钮的表单，点击按钮将使输入字段获得焦点，正如预期的那样。
- en: '*As we mentioned previously, in general, we should try to avoid using refs
    because they force the code to be more imperative, and they become harder to read
    and maintain.*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*正如我们之前提到的，通常情况下，我们应该尽量避免使用refs，因为它们会使代码变得更加命令式，并且它们变得难以阅读和维护。*'
- en: Understanding forwardRef
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解`forwardRef`
- en: '`React.forwardRef` is a useful feature that allows you to pass a ref (short
    for “reference”) from a parent component down to a child component. This article
    will provide a basic introduction to `React.forwardRef` and offer a straightforward
    example to help you understand its practical usage.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`React.forwardRef`是一个有用的特性，允许你从父组件向下传递一个ref（简称“引用”）到子组件。本文将提供一个关于`React.forwardRef`的基本介绍，并提供一个简单的示例来帮助你理解其实际用法。'
- en: Refs in React are a mechanism to access and interact with the DOM elements rendered
    by a component. They provide a way to modify the DOM or access DOM properties
    directly.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: React中的refs是一种机制，用于访问和与组件渲染的DOM元素交互。它们提供了一种修改DOM或直接访问DOM属性的方法。
- en: '`React.forwardRef` is a higher-order component that allows you to pass a ref
    down to a child component. This is useful when you need to access the child component’s
    DOM element or instance from the parent component.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`React.forwardRef`是一个高阶组件，允许你将ref传递给子组件。当你需要从父组件访问子组件的DOM元素或实例时，这非常有用。'
- en: 'To create a component that can accept a forwarded ref, you will use the `React.forwardRef`
    function, which takes a render function as an argument. This render function receives
    two parameters: the component’s `props` and the forwarded ref.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个可以接受转发ref的组件，你将使用`React.forwardRef`函数，它接受一个作为参数的渲染函数。这个渲染函数接收两个参数：组件的`props`和转发的ref。
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: To use the `forwardRef` component, you will create a ref using the `useRef()`
    hook and assign it to the `forwardRef` component.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`forwardRef`组件，你需要使用`useRef()`钩子创建一个ref，并将其分配给`forwardRef`组件。
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this example, we created a `TextInputWithRef` component that accepts a forwarded
    ref. In the `App` component, we use the `useRef()` hook to create a ref, which
    we then pass to the `TextInputWithRef` component. When the `"Focus on input"`
    button is clicked, the `handleClick` function is called, which focuses on the
    input element.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个`TextInputWithRef`组件，它接受一个传递的ref。在`App`组件中，我们使用`useRef()`钩子创建一个ref，然后将其传递给`TextInputWithRef`组件。当点击“聚焦到输入框”按钮时，会调用`handleClick`函数，该函数聚焦到输入元素。
- en: '`React.forwardRef` is a powerful feature that allows you to pass refs from
    parent components to child components, providing greater control over the child
    components’ behavior.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`React.forwardRef`是一个强大的功能，允许您将ref从父组件传递到子组件，从而提供对子组件行为的更大控制。'
- en: By understanding the basics of refs and `forwardRef`, and examining a simple
    example, you can effectively utilize this feature in your React applications.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解`refs`和`forwardRef`的基本知识，并检查一个简单的示例，你可以在你的React应用程序中有效地利用这个功能。
- en: 'With the nuances of utilizing `React.forwardRef` for superior control over
    components explored, we can now shift our focus toward another pivotal aspect
    of enhancing user experiences in React applications: implementing animations.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在探讨了利用`React.forwardRef`以实现对组件的更高级控制之后，我们现在可以将注意力转向另一个增强React应用程序用户体验的关键方面：实现动画。
- en: Implementing animations
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现动画
- en: When we think about UIs and the browser, we must surely think about animations
    as well. Animated UIs are more pleasant for users, and they are a very important
    tool to show users that something has happened or is about to occur.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们思考UI和浏览器时，我们肯定也会想到动画。动画化的UI对用户来说更愉快，它们是向用户展示已经发生或即将发生的事情的重要工具。
- en: This section does not aim to be an exhaustive guide to creating animations and
    beautiful UIs; the goal here is to provide you with some basic information about
    the common solutions we can put in place to animate our React components.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的目的不是提供一个创建动画和美观UI的详尽指南；这里的目的是提供一些关于我们可以实施以动画化我们的React组件的常见解决方案的基本信息。
- en: For a UI library such as React, it is crucial to provide an easy way for developers
    to create and manage animations. React comes with an add-on, called `react-transition-group`,
    which is a component that helps us build animations in a declarative way. Again,
    being able to perform operations declaratively is incredibly powerful, and it
    makes the code much easier to reason about and share with the team.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像React这样的UI库，为开发者提供一个简单的方式来创建和管理动画至关重要。React附带了一个名为`react-transition-group`的附加组件，它是一个帮助我们以声明式方式构建动画的组件。再次强调，能够以声明式方式执行操作非常强大，它使得代码更容易推理和与团队共享。
- en: 'The first thing we need to do to start building an animated component is to
    install the add-on:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始构建动画组件，我们首先需要安装附加组件：
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Once we have done that, we can import the component:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，我们可以导入组件：
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, we just wrap the component to which we want to apply the animation:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们只需将动画应用到我们想要应用的组件上：
- en: '[PRE32]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see, there are some props that need explaining. First, we are declaring
    the `transitionName` prop. `ReactTransitionGroup` applies a class with the name
    of that property to the child element so that we can then use CSS transitions
    to create our animations.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，有一些属性需要解释。首先，我们声明了`transitionName`属性。`ReactTransitionGroup`将具有该属性名称的类应用到子元素上，这样我们就可以使用CSS过渡来创建动画。
- en: With a single class, we cannot easily create a proper animation, and that is
    why the transition group applies multiple classes according to the state of the
    animation. In this case, with the `transitionAppear` prop, we are telling the
    component that we want to animate the children when they appear on the screen.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单个类，我们无法轻松地创建合适的动画，这就是为什么过渡组根据动画的状态应用多个类。在这种情况下，使用`transitionAppear`属性，我们告诉组件当子元素出现在屏幕上时，我们想要对它们进行动画处理。
- en: So, what the library does is apply the `fade-appear` class (where fade is the
    value of the `transitionName` prop) to the component as soon as it gets rendered.
    On the next tick, the `fade-appear-active` class is applied so that we can fire
    our animation from the initial state to the new one, using CSS.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，库所做的是在组件渲染后立即将其`fade-appear`类（其中`fade`是`transitionName`属性的值）应用到组件上。在下一次tick时，应用`fade-appear-active`类，这样我们就可以使用CSS从初始状态到新状态触发动画。
- en: We also have to set the `transitionAppearTimeout` property to tell React the
    length of the animation so that it doesn’t remove elements from the DOM before
    animations are completed.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须设置`transitionAppearTimeout`属性来告诉React动画的长度，这样它就不会在动画完成之前从DOM中删除元素。
- en: The CSS to make an element `fade-in` is as follows.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使元素`淡入`的CSS如下。
- en: 'First, we define the opacity of the element in the initial state:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在初始状态中定义元素的透明度：
- en: '[PRE33]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, we define our transition using the second class, which starts as soon
    as it gets applied to the element:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用第二个类定义我们的过渡，它一旦应用到元素上就开始：
- en: '[PRE34]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We are transitioning the opacity from 0.01 to 1 in 500ms using the ease-in function.
    This is pretty easy, but we can create more complex animations, and we can also
    animate different states of the component. For example, the `*-enter` and `*-enter-active`
    classes are applied when a new element is added as a child of the transition group.
    A similar thing applies to remove elements.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用缓动函数在500ms内将透明度从0.01过渡到1。这很简单，但我们可以创建更复杂的动画，我们还可以动画化组件的不同状态。例如，当新的元素作为过渡组的子元素被添加时，会应用`*-enter`和`*-enter-active`类。类似的事情也适用于删除元素。
- en: 'After delving into the dynamic world of animations and understanding how they
    can dramatically enhance our React components, let’s now turn our attention to
    another fascinating facet of web design: the exploration of **Scalable Vector
    Graphics** (**SVG**).'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究动画的动态世界并了解它们如何极大地增强我们的React组件之后，现在让我们将注意力转向网络设计的另一个迷人方面：可伸缩矢量图形（**SVG**）的探索。
- en: Exploring SVG
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索SVG
- en: Finally, one of the most interesting techniques we can apply in the browser
    to draw icons and graphs is SVG.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在浏览器中应用的一种最有趣的技巧是使用SVG来绘制图标和图表。
- en: SVG is great because it is a declarative way of describing vectors and it fits
    perfectly with the purposes of React. We used to use icon fonts to create icons,
    but they have well-known problems, with the first being that they are not accessible.
    It is also pretty hard to position icon fonts with CSS, and they do not always
    look beautiful in all browsers. These are the reasons we should prefer SVG for
    our web applications.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: SVG很棒，因为它是一种描述矢量的声明性方式，它与React的目的完美契合。我们过去使用图标字体来创建图标，但它们有众所周知的问题，首先是它们不可访问。使用CSS定位图标字体也很困难，并且它们并不总是在所有浏览器中看起来都很漂亮。这就是我们应该在我们的Web应用程序中优先考虑SVG的原因。
- en: From a React point of view, it does not make any difference if we output a div
    or an SVG element from the render method, and this is what makes it so powerful.
    We also tend to choose SVG because we can easily modify them at runtime using
    CSS and JavaScript, which makes them an excellent candidate for the functional
    approach of React.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 从React的角度来看，无论我们从渲染方法中输出div还是SVG元素，这都没有任何区别，这也是它如此强大的原因。我们也倾向于选择SVG，因为我们可以使用CSS和JavaScript轻松地在运行时修改它们，这使得它们成为React函数式方法的绝佳候选者。
- en: So, if we think about our components as a function of their props, we can easily
    imagine how we can create self-contained SVG icons that we can manipulate by passing
    different props to them. A common way to create SVG in a web app with React is
    to wrap our vectors into a React component and use the props to define their dynamic
    values.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们把我们的组件视为其属性的函数，我们就可以很容易地想象出如何创建自包含的SVG图标，我们可以通过向它们传递不同的属性来操作它们。在React
    web应用中创建SVG的一个常见方法是将我们的矢量包装在一个React组件中，并使用属性来定义它们的动态值。
- en: 'Let’s look at a simple example where we draw a blue circle, thus creating a
    React component that wraps an SVG element:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的例子，我们画一个蓝色圆圈，从而创建一个包装SVG元素的React组件：
- en: '[PRE35]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you can see, we can easily use a stateless functional component that wraps
    the SVG markup, and it accepts the same props as SVG does.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们可以轻松使用无状态的函数式组件来包装SVG标记，并且它接受SVG相同的属性。
- en: 'An example usage is as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例用法：
- en: '[PRE36]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We can obviously use the full power of React and set some default parameters
    so that, if the circle icon is rendered without props, we still show something.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们显然可以使用React的全部功能并设置一些默认参数，这样，如果圆图标没有属性被渲染，我们仍然会显示一些内容。
- en: 'For example, we can define the default color:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以定义默认颜色：
- en: '[PRE37]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is pretty powerful when we build UIs, especially in a team where we share
    our icon set and we want to have some default values in it, but we also want to
    let other teams decide their settings without having to recreate the same SVG
    shapes.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建UI时，这非常强大，尤其是在一个团队中，我们共享我们的图标集，并希望在它中设置一些默认值，但我们也希望让其他团队决定他们的设置，而无需重新创建相同的SVG形状。
- en: However, in some cases, we prefer to be stricter and fix some values to keep
    consistency. With React, this is a super simple task.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，我们更喜欢更加严格，并固定一些值以保持一致性。使用React，这是一个超级简单的任务。
- en: 'For example, we can wrap the base circle component into `RedCircle`, as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以将基本圆圈组件包裹在`RedCircle`中，如下所示：
- en: '[PRE38]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, the color is set by default, and it cannot be changed, while the other
    props are transparently passed to the original circle.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，颜色默认设置，并且不能更改，而其他属性则透明地传递给原始圆。
- en: 'The following screenshot shows two circles, blue and red, that are generated
    by React using SVG:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了由React使用SVG生成的两个圆圈，蓝色和红色：
- en: '![Icon  Description automatically generated](img/B18414_05_01.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图标描述自动生成](img/B18414_05_01.png)'
- en: 'Figure 5.1: Two circles, blue and red SVGs'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：两个圆圈，蓝色和红色SVG
- en: We can apply this technique and create different variations of the circle, such
    as `SmallCircle` and `RightCircle`, and everything else we need to build our UIs.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以应用这种技术并创建圆的不同变体，例如`SmallCircle`和`RightCircle`，以及构建我们的UI所需的一切。
- en: Summary
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the different capabilities of React when targeting
    the browser, from creating forms and handling events to animating SVGs. We also
    learned about the new `useRef` Hook, which provides a simple way to access DOM
    nodes. React’s declarative approach simplifies the management of complex web applications.
    Additionally, React provides a way to access the DOM nodes, allowing for imperative
    operations if needed, making it easier to integrate React with existing libraries.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了React在针对浏览器时的不同功能，从创建表单和处理事件到动画SVG。我们还学习了新的`useRef`钩子，它提供了一种简单的方式来访问DOM节点。React的声明式方法简化了复杂Web应用程序的管理。此外，React提供了一种访问DOM节点的方式，如果需要，可以进行命令式操作，这使得将React与现有库集成变得更加容易。
- en: In the next chapter, we will delve into CSS and inline styles, and explore the
    concept of writing CSS in JavaScript.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入研究CSS和内联样式，并探讨在JavaScript中编写CSS的概念。
