- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Structuring User Interfaces with Components
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用组件构建用户界面
- en: So far, we have had the opportunity to take a bird’s-eye view of the Angular
    framework. We learned how to create a new Angular application using the Angular
    CLI and how to interact with an Angular component using template syntax. We also
    explored TypeScript, which will help us understand how to write Angular code.
    We have everything we need to explore the further possibilities that Angular brings
    to the game regarding creating interactive components and how they can communicate
    with each other.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有机会从宏观的角度了解 Angular 框架。我们学习了如何使用 Angular CLI 创建新的 Angular 应用程序，以及如何使用模板语法与
    Angular 组件进行交互。我们还探讨了 TypeScript，这将帮助我们理解如何编写 Angular 代码。我们已经拥有了探索 Angular 带来的更多可能性的所有工具，包括创建交互式组件以及它们如何相互通信。
- en: 'In this chapter, we will learn about the following concepts:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下概念：
- en: Creating our first component
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们的第一个组件
- en: Interacting with the template
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与模板交互
- en: Component inter-communication
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件间通信
- en: Encapsulating CSS styling
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装 CSS 样式
- en: Deciding on a change detection strategy
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定变更检测策略
- en: Introducing the component lifecycle
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍组件生命周期
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter contains various code samples to walk you through Angular components.
    You can find the related source code in the `ch03` folder of the following GitHub
    repository:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含各种代码示例，以引导您了解 Angular 组件。您可以在以下 GitHub 仓库的 `ch03` 文件夹中找到相关源代码：
- en: '[https://www.github.com/PacktPublishing/Learning-Angular-Fifth-Edition](https://www.github.com/PacktPublishing/Learning-Angular-Fifth-Edition
    )'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.github.com/PacktPublishing/Learning-Angular-Fifth-Edition](https://www.github.com/PacktPublishing/Learning-Angular-Fifth-Edition)'
- en: Creating our first component
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的第一个组件
- en: 'Components are the basic building blocks of an Angular application. They control
    different web page parts called **views** , such as a list of products or an order
    checkout form. They are responsible for the presentational logic of an Angular
    application, and they are organized in a hierarchical tree of components that
    can interact with each other:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是 Angular 应用程序的基本构建块。它们控制不同的网页部分，称为 **视图**，例如产品列表或订单结账表单。它们负责 Angular 应用程序的展示逻辑，并且它们组织在一个可以相互交互的组件分层树中：
- en: '![A picture containing icon  Description automatically generated](img/B21418_03_01.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![包含图标  自动生成的描述](img/B21418_03_01.png)'
- en: 'Figure 3.1: Component architecture'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1：组件架构
- en: The architecture of an Angular application is based on Angular components. Each
    Angular component can communicate and interact with one or more components in
    the component tree. As we can see Figure 3.1, a component can simultaneously be
    a parent of some child components and a child of another parent component.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 应用程序的架构基于 Angular 组件。每个 Angular 组件都可以与组件树中的一个或多个组件进行通信和交互。如图 3.1 所示，一个组件可以同时是某些子组件的父组件，也是另一个父组件的子组件。
- en: 'In this section, we will explore the following topics about Angular components:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨以下关于 Angular 组件的主题：
- en: The structure of an Angular component
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 组件的结构
- en: Creating components with the Angular CLI
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Angular CLI 创建组件
- en: We will start our journey by investigating the internals of Angular components.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从调查 Angular 组件的内部结构开始我们的旅程。
- en: The structure of an Angular component
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular 组件的结构
- en: 'As we learned in *Chapter 1* , *Building Your First Angular Application* ,
    a typical Angular application contains at least a main component that consists
    of multiple files. The TypeScript class of the component is defined in the `app.component.ts`
    file:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 *第一章*，*构建您的第一个 Angular 应用程序* 中所学，一个典型的 Angular 应用程序至少包含一个主组件，该组件由多个文件组成。组件的
    TypeScript 类定义在 `app.component.ts` 文件中：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `@Component` is an **Angular decorator** that defines the properties of
    the Angular component. An Angular decorator is a method that accepts an object
    with metadata as a parameter. The metadata is used to configure a TypeScript class
    as an Angular component using the following properties:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Component` 是一个 **Angular 装饰器**，用于定义 Angular 组件的属性。Angular 装饰器是一个接受包含元数据对象作为参数的方法。元数据用于使用以下属性将
    TypeScript 类配置为 Angular 组件：'
- en: '`selecto` `r` : A CSS selector that instructs Angular to load the component
    in the location that finds the corresponding tag in an HTML template. The Angular
    CLI adds the `app` prefix by default, but you can customize it using the `--prefix`
    option when creating the Angular project.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selector`：一个 CSS 选择器，指示 Angular 在 HTML 模板中找到相应标签的位置加载组件。Angular CLI 默认添加 `app`
    前缀，但您可以在创建 Angular 项目时使用 `--prefix` 选项来自定义它。'
- en: '`imports` : Defines a list of Angular artifacts that the component needs to
    be loaded correctly, such as other Angular components. The Angular CLI adds the
    `RouterOutlet` in the main application component by default. The `RouterOutlet`
    is used when we need routing capabilities in an Angular application. We will learn
    how to configure routing in *Chapter 9* , *Navigating through Applications with
    Routing* .'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`imports`：定义组件需要正确加载的 Angular 艺术品列表，例如其他 Angular 组件。Angular CLI 默认在主应用程序组件中添加
    `RouterOutlet`。当我们在 Angular 应用程序中需要路由功能时，会使用 `RouterOutlet`。我们将在 *第 9 章* 中学习如何配置路由，即
    *使用路由在应用程序中导航*。'
- en: '`templateUrl` : Defines the path of an external HTML file that contains the
    HTML template of the component. Alternatively, you can provide the template inline
    using the `template` property.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`templateUrl`：定义包含组件 HTML 模板的外部 HTML 文件的路径。或者，您可以使用 `template` 属性在行内提供模板。'
- en: '`styleUrl` : Defines the path of an external CSS style sheet file that contains
    the CSS styles of the component. Alternatively, you can provide the styles inline
    using the `styles` property.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`styleUrl`：定义包含组件 CSS 样式的外部 CSS 样式表文件的路径。或者，您可以使用 `styles` 属性在行内提供样式。'
- en: In applications built with older Angular versions, you may notice that the `imports`
    property is missing from the `@Component` decorator. This is because such components
    rely on Angular modules to provide the necessary functionality.
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在使用较旧版本的 Angular 构建的应用程序中，您可能会注意到 `@Component` 装饰器中缺少 `imports` 属性。这是因为此类组件依赖于
    Angular 模块来提供必要的功能。
- en: However, starting from Angular v16, the `standalone` property was introduced
    as an alternative to Angular modules. With Angular v19, **standalone components**
    are now the default and are enforced throughout the project structure. This shift
    means that applications created with Angular v19 will utilize the `imports` array
    in standalone components by default, marking a significant departure from the
    module-based architecture of earlier versions.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，从 Angular v16 版本开始，引入了 `standalone` 属性作为 Angular 模块的一个替代方案。在 Angular v19
    版本中，**独立组件** 现在成为默认选项，并在整个项目结构中强制执行。这种转变意味着使用 Angular v19 创建的应用程序将默认使用独立组件中的 `imports`
    数组，这标志着与早期版本基于模块的架构有显著的不同。
- en: Now that we have explored the structure of an Angular component, we will learn
    how to use the Angular CLI and create components by ourselves.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经探讨了 Angular 组件的结构，我们将学习如何使用 Angular CLI 并自行创建组件。
- en: Creating components with the Angular CLI
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Angular CLI 创建组件
- en: In addition to the main application component, we can create other Angular components
    that provide specific functionality to the application.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 除了主应用程序组件外，我们还可以创建其他 Angular 组件，为应用程序提供特定的功能。
- en: You will need an Angular application to follow along with the rest of the chapter.
    An option is to create a new Angular application by running the `ng new` command
    that you learned about in *Chapter 1* , *Building Your First Angular Application*
    . Alternatively, you can get the source code from the GitHub repository mentioned
    in the *Technical requirements* section of the same chapter.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要有一个 Angular 应用程序才能跟随本章的其余部分。一个选择是运行您在 *第 1 章* 中学到的 `ng new` 命令来创建一个新的 Angular
    应用程序。或者，您可以从本章 *技术要求* 部分提到的 GitHub 仓库中获取源代码。
- en: 'To create a new component in an Angular application, we use the `ng generate`
    command of the Angular CLI, passing the name of the component as a parameter.
    Run the following command inside the root folder of the current Angular CLI workspace:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Angular 应用程序中创建一个新的组件，我们使用 Angular CLI 的 `ng generate` 命令，并将组件名称作为参数传递。请在当前
    Angular CLI 工作区的根目录中运行以下命令：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding command creates a dedicated folder for the component named `product-list`
    that contains all the necessary files:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令为组件创建了一个名为 `product-list` 的专用文件夹，其中包含所有必要的文件：
- en: The `product-list.component.css` file, which does not contain any CSS styles
    yet.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`product-list.component.css` 文件，目前还没有包含任何 CSS 样式。'
- en: 'The `product-list.component.html` file, which contains a paragraph element
    that displays static text:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含显示静态文本的段落元素的 `product-list.component.html` 文件：
- en: '[PRE2]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `product-list.component.spec.ts` file, which contains a unit test that
    checks if the component can be created successfully:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含一个单元测试的 `product-list.component.spec.ts` 文件，该测试检查组件是否可以成功创建：
- en: '[PRE3]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We will learn more about unit testing and its syntax in *Chapter 13* , *Unit
    Testing Angular Applications* .
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 *第 13 章* 中学习更多关于单元测试及其语法的知识，即 *单元测试 Angular 应用程序*。
- en: 'The `product-list.component.ts` file, which contains the presentational logic
    of our component:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含我们组件展示逻辑的 `product-list.component.ts` 文件：
- en: '[PRE4]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this section, we focused on the TypeScript class of Angular components, but
    how do they interact with their HTML template?
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们专注于 Angular 组件的 TypeScript 类，但它们是如何与它们的 HTML 模板交互的呢？
- en: In the following section, we will learn how to display the HTML template of
    an Angular component on a page. We will also see how to use the Angular template
    syntax to interact between the TypeScript class of the component and its HTML
    template.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下部分，我们将学习如何在页面上显示 Angular 组件的 HTML 模板。我们还将了解如何使用 Angular 模板语法在组件的 TypeScript
    类和其 HTML 模板之间进行交互。
- en: Interacting with the template
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与模板交互
- en: 'As we have learned, creating an Angular component using the Angular CLI involves
    generating a set of accompanying files. One of these files is the component template
    containing the HTML content displayed on the page. In this section, we will explore
    how to display and interact with the template through the following topics:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所学的，使用 Angular CLI 创建 Angular 组件涉及生成一系列配套文件。其中之一是包含在页面中显示的 HTML 内容的组件模板。在本节中，我们将通过以下主题探索如何显示和与模板交互：
- en: Loading the component template
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载组件模板
- en: Displaying data from the component class
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示组件类中的数据
- en: Styling the component
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件样式化
- en: Getting data from the template
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从模板获取数据
- en: We will start our journey in the component template by exploring how we render
    a component on the web page.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在组件模板中开始我们的旅程，探索如何在网页上渲染组件。
- en: Loading the component template
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载组件模板
- en: We learned that Angular uses the `selector` property to load the component in
    an HTML template. A typical Angular application loads the template of the main
    component at application startup. The `<app-root>` tag we saw in *Chapter 1* ,
    *Building Your First Angular Application* , is the `selector` of the main application
    component.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到 Angular 使用 `selector` 属性在 HTML 模板中加载组件。典型的 Angular 应用程序在应用程序启动时加载主组件的模板。我们在
    *第一章* 中看到的 `<app-root>` 标签是主应用程序组件的 `selector`。
- en: 'To load a component we have created, such as the product list component, we
    must add its `selector` inside an HTML template. For this scenario, we will load
    it in the template of the main application component:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载我们创建的组件，例如产品列表组件，我们必须在 HTML 模板中添加其 `selector`。对于此场景，我们将在主应用程序组件的模板中加载它：
- en: Open the `app.component.html` file and move the contents of the `<style>` tag
    in the `app.component.css` file.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `app.component.html` 文件并将 `app.component.css` 文件中 `<style>` 标签的内容移动过来。
- en: It is more maintainable and considered a best practice to have all CSS styles
    in a separate file.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有 CSS 样式放在一个单独的文件中，这样做更易于维护，并且被认为是最佳实践。
- en: 'Modify the `app.component.html` file by adding the `<app-product-list>` tag
    inside the `<div>` tag with the `content` class:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在具有 `content` 类的 `<div>` 标签内添加 `<app-product-list>` 标签来修改 `app.component.html`
    文件：
- en: '[PRE5]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We can also use self-enclosing tags, similar to `<input>` and `<img>` HTML elements,
    to add the product list component as `<app-product-list />` .
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用自闭合标签，类似于 `<input>` 和 `<img>` HTML 元素，将产品列表组件添加为 `<app-product-list />`
    。
- en: 'Run the `ng serve` command in a terminal window to start the Angular application.
    The command will fail, stating the following error:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端窗口中运行 `ng serve` 命令以启动 Angular 应用程序。该命令将失败，并显示以下错误：
- en: '[PRE6]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This error is caused because the main application component does not recognize
    the product list component yet.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此错误是由于主应用程序组件尚未识别产品列表组件。
- en: 'Open the `app.component.ts` file and import the `ProductListComponent` class:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `app.component.ts` 文件并导入 `ProductListComponent` 类：
- en: '[PRE7]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: After the application has been built successfully, navigate to `http://localhost:4200`
    to preview it. The web page displays the static text from the template of the
    product list component.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序构建成功后，导航到 `http://localhost:4200` 预览它。网页显示产品列表组件模板中的静态文本。
- en: In the following sections, we will see how to use the Angular template syntax
    and interact with the template through the TypeScript class. We will start exploring
    how to display dynamic data defined in the TypeScript class of the component.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将看到如何使用Angular模板语法，并通过TypeScript类与模板交互。我们将开始探索如何显示在组件TypeScript类中定义的动态数据。
- en: Displaying data from the component class
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从组件类显示数据
- en: 'We have already stumbled upon interpolation to display a property value as
    text from the component class to the template:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经遇到了插值来显示从组件类到模板的属性值作为文本：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Angular converts the `title` component property into text and displays it on
    the screen.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Angular将`title`组件属性转换为文本并在屏幕上显示。
- en: 'An alternative way to perform interpolation is to bind the `title` property
    to the `innerText` property of the `<h1>` HTML element, a method called **property
    binding** :'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 执行插值的另一种方法是绑定`title`属性到`<h1>`HTML元素的`innerText`属性，这种方法称为**属性绑定**：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding snippet, we bind to the DOM property of an element and *not*
    its HTML attribute, as it looks at first sight. The property inside square brackets
    is called the **target property** and is the property of the DOM element into
    which we want to bind. The variable on the right is called the **template expression**
    and corresponds to the `title` property of the component.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们绑定到元素的DOM属性，而不是其HTML属性，乍一看是这样的。方括号内的属性称为**目标属性**，是我们想要绑定到其中的DOM元素的属性。右侧的变量称为**模板表达式**，对应于组件的`title`属性。
- en: When we open a web page, the browser parses the HTML content of the page and
    converts it into a tree structure, the DOM. Each HTML element of the page is converted
    into an object called a **node** , which represents part of the DOM. A node defines
    a set of properties and methods representing the object API. The `innerText` is
    such a property and is used to set the text inside of an HTML element.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打开一个网页时，浏览器解析页面的HTML内容并将其转换为树结构，即DOM。页面上的每个HTML元素都转换为称为**节点**的对象，它代表DOM的一部分。节点定义了一组属性和方法，代表对象API。`innerText`是这样一个属性，用于设置HTML元素内的文本。
- en: To better understand how the Angular templating mechanism works, we first need
    to understand how Angular interacts with attributes and properties. It defines
    HTML attributes to initialize a DOM property and then uses data binding to interact
    directly with the property.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解Angular模板机制的工作原理，我们首先需要了解Angular如何与属性和属性交互。它定义HTML属性以初始化DOM属性，然后使用数据绑定直接与属性交互。
- en: 'To set the attribute of an HTML element, we use the `attr.` syntax through
    property binding followed by the attribute name. For example, to set the `aria-label`
    accessibility attribute of an HTML element, we would write the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置HTML元素的属性，我们使用属性绑定后的`attr.`语法，后跟属性名称。例如，要设置HTML元素的`aria-label`无障碍属性，我们会写如下：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the preceding snippet, `myText` is a property of an Angular component. Remember
    that property binding interacts with the properties of an Angular component. Therefore,
    if we wanted to set the value of the `innerText` property directly to the HTML,
    we would write the text value surrounded by single quotes:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`myText`是Angular组件的一个属性。记住，属性绑定与Angular组件的属性交互。因此，如果我们想直接将`innerText`属性的值设置到HTML中，我们会写上单引号包围的文本值：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this case, the value passed to the `innerText` property is static text, not
    a component property.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，传递给`innerText`属性的值是静态文本，而不是组件属性。
- en: Property binding in the Angular framework binds property values from the component
    TypeScript class into the template. As we will see next, the **control flow syntax**
    is suitable for coordinating how those values will be displayed in the template.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular框架中，属性绑定将组件TypeScript类中的属性值绑定到模板中。正如我们接下来将要看到的，**控制流语法**适合协调这些值如何在模板中显示。
- en: Controlling data representation
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制数据表示
- en: 'The new control flow syntax introduced in the latest versions of the Angular
    framework allows us to manipulate how data will be represented in the component
    template. It features a set of built-in blocks that add the following capabilities
    to the Angular template syntax:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Angular框架最新版本中引入的新控制流语法允许我们操作数据在组件模板中的表示方式。它提供了一套内置块，为Angular模板语法添加了以下功能：
- en: Displaying data conditionally
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件显示数据
- en: Iterating through data
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历数据
- en: Switching through templates
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切换模板
- en: In the following sections, we will explore the preceding capabilities, starting
    with displaying component data based on a conditional statement.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探索先前的功能，从基于条件语句显示组件数据开始。
- en: Displaying data conditionally
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 有条件地显示数据
- en: 'The `@if` block adds or removes an HTML element in the DOM based on evaluating
    an expression. If the expression evaluates to `true` , the element is inserted
    into the DOM. Otherwise, the element is removed from the DOM. We will illustrate
    the use of the `@if` block with an example:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`@if`块根据评估表达式来添加或删除DOM中的HTML元素。如果表达式评估为`true`，则元素被插入到DOM中。否则，元素将从DOM中删除。我们将通过一个示例来说明`@if`块的使用：'
- en: 'Run the following command to create an interface for products:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令来为产品创建一个接口：
- en: '[PRE12]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Open the `product.ts` file and add the following properties:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`product.ts`文件并添加以下属性：
- en: '[PRE13]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `Product` interface defines the structure of a `Product` object.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`Product`接口定义了`Product`对象的结构。'
- en: Open the `app.component.css` file and move the CSS styles that contain the `h1`
    and `p` selectors in the `product-list.component.css` file.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`app.component.css`文件并将包含`h1`和`p`选择器的CSS样式从`product-list.component.css`文件中移动出来。
- en: 'Open the `product-list.component.ts` file and create an empty `products` array:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`product-list.component.ts`文件并创建一个空的`products`数组：
- en: '[PRE14]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `products` array will be used to store a list of `Product` objects.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`products`数组将用于存储`Product`对象列表。'
- en: 'Open the `product-list.component.html` file and replace its content with the
    following snippet:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`product-list.component.html`文件并用以下片段替换其内容：
- en: '[PRE15]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `<h1>` element in the preceding HTML template is rendered on the screen
    when the `products` array is not empty. Otherwise, it is removed completely.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的HTML模板中，当`products`数组不为空时，`<h1>`元素会在屏幕上渲染。否则，它将被完全删除。
- en: 'The `@if` block behaves similarly to a JavaScript `if` statement. Thus, we
    can add an `@else` section in the component template to execute custom logic when
    there are not yet any products:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@if`块的行为类似于JavaScript的`if`语句。因此，我们可以在组件模板中添加一个`@else`部分，以便在没有产品时执行自定义逻辑：'
- en: '[PRE16]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If we had an additional condition that we would like to evaluate, we could
    use an `@else if` section:'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们有一个额外的条件想要评估，我们可以使用`@else if`部分：
- en: '[PRE17]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Run the `ng serve` command to preview the application so far:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`ng serve`命令来预览到目前为止的应用程序：
- en: '![Εικόνα που περιέχει γραμματοσειρά, τυπογραφία, κείμενο, καλλιγραφία  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_03_02.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![包含字体、字体样式、文本、书法的图片 自动生成的描述](img/B21418_03_02.png)'
- en: 'Figure 3.2: Application output'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2：应用程序输出
- en: 'In applications built with older Angular versions where the control flow syntax
    is not available, you may notice the `*ngIf` syntax was used to display conditional
    data:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用较旧版本的Angular构建的应用程序中，由于控制流语法不可用，你可能注意到使用了`*ngIf`语法来显示条件数据：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `*ngIf` is an **Angular directive** with the same behavior as the `@if`
    block. We will learn how to create custom Angular directives in the following
    chapter.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`*ngIf`是一个与`@if`块具有相同行为的**Angular指令**。我们将在下一章学习如何创建自定义Angular指令。'
- en: 'However, it is highly recommended to use the `@if` block for the following
    reasons:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，强烈建议使用`@if`块，以下是一些原因：
- en: Makes templates much more readable
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使得模板更加易于阅读
- en: The syntax is closer to JavaScript and is easier to remember
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法更接近JavaScript，更容易记住
- en: It is built into the framework and immediately available, which results in smaller
    bundle sizes
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它内置在框架中并且立即可用，这导致包的大小更小
- en: You can find more information about `*ngIf` at [https://angular.dev/guide/directives#adding-or-removing-an-element-with-ngif](https://angular.dev/guide/directives#adding-or-removing-an-element-with-ngif)
    .
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://angular.dev/guide/directives#adding-or-removing-an-element-with-ngif](https://angular.dev/guide/directives#adding-or-removing-an-element-with-ngif)找到更多关于`*ngIf`的信息。
- en: The application we have built does not display any data because the `products`
    array is empty. In the following section, we will learn how to add and display
    product data on the product list component.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建的应用程序没有显示任何数据，因为`products`数组是空的。在接下来的部分，我们将学习如何在产品列表组件中添加和显示产品数据。
- en: Iterating through data
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 遍历数据
- en: The `@for` block allows us to loop through a collection of items and render
    a template for each, where we can define convenient placeholders to interpolate
    item data. Each rendered template is scoped to the outer context, where the loop
    directive is placed so that we can access other bindings. We can think of the
    `@for` block as the JavaScript `for` loop but for HTML templates.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`@for` 块允许我们遍历一组项目并为每个项目渲染一个模板，其中我们可以定义方便的占位符来插值项目数据。每个渲染的模板都限定在放置循环指令的外部上下文中，这样我们就可以访问其他绑定。我们可以将
    `@for` 块视为 JavaScript `for` 循环，但用于 HTML 模板。'
- en: 'We can use the `@for` block to display the product list in our component as
    follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `@for` 块在组件中显示产品列表，如下所示：
- en: Open the `app.component.css` file and move the CSS styles that contain the .
    `pill-group` , `.pill` , and `.pill:hover` selectors in the `product-list.component.css`
    file.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `app.component.css` 文件，并将 `product-list.component.css` 文件中包含 `.pill-group`、`.pill`
    和 `.pill:hover` 选择器的 CSS 样式移动到 `app.component.css` 文件中。
- en: 'Modify the `products` array in the `ProductListComponent` class of the `product-list.component.ts`
    file so that it contains the following data:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `product-list.component.ts` 文件中 `ProductListComponent` 类的 `products` 数组，使其包含以下数据：
- en: '[PRE19]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Open the `product-list.component.html` file and add the following snippet after
    the `@if` block:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `product-list.component.html` 文件，并在 `@if` 块之后添加以下片段：
- en: '[PRE20]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding code, we use the `@for` block and turn each item fetched from
    the `products` array into a `product` variable called the **template input variable**
    . We reference the template variable in our HTML by binding its `title` property
    using Angular interpolation syntax.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用 `@for` 块并将从 `products` 数组中获取的每个元素转换为名为 **模板输入变量** 的 `product` 变量。我们通过使用
    Angular 插值语法绑定其 `title` 属性来在 HTML 中引用模板变量。
- en: During the execution of the `@for` block, data may change, HTML elements may
    be added, moved, or removed, and the whole list may even be replaced. Angular
    must synchronize data changes with the DOM tree by connecting the iterated array
    and its corresponding DOM element. It is a process that can become very slow and
    expensive and may eventually result in poor performance. For that purpose, Angular
    relies on the `track` property, which keeps track of data changes. In our case,
    the `track` property defines the property name of the `product` variable that
    will be used to keep track of every item in the `products` array.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `@for` 块的执行过程中，数据可能会改变，HTML 元素可能会被添加、移动或删除，整个列表甚至可能被替换。Angular 必须通过连接迭代的数组和相应的
    DOM 元素来同步数据更改与 DOM 树。这是一个可能变得非常缓慢和昂贵的进程，并可能导致性能不佳。为此，Angular 依赖于 `track` 属性，该属性跟踪数据更改。在我们的例子中，`track`
    属性定义了 `product` 变量的属性名称，该属性将用于跟踪 `products` 数组中的每个项目。
- en: 'Run the `ng serve` command to preview the application:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `ng serve` 命令以预览应用程序：
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά, λογότυπο  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_03_03.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、屏幕截图、字体、标志的图像，自动生成的描述](img/B21418_03_03.png)'
- en: 'Figure 3.3: Product list'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3：产品列表
- en: 'The `@for` block supports adding an `@empty` section, which is executed when
    the array of items is empty. We can refactor our code by removing the `@else`
    section of the `@if` block and adding an `@empty` section as follows:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@for` 块支持添加一个 `@empty` 部分，当项目数组为空时执行。我们可以通过删除 `@if` 块的 `@else` 部分并添加以下 `@empty`
    部分来重构我们的代码：'
- en: '[PRE21]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `@for` block can observe changes in the underlying collection and add,
    remove, or sort the rendered templates as items are added, removed, or reordered
    in the collection. It is also possible to keep track of other useful properties
    as well. We can use the extended version of the `@for` block using the following
    syntax:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`@for` 块可以观察底层集合的变化，并在集合中的项目添加、删除或重新排序时添加、删除或排序渲染的模板。还可以跟踪其他有用的属性。我们可以使用以下语法使用
    `@for` 块的扩展版本：'
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `variable` is a template input variable that we can reference later in
    our template. The `property` can have the following values:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`variable` 是一个模板输入变量，我们可以在模板中稍后引用。`property` 可以有以下值：'
- en: '`$count` : Indicates the number of items in the array'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$count` : 表示数组中元素的数量'
- en: '`$index` : Indicates the index of the item in the array'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$index` : 表示数组中元素的索引'
- en: '`$first` / `$last` : Indicates whether the current item is the first or last
    one in the array'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$first` / `$last` : 表示当前元素是否是数组中的第一个或最后一个'
- en: '`$even` / `$odd` : Indicates whether the index of the item in the array is
    even or odd'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$even` / `$odd` : 表示数组中元素的索引是偶数还是奇数'
- en: We can use the preceding properties directly or by declaring an alias, as seen
    in the following example.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接使用前面的属性，或者通过声明一个别名来使用，如下面的示例所示。
- en: 'In the following snippet, Angular assigns the value of the `$index` property
    to the `i` input variable. The `i` variable is later used in the template to display
    each product as a numbered list:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，Angular 将 `$index` 属性的值赋给 `i` 输入变量。该 `i` 变量随后在模板中使用，以显示每个产品作为编号列表：
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Use the `$index` property in the `track` variable when unsure of which one you
    should pick from your object data. Additionally, it is recommended to use it when
    you don’t have any unique property in your object and you are not modifying the
    order of the list by deleting, adding, or moving elements.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当不确定应该从对象数据中选择哪一个时，在 `track` 变量中使用 `$index` 属性。此外，当你没有在对象中任何独特的属性，并且你不会通过删除、添加或移动元素来修改列表的顺序时，建议使用它。
- en: 'In applications built with older Angular versions, you may notice the following
    syntax for iterating over collections:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用较旧版本的 Angular 构建的应用程序中，你可能注意到底下的集合迭代语法：
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `*ngFor` is an Angular directive that works similarly to the `@for` block.
    However, it is highly recommended to use `@for` for the same reasons mentioned
    about the `@if` block in the previous section.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`*ngFor` 是一个与 `@for` 块类似工作的 Angular 指令。然而，强烈建议出于与上一节中提到的 `@if` 块相同的原因使用 `@for`。'
- en: You can find more information about `*ngFor` at [https://angular.dev/guide/directives#listing-items-with-ngfor](https://angular.dev/guide/directives#listing-items-with-ngfor)
    .
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://angular.dev/guide/directives#listing-items-with-ngfor](https://angular.dev/guide/directives#listing-items-with-ngfor)
    找到更多关于 `*ngFor` 的信息。
- en: The last block of the control flow syntax we will cover is the `@switch` block
    in the following section.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中介绍控制流语法的最后一个块，即 `@switch` 块。
- en: Switching through templates
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模板切换
- en: The `@switch` block switches between parts of the component template and displays
    each depending on a defined value.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`@switch` 块在组件模板的部分之间切换，并根据定义的值显示每个部分。'
- en: 'You can think of `@switch` like the JavaScript `switch` statement. It consists
    of the following sections:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 `@switch` 想象成 JavaScript 的 `switch` 语句。它由以下部分组成：
- en: '`@switch` : Defines the property that we want to check when applying the block'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@switch`：定义在应用该块时要检查的属性'
- en: '`@case` : Adds or removes a template from the DOM tree depending on the value
    of the property defined in the `@switch` block'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@case`：根据在 `@switch` 块中定义的属性的值，向 DOM 树中添加或删除模板'
- en: '`@default` : Adds a template to the DOM tree if the value of the property defined
    in the `@switch` block does not meet any `@case` statement'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@default`：如果 `@switch` 块中定义的属性的值不满足任何 `@case` 语句，则向 DOM 树中添加模板'
- en: 'We will learn how to use the `@switch` block by displaying a different emoji
    according to the product title. Open the `product-list.component.html` file and
    modify the `@for` block so that it includes the following `@switch` block:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过根据产品标题显示不同的表情符号来学习如何使用 `@switch` 块。打开 `product-list.component.html` 文件，并修改
    `@for` 块，使其包含以下 `@switch` 块：
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `@switch` block evaluates the `title` property of each product. When it
    finds a match, it activates the appropriate `@case` section. If the value of the
    `title` property does not match any `@case` section, the `@default` section is
    activated.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`@switch` 块评估每个产品的 `title` 属性。当它找到一个匹配项时，它激活相应的 `@case` 部分。如果 `title` 属性的值与任何
    `@case` 部分不匹配，则激活 `@default` 部分。'
- en: 'In applications built with older Angular versions, you may notice the following
    syntax for switching over parts of the template:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用较旧版本的 Angular 构建的应用程序中，你可能注意到底下的模板切换语法：
- en: '[PRE26]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `[ngSwitch]` is an Angular directive with the same behavior as the `@switch`
    block. However, it is highly recommended to use `@switch` for the same reasons
    mentioned about the `@if` block in the previous section.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`[ngSwitch]` 是一个具有与 `@switch` 块相同行为的 Angular 指令。然而，强烈建议出于与上一节中提到的 `@if` 块相同的原因使用
    `@switch`。'
- en: You can find more information about `[ngSwitch]` at [https://angular.dev/guide/directives#switching-cases-with-ngswitch](
    https://angular.dev/guide/directives#switching-cases-with-ngswitch) .
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://angular.dev/guide/directives#switching-cases-with-ngswitch](https://angular.dev/guide/directives#switching-cases-with-ngswitch)
    找到更多关于 `[ngSwitch]` 的信息。
- en: The simplicity and improved ergonomics of the control flow syntax have enabled
    the introduction of the `@defer` block in the Angular framework. The `@defer`
    block helps to enhance UX and improve application performance by loading parts
    of the component template asynchronously. We will learn more in *Chapter 15* ,
    *Optimizing Application Performance* .
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 控制流语法的简洁性和改进的人体工程学使得在Angular框架中引入`@defer`块成为可能。`@defer`块通过异步加载组件模板的部分来帮助增强用户体验和提高应用程序性能。我们将在第15章*优化应用程序性能*中了解更多内容。
- en: In this section, we learned how to leverage the control flow syntax and coordinate
    how data will be displayed on the component template.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何利用控制流语法并协调如何在组件模板上显示数据。
- en: If you want to use this syntax in applications that already use the old directive
    approach, you can execute the Angular CLI migration described at [https://angular.dev/reference/migrations/control-flow](https://angular.dev/reference/migrations/control-flow)
    .
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在已经使用旧指令方法的现有应用程序中使用此语法，可以执行Angular CLI迁移，详情请参阅[https://angular.dev/reference/migrations/control-flow](https://angular.dev/reference/migrations/control-flow)。
- en: As we will learn in the following section, property binding in the Angular framework
    applies CSS styles and classes in Angular templates.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在下一节中学习的，Angular框架中的属性绑定在Angular模板中应用CSS样式和类。
- en: Styling the component
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 组件样式化
- en: 'Styles in a web application can be applied using either the `class` or `style`
    attribute, or both, of an HTML element:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web应用程序中，可以使用HTML元素的`class`或`style`属性，或同时使用两者来应用样式：
- en: '[PRE27]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The Angular framework provides two types of property binding:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Angular框架提供两种类型的属性绑定：
- en: Class binding
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类绑定
- en: Style binding
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样式绑定
- en: Let’s begin our journey on component styling with class binding in the following
    section.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节开始我们的组件样式之旅，使用类绑定。
- en: Class binding
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类绑定
- en: 'We can apply a single class to an HTML element using the following syntax:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下语法将单个类应用到HTML元素上：
- en: '[PRE28]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the preceding snippet, the `star` class will be added to the paragraph element
    when the `isLiked` expression is `true` . Otherwise, it will be removed from the
    element. If we want to apply multiple CSS classes simultaneously, we can use the
    following syntax:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，当`isLiked`表达式为`true`时，`star`类将被添加到段落元素中。否则，它将从元素中移除。如果我们想同时应用多个CSS类，可以使用以下语法：
- en: '[PRE29]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `currentClasses` variable is a component property. The value of an expression
    that is used in a class binding can be one of the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`currentClasses`变量是一个组件属性。在类绑定中使用的表达式的值可以是以下之一：'
- en: A space-delimited string of class names such as `'star active'` .
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类名由空格分隔的字符串，例如`'star active'`。
- en: 'An object with keys as the class names and values as boolean conditions for
    each key. A class is added to the element when the value of the key, with its
    name, is evaluated to be `true` . Otherwise, the class is removed from the element:'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个对象，键是类名，值是每个键的布尔条件。当键的值（带有其名称）评估为`true`时，将向元素添加类。否则，将从元素中移除该类：
- en: '[PRE30]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Instead of styling our elements using CSS classes, we can set styles directly
    with the style binding.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用样式绑定直接设置元素的样式，而不是使用CSS类来样式化我们的元素。
- en: Style binding
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 样式绑定
- en: 'Like the class binding, we can apply single or multiple styles simultaneously
    using a style binding. A single style can be set to an HTML element using the
    following syntax:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 与类绑定类似，我们可以使用样式绑定同时应用单个或多个样式。可以使用以下语法将单个样式设置为HTML元素：
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the preceding snippet, the paragraph element will have a `greenyellow` color.
    Some styles can be expanded further in the binding, such as the `width` of the
    paragraph element, which we can define along with the measurement unit:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，段落元素将具有`greenyellow`颜色。一些样式可以在绑定中进一步展开，例如段落元素的`width`，我们可以定义它以及度量单位：
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The paragraph element will be `100` pixels long. If we need to toggle multiple
    styles at once, we can use the object syntax:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 段落元素将长`100`像素。如果我们需要同时切换多个样式，可以使用对象语法：
- en: '[PRE33]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `currentStyles` variable is a component property. The value of an expression
    that is used in a style binding can be one of the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`currentStyles`变量是一个组件属性。在样式绑定中使用的表达式的值可以是以下之一：'
- en: 'A string with styles separated by semicolons such as `''color: greenyellow;
    width: 100px''`'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '一个由分号分隔的样式字符串，例如`''color: greenyellow; width: 100px''`'
- en: 'An object where its keys are the names of styles and the values are the actual
    style values:'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个对象，其键是样式的名称，值是实际的样式值：
- en: '[PRE34]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Class and style bindings are powerful features that Angular provides out of
    the box. Together with the CSS styling configuration that we can define in the
    `@Component` decorator, it gives endless opportunities for styling Angular components.
    An equally compelling feature is the ability to read data from a template into
    the component class, which we look at next.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 类和样式绑定是 Angular 提供的强大功能，无需额外配置。结合我们可以在 `@Component` 装饰器中定义的 CSS 样式配置，它为 Angular
    组件的样式化提供了无限的机会。同样引人注目的功能是能够从模板读取数据到组件类，我们将在下一节中探讨这一点。
- en: Getting data from the template
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从模板获取数据
- en: 'In the previous section, we learned how to use property binding to display
    data from the component class. Real-world scenarios usually involve bidirectional
    data flow through components. To get data from the template back to the component
    class, we use a technique called **event binding** . We will learn how to use
    event binding by notifying the component class when a product has been selected
    from the list:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何使用属性绑定来显示来自组件类的数据。现实场景通常涉及组件之间的双向数据流。要从模板获取数据返回到组件类，我们使用一种称为**事件绑定**的技术。我们将通过在从列表中选择产品时通知组件类来学习如何使用事件绑定：
- en: 'Open the `product-list.component.ts` file and add a `selectedProduct` property:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `product-list.component.ts` 文件并添加一个 `selectedProduct` 属性：
- en: '[PRE35]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Open the `product-list.component.html` file and use the interpolation syntax
    to display the selected product if it exists:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `product-list.component.html` 文件，并使用插值语法来显示所选产品（如果存在）：
- en: '[PRE36]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Add a `click` event binding in the `<li>` tag to set the `selectedProduct`
    to the current `product` variable of the `@for` block:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `<li>` 标签中添加一个 `click` 事件绑定，将 `selectedProduct` 设置为 `@for` 块的当前 `product`
    变量：
- en: '[PRE37]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Run `ng serve` to start the application and click on a product from the list:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `ng serve` 以启动应用程序并从列表中选择一个产品：
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά, λογότυπο  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_03_04.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、屏幕截图、字体、标志的自动创建的描述](img/B21418_03_04.png)'
- en: 'Figure 3.4: Product selection'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4：产品选择
- en: An event binding listens for DOM events on the target HTML element and responds
    to those events by interacting with members of the component class. The event
    inside parentheses is called the **target event** and is the event we are currently
    listening to. The expression on the right is called the **template statement**
    and interacts with the component class. Event binding in Angular supports all
    native DOM events found at [https://developer.mozilla.org/docs/Web/Events](https://developer.mozilla.org/docs/Web/Events)
    .
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 事件绑定监听目标 HTML 元素上的 DOM 事件，并通过与组件类的成员交互来响应这些事件。括号内的事件称为**目标事件**，是我们当前正在监听的事件。右侧的表达式称为**模板语句**，它与组件类交互。Angular
    的事件绑定支持在 [https://developer.mozilla.org/docs/Web/Events](https://developer.mozilla.org/docs/Web/Events)
    找到的所有原生 DOM 事件。
- en: 'The interaction of a component template with its corresponding TypeScript class
    is summarized in the following diagram:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 组件模板与其相应的 TypeScript 类的交互总结在下述图中：
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά, γραμμή  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_03_05.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、屏幕截图、字体、行号的自动创建的描述](img/B21418_03_05.png)'
- en: 'Figure 3.5: Component-template interaction'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5：组件模板交互
- en: The same principle we followed for interacting with the component template and
    class can be used when communicating between components.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用于与组件模板和类交互的相同原则也可以用于组件之间的通信。
- en: Component inter-communication
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件间通信
- en: Angular components expose a public API that allows them to communicate with
    other components. This API encompasses input properties, which we use to feed
    the component with data. It also exposes output properties we can bind event listeners
    to, thereby getting timely information about changes in the component state.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 组件公开一个公共 API，允许它们与其他组件进行通信。此 API 包含输入属性，我们使用这些属性向组件提供数据。它还公开了我们可以绑定事件监听器的输出属性，从而及时获取有关组件状态变化的详细信息。
- en: In this section, we will learn how Angular solves the problem of injecting data
    into and extracting data from components through quick and easy examples.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过快速简单的示例学习 Angular 如何通过组件注入和提取数据解决问题。
- en: Passing data using an input binding
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用输入绑定传递数据
- en: The application currently displays the product list and the selected product
    details in the same component. To learn how to pass data between different components,
    we will create a new Angular component that will display the details of the selected
    product. Data representing the specific product details will be dynamically passed
    from the product list component.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当前应用程序在同一组件中显示产品列表和所选产品详情。为了学习如何在不同的组件之间传递数据，我们将创建一个新的Angular组件，该组件将显示所选产品的详情。表示特定产品详情的数据将从产品列表组件动态传递。
- en: 'We will start by creating and configuring the component to display product
    details:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建和配置组件以显示产品详情：
- en: 'Run the following Angular CLI command to create the new Angular component:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下Angular CLI命令以创建新的Angular组件：
- en: '[PRE38]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Open the `product-detail.component.ts` file and modify the `import` statements
    accordingly:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`product-detail.component.ts`文件并相应地修改`import`语句：
- en: '[PRE39]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `input` function is part of the Signals API and is used when we want to
    pass data from one component *down* to another component.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`input`函数是信号API的一部分，当我们想要将数据从一个组件向下传递到另一个组件时使用。'
- en: We will learn more about the Signals API in *Chapter 7* , *Tracking Application
    State with Signals* .
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*第7章*中了解更多关于信号API的内容，即使用信号跟踪应用程序状态。
- en: 'Define a `product` property in the `ProductDetailComponent` class that uses
    the `input` function:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ProductDetailComponent`类中定义一个`product`属性，使用`input`函数：
- en: '[PRE40]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In older versions of Angular, we use the `@Input` decorator for passing data
    between components. You can learn more at [https://angular.dev/guide/components/inputs](https://angular.dev/guide/components/inputs)
    .
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular的旧版本中，我们使用`@Input`装饰器在组件之间传递数据。您可以在[https://angular.dev/guide/components/inputs](https://angular.dev/guide/components/inputs)了解更多信息。
- en: 'Open the `product-detail.component.html` file and add the following contents:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`product-detail.component.html`文件并添加以下内容：
- en: '[PRE41]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the preceding snippet, we use an `@if` block to check if the `product` input
    property has been set before displaying its `title` .
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用`@if`块检查`product`输入属性是否已设置，然后再显示其`title`。
- en: 'Open the `product-list.component.ts` file and import the `ProductDetailComponent`
    class:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`product-list.component.ts`文件并导入`ProductDetailComponent`类：
- en: '[PRE42]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Finally, replace the last `@if` block in the `product-list.component.html`
    file with the following snippet:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将`product-list.component.html`文件中的最后一个`@if`块替换为以下代码片段：
- en: '[PRE43]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the preceding snippet, we use property binding to bind the value of the `selectedProduct`
    property into the `product` input property of the product detail component. This
    approach is called **input binding** .
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用属性绑定将`selectedProduct`属性的值绑定到产品详情组件的`product`输入属性。这种方法称为**输入绑定**。
- en: If we run the application and click on a product from the list, we will see
    that product selection continues to work as expected.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行应用程序并点击列表中的产品，我们会看到产品选择仍然按预期工作。
- en: 'The `@if` block in the template of the product detail component implies that
    the `product` input property is required; otherwise, it does not display its `title`
    . Angular does not know if the product list component passes a value for the `product`
    input binding during build time. If we want to enforce that rule during compile
    time, we can define an input property as required accordingly:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 产品详情组件模板中的`@if`块意味着`product`输入属性是必需的；否则，它不会显示其`title`。Angular在构建时不知道产品列表组件是否为`product`输入绑定传递了值。如果我们想在编译时强制执行此规则，我们可以相应地定义一个必需的输入属性：
- en: '[PRE44]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'According to the previous snippet, if the product list component does not pass
    a value for the `product` input property, the Angular compiler will throw the
    following error:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的代码片段，如果产品列表组件没有为`product`输入属性传递值，Angular编译器将抛出以下错误：
- en: '[PRE45]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: That’s it! We have successfully passed data from one component to another. In
    the following section, we’ll learn how to listen for events in a component and
    respond to them.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们已经成功地将数据从一个组件传递到另一个组件。在下一节中，我们将学习如何在组件中监听事件并对其做出响应。
- en: Listening for events using an output binding
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用输出绑定监听事件
- en: We learned that input binding is used when we want to pass data between components.
    This method is applicable in scenarios where we have two components, one that
    acts as the parent component and the other as the child. What if we want to communicate
    the other way, from the child component to the parent? How do we notify the parent
    component about specific actions in the child component?
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到，当我们需要在组件之间传递数据时，会使用输入绑定。这种方法适用于有两个组件的场景，一个作为父组件，另一个作为子组件。如果我们想从子组件向父组件进行通信呢？我们如何通知父组件关于子组件中的特定操作？
- en: 'Consider a scenario where the product detail component should have a button
    to add the current product to a shopping cart. The shopping cart would be a property
    of the product list component. How would the product detail component notify the
    product list component that the button was clicked? Let’s see how we would implement
    this functionality in our application:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个场景，其中产品详情组件应该有一个按钮，可以将当前产品添加到购物车中。购物车将是产品列表组件的一个属性。产品详情组件如何通知产品列表组件按钮已被点击？让我们看看我们如何在应用程序中实现这个功能：
- en: 'Open the `product-detail.component.ts` file and import the `output` function
    from the `@angular/core` npm package:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `product-detail.component.ts` 文件，并从 `@angular/core` npm 包中导入 `output` 函数：
- en: '[PRE46]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `output` function is used when we want to create events that will be triggered
    from one component *up* to another.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要创建从组件 *向上* 触发的事件时，会使用 `output` 函数。
- en: 'Define a new component property inside the `ProductDetailComponent` class that
    uses the `output` function:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ProductDetailComponent` 类中定义一个新的组件属性，该属性使用 `output` 函数：
- en: '[PRE47]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In older versions of Angular, we use the `@Output` decorator for triggering
    events between components. You can learn more at [https://angular.dev/guide/components/outputs](https://angular.dev/guide/components/outputs)
    .
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 的旧版本中，我们使用 `@Output` 装饰器在组件之间触发事件。您可以在 [https://angular.dev/guide/components/outputs](https://angular.dev/guide/components/outputs)
    上了解更多信息。
- en: 'In the same TypeScript class, create the following method:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个 TypeScript 类中，创建以下方法：
- en: '[PRE48]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `addToCart` method calls the `emit` method on the `added` output event we
    created in the previous step. The `emit` method triggers an event and notifies
    any component currently listening to that event.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`addToCart` 方法在之前步骤中创建的 `added` 输出事件上调用 `emit` 方法。`emit` 方法触发一个事件，并通知任何当前监听该事件的组件。'
- en: 'Now, add a `<button>` element in the component template and bind its `click`
    event to the `addToCart` method:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在组件模板中添加一个 `<button>` 元素，并将其 `click` 事件绑定到 `addToCart` 方法：
- en: '[PRE49]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Open the `product-detail.component.css` file and add the following CSS styles
    that will be applied to the `<button>` element:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `product-detail.component.css` 文件，并添加以下将应用于 `<button>` 元素的 CSS 样式：
- en: '[PRE50]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We are almost there! Now, we need to wire up the binding in the product list
    component so that the two components can communicate. Open the `product-list.component.ts`
    file and create the following method:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们几乎完成了！现在，我们需要在产品列表组件中设置绑定，以便两个组件可以通信。打开 `product-list.component.ts` 文件，并创建以下方法：
- en: '[PRE51]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In the preceding snippet, we use the native `alert` method of the browser to
    display a dialog to the user.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用浏览器的原生 `alert` 方法向用户显示一个对话框。
- en: 'Finally, modify the `<app-product-detail>` tag in the `product-list.component.html`
    file as follows:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，按照以下方式修改 `product-list.component.html` 文件中的 `<app-product-detail>` 标签：
- en: '[PRE52]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In the preceding snippet, we use event binding to bind the `onAdded` method
    into the `added` output property of the product detail component. This approach
    is called **output binding** .
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用事件绑定将 `onAdded` 方法绑定到产品详情组件的 `added` 输出属性。这种方法被称为 **输出绑定**。
- en: 'If we select a product from the list and click on the **Add to cart** button,
    a dialog box will display a message such as the following:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从列表中选择一个产品并点击 **添加到购物车** 按钮，对话框将显示如下消息：
- en: '**Web camera added to the cart!**'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '**已将网络摄像头添加到购物车！**'
- en: 'You can see an overview of the component communication mechanism that we have
    discussed in the following diagram:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下图中看到我们讨论的组件通信机制的概述：
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά, γραμμή  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_03_06.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本的图像，屏幕截图，字体，行号，自动生成的描述](img/B21418_03_06.png)'
- en: 'Figure 3.6: Component inter-communication'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6：组件间通信
- en: The output event of the product detail component does nothing more and nothing
    less than emitting an event to the parent component. However, we can use it to
    pass arbitrary data through the `emit` method, as we will learn in the following
    section.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 产品详情组件的输出事件除了向父组件发出事件之外，没有做更多或更少的事情。然而，我们可以通过`emit`方法使用它来传递任意数据，正如我们将在下一节中学习的那样。
- en: Emitting data through custom events
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过自定义事件发送数据
- en: The `emit` method of an output event can accept any data to pass up to the parent
    component. It is best to define the data type that can be passed to enforce static
    type checking.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 输出事件的`emit`方法可以接受任何数据以传递给父组件。最好定义可以传递的数据类型以强制进行静态类型检查。
- en: 'Currently, the product list component already knows the selected product. Let’s
    assume that the product list component could only realize it after the user clicks
    on the **Add to cart** button:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，产品列表组件已经知道选定的产品。让我们假设产品列表组件只能在用户点击**添加到购物车**按钮后实现这一点：
- en: 'Open the `product-detail.component.ts` file and use generics to declare the
    type of data that will be passed into the product list component:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`product-detail.component.ts`文件，并使用泛型声明将传递到产品列表组件的数据类型：
- en: '[PRE53]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Modify the `addToCart` method so that the `emit` method passes the currently
    selected product:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`addToCart`方法，以便`emit`方法传递当前选定的产品：
- en: '[PRE54]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Open the `product-list.component.html` file and pass the `$event` variable
    in the `onAdded` method:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`product-list.component.html`文件，并在`onAdded`方法中传递`$event`变量：
- en: '[PRE55]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `$event` object is a reserved keyword in Angular that contains the payload
    data of an event emitter from an output binding, in our case, a `Product` object.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`$event`对象是Angular中的一个保留关键字，它包含来自输出绑定的事件发射器的有效负载数据，在我们的例子中是一个`Product`对象。'
- en: 'Open the `product-list.component.ts` file and change the signature of the `onAdded`
    method accordingly:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`product-list.component.ts`文件，并相应地更改`onAdded`方法的签名：
- en: '[PRE56]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: As we saw, output event bindings are a great way to notify a parent component
    about a change in the component state or send any data.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，输出事件绑定是一种通知父组件组件状态变化或发送任何数据的好方法。
- en: Besides using the input and output bindings for communicating with components,
    we can access their properties and methods directly using local **template reference
    variables** .
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用输入和输出绑定与组件进行通信外，我们还可以直接使用局部**模板引用变量**访问它们的属性和方法。
- en: Local reference variables in templates
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板中的局部引用变量
- en: We have seen how to bind data to our templates using interpolation with the
    double curly braces syntax. Besides this, we often spot named identifiers prefixed
    by a hash symbol ( `#` ) in the elements belonging to our components or even regular
    HTML elements. These reference identifiers, namely, template reference variables,
    refer to the components flagged with them in our template views and then access
    them programmatically. Components can also use them to refer to other elements
    in the DOM and access their properties.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用双大括号语法进行插值将数据绑定到我们的模板中。除此之外，我们经常在我们的组件元素或甚至是常规HTML元素中看到以井号符号（`#`）为前缀的命名标识符。这些引用标识符，即模板引用变量，指的是我们在模板视图中标记的组件，然后通过编程方式访问它们。组件也可以使用它们来引用DOM中的其他元素并访问它们的属性。
- en: We have learned how components communicate by listening to emitted events using
    output binding or passing data through input binding. But what if we could inspect
    the component in depth, or at least its exposed properties and methods, and access
    them without going through the input and output bindings? Setting a local reference
    on the component opens the door to its public API.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了组件如何通过监听使用输出绑定的发出事件或通过输入绑定传递数据来进行通信。但如果我们能够深入检查组件，或者至少是其公开的属性和方法，并且无需通过输入和输出绑定来访问它们怎么办？在组件上设置局部引用为访问其公共API打开了大门。
- en: The public API of a component consists of all `public` members of the TypeScript
    class.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的公共API由TypeScript类的所有`public`成员组成。
- en: 'We can declare a template reference variable for the product detail component
    in the `product-list.component.html` file as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`product-list.component.html`文件中为产品详情组件声明一个模板引用变量，如下所示：
- en: '[PRE57]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'From that moment, we can access the component members directly and even bind
    them in other locations of the template, such as displaying the product title:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 从那一刻起，我们可以直接访问组件成员，甚至可以在模板的其他位置绑定它们，例如显示产品标题：
- en: '[PRE58]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This way, we do not need to rely on the input and output properties and can
    manipulate the value of such properties.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就不需要依赖于输入和输出属性，并且可以操作这些属性的值。
- en: The local reference variable approach is particularly useful when using libraries
    where we cannot control the child components to add input or output binding properties.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用无法控制子组件添加输入或输出绑定属性库时，局部引用变量方法特别有用。
- en: We have mainly explained how the component class interacts with its template
    or other components but have barely been concerned about their styling. We explore
    that in more detail next.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们主要解释了组件类如何与其模板或其他组件交互，但几乎没有关注它们的样式。我们将在下一部分更详细地探讨这一点。
- en: Encapsulating CSS styling
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 封装CSS样式
- en: We can define CSS styling within our components to better encapsulate our code
    and make it more reusable. In the *Creating our first component* section, we learned
    how to define CSS styles for a component using an external CSS file through the
    `styleUrl` property or by defining CSS styles inside the TypeScript component
    file with the `styles` property.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在组件内部定义CSS样式，以更好地封装我们的代码并使其更具可重用性。在*创建我们的第一个组件*部分，我们学习了如何使用`styleUrl`属性通过外部CSS文件定义组件的CSS样式，或者通过TypeScript组件文件中的`styles`属性在文件内部定义CSS样式。
- en: 'The usual rules of CSS specificity govern both ways: [https://developer.mozilla.org/docs/Web/CSS/Specificity](https://developer.mozilla.org/docs/Web/CSS/Specificity)
    .'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: CSS特定性的常规规则同时适用于这两种方式：[https://developer.mozilla.org/docs/Web/CSS/Specificity](https://developer.mozilla.org/docs/Web/CSS/Specificity)。
- en: Thanks to scoped styling, CSS management and specificity become a breeze on
    browsers that support **shadow DOM** . CSS styles apply to the elements contained
    in the component, but they do not spread beyond their boundaries.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢作用域样式的存在，在支持**阴影DOM**的浏览器上，CSS管理和特定性变得非常简单。CSS样式应用于组件内的元素，但不会超出它们的边界。
- en: You can find more detail on shadow DOM at [https://developer.mozilla.org/docs/Web/API/Web_components/Using_shadow_DOM](https://developer.mozilla.org/docs/Web/API/Web_components/Using_shadow_DOM)
    .
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://developer.mozilla.org/docs/Web/API/Web_components/Using_shadow_DOM](https://developer.mozilla.org/docs/Web/API/Web_components/Using_shadow_DOM)上找到更多关于阴影DOM的详细信息。
- en: On top of that, Angular embeds style sheets in the `<head>` element of a web
    page so that they may affect other elements of our application. We can set up
    different levels of **view encapsulation** to prevent this from happening.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Angular将样式表嵌入网页的`<head>`元素中，以便它们可以影响我们应用的其他元素。我们可以设置不同级别的**视图封装**来防止这种情况发生。
- en: 'View encapsulation is how Angular needs to manage CSS scoping within the component.
    We can change it by setting the `encapsulation` property of the `@Component` decorator
    in one of the following `ViewEncapsulation` enumeration values:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 视图封装是Angular需要在组件内部管理CSS作用域的方式。我们可以通过设置`@Component`装饰器的`encapsulation`属性来改变它，以下是一些`ViewEncapsulation`枚举值：
- en: '`Emulated` : Entails an emulation of native scoping in shadow DOM by sandboxing
    the CSS rules under a specific selector that points to a component. This option
    is preferred to ensure that component styles do not leak outside the component
    and are not affected by other external styles. It is the default behavior in Angular
    CLI projects.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Emulated`：通过在指向组件的特定选择器下沙盒CSS规则来模拟阴影DOM中的本地作用域。此选项被首选以确保组件样式不会泄漏到组件外部，并且不受其他外部样式的影响。它是Angular
    CLI项目的默认行为。'
- en: '`Native` : Uses the native shadow DOM encapsulation mechanism of the renderer
    that works only on browsers that support shadow DOM.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Native`：使用渲染器的本地阴影DOM封装机制，仅在支持阴影DOM的浏览器上工作。'
- en: '`None` : Template or style encapsulation is not provided. The styles are injected
    as they were added into the `<head>` element of the document. It is the only option
    if shadow DOM-enabled browsers are not involved.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`None`：不提供模板或样式封装。样式按添加到文档`<head>`元素中的顺序注入。如果未涉及阴影DOM启用浏览器，则这是唯一选项。'
- en: 'We will explore the `Emulated` and `None` options due to their extended support
    using an example:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过一个示例来探索`Emulated`和`None`选项，因为它们具有扩展的支持：
- en: 'Open the `product-detail.component.html` file and enclose the contents of the
    `@if` block in a `<div>` element:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`product-detail.component.html`文件，并将`@if`块的内容包裹在一个`<div>`元素中：
- en: '[PRE59]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Open the `product-detail.component.css` file and add a CSS style to change
    the border of a `<div>` element:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`product-detail.component.css`文件，并添加一个CSS样式来改变`<div>`元素的边框：
- en: '[PRE60]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Run the application using the `ng serve` command and notice that the product
    detail component has a dashed border around it when you select a product:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ng serve`命令运行应用程序，并注意当你选择一个产品时，产品详情组件周围有一个虚线边框：
- en: '![Εικόνα που περιέχει κείμενο, γραμματοσειρά, στιγμιότυπο οθόνης, γραμμή  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_03_07.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、字体、屏幕截图、描述的图片](img/B21418_03_07.png)'
- en: 'Figure 3.7: Product details'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7：产品详情
- en: The style did not affect the `<div>` element in the `app.component.html` file
    because the default encapsulation scopes all CSS styles defined to the specific
    component.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 样式不会影响`app.component.html`文件中的`<div>`元素，因为默认的封装作用域将所有CSS样式定义到特定的组件中。
- en: The default view encapsulation is `Emulated` if we do not specify one explicitly.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有明确指定，默认视图封装是`Emulated`。
- en: 'Open the `product-detail.component.ts` file and set the component encapsulation
    to `ViewEncapsulation.None` :'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`product-detail.component.ts`文件，并将组件封装设置为`ViewEncapsulation.None`：
- en: '[PRE61]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The application output should look like the following:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序输出应如下所示：
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά, αριθμός  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_03_08.png)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、屏幕截图、字体、编号的图片](img/B21418_03_08.png)'
- en: 'Figure 3.8: No view encapsulation'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8：无视图封装
- en: In the preceding image, the CSS style leaked to the component tree and affected
    the `<div>` element of the main application component.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图像中，CSS样式泄漏到组件树中，影响了主应用程序组件的`<div>`元素。
- en: View encapsulation can solve many issues when styling our components. However,
    it should be used cautiously because, as we already learned, CSS styles may leak
    into parts of the application and produce unwanted effects.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 视图封装可以在我们为组件设置样式时解决许多问题。然而，应该谨慎使用，因为我们已经了解到，CSS样式可能会泄漏到应用程序的某些部分并产生不受欢迎的效果。
- en: The change detection strategy is another property of the `@Component` decorator
    that is very powerful. Let’s examine this next.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 变更检测策略是`@Component`装饰器的另一个非常强大的属性。让我们接下来看看这个。
- en: Deciding on a change detection strategy
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 决定变更检测策略
- en: Change detection is the mechanism that Angular uses internally to detect changes
    that occur in component properties and reflect these changes to the view. It is
    triggered on specific events, such as when the user clicks a button, an asynchronous
    request is completed, or a `setTimeout` and `setInterval` method is executed.
    Angular uses a process called **monkey patching** to modify such events by overwriting
    their default behavior using a library called **Zone.js** .
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 变更检测是Angular内部用来检测组件属性变化并将其反映到视图中的机制。它在特定事件上触发，例如当用户点击按钮、异步请求完成或执行`setTimeout`和`setInterval`方法时。Angular使用称为**monkey
    patching**的过程，通过使用名为**Zone.js**的库来覆盖这些事件的默认行为来修改这些事件。
- en: Every component has a change detector that detects whether a change has occurred
    in its properties by comparing the current value of a property with the previous
    one. If there are differences, it applies the change to the component template.
    In the product detail component, when the `product` input property changes as
    a result of an event that we mentioned earlier, the change detection mechanism
    runs for this component and updates the template accordingly.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 每个组件都有一个变更检测器，通过比较属性的当前值和上一个值来检测其属性是否发生变化。如果有差异，它将更改应用到组件模板中。在产品详情组件中，当`product`输入属性由于我们之前提到的事件而发生变化时，变更检测机制会为此组件运行并相应地更新模板。
- en: However, there are cases where this behavior is not desired, such as components
    that render a large amount of data. In that scenario, the default change detection
    mechanism is insufficient because it may introduce performance bottlenecks in
    the application. We could alternatively use the `changeDetection` property of
    the `@Component` decorator, which dictates the selected strategy the component
    will follow for change detection.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有些情况下我们不希望这种行为，例如渲染大量数据的组件。在这种情况下，默认的变更检测机制是不够的，因为它可能会在应用程序中引入性能瓶颈。我们可以使用`@Component`装饰器的`changeDetection`属性作为替代，它决定了组件将遵循的变更检测策略。
- en: 'We will learn how to use a change detection mechanism by profiling our Angular
    application with Angular DevTools:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过使用Angular DevTools分析我们的Angular应用程序来学习如何使用变更检测机制：
- en: 'Open the `product-detail.component.ts` file and create a getter property that
    returns the current product title:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `product-detail.component.ts` 文件，创建一个返回当前产品标题的 getter 属性：
- en: '[PRE62]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Open the `product-detail.component.html` file and replace the `product.title`
    expression inside the `<strong>` tag with the `productTitle` :'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `product-detail.component.html` 文件，并将 `<strong>` 标签内的 `product.title` 表达式替换为
    `productTitle`：
- en: '[PRE63]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Run the application using the `ng serve` command and preview it at `http://localhost:4200`
    .
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `ng serve` 命令运行应用程序，并在 `http://localhost:4200` 预览它。
- en: Start Angular DevTools, select the **Profiler** tab, and click the **Start recording**
    button to start profiling the Angular application.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Angular DevTools，选择 **Profiler** 选项卡，并点击 **开始录制** 按钮以开始分析 Angular 应用程序。
- en: 'Click on the **Keyboard** product from the product list and select the first
    bar in the bar chart to review change detection:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从产品列表中点击 **键盘** 产品，并在柱状图中选择第一个条形来审查变更检测：
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά, αριθμός  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_03_09.png)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、屏幕截图、字体、编号的图像，自动生成的描述](img/B21418_03_09.png)'
- en: 'Figure 3.9: Change detection bar chart'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9：变更检测柱状图
- en: In the preceding image, we can see that change detection is triggered for each
    component in the component tree of the application.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图像中，我们可以看到变更检测触发了应用程序组件树中的每个组件。
- en: 'Click on the **Add to cart** button and select the second bar in the bar chart:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **添加到购物车** 按钮，并在柱状图中选择第二个条形：
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά, επαγγελματική
    κάρτα  Περιγραφή που δημιουργήθηκε αυτόματα](img/B21418_03_10.png)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、线条、字体、屏幕截图的图像，自动生成的描述](img/B21418_03_10.png)'
- en: 'Figure 3.10: Change detection bar chart'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10：变更检测柱状图
- en: Angular executed change detection in the product detail component even though
    we did not change its properties.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有更改其属性，Angular 也在产品详情组件中执行了变更检测。
- en: 'Modify the `@Component` decorator of the `product-detail.component.ts` file
    by setting the `changeDetection` property to `ChangeDetectionStrategy.OnPush`
    :'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将 `product-detail.component.ts` 文件的 `@Component` 装饰器的 `changeDetection` 属性设置为
    `ChangeDetectionStrategy.OnPush` 来修改它：
- en: '[PRE64]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Repeat steps 4 to 6 and observe the output of the second bar in the change
    detection bar chart:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤 4 到 6，并观察变更检测柱状图的第二个条形输出：
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά, αριθμός  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_03_11.png)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、屏幕截图、字体、编号的图像，自动生成的描述](img/B21418_03_11.png)'
- en: 'Figure 3.11: Change detection bar chart'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.11：变更检测柱状图
- en: Change detection did not run for the product detail component this time.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这次没有为产品详情组件运行变更检测。
- en: 'Click on the **Microphone** product from the list and observe the new bar in
    the bar chart:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从列表中点击 **麦克风** 产品，并观察柱状图中的新条形：
- en: '![Εικόνα που περιέχει κείμενο, γραμμή, γραμματοσειρά, στιγμιότυπο οθόνης  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_03_12.png)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、线条、字体、屏幕截图的图像，自动生成的描述](img/B21418_03_12.png)'
- en: 'Figure 3.12: Change detection bar chart'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.12：变更检测柱状图
- en: Change detection ran this time because we changed the reference of the `product`
    input property. If we had just changed a property using the `OnPush` change detection
    strategy, the change detection mechanism would not have been triggered. You can
    learn about more change detection scenarios at [https://angular.dev/best-practices/skipping-subtrees](https://angular.dev/best-practices/skipping-subtrees)
    .
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这次运行了变更检测，因为我们更改了 `product` 输入属性的引用。如果我们只是使用 `OnPush` 变更检测策略更改了一个属性，变更检测机制就不会被触发。您可以在
    [https://angular.dev/best-practices/skipping-subtrees](https://angular.dev/best-practices/skipping-subtrees)
    了解更多变更检测场景。
- en: The change detection strategy is a mechanism that allows us to modify the way
    our components detect changes in their data, significantly improving performance
    in large-scale applications. It concludes our journey of configuring a component,
    but the Angular framework does not stop there. As we’ll learn in the following
    section, we can hook into specific times in the component lifecycle.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 变更检测策略是一种机制，允许我们修改组件检测其数据变化的方式，这在大型应用程序中可以显著提高性能。它结束了配置组件的旅程，但 Angular 框架并未止步于此。正如我们将在下一节中学习的，我们可以在组件生命周期的特定时间点进行挂钩。
- en: Introducing the component lifecycle
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍组件生命周期
- en: Lifecycle events are hooks that allow us to jump into specific stages in the
    lifecycle of a component and apply custom logic. They are optional to use but
    might be valuable if you understand how to use them.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期事件是钩子，允许我们在组件生命周期的特定阶段跳入并应用自定义逻辑。它们的使用是可选的，但如果你了解如何使用它们，可能会很有价值。
- en: Some hooks are considered best practices, while others help debug and understand
    what happens in an Angular application. A hook has an interface defining a method
    we need to implement. The Angular framework ensures the hook is called, provided
    we have implemented this method in the component.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 一些钩子被认为是最佳实践，而其他钩子有助于调试和理解 Angular 应用程序中发生的事情。钩子有一个定义我们需要实现的方法的接口。Angular 框架确保钩子被调用，前提是我们已在组件中实现了该方法。
- en: Defining the interface in the component is not obligatory but is considered
    a good practice. Angular cares only about whether we have implemented the actual
    method or not.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件中定义接口不是强制性的，但被认为是良好的实践。Angular 只关心我们是否实现了实际的方法，而不关心我们是否定义了接口。
- en: 'The most basic lifecycle hooks of an Angular component are:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 组件最基本的生命周期钩子包括：
- en: '`ngOnInit` : This is called when a component is initialized'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngOnInit`：当组件初始化时调用此方法'
- en: '`ngOnDestroy` : This is called when a component is destroyed'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngOnDestroy`：当组件被销毁时调用此方法'
- en: '`ngOnChanges` : This is called when values of input binding properties in the
    component change'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngOnChanges`：当组件中输入绑定属性的值发生变化时调用此方法'
- en: '`ngAfterViewInit` : This is called when Angular initializes the view of the
    current component and its child components'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngAfterViewInit`：当 Angular 初始化当前组件及其子组件的视图时调用此方法'
- en: All of these lifecycle hooks are available from the `@angular/core` npm package
    of the Angular framework.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些生命周期钩子都可在 Angular 框架的 `@angular/core` npm 包中找到。
- en: A full list of all the supported lifecycle hooks is available in the official
    Angular documentation at [https://angular.dev/guide/components/lifecycle](https://angular.dev/guide/components/lifecycle)
    .
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 所有支持的生命周期钩子的完整列表可在官方 Angular 文档中找到，网址为 [https://angular.dev/guide/components/lifecycle](https://angular.dev/guide/components/lifecycle)。
- en: We will explore each one through an example in the following sections. Let’s
    start with the `ngOnInit` hook, which is the most basic lifecycle event of a component.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中通过示例逐一探索这些方法。让我们从最基本的组件生命周期事件 `ngOnInit` 开始。
- en: Performing component initialization
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行组件初始化
- en: 'The `ngOnInit` lifecycle hook is a method called during the component initialization.
    All input bindings and data-bound properties have been set appropriately at this
    stage, and we can safely use them. Using the component `constructor` to access
    them may be tempting, but their values would not have been set at that point.
    We will learn how to use the `ngOnInit` lifecycle hook through the following example:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngOnInit` 生命周期钩子是在组件初始化期间调用的一个方法。在这个阶段，所有输入绑定和数据绑定属性都已适当地设置，我们可以安全地使用它们。使用组件的
    `constructor` 来访问它们可能很有吸引力，但那时的值尚未设置。我们将通过以下示例学习如何使用 `ngOnInit` 生命周期钩子：'
- en: 'Open the `product-detail.component.ts` file and add a `constructor` that logs
    the value of the `product` property in the browser console:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `product-detail.component.ts` 文件，并添加一个 `constructor` 方法，用于在浏览器控制台中记录 `product`
    属性的值：
- en: '[PRE65]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Import the `OnInit` interface from the `@angular/core` npm package:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `@angular/core` npm 包中导入 `OnInit` 接口：
- en: '[PRE66]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Add the `OnInit` interface to the list of implemented interfaces of the `ProductDetailComponent`
    class:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `OnInit` 接口添加到 `ProductDetailComponent` 类实现的接口列表中：
- en: '[PRE67]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Add the following method in the `ProductDetailComponent` class to log the same
    information as in step 1:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ProductDetailComponent` 类中添加以下方法，以记录与步骤 1 相同的信息：
- en: '[PRE68]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Open the `product-list.component.ts` file and set an initial value to the `selectedProduct`
    property:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `product-list.component.ts` 文件，并为 `selectedProduct` 属性设置一个初始值：
- en: '[PRE69]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Run the application using the `ng serve` command and inspect the output of
    the browser console:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `ng serve` 命令运行应用程序，并检查浏览器控制台输出：
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_03_13.png)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本的图片，屏幕截图，字体，自动生成的描述](img/B21418_03_13.png)'
- en: 'Figure 3.13: Console output'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.13：控制台输出
- en: The first message from the `constructor` contains an `undefined` value, but
    in the second message, the value of the `product` property is displayed correctly.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '`constructor` 的第一条消息包含一个 `undefined` 值，但在第二条消息中，`product` 属性的值显示正确。'
- en: Constructors should be relatively empty and devoid of logic other than setting
    initial variables. Adding business logic inside a constructor makes it challenging
    to mock it in testing scenarios.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数应该相对为空，并且除了设置初始变量之外不应包含其他逻辑。在构造函数中添加业务逻辑会使它在测试场景中难以模拟。
- en: Another good use of the `ngOnInit` hook is when we need to initialize a component
    with data from an external source, such as an Angular service, as we will learn
    in *Chapter 5* , *Managing Complex Tasks with Services* .
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngOnInit`钩子的另一个良好用途是在我们需要使用来自外部源的数据初始化组件时，例如Angular服务，正如我们将在第5章“使用服务管理复杂任务”中学习到的那样。'
- en: The Angular framewor k provides hooks for all stages of the component lifecycle,
    from initialization to destruction.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: Angular框架为组件生命周期的所有阶段提供了钩子，从初始化到销毁。
- en: Cleaning up component resources
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清理组件资源
- en: 'The interface we use to hook on the destruction event of a component is the
    `ngOnDestroy` lifecycle hook. We need to import the `OnDestroy` interface and
    implement the `ngOnDestroy` method to start using it:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用于挂钩组件销毁事件的接口是`ngOnDestroy`生命周期钩子。我们需要导入`OnDestroy`接口并实现`ngOnDestroy`方法，然后才能开始使用它：
- en: '[PRE70]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: In the preceding snippet, we have added the `OnDestroy` interface and implemented
    its `ngOnDestroy` method. We can then add any custom logic in the `ngOnDestroy`
    method to run code when the component is destroyed.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们已经添加了`OnDestroy`接口并实现了其`ngOnDestroy`方法。然后我们可以在`ngOnDestroy`方法中添加任何自定义逻辑，以便在组件销毁时运行代码。
- en: 'A component is destroyed when it is removed from the DOM tree of a web page
    due to the following reasons:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件因以下原因从网页的DOM树中移除时，它将被销毁：
- en: Using the `@if` block from the control flow syntax
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用控制流语法中的`@if`块
- en: Navigating away from a component using the Angular router, which we will learn
    about in *Chapter 9* , *Navigating through Applications with Routing*
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Angular路由离开组件，我们将在第9章“使用路由导航应用程序”中学习到这一点，*导航通过应用程序的配置*
- en: 'We usually perform a cleanup of component resources inside the `ngOnDestroy`
    method, such as the following:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常在`ngOnDestroy`方法中执行组件资源的清理，例如以下操作：
- en: Resetting timers and intervals
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重置计时器和间隔
- en: Unsubscribing from observable streams, which we will learn about in *Chapter
    6* , *Reactive Patterns in Angular*
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从可观察流中取消订阅，我们将在第6章“Angular中的响应式模式”中学习到这一点。
- en: 'An alternative method to the `ngOnDestroy` lifecycle hook is to use a built-in
    Angular service such as `DestroyRef` :'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngOnDestroy`生命周期钩子的另一种方法是使用内置的Angular服务，例如`DestroyRef`：'
- en: '[PRE71]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: As we will learn in *Chapter 5* , *Managing Complex Tasks with Services* , using
    a `constructor` is one way to inject Angular services into other Angular artifacts.
    In this case, the `destroyRef` service exposes the `onDestroy` method, which accepts
    a callback function as a parameter. The callback function will be called when
    the component is destroyed.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在第5章“使用服务管理复杂任务”中学习到的那样，使用`constructor`是将Angular服务注入到其他Angular组件的一种方法。在这种情况下，`destroyRef`服务公开了`onDestroy`方法，它接受一个回调函数作为参数。当组件销毁时，将调用回调函数。
- en: We have already learned how to pass data down to a component using an input
    binding. The Angular framework provides the `ngOnChanges` lifecycle hook, which
    we can use to inspect when the value of such a binding has changed.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何使用输入绑定将数据传递到组件。Angular框架提供了`ngOnChanges`生命周期钩子，我们可以使用它来检查此类绑定的值何时已更改。
- en: Detecting input binding changes
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测输入绑定更改
- en: 'The `ngOnChanges` lifecycle hook is called when Angular detects that the value
    of an input data binding has changed. We will use it in the product detail component
    to learn how it behaves when we select a different product from the list:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 当Angular检测到输入数据绑定的值已更改时，会调用`ngOnChanges`生命周期钩子。我们将在产品详情组件中使用它来了解当我们从列表中选择不同的产品时，它的行为如何：
- en: 'Import the `OnChanges` and `SimpleChanges` interfaces in the `product-detail.component.ts`
    file:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`product-detail.component.ts`文件中导入`OnChanges`和`SimpleChanges`接口：
- en: '[PRE72]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Modify the definition of the `ProductDetailComponent` class so that it implements
    the `OnChanges` interface:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`ProductDetailComponent`类的定义，使其实现`OnChanges`接口：
- en: '[PRE73]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Implement the `ngOnChanges` method that is defined in the `OnChanges` interface.
    It accepts an object of the `SimpleChanges` type as a parameter that contains
    one key for each input property that changes. Each key points to another object
    with the properties `currentValue` and `previousValue` , which denote the new
    and the old value of the input property, respectively:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现定义在`OnChanges`接口中的`ngOnChanges`方法。它接受一个`SimpleChanges`类型的对象作为参数，该对象包含每个更改的输入属性的键。每个键指向另一个对象，该对象具有`currentValue`和`previousValue`属性，分别表示输入属性的新旧值：
- en: '[PRE74]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The preceding snippet tracks the `product` input property for changes and logs
    old and new values in the browser console window.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段跟踪`product`输入属性的变化，并在浏览器控制台窗口中记录旧值和新值。
- en: 'To inspect the application, run the `ng serve` command, select a product from
    the list, and notice the output in the console. You should get something like
    the following:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要检查应用程序，运行`ng serve`命令，从列表中选择一个产品，并注意控制台中的输出。你应该得到以下类似的内容：
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά, γραμμή  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_03_14.png)'
  id: totrans-410
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、屏幕截图、字体、行号的图像，自动生成的描述](img/B21418_03_14.png)'
- en: 'Figure 3.14: Console output'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.14：控制台输出
- en: In the preceding image, the first two lines state that the product value was
    changed from `undefined` to `undefined` . It is the actual time when the product
    detail component is initialized, and the `product` property has no value yet.
    The `OnChanges` lifecycle event is triggered once the value is first set and in
    all subsequent changes that occur through the binding mechanism.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图像中，前两行表明产品值从`undefined`更改为`undefined`。这是产品详情组件初始化的实际时间，`product`属性还没有值。`OnChanges`生命周期事件在值首次设置后触发，并在所有通过绑定机制发生的后续更改中触发。
- en: 'To eliminate the unnecessary log messages, we can check whether it is the first
    time that the `product` property is being changed using the `isFirstChange` method:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了消除不必要的日志消息，我们可以使用`isFirstChange`方法检查`product`属性是否是第一次被更改：
- en: '[PRE75]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: If we refresh the browser, we can see the correct message in the console window.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们刷新浏览器，我们可以在控制台窗口中看到正确的消息。
- en: The `ngOnChanges` lifecycle hook is a great way to detect when the value of
    an input property changes. With the advent of the Signals API, we have much better
    methods to detect and react to these changes, as we will learn in *Chapter 7*
    , *Tracking Application State with Signals* . However, for older versions of Angular,
    the hook is still the preferred solution.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngOnChanges`生命周期钩子是检测输入属性值变化的好方法。随着信号API的出现，我们有了更好的方法来检测和响应这些变化，正如我们将在*第7章*，*使用信号跟踪应用程序状态*中学习的那样。然而，对于Angular的旧版本，钩子仍然是首选的解决方案。'
- en: The last lifecycle event of an Angular component we will explore is the `ngAfterViewInit`
    hook.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要探索的Angular组件的最后一个生命周期事件是`ngAfterViewInit`钩子。
- en: Accessing child components
  id: totrans-418
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问子组件
- en: 'The `ngAfterViewInit` lifecycle hook of an Angular component is called when:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 当Angular组件的`ngAfterViewInit`生命周期钩子被调用时：
- en: The HTML template of the component has been initialized
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件的HTML模板已经初始化
- en: The HTML templates of all child components have been initialized
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有子组件的HTML模板已经初始化
- en: 'We can explore how the `ngAfterViewInit` event works using the product list
    and product detail components:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过产品列表和产品详情组件来探索`ngAfterViewInit`事件是如何工作的：
- en: 'Open the `product-list.component.ts` file and import the `AfterViewInit` and
    `viewChild` artifacts from the `@angular/core` npm package:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`product-list.component.ts`文件，并从`@angular/core` npm包中导入`AfterViewInit`和`viewChild`组件：
- en: '[PRE76]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Create the following property in the `ProductListComponent` class:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ProductListComponent`类中创建以下属性：
- en: '[PRE77]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: We have already learned how to query a component class from an HTML template
    using local reference variables. Alternatively, we can use the `viewChild` function
    to query a child component from the parent component class.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何使用局部引用变量从HTML模板中查询组件类。或者，我们也可以使用`viewChild`函数从父组件类中查询子组件。
- en: In older versions of Angular, we use the `@ViewChild` decorator for querying
    child components. You can learn more at [https://angular.dev/guide/components/queries](https://angular.dev/guide/components/queries)
    .
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular的旧版本中，我们使用`@ViewChild`装饰器来查询子组件。你可以了解更多信息在[https://angular.dev/guide/components/queries](https://angular.dev/guide/components/queries)。
- en: The `viewChild` function accepts the type of component we want to query as a
    parameter.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '`viewChild`函数接受我们想要查询的组件类型作为参数。'
- en: 'Modify the definition of the `ProductListComponent` class so that it implements
    the `AfterViewInit` interface:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`ProductListComponent`类的定义，使其实现`AfterViewInit`接口：
- en: '[PRE78]'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The `AfterViewInit` interface implements the `ngAfterViewInit` method, which
    we can use to access the `productDetail` property:'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AfterViewInit`接口实现了`ngAfterViewInit`方法，我们可以使用它来访问`productDetail`属性：'
- en: '[PRE79]'
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: When we query the `productDetail` property, we get an instance of the `ProductDetail-Component`
    class. We can then access any member of its public API, such as the `product`
    property.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查询`productDetail`属性时，我们得到`ProductDetail-Component`类的实例。然后我们可以访问其公共API的任何成员，例如`product`属性。
- en: Running the preceding code will display an `undefined` value for the `product`
    property because we do not set an initial value when the product detail component
    is initialized.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码将显示`product`属性的`undefined`值，因为我们没有在产品详情组件初始化时设置初始值。
- en: The `ngAfterViewInit` lifecycle event concludes our journey through the lifecycle
    of Angular components. Component lifecycle hooks are a useful feature of the framework,
    and you will use them a lot for developing Angular applications.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngAfterViewInit`生命周期事件标志着我们通过Angular组件生命周期的旅程结束。组件生命周期钩子是框架的一个有用特性，您将在开发Angular应用程序时大量使用它们。'
- en: Summary
  id: totrans-437
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored Angular components. We saw their structure and
    how to create them and discussed how to isolate a component’s HTML template in
    an external file to ease its future maintainability. Also, we saw how to do the
    same with any style sheet we wanted to bind to the component in case we did not
    want to bundle the component styles inline. We also learned how to use the Angular
    template syntax and interact with the component template. Similarly, we went through
    how components communicate bidirectionally using property and event bindings.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了Angular组件。我们看到了它们的结构以及如何创建它们，并讨论了如何将组件的HTML模板隔离在外部文件中，以简化其未来的可维护性。我们还看到了如何将任何我们想要绑定到组件的样式表也进行相同的处理，以防我们不希望将组件样式内联捆绑。我们还学习了如何使用Angular模板语法并与组件模板交互。同样，我们了解了组件如何通过属性和事件绑定双向通信。
- en: We went through the options available in Angular for creating powerful APIs
    for our components so that we could provide high levels of interoperability between
    components, configuring their properties by assigning either static values or
    managed bindings. We also saw how a component could act as a host component for
    another child component, instantiating the former’s custom element in its template
    and laying the groundwork for larger component trees in our applications. Output
    parameters give us the layer of interactivity we need by turning our components
    into event emitters so they can adequately communicate with any parent component
    that might eventually host them.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了Angular中创建强大API的选项，以便我们可以在组件之间提供高水平的互操作性，通过分配静态值或管理绑定来配置它们的属性。我们还看到了一个组件如何作为宿主组件为另一个子组件服务，在其模板中实例化前者的自定义元素，并为我们的应用程序中更大的组件树奠定基础。输出参数通过将我们的组件转换为事件发射器，为我们提供了所需的交互层，从而使它们能够与任何可能最终托管它们的父组件充分通信。
- en: Template references paved the way for us to create references in our custom
    elements, which we can use as accessors to their properties and methods from within
    the template in a declarative fashion. An overview of the built-in features for
    handling CSS view encapsulation in Angular gave us additional insights into how
    we can benefit from shadow DOM’s CSS scoping per component. Finally, we learned
    how important change detection is in an Angular application and how we can customize
    it to improve its performance further.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 模板引用为我们铺平了道路，使我们能够在自定义元素中创建引用，我们可以使用它们作为访问器，从模板中以声明方式访问它们的属性和方法。Angular中处理CSS视图封装的内置功能概述让我们对如何从每个组件的shadow
    DOM的CSS作用域中受益有了更深入的了解。最后，我们学习了在Angular应用程序中变更检测的重要性以及如何自定义它以进一步提高其性能。
- en: 'We also studied the component lifecycle and learned how to execute custom logic
    using built-in Angular lifecycle hooks. We still have much more to learn regarding
    template management in Angular, mostly concerning two concepts you will use in
    your journey with Angular: directives and pipes, which we will cover in the next
    chapter.'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了组件生命周期，并学习了如何使用内置的Angular生命周期钩子执行自定义逻辑。关于Angular中的模板管理，我们还有更多要学习的内容，主要涉及您在Angular之旅中将要使用的两个概念：指令和管道，这些内容将在下一章中介绍。
