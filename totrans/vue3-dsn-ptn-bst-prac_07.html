<html><head></head><body>
<div id="_idContainer056">
<h1 class="chapter-number" id="_idParaDest-135"><a id="_idTextAnchor173"/><span class="koboSpan" id="kobo.1.1">7</span></h1>
<h1 id="_idParaDest-136"><a id="_idTextAnchor174"/><span class="koboSpan" id="kobo.2.1">Data Flow Management</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In previous chapters, we have focused on understanding the Vue 3 framework and providing a context to create web applications. </span><span class="koboSpan" id="kobo.3.2">In this chapter, we will focus on the way our components communicate with each other and share information to make our application happen. </span><span class="koboSpan" id="kobo.3.3">We have touched on this topic briefly previously, but now we will dive deep into some patterns by implementing them alongside each other. </span><span class="koboSpan" id="kobo.3.4">Applying an appropriate information workflow is an important skill that can make or break an application. </span><span class="koboSpan" id="kobo.3.5">In particular, we will see the following approaches and </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">code examples:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.5.1">Parent-child-sibling communication</span></span></li>
<li><span class="koboSpan" id="kobo.6.1">Implementing a message bus using the </span><strong class="bold"><span class="koboSpan" id="kobo.7.1">Singleton </span></strong><span class="koboSpan" id="kobo.8.1">and </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.9.1">Observer </span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">patterns</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Implementing a basic reactive state with </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">composable components</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Implementing a centralized data repository with the powerful Pinia </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">reactive store</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Reviewing browser-provided alternatives to share and </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">store information</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Experimenting with reactivity, composables, and proxy patterns </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">in action</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.19.1">As we have done previously, we will be building one concept at a time, incrementing in complexity. </span><span class="koboSpan" id="kobo.19.2">By the end of this chapter, you will have seen clear examples of implementation so that you can decide when to apply each one based on the needs of your application. </span><span class="koboSpan" id="kobo.19.3">Some of these are more suitable for small applications, and others for large, complex ones. </span><span class="koboSpan" id="kobo.19.4">You will be better prepared to control the workflow of information for </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">your application.</span></span></p>
<h1 id="_idParaDest-137"><a id="_idTextAnchor175"/><span class="koboSpan" id="kobo.21.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.22.1">This chapter will approach concepts and apply patterns to control the communication and flow of information between components. </span><span class="koboSpan" id="kobo.22.2">You should be able to follow through with the code presented in this text, but for a better understanding and context experience, you would benefit from inspecting the full application code for this chapter, available in the repository for this </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">book: </span></span><a href="https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter07"><span class="No-Break"><span class="koboSpan" id="kobo.24.1">https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter07</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.25.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.26.1">If you are starting a new project, just follow the instructions for scaffolding one, as seen in </span><a href="B18602_03.xhtml#_idTextAnchor079"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.27.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.28.1">, </span><em class="italic"><span class="koboSpan" id="kobo.29.1">Setting Up a </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.30.1">Working Project</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.32.1">Check out the following video to see the Code in </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">Action: </span></span><a href="https://packt.link/ZKTBJ"><span class="No-Break"><span class="koboSpan" id="kobo.34.1">https://packt.link/ZKTBJ</span></span></a></p>
<h1 id="_idParaDest-138"><a id="_idTextAnchor176"/><span class="koboSpan" id="kobo.35.1">Components’ basic communication</span></h1>
<p><span class="koboSpan" id="kobo.36.1">We have seen previously</span><a id="_idIndexMarker533"/><span class="koboSpan" id="kobo.37.1"> that a parent component and its children have a rather simple and straightforward way to communicate. </span><span class="koboSpan" id="kobo.37.2">Parents pass data as </span><strong class="source-inline"><span class="koboSpan" id="kobo.38.1">props</span></strong><span class="koboSpan" id="kobo.39.1"> to their children, and these raise events (</span><strong class="source-inline"><span class="koboSpan" id="kobo.40.1">emits</span></strong><span class="koboSpan" id="kobo.41.1">) to capture the attention of the parent. </span><span class="koboSpan" id="kobo.41.2">Much like the comparability of parameters and arguments in functions, </span><strong class="source-inline"><span class="koboSpan" id="kobo.42.1">props</span></strong><span class="koboSpan" id="kobo.43.1"> receive simple data by copy, and complex types (objects, arrays, and so on) by reference. </span><span class="koboSpan" id="kobo.43.2">We could pass, then, a plain object with member functions from the parent to the child, and have the child run the functions to access the parent’s data. </span><span class="koboSpan" id="kobo.43.3">Even though this “works”, it is sort of a dark pattern or anti-pattern, as it hides the relationship and makes it difficult to understand the data flow. </span><span class="koboSpan" id="kobo.43.4">The proper way to pass data upward in the component tree is through events (</span><strong class="source-inline"><span class="koboSpan" id="kobo.44.1">emits</span></strong><span class="koboSpan" id="kobo.45.1">). </span><span class="koboSpan" id="kobo.45.2">Having said this, we must point out that child components are “ignorant” of each other, meaning that they do not have a direct way to communicate among themselves. </span><span class="koboSpan" id="kobo.45.3">We could pass a reactive variable and have each component involved access it, and this is certainly a working alternative, if not a clean one. </span><span class="koboSpan" id="kobo.45.4">In some cases, this would provide a simple solution, but again, it can lead to hidden </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">side effects.</span></span></p>
<p><span class="koboSpan" id="kobo.47.1">To manage in a clean way the workflow of data, we have several alternatives that follow good practices and design patterns. </span><span class="koboSpan" id="kobo.47.2">As a general rule and principle, the component that declares the variable is the owner of it, and it should be the one that manipulates it. </span><span class="koboSpan" id="kobo.47.3">With this in mind, in the most basic communication, the information needs to be maintained and manipulated by the parent component and shared among the children. </span><span class="koboSpan" id="kobo.47.4">We can leverage Vue’s reactive system to spread the information. </span><span class="koboSpan" id="kobo.47.5">The key here is that only the parent component will manipulate it. </span><span class="koboSpan" id="kobo.47.6">Let’s see how this works in practice with an example, implementing a small trivial application, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.48.1">Figure 7</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.49.1">.1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer049">
<span class="koboSpan" id="kobo.51.1"><img alt="Figure 7.1 – Direct basic communication and reactivity" src="image/Figure_7.01_B18602.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.52.1">Figure 7.1 – Direct basic communication and reactivity</span></p>
<p><span class="koboSpan" id="kobo.53.1">In this application, the parent component</span><a id="_idIndexMarker534"/><span class="koboSpan" id="kobo.54.1"> has three direct children and shares with them a reactive counter. </span><span class="koboSpan" id="kobo.54.2">All the components display a label with the value of the counter and have a button to trigger an increment... </span><span class="koboSpan" id="kobo.54.3">but only the father component performs the actual manipulation of the data. </span><span class="koboSpan" id="kobo.54.4">Vue handles the reactivity, meaning that when the parent modifies the value, the child components also receive them. </span><span class="koboSpan" id="kobo.54.5">Simple enough—let’s see the important parts of how this </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">is implemented:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.56.1">/basic/ParentBasic.vue</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.57.1">
&lt;script setup&gt;
import {ref} from "vue"
import ChildComponent from "./Child.vue"
const </span><strong class="bold"><span class="koboSpan" id="kobo.58.1">_counter</span></strong><span class="koboSpan" id="kobo.59.1"> = ref(0);                                  </span><strong class="bold"><span class="koboSpan" id="kobo.60.1">//1</span></strong><span class="koboSpan" id="kobo.61.1">
function </span><strong class="bold"><span class="koboSpan" id="kobo.62.1">incrementCounter()</span></strong><span class="koboSpan" id="kobo.63.1"> {                             </span><strong class="bold"><span class="koboSpan" id="kobo.64.1">//2</span></strong><span class="koboSpan" id="kobo.65.1">
   _counter.value++;
}
&lt;/script&gt;
&lt;template&gt;
&lt;div&gt;
   &lt;strong&gt;Counter &lt;/strong&gt;
   &lt;span&gt;{{ _counter }}&lt;/span&gt;
   &lt;button </span><strong class="bold"><span class="koboSpan" id="kobo.66.1">@click="incrementCounter()"</span></strong><span class="koboSpan" id="kobo.67.1">&gt;                   </span><strong class="bold"><span class="koboSpan" id="kobo.68.1">//3</span></strong><span class="koboSpan" id="kobo.69.1">
       Increment
   &lt;/button&gt;
&lt;/div&gt;
&lt;section&gt;
&lt;ChildComponent title="Child component 1"
  </span><strong class="bold"><span class="koboSpan" id="kobo.70.1">:counter="_counter" @increment="incrementCounter()"</span></strong><span class="koboSpan" id="kobo.71.1">&gt;    </span><strong class="bold"><span class="koboSpan" id="kobo.72.1">//4</span></strong><span class="koboSpan" id="kobo.73.1">
&lt;/ChildComponent&gt;
&lt;ChildComponent title="Child component 2"
  </span><strong class="bold"><span class="koboSpan" id="kobo.74.1">:counter="_counter" @increment="incrementCounter()"</span></strong><span class="koboSpan" id="kobo.75.1">&gt;
&lt;/ChildComponent&gt;
&lt;ChildComponent title="Child component 3"
  </span><strong class="bold"><span class="koboSpan" id="kobo.76.1">:counter="_counter"</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.77.1">  @increment="incrementCounter()"</span></strong><span class="koboSpan" id="kobo.78.1">&gt;&lt;/ChildComponent&gt;
&lt;/section&gt;
&lt;/template&gt;</span></pre>
<p><span class="koboSpan" id="kobo.79.1">In this component, we declare a </span><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">_counter</span></strong><span class="koboSpan" id="kobo.81.1"> reactive variable (line </span><strong class="source-inline"><span class="koboSpan" id="kobo.82.1">//1</span></strong><span class="koboSpan" id="kobo.83.1">) and an </span><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">incrementCounter()</span></strong><span class="koboSpan" id="kobo.85.1"> function to manipulate</span><a id="_idIndexMarker535"/><span class="koboSpan" id="kobo.86.1"> its value (line </span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">//2</span></strong><span class="koboSpan" id="kobo.88.1">). </span><span class="koboSpan" id="kobo.88.2">We trigger this function in the parent button, on the click event, as seen in line </span><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">//3</span></strong><span class="koboSpan" id="kobo.90.1">. </span><span class="koboSpan" id="kobo.90.2">Now, to see this pattern implemented, we just pass our reactive </span><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">_counter</span></strong><span class="koboSpan" id="kobo.92.1"> variable as a prop to each child component, and we link our </span><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">incrementCounter()</span></strong><span class="koboSpan" id="kobo.94.1"> function to each child’s increment event (line </span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">//4</span></strong><span class="koboSpan" id="kobo.96.1">). </span><span class="koboSpan" id="kobo.96.2">Simple enough—let’s see how each child implements </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">its part:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.98.1">/basic/Child.vue</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.99.1">
&lt;script setup&gt;
const
</span><strong class="bold"><span class="koboSpan" id="kobo.100.1">    $props=defineProps(['counter', 'title'])</span></strong><span class="koboSpan" id="kobo.101.1">,         //1
</span><strong class="bold"><span class="koboSpan" id="kobo.102.1">    $emit=defineEmits(['increment'])</span></strong><span class="koboSpan" id="kobo.103.1">
function incrementCounter(){$emit("increment")}      //2
&lt;/script&gt;
&lt;template&gt;
&lt;h3&gt;{{$props.title}}&lt;/h3&gt;
&lt;span class="badge"&gt;</span><strong class="bold"><span class="koboSpan" id="kobo.104.1">{{$props.counter}}</span></strong><span class="koboSpan" id="kobo.105.1">&lt;/span&gt;        //3
&lt;button</span><strong class="bold"><span class="koboSpan" id="kobo.106.1"> @click="incrementCounter()"</span></strong><span class="koboSpan" id="kobo.107.1">&gt;                 //4
    Increment
&lt;/button&gt;
&lt;/template&gt;</span></pre>
<p><span class="koboSpan" id="kobo.108.1">Our child implementation is simple as well. </span><span class="koboSpan" id="kobo.108.2">We start by defining the props to receive the counter variable in line </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">//1</span></strong><span class="koboSpan" id="kobo.110.1">, and also our </span><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">increment</span></strong><span class="koboSpan" id="kobo.112.1"> custom event so that we can notify the parent. </span><span class="koboSpan" id="kobo.112.2">In order to do that, we create a function in line </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">//2</span></strong><span class="koboSpan" id="kobo.114.1">. </span><span class="koboSpan" id="kobo.114.2">In our template, we display our prop in line </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">//3</span></strong><span class="koboSpan" id="kobo.116.1"> and trigger our increment function in line </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">//4</span></strong><span class="koboSpan" id="kobo.118.1">. </span><span class="koboSpan" id="kobo.118.2">Notice that our child component does not modify the counter. </span><span class="koboSpan" id="kobo.118.3">That is the responsibility of the father component, so we respect </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">the pattern.</span></span></p>
<p><span class="koboSpan" id="kobo.120.1">This pattern is one that we</span><a id="_idIndexMarker536"/><span class="koboSpan" id="kobo.121.1"> will use quite often, but it does have some limitations. </span><span class="koboSpan" id="kobo.121.2">For example, what happens when the data needs to reach a parent, sibling, or grandchild? </span><span class="koboSpan" id="kobo.121.3">Do we pass data up and down the tree, even though components don’t use it? </span><span class="koboSpan" id="kobo.121.4">We could, but again, that is messy, verbose, and not the best way. </span><span class="koboSpan" id="kobo.121.5">We have better tools </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">for that.</span></span></p>
<p><span class="koboSpan" id="kobo.123.1">In </span><a href="B18602_04.xhtml#_idTextAnchor102"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.124.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.125.1">, </span><em class="italic"><span class="koboSpan" id="kobo.126.1">User Interface Composition with Components</span></em><span class="koboSpan" id="kobo.127.1">, we saw that</span><a id="_idIndexMarker537"/><span class="koboSpan" id="kobo.128.1"> a parent can pass data and functionality to any of their children down the tree, by using </span><strong class="bold"><span class="koboSpan" id="kobo.129.1">dependency injection</span></strong><span class="koboSpan" id="kobo.130.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.131.1">DI</span></strong><span class="koboSpan" id="kobo.132.1">) with </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">provide</span></strong><span class="koboSpan" id="kobo.134.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">inject</span></strong><span class="koboSpan" id="kobo.136.1">. </span><span class="koboSpan" id="kobo.136.2">Since the example presented there was quite comprehensive, we will not repeat it here. </span><span class="koboSpan" id="kobo.136.3">I encourage you to review how the provision was created and injected. </span><span class="koboSpan" id="kobo.136.4">Instead of repeating ourselves, let’s move ahead with the next item in our agenda to share information</span><a id="_idIndexMarker538"/><span class="koboSpan" id="kobo.137.1"> anywhere in the component</span><a id="_idIndexMarker539"/><span class="koboSpan" id="kobo.138.1"> tree: implement a </span><strong class="bold"><span class="koboSpan" id="kobo.139.1">message bus</span></strong><span class="koboSpan" id="kobo.140.1"> (also called an </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.141.1">event bus</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">).</span></span></p>
<h1 id="_idParaDest-139"><a id="_idTextAnchor177"/><span class="koboSpan" id="kobo.143.1">Implementing an event bus with the Singleton and Observer patterns</span></h1>
<p><span class="koboSpan" id="kobo.144.1">A message bus is an implementation</span><a id="_idIndexMarker540"/><span class="koboSpan" id="kobo.145.1"> of the </span><em class="italic"><span class="koboSpan" id="kobo.146.1">Observer pattern</span></em><a id="_idIndexMarker541"/><span class="koboSpan" id="kobo.147.1"> that we saw in </span><a href="B18602_02.xhtml#_idTextAnchor040"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.148.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.149.1">, </span><em class="italic"><span class="koboSpan" id="kobo.150.1">Software Design Principles and Patterns</span></em><span class="koboSpan" id="kobo.151.1">. </span><span class="koboSpan" id="kobo.151.2">As a short refreshment of the main concept, we seek </span><a id="_idIndexMarker542"/><span class="koboSpan" id="kobo.152.1">to create an object</span><a id="_idIndexMarker543"/><span class="koboSpan" id="kobo.153.1"> or structure that receives and emits events that our components can subscribe and react to. </span><span class="koboSpan" id="kobo.153.2">This pattern runs independently of the component tree structure, so any </span><em class="italic"><span class="koboSpan" id="kobo.154.1">component and service</span></em><span class="koboSpan" id="kobo.155.1"> can make use of it. </span><span class="koboSpan" id="kobo.155.2">Visually, we can represent the resulting relationship </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer050">
<span class="koboSpan" id="kobo.157.1"><img alt="Figure 7.2 – A simplified view of a message bus relationship with components" src="image/Figure_7.02_B18602.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.158.1">Figure 7.2 – A simplified view of a message bus relationship with components</span></p>
<p><span class="koboSpan" id="kobo.159.1">From the preceding diagram, we can immediately see that each component is treated equally by the message bus. </span><span class="koboSpan" id="kobo.159.2">Each component subscribes one or more of its methods to a specific event, and at the same time has the same possibility to publish an event. </span><span class="koboSpan" id="kobo.159.3">This makes it very flexible, as events can also </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">transport data.</span></span></p>
<p><span class="koboSpan" id="kobo.161.1">Let’s bring down to code these concepts with an implementation example. </span><span class="koboSpan" id="kobo.161.2">We start by creating a service, using the Singleton pattern, that provides us with a message bus. </span><span class="koboSpan" id="kobo.161.3">In our case, we will just wrap the </span><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">mitt</span></strong><span class="koboSpan" id="kobo.163.1"> package, which gives us this functionality (</span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">see </span></span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">https://github.com/developit/mitt#usage</span></span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.167.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">mitt</span></strong><span class="koboSpan" id="kobo.169.1"> package can be installed in our application with the following command in </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">the terminal:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.171.1">
$ npm install mitt</span></pre>
<p><span class="koboSpan" id="kobo.172.1">Our service then looks </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">like this:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.174.1">/services/MessageBus.js</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.175.1">
import mitt from "mitt"
const messageBus = mitt()
export default messageBus</span></pre>
<p><span class="koboSpan" id="kobo.176.1">This will give us a singleton</span><a id="_idIndexMarker544"/><span class="koboSpan" id="kobo.177.1"> for an event emitter and</span><a id="_idIndexMarker545"/><span class="koboSpan" id="kobo.178.1"> dispatcher, meaning our message bus. </span><span class="koboSpan" id="kobo.178.2">In our</span><a id="_idIndexMarker546"/><span class="koboSpan" id="kobo.179.1"> example, we will dispatch text messages</span><a id="_idIndexMarker547"/><span class="koboSpan" id="kobo.180.1"> through it, and each receiving component will display it. </span><span class="koboSpan" id="kobo.180.2">Our components will then look something </span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">like this:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.182.1">/bus/Child.vue</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.183.1">
&lt;script setup&gt;
import </span><strong class="bold"><span class="koboSpan" id="kobo.184.1">messageBus </span></strong><span class="koboSpan" id="kobo.185.1">from '../services/MessageBus';         </span><strong class="bold"><span class="koboSpan" id="kobo.186.1">//1</span></strong><span class="koboSpan" id="kobo.187.1">
import {ref, onMounted, onBeforeUnmount} from 'vue';
const
   $props=defineProps(['title']),
   </span><strong class="bold"><span class="koboSpan" id="kobo.188.1">message=ref("")                                   </span></strong><span class="koboSpan" id="kobo.189.1">    </span><strong class="bold"><span class="koboSpan" id="kobo.190.1">//2</span></strong><span class="koboSpan" id="kobo.191.1">
    onMounted(()=&gt;{
        </span><strong class="bold"><span class="koboSpan" id="kobo.192.1">messageBus.on(</span></strong><span class="koboSpan" id="kobo.193.1">"message", showMessage)})                 </span><strong class="bold"><span class="koboSpan" id="kobo.194.1">//3</span></strong><span class="koboSpan" id="kobo.195.1">
    onBeforeUnmount(()=&gt;{
        </span><strong class="bold"><span class="koboSpan" id="kobo.196.1">messageBus.off(</span></strong><span class="koboSpan" id="kobo.197.1">"message",showMessage)})
    function </span><strong class="bold"><span class="koboSpan" id="kobo.198.1">showMessage</span></strong><span class="koboSpan" id="kobo.199.1">(value){                               </span><strong class="bold"><span class="koboSpan" id="kobo.200.1">//4</span></strong><span class="koboSpan" id="kobo.201.1">
        message.value=value;}
    function </span><strong class="bold"><span class="koboSpan" id="kobo.202.1">sendMessage</span></strong><span class="koboSpan" id="kobo.203.1">(){                                    </span><strong class="bold"><span class="koboSpan" id="kobo.204.1">//5</span></strong><span class="koboSpan" id="kobo.205.1">
        messageBus.emit("message",`Sent by ${$props.title}`)}
&lt;/script&gt;
&lt;template&gt;
    &lt;h4&gt;{{$props.title}}&lt;/h4&gt;
    &lt;strong&gt;Received: &lt;/strong&gt;
    &lt;div&gt;{{message}}&lt;/div&gt;
    &lt;button </span><strong class="bold"><span class="koboSpan" id="kobo.206.1">@click="sendMessage()"</span></strong><span class="koboSpan" id="kobo.207.1">&gt;Send message&lt;/button&gt;       </span><strong class="bold"><span class="koboSpan" id="kobo.208.1">//6</span></strong><span class="koboSpan" id="kobo.209.1">
&lt;/template&gt;</span></pre>
<p><span class="koboSpan" id="kobo.210.1">In this example, we start in line </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">//1</span></strong><span class="koboSpan" id="kobo.212.1"> by importing our </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">messageBus</span></strong><span class="koboSpan" id="kobo.214.1"> object (check the right path in your implementation) and declare a </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">message</span></strong><span class="koboSpan" id="kobo.216.1"> reactive variable initialized to an empty string. </span><span class="koboSpan" id="kobo.216.2">Notice how we also import and use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">onMounted()</span></strong><span class="koboSpan" id="kobo.218.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">onBeforeUnmount()</span></strong><span class="koboSpan" id="kobo.220.1"> methods from the component’s life cycle to subscribe and unsubscribe to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">message</span></strong><span class="koboSpan" id="kobo.222.1"> event starting</span><a id="_idIndexMarker548"/><span class="koboSpan" id="kobo.223.1"> in line </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">//3</span></strong><span class="koboSpan" id="kobo.225.1">. </span><span class="koboSpan" id="kobo.225.2">The function that we register is in line </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">//4</span></strong><span class="koboSpan" id="kobo.227.1">, and it receives</span><a id="_idIndexMarker549"/><span class="koboSpan" id="kobo.228.1"> from the event a value</span><a id="_idIndexMarker550"/><span class="koboSpan" id="kobo.229.1"> that we pass to our internal variable to display</span><a id="_idIndexMarker551"/><span class="koboSpan" id="kobo.230.1"> in the template. </span><span class="koboSpan" id="kobo.230.2">We also need a function to publish the event to notify others, and that can be found in line </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">//5</span></strong><span class="koboSpan" id="kobo.232.1">. </span><span class="koboSpan" id="kobo.232.2">In this case, we publish the title of the component. </span><span class="koboSpan" id="kobo.232.3">This function is triggered by a button, as shown in </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">line </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">//6</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.236.1">If you run the application example with some additional minimal styling, this code will result in something </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer051">
<span class="koboSpan" id="kobo.238.1"><img alt="Figure 7.3 – A simple implementation of data sharing through the Observer pattern" src="image/Figure_7.03_B18602.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.239.1">Figure 7.3 – A simple implementation of data sharing through the Observer pattern</span></p>
<p><span class="koboSpan" id="kobo.240.1">This approach to handling the workflow of data is quite effective in what it does, but also has limitations. </span><span class="koboSpan" id="kobo.240.2">Events are a good way to notify multiple components simultaneously to trigger actions, independently of their place in the organization tree. </span><span class="koboSpan" id="kobo.240.3">When an application has multiple sub-systems that need to react to an application state change, this is a good pattern to apply. </span><span class="koboSpan" id="kobo.240.4">However, when dealing mainly with application data, this pattern has an important drawback: each component keeps an internal copy of the information. </span><span class="koboSpan" id="kobo.240.5">This makes the handling of memory quite inefficient, as the propagation of data means copying into different parts of our application. </span><span class="koboSpan" id="kobo.240.6">There are cases when this is necessary or desired, but certainly not for every case. </span><span class="koboSpan" id="kobo.240.7">If we have 50, 100, or 1,000 components subscribed to the same event, will all of them have the same copy of the data? </span><span class="koboSpan" id="kobo.240.8">If each component needs to handle and possibly modify the data independently of the others, this works</span><a id="_idIndexMarker552"/><span class="koboSpan" id="kobo.241.1"> fine... </span><span class="koboSpan" id="kobo.241.2">but if we want to make better</span><a id="_idIndexMarker553"/><span class="koboSpan" id="kobo.242.1"> use of Vue’s reactivity and improve</span><a id="_idIndexMarker554"/><span class="koboSpan" id="kobo.243.1"> our memory handling, we need</span><a id="_idIndexMarker555"/><span class="koboSpan" id="kobo.244.1"> to use a different approach. </span><span class="koboSpan" id="kobo.244.2">This is what we will see next with a basic reactive </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">application state.</span></span></p>
<h1 id="_idParaDest-140"><a id="_idTextAnchor178"/><span class="koboSpan" id="kobo.246.1">Implementing a basic reactive state</span></h1>
<p><span class="koboSpan" id="kobo.247.1">As mentioned before, a drawback </span><a id="_idIndexMarker556"/><span class="koboSpan" id="kobo.248.1">of using a message bus to share data is the multiplicity of copies of the same data, including the overhead for the handling of the events. </span><span class="koboSpan" id="kobo.248.2">Instead, we can leverage Vue’s reactivity engine and, in particular, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">reactive()</span></strong><span class="koboSpan" id="kobo.250.1"> helper constructor to create a single entity to hold our application state. </span><span class="koboSpan" id="kobo.250.2">Just like before, we can wrap this reactive object in a Singleton pattern to share it among components and plain JavaScript functions, objects, and classes. </span><span class="koboSpan" id="kobo.250.3">It's worth mentioning that this is one of the great advantages of Vue 3 and the new </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">Composition API.</span></span></p>
<p><span class="koboSpan" id="kobo.252.1">From the example code, we will end with a basic example </span><span class="No-Break"><span class="koboSpan" id="kobo.253.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer052">
<span class="koboSpan" id="kobo.254.1"><img alt="Figure 7.4 – A shared reactive object for state management" src="image/Figure_7.04_B18602.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.255.1">Figure 7.4 – A shared reactive object for state management</span></p>
<p><span class="koboSpan" id="kobo.256.1">As you can see in the previous</span><a id="_idIndexMarker557"/><span class="koboSpan" id="kobo.257.1"> screenshot, the state in this case is shared (or accessed) by all the components of this example. </span><span class="koboSpan" id="kobo.257.2">Any of the child components can modify any of its values, and the change is reflected immediately across the application. </span><span class="koboSpan" id="kobo.257.3">In contrast with the previous examples, the implementation of this pattern is both simple and straightforward. </span><span class="koboSpan" id="kobo.257.4">Let’s dive into it by first creating a service with our </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">reactive state:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.259.1">/service/SimpleState.js</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.260.1">
import {reactive} from "vue"                       //1
const _state=reactive({counter: 0})                //2
function useState(){return _state;}                //3
export default useState;</span></pre>
<p><span class="koboSpan" id="kobo.261.1">If this code seems simple, it is because indeed it is. </span><span class="koboSpan" id="kobo.261.2">We create a JavaScript file and import the </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">reactive</span></strong><span class="koboSpan" id="kobo.263.1"> constructor from Vue (line </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">//1</span></strong><span class="koboSpan" id="kobo.265.1">). </span><span class="koboSpan" id="kobo.265.2">Then, we declare a reactive constant with an initial object (line </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">//2</span></strong><span class="koboSpan" id="kobo.267.1">). </span><span class="koboSpan" id="kobo.267.2">This will be the application state that we return through a </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">useState()</span></strong><span class="koboSpan" id="kobo.269.1"> function, named following the model of composable components (line </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">//3</span></strong><span class="koboSpan" id="kobo.271.1">). </span><span class="koboSpan" id="kobo.271.2">This function is our </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">module exports.</span></span></p>
<p><span class="koboSpan" id="kobo.273.1">Making use of this centralized state</span><a id="_idIndexMarker558"/><span class="koboSpan" id="kobo.274.1"> is also very simple, as we can </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">see here:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.276.1">/simple/ChildSimple.vue</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.277.1">
&lt;script setup&gt;
    import </span><strong class="bold"><span class="koboSpan" id="kobo.278.1">useState </span></strong><span class="koboSpan" id="kobo.279.1">from "../../services/SimpleState"          //1
    </span><strong class="bold"><span class="koboSpan" id="kobo.280.1">const $state=useState()</span></strong><span class="koboSpan" id="kobo.281.1">
&lt;/script&gt;
&lt;template&gt;
    &lt;strong&gt;State: &lt;/strong&gt;&lt;br&gt;
    &lt;pre&gt;</span><strong class="bold"><span class="koboSpan" id="kobo.282.1">{{$state}}</span></strong><span class="koboSpan" id="kobo.283.1">&lt;/pre&gt;                                      //2
    &lt;div&gt;
    &lt;button </span><strong class="bold"><span class="koboSpan" id="kobo.284.1">@click="$state.counter++"</span></strong><span class="koboSpan" id="kobo.285.1">&gt;Increment&lt;/button&gt;       //3
    &lt;button @click="$state.counter--"&gt;Decrement&lt;/button&gt;
    &lt;/div&gt;
&lt;/template&gt;</span></pre>
<p><span class="koboSpan" id="kobo.286.1">We start our component by importing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">useState</span></strong><span class="koboSpan" id="kobo.288.1"> factory function, and we declare a reactive constant using it (line </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">//1</span></strong><span class="koboSpan" id="kobo.290.1">). </span><span class="koboSpan" id="kobo.290.2">We use this reactive variable in our template just like any other (line </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">//2</span></strong><span class="koboSpan" id="kobo.292.1">), and in the same way, we can access directly the member fields of the object to modify them as with any other object, as you can see in line </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">//3</span></strong><span class="koboSpan" id="kobo.294.1">. </span><span class="koboSpan" id="kobo.294.2">Having done this, as one would expect, once a component modifies any value, the change gets propagated across </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.296.1">This simple approach is very useful and fit for small to even medium-sized applications. </span><span class="koboSpan" id="kobo.296.2">It has many benefits, such as </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.298.1">It is easy to implement </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">and understand.</span></span></li>
<li><span class="koboSpan" id="kobo.300.1">It leverages Vue’s </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">reactivity system.</span></span></li>
<li><span class="koboSpan" id="kobo.302.1">It is flexible, as we can add new reactive members </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">after initialization.</span></span></li>
<li><span class="koboSpan" id="kobo.304.1">It establishes a single source of truth meaning that our state is the centralized repository of the application data. </span><span class="koboSpan" id="kobo.304.2">There's no need to keep internal or private </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">variables synchronized.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.306.1">If you consider the options we have seen until now, this is a giant leap forward. </span><span class="koboSpan" id="kobo.306.2">However, there are some situations when these </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">falls short:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.308.1">What happens when a function modifies its value in an asynchronous manner if other components made changes before it </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">was resolved?</span></span></li>
<li><span class="koboSpan" id="kobo.310.1">This approach does not allow us to handle computed data that needs to be implemented in </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">each component</span></span></li>
<li><span class="koboSpan" id="kobo.312.1">Debugging could be hard as there is no specific support for </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">developer tools</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.314.1">As mentioned, this approach</span><a id="_idIndexMarker559"/><span class="koboSpan" id="kobo.315.1"> is suitable for simple needs. </span><span class="koboSpan" id="kobo.315.2">For a more robust approach, we will dig into the official central state management solution by the Vue </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">project: </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.317.1">Pinia</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">.</span></span></p>
<h1 id="_idParaDest-141"><a id="_idTextAnchor179"/><span class="koboSpan" id="kobo.319.1">Implementing a powerful reactive store with Pinia</span></h1>
<p><span class="koboSpan" id="kobo.320.1">Central state management</span><a id="_idIndexMarker560"/><span class="koboSpan" id="kobo.321.1"> is not a concept private only to Vue, and the same</span><a id="_idIndexMarker561"/><span class="koboSpan" id="kobo.322.1"> pattern can be found in other libraries and frameworks. </span><span class="koboSpan" id="kobo.322.2">Just as in our basic reactive example, </span><strong class="bold"><span class="koboSpan" id="kobo.323.1">Pinia</span></strong><span class="koboSpan" id="kobo.324.1"> is a central state management tool that provides</span><a id="_idIndexMarker562"/><span class="koboSpan" id="kobo.325.1"> us with a single source of truth, meaning that a change in one of its values will propagate reactively to the entire application wherever is used. </span><span class="koboSpan" id="kobo.325.2">This state is shared among components in the application and gives us access to the full range of reactive tools Vue provides through a well-defined interface. </span><span class="koboSpan" id="kobo.325.3">It is easier to understand Pinia if first we build an example to show the results of using it. </span><span class="koboSpan" id="kobo.325.4">Running the code example will give us something </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer053">
<span class="koboSpan" id="kobo.327.1"><img alt="Figure 7.5 – Central state management with Pinia" src="image/Figure_7.05_B18602.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.328.1">Figure 7.5 – Central state management with Pinia</span></p>
<p><span class="koboSpan" id="kobo.329.1">In this example, we build</span><a id="_idIndexMarker563"/><span class="koboSpan" id="kobo.330.1"> a store that not only exposes a reactive</span><a id="_idIndexMarker564"/><span class="koboSpan" id="kobo.331.1"> state but also implements computed values. </span><span class="koboSpan" id="kobo.331.2">As an officially supported project, Pinia also exposes implementations of the Options and Composition APIs. </span><span class="koboSpan" id="kobo.331.3">To use Pinia, we need to first include it in our project with the following command in the project’s </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">root directory:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.333.1">
$ npm install pinia</span></pre>
<p><span class="koboSpan" id="kobo.334.1">After the installation, we should create a store and then attach it to our application so that it can be used by all the components. </span><span class="koboSpan" id="kobo.334.2">A store is like our reactive singleton from the previous section, meaning an object that will have reactive fields to be shared in our application, but also the related business logic. </span><span class="koboSpan" id="kobo.334.3">So, each</span><a id="_idIndexMarker565"/><span class="koboSpan" id="kobo.335.1"> store will have the following items: </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">data</span></strong><span class="koboSpan" id="kobo.337.1">, computed properties known as </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">getters</span></strong><span class="koboSpan" id="kobo.339.1">, and methods known as </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">actions</span></strong><span class="koboSpan" id="kobo.341.1">. </span><span class="koboSpan" id="kobo.341.2">We define each store </span><a id="_idIndexMarker566"/><span class="koboSpan" id="kobo.342.1">in its own file as a module, defining each item. </span><span class="koboSpan" id="kobo.342.2">Using the Options API, a store would look </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">like this:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.344.1">Options API basic store</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.345.1">
import { </span><strong class="bold"><span class="koboSpan" id="kobo.346.1">defineStore </span></strong><span class="koboSpan" id="kobo.347.1">} from 'pinia';                    //1
const </span><strong class="bold"><span class="koboSpan" id="kobo.348.1">useCounterStore </span></strong><span class="koboSpan" id="kobo.349.1">= defineStore(</span><strong class="bold"><span class="koboSpan" id="kobo.350.1">'counter'</span></strong><span class="koboSpan" id="kobo.351.1">, {        //2
  </span><strong class="bold"><span class="koboSpan" id="kobo.352.1">state</span></strong><span class="koboSpan" id="kobo.353.1">: () =&gt; {return </span><strong class="bold"><span class="koboSpan" id="kobo.354.1">{count: 0, in_range: false}</span></strong><span class="koboSpan" id="kobo.355.1">},    //3
  </span><strong class="bold"><span class="koboSpan" id="kobo.356.1">getters</span></strong><span class="koboSpan" id="kobo.357.1">: {
    doubleCount: (state) =&gt; {                           //4
      if(state.count&gt;=0){
            return state.count *2;
      }else{
       return 0
      }
  }, inRange: (state)=&gt;return state.count&gt;=0},
  </span><strong class="bold"><span class="koboSpan" id="kobo.358.1">actions</span></strong><span class="koboSpan" id="kobo.359.1">: {                                            //5
    increment(){this.count++},
    decrement(){this.count--;}
  },
})
export {</span><strong class="bold"><span class="koboSpan" id="kobo.360.1">useCounterStore}</span></strong></pre>
<p><span class="koboSpan" id="kobo.361.1">In this store, we start by importing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">defineStore</span></strong><span class="koboSpan" id="kobo.363.1"> constructor from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">Pinia </span></strong><span class="koboSpan" id="kobo.365.1">package (line </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">//1</span></strong><span class="koboSpan" id="kobo.367.1">) and use it to create a store in line </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">//2</span></strong><span class="koboSpan" id="kobo.369.1">. </span><span class="koboSpan" id="kobo.369.2">This constructor receives </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">two arguments:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.371.1">The name of the</span><a id="_idIndexMarker567"/><span class="koboSpan" id="kobo.372.1"> store, as a string. </span><span class="koboSpan" id="kobo.372.2">This has</span><a id="_idIndexMarker568"/><span class="koboSpan" id="kobo.373.1"> to be unique among the stores, as it is used internally as </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">an ID.</span></span></li>
<li><span class="koboSpan" id="kobo.375.1">An object with the store definition with the </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">following members:</span></span><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">state</span></strong><span class="koboSpan" id="kobo.378.1"> (line </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">//3</span></strong><span class="koboSpan" id="kobo.380.1">): This is a function that returns an object. </span><span class="koboSpan" id="kobo.380.2">Notice that we do not declare it to be reactive. </span><span class="koboSpan" id="kobo.380.3">Pinia will take care </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">of that.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">getters</span></strong><span class="koboSpan" id="kobo.383.1"> (line </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">//4</span></strong><span class="koboSpan" id="kobo.385.1">): This is an object whose members will become computed properties. </span><span class="koboSpan" id="kobo.385.2">Each member receives as the first argument the state of the store, as a </span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">reactive object.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">actions</span></strong><span class="koboSpan" id="kobo.388.1"> (line </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">//5</span></strong><span class="koboSpan" id="kobo.390.1">): This is, again, an object whose members are functions that can access and modify the state but must do so by accessing it through the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">this</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.392.1"> keyword.</span></span></li></ul></li>
</ul>
<p><span class="koboSpan" id="kobo.393.1">Using the Options API to define</span><a id="_idIndexMarker569"/><span class="koboSpan" id="kobo.394.1"> the store is a good way to understand </span><a id="_idIndexMarker570"/><span class="koboSpan" id="kobo.395.1">the parts that make it up. </span><span class="koboSpan" id="kobo.395.2">However, the change of syntax between </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">getters</span></strong><span class="koboSpan" id="kobo.397.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">actions</span></strong><span class="koboSpan" id="kobo.399.1"> could be confusing and lead to involuntary mistakes, as one accesses the state through an argument and the other by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">this</span></strong><span class="koboSpan" id="kobo.401.1"> reference. </span><span class="koboSpan" id="kobo.401.2">However, if we take a moment to look at the constructor, we can see that </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">getters</span></strong><span class="koboSpan" id="kobo.403.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">actions</span></strong><span class="koboSpan" id="kobo.405.1"> are analogous to </span><em class="italic"><span class="koboSpan" id="kobo.406.1">computed properties and component methods</span></em><span class="koboSpan" id="kobo.407.1"> (functions). </span><span class="koboSpan" id="kobo.407.2">With that in mind, let’s see how to rewrite this store using the Composition API, and this is the one we will use in our </span><span class="No-Break"><span class="koboSpan" id="kobo.408.1">example code:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.409.1">/stores/counter.js</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.410.1">
//Composition API
</span><strong class="bold"><span class="koboSpan" id="kobo.411.1">import {ref,computed} from 'vue'</span></strong><span class="koboSpan" id="kobo.412.1">                          //1
import {defineStore} from 'pinia'
const useCounterStore=defineStore('counter',</span><strong class="bold"><span class="koboSpan" id="kobo.413.1">()=&gt;{</span></strong><span class="koboSpan" id="kobo.414.1">         //2
    const
        count = ref(0),                                   //3
        in_range=ref(true),
        doubleCount = computed(() =&gt; {                    //4
             if(count.value&gt;=0){
                 return count.value *2;
             }else{
                 return 0
        }}),
        inRange = computed(()=&gt;return count.value&gt;=0);
    function increment() {count.value++}                  //5
    function decrement(){count.value--;}
    return {                                              //6
        count, doubleCount, inRange,
        increment, decrement
    }
</span><strong class="bold"><span class="koboSpan" id="kobo.415.1">})</span></strong></pre>
<p><span class="koboSpan" id="kobo.416.1">Using the Composition API</span><a id="_idIndexMarker571"/><span class="koboSpan" id="kobo.417.1"> makes the store look more like the rest</span><a id="_idIndexMarker572"/><span class="koboSpan" id="kobo.418.1"> of our application, as we apply the same approach. </span><span class="koboSpan" id="kobo.418.2">We start by importing from Vue the constructors we need in line </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">//1</span></strong><span class="koboSpan" id="kobo.420.1">, as with components using the same API. </span><span class="koboSpan" id="kobo.420.2">This time, when we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">defineStore</span></strong><span class="koboSpan" id="kobo.422.1"> constructor, instead of passing an object we pass a function (or arrow function) that will return the reactive properties and methods that make up the store. </span><span class="koboSpan" id="kobo.422.2">You can see this in line </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">//2</span></strong><span class="koboSpan" id="kobo.424.1">, and then the </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">return</span></strong><span class="koboSpan" id="kobo.426.1"> object in line </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">//6</span></strong><span class="koboSpan" id="kobo.428.1">. </span><span class="koboSpan" id="kobo.428.2">As you can expect, inside that function we declare our reactive properties (line </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">//3</span></strong><span class="koboSpan" id="kobo.430.1">) and computed properties (line </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">//4</span></strong><span class="koboSpan" id="kobo.432.1">), and methods (line </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">//5</span></strong><span class="koboSpan" id="kobo.434.1">). </span><span class="koboSpan" id="kobo.434.2">Reactive properties will become, well, reactive properties. </span><span class="koboSpan" id="kobo.434.3">Computed properties will become our getters, and the functions will become the actions. </span><span class="koboSpan" id="kobo.434.4">This far, this syntax does not have the syntactic sugar we are used to using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">&lt;script setup&gt;</span></strong><span class="koboSpan" id="kobo.436.1"> tag, but the body of the function is the same approach (state of mind) that we use </span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">with components.</span></span></p>
<p><span class="koboSpan" id="kobo.438.1">Now that we have a store (and we could have many), before we can actually use it, we need to implement Pinia in our application. </span><span class="koboSpan" id="kobo.438.2">For that, in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">main.js</span></strong><span class="koboSpan" id="kobo.440.1"> file, include the following </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">highlighted lines:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.442.1">./main.js</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.443.1">
import { createApp } from 'vue'
</span><strong class="bold"><span class="koboSpan" id="kobo.444.1">import { createPinia } from 'pinia'</span></strong><span class="koboSpan" id="kobo.445.1">
import App from './App.vue'
const app = createApp(App)
</span><strong class="bold"><span class="koboSpan" id="kobo.446.1">app.use(createPinia())</span></strong><span class="koboSpan" id="kobo.447.1">
app.mount('#app')</span></pre>
<p><span class="koboSpan" id="kobo.448.1">This step is necessary to enable</span><a id="_idIndexMarker573"/><span class="koboSpan" id="kobo.449.1"> the Pinia engine for the entire </span><a id="_idIndexMarker574"/><span class="koboSpan" id="kobo.450.1">application. </span><span class="koboSpan" id="kobo.450.2">What is left now is to import the store we want to use in our components that need it. </span><span class="koboSpan" id="kobo.450.3">For example, if you look into the example repository, you will find </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">this file:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.452.1">/pinia/ChildPinia.vue</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.453.1">
&lt;script setup&gt;
import { </span><strong class="bold"><span class="koboSpan" id="kobo.454.1">useCounterStore </span></strong><span class="koboSpan" id="kobo.455.1">} from '../../stores/counter';   //1
const </span><strong class="bold"><span class="koboSpan" id="kobo.456.1">$store=useCounterStore()</span></strong><span class="koboSpan" id="kobo.457.1">                            </span><strong class="bold"><span class="koboSpan" id="kobo.458.1">//2</span></strong><span class="koboSpan" id="kobo.459.1">
&lt;/script&gt;
&lt;template&gt;
    &lt;h4&gt;Child component&lt;/h4&gt;
    &lt;code :class="{'red': !</span><strong class="bold"><span class="koboSpan" id="kobo.460.1">$store.in_range</span></strong><span class="koboSpan" id="kobo.461.1">}"&gt;             //3
        {{$store}}
    &lt;/code&gt;
    &lt;button @click="</span><strong class="bold"><span class="koboSpan" id="kobo.462.1">$store.increment()</span></strong><span class="koboSpan" id="kobo.463.1">"&gt;                  //4
        Increment&lt;/button&gt;
    &lt;button @click="$store.decrement()"
        :disabled="!$store.in_range"&gt;Decrement
    &lt;/button&gt;
&lt;/template&gt;
&lt;style scoped&gt;
.red{color: red;}
&lt;/style&gt;</span></pre>
<p><span class="koboSpan" id="kobo.464.1">We import the store constructor in line </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">//1</span></strong><span class="koboSpan" id="kobo.466.1">, and we create our reactive object in line </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">//2</span></strong><span class="koboSpan" id="kobo.468.1">. </span><span class="koboSpan" id="kobo.468.2">To use their values or execute their methods, we use them directly as if they were regular objects using the dot (</span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">.</span></strong><span class="koboSpan" id="kobo.470.1">) notation. </span><span class="koboSpan" id="kobo.470.2">Notice in line </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">//3</span></strong><span class="koboSpan" id="kobo.472.1"> how we access the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">in_range</span></strong><span class="koboSpan" id="kobo.474.1">, and later, in line </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">//4</span></strong><span class="koboSpan" id="kobo.476.1">, we execute the </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">increment()</span></strong><span class="koboSpan" id="kobo.478.1"> function. </span><span class="koboSpan" id="kobo.478.2">As we would expect, any modification of the store values will be synchronized automatically across </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">our application.</span></span></p>
<p><span class="koboSpan" id="kobo.480.1">Unlike previous methods, Pinia stores and states are traceable and show up on the developer tools. </span><span class="koboSpan" id="kobo.480.2">For applications of medium size and above, using Pinia is almost a requirement when a central state </span><span class="No-Break"><span class="koboSpan" id="kobo.481.1">is necessary.</span></span></p>
<p><span class="koboSpan" id="kobo.482.1">Pinia is Vue 3’s official solution</span><a id="_idIndexMarker575"/><span class="koboSpan" id="kobo.483.1"> for central state</span><a id="_idIndexMarker576"/><span class="koboSpan" id="kobo.484.1"> management, replacing Vuex from the Vue 2 branch. </span><span class="koboSpan" id="kobo.484.2">In practice, they accomplish the same functionality, but the former has some advantages that made the Vue team select it and sponsor it. </span><span class="koboSpan" id="kobo.484.3">A deep review is not a topic for our purposes, but here</span><a id="_idIndexMarker577"/><span class="koboSpan" id="kobo.485.1"> is a short list of changes or advantages </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">of Pinia:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.487.1">Different approach to stores. </span><span class="koboSpan" id="kobo.487.2">In Pinia, each store is its own module, and they are all dynamic. </span><span class="koboSpan" id="kobo.487.3">Vuex instead had one single store, with partitions </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">in modules.</span></span></li>
<li><span class="koboSpan" id="kobo.489.1">The syntax and API for Pinia a</span><a id="_idTextAnchor180"/><span class="koboSpan" id="kobo.490.1">re simpler and less verbose </span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">than Vuex.</span></span></li>
<li><span class="koboSpan" id="kobo.492.1">Better support for TypeS</span><a id="_idTextAnchor181"/><span class="koboSpan" id="kobo.493.1">cript and discoverability for the IDE’s </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">autocomplete features.</span></span></li>
<li><span class="koboSpan" id="kobo.495.1">Support for both Options and </span><span class="No-Break"><span class="koboSpan" id="kobo.496.1">Composition APIs.</span></span></li>
<li><span class="koboSpan" id="kobo.497.1">Better internal use of Vue’s new </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">reactive models.</span></span></li>
<li><span class="koboSpan" id="kobo.499.1">Developer </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">tools support.</span></span></li>
<li><span class="koboSpan" id="kobo.501.1">A plugin architecture to </span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">extend Pinia.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.503.1">The change from Vuex to Pinia makes it difficult to make a one-step replacement upgrade for projects that were using it. </span><span class="koboSpan" id="kobo.503.2">However, the Pinia team</span><a id="_idIndexMarker578"/><span class="koboSpan" id="kobo.504.1"> has published a nice migration guide on the official website that you can find here:</span><a href=" https://pinia.vuejs.org/cookbook/migration-vuex.html"><span class="koboSpan" id="kobo.505.1"> https://pinia.vuejs.org/cookbook/migration-vuex.html</span></a><span class="koboSpan" id="kobo.506.1">. </span><span class="koboSpan" id="kobo.506.2">For a complete reference of all the options available with Pinia, I recommend reading</span><a id="_idIndexMarker579"/><span class="koboSpan" id="kobo.507.1"> the official documentation </span><span class="No-Break"><span class="koboSpan" id="kobo.508.1">at </span></span><a href="https://pinia.vuejs.org"><span class="No-Break"><span class="koboSpan" id="kobo.509.1">https://pinia.vuejs.org</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.510.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.511.1">With Pinia, we have seen</span><a id="_idIndexMarker580"/><span class="koboSpan" id="kobo.512.1"> now the most common and relevant</span><a id="_idIndexMarker581"/><span class="koboSpan" id="kobo.513.1"> patterns to control the flow of data between components (and services!), but these are not the only ones available to us. </span><span class="koboSpan" id="kobo.513.2">We will see next the stores provided by default in modern web browsers, and how to </span><span class="No-Break"><span class="koboSpan" id="kobo.514.1">use them.</span></span></p>
<h1 id="_idParaDest-142"><a id="_idTextAnchor182"/><span class="koboSpan" id="kobo.515.1">Browser data stores – session, local, and IndexedDB</span></h1>
<p><span class="koboSpan" id="kobo.516.1">Browsers provide</span><a id="_idIndexMarker582"/><span class="koboSpan" id="kobo.517.1"> other features to store data locally, which can be read not only by any other component but also by any script running on the same page. </span><span class="koboSpan" id="kobo.517.2">We will not talk about cookies, but the</span><a id="_idIndexMarker583"/><span class="koboSpan" id="kobo.518.1"> new methods</span><a id="_idIndexMarker584"/><span class="koboSpan" id="kobo.519.1"> provided as key-value stores: </span><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">SessionStore</span></strong><span class="koboSpan" id="kobo.521.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">LocalStore</span></strong><span class="koboSpan" id="kobo.523.1">. </span><span class="koboSpan" id="kobo.523.2">But these are not the only options, as browsers also provide a database called </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">IndexedDB</span></strong><span class="koboSpan" id="kobo.525.1"> that offers much more storage space and can be accessed also outside the scope of our application’s window in a different thread. </span><span class="koboSpan" id="kobo.525.2">We will see how in </span><a href="B18602_08.xhtml#_idTextAnchor186"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.526.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.527.1">, </span><em class="italic"><span class="koboSpan" id="kobo.528.1">Multithreading with Web Workers</span></em><span class="koboSpan" id="kobo.529.1">, in more detail, while here, we will focus first on understanding the basic concept and limitations of </span><span class="No-Break"><span class="koboSpan" id="kobo.530.1">each one.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">SessionStorage</span></strong><span class="koboSpan" id="kobo.532.1"> is a read-only object created for each page origin. </span><span class="koboSpan" id="kobo.532.2">It stores only string data that can be accessed and retrieved using a simple interface. </span><span class="koboSpan" id="kobo.532.3">This data exists only through the duration of the </span><em class="italic"><span class="koboSpan" id="kobo.533.1">browser tab</span></em><span class="koboSpan" id="kobo.534.1"> and persists during refreshes. </span><span class="koboSpan" id="kobo.534.2">A clear example of this use is to persist form data. </span><span class="koboSpan" id="kobo.534.3">The object is attached to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">window</span></strong><span class="koboSpan" id="kobo.536.1"> object (</span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">window.sessionStorage</span></strong><span class="koboSpan" id="kobo.538.1">) and can be accessed by any script on </span><span class="No-Break"><span class="koboSpan" id="kobo.539.1">the page.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">LocalStorage</span></strong><span class="koboSpan" id="kobo.541.1"> is similar to </span><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">SessionStorage</span></strong><span class="koboSpan" id="kobo.543.1"> in capabilities and data storage. </span><span class="koboSpan" id="kobo.543.2">It has the same interface and is restricted also to the same origin of the page. </span><span class="koboSpan" id="kobo.543.3">The main difference is that it persists beyond the life of the page and is shared among all the open pages of the same origin. </span><span class="koboSpan" id="kobo.543.4">Websites and applications can use it to store data and retrieve it throughout multiple sessions on the </span><span class="No-Break"><span class="koboSpan" id="kobo.544.1">same browser.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">SessionStorage</span></strong><span class="koboSpan" id="kobo.546.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">LocalStorage</span></strong><span class="koboSpan" id="kobo.548.1"> share the </span><span class="No-Break"><span class="koboSpan" id="kobo.549.1">same interface:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">.setItem(item_name, item_data)</span></strong><span class="koboSpan" id="kobo.551.1">: Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">item_name</span></strong><span class="koboSpan" id="kobo.553.1"> is a string that uniquely identifies </span><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">item_data</span></strong><span class="koboSpan" id="kobo.555.1">, which is also </span><span class="No-Break"><span class="koboSpan" id="kobo.556.1">a string</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">.getItem(item_name)</span></strong><span class="koboSpan" id="kobo.558.1">: Retrieves the string data stored under </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">item-_name</span></strong><span class="koboSpan" id="kobo.560.1">, or null if </span><span class="No-Break"><span class="koboSpan" id="kobo.561.1">not found</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.562.1">.removeItem(item_name)</span></strong><span class="koboSpan" id="kobo.563.1">: Deletes the data by </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">item_name</span></strong><span class="koboSpan" id="kobo.565.1"> from </span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">the store</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">.clear()</span></strong><span class="koboSpan" id="kobo.568.1">: Removes all data from </span><span class="No-Break"><span class="koboSpan" id="kobo.569.1">the store</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.570.1">The preceding</span><a id="_idIndexMarker585"/><span class="koboSpan" id="kobo.571.1"> methods represent</span><a id="_idIndexMarker586"/><span class="koboSpan" id="kobo.572.1"> the totality of API endpoints</span><a id="_idIndexMarker587"/><span class="koboSpan" id="kobo.573.1"> for both storages. </span><span class="koboSpan" id="kobo.573.2">Simple enough—we can serialize data to record it in these stores. </span><span class="koboSpan" id="kobo.573.3">For example, to store a JSON object, we would use the following (we can omit the </span><strong class="source-inline"><span class="koboSpan" id="kobo.574.1">window</span></strong><span class="koboSpan" id="kobo.575.1"> object reference, as it is considered a </span><span class="No-Break"><span class="koboSpan" id="kobo.576.1">global object):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.577.1">
localStorage.setItem("MyData", JSON.stringify({…});</span></pre>
<p><span class="koboSpan" id="kobo.578.1">And then, to retrieve it, we would use </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.580.1">
let data=localStorage.getItem("MyData")
if(data){
   data=JSON.parse(data);
}</span></pre>
<p><span class="koboSpan" id="kobo.581.1">Both stores have some limitations</span><a id="_idIndexMarker588"/><span class="koboSpan" id="kobo.582.1"> and a </span><span class="No-Break"><span class="koboSpan" id="kobo.583.1">few caveats:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.584.1">There is no standard limit set among browsers</span><a id="_idIndexMarker589"/><span class="koboSpan" id="kobo.585.1"> for how many characters each store can hold. </span><span class="koboSpan" id="kobo.585.2">Strings are stored in UTF-16, so each character can take from 2 bytes or more (see </span><a href="https://en.wikipedia.org/wiki/UTF-16"><span class="koboSpan" id="kobo.586.1">https://en.wikipedia.org/wiki/UTF-16</span></a><span class="koboSpan" id="kobo.587.1">), which makes calculation hard. </span><span class="koboSpan" id="kobo.587.2">The specifications recommend at least 5 MB for </span><span class="No-Break"><span class="koboSpan" id="kobo.588.1">each storage.</span></span></li>
<li><span class="koboSpan" id="kobo.589.1">When these storages run out of space, some browsers crash the page, while others prompt the user for consent to expand </span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">the storage.</span></span></li>
<li><span class="koboSpan" id="kobo.591.1">Access to store and retrieve data is sequential, possibly blocking the render process and making the page/application look irresponsive... </span><span class="koboSpan" id="kobo.591.2">But this only happens in </span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">long operations.</span></span></li>
<li><span class="koboSpan" id="kobo.593.1">For </span><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">sessionStorage</span></strong><span class="koboSpan" id="kobo.595.1">, duplicating tabs will also duplicate the storage. </span><span class="koboSpan" id="kobo.595.2">Instead, for </span><strong class="source-inline"><span class="koboSpan" id="kobo.596.1">localStorage</span></strong><span class="koboSpan" id="kobo.597.1">, both tabs will access the </span><span class="No-Break"><span class="koboSpan" id="kobo.598.1">same information.</span></span></li>
<li><span class="koboSpan" id="kobo.599.1">Neither localStorage nor sessionStorage is reactive</span><a id="_idIndexMarker590"/><span class="koboSpan" id="kobo.600.1"> or provides listeners to watch when a </span><span class="No-Break"><span class="koboSpan" id="kobo.601.1">value changes.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.602.1">The preceding limitations</span><a id="_idIndexMarker591"/><span class="koboSpan" id="kobo.603.1"> are in no way a threat or a suggestion not to use them. </span><span class="koboSpan" id="kobo.603.2">Instead, they</span><a id="_idIndexMarker592"/><span class="koboSpan" id="kobo.604.1"> are the boundaries and limits to using them, since all data is stored locally on the user’s browser, and nothing is sent back to the server (as </span><span class="No-Break"><span class="koboSpan" id="kobo.605.1">cookies do).</span></span></p>
<p><span class="koboSpan" id="kobo.606.1">In contrast to these web storage objects, </span><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">IndexedDB</span></strong><span class="koboSpan" id="kobo.608.1"> is a different system altogether. </span><span class="koboSpan" id="kobo.608.2">It is a full implementation</span><a id="_idIndexMarker593"/><span class="koboSpan" id="kobo.609.1"> of a transactional database that stores JavaScript objects under a unique key. </span><span class="koboSpan" id="kobo.609.2">We can open multiple databases, create connections to them, and define schemas, and all operations are asynchronous, so there is no application blocking. </span><span class="koboSpan" id="kobo.609.3">The size limit has also</span><a id="_idIndexMarker594"/><span class="koboSpan" id="kobo.610.1"> been extended, with a soft limit of 50 MB. </span><span class="koboSpan" id="kobo.610.2">If a database grows more than that, the user is prompted to consent to expand it, and more space is given. </span><span class="koboSpan" id="kobo.610.3">In theory, depending on the implementation in each browser, it could occupy as much space as available. </span><span class="koboSpan" id="kobo.610.4">In practice, each browser has its own way to negotiate available space with the local operating system, so no hard number can be given about its limits that would hold true in </span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">every case.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.612.1">Curiosity</span></p>
<p class="callout"><span class="koboSpan" id="kobo.613.1">The Chrome engine provides a flag to build the engine without limits to </span><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">IndexedDB</span></strong><span class="koboSpan" id="kobo.615.1">, save for the available disk space. </span><span class="koboSpan" id="kobo.615.2">This flag can also be activated in hybrid frameworks such as NW.js or when building the browser </span><span class="No-Break"><span class="koboSpan" id="kobo.616.1">from source.</span></span></p>
<p><span class="koboSpan" id="kobo.617.1">There is a major issue with </span><strong class="source-inline"><span class="koboSpan" id="kobo.618.1">IndexedDB</span></strong><span class="koboSpan" id="kobo.619.1">, which is that its API is </span><a id="_idIndexMarker595"/><span class="koboSpan" id="kobo.620.1">complicated and cumbersome, so it is very rare that an application would access it directly. </span><span class="koboSpan" id="kobo.620.2">Instead, since </span><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">IndexedDB</span></strong><span class="koboSpan" id="kobo.622.1"> is so flexible and fast, there is a fair</span><a id="_idIndexMarker596"/><span class="koboSpan" id="kobo.623.1"> number of libraries that create their own database implementation on top of it or facilitate a simpler interface (using the Façade pattern, for example). </span><span class="koboSpan" id="kobo.623.2">A curated list of these libraries</span><a id="_idIndexMarker597"/><span class="koboSpan" id="kobo.624.1"> and frameworks can be found in the </span><strong class="bold"><span class="koboSpan" id="kobo.625.1">Mozilla Developer Network</span></strong><span class="koboSpan" id="kobo.626.1"> documentation (https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API#see_also). </span><span class="koboSpan" id="kobo.626.2">In our implementation examples for </span><a href="B18602_08.xhtml#_idTextAnchor186"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.627.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.628.1">, </span><em class="italic"><span class="koboSpan" id="kobo.629.1">Multithreading with Web Workers</span></em><span class="koboSpan" id="kobo.630.1">, we will use one of these libraries. </span><span class="koboSpan" id="kobo.630.2">For the purposes of this chapter, just keep in mind that each browser provides you with a powerful database for your application, and you can access it through a variety of patterns </span><span class="No-Break"><span class="koboSpan" id="kobo.631.1">and approaches.</span></span></p>
<h1 id="_idParaDest-143"><a id="_idTextAnchor183"/><span class="koboSpan" id="kobo.632.1">Experimenting with reactivity and Proxies patterns</span></h1>
<p><span class="koboSpan" id="kobo.633.1">It is time to put into practice</span><a id="_idIndexMarker598"/><span class="koboSpan" id="kobo.634.1"> what we have learned in this chapter under the light</span><a id="_idIndexMarker599"/><span class="koboSpan" id="kobo.635.1"> of patterns we saw in </span><a href="B18602_02.xhtml#_idTextAnchor040"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.636.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.637.1">, </span><em class="italic"><span class="koboSpan" id="kobo.638.1">Software Design Principles and Patterns</span></em><span class="koboSpan" id="kobo.639.1">, with a small experimental project. </span><span class="koboSpan" id="kobo.639.2">We want to create an option to make </span><strong class="source-inline"><span class="koboSpan" id="kobo.640.1">sessionStorage</span></strong><span class="koboSpan" id="kobo.641.1"> data behave like a reactive central state manager so that we can use it in our components. </span><span class="koboSpan" id="kobo.641.2">Possible uses for this approach could be to persist user-entered data during refreshes, alert components of data changes, and </span><span class="No-Break"><span class="koboSpan" id="kobo.642.1">so on.</span></span></p>
<p><span class="koboSpan" id="kobo.643.1">Since </span><strong class="source-inline"><span class="koboSpan" id="kobo.644.1">SessionStorage</span></strong><span class="koboSpan" id="kobo.645.1"> does not provide an API we can listen to, our approach will be to create a Proxy handler using the Decorator pattern, to match and keep synchronized the values in the store with an internal and private reactive property. </span><span class="koboSpan" id="kobo.645.2">We will wrap this in a </span><em class="italic"><span class="koboSpan" id="kobo.646.1">singleton</span></em><span class="koboSpan" id="kobo.647.1"> and use the </span><em class="italic"><span class="koboSpan" id="kobo.648.1">Central State </span></em><span class="koboSpan" id="kobo.649.1">manager approach to share it in our application. </span><span class="koboSpan" id="kobo.649.2">Let’s start by creating our </span><span class="No-Break"><span class="koboSpan" id="kobo.650.1">core service:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.651.1">/services/sessionStorage.js</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.652.1">
import { reactive } from 'vue';
let </span><strong class="bold"><span class="koboSpan" id="kobo.653.1">handler </span></strong><span class="koboSpan" id="kobo.654.1">= {                                                  //1
</span><strong class="bold"><span class="koboSpan" id="kobo.655.1">    props: reactive({})</span></strong><span class="koboSpan" id="kobo.656.1">,                                         //2
</span><strong class="bold"><span class="koboSpan" id="kobo.657.1">    get</span></strong><span class="koboSpan" id="kobo.658.1">(target, prop, receiver) {                                //3
        let value = target[prop]
        if (value instanceof Function) {
            return (...args) =&gt; {
                return target[prop](...args)
            }
        } else {
            value = target.getItem(prop)
            if (value) {
                this.props[prop] = value;
            }
            return this.props[prop]
        }
    },
</span><strong class="bold"><span class="koboSpan" id="kobo.659.1">    set</span></strong><span class="koboSpan" id="kobo.660.1">(target, prop, value) {                                   //4
        target.setItem(prop, value)
        this.props[prop] = value
        return true;
    }
}
const Decorator= new Proxy(window.sessionStorage, handler);      //5
function </span><strong class="bold"><span class="koboSpan" id="kobo.661.1">useSessionStorage</span></strong><span class="koboSpan" id="kobo.662.1">(){                                    //6
     return Decorator;
}
export { useSessionStorage }</span></pre>
<p><span class="koboSpan" id="kobo.663.1">In this </span><strong class="source-inline"><span class="koboSpan" id="kobo.664.1">service</span></strong><span class="koboSpan" id="kobo.665.1"> module, we will use</span><a id="_idIndexMarker600"/><span class="koboSpan" id="kobo.666.1"> the native JavaScript implementation</span><a id="_idIndexMarker601"/><span class="koboSpan" id="kobo.667.1"> of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.668.1">Proxy</span></strong><span class="koboSpan" id="kobo.669.1"> object to capture specific calls to the API of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.670.1">window.sessionStorage</span></strong><span class="koboSpan" id="kobo.671.1"> object. </span><span class="koboSpan" id="kobo.671.2">The use of Proxy objects</span><a id="_idIndexMarker602"/><span class="koboSpan" id="kobo.672.1"> is rather advanced in JavaScript, so I recommend that you look at the documentation on MDN here: </span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy"><span class="koboSpan" id="kobo.673.1">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy</span></a><span class="koboSpan" id="kobo.674.1">. </span><span class="koboSpan" id="kobo.674.2">We start by importing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">reactive()</span></strong><span class="koboSpan" id="kobo.676.1"> constructor from Vue and then creating a plain object named </span><strong class="source-inline"><span class="koboSpan" id="kobo.677.1">handler</span></strong><span class="koboSpan" id="kobo.678.1"> (line </span><strong class="source-inline"><span class="koboSpan" id="kobo.679.1">//1</span></strong><span class="koboSpan" id="kobo.680.1">), that will act as our proxy/decorator. </span><span class="koboSpan" id="kobo.680.2">This object will be placed to intercept the calls to the original </span><strong class="source-inline"><span class="koboSpan" id="kobo.681.1">sessionStorage</span></strong><span class="koboSpan" id="kobo.682.1">. </span><span class="koboSpan" id="kobo.682.2">Inside it, we declare a </span><strong class="source-inline"><span class="koboSpan" id="kobo.683.1">prop</span></strong><span class="koboSpan" id="kobo.684.1"> property as reactive (line </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">//2)</span></strong><span class="koboSpan" id="kobo.686.1">), initializing it with an empty object. </span><span class="koboSpan" id="kobo.686.2">This object will be synchronized with the storage. </span><span class="koboSpan" id="kobo.686.3">Then, we create two traps (or interceptors): one for get or read operations (line </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">//3</span></strong><span class="koboSpan" id="kobo.688.1">), and another for set or write operations (</span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">line </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.690.1">//4</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.691.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.692.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">get()</span></strong><span class="koboSpan" id="kobo.694.1"> function receives three arguments, of which we will use only two. </span><span class="koboSpan" id="kobo.694.2">The target refers to </span><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">sessionStorage</span></strong><span class="koboSpan" id="kobo.696.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">prop</span></strong><span class="koboSpan" id="kobo.698.1"> is the name of the method or attribute requested. </span><span class="koboSpan" id="kobo.698.2">Because </span><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">prop</span></strong><span class="koboSpan" id="kobo.700.1"> can be either one, we test if it is a function with an </span><strong class="source-inline"><span class="koboSpan" id="kobo.701.1">if</span></strong><span class="koboSpan" id="kobo.702.1"> statement, and if so, we return a function that takes in all the arguments and returns the original function call with them. </span><span class="koboSpan" id="kobo.702.2">If it is not a function, then we retrieve the item from the store, test if it is part of our internal reactive property, and finally, return the value. </span><span class="koboSpan" id="kobo.702.3">This makes sure that our internal </span><strong class="source-inline"><span class="koboSpan" id="kobo.703.1">props</span></strong><span class="koboSpan" id="kobo.704.1"> object is in sync with values created before the decorator </span><span class="No-Break"><span class="koboSpan" id="kobo.705.1">was implemented.</span></span></p>
<p><span class="koboSpan" id="kobo.706.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.707.1">set()</span></strong><span class="koboSpan" id="kobo.708.1"> function is simpler, as we just</span><a id="_idIndexMarker603"/><span class="koboSpan" id="kobo.709.1"> take the value passed and store</span><a id="_idIndexMarker604"/><span class="koboSpan" id="kobo.710.1"> it in both places: our internal props and </span><span class="No-Break"><span class="koboSpan" id="kobo.711.1">the store.</span></span></p>
<p><span class="koboSpan" id="kobo.712.1">With our handler ready, in line </span><strong class="source-inline"><span class="koboSpan" id="kobo.713.1">//5</span></strong><span class="koboSpan" id="kobo.714.1">, we create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.715.1">Decorator</span></strong><span class="koboSpan" id="kobo.716.1"> proxy object using a native JavaScript constructor and provide a </span><strong class="source-inline"><span class="koboSpan" id="kobo.717.1">useSessionStorage()</span></strong><span class="koboSpan" id="kobo.718.1"> function in line </span><strong class="source-inline"><span class="koboSpan" id="kobo.719.1">//6</span></strong><span class="koboSpan" id="kobo.720.1"> so that we can export it as </span><span class="No-Break"><span class="koboSpan" id="kobo.721.1">a singleton.</span></span></p>
<p><span class="koboSpan" id="kobo.722.1">With our Decorator created, now we can use it in our components, with the same approach as is standard in </span><span class="No-Break"><span class="koboSpan" id="kobo.723.1">Vue 3:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.724.1">/session_storage/ChildSession.vue</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.725.1">
&lt;script setup&gt;
    import {</span><strong class="bold"><span class="koboSpan" id="kobo.726.1">useSessionStorage</span></strong><span class="koboSpan" id="kobo.727.1">} from "../../services/SessionStorage"
    const </span><strong class="bold"><span class="koboSpan" id="kobo.728.1">$sessionStorage </span></strong><span class="koboSpan" id="kobo.729.1">= </span><strong class="bold"><span class="koboSpan" id="kobo.730.1">useSessionStorage()</span></strong><span class="koboSpan" id="kobo.731.1">
&lt;/script&gt;
&lt;template&gt;
    &lt;strong&gt;Child Component&lt;/strong&gt;
    Counter: {{ </span><strong class="bold"><span class="koboSpan" id="kobo.732.1">$sessionStorage.counter </span></strong><span class="koboSpan" id="kobo.733.1">}}
&lt;/template&gt;</span></pre>
<p><span class="koboSpan" id="kobo.734.1">Notice that now we can use this object as a Pinia store or a simple reactive object, and the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.735.1">sessionStorage</span></strong><span class="koboSpan" id="kobo.736.1"> will always be synchronized and persist even if we refresh the page. </span><span class="koboSpan" id="kobo.736.2">To view the full example, please check the implementation of the code example in the GitHub repository. </span><span class="koboSpan" id="kobo.736.3">When you run it, you will see a section like </span><span class="No-Break"><span class="koboSpan" id="kobo.737.1">this one:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer054">
<span class="koboSpan" id="kobo.738.1"><img alt="Figure 7.6 – Example of our reactive $sessionStorage object" src="image/Figure_7.06_B18602.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.739.1">Figure 7.6 – Example of our reactive $sessionStorage object</span></p>
<p><span class="koboSpan" id="kobo.740.1">In this example, we also implemented a parent component with an input element. </span><span class="koboSpan" id="kobo.740.2">When you modify the value, it is automatically synchronized and reflected in the children component, but also in </span><strong class="source-inline"><span class="koboSpan" id="kobo.741.1">sessionStorage</span></strong><span class="koboSpan" id="kobo.742.1">. </span><span class="koboSpan" id="kobo.742.2">If you open the browser’s developer tools and navigate to the </span><strong class="bold"><span class="koboSpan" id="kobo.743.1">Web Storage</span></strong><span class="koboSpan" id="kobo.744.1"> section, you will see this reflected. </span><span class="koboSpan" id="kobo.744.2">Here is a screenshot of how this looks in Chrome, on an </span><span class="No-Break"><span class="koboSpan" id="kobo.745.1">Ubuntu system:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer055">
<span class="koboSpan" id="kobo.746.1"><img alt="Figure 7.7 – Session Storage showing the item from the example" src="image/Figure_7.07_B18602.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.747.1">Figure 7.7 – Session Storage showing the item from the example</span></p>
<p><span class="koboSpan" id="kobo.748.1">In the same way</span><a id="_idIndexMarker605"/><span class="koboSpan" id="kobo.749.1"> we implemented this pattern for the session</span><a id="_idIndexMarker606"/><span class="koboSpan" id="kobo.750.1"> storage, we could also, with a few changes, apply it to </span><span class="No-Break"><span class="koboSpan" id="kobo.751.1">local storage.</span></span></p>
<h1 id="_idParaDest-144"><a id="_idTextAnchor184"/><span class="koboSpan" id="kobo.752.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.753.1">In this chapter, we have seen in detail the different approaches and methods to control the flow of data between our components, services, and persistent storage provided by modern browsers. </span><span class="koboSpan" id="kobo.753.2">We also took time to integrate our knowledge by experimenting with session storage and the Decorator pattern to create a reactive/persistent central state. </span><span class="koboSpan" id="kobo.753.3">We took time to differentiate between approaches, and we have seen code for the implementation of each method. </span><span class="koboSpan" id="kobo.753.4">All these new skills are used daily in the development of Vue </span><span class="No-Break"><span class="koboSpan" id="kobo.754.1">3 applications.</span></span></p>
<p><span class="koboSpan" id="kobo.755.1">In the next chapter, we will investigate improving the performance of our application by using advanced JavaScript tools: </span><span class="No-Break"><span class="koboSpan" id="kobo.756.1">web workers.</span></span></p>
<h1 id="_idParaDest-145"><a id="_idTextAnchor185"/><span class="koboSpan" id="kobo.757.1">Review questions</span></h1>
<p><span class="koboSpan" id="kobo.758.1">Use these questions to review what you have learned in </span><span class="No-Break"><span class="koboSpan" id="kobo.759.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.760.1">Which methods do we have available to share data between </span><span class="No-Break"><span class="koboSpan" id="kobo.761.1">sibling components?</span></span></li>
<li><span class="koboSpan" id="kobo.762.1">What is a message/event bus, and when is it </span><span class="No-Break"><span class="koboSpan" id="kobo.763.1">most useful?</span></span></li>
<li><span class="koboSpan" id="kobo.764.1">What is a central state management approach, and how can we </span><span class="No-Break"><span class="koboSpan" id="kobo.765.1">implement it?</span></span></li>
<li><span class="koboSpan" id="kobo.766.1">What is the difference between session and </span><span class="No-Break"><span class="koboSpan" id="kobo.767.1">local storage?</span></span></li>
<li><span class="koboSpan" id="kobo.768.1">How can we see what information is stored in session or </span><span class="No-Break"><span class="koboSpan" id="kobo.769.1">local storage?</span></span></li>
</ul>
</div>
</body></html>