<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Putting Things to the Test</h1>
                </header>
            
            <article>
                
<p>Writing tests is crucial for the maintainability of your code. It's a known fact that having a good range of tests, covering most of your functionality, is as important as the functionality itself.</p>
<p>The first thing that comes to mind when thinking about tests is probably code quality assurance. You test the code that you write, so this is definitely ensuring the quality of your code. However, there are many other important aspects of writing tests:</p>
<ul>
<li><strong>Resistance to unexpected changes</strong>: Your tests define what your code is supposed to do. They test whether your code conforms to your specifications. This has several benefits, the most obvious of which is probably a resistance to unexpected changes in the future. If you modify the code in the future, you'll be less likely to break your existing code, because your tests will validate whether the existing functionality still works as specified.</li>
<li><strong>Documentation</strong>: Your tests define what your code should do. At the same time, they display the API calls that are required to use the concerned functionality. This is the perfect documentation for any developer. Whenever I want to understand how a library really works, the tests are the first thing I look at.</li>
<li><strong>Avoiding unnecessary code</strong>: The practice of writing tests forces you to limit your code to fulfill the requirements of your specification, and nothing more. Any code in your application that is not reached in your automated tests can be considered dead code. If you stick to a merciless refactoring approach, you'll remove such unused code as soon as possible.</li>
</ul>
<p>So far, we haven't considered testing in our book at all, and, given its importance, you may wonder why I am approaching this now, in the very last chapter of the book. In a real project, we'd definitely create tests much earlier, if not at first. However, I hope you understand that in this book, we postponed this rather important topic until the end for a reason. I really love testing, but, as we're mainly focused on the component architecture of Angular, placing this chapter at the end seemed more logical.</p>
<p>In this chapter, we'll look into how to perform proper unit testing on your components. We'll focus on unit testing; automated, end-to-end testing is beyond the scope of this book. We'll look into how to test user interaction with components, but not at the level it would be done in end-to-end testing.</p>
<p>In this chapter, we will delve into the following topics:</p>
<ul>
<li>An introduction to the Jasmine testing framework</li>
<li>Writing simple tests for components</li>
<li>Creating Jasmine spies and observing component output properties</li>
<li>Learning about Angular testing utilities, such as <kbd>inject</kbd>, <kbd>async</kbd>, <kbd>TestBed</kbd>, <kbd>ComponentFixture</kbd>, <kbd>DebugElement</kbd>, and more</li>
<li>Mocking components</li>
<li>Mocking existing services</li>
<li>Creating tests for our <kbd>Efforts</kbd> UI component</li>
<li>Creating tests for our <kbd>TaskListContainer</kbd> component</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">An introduction to Jasmine and Karma</h1>
                </header>
            
            <article>
                
<p>Jasmine is a very simple testing framework that comes with an API; it allows you to write <strong>Behavior-Driven Development</strong> (<strong>BDD</strong>) style tests. BDD is an agile software development process for defining specifications in a written format.</p>
<p>In BDD, we define that an agile user story consists of multiple scenarios. These scenarios closely relate to, or even replace, the acceptance criteria of a story. They define requirements on a higher level, and they are mostly written narratives. Each scenario consists of three parts:</p>
<ul>
<li><strong>Given</strong>: This part is used to describe the initial state of the scenario. The test code is where we perform all of the setup that is needed to execute the test scenario.</li>
<li><strong>When</strong>: This part reflects the changes that we perform on the system being tested. Usually, this part consists of some API calls and actions that reflect the behavior of a user of the system.</li>
<li><strong>Then</strong>: This part specifies what the system should look like after the given state and the changes applied in the <em>when</em> part. In our code, this is the part that is usually at the end of our test function, where we use assertion libraries to verify the state of the system.</li>
</ul>
<p>Jasmine comes with an API that makes it very easy to write tests that are structured according to the BDD style. Let's look at a very simple example of how we can use Jasmine to write a test for a shopping cart system:</p>
<pre>describe('Buying items in the shop', () =&gt; { 
  it('should increase the basket count', () =&gt; { 
    // Given 
    const shop = new Shop(); 
    // When 
    shop.buy('Toothpast'); 
    shop.buy('Shampoo'); 
    // Then 
    expect(shop.basket.length).toBe(2); 
    expect(shop.basket).toContain('Toothpaste'); 
    expect(shop.basket).toContain('Shampoo'); 
  }); 
}); </pre>
<p>Jasmine provides us with a <kbd>describe</kbd> function, which allows us to group certain scenarios on the same subject. In this example, we used the <kbd>describe</kbd> function to register a new test suite for tests concerning buying items in a shop.</p>
<p>Using the <kbd>it</kbd> function, we can register individual scenarios that we'd like to get tested. Within the <kbd>describe</kbd> callback function, we can register as many scenarios as we like. It's also possible to nest <kbd>describe</kbd> calls, in order to further group our scenarios.</p>
<p>Inside the callback function of the Jasmine <kbd>it</kbd> function, we can start writing our test. We can use BDD style comments to structure the code inside our test.</p>
<p>You don't necessarily need to run Jasmine in the browser, but if you do so, you'll get a nice summary report of all of the tests and their states:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/dabfdf5e-c33c-4165-8eb2-4f787146e654.png" style=""/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Jasmine provides a nice visual report of all of your test specifications, which also allows you to rerun individual tests and provides you with more options</div>
<p class="mce-root">Jasmine comes with three parts that are relevant to us:</p>
<ul>
<li><strong>Jasmine core</strong>: This contains the test definition APIs, the assertion library, and all of the other core parts of the testing framework</li>
<li><strong>Jasmine HTML</strong>: This is the HTML reporter, which will write all test results to the browser document, and will even provide options to rerun individual tests</li>
<li><strong>Jasmine boot</strong>: This is the file that bootstraps the Jasmine framework for the browser and performs any setup that is needed with the HTML reporter</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Karma and integration to Angular CLI</h1>
                </header>
            
            <article>
                
<p>Jasmine is the default test framework that ships with the Angular CLI tool. The CLI tool installs Jasmine, along with the popular test runner Karma, which allows you to run your tests in the browser of your choice.</p>
<p>By using Karma, we don't need to take care of installing and configuring Jasmine within our project. Karma takes care of that, and it also provides a lot of extras.</p>
<p>A project generated with the Angular CLI comes with two files relevant for running tests with Karma and Jasmine:</p>
<ul>
<li><kbd>/karma.conf.js</kbd>: This file contains the configuration for the Karma test runner. It's already created for running Angular tests within the browser. By default, it's configured to run tests within a real Chrome browser. However, you can change that to a headless version of Chrome, to a different browser, or even to PhantomJS, which is a really fast and lightweight headless browser.</li>
<li><kbd>/src/test.ts</kbd>: This file is the main entry file for running your tests. It's automatically generated for you when you create a new project using the CLI. This file contains all of the necessary preparations to run Angular tests within your browser using Karma. It also uses dynamic imports, in order to discover any test files (filenames ending with <kbd>.spec.ts</kbd>) within your project, and passes them to Karma for execution.</li>
</ul>
<p>The Angular CLI comes with a set of predefined commands, in order to execute the tests within your project. It supports running all tests once, in order to verify your current state. However, sometimes, it's very useful to keep your tests running when working on your application. This supports you in test-driven development approaches, where you'll want to have a constant feedback loop from your tests.</p>
<p>Let's start testing by running two different commands using the Angular CLI tool. Make sure that you're within your project folder, and execute the following command:</p>
<pre><strong>ng test --watch false</strong></pre>
<p>The preceding code will start a single test run within your project. Since we have not added any tests yet, you should see an output similar to this one:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/9c84a848-64d0-440e-82f9-4d71f0358a2c.png" style=""/></div>
<div class="packt_figure CDPAlignCenter packt_figref CDPAlign">A single execution (single run) using the Angular CLI, with no tests present</div>
<p>A single run of your tests is nice when you're about to pull a new release, or if you want to verify the quality of a certain state of your code. Within this chapter, we're going to add a few tests to our existing components, and it will be nice to see our tests evaluated when we're performing our changes. For this purpose, we're starting Karma using its file watch functionality. By running the following Angular CLI command, you can start Karma in watch mode. This will keep your Terminal busy with testing, similar to the <kbd>serve</kbd> command within the Angular CLI.</p>
<p>Let's start the Angular CLI in test watch mode by running the following command:</p>
<pre><strong>ng test</strong></pre>
<p>As you can see, we're fully omitting the <kbd>watch</kbd> command-line parameter this time. By default, the Angular CLI will run Karma in watch mode when you execute the <kbd>test</kbd> command.</p>
<div class="packt_tip">If you like to benefit from constant feedback when running your tests, you should always start two Terminal sessions, one executing the Angular CLI server (<kbd>ng serve</kbd>) and another one running Karma in watch mode (<kbd>ng test</kbd>).</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing our first test</h1>
                </header>
            
            <article>
                
<p>Now that we are all set with the testing setup, we can start writing our first test. In this section, we will create a first test for the efforts component that we created in <a href="43791ecf-9bd7-4439-ba76-8f34098d350a.xhtml"><span class="ChapterrefPACKT">Chapter 8</span></a>, <em>Time Will Tell</em>.</p>
<p>As Angular components are just classes, we can already test a lot of their functionality by instantiating the component class and testing its methods. Tests that can be performed like this should always be considered first. Tests that don't involve the rendering logic of your components can run without Angular compiling and bootstrap the component.</p>
<p>The efforts component uses a method to add a certain amount of hours to the effective time worked on a task. Within the template of the efforts component, we're providing three buttons, to add some common amounts of hours. Let's create our first test for the method, <kbd>addEffectiveHours</kbd>, in our efforts component. For this test, we'd like to start simple and create the component class instance manually. This allows us to test its basic functionality without the need to start the Angular template compiler, change detection and other </p>
<p>When creating a new component with the Angular CLI, a corresponding <kbd>spect.ts</kbd> file, containing some basic tests, will be created for you. However, we've always created new components using the flag <kbd>--spec false</kbd>, which prevents this step. Let's create our first spec file manually, by creating a new file on the path <kbd>src/app/efforts/efforts/efforts.component.spec.ts</kbd>.</p>
<p>Open the created file and add the following content:</p>
<pre>import {EffortsComponent} from './efforts.component';<br/>import {TimeEfforts} from '../../model';<br/><br/>describe('EffortsComponent', () =&gt; {<br/>  it('should add eight hours correctly', () =&gt; {<br/>    // Given<br/>    const hour = 3600000;<br/>    const component = new EffortsComponent();<br/>    component.efforts = {<br/>      estimated: 0,<br/>      effective: 0<br/>    };<br/>    component.outEffortsChange.subscribe((efforts: TimeEfforts) =&gt; {<br/>      // Then<br/>      expect(efforts.effective).toBe(hour * 8);<br/>    });<br/><br/>    // When<br/>    component.addEffectiveHours(8);<br/>  });<br/>});</pre>
<p>Karma loads our spec files, and it already loaded Jasmine prior to executing our test. We can therefore safely rely on the global <kbd>describe</kbd>, <kbd>it</kbd>, and <kbd>expect</kbd> functions that are exposed by Jasmine.</p>
<p>As you can see, we don't really need to bootstrap Angular in order to test some of our components' functionality. Simply by testing the component class instance, we can already execute some of our specifications.</p>
<p>To illustrate how we structure our test in a BDD way, we've added some comments, indicating the "given", "when" and "then" sections.</p>
<p>Within the given section, we create a new efforts component instance. We then set the efforts input property of our component to a new efforts object, containing an estimated and effective duration of zero. In the when section, we call the method <kbd>addEffectiveHours</kbd>, with a parameter of 8 hours.</p>
<p>Now, we'd like to test whether our method call is performing as we expected. Our efforts component is a pure UI component that does not store any of its state. Instead, it delegates any state changes using output properties. In the context of our test, the <kbd>outEffortsChange</kbd> output is triggered after a call to the method <kbd>addEffectiveHours</kbd>.</p>
<p>Since event emitters present on component output properties are just observables, we can simply subscribe to the output in order to validate our test. We use the Jasmine helper function, <span><kbd>expect</kbd>, in order to assert whether the updated effective efforts property is what we expect it to be after our test.</span></p>
<p>If you had the Angular CLI test command still running when writing this first test, you should now see a successful test execution on your Terminal output. Otherwise, just start the test runner again, using the command <kbd>ng test</kbd> on your Terminal:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f418e02a-dcdb-40a2-aa85-b1dd8348f413.png" style=""/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Terminal and Angular CLI ng test command, showing our first test running successfully</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spying on component output</h1>
                </header>
            
            <article>
                
<p>In testing, a common practice is to spy on function calls during the execution of tests, and then evaluate these calls, checking whether all functions were called correctly.</p>
<p>Jasmine provides us with some nice helpers, in order to use <kbd>spy</kbd> function calls. We can use the <kbd>spyOn</kbd> function of Jasmine to replace the original function with a <kbd>spy</kbd> function. The <kbd>spy</kbd> function will record any calls, and we can evaluate how many times they were called, and with what parameters.</p>
<p>Let's look at a simple example of how to use the <kbd>spyOn</kbd> function:</p>
<pre>class Calculator { 
  multiply(a, b) { 
    return a * b; 
  } 
   
  pythagorean(a, b) { 
    return Math.sqrt(this.multiply(a, a) + this.multiply(b, b)); 
  } 
} </pre>
<p>We will test a simple calculator class that has two methods. The <kbd>multiply</kbd> method simply multiplies two numbers and returns the result. The <kbd>pythagorean</kbd> method calculates the hypotenuse of a right-angled triangle with two sides, <kbd>a</kbd> and <kbd>b</kbd>.</p>
<p>You might remember the formula for the Pythagorean theorem from your early school days:</p>
<p><img class="fm-editor-equation" src="assets/d2d7af3c-2cd4-475b-8b49-1f3696cd3402.png" style="width:8.25em;height:1.67em;"/></p>
<p>We will use this formula to produce <kbd>c</kbd> from <kbd>a</kbd> and <kbd>b</kbd>, by getting the square root of the result of <kbd>a*a + b*b</kbd>. For the multiplication, we'll use our <kbd>multiply</kbd> method, instead of using arithmetic operators directly.</p>
<p>Now, we want to test our calculator <kbd>pythagorean</kbd> method, and, as it uses the <kbd>multiply</kbd> method to multiply <kbd>a</kbd> and <kbd>b</kbd>, we can spy on the method to verify our test result in depth:</p>
<pre>describe('Calculator pythagorean function', () =&gt; { 
  it('should call multiply function correctly', () =&gt; { 
    // Given 
    const calc = new Calculator(); 
    spyOn(calc, 'multiply').and.callThrough(); 
    // When 
    const result = calc.pythagorean(6, 8); 
    // Then 
    expect(result).toBe(10); 
    expect(calc.mul).toHaveBeenCalled(); 
    expect(calc.mul.calls.count()).toBe(2); 
    expect(calc.mul.calls.argsFor(0)).toEqual([6, 6]); 
    expect(calc.mul.calls.argsFor(1)).toEqual([8, 8]); 
  }); 
}); </pre>
<p>The <kbd>spyOn</kbd> function of Jasmine takes an object as the first parameter and the function name of the object on which we'd like to spy as a second parameter.</p>
<p>This will effectively replace the original <kbd>multiply</kbd> function in our class instance with a new <kbd>spy</kbd> function of Jasmine. By default, <kbd>spy</kbd> functions will only record function calls, and they won't delegate the call to the original function. We can use the <kbd>.and.callThrough()</kbd> function to specify that we'd like Jasmine to call the original function. This way, our spy function will act as a proxy, and will record any calls at the same time.</p>
<p>In the then section of our test, we can inspect the <kbd>spy</kbd> function. Using the <kbd>toHaveBeenCalled</kbd> matcher, we can check whether the spy function was called after all.</p>
<p>Using the <kbd>calls</kbd> property of the <kbd>spy</kbd> function, we can inspect in more detail and verify the call count, as well as the arguments that individual calls received.</p>
<p>We can apply the knowledge that we gained about Jasmine spies to our component tests. As we know that all output properties of components contain an event emitter, we can actually spy on them to check whether our component sends output.</p>
<p>Inside components, we call the <kbd>emit</kbd> method on event emitters, in order to send output to parent component bindings. As this is an asynchronous operation, and we'd also like to test our components without needing to involve parent components, we can simply spy on the <kbd>emit</kbd> method of our output properties.</p>
<div class="packt_tip">It's generally a good practice to avoid asynchronous operations in unit tests, if possible. By using Jasmine spies, we can mock certain function calls that would result in asynchronous operations.</div>
<p>Let's change our first test of the efforts component to use Jasmine spies, rather than relying on observable subscriptions. Open the file <kbd><span>src/app/efforts/efforts/efforts.component.spec.ts</span></kbd>, and perform the following changes:</p>
<pre>import {EffortsComponent} from './efforts.component';<br/><br/>describe('EffortsComponent', () =&gt; {<br/>  it('should add eight hours correctly', () =&gt; {<br/>    // Given<br/>    const hour = 3600000;<br/>    const component = new EffortsComponent();<br/>    component.efforts = {<br/>      estimated: 0,<br/>      effective: 0<br/>    };<br/><strong>    spyOn(component.outEffortsChange, 'emit');</strong><br/><br/>    // When<br/>    component.addEffectiveHours(8);<br/><br/>    // Then<br/><strong>    expect(component.outEffortsChange.emit).toHaveBeenCalledWith({</strong><br/><strong>      estimated: 0,</strong><br/><strong>      effective: hour * 8</strong><br/><strong>    });</strong><br/>  });<br/>});</pre>
<p>We've created a Jasmine spy that spies on the <kbd>outEffortsChange</kbd> output property. More precisely, we're spying on any calls to the <kbd>emit</kbd> method of the underlying event emitter.</p>
<p>Since we're no longer relying on a callback registered with the <kbd>subscribe</kbd> method on our event emitter output, we now have a much cleaner testing code. The testing code is perfectly structured into the given, when, and then sections of our BDD style test, and no subscription with a callback function needs to be used.</p>
<p>Using the <kbd>toHaveBeenCalledWith</kbd> assertion helper in Jasmine allows us to carefully evaluate the <kbd>spy</kbd> function and check whether the recorded calls match what we expected them to be.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Utilities to test components</h1>
                </header>
            
            <article>
                
<p>So far, we have tested our components with plain vanilla JavaScript. The fact that components are in regular classes makes this possible. However, this can only be done for very simple use cases. As soon as we want to test components for things that involve template compilation, user interaction on components, change detection, or dependency injection, we'll need to get a little help from Angular to perform our tests.</p>
<p>Angular comes with a whole bunch of testing tools that can help us out here. In fact, the platform-agnostic way that Angular is built allows us to exchange the regular view adapter with a debug view adapter. This enables us to render components in such a way that we can inspect them in greater detail.</p>
<p>The Angular CLI has already enabled this for us, and if you check the content of the file <kbd>src/test.ts</kbd>, you can see that there's a special preparation step that enables our testing Angular platform. The following core excerpt shows the relevant content of our default test entry point, which was generated by the Angular CLI tool when we created our project:</p>
<pre>…<br/>import { getTestBed } from '@angular/core/testing';<br/>import {<br/>  BrowserDynamicTestingModule,<br/>  platformBrowserDynamicTesting<br/>} from '@angular/platform-browser-dynamic/testing';<br/><br/>…<br/><br/>getTestBed().initTestEnvironment(<br/>  BrowserDynamicTestingModule,<br/>  platformBrowserDynamicTesting()<br/>);<br/>…</pre>
<p>Using the <kbd>initTestEnvironment</kbd> function of the <kbd>@angular/core/testing</kbd> module, we can actually initialize a test platform injector, which will then be used in the context of our Angular testing.</p>
<p>From the <kbd>@angular/platform-browser-dynamic/testing</kbd> module, we can import a special testing platform factory function, as well as the Angular browser testing module.</p>
<p>This code helps us to set up a testing environment that relies on a special platform for testing within a browser. Additional debug information will be present in the runtime when we're using this platform.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Injecting in tests</h1>
                </header>
            
            <article>
                
<p>Injecting Angular dependencies in tests is made easy by two helper functions. The <kbd>inject</kbd> and <kbd>async</kbd> functions are available through the <kbd>@angular/core/testing</kbd> package, and they help us inject dependencies into our tests.</p>
<p>Let's look at this simple example, where we inject the <kbd>document</kbd> element using the <kbd>inject</kbd> wrapper function. This test is irrelevant for our application, but it illustrates how we can make use of injection in our tests:</p>
<pre>import {DOCUMENT} from '@angular/common';<br/><strong>import {inject} from '@angular/core/testing';</strong><br/><br/>describe('Application initialized with test providers', () =&gt; {<br/>  it('should inject document', <strong>inject([DOCUMENT], (document) =&gt; {</strong><br/><strong>    expect(document).toBe(window.document);</strong><br/><strong>  })</strong>);<br/>});</pre>
<p>We can simply use <kbd>inject</kbd> to wrap our test function. The <kbd>inject</kbd> function accepts an array as the first parameter, which should include a list of injectable types. The second parameter is our actual test function, which will now receive the injected document.</p>
<p>The <kbd>async</kbd> function, on the other hand, helps us with a different concern. What if our tests actually involve asynchronous operations? Well, a standard asynchronous Jasmine test would look as follows:</p>
<pre>describe('Async test', () =&gt; { 
  it('should be completed by calling done', (done) =&gt; { 
    setTimeout(() =&gt; { 
      expect(true).toBe(true); 
      done(); 
    }, 2000); 
  }); 
}); </pre>
<p>Jasmine provides us with a nice way to specify asynchronous tests. We can simply use the first parameter of our test functions, which resolves to a callback function and is called <kbd>done</kbd>, by convention. By calling this callback function, we can tell Jasmine that our asynchronous operations are done, and we would like to finish the test.</p>
<p>Using callbacks to indicate whether our asynchronous test is finished is a valid option. However, this can make our test quite complicated, if many asynchronous operations are involved. It's sometimes even impossible to monitor all of the asynchronous operations that are happening under the hood, which also makes it impossible for us to determine the end of our test.</p>
<p>This is where the <kbd>async</kbd> helper function comes into play. Angular uses a library called Zone.js to monitor any asynchronous operations in the browser. Simply put, Zone.js hooks into any asynchronous operations and monitors when they are initiated, as well as when they are finished. With this information, Angular knows exactly how many pending asynchronous operations there are.</p>
<p>If we're using the <kbd>async</kbd> helper, we can tell Angular to automatically finish our test when all of the asynchronous operations in our test are done. The helper uses Zone.js to create a new zone, and also to determine whether all microtasks executed within this zone are finished.</p>
<p>Let's look at how we can combine injection with an asynchronous operation in our test:</p>
<pre>import {describe, expect, it, inject, async} from '@angular/core/testing'; 
import {DOCUMENT} from '@angular/platform-browser'; 
 
describe('Application initialized with test providers', () =&gt; {<br/>  it('should inject document', async(inject([DOCUMENT], (document) =&gt; {<br/>    setTimeout(() =&gt; {<br/>      expect(document).toBe(window.document);<br/>    }, 2000);<br/>  })));<br/>});</pre>
<p>By combining <kbd>inject</kbd> with <kbd>async</kbd> (wrapping), we can now test asynchronous operations in our test, without any hassle. The <kbd>async</kbd> helper will make our test wait until all asynchronous operations have completed. We don't need to rely on a callback, and we have the guarantee that even internal asynchronous operations will complete before our test finishes.</p>
<div class="packt_tip"><span>Zone.js is designed to work with all asynchronous operations in the browser. It patches all core DOM APIs, and makes sure that every operation goes through a zone. Angular also relies on Zone.js to initiate change detection. It waits for zones (any asynchronous operations within the browser) to terminate, in order to execute change detection. This is pretty smart, since the only possible moment for your application state to change is right after asynchronous operations are terminated.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using TestBed for running Angular tests</h1>
                </header>
            
            <article>
                
<p>Angular comes with another very important testing utility. So far, we have only tested the component class of our components. However, as soon as we need to test components and their behaviors in our application, a few more things will be involved:</p>
<ul>
<li><strong>Testing the view of components</strong>: It's sometimes required that we test the rendered view of components. With all of the bindings in our view, dynamic instantiation using template directives and content projection, it can be hard to write deterministic tests.</li>
<li><strong>Testing change detection</strong>: As soon as we update our model in our component class, we will want to test the updates that are performed via change detection. This involves the whole change detection behavior of our components.</li>
<li><strong>User interaction</strong>: Our component templates probably contain a set of event bindings, which trigger some behaviors in user interaction. We'll need a way to test the state after user interactions.</li>
<li><strong>Overriding and mocking</strong>: In a testing scenario, it's sometimes required to mock certain areas in our components, in order to create a proper isolation for our test. In unit testing, we should only be concerned with the specific behavior that we want to test.</li>
</ul>
<p>The <kbd>TestBed</kbd> class, which is available through the <kbd>@angular/core/testing</kbd> package, helps us with the previously listed concerns. It's our main tool for testing components.</p>
<p>Let's look at a very simple example of how we can use the <kbd>TestBed</kbd> class to test the view rendering of a simple dummy component:</p>
<pre>import {Component} from '@angular/core';<br/>import {TestBed, async} from '@angular/core/testing';<br/><br/>@Component({<br/>  selector: 'mac-dummy',<br/>  template: 'dummy'<br/>})<br/>class DummyComponent {}<br/><br/>describe('DummyComponent', () =&gt; {<br/>  beforeEach(async(() =&gt; {<br/>    TestBed.configureTestingModule({<br/>      declarations: [DummyComponent],<br/>    }).compileComponents();<br/>  }));<br/><br/>  it('should render its view correctly', async(() =&gt; {<br/>    const fixture = TestBed.createComponent(DummyComponent);<br/>    expect(fixture.nativeElement.textContent).toBe('dummy');<br/>  }));<br/>}); </pre>
<p>The <kbd>beforeEach</kbd> function is a Jasmine helper that allows us to execute something before each and every test within a given test suite. Within the <kbd>beforeEach</kbd> callback, we're using the <kbd>TestBed</kbd> class imported from <kbd>@angular/core/testing</kbd>, in order to prepare our testing environment.</p>
<p>The <kbd>configureTestingModule</kbd> method on the <kbd>Testbed</kbd> class allows us to configure a dynamic Angular module that defines the whole context for our test. The configuration object that we're passing to the method is exactly the same as the one that we pass to the <kbd>@NgModule</kbd> decorator factory, when defining Angular modules. It supports <kbd>import</kbd>, <kbd>providers</kbd>, <kbd>declarations</kbd>, and all other properties of Angular modules. This allows us to create a very specific and isolated testing environment, where we can test only the things we really need to.</p>
<p>Also, note that we're using the Angular <kbd>async</kbd> helper to wrap our <kbd>beforeEach</kbd> callback function. This is necessary, since the <kbd>compileComponents</kbd> method call is an asynchronous operation that compiles all components present within our dynamic testing module. This will ensure that when we enter our test methods, the compilation performed within the <kbd>beforeEach</kbd> callback is finished, and we can start our testing.</p>
<div class="packt_infobox">When testing components, you need to make sure that you're including all of the necessary dependencies within the dynamic module created by the <kbd>configureTestingModule</kbd> call. This includes any sub-components present within the component, under tests, pipes, services, and any other dependencies of your component.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Component fixture</h1>
                </header>
            
            <article>
                
<p>In our test, we use the <kbd>createComponent</kbd> method of the <kbd>Testbed</kbd> class to create a new component instance of our dummy component. As a result of that method call, we'll receive a component fixture object that will help us to further perform testing on our component.</p>
<p>The component fixture is a wrapper around our component being tested, which allows us to further inspect and manipulate our test case. We can now use the <kbd>nativeElement</kbd> property of the fixture to access the root DOM element of the created component, and to assert on the text content of that element, to verify whether the component has rendered correctly.</p>
<p>Let's look at the <kbd>ComponentFixture</kbd> type, and the available properties and methods, in more detail:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p>Member</p>
</td>
<td>
<p>Description</p>
</td>
</tr>
<tr>
<td>
<p><kbd>detectChanges()</kbd></p>
</td>
<td>
<p>This executes change detection on the root component that was created in the context of the fixture. The template bindings will not automatically be evaluated after creating a component using the <kbd>Testbed</kbd> class. It's our own responsibility to trigger change detection. Even after we change the state of our components, we need to trigger change detection again. This manual change detection may sound cumbersome, but it's important to have full control of any operation performed during a test. We always want a test to be fully deterministic.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>destroy()</kbd></p>
</td>
<td>
<p>This method destroys the underlying component and performs any cleanup that is required. This can be used to test the <kbd>OnDestroy</kbd> component's life cycle.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>componentInstance</kbd></p>
</td>
<td>
<p>This property points to the component class instance, and it is our main interaction point if we want to interact with the component.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>nativeElement</kbd></p>
</td>
<td>
<p>This is a reference to the native DOM element at the root of the created component. This property can be used to directly inspect the rendered DOM of our component.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>elementRef</kbd></p>
</td>
<td>
<p>This is the <kbd>ElementRef</kbd> wrapper around the root element of the created component.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>debugElement</kbd></p>
</td>
<td>
<p>This property points to an instance of <kbd>DebugElement</kbd> that was created in the component view rendering pipeline when using the testing browser platform. The debug element provides us with some nice utilities to inspect the rendered element tree and test user interaction. We'll take a closer look at this later, in another section.</p>
</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mocking child components</h1>
                </header>
            
            <article>
                
<p>We've now looked at a very simple dummy component, and how to test it using the Angular <kbd>TestBed</kbd>, in conjunction with the <kbd>inject</kbd> and <kbd>async</kbd> helper functions.</p>
<p>This is great, but it doesn't really reflect the complexity that we face when we need to test real components. Real components have a lot more dependencies than our dummy component. We rely on child directives, and probably injected services, to obtain data.</p>
<p>Of course, the Angular <kbd>TestBed</kbd> also provides us with the tools that we need to test more complex components, while keeping the necessary isolation in a unit test.</p>
<p>First, let's look at an example, where we'd like to test a parent component that uses a child component to render a list of numbers. In this test, we'd only like to test the parent component, and we're not interested in how the child component renders the list. We want to remove the behavior of the child component from our test by providing a mock component for the child component during the test, allowing us to easily verify that the data is received by the child component:</p>
<pre>@Component({<br/>  selector: 'mac-child',<br/>  template: '&lt;ul&gt;&lt;li *ngFor="let n of numbers"&gt;Item: {{ n }}&lt;/li&gt;&lt;/ul&gt;'<br/>})<br/>class ChildComponent {<br/>  @Input() numbers;<br/>}<br/><br/>@Component({<br/>  selector: 'mac-parent',<br/>  template: '&lt;mac-child [numbers]="numbers"&gt;&lt;/mac-child&gt;'<br/>})<br/>class ParentComponent {<br/>  numbers = [1, 2, 3];<br/>}</pre>
<p>This is our starting point. We have two components, and we'll only be interested in testing the parent component. However, the child component is required by the parent component, and it implies a very specific way to render the numbers that are passed by the parent. We would only like to test whether our numbers were passed successfully to the child component. We don't want to involve the rendering logic of the child component in our test. This is very important, because changing only the child component could break our parent component test, which is what we want to avoid.</p>
<p>Now, we want to create a mock of our child component, in the context of our test:</p>
<pre>@Component({<br/>  selector: 'mac-child',<br/>  template: '{{ numbers.toString() }}'<br/>})<br/>class MockChildComponent {<br/>  @Input() numbers;<br/>}</pre>
<p>In our mock child component, it's important that we use the same selector property as the real component. Otherwise, the mocking will not work. In the template, we use a very simple output of the numbers input, which enables an easy inspection. The <kbd>toString</kbd> method on an array will just render all elements, separated by commas.</p>
<p>It's also important that we provide the same input properties as the original component. Otherwise, we won't imitate the real component correctly.</p>
<p>Now, we can go ahead and prepare for our test. By simply adding our mock child component to the declarations of our dynamic test module, we can make sure that our parent component uses our mock component, instead of the real child component:</p>
<pre>describe('ParentComponent', () =&gt; {<br/>  beforeEach(async(() =&gt; {<br/>    TestBed.configureTestingModule({<br/>      declarations: [<br/>        ParentComponent,<br/>        MockChildComponent<br/>      ],<br/>    }).compileComponents();<br/>  }));<br/><br/>  it('should pass numbers to child correctly', async(() =&gt; {<br/>    const fixture = TestBed.createComponent(ParentComponent);<br/>    fixture.detectChanges();<br/>    expect(fixture.nativeElement.textContent).toBe('1,2,3');<br/>  }));<br/>}); </pre>
<p>As a result, we decouple the parent component from the child component, in the context of our test. We need this level of separation in order to create a proper isolation of our unit test. As our mock child component simply renders the string representation of the passed array, we can easily test the text content of our fixture.</p>
<div class="packt_tip"><span>The definition of a unit test is to test a single unit and isolate the unit from any dependencies. If we want to stick to this paradigm, we need to create a mock for every dependent component. This can easily get us into a situation where we need to maintain more complexity, for the sake of our tests. The key lies in finding the right balance. You should mock dependencies that have a great impact on the subject, and ignore dependencies that have a </span>low<span> impact on the functionality that you'd like to test.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mocking services</h1>
                </header>
            
            <article>
                
<p>Let's look at a different use case, where we have a component that injects a service in order to obtain data. As we only want to test our component, and not the service it relies on, we somehow need to sneak in a mock service instead of the real service. Since we can define our dynamic test module for our needs, we can simply use the <kbd>providers</kbd> property on our module definition to introduce mock services.</p>
<p>First, we should declare our base component and a service that it relies on. In this example, the numbers component injects a numbers service, where it obtains an array with numbers:</p>
<pre>@Injectable()<br/>class NumbersService {<br/>  numbers = [1, 2, 3, 4, 5, 6];<br/>}<br/><br/>@Component({<br/>  selector: 'mac-numbers',<br/>  template: '{{ numbers.toString() }}'<br/>})<br/>class NumbersComponent {<br/>  numbers: number[];<br/><br/>  constructor(numbersService: NumbersService) {<br/>    this.numbers = numbersService.numbers;<br/>  }<br/>}</pre>
<p>Now, we need to create a mock service that provides the data required in our test and isolates our component from the original service:</p>
<pre>@Injectable()<br/>class MockNumbersService {<br/>  numbers = [1, 2, 3];<br/>}</pre>
<p>In this simplified example, we just provide a different set of numbers. However, in a real mocking case, we could exclude a lot of steps that are unnecessary and could potentially create side effects. Using a mock service also ensures that our test, which is focused on the numbers component, will not break because of a change in the real numbers service.</p>
<p>Now, let's look at the test case and see how we can use <kbd>TestBed</kbd> to provide our mock service, instead of the real one:</p>
<pre>describe('NumbersComponent', () =&gt; {<br/>  beforeEach(async(() =&gt; {<br/>    TestBed.configureTestingModule({<br/>      declarations: [NumbersComponent],<br/>      providers: [{<br/>        provide: NumbersService,<br/>        useClass: MockNumbersService<br/>      }]<br/>    }).compileComponents();<br/>  }));<br/><br/>  it('should render numbers correctly', async(() =&gt; {<br/>    const fixture = TestBed.createComponent(NumbersComponent);<br/>    fixture.detectChanges();<br/>    expect(fixture.nativeElement.textContent).toBe('1,2,3');<br/>  }));<br/>});</pre>
<p>Using the <kbd>providers</kbd> property in the dynamic test module definition, we can provide dependencies to the component under test. This allows us to substitute dependencies that are used in the component. We can simply create a provider that provides our substitute mock numbers service when the numbers service is requested within the dependency injection.</p>
<p>Sometimes, we don't have full control of our dependencies; for example, when we're obtaining a predefined set of providers by an imported module. The <kbd>TestBed</kbd> helps us in such situations by providing additional override methods. Let's look at the preceding example again; this time, we're using an override mechanism to sneak in our mock service:</p>
<pre>describe('NumbersComponent', () =&gt; {<br/>  beforeEach(async(() =&gt; {<br/><strong>    TestBed.configureTestingModule({</strong><br/><strong>      declarations: [NumbersComponent],</strong><br/><strong>      providers: [NumbersService]</strong><br/><strong>    });</strong><br/><strong>    TestBed.overrideProvider(NumbersService, {useValue: new MockNumbersService()});</strong><br/><strong>    TestBed.compileComponents();</strong><br/>  }));<br/><br/>  it('should render numbers correctly', async(() =&gt; {<br/>    const fixture = TestBed.createComponent(NumbersComponent);<br/>    fixture.detectChanges();<br/>    expect(fixture.nativeElement.textContent).toBe('1,2,3');<br/>  }));<br/>});</pre>
<p>Using the <kbd>overrideProvider</kbd> method allows us to override the previously specified real service with our mock service. This is an important tool when you're testing large applications that rely on imported Angular modules, which won't be under your full control.</p>
<p>The <kbd>Testbed</kbd> class of Angular allows us to perform tests in a very simple, isolated, and flexible fashion. It plays a major role when writing unit tests for components. If you'd like to read more about the available methods in the <kbd>Testbed</kbd> class, you can visit the official documentation website at <a href="https://angular.io/api/core/testing/TestBed">https://angular.io/api/core/testing/TestBed</a>.</p>
<p>Now, it's time to use our new knowledge about the <kbd>Testbed</kbd> utility class and start to test our application components in action!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing components in action</h1>
                </header>
            
            <article>
                
<p>In the previous topic, we learned about the <kbd>Testbed</kbd> utility class, and how to use it to test components in an isolated testing environment. We learned about the <kbd>inject</kbd> and <kbd>async</kbd> helpers, as well as how to mock components and services.</p>
<p>Now, let's use this knowledge to work on our tests for the efforts component. If you take a look at the template of our efforts component, you'll remember that we rely on two child components:</p>
<ul>
<li><strong>Duration</strong>: The two duration components within the template are used to enter both the duration values for estimated as well as effective efforts spent on tasks. It's a good idea to mock out that component when you want to perform tests on the efforts component. The duration component itself relies on the rather complex editor component.</li>
<li><strong>Efforts Timeline</strong>: As it is a purely graphical component to represent our task efforts, we don't really want it to participate in our test of the efforts component. However, since this component does not really interfere with our efforts behavior, we don't necessarily need to mock it. Let's use the real component in this specific instance.</li>
</ul>
<p>Alright; let's continue writing tests for our efforts component. So far, we've only tested the component class methods of our efforts component. We would now like to continue by mocking the duration component and using the Angular <kbd>TestBed</kbd> to create a new component instance.</p>
<p>If you don't have it running already, it would be a good time to start the test framework using the Angular CLI tool. Use the command <kbd>ng test</kbd> in your command line while inside of the project folder.</p>
<p>Open the test file, located on the path <span><kbd>src/app/efforts/efforts/efforts.component.spec.ts</kbd>, and perform the following changes:</span></p>
<pre><strong>import {Component, EventEmitter, Input, Output} from '@angular/core';</strong><br/><strong>import {TestBed, async, ComponentFixture} from '@angular/core/testing';</strong><br/>import {EffortsComponent} from './efforts.component';<br/><strong>import {EffortsTimelineComponent} from '../efforts-timeline/efforts-timeline.component';</strong><br/><br/><strong>@Component({</strong><br/><strong>  selector: 'mac-duration',</strong><br/><strong>  template: '{{ duration }}'</strong><br/><strong>})</strong><br/><strong>class MockDurationComponent {</strong><br/><strong>  @Input() duration: number;</strong><br/><strong>  @Output() outDurationChange = new EventEmitter&lt;number&gt;();</strong><br/><strong>}</strong><br/><br/>describe('EffortsComponent', () =&gt; {<br/>  <strong>let fixture: ComponentFixture&lt;EffortsComponent&gt;;</strong><br/><br/><strong>  beforeEach(async(() =&gt; {</strong><br/><strong>    TestBed.configureTestingModule({</strong><br/><strong>      declarations: [</strong><br/><strong>        EffortsComponent,</strong><br/><strong>        MockDurationComponent,</strong><br/><strong>        EffortsTimelineComponent</strong><br/><strong>      ],</strong><br/><strong>    }).compileComponents();</strong><br/><strong>    fixture = TestBed.createComponent(EffortsComponent);</strong><br/><strong>  }));</strong><br/><br/>  …<br/>});</pre>
<p>Our newly introduced mock duration component might look a bit tenuous, but this is actually all that we need for our current tests of the efforts component. The duration component should just accept a <kbd>duration</kbd> input and expose an <kbd>ourDurationChange</kbd> output. This is the interface that is expected within the template of our efforts component. Since we don't want to rely on any of the duration component internals, including the use of the editor component, the template of our mock duration component simply renders the duration input. This way, we can easily verify whether the correct duration is rendered within our mock component.</p>
<p>Now, let's create our first test, using the component instance and fixture created with the <kbd>Testbed</kbd>. Apply the following changes to the effort test file:</p>
<pre>…<br/><br/>describe('EffortsComponent', () =&gt; {<br/>  …<br/><br/>  it('should render initial efforts correctly', () =&gt; {<br/>    // Given<br/>    const component = fixture.componentInstance;<br/>    component.efforts = {<br/>      estimated: 1,<br/>      effective: 2<br/>    };<br/><br/>    // When<br/>    fixture.detectChanges();<br/><br/>    // Then<br/>    expect(fixture.nativeElement.textContent).toBe('Estimated:1Effective:2+1h+4h+1d');<br/>  });<br/><br/>  …<br/><br/>});</pre>
<p>In our tests, we'd like to test whether the effort component initializes the duration child components (respectively, our mock duration component) with the right content.</p>
<p>Using the component fixture that is provided by the <kbd>Testbed</kbd> utility class, we can start to interact with the created component. Using the <kbd>componentInstance</kbd> member of the component fixture, we can set the required input properties of our efforts component.</p>
<p>As we're responsible for handling change detection in our tests manually, we use the <kbd>detectChanges</kbd> method on our fixture to update the component view. This will initiate the change detection life cycle on our component and perform the necessary view updates.</p>
<p>After the view updates of both duration components, we can run our assertions to validate the updated DOM by getting the text content of the <kbd>nativeElement</kbd> property on our fixture.</p>
<p>Using the text content property of our whole component fixture might be good, in some circumstances. However, sometimes, this does not provide the necessary granularity for a good assertion. In some scenarios, when we have more DOM elements involved, it won't be sufficient to directly assert on the root component's <kbd>textContent</kbd> property. It would probably include a lot of noise, which we're not interested in for our assertion. We should always try to narrow our assertion to the fewest details possible.</p>
<p>Within our newly created test, we need to assert with the string <kbd>Estimated:1Effective:2+1h+4h+1d</kbd>, in order to validate the correct rendering of our components. However, this also includes the labels of our add buttons, which is not exactly what we want to test here. Remember, we always want to narrow our test down to exactly one single unit and avoid any dependencies on things outside of our specific test case.</p>
<p>Let's try to enhance our test and assert on more specific parts of our component view. As we have access to the native DOM element on our fixture, we can simply use the DOM API to select child elements, in order to narrow our assertion:</p>
<pre>expect(fixture.nativeElement.querySelector('mac-duration').textContent.trim()).toBe('1'); </pre>
<p>This would successfully select the DOM element of our first mock duration component, and we can only check the text content inside the duration component.</p>
<p>Although this would be a feasible approach, Angular provides us with a much better approach to solve this problem.</p>
<p>Provided by the component fixture, we have access to the debug element tree that is created by the test browser platform, in the context of our test. Debug elements allow us to do an advanced inspection of the element tree that was created by Angular while rendering our components. It also contains an advanced querying API, which allows us to search for certain elements in the component tree.</p>
<p>Let's rewrite our test to use the advanced capabilities provided by the debug element, and assert on both the estimated and effective duration components views individually:</p>
<pre>…<br/><strong>import {By} from '@angular/platform-browser';</strong><br/>…<br/><br/>describe('EffortsComponent', () =&gt; {<br/>  …<br/><br/>  it('should render initial efforts correctly', () =&gt; {<br/>    // Given<br/>    const component = fixture.componentInstance;<br/>    component.efforts = {<br/>      estimated: 1,<br/>      effective: 2<br/>    };<br/>    <strong>const [estimatedDurationElement, effectiveDurationElement] = fixture.debugElement</strong><br/><strong>      .queryAll(By.directive(MockDurationComponent));</strong><br/><br/>    // When<br/>    fixture.detectChanges();<br/><br/>    // Then<br/><strong>    expect(estimatedDurationElement.nativeElement.textContent).toBe('1');</strong><br/><strong>    expect(effectiveDurationElement.nativeElement.textContent).toBe('2');</strong><br/>  });<br/><br/>  …<br/><br/>});</pre>
<p>The <kbd>query</kbd> and <kbd>queryAll</kbd> methods that are available on every debug element object allow us to query the Angular view tree like we would query a DOM tree, using <kbd>querySelector</kbd> and <kbd>querySelectorAll</kbd>. The difference here is that we can<br/>
use a predicate helper to query for matching elements. Using the <kbd>By</kbd> helper class, we can create these predicates, which will then be used to query the debug element tree.</p>
<p>There are currently three different predicates available, using the <kbd>By</kbd> helper:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p>Member</p>
</td>
<td>
<p>Description</p>
</td>
</tr>
<tr>
<td>
<p><kbd>By.all()</kbd></p>
</td>
<td>
<p>This is the predicate that will result in querying for all of the child <kbd>DebugElement</kbd> objects of the current <kbd>DebugElement</kbd> object.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>By.css(selector)</kbd></p>
</td>
<td>
<p>This is the predicate that will result in querying for <kbd>DebugElement</kbd> using the specified CSS selector.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>By.directive(type)</kbd></p>
</td>
<td>
<p>This is the predicate that will result in querying for the <kbd>DebugElement</kbd> that contains the specified directive.</p>
</td>
</tr>
</tbody>
</table>
<div class="packt_figure"/>
<p> </p>
<p>Going back to our test, we can now use the query method on the fixture debug element, in order to query for our duration components. As we've exchanged the real duration component with our mock duration component, we need to query for the latter. We use a predicate, <kbd>By.directive(MockDurationComponent)</kbd>, which will successfully query for the debug element object that represents the host elements of our two mock duration components.</p>
<p>The <kbd>query</kbd> method of the debug element object will always return a new debug element object of the first found element, if there was a match. It will return <kbd>null</kbd> if the queried element was not found.</p>
<p>The <kbd>queryAll</kbd> method of a debug element will return an array of many debug elements, which will contain all elements that match the predicate. If there are no matching elements, this method will return an empty array.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing component interaction</h1>
                </header>
            
            <article>
                
<p>Although UI interaction testing is probably part of end-to-end testing, we'll look at how to test basic user interaction with your components. In this topic, we'll test the efforts component when the user clicks on one of the buttons to add effective effort hours.</p>
<p>Let's add a new test to our existing efforts component test file, located on the path <kbd><span>src/app/efforts/efforts/efforts.component.spec.ts</span></kbd>:</p>
<pre>  it('should add one day of effective efforts on button click', () =&gt; {<br/>    // Given<br/>    const day = 3600000 * 8;<br/>    const component = fixture.componentInstance;<br/>    component.efforts = {<br/>      estimated: 0,<br/>      effective: 0<br/>    };<br/>    const addDayButton = fixture.debugElement<br/>      .queryAll(By.css('button'))[2];<br/>    spyOn(component.outEffortsChange, 'emit');<br/><br/>    // When<br/>    addDayButton.triggerEventHandler('click', null);<br/><br/>    // Then<br/>    expect(component.outEffortsChange.emit).toHaveBeenCalledWith({<br/>      estimated: 0,<br/>      effective: day<br/>    });<br/>  });</pre>
<p>We want to set a Jasmine spy up on the <kbd>outEffortsChange.emit</kbd> function for our test. This way, we can later check whether our efforts component successfully emits the event when we click on the button to add a day of effective efforts.</p>
<p>In the given section, we're preparing everything for our test. We initialize the <kbd>efforts</kbd> input of our component with a new object. We also query for the debug element of the button within the efforts component view that adds one day to the effective effort. We use the <kbd>queryAll</kbd> method to get a list of all three buttons, and select the third by accessing the array element with the index <kbd>2</kbd>. The <kbd>css</kbd> predicate factory allows us to pass a CSS selector to query for debug elements.</p>
<p>In the when section of our test, we can simulate a <kbd>click</kbd> event on the <kbd>addDayButton</kbd> debug element by using the method <kbd>tiggerEventHandler</kbd>. Using this method, you can trigger an event that you'd like to be emitted on the underlying element. Angular event listeners that listen for that event will be triggered synchronously.</p>
<p>Within the then section of our BDD style test, we can simply evaluate the Jasmine spy that we've created on the <kbd>outEffortsChange</kbd> output property of our component.</p>
<p>Testing user interaction on components is made very easy by using the debug element. We can also decouple our tests from the underlying DOM event architecture by using the <kbd>triggerEventHandler</kbd> helper method.</p>
<div class="packt_tip"><span>The </span><kbd>triggerEventHandler</kbd><span> method operates on the virtual element tree of Angular, rather than the actual DOM tree. Due to this, we can also use this method to trigger event handlers that are attached to component output properties.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this last chapter of the book, we learned how to write concise unit tests for our components. We followed a BDD style approach of writing tests, and we also covered the basics of the JavaScript testing framework, Jasmine.</p>
<p>We learned about the debugging tools that are available in Angular, and how to set up an environment for testing. Using the Angular <kbd>Testbed</kbd> utility class, we were able to perform tests in a very flexible but precise way. We also learned about the debug view tree and the component fixture. These allowed us to perform clever inspections and apply practical queries to the rendered views, in order to assert expected results.</p>
<p>We used the <kbd>inject</kbd> and <kbd>async</kbd> helpers to inject dependencies, and to run asynchronous tests at the same time. We built mock components, in order to isolate our tests from the rest of our application.</p>


            </article>

            
        </section>
    </body></html>