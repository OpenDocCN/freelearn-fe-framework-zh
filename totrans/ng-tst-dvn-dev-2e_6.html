<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;The First Step"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. The First Step</h1></div></div></div><p>The first step is always the most difficult. This chapter provides an initial introductory walk-through of how to use TDD to build an Angular application with a component, class, and model. We will be able to begin the TDD journey and see the fundamentals in action. Up to this point, this book has focused on a foundation of TDD and the tools required for it. Now, we will switch gear and dive into TDD with Angular.</p><p>This chapter will be the first step of TDD. We have already seen how to install Karma and Protractor, in addition to small examples and a walk-through on how to apply them. In this chapter, we will focus on:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating a simple comments application </li><li class="listitem" style="list-style-type: disc">Integrating Karma and Protractor with the application</li><li class="listitem" style="list-style-type: disc">Covering the components of testing and its associated classes</li></ul></div><div class="section" title="Preparing the application's specifications"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec43"/>Preparing the application's specifications</h1></div></div></div><p>Create an application to enter comments. The specifications of the application are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If I am posting a new comment, when I click on the <span class="strong"><strong>Submit</strong></span> button, the comment should be added to the comment list</li><li class="listitem" style="list-style-type: disc">For a comment, when I click on the <span class="strong"><strong>Like</strong></span> button, the number of likes for the comment should increase</li></ul></div><p>Now that we have the specifications of the application, we can create our development to-do list. It won't be easy to create an entire to-do list of the whole application. Based on the user specifications, we have an idea of what needs to be developed. Here is a rough sketch of the UI:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_001-1.jpg" alt="Preparing the application's specifications"/></div><p>
</p><p>Hold back from jumping into the implementation and thinking about how we will use a component class, <code class="literal">*ngFor</code>, and so on. Resist, resist, resist! Although we can think of how this will be developed in the future, it is never clear until we delve into the code, and that is where we will start getting into trouble. TDD and its principles are here to help us get our mind and focus in the right place.</p></div></div>
<div class="section" title="Setting up the Angular project"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec44"/>Setting up the Angular project</h1></div></div></div><p>In previous chapters, we discussed in detail how a project should be set up, looked at the different components involved, and walked through the entire process of testing. We will skip these details and provide a list in the following section for the initial actions to get the project set up and ready with a test configuration for unit and end-to-end testing.</p><div class="section" title="Loading an existing project"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec78"/>Loading an existing project</h2></div></div></div><p>We will get a simple Angular project from the Angular team's examples and modify it for our implementation.</p><p>We will clone the <code class="literal">quickstart</code> project from the Angular GitHub repo and start with that one. We should have Git installed globally besides <code class="literal">node</code>/<code class="literal">npm</code>.</p><pre class="programlisting">
<span class="strong"><strong>$ git clone https://github.com/angular/quickstart.git &#13;
    angular-project</strong></span>
</pre><p>This will copy the project locally as <code class="literal">angular-project</code>; this project may contain some extra files (they may be updated continuously), but we will try to keep our project folder structure looking like this:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_002.jpg" alt="Loading an existing project"/></div><p>
</p><p>We will keep it simple initially, and then, we will add our required files step by step. This will make us more confident.</p><p>Let's proceed with it and run the following:</p><pre class="programlisting">
<span class="strong"><strong>$ cd angular-project</strong></span>
<span class="strong"><strong>$ npm install</strong></span>
</pre><p>The <code class="literal">npm install</code> command will install the required modules for project dependencies that are defined in the <code class="literal">package.json</code> file that is in the project's root.</p></div><div class="section" title="Setting up the directory"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec79"/>Setting up the directory</h2></div></div></div><p>In previous examples, we put the component, unit test spec, and e2e test spec in the same folder just to keep it simpler. For a larger project, it's difficult to manage all in the same folder.</p><p>To make that manageable, we will put the test spec in a separate folder. Here, our sample <code class="literal">quickstart</code> project has already put test specs in the default folder, but we will have a new structure and will put our test files in the new structure.</p><p>Let's start setting up the project directory:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Navigate to the project's root folder:<pre class="programlisting">        <span class="strong"><strong>cd angular-project</strong></span>
</pre></li><li class="listitem">Initialize the test (<code class="literal">spec</code>) directory:<pre class="programlisting">        <span class="strong"><strong>mkdir spec</strong></span>
</pre></li><li class="listitem">Initialize the <code class="literal">unit</code> test directory:<pre class="programlisting">        <span class="strong"><strong>mkdir spec/unit</strong></span>
</pre></li><li class="listitem">Initialize the end-to-end (<code class="literal">e2e</code>) test directory:<pre class="programlisting">        <span class="strong"><strong>mkdir spec/e2e</strong></span>
</pre></li></ol></div><p>Once the initialization is complete, our folder structure should look as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_003.jpg" alt="Setting up the directory"/></div><p>
</p></div><div class="section" title="Setting up Karma"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec80"/>Setting up Karma</h2></div></div></div><p>The details for Karma can be found in <a class="link" href="ch03.html" title="Chapter 3. The Karma Way">Chapter 3</a>, <span class="emphasis"><em>The Karma Way</em></span>. Here, we will mostly take a look at the Karma configuration file.</p><p>In this <code class="literal">quickstart</code> project, we have already installed and configured Karma, and we have the <code class="literal">karma.conf.js</code> file in the project directory.</p><p>To confirm that we have Karma in the system, let's install it globally using the following command:</p><pre class="programlisting">
<span class="strong"><strong>npm install -g karma</strong></span>
</pre><p>As mentioned before, we already have Karma configured in this project as part of a <code class="literal">quickstart</code> project, and we have the <code class="literal">karma.conf.js</code> file in the project directory.</p><p>Now we will look at some basic configuration options that everyone should know. In this configuration file, there are some advanced options, such as test reporting and bug reporting. We will skip those as they are not very important to know at this initial stage.</p><p>Let's know more about a few of the configurations that we will need to proceed further.</p><p>The <code class="literal">basePath</code> should be updated when we have a custom path for the project in the server. For now, it's <code class="literal">''</code>, as this project is running in the root path. The next option is the <code class="literal">frameworks</code>; by default, we are using <code class="literal">jasmine</code> here, but we can change the framework name if we want to use others, such as <code class="literal">mocha</code>. One point to remember is that if we plan for a different framework, we will have to add the relevant plugin.</p><pre class="programlisting">    basePath: '', &#13;
        frameworks: ['jasmine'], &#13;
</pre><p>Plugins are required, as Karma will use these <code class="literal">npm</code> modules inside to perform the actions; for example, if we plan to use PhantomJS as the browser, we will need to add <code class="literal">'karma-phantomjs-launcher'</code> to the list:</p><pre class="programlisting">    plugins: [ &#13;
            'karma-jasmine', &#13;
            'karma-chrome-launcher' &#13;
    ] &#13;
</pre><p>The next and most important option is <code class="literal">files[]</code>; with this, Karma will include all the required files for testing. It loads a file based on dependency. We will have all the required files in the <code class="literal">files[]</code> array.</p><p>First, we will add <code class="literal">System.js</code> since we use <code class="literal">systemjs</code> as the module loader in the app. Then, add <code class="literal">polyfills</code> for shim support on all browsers, <code class="literal">zone.js</code> for Async support in the app, RxJS as the reactive library, Angular library files, shim for Karma test, the components file, and, finally, the test specs. There might be some other files in the list for debug and reporting; we are skipping their explanations.</p><p>This is what our <code class="literal">files[]</code> array will look like:</p><pre class="programlisting">    files: [&#13;
          // System.js for module loading&#13;
          'node_modules/systemjs/dist/system.src.js',&#13;
&#13;
          // Polyfills&#13;
          'node_modules/core-js/client/shim.js',&#13;
          'node_modules/reflect-metadata/Reflect.js',&#13;
&#13;
          // zone.js&#13;
          'node_modules/zone.js/dist/zone.js',&#13;
          'node_modules/zone.js/dist/long-stack-trace-zone.js',&#13;
          'node_modules/zone.js/dist/proxy.js',&#13;
          'node_modules/zone.js/dist/sync-test.js',&#13;
          'node_modules/zone.js/dist/jasmine-patch.js',&#13;
          'node_modules/zone.js/dist/async-test.js',&#13;
          'node_modules/zone.js/dist/fake-async-test.js',&#13;
&#13;
          // RxJs&#13;
          { pattern: 'node_modules/rxjs/**/*.js', included: false, &#13;
          watched: false },&#13;
          { pattern: 'node_modules/rxjs/**/*.js.map', included: &#13;
          false, watched: false },&#13;
&#13;
          // Paths loaded via module imports:&#13;
          // Angular itself&#13;
          { pattern: 'node_modules/@angular/**/*.js', included: &#13;
          false, watched: false },&#13;
          { pattern: 'node_modules/@angular/**/*.js.map', included: &#13;
          false, watched: false },&#13;
&#13;
          { pattern: 'systemjs.config.js', included: false, watched: &#13;
          false },&#13;
          { pattern: 'systemjs.config.extras.js', included: false, &#13;
          watched: false },&#13;
          'karma-test-shim.js',&#13;
&#13;
          // transpiled application &amp; spec code paths loaded via &#13;
          module imports&#13;
          { pattern: appBase + '**/*.js', included: false, watched: &#13;
          true },&#13;
          { pattern: testBase + '**/*.spec.js', included: false, &#13;
          watched: true },&#13;
],&#13;
</pre><p>That's all we need to know for now in the <code class="literal">karma.conf</code> file. We will proceed by updating these settings if needed.</p><p>Let's take a look at the complete <code class="literal">karma.conf.js</code> file:</p><pre class="programlisting">module.exports = function(config) {&#13;
&#13;
  var appBase    = 'app/';       // transpiled app JS and map files&#13;
  var appSrcBase = 'app/';       // app source TS files&#13;
  var appAssets  = 'base/app/'; // component assets fetched by &#13;
  Angular's compiler&#13;
&#13;
  var testBase    = 'spec/unit/';       // transpiled test JS and map &#13;
  files&#13;
  var testSrcBase = 'spec/unit/';       // test source TS files&#13;
&#13;
  config.set({&#13;
    basePath: '',&#13;
    frameworks: ['jasmine'],&#13;
    plugins: [&#13;
      require('karma-jasmine'),&#13;
      require('karma-chrome-launcher'),&#13;
      require('karma-jasmine-html-reporter'), // click "Debug" in &#13;
      browser to see it&#13;
      require('karma-htmlfile-reporter') // crashing w/ strange &#13;
      socket error&#13;
    ],&#13;
&#13;
    customLaunchers: {&#13;
      // From the CLI. Not used here but interesting&#13;
      // chrome setup for travis CI using chromium&#13;
      Chrome_travis_ci: {&#13;
        base: 'Chrome',&#13;
        flags: ['--no-sandbox']&#13;
      }&#13;
    },&#13;
    files: [&#13;
      // System.js for module loading&#13;
      'node_modules/systemjs/dist/system.src.js',&#13;
&#13;
      // Polyfills&#13;
      'node_modules/core-js/client/shim.js',&#13;
      'node_modules/reflect-metadata/Reflect.js',&#13;
&#13;
      // zone.js&#13;
      'node_modules/zone.js/dist/zone.js',&#13;
      'node_modules/zone.js/dist/long-stack-trace-zone.js',&#13;
      'node_modules/zone.js/dist/proxy.js',&#13;
      'node_modules/zone.js/dist/sync-test.js',&#13;
      'node_modules/zone.js/dist/jasmine-patch.js',&#13;
      'node_modules/zone.js/dist/async-test.js',&#13;
      'node_modules/zone.js/dist/fake-async-test.js',&#13;
&#13;
      // RxJs&#13;
      { pattern: 'node_modules/rxjs/**/*.js', included: false, &#13;
      watched: false },&#13;
      { pattern: 'node_modules/rxjs/**/*.js.map', included: false, &#13;
      watched: false },&#13;
&#13;
      // Paths loaded via module imports:&#13;
      // Angular itself&#13;
      { pattern: 'node_modules/@angular/**/*.js', included: false, &#13;
      watched: false },&#13;
      { pattern: 'node_modules/@angular/**/*.js.map', included: &#13;
      false, watched: false },&#13;
&#13;
      { pattern: 'systemjs.config.js', included: false, watched: &#13;
      false },&#13;
      { pattern: 'systemjs.config.extras.js', included: false, &#13;
      watched: false },&#13;
      'karma-test-shim.js',&#13;
&#13;
      // transpiled application &amp; spec code paths loaded via module &#13;
      imports&#13;
      { pattern: appBase + '**/*.js', included: false, watched: true &#13;
      },&#13;
      { pattern: testBase + '**/*.spec.js', included: false, watched: &#13;
      true },&#13;
&#13;
      // Asset (HTML &amp; CSS) paths loaded via Angular's component &#13;
      compiler&#13;
      // (these paths need to be rewritten, see proxies section)&#13;
      { pattern: appBase + '**/*.html', included: false, watched: true &#13;
      },&#13;
      { pattern: appBase + '**/*.css', included: false, watched: true &#13;
      },&#13;
&#13;
      // Paths for debugging with source maps in dev tools&#13;
      { pattern: appSrcBase + '**/*.ts', included: false, watched: &#13;
      false },&#13;
      { pattern: appBase + '**/*.js.map', included: false, watched: &#13;
      false },&#13;
      { pattern: testSrcBase + '**/*.ts', included: false, watched: &#13;
      false },&#13;
      { pattern: testBase + '**/*.js.map', included: false, watched: &#13;
      false }&#13;
    ],&#13;
&#13;
    // Proxied base paths for loading assets&#13;
     proxies: {&#13;
       // required for component assets fetched by Angular's compiler&#13;
       "/app/": appAssets&#13;
   },&#13;
&#13;
    exclude: [],&#13;
    preprocessors: {},&#13;
    // disabled HtmlReporter; suddenly crashing w/ strange socket &#13;
    error&#13;
    reporters: ['progress', 'kjhtml'],//'html'],&#13;
&#13;
    // HtmlReporter configuration&#13;
    htmlReporter: {&#13;
      // Open this file to see results in browser&#13;
      outputFile: '_test-output/tests.html',&#13;
&#13;
      // Optional&#13;
      pageTitle: 'Unit Tests',&#13;
      subPageTitle: __dirname&#13;
    },&#13;
&#13;
    port: 9876,&#13;
    colors: true,&#13;
    logLevel: config.LOG_INFO,&#13;
    autoWatch: true,&#13;
    browsers: ['Chrome'],&#13;
    singleRun: true&#13;
  })&#13;
};&#13;
&#13;
</pre></div><div class="section" title="Test directory updated"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec81"/>Test directory updated</h2></div></div></div><p>We have seen details of <code class="literal">karma-test-shim.js</code> in <a class="link" href="ch03.html" title="Chapter 3. The Karma Way">Chapter 3</a>, <span class="emphasis"><em>The Karma Way</em></span>. This is needed to run unit testing via Karma.</p><p>We have changed the test specs directory/location, and <code class="literal">karma-test-shim.js</code> is configured based on the default structure of the project. Because we have moved the test to a different location and out of the <code class="literal">app/</code> folder, we need to update <code class="literal">karma-test-shim.js</code> accordingly.</p><p>Here is the change that will need to be made:</p><pre class="programlisting">    var builtPath = '/base/'; &#13;
</pre></div><div class="section" title="Setting up Protractor"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec82"/>Setting up Protractor</h2></div></div></div><p>In <a class="link" href="ch04.html" title="Chapter 4. End-to-End Testing with Protractor">Chapter 4</a>, <span class="emphasis"><em>End-to-End Testing with Protractor</em></span>, we discussed the full installation and setup of Protractor. This sample application already has Protractor installed and configured. So, we will just take a look at the <code class="literal">protractor.conf.js</code> file.</p><p>This configured Protractor instance has test reporting implemented. We will skip those parts from the config file here and just have a look at the common setting options.</p><p>Before we go to the config file overview, to be sure, we will install Protractor globally on the system:</p><pre class="programlisting">
<span class="strong"><strong>$ npm install -g protractor</strong></span>
</pre><p>Update Selenium WebDriver:</p><pre class="programlisting">
<span class="strong"><strong>$ webdriver-manager update</strong></span>
</pre><p>We will have to make sure that Selenium is installed.</p><p>As expected, <code class="literal">protractor.conf.js</code> is located at the root of the application. Here is the complete configuration of the <code class="literal">protractor.conf.js</code> file:</p><pre class="programlisting">var fs = require('fs'); &#13;
var path = require('canonical-path'); &#13;
var _ = require('lodash'); &#13;
 &#13;
exports.config = { &#13;
  directConnect: true, &#13;
 &#13;
  // Capabilities to be passed to the webdriver instance. &#13;
  capabilities: { &#13;
    'browserName': 'chrome' &#13;
  }, &#13;
 &#13;
  // Framework to use. Jasmine is recommended. &#13;
  framework: 'jasmine', &#13;
 &#13;
  // Spec patterns are relative to this config file &#13;
  specs: ['**/*e2e-spec.js' ], &#13;
 &#13;
 &#13;
  // For angular tests &#13;
  useAllAngular2AppRoots: true, &#13;
 &#13;
  // Base URL for application server &#13;
  baseUrl: 'http://localhost:8080', &#13;
 &#13;
  // doesn't seem to work. &#13;
  // resultJsonOutputFile: "foo.json", &#13;
 &#13;
  onPrepare: function() { &#13;
    //// SpecReporter &#13;
    //var SpecReporter = require('jasmine-spec-reporter'); &#13;
    //jasmine.getEnv().addReporter(new &#13;
    SpecReporter({displayStacktrace: 'none'}));  &#13;
    //// jasmine.getEnv().addReporter(new SpecReporter({&#13;
    displayStacktrace: 'all'})); &#13;
 &#13;
    // debugging &#13;
    // console.log('browser.params:' +    &#13;
    JSON.stringify(browser.params)); &#13;
    jasmine.getEnv().addReporter(new Reporter( browser.params )) ; &#13;
 &#13;
    // Allow changing bootstrap mode to NG1 for upgrade tests &#13;
    global.setProtractorToNg1Mode = function() { &#13;
      browser.useAllAngular2AppRoots = false; &#13;
      browser.rootEl = 'body'; &#13;
    }; &#13;
  }, &#13;
 &#13;
  jasmineNodeOpts: { &#13;
    // defaultTimeoutInterval: 60000, &#13;
    defaultTimeoutInterval: 10000, &#13;
    showTiming: true, &#13;
    print: function() {} &#13;
  } &#13;
};  &#13;
</pre></div></div>
<div class="section" title="Top-down versus bottom-up approach - which one do we use?"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec45"/>Top-down versus bottom-up approach - which one do we use?</h1></div></div></div><p>From a development perspective, we have to determine where to start. The approaches that we will discuss in this book are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>The bottom-up approach</strong></span>: With this approach, we think about the different components we will need (class, service, module, and so on) and then pick the most logical one and start coding.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>The top-down approach</strong></span>: With this approach, we work from the user scenario and UI. We then create the application around the components in the application.</li></ul></div><p>There are merits to both these approaches, and the choice can be based on your team, the existing components, requirements, and so on. In most cases, it is best for you to make the choice based on the least resistance.</p><p>In this chapter, the approach of the specification is top-down; everything is laid out for you from the user scenario and will allow you to organically build the application around the UI.</p></div>
<div class="section" title="Testing a component"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec46"/>Testing a component</h1></div></div></div><p>Before getting into the specifications and the mindset of the feature being delivered, it is important to understand the fundamentals of testing a component class. A component in Angular is a key feature used in most applications.</p><div class="section" title="Getting ready to go"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec83"/>Getting ready to go</h2></div></div></div><p>Our sample application (<code class="literal">quickstart</code>) has some very basic test specs for unit and end-to-end testing. We will start the TDD approach from the very beginning, so we will not use any of the test specs and the existing component's code in our implementation.</p><p>For that, what can we do is just clean up this sample application, and we will just keep the folder structure and application bootstrap files.</p><p>So, first of all, we will have to remove the unit test file (<code class="literal">app.component.spec.ts</code>) and end-to-end test files (<code class="literal">app.e2e-spec.ts</code>). These are two test specs that existed in the application structure.</p></div><div class="section" title="Setting up a simple component test"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec84"/>Setting up a simple component test</h2></div></div></div><p>When testing a component, it's important to inject the component into the test suite and then initiate the component class as the second task. The tests confirm that either the objects or methods in the component's scope are available as expected.</p><p>To have the component instance in the test suite, we will use the simple <code class="literal">import</code> statement in the test suite and initiate the component object in the <code class="literal">beforeEach</code> method so that we have a new instance of the component object for every test spec with that test suite. Here is an example of what this will look like:</p><pre class="programlisting">import { async, ComponentFixture, TestBed } from '@angular/core/testing'; &#13;
 &#13;
import {AppComponent} from "../../app.component"; &#13;
 &#13;
describe('AppComponent Tests Suite', () =&gt; { &#13;
 &#13;
  let comp: AppComponent; &#13;
  let fixture: ComponentFixture&lt;AppComponent&gt;; &#13;
 &#13;
  beforeEach(async(() =&gt; { &#13;
   TestBed.configureTestingModule({ &#13;
      declarations: [ AppComponent ] &#13;
    }) &#13;
    .compileComponents(); &#13;
  })); &#13;
 &#13;
  beforeEach(() =&gt; { &#13;
    fixture = TestBed.createComponent(AppComponent); &#13;
    comp = fixture.componentInstance; &#13;
 &#13;
  }); &#13;
}); &#13;
</pre><p>So, as long as the component class is initiated for every test spec, it will have a new instance for every spec, and the internal scope will act based on that.</p></div><div class="section" title="Initializing the component"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec85"/>Initializing the component</h2></div></div></div><p>To test a component, it's important to initialize the component class so that we have the component object available to the test suite's scope and all the members of the object are available around the specific test suite.</p><p>As long as the component contains the template to render the UI, it's important to initialize the component before beginning e2e testing, and it depends on DOM elements.</p><p>So when we plan to do e2e testing for any component, we should initiate that in the DOM, as follows:</p><pre class="programlisting">&lt;body&gt; &#13;
  &lt;my-app&gt;&lt;/my-app&gt; &#13;
&lt;/body&gt; &#13;
</pre></div><div class="section" title="End-to-end versus unit test for components"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec86"/>End-to-end versus unit test for components</h2></div></div></div><p>In the preceding example, we looked at the component test suite, which is for unit testing, and we have to import and create an instance of the component class as the unit test. We will test the functionality or feature of every method that is defined in the component.</p><p>On the other hand, for end-to-end testing, we do not need to import or create an instance of the component class as we will not need to comment with the competent object or all its members. Rather, it needs to interact with the DOM elements of the landing page of the application that is running.</p><p>So, for that, we will need to run the application and navigate the test suite to the application landing page, and we can do so with the global <code class="literal">browser</code> object provided by Protractor itself.</p><p>Here is an example of what it should look like:</p><pre class="programlisting">import { browser, element, by } from 'protractor'; &#13;
 &#13;
describe('Test suite for e2e test', () =&gt; { &#13;
    beforeEach(() =&gt; { &#13;
        browser.get(''); &#13;
    }); &#13;
}); &#13;
</pre><p>We can navigate to all the URLs of the application using <code class="literal">browser.get('path')</code> as needed.
</p></div></div>
<div class="section" title="Diving into our comment application"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec47"/>Diving into our comment application</h1></div></div></div><p>Now that the setup and approach have been decided, we can start our first test. From a testing point of view, as we will be using a top-down approach, we will write our Protractor tests first and then build the application. We will follow the same TDD life cycle we have already reviewed: test first, make it run, and make it better.</p><div class="section" title="Test first"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec87"/>Test first</h2></div></div></div><p>The scenario given is already in a well-specified format and fits our Protractor testing template:</p><pre class="programlisting">describe('', () =&gt; { &#13;
    describe('', () =&gt; { &#13;
     beforeEach(() =&gt; { &#13;
     }); &#13;
 &#13;
      it('', () =&gt; { &#13;
      }); &#13;
    }); &#13;
}); &#13;
</pre><p>Placing the scenario in the template, we get the following code:</p><pre class="programlisting">describe('Given I am posting a new comment', () =&gt; { &#13;
    describe('When I push the submit button', () =&gt; { &#13;
        beforeEach(() =&gt; { &#13;
            // ...  &#13;
        }); &#13;
 &#13;
        it('Should then add the comment', () =&gt; { &#13;
            // ... &#13;
        }); &#13;
    }); &#13;
}); &#13;
</pre><p>Following the 3 A's (assemble, act, assert), we will fit the user scenario in the template.
</p><div class="section" title="Assemble"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec23"/>Assemble</h3></div></div></div><p>The browser will need to point to the first page of the application. As the base URL has already been defined, we can add the following to the test:</p><pre class="programlisting">beforeEach(() =&gt; { &#13;
    browser.get(''); &#13;
}); &#13;
</pre><p>Now that the test has been prepared, we can move on to the next step: act.</p></div><div class="section" title="Act"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec24"/>Act</h3></div></div></div><p>The next thing we need to do, based on the user specification, is to add an actual comment. The easiest thing is to just put some text into an input box. The test for this, again without knowing what the element will be called or what it will do, is to write it based on what it should be.</p><p>Here is the code to add the comment section for the application:</p><pre class="programlisting">beforeEach(() =&gt; { &#13;
    ... &#13;
    var commentInput = element(by.css('input')); &#13;
    commentInput.sendKeys('a sample comment'); &#13;
}); &#13;
</pre><p>The last assembly component, as a part of the test, is to click on the <span class="strong"><strong>Submit</strong></span> button. This can be easily achieved in Protractor using the <code class="literal">click</code> function. Even though we don't have a page yet, or any attributes, we can still name the button that will be created:</p><pre class="programlisting">beforeEach(() =&gt; { &#13;
    ... &#13;
    var submitButton = element(by.buttonText('Submit')).click(); &#13;
}); &#13;
</pre><p>Finally, we will hit the crux of the test and assert the user's expectations.</p></div><div class="section" title="Assert"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec25"/>Assert</h3></div></div></div><p>The user expectation is that once the <span class="strong"><strong>Submit</strong></span> button is clicked on, the comment is added. This is a little ambiguous, but we can determine that somehow the user needs to get notified that the comment was added.</p><p>The easiest approach is to display all comments on the page. In Angular, the easiest way to do this is to add an <code class="literal">*ngFor</code> object that displays all comments. To test this, we will add the following:</p><pre class="programlisting">it('Should then add the comment', () =&gt; { &#13;
    var comment = element.all(by.css('li')).first(); &#13;
    expect(comment.getText()).toBe('a sample comment'); &#13;
}); &#13;
</pre><p>Now the test has been constructed and meets the user specifications. It is small and concise. Here is the completed test:</p><pre class="programlisting">describe('Given I am posting a new comment', () =&gt; { &#13;
    describe('When I push the submit button', () =&gt; { &#13;
      beforeEach(() =&gt; { &#13;
            //Assemble &#13;
            browser.get(''); &#13;
            var commentInput = element(by.css('input')); &#13;
            commentInput.sendKeys('a sample comment'); &#13;
 &#13;
            //Act &#13;
            var submitButton =  element(by.buttonText&#13;
            ('Submit')).click(); &#13;
      }); &#13;
 &#13;
       //Assert &#13;
  it('Should then add the comment', () =&gt; { &#13;
            var comment = element.all(by.css('li')).first(); &#13;
            expect(comment.getText()).toBe('a sample comment'); &#13;
  }); &#13;
    }); &#13;
}); &#13;
</pre></div></div><div class="section" title="Make it run"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec88"/>Make it run</h2></div></div></div><p>Based on the errors and output of the test, we will build our application as we go.</p><p>Start the web server using the following command:</p><pre class="programlisting">
<span class="strong"><strong>$ npm start</strong></span>
</pre><p>Run the Protractor test to see the first error:</p><pre class="programlisting">
<span class="strong"><strong>$ protractor</strong></span>
</pre><p>Alternatively, we can run this:</p><pre class="programlisting">
<span class="strong"><strong>$ npm run e2e // run via npm </strong></span>
</pre><p>Our first error could be that it's not getting the element the locator expected:</p><pre class="programlisting">
<span class="strong"><strong>$ Error: Failed: No element found using locator: &#13;
    By(css selector, input)</strong></span>
</pre><p>The reason for the error is simple: it's not getting the element as defined in the locator. We can see the current application and why it's not getting the element.</p><div class="section" title="Recap the present application"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec26"/>Recap the present application</h3></div></div></div><p>As long as we have cloned the sample Angular <code class="literal">quickstart</code> project as our application to test, it has a ready Angular environment. It Bootstraps the Angular project with a simple application component defined with <code class="literal">My First Angular 2 App</code> as the output.</p><p>So, in our TDD approach, we should not have any environment/Angular Bootstrap-related error, and it seems we are on the right path.</p><p>Let's take a look at what we have right now in our sample application. On our landing page, <code class="literal">index.html</code>, we have included all required library files and implemented <code class="literal">system.js</code> to load the application files.</p><p>In the <code class="literal">&lt;body&gt;</code> tag in the <code class="literal">index.html</code> file, we have initiated the application as follows:</p><pre class="programlisting">&lt;body&gt; &#13;
    &lt;my-app&gt;Loading...&lt;/my-app&gt; &#13;
&lt;/body&gt; &#13;
</pre><p>The HTML tag expects a component with <code class="literal">my-app</code> as the selector for that component, and yes, we have that as <code class="literal">app.component.ts</code>, as follows:</p><pre class="programlisting">import {Component} from '@angular/core'; &#13;
@Component({ &#13;
    selector: 'my-app', &#13;
    template: '&lt;h1&gt;My First Angular 2 App&lt;/h1&gt;' &#13;
}) &#13;
export class AppComponent { } &#13;
</pre><p>Angular introduced <code class="literal">ngModule</code> as an <code class="literal">appModule</code> to modularize and manage dependencies for every component. With this <code class="literal">appModule</code>, an application can define all the required dependencies at a glance. Besides that, it helped lazy-load the modules. We will look at the details of <code class="literal">ngModule</code> in the Angular docs.</p><p>It imports all the required modules in the application, declares all the modules from a single entry point, and also defines the Bootstrapping component.</p><p>The application always Bootstraps based on this file's configuration.</p><p>The file is located at the application root as <code class="literal">app.module.ts</code>, and it looks as follows:</p><pre class="programlisting">import { NgModule }      from '@angular/core'; &#13;
import { BrowserModule } from '@angular/platform-browser'; &#13;
 &#13;
import { AppComponent }  from './app.component'; &#13;
 &#13;
@NgModule({ &#13;
  imports:      [ BrowserModule], &#13;
  declarations: [ AppComponent ], &#13;
  bootstrap:    [ AppComponent ] &#13;
}) &#13;
export class AppModule { } &#13;
</pre><p>The entry point to the application is the <code class="literal">main.ts</code> file, which will import the <code class="literal">appModule</code> file and instruct to Bootstrap the application based on that:</p><pre class="programlisting">import { platformBrowserDynamic } from '@angular/platform&#13;
-browser-dynamic'; &#13;
 &#13;
import { AppModule } from './app.module'; &#13;
 &#13;
platformBrowserDynamic().bootstrapModule(AppModule); &#13;
</pre><p>The test couldn't find our input locator. We need to add the input to the page, and we need to do that via the component's template.</p></div><div class="section" title="Adding the input"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec27"/>Adding the input</h3></div></div></div><p>Here are the steps we need to follow to add the input to the page:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We will have to add a simple <code class="literal">input</code> tag to the template of the application component, as shown here:<pre class="programlisting">        template: ` &#13;
        &lt;input type='text' /&gt;` &#13;
</pre></li><li class="listitem">After running the test again, it seems that there are no more errors related to the input locator, but it has a new error as the <code class="literal">button</code> tag was missing:<pre class="programlisting">        <span class="strong"><strong>$ Error: Failed: No element found using locator: &#13;
        by.buttonText('Submit')</strong></span>
</pre></li><li class="listitem">Just like the previous error, we need to add a <code class="literal">button</code> to the template with the appropriate text:<pre class="programlisting">        template: ` ...........  &#13;
        &lt;button type='button'&gt;Submit&lt;/button&gt;` &#13;
</pre></li><li class="listitem">After running the test again, it seems that there are no more errors related to the <code class="literal">button</code> locator, but again, it has a new error, as follows, as the repeater locator is missing:<pre class="programlisting">        <span class="strong"><strong>$ Error: Failed: No element found using locator: By&#13;
        (css selector, li)</strong></span>
</pre></li></ol></div><p>This appears to be a result of our assumption that a submitted comment will be available on the page through <code class="literal">*ngFor</code>. To add this to the page, we will use a method in the component class to provide the data for the repeater.</p></div><div class="section" title="Component"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec28"/>Component</h3></div></div></div><p>As mentioned in the preceding section, the error occurs because there is no <code class="literal">comments</code> object. In order to add the <code class="literal">comments</code> object, we will use the component class that has an array of <code class="literal">comments</code> in its scope.</p><p>Perform the following steps to add a <code class="literal">comments</code> object to the scope:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">As we already have <code class="literal">AppComponent</code> as a class in our component, we will need to define the comments array, which we can use in a repeater:<pre class="programlisting">        export class AppComponent { &#13;
            comments:Array&lt;string&gt;; &#13;
        } &#13;
</pre></li><li class="listitem">Then, we will add a repeater for the comments in the template, as shown here:<pre class="programlisting">        template: `..........  &#13;
            &lt;ul&gt; &#13;
              &lt;li *ngFor="let comment of comments"&gt;{{comment}}&lt;/li&gt; &#13;
            &lt;/ul&gt;` &#13;
</pre></li><li class="listitem">Let's run the Protractor test and see where we are:<pre class="programlisting">        <span class="strong"><strong>$   Error: Failed: No element found using locator: By(css&#13;
        selector, li)</strong></span>
</pre></li></ol></div><p>Oops! We are still getting the same error. However, don't worry; there might be some other issue.</p><p>Let's look at the actual page that gets rendered and see what's going on. In Chrome, navigate to <code class="literal">http://localhost:3000</code> and open the console to see the page source (<span class="emphasis"><em>Ctrl + Shift + J</em></span>). Note that the repeater and component are both there; however, the repeater is commented out. Since Protractor is only looking at visible elements, it won't find the list.</p><p>Great! Now we know why the repeater list isn't visible, but we have to fix it. In order for a comment to show up, it has to exist on the component's <code class="literal">comments</code> scope.</p><p>The smallest change is to add something to the array to initialize it, as shown in the following code snippet:</p><pre class="programlisting">export class AppComponent { &#13;
    comments:Array&lt;string&gt;; &#13;
    constructor() { &#13;
        this.comments = ['First comment', 'Second comment',&#13;
        'Third comment']; &#13;
    } &#13;
}; &#13;
</pre><p>Now, if we run the test, we get the following output:</p><pre class="programlisting">
<span class="strong"><strong>$ Expected 'First comment' to be 'a sample comment'.</strong></span>
</pre><p>Great, it seems we are getting closer as the errors have gone down! We have tackled almost all the unexpected errors and met our expectations.</p><p>So let's take a look at the changes that we have made so far and what our codes look like.</p><p>Here's the <code class="literal">body</code> tag of the <code class="literal">index.html</code> file:</p><pre class="programlisting">&lt;body&gt; &#13;
    &lt;my-app&gt;Loading...&lt;/my-app&gt; &#13;
&lt;/body&gt; &#13;
</pre><p>The application component file is as follows:</p><pre class="programlisting">import {Component} from '@angular/core'; &#13;
 &#13;
@Component({ &#13;
    selector: 'my-app', &#13;
    template: `&lt;h1&gt;My First Angular 2 App&lt;/h1&gt; &#13;
    &lt;input type='text' /&gt; &#13;
    &lt;button type='button'&gt;Submit&lt;/button&gt; &#13;
    &lt;ul&gt; &#13;
      &lt;li *ngFor="let comment of comments"&gt;{{comment}}&lt;/li&gt; &#13;
    &lt;/ul&gt;` &#13;
}) &#13;
export class AppComponent { &#13;
    comments:Array&lt;string&gt;; &#13;
 &#13;
    constructor() { &#13;
        this.comments = ['First comment', 'Second comment', &#13;
        'Third comment']; &#13;
    } &#13;
} &#13;
</pre></div></div><div class="section" title="Make it pass"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec89"/>Make it pass</h2></div></div></div><p>With TDD, we want to add the smallest possible component to make the test pass.</p><p>Since we have hard coded the comments array for the moment to be initialized to three items and the first items to be <code class="literal">First comment</code>, change <code class="literal">First comment</code> to <code class="literal">a sample comment</code>; this should make the test pass.</p><p>Here is the code to make the test pass:</p><pre class="programlisting">export class AppComponent { &#13;
    comments:Array&lt;string&gt;; &#13;
    constructor() { &#13;
        this.comments = ['a sample comment', 'Second comment', &#13;
        'Third comment']; &#13;
    } &#13;
}; &#13;
</pre><p>Run the test, and bam! We get a passing test:</p><pre class="programlisting">
<span class="strong"><strong>$ 1 test, 1 assertion, 0 failures</strong></span>
</pre><p>Wait a second! We still have some work to do. Although we got the test to pass, it is not done. We added some hacks just to get it to pass. Two things stand out:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We clicked on the <span class="strong"><strong>Submit</strong></span> button, which really doesn't have any functionality</li><li class="listitem" style="list-style-type: disc">We hardcoded the initialization of the expected value for a comment</li></ul></div><p>The preceding changes are critical steps that we need to perform before we move forward. They will be tackled in the next phase of the TDD life cycle, that is, make it better (refactor).
</p></div><div class="section" title="Make it better"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec90"/>Make it better</h2></div></div></div><p>The two components that need to be reworked are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Adding behavior to the <span class="strong"><strong>Submit</strong></span> button</li><li class="listitem" style="list-style-type: disc">Removing the hardcoded value of the comments</li></ul></div><div class="section" title="Implementing the Submit button"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec29"/>Implementing the Submit button</h3></div></div></div><p>The <span class="strong"><strong>Submit</strong></span> button needs to actually do something. We were able to sidestep the implementation by just hardcoding the value. Using our tried-and-trusted TDD techniques, switch to an approach focused on unit testing. So far, the focus has been on the UI and pushing changes to the code; we haven't written a single unit test.</p><p>For this next bit of work, we will switch gears and focus on driving the development of the <span class="strong"><strong>Submit</strong></span> button through tests. We will be following the TDD life cycle (test first, make it run, and make it better).</p><div class="section" title="Configuring Karma"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl4sec1"/>Configuring Karma</h4></div></div></div><p>We did something very similar for the to-do list application in <a class="link" href="ch03.html" title="Chapter 3. The Karma Way">Chapter 3</a>, <span class="emphasis"><em>The Karma Way</em></span>. We won't spend as much time diving into the code, so review the previous chapters for a deeper discussion of some of the attributes.</p><p>Here are the steps we need to follow to configure Karma:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Update the <code class="literal">files</code> section with the added files:<pre class="programlisting">        files: [ &#13;
            ... &#13;
            // Application files &#13;
            {pattern: 'app/**/*.js', included: false, watched: &#13;
            true} &#13;
 &#13;
            // Unit Test spec files &#13;
            {pattern: 'spec/unit/**/*.spec.js', included: false,&#13;
            watched: true} &#13;
            ... &#13;
        ], &#13;
</pre></li><li class="listitem">Start Karma:<pre class="programlisting">        <span class="strong"><strong>$ karma start</strong></span>
</pre></li><li class="listitem">Confirm that Karma is running:<pre class="programlisting">        <span class="strong"><strong>$ Chrome 50.0.2661 (Mac OS X 10.10.5): Executed 0 of 0 &#13;
        SUCCESS (0.003 secs / 0 secs)</strong></span>
</pre></li></ol></div></div><div class="section" title="Test first"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl4sec2"/>Test first</h4></div></div></div><p>Let's start with a new file in the <code class="literal">spec/unit</code> folder, called <code class="literal">app.component.spec.ts</code>. This will contain the test spec for the unit test. We will use the base template, including all necessary imports, such as <code class="literal">TestBed</code>:</p><pre class="programlisting">    describe('', () =&gt; { &#13;
     beforeEach(() =&gt; { &#13;
     }); &#13;
 &#13;
      it('', () =&gt; { &#13;
      }); &#13;
    }); &#13;
</pre><p>According to the specification, when the <span class="strong"><strong>Submit</strong></span> button is clicked on, it needs to add a comment. We will need to fill in the blanks of the three components of a test (assemble, act, and assert).</p><p><span class="strong"><strong>Assemble</strong></span></p><p>The behavior needs to be part of a component for the frontend to use it. The object under testing in this case is the component's scope. We need to add this to the assembly of this test. Like we did in <a class="link" href="ch03.html" title="Chapter 3. The Karma Way">Chapter 3</a>, <span class="emphasis"><em>The Karma Way</em></span>, we will do the same in the following code:</p><pre class="programlisting">import {AppComponent} from "../../app/app.component"; &#13;
 &#13;
describe('AppComponent Unit Test', () =&gt; { &#13;
    let comp: AppComponent; &#13;
    let fixture: ComponentFixture&lt;AppComponent&gt;; &#13;
 &#13;
    beforeEach(() =&gt; { fixture = TestBed.create&#13;
    Component(AppComponent); &#13;
      comp = fixture.componentInstance; &#13;
 &#13;
    }); &#13;
}); &#13;
</pre><p>Now, the component object and its member are available in the test suite and will be testable as expected.</p><span class="strong"><strong>Act</strong></span><p>The specification determines that we need to call an <code class="literal">add</code> method in the component object. Add the following code to the <code class="literal">beforeEach</code> section of the test:</p><pre class="programlisting">beforeEach(() =&gt; { comp.add('a sample comment'); &#13;
}); &#13;
</pre><p>Now, the assertion should get the first comment to test.</p><p><span class="strong"><strong>Assert</strong></span></p><p>Assert that the comment items in the <code class="literal">component</code> object now contain any comment as the first element. Add the following code to the test:</p><pre class="programlisting">it('',function(){ &#13;
  expect(com.comments[0]).toBe('a sample comment'); &#13;
}); &#13;
</pre><p>Save the file, and let's move on to the next step of the life cycle and make it run (execute).</p></div><div class="section" title="Make it run"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl4sec3"/>Make it run</h4></div></div></div><p>Now that we have prepared the test, we need to make the test pass. Looking at the output of the console where Karma is running, we see the following:</p><pre class="programlisting">
<span class="strong"><strong>$ TypeError: com.add is not a function</strong></span>
</pre><p>Looking at our unit test, we see that this is the <code class="literal">add</code> function. Let's go ahead and put in an <code class="literal">add</code> function into the controller's <code class="literal">scope</code> object using the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the controller scope and create a function named <code class="literal">add</code>:<pre class="programlisting">        export class AppComponent { &#13;
            ............. &#13;
            add() { &#13;
            // .... &#13;
            } &#13;
        } &#13;
</pre></li><li class="listitem">Check Karma's output, and let's see where we are:<pre class="programlisting">        <span class="strong"><strong>$ Expected 'First comment' to be 'a sample comment'.</strong></span>
</pre></li><li class="listitem">Now, we have hit the expectation. Remember to think of the smallest change to get this to work. Modify the <code class="literal">add</code> function to set the <code class="literal">$scope.comments</code> array to any comment when called:<pre class="programlisting">        export class AppComponent { &#13;
            ............. &#13;
            add() { &#13;
                this.comments.unshift('a sample comment'); &#13;
            } &#13;
        }; &#13;
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note14"/>Note</h3><p>The <code class="literal">unshift</code> function is a standard JavaScript function that adds an item to the front of an array.</p></div></div></li></ol></div><p>When we check Karma's output, we'll see the following:</p><pre class="programlisting">
<span class="strong"><strong>$ Chrome 50.0.2661 (Mac OS X 10.10.5): Executed 1 of 1 &#13;
    SUCCESS (0.008 secs / 0.002 secs)</strong></span>
</pre><p>Success! The test passes, but again needs some work. Let's move on to the next stage and make it better (refactor).</p></div><div class="section" title="Make it better"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl4sec4"/>Make it better</h4></div></div></div><p>The main point that needs to be refactored is the <code class="literal">add</code> function. It doesn't take any arguments! This should be straightforward to add, and simply confirms that the test still runs. Update the <code class="literal">add</code> function of <code class="literal">app.component.ts</code> to take an argument and use that argument to add to the <code class="literal">comments</code> array:</p><pre class="programlisting">export class AppComponent { &#13;
    ............. &#13;
    add(comment) { &#13;
        this.comments.unshift(comment); &#13;
    } &#13;
}; &#13;
</pre><p>Check the output window of Karma and ensure that the test still passes. The complete unit test looks as follows:</p><pre class="programlisting">import {AppComponent} from "../../app/app.component"; &#13;
 &#13;
describe('AppComponent Tests', () =&gt; { &#13;
    let comp: AppComponent; &#13;
    let fixture: ComponentFixture&lt;AppComponent&gt;; &#13;
 &#13;
    beforeEach(() =&gt; { &#13;
        fixture = TestBed.createComponent(AppComponent); &#13;
        comp = fixture.componentInstance;         &#13;
        comp.add('a sample comment'); &#13;
    }); &#13;
 &#13;
    it('First item inthe item should match', () =&gt; { &#13;
        expect(com.comments[0]).toBe('a sample comment'); &#13;
    }); &#13;
}); &#13;
</pre><p>The <code class="literal">AppComponent</code> class file now looks like this:</p><pre class="programlisting">import {Component} from '@angular/core'; &#13;
 &#13;
@Component({ &#13;
    selector: 'my-app', &#13;
    template: `&lt;h1&gt;My First Angular 2 App&lt;/h1&gt; &#13;
    &lt;input type='text' /&gt; &#13;
    &lt;button type='button'&gt;Submit&lt;/button&gt; &#13;
    &lt;ul&gt; &#13;
      &lt;li *ngFor="let comment of comments"&gt;{{comment}}&lt;/li&gt; &#13;
    &lt;/ul&gt;` &#13;
}) &#13;
export class AppComponent { &#13;
    comments:Array&lt;string&gt;; &#13;
 &#13;
    constructor() { &#13;
        this.comments = ['First comment', 'Second comment', &#13;
        'Third comment']; &#13;
    } &#13;
    add(comment) { &#13;
        this.comments.unshift(comment); &#13;
    } &#13;
} &#13;
</pre></div></div><div class="section" title="Backing up the test chain"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec30"/>Backing up the test chain</h3></div></div></div><p>We completed the unit test and added the <code class="literal">add</code> function. Now we can add the function to specify the behavior of the <span class="strong"><strong>Submit</strong></span> button. The way to link the <code class="literal">add</code> method to the button is to use the <code class="literal">(click)</code> event. The steps to add the behavior to the <span class="strong"><strong>Submit</strong></span> button are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">app.component.ts</code> file and update it as follows:<pre class="programlisting">        @Component({ &#13;
           template: `....... &#13;
            &lt;button type="button" (click)="add('a sample      &#13;
            comment')"&gt;Submit&lt;/button&gt; &#13;
            ...........` &#13;
        }) &#13;
</pre><p>Hold on! Is the value hardcoded? Well, again, we want to make the smallest change and ensure that the test still passes. We will work through our refactors until the code is how we want it to be, but instead of a Big Bang approach, we want to make small, incremental changes.</p></li><li class="listitem">Now, let's rerun the Protractor test and ensure that it still passes. The output says that it passed, and we are okay. The hardcoded value wasn't removed from the comments. Let's go ahead and remove that now.</li><li class="listitem">The <code class="literal">AppComponent</code> class file should now look as follows:<pre class="programlisting">        constructor() { &#13;
            this.comments = []; &#13;
        } &#13;
</pre></li><li class="listitem">Run the test and see that we still get a passing test.</li></ol></div><p>The last thing we need to mop up is the hardcoded value in <code class="literal">(click)</code>. The comment being added should be determined by the input in the comment input text.</p></div></div><div class="section" title="Binding the input"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec91"/>Binding the input</h2></div></div></div><p>Here are the steps we need to follow to bind the input:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">To be able to bind the input to something meaningful, add an <code class="literal">ngModel</code> attribute to the <code class="literal">input</code> tag:<pre class="programlisting">        @Component({ &#13;
            template: `............. &#13;
            &lt;input type="text" [(ngModel)]="newComment"&gt; &#13;
            ...........` &#13;
        }) &#13;
</pre></li><li class="listitem">Then, in the <code class="literal">(click)</code> attribute, simply use the <code class="literal">newComment</code> model as the input:<pre class="programlisting">        @Component({ &#13;
           template: `....... &#13;
            &lt;button type="button" (click)="add(newComment)"&gt;&#13;
            Submit&lt;/button&gt; &#13;
            ...........` &#13;
        }) &#13;
</pre></li><li class="listitem">We will have to import the form module in the app module (<code class="literal">app.module.ts</code>) as it's a dependency for <code class="literal">ngModel</code>:<pre class="programlisting">        import { FormsModule }   from '@angular/forms'; &#13;
        @NgModule({ &#13;
        imports: [ BrowserModule, FormsModule ], &#13;
        }) &#13;
</pre></li><li class="listitem">Run the Protractor test and confirm that everything has passed and is good to go.</li></ol></div></div></div>
<div class="section" title="Onward and upward"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec48"/>Onward and upward</h1></div></div></div><p>Now that we have the first specification working, and it is end-to-end and unit tested, we can start the next specification. The next specification states that the user wants the ability to like a comment.</p><p>We will use the top-down approach and start our test from Protractor. We will continue to follow the TDD life cycle: test first, make it run, and make it better.</p><div class="section" title="Test first"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec92"/>Test first</h2></div></div></div><p>Following the pattern, we will start with a basic Protractor test template:</p><pre class="programlisting">describe('', () =&gt; { &#13;
     beforeEach(() =&gt; { &#13;
     }); &#13;
 &#13;
      it('', () =&gt; { &#13;
      }); &#13;
    }); &#13;
</pre><p>When we fill in the specification, we get the following:</p><pre class="programlisting">describe('When I like a comment', () =&gt; { &#13;
    beforeEach(() =&gt; { &#13;
    }); &#13;
 &#13;
    it('should then be liked', () =&gt; { &#13;
      }); &#13;
}); &#13;
</pre><p>With the template in place, we are ready to construct the test.</p><div class="section" title="Assemble"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec31"/>Assemble</h3></div></div></div><p>The assembly of this test will require a comment to exist. Place the comment within the existing posted comment test. It should look similar to this:</p><pre class="programlisting">describe(''Given I am posting a new comment', () =&gt; { &#13;
    describe('When I like a comment', () =&gt; { &#13;
    ... &#13;
    }); &#13;
}); &#13;
</pre></div><div class="section" title="Act"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec32"/>Act</h3></div></div></div><p>The user specification we test is that the <span class="strong"><strong>Like</strong></span> button performs an action for a specific comment. Here are the steps that will be required and the code required to carry them out (note that the following steps will be added to the <code class="literal">beforeEach</code> text):</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Store the first comment so that it can be used in the test:<pre class="programlisting">        var firstComment = null; &#13;
        beforeEach(() =&gt; { &#13;
            ... &#13;
        } &#13;
</pre></li><li class="listitem">Find the first comment's <code class="literal">likeButton</code>:<pre class="programlisting">        var firstComment = element.all(by.css('li').first(); &#13;
        var likeButton = firstComment.element(by.buttonText('like')); &#13;
</pre></li><li class="listitem">The code for the <span class="strong"><strong>Like</strong></span> button when it is clicked on is as follows:<pre class="programlisting">        likeButton.click(); &#13;
</pre></li></ol></div></div><div class="section" title="Assert"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec33"/>Assert</h3></div></div></div><p>The specification expectation is that once the comment has been liked, it is liked. This is best done by putting an indicator of the number of likes and ensuring that the count is <code class="literal">1</code>. The code will then be as follows:</p><pre class="programlisting">it('Should increase the number of likes to one', () =&gt; { &#13;
var commentLikes = firstComment.element(by.binding('likes')); &#13;
  expect(commentLikes.getText()).toBe(1); &#13;
}); &#13;
</pre><p>The created test now looks like this:</p><pre class="programlisting">describe('When I like a comment', () =&gt; { &#13;
    var firstComment = null; &#13;
    beforeEach(() =&gt; { &#13;
 &#13;
      //Assemble &#13;
      firstComment = element.all(by.css('li').first(); &#13;
      var likeButton = firstComment.element(by.buttonText('like')); &#13;
 &#13;
      //Act &#13;
      likeButton.click(); &#13;
  }); &#13;
 &#13;
  //Assert &#13;
  it('Should increase the number of likes to one', () =&gt; { &#13;
      var commentLikes = firstComment.element(by.css('#likes')); &#13;
      expect(commentLikes.getText()).toBe(1); &#13;
  }); &#13;
}); &#13;
</pre></div></div><div class="section" title="Make it run"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec93"/>Make it run</h2></div></div></div><p>The test has been prepared and is itching to run. We will now run it and fix the code until the test passes. The following steps will detail the error and fix the cycle required to make the test path:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Run Protractor.</li><li class="listitem">View the error message in the command line:<pre class="programlisting">
<span class="strong"><strong>$ Error: No element found using locator: by.buttonText("like")</strong></span>
</pre></li><li class="listitem">As the error states, there is no <span class="strong"><strong>like</strong></span> button. Go ahead and add the button:<pre class="programlisting">        @Component({ &#13;
              template: `........ &#13;
              &lt;ul&gt; &#13;
              &lt;li *ngFor="let comment of comments"&gt; &#13;
              {{comment}} &#13;
            &lt;button type="button"&gt;like&lt;/button&gt; &#13;
              &lt;/li&gt; &#13;
              &lt;/ul&gt;` &#13;
          }); &#13;
</pre></li><li class="listitem">Run Protractor.</li><li class="listitem">View the next error message:<pre class="programlisting">
<span class="strong"><strong>$ Expected 'a sample comment like' to be 'a sample comment'.</strong></span>
</pre></li><li class="listitem">By adding the <span class="strong"><strong>like</strong></span> button, we caused our other test to fail. The reason is our use of the <code class="literal">getText() </code>method. Protractor's <code class="literal">getText()</code> method gets the inner text, including inner elements.</li><li class="listitem">To fix this, we need to update the previous test to include <span class="strong"><strong>like</strong></span> as part of the test:<pre class="programlisting">        it('Should then add the comment', () =&gt; { &#13;
          var comments = element.all(by.css('li')).first(); &#13;
          expect(comments.getText()).toBe('a sample comment like'); &#13;
        }); &#13;
</pre></li><li class="listitem">Run Protractor.</li><li class="listitem">View the next error message:<pre class="programlisting">
<span class="strong"><strong>$ Error: No element found using locator: by.css("#likes")</strong></span>
</pre></li><li class="listitem">It's time to add a <code class="literal">likes</code> binding. This one is a little more involved. The <code class="literal">likes</code> needs to be bound to a comment. We need to change the way the comments are held in the component. Comments need to hold the <code class="literal">comment</code> title and the number of likes. A comment should be an object like this:<pre class="programlisting">        {title:'',likes:0} &#13;
</pre></li><li class="listitem">Again, the focus of this step is just to get the test to pass. The next step is to update the component's <code class="literal">add</code> function to create comments based on the object that we described in the preceding steps.</li><li class="listitem">Open <code class="literal">app.component.ts</code> and edit the <code class="literal">add</code> function, as follows:<pre class="programlisting">        export class AppComponent { &#13;
            ...... &#13;
              add(comment) { &#13;
                  var commentObj = {title: comment, likes: 0}; &#13;
                  this.comments.unshift(commentObj); &#13;
              } &#13;
        } &#13;
</pre></li><li class="listitem">Update the page to use the value for the comment:<pre class="programlisting">        @Component({ &#13;
            template: `........... &#13;
            &lt;ul&gt; &#13;
              &lt;li *ngFor="let comment of comments"&gt; &#13;
          {{comment.title}} &#13;
            &lt;/li&gt; &#13;
            &lt;/ul&gt;` &#13;
        }) &#13;
</pre></li><li class="listitem">Before rerunning the Protractor test, we need to add the new <code class="literal">comment.likes</code> binding to the HTML page:<pre class="programlisting">        @Component({ &#13;
            template: `........... &#13;
            &lt;ul&gt; &#13;
              &lt;li *ngFor="let comment of comments"&gt; &#13;
          {{comment.title}} &#13;
          ............. &#13;
          &lt;span id="likes"&gt;{{comment.likes}}&lt;/span&gt; &#13;
              &lt;/li&gt; &#13;
          &lt;/ul&gt;` &#13;
        }) &#13;
</pre></li><li class="listitem">Now rerun the Protractor tests, and let's see where the errors are:<pre class="programlisting">
<span class="strong"><strong>$ Expected 'a sample comment like 0' to be 'a sample&#13;
        comment like'</strong></span>
</pre></li><li class="listitem">As the inner text of the comment has changed, we need to change the expectation of the test:<pre class="programlisting">        it('Should then add the comment',() =&gt; { &#13;
        ... &#13;
          expect(comments.getText()).toBe('a sample comment like 0'); &#13;
        }); &#13;
</pre></li><li class="listitem">Run Protractor:<pre class="programlisting">
<span class="strong"><strong>$ Expected '0' to be '1'.</strong></span>
</pre></li><li class="listitem">Finally, we are down to the expectation of the test. In order to make this test pass, the smallest change will be to make the <span class="strong"><strong>like</strong></span> button update the likes on the <code class="literal">comment</code> array. The first step is to add a <code class="literal">like</code> method to the controller, which will update the number of likes:<pre class="programlisting">        export class AppComponent { &#13;
            ...... &#13;
              like(comment) { &#13;
                  comment.like++; &#13;
              } &#13;
        } &#13;
</pre></li><li class="listitem">Link the <code class="literal">like</code> method to the HTML page using a <code class="literal">(click)</code> attribute on the button, as follows:<pre class="programlisting">        @Component({ &#13;
              template: `........ &#13;
              &lt;ul&gt; &#13;
              &lt;li *ngFor="let comment of comments"&gt; &#13;
              {{comment}} &#13;
            &lt;button type="button" (click)="like(comment)"&gt;&#13;
            like&lt;/button&gt; &#13;
        &lt;span id="likes"&gt;{{comment.likes}}&lt;/span&gt; &#13;
              &lt;/li&gt; &#13;
              &lt;/ul&gt;` &#13;
          }); &#13;
</pre></li><li class="listitem">Run Protractor and confirm that the tests pass!</li></ol></div><p>The page now looks like the following screenshot:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_004.jpg" alt="Make it run"/></div><p>
</p><p>Compared with the diagram at the beginning of this chapter, all the features have been created. Now that we've made the test pass in Protractor, we need to check the unit tests to ensure that our changes didn't break the them.</p><div class="section" title="Fixing the unit tests"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec34"/>Fixing the unit tests</h3></div></div></div><p>One of the primary changes required was to make the comment an object consisting of a value and the number of likes. Before thinking too much about how the unit tests could have been affected, let's kick them off. Execute the following command:</p><pre class="programlisting">
<span class="strong"><strong>$ karma start</strong></span>
</pre><p>As expected, the error is related to the new <code class="literal">comment</code> object:</p><pre class="programlisting">
<span class="strong"><strong>$ Expected { value : 'a sample comment', likes : 0 } to be &#13;
    'a sample comment'.</strong></span>
</pre><p>Reviewing the expectation, it seems like the only thing required is for <code class="literal">comment.value</code> to be used in the expectation, as opposed to the <code class="literal">comment</code> object itself. Change the expectation as follows:</p><pre class="programlisting">it('',() =&gt; { &#13;
    var firstComment = app.comments[0]; &#13;
    expect(firstComment.title).toBe('a sample comment'); &#13;
}) &#13;
</pre><p>Save the file and check the Karma output. Confirm that the test passes. Both the Karma and Protractor tests pass, and we have completed the primary user behaviors of adding a comment and liking it. We are now free to move on to the next step and make things better.</p></div></div><div class="section" title="Make it better"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec94"/>Make it better</h2></div></div></div><p>All in all, the approach ended with the result we wanted. Users are now able to like a comment in the UI and see the number of likes. The major thing from a refactor standpoint is that we have not unit-tested the <code class="literal">like</code> method.</p><p>Reviewing our development to-do list, we see that the list is an action that we wrote down. Before completely wrapping up the feature, let's discuss the option of adding a unit test for the <code class="literal">like</code> functionality.</p></div><div class="section" title="Coupling the test"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec95"/>Coupling the test</h2></div></div></div><p>As already discussed, tests are tightly coupled to the implementation. This is a good thing when there is a complicated logic involved or we need to ensure that certain aspects of the application behave in certain ways. It is important to be aware of the coupling and know when it is important to bring it into the application and when it is not. The <code class="literal">like</code> function, which we created, simply increments a counter on an object. This can be easily tested; however, the coupling that we will bring in with a unit test will not give us the extra value.</p><p>In this case, we will not add another unit test for the <code class="literal">like</code> method. As the application progresses, we may find the need to add a unit test in order to develop and extend the function.</p><p>Here are some things I consider when adding a test:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Does adding a test outweigh the cost of maintaining it?</li><li class="listitem" style="list-style-type: disc">Is the test adding value to the code?</li><li class="listitem" style="list-style-type: disc">Does it help other developers understand the code better?</li><li class="listitem" style="list-style-type: disc">Is the functionality being tested in some or the other way?</li></ul></div><p>Based on our decision, there is no more refactoring or testing required. In the next section, we will take a step back and review the main points of this chapter.</p></div></div>
<div class="section" title="Self-test questions"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec49"/>Self-test questions</h1></div></div></div><p>Q1. Karma needs the Selenium WebDriver to run tests.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">True</li><li class="listitem" style="list-style-type: disc">False</li></ul></div><p>Q2. Given the following code segment, how would you select the following button:</p><pre class="programlisting">    &lt;button type="button"&gt;Click Me&lt;/button&gt;? &#13;
</pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">element.all(by.button('button'))</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">element.all(by.css('type=button'))</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">element(by.buttonText('Click Me')</code></li></ul></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec50"/>Summary</h1></div></div></div><p>In this chapter, we walked through the TDD techniques of using Protractor and Karma together. As the application was developed, we were able to see where, why, and how to apply TDD testing tools and techniques.</p><p>The approach, top-down, was different from the bottom-up approach discussed in <a class="link" href="ch03.html" title="Chapter 3. The Karma Way">Chapter 3</a>, <span class="emphasis"><em>The Karma Way</em></span>, and <a class="link" href="ch04.html" title="Chapter 4. End-to-End Testing with Protractor">Chapter 4</a>, <span class="emphasis"><em>End-to-End Testing with Protractor</em></span>. With the bottom-up approach, the specifications are used to build unit tests and then build the UI layer on top of that. In this chapter, a top-down approach was shown to focus on the user's behavior.</p><p>The top-down approach tests the UI and then filters the development through the other layers. Both the approaches have their merits. When applying TDD, it is essential to know how to use both. In addition to walking through a different TDD approach, we saw some of the core testing components of Angular, such as the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Testing a component from end-to-end and unit perspectives</li><li class="listitem" style="list-style-type: disc">Importing a component class to the test suite and initiating it for unit testing</li><li class="listitem" style="list-style-type: disc">Protractor's ability to bind to <code class="literal">ngModel</code>, send keystrokes to input columns, and get an element's text by its inner HTML code and all subelements</li></ul></div><p>The next chapter will build on the techniques used here and look into headless browser testing, advanced techniques for Protractor, and how to test Angular routes.</p></div></body></html>