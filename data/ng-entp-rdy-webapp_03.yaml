- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Creating a Basic Angular App
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建基本的 Angular 应用
- en: In this chapter, we'll design and build a simple Local Weather app using Angular
    and a third-party web API with an iterative development methodology. We'll focus
    on delivering value first while learning about the nuances and optimal ways of
    using Angular, TypeScript, Visual Studio (VS) Code, Reactive Programming, and
    RxJS. Before we dive into coding, we need to build a roadmap of features, create
    a mock-up of the application we intend to build, and diagram the high-level architecture
    of our app.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 Angular 和第三方 Web API 以及迭代开发方法设计并构建一个简单的本地天气应用。我们将专注于首先交付价值，同时了解 Angular、TypeScript、Visual
    Studio (VS) Code、响应式编程和 RxJS 的细微差别和最佳使用方式。在我们开始编码之前，我们需要构建一个功能路线图，创建我们打算构建的应用的
    mock-up，并绘制我们应用的高级架构图。
- en: You'll be introduced to Angular fundamentals to build a simple web app and become
    familiar with the new Angular platform and full-stack architecture.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 您将了解 Angular 基础知识以构建一个简单的 Web 应用，并熟悉新的 Angular 平台和全栈架构。
- en: 'In this chapter, you are going to learn the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下内容：
- en: Planning out your roadmap using GitHub projects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 GitHub 项目规划您的路线图
- en: Using a Kanban board to enable collaboration and effortless information radiation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用看板板来启用协作和无缝的信息辐射
- en: Crafting a new UI element to display current weather information using Angular
    components and TypeScript interfaces
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Angular 组件和 TypeScript 接口制作一个新的 UI 元素来显示当前天气信息
- en: Using Angular services and `HttpClient` to retrieve data from `OpenWeatherMap`
    APIs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Angular 服务和 `HttpClient` 从 `OpenWeatherMap` API 获取数据
- en: Leveraging observable streams to transform data using RxJS
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用可观察流使用 RxJS 转换数据
- en: Null guarding in Angular
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 中的空值保护
- en: The most up-to-date versions of the sample code for the book are on GitHub at
    the repository linked below. The repository contains the final and completed state
    of the code. You can verify your progress at the end of this chapter by looking
    for the end-of-chapter snapshot of code under the `projects` folder.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 书中样本代码的最新版本可在以下链接的 GitHub 仓库中找到。该仓库包含代码的最终和完成状态。您可以在本章末尾通过查找 `projects` 文件夹下的章节末尾代码快照来验证您的进度。
- en: 'For *Chapter 3*:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 *第 3 章*：
- en: Clone the repository [https://github.com/duluca/local-weather-app](https://github.com/duluca/local-weather-app).
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆仓库 [https://github.com/duluca/local-weather-app](https://github.com/duluca/local-weather-app)。
- en: Execute `npm install` on the root folder to install dependencies.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根文件夹中执行 `npm install` 以安装依赖项。
- en: 'The code sample for this chapter is under the sub-folder:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本章的代码示例位于子文件夹：
- en: '[PRE0]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To run the Angular app for this chapter, execute:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行本章的 Angular 应用，请执行：
- en: '[PRE1]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Beware that the source code in the book or on GitHub may not always match the
    code generated by Angular CLI. There may also be slight differences in implementation
    between the code in the book and what's on GitHub because the ecosystem is ever-evolving.
    It is natural for the sample code to change over time. Also, on GitHub, expect
    to find corrections, fixes to support newer versions of libraries, or side-by-side
    implementations of multiple techniques for the reader to observe. The reader is
    only expected to implement the ideal solution recommended in the book. If you
    find errors or have questions, please create an issue or submit a pull request
    on GitHub for the benefit of all readers.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，书中或 GitHub 上的源代码可能并不总是与 Angular CLI 生成的代码相匹配。由于生态系统不断演变，书中代码和 GitHub 上的代码在实现上可能也存在细微差异。样本代码随时间变化是自然的。在
    GitHub 上，您可能会找到更正、修复以支持库的新版本，或者为读者观察而并排实现多种技术的示例。读者只需实现书中推荐的理想解决方案即可。如果您发现错误或有疑问，请创建一个
    issue 或在 GitHub 上提交一个 pull request，以惠及所有读者。
- en: You can read more about updating Angular in *Appendix C*, *Keeping Angular and
    Tools Evergreen*. You can find this appendix online from [https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen.pdf](https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen.)
    or at [https://expertlysimple.io/stay-evergreen](https://expertlysimple.io/stay-evergreen).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 *附录 C* 中了解更多关于更新 Angular 的信息，即 *保持 Angular 和工具始终如一*。您可以从 [https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen.pdf](https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen.)
    或 [https://expertlysimple.io/stay-evergreen](https://expertlysimple.io/stay-evergreen)
    在线找到此附录。
- en: Let's start by creating a high-level plan to understand what to implement before
    you start coding.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先制定一个高级计划，以便在您开始编码之前了解要实现的内容。
- en: Planning using Kanban and GitHub projects
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用看板和GitHub项目进行规划
- en: Having a roadmap before getting on the road is critical in ensuring that you
    reach your destination. Similarly, building a rough plan of action before you
    start coding is very important in ensuring project success. Building a plan early
    on enables your colleagues or clients to be aware of what you're planning to accomplish.
    However, any initial plan is guaranteed to change over time.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在上路之前有一个路线图对于确保你达到目的地至关重要。同样，在开始编码之前制定一个粗略的行动计划对于确保项目成功非常重要。尽早制定计划可以让你的同事或客户了解你打算完成什么。然而，任何初始计划都注定会随着时间的推移而改变。
- en: Agile software development aims to account for the change of priorities and
    features over time. Kanban and Scrum are the two most popular methodologies that
    you can use to manage your project. Each methodology has a concept of a backlog
    and lists that capture planned, in progress, and completed work. A backlog, which
    contains a prioritized list of tasks, establishes a shared understanding of what
    needs to be worked on next. Lists that capture the status of each task act as
    information radiators, where stakeholders can get updates without interrupting
    your workflow. Whether you're building an app for yourself or someone else, keeping
    a live backlog and tracking the progress of tasks pays dividends and keeps the
    focus on the goal you're trying to achieve.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 敏捷软件开发旨在随着时间的推移考虑优先级和功能的变更。看板和Scrum是你可以使用来管理项目的两种最流行的方法。每种方法都有一个待办事项的概念，并列出计划、进行中和已完成的工作。包含优先级任务列表的待办事项建立了一个关于接下来需要做什么的共享理解。捕获每个任务状态的列表充当信息辐射器，利益相关者可以在不打扰你的工作流程的情况下获取更新。无论你是为自己还是为他人构建应用程序，保持待办事项的实时状态并跟踪任务的进度都会带来回报，并保持对你要实现的目标的关注。
- en: In implementing the Local Weather app, we are going to leverage a GitHub project
    to act as a Kanban board. In an enterprise, you can use ticketing systems or tools
    that can keep a backlog, implement the Scrum methodology, and display Kanban boards.
    In GitHub, issues represent your backlog. You can leverage the built-in **Projects**
    tab to define a scope of work that represents a release or a sprint to establish
    a Kanban board. A GitHub project directly integrates with your GitHub repository's
    issues and keeps track of the status of issues via labels. This way, you can keep
    using the tool of your choice to interact with your repository and still, effortlessly,
    radiate information. In the next section, you are going to set up a project to
    achieve this goal.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现本地天气应用时，我们将利用GitHub项目作为看板。在企业中，你可以使用票据系统或能够保持待办事项、实施敏捷方法学和显示看板工具。在GitHub中，问题代表你的待办事项。你可以利用内置的**项目**标签页来定义一个代表发布或迭代的范围，从而建立看板。GitHub项目直接集成到你的GitHub仓库的问题中，并通过标签跟踪问题的状态。这样，你就可以继续使用你选择的工具与你的仓库交互，并且毫不费力地传播信息。在下一节中，你将设置一个项目来实现这一目标。
- en: Setting up a GitHub project
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置GitHub项目
- en: 'Let''s set up a GitHub project:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置一个GitHub项目：
- en: Navigate to your GitHub repository in your browser.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中导航到你的GitHub仓库。
- en: Switch over to the **Projects** tab.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到**项目**标签页。
- en: Click on **Create a new project**, as shown in the screenshot that follows:![](img/B14094_03_01.png)
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建新项目**，如下面的截图所示![图片](img/B14094_03_01.png)
- en: 'Figure 3.1: Creating a new project in GitHub'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.1：在GitHub中创建新项目
- en: Provide a name in the **Project board name** box.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目看板名称**框中提供名称。
- en: Select a **Project template**, such as **Automated Kanban**.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个**项目模板**，例如**自动化看板**。
- en: Later in the book, we'll enable GitHub flow for your GitHub projects. With GitHub
    flow, changes to your repository are processed through **Pull Requests** (**PR**).
    In the future, you may want to select the **Automated Kanban with reviews** template,
    which automatically keeps track of the status of a PR, radiating more detailed
    information about the inner workings of the software development process.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本书的后面部分，我们将为你的GitHub项目启用GitHub流程。使用GitHub流程，你的仓库更改将通过**拉取请求**（**PR**）进行处理。在未来，你可能想选择**带有审查的自动化看板**模板，该模板自动跟踪PR的状态，传播更多关于软件开发过程内部运作的详细信息。
- en: Click on **Create project**.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建项目**。
- en: 'Observe your Kanban board, which should appear as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 观察你的看板，它应该如下所示：
- en: '![](img/B14094_03_02.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_03_02.png)'
- en: 'Figure 3.2: The Kanban board for your project'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2：你的项目看板
- en: If you have existing issues on your repository, you may be prompted to add cards
    to your board. You can safely ignore this for now and return to it with the **+
    Add cards** button. You are also presented with several **To do** cards. Feel
    free to review and dismiss these cards to clear out your board.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的仓库中已有现有问题，您可能会被提示将卡片添加到您的看板。现在您可以安全地忽略它，稍后再用 **+ 添加卡片** 按钮返回。您还会看到几个 **待办**
    卡片。您可以自由地审查并删除这些卡片以清理您的看板。
- en: If you would like to keep track of every release or sprint, you can create a
    new project for each one. Creating new projects helps keep track of percentage
    completion for a given release or sprint, at the cost of introducing additional
    management overhead.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想跟踪每个发布或冲刺，可以为每个创建一个新的项目。创建新项目有助于跟踪特定发布或冲刺的完成百分比，但这会引入额外的管理开销。
- en: Next, we are going to configure the project as a Kanban board instead of a GitHub
    Project, which is a lightweight methodology to organize your work you might choose
    over other methodologies like Scrum.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将配置项目为看板板而不是GitHub项目，这是一种轻量级的方法，可以组织您的工作，您可能会选择它而不是其他方法，如Scrum。
- en: Configuring a Kanban board
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置看板板
- en: Kanban does not define formal iterations or releases of your work. If you would
    like to have a low-overhead process, where you only work with a single project,
    you can do this by introducing a Backlog column to your project.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 看板不定义您工作的正式迭代或发布。如果您想有一个低开销的过程，只与一个项目工作，可以通过向项目中引入待办事项列来实现。
- en: 'Now let''s add a Backlog column:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个待办事项列：
- en: Click on **+ Add column**.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **+ 添加列**。
- en: For **Column name** enter `Backlog`.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **列名称** 中输入 `Backlog`。
- en: For **Preset** select **To do**.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 **预设** 选择 **待办**。
- en: Under **Move issues here when…**, select **Newly added**, as shown here:![A
    screenshot of a social media post  Description automatically generated](img/B14094_03_03.png)
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **当以下条件满足时移动问题到这里** 下，选择 **新添加的**，如图所示：![社交媒体帖子的截图 自动生成的描述](img/B14094_03_03.png)
- en: 'Figure 3.3: Where to select "Newly added"'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.3：选择“新添加”的位置
- en: Click on **Create column**.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **创建列**。
- en: Drag the column to become the leftmost column.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将列拖动到最左侧的位置。
- en: With this setup, new issues are added to the **Backlog**, allowing you to manually
    maintain the items you intend to work on in the **To do** column.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此设置，新问题被添加到 **待办事项** 中，允许您手动维护您打算在 **待办** 列表中工作的项目。
- en: Creating a backlog for the Local Weather app
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为本地天气应用程序创建待办事项列表
- en: Let's create a backlog of issues to keep track of your progress as you implement
    the design of your application. When creating issues, you should focus on delivering
    functional iterations that bring some value to the user.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个待办事项列表，以便在实现应用程序设计的过程中跟踪您的进度。在创建问题时，您应该专注于交付具有用户价值的功能性迭代。
- en: The technical hurdles you must clear to achieve those results are of no interest
    to your users or clients.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须克服的技术障碍对您的用户或客户没有兴趣。
- en: 'Here are the features we plan to build in our first release:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们在首次发布中计划构建的功能：
- en: Display current location weather information for the current day
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示当天的当前位置天气信息
- en: Display forecast information for the current location
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示当前位置的预报信息
- en: Add city search capability so that users can see weather information for other cities
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加城市搜索功能，以便用户可以看到其他城市的天气信息
- en: Add a preferences pane to store the default city for the user
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个偏好设置面板以存储用户的默认城市
- en: Improve the UX of the app with Angular Material
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Angular Material改进应用程序的UX
- en: 'Let''s also add some features that we won''t implement in this book as a way
    to demonstrate how a backlog can capture your ideas:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再添加一些我们不会在本书中实现的功能，以此展示待办事项如何捕捉您的想法：
- en: Add authentication so that users can retrieve data from any browser
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加身份验证，以便用户可以从任何浏览器检索数据
- en: Add HTML5 Geolocation support
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加HTML5地理位置支持
- en: Use `localStorage` to cache user preferences
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `localStorage` 缓存用户偏好设置
- en: Feel free to add other features you can think of to your backlog.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以自由地向待办事项添加您能想到的其他功能。
- en: 'Begin by creating the preceding features as issues on GitHub. Make sure to
    assign each new issue to the project you created earlier in the chapter. Once
    created, move the preceding defined features to the **To do** column. When you
    begin working on a task, move the card into the **In progress** column and when
    it''s completed, move it to the **Don**e column. The following is what the board
    looks like as we plan to begin working on the first feature – *Display Current
    Location weather information for the current day*:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将前面的功能作为GitHub上的问题创建。确保将每个新问题分配给本章早期创建的项目。一旦创建，将前面定义的功能移动到**待办**列。当您开始处理一个任务时，将卡片移动到**进行中**列，当它完成时，将其移动到**完成**列。以下是我们计划开始工作的第一个功能——*显示当前日期当前位置的天气信息*的板子样子：
- en: '![](img/B14094_03_04.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_03_04.png)'
- en: 'Figure 3.4: A snapshot of the initial state of the board on GitHub'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4：GitHub上板子初始状态的一张快照
- en: Note that I also added an issue to **Create a mock-up for the app** and moved
    it to **Done**, which is something I'll cover in the next section. Also, GitHub
    might automatically move a card from one state to another as you open and close
    them.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我还添加了一个创建应用原型的问题，并将其移动到**完成**状态，这将在下一节中介绍。此外，GitHub可能会在您打开和关闭它们时自动将卡片从一个状态移动到另一个状态。
- en: Ultimately, GitHub projects provide an easy-to-use GUI so that non-technical
    people can easily interact with GitHub issues. By allowing non-technical people
    to participate in the development process on GitHub, you unlock the benefits of
    GitHub becoming the single source of information for your entire project. Questions,
    answers, and discussions about features and issues are all tracked as part of
    GitHub issues, instead of being lost in emails. You can also store wiki-type documentation
    on GitHub. So, by centralizing all project-related information, data, conversations,
    and artifacts on GitHub, you are greatly simplifying the potentially complicated
    interaction of multiple systems that require continued maintenance at a high cost.
    For private repositories and on-premise enterprise installations, GitHub has a
    very reasonable cost. If you're sticking with open source, as we are in this chapter,
    all these tools are free.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，GitHub项目提供了一个易于使用的图形用户界面，以便非技术人员可以轻松地与GitHub问题进行交互。通过允许非技术人员参与GitHub上的开发过程，您可以解锁GitHub成为您整个项目单一信息源的好处。关于功能和问题的疑问、答案和讨论都被跟踪为GitHub问题的组成部分，而不是在电子邮件中丢失。您还可以在GitHub上存储类似维基的文档。因此，通过在GitHub上集中所有项目相关的信息、数据、对话和工件，您极大地简化了需要持续维护且成本高昂的多个系统的复杂交互。对于私有仓库和本地企业安装，GitHub的成本非常合理。如果您坚持开源，就像我们在本章中所做的那样，所有这些工具都是免费的。
- en: As a bonus, I created a rudimentary wiki page on my repository at [https://github.com/duluca/local-weather-app/wiki](https://github.com/duluca/local-weather-app/wiki).
    Note that you can't upload images to `README.md` or wiki pages. To get around
    this limitation, you can create a new issue, upload an image in a comment, and
    copy and paste the URL for it to embed images to `README.md` or wiki pages. In
    the sample wiki, I followed this technique to embed the wireframe design into
    the page.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外的好处，我在我的仓库[https://github.com/duluca/local-weather-app/wiki](https://github.com/duluca/local-weather-app/wiki)上创建了一个基本的维基页面。请注意，您不能上传图片到`README.md`或维基页面。为了克服这一限制，您可以创建一个新的问题，在评论中上传一张图片，并将它的URL复制粘贴到`README.md`或维基页面上以嵌入图片。在示例维基中，我遵循了这种技术将线框设计嵌入到页面中。
- en: With a roadmap in place, you're now ready to create a mock-up of your application.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在有了路线图之后，您现在可以开始创建您应用程序的原型了。
- en: Wireframe design
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线框设计
- en: 'There are some great tools out there to do rough-looking mock-ups to demonstrate
    your idea with surprising amounts of rich functionality. If you have a dedicated
    UX designer, such tools are great for creating quasi prototypes. However, as a
    full-stack developer, I find the best tool out there to be pen and paper. This
    way, you don''t have to learn **yet another tool** (**YAT**), and it is a far
    better alternative to having no design at all. Putting things on paper saves you
    from costly coding detours down the line and if you can validate your wireframe
    design with users ahead of time, even better. My app is called LocalCast Weather,
    but get creative and pick your own name. Behold, the wireframe design for your
    weather app:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有很多优秀的工具可以制作看起来粗糙的模型，用丰富的功能来展示你的想法。如果你有一个专门的UX设计师，这些工具对于创建准原型来说非常棒。然而，作为一个全栈开发者，我发现最好的工具还是笔和纸。这样，你不必学习**另一个工具**（**YAT**），而且这比完全没有设计要好得多。将事物放在纸上可以避免未来昂贵的编码错误，如果你能在用户验证你的线框设计之前就进行验证，那就更好了。我的应用叫做LocalCast
    Weather，但请发挥创意，选择你自己的名字。看看，这是你的天气应用的线框设计：
- en: '![](img/B14094_03_05.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_03_05.png)'
- en: 'Figure 3.5: Hand-drawn wireframe for LocalCast. (Tip: I did use a ruler!)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5：LocalCast的手绘线框图。（提示：我确实使用了尺子！）
- en: The wireframe shouldn't be anything fancy. I recommend starting with a hand-drawn
    design, which is very quick to do and carries over the rough outlines effectively.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 线框不需要太花哨。我建议从手绘设计开始，这非常快，而且能有效地传达粗略的轮廓。
- en: There are great wireframing tools out there. I suggest and use a couple of them
    throughout this book, however, in the first days of your project, every hour matters.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有很多优秀的线框工具。我在这本书中建议并使用其中几个，然而，在你项目的最初几天，每一小时都很重要。
- en: Granted, this kind of rough design may never leave the boundaries of your team,
    but please know that nothing beats getting that instantaneous feedback and collaboration
    by putting your ideas down on paper or a whiteboard.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种粗略的设计可能永远不会超出你团队的边界，但请知道，没有什么能比将你的想法写在纸上或白板上更快地获得即时反馈和协作。
- en: High-level architecture
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级架构
- en: No matter how small or large your project is, it is critical to start with a
    sound architecture that can scale if duty calls. Most of the time, you can't accurately
    predict the size of your project ahead of time. Sticking to the architectural
    fundamentals discussed in *Chapter 1*, *Introduction to Angular and Its Concepts*,
    results in an architecture that is not overly burdensome, so you can quickly execute
    a simple app idea. The key is to ensure proper decoupling from the get-go.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你的项目大小如何，开始时有一个可以扩展的坚实基础架构至关重要。大多数时候，你无法提前准确预测项目的大小。坚持在*第一章*，*Angular及其概念简介*中讨论的架构基础，可以导致一个不会过于繁重的架构，这样你可以快速执行一个简单的应用想法。关键是从一开始就确保适当的解耦。
- en: In my view, there are two types of decoupling. One is soft-decoupling, where
    a "Gentlemen's Agreement" is made not to mix concerns and you try and not mess
    up the code base. This can apply to the code you write, all the way to infrastructure-level
    interactions. If you maintain your frontend code under the same code structure
    as your backend code, and if you let your REST server serve up your frontend application,
    then you are only practicing soft-decoupling.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，解耦有两种类型。一种叫做软解耦，这里指的是通过“绅士协议”来避免混合关注点，并尽量不破坏代码库。这可以应用到你所编写的代码，甚至到基础设施级别的交互。如果你让你的前端代码与后端代码保持相同的代码结构，并且如果你的REST服务器提供前端应用服务，那么你只是在实践软解耦。
- en: 'You should instead practice hard-decoupling, which means frontend code lives
    in a separate repository, never calls the database directly, and is hosted on
    its web server altogether. This way, you can be sure that, at all times, your
    REST APIs or your frontend code is entirely replaceable and independent of other
    code. Practicing hard-decoupling has monetary and security benefits as well. The
    serving and scaling needs of your frontend application are guaranteed to be different
    from your backend, so you can optimize your host environment appropriately and
    save money. If you whitelist access to your REST APIs to only the calls originating
    from your frontend servers, you will vastly improve your security. Consider the
    following high-level architecture diagram for our LocalCast Weather app:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该练习严格的解耦，这意味着前端代码位于一个独立的仓库中，永远不会直接调用数据库，并且完全托管在其自己的Web服务器上。这样，你可以确保在任何时候，你的REST
    API或前端代码都是完全可替换的，并且独立于其他代码。练习严格的解耦也有货币和安全方面的好处。你前端应用程序的托管和扩展需求肯定与后端不同，因此你可以相应地优化你的主机环境并节省资金。如果你只允许来自你的前端服务器的调用访问你的REST
    API，你将大大提高你的安全性。考虑以下我们LocalCast天气应用的高级架构图：
- en: '![](img/B14094_03_06.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_03_06.png)'
- en: 'Figure 3.6: LocalCast high-level architecture'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6：LocalCast高级架构
- en: The high-level architecture shows that our Angular web application is completely
    decoupled from any backend. It is hosted on its web server, can communicate with
    a web API such as **OpenWeatherMap**, or optionally be paired with a backend infrastructure
    to unlock rich and customized features that a web API alone can't provide, such
    as storing per-user preferences or complementing the OpenWeatherMap API's dataset
    with our own.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 高级架构显示，我们的Angular Web应用完全解耦于任何后端。它托管在其自己的Web服务器上，可以与Web API（如**OpenWeatherMap**）通信，或者可选地与后端基础设施配对，以解锁Web
    API单独无法提供的丰富和定制化功能，例如存储每个用户的偏好或用我们自己的数据集补充OpenWeatherMap API的数据集。
- en: Regardless of your backend technology, I recommend that your frontend always
    resides in its repository, and is served using its web server that does not depend
    on your API server.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你的后端技术是什么，我建议你的前端始终位于其仓库中，并使用不依赖于你的API服务器的Web服务器进行托管。
- en: In *Chapter 10*, *RESTful APIs and Full-Stack Implementation*, you'll deep-dive
    into learning how a MEAN stack application, using MongoDB, Express, Angular, and
    Node, comes together in practice.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在第10章“RESTful API和全栈实现”中，你将深入了解如何将MongoDB、Express、Angular和Node组成的MEAN栈应用在实践中结合起来。
- en: Now that we have our features, wireframe designs, and high-level architecture
    in place, we can start implementing our app.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了我们的功能、线框设计和高级架构，我们可以开始实现我们的应用。
- en: Crafting UI elements using components and interfaces
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用组件和接口制作UI元素
- en: In *Chapter 2*, *Setting Up Your Development Environment*, you should have created
    an Angular application. We'll use that as our starting point. If you haven't done
    so, please go back to *Chapter 2, Setting Up Your Development Environment*, and
    create your project.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2章“设置你的开发环境”中，你应该已经创建了一个Angular应用。我们将以此作为起点。如果你还没有这样做，请回到第2章“设置你的开发环境”，并创建你的项目。
- en: In this section, you'll leverage Angular components, interfaces, and services
    to build the current weather feature in a decoupled, cohesive, and encapsulated
    manner.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将利用Angular组件、接口和服务以解耦、一致和封装的方式构建当前天气功能。
- en: The landing page of an Angular app, by default, resides in `app.component.html`.
    So, start by editing the template of `AppComponent` with basic HTML, laying out
    the initial landing experience for the application.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Angular应用的着陆页位于`app.component.html`。因此，首先通过基本的HTML编辑`AppComponent`的模板，为应用布局初始着陆体验。
- en: 'We are now beginning the development of Feature 1: **Display Current Location
    weather information for the current day** so you can move the card in the Github
    project to the **In progress** column.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在开始开发功能1：**显示当前日期的当前位置天气信息**，这样你就可以将GitHub项目中的卡片移动到**进行中**列。
- en: Delete any existing code in the template file `app.component.html`
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除模板文件`app.component.html`中任何现有的代码
- en: 'Add a header as an `h1` tag, followed by the tagline of our app as a `div`,
    and placeholders for where we may want to display the current weather, demonstrated
    as shown in the following code block:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`h1`标签作为标题，然后是我们的应用标语作为`div`标签，以及我们可能想要显示当前天气的占位符，如下面的代码块所示：
- en: '[PRE2]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Remove the unused `title` property from the `component` class, so it's empty
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`component`类中移除未使用的`title`属性，使其为空
- en: '[PRE3]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the terminal, execute `npm start`
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中执行`npm start`
- en: Navigate to `http://localhost:5000` on your browser
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的浏览器中导航到`http://localhost:5000`
- en: You should now be able to observe the changes you're making in real time in
    the browser.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能够在浏览器中实时观察你所做的更改。
- en: Note that you should use the integrated terminal within VS Code to run commands,
    so you don't have to jump around different windows. Use [`CTRL`+`` ` ``] on Windows
    or [`^`+`` ` ``] on Mac to bring the terminal up. In case you're not familiar,
    `` ` `` is a backtick and is usually on the same key as `~` (tilde).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你应该使用VS Code中的集成终端来运行命令，这样你就不必在不同的窗口之间跳转。在Windows上使用`[CTRL] + `` ` ```，在Mac上使用`[^]
    + `` ` ```来打开终端。如果你不熟悉，`` ` ``是一个反引号，通常与`~`（波浪号）在同一键上。
- en: Adding an Angular component
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加Angular组件
- en: We need to display the current weather information, where `<div>current weather</div>`
    is located. To achieve this, we need to build a component that is responsible
    for displaying the weather data.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要显示当前的天气信息，其中`<div>current weather</div>`所在的位置。为了实现这一点，我们需要构建一个负责显示天气数据的组件。
- en: 'The reason behind creating a separate component is an architectural best practice
    that is codified in the **Model-View-ViewModel** (**MVVM**) design pattern. You
    may have heard of the **Model-View-Controller** (**MVC**) pattern before. The
    vast majority of web-based code written circa 2005-2015 was written following
    the MVC pattern. MVVM differs from the MVC pattern in meaningful ways, as I explained
    in my 2013 article on DevPro:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 创建独立组件的原因是编码在**模型-视图-视图模型**（**MVVM**）设计模式中的架构最佳实践。你可能之前听说过**模型-视图-控制器**（**MVC**）模式。大约在2005-2015年间编写的绝大多数基于Web的代码都是按照MVC模式编写的。MVVM模式与MVC模式在有意义的方式上有所不同，正如我在2013年DevPro上的文章中解释的那样：
- en: An effective implementation of MVVM inherently enforces proper separation of
    concerns. Business logic is clearly separated from presentation logic. So, when
    a View is developed, it stays developed, because fixing a bug in one View's functionality
    doesn't impact other views. On the flip side, if [you use] visual inheritance
    effectively and [create] reusable user controls, fixing a bug in one place can
    fix issues throughout the application.
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: MVVM的有效实现内在地强制执行适当的关注点分离。业务逻辑与表示逻辑明显分离。因此，当开发视图时，它将保持开发状态，因为修复一个视图功能中的错误不会影响其他视图。另一方面，如果你有效地使用视觉继承并创建可重用的用户控件，修复一个地方中的错误可以修复整个应用程序中的问题。
- en: 'Angular provides a practical implementation of MVVM:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供了MVVM的实用实现：
- en: ViewModels neatly encapsulate any presentation logic and allow for simpler View
    code by acting as a specialized version of the model. The relationship between
    a View and ViewModel is straightforward, allowing more natural ways to wrap UI
    behavior in reusable user controls.
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 视图模型优雅地封装了任何表示逻辑，并通过充当模型的专用版本来允许更简单的视图代码。视图和视图模型之间的关系简单明了，允许更自然地将UI行为封装在可重用的用户控件中。
- en: You can read more about the architectural nuance, with illustrations, at [http://bit.ly/MVVMvsMVC](http://bit.ly/MVVMvsMVC).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[http://bit.ly/MVVMvsMVC](http://bit.ly/MVVMvsMVC)上阅读更多关于架构细微差别和插图的信息。
- en: 'Next, you create your very first Angular component, which includes the View
    and the ViewModel, using the Angular CLI''s `ng generate` command:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你使用Angular CLI的`ng generate`命令创建你的第一个Angular组件，该组件包括视图和视图模型：
- en: In the terminal, execute `npx ng generate component current-weather`
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中执行`npx ng generate component current-weather`
- en: Ensure that you are executing `ng` commands under the `local-weather-app` folder,
    and not under the parent folder where you initialized the project. Also, note
    that `npx ng generate component current-weather` can be rewritten as `ng g c current-weather`.
    This book utilizes the shorthand format going forward and expects you to prepend
    `npx`, if necessary.
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保你是在`local-weather-app`文件夹下执行`ng`命令，而不是在初始化项目的父文件夹下。此外，请注意`npx ng generate
    component current-weather`可以重写为`ng g c current-weather`。本书将使用简写格式并期望你在必要时添加`npx`。
- en: 'Observe the new files created in your `app` folder:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察在`app`文件夹中创建的新文件：
- en: '[PRE4]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A generated component has four parts:'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 生成的组件有四个部分：
- en: '`current-weather.component.css` contains any CSS that is specific to the component
    and is an optional file.'
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`current-weather.component.css`包含任何特定于组件的CSS，这是一个可选文件。'
- en: '`current-weather.component.html` contains the HTML template that defines the
    look of the component and rendering of the bindings and can be considered the
    View, in combination with any CSS styles used.'
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`current-weather.component.html` 包含定义组件外观和绑定渲染的 HTML 模板，可以被认为是 View，结合任何使用的
    CSS 样式。'
- en: '`current-weather.component.spec.ts` contains Jasmine-based unit tests that
    you can extend to test your component functionality.'
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`current-weather.component.spec.ts` 包含基于 Jasmine 的单元测试，你可以扩展这些测试来测试你的组件功能。'
- en: '`current-weather.component.ts` contains the `@Component` decorator above the
    class definition and is the glue that ties together the CSS, HTML, and JavaScript
    code. The class itself can be considered the ViewModel, pulling data from services
    and performing any necessary transformations to expose sensible bindings for the
    View, shown as follows:'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`current-weather.component.ts` 包含在类定义之上的 `@Component` 装饰器，并且是连接 CSS、HTML 和
    JavaScript 代码的粘合剂。这个类本身可以被视为 ViewModel，从服务中获取数据并执行任何必要的转换，以便为 View 提供合理的绑定，如下所示：'
- en: '[PRE5]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If the component you''re planning to write is a simple one, you can write it
    using inline styles and an inline template to simplify the structure of your code.
    If we were to rewrite the component above using inline templates and styles, it
    would look like the following example:'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你计划编写的组件很简单，你可以使用内联样式和内联模板来简化你的代码结构。如果我们使用内联模板和样式重写上面的组件，它将看起来像以下示例：
- en: '[PRE6]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: However, we won't be inlining this template. So, keep your generated code as-is.
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，我们不会内联这个模板。所以，保持你的生成代码不变。
- en: Note that the template is surrounded by the backtick character, `` ` ``, instead
    of a single-quote character. The backtick character defines a template literal,
    which allows newlines to be defined without having to concatenate strings with
    a plus operator. You can read more about template literals at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals).
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，模板被反引号字符 `` ` `` 包围，而不是单引号字符。反引号字符定义了一个模板字面量，允许定义换行而不必使用加号运算符连接字符串。你可以在 [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
    上了解更多关于模板字面量的信息。
- en: 'When you executed the `generate` command, in addition to creating the component,
    the command also added the new component you created in the app''s root module,
    `app.module.ts`, avoiding the otherwise tedious task of wiring up components together:'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你执行 `generate` 命令时，除了创建组件外，该命令还将在应用程序的根模块 `app.module.ts` 中添加你创建的新组件，从而避免了将组件连接在一起的繁琐任务：
- en: '[PRE7]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The bootstrap process of Angular is, admittedly, a bit convoluted. This is the
    chief reason the Angular CLI exists. `index.html` contains an element named `<app-root>`.
    When Angular begins execution, it first loads `main.ts`, which configures the
    framework for browser use and loads the app module. The app module then loads
    all its dependencies and renders within the aforementioned `<app-root>` element.
    In *Chapter 7*, *Creating a Router-First Line-of-Business App*, when we build
    a line-of-business app, we create feature modules to take advantage of the scalability
    features of Angular.
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Angular 的引导过程确实有些复杂。这正是 Angular CLI 存在的主要原因。`index.html` 包含一个名为 `<app-root>`
    的元素。当 Angular 开始执行时，它首先加载 `main.ts`，该文件配置了框架以供浏览器使用并加载应用程序模块。然后应用程序模块加载所有其依赖项，并在上述
    `<app-root>` 元素内渲染。在 *第 7 章*，*创建以路由为第一线的业务应用* 中，当我们构建业务应用时，我们创建功能模块以利用 Angular
    的可伸缩性功能。
- en: Now, we need to display our new component on the initial `AppComponent` template,
    so it is visible to the end user.
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们需要在初始的 `AppComponent` 模板中显示我们的新组件，以便最终用户可以看到。
- en: 'Add the `CurrentWeatherComponent` to `AppComponent` by replacing `<div>current
    weather</div>` with `<app-current-weather></app-current-weather>`:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将 `<div>current weather</div>` 替换为 `<app-current-weather></app-current-weather>`
    来将 `CurrentWeatherComponent` 添加到 `AppComponent`：
- en: '[PRE8]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If everything worked correctly, you should see this:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切正常，你应该会看到以下内容：
- en: '![](img/B14094_03_07.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_03_07.png)'
- en: 'Figure 3.7: Initial render of your Local Weather app'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7：本地天气应用的初始渲染
- en: Note the icon and name in the tab of the browser window. As a web development
    norm, in the `index.html` file, update the `<title>` tag and the `favicon.ico`
    file with the name and icon of your application to customize the browser tab information.
    If your favicon doesn't update, append the `href` attribute with a unique version
    number, such as `href="favicon.ico?v=2"`. As a result, your app will start to
    look like a real web app, instead of a CLI-generated starter project.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意浏览器窗口标签页中的图标和名称。作为网络开发的标准，在`index.html`文件中，更新`<title>`标签和`favicon.ico`文件以包含应用程序的名称和图标，以自定义浏览器标签页信息。如果你的favicon没有更新，请将`href`属性附加一个唯一的版本号，例如`href="favicon.ico?v=2"`。结果，你的应用程序将开始看起来像一个真正的网络应用程序，而不是CLI生成的启动项目。
- en: Now that you have seen an Angular component in action, let's cover some basics
    of what is going on under the covers.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经看到了Angular组件的实际应用，让我们来了解一下其背后的基础知识。
- en: Demystifying Angular components
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 揭秘Angular组件
- en: As discussed in *Chapter 1*, *Introduction to Angular and Its Concepts*, an
    Angular component is implemented as an ES2015 class, which allows us to leverage
    OOP concepts. Classes are traditionally present in strongly-typed languages, so
    it is excellent that JavaScript implements classes as a dynamically typed language.
    Classes allow us to group (encapsulate) functionality and behavior in self-contained
    units (objects). We can define the behavior in very generalized and abstract ways
    and implement an inheritance hierarchy to share and morph behavior into differing
    implementations.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在*第一章*，*Angular及其概念简介*中所述，Angular组件是以ES2015类的方式实现的，这使得我们能够利用面向对象编程（OOP）的概念。类在强类型语言中是传统存在的，因此JavaScript作为动态类型语言实现类是非常出色的。类允许我们将功能和行为封装在自包含的单元（对象）中。我们可以用非常通用和抽象的方式定义行为，并实现继承层次结构以共享和将行为转化为不同的实现。
- en: 'Considering the `CurrentWeatherComponent` class that follows, I can highlight
    some benefits of classes:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到下面的`CurrentWeatherComponent`类，我可以强调一些类的优点：
- en: '[PRE9]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Unlike a function, you can't directly use code within a class. It must be instantiated
    as an object with the new keyword. This means that we can have multiple instances
    of any given class and each object can maintain its internal state. In this case,
    Angular instantiates a component for us behind the scenes. A `constructor` of
    a class is executed at the time of its instantiation. You can put any code that
    initializes other classes or variables inside a constructor. However, you shouldn't
    make an HTTP call or attempt to access DOM elements from a constructor. This is
    where the `OnInit` life cycle hook comes into play.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 与函数不同，你无法直接在类中使用代码。它必须使用new关键字实例化为一个对象。这意味着我们可以有任意给定类的多个实例，每个对象都可以保持其内部状态。在这种情况下，Angular在幕后为我们实例化组件。类的`constructor`在其实例化时执行。你可以在构造函数中放置任何初始化其他类或变量的代码。然而，你不应该在构造函数中进行HTTP调用或尝试访问DOM元素。这就是`OnInit`生命周期钩子发挥作用的地方。
- en: As Angular is initializing `CurrentWeatherComponent` as an object, it is also
    going through the entire graph of modules, components, services, and other dependencies
    to ensure all interdependent code is loaded into memory. During this time, Angular
    can't yet guarantee the availability of HTTP or DOM access. After all classes
    are instantiated, Angular goes through the classes that are decorated with `@Component`,
    implements the `OnInit` interface, and calls the `ngOnInit` function within our
    class. This is why we need to put any code that needs HTTP or DOM access during
    the first load of our component into `ngOnInit`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当Angular初始化`CurrentWeatherComponent`为对象时，它也在遍历整个模块、组件、服务和其它依赖关系的图，以确保所有相互依赖的代码都被加载到内存中。在此期间，Angular还不能保证HTTP或DOM访问的可用性。所有类实例化完成后，Angular会遍历带有`@Component`装饰器的类，实现`OnInit`接口，并在我们的类中调用`ngOnInit`函数。这就是为什么我们需要将需要在组件首次加载时进行HTTP或DOM访问的任何代码放入`ngOnInit`中。
- en: Classes can have properties, variables, and functions. From an Angular template,
    you can access any property, variable, or function inside of an expression. The
    syntax of an expression looks like `{{ expression }}, [target]="expression", (event)="expression"`
    or `*ngIf="expression"`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 类可以有属性、变量和函数。从Angular模板中，你可以访问表达式中的任何属性、变量或函数。表达式的语法看起来像`{{ expression }}`，`[target]="expression"`，`(event)="expression"`或`*ngIf="expression"`。
- en: Now you have a good understanding of how the code, or the ViewModel, behind
    the template, the View, is instantiated and how you can access that code from
    the template. In the next section, we'll build an interface, which is a contract
    that defines the shape of an object.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经很好地理解了代码，或者模板背后的视图模型（ViewModel）是如何实例化的，以及你如何从模板中访问这段代码。在下一节中，我们将构建一个接口，这是一个定义对象形状的合约。
- en: Defining your model using interfaces
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用接口定义你的模型
- en: 'Now that your View and ViewModel are in place, you need to define your model.
    If you look back on the design, you''ll see that the component needs to display:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的视图（View）和视图模型（ViewModel）已经就绪，你需要定义你的模型。如果你回顾一下设计，你会看到该组件需要显示：
- en: City and country
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 城市和国家
- en: Current date
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前日期
- en: Current image
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前图像
- en: Current temperature
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前温度
- en: Current weather description
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前天气描述
- en: You first need to create an interface that represents this data structure. We
    are creating an interface instead of a class because an interface is an abstraction
    that does not contain any implementation. When creating touchpoints or passing
    data between various components, we can ensure a decoupled design if we rely on
    an abstract definition over an object that may implement unpredictable custom
    behavior, leading to bugs.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要创建一个表示这种数据结构的接口。我们创建接口而不是类，因为接口是一种不包含任何实现的抽象。在创建触摸点或在不同组件之间传递数据时，如果我们依赖于抽象定义而不是可能实现不可预测的自定义行为的对象，我们可以确保一个解耦的设计，这可能导致错误。
- en: 'Start by creating the interface:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建接口：
- en: In the terminal, execute `npx ng generate interface ICurrentWeather`
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中执行`npx ng generate interface ICurrentWeather`
- en: 'Observe a newly generated file named `icurrent-weather.ts` with an empty interface
    definition that looks like this:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察一个新创建的名为`icurrent-weather.ts`的文件，其中包含一个空接口定义，如下所示：
- en: '[PRE10]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is not an ideal setup, since we may add numerous interfaces to our app,
    and it can get tedious tracking down various interfaces. Over time, as you add
    concrete implementations of these interfaces as classes, it makes sense to put
    classes and their interfaces in their files.
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这不是一个理想的环境，因为我们可能会向我们的应用程序添加许多接口，跟踪各种接口可能会变得繁琐。随着时间的推移，当你将这些接口的具体实现作为类添加时，将类及其接口放在它们的文件中是有意义的。
- en: Why not just call the interface `CurrentWeather`? This is because, later on,
    we may create a class to implement some interesting behavior for `CurrentWeather`.
    Interfaces establish a contract, establishing the list of available properties
    on any class or interface that implements or extends the interface. It is always
    important to be aware of when you're using a class versus an interface. If you
    follow the best practice of always starting your interface names with a capital
    `I`, you will always be conscious of what type of object you are passing around.
    Hence, the interface is named `ICurrentWeather`.
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为什么不直接将接口命名为`CurrentWeather`呢？这是因为，稍后我们可能会创建一个类来实现`CurrentWeather`的一些有趣行为。接口建立了一个合约，为任何实现或扩展该接口的类或接口上的可用属性建立列表。始终意识到你是在使用类还是接口非常重要。如果你遵循最佳实践，始终以大写`I`开始你的接口名称，你将始终意识到你正在传递的对象类型。因此，接口被命名为`ICurrentWeather`。
- en: Rename `icurrent-weather.ts` to `interfaces.ts`
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`icurrent-weather.ts`重命名为`interfaces.ts`
- en: 'Also, implement the interface as follows:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，按照以下方式实现接口：
- en: '[PRE11]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This interface and its eventual concrete representation as a class is the Model
    in MVVM. So far, I have highlighted how various parts of Angular fit the MVVM
    pattern; going forward, I'll refer to these parts by their actual names.
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个接口及其最终作为类的具体表示是MVVM中的模型。到目前为止，我已经强调了Angular的各个部分如何符合MVVM模式；接下来，我将按照它们的实际名称来引用这些部分。
- en: Now, we can import the interface into the component and start wiring up the bindings
    in the template of `CurrentWeatherComponent`.
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们可以将接口导入组件中，并开始在`CurrentWeatherComponent`的模板中设置绑定。
- en: Import `ICurrentWeather`
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`ICurrentWeather`
- en: Switch back to `templateUrl` and `styleUrls`
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换回`templateUrl`和`styleUrls`
- en: 'Define a local variable called `current` with type `ICurrentWeather`:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为`current`的局部变量，其类型为`ICurrentWeather`：
- en: '[PRE12]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you just type `current:ICurrentWeather`, you can use the Auto Fixer in VS
    Code to automatically insert the `import` statement.
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你只输入`current:ICurrentWeather`，你可以使用VS Code中的自动修复功能来自动插入`import`语句。
- en: In the constructor, you need to temporarily populate the `current` property
    with dummy data to test your bindings.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在构造函数中，你需要暂时用占位符数据填充`current`属性以测试你的绑定。
- en: 'Implement dummy data as a JSON object and declare its adherence to `ICurrentWeather`
    using the `as` operator:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将模拟数据实现为一个JSON对象，并使用`as`运算符声明其遵循`ICurrentWeather`：
- en: '[PRE13]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the `src/assets` folder, create a subfolder named `img` and place an image
    of your choice to reference in your dummy data.
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`src/assets`文件夹中，创建一个名为`img`的子文件夹，并将你选择的图片放置在那里以供你的模拟数据引用。
- en: 'You may forget the exact properties in the interface you created. You can get a
    quick peek at them by holding `Ctrl` + hovering over the interface name with your
    mouse, as shown:'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能会忘记你创建的界面中的确切属性。你可以通过按住`Ctrl`并用鼠标悬停在界面名称上快速查看它们，如图所示：
- en: '![](img/B14094_03_08.png)'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B14094_03_08.png)'
- en: 'Figure 3.8: `Ctrl` + hover over the interface'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.8：`Ctrl` + 悬停在界面上
- en: Now, update the template to wire up your bindings with a basic HTML-based layout.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，更新模板以将绑定与基本的HTML布局连接起来。
- en: 'Begin implementing the template:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始实现模板：
- en: '[PRE14]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Within the parent `div`, define another `div` to display the city and country
    information using binding:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在父`div`内部，定义另一个`div`来使用绑定显示城市和国家信息：
- en: '[PRE15]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that within the `span`, you can use static text to position the two properties.
    In this case, the `city` and `country` are separated by a comma, followed by a
    space.
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，在`span`内部，你可以使用静态文本来定位两个属性。在这种情况下，`city`和`country`由逗号分隔，后面跟着一个空格。
- en: 'Below `city` and `country`, display the `date` using binding and a `DatePipe`
    to define a display format for the property:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`city`和`country`下方，使用绑定和`DatePipe`定义属性显示格式来显示`date`：
- en: '[PRE16]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: To change the display formatting of `current.date`, we used the `DatePipe` above,
    passing in `'fullDate'` as the format option. In Angular, various out-of-the-box
    and custom pipe `|` operators can be used to change the appearance of data without
    actually changing the underlying data. This is a very powerful, convenient, and
    flexible system to share such user interface logic without writing repetitive
    boilerplate code.
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要更改`current.date`的显示格式，我们使用了上面的`DatePipe`，传入`'fullDate'`作为格式选项。在Angular中，可以使用各种内置和自定义的`|`操作符来更改数据的显示外观，而实际上并不改变底层数据。这是一个非常强大、方便且灵活的系统，可以共享这样的用户界面逻辑，而无需编写重复的模板代码。
- en: In the preceding example, we could pass in `'shortDate'` if we wanted to represent
    the current date in a more compact form. For more information on various `DatePipe`
    options, refer to the documentation at [https://angular.io/api/common/DatePipe](https://angular.io/api/common/DatePipe).
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的例子中，如果我们想以更紧凑的形式表示当前日期，我们可以传入`'shortDate'`。有关`DatePipe`的各种选项的更多信息，请参阅[https://angular.io/api/common/DatePipe](https://angular.io/api/common/DatePipe)文档。
- en: 'Define another `div` to display the temperature information, formatting the
    value using `DecimalPipe` and bind an image of the current weather to an `img`
    tag:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义另一个`div`来显示温度信息，使用`DecimalPipe`格式化值，并将当前天气的图像绑定到一个`img`标签：
- en: '[PRE17]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We bind the image property to the `img` tag's `src` attribute using the square
    bracket syntax. Next, we format `current.temperature` so that no fractional values
    are shown, using `DecimalPipe`. The documentation is at [https://angular.io/api/common/DecimalPipe](https://angular.io/api/common/DecimalPipe).
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用方括号语法将图像属性绑定到`img`标签的`src`属性。接下来，我们使用`DecimalPipe`格式化`current.temperature`，以确保不显示小数值。文档在[https://angular.io/api/common/DecimalPipe](https://angular.io/api/common/DecimalPipe)。
- en: 'Note that you can render ˚C and ˚F using their respective HTML codes: `&#8451;`
    for ˚C and `&#8457`; for ˚F.'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，你可以使用各自的HTML代码来渲染˚C和˚F：`&#8451;`用于˚C，`&#8457;`用于˚F。
- en: 'Create a final `div` to display the description property:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个最终的`div`来显示描述属性：
- en: '[PRE18]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Your final template should look as follows:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的最终模板应该如下所示：
- en: '[PRE19]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If everything worked correctly, your app should be looking similar to this
    screenshot:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切正常工作，你的应用应该看起来与这个截图相似：
- en: '![](img/B14094_03_09.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_03_09.png)'
- en: 'Figure 3.9: App after wiring up bindings with dummy data'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9：连接了模拟数据的App
- en: Congratulations – you have successfully wired up your first component!
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你 – 你已经成功连接了你的第一个组件！
- en: Now let's update the app so that we can pull live weather data from a Web API.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更新应用，以便可以从Web API中拉取实时天气数据。
- en: Using Angular Services and HttpClient to retrieve data
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Angular服务和HttpClient检索数据
- en: Now you need to connect your `CurrentWeather` component to the `OpenWeatherMap`
    APIs to pull live weather data. However, we don't want to insert this code directly
    into our component. If we did this, we would have to update the component if the
    API changed. Now imagine an app with dozens or hundreds of views and imagine how
    this would create a significant maintainability challenge.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您需要将您的 `CurrentWeather` 组件连接到 `OpenWeatherMap` API 以获取实时天气数据。然而，我们不想直接将此代码插入到我们的组件中。如果我们这样做，如果
    API 发生变化，我们就必须更新组件。现在想象一个拥有数十或数百个视图的应用程序，想象这将如何创建一个重大的可维护性挑战。
- en: Instead, we'll leverage an Angular service, a singleton class, which can provide
    the current weather information to our component and abstract away the source
    of the data. The abstraction decouples the UI from the Web API. Leveraging this
    separation of concerns, in the future, we could enhance our service to pull from
    multiple APIs or a local cache to load weather information without having to change
    the UI code.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将利用一个 Angular 服务，一个单例类，它可以为我们组件提供当前的天气信息，并抽象出数据源。这种抽象将 UI 与 Web API 解耦。利用这种关注点的分离，在未来，我们可以增强我们的服务以从多个
    API 或本地缓存中获取天气信息，而无需更改 UI 代码。
- en: 'In the upcoming sections, we''ll go over the following steps to accomplish
    this goal:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将介绍以下步骤以实现这一目标：
- en: Creating a new Angular service
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Angular 服务
- en: Importing `HttpClientModule` and injecting it into the service
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `HttpClientModule` 并将其注入到服务中
- en: Discovering the `OpenWeatherMap` API
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发现 `OpenWeatherMap` API
- en: Creating a new interface that conforms to the shape of the API
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个符合 API 形状的新的接口
- en: Writing a `get` request
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个 `get` 请求
- en: Injecting the new service into the `CurrentWeather` component
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新服务注入到 `CurrentWeather` 组件中
- en: Calling the service from the `ngOnInit` function of the `CurrentWeather` component
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `CurrentWeather` 组件的 `ngOnInit` 函数中调用服务
- en: Finally, mapping the API data to the local `ICurrentWeather` type using RxJS functions
    so that your component can consume it
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用 RxJS 函数将 API 数据映射到本地的 `ICurrentWeather` 类型，以便您的组件可以消费它
- en: Creating a new Angular service
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个新的 Angular 服务
- en: Any code that goes outside of the boundaries of a component should exist in
    a service; this includes inter-component communication (unless there's a parent-child
    relationship), API calls of any kind, and any code that caches or retrieves data
    from a cookie or the browser's `localStorage`. This is a critical architectural
    pattern that keeps your application maintainable in the long term. I expand upon
    this idea in my DevPro MVVM article at link [https://www.itprotoday.com/microsoft-visualstudio/mvvm-and-net-great-combo-web-application-development](https://www.itprotoday.com/microsoft-visualstudio/mvvm-and-net-great-combo-web-application-developme).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 任何超出组件边界之外的代码都应该存在于服务中；这包括组件间的通信（除非存在父子关系）、任何类型的 API 调用，以及任何从 cookie 或浏览器的 `localStorage`
    中缓存或检索数据的代码。这是一个关键的建筑模式，可以确保您的应用程序在长期内可维护。我在我的 DevPro MVVM 文章中扩展了这个想法，链接为 [https://www.itprotoday.com/microsoft-visualstudio/mvvm-and-net-great-combo-web-application-development](https://www.itprotoday.com/microsoft-visualstudio/mvvm-and-net-great-combo-web-application-developme)。
- en: 'To create an Angular service, use the Angular CLI:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个 Angular 服务，请使用 Angular CLI：
- en: In the terminal, execute `npx ng g s weather --flat false`
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中，执行 `npx ng g s weather --flat false`
- en: 'Observe the new `weather` folder that''s created:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察新创建的 `weather` 文件夹：
- en: '[PRE20]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'A CLI-generated service has two parts:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: CLI 生成的服务有两个部分：
- en: '`weather.service.spec.ts` contains Jasmine-based unit tests that you can extend
    to test your service''s functionality.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`weather.service.spec.ts` 包含基于 Jasmine 的单元测试，您可以扩展以测试服务功能。'
- en: '`weather.service.ts` contains the `@Injectable` decorator above the class definition,
    which makes it possible to inject this service into other components, leveraging
    Angular''s provider system. This ensures that our service is a singleton, meaning
    it is instantiated once, no matter how many times it is injected elsewhere.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`weather.service.ts` 包含在类定义之上的 `@Injectable` 装饰器，这使得可以将此服务注入到其他组件中，利用 Angular
    的提供者系统。这确保了我们的服务是单例的，意味着它只实例化一次，无论它在其他地方被注入多少次。'
- en: 'The service is generated as shown here:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 服务生成如下所示：
- en: '[PRE21]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that the `providedIn` property ensures that the root module provides the
    weather service in `app.module.ts`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`providedIn` 属性确保根模块在 `app.module.ts` 中提供天气服务。
- en: Next, let's see the dependency injection mechanism in Angular, which allows
    services and modules to be used by other services, components, or modules without
    the developer having to manage the instantiation of the shared objects.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看Angular中的依赖注入机制，它允许服务、组件或模块之间使用其他服务、组件或模块，而无需开发者管理共享对象的实例化。
- en: Injecting dependencies
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖注入
- en: 'To make API calls, you need to leverage the `HttpClient` module in Angular.
    The official documentation ([https://angular.io/guide/http](https://angular.io/guide/http))
    explains the benefits of this module succinctly:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行API调用，你需要利用Angular中的`HttpClient`模块。官方文档([https://angular.io/guide/http](https://angular.io/guide/http))简洁地解释了此模块的优点：
- en: '"With HttpClient, @angular/common/http provides a simplified API for HTTP functionality
    for use with Angular applications, building on top of the XMLHttpRequest interface
    exposed by browsers. Additional benefits of HttpClient include testability support,
    strong typing of request and response objects, request and response interceptor
    support, and better error handling via APIs based on Observables."'
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"使用HttpClient，@angular/common/http为Angular应用程序提供了一个简化的HTTP功能API，它建立在浏览器暴露的XMLHttpRequest接口之上。HttpClient的其他优点包括测试支持、请求和响应对象的强类型、请求和响应拦截器支持，以及基于Observables的API提供的更好的错误处理。"'
- en: 'Let''s start by importing the `HttpClientModule` into our app so we can inject
    the `HttpClient` provided by the module into the `WeatherService`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从将`HttpClientModule`导入我们的应用程序开始，这样我们就可以将模块提供的`HttpClient`注入到`WeatherService`中：
- en: 'Add `HttpClientModule` to `app.module.ts`, as follows:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`HttpClientModule`添加到`app.module.ts`中，如下所示：
- en: '[PRE22]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Inject `HttpClient`, provided by the `HttpClientModule` in the `WeatherService`,
    as follows:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`HttpClient`注入到`WeatherService`中，如下所示：
- en: '[PRE23]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, `httpClient` is ready for use in your service.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`httpClient`已准备好在你的服务中使用。
- en: Discovering OpenWeatherMap APIs
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发现OpenWeatherMap API
- en: 'Since `httpClient` is strongly typed, we need to create a new interface that
    conforms to the shape of the API we''ll call. To be able to do this, you need
    to familiarize yourself with the Current Weather Data API:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`httpClient`是强类型的，我们需要创建一个新的接口，该接口符合我们将要调用的API的形状。为了能够做到这一点，你需要熟悉当前天气数据API：
- en: Read the documentation by navigating to [http://openweathermap.org/current](http://openweathermap.org/current):![](img/B14094_03_10.png)
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到[http://openweathermap.org/current](http://openweathermap.org/current)阅读文档：![](img/B14094_03_10.png)
- en: 'Figure 3.10: OpenWeatherMap Current Weather Data API documentation'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.10：OpenWeatherMap当前天气数据API文档
- en: 'You need to use the API named **By city name**, which allows you to get current
    weather data by providing the city name as a parameter so that our web request
    looks as follows:'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你需要使用名为**按城市名称**的API，它允许你通过提供城市名称作为参数来获取当前天气数据，这样我们的网络请求看起来如下所示：
- en: '[PRE24]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'On the documentation page, click on the link under **Example of API calls**,
    and you will see a sample response like the following:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文档页面上，点击**API调用示例**下的链接，你将看到如下所示的示例响应：
- en: '[PRE25]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Given the existing `ICurrentWeather` interface that you have already created,
    this response contains more information than you need. You need to write a new
    interface that conforms to the shape of this response, but only specify the pieces
    of data you intend to use. This interface only exists in the `WeatherService`
    and we won't export it since the other parts of the application don't need to
    know about this type.
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 给定你已创建的现有`ICurrentWeather`接口，此响应包含的信息比你需要的多。你需要编写一个新的接口，该接口符合此响应的形状，但仅指定你打算使用的数据部分。此接口仅存在于`WeatherService`中，我们不会将其导出，因为应用程序的其他部分不需要了解此类型。
- en: Create a new interface named `ICurrentWeatherData` in `weather.service.ts` between
    the `import` and `@Injectable` statements
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`weather.service.ts`中的`import`和`@Injectable`语句之间创建一个名为`ICurrentWeatherData`的新接口
- en: 'The new interface should like this:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新接口应该如下所示：
- en: '[PRE26]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: With the `ICurrentWeatherData` interface, we are defining new anonymous types
    by adding children objects to the interface with varying structures. Each of these
    objects can be individually extracted out and defined as their own named interface.
    Especially note that `weather` is an array of the anonymous type that has the
    `description` and `icon` properties.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ICurrentWeatherData`接口，我们通过向接口添加具有不同结构的子对象来定义新的匿名类型。这些对象中的每一个都可以单独提取出来并定义为自己的命名接口。特别注意的是，`weather`是一个具有`description`和`icon`属性的匿名类型的数组。
- en: Next, let's learn how you can introduce environment variables into your Angular
    application, so the test and production versions of your app can rely on different
    values.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们学习如何将环境变量引入到你的Angular应用程序中，以便你的应用程序的测试和产品版本可以依赖不同的值。
- en: Storing environment variables
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储环境变量
- en: 'It''s easy to miss, but the sample URL in the previous sections—`http://samples.openweathermap.org/data/2.5/weather?q=London,uk&appid=b1b15e88fa797225412429c1c50c122a1`—contains
    a required `appid` parameter. You must store this key in your Angular app. You
    can store it in the weather service, but in reality, applications need to be able
    to target different sets of resources as they move from development to testing,
    staging, and production environments. Out of the box, Angular provides two environments:
    one `prod` and the other one as the default.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 容易被忽略的是，前几节中的示例URL——`http://samples.openweathermap.org/data/2.5/weather?q=London,uk&appid=b1b15e88fa797225412429c1c50c122a1`——包含一个必需的`appid`参数。你必须将此密钥存储在你的Angular应用程序中。你可以将其存储在天气服务中，但现实中，应用程序需要能够在从开发到测试、预生产和生产环境迁移时针对不同的资源集。默认情况下，Angular提供了两个环境：一个是`prod`，另一个是默认环境。
- en: Before you can continue, you need to sign up for a free `OpenWeatherMap` account
    and retrieve your `appid`. You can read the documentation for `appid` at [http://openweathermap.org/appid](http://openweathermap.org/appid)
    for more detailed information.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在你继续之前，你需要注册一个免费的`OpenWeatherMap`账户并获取你的`appid`。你可以在[http://openweathermap.org/appid](http://openweathermap.org/appid)上阅读有关`appid`的文档以获取更多信息。
- en: Copy your `appid`, which is a long string of characters and numbers
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制你的`appid`，它是一串由字符和数字组成的长字符串
- en: Store your `appid` in `environment.ts`
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`environment.ts`中存储你的`appid`
- en: 'Configure `baseUrl` for later use:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为后续使用配置`baseUrl`：
- en: '[PRE27]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In code, we use a camel-case `appId` to keep our coding style consistent.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们使用驼峰式`appId`来保持我们的编码风格一致。
- en: Since URL parameters are case-insensitive, `appId` works as well as `appid`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 由于URL参数不区分大小写，`appId`和`appid`都可以使用。
- en: Next, let's implement an HTTP GET to get the current weather data.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们实现一个HTTP GET来获取当前的天气数据。
- en: Implementing an HTTP GET operation
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现HTTP GET操作
- en: 'Now, we can implement the GET call in the `WeatherService` class:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在`WeatherService`类中实现GET调用：
- en: Add a new function to the `WeatherService` class named `getCurrentWeather`
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`WeatherService`类中添加一个名为`getCurrentWeather`的新函数
- en: Import the `environment` object
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`environment`对象
- en: Implement the `httpClient.get` function
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现HTTP GET函数
- en: 'Return the results of the HTTP call:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回HTTP调用的结果：
- en: '[PRE28]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note the use of ES2015's String Interpolation feature. Instead of building your
    string by appending variables to one another like `environment.baseUrl + 'api.openweathermap.org/data/2.5/weather?q='
    + city + ',' + country + '&appid=' + environment.appId`, you can use the backtick
    syntax to wrap `` `your string` ``. Inside the backticks, you can have newlines
    and directly embed variables in the flow of your string by wrapping them with
    the `${dollarbracket}` syntax. However, when you introduce a newline in your code,
    it is interpreted as a literal newline `\n`. To break up the string in your code,
    you can add a backslash `\`, but then the next line of your code can have no indentation.
    It is easier to just concatenate multiple templates, as shown in the preceding
    code sample.
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意ES2015的字符串插值功能的使用。你不需要像`environment.baseUrl + 'api.openweathermap.org/data/2.5/weather?q='
    + city + ',' + country + '&appid=' + environment.appId`那样通过将变量一个接一个地附加来构建你的字符串，你可以使用反引号语法来包裹`
    ``your string`` ``。在反引号内部，你可以使用换行符，并通过使用`${dollarbracket}`语法直接在字符串流中嵌入变量。然而，当你代码中引入换行符时，它被解释为一个字面换行符`\n`。为了在代码中分割字符串，你可以添加一个反斜杠`\`，但这样你的代码的下一行就不能有缩进。正如前面的代码示例所示，直接连接多个模板会更简单。
- en: Using a long and complicated string is an error-prone process. Instead, we can
    use the `HttpParams` object to build the URL programmatically.
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用长而复杂的字符串是一个容易出错的流程。相反，我们可以使用`HttpParams`对象来程序化地构建URL。
- en: 'Leverage `HttpParams` to simplify the URL:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 利用`HttpParams`简化URL：
- en: '[PRE29]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now let's connect the dots so that we can get the current weather data from
    the CurrentWeather component leveraging the Weather service.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们连接这些点，以便我们可以通过利用天气服务从`CurrentWeather`组件中获取当前的天气数据。
- en: Retrieving service data from a component
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从组件中检索服务数据
- en: 'To be able to use the `getCurrentWeather` function in the `CurrentWeather`
    component, you need to inject the service into the component:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 要能在`CurrentWeather`组件中使用`getCurrentWeather`函数，你需要将该服务注入到组件中：
- en: Inject the `WeatherService` into the constructor of the `CurrentWeatherComponent`
    class
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`WeatherService`注入到`CurrentWeatherComponent`类的构造函数中
- en: 'Remove the existing code that created the dummy data in the constructor:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中移除创建模拟数据的现有代码：
- en: '[PRE30]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note the use of TypeScript generics with the `get` function using the caret
    syntax, like `<TypeName>`. Using generics is a development-time quality-of-life
    feature. By providing the type information to the function, input and/or return
    variable types of that function display as you write your code and are validated
    during development and also at compile time.
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意使用TypeScript泛型与`get`函数的尖号语法，如`<TypeName>`。使用泛型是一个开发时提高生活质量的特性。通过向函数提供类型信息，输入和/或返回变量的类型会在你编写代码时显示，并在开发和编译时进行验证。
- en: 'Call the `getCurrentWeather` function inside the `ngOnInit` function:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ngOnInit`函数内部调用`getCurrentWeather`函数：
- en: '[PRE31]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Fair warning: do not expect this code to be working just yet, because `data`
    is of type `ICurrentWeatherData` and `current` is of type `ICurrentWeather`. You
    can observe the error, which should say "`error TS2322: Type ''Observable<ICurrentWeatherData>''
    is not assignable to type ''Observable<ICurrentWeather>''`." Let''s look at what''s
    goes in the next segment.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '提醒一下：不要期望这段代码立即就能工作，因为`data`的类型是`ICurrentWeatherData`，而`current`的类型是`ICurrentWeather`。你可以观察错误，它应该会提示"`error
    TS2322: 类型 ''Observable<ICurrentWeatherData>'' 无法分配给类型 ''Observable<ICurrentWeather>''`。"让我们看看下一部分的内容。'
- en: Angular components have a rich collection of life cycle hooks that allow you
    to inject your custom behavior when a component is being rendered, refreshed,
    or destroyed. `ngOnInit()` is the most common life cycle hook you're going to
    use. It is only called once, when a component is first instantiated or visited.
    This is where you want to perform your service calls. For a deeper understanding
    of component life cycle hooks, check out the documentation at [https://angular.io/guide/lifecycle-hooks](https://angular.io/guide/lifecycle-hooks).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: Angular组件拥有丰富的生命周期钩子，允许你在组件渲染、刷新或销毁时注入自定义行为。`ngOnInit()`是你将最常使用的生命周期钩子。它只调用一次，当组件首次实例化或访问时。这就是你想要执行服务调用的地方。要深入了解组件生命周期钩子，请查看[https://angular.io/guide/lifecycle-hooks](https://angular.io/guide/lifecycle-hooks)中的文档。
- en: 'Note that the anonymous function you have passed to subscribe is an ES2015
    arrow function. If you''re not familiar with arrow functions, it may be confusing
    at first. Arrow functions are quite elegant and simple. Consider the following
    arrow function:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你传递给`subscribe`的匿名函数是一个ES2015箭头函数。如果你不熟悉箭头函数，一开始可能会感到困惑。箭头函数非常优雅且简单。考虑以下箭头函数：
- en: '[PRE32]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You can rewrite it simply as:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以简单地将其重写为：
- en: '[PRE33]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'There''s a special condition—when you write an arrow function that transforms
    a piece of data, such as:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个特殊条件——当你编写一个转换数据的箭头函数时，例如：
- en: '[PRE34]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This function effectively takes `ICurrentWeatherData` as an input and returns
    the `temp` property. The return statement is implicit. If you rewrite it as a
    regular function, it looks as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数有效地将`ICurrentWeatherData`作为输入，并返回`temp`属性。返回语句是隐式的。如果你将其重写为一个普通函数，它看起来如下所示：
- en: '[PRE35]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When the `CurrentWeather` component loads, `ngOnInit` fires once, which calls
    the `getCurrentWeather` function, which returns an object with the type `Observable<ICurrentWeatherData>`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 当`CurrentWeather`组件加载时，`ngOnInit`会触发一次，调用`getCurrentWeather`函数，该函数返回一个类型为`Observable<ICurrentWeatherData>`的对象。
- en: An Observable *is the most basic building block of RxJS* and represents an event
    emitter, which emits any data received over time with the type of `ICurrentWeatherData`
    as described in the official documentation.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察对象*是RxJS中最基本的构建块*，它代表了一个事件发射器，它会在一段时间内发射任何接收到的数据，其类型如官方文档中所述的`ICurrentWeatherData`。
- en: The Observable object by itself is benign and won't send a request over the
    network unless it is being listened to. You can read more about Observables at
    [https://reactivex.io/rxjs/class/es6/Observable.js~Observable.html](https://reactivex.io/rxjs/class/es6/Observable.js~Observable.html).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察对象本身是良性的，除非被监听，否则不会通过网络发送请求。你可以在[https://reactivex.io/rxjs/class/es6/Observable.js~Observable.html](https://reactivex.io/rxjs/class/es6/Observable.js~Observable.html)了解更多关于可观察对象的信息。
- en: By calling `.subscribe` on the Observable, you're essentially attaching a listener
    to the emitter. You've implemented an anonymous function within the `subscribe`
    method, which gets executed whenever a new piece of data is received and an event
    is emitted. The anonymous function takes a data object as a parameter, and the
    specific implementation, in this case, assigns the piece of data to the local
    variable named `current`. Whenever `current` is updated, the template bindings
    you implemented earlier pull in the new data and render it on the View. Even though
    `ngOnInit` executes only once, the subscription to the Observable persists. So,
    whenever there's new data, the current variable updates and the View rerenders
    to display the latest data.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 Observable 上调用 `.subscribe`，你实际上是在将一个监听器附加到发射器上。你在 `subscribe` 方法中实现了一个匿名函数，该函数在接收到新数据并发出事件时执行。匿名函数接受一个数据对象作为参数，在这种情况下，具体的实现将数据块分配给名为
    `current` 的局部变量。每当 `current` 更新时，你之前实现的模板绑定会拉入新数据并在视图中渲染它。即使 `ngOnInit` 只执行一次，对
    Observable 的订阅仍然存在。因此，每当有新数据时，`current` 变量就会更新，视图会重新渲染以显示最新数据。
- en: The root cause of the error at hand is that the data that is being emitted is
    of type `ICurrentWeatherData`; however, our component only understands data that
    is shaped as described by the `ICurrentWeather` interface. In the next section,
    you'll need to dig deeper into RxJS to understand how best to accomplish that
    task.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 当前错误的根本原因是正在发出的数据类型为 `ICurrentWeatherData`；然而，我们的组件只能理解按照 `ICurrentWeather`
    接口描述的形状的数据。在下一节中，你需要更深入地了解 RxJS，以了解如何最好地完成这项任务。
- en: Beware, VS Code and the CLI sometimes stop working. As previously noted, as
    you code, the `npm start` command is running in the integrated terminal of VS
    Code. The Angular CLI, in combination with the Angular Language Service plugin,
    continuously watches for code changes and transpiles your TypeScript code to JavaScript
    so that you can observe your changes with live-reloading in the browser. The great
    thing is that when you make coding errors, in addition to the red underlining
    in VS Code, you also see some red text in the terminal, or even the browser, because
    the transpilation has failed. In most cases, when correcting the error, the red
    underlining goes away and the Angular CLI automatically re-transpiles your code
    and everything works. However, in specific scenarios, note that VS Code fails
    to pick typing changes in the IDE so that you won't get autocompletion help, or
    the CLI tool may get stuck with a message saying **webpack:** **Failed to compile**.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，VS Code 和 CLI 有时会出现停止工作的情况。如前所述，当你编码时，`npm start` 命令正在 VS Code 的集成终端中运行。Angular
    CLI 与 Angular 语言服务插件结合使用，持续监视代码更改并将你的 TypeScript 代码转换为 JavaScript，以便你可以在浏览器中使用实时重新加载来观察你的更改。好事是，当你犯编码错误时，除了
    VS Code 中的红色下划线外，你还会在终端或浏览器中看到一些红色文本，因为转换失败了。在大多数情况下，当你纠正错误时，红色下划线会消失，Angular
    CLI 会自动重新转换你的代码，一切都会正常工作。然而，在特定场景中，请注意 VS Code 无法在 IDE 中识别类型更改，因此你将不会获得自动完成帮助，或者
    CLI 工具可能会因为显示 **webpack:** **Failed to compile** 的消息而卡住。
- en: 'You have two main strategies to recover from such conditions:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 你有两种主要策略来从这种状态中恢复：
- en: Click on the terminal and hit `Ctrl` + `C` to stop running the CLI task and
    restart by executing `npm start`.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击终端并按 `Ctrl` + `C` 停止运行 CLI 任务，然后通过执行 `npm start` 重新启动。
- en: If that doesn't work, quit VS Code with `Alt` + `F4` for Windows or `![](img/B14094_02_0012.png)`
    + `Q` for macOS and restart it. Given Angular and VS Code's monthly release cycles,
    I'm confident that in time the tooling will only improve.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果这不起作用，请使用 `Alt` + `F4`（Windows）或 `![](img/B14094_02_0012.png)` + `Q`（macOS）退出
    VS Code，并重新启动它。鉴于 Angular 和 VS Code 的月度发布周期，我坚信随着时间的推移，工具将只会变得更好。
- en: Let's resolve the type mismatch issue by transforming the shape of the data.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过转换数据形状来解决类型不匹配问题。
- en: Transforming data using RxJS
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 RxJS 转换数据
- en: We are going to use an RxJS reactive pipe (or data stream) to reshape the structure
    of data coming from the external API to fit the shape of the data we expect within
    our Angular app. If we don't do this, then our code will fail due to a type mismatch
    error.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 RxJS 的响应式管道（或数据流）来重塑来自外部 API 的数据结构，以适应我们 Angular 应用中预期的数据形状。如果我们不这样做，那么我们的代码将因类型不匹配错误而失败。
- en: Refer to *Chapter 1*, *Introduction to Angular and Its Concepts*, to get a deeper
    understanding of RxJS and reactive programming.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 参考第 1 章，*Angular 及其概念简介*，以深入了解 RxJS 和响应式编程。
- en: Implementing Reactive transformations
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现响应式转换
- en: 'To avoid future mistakes such as returning an unintended type of data from
    your service, you need to update the `getCurrentWeather` function to define the
    return type as `Observable<ICurrentWeather>` and import the `Observable` type,
    as shown:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免未来出现从你的服务中返回不期望的数据类型等错误，你需要更新 `getCurrentWeather` 函数，将其返回类型定义为 `Observable<ICurrentWeather>`
    并导入 `Observable` 类型，如下所示：
- en: '[PRE36]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, VS Code lets you know that the type `Observable<ICurrentWeatherData>`
    is not assignable to the type `Observable<ICurrentWeather>`:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，VS Code 告诉你，类型 `Observable<ICurrentWeatherData>` 不能赋值给类型 `Observable<ICurrentWeather>`:'
- en: Write a transformation function named `transformToICurrentWeather` that can
    convert `ICurrentWeatherData` to `ICurrentWeather`
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为 `transformToICurrentWeather` 的转换函数，该函数可以将 `ICurrentWeatherData` 转换为 `ICurrentWeather`
- en: 'Also, write a helper function named `convertKelvinToFahrenheit` that converts
    the API-provided Kelvin temperature to Fahrenheit:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，编写一个名为 `convertKelvinToFahrenheit` 的辅助函数，该函数可以将 API 提供的开尔文温度转换为华氏温度：
- en: '[PRE37]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note that you need to be converting the icon property to an image URL at this
    stage. Doing this in the service helps preserve encapsulation; binding the icon
    value to the URL in the View template breaks the **Separation of Concerns** (**SoC**)
    principle. If you wish to create truly modular, reusable, and maintainable components,
    you must remain vigilant and strict in terms of enforcing SoC. The documentation
    for Weather Icons and details of how the URL should be formed, including all the
    available icons, can be found at [http://openweathermap.org/weather-conditions](http://openweathermap.org/weather-conditions).
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，你需要在当前阶段将图标属性转换为图像 URL。在服务中这样做有助于保持封装；在视图模板中将图标值绑定到 URL 上会破坏**关注点分离**（**SoC**）原则。如果你希望创建真正模块化、可重用和可维护的组件，你必须保持警惕并严格执行
    SoC。有关天气图标和如何形成 URL 的详细说明，包括所有可用的图标，可以在[http://openweathermap.org/weather-conditions](http://openweathermap.org/weather-conditions)找到。
- en: On a separate note, the argument could be made that Kelvin to Fahrenheit conversion
    is a View concern, but we have implemented it in the service. This argument holds
    water, especially considering that we have a planned feature to be able to toggle
    between Celsius and Fahrenheit. A counter-argument would be that, at this time,
    we only need to display temperatures in Fahrenheit and it is part of the job of
    the weather service to be able to convert the units. This argument makes sense
    as well. The ultimate implementation is to write a custom Angular pipe and apply
    it in the template. A pipe can easily bind with the planned toggle button as well.
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一方面，可以说开尔文到华氏的转换是视图关注点，但我们已经在服务中实现了它。这个论点站得住脚，特别是考虑到我们有一个计划中的功能，可以切换摄氏度和华氏度。反论点是，目前我们只需要显示华氏温度，并且将单位转换为天气服务的一部分工作。这个论点也有道理。最终的实现是编写一个自定义的
    Angular 管道并将其应用于模板。管道可以轻松地与计划中的切换按钮绑定。
- en: However, at this time, we only need to display temperatures in Fahrenheit, and
    I would err on the side of *not* over-engineering a solution.
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，目前我们只需要显示华氏温度，我会选择*不*过度设计解决方案。
- en: Update `ICurrentWeather.date` to the `number` type
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `ICurrentWeather.date` 更改为 `number` 类型
- en: While writing the transformation function, note that the API returns the date
    as a number. This number represents the amount of time in seconds since the Unix
    epoch (timestamp), which is January 1, 1970 00:00:00 UTC. However, `ICurrentWeather`
    expects a `Date` object. It is easy enough to convert the timestamp by passing
    it into the constructor of the `Date` object like a new `Date(data.dt)`. This
    is fine, but also unnecessary since Angular's `DatePipe` can directly work with
    the timestamp. In the name of relentless simplicity and maximally leveraging the
    functionality of the frameworks we use, we update `ICurrentWeather` to use number.
    There's also a performance and memory benefit to this approach if you're transforming
    massive amounts of data, but that concern is not applicable here. There's one
    caveat—JavaScript's timestamp is in milliseconds, but the server value is in seconds,
    so a simple multiplication during the transformation is still required.
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在编写转换函数时，请注意API以数字形式返回日期。这个数字代表自Unix纪元（时间戳）以来的秒数，即1970年1月1日00:00:00 UTC。然而，`ICurrentWeather`期望一个`Date`对象。通过将其传递给`Date`对象的构造函数，如`new
    Date(data.dt)`，转换时间戳是很容易的。这是可以的，但也是不必要的，因为Angular的`DatePipe`可以直接处理时间戳。为了追求极致的简洁性和最大限度地利用我们使用的框架的功能，我们将`ICurrentWeather`更新为使用数字。如果你正在转换大量数据，这种方法还有性能和内存上的好处，但在这里这个顾虑不适用。有一个注意事项——JavaScript的时间戳是以毫秒为单位的，但服务器值是以秒为单位的，所以在转换过程中仍然需要进行简单的乘法。
- en: 'Import the RxJS `map` operator right below the other `import` statements:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其他`import`语句下方导入RxJS的`map`操作符：
- en: '[PRE38]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: It may seem odd to have to manually import the `map` operator. RxJS is a capable
    framework with a wide API surface. An `Observable` alone has over 200 methods
    attached to it. Including all of these methods by default creates development
    time issues with too many functions to choose from and also negatively impacts
    the size of the final deliverable, including app performance and memory use. You
    must add each operator you intend to use individually.
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不得不手动导入`map`操作符可能看起来有些奇怪。RxJS是一个功能强大的框架，具有广泛的API表面。一个`Observable`本身就有超过200个方法附加到它上。默认包含所有这些方法会导致开发时间问题，因为有很多函数可供选择，同时也对最终交付物的尺寸产生负面影响，包括应用性能和内存使用。你必须单独添加你打算使用的每个操作符。
- en: Apply the `map` function to the data stream returned by the `httpClient.get`
    method through a `pipe`
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`pipe`将`httpClient.get`方法返回的数据流应用`map`函数
- en: 'Pass the data object into the `transformToICurrentWeather` function:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据对象传递给`transformToICurrentWeather`函数：
- en: '[PRE39]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now incoming data can be transformed as it flows through the stream, ensuring
    that the `OpenWeatherMap` Current Weather API data is in the correct shape so
    that the `CurrentWeather` component can consume it.
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，数据可以在流通过时进行转换，确保`OpenWeatherMap`当前天气API数据处于正确的形状，以便`CurrentWeather`组件可以消费它。
- en: Ensure that your app compiles successfully
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你的应用编译成功
- en: Inspect the results in the browser:![](img/B14094_03_11.png)
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中检查结果：![图3.11](img/B14094_03_11.png)
- en: 'Figure 3.11: Displaying live data from OpenWeatherMap'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.11：显示来自OpenWeatherMap的实时数据
- en: You should see that your app is able to pull live data from `OpenWeatherMap`
    and correctly transform server data into the format you expect.
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该看到你的应用能够从`OpenWeatherMap`拉取实时数据，并且能够正确地将服务器数据转换为预期的格式。
- en: 'You have completed the development of Feature 1: **Display Current Location
    weather information for the current day**. Commit your code!'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你已经完成了功能1的开发：**显示当前日期的当前位置天气信息**。提交你的代码！
- en: Finally, we can move this task to the **Done** column:![](img/B14094_03_12.png)
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以将这个任务移动到**完成**列：![图3.12](img/B14094_03_12.png)
- en: 'Figure 3.12: GitHub project Kanban board status'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.12：GitHub项目看板状态
- en: Great work! You're now familiar with the fundamental architecture of Angular.
    You also started implementing code in the reactive paradigm by leveraging RxJS.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！你现在熟悉了Angular的基本架构。你通过利用RxJS开始以响应式范式编写代码。
- en: Now let's increase the resiliency of our app by guarding against null or undefined
    values that can break your application code.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过防范null或undefined值来提高我们应用的健壮性，这些值可能会破坏你的应用程序代码。
- en: Null guarding in Angular
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular中的null防护
- en: In JavaScript, the `undefined` and `null` values are a persistent issue that
    must be proactively dealt with every step of the way. This is especially critical
    when dealing with external APIs and other libraries. If we don't deal with `undefined`
    and `null` values, then your app may present badly rendered views, console errors,
    issues with business logic, or even a crash of your entire app.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，`undefined` 和 `null` 值是一个持续存在的问题，必须在每个步骤中积极处理。这在与外部 API 和其他库打交道时尤其关键。如果我们不处理
    `undefined` 和 `null` 值，那么你的应用程序可能会呈现渲染不良的视图、控制台错误、业务逻辑问题，甚至可能导致整个应用程序崩溃。
- en: 'There are multiple strategies to guard against null values in Angular:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 中，有多种策略可以防止空值：
- en: Property initialization
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性初始化
- en: The safe navigation operator, `?.`
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全导航操作符 `?.`
- en: Null guarding with `*ngIf`
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `*ngIf` 进行空值保护
- en: You may use one or more of these strategies. However, in the next few sections
    I demonstrate why the `*ngIf` strategy is the optimal one to use.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用这些策略中的一个或多个。然而，在接下来的几节中，我将演示为什么 `*ngIf` 策略是最佳选择。
- en: 'To simulate the scenario of getting an empty response from the server, go ahead
    and comment out the `getCurrentWeather` call in `ngOnInit` of `CurrentWeatherComponent`:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟从服务器获取空响应的场景，请先在 `CurrentWeatherComponent` 的 `ngOnInit` 中注释掉 `getCurrentWeather`
    调用：
- en: '[PRE40]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Let's start with implementing the property initialization strategy to guard
    against null values.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从实现属性初始化策略来防止空值开始。
- en: Property initialization
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性初始化
- en: 'In statically-typed languages such as Java, it is drilled into you that proper
    variable initialization/instantiation is the key to error-free operation. So,
    let''s try that in `CurrentWeatherComponent` by initializing `current` with default
    values:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在静态类型语言（如 Java）中，你被灌输的是适当的变量初始化/实例化是错误无操作的关键。因此，让我们在 `CurrentWeatherComponent`
    中通过用默认值初始化 `current` 来尝试一下：
- en: '[PRE41]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The outcome of these changes reduces the number of console errors from two
    to zero. However, the app itself is not in a presentable state, as you can see
    here:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改的结果将控制台错误的数量从两个减少到零。然而，应用程序本身仍然没有达到可展示的状态，如下所示：
- en: '![](img/B14094_03_13.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![图片 B14094_03_13](img/B14094_03_13.png)'
- en: 'Figure 3.13: Results of property initialization'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.13：属性初始化的结果
- en: To make this View presentable to the user, we have to code with default values
    on every property on the template. So, by fixing the null guarding issue with
    initialization, we created a default value handling issue. Both the initialization
    and the default value handling are *O(n)* scale tasks for developers. At its best,
    this strategy is annoying to implement and at its worst, highly ineffective and
    error-prone, requiring, at a minimum, *O(2n)* effort per property.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个视图对用户友好，我们必须在模板上的每个属性上编写默认值。因此，通过初始化来解决空值保护问题，我们创建了一个默认值处理问题。初始化和默认值处理都是对开发者来说的
    *O(n)* 规模的任务。在最理想的情况下，这种策略的实现令人烦恼，在最糟糕的情况下，效率极低且容易出错，每个属性至少需要 *O(2n)* 的努力。
- en: Next, let's learn about Angular's safe navigation operator, which comes in handy
    when dealing with objects that are external to our application when we can't control which
    properties may be null or undefined.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们了解 Angular 的安全导航操作符，当处理我们无法控制哪些属性可能为 null 或 undefined 的外部对象时，这个操作符非常有用。
- en: The safe navigation operator
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全导航操作符
- en: Angular implements the safe navigation operation, `?.`, to prevent unintended
    traversals of undefined objects. So, instead of writing initialization code and
    having to deal with template values, we can just update the template.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 实现了安全导航操作符 `?.`，以防止意外遍历未定义的对象。因此，我们不必编写初始化代码并处理模板值，我们只需更新模板。
- en: 'Remove the property initialization code from the constructor and instead update
    the template as shown:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 从构造函数中删除属性初始化代码，而是按照以下方式更新模板：
- en: '[PRE42]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This time, we didn''t have to make up defaults, and we let Angular deal with
    displaying undefined bindings. The app itself is in somewhat better shape. There''s no
    more confusing data being displayed; however, it still is not in a presentable
    state, as shown here:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们不必创建默认值，而是让 Angular 处理显示未定义绑定。应用程序本身处于某种更好的状态。不再显示令人困惑的数据；然而，它仍然没有达到可展示的状态，如下所示：
- en: '![](img/B14094_03_14.png)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![图片 B14094_03_14](img/B14094_03_14.png)'
- en: 'Figure 3.14: Results of using the safe navigation operator'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 3.14：使用安全导航操作符的结果](img/B14094_03_14.png)'
- en: You can probably imagine ways in which the safe navigation operator could come
    in handy, in far more complicated scenarios. However, when deployed at scale,
    this type of coding still requires, at a minimum, *O(n)* level of effort to implement.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能可以想象出安全导航操作符在更复杂场景中可能很有用的方式。然而，当大规模部署时，这种类型的编码仍然至少需要*O(n)*级别的努力来实现。
- en: When presenting data to the user, we don't want to present empty values. The
    easiest way to clean up the UI would be to leverage the `ngIf` directive to hide
    the entire `div`.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 当向用户展示数据时，我们不想展示空值。清理UI的最简单方法就是利用`ngIf`指令来隐藏整个`div`。
- en: Null guarding with *ngIf
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用*ngIf进行空值保护
- en: The ideal strategy is to use `*ngIf`, which is a structural directive, meaning
    Angular stops traversing DOM tree elements beyond a falsy statement.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 理想策略是使用`*ngIf`，这是一个结构化指令，意味着Angular会在遇到假值时停止遍历DOM树元素。
- en: 'In the `CurrentWeather` component, we can easily check to see whether the `current`
    variable is null or undefined before attempting to render the template:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CurrentWeather`组件中，我们可以在尝试渲染模板之前轻松检查`current`变量是否为null或undefined：
- en: Undo the implementation of the safe navigation operators from the previous section
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 撤销上一节中安全导航操作符的实现
- en: 'Update the topmost `div` element with `*ngIf` to check whether `current` is
    an object, as shown:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`*ngIf`更新最顶层的`div`元素，以检查`current`是否是一个对象，如下所示：
- en: '[PRE43]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now observe the console log and that no errors are being reported. You should
    always ensure that your Angular application reports zero console errors. If you're
    still seeing errors in the console log, ensure that you have correctly reverted
    the `OpenWeather` URL to its correct state or kill and restart your `npm start`
    process. I highly recommend that you resolve any console errors before moving
    on.
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在观察控制台日志，没有错误被报告。你应该始终确保你的Angular应用程序报告零控制台错误。如果你在控制台日志中仍然看到错误，请确保你已经正确地将`OpenWeather`
    URL恢复到其正确状态，或者终止并重新启动你的`npm start`进程。我强烈建议你在继续之前解决任何控制台错误。
- en: Observe that the UI will now show that there's no data:![](img/B14094_03_15.png)
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意到UI现在会显示没有数据！![图片](img/B14094_03_15.png)
- en: 'Figure 3.15: Results of using null guarding with *ngIf'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.15：使用*ngIf进行空值保护的结果
- en: 'Re-enable the `getCurrentWeather` call in `ngOnInit` of `CurrentWeatherComponent`:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CurrentWeatherComponent`的`ngOnInit`中重新启用`getCurrentWeather`调用：
- en: '[PRE44]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Commit your changes.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交你的更改。
- en: With null guarding, you can ensure that your UI always looks professional.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 使用空值保护，你可以确保你的UI始终看起来专业。
- en: Summary
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Congratulations! In this chapter, you created your first Angular application
    with a flexible architecture while avoiding over-engineering. This was possible
    because we first built a roadmap and codified it in a Kanban board that is visible
    to your peers and colleagues. We stayed focused on implementing the first feature
    we put in progress and didn't deviate from the plan.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！在本章中，你创建了一个具有灵活架构的Angular应用程序，同时避免了过度设计。这是可能的，因为我们首先制定了一个路线图，并在一个对同事可见的看板中将其编码化。我们专注于实现我们首先放入进行中的第一个功能，并始终没有偏离计划。
- en: You learned how to avoid coding mistakes by proactively declaring the input
    and return types of functions and working with generic functions. You used the
    date and decimal pipes to ensure that data is formatted as desired while keeping
    formatting-related concerns mostly in the template, where this kind of logic belongs.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 你学习了如何通过积极声明函数的输入和返回类型以及使用泛型函数来避免编码错误。你使用了日期和小数管道来确保数据以所需的方式格式化，同时将格式化相关的问题主要保留在模板中，这种逻辑属于模板。
- en: Finally, you used interfaces to communicate between components and services
    without leaking the external data structure to internal components. By applying
    all these techniques in combination, which Angular, RxJS, and TypeScript allowed
    us to do, you ensured proper separation of concerns and encapsulation. As a result,
    the `CurrentWeather` component is now truly reusable and composable; this is not
    an easy feat to achieve.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你使用了接口在组件和服务之间进行通信，而没有将外部数据结构泄露给内部组件。通过结合应用所有这些技术，Angular、RxJS和TypeScript允许我们这样做，你确保了适当的关注点分离和封装。因此，`CurrentWeather`组件现在真正是可重用和可组合的；这不是一件容易的事情。
- en: If you don't ship it, it never happened. In the next chapter, we'll prepare
    this Angular app for a production release by troubleshooting application errors,
    ensuring automated unit and e2e tests pass, and containerizing the Angular app
    with Docker so that it can be published on the web.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有发布，那就从未发生过。在下一章中，我们将通过排除应用错误、确保自动化单元和端到端测试通过，以及使用Docker容器化Angular应用，为生产发布准备这个Angular应用，以便可以在网络上发布。
- en: Further reading
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*The Back of the Napkin: Solving Problems and Selling Ideas with Pictures*,
    Dan Roam, 2008.'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《便签背面：用图片解决问题和推销想法*》，丹·罗姆，2008年。'
- en: '*Visual Thinking: Empowering People and Organizations through Visual Collaboration*,
    Williemien Brand, 2017.'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*视觉思维：通过视觉协作赋予人们和组织力量*，威尔米恩·布兰德，2017年。'
- en: '*The Project Cartoon*, [http://projectcartoon.com](http://projectcartoon.com).'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*项目卡通*，[http://projectcartoon.com](http://projectcartoon.com)。'
- en: '*Project management, made simple*, GitHub, [https://github.com/features/project-management](https://github.com/features/project-management).'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*项目管理，简单化*，GitHub，[https://github.com/features/project-management](https://github.com/features/project-management)。'
- en: '*Creating a project board*, GitHub, [https://help.github.com/en/articles/creating-a-project-board](https://help.github.com/en/articles/creating-a-project-board).'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建项目板*，GitHub，[https://help.github.com/en/articles/creating-a-project-board](https://help.github.com/en/articles/creating-a-project-board)。'
- en: Questions
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Answer the following questions as best as you can to ensure that you've understood
    the key concepts from this chapter without Googling. Do you need help answering
    the questions? See *Appendix D*, *Self-Assessment Answers* online at [https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf](https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf)
    or visit [https://expertlysimple.io/angular-self-assessment](https://expertlysimple.io/angular-self-assessment).
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能地回答以下问题，以确保你在不使用Google的情况下理解了本章的关键概念。你需要帮助回答这些问题吗？请参阅*附录D*，*自我评估答案*，在线位于[https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf](https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf)或访问[https://expertlysimple.io/angular-self-assessment](https://expertlysimple.io/angular-self-assessment)。
- en: I introduced the concept of a Kanban board. What is it, and what role does a Kanban
    board play in our software application development?
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我介绍了看板的概念。它是什么，看板在我们的软件应用开发中扮演什么角色？
- en: What were the different Angular components we generated using the Angular CLI
    tool to build out our Local Weather app after we initially created it, and what
    function and role do each of them serve?
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用Angular CLI工具创建Local Weather应用后，生成了哪些不同的Angular组件，以及每个组件的功能和角色是什么？
- en: What are the different ways of binding data in Angular?
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Angular中绑定数据的不同方式有哪些？
- en: Why do we need services in Angular?
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们需要在Angular中使用服务？
- en: What is an observable in RxJS?
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在RxJS中，可观察者是什么？
- en: What is the easiest way to present a clean UI if the data behind your template
    is falsy?
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你的模板背后的数据是假的，最容易的方式展示一个干净的UI是什么？
