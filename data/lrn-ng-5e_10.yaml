- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Collecting User Data with Forms
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用表单收集用户数据
- en: Web applications use forms to collect input data from users. Use cases vary,
    from allowing users to log in, fill in payment information, book a flight, or
    even perform a search. Form data can later be persisted on local storage or be
    sent to a server using a backend API.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 网络应用程序使用表单从用户那里收集输入数据。用例多种多样，从允许用户登录、填写支付信息、预订航班，甚至执行搜索。表单数据可以稍后保存在本地存储中或通过后端API发送到服务器。
- en: 'In this chapter, we will cover the following topics about forms:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下关于表单的主题：
- en: Introducing web forms
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍网络表单
- en: Building template-driven forms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建模板驱动表单
- en: Building reactive forms
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建响应式表单
- en: Using a form builder
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用表单构建器
- en: Validating input in forms
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在表单中验证输入
- en: Manipulating form state
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作表单状态
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The chapter contains various code samples to walk you through creating and
    managing forms in Angular. You can find the related source code in the `ch10`
    folder of the following GitHub repository:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含各种代码示例，引导你创建和管理Angular中的表单。你可以在以下GitHub仓库的`ch10`文件夹中找到相关源代码：
- en: '[https://www.github.com/PacktPublishing/Learning-Angular-Fifth-Edition](https://www.github.com/PacktPublishing/Learning-Angular-Fifth-Edition
    )'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.github.com/PacktPublishing/Learning-Angular-Fifth-Edition](https://www.github.com/PacktPublishing/Learning-Angular-Fifth-Edition)'
- en: Introducing web forms
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍网络表单
- en: 'A form usually has the following characteristics that enhance the user experience
    of a web application:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 表单通常具有以下特性，这些特性可以增强网络应用程序的用户体验：
- en: Defines different kinds of input fields
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义不同类型的输入字段
- en: Sets up different kinds of validations and displays validation errors to the
    user
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置不同类型的验证并向用户显示验证错误
- en: Supports different strategies for handling data if the form is in an error state
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果表单处于错误状态，支持不同的数据处理策略
- en: 'The Angular framework provides two approaches to handling forms: **template-driven**
    and **reactive** . Neither approach is considered better; you must choose the
    one that best suits your scenario. The main difference between the two approaches
    is how they manage data:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Angular框架提供了两种处理表单的方法：**模板驱动**和**响应式**。两种方法都没有被认为是更好的；你必须选择最适合你场景的方法。两种方法之间的主要区别在于它们管理数据的方式：
- en: '**Template-driven forms** : These are easy to set up and add to an Angular
    application. They operate solely on the component template to create elements
    and configure validation rules; thus, they are not easy to test. They also depend
    on the change detection mechanism of the framework.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模板驱动表单**：这些表单易于设置并添加到Angular应用程序中。它们仅通过组件模板来创建元素和配置验证规则；因此，它们不易于测试。它们还依赖于框架的变更检测机制。'
- en: '**Reactive forms** : These are more robust when scaling and testing. They operate
    in the component class to manage input controls and set validation rules. They
    also manipulate data using an intermediate form model, maintaining their immutable
    nature. This technique is for you if you use reactive programming techniques extensively
    or if your Angular application comprises many forms.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应式表单**：在扩展和测试时更为稳健。它们在组件类中操作，以管理输入控件和设置验证规则。它们还使用中间表单模型来操作数据，保持其不可变性质。如果你广泛使用响应式编程技术，或者你的Angular应用程序包含许多表单，那么这项技术适合你。'
- en: 'A form in a web application consists of a `<form>` HTML element that contains
    HTML elements for entering data, such as `<input>` and `<select>` elements, and
    `<button>` elements for interacting with the data. The form can retrieve and save
    data locally or send it to a server for further manipulation. The following is
    an example of a simple form that is used for logging a user into a web application:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 网络应用程序中的表单由一个包含用于输入数据的HTML元素（如`<input>`和`<select>`元素）以及用于与数据交互的`<button>`元素的`<form>`HTML元素组成。表单可以本地检索和保存数据，或将其发送到服务器进行进一步处理。以下是一个用于在Web应用程序中登录用户的简单表单示例：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding form has two `<input>` elements: one for entering the username
    and another for entering the password. The type of the `password` field is set
    to `password` so that the content of the input control is not visible while typing.
    The type of the `<button>` element is set to `submit` so that the form can collect
    data by a user clicking on the button or pressing *Enter* on any input control.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的表单有两个`<input>`元素：一个用于输入用户名，另一个用于输入密码。`password`字段的类型设置为`password`，这样在输入时输入控件的内容是不可见的。`<button>`元素的类型设置为`submit`，这样表单可以通过用户点击按钮或按下任何输入控件上的*Enter*键来收集数据。
- en: We could add another button with the `reset` type if we wanted to reset form
    data.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要重置表单数据，可以添加另一个具有 `reset` 类型的按钮。
- en: 'Notice that an HTML element must reside inside the `<form>` element to be part
    of it. The following screenshot shows what the form looks like when rendered on
    a page:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一个 HTML 元素必须位于 `<form>` 元素内部，才能成为其一部分。以下截图显示了在页面上渲染的表单外观：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B21418_10_01.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序  自动生成的描述](img/B21418_10_01.png)'
- en: 'Figure 10.1: Login form'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1：登录表单
- en: Web applications can significantly enhance the user experience by using forms
    that provide features such as autocomplete in input controls or prompting the
    user to save sensitive data. Now that we have understood what a web form looks
    like, let’s learn how all that fits into the Angular framework.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用提供如输入控件中的自动完成或提示用户保存敏感数据等功能的表单，Web 应用程序可以显著提升用户体验。现在我们已经了解了 Web 表单的外观，让我们学习所有这些如何在
    Angular 框架中结合在一起。
- en: Building template-driven forms
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建模板驱动的表单
- en: Template-driven forms are one of two different ways of integrating forms with
    Angular. These can be powerful in cases where we want to create small and simple
    forms for our Angular application.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 模板驱动的表单是两种不同的将表单集成到 Angular 的方式之一。在需要为我们的 Angular 应用程序创建小型和简单表单的情况下，这些功能可能非常强大。
- en: We learned about data binding in *Chapter 3* , *Structuring User Interfaces
    with Components* , and how we can use different types to read data from an Angular
    component and write data to it. In that case, binding is either one way or another,
    called **one-way binding** . In template-driven forms, we can combine both ways
    and create a **two-way binding** that can read and write data simultaneously.
    Template-driven forms provide the `ngModel` directive, which we can use in our
    components to get this behavior. To learn more about template-driven forms, we
    will convert the change price functionality of our product detail component to
    work with Angular forms.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 *第3章* ，*使用组件构建用户界面* 中学习了数据绑定，以及我们如何使用不同类型从 Angular 组件中读取数据并将其写入。在这种情况下，绑定可以是单向的或双向的，称为
    **单向绑定**。在模板驱动的表单中，我们可以结合两种方式，创建一个可以同时读取和写入数据的 **双向绑定**。模板驱动的表单提供了 `ngModel` 指令，我们可以在我们的组件中使用它来获得这种行为。要了解更多关于模板驱动的表单，我们将把产品详情组件的更改价格功能转换为与
    Angular 表单一起工作。
- en: You will need the source code of the Angular application we created in *Chapter
    9* , *Navigating through Applications with Routing* , to follow along with the
    rest of the chapter.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随本章的其余部分，你需要我们创建在 *第9章* ，*使用路由导航应用程序* 中的 Angular 应用程序的源代码。
- en: 'Let’s get started:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: 'Open the `product-detail.component.ts` file and add the following `import`
    statement:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `product-detail.component.ts` 文件，并添加以下 `import` 语句：
- en: '[PRE1]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We add template-driven forms to an Angular application using the `FormsModule`
    class from the `@angular/forms` npm package.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用来自 `@angular/forms` npm 包的 `FormsModule` 类将模板驱动的表单添加到 Angular 应用程序中。
- en: 'Add `FormsModule` in the `imports` array of the `@Component` decorator:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `@Component` 装饰器的 `imports` 数组中添加 `FormsModule`：
- en: '[PRE2]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Open the `product-detail.component.html` file and modify the `<input>` element
    as follows:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `product-detail.component.html` 文件，并按如下方式修改 `<input>` 元素：
- en: '[PRE3]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding snippet, we bind the `price` property of the `product` template
    variable to the `ngModel` directive of the `<input>` element. The `name` attribute
    is required so that Angular can internally create a unique form control to distinguish
    it.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们将 `product` 模板变量的 `price` 属性绑定到 `<input>` 元素的 `ngModel` 指令。`name`
    属性是必需的，这样 Angular 可以在内部创建一个唯一的表单控件来区分它。
- en: The syntax of the `ngModel` directive is known as a *banana in a box* , and
    we create it in two steps. First, we make the *banana* by surrounding `ngModel`
    in parentheses `()` . Then, we put it *in a box* by surrounding it with square
    brackets `[()]` .
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngModel` 指令的语法被称为 *香蕉盒*，我们通过以下两个步骤创建它。首先，我们通过括号 `()` 将 `ngModel` 包围起来制作出 *香蕉*。然后，我们通过方括号
    `[()]` 将它放入 *盒子* 中。'
- en: 'Modify the `<button>` element as follows:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `<button>` 元素如下：
- en: '[PRE4]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding snippet, we remove the `click` event from the `<button>` element
    because submitting the form will update the price. We also add the `submit` type
    to indicate that the form submission can happen by a user clicking the button.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们从 `<button>` 元素中移除了 `click` 事件，因为提交表单将更新价格。我们还添加了 `submit` 类型来表示表单提交可以通过用户点击按钮来实现。
- en: 'Surround the `<input>` and `<button>` elements with the following `<form>`
    element:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `<input>` 和 `<button>` 元素包裹在以下 `<form>` 元素中：
- en: '[PRE5]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding snippet, we bind the `changePrice` method to the `ngSubmit`
    event of the form. The binding will trigger the method execution if we press *Enter*
    inside the input box or click the button. The `ngSubmit` event is part of the
    Angular `FormsModule` and hooks on the native `submit` event of an HTML form.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们将 `changePrice` 方法绑定到表单的 `ngSubmit` 事件。如果我们在输入框内按下 *Enter* 键或点击按钮，绑定将触发方法执行。`ngSubmit`
    事件是 Angular `FormsModule` 的一部分，它挂钩于 HTML 表单的本地 `submit` 事件。
- en: 'Open the `product-detail.component.ts` file and modify the `changePrice` method
    as follows:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `product-detail.component.ts` 文件，并按如下方式修改 `changePrice` 方法：
- en: '[PRE6]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Run the application using the `ng serve` command and select a product from the
    list.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `ng serve` 命令运行应用程序，并从列表中选择一个产品。
- en: 'You will notice that the current product price is already displayed inside
    the input box. Try to change the price, and you will notice that the current price
    of the product is also changing while you type:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会注意到当前产品价格已经显示在输入框中。尝试更改价格，你会注意到当你键入时，产品的当前价格也在变化：
- en: '![img](img/B21418_10_02.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B21418_10_02.png)'
- en: 'Figure 10.2: Two-way binding'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2：双向绑定
- en: The behavior of our application depicted in the preceding image is the magic
    behind two-way binding and `ngModel` .
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 前面图像中所示的应用程序行为是双向绑定和 `ngModel` 的魔法所在。
- en: Two-way binding was the biggest selling point when AngularJS came out in 2010.
    It was complex to achieve that behavior in those days with vanilla JavaScript
    and jQuery.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当 AngularJS 在 2010 年推出时，双向绑定是其最大的卖点。在当时使用纯 JavaScript 和 jQuery 实现该行为是复杂的。
- en: While we type inside the input box, the `ngModel` directive updates the value
    of the product price. The new price is directly reflected in the template because
    we use Angular interpolation syntax to display its value.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在输入框中键入时，`ngModel` 指令会更新产品价格的价值。新价格会直接反映在模板中，因为我们使用了 Angular 插值语法来显示其值。
- en: 'In our case, updating the current product price while entering a new one is
    a bad user experience. The user should be able to view the current price of the
    product at all times. We will modify the product detail component so that the
    price is displayed correctly:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，在输入新价格的同时更新当前产品价格是一种糟糕的用户体验。用户应该能够始终查看产品的当前价格。我们将修改产品详情组件，以便正确显示价格：
- en: 'Open the `product-detail.component.ts` file and create a `price` property inside
    the `ProductDetailComponent` class:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `product-detail.component.ts` 文件，并在 `ProductDetailComponent` 类中创建一个 `price`
    属性：
- en: '[PRE7]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Modify the `changePrice` method to use the `price` component property:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `changePrice` 方法修改为使用 `price` 组件属性：
- en: '[PRE8]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Open the `product-detail.component.html` file and replace the binding in the
    `<input>` element to use the new component property:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `product-detail.component.html` 文件，并将 `<input>` 元素中的绑定替换为使用新的组件属性：
- en: '[PRE9]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If we run the application and try to enter a new price inside the **New price**
    input box, we will notice that the current price displayed does not change. The
    functionality of changing the price also works correctly as before.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行应用程序并尝试在 **新价格** 输入框中输入新价格，我们会注意到显示的当前价格没有变化。更改价格的功能也像以前一样正常工作。
- en: 'We have seen how template-driven forms can be useful when creating small and
    simple forms. In the next section, we dive deeper into the alternative approach
    offered by the Angular framework: reactive forms.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，当创建小型和简单的表单时，模板驱动的表单非常有用。在下一节中，我们将更深入地探讨 Angular 框架提供的另一种方法：响应式表单。
- en: Building reactive forms
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建响应式表单
- en: Reactive forms, as the name implies, reactively provide access to web forms.
    They are built with reactivity in mind, where input controls and their values
    can be manipulated using observable streams. They also maintain an immutable state
    of form data, making them easier to test because we can be sure that the form
    state can be modified explicitly and consistently.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，响应式表单能够动态地提供对网页表单的访问。它们是考虑到响应性而构建的，其中输入控件及其值可以通过可观察流进行操作。它们还保持表单数据的不可变状态，这使得它们更容易测试，因为我们有信心可以明确且一致地修改表单状态。
- en: 'Reactive forms have a programmatic approach to creating form elements and setting
    up validation rules by setting everything up in the component class. The Angular
    key classes involved in this approach are the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式表单采用程序化方法来创建表单元素和设置验证规则，通过在组件类中设置一切来实现。在此方法中涉及的 Angular 关键类如下：
- en: '`FormControl` : Represents an individual form control, such as an `<input>`
    element.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FormControl`：表示单个表单控件，例如 `<input>` 元素。'
- en: '`FormGroup` : Represents a collection of form controls. The `<form>` element
    is the topmost `FormGroup` in the hierarchy of a reactive form.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FormGroup`：表示一组表单控件。`<form>` 元素是响应式表单层次结构中最顶层的 `FormGroup`。'
- en: '`FormArray` : Represents a collection of form controls, just like `FormGroup`
    , but can be modified at runtime. For example, we can add or remove `FormControl`
    objects dynamically as needed.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FormArray`：表示一组表单控件，就像 `FormGroup` 一样，但可以在运行时进行修改。例如，我们可以根据需要动态添加或删除 `FormControl`
    对象。'
- en: 'The preceding classes are available from the `@angular/forms` npm package and
    contain properties that can be used in the following scenarios:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的类都来自 `@angular/forms` npm 包，并包含可用于以下场景的属性：
- en: To render the UI differently according to the status of a form or control
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据表单或控件的状态渲染不同的 UI
- en: To check if we have interacted with a form or control
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查我们是否与表单或控件进行了交互
- en: We will explore each form class through an example in our Angular application.
    In the following section, we will introduce reactive forms in our application
    using the product create component.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过 Angular 应用程序中的示例来探索每个表单类。在下一节中，我们将使用产品创建组件在我们的应用程序中介绍响应式表单：
- en: Interacting with reactive forms
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与响应式表单交互
- en: 'The Angular application we have built contains a component to add new products.
    The component uses template reference variables to collect input data. We will
    use the Angular forms API to accomplish the same task using reactive forms:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建的 Angular 应用程序包含一个用于添加新产品的组件。该组件使用模板引用变量来收集输入数据。我们将使用 Angular 表单 API 通过响应式表单来完成相同任务：
- en: 'Open the `product-create.component.ts` file and add the following `import`
    statement:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `product-create.component.ts` 文件并添加以下 `import` 语句：
- en: '[PRE10]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the `ReactiveFormsModule` class in the `imports` array of the `@Component`
    decorator:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `@Component` 装饰器的 `imports` 数组中添加 `ReactiveFormsModule` 类：
- en: '[PRE11]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The Angular forms library provides the `ReactiveFormsModule` class to create
    reactive forms in an Angular application.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 表单库提供了 `ReactiveFormsModule` 类，用于在 Angular 应用程序中创建响应式表单。
- en: 'Define the following `productForm` property in the `ProductCreateComponent`
    class:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ProductCreateComponent` 类中定义以下 `productForm` 属性：
- en: '[PRE12]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `FormGroup` constructor accepts an object that contains key-value pairs
    of form controls. The key is a unique control name, and the value is a `FormControl`
    instance. The `FormControl` constructor accepts the default value of the control
    in the first parameter. For the `title` and the `category` controls, we pass an
    empty string so that we do not set any value initially. For the `price` control,
    which should accept numbers as values, we set it initially to `undefined` . The
    second parameter passed in the `FormControl` is an object that sets the `nonNullable`
    property to indicate that the control does not accept null values.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`FormGroup` 构造函数接受一个包含表单控件键值对的对象。键是唯一的控件名称，值是 `FormControl` 实例。`FormControl`
    构造函数接受控件在第一个参数中的默认值。对于 `title` 和 `category` 控件，我们传递一个空字符串，这样我们就不设置任何初始值。对于应该接受数字作为值的
    `price` 控件，我们将其初始值设置为 `undefined`。传递给 `FormControl` 的第二个参数是一个对象，它将 `nonNullable`
    属性设置为指示控件不接受空值。'
- en: 'After we have created the form group and its controls, we need to associate
    them with the respective HTML elements in the template. Open the `product-create.component.html`
    file and surround the `<input>` , `<select>` , and `<button>` HTML elements with
    the following `<form>` element:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们创建了表单组和其控件之后，我们需要将它们与模板中相应的 HTML 元素关联起来。打开 `product-create.component.html`
    文件，并在 `<input>`、`<select>` 和 `<button>` HTML 元素周围添加以下 `<form>` 元素：
- en: '[PRE13]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding template, we use the `formGroup` directive, exported from the
    `ReactiveFormsModule` class, to connect a `FormGroup` instance to a `<form>` element.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的模板中，我们使用从 `ReactiveFormsModule` 类导出的 `formGroup` 指令将 `FormGroup` 实例连接到 `<form>`
    元素。
- en: 'The `ReactiveFormsModule` class also exports the `formControlName` directive,
    which we use to connect a `FormControl` instance to an HTML element. Modify the
    form HTML elements as follows:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ReactiveFormsModule` 类还导出了 `formControlName` 指令，我们使用它将 `FormControl` 实例连接到
    HTML 元素。按照以下方式修改表单 HTML 元素：'
- en: '[PRE14]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding snippet, we set the value of the `formControlName` directive
    to the name of the respective `FormControl` instance. We also remove the template
    reference variables because we can get their values directly from the `FormGroup`
    instance.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们将`formControlName`指令的值设置为相应的`FormControl`实例的名称。我们还删除了模板引用变量，因为我们可以直接从`FormGroup`实例获取它们的值。
- en: 'Modify the `createProduct` method in the `product-create.component.ts` file
    accordingly:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据需要在`product-create.component.ts`文件中修改`createProduct`方法：
- en: '[PRE15]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding method, we use the `value` property of the `FormGroup` class
    to get the form value.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的方法中，我们使用`FormGroup`类的`value`属性来获取表单值。
- en: Note that the `value` property does not include values from disabled fields
    of a form. Instead, we can use the `getRawValue` method to return values from
    all fields.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`value`属性不包括表单禁用字段的值。相反，我们可以使用`getRawValue`方法来返回所有字段的值。
- en: In this case, we can use the form value because the form model is identical
    to the `Product` interface.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以使用表单值，因为表单模型与`Product`接口相同。
- en: 'If it was different, we could use the `controls` property of the `FormGroup`
    class to get form control values individually as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它不同，我们可以使用`FormGroup`类的`controls`属性来单独获取表单控件值，如下所示：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `FormControl` class contains a `value` property that returns the value of
    a form control.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`FormControl`类包含一个`value`属性，它返回表单控件的值。'
- en: 'Modify the `<form>` element in the `product-create.component.html` file so
    that we create a new product upon form submission:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`product-create.component.html`文件中修改`<form>`元素，以便在表单提交时创建新产品：
- en: '[PRE17]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Open the global `styles.css` file and add the following CSS style:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开全局`styles.css`文件并添加以下CSS样式：
- en: '[PRE18]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We want the preceding styles to be available globally because we will use them
    in the cart component later in the chapter.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望前面的样式在全局范围内可用，因为我们将在本章后面的购物车组件中使用它们。
- en: Open the `product-create.component.css` file and remove the style for the `<label>`
    tag.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`product-create.component.css`文件并删除`<label>`标签的样式。
- en: If we run the application, we will see that the functionality of adding a new
    product still works as expected.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行应用程序，我们会看到添加新产品的功能仍然按预期工作。
- en: We learned that the `FormGroup` class groups a collection of form controls.
    A form control can be a single form control or another form group, as we will
    see in the following section.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到`FormGroup`类将一组表单控件分组。表单控件可以是一个单独的表单控件或另一个表单组，正如我们将在下一节中看到的。
- en: Creating nesting form hierarchies
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建嵌套表单层次结构
- en: 'The product create component consists of a single form group with three form
    controls. Some use cases in enterprise applications require more advanced forms
    that involve creating nested hierarchies of form groups. Consider the following
    form, which is used to add a new product along with additional details:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 产品创建组件由一个包含三个表单控件的单一表单组组成。在企业应用程序中，某些用例需要更高级的表单，这些表单涉及创建嵌套的表单组层次结构。考虑以下表单，它用于添加新产品及其附加详细信息：
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά, αριθμός  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_10_03.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本的图片，屏幕截图，字体，编号  自动生成的描述](img/B21418_10_03.png)'
- en: 'Figure 10.3: New product form with additional information'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3：带有附加信息的新产品表单
- en: 'The preceding form may look like a single form group, but if we take a deeper
    look at the component class, we will see that the `productForm` consists of two
    `FormGroup` instances, one nested inside the other:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的表单可能看起来像一个单一的表单组，但如果我们深入查看组件类，我们会看到`productForm`由两个`FormGroup`实例组成，一个嵌套在另一个内部：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `productForm` property is the parent form group, while `extra` is its child.
    A parent form group can have as many children form groups as it needs. If we take
    a look at the component template, we will see that the child form group is defined
    differently from the parent one:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`productForm`属性是父表单组，而`extra`是其子项。一个父表单组可以有它需要的任意多个子表单组。如果我们查看组件模板，我们会看到子表单组与父表单组定义不同：'
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding HTML template, we use the `formGroupName` directive to bind
    the inner form element to the `extra` property.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的HTML模板中，我们使用`formGroupName`指令将内部表单元素绑定到`extra`属性。
- en: You may have expected to bind it directly to the `productForm.extra` property,
    but Angular is pretty smart because it understands that `extra` is a child form
    group of `productForm` . It can deduce this information because the form element
    related to `extra` is inside the form element that binds to the `productForm`
    property.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能期望直接将其绑定到 `productForm.extra` 属性，但 Angular 非常聪明，因为它理解 `extra` 是 `productForm`
    的子表单组。它能推断出这个信息，因为与 `extra` 相关的表单元素位于绑定到 `productForm` 属性的表单元素内部。
- en: The value of a child form group is shared with its parent in a nested form hierarchy.
    In our case, the value of the `extra` form group will be included in the `productForm`
    group, thereby maintaining a consistent form model.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌套表单层次结构中，子表单组的值与其父表单共享。在我们的例子中，`extra` 表单组的值将包含在 `productForm` 组中，从而保持一致的表单模型。
- en: We have already covered the `FormGroup` and `FormControl` classes. In the following
    section, we will learn how to use the `FormArray` class to interact with dynamic
    forms.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了 `FormGroup` 和 `FormControl` 类。在下一节中，我们将学习如何使用 `FormArray` 类与动态表单进行交互。
- en: Modifying forms dynamically
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态修改表单
- en: Consider the scenario where we have added some products to the shopping cart
    of our e-shop application and want to update their quantities before checking
    out the order.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下场景：我们在我们的电子商务应用的购物车中添加了一些产品，并想在结账前更新它们的数量。
- en: 'Currently, our application does not have any functionality for a shopping cart,
    so we will now add one:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的应用程序没有购物车的任何功能，因此我们现在将添加一个：
- en: 'Run the following command to create a `Cart` interface:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以创建 `Cart` 接口：
- en: '[PRE21]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Open the `cart.ts` file and modify the `Cart` interface as follows:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `cart.ts` 文件，并按如下方式修改 `Cart` 接口：
- en: '[PRE22]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding snippet, the `products` property will contain the product IDs
    that belong to the current cart.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`products` 属性将包含属于当前购物车的产品 ID。
- en: 'Create a new service to manage the shopping cart by running the following Angular
    CLI command:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下 Angular CLI 命令创建一个新的服务来管理购物车：
- en: '[PRE23]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Open the `cart.service.ts` file and modify the `import` statements as follows:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `cart.service.ts` 文件，并按如下方式修改 `import` 语句：
- en: '[PRE24]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create the following properties in the `CartService` class:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `CartService` 类中创建以下属性：
- en: '[PRE25]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `cartUrl` property is used for the cart endpoint of the Fake Store API and
    the `cart` property to keep a local cache of the user cart.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`cartUrl` 属性用于 Fake Store API 的购物车端点，而 `cart` 属性用于保存用户购物车的本地缓存。'
- en: 'Inject the `HttpClient` service in the `constructor` :'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `constructor` 中注入 `HttpClient` 服务：
- en: '[PRE26]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add the following method to add a product to the cart:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下方法以将产品添加到购物车：
- en: '[PRE27]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding method, we use a new RxJS operator called `defer` . The `defer`
    operator works as an if/else statement for observables.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一种方法中，我们使用了一个名为 `defer` 的新 RxJS 操作符。`defer` 操作符在观察者中充当 if/else 语句的作用。
- en: If the `cart` property has not been initialized, which means that our cart is
    currently empty, we initiate a POST request to the API passing the `cartProduct`
    variable as a parameter. Otherwise, we initiate a PATCH request passing the `cartProduct`
    along with the existing products from the cart.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `cart` 属性尚未初始化，这意味着我们的购物车目前为空，我们将向 API 发起一个 POST 请求，并将 `cartProduct` 变量作为参数传递。否则，我们将发起一个包含
    `cartProduct` 以及购物车中现有产品的 PATCH 请求。
- en: 'We have completed the setup of our service so that it can communicate with
    the Fake Store API. Now, we need to connect the service with the respective component:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了服务的设置，使其能够与 Fake Store API 进行通信。现在，我们需要将服务与相应的组件连接起来：
- en: 'Open the `product-detail.component.ts` file and add the following `import`
    statement:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `product-detail.component.ts` 文件，并添加以下 `import` 语句：
- en: '[PRE28]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Inject `CartService` in the `ProductDetailComponent` class:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ProductDetailComponent` 类中注入 `CartService`：
- en: '[PRE29]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Modify the `addToCart` method so that it calls the `addProduct` method of the
    `CartService` class:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `addToCart` 方法，使其调用 `CartService` 类的 `addProduct` 方法：
- en: '[PRE30]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, open the `product-detail.component.html` file and modify the `click`
    event of the `Add to cart` button:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，打开 `product-detail.component.html` 文件，并修改 `Add to cart` 按钮的 `click` 事件：
- en: '[PRE31]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We have implemented the basic functionality for storing the selected products
    that users want to buy. Now, we must modify the cart component to display the
    cart items:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了存储用户想要购买的产品的基本功能。现在，我们必须修改购物车组件以显示购物车项目：
- en: 'Open the `cart.component.ts` file and modify the `import` statements as follows:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `cart.component.ts` 文件，并按如下方式修改 `import` 语句：
- en: '[PRE32]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Add the `ReactiveFormsModule` class in the `imports` array of the `@Component`
    decorator:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`@Component`装饰器的`imports`数组中添加`ReactiveFormsModule`类：
- en: '[PRE33]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Add the `OnInit` interface to the list of implemented interfaces of the `CartComponent`
    class:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`OnInit`接口添加到`CartComponent`类的实现接口列表中：
- en: '[PRE34]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Create the following properties in the TypeScript class:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在TypeScript类中创建以下属性：
- en: '[PRE35]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding snippet, we created a `FormGroup` object containing a `products`
    property. We set the value of the `products` property to an instance of the `FormArray`
    class. The constructor of the `FormArray` class accepts a list of `FormControl`
    instances with the type `number` as a parameter. The list is empty for now since
    the cart has no products. The `products` property outside the `FormGroup` instance
    will be used for lookup reasons to display the title of each product in the cart.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们创建了一个包含`products`属性的`FormGroup`对象。我们将`products`属性的值设置为`FormArray`类的实例。`FormArray`类的构造函数接受一个参数，该参数是一个具有`number`类型的`FormControl`实例列表。目前这个列表是空的，因为购物车中没有产品。`FormGroup`实例外的`products`属性将用于查找原因，以显示购物车中每个产品的标题。
- en: 'Add a `constructor` to inject the following services:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`constructor`来注入以下服务：
- en: '[PRE36]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Create the following method to get products from the cart:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下方法以从购物车获取产品：
- en: '[PRE37]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the preceding method, we initially subscribe to the `getProducts` method
    of the `ProductsService` class to get the available products. Then, for each product
    in the cart, we extract the `productId` property and check if it exists inside
    the cart. If the product is found, we add it to the `products` component property.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的方法中，我们最初订阅了`ProductsService`类的`getProducts`方法以获取可用产品。然后，对于购物车中的每个产品，我们提取`productId`属性并检查它是否在购物车中存在。如果找到产品，我们就将其添加到`products`组件属性中。
- en: 'Create another method to build our form:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个方法来构建我们的表单：
- en: '[PRE38]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the preceding method, we iterate over the `products` property and add a `FormControl`
    instance for each one inside the `products` form array. We set the value of each
    form control to `1` to indicate that the cart contains one item of each product
    by default.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的方法中，我们遍历`products`属性并为`products`表单数组中的每个产品添加一个`FormControl`实例。我们将每个表单控件的值设置为`1`，以表示购物车默认包含每种产品的一个项目。
- en: 'Create the following `ngOnInit` method that combines both methods from *steps
    6* and *7* :'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下`ngOnInit`方法，该方法结合了*步骤6*和*步骤7*：
- en: '[PRE39]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Open the `cart.component.html` file and replace its HTML template with the
    following content:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`cart.component.html`文件，并用以下内容替换其HTML模板：
- en: '[PRE40]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the preceding template, we use a `@for` block to iterate over the `controls`
    property of the `products` form array and create an `<input>` element for each
    one. We use the `$index` keyword of the `@for` block to give a dynamically created
    name to each form control using the `formControlName` binding. We have also added
    a `<label>` tag that displays the product title from the `products` component
    property. The product title is fetched using the `$index` of the current product
    in the array.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的模板中，我们使用`@for`块遍历`products`表单数组的`controls`属性并为每个创建一个`<input>`元素。我们使用`@for`块的`$index`关键字通过`formControlName`绑定动态地为每个表单控件提供一个名称。我们还添加了一个`<label>`标签，用于显示`products`组件属性中的产品标题。产品标题是通过使用数组中当前产品的`$index`获取的。
- en: 'Finally, open the `cart.component.css` files and add the following CSS styles:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，打开`cart.component.css`文件并添加以下CSS样式：
- en: '[PRE41]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: To see the cart component in action, run the application using the `ng serve`
    command and add some products to the cart.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看购物车组件的实际效果，请使用`ng serve`命令运行应用程序并将一些产品添加到购物车中。
- en: Do not forget to log in first because the functionality that adds a product
    to the cart is available only to authenticated users.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记先登录，因为将产品添加到购物车的功能仅对认证用户可用。
- en: 'After adding some products to the cart, click the **My Cart** link to view
    your shopping cart. It should look like the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在将一些产品添加到购物车后，点击**我的购物车**链接以查看您的购物车。它应该看起来像以下这样：
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά, διάγραμμα  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_10_04.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本的图片、屏幕截图、字体、图表 自动生成的描述](img/B21418_10_04.png)'
- en: 'Figure 10.4: Shopping cart'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4：购物车
- en: 'Since we have established the business logic for managing a shopping cart,
    we can also update the checkout guard we created in the previous chapter:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经为管理购物车建立了业务逻辑，我们也可以更新上一章中创建的结账守卫：
- en: 'Open the `checkout.guard.ts` file and add the following `import` statements:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`checkout.guard.ts`文件并添加以下`import`语句：
- en: '[PRE42]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Inject the `CartService` class in the `checkoutGuard` function using the following
    statement:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下语句在`checkoutGuard`函数中注入`CartService`类：
- en: '[PRE43]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Modify the remaining body of the `checkoutGuard` arrow function so that we
    display the confirmation dialog only when the cart is not empty:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`checkoutGuard`箭头函数的剩余部分，以便仅在购物车不为空时显示确认对话框：
- en: '[PRE44]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: With the `FormArray` , we have completed our exploration of the most basic building
    blocks of an Angular form. We learned how to use Angular forms classes to create
    structured web forms and collect user input. In the following section, we will
    learn how to build Angular forms using the `FormBuilder` service.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`FormArray`，我们已经完成了对Angular表单最基本构建块的探索。我们学习了如何使用Angular表单类创建结构化Web表单并收集用户输入。在下一节中，我们将学习如何使用`FormBuilder`服务构建Angular表单。
- en: Using a form builder
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用表单构建器
- en: 'Using form classes to build Angular forms can become repetitive and tedious
    for complex scenarios. The Angular framework provides `FormBuilder` , a built-in
    service to Angular forms that contains helper methods for building forms. Let’s
    see how we could use it to build a form for creating new products:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 使用表单类构建Angular表单可能会在复杂场景中变得重复和繁琐。Angular框架提供了`FormBuilder`，这是一个内置的Angular表单服务，包含用于构建表单的辅助方法。让我们看看我们如何使用它来构建创建新产品的表单：
- en: 'Open the `product-create.component.ts` file and import the `OnInit` and `FormBuilder`
    artifacts:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`product-create.component.ts`文件并导入`OnInit`和`FormBuilder`组件：
- en: '[PRE45]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Add `OnInit` to the list of implemented interfaces in the `ProductCreateComponent`
    class:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`OnInit`添加到`ProductCreateComponent`类实现的接口列表中：
- en: '[PRE46]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Inject the `FormBuilder` class in the `constructor` :'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`constructor`中注入`FormBuilder`类：
- en: '[PRE47]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Modify the `productForm` property as follows:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式修改`productForm`属性：
- en: '[PRE48]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In the preceding snippet, we define only the structure of the form because it
    will now be created using the `FormBuilder` service.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们只定义了表单的结构，因为它现在将使用`FormBuilder`服务创建。
- en: 'Create the following method to build the form:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下方法来构建表单：
- en: '[PRE49]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the preceding method, we use the `nonNullable` property of the `FormBuilder`
    class to create a form group that cannot be null. The `group` method is used to
    group form controls. The `title` and `category` form controls are created using
    an empty string as the default value. The `price` form control follows a different
    approach from the rest because we cannot assign a default value of `undefined`
    due to TypeScript language limitations. In this case, we use the `control` method
    of the `nonNullable` property to define the form control.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的方法中，我们使用`FormBuilder`类的`nonNullable`属性创建一个不能为空的表单组。`group`方法用于组合表单控件。`title`和`category`表单控件使用空字符串作为默认值创建。`price`表单控件采用与其他不同的方法，因为我们不能因为TypeScript语言限制而分配`undefined`作为默认值。在这种情况下，我们使用`nonNullable`属性的`control`方法来定义表单控件。
- en: 'Add the `ngOnInit` lifecycle hook to execute the `buildForm` method:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ngOnInit`生命周期钩子添加到执行`buildForm`方法：
- en: '[PRE50]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Add the non-null assertion operator when accessing the `productForm` property
    in the `createProduct` method:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`createProduct`方法中访问`productForm`属性时添加非空断言运算符：
- en: '[PRE51]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Open the `product-create.component.html` file and add the non-null assertion
    operator in the `<form>` HTML element also:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`product-create.component.html`文件，并在`<form>`HTML元素中也添加非空断言运算符：
- en: '[PRE52]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Using the `FormBuilder` service to create Angular forms, we don’t have to deal
    with the `FormGroup` and `FormControl` data types explicitly, although that is
    what is being created under the hood.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`FormBuilder`服务创建Angular表单时，我们不需要显式处理`FormGroup`和`FormControl`数据类型，尽管底层正在创建这些类型。
- en: Run the application using the `ng serve` command and verify that the new product
    creation process works correctly. Try to click the **Create** button without entering
    any values in the form controls and observe what happens in the product list.
    The application creates a product with an empty title. It is a situation that
    we should avoid in a real-world scenario. We should be aware of the status of
    a form control and take action accordingly.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ng serve`命令运行应用程序，并验证新产品创建过程是否正确工作。尝试在不输入任何表单控件值的情况下点击**创建**按钮，并观察产品列表中的情况。应用程序创建了一个标题为空的产物。这是我们应在实际场景中避免的情况。我们应该意识到表单控件的状态并相应地采取行动。
- en: The example code in the rest of the chapter does not use the `FormBuilder` service
    when working with reactive forms.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 本章其余部分的示例代码在处理响应式表单时没有使用`FormBuilder`服务。
- en: In the following section, we’ll investigate different properties that we can
    check to get form status and provide feedback to the user.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将调查我们可以检查的不同属性，以获取表单状态并向用户提供反馈。
- en: Validating input in forms
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在表单中验证输入
- en: 'An Angular form should validate input and provide visual feedback to enhance
    UX and guide users to complete the form successfully. We will investigate the
    following ways to validate forms in Angular applications:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Angular表单应该验证输入并提供视觉反馈以增强用户体验并指导用户成功完成表单。我们将探讨以下在Angular应用程序中验证表单的方法：
- en: Global validation with CSS
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CSS的全局验证
- en: Validation in the component class
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件类中的验证
- en: Validation in the component template
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件模板中的验证
- en: Building custom validators
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建自定义验证器
- en: In the following section, we will learn how to apply validation rules globally
    in an Angular application using CSS styles.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何在Angular应用程序中使用CSS样式全局应用验证规则。
- en: Global validation with CSS
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用CSS的全局验证
- en: 'The Angular framework sets the following CSS classes automatically in a form,
    template-driven or reactive, that we can use to provide user feedback:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Angular框架在表单和模板驱动或响应式表单中自动设置以下CSS类，我们可以使用它们来提供用户反馈：
- en: '`ng-untouched` : Indicates that we have not interacted with a form yet'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-untouched` : 表示我们尚未与表单交互'
- en: '`ng-touched` : Indicates that we have interacted with a form'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-touched` : 表示我们已与表单交互'
- en: '`ng-dirty` : Indicates that we have set a value to a form'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-dirty` : 表示我们已经向表单设置了一个值'
- en: '`ng-pristine` : Indicates that we have not modified a form yet'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-pristine` : 表示我们尚未修改表单'
- en: 'Furthermore, Angular adds the following classes on the HTML element of a form
    control:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Angular还会在表单控制的HTML元素上添加以下类：
- en: '`ng-valid` : Indicates that the value of a form is valid'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-valid` : 表示表单的值有效'
- en: '`ng-invalid` : Indicates that the value of a form is not valid'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-invalid` : 表示表单的值无效'
- en: Angular sets the preceding CSS classes in the form and its controls according
    to their status. The form status is evaluated according to the status of its controls.
    For example, if at least one form control is invalid, Angular will set the `ng-invalid`
    CSS class to the form and the corresponding control.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Angular根据其状态在表单及其控件中设置上述CSS类。表单状态是根据其控件的状态评估的。例如，如果至少有一个表单控件无效，Angular将设置`ng-invalid`
    CSS类到表单和相应的控件。
- en: In the case of nested form hierarchies, the status of a child form group is
    bubbled up to the hierarchy and shared with its parent form.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌套表单层次结构的情况下，子表单组的状态会冒泡到层次结构中，并与父表单共享。
- en: 'We can use the built-in CSS classes and style Angular forms using CSS only.
    For example, to display a light blue highlighted border in an input control when
    interacting with that control for the first time, we should add the following
    style:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用内置的CSS类和仅使用CSS来样式化Angular表单。例如，为了在第一次与控件交互时在输入控件中显示浅蓝色高亮边框，我们应该添加以下样式：
- en: '[PRE53]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We can also combine CSS classes according to the needs of our application:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以根据应用程序的需要组合CSS类：
- en: 'Open the global `styles.css` file and modify the `input.valid` style as follows:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开全局的`styles.css`文件并按如下方式修改`input.valid`样式：
- en: '[PRE54]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The preceding style will display a green border when an input control has a
    valid value entered by the user.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 上述样式将在用户输入有效值时显示绿色边框。
- en: 'Modify the `input.invalid` style accordingly:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据需要修改`input.invalid`样式：
- en: '[PRE55]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The preceding style will display a red border when an input control has an invalid
    value entered by the user.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 上述样式将在用户输入无效值时显示红色边框。
- en: 'Open the `product-create.component.html` file and add the `required` attribute
    in the `<input>` form controls:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`product-create.component.html`文件并在`<input>`表单控件中添加`required`属性：
- en: '[PRE56]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Run the application using the `ng serve` command and navigate to `http://localhost:4200/products/new`
    .
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ng serve`命令运行应用程序并导航到`http://localhost:4200/products/new` 。
- en: Enter some text into the **Title** field and click outside of the input control.
    Notice that it has a green border.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**标题**字段中输入一些文本并点击输入控件之外。注意它有一个绿色边框。
- en: Remove the text from the **Title** field and click outside of the input control.
    The border should now turn red.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**标题**字段中删除文本并点击输入控件之外。现在边框应该变成红色。
- en: We learned how to define validation rules in the template using CSS styles.
    In the following section, we will learn how to define them in template-driven
    forms and give visual feedback using appropriate messages.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何在模板中使用CSS样式定义验证规则。在下一节中，我们将学习如何在模板驱动的表单中定义它们，并使用适当的消息提供视觉反馈。
- en: Validation in template-driven forms
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板驱动的表单验证
- en: 'In the preceding section, we learned that Angular adds a collection of built-in
    CSS classes while validating Angular forms. Each class has a corresponding boolean
    property in the respective form model, both in template-drive and reactive forms:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们了解到Angular在验证Angular表单时添加了一系列内置的CSS类。每个类在相应的表单模型中都有一个对应的布尔属性，无论是在模板驱动的表单还是响应式表单中：
- en: '`untouched` : Indicates that we have not interacted with a form yet'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`untouched`：表示我们尚未与表单交互'
- en: '`touched` : Indicates that we have interacted with a form'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`touched`：表示我们已与表单交互'
- en: '`dirty` : Indicates that we have set a value to a form'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dirty`：表示我们已经为表单设置了一个值'
- en: '`pristine` : Indicates that we have not modified a form yet'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pristine`：表示我们尚未修改表单'
- en: '`valid` : Indicates that the value of a form is valid'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`valid`：表示表单的值有效'
- en: '`invalid` : Indicates that the value of a form is not valid'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invalid`：表示表单的值无效'
- en: 'We can leverage the preceding classes and inform the user about the current
    form status. First, let’s investigate the behavior of the change price process
    in the product details component:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用前面的类来通知用户当前的表单状态。首先，让我们调查产品详情组件中更改价格过程的行为：
- en: Run the `ng serve` command to start the application and navigate to `http://localhost:4200`
    .
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`ng serve`命令以启动应用程序并导航到`http://localhost:4200`。
- en: Select a product from the list.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从列表中选择一个产品。
- en: Add a value of `0` into the **New price** input box and click the **Change**
    button.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**新价格**输入框中输入一个`0`的值并点击**更改**按钮。
- en: 'Select the same product from the list and observe the output:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从列表中选择相同的产品并观察输出：
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_10_05.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本的图片，屏幕截图，字体描述自动创建](img/B21418_10_05.png)'
- en: 'Figure 10.5: Product details'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5：产品详情
- en: The presentation logic of the component fails to detect that the user can enter
    `0` for the product price. A product should always have a price.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的展示逻辑未能检测到用户可以为产品价格输入`0`。产品应该始终有一个价格。
- en: The product details component needs to validate the input of the price value,
    and if the input is found to be invalid, disable the **Change** button, and display
    an informational message to the user.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 产品详情组件需要验证价格值的输入，如果发现输入无效，则禁用**更改**按钮，并向用户显示一条信息消息。
- en: Handling validation is a matter of personal preference or business specification.
    In this scenario, we decided to showcase a common validation approach by disabling
    the button and displaying an appropriate message.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 处理验证是个人偏好或业务规范的问题。在这种情况下，我们决定通过禁用按钮并显示适当的消息来展示一种常见的验证方法。
- en: 'Template-driven validation is performed in the component template. Open the
    `product-detail.component.html` file and execute the following steps:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 模板驱动的验证是在组件模板中执行的。打开`product-detail.component.html`文件并执行以下步骤：
- en: 'Create the `priceCtrl` template reference variable and bind it to the `ngModel`
    property:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`priceCtrl`模板引用变量并将其绑定到`ngModel`属性：
- en: '[PRE57]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `ngModel` property gives us access to the underlying form control model.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngModel`属性使我们能够访问底层表单控件模型。'
- en: 'Add the `required` and `min` validation attributes to the HTML element:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`required`和`min`验证属性添加到HTML元素：
- en: '[PRE58]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `min` validation attribute can be used only with `<input>` HTML elements
    of the `number` type. It is used to define the minimum value when using the arrows
    of the numeric control.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`min`验证属性只能与`<input>` HTML元素中的`number`类型一起使用。它用于在数字控件使用箭头时定义最小值。'
- en: 'Add the following `<span>` HTML element underneath the `<button>` element of
    the form:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在表单的`<button>`元素下方添加以下`<span>`HTML元素：
- en: '[PRE59]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The preceding HTML element will be displayed when we enter a price value and
    then either leave it blank or enter a zero. We use the `hasError` method of the
    form control model to check if the `min` validation throws an error.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们输入一个价格值然后留空或输入零时，将显示前面的HTML元素。我们使用表单控件模型的`hasError`方法来检查`min`验证是否抛出错误。
- en: All validation attributes can be checked using the `hasError` method. The validity
    status of a control is evaluated based on the status of all validation attributes
    we attach to the HTML element.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 所有验证属性都可以使用 `hasError` 方法进行检查。控件的有效性状态是根据我们附加到 HTML 元素的所有验证属性的状态来评估的。
- en: 'Add a `priceForm` template reference variable in the `<form>` HTML element
    and bind it to the `ngForm` property:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `<form>` HTML 元素中添加一个 `priceForm` 模板引用变量，并将其绑定到 `ngForm` 属性：
- en: '[PRE60]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The `ngForm` property gives us access to the underlying form model.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngForm` 属性为我们提供了访问底层表单模型的权限。'
- en: 'Bind the `disabled` property of the `<button>` HTML element to the `invalid`
    status of the form model:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `<button>` HTML 元素的 `disabled` 属性绑定到表单模型的 `invalid` 状态：
- en: '[PRE61]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In the preceding template, we could bind directly to the `priceCtrl.invalid`
    status since the form has only one control. We choose the form instead for demonstration
    purposes.
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的模板中，由于表单只有一个控件，我们可以直接绑定到 `priceCtrl.invalid` 状态。出于演示目的，我们选择表单。
- en: 'Open the `styles.css` file and add the following CSS styles for the `<span>`
    tag and the `disabled` button:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `styles.css` 文件，并为 `<span>` 标签和 `disabled` 按钮添加以下 CSS 样式：
- en: '[PRE62]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'To verify that the validation works as intended, execute the following steps:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证验证是否按预期工作，执行以下步骤：
- en: Run the `ng serve` command to start the application and select a product from
    the list.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `ng serve` 命令以启动应用程序，并从列表中选择一个产品。
- en: 'Enter `0` in the **New price** input box and observe the output:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **新价格** 输入框中输入 `0` 并观察输出：
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά, αριθμός  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_10_06.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本的图片，屏幕截图，字体，编号  自动生成的描述](img/B21418_10_06.png)'
- en: 'Figure 10.6: Validation error'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6：验证错误
- en: Enter a valid value and verify that the error message is gone and the **Change**
    button is enabled.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入一个有效值，并验证错误消息是否消失，以及 **更改** 按钮是否被启用。
- en: Leave the **New price** input box blank and verify that the error message is
    displayed again and the **Change** button is disabled.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **新价格** 输入框中留空，并验证错误消息是否再次显示，以及 **更改** 按钮是否被禁用。
- en: Now that we have learned how to accomplish validation in template-driven forms,
    let’s see how to validate input data in reactive ones.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了如何在模板驱动表单中完成验证，让我们看看如何验证响应式表单中的输入数据。
- en: Validation in reactive forms
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应式表单的验证
- en: Template-driven forms rely solely on the component template to perform validations.
    In reactive forms, the source of truth is our form model that resides in the TypeScript
    class of the component. We define validation rules in reactive forms when building
    the `FormGroup` instance programmatically.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 模板驱动表单完全依赖于组件模板来执行验证。在响应式表单中，真相之源是我们组件 TypeScript 类中驻留的表单模型。我们在构建 `FormGroup`
    实例时程序化地定义响应式表单中的验证规则。
- en: 'To demonstrate validation in reactive forms, we will add validation rules in
    the product create component:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示响应式表单中的验证，我们将在产品创建组件中添加验证规则：
- en: 'Open the `product-create.component.ts` file and import the `Validators` class
    from the `@angular/forms` npm package:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `product-create.component.ts` 文件，并从 `@angular/forms` npm 包中导入 `Validators`
    类：
- en: '[PRE63]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Modify the declaration of the `productForm` property so that the `title` and
    `price` form controls pass a `validators` property in the `FormControl` instance:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `productForm` 属性的声明，以便 `title` 和 `price` 表单控件在 `FormControl` 实例中传递一个 `validators`
    属性：
- en: '[PRE64]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The `Validators` class contains a static field for each validation rule available.
    It contains almost the same validator rules that are available for template-driven
    forms. We can combine multiple validators by adding them to an array, as indicated
    by the `validators` property in the `price` form control.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`Validators` 类包含每个可用验证规则的静态字段。它包含几乎与模板驱动表单中可用的相同验证规则。我们可以通过将它们添加到数组中，如 `price`
    表单控件中的 `validators` 属性所示，来组合多个验证器。'
- en: When we add a validator using the `FormControl` class, we can remove the respective
    HTML attribute from the HTML template. However, it is recommended to keep it for
    accessibility purposes so that screen-reader applications can use it.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `FormControl` 类添加验证器时，我们可以从 HTML 模板中删除相应的 HTML 属性。然而，出于可访问性的目的，建议保留它，以便屏幕阅读器应用程序可以使用它。
- en: 'Open the `product-create.component.html` file and use the `invalid` property
    of the `productForm` property to disable the `Create` button:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `product-create.component.html` 文件，并使用 `productForm` 属性的 `invalid` 属性来禁用
    **创建** 按钮：
- en: '[PRE65]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Add a `<span>` HTML element in each `<input>` form control to display an error
    message when the control has been touched, and the `required` validation throws
    an error:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个`<input>`表单控件中添加一个`<span>` HTML元素，以在控件被触摸且`required`验证抛出错误时显示错误消息：
- en: '[PRE66]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: In the preceding snippet, we use the `controls` property of the `productForm`
    property to get access to the individual form control models and get their statuses.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用`productForm`属性的`controls`属性来访问单个表单控件模型并获取它们的状态。
- en: 'It would be nice to display different messages depending on the validation
    rule. We could display a more specific message when the `min` validation of the
    `price` control throws an error, for example. We can use the `hasError` method
    that we saw in the preceding section to display such a message:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据验证规则显示不同的消息会很方便。例如，当`price`控件的`min`验证抛出错误时，我们可以显示一个更具体的消息。我们可以使用前面章节中看到的`hasError`方法来显示这样的消息：
- en: '[PRE67]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The Angular framework provides a set of built-in validators that we learned
    to use in our forms. In the following section, we will learn how to create a custom
    validator for template-driven and reactive forms to satisfy particular business
    needs.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: Angular框架提供了一套内置验证器，我们已经在我们的表单中学习了如何使用它们。在下一节中，我们将学习如何为模板驱动和响应式表单创建自定义验证器以满足特定的业务需求。
- en: Building custom validators
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建自定义验证器
- en: Built-in validators won’t cover all the scenarios we might encounter in an Angular
    application; however, writing a custom validator and using it in an Angular form
    is easy. In our case, we will build a validator to check that the price of a product
    cannot exceed a specified threshold.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 内置验证器可能无法涵盖我们在Angular应用程序中可能遇到的所有场景；然而，编写自定义验证器并在Angular表单中使用它是很容易的。在我们的例子中，我们将构建一个验证器来检查产品的价格不能超过指定的阈值。
- en: We could use the built-in `max` validator to accomplish the same task. However,
    we will be building the validator function for learning purposes.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用内置的`max`验证器来完成同样的任务。然而，我们将为了学习目的构建验证器函数。
- en: Custom validators are used when we want to validate a form or a control with
    custom code. For example, to communicate with an API for validating a value, or
    to perform a complex calculation for validating a value.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要使用自定义代码验证表单或控件时，会使用自定义验证器。例如，为了与API通信以验证值，或者执行复杂的计算以验证值。
- en: 'Create a file named `price-maximum.validator.ts` in the `src\app` folder and
    add the following contents:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src\app`文件夹中创建一个名为`price-maximum.validator.ts`的文件，并添加以下内容：
- en: '[PRE68]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: A form validator is a function that returns a `ValidationErrors` object with
    the error specified or a `null` value. It accepts the form control to which it
    will be applied as a parameter. In the preceding snippet, if the control value
    is larger than a specific threshold passed in the `price` parameter of the exported
    function, it returns a validation error object. Otherwise, it returns `null` .
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 表单验证器是一个返回包含指定错误或`null`值的`ValidationErrors`对象的函数。它接受将被应用到的表单控件作为参数。在前面的代码片段中，如果控件值大于通过导出函数的`price`参数传递的特定阈值，它将返回一个验证错误对象。否则，它返回`null`。
- en: The key of the validation error object specifies a descriptive name for the
    validator error. It is a name we can later check with the `hasError` method of
    the control to find out if it has any errors. The value of the validation error
    object can be any arbitrary value that we can pass in the error message.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 验证错误对象的键指定了验证器错误的描述性名称。这是一个我们可以稍后通过控件的`hasError`方法进行检查的名称，以找出它是否有任何错误。验证错误对象的值可以是任何任意值，我们可以将其传递到错误消息中。
- en: 'Open the `product-create.component.ts` file and add the following `import`
    statement:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`product-create.component.ts`文件，并添加以下`import`语句：
- en: '[PRE69]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Add the validator in the `validators` array of the `price` form control and
    set the threshold to `1000` :'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`price`表单控件的`validators`数组中添加验证器，并将阈值设置为`1000`：
- en: '[PRE70]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Add a new `<span>` HTML element for the price form control in the `product-create.component.html`
    file:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`product-create.component.html`文件中为价格表单控件添加一个新的`<span>` HTML元素：
- en: '[PRE71]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Run the `ng` `serve` command to start the application and navigate to `http://localhost:4200/products/new`
    .
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`ng serve`命令以启动应用程序并导航到`http://localhost:4200/products/new`。
- en: 'Enter a value of `1200` in the **Price** field, click outside the input box,
    and observe the output:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**价格**字段中输入`1200`的值，点击输入框外部，并观察输出结果：
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά, αριθμός  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_10_07.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本的图像，屏幕截图，字体，编号  自动生成的描述](img/B21418_10_07.png)'
- en: 'Figure 10.7: Validation in reactive forms'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7：响应式表单中的验证
- en: 'To use the price maximum validator in a template-driven form, we must follow
    a different approach that involves creating an Angular directive:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 要在模板驱动的表单中使用价格最大值验证器，我们必须遵循不同的方法，该方法涉及创建Angular指令：
- en: 'Run the following command to create an Angular directive:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令创建Angular指令：
- en: '[PRE72]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The preceding directive will act as a wrapper over the `priceMaximumValidator`
    function we have already created.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的指令将作为我们已创建的`priceMaximumValidator`函数的包装器。
- en: 'Open the `price-maximum.directive.ts` file and modify the `import` statements
    as follows:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`price-maximum.directive.ts`文件并按如下方式修改`import`语句：
- en: '[PRE73]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Add the `NG_VALIDATORS` provider in the `@Directive` decorator:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`@Directive`装饰器中添加`NG_VALIDATORS`提供者：
- en: '[PRE74]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The `NG_VALIDATORS` token is a built-in token of Angular forms that helps us
    register an Angular directive as a form validator. In the preceding snippet, we
    use the `multi` property in the provider configuration because we can register
    multiple directives with the `NG_VALIDATORS` token.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`NG_VALIDATORS`令牌是Angular表单的内置令牌，它帮助我们注册Angular指令作为表单验证器。在上面的代码片段中，我们使用提供者配置中的`multi`属性，因为我们可以使用`NG_VALIDATORS`令牌注册多个指令。'
- en: 'Add the `Validator` interface in the implemented interfaces of the `PriceMaximumDirective`
    class:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PriceMaximumDirective`类的实现接口中添加`Validator`接口：
- en: '[PRE75]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Add the following input property that will be used to pass a value for the
    maximum threshold:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下输入属性，该属性将用于传递最大阈值值：
- en: '[PRE76]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: In the preceding property, we pass a configuration object with two properties
    as a parameter in the `input` function. The `alias` property defines the name
    of the input property that we will use for binding. The `transform` property is
    used to convert the value of the input property to a different type. The `numberAttribute`
    is a built-in function of the Angular framework that converts the input property
    value to a number.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的属性中，我们将包含两个属性配置对象作为`input`函数的参数。`alias`属性定义了我们将用于绑定的输入属性名称。`transform`属性用于将输入属性值转换为不同类型。`numberAttribute`是Angular框架的内置函数，它将输入属性值转换为数字。
- en: Angular also contains the `booleanAttribute` function, which parses an input
    property value as a boolean.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: Angular还包含`booleanAttribute`函数，该函数将输入属性值解析为布尔值。
- en: 'Implement the `validate` method of the `Validator` interface as follows:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式实现`Validator`接口的`validate`方法：
- en: '[PRE77]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The signature of the `validate` method is the same as the function returned
    from the `priceMaximumValidator` function. It checks the `appPriceMaximum` input
    property and accordingly delegates its value to the `priceMaximumValidator` function.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`validate`方法的签名与`priceMaximumValidator`函数返回的函数相同。它检查`appPriceMaximum`输入属性，并根据情况将值委托给`priceMaximumValidator`函数。'
- en: 'We will use the new directive we created in the product detail component:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在产品详情组件中使用我们创建的新指令：
- en: 'Open the `product-detail.component.ts` file and add the following `import`
    statement:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`product-detail.component.ts`文件并添加以下`import`语句：
- en: '[PRE78]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Add the `PriceMaximumDirective` class in the `imports` array of the `@Component`
    decorator:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`@Component`装饰器的`imports`数组中添加`PriceMaximumDirective`类：
- en: '[PRE79]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Open the `product-detail.component.html` file and add the new validator in
    the `<input>` HTML element:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`product-detail.component.html`文件并在`<input>`HTML元素中添加新的验证器：
- en: '[PRE80]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Add a new `<span>` HTML element to display a different message when the validator
    throws an error:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的`<span>`HTML元素，当验证器抛出错误时显示不同的消息：
- en: '[PRE81]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Run the `ng serve` command to start the application and select a product from
    the list.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`ng serve`命令以启动应用程序并从列表中选择一个产品。
- en: 'Enter the value `600` in the **New price** input box and observe the output:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**新价格**输入框中输入值`600`并观察输出：
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_10_08.png)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、屏幕截图、字体样式的自动生成的描述](img/B21418_10_08.png)'
- en: 'Figure 10.8: Validation in template-driven forms'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8：模板驱动表单中的验证
- en: Angular custom validations can work synchronously or asynchronously. In this
    section, we learned how to work with the former. Asynchronous validations are
    an advanced topic that we will not cover in this book. However, you can learn
    more at [https://angular.dev/guide/forms/form-validation#creating-asynchronous-validators](https://angular.dev/guide/forms/form-validation#creating-asynchronous-validators)
    .
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: Angular自定义验证可以同步或异步工作。在本节中，我们学习了如何使用前者。异步验证是一个高级主题，我们不会在本书中涉及。然而，你可以在[https://angular.dev/guide/forms/form-validation#creating-asynchronous-validators](https://angular.dev/guide/forms/form-validation#creating-asynchronous-validators)了解更多信息。
- en: In the following section, we will explore manipulating the state of an Angular
    form.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨操作Angular表单的状态。
- en: Manipulating form state
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作表单状态
- en: 'The state of an Angular form differs between template-driven and reactive forms.
    In the former, the state is a plain object, whereas in the latter, it is kept
    in the form model. In this section, we will learn about the following concepts:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: Angular表单的状态在模板驱动和响应式表单之间有所不同。在前者中，状态是一个普通对象，而在后者中，它保存在表单模型中。在本节中，我们将学习以下概念：
- en: Updating form state
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新表单状态
- en: Reacting to state changes
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对状态变化做出反应
- en: We will start by exploring how we can change the form state.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先探讨如何更改表单状态。
- en: Updating form state
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新表单状态
- en: Working with the form state in template-driven forms is relatively easy. We
    must interact with the component property bound to the `ngModel` directive of
    a form control.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板驱动的表单中处理表单状态相对简单。我们必须与绑定到表单控件`ngModel`指令的组件属性进行交互。
- en: 'In reactive forms, we can use the `value` property of a `FormControl` instance
    or the following methods of the `FormGroup` class to change values in the whole
    form:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应式表单中，我们可以使用`FormControl`实例的`value`属性或`FormGroup`类的以下方法来更改整个表单中的值：
- en: '`setValue` : Replaces values in all controls of the form'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setValue`：替换表单中所有控件的值'
- en: '`patchValue` : Updates values in specific controls of the form'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`patchValue`：更新表单中特定控件的值'
- en: 'The `setValue` method accepts an object as a parameter that contains key-value
    pairs for all form controls. If we want to fill in the details of a product in
    the product create component programmatically, the following snippet serves as
    an example:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`setValue`方法接受一个对象作为参数，该对象包含所有表单控件的键值对。如果我们想以编程方式在产品创建组件中填写产品的详细信息，以下代码片段可以作为示例：'
- en: '[PRE82]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: In the preceding snippet, each key of the object passed in the `setValue` method
    must match the name of each form control. If we omit one, Angular will throw an
    error.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，传递给`setValue`方法的对象中的每个键都必须与每个表单控件的名称匹配。如果我们省略一个，Angular将抛出错误。
- en: 'If we want to fill in some of the details of a product, we can use the `patchValue`
    method:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想填写一些产品的详细信息，可以使用`patchValue`方法：
- en: '[PRE83]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The `setValue` and `patchValue` methods of the `FormGroup` class help us set
    data in a form.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '`FormGroup`类的`setValue`和`patchValue`方法帮助我们设置表单中的数据。'
- en: Another interesting aspect of forms is that we can be notified when these values
    change, as we will see in the following section.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 表单的另一个有趣方面是，当这些值发生变化时，我们可以收到通知，正如我们将在下一节中看到的那样。
- en: Reacting to state changes
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对状态变化做出反应
- en: 'A common scenario when working with Angular forms is that we want to trigger
    a side effect when the value of a form control changes. A side effect can be any
    of the following:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Angular表单时，一个常见的场景是我们希望在表单控件的值变化时触发副作用。副作用可以是以下任何一种：
- en: To alter the value of a form control
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要更改表单控件的值
- en: To initiate an HTTP request to filter the value of a form control
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了发起一个HTTP请求来过滤表单控件的值
- en: To enable/disable certain parts of the component template
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了启用/禁用组件模板的某些部分
- en: 'In template-driven forms, we can use an extended version of the `ngModel` directive
    to get notified when its value changes. The `ngModel` directive contains the following
    bindable properties:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板驱动的表单中，我们可以使用`ngModel`指令的扩展版本来在值变化时得到通知。`ngModel`指令包含以下可绑定属性：
- en: '`ngModel` : An input property for passing values to the control'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngModel`：一个输入属性，用于将值传递到控件'
- en: '`ngModelChange` : An output property for getting notified when the control
    value changes'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngModelChange`：当控件值变化时得到通知的输出属性'
- en: 'We can write the `ngModel` binding in the `<input>` HTML element of the product
    detail component in the following alternate way:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在产品详情组件的`<input>`HTML元素中以下方式编写`ngModel`绑定：
- en: '[PRE84]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: In the preceding snippet, we set the value of the `ngModel` input property using
    property binding and the value of the `price` component property using event binding.
    Angular triggers the `ngModelChange` event automatically and includes the new
    value of the `<input>` HTML element in the `$event` property. We can use the `ngModelChange`
    event for any side effects in our component when the value of the price form control
    changes.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用属性绑定设置了`ngModel`输入属性的值，并使用事件绑定设置了`price`组件属性的值。Angular会自动触发`ngModelChange`事件，并将新值包含在`$event`属性中。当价格表单控件的值发生变化时，我们可以使用`ngModelChange`事件在我们的组件中进行任何副作用。
- en: In reactive forms, we use an observable-based API to react to state changes.
    The `FormGroup` and `FormControl` classes contain the `valueChanges` observable,
    which we can use to subscribe and get notified when the value of the form or control
    changes.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应式表单中，我们使用基于可观察的API来响应状态变化。`FormGroup`和`FormControl`类包含`valueChanges`可观察流，我们可以使用它来订阅并在表单或控件的值发生变化时接收通知。
- en: 'We will use it to reset the value of the `price` form control in the product
    create component when the category changes:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用它来在类别更改时重置产品创建组件中`price`表单控件的值：
- en: 'Open the `product-create.component.ts` file and import the `OnInit` artifact
    from the `@angular/core` npm package:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`product-create.component.ts`文件并从`@angular/core` npm包中导入`OnInit`实体：
- en: '[PRE85]'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Add the `OnInit` interface to the list of the `ProductCreateComponent` class
    implemented interfaces:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`OnInit`接口添加到`ProductCreateComponent`类实现的接口列表中：
- en: '[PRE86]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Create the following `ngOnInit` method to subscribe to the `valueChanges` property
    of the `category` form control:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下`ngOnInit`方法以订阅`category`表单控件的`valueChanges`属性：
- en: '[PRE87]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: In the preceding method, we reset the value of the `price` form control by using
    the `reset` method of the `FormControl` class.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的方法中，我们通过使用`FormControl`类的`reset`方法来重置`price`表单控件的值。
- en: The `valueChanges` property of the `FormControl` class is a standard observable
    stream. Do not forget to unsubscribe when the component is destroyed.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '`FormControl`类的`valueChanges`属性是一个标准的可观察流。当组件被销毁时，不要忘记取消订阅。'
- en: Of course, there is more that we can do with the `valueChanges` observable;
    for example, we could check if the product title is already reserved by sending
    it to a backend API. Hopefully, however, the preceding examples have conveyed
    how you can take advantage of the reactive nature of forms and respond accordingly.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们还可以使用`valueChanges`可观察流做更多的事情；例如，我们可以通过将其发送到后端API来检查产品标题是否已被预留。然而，希望前面的例子已经传达了如何利用表单的响应性特性并相应地做出反应。
- en: Summary
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned that Angular provides two different flavors for
    creating forms – template-driven and reactive – and neither approach is better
    than the other. We explored how to build each form type and perform validations
    on input data, and covered custom validations for implementing additional validation
    scenarios. We also learned how to update the state of a form and how to react
    when the values in the state change.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解到Angular提供了两种不同的创建表单的方法——模板驱动和响应式——并且没有一种方法比另一种更好。我们探讨了如何构建每种类型的表单以及如何对输入数据进行验证，并涵盖了自定义验证以实现额外的验证场景。我们还学习了如何更新表单的状态以及当状态中的值发生变化时如何做出反应。
- en: In the following chapter, we will explore various ways of handling application
    errors. Error handling is a very important feature of an Angular application and
    can have different sources and reasons, as we will see.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨处理应用程序错误的各种方法。错误处理是Angular应用程序的一个非常重要的特性，并且可能具有不同的来源和原因，正如我们将看到的。
