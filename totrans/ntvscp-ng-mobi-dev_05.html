<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Routing and Lazy Loading</h1>
                
            
            <article>
                
<p class="mce-root"><span>Routing is essential to the solid usability flow of any app. Let's understand the key elements of routing configuration for a mobile app that takes advantage of all the flexibility Angular's router gives us.</span><br class="title-page-name"/></p>
<p class="mce-root">In this chapter, we will be covering the following topics:</p>
<ul class="calibre13">
<li class="calibre14">Configuring the Angular Router with a NativeScript app</li>
<li class="calibre14">Lazy loading modules by route</li>
<li class="calibre14">Provide NSModuleFactoryLoader for Angular's NgModuleFactoryLoader</li>
<li class="calibre14">Understanding how to use router-outlet in conjunction with page-router-outlet</li>
<li class="calibre14">Learn how to share singleton services across multiple lazy loaded modules</li>
<li class="calibre14">Using auth guards to protect views that require valid authentication</li>
<li class="calibre14">Learn about <kbd class="calibre11">NavigationButton</kbd> to customize back mobile navigation</li>
<li class="calibre14">Take advantage of our flexible routing setup by introducing late feature requirements</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Get your kicks on Route 66</h1>
                
            
            <article>
                
<p class="mce-root">As we begin our journey down this highway full of adventure, let's start with a pit stop at our local service shop to ensure our vehicle is in tip-top shape. Take a turn into the root directory of <kbd class="calibre11">app</kbd> to build a new add-on to our vehicle's engine: the routing module.</p>
<p class="mce-root">Create a new routing module, <kbd class="calibre11">app/app.routing.ts</kbd>, with the following contents:</p>
<pre class="calibre22">import { NgModule } from '@angular/core';<br class="title-page-name"/>import { NativeScriptRouterModule } <br class="title-page-name"/>  from 'nativescript-angular/router';<br class="title-page-name"/>import { Routes } from '@angular/router';<br class="title-page-name"/><br class="title-page-name"/>const routes: Routes = [<br class="title-page-name"/>  {<br class="title-page-name"/>    path: '',<br class="title-page-name"/>    redirectTo: '/mixer/home',<br class="title-page-name"/>    pathMatch: 'full'<br class="title-page-name"/>  },<br class="title-page-name"/>  {<br class="title-page-name"/>    path: 'mixer',<br class="title-page-name"/>    loadChildren: () =&gt; require('./modules/mixer/mixer.module')['MixerModule']<br class="title-page-name"/>  },<br class="title-page-name"/>  {<br class="title-page-name"/>    path: 'record',<br class="title-page-name"/>    loadChildren: () =&gt; require('./modules/recorder/recorder.module')['RecorderModule']<br class="title-page-name"/>  }<br class="title-page-name"/>];<br class="title-page-name"/><br class="title-page-name"/>@NgModule({<br class="title-page-name"/>  imports: [<br class="title-page-name"/>    NativeScriptRouterModule.forRoot(routes)<br class="title-page-name"/>  ],<br class="title-page-name"/>  exports: [<br class="title-page-name"/>    NativeScriptRouterModule<br class="title-page-name"/>  ]<br class="title-page-name"/>})<br class="title-page-name"/>export class AppRoutingModule { }</pre>
<p class="mce-root">Defining the root <kbd class="calibre11">''</kbd> path to redirect to a lazy loaded module provides a very flexible routing configuration, as you will see throughout this chapter. You will see a new module, <kbd class="calibre11">MixerModule</kbd>, which we will create momentarily. In fact, it will largely end up being what <kbd class="calibre11">AppComponent</kbd> is right now. Here's a list of some advantages you gain with a route configuration similar to this:</p>
<ul class="calibre13">
<li class="calibre14">Keeps app startup time fast by eagerly loading only the bare minimum root module configuration, then rapidly loading the first route's module lazily</li>
<li class="calibre14">Provides us with the ability to utilize <kbd class="calibre11">page-router-outlet</kbd> in conjunction with <kbd class="calibre11">router-outlet</kbd> for a combination of master/detail navigation as well as the <kbd class="calibre11">clearHistory</kbd> swap page navigation</li>
<li class="calibre14">Isolates routing configuration responsibility to the modules it concerns which scales well over time</li>
<li class="calibre14">Allows us to target different <strong class="calibre1">start pages</strong> easily in the future if we decide to change the initial page our users are presented with</li>
</ul>
<p class="mce-root">This uses <kbd class="calibre11">NativeScriptRoutingModule.forRoot(routes)</kbd>, since this should be considered the root of our app's routing configuration.</p>
<p class="mce-root">We also export <kbd class="calibre11">NativeScriptRoutingModule</kbd>, since we will be importing this <kbd class="calibre11">AppRoutingModule</kbd> into our root <kbd class="calibre11">AppModule</kbd> in a moment. This makes the routing directives available to our root module's root component.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Providing NSModuleFactoryLoader for NgModuleFactoryLoader</h1>
                
            
            <article>
                
<p class="mce-root">By default, Angular's built-in module loader uses SystemJS; however, NativeScript provides an enhanced module loader called <kbd class="calibre11">NSModuleFactoryLoader</kbd>. Let's provide this in our main routing module to ensure all our modules are loaded with it instead of Angular's default module loader.</p>
<p class="mce-root">Make the following modifications to <kbd class="calibre11">app/app.routing.ts</kbd>:</p>
<pre class="calibre22">import { NgModule, <strong class="calibre1">NgModuleFactoryLoader</strong> } from '@angular/core';<br class="title-page-name"/>import { NativeScriptRouterModule, <strong class="calibre1">NSModuleFactoryLoader</strong> } from 'nativescript-angular/router';<br class="title-page-name"/><br class="title-page-name"/>const routes: Routes = [<br class="title-page-name"/>  {<br class="title-page-name"/>    path: '',<br class="title-page-name"/>    redirectTo: '/mixer/home',<br class="title-page-name"/>    pathMatch: 'full'<br class="title-page-name"/>  },<br class="title-page-name"/>  {<br class="title-page-name"/>    path: 'mixer',<br class="title-page-name"/>    loadChildren: <strong class="calibre1">'./modules/mixer/mixer.module#MixerModule'</strong><br class="title-page-name"/>  },<br class="title-page-name"/>  {<br class="title-page-name"/>    path: 'record',<br class="title-page-name"/>    loadChildren: <strong class="calibre1">'./modules/recorder/recorder.module#RecorderModule'</strong>,<br class="title-page-name"/>    canLoad: [AuthGuard]<br class="title-page-name"/>  }<br class="title-page-name"/>];<br class="title-page-name"/><br class="title-page-name"/>@NgModule({<br class="title-page-name"/>  imports: [<br class="title-page-name"/>    NativeScriptRouterModule.forRoot(routes)<br class="title-page-name"/>  ],<br class="title-page-name"/>  providers: [<br class="title-page-name"/>    AuthGuard,<br class="title-page-name"/>    <strong class="calibre1">{</strong><br class="title-page-name"/><strong class="calibre1">      provide: NgModuleFactoryLoader,</strong><br class="title-page-name"/><strong class="calibre1">      useClass: NSModuleFactoryLoader</strong><br class="title-page-name"/><strong class="calibre1">    }</strong><br class="title-page-name"/>  ],<br class="title-page-name"/>  exports: [<br class="title-page-name"/>    NativeScriptRouterModule<br class="title-page-name"/>  ]<br class="title-page-name"/>})<br class="title-page-name"/>export class AppRoutingModule { }</pre>
<p class="mce-root">Now, we can use the standard Angular lazy loading syntax via <kbd class="calibre11">loadChildren</kbd> by specifying the default <kbd class="calibre11">NgModuleFactoryLoader</kbd> but should instead use NativeScript's enhanced <kbd class="calibre11">NSModuleFactoryLoader</kbd>. We won't go into what <kbd class="calibre11">NSModuleFactoryLoader</kbd> provides in detail, since it is explained very well here: <a href="https://www.nativescript.org/blog/optimizing-app-loading-time-with-angular-2-lazy-loading" class="calibre3">https://www.nativescript.org/blog/optimizing-app-loading-time-with-angular-2-lazy-loading</a>, and we have a lot more we want to cover in this book.</p>
<p class="mce-root">Excellent. With these upgrades in place, we can leave the service shop and continue on our journey down the highway. Let's move on to implementing our new routing setup. </p>
<p class="mce-root">Open <kbd class="calibre11">app/app.component.html</kbd>; cut its contents to the clipboard and replace them with the following:</p>
<pre class="calibre22">&lt;page-router-outlet&gt;&lt;/page-router-outlet&gt;</pre>
<p class="mce-root">This will be the base of our view level implementation. <kbd class="calibre11">page-router-outlet</kbd> allows any Component to insert itself in its place, whether it be a single flat route or one with child views of its own. It also allows other Component views to push onto the mobile nav stack, allowing master/detail mobile navigation with back history.</p>
<p class="mce-root">In order for this <kbd class="calibre11">page-router-outlet</kbd> directive to work, we need our root <kbd class="calibre11">AppModule</kbd> to import our new <kbd class="calibre11">AppRoutingModule</kbd>. We will also take this opportunity to remove <kbd class="calibre11">PlayerModule</kbd>, which was imported here before. Open <kbd class="calibre11">app/app.module.ts</kbd> and make the following modifications:</p>
<pre class="calibre22">// angular<br class="title-page-name"/>import { NgModule } from '@angular/core';<br class="title-page-name"/><br class="title-page-name"/>// app<br class="title-page-name"/>import { CoreModule } from './modules/core/core.module';<br class="title-page-name"/><strong class="calibre1">import { AppRoutingModule } from './app.routing';</strong><br class="title-page-name"/>import { AppComponent } from './app.component';<br class="title-page-name"/><br class="title-page-name"/>@NgModule({<br class="title-page-name"/> imports: [<br class="title-page-name"/>   CoreModule,<br class="title-page-name"/>   <strong class="calibre1">AppRoutingModule</strong><br class="title-page-name"/> ],<br class="title-page-name"/> declarations: [AppComponent],<br class="title-page-name"/> bootstrap: [AppComponent]<br class="title-page-name"/>})<br class="title-page-name"/>export class AppModule { }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating MixerModule</h1>
                
            
            <article>
                
<p class="mce-root">This module really won't be anything new, as it will serve as a relocation of what was previously our root component's view. However, it will introduce an extra nicety: the ability to define its own inner routes.</p>
<p class="mce-root">Create <kbd class="calibre11">app/modules/mixer/components/mixer.component.html</kbd> and paste the contents from where we had cut from the  <kbd class="calibre11">app.component.html</kbd>:</p>
<pre class="calibre22">&lt;ActionBar title="TNSStudio" class="action-bar"&gt;&lt;/ActionBar&gt;&lt;GridLayout rows="*, 100" columns="*" class="page"&gt;  <br class="title-page-name"/>  &lt;track-list row="0" col="0"&gt;&lt;/track-list&gt;  <br class="title-page-name"/>  &lt;player-controls row="1" col="0"&gt;&lt;/player-controls&gt;&lt;/GridLayout&gt;</pre>
<p class="mce-root">Then create a matching <kbd class="calibre11">app/modules/mixer/components/mixer.component.ts</kbd>:</p>
<pre class="calibre22">import { Component } from '@angular/core';<br class="title-page-name"/><br class="title-page-name"/>@Component({ <br class="title-page-name"/>  moduleId: module.id, <br class="title-page-name"/>  selector: 'mixer', <br class="title-page-name"/>  templateUrl: 'mixer.component.html'<br class="title-page-name"/>})<br class="title-page-name"/>export class MixerComponent {}</pre>
<p class="mce-root">Now, we will create <kbd class="calibre11">BaseComponent</kbd>, which will serve as the placeholder for not only the preceding <kbd class="calibre11">MixerComponent</kbd> but also any other child view components we may want to present in its place. For example, our mixer may want to allow users to pop a single track out of the mixer and into an isolated view to work with audio effects.</p>
<p class="mce-root">Create <kbd class="calibre11">app/modules/mixer/components/base.component.ts</kbd> with the following:</p>
<pre class="calibre22">// angular<br class="title-page-name"/>import { Component } from '@angular/core';<br class="title-page-name"/><br class="title-page-name"/>@Component({<br class="title-page-name"/> moduleId: module.id,<br class="title-page-name"/> selector: 'mixer-base',<br class="title-page-name"/> template: `&lt;router-outlet&gt;&lt;/router-outlet&gt;`<br class="title-page-name"/>})<br class="title-page-name"/>export class BaseComponent { }</pre>
<p class="mce-root">This provides a slot to insert any child routes our mixer configures, one of which is <kbd class="calibre11">MixerComponent</kbd> itself. Since the view is just a simple <kbd class="calibre11">router-outlet</kbd>, there's really no need to create a separate <kbd class="calibre11">templateUrl</kbd>, so we have just inlined it here.</p>
<p class="mce-root">Now we are ready to implement <kbd class="calibre11">MixerModule</kbd>; create <kbd class="calibre11">app/modules/mixer/mixer.module.ts</kbd> with the following:</p>
<pre class="calibre22">import { NgModule, NO_ERRORS_SCHEMA } from '@angular/core';<br class="title-page-name"/>import { NativeScriptRouterModule } from <br class="title-page-name"/>  'nativescript-angular/router';<br class="title-page-name"/>import { Routes } from '@angular/router';<br class="title-page-name"/><br class="title-page-name"/>import { PlayerModule } from '../player/player.module';<br class="title-page-name"/>import { BaseComponent } from './components/base.component';<br class="title-page-name"/>import { MixerComponent } from <br class="title-page-name"/>  './components/mixer.component';<br class="title-page-name"/><br class="title-page-name"/>const COMPONENTS: any[] = [<br class="title-page-name"/>  BaseComponent,<br class="title-page-name"/>  MixerComponent<br class="title-page-name"/>]<br class="title-page-name"/><br class="title-page-name"/>const routes: Routes = [<br class="title-page-name"/>  {<br class="title-page-name"/>    path: '',<br class="title-page-name"/>    component: BaseComponent,<br class="title-page-name"/>    children: [<br class="title-page-name"/>      {<br class="title-page-name"/>        path: 'home',<br class="title-page-name"/>        component: MixerComponent<br class="title-page-name"/>      }<br class="title-page-name"/>    ]<br class="title-page-name"/>  }<br class="title-page-name"/>];<br class="title-page-name"/><br class="title-page-name"/>@NgModule({<br class="title-page-name"/>  imports: [<br class="title-page-name"/>    PlayerModule,<br class="title-page-name"/>    NativeScriptRouterModule.forChild(routes)<br class="title-page-name"/>  ],<br class="title-page-name"/>  declarations: [<br class="title-page-name"/>    ...COMPONENTS<br class="title-page-name"/>  ],<br class="title-page-name"/>  schemas: [<br class="title-page-name"/>    NO_ERRORS_SCHEMA<br class="title-page-name"/>  ]<br class="title-page-name"/>})<br class="title-page-name"/>export class MixerModule { }</pre>
<p class="mce-root">We have imported <kbd class="calibre11">PlayerModule</kbd> since the mixer uses components/widgets defined there (namely, <kbd class="calibre11">track-list</kbd> and <kbd class="calibre11">player-controls</kbd>). We are also utilizing the <kbd class="calibre11">NativeScriptRouterModule.forChild(routes)</kbd> method to indicate that these are specifically child routes. Our route configuration sets up the BaseComponent at the root <kbd class="calibre11">' '</kbd> path, which defines <kbd class="calibre11">'home'</kbd> as <kbd class="calibre11">MixerComponent</kbd>. If you recall, our app's <kbd class="calibre11">AppRoutingModule</kbd> configured the root path of our app, as follows:</p>
<pre class="calibre22">...<br class="title-page-name"/>{<br class="title-page-name"/>  path: '',<br class="title-page-name"/>  redirectTo: '/mixer/home',<br class="title-page-name"/>  pathMatch: 'full'<br class="title-page-name"/>},<br class="title-page-name"/>...</pre>
<p class="mce-root">This will route directly to <kbd class="calibre11">MixerComponent</kbd> here, defined as <kbd class="calibre11">'home'</kbd>. We could easily direct the start page to a different view by pointing <kbd class="calibre11">redirectTo</kbd> at a different child view of our mixer if we wanted. Since <kbd class="calibre11">BaseComponent</kbd> is simply a <kbd class="calibre11">router-outlet</kbd>, any children defined underneath the root <kbd class="calibre11">' '</kbd> of our mixer's routes (seen by our the overall app's routes as <kbd class="calibre11">'/mixer'</kbd>) will insert directly in that view slot. If you were to run this right now, you should see the same start page we had before.</p>
<p class="mce-root">Congrats! Your app's start time is now fast and you have lazily loaded your first module!</p>
<p class="mce-root">However, there's a couple of surprising things to note:</p>
<ul class="calibre13">
<li class="calibre14">You may notice a quick white flash before the start page appears (on iOS at least)</li>
<li class="calibre14">You might notice the console log prints <kbd class="calibre11">`Current user:`</kbd><span> twice</span></li>
</ul>
<p class="mce-root">We will address each of these issues respectively.</p>
<ol class="calibre16">
<li value="1" class="calibre14">Remove the white flash after the splash screen before the start page displays.</li>
</ol>
<p class="calibre25">This is normal and is the result of the default Page background color which is white. To provide a seamless launch experience, open the <kbd class="calibre11">app/common.css</kbd> file and drop this global <kbd class="calibre11">Page</kbd> class definition to tint the background-color to the same as our <kbd class="calibre11">ActionBar</kbd> background-color:</p>
<pre class="calibre26">Page {<br class="title-page-name"/>  background-color:#101B2E;<br class="title-page-name"/>}</pre>
<p class="calibre30">Now, there will be no more white flash and the launch of the app will appear seamless.</p>
<ol start="2" class="calibre16">
<li value="2" class="calibre14">The console log prints <kbd class="calibre11">`Current user:`</kbd> twice</li>
</ol>
<p class="calibre30">Angular's dependency injector is causing this due to lazy loading.</p>
<p class="mce-root">This comes from <kbd class="calibre11">app/modules/core/services/auth.service.ts</kbd>, where we had a private <kbd class="calibre11">init</kbd> method that was being called from the service's constructor:</p>
<pre class="calibre26">...<br class="title-page-name"/>@Injectable()<br class="title-page-name"/>export class AuthService {<br class="title-page-name"/>   ...<br class="title-page-name"/>   constructor(<br class="title-page-name"/>     private databaseService: DatabaseService,<br class="title-page-name"/>     private logService: LogService<br class="title-page-name"/>   ) {<br class="title-page-name"/>     this._init();<br class="title-page-name"/>   } <br class="title-page-name"/>  ...<br class="title-page-name"/>  private _init() {<br class="title-page-name"/>    AuthService.CURRENT_USER = this.databaseService.getItem(<br class="title-page-name"/>      DatabaseService.KEYS.currentUser);<br class="title-page-name"/>    <strong class="calibre1">this.logService.debug(`Current user: `,</strong><br class="title-page-name"/><strong class="calibre1">      AuthService.CURRENT_USER);</strong><br class="title-page-name"/>    this._notifyState(!!AuthService.CURRENT_USER);<br class="title-page-name"/>  }<br class="title-page-name"/>  ...<br class="title-page-name"/>}</pre>
<p class="mce-root">Wait! What?! Does this mean <kbd class="calibre11">AuthService</kbd> is getting constructed twice??!!</p>
<p class="mce-root">Yes. It does. :(</p>
<p class="mce-root">I can hear the sound of the car's wheels squealing, as you veer off this highway adventure into a ditch right about now. ;)</p>
<p class="mce-root">This is most certainly a huge problem, as we absolutely intended for <kbd class="calibre11">AuthService</kbd> to be a globally shared Singleton that could be injected anywhere and shared to provide the current authenticated state of our app. </p>
<p class="mce-root">It is imperative we solve this right now, but let's first take a brief detour to understand why this is happening before looking at a solid solution.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Understanding Angular's Dependency Injector when lazy loading modules</h1>
                
            
            <article>
                
<p class="mce-root">Instead of restating the details, we will paraphrase directly from Angular's official documentation (<kbd class="calibre11">https://angular.io/guide/ngmodule-faq#!#q-why-child-injector</kbd>), which explains this perfectly:</p>
<div class="packt_quote">Angular adds <kbd class="calibre11">@NgModule.providers</kbd> to the application root injector unless the module is lazy loaded. For a lazy-loaded module, Angular creates a child injector and adds the module's providers to the child injector.<br class="title-page-name"/>
<br class="title-page-name"/>
This means that a module behaves differently depending on whether it's loaded during application start or lazily loaded later. Neglecting that difference can lead to adverse consequences.<br class="title-page-name"/>
<br class="title-page-name"/>
Why doesn't Angular add lazy-loaded providers to the app root injector as it does for eagerly loaded modules?<br class="title-page-name"/>
<br class="title-page-name"/>
The answer is grounded in a fundamental characteristic of the Angular dependency-injection system. An injector can add providers until it's first used. Once an injector starts creating and delivering services, its provider list is frozen; no new providers are allowed.<br class="title-page-name"/>
<br class="title-page-name"/>
When an application starts, Angular first configures the root injector with the providers of all eagerly loaded modules before creating its first component and injecting any of the provided services. Once the application begins, the app root injector is closed to new providers.<br class="title-page-name"/>
<br class="title-page-name"/>
Time passes and application logic triggers lazy loading of a module. Angular must add the lazy-loaded module's providers to an injector somewhere. It can't add them to the app root injector because that injector is closed to new providers. So Angular creates a new child injector for the lazy-loaded module context.</div>
<p class="mce-root">If we look at our root <kbd class="calibre11">AppModule</kbd>, we can see it imports <kbd class="calibre11">CoreModule</kbd>, which provides <kbd class="calibre11">AuthService</kbd>:</p>
<pre class="calibre22">...<br class="title-page-name"/>@NgModule({<br class="title-page-name"/>  imports: [<br class="title-page-name"/>    <strong class="calibre1">CoreModule,</strong><br class="title-page-name"/>    AppRoutingModule<br class="title-page-name"/>  ],<br class="title-page-name"/>  declarations: [AppComponent],<br class="title-page-name"/>  bootstrap: [AppComponent],<br class="title-page-name"/>  schemas: [NO_ERRORS_SCHEMA]<br class="title-page-name"/>})<br class="title-page-name"/>export class AppModule { }</pre>
<p class="mce-root">If we then look at <kbd class="calibre11">PlayerModule</kbd>, we can see it also imports <kbd class="calibre11">CoreModule</kbd>, since the components of <kbd class="calibre11">PlayerModule</kbd> make use of the <kbd class="calibre11">OrderByPipe</kbd> it declares as well as several of the services it provides (that is, <kbd class="calibre11">AuthService</kbd>, <kbd class="calibre11">LogService</kbd>, and <kbd class="calibre11">DialogService</kbd>):</p>
<pre class="calibre22">...<br class="title-page-name"/>@NgModule({<br class="title-page-name"/>  imports: [<br class="title-page-name"/>    <strong class="calibre1">CoreModule</strong><br class="title-page-name"/>  ],<br class="title-page-name"/>  providers: [...PROVIDERS],<br class="title-page-name"/>  declarations: [...COMPONENTS],<br class="title-page-name"/>  exports: [...COMPONENTS],<br class="title-page-name"/>  schemas: [ NO_ERRORS_SCHEMA ]<br class="title-page-name"/>})<br class="title-page-name"/>export class PlayerModule { }</pre>
<p class="mce-root"><kbd class="calibre11">PlayerModule</kbd> is now lazily loaded along with <kbd class="calibre11">MixerModule</kbd> due to our fancy new routing configuration. This causes Angular's dependency injector to register a new child injector for our lazily loaded <kbd class="calibre11">MixerModule</kbd>, which brings along  <kbd class="calibre11">PlayerModule</kbd>, which also brings along its import of <kbd class="calibre11">CoreModule</kbd>, which defines those providers, including <kbd class="calibre11">AuthService</kbd>, <kbd class="calibre11">LogService</kbd>, and so on. When Angular registers <kbd class="calibre11">MixerModule</kbd>, it will register all the providers defined throughout the new module, including its imported modules with the new child injector, giving rise to the new instances of those services being constructed.</p>
<p class="mce-root">Angular's docs also provide a recommended setup for modules to remedy this situation, so let's paraphrase again from <kbd class="calibre11"><span>https://angular.io/guide/ngmodule-faq#!#q-module-recommendations</span></kbd>:</p>
<div class="packt_quote"><span>SharedModule</span><br class="title-page-name"/>
Create a <kbd class="calibre11">SharedModule</kbd> with the components, directives, and pipes that you use everywhere in your app. This module should consist entirely of declarations, most of them exported. The <kbd class="calibre11">SharedModule</kbd> may re-export other widget modules, such as <kbd class="calibre11">CommonModule</kbd>, <kbd class="calibre11">FormsModule</kbd>, and modules with the UI controls that you use most widely.The <kbd class="calibre11">SharedModule</kbd> should not have providers for reasons explained previously. Nor should any of its imported or re-exported modules have providers. If you deviate from this guideline, know what you're doing and why. Import the <kbd class="calibre11">SharedModule</kbd> in your feature modules, both those loaded when the app starts and those you lazily load later.<br class="title-page-name"/>
Create a <kbd class="calibre11">CoreModule</kbd> with providers for the singleton services you load when the application starts.</div>
<div class="packt_infobox">Import <kbd class="calibre29">CoreModule</kbd> in the root <kbd class="calibre29">AppModule</kbd> only. Never import <kbd class="calibre29">CoreModule</kbd> in any other module.<br class="calibre24"/>
Consider making <kbd class="calibre29">CoreModule</kbd> a pure service module with no declarations.</div>
<p class="mce-root">OK wow! That is an excellent recommendation. Particularly worthy of note is that very last line:</p>
<div class="packt_quote">Consider making CoreModule a pure service module with no declarations.</div>
<p class="mce-root">So, we already have <kbd class="calibre11">CoreModule</kbd>, which is great news, but we will want to make it a <em class="calibre21">pure service module with no declarations</em>. We will also <span><em class="calibre21">Import CoreModule in the root AppModule only. Never import CoreModule in any other module. </em></span>Then, we can create a new <kbd class="calibre11">SharedModule</kbd> to provide just <em class="calibre21">...</em><span><em class="calibre21">the components, directives, and pipes that [we] use everywhere in [our] app</em>.</span></p>
<p class="mce-root"><span>Let's create</span> <kbd class="calibre11">app/modules/shared/shared.module.ts</kbd>, <span>as follows:</span></p>
<pre class="calibre22">// nativescript<br class="title-page-name"/>import { NativeScriptModule } from 'nativescript-angular/nativescript.module'; <br class="title-page-name"/><br class="title-page-name"/>// angular<br class="title-page-name"/>import { NgModule, NO_ERRORS_SCHEMA } from '@angular/core';<br class="title-page-name"/><br class="title-page-name"/>// app<br class="title-page-name"/>import { PIPES } from './pipes';<br class="title-page-name"/><br class="title-page-name"/>@NgModule({<br class="title-page-name"/>  imports: [<br class="title-page-name"/>    NativeScriptModule<br class="title-page-name"/>  ],<br class="title-page-name"/>  declarations: [<br class="title-page-name"/>    ...PIPES<br class="title-page-name"/>  ],<br class="title-page-name"/>  exports: [<br class="title-page-name"/>    NativeScriptModule,<br class="title-page-name"/>    ...PIPES<br class="title-page-name"/>  ],<br class="title-page-name"/>  schemas: [ NO_ERRORS_SCHEMA ]<br class="title-page-name"/>})<br class="title-page-name"/>export class SharedModule {}</pre>
<p class="mce-root">For <kbd class="calibre11">PIPES</kbd>, we are just moving the pipes directory from <kbd class="calibre11">app/modules/core</kbd> to the <kbd class="calibre11">app/modules/shared</kbd> folder. Now,  <kbd class="calibre11">SharedModule</kbd> is the one we can be free to import across several different modules that need any pipes or future shared components/directives it may provide. It will not define any service providers as mentioned by this suggestion:</p>
<div class="packt_quote"><span><kbd class="calibre11">SharedModule</kbd> should not have providers for reasons explained previously, nor should any of its imported or re-exported modules have providers.</span></div>
<p class="mce-root">We can then adjust <kbd class="calibre11">CoreModule</kbd> (located in <kbd class="calibre11">app/modules/core/core.module.ts</kbd>) as follows to be a pure service module with no declarations:</p>
<pre class="calibre22">// nativescript<br class="title-page-name"/>import { NativeScriptModule } from 'nativescript-angular/nativescript.module'; <br class="title-page-name"/>import { NativeScriptFormsModule } from 'nativescript-angular/forms'; <br class="title-page-name"/>import {NativeScriptHttpModule } from 'nativescript-angular/http';<br class="title-page-name"/>// angular<br class="title-page-name"/>import { NgModule, Optional, SkipSelf } from '@angular/core';<br class="title-page-name"/><br class="title-page-name"/>// app<br class="title-page-name"/>import { PROVIDERS } from './services';<br class="title-page-name"/><br class="title-page-name"/>const MODULES: any[] = [<br class="title-page-name"/>  NativeScriptModule,<br class="title-page-name"/>  NativeScriptFormsModule,<br class="title-page-name"/>  NativeScriptHttpModule<br class="title-page-name"/>];<br class="title-page-name"/><br class="title-page-name"/>@NgModule({<br class="title-page-name"/>  imports: [<br class="title-page-name"/>    ...MODULES<br class="title-page-name"/>  ],<br class="title-page-name"/>  providers: [<br class="title-page-name"/>    ...PROVIDERS<br class="title-page-name"/>  ],<br class="title-page-name"/>  exports: [<br class="title-page-name"/>    ...MODULES<br class="title-page-name"/>  ]<br class="title-page-name"/>})<br class="title-page-name"/>export class CoreModule {<br class="title-page-name"/>  constructor (<br class="title-page-name"/>    @Optional() @SkipSelf() parentModule: CoreModule) {<br class="title-page-name"/>    if (parentModule) {<br class="title-page-name"/>      throw new Error(<br class="title-page-name"/>        'CoreModule is already loaded. Import it in the AppModule only');<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="mce-root">This module now only defines providers as the collection containing <kbd class="calibre11">AuthService</kbd>, <kbd class="calibre11">DatabaseService</kbd>, <kbd class="calibre11">DialogService</kbd>, and <kbd class="calibre11">LogService</kbd>, all of which we created earlier in the book, and we want to ensure they are true Singletons used across our app, whether they are used in lazy loaded modules or not.</p>
<div class="packt_infobox"><span class="calibre31">Why do we use the <kbd class="calibre29">...PROVIDERS</kbd> spread notation instead of just assigning the collection directly?<br class="calibre24"/>
For scalability reasons. In the future, if we need to add an additional provider or override a provider, we can do so simply by just adding to the collection right in the module. The same goes for imports and exports.<br class="calibre24"/></span></div>
<p class="mce-root">We also take this opportunity to import some additional modules that we want to ensure are also used globally throughout the app. <kbd class="calibre11">NativeScriptModule</kbd>, <kbd class="calibre11">NativeScriptFormsModule</kbd>, and <kbd class="calibre11">NativeScriptHttpModule</kbd> are all essential modules that override certain web APIs from Angular's various providers out-of-the-box to enhance our app with native APIs. For example, instead of the app using <kbd class="calibre11">XMLHttpRequest</kbd> (which is a web API), it will use native HTTP APIs made available on both iOS and Android for the ultimate networking performance. We ensure we export these as well so our root module no longer needs to import them and can instead just import this <kbd class="calibre11">CoreModule</kbd>.</p>
<p class="mce-root">Lastly, we define a constructor that will help safeguard us in the future from accidentally importing this <kbd class="calibre11">CoreModule</kbd> into other lazily loaded modules.</p>
<p class="mce-root">We don't know yet if <kbd class="calibre11">PlayerService</kbd> provided by <kbd class="calibre11">PlayerModule</kbd> will be needed by <kbd class="calibre11">RecorderModule</kbd>, which also will be lazily loaded. If that comes up in the future, we can also refactor <kbd class="calibre11">PlayerService</kbd> into <kbd class="calibre11">CoreModule</kbd> to ensure it's a true Singleton shared across our entire app. For now, we will just leave it where it is as part of <kbd class="calibre11">PlayerModule</kbd>.</p>
<p class="mce-root">Let's now make our final adjustments to our other modules based on what we have done to tighten everything down.</p>
<p class="mce-root">The <kbd class="calibre11">app/modules/player/player.module.ts</kbd> file should now look like this:</p>
<pre class="calibre22">// angular<br class="title-page-name"/>import { NgModule, NO_ERRORS_SCHEMA } from '@angular/core';<br class="title-page-name"/><br class="title-page-name"/>// app<br class="title-page-name"/><strong class="calibre1">import { SharedModule } from '../shared/shared.module';</strong><br class="title-page-name"/>import { COMPONENTS } from './components';<br class="title-page-name"/>import { PROVIDERS } from './services';<br class="title-page-name"/><br class="title-page-name"/>@NgModule({<br class="title-page-name"/>  imports: [ <strong class="calibre1">SharedModule </strong>],<br class="title-page-name"/>  providers: [ ...PROVIDERS ],<br class="title-page-name"/>  declarations: [ ...COMPONENTS ],<br class="title-page-name"/>  exports: [<br class="title-page-name"/>    SharedModule,<br class="title-page-name"/>    ...COMPONENTS<br class="title-page-name"/>  ],<br class="title-page-name"/>  schemas: [ NO_ERRORS_SCHEMA ]<br class="title-page-name"/>})<br class="title-page-name"/>export class PlayerModule { }</pre>
<p class="mce-root">The <kbd class="calibre11">app/modules/recorder/recorder.module.ts</kbd> file should now look like this:</p>
<pre class="calibre22">// angular<br class="title-page-name"/>import { NgModule, NO_ERRORS_SCHEMA } from '@angular/core';<br class="title-page-name"/><br class="title-page-name"/>// app<br class="title-page-name"/><strong class="calibre1">import { SharedModule } from '../shared/shared.module';</strong><br class="title-page-name"/>import { PROVIDERS } from './services';<br class="title-page-name"/><br class="title-page-name"/>@NgModule({<br class="title-page-name"/> imports: [ <strong class="calibre1">SharedModule</strong> ],<br class="title-page-name"/> providers: [ ...PROVIDERS ],<br class="title-page-name"/> schemas: [ NO_ERRORS_SCHEMA ]<br class="title-page-name"/>})<br class="title-page-name"/>export class RecorderModule { }</pre>
<p class="mce-root">Notice we now import <kbd class="calibre11">SharedModule</kbd> instead of <kbd class="calibre11">CoreModule</kbd>. This provides us with the ability to share directives, components, and pipes (essentially anything that would be in the declarations portion of the module) across the entire app by importing that <kbd class="calibre11">SharedModule</kbd>.</p>
<p class="mce-root">Our root <kbd class="calibre11">AppModule</kbd> at <kbd class="calibre11">app/app.module.ts</kbd> stays the same:</p>
<pre class="calibre22">// angular<br class="title-page-name"/>import { NgModule } from '@angular/core';<br class="title-page-name"/><br class="title-page-name"/>// app<br class="title-page-name"/>import { CoreModule } from './modules/core/core.module';<br class="title-page-name"/>import { AppRoutingModule } from './app.routing';<br class="title-page-name"/>import { AppComponent } from './app.component';<br class="title-page-name"/><br class="title-page-name"/>@NgModule({<br class="title-page-name"/>  imports: [<br class="title-page-name"/>    CoreModule,<br class="title-page-name"/>    AppRoutingModule<br class="title-page-name"/>  ],<br class="title-page-name"/>  declarations: [ AppComponent ],<br class="title-page-name"/>  bootstrap: [ AppComponent ]<br class="title-page-name"/>})<br class="title-page-name"/>export class AppModule { }</pre>
<p class="mce-root">Any module (lazy loaded or not) can still inject any services that <kbd class="calibre11">CoreModule</kbd> provides, since the root <kbd class="calibre11">AppModule</kbd> now imports that <kbd class="calibre11">CoreModule</kbd>. This allows Angular's root injector to construct the services provided by <kbd class="calibre11">CoreModule</kbd> exactly once. Then, any time those services are injected anywhere (<em class="calibre21">in a lazily loaded module or not</em>), Angular will first ask the parent injector (in the case of a lazy loaded module, it would be the child injector) for that service and, if not found there, it will ask the next parent making its way to the root injector, eventually, where those Singletons are provided.</p>
<p class="mce-root">Well, we've had an amazing time in this desert of a town. Let's cruise on down the highway to the ultra secure Area 51, where modules can be locked away for years unless proper authorization is presented.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating AuthGuard for RecorderModule</h1>
                
            
            <article>
                
<p class="mce-root">One of our app's requirements is that recording features should be locked away and inaccessible until a user is authenticated. This provides us with the ability to have a user base and potentially introduce paid features down the road if we so desire.</p>
<p class="mce-root">Angular provides the ability to insert guards on our routes, which would only activate under certain conditions. This is exactly what we need to implement this feature requirement, since we have isolated the <kbd class="calibre11">'/record'</kbd> route to lazily load <kbd class="calibre11">RecorderModule</kbd>, which will contain all the recording features. We want to only allow access to that <kbd class="calibre11">'/record'</kbd> route if the user is authenticated.</p>
<p class="mce-root">Let's create <kbd class="calibre11">app/guards/auth-guard.service.ts</kbd> in a new folder for scalability, since we could grow and create other guards as necessary here:</p>
<pre class="calibre22">import { Injectable } from '@angular/core';<br class="title-page-name"/>import { Route, CanActivate, CanLoad } from '@angular/router';<br class="title-page-name"/>import { AuthService } from '../modules/core/services/auth.service';<br class="title-page-name"/><br class="title-page-name"/>@Injectable()<br class="title-page-name"/>export class AuthGuard implements CanActivate, CanLoad {<br class="title-page-name"/><br class="title-page-name"/>  constructor(private authService: AuthService) { }<br class="title-page-name"/><br class="title-page-name"/>  canActivate(): Promise&lt;boolean&gt; {<br class="title-page-name"/>    return new Promise((resolve, reject) =&gt; {<br class="title-page-name"/>      if (this._isAuth()) {<br class="title-page-name"/>        resolve(true);<br class="title-page-name"/>      } else {<br class="title-page-name"/>        // login sequence to continue prompting<br class="title-page-name"/>        let promptSequence = (usernameAttempt?: string) =&gt; {<br class="title-page-name"/>          this.authService.promptLogin(<br class="title-page-name"/>            'Authenticate to record.',<br class="title-page-name"/>            usernameAttempt<br class="title-page-name"/>          ).then(() =&gt; {<br class="title-page-name"/>            resolve(true); <br class="title-page-name"/>          }, (usernameAttempt) =&gt; {<br class="title-page-name"/>            if (usernameAttempt === false) {<br class="title-page-name"/>              // user canceled prompt<br class="title-page-name"/>              resolve(false);<br class="title-page-name"/>            } else {<br class="title-page-name"/>              // initiate sequence again<br class="title-page-name"/>              promptSequence(usernameAttempt);<br class="title-page-name"/>            }<br class="title-page-name"/>          });<br class="title-page-name"/>        };<br class="title-page-name"/>        // start login prompt sequence<br class="title-page-name"/>        // require auth before activating<br class="title-page-name"/>        promptSequence();<br class="title-page-name"/>      }<br class="title-page-name"/>    });<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  canLoad(route: Route): Promise&lt;boolean&gt; {<br class="title-page-name"/>    // reuse same logic to activate<br class="title-page-name"/>    return this.canActivate();<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  private _isAuth(): boolean {<br class="title-page-name"/>    // just get the latest value from our BehaviorSubject<br class="title-page-name"/>    return this.authService.authenticated$.getValue();<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="mce-root">We are able to take advantage of <kbd class="calibre11">BehaviorSubject</kbd> of <kbd class="calibre11">AuthService</kbd> to grab the latest value using <kbd class="calibre11">this.authService.authenticated$.getValue()</kbd> to determine the auth state. We use this to immediately activate the route via the <kbd class="calibre11">canActivate</kbd> hook (or load the module via the <kbd class="calibre11">canLoad</kbd> hook) if the user is authenticated. Otherwise, we display the login prompt via the service's method, but this time we wrap it in a reprompt sequence, which will continue to prompt on failed attempts until a successful authentication, or ignore it if the user cancels the prompt.</p>
<div class="packt_infobox">For the book, we aren't wiring up to any backend service to do any real authentication with a service provider. We will leave that part up to you in your own app. We will just be persisting the e-mail and password you enter into the login prompt as a valid user after doing very simple validation on the input.</div>
<p class="mce-root">Notice that <kbd class="calibre11">AuthGuard</kbd> is an Injectable service like other services, so we will want to make sure it is added to the providers metadata of <kbd class="calibre11">AppRoutingModule</kbd>. We can now guard our route with the following highlighted modifications to <kbd class="calibre11">app/app.routing.ts</kbd> to use it:</p>
<pre class="calibre22">...<br class="title-page-name"/><strong class="calibre1">import { AuthGuard } from './guards/auth-guard.service';</strong><br class="title-page-name"/><br class="title-page-name"/>const routes: Routes = [<br class="title-page-name"/>  ...<br class="title-page-name"/>  {<br class="title-page-name"/>    path: 'record',<br class="title-page-name"/>    loadChildren: <br class="title-page-name"/>      './modules/recorder/recorder.module#RecorderModule',<br class="title-page-name"/>    <strong class="calibre1">canLoad: [AuthGuard]</strong><br class="title-page-name"/>  }<br class="title-page-name"/>];<br class="title-page-name"/><br class="title-page-name"/>@NgModule({<br class="title-page-name"/>  ...<br class="title-page-name"/>  providers: [<br class="title-page-name"/>    <strong class="calibre1">AuthGuard,</strong><br class="title-page-name"/>    ...<br class="title-page-name"/>  ],<br class="title-page-name"/>  ...<br class="title-page-name"/>})<br class="title-page-name"/>export class AppRoutingModule { }</pre>
<p class="mce-root">To try this out, we need to add child routes to our <kbd class="calibre11">RecorderModule</kbd>, since we have not done that yet. Open <kbd class="calibre11">app/modules/recorder/recorder.module.ts</kbd> and add the following highlighted sections:</p>
<pre class="calibre22">// nativescript<br class="title-page-name"/>import { NativeScriptModule } from 'nativescript-angular/nativescript.module';<br class="title-page-name"/><strong class="calibre1">import { NativeScriptRouterModule } from 'nativescript-angular/router';</strong><br class="title-page-name"/><br class="title-page-name"/>// angular<br class="title-page-name"/>import { NgModule, NO_ERRORS_SCHEMA } from '@angular/core';<br class="title-page-name"/><strong class="calibre1">import { Routes } from '@angular/router';</strong><br class="title-page-name"/><br class="title-page-name"/>// app<br class="title-page-name"/>import { SharedModule } from '../shared/shared.module';<br class="title-page-name"/>import { PROVIDERS } from './services';<br class="title-page-name"/><strong class="calibre1">import { RecordComponent } from './components/record.component';</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">const COMPONENTS: any[] = [</strong><br class="title-page-name"/><strong class="calibre1">  RecordComponent</strong><br class="title-page-name"/><strong class="calibre1">]</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">const routes: Routes = [</strong><br class="title-page-name"/><strong class="calibre1">  {</strong><br class="title-page-name"/><strong class="calibre1">    path: '',</strong><br class="title-page-name"/><strong class="calibre1">    component: RecordComponent</strong><br class="title-page-name"/><strong class="calibre1">  }</strong><br class="title-page-name"/><strong class="calibre1">];</strong><br class="title-page-name"/><br class="title-page-name"/>@NgModule({<br class="title-page-name"/>  imports: [<br class="title-page-name"/>    SharedModule,<br class="title-page-name"/>    <strong class="calibre1">NativeScriptRouterModule.forChild(routes)</strong><br class="title-page-name"/>  ],<br class="title-page-name"/>  <strong class="calibre1">declarations: [ ...COMPONENTS ],</strong><br class="title-page-name"/>  providers: [ ...PROVIDERS ],<br class="title-page-name"/>  schemas: [ NO_ERRORS_SCHEMA ]<br class="title-page-name"/>})<br class="title-page-name"/>export class RecorderModule { }</pre>
<p class="mce-root">We now have a proper child route configuration that will display the single <kbd class="calibre11">RecordComponent</kbd> when the user navigates to the <kbd class="calibre11">'/record'</kbd> path. We won't show the details of <kbd class="calibre11">RecordComponent</kbd>, as you can refer to the <a href="part0064.html#1T1400-289fe2426d594f99a90e4363b2c9c34d" class="calibre3">Chapter 5</a>, <em class="calibre21">Routing and Lazy Loading</em> branch on the repo for the book. However, it is just a stubbed out component at this point inside <kbd class="calibre11">app/modules/recorder/components/record.component.html</kbd>, which just shows a simple label, so we can try this out.</p>
<p class="mce-root">Lastly, we need a button that will route to our <kbd class="calibre11">'/record'</kbd> path. If we look back at our original sketch, we wanted a Record button to display in the top right corner of <kbd class="calibre11">ActionBar</kbd>, so let's implement that now.</p>
<p class="mce-root">Open <kbd class="calibre11">app/modules/mixer/components/mixer.component.html</kbd> and add the following:</p>
<pre class="calibre22">&lt;ActionBar title="TNSStudio" class="action-bar"&gt;<br class="title-page-name"/>  <strong class="calibre1">&lt;ActionItem nsRouterLink="/record" ios.position="right"&gt;</strong><br class="title-page-name"/><strong class="calibre1">    &lt;Button text="Record" class="action-item"&gt;&lt;/Button&gt;</strong><br class="title-page-name"/><strong class="calibre1">  &lt;/ActionItem&gt;</strong><br class="title-page-name"/>&lt;/ActionBar&gt;<br class="title-page-name"/>&lt;GridLayout rows="*, 100" columns="*" class="page"&gt;<br class="title-page-name"/>  &lt;track-list row="0" col="0"&gt;&lt;/track-list&gt;<br class="title-page-name"/>  &lt;player-controls row="1" col="0"&gt;&lt;/player-controls&gt;<br class="title-page-name"/>&lt;/GridLayout&gt;</pre>
<p class="mce-root">Now, if we were to run this in the iOS Simulator, we would notice that our Record button in <kbd class="calibre11">ActionBar</kbd> does not do anything! This is because <kbd class="calibre11">MixerModule</kbd> only imports the following:</p>
<pre class="calibre22">@NgModule({<br class="title-page-name"/>  imports: [<br class="title-page-name"/>    PlayerModule,<br class="title-page-name"/>    NativeScriptRouterModule.forChild(routes)<br class="title-page-name"/>  ],<br class="title-page-name"/>  ...<br class="title-page-name"/>})<br class="title-page-name"/>export class MixerModule { }</pre>
<p class="mce-root">The <kbd class="calibre11">NativeScriptRouterModule.forChild(routes)</kbd> method just configures the routes but does not make various routing directives, such as <kbd class="calibre11">nsRouterLink</kbd>, available to our components.</p>
<p class="mce-root">Since you learned earlier that <kbd class="calibre11">SharedModule</kbd> should be used to declare various directives, components, and pipes you want to share throughout your modules (lazy loaded or not), this is a perfect opportunity to take advantage of that.</p>
<p class="mce-root">Open <kbd class="calibre11">app/modules/shared/shared.module.ts</kbd> and make the following highlighted modifications:</p>
<pre class="calibre22">...<br class="title-page-name"/><strong class="calibre1">import { NativeScriptRouterModule } from 'nativescript-angular/router';</strong> <br class="title-page-name"/>...<br class="title-page-name"/><br class="title-page-name"/>@NgModule({<br class="title-page-name"/>  imports: [<br class="title-page-name"/>    NativeScriptModule, <br class="title-page-name"/>    <strong class="calibre1">NativeScriptRouterModule</strong><br class="title-page-name"/>  ],<br class="title-page-name"/>  declarations: [<br class="title-page-name"/>    ...PIPES<br class="title-page-name"/>  ],<br class="title-page-name"/>  exports: [<br class="title-page-name"/>    NativeScriptModule,<br class="title-page-name"/>    <strong class="calibre1">NativeScriptRouterModule,</strong><br class="title-page-name"/>    ...PIPES<br class="title-page-name"/>  ],<br class="title-page-name"/>  schemas: [NO_ERRORS_SCHEMA]<br class="title-page-name"/>})<br class="title-page-name"/>export class SharedModule { }</pre>
<p class="mce-root">Now, back in <kbd class="calibre11">MixerModule</kbd>, we can adjust the imports to use <kbd class="calibre11">SharedModule</kbd>:</p>
<pre class="calibre22"><strong class="calibre1">...<br class="title-page-name"/>import { SharedModule } from '../shared/shared.module';<br class="title-page-name"/></strong><br class="title-page-name"/>@NgModule({<br class="title-page-name"/>  imports: [<br class="title-page-name"/>    PlayerModule,<br class="title-page-name"/>    <strong class="calibre1">SharedModule,</strong><br class="title-page-name"/>    NativeScriptRouterModule.forChild(routes)<br class="title-page-name"/>  ],<br class="title-page-name"/>  ...<br class="title-page-name"/>})<br class="title-page-name"/>export class MixerModule { }</pre>
<p class="mce-root">This ensures all the directives exposed via <kbd class="calibre11">NativeScriptRouterModule</kbd> are now included and available for use in  <kbd class="calibre11">MixerModule</kbd> by utilizing our app-wide <kbd class="calibre11">SharedModule</kbd>.</p>
<p class="mce-root">Running our app again, we now see the login prompt when we tap the <span>Record</span> button in <kbd class="calibre11">ActionBar</kbd>. If we enter a properly formatted e-mail address and any password, it will persist the details, log us in, and display <kbd class="calibre11">RecordComponent</kbd> as follows on iOS:</p>
<div class="mce-root1"><img class="image-border17" src="../images/00022.jpeg"/></div>
<p class="cdpalignleft1">You might notice something rather interesting. <kbd class="calibre11">ActionBar</kbd> changed from the background color we assigned via CSS and the button color now displays the default blue color. This is because <kbd class="calibre11">RecordComponent</kbd> does not define <kbd class="calibre11">ActionBar</kbd>; therefore, it is reverting to a default styled <kbd class="calibre11">ActionBar</kbd> with a default back button, which takes on the title of the page it just navigated from. The <kbd class="calibre11">'/record'</kbd> route is also using the ability of <kbd class="calibre11">page-router-outlet</kbd> to push components onto the mobile navigation stack. <kbd class="calibre11">RecordComponent</kbd> is animated into view while allowing the user to choose the top left button to navigate back (to pop the navigation history back one).</p>
<p class="cdpalignleft1">To fix <kbd class="calibre11">ActionBar</kbd>, let's just add <kbd class="calibre11">ActionBar</kbd> to the <kbd class="calibre11">RecordComponent</kbd> view with a custom <kbd class="calibre11">NavigationButton</kbd> (a <kbd class="calibre11">NativeScript</kbd> view component simulating a mobile device's default back navigation button). We can make the adjustments to <kbd class="calibre11">app/modules/record/components/record.component.html</kbd>:</p>
<pre class="calibre22">&lt;ActionBar title="Record" class="action-bar"&gt;<br class="title-page-name"/>  &lt;NavigationButton text="Back"<br class="title-page-name"/>    android.systemIcon="ic_menu_back"&gt;<br class="title-page-name"/>  &lt;/NavigationButton&gt;<br class="title-page-name"/>&lt;/ActionBar&gt;<br class="title-page-name"/>&lt;StackLayout class="p-20"&gt;<br class="title-page-name"/>  &lt;Label text="TODO: Record" class="h1 text-center"&gt;&lt;/Label&gt;<br class="title-page-name"/>&lt;/StackLayout&gt;</pre>
<p class="cdpalignleft1">Now, this looks a lot better:</p>
<div class="mce-root1"><img class="image-border11" src="../images/00023.jpeg"/></div>
<p class="cdpalignleft1">If we run this on Android and log in using any e-mail/password combo to persist a user, it will display the same <kbd class="calibre11">RecordComponent</kbd> view; however, you will notice another interesting detail. We have set up Android to display a standard back arrow system icon as <kbd class="calibre11">NavigationButton</kbd>, but when tapping that arrow, it does not do anything. Android's default behavior relies on the device's physical hardware back button next to the home button. However, we can provide a consistent experience by just adding a tap event to <kbd class="calibre11">NavigationButton</kbd>, so both iOS and Android react the same to tapping the back button. Make the following modification to the template:</p>
<pre class="calibre22">&lt;ActionBar title="Record" icon="" class="action-bar"&gt;<br class="title-page-name"/>  &lt;NavigationButton <strong class="calibre1">(tap)="back()"</strong> text="Back" <br class="title-page-name"/>    android.systemIcon="ic_menu_back"&gt;<br class="title-page-name"/>  &lt;/NavigationButton&gt;<br class="title-page-name"/>&lt;/ActionBar&gt;<br class="title-page-name"/>&lt;StackLayout class="p-20"&gt;<br class="title-page-name"/>  &lt;Label text="TODO: Record" class="h1 text-center"&gt;&lt;/Label&gt;<br class="title-page-name"/>&lt;/StackLayout&gt;</pre>
<p class="cdpalignleft1">Then, we can implement the <kbd class="calibre11">back()</kbd> method in <kbd class="calibre11">app/modules/recorder/components/record.component.ts</kbd> using <kbd class="calibre11">NativeScript</kbd> for Angular's <kbd class="calibre11">RouterExtensions</kbd> service:</p>
<pre class="calibre22">// angular<br class="title-page-name"/>import { Component } from '@angular/core';<br class="title-page-name"/><strong class="calibre1">import { RouterExtensions } from 'nativescript-angular/router';</strong><br class="title-page-name"/><br class="title-page-name"/>@Component({<br class="title-page-name"/> moduleId: module.id,<br class="title-page-name"/> selector: 'record',<br class="title-page-name"/> templateUrl: 'record.component.html'<br class="title-page-name"/>})<br class="title-page-name"/>export class RecordComponent { <br class="title-page-name"/><br class="title-page-name"/>  constructor(<strong class="calibre1">private router: RouterExtensions</strong>) { }<br class="title-page-name"/><br class="title-page-name"/>  <strong class="calibre1">public back() {<br class="title-page-name"/>    this.router.back();<br class="title-page-name"/>  }</strong><br class="title-page-name"/>}</pre>
<p class="cdpalignleft1">Now, Android's back button can be tapped to navigate back in addition to the hardware back button. iOS simply ignores the tap event handler, since it uses the default native behavior for <kbd class="calibre11">NavigationButton</kbd>. Pretty nice. Here is how <kbd class="calibre11">RecordComponent</kbd> looks on Android:</p>
<div class="mce-root1"><img class="image-border18" src="../images/00024.jpeg"/></div>
<p class="cdpalignleft1">We will implement a nice recording view in upcoming chapters.</p>
<p class="cdpalignleft1">We are surely cruising down Route 66 by now!</p>
<p class="cdpalignleft1">We have implemented lazily loaded routes, provided <kbd class="calibre11">AuthGuard</kbd> to protect unauthorized use of our app's recording features, and learned a ton in the process. <em class="calibre21">However, we've just realized we are missing a very important feature late in the game</em>. We need a way to work on several different mixes over time. By default, our app may launch the last opened mix, but we would like to create new mixes (let's consider them <strong class="calibre1">compositions</strong>) and record entirely new mixes of individual tracks as separate compositions. We need a new route to display these compositions that we can name appropriately, so we can jump back and forth and work on different material.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Handling late feature requirements – managing compositions</h1>
                
            
            <article>
                
<p class="mce-root">It's time to deal with unexpected traffic along Route 66. We have encountered a late feature requirement, realizing we need a way to manage any number of different mixes so we can work on different material over time. We could refer to each mix as a composition of audio tracks.</p>
<p class="mce-root">The good news is we have spent a reasonable amount of time engineering a scalable architecture and we are about to reap the fruits of our labor. Responding to late feature requirements now becomes a rather enjoyable Sunday stroll around the neighborhood. Let's show off the strengths of our app's architecture by taking a moment to work on this new feature.</p>
<p class="mce-root">Let's start by defining a new route for a new <kbd class="calibre11">MixListComponent</kbd> we will create. Open <kbd class="calibre11">app/modules/mixer/mixer.module.ts</kbd> and make the following highlighted modifications:</p>
<pre class="calibre22">...<br class="title-page-name"/><strong class="calibre1">import { MixListComponent } from './components/mix-list.component';<br class="title-page-name"/>import { PROVIDERS } from './services';</strong><br class="title-page-name"/><br class="title-page-name"/>const COMPONENTS: any[] = [<br class="title-page-name"/>  BaseComponent,<br class="title-page-name"/>  MixerComponent,<br class="title-page-name"/>  <strong class="calibre1">MixListComponent</strong><br class="title-page-name"/>]<br class="title-page-name"/><br class="title-page-name"/>const routes: Routes = [<br class="title-page-name"/>  {<br class="title-page-name"/>    path: '',<br class="title-page-name"/>    component: BaseComponent,<br class="title-page-name"/>    children: [<br class="title-page-name"/>      <strong class="calibre1">{</strong><br class="title-page-name"/><strong class="calibre1">        path: 'home',</strong><br class="title-page-name"/><strong class="calibre1">        component: MixListComponent</strong><br class="title-page-name"/><strong class="calibre1">      },</strong><br class="title-page-name"/><strong class="calibre1">      {</strong><br class="title-page-name"/><strong class="calibre1">        path: ':id',</strong><br class="title-page-name"/><strong class="calibre1">        component: MixerComponent</strong><br class="title-page-name"/><strong class="calibre1">      }</strong><br class="title-page-name"/>    ]<br class="title-page-name"/>  }<br class="title-page-name"/>];<br class="title-page-name"/><br class="title-page-name"/>@NgModule({<br class="title-page-name"/>   ...<br class="title-page-name"/>   <strong class="calibre1">providers: [</strong><br class="title-page-name"/><strong class="calibre1">     ...PROVIDERS</strong><br class="title-page-name"/><strong class="calibre1">   ]</strong><br class="title-page-name"/>})<br class="title-page-name"/>export class MixerModule { }</pre>
<p class="mce-root">We are switching up our initial strategy of presenting <kbd class="calibre11">MixerComponent</kbd> as the home start page, but instead we are going to create a new <kbd class="calibre11">MixListComponent</kbd> in a moment to represent the <kbd class="calibre11">'home'</kbd> start page, which will be a listing of all the compositions we are working on. We could still have the <kbd class="calibre11">MixListComponent</kbd> auto select the last selected composition on the app launch for convenience later. We have now defined <kbd class="calibre11">MixerComponent</kbd> as a parameterized route, since it will always represent one of our working compositions identified by the <kbd class="calibre11">':id'</kbd> param routes, which will resolve to a route looking like <kbd class="calibre11">'/mixer/1'</kbd> for example. We have also imported <kbd class="calibre11">PROVIDERS</kbd>, which we will create in a moment.</p>
<p class="mce-root">Let's modify <kbd class="calibre11">DatabaseService</kbd> provided by <kbd class="calibre11">CoreModule</kbd> to help provide a constant persistence key for our new data needs. We will want to persist user created compositions stored via this constant key name. Open <kbd class="calibre11">app/modules/core/services/database.service.ts</kbd> and make the following highlighted modifications:</p>
<pre class="calibre22">...<br class="title-page-name"/>interface IKeys {<br class="title-page-name"/>  currentUser: string;<br class="title-page-name"/>  <strong class="calibre1">compositions: string;</strong><br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>@Injectable()<br class="title-page-name"/>export class DatabaseService {<br class="title-page-name"/><br class="title-page-name"/>  public static KEYS: IKeys = {<br class="title-page-name"/>    currentUser: 'current-user',<br class="title-page-name"/>    <strong class="calibre1">compositions: 'compositions'</strong><br class="title-page-name"/>  };<br class="title-page-name"/>...</pre>
<p class="mce-root">Let's also create a new data model to represent our compositions. Create <kbd class="calibre11">app/modules/shared/models/composition.model.ts</kbd>:</p>
<pre class="calibre22">import { ITrack } from './track.model';<br class="title-page-name"/><br class="title-page-name"/>export interface IComposition {<br class="title-page-name"/>  id: number;<br class="title-page-name"/>  name: string;<br class="title-page-name"/>  created: number;<br class="title-page-name"/>  tracks: Array&lt;ITrack&gt;;<br class="title-page-name"/>  order: number;<br class="title-page-name"/>}<br class="title-page-name"/>export class CompositionModel implements IComposition {<br class="title-page-name"/>  public id: number;<br class="title-page-name"/>  public name: string;<br class="title-page-name"/>  public created: number;<br class="title-page-name"/>  public tracks: Array&lt;ITrack&gt; = [];<br class="title-page-name"/>  public order: number;<br class="title-page-name"/><br class="title-page-name"/>  constructor(model?: any) {<br class="title-page-name"/>    if (model) {<br class="title-page-name"/>      for (let key in model) {<br class="title-page-name"/>        this[key] = model[key];<br class="title-page-name"/>      }<br class="title-page-name"/>    }<br class="title-page-name"/>    if (!this.created) this.created = Date.now();<br class="title-page-name"/>    // if not assigned, just assign a random id<br class="title-page-name"/>    if (!this.id)<br class="title-page-name"/>      this.id = Math.floor(Math.random() * 100000);<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="mce-root">Then, holding strong to our conventions, open <kbd class="calibre11">app/modules/shared/models/index.ts</kbd> and re-export this new model:</p>
<pre class="calibre22"><strong class="calibre1">export * from './composition.model';</strong><br class="title-page-name"/>export * from './track.model';</pre>
<p class="mce-root">We can now use this new model and database key in a new data service on which to build this new feature. Create <kbd class="calibre11">app/modules/mixer/services/mixer.service.ts</kbd>:</p>
<pre class="calibre22">// angular<br class="title-page-name"/>import { Injectable } from '@angular/core';<br class="title-page-name"/><br class="title-page-name"/>// app<br class="title-page-name"/>import { ITrack, IComposition, CompositionModel } from '../../shared/models';<br class="title-page-name"/>import { DatabaseService } from '../../core/services/database.service';<br class="title-page-name"/>import { DialogService } from '../../core/services/dialog.service';<br class="title-page-name"/><br class="title-page-name"/>@Injectable()<br class="title-page-name"/>export class MixerService {<br class="title-page-name"/><br class="title-page-name"/>  public list: Array&lt;IComposition&gt;;<br class="title-page-name"/> <br class="title-page-name"/>  constructor(<br class="title-page-name"/>    private databaseService: DatabaseService,<br class="title-page-name"/>    private dialogService: DialogService<br class="title-page-name"/>  ) {<br class="title-page-name"/>    // restore with saved compositions or demo list<br class="title-page-name"/>    this.list = this._savedCompositions() || <br class="title-page-name"/>      this._demoComposition();<br class="title-page-name"/>  } <br class="title-page-name"/><br class="title-page-name"/>  public add() {<br class="title-page-name"/>    this.dialogService.prompt('Composition name:')<br class="title-page-name"/>      .then((value) =&gt; {<br class="title-page-name"/>        if (value.result) {<br class="title-page-name"/>          let composition = new CompositionModel({<br class="title-page-name"/>            id: this.list.length + 1,<br class="title-page-name"/>            name: value.text,<br class="title-page-name"/>            order: this.list.length // next one in line<br class="title-page-name"/>          });<br class="title-page-name"/>          this.list.push(composition);<br class="title-page-name"/>          // persist changes<br class="title-page-name"/>          this._saveList();<br class="title-page-name"/>        }<br class="title-page-name"/>      });<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public edit(composition: IComposition) {<br class="title-page-name"/>    this.dialogService.prompt('Edit name:', composition.name)<br class="title-page-name"/>      .then((value) =&gt; {<br class="title-page-name"/>        if (value.result) {<br class="title-page-name"/>          for (let comp of this.list) {<br class="title-page-name"/>            if (comp.id === composition.id) {<br class="title-page-name"/>              comp.name = value.text;<br class="title-page-name"/>              break;<br class="title-page-name"/>            }<br class="title-page-name"/>          }<br class="title-page-name"/>          // re-assignment triggers view binding change<br class="title-page-name"/>          // only needed with default change detection<br class="title-page-name"/>          // when object prop changes in collection<br class="title-page-name"/>          // NOTE: we will use Observables in ngrx chapter<br class="title-page-name"/>          this.list = [...this.list];<br class="title-page-name"/>          // persist changes<br class="title-page-name"/>          this._saveList();<br class="title-page-name"/>        }<br class="title-page-name"/>      });<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  private _savedCompositions(): any {<br class="title-page-name"/>    return this.databaseService<br class="title-page-name"/>      .getItem(DatabaseService.KEYS.compositions);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  private _saveList() {<br class="title-page-name"/>    this.databaseService<br class="title-page-name"/>      .setItem(DatabaseService.KEYS.compositions, this.list);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  private _demoComposition(): Array&lt;IComposition&gt; {<br class="title-page-name"/>    // Starter composition to demo on first launch<br class="title-page-name"/>    return [<br class="title-page-name"/>      {<br class="title-page-name"/>        id: 1,<br class="title-page-name"/>        name: 'Demo',<br class="title-page-name"/>        created: Date.now(),<br class="title-page-name"/>        order: 0,<br class="title-page-name"/>        tracks: [<br class="title-page-name"/>          {<br class="title-page-name"/>            id: 1,<br class="title-page-name"/>            name: 'Guitar',<br class="title-page-name"/>            order: 0<br class="title-page-name"/>          },<br class="title-page-name"/>          {<br class="title-page-name"/>            id: 2,<br class="title-page-name"/>            name: 'Vocals',<br class="title-page-name"/>            order: 1<br class="title-page-name"/>          }<br class="title-page-name"/>        ]<br class="title-page-name"/>      }<br class="title-page-name"/>    ]<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="mce-root">We now have a service that will provide a list to bind our view to display the user's saved compositions. It also provides a way to add and edit compositions and seed the first app launch with a demo composition for a good first-time user experience (<em class="calibre21">we will add actual tracks to the demo later</em>).</p>
<p class="mce-root">In keeping with our conventions, let's also add <kbd class="calibre11">app/modules/mixer/services/index.ts</kbd>, as follows, which we illustrated being imported in <kbd class="calibre11">MixerModule</kbd> a moment ago:</p>
<pre class="calibre22">import { MixerService } from './mixer.service';<br class="title-page-name"/><br class="title-page-name"/>export const PROVIDERS: any[] = [<br class="title-page-name"/>  MixerService<br class="title-page-name"/>];<br class="title-page-name"/><br class="title-page-name"/>export * from './mixer.service';</pre>
<p class="mce-root">Let's now create <kbd class="calibre11">app/modules/mixer/components/mix-list.component.ts</kbd> to consume and project our new data service:</p>
<pre class="calibre22">// angular<br class="title-page-name"/>import { Component } from '@angular/core';<br class="title-page-name"/><br class="title-page-name"/>// app<br class="title-page-name"/>import { MixerService } from '../services/mixer.service';<br class="title-page-name"/><br class="title-page-name"/>@Component({<br class="title-page-name"/>  moduleId: module.id,<br class="title-page-name"/>  selector: 'mix-list',<br class="title-page-name"/>  templateUrl: 'mix-list.component.html'<br class="title-page-name"/>})<br class="title-page-name"/>export class MixListComponent {<br class="title-page-name"/><br class="title-page-name"/>  constructor(public mixerService: MixerService) { } <br class="title-page-name"/>}</pre>
<p class="mce-root">And, for the view template, <kbd class="calibre11">app/modules/mixer/components/mix-list.component.html</kbd>:</p>
<pre class="calibre22">&lt;ActionBar title="Compositions" class="action-bar"&gt;<br class="title-page-name"/>  &lt;ActionItem (tap)="mixerService.add()" <br class="title-page-name"/>    ios.position="right"&gt;<br class="title-page-name"/>    &lt;Button text="New" class="action-item"&gt;&lt;/Button&gt;<br class="title-page-name"/>  &lt;/ActionItem&gt;<br class="title-page-name"/>&lt;/ActionBar&gt;<br class="title-page-name"/>&lt;ListView [items]="mixerService.list | orderBy: 'order'" <br class="title-page-name"/>  class="list-group"&gt;<br class="title-page-name"/>  &lt;ng-template let-composition="item"&gt;<br class="title-page-name"/>    &lt;GridLayout rows="auto" columns="100,*,auto" <br class="title-page-name"/>      class="list-group-item"&gt;<br class="title-page-name"/>      &lt;Button text="Edit" row="0" col="0" <br class="title-page-name"/>        (tap)="mixerService.edit(composition)"&gt;&lt;/Button&gt;<br class="title-page-name"/>      &lt;Label [text]="composition.name"<br class="title-page-name"/>        [nsRouterLink]="['/mixer', composition.id]"<br class="title-page-name"/>        class="h2" row="0" col="1"&gt;&lt;/Label&gt;<br class="title-page-name"/>      &lt;Label [text]="composition.tracks.length" <br class="title-page-name"/>        class="text-right" row="0" col="2"&gt;&lt;/Label&gt;<br class="title-page-name"/>    &lt;/GridLayout&gt;<br class="title-page-name"/>  &lt;/ng-template&gt;<br class="title-page-name"/>&lt;/ListView&gt;</pre>
<p class="mce-root">This will render our list of <kbd class="calibre11">MixerService</kbd> user-saved compositions to the view and, when we first launch the app, it will have been seeded with one sample <strong class="calibre1">Demo</strong> composition preloaded with two recordings, so the user can play around. Here is how things look on iOS upon first launch now:</p>
<div class="mce-root1"><img class="image-border19" src="../images/00025.jpeg"/></div>
<p class="mce-root">We can create new compositions and edit the names of existing ones. We can also tap the composition's name to view  <kbd class="calibre11">MixerComponent</kbd>; however, we need to adjust the component to grab the route <kbd class="calibre11">':id'</kbd> param and wire its view into the selected composition. Open <kbd class="calibre11">app/modules/mixer/components/mixer.component.ts</kbd> and add the highlighted sections:</p>
<pre class="calibre22">// angular<br class="title-page-name"/>import { Component, <strong class="calibre1">OnInit, OnDestroy</strong> } from '@angular/core';<br class="title-page-name"/><strong class="calibre1">import { ActivatedRoute } from '@angular/router';</strong><br class="title-page-name"/><strong class="calibre1">import { Subscription } from 'rxjs/Subscription';</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">// app</strong><br class="title-page-name"/><strong class="calibre1">import { MixerService } from '../services/mixer.service';</strong><br class="title-page-name"/><strong class="calibre1">import { CompositionModel } from '../../shared/models';</strong><br class="title-page-name"/><br class="title-page-name"/>@Component({<br class="title-page-name"/> moduleId: module.id,<br class="title-page-name"/> selector: 'mixer',<br class="title-page-name"/> templateUrl: 'mixer.component.html'<br class="title-page-name"/>})<br class="title-page-name"/>export class MixerComponent <strong class="calibre1">implements OnInit, OnDestroy</strong> {<br class="title-page-name"/><br class="title-page-name"/>  <strong class="calibre1">public composition: CompositionModel; </strong><br class="title-page-name"/><strong class="calibre1">  private _sub: Subscription;</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">  constructor(</strong><br class="title-page-name"/><strong class="calibre1">    private route: ActivatedRoute,</strong><br class="title-page-name"/><strong class="calibre1">    private mixerService: MixerService</strong><br class="title-page-name"/><strong class="calibre1">  ) { } </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">  ngOnInit() {</strong><br class="title-page-name"/><strong class="calibre1">    this._sub = this.route.params.subscribe(params =&gt; {</strong><br class="title-page-name"/><strong class="calibre1">      for (let comp of this.mixerService.list) {</strong><br class="title-page-name"/><strong class="calibre1">        if (comp.id === +params['id']) {</strong><br class="title-page-name"/><strong class="calibre1">          this.composition = comp;</strong><br class="title-page-name"/><strong class="calibre1">          break;</strong><br class="title-page-name"/><strong class="calibre1">        }</strong><br class="title-page-name"/><strong class="calibre1">      }</strong><br class="title-page-name"/><strong class="calibre1">    });</strong><br class="title-page-name"/><strong class="calibre1">  } </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">  ngOnDestroy() {</strong><br class="title-page-name"/><strong class="calibre1">    this._sub.unsubscribe();</strong><br class="title-page-name"/><strong class="calibre1">  }</strong><br class="title-page-name"/>}</pre>
<p class="mce-root">We can inject Angular's <kbd class="calibre11">ActivatedRoute</kbd> to subscribe to the route's params, which give us access to <kbd class="calibre11">id</kbd>. Because it will come in as a String by default, we use <kbd class="calibre11">+params['id']</kbd> to convert it to a number when we locate the composition in our service's list. We assign a local reference to the selected <kbd class="calibre11">composition</kbd>, which now allows us to bind to it in the view. While we're at it, we will also add a Button labeled <kbd class="calibre11">List</kbd> for now in <kbd class="calibre11">ActionBar</kbd> to navigate back to our compositions (<em class="calibre21">later, we will implement font icons to display in their place</em>). Open <kbd class="calibre11">app/modules/mixer/components/mixer.component.html</kbd> and make the following highlighted modifications:</p>
<pre class="calibre22">&lt;ActionBar <strong class="calibre1">[title]="composition.name"</strong> class="action-bar"&gt;<br class="title-page-name"/>  <strong class="calibre1">&lt;ActionItem nsRouterLink="/mixer/home"&gt;</strong><br class="title-page-name"/><strong class="calibre1">    &lt;Button text="List" class="action-item"&gt;&lt;/Button&gt;</strong><br class="title-page-name"/><strong class="calibre1">  &lt;/ActionItem&gt;</strong><br class="title-page-name"/>  &lt;ActionItem nsRouterLink="/record" ios.position="right"&gt;<br class="title-page-name"/>    &lt;Button text="Record" class="action-item"&gt;&lt;/Button&gt;<br class="title-page-name"/>  &lt;/ActionItem&gt;<br class="title-page-name"/>&lt;/ActionBar&gt;<br class="title-page-name"/>&lt;GridLayout rows="*, 100" columns="*" class="page"&gt;<br class="title-page-name"/>  &lt;track-list <strong class="calibre1">[tracks]="composition.tracks"</strong> row="0" col="0"&gt;&lt;/track-list&gt;<br class="title-page-name"/>  &lt;player-controls row="1" col="0"&gt;&lt;/player-controls&gt;<br class="title-page-name"/>&lt;/GridLayout&gt;</pre>
<p class="mce-root">This allows us to display the selected composition's name in the title of <kbd class="calibre11">ActionBar</kbd> as well as pass its tracks to <kbd class="calibre11">track-list</kbd>. We need to add <kbd class="calibre11">Input</kbd> to <kbd class="calibre11">track-list</kbd>, so it renders the composition's tracks instead of the dummy data it's bound to now. Let's open <kbd class="calibre11">app/modules/player/components/track-list/track-list.component.ts</kbd> and add an <kbd class="calibre11">Input</kbd>:</p>
<pre class="calibre22">...<br class="title-page-name"/>export class TrackListComponent {<br class="title-page-name"/> <br class="title-page-name"/> @Input() tracks: Array&lt;ITrack&gt;;<br class="title-page-name"/><br class="title-page-name"/> ...<br class="title-page-name"/>}</pre>
<p class="mce-root">Previously, the <kbd class="calibre11">TrackListComponent</kbd> view was bound to <kbd class="calibre11">playerService.tracks</kbd>, so let's adjust the view template for the component at <kbd class="calibre11">app/modules/player/components/track-list/track-list.component.html</kbd> to bind to our new <kbd class="calibre11">Input</kbd>, which will now represent the tracks in the user's actual selected composition<strong class="calibre1">:</strong></p>
<pre class="calibre22">&lt;ListView [items]="<strong class="calibre1">tracks</strong> | orderBy: 'order'" class="list-group"&gt;<br class="title-page-name"/>  &lt;template let-track="item"&gt;<br class="title-page-name"/>    &lt;GridLayout rows="auto" columns="100,*,100" class="list-group-item"&gt;<br class="title-page-name"/>      &lt;Button text="Record" (tap)="record(track)" row="0" col="0" class="c-ruby"&gt;&lt;/Button&gt;<br class="title-page-name"/>      &lt;Label [text]="track.name" row="0" col="1" class="h2"&gt;&lt;/Label&gt;<br class="title-page-name"/>      &lt;Switch [checked]="track.solo" row="0" col="2" class="switch"&gt;&lt;/Switch&gt;<br class="title-page-name"/>    &lt;/GridLayout&gt;<br class="title-page-name"/>  &lt;/template&gt;<br class="title-page-name"/>&lt;/ListView&gt;</pre>
<p class="mce-root">We now have the following sequence in our app to meet the needs of this late feature requirement and we did it in just a few pages of material here:</p>
<div class="mce-root1"><img class="image-border20" src="../images/00026.jpeg"/></div>
<p class="mce-root">And it works exactly the same on Android while retaining its unique native characteristics. </p>
<div class="mce-root1"><img class="image-border20" src="../images/00027.jpeg"/></div>
<p class="mce-root">You might notice, however, that <kbd class="calibre11">ActionBar</kbd> on Android defaults to all <kbd class="calibre11">ActionItem</kbd> on the right-hand side. One last trick we want to show you quickly is the ability for platform-specific view templates. Oh and don't worry about those ugly Android buttons; we will integrate font icons later for those.</p>
<div class="packt_tip">Create platform-specific view templates wherever you see fit. Doing so will help you dial views for each platform where necessary and make them highly maintainable.</div>
<p class="mce-root">Let's create <kbd class="calibre11">app/modules/mixer/components/action-bar/action-bar.component.ts</kbd>:</p>
<pre class="calibre22">// angular<br class="title-page-name"/>import { Component, Input } from '@angular/core';<br class="title-page-name"/><br class="title-page-name"/>@Component({<br class="title-page-name"/>  moduleId: module.id,<br class="title-page-name"/>  selector: 'action-bar',<br class="title-page-name"/>  templateUrl: 'action-bar.component.html'<br class="title-page-name"/>})<br class="title-page-name"/>export class ActionBarComponent {<br class="title-page-name"/><br class="title-page-name"/>  @Input() title: string;<br class="title-page-name"/>}</pre>
<p class="mce-root">You can then create an iOS-specific view template: <kbd class="calibre11">app/modules/mixer/components/action-bar/action-bar.component.ios.html</kbd>:</p>
<pre class="calibre22">&lt;ActionBar [title]="title" class="action-bar"&gt;<br class="title-page-name"/>  &lt;ActionItem nsRouterLink="/mixer/home"&gt;<br class="title-page-name"/>    &lt;Button text="List" class="action-item"&gt;&lt;/Button&gt;<br class="title-page-name"/>  &lt;/ActionItem&gt;<br class="title-page-name"/>  &lt;ActionItem nsRouterLink="/record" ios.position="right"&gt;<br class="title-page-name"/>    &lt;Button text="Record" class="action-item"&gt;&lt;/Button&gt;<br class="title-page-name"/>  &lt;/ActionItem&gt;<br class="title-page-name"/>&lt;/ActionBar&gt;</pre>
<p class="mce-root">And an Android-specific view template: <kbd class="calibre11">app/modules/mixer/components/action-bar/action-bar.component.android.html</kbd>:</p>
<pre class="calibre22">&lt;ActionBar class="action-bar"&gt;<br class="title-page-name"/>  &lt;GridLayout rows="auto" columns="auto,*,auto" class="action-bar"&gt;<br class="title-page-name"/>    &lt;Button text="List" nsRouterLink="/mixer/home" class="action-item" row="0" col="0"&gt;&lt;/Button&gt;<br class="title-page-name"/>    &lt;Label [text]="title" class="action-bar-title text-center" row="0" col="1"&gt;&lt;/Label&gt;<br class="title-page-name"/>    &lt;Button text="Record" nsRouterLink="/record" class="action-item" row="0" col="2"&gt;&lt;/Button&gt;<br class="title-page-name"/>  &lt;/GridLayout&gt;<br class="title-page-name"/>&lt;/ActionBar&gt;</pre>
<p class="mce-root">Then we can use it in <kbd class="calibre11">app/modules/mixer/components/mixer.component.html</kbd>:</p>
<pre class="calibre22"><strong class="calibre1">&lt;action-bar [title]="composition.name"&gt;&lt;/action-bar&gt;</strong><br class="title-page-name"/>&lt;GridLayout rows="*, 100" columns="*" class="page"&gt;<br class="title-page-name"/>  &lt;track-list [tracks]="composition.tracks" row="0" col="0"&gt;&lt;/track-list&gt;<br class="title-page-name"/>  &lt;player-controls row="1" col="0"&gt;&lt;/player-controls&gt;<br class="title-page-name"/>&lt;/GridLayout&gt;</pre>
<p class="mce-root">Just ensure you add it to the <kbd class="calibre11">COMPONENTS</kbd> of <kbd class="calibre11">MixerModule</kbd>  in <kbd class="calibre11">app/modules/mixer/mixer.module.ts</kbd>:</p>
<pre class="calibre22">...<br class="title-page-name"/><strong class="calibre1">import { ActionBarComponent } from './components/action-bar/action-bar.component';</strong><br class="title-page-name"/>...<br class="title-page-name"/><br class="title-page-name"/>const COMPONENTS: any[] = [<br class="title-page-name"/>  <strong class="calibre1">ActionBarComponent,</strong><br class="title-page-name"/>  BaseComponent,<br class="title-page-name"/>  MixerComponent,<br class="title-page-name"/>  MixListComponent<br class="title-page-name"/>];<br class="title-page-name"/>...</pre>
<p class="cdpalignleft1">Voila! </p>
<div class="mce-root1"><img class="image-border21" src="../images/00028.jpeg"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="mce-root">We have arrived at the end of this amazing journey down Route 66 and hope you feel as exhilarated as we do. This chapter has presented some interesting Angular concepts, including route configuration with lazy loaded modules to keep the app startup time fast; building a custom module loader using native file handling APIs; combining the flexibility of <kbd class="calibre11">router-outlet</kbd> with NativeScript's <kbd class="calibre11">page-router-outlet</kbd>; gaining control and understanding of Singleton services with lazy loaded modules; guarding routes dependent on authorized access; and working on late feature requirements to show off our wonderfully scalable app design.</p>
<p class="mce-root">This chapter rounds out the general usability flow of our app and, at this point, we are ready to venture into the core competency of our app: <strong class="calibre1">Audio Handling via iOS and Android's rich native APIs</strong>.</p>
<p class="mce-root">Before delving into the thick of things, in the next chapter we will take a brief moment to inspect NativeScript's various <kbd class="calibre11">tns</kbd> command-line arguments to run our app to lock in a thorough education of the tool belt we can now bring to work.</p>


            </article>

            
        </section>
    </body></html>