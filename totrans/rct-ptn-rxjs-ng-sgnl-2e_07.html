<html><head></head><body>
<div id="_idContainer057">
<h1 class="chapter-number" id="_idParaDest-101"><a id="_idTextAnchor107"/><span class="koboSpan" id="kobo.1.1">7</span></h1>
<h1 id="_idParaDest-102"><a id="_idTextAnchor108"/><span class="koboSpan" id="kobo.2.1">Sharing Data between Angular Components</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Sharing data between components is a very common use case in web applications. </span><span class="koboSpan" id="kobo.3.2">Angular provides many approaches for communicating between parent and child components, such as the popular </span><strong class="source-inline"><span class="koboSpan" id="kobo.4.1">@Input()</span></strong><span class="koboSpan" id="kobo.5.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.6.1">@Output()</span></strong><span class="koboSpan" id="kobo.7.1"> decorator patterns. </span><span class="koboSpan" id="kobo.7.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.8.1">@Input()</span></strong><span class="koboSpan" id="kobo.9.1"> decorator allows parent components to provide data to their child components, while the </span><strong class="source-inline"><span class="koboSpan" id="kobo.10.1">@Output()</span></strong><span class="koboSpan" id="kobo.11.1"> decorator allows the child component to send data to a parent component. </span><span class="koboSpan" id="kobo.11.2">That’s great, but when data needs to be shared between components that are either deeply nested or not immediately connected, those kinds of techniques become less efficient and difficult </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">to maintain.</span></span></p>
<p><span class="koboSpan" id="kobo.13.1">So, what’s the best way to share data between sibling components? </span><span class="koboSpan" id="kobo.13.2">This is the heart of this chapter. </span><span class="koboSpan" id="kobo.13.3">We will start by explaining the sharing data requirement, before walking through the different steps to implement the reactive pattern for sharing data between sibling components in our app. </span><span class="koboSpan" id="kobo.13.4">Finally, we will introduce Angular’s new Deferrable Views feature to maximize our </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">app’s performance.</span></span></p>
<p><span class="koboSpan" id="kobo.15.1">In this chapter, we’re going to cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.17.1">Defining the sharing </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">data requirement</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Exploring the reactive pattern to </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">share data</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">Leveraging Deferrable Views in </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">Angular 17</span></span></li>
</ul>
<h1 id="_idParaDest-103"><a id="_idTextAnchor109"/><span class="koboSpan" id="kobo.23.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.24.1">This chapter assumes that you have a basic understanding </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">of RxJS.</span></span></p>
<p><span class="koboSpan" id="kobo.26.1">The source code of this chapter is available </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">at </span></span><a href="https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition/tree/main/Chap07"><span class="No-Break"><span class="koboSpan" id="kobo.28.1">https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition/tree/main/Chap07</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.29.1">.</span></span></p>
<h1 id="_idParaDest-104"><a id="_idTextAnchor110"/><span class="koboSpan" id="kobo.30.1">Defining the sharing data requirement</span></h1>
<p><span class="koboSpan" id="kobo.31.1">Let’s assume that we have four components – </span><strong class="bold"><span class="koboSpan" id="kobo.32.1">C1</span></strong><span class="koboSpan" id="kobo.33.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.34.1">C2</span></strong><span class="koboSpan" id="kobo.35.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.36.1">C3</span></strong><span class="koboSpan" id="kobo.37.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.38.1">C4</span></strong><span class="koboSpan" id="kobo.39.1"> – that do not have any relationship </span><a id="_idIndexMarker285"/><span class="koboSpan" id="kobo.40.1">with each other, and there is information – </span><strong class="bold"><span class="koboSpan" id="kobo.41.1">DATA</span></strong><span class="koboSpan" id="kobo.42.1"> – shared between </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">those components:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer055">
<span class="koboSpan" id="kobo.44.1"><img alt="Figure 7.1 – Shared data between components" src="image/B21180_07_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.45.1">Figure 7.1 – Shared data between components</span></p>
<p><span class="koboSpan" id="kobo.46.1">The components can update and consume </span><strong class="bold"><span class="koboSpan" id="kobo.47.1">DATA</span></strong><span class="koboSpan" id="kobo.48.1"> at the same time. </span><span class="koboSpan" id="kobo.48.2">But at any time during the process, the components should be able to access the last value </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">of </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.50.1">DATA</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.52.1">Now, let’s make that explanation clearer with a more </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">concrete example.</span></span></p>
<p><span class="koboSpan" id="kobo.54.1">In our recipe application, when the user clicks on one recipe, it gets selected, but we want all components to have access to the last selected recipe by the user. </span><span class="koboSpan" id="kobo.54.2">In that case, the selected recipe represents our </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">shared data.</span></span></p>
<p><span class="koboSpan" id="kobo.56.1">One of the components that will need access to the selected recipe is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.57.1">RecipeDetailsComponent</span></strong><span class="koboSpan" id="kobo.58.1"> component, as it will display the details of the </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">selected recipe.</span></span></p>
<p><span class="koboSpan" id="kobo.60.1">Without further ado, in the next section, let’s see how we can make this data available to everyone in a </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">reactive way.</span></span></p>
<h1 id="_idParaDest-105"><a id="_idTextAnchor111"/><span class="koboSpan" id="kobo.62.1">Exploring the reactive pattern to share data</span></h1>
<p><span class="koboSpan" id="kobo.63.1">Angular </span><a id="_idIndexMarker286"/><span class="koboSpan" id="kobo.64.1">services are powerful and efficient </span><a id="_idIndexMarker287"/><span class="koboSpan" id="kobo.65.1">for creating common references to share both data and business logic between components. </span><span class="koboSpan" id="kobo.65.2">We will combine Angular services with Observables – more specifically, </span><strong class="source-inline"><span class="koboSpan" id="kobo.66.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.67.1"> instances – to create stateful, reactive services that will allow us to synchronize the state efficiently across an entire application. </span><span class="koboSpan" id="kobo.67.2">So, in </span><a id="_idIndexMarker288"/><span class="koboSpan" id="kobo.68.1">the following subsections, let’s </span><a id="_idIndexMarker289"/><span class="koboSpan" id="kobo.69.1">explain the steps to implement a reactive pattern to share data between unrelated or </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">sibling components.</span></span></p>
<h2 id="_idParaDest-106"><a id="_idTextAnchor112"/><span class="koboSpan" id="kobo.71.1">Step 1 – Creating a shared service</span></h2>
<p><span class="koboSpan" id="kobo.72.1">First, we will </span><a id="_idIndexMarker290"/><span class="koboSpan" id="kobo.73.1">create an Angular service called </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">SharedDataService</span></strong><span class="koboSpan" id="kobo.75.1"> using the Angular CLI, as usual under the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.76.1">src/app/core/services</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.77.1"> folder:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.78.1">
ng g s SharedData</span></pre> <p class="callout-heading"><span class="koboSpan" id="kobo.79.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.80.1">Here, we named the service </span><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">SharedDataService</span></strong><span class="koboSpan" id="kobo.82.1"> for demonstration purposes. </span><span class="koboSpan" id="kobo.82.2">While it’s true that we already have a service named </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">RecipesService</span></strong><span class="koboSpan" id="kobo.84.1"> that could have accommodated the shared data, the purpose of this chapter is to underscore the broader concept of data sharing. </span><span class="koboSpan" id="kobo.84.2">Therefore, we chose a more generic term. </span><span class="koboSpan" id="kobo.84.3">However, in your own application, it’s recommended to use specific and descriptive names such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">RecipesService</span></strong><span class="koboSpan" id="kobo.86.1"> or another name that accurately reflects the role and domain of the service. </span><span class="koboSpan" id="kobo.86.2">A name that accurately reflects the purpose of your service is crucial for clarity and maintainability, especially in a framework such as Angular where conventions can </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">guide developers.</span></span></p>
<p><span class="koboSpan" id="kobo.88.1">Then, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">SharedDataService</span></strong><span class="koboSpan" id="kobo.90.1"> class, we need to create </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.92.1">A private </span><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.94.1"> instance called </span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">selectedRecipeSubject</span></strong><span class="koboSpan" id="kobo.96.1"> that emits the value of the currently selected recipe, which represents the data to </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">be shared:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.98.1">
private selectedRecipeSubject = new BehaviorSubject&lt;Recipe | undefined&gt;(undefined);</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.99.1">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">selectedRecipeSubject</span></strong><span class="koboSpan" id="kobo.101.1"> has </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">Recipe</span></strong><span class="koboSpan" id="kobo.103.1"> as the type and </span><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">undefined</span></strong><span class="koboSpan" id="kobo.105.1"> as the initial value since initially, we don’t have any </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">selected value.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.107.1">Also, </span><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">selectedRecipeSubject</span></strong><span class="koboSpan" id="kobo.109.1"> is declared as </span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">private</span></strong><span class="koboSpan" id="kobo.111.1"> to ensure that it’s only accessible within </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">SharedDataService</span></strong><span class="koboSpan" id="kobo.113.1">, where it’s defined, protecting it from external manipulation. </span><span class="koboSpan" id="kobo.113.2">Otherwise, any external process could have access to the property and consequently call the next method and change the emissions, which is dangerous. </span><span class="koboSpan" id="kobo.113.3">This encapsulation is important for maintaining control over the state and preventing </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">unintended changes.</span></span></p></li> <li><span class="koboSpan" id="kobo.115.1">A public Observable, named </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">selectedRecipe$</span></strong><span class="koboSpan" id="kobo.117.1">, extracted from </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">selectedRecipeSubject</span></strong><span class="koboSpan" id="kobo.119.1"> to handle data as </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">an Observable:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.121.1">
selectedRecipe$ = this.selectedRecipeSubject.asObservable();</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.122.1">Here, we used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">asObservable()</span></strong><span class="koboSpan" id="kobo.124.1"> method available in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">Subject</span></strong><span class="koboSpan" id="kobo.126.1"> type to derive a read-only Observable from </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">selectedRecipeSubject</span></strong><span class="koboSpan" id="kobo.128.1">. </span><span class="koboSpan" id="kobo.128.2">This ensures that the </span><a id="_idIndexMarker291"/><span class="koboSpan" id="kobo.129.1">emissions of </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">selectedRecipeSubject</span></strong><span class="koboSpan" id="kobo.131.1"> are only consumed in read-only mode, preventing external processes from altering the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">selectedRecipeSubject</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.133.1"> value.</span></span></p></li> <li><span class="koboSpan" id="kobo.134.1">A method called </span><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">updateSelectedRecipe</span></strong><span class="koboSpan" id="kobo.136.1"> that will update the shared data, which is the </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">selected recipe:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.138.1">
updateSelectedRecipe(recipe: Recipe) {
  this.selectedRecipeSubject.next(recipe);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.139.1">This method only calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">next</span></strong><span class="koboSpan" id="kobo.141.1"> on </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">selectedRecipeSubject</span></strong><span class="koboSpan" id="kobo.143.1"> to notify all subscribers of the last selected recipe passed as a parameter. </span><span class="koboSpan" id="kobo.143.2">The process that updates the selected recipe will call this method, which we will discuss in the </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">next step.</span></span></p></li> </ul>
<p><span class="koboSpan" id="kobo.145.1">This is </span><a id="_idIndexMarker292"/><span class="koboSpan" id="kobo.146.1">what the service looks like after putting all the </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">pieces together:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.148.1">
import { Injectable } from '@angular/core';
import { BehaviorSubject } from 'rxjs';
import { Recipe } from '../model/recipe.model';
@Injectable({
  providedIn: 'root'
})
export class SharedDataService {
  private selectedRecipeSubject = new
    BehaviorSubject&lt;Recipe | undefined&gt;(undefined);
  selectedRecipe$ =
    this.selectedRecipeSubject.asObservable();
  updateSelectedRecipe(recipe: Recipe) {
    this.selectedRecipeSubject.next(recipe);
  }
}</span></pre> <p><span class="koboSpan" id="kobo.149.1">Now that we have prepared the groundwork by creating our shared data service and defined the behavior subject that will hold the shared data, let’s see how we can update the shared data in the </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">next section.</span></span></p>
<h2 id="_idParaDest-107"><a id="_idTextAnchor113"/><span class="koboSpan" id="kobo.151.1">Step 2 – Updating the last selected recipe</span></h2>
<p><span class="koboSpan" id="kobo.152.1">We should </span><a id="_idIndexMarker293"/><span class="koboSpan" id="kobo.153.1">update the shared </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">selectedRecipe</span></strong><span class="koboSpan" id="kobo.155.1"> instance when the user clicks on one of the recipe cards in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">RecipesListComponent</span></strong><span class="koboSpan" id="kobo.157.1"> component. </span><span class="koboSpan" id="kobo.157.2">As a reminder, here are the recipe cards in our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">Recipe</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.159.1"> app:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer056">
<span class="koboSpan" id="kobo.160.1"><img alt="Figure 7.2 – List of recipes" src="image/B21180_07_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.161.1">Figure 7.2 – List of recipes</span></p>
<p><span class="koboSpan" id="kobo.162.1">In order to update the shared </span><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">selectedRecipe</span></strong><span class="koboSpan" id="kobo.164.1"> instance when the user clicks on the card, we need to incorporate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">(click)</span></strong><span class="koboSpan" id="kobo.166.1"> event output in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">RecipesListComponent</span></strong><span class="koboSpan" id="kobo.168.1"> HTML template, which triggers the execution of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">editRecipe(recipe)</span></strong><span class="koboSpan" id="kobo.170.1"> method. </span><span class="koboSpan" id="kobo.170.2">This is the HTML </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">code required:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.172.1">
@if (filteredRecipes$ | async; as recipes) {
&lt;div class="card"&gt;
    &lt;p-dataView #dv [value]="recipes" [paginator]="true"
    [rows]="9" filterBy="name" layout="grid"&gt;
        &lt;ng-template let-recipes pTemplate="gridItem"&gt;
            &lt;div class="grid grid-nogutter"&gt;
                @for (recipe of recipes; track recipe) {
                &lt;div class="col-12" style="cursor:
                    pointer;" (click)="editRecipe(recipe)"
                        class="recipe-grid-item card"&gt;
// extra code here
&lt;/div&gt;
} @empty {
&lt;div&gt;There are no recipes&lt;/div&gt;
}
            &lt;/div&gt;
        &lt;/ng-template&gt;
    &lt;/p-dataView&gt;
&lt;/div&gt;
} @else {
&lt;div&gt;There are no recipes&lt;/div&gt;
}</span></pre> <p><span class="koboSpan" id="kobo.173.1">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">(click)</span></strong><span class="koboSpan" id="kobo.175.1"> event binding is applied to each card, ensuring that when clicked, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">editRecipe(recipe)</span></strong><span class="koboSpan" id="kobo.177.1"> method is invoked to update the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">selectedRecipe</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.179.1"> instance.</span></span></p>
<p><span class="koboSpan" id="kobo.180.1">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">RecipesListComponent</span></strong><span class="koboSpan" id="kobo.182.1">, we implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">editRecipe</span></strong><span class="koboSpan" id="kobo.184.1"> method as </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">follows :</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.186.1">
editRecipe(recipe: Recipe) {
  this.sharedService.updateSelectedRecipe(recipe);
  this.router.navigate(['/recipes/details']);
}</span></pre> <p><span class="koboSpan" id="kobo.187.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">editRecipe</span></strong><span class="koboSpan" id="kobo.189.1"> method takes the selected recipe as the input</span><a id="_idIndexMarker294"/><span class="koboSpan" id="kobo.190.1"> and performs </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">two actions:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.192.1">It notifies </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">selectedRecipeSubject</span></strong><span class="koboSpan" id="kobo.194.1"> that the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">selectedRecipe</span></strong><span class="koboSpan" id="kobo.196.1"> has changed by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">updateSelectedRecipe(recipe:Recipe)</span></strong><span class="koboSpan" id="kobo.198.1"> method, available in </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">SharedDataService</span></strong><span class="koboSpan" id="kobo.200.1">. </span><span class="koboSpan" id="kobo.200.2">So, we should inject the </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">SharedDataService</span></strong><span class="koboSpan" id="kobo.202.1"> service in </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">RecipesListComponent</span></strong><span class="koboSpan" id="kobo.204.1"> as </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">follows :</span></span><pre class="source-code"><span class="koboSpan" id="kobo.206.1">
import { SharedDataService } from '../core/services/shared-data.service';
export class RecipesListComponent implements OnInit {
  constructor(private sharedService:
  SharedDataService) {}
}</span></pre></li> <li><span class="koboSpan" id="kobo.207.1">It displays the details of the recipe by routing to </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">RecipeDetailsComponent</span></strong><span class="koboSpan" id="kobo.209.1">, the standalone component responsible for rendering and displaying the details of a recipe. </span><span class="koboSpan" id="kobo.209.2">We’ve added a route configuration in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">app-routing-module.ts</span></strong><span class="koboSpan" id="kobo.211.1"> file as </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">follows :</span></span><pre class="source-code"><span class="koboSpan" id="kobo.213.1">
import { RecipeDetailsComponent } from
'./recipe-details/recipe-details.component';
const routes: Routes = [
  { path: 'recipes/details',
  component: RecipeDetailsComponent},
];</span></pre></li> </ul>
<p><span class="koboSpan" id="kobo.214.1">At this point, we have put in place the mechanism that updates the value of the shared data. </span><span class="koboSpan" id="kobo.214.2">Now, all that is left is to listen to the shared data and </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">consume it.</span></span></p>
<h2 id="_idParaDest-108"><a id="_idTextAnchor114"/><span class="koboSpan" id="kobo.216.1">Step 3 – Consuming the last selected recipe</span></h2>
<p><span class="koboSpan" id="kobo.217.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">RecipeDetails</span></strong><span class="koboSpan" id="kobo.219.1"> component, we need to consume the last selected recipe in order </span><a id="_idIndexMarker295"/><span class="koboSpan" id="kobo.220.1">to display its details. </span><span class="koboSpan" id="kobo.220.2">So, again, we need to inject </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">SharedDataService</span></strong><span class="koboSpan" id="kobo.222.1"> and define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">selectedRecipe$</span></strong><span class="koboSpan" id="kobo.224.1"> Observable – which will emit the last selected recipe – </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.226.1">
import { SharedDataService } from '../core/services/shared-data.service';
export class RecipeDetailsComponent {
  constructor(private sharedService: SharedDataService) { }
  selectedRecipe$ = this.sharedService.selectedRecipe$;
}</span></pre> <p><span class="koboSpan" id="kobo.227.1">Then, we will subscribe to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">selectedRecipe$</span></strong><span class="koboSpan" id="kobo.229.1"> Observable using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">async</span></strong><span class="koboSpan" id="kobo.231.1"> pipe in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">RecipeDetailsComponent</span></strong><span class="koboSpan" id="kobo.233.1"> HTML template in order to display the selected recipe’s details, as </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">follows :</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.235.1">
@if (selectedRecipe$|async;as recipe) {
&lt;div&gt;
    &lt;span&gt; {{recipe.title}} &lt;/span&gt;
    &lt;span&gt; {{recipe.steps}} &lt;/span&gt;
    &lt;span&gt; {{recipe.ingredients}} &lt;/span&gt;
&lt;/div&gt;
}</span></pre> <p><span class="koboSpan" id="kobo.236.1">And that’s it – this is how you can share data between unrelated components throughout </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">the application!</span></span></p>
<p><span class="koboSpan" id="kobo.238.1">Now, we can use the latest value of the recipe everywhere – we only have to inject </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">SharedDataService</span></strong><span class="koboSpan" id="kobo.240.1"> into the component that needs the shared data and subscribe to the public Observable that emits </span><a id="_idIndexMarker296"/><span class="koboSpan" id="kobo.241.1">the read-only value. </span><span class="koboSpan" id="kobo.241.2">For example, we can add this code in </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">HeaderComponent</span></strong><span class="koboSpan" id="kobo.243.1"> to display the title of the last selected recipe in the </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">application’s header:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.245.1">
@if(selectedRecipe$|async; as recipe) {
    &lt;div&gt;
        &lt;span&gt; {{recipe.title}} &lt;/span&gt;
    &lt;/div&gt;
}</span></pre> <p><span class="koboSpan" id="kobo.246.1">If we change the shared value in this component, all other components that listen to the shared data will get notified to </span><a id="_idIndexMarker297"/><span class="koboSpan" id="kobo.247.1">update </span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">their processes.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.249.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.250.1">We used this pattern in </span><a href="B21180_05.xhtml#_idTextAnchor083"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.251.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.252.1">, </span><em class="italic"><span class="koboSpan" id="kobo.253.1">Combining Streams</span></em><span class="koboSpan" id="kobo.254.1">, to share the value of the filter in </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">RecipesFilterComponent</span></strong><span class="koboSpan" id="kobo.256.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">RecipesListComponent</span></strong><span class="koboSpan" id="kobo.258.1"> instances, and then we combined the streams to display the </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">filtered results.</span></span></p>
<h2 id="_idParaDest-109"><a id="_idTextAnchor115"/><span class="koboSpan" id="kobo.260.1">Wrapping up the data-sharing reactive pattern</span></h2>
<p><span class="koboSpan" id="kobo.261.1">To summarize everything, here’s a wrap-up of </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">the steps:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.263.1">Begin by creating an Angular service that will be shared across components. </span><span class="koboSpan" id="kobo.263.2">Within this service, define a private </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.265.1"> instance that will emit the shared value to</span><a id="_idIndexMarker298"/><span class="koboSpan" id="kobo.266.1"> its subscribers, remembering to specify the type of data emitted by </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.268.1"> and initialize it with the initial value of the </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">shared data.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.270.1">It’s important to note that we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.272.1"> for two </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">primary reasons:</span></span></p><ul><li><span class="koboSpan" id="kobo.274.1">It allows us to broadcast shared data to </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">multiple observers.</span></span></li><li><span class="koboSpan" id="kobo.276.1">It stores the latest value emitted to its observers, and any new subscriber immediately receives the last emitted value </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">upon subscription.</span></span></li></ul></li>
<li><span class="koboSpan" id="kobo.278.1">Next, define a public Observable within the shared service to hold the read-only </span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">shared value.</span></span></li>
<li><span class="koboSpan" id="kobo.280.1">Implement an </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">update</span></strong><span class="koboSpan" id="kobo.282.1"> method within the shared service to update the shared value by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">next</span></strong><span class="koboSpan" id="kobo.284.1"> method of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">Subject</span></strong><span class="koboSpan" id="kobo.286.1"> type to emit the updated value </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">to subscribers.</span></span></li>
<li><span class="koboSpan" id="kobo.288.1">Inject the shared service in the component responsible for updating the value of the shared data and call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">update</span></strong><span class="koboSpan" id="kobo.290.1"> method implemented in </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">the service.</span></span></li>
<li><span class="koboSpan" id="kobo.292.1">Inject the shared service in the component that consumes the value of the shared data and subscribe to the exposed Observable in </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">the service.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.294.1">This reactive sharing data pattern has </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">many benefits:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.296.1">It improves the sharing of data between </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">unrelated components.</span></span></li>
<li><span class="koboSpan" id="kobo.298.1">It manages mutability risk. </span><span class="koboSpan" id="kobo.298.2">In fact, as we only expose the read-only extracted Observable to other consumers and keep </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.300.1"> private, we prevent shared data from being modified by subscribers, which can lead to data corruption and </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">unexpected behavior.</span></span></li>
<li><span class="koboSpan" id="kobo.302.1">It makes communication between components easier as you will only have to inject the shared service where you need it and just take care of updating </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">the data.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.304.1">As far as I’m concerned, this is the simplest way to share data between unrelated components in Angular and manage the application state. </span><span class="koboSpan" id="kobo.304.2">This works perfectly in many situations, but for big applications where there are a lot of user interactions and multiple data sources, managing states in services can </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">become complicated.</span></span></p>
<p><span class="koboSpan" id="kobo.306.1">In those cases, we can use a state management library to manage the state of our application. </span><span class="koboSpan" id="kobo.306.2">There are many great state management libraries out there to manage states in Angular, all with one thing in common – they are built on top of RxJS Observables, and the state is stored in </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.308.1">. </span><span class="koboSpan" id="kobo.308.2">The most </span><a id="_idIndexMarker299"/><span class="koboSpan" id="kobo.309.1">popular state management library is NgRx, which you can find out more about </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">here: </span></span><a href="https://ngrx.io/guide/store"><span class="No-Break"><span class="koboSpan" id="kobo.311.1">https://ngrx.io/guide/store</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.312.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.313.1">Data-sharing mechanisms facilitate communication between different components and improve the user experience, as well as the responsiveness of your application. </span><span class="koboSpan" id="kobo.313.2">Before ending this chapter, I want to shed light on a new feature introduced in Angular 17, Deferrable Views, which can complement data sharing and contribute to creating more responsive and efficient applications. </span><span class="koboSpan" id="kobo.313.3">Let’s see this in action in the </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">next section.</span></span></p>
<h1 id="_idParaDest-110"><a id="_idTextAnchor116"/><span class="koboSpan" id="kobo.315.1">Leveraging Deferrable Views in Angular 17</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.316.1">Deferrable Views</span></strong><span class="koboSpan" id="kobo.317.1"> allow you to declaratively mark parts of your templates as non-essential for immediate rendering. </span><span class="koboSpan" id="kobo.317.2">It is kind like delaying the rendering of certain parts of a page to improve the perceived</span><a id="_idIndexMarker300"/><span class="koboSpan" id="kobo.318.1"> performance of your application, as well as optimize the initial bundle size and </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">loading times.</span></span></p>
<p><span class="koboSpan" id="kobo.320.1">There are a number of real-world scenarios </span><a id="_idIndexMarker301"/><span class="koboSpan" id="kobo.321.1">where defer rendering can help to achieve faster load times such as e-commerce product pages – in this example, you can initially display the essential product details and then lazy load additional content such as reviews when the user clicks on a </span><strong class="bold"><span class="koboSpan" id="kobo.322.1">Read more</span></strong><span class="koboSpan" id="kobo.323.1"> button or scrolls down </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">the page.</span></span></p>
<p><span class="koboSpan" id="kobo.325.1">Let’s quickly see how this works. </span><span class="koboSpan" id="kobo.325.2">To lazy load a component, you need to use a Standalone component, otherwise deferring won’t work. </span><span class="koboSpan" id="kobo.325.3">Then you want to wrap up the Standalone component in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">@defer</span></strong><span class="koboSpan" id="kobo.327.1"> block, </span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.329.1">
@defer {
  &lt;delayed-component /&gt;
}</span></pre> <p><span class="koboSpan" id="kobo.330.1">You can also define conditions for when exactly the deferred component should load. </span><span class="koboSpan" id="kobo.330.2">You can do this by using </span><strong class="bold"><span class="koboSpan" id="kobo.331.1">triggers</span></strong><span class="koboSpan" id="kobo.332.1">, which specify events or situations that </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">initiate loading:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.334.1">
@defer(on viewport) {
  &lt;delayed-component /&gt;
}</span></pre> <p><span class="koboSpan" id="kobo.335.1">Here, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">on viewport</span></strong><span class="koboSpan" id="kobo.337.1"> trigger is used to display the </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">delayed-component</span></strong><span class="koboSpan" id="kobo.339.1"> when it enters the viewport area of the user’s </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">browser window.</span></span></p>
<p><span class="koboSpan" id="kobo.341.1">Besides </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">on viewport</span></strong><span class="koboSpan" id="kobo.343.1">, there are other triggers that can be used such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">on hover</span></strong><span class="koboSpan" id="kobo.345.1">, which only initiates the content to load when the user’s mouse hovers over the delayed content. </span><span class="koboSpan" id="kobo.345.2">You can find a full list of available triggers </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">here: </span></span><a href="https://angular.dev/guide/defer#triggers"><span class="No-Break"><span class="koboSpan" id="kobo.347.1">https://angular.dev/guide/defer#triggers</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.348.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.349.1">Furthermore, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">@defer</span></strong><span class="koboSpan" id="kobo.351.1"> block has some important sub-blocks. </span><span class="koboSpan" id="kobo.351.2">For example, you can display alternative content before the deferred content loads using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">@placeholder</span></strong><span class="koboSpan" id="kobo.353.1"> sub-block, </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.355.1">
@defer(on viewport) {
    &lt;delayed-component /&gt;
}
@placeholder {
    &lt;div&gt;Placeholder text here&lt;/div&gt;
}</span></pre> <p><span class="koboSpan" id="kobo.356.1">In addition to </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">@placeholder</span></strong><span class="koboSpan" id="kobo.358.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">@defer</span></strong><span class="koboSpan" id="kobo.360.1"> also offers two other sub-blocks – </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">@loading</span></strong><span class="koboSpan" id="kobo.362.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">error</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.365.1"> :</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.366.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">@loading</span></strong><span class="koboSpan" id="kobo.368.1"> block is</span><a id="_idIndexMarker302"/><span class="koboSpan" id="kobo.369.1"> similar to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">@placeholder</span></strong><span class="koboSpan" id="kobo.371.1"> block, but it specifically shows content like a loading message while the actual content is</span><a id="_idIndexMarker303"/> <span class="No-Break"><span class="koboSpan" id="kobo.372.1">being prepared.</span></span></li>
<li><span class="koboSpan" id="kobo.373.1"> The </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">@error</span></strong><span class="koboSpan" id="kobo.375.1"> block is displayed if there is an error while fetching or processing the deferred content. </span><span class="koboSpan" id="kobo.375.2">This allows you to provide a user-friendly error message, or alternative content, in case something </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">goes wrong.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.377.1">Now let’s look at how we can utilize defer rending in our Recipe app. </span><span class="koboSpan" id="kobo.377.2">Given that the images for each recipe have a high resolution, let’s delay the rendering of the images in </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">RecipesListComponent</span></strong><span class="koboSpan" id="kobo.379.1"> HTML template so that they are only shown when the user hovers over </span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">the image:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.381.1">
@defer (on hover) {
    &lt;img class="recipe-image" [src]="'assets/recipes/'+
    recipe.imageUrl" [alt]="recipe.title" /&gt;
}
@placeholder {
    &lt;div&gt;Hover to load the image&lt;/div&gt;
}</span></pre> <p><span class="koboSpan" id="kobo.382.1">As you can see, we surrounded the code block displaying the image with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">@defer</span></strong><span class="koboSpan" id="kobo.384.1"> block, and used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">on hover</span></strong><span class="koboSpan" id="kobo.386.1"> trigger. </span><span class="koboSpan" id="kobo.386.2">Then we used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">@placeholder</span></strong><span class="koboSpan" id="kobo.388.1"> block to specify some text that should be displayed </span><a id="_idIndexMarker304"/><span class="koboSpan" id="kobo.389.1">while the deferred content is not yet loaded. </span><span class="koboSpan" id="kobo.389.2">In this </span><a id="_idIndexMarker305"/><span class="koboSpan" id="kobo.390.1">case, inside the &lt;div&gt; element, we added the text, </span><strong class="bold"><span class="koboSpan" id="kobo.391.1">Hover to load </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.392.1">the image</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.394.1">For more details about the Deferrable Views feature, refer </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">to </span></span><a href="https://angular.dev/guide/image-optimization"><span class="No-Break"><span class="koboSpan" id="kobo.396.1">https://angular.dev/guide/image-optimization</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.397.1">.</span></span></p>
<h1 id="_idParaDest-111"><a id="_idTextAnchor117"/><span class="koboSpan" id="kobo.398.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.399.1">In this chapter, we explained the motivation behind sharing data between components and learned how to implement it in a reactive way. </span><span class="koboSpan" id="kobo.399.2">First, we learned how we can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.401.1"> combined with Angular services to share data between unrelated components and manage our application state. </span><span class="koboSpan" id="kobo.401.2">Then, we highlighted the advantages of the sharing data reactive pattern. </span><span class="koboSpan" id="kobo.401.3">Finally, we explored Angular’s new Deferrable </span><span class="No-Break"><span class="koboSpan" id="kobo.402.1">Views feature.</span></span></p>
<p><span class="koboSpan" id="kobo.403.1">The features covered in this chapter will help you implement a good architecture for your web application, making it more reactive and performant, improving load times, and reducing the cost </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">of maintainability.</span></span></p>
<p><span class="koboSpan" id="kobo.405.1">Now, get ready for an exciting journey, because in the next chapter, we delve into a brand-new feature called Angular Signals! </span><span class="koboSpan" id="kobo.405.2">We’ll cover some reactive patterns using Signals and even integrate them into what we’ve learned </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">so far.</span></span></p>
</div>


<div class="Content" id="_idContainer058">
<h1 id="_idParaDest-112" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor118"/><span class="koboSpan" id="kobo.1.1">Part 3: The Power of Angular Signals</span></h1>
<p><span class="koboSpan" id="kobo.2.1">Dive into the exciting world of Angular Signals! </span></p>
<p><span class="koboSpan" id="kobo.3.1">In this section, you will discover the core functionalities and advantages of Angular Signals, as well as unlock the potential of reactivity by leveraging Angular Signals and RxJS together. </span><span class="koboSpan" id="kobo.3.2">We will also go through the latest Angular Signals improvements. </span></p>
<p><span class="koboSpan" id="kobo.4.1">This part includes the </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">following chapter:</span></span></p>
<ul>
<li><a href="B21180_08.xhtml#_idTextAnchor119"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 8</span></em></a><span class="koboSpan" id="kobo.7.1">, </span><em class="italic"><span class="koboSpan" id="kobo.8.1">Mastering Reactivity with Angular Signals</span></em></li>
</ul>
</div>
<div>
<div id="_idContainer059">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer060">
</div>
</div>
</body></html>