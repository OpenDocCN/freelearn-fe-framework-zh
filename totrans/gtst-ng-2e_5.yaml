- en: Chapter 5. Dependency Injection in Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll explain how to take advantage of the **dependency injection**
    (**DI**) mechanism of the framework, with all its various features.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will explore the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring and creating injectors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instantiating objects using injectors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Injecting dependencies into directives and components-this way, we will be able
    to reuse the business logic defined within the services and wire it up with the
    UI logic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Annotating ES5 code in order to get the exact same result we get when we use
    the TypeScript syntax.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why do I need DI?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s suppose that we have a `Car` class that depends on `Engine` and `Transmission`
    classes. How can we implement this system? Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we create the dependencies of the `Car` class inside
    its constructor. Although it looks simple, it is far from being flexible. Each
    time we create an instance of the `Car` class, in its constructor, instances of
    the same `Engine` and `Transmission` classes will be created. This may be problematic
    because of the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Car` class gets less testable because we can't test it independently of its
    `engine` and `transmission` dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We couple the `Car` class with the logic used for the instantiation of its dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DI in Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another way we can approach this is by taking advantage of the DI pattern.
    We''re already familiar with it from AngularJS; let''s demonstrate how we can
    refactor the preceding code using DI in the context of Angular:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: All we did in the preceding snippet was add the `@Injectable` class decorator
    on top of the definition of the `Car` class and provide type annotations for the
    parameters of its constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of DI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is one more step left, which we''ll take a look at in the next section.
    Before that, let''s take a look at what the benefits of the mentioned approach
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: We can easily pass different versions of the dependencies of the `Car` class
    for a testing environment, or for instantiating different `Car` models.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We're not coupled with the logic around the dependencies' instantiation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Car` class is only responsible for implementing its own domain-specific
    logic instead of being coupled with additional functionalities, such as the management
    of its dependencies. Our code also got more declarative and easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: Now, that we've realized some of the benefits of DI, let's take a look at the
    missing pieces in order to make this code work.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring an injector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The primitive used for the instantiation of the individual dependencies in our
    Angular applications via the DI mechanism of the framework is called the **injector**.
    The injector contains a set of **providers** that encapsulate the logic for the
    instantiation of registered dependencies associated with **tokens**. We can think
    of tokens as identifiers of the different providers registered within the injector.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following snippet, which is located at `ch5/ts/injector-basics/injector.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run the file using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you haven't installed `ts-node` yet, take a look at [Chapter 3](ch03.html
    "Chapter 3. TypeScript Crash Course"), *TypeScript Crash Course*, which explains
    how you can proceed in order to have it up and running on your computer.
  prefs: []
  type: TYPE_NORMAL
- en: We then import `ReflectiveInjector`, `Injectable`, `Inject`, `OpaqueToken`,
    and `provide`.
  prefs: []
  type: TYPE_NORMAL
- en: Injector represents an abstract **container** used for the instantiation of
    the different dependencies; `ReflectiveInjector` is a concrete class, which implements
    this abstraction. Using rules like the one declared, with the object literal passed
    as first argument to `resolveAndCreate` and the metadata generated by the TypeScript
    compiler, `ReflectiveInjector` knows how to create the different dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding snippet, we initially define the `BUFFER_SIZE` constant and
    set it to the `new OpaqueToken('buffer-size')` value. We can think of the value
    of `BUFFER_SIZE` as a unique value that cannot be duplicated in the application
    (`OpaqueToken` is an alternative of the `Symbol` class from ES2015, since at the
    time of writing this book, it is not supported by TypeScript).
  prefs: []
  type: TYPE_NORMAL
- en: 'We defined two classes: `Buffer` and `Socket`. The `Buffer` class has a constructor
    that accepts only a single dependency called `size`, which is of the type `Number`.
    In order to add additional metadata for the process of dependency resolution,
    we use the `@Inject` parameter decorator. This decorator accepts an identifier
    (also known as **token**) for the dependency we want to inject. Usually, it is
    the type of the dependency (that is, a reference of a class), but in some cases,
    it can be a different type of value. For example, in our case, we used the instance
    of the `OpaqueToken` class.'
  prefs: []
  type: TYPE_NORMAL
- en: Dependency resolution with generated metadata
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's take a look at the `Socket` class. We decorate it with the `@Injectable`
    decorator. This decorator is supposed to be used by any class that accepts dependencies
    that should be injected via the DI mechanism of Angular.
  prefs: []
  type: TYPE_NORMAL
- en: The `@Injectable` decorator forces the TypeScript compiler to generate additional
    metadata for the types of dependencies that a given class accepts. This means
    that, if we omit the `@Injectable` decorator, Angular's DI mechanism will not
    be aware of the tokens associated with the dependencies it needs to resolve.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript doesn't generate any metadata if no decorator is used on top of a
    class, mostly for performance concerns. Imagine, if such metadata was generated
    for each individual class that accepts dependencies-in this case, the output would
    be bloated with an additional type metadata that would be unused.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative to using `@Injectable` is to explicitly declare the tokens of
    the dependencies using the `@Inject` decorator. Take a look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This means that the preceding code has equivalent semantics to the code that
    uses `@Injectable`, as mentioned earlier. The only difference is that Angular
    will get the type of dependency (that is, the token associated with it) explicitly
    (directly from the metadata added by the `@Inject` decorator) as compared to the
    case where `@Injectable` is used, when it will look at the metadata generated
    by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Instantiating an injector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s create an instance of an injector in order to use it for the instantiation
    of registered tokens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We create an instance of the `ReflectiveInjector` using its static method called
    `resolveAndCreate`. This is a factory method that accepts an array of providers
    as argument and returns a new `ReflectiveInjector`.
  prefs: []
  type: TYPE_NORMAL
- en: '`resolve` means that the providers will go through a resolution process, which
    includes some internal processing (flattening multiple nested arrays and converting
    individual providers into an array). Later, the injector can instantiate any of
    the dependencies for which we have registered providers based on the rules the
    providers encapsulate.'
  prefs: []
  type: TYPE_NORMAL
- en: In our case, with the provider's declaration we explicitly tell the Angular's
    DI mechanism to use the value `42` when the `BUFFER_SIZE` token is required. The
    other two providers are implicit. Angular will instantiate them by invoking the
    provided class with the `new` operator once all of their dependencies are resolved.
  prefs: []
  type: TYPE_NORMAL
- en: 'We request the `BUFFER_SIZE` value in the constructor of the `Buffer` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we use the `@Inject` parameter decorator. It hints
    the DI mechanism that the first argument of the constructor of the `Buffer` class
    should be instantiated with the provider associated with the `BUFFER_SIZE` token
    passed to the injector.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing forward references
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Angular introduced the concept of **forward references**. It is required due
    to the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: ES2015 classes are not hoisted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing resolution of the dependencies that are declared after the declaration
    of the dependent providers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we will explain the problem that forward references solve and
    the way we can take advantage of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s suppose that we have defined the `Buffer` and `Socket` classes
    in the opposite order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have the exact same dependencies as the ones in the previous example
    but, in this case, the `Socket` class definition precedes the definition of the
    `Buffer` class. Note that the value of the `Buffer` identifier will equal `undefined`
    until the JavaScript virtual machine evaluates the declaration of the `Buffer`
    class. However, the metadata for the types of dependencies that `Socket` accepts
    will be generated and placed right after the `Socket` class definition. This means
    that, during the interpretation of the generated JavaScript, the value of the
    `Buffer` identifier will equal `undefined`-that is, as a type of dependency (or
    in the context of the DI mechanism of Angular, its token), the framework will
    get an invalid value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the preceding snippet will result in a runtime error of the following
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '****Error: Cannot resolve all parameters for Socket(undefined). Make sure they
    all have valid type or annotations.****'
  prefs: []
  type: TYPE_NORMAL
- en: 'The best way to resolve this issue is by swapping the definitions with their
    proper order. Another way we can proceed is to take advantage of a solution that
    Angular provides-a forward reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet demonstrates how we can take advantage of forward references.
    All we need to do is invoke the `@Inject` parameter decorator with argument the
    result of the invocation of the `forwardRef` function. The `forwardRef` function
    is a higher-order function that accepts a single argument-another function that
    is responsible for returning the token associated with the dependency (or more
    precisely associated with its provider) that needs to be injected. This way, the
    framework provides a way to defer the process of resolving the types (tokens)
    of dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: The token of the dependency will be resolved the first time `Socket` needs to
    be instantiated, unlike the default behavior in which the token is required at
    the time of the declaration of the given class.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring providers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at an example similar to the one used earlier, but
    with a different configuration of the injector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this case, inside the provider, we explicitly declared that we want the `Buffer`
    class to be used for the construction of the dependency with a token equal to
    the reference of the `Buffer` class. We do the exact same thing for the dependency
    associated with the `Socket` token; but, this time, we provided the `Socket` class
    instead. This is how Angular will proceed when we omit the explicit provider declaration and
    pass only a reference to a class instead.
  prefs: []
  type: TYPE_NORMAL
- en: Explicitly declaring the class used for the creation of an instance of the same
    class may seem quite worthless, and given the examples we have looked at so far,
    that'd be completely correct. In some cases, however, we might want to provide
    a different class for the instantiation of a dependency associated with a given
    class token.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s suppose we have the `Http` service that is used in a service
    called `UserService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `UserService` service uses `Http` for communication with a RESTful service.
    We can instantiate `UserService` using `injector.get(UserService)`. This way,
    the constructor of `UserService` invoked by the injector''s `get` method will
    accept an instance of the `Http` service as an argument. However, if we want to
    test `UserService`, we don''t really need to make HTTP calls to the RESTful service.
    In the case of unit testing, we can provide a dummy implementation that will only
    fake these HTTP calls. In order to inject an instance of a different class to
    the `UserService` service, we can change the configuration of the injector to
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now, when we instantiate `UserService`, its constructor will receive a reference
    to an instance of the `DummyHttp` service. This code is available at `ch5/ts/configuring-providers/dummy-http.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: Using existing providers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another way to proceed is by using the `useExisting` property of the provider''s
    configuration object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we register three tokens: `DummyService`, `UserService`,
    and `Http`. We declare that we want to bind the `Http` token to the existing token,
    `DummyService`. This means that, when the `Http` service is requested, the injector
    will find the provider for the token used as the value of the `useExisting` property
    and instantiate it or get the value associated with it. We can think of `useExisting`
    as creating an alias of the given token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet will create an alias of the `Http` token to the `DummyHttp`
    token. This means that once the `Http` token is requested, the call will be forwarded
    to the provider associated with the `DummyHttp` token, which will be resolved
    to the value of `dummyHttp`.
  prefs: []
  type: TYPE_NORMAL
- en: Defining factories for instantiating services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's suppose that we want to create a complex object, for example, one
    that represents a **Transport Layer Security** (**TLS**) connection. A few of
    the properties of such an object are a socket, a set of crypto protocols, and
    a certificate. In the context of this problem, the features of the DI mechanism
    of Angular we have looked at so far might seem a bit limited.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we might need to configure some of the properties of the `TLSConnection`
    class without coupling the process of its instantiation with all the configuration
    details (choose appropriate crypto algorithms, open the TCP socket over which
    we will establish the secure connection, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we can take advantage of the `useFactory` property of the provider''s
    configuration object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The snippet above seems a bit complex at first, but let''s take a look at it
    step-by-step. We can start with the parts we''re already familiar with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Initially, we register a number of providers: `Buffer`, `Socket`, `Certificate`,
    and `Crypto`. Just like in the preceding example, we also register the `BUFFER_SIZE`
    token and associated it with the value `42`. This means that we can already create
    objects of the `Buffer`, `Socket`, `Certificate`, and `Crypto` types, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create and configure an instance of the `TLSConnection` object in the
    following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we register a provider that has the `TLSConnection` token as a dependency,
    we will prevent the DI mechanism of Angular from taking care of the dependency
    resolution process. In order to handle this problem, we can use the `useFactory`
    property of the provider''s configuration object. This way, we can specify a function
    in which we can manually create the instance of the object associated with the
    provider''s token. We can use the `useFactory` property together with the `deps`
    property in order to specify the dependencies to be passed to the factory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we define the factory function used for the instantiation
    of `TLSConnection`. As dependencies, we declare `Socket`, `Certificate`, and `Crypto`.
    These dependencies are resolved by the DI mechanism of Angular and injected into
    the factory function. You can take a look at the entire implementation and play
    with it at `ch5/ts/configuring-providers/factory.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: Child injectors and visibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will take a look at how we can build a hierarchy of injectors.
    This is a completely new concept in the framework introduced by Angular 2\. Each
    injector can have either zero or one parent injectors, and each parent injector
    can have zero or more children. In contrast to AngularJS where all the registered
    providers are stored in a flat structure, in Angular 2 and later versions, they
    are stored in a tree. The flat structure is more limited; for instance, it doesn't
    support the namespacing of tokens; we cannot declare different providers for the
    same token, which might be required in some cases. So far, we have looked at an
    example of an injector that doesn't have any children or a parent. Now, let's
    build a hierarchy of injectors.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to gain a better understanding of this hierarchical structure of injectors,
    let''s take a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Child injectors and visibility](img/5081_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we see a tree where each node is an injector, and each of these injectors
    keeps a reference to its parent. The injector **House** has three child injectors:
    **Bathroom**, **Kitchen**, and **Garage**.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Garage** has two child injectors: **Car** and **Storage**. We can think of
    these injectors as containers with registered providers inside of them.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's suppose that we want to get the value of the provider associated with
    the token **Tire**. If we use the injector **Car**, this means that Angular's
    DI mechanism will try to find the provider associated with this token in **Car**
    and all of its parents, **Garage** and **House**, until it finds it.
  prefs: []
  type: TYPE_NORMAL
- en: Building a hierarchy of injectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to gain a better understanding of the paragraph, let''s take a look
    at this simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The imports are omitted since they are not essential to explain the code. We
    have two services, `Http` and `UserService`, where `UserService` depends on the
    `Http` service.
  prefs: []
  type: TYPE_NORMAL
- en: Initially, we create an injector using the `resolveAndCreate` static method
    of the `ReflectiveInjector` class. We pass an implicit provider to this injector,
    which will later be resolved to a provider with an `Http` token. Using `resolveAndCreateChild`,
    we resolve the passed providers and instantiate an injector, which points to `parentInjector`
    (so, we get the same relation as the one between **Garage** and **House** shown
    in the previous diagram).
  prefs: []
  type: TYPE_NORMAL
- en: Now, using `childInjector.get(UserService)`, we are able to get the value associated
    with the `UserService` token. Similarly, using `childInjector.get(Http)` and `parentInjector.get(Http)`,
    we get the same value associated with the `Http` token. This means that `childInjector`
    asks its parent for the value associated with the requested token.
  prefs: []
  type: TYPE_NORMAL
- en: However, if we try to use `parentInjector.get(UserService)`, we won't be able
    to get the value associated with the token, since its provider is registered in
    `childInjector`.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we're familiar with the injectors' hierarchy, let's see how we can
    get the dependencies from the appropriate injectors in it.
  prefs: []
  type: TYPE_NORMAL
- en: Using the @Self decorator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let''s suppose that we have the following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can instantiate the `UserService` token using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In `UserService`, we can declare that we want to get the `Channel` dependency
    from the current injector (that is, `childInjector`) using the `@Self` decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Although this will be the default behavior during the instantiation of the
    `UserService`, using `@Self`, we can be more explicit. Let''s suppose that we
    change the configuration of `childInjector` to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If we keep the `@Self` decorator in the `UserService` constructor and try to
    instantiate `UserService` using `childInjector`, we will get a runtime error because
    of the missing provider for `Channel`.
  prefs: []
  type: TYPE_NORMAL
- en: Skipping the self injector
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In some cases, we may want to use the provider registered in the parent injector
    instead of the one registered in the current injector. We can achieve this behavior
    by taking advantage of the `@SkipSelf` decorator. For instance, let''s suppose
    that we have the following definition of the `Context` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Each instance of the `Context` class has a parent. Now, let''s build a hierarchy
    of two injectors, which will allow us to create a context with a parent context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Since the root context doesn't have a parent, we will set the value of its provider
    to be `new Context(null)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to instantiate the child context, we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: For the instantiation of the child, `Context` will be used by the provider registered
    within the `childInjector`. However, as a dependency, it accepts an object that
    is an instance of the `Context` class. Such classes exist in the same injector,
    which means that Angular will try to instantiate it, but it has a dependency of
    the `Context` type. This process will lead to an infinite loop that will cause
    a runtime error.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to prevent it from happening, we can change the definition of `Context`
    in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The only change that we introduced is the addition of the parameter decorator
    `@SkipSelf`.
  prefs: []
  type: TYPE_NORMAL
- en: Having optional dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Angular 2 introduced the `@Optional` decorator, which allows us to deal with
    dependencies that don't have a registered provider associated with them. Let's
    suppose that a dependency of a provider is not available in any of the target
    injectors responsible for its instantiation. If we use the `@Optional` decorator,
    during the instantiation of the dependent provider the value of the missing dependency
    will be passed `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we defined an abstract class called `SortingAlgorithm` and a class
    called `Collection`, which accepts an instance of a concrete class as a dependency
    that extends `SortingAlgorithm`. Inside the `Collection` constructor, we set the
    `sort` instance property to the passed dependency of the `SortingAlgorithm` type
    or a default sorting algorithm implementation.
  prefs: []
  type: TYPE_NORMAL
- en: We didn't define any providers for the `SortingAlgorithm` token in the injector
    we configured. So, if we want to get an instance of the `Collection` class using
    `injector.get(Collection)`, we'll get a runtime error. This means that if we want
    to get an instance of the `Collection` class using the DI mechanism of the framework,
    we must register a provider for the `SortingAlgorithm` token, although we may
    want to fall back to a default sorting algorithm, returned by the `getDefaultSort`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular provides a solution to this problem with the `@Optional` decorator.
    This is how we can approach the problem using it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we declare the `sort` dependency as optional, which
    means that if Angular doesn't find any provider for its token, it will pass the
    `null` value.
  prefs: []
  type: TYPE_NORMAL
- en: Using multiproviders
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Multiproviders are another new concept introduced to the DI mechanism of Angular
    in version 2\. They allow us to associate multiple providers with the same token.
    This can be quite useful if we're developing a third-party library that comes
    with some default implementations of different services, but you want to allow
    the users to extend it with custom ones. They are also exclusively used to declare
    multiple validations over a single control in the Angular's form module. We will
    explain this module in [Chapter 6](ch06.html "Chapter 6. Working with the Angular
    Router and Forms"), *Working with the Angular Router and Forms*, and [Chapter
    7](ch07.html "Chapter 7. Explaining Pipes and Communicating with RESTful Services"),
    *Explaining Pipes and Communicating with RESTful Services*.
  prefs: []
  type: TYPE_NORMAL
- en: Another sample of an applicable use case of multiproviders is what Angular uses
    for event management in its Web Workers implementation. They create multiproviders
    for event management plugins. Each of the providers return a different strategy,
    which supports a different set of events (touch events, keyboard events, and so
    on). Once a given event occurs, they can choose the appropriate plugin that handles
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example that illustrates a typical usage of multiproviders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we declare a constant called `VALIDATOR` and as its
    value we set a new instance of `OpaqueToken`. We also create an injector where
    we register three providers-two of them provide functions that, based on different
    criteria, validate instances of the class `Employee`. These functions are of the
    type `EmployeeValidator`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to declare that we want the injector to pass all the registered validators
    to the constructor of the `Employee` class, we need to use the following constructor
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the example, we declare a class `Employee` that accepts a single dependency:
    an array of `EmployeeValidator`s. In the method `validate`, we apply the individual
    validators over the current class instance and filter the results in order to
    get only the ones that have returned an error message.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the constructor argument `validators` is of the `EmployeeValidator[]`
    type. Since we can't use the type "array of objects" as a token for a provider,
    because it is not a valid value in JavaScript and can't be used as a token, we
    will need to use the `@Inject` parameter decorator.
  prefs: []
  type: TYPE_NORMAL
- en: Using DI with components and directives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 4](ch04.html "Chapter 4. Getting Started with Angular Components
    and Directives"), *Getting Started with Angular Components and Directives*, when
    we developed our first Angular directive, we saw how we can take advantage of
    the DI mechanism to inject services into our UI-related components (that is, directives
    and components).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a quick look at what we did earlier, but from a DI perspective:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Most of the code from the earlier implementation is omitted because it is not
    directly related to our current focus.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the constructor of `Tooltip` accepts two dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: An instance of the `ElementRef` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An instance of the `Overlay` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The types of dependencies are the tokens associated with their providers and
    the corresponding values obtained from the providers will be injected with the
    DI mechanism of Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Although the declaration of the dependencies of the `Tooltip` class looks exactly
    the same as what we did in the previous sections, there's neither any explicit
    configuration nor any instantiation of an injector. In this case, Angular internally
    creates and configures the so called **element injector**. We'll explain it a
    little bit later, but before that, lets take a look at how we can configure the
    DI mechanism using NgModules.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring DI with NgModules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already talked about NgModules in [Chapter 2](ch02.html "Chapter 2. The
    Building Blocks of an Angular Application"), *The Building Blocks of an Angular
    Application* and [Chapter 4](ch04.html "Chapter 4. Getting Started with Angular
    Components and Directives"), *Getting Started with Angular Components and Directives*.
    We mentioned that they help us to divide our application into logical parts; we
    also discussed how to use NgModules' imports and exports. In this section, we'll
    look at a brief overview of how we can use them to configure the providers of
    our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the providers declared in a given NgModule, Angular will instantiate
    an injector. This injector will manage all the providers that are listed in the
    `providers` property of the object literal we pass to the `@NgModule` decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we declare a single provider for the `Markdown` service.
    It will be available in all the components and directives listed in the `declarations`
    array because the injectors used by the top-level components will get the one
    configured through the NgModule as their parent injector.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s suppose that our module imports another module that has a declaration
    of providers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the example, we have two modules – the `AppModule` we previously saw and
    `ButtonModule`. In the snippet `AppModule` imports `ButtonModule`, which means
    that all the exports of `ButtonModule` will be available as declarations in `AppModule`.
    On top of that, the providers declared in `ButtonModule` will be merged with the
    providers of `AppModule`. Based on all these providers, Angular will instantiate an
    injector and set it as a parent injector to the injector used by the bootstrap
    component - `App`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's discuss the element injector that each component and directive has
    associated to it.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the element injectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Under the hood, Angular will create injectors for all the directives and components,
    and add a default set of providers to them. These are the so-called **element
    injectors** and are something the framework takes care of itself. The injectors
    associated with the components are called **host injectors**. One of the providers
    in each element injector is associated with the `ElementRef` token; it will return
    a reference to the host element of the directive. However, where is the provider
    for the `Overlay` class declared? Let''s take a look at the implementation of
    the top-level component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We configure the element injector for the `App` component by declaring the `providers`
    property inside the `@Component` decorator. At this point, the registered providers
    will be visible by the directive or the component associated with the corresponding
    element injector and the component's entire component subtree, unless they are overridden
    somewhere in the hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring providers for the element injectors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Having the declaration of all the providers in the same place might be quite
    inconvenient. For example, imagine we're developing a large-scale application
    that has hundreds of components depending on thousands of services. In this case,
    configuring all the providers in the root component is not a practical solution.
    There will be name collisions when two or more providers are associated with the
    same token. The configuration will be huge, and it will be hard to trace where
    the different dependencies need to be injected.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we mentioned, Angular''s `@Directive` (and `@Component`) decorator allows
    us to introduce directive-specific providers using the `providers` property. Here
    is how we can approach this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example overrides the provider for the `Overlay` token in the
    `Tooltip` directive's declaration. This way, Angular will inject an instance of
    `OverlayMock` instead of `Overlay` during the instantiation of the tooltip.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring DI with components
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since components are generally directives with views, everything we've seen
    so far regarding how the DI mechanism works with directives is valid for components
    as well. However, because of the extra features that the components provide, we're
    allowed to have further control over their providers.
  prefs: []
  type: TYPE_NORMAL
- en: As we said, the injector associated with each component will be marked as a
    **host** injector. There's a parameter decorator called `@Host`, which allows
    us to retrieve a given dependency from any injector until it reaches the closest
    host injector. This means that, using the `@Host` decorator in a directive, we
    can declare that we want to retrieve the given dependency from the current injector
    or any parent injector until we reach the injector of the closest parent component.
  prefs: []
  type: TYPE_NORMAL
- en: The `viewProviders` property added to the `@Component` decorator is in charge
    of achieving even more control.
  prefs: []
  type: TYPE_NORMAL
- en: viewProviders versus providers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example of a component called `MarkdownPanel`. This
    component will be used in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The content of each section of the panel will be translated from markdown to
    HTML. We can delegate this functionality to a service called `Markdown`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `Markdown` service wraps the `markdown` module in order to make it injectable
    through the DI mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's implement `MarkdownPanel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following snippet, we can find all the important details from the component''s
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `@Component` decorator, we use the `markdown-panel` selector and set
    the `viewProviders` property. In this case, there''s only a single view provider:
    the one for the `Markdown` service. By setting this property, we declare that
    all the providers declared in it will be accessible from the component itself
    and all of its **view children**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s suppose we have a component called `MarkdownButton` and we want
    to add it to our template in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Markdown` service will not be accessible by the `MarkdownButton` used
    below the `panel-content` element; however, it''ll be accessible if we use the
    button in the component''s template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: If we need the provider to be visible in all the content and view children,
    all we should do is change the name of the property `viewProviders` to `providers`.
  prefs: []
  type: TYPE_NORMAL
- en: You can find this example in the examples directory at `ch5/ts/directives/app.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that, for any component or directive, we can override an existing provider
    declared in a NgModule using the `providers` properties of the object literal
    we pass to the `@Component` or the `@Directive` decorators. If we want to override
    a specific provider only for the view children of a given component, we can use
    `viewProviders`.
  prefs: []
  type: TYPE_NORMAL
- en: Using Angular's DI with ES5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are already proficient in using the DI of Angular with TypeScript! As we
    know, we are not limited to TypeScript for the development of Angular applications;
    we can also use ES5, ES2015, and ES2016 (as well as Dart, but that is outside
    the scope of this book).
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we declared the dependencies of the different classes in their constructor
    using standard TypeScript type annotations. All such classes are supposed to be
    decorated with the `@Injectable` decorator. Unfortunately, some of the other languages
    supported by Angular miss a few of these features. In the following table, we
    can see that ES5 doesn''t support type annotations, classes, and decorators:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **ES5** | **ES2015** | **ES2016** |'
  prefs: []
  type: TYPE_TB
- en: '| **Classes** | No | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| **Decorators** | No | No | Yes (no parameter decorators) |'
  prefs: []
  type: TYPE_TB
- en: '| **Type annotations** | No | No | No |'
  prefs: []
  type: TYPE_TB
- en: How can we take advantage of the DI mechanism in these languages? Angular provides
    an internal JavaScript **domain-specific language** (**DSL**), which allows us
    to take advantage of the entire functionalities of the framework using ES5.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s translate the `MarkdownPanel` example we took a look at in the
    previous section from TypeScript to ES5\. First, let''s start with the `Markdown`
    service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We defined a variable called `Markdown` and set its value to the returned result
    from the invocation of `ng.core.Class`. This construct allows us to emulate ES2015
    classes using ES5\. The argument of the `ng.core.Class` method is an object literal,
    which must have the definition of a `constructor` function. As a result, `ng.core.Class`
    will return a JavaScript constructor function with the body of `constructor` from
    the object literal. All the other methods defined within the boundaries of the
    passed parameter will be added to the function's prototype.
  prefs: []
  type: TYPE_NORMAL
- en: 'One problem is solved: we can now emulate classes in ES5; there are two more
    problems left!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at how we can define the `MarkdownPanel` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: From [Chapter 4](ch04.html "Chapter 4. Getting Started with Angular Components
    and Directives"), *Getting Started with Angular Components and Directives*, we
    are already familiar with the ES5 syntax used to define components. Now, let's
    take a look at the constructor function of `MarkdownPanel`, in order to check how
    we can declare the dependencies of our components and classes in general.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the preceding snippet, we should notice that the value of the constructor
    is not a function this time, but an array instead. This might seem familiar to
    you from AngularJS, where we are able to declare the dependencies of the given
    service by listing their names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Although the new syntax looks similar, it brings some improvements. For instance,
    we're no longer limited to using strings for the dependencies' tokens.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s suppose we want to make the `Markdown` service an optional dependency.
    In this case, we can approach this by passing an array of decorators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This way, by nesting arrays, we can apply a sequence of decorators: `[[ng.core.Optional(),
    ng.core.Self(), Markdown], ...]`. In this example, the `@Optional` and `@Self`
    decorators will add the associated metadata to the class in the specified order.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although using ES5 makes our build simpler and allows us to skip the intermediate
    step of transpilation, which can be tempting, Google's recommendation is to take
    advantage of static typing using TypeScript. This way, we have a much clearer
    syntax, which carries better semantics with less typing and provides us with great
    tooling, including the straightforward process of AoT compilation (we'll explore
    the Angular's AoT in the final chapter of the book).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the DI mechanism of Angular. We briefly discussed
    the positives of using DI in our projects by introducing it in the context of
    the framework. The second step in our journey was how to instantiate and configure
    injectors; we also explained the injectors' hierarchy and the visibility of the
    registered providers. In order to enforce a better separation of concerns, we
    mentioned how we can inject services carrying the business logic of our application
    in our directives and components. The last point we took a look at was how we
    can use the DI mechanism with the ES5 syntax.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll introduce the new routing mechanism of the framework.
    We'll explain how we can configure the component-based router and add multiple
    views to our application. Another important topic we will cover is the new form
    module. By building a simple application, we will demonstrate how we can create
    and manage forms.
  prefs: []
  type: TYPE_NORMAL
