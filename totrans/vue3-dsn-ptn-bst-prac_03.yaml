- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setting Up a Working Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we laid the theoretical foundation for designing a
    web application in JavaScript using the *Vue 3 framework*. However, so far, we
    have not really gotten into a real project. That is what this chapter is about.
    We will use the new set of tools that comes along with Vue 3 to create a project
    from scratch and prepare a template that we will use in other projects. As is
    custom, this initial project for a web application is to build a *To-Do list*
    (the equivalent of *Hello World*). As we progress with the introduction of each
    new concept, we will over-engineer the application to turn it into something much
    more useful, or at the very least, more interesting to look upon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the practical skills we will learn here are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up your working environment and **integrated development** **environment**
    (**IDE**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the new command-line tools and the new **Vite** bundler to scaffold our
    application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying the basic template and folder structure to accommodate *best practices*
    and advanced architecture *design patterns*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating out-of-the-box **CSS frameworks** into our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the Vite bundler to accommodate our needs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unlike in previous chapters, this one will be mostly practical, and there will
    be references to the official documentation for each element of the ecosystem,
    as these change from time to time. You don’t need to memorize the steps, as starting
    up a project from scratch is not so common for large projects and the tools to
    scaffold them evolve. Let’s start.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow the practical steps in this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A computer running **Windows**, **Linux**, or **macOS** with a 64-bit architecture.
    I will be using **Ubuntu 22.04**, but these tools are cross-platform, and the
    steps translate between OSs (when something is different, I will point it out).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Node.js 16.16.0 LTS** with **npm** (**node package manager**) installed.
    You can find the steps to install Node.js in the official documentation, at [https://nodejs.org/](https://nodejs.org/).
    The building tools work on top of Node.js, so without this, you can’t go very
    far. Node.js is a JavaScript version adapted to run on servers and in systems
    “outside” the browser, something that makes it very, very handy and powerful.
    Most of today’s bundlers for web development use Node.js in one way or another,
    if not at least for the great convenience it provides.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Volar` plugin. The official site is [https://code.visualstudio.com/](https://code.visualstudio.com/),
    and in this book, we will be using this editor as the recommended IDE to work
    with Vue and Vite.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sublime Text** (free trial/paid): This is another popular option, especially
    among macOS users. The official site is [https://www.sublimetext.com/](https://www.sublimetext.com/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Jetbrains WebStorm** (free trial, paid): The official site is [https://www.jetbrains.com/webstorm/](https://www.jetbrains.com/webstorm/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Komodo IDE** (free): The official site is [https://www.activestate.com/products/komodo-ide/](https://www.activestate.com/products/komodo-ide/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NetBeans IDE** (free): The official site is [https://netbeans.apache.org/](https://netbeans.apache.org/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **console** or **terminal emulator**. Users of Linux and macOS will be most
    familiar with this concept. Windows users can use **Command Prompt**, an integrated
    terminal on some IDEs, or install a **Windows Terminal** from the Microsoft Store.*   A
    modern web browser, either based on the Chromium engine (Google Chrome, Microsoft
    Edge, Opera, Brave, Vivaldi, etc.) or Mozilla Firefox.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these installed, we are ready to follow the examples and basic projects.
    However, I would recommend that you also install **Git**, for code versioning
    control. We will use it later in this book, in [*Chapter 9*](B18602_09.xhtml#_idTextAnchor199),
    *Testing and Source Control*. In modern development, it is hard to imagine working
    on a project without some tool to keep track of code changes and version control.
    Git has become the industry standard. You can install it following the documentation
    from the official website at [https://git-scm.com/](https://git-scm.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found on GitHub here: [https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter03](https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter03).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://packt.link/CmuO9](https://packt.link/CmuO9)'
  prefs: []
  type: TYPE_NORMAL
- en: Now, with our tools in place, we are ready to start our first project in Vue
    3.
  prefs: []
  type: TYPE_NORMAL
- en: Project setup and tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create a new project using **Vite** as our bundler, directly from the
    command line. Open a terminal window in the directory where you will place our
    project, and follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$ npm create vite@latest`'
  prefs: []
  type: TYPE_NORMAL
- en: If you get a prompt to install additional packages, type `Y` (yes).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, you will be prompted to enter project information in the following order:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`.`) as the name.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`chapter-3` (or any name of your choosing). This option may not show if you
    entered or accepted a project name or accepted the default name suggested. If
    you entered a period (`.`) as the name to create the project in the current directory,
    then this option will be mandatory.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`vue` with the arrow keys and press *Enter*.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Select variant:** Just like before, use the arrow keys and select JavaScript
    (or TypeScript, but we will use plain JavaScript throughout this book).'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, you will see how the assistant downloads additional content based on
    your selections and scaffolds the project. It will create a directory structure
    with multiple files. However, if we intend to run the project, we soon will discover
    that it just doesn’t work. That is because the scaffolding does not install dependencies,
    only the skeleton. So, there is still one more step to do, and that is to install
    the dependencies using `npm`. In the terminal, enter the following command and
    hit *Enter* (if you installed in the current directory; if not, first enter the
    directory just created):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The package manager will download and install the dependencies for our project
    and place them in a new directory named `node_modules`. As you can guess already,
    our development environment for **Vue** with **Vite** is a **Node.js** project.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the dependencies in place, now is the time to run the project and see
    what the scaffolding tool prepared for us. In the terminal, enter the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'What happens next may be quite fast. Vite will parse your project files and
    launch a developer server on your machine with a web address that you can use
    in your browser. You will see something like this in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 - The result of running the development server with Vite](img/Figure_3.01_B18602.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 - The result of running the development server with Vite
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important information here is `localhost` and the port where your
    project website is being served. The milliseconds shown there are just to let
    you know how fast Vite is to get you up and running (bragging rights, if you ask
    me). Next, to see the results of our labor so far, open the **local address**
    in your web browser, and you should be welcomed by a website looking something
    like the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 3.2: Basic Vite + Vue project in the browser](img/Figure_3.02_B18602.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: Basic Vite + Vue project in the browser'
  prefs: []
  type: TYPE_NORMAL
- en: This website is fully functional as it is, if not very productive. To test that
    Vue 3 is working, click the button in the middle of the screen and you’ll see
    how the counter increases with each click. This is reactivity in action! Moreover,
    Vite offers us a development server with live updates and **Hot Module Replacement**
    (**HMR**), which means that as soon as we make changes in our code and save the
    files, the website will update automatically. In practice, it is very common when
    developing user interfaces to keep this self-updating site open in the browser
    to preview our work, and in some cases, several browsers at the same time. Very
    neat!
  prefs: []
  type: TYPE_NORMAL
- en: We have advanced in our journey, but we are far from over. The scaffolded site
    is nothing more than a starting point. We will modify it to better serve our purposes
    and will create a simple To-Do application in the rest of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will take a closer look at the structure and organization
    of our starting project.
  prefs: []
  type: TYPE_NORMAL
- en: Folder structure and modifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [*Chapter 1*](B18602_01.xhtml#_idTextAnchor017), *The Vue 3 Framework*,
    we mentioned that frameworks prescribe some structure for your application. Vue
    3 is not an exception, but the conventions used in the directory structure are
    minimal when compared to other frameworks. If you open the directory where you
    installed the project in the Files Explorer (either from your OS or in your IDE),
    you will find a structure like this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3: Project structure in Visual Code](img/Figure_3.03_B18602.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3: Project structure in Visual Code'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `.vscode` folder was created by the IDE, and `node_modules` was created
    by `npm` to allocate the dependencies. We will ignore them, as we don’t need to
    worry or work with them. Starting from the top, let’s review what each directory
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This folder contains a directory structure and files that will not be processed
    by the bundler and will be copied directly into the final website. You can freely
    place your own static content here. This is where you will place your images,
    web fonts, third-party CSS libraries, icons, and so on. As a general rule, files
    here are those that will never be referenced by your code, such as `manifest.json`,
    `favicon.ico`, `robots.txt` and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '`src`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is where we will place our JavaScript, dynamic CSS, components, and so
    on. If we expand this folder, we will find that the scaffolding tool has already
    created a minimal structure with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An `assets` folder with an SVG file. In this folder, we can include files that
    will be manipulated either by the code or by the bundler. You can import them
    directly into your code, and the bundler will take care of mapping them properly
    when serving them on a web server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `components` folder, where we will place our `.vue` extension. We can create
    the directory structure here as we please. The scaffolding tool has been placed
    inside a `HelloWorld.vue` component for us.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `App.vue` file. This is the main component of our application and the root
    component of our hierarchy. It is a convention to call it this way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `main.js` file, which is the starting point of our application. It is in charge
    of loading the initial dependencies, the main component (`App.vue`), creating
    the Vue 3 application with all extras (plugins, global directives, and components),
    and launching and mounting the application to the web page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `styles.css` file, which is a global stylesheet that will apply to our entire
    application. Previous versions of the scaffolding tool used to place it in the
    `assets` folder, but now it has moved to the `src/` root giving it a more predominant
    place. This file, when imported into the `main.js` file, will be parsed and bundled
    with our JavaScript.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is now time to investigate the files in the project root, in the same order
    as they appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.gitignore` is a file that controls what is excluded from the Git source control.
    We will see Git in [*Chapter 9*](B18602_09.xhtml#_idTextAnchor199), *Testing and*
    *Source Control*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index.html` is the main file and the starting point for our web application.
    The bundler will start accessing and processing other files in the order they
    appear, starting with `index.html`. You can modify it to fit your needs, as the
    generated file is quite basic. Notice how towards the end of the `body` tag, the
    scaffolding tool included a `script` tag to load our `main.js` file. This file
    is the one that creates our Vue application. Unlike other bundlers that automatically
    generate this file and then inject it into `index.html`, Vite requires that you
    have this imported explicitly. Among other advantages, this gives you control
    of when the Vue application will be loaded inside your web page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`package-lock.json` is used by `npm` to manage the dependencies in `node_modules`.
    Ignore it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`package.json` is very important. This file defines the project, keeps track
    of your development and production dependencies, and provides some nice features
    such as the automation of some tasks by simple commands. Of interest at this time
    is the `scripts` section, which defines simple aliases for commands. We can run
    these from the command line by typing `npm run <script name>`. The scaffolding
    tool already prepared three Vite commands for us:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`npm run dev`: This will launch the website in developer mode, with a local
    server and live reload.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`npm run build`: This will bundle our code and optimize it to create a production-ready
    version.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`npm run preview`: This is a middle point between the previous two. It will
    allow you to see locally the built production-ready version. This may sound confusing
    until you consider that while in development, the addresses and resources that
    your application access, as well as the public URL, may be different than those
    in production. This option lets you run the application locally, but still reference
    and use those production endpoints and resources. It is a good practice to run
    a “preview” before you deploy your application.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vite.config.js` is the configuration file that governs how Vite will behave
    during development and when bundling for production. We will see some of the most
    important or common options later in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have a clearer view of what was given to us by the Vite scaffolding
    tool, it is time to start building our sample application. Before we dig deep
    into the code, there are a couple more items we need to address: how to integrate
    third-party stylesheets and CSS frameworks, and some Vite configurations that
    will make our life easier.'
  prefs: []
  type: TYPE_NORMAL
- en: Integration with CSS frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we remember the last three principles discussed in [*Chapter 2*](B18602_02.xhtml#_idTextAnchor040),
    *Software Design Principles and Patterns*, (*don’t repeat yourself*, *keep it
    clean*, and *code for the next*), reinventing the wheel in matters of visual appearance
    and graphic language is something not desirable in most cases. The web has an
    ever-growing collection of CSS frameworks and libraries that we can easily incorporate
    into our applications. From the old popular Bootstrap to atomic design, to utility
    classes such as Tailwind, and passing by graphics languages such as Material Design
    and skeuomorphism, the spectrum of options is huge. Vue has a good number of component
    libraries already implementing some of these libraries, which you can find in
    the `npm` repositories. Using these, you’ll be restricted to learning about and
    applying the conventions applied by the designer, which, in some cases, may set
    in stone how you can build your user interface. Typical examples of these are
    the use of **Vue-material** (and others) that adheres to Google’s Material Design
    specifications or the incorporation of web fonts and icon fonts. It is impossible
    to discuss each one, but here are guidelines and some examples of how to incorporate
    these libraries into your project:'
  prefs: []
  type: TYPE_NORMAL
- en: Place the static assets provided by the framework or library in the `public`
    folder, following their required structure, and respecting whatever tree structure
    is needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Include the dependencies for the CSS framework or libraries in your `index.html`
    file, following their instructions. Often, this will imply importing stylesheets
    and JavaScript files in the `head` section or the `body` tag. In either case,
    make sure these are placed before the loading of our application (the `script`
    tag that references our `main.js` file).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the framework or library needs to be instantiated, do so before we mount
    our application. You can do this directly in `index.html` in a `script` tag, in
    `main.js`, or in another module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the classes (and JavaScript functions) in your component’s template section
    normally, as you would in plain HTML using these libraries. Some frameworks create
    JavaScript global objects attached to the `window` object, so you can access them
    directly in your component’s `script` section. If this is not the case, consider
    encapsulating the functionality to use it in your application, using a design
    pattern such as a *singleton*, *proxy*, or *decorator* patterns.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now let’s put these simple instructions to work by applying them to our example
    project. We will incorporate a CSS-only framework (meaning that it doesn’t use
    additional JavaScript), and font icons to include basic iconography. In a production
    build, we should remove unused CSS rules. Some CSS frameworks provide this feature
    out of the box, such as Tailwind ([https://tailwindcss.com/](https://tailwindcss.com/)).
    However, this topic is beyond the scope of this book but is worth researching
    online.
  prefs: []
  type: TYPE_NORMAL
- en: The w3.css framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The website [w3school.com](http://w3school.com) offers a free CSS-only framework
    that is partially based on the Material Design language, made popular by Google,
    and used in many mobile applications. It offers many utility classes that you
    can implement, license-free, in your applications. You can find out more on the
    official website: [https://www.w3schools.com/w3css/](https://www.w3schools.com/w3css/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will follow the guidelines mentioned before, so let’s follow the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the `w3.css` file from [https://www.w3schools.com/w3css/w3css_downloads.asp](https://www.w3schools.com/w3css/w3css_downloads.asp)
    and place it in a new folder named `css` in the `public` directory. When you are
    done, it should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.4 - Location for the w3.css file](img/Figure_3.04_B18602.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 - Location for the w3.css file
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify `index.html` at the root of our project by adding the reference to the
    `w3.css` file using a `link` tag like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With that inclusion, the classes defined in the CSS file are now ready to be
    used in our component’s templates. Also, to avoid unwelcome styles from the scaffolding
    of a project, remember to clear the `styles.css` file provided by the installer.
    If we now run the development server with `npm run dev`, we will see that the
    appearance of the website has changed slightly, as the new stylesheet has been
    successfully applied. The next step now is to add an *icon font*.
  prefs: []
  type: TYPE_NORMAL
- en: FontAwesome is just awesome
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the ways that developers save resources when dealing with a multitude
    of icons is with the use of **font icons**. These are font files that, instead
    of characters, display icons. This concept is not new, but it has a lot of applications
    in web development. Using fonts for icons, as opposed to other techniques (such
    as CSS sprite sheets, for example) has plenty of benefits. One of the most relevant
    is that these icons are subject to the same manipulation as regular fonts, so
    we can easily alter their size, color, and so on, and keep them in coordination
    with the rest of the text. Not all is joy and happiness with this approach, since
    now, the major trade-off is that these icons display only one or two colors at
    most and have to be rather simple by necessity.
  prefs: []
  type: TYPE_NORMAL
- en: '**FontAwesome** is a website that offers **icon fonts** to use in our applications,
    both web and desktop. It has been doing this for years and has some of the best
    icon collections out there. We can download and use its free tier for our project.
    Let’s follow again the guidelines to implement them in our project:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the fonts *for the web* from [https://fontawesome.com/download](https://fontawesome.com/download).
    It will download a rather large ZIP file with all the different alternatives.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From within the ZIP file, copy the `css/` and `webfonts/` directories as they
    are, to our `public/` folder. We will not use everything in this folder in our
    projects here, so you can delete what we don’t use later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the `index.html` file to add the stylesheets that we will use. These CSS
    files will automatically load the icon fonts from the `/``webfonts/` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And that is all we need to do to include FontAwesome in our project. There
    are other alternatives that have encapsulated the fonts into Vue components, and
    even the website provides a Vue implementation. However, for our purposes in this
    book, we will use the *direct* approach. If we open the icons section of the site,
    we can browse and search all the available icons. You can restrict the search
    to “solid” and “brands” since those are the ones we have included in our project.
    For example, if you want to display the Vue icon using FontAwesome, we can include
    the following in our template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'These classes make all the magic happen in any empty element, but for tradition
    and convenience, we always use the `i` tag. Moreover, you do not even need to
    type them. Once you locate the icon you want to use, the website offers this neat
    feature to “click and copy” the code. The previous line came from here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 3.5 - FontAwesome icon page](img/Figure_3.05_B18602.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 - FontAwesome icon page
  prefs: []
  type: TYPE_NORMAL
- en: Let’s keep in mind that including a large library of icons when only using a
    few of them will impact performance. For production builds, ensure that you only
    include the icons you will use in your application by creating icon fonts only
    with the necessary icons. For the purposes of our book and during development,
    we can skip this practice.
  prefs: []
  type: TYPE_NORMAL
- en: With a nice stylesheet and some good icon fonts, we are almost ready to start
    our coding. There is just one more thing to do and it is to include a few extra
    options in our Vite configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Vite configuration options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `vite.config.js` file exports the configuration that Vite will use for development
    and also for production. Vite was meant to be functional for many different frameworks
    and not only for Vue 3, even though it is the official bundler for it. When we
    open the file, we notice that Vue is a plugin for Vite. Internally, Vite uses
    **Rollup.js** ([https://www.rollupjs.org/](https://www.rollupjs.org/)) and **esbuild**
    ([https://esbuild.github.io/](https://esbuild.github.io/)), for development and
    production build, respectively. This means that we can pass options to Vite, but
    also have even more fine-grained control over some edge cases by passing arguments
    to these two underlining tools. Additionally, you can pass different configurations
    for each processing mode (development and production), so we are not left without
    options here.
  prefs: []
  type: TYPE_NORMAL
- en: We will see some specific configurations for deployment in [*Chapter 10*](B18602_10.xhtml#_idTextAnchor224),
    *Deploying Your Application*, but for now, we will focus only on the development
    part with a few additions to keep us from typing too much and repeating ourselves
    in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `vite.config.js` file and add the following import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Yes, the path import is not JavaScript, but Node.js, and we can do this because
    this file is read and executed in a Node.js context. It will never reach the browser
    or any JavaScriptcontext.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the export configuration so it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In these lines, we are indicating an alias named `@components` matched to the
    project path `/src/components`. This way, when we are importing components, we
    can avoid writing relative or full paths, and just reference the imports inside
    components in this manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Having aliases for paths is a nice feature to have for a developer experience.
    Paths to components can get quite long in a large project, and code reorganization
    does happen from time to time, making maintenance yet another point of possible
    disruption. Having an alias defined gives us more flexibility by making changes
    only in one place (*principle: Don’t* *repeat yourself*).'
  prefs: []
  type: TYPE_NORMAL
- en: You can find a complete reference of the Vite configuration file at [https://vitejs.dev/config.](https://vitejs.dev/config)
    Vite offers a short list of official plugins (such as for Vue) at https://vitejs.dev/plugins/,
    but the community has provided a fair share of plugins to cover many scenarios
    at https://github.com/vitejs/awesome-vite#plugins. These can be installed and
    imported into our configuration file when and if needed.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have enough preparation done so we can move ahead and finally
    create our simple To-Do app.
  prefs: []
  type: TYPE_NORMAL
- en: The To-Do app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our example application will build on the scaffolding files of a basic application.
    It will provide us with an input element to enter our to-do items and will display
    the list of tasks pending and completed. The purpose of this exercise is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Develop the application with live updates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a component, with reactive elements in the `script` `setup` syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply styles and icon fonts from third-party libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we are done, we will have a simple website that should look like this
    (the to-do items have been added as an example):'
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 3.6 - The final result of our To-Do List application with styles
    applied](img/Figure_3.06_B18602.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 - The final result of our To-Do List application with styles applied
  prefs: []
  type: TYPE_NORMAL
- en: For the purpose of this exercise, we will develop the entire To-Do application
    in one single component, which we will import into our `main` component (`App.vue`).
    This, of course, is purposely breaking some of the principles that we saw in [*Chapter
    2*](B18602_02.xhtml#_idTextAnchor040), *Software Design Principles and Design
    Patterns*. In [*Chapter 4*](B18602_04.xhtml#_idTextAnchor102), *User Interface
    Composition with Components*, we will take this product and “make it right” with
    multiple components.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the application, the user will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Type a short description and press the *Enter* key or click the plus sign to
    enter it as a task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The system will display the pending and completed tasks in separate lists, displaying
    how many are in each group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user can click on any task to mark if it has been done or undone, and the
    application will move it to the corresponding group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Knowing how the application has to work, let’s move onto the code.
  prefs: []
  type: TYPE_NORMAL
- en: App.vue
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is our main component. In the starter application, we need to remove the
    content from each section and change it to the following (we’ll explain next what
    each part does):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `script` section, we only need to import a component named `ToDos` (we
    will create this file next). Notice how we are using already an alias for the
    path (`@components`). Our main component will not handle any other data or functionality,
    and we are using it only as a wrapper to control the layout of this application.
    With that in mind, our template now will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We declare a `div` element with a private class (`.app`) that we will define
    in the `style` section. We also applied one of the styles we imported from `W3.css`
    to give our application a background color. Inside our `div` element, we place
    our `ToDos` component. Notice that we are using the same name as imported into
    our `script` section in Pascal case. We can use this notation, or the HTML kebab-case
    equivalent, `<to-dos />`, (lowercase words separated by hyphens). However, the
    recommendation is to always use Pascal case in our templates, with multiple words,
    to avoid conflicts with HTML components, present or future. This name will be
    transformed into kebab case in the final HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will define the style, using the CSS `flex` layout to center our component
    in the center of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: With our main component in place, now let’s create our `ToDos` component in
    the `/src/components` directory, properly named `ToDos.vue`.
  prefs: []
  type: TYPE_NORMAL
- en: ToDos.vue
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this component, we will place all the logic of this simple application.
    We will need the following reactive variables:'
  prefs: []
  type: TYPE_NORMAL
- en: A variable to capture the text from the input, and create our task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An array where we will host our task objects with the following fields: a unique
    ID, a description, and a Boolean value to indicate whether it is complete or not'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A filtering function or computed property (or properties) to display only the
    tasks that are completed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With the preceding requirements, let’s populate our `script` section with the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by importing the `ref` and `computed` constructors from Vue in line
    `//1`, since this is all that we will need in this application from the framework.
    In line `//2`, we start declaring two constants to point to reactive values: `_todo_text`,
    which will host our user’s task description in the input element, and `_todo_list`,
    which will be the array of tasks (to-do items). In lines `//3` and `//4`, we declare
    two `computed` properties named `_pending` and `_done`. The first one will have
    a reactive array of all the to-do items that are incomplete, and the second one
    all those marked as completed. Notice that by using a `computed` property, we
    only need to keep a single array with all the items. Computed properties are used
    to get a view segment of the list according to our needs. This is a commonly used
    pattern for these kinds of circumstances as opposed to, for example, having two
    arrays for each group and moving items between them.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have a helper function in line `//5`, to reset the value of our
    item text, and in line `//6`, we have a simple function that checks the value
    of the description and creates a task (to-do item) to add to our list. It is important
    to note that the moment we modify `_task_list`, all the properties and variables
    that depend on it will be automatically re-evaluated. Such is the case with the
    `computed` properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is all that we will need in our component’s logic to achieve the results
    we want. Now, it is time to create the template with HTML. We will split the code
    into sections for convenience. The segments that appear highlighted mark those
    with bindings or interactions with the framework and our code in the `script`
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The template of our component starts in line `//1` by defining a wrapper element
    with some styles. Then, in line `//2`, we place a simple header with styles and
    an icon font. Notice how we are using CSS classes from the **W3 CSS framework**,
    at the same time as our own scoped styles. The next lines in the code will focus
    on capturing the user input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The interactivity with the user starts in the section in line `//3`, where
    we define an input element and attach our `_todo_text` reactive variable with
    the `v-model` directive. From this time on, anything that the user types into
    our input box will be the value of our variable in the code. Just for convenience,
    we are also capturing the *Enter* key with the following attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This will trigger the `addToDo` function from our script. We will add the same
    in the plus button next to the input field, also on the `click` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us two ways to enter our descriptions as tasks for our to-do list,
    using multiple events linked to the same function. The following code now focuses
    on displaying the input data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To display our task list, we have two almost identical blocks of code, starting
    on lines `//4` and `//5` – one for the pending tasks and the other for the completed
    ones. We will only focus on the first block (starting on line `//4`) since the
    behavior of these blocks is almost the same. In the first `div` element, we create
    a small header that displays the number of items on the `_pending` array, by interpolating
    its length. We do this with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we can access the array attributes directly inside the double curly
    brackets, without the use of the `.value` attribute. While in our JavaScript code,
    we should write this as `_pending.value.length`, when we are using interpolation
    in our HTML, Vue is smart enough to identify the reactive variable in our `template`
    section and access the value directly. This is true for `computed` properties
    as well as reactive variables created with `ref()`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next `div` element, we create a list with a `v-for/:key` directive that
    will iterate over our `_pending` array and create a copy of the element for each
    item. Inside each one, we can now reference each item with the name `todo`, which
    we declared in the `v-for` directive. Next, we wrap an `input` checkbox and a
    span inside a `label` element and bind the `todo.checked` property (Boolean) to
    the input with `v-model`. Vue will take care of assigning a `true` or `false`
    value depending on the state of the checkbox. When that happens, it will also
    trigger the recalculation of the `computed` properties and we will see how just
    by checking/unchecking an item, it moves between groups (pending and completed)
    and also updates the total number of each block. We also have a `span` element
    to display the text of the task.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, for the cases when a list group is empty, we also have a `div` element
    that will be visible only when that list is empty in line `//``6` (`_pending.length==0`).
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned before, the part that displays our “done” list works in the same
    way, applying the same logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our scoped styles will be quite small in this case, as we only need a couple
    of extra settings since most of the heavy lifting has been done using the `w3.css`
    library. Inside our `style` section, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `todo-container` class limits the maximum and minimum width of our component,
    and we also modify the `label` element to display its children using the `flex`
    layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the application in action, save all the changes and start the Vite development
    server with the following command in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Once Vite is ready, open the address in the web browser just as we did before.
    If all is well, you should see our To-Do list working as expected. If not, check
    with the source code in the repository to make sure that your typed code matches
    the full example.
  prefs: []
  type: TYPE_NORMAL
- en: A quick critique of our To-Do application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The application we just made is working and is a bit more advanced than a simple
    `Hello World` or a counter button. However, we have not applied all the best practices
    and patterns that we should or could. This is done on purpose, as a learning exercise.
    Sometimes, to know how to build something right, we first need to build it to
    work as is. In general, all engineering practices understand that there is an
    iterative refinement process that provides learning and sophistication with each
    interaction. Once we build our first prototype, it is time to take a step back
    and do a sincere critique of it, thinking about how we can improve it and do things
    better. In this case, here is our critique:'
  prefs: []
  type: TYPE_NORMAL
- en: We have duplication of code in our template, as the `_pending` and `_done` computed
    properties are basically the same, with a minor difference based on the value
    of a variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are not leveraging the power of components, as everything is built in a single
    component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our component is also creating our models (the To-Do items), so our business
    logic is tied to our component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have done very little in terms of input sanitization and control. It is foreseeable
    that some code, even equal inputs, will break our application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our to-do list is volatile. A refresh of the page will wipe clean our list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our task only accommodates two states (done and pending). What if we want to
    have a third state or more? For example, in progress, waiting, or next in line?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current design does not provide a way to edit or delete a task once it has
    been created.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can only manage one list of items at a time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we move forward, we will improve our application and apply principles and
    patterns to make this a more resilient and useful application. In the next chapter,
    we will look at how to compose a web application with web components in a more
    approachable way.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have started to create applications using real-life tools,
    from IDEs to command-line tools, to scaffold, preview, and build our application.
    We have also created a simple To-Do application and learned how we can integrate
    third-party CSS libraries and icon fonts into our application and defined some
    general guidelines to incorporate others. We also took a critical approach to
    our simple application as a step to improve its functionality and, at the same
    time, our skills. In the next chapter, we will look into how to better organize
    our code and create a component hierarchy to create our user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Review questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the requirements to develop a Vue 3 application with Vite?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is it possible to integrate third-party libraries and frameworks with Vue 3?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are some steps to integrate a CSS-only library with a Vue application?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is creating an application inside a single component a good idea? Why yes or
    no? Can you think of scenarios when a single-component application is the right
    fit? How about a scenario when it is not?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why is software development an iterative refinement process?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
