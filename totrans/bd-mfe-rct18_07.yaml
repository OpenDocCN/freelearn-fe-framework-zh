- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Implementing the Micro-Apps Pattern for Microfrontends
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现微前端模式的微应用
- en: In the previous chapter, we saw the multi-SPA pattern for building microfrontends,
    which is ideal for building large-scale applications where each SPA contains its
    own user journey.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了构建微前端的多种SPA模式，这对于构建每个SPA都包含其自身用户旅程的大型应用来说是非常理想的。
- en: The primary advantage of this pattern is that each app is completely independent
    of the others, and they are connected via a namespaced primary route that is external
    to the app. As a user, while navigating through the app, you will have also noticed
    that when you move from one SPA to another, you are redirected via the browser
    and the page reloads. If this is something you’d like to avoid, and if you want
    a consistent SPA experience, then we can explore the micro-apps-pattern that uses
    Module Federation.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '这种模式的优点是每个应用都完全独立于其他应用，并且它们通过一个外部于应用的名字空间主路由连接。作为用户，在浏览应用时，您也会注意到，当您从一个SPA切换到另一个SPA时，您会通过浏览器重定向，并且页面会重新加载。如果您想避免这种情况，并且希望获得一致的SPA体验，那么我们可以探索使用模块联邦的微应用模式。 '
- en: 'In this chapter, we will go about building a micro-apps microfrontend, where
    we will learn about the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个微应用微前端，我们将学习以下内容：
- en: What is Module Federation, and why is it a key to building microfrontends?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块联邦是什么，为什么它是构建微前端的关键？
- en: Setting up a microfrontend app with host and remote apps
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置带有主机和远程应用的微前端应用
- en: Breaking down the app into smaller micro apps that are loaded via Module Federation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将应用拆分成更小的微应用，并通过模块联邦加载
- en: Setting up routing between the different pages
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置不同页面之间的路由
- en: Sharing state between the different micro apps
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同的微应用之间共享状态
- en: By the end of this chapter, we will have converted our multi-SPA microfrontend
    into a micro-apps microfrontend using Module Federation. In doing so, we will
    have also learned about Zustand, an easy-to-use state management library.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将使用模块联邦将我们的多SPA微前端转换为微应用微前端。在这个过程中，我们还将了解Zustand，这是一个易于使用的状态管理库。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'As we go through the code examples in this chapter, we will need the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们浏览本章的代码示例时，我们需要以下条件：
- en: A PC, Mac, or Linux desktop or laptop with at least 8 GB of RAM (16 GB preferred)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少8 GB RAM的PC、Mac或Linux桌面或笔记本电脑（16 GB更佳）
- en: An Intel chipset i5+ or a Mac M1 + chipset
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 英特尔芯片组i5+或Mac M1+芯片组
- en: At least 256 GB of free hard disk storage
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少256 GB的空闲硬盘存储空间
- en: 'You will also need the following software installed on your computer:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要在您的计算机上安装以下软件：
- en: Node.js version 18+ (use **nvm** to manage different versions of Node.js if
    you have to)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js版本18+（如果需要管理不同版本的Node.js，请使用**nvm**）
- en: 'Terminal: iTerm2 with OhMyZsh (you will thank me later)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终端：iTerm2配合OhMyZsh（你以后会感谢我的）
- en: 'IDE: We strongly recommend VS Code as we will be making use of some of the
    plugins that come with it for an improved developer experience'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IDE：我们强烈推荐使用VS Code，因为我们将会利用它自带的一些插件来提升开发体验
- en: NPM, Yarn, or PNPM. We recommend PNPM because it’s fast and storage-efficient
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NPM、Yarn或PNPM。我们推荐PNPM，因为它速度快且存储效率高
- en: 'Browser: Chrome, Microsoft Edge, or Firefox'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器：Chrome、Microsoft Edge或Firefox
- en: A basic understanding of Nx.dev monorepos and a basic understanding of using
    the NX console plugin in VS Code
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对Nx.dev单仓库有基本理解，以及使用VS Code中的NX控制台插件的基本技能
- en: Working knowledge of React
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对React有实际操作经验
- en: 'The code files for this chapter can be found here: [https://github.com/PacktPublishing/Building-Micro-Frontends-with-React](https://github.com/PacktPublishing/Building-Micro-Frontends-with-React).'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在以下位置找到：[https://github.com/PacktPublishing/Building-Micro-Frontends-with-React](https://github.com/PacktPublishing/Building-Micro-Frontends-with-React)。
- en: We also assume you have a basic working knowledge of Git, including branching,
    committing code, and raising a pull request.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还假设您对Git有基本的操作知识，包括分支、提交代码和发起拉取请求。
- en: Why do we need Module Federation for Microfrontends?
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么微前端需要模块联邦？
- en: In the multi-SPA approach to microfrontends, you may have noticed that we end
    up duplicating some of the common dependencies across the different micro apps.
    In the grand scheme of things, when the primary goal is to keep things simple,
    this would be an acceptable trade-off. However, when the number of dependencies
    being duplicated and the number of apps being built are high, you need to optimize
    things and minimize duplication. Trying to achieve this before Webpack 5 would
    have led to having to deal with complex dependency management. It would also have
    made it difficult to maintain and evolve microfrontend applications. Module Federation
    helps us solve these challenges.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在多SPA方法构建微前端时，你可能已经注意到我们在不同的微应用之间重复了一些公共依赖项。从大局来看，当主要目标是保持简单时，这可以是一个可接受的权衡。然而，当重复的依赖项数量和构建的应用程序数量很高时，你需要优化事情并最小化重复。在Webpack
    5之前尝试实现这一点会导致不得不处理复杂的依赖项管理。这也会使维护和演进微前端应用程序变得困难。模块联邦帮助我们解决这些挑战。
- en: In the next sections, we will learn more about what Module Federation is and
    how it helps with building microfrontends.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将了解模块联邦是什么以及它是如何帮助构建微前端的。
- en: What is Module Federation?
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是模块联邦？
- en: '**Module Federation** is a new feature introduced in Webpack 5 that allows
    us to load external JS bundles in real time.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**模块联邦**是Webpack 5中引入的一个新特性，它允许我们在实时中加载外部JS包。'
- en: Before Module Federation, the standard way to import all the necessary modules
    for an application was only during build time, where it created a large JS bundle
    or smaller chunks that got loaded based on page routes, but it wasn’t quite possible
    to dynamically load an app bundle in real time.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块联邦之前，导入应用程序所需的所有必要模块的标准方式仅限于构建时，此时它创建了一个大JS包或基于页面路由加载的小块，但无法实时动态加载应用程序包。
- en: Module Federation provides us with a radically new way to architect our apps,
    build and deploy shared components, and update them without the need to rebuild
    the entire application.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 模块联邦为我们提供了一种彻底新的方式来构建我们的应用程序，构建和部署共享组件，并在无需重新构建整个应用程序的情况下更新它们。
- en: Traditionally, we build most of our shared components, such as UI component
    libraries or `npm` modules, and import them into our application during build
    time. With Module Federation, these modules can be hosted at an independent URL
    and imported into the application at runtime. We take advantage of this very same
    feature to build our microfrontend architecture, where we have our micro apps
    independently hosted and loaded into the host or shell app in real time.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，我们构建大部分共享组件，例如UI组件库或`npm`模块，并在构建时将它们导入到我们的应用程序中。使用模块联邦，这些模块可以托管在独立的URL上，并在运行时导入到应用程序中。我们利用这一相同的功能来构建我们的微前端架构，其中我们的微应用独立托管，并实时加载到宿主或壳应用程序中。
- en: Before we get into how to go about doing it, let us look at some basic terminology
    associated with Module Federation. Module Federation revolves around a few concepts.
    Here are some of them.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解如何进行之前，让我们看看与模块联邦相关的一些基本术语。模块联邦围绕几个概念。以下是一些：
- en: ModuleFederationPlugin
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ModuleFederationPlugin
- en: All of Module Federation’s features are made available in Webpack 5+ via the
    `ModuleFederationPlugin` plugin. This is where you define the settings of how
    Module Federation should work.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 所有模块联邦的功能都通过`ModuleFederationPlugin`插件在Webpack 5+中提供。这是你定义模块联邦应该如何工作的设置的地方。
- en: This plugin allows a build to provide or consume modules during **runtime**
    with other independent builds.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此插件允许在**运行时**与其他独立构建提供或消费模块。
- en: 'You can read in detail about `ModuleFederationPlugin` and its specs here: [https://webpack.js.org/plugins/module-federation-plugin/](https://webpack.js.org/plugins/module-federation-plugin/).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处详细了解`ModuleFederationPlugin`及其规范：[https://webpack.js.org/plugins/module-federation-plugin/](https://webpack.js.org/plugins/module-federation-plugin/)。
- en: 'In its simplest form, the code for `ModuleFederationPlugin` should look like
    this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最简单的形式中，`ModuleFederationPlugin`的代码应如下所示：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code is the skeleton that holds all the configurations required
    to enable Module Federation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是包含启用模块联邦所需所有配置的骨架。
- en: Host apps
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 宿主应用程序
- en: This is the root application within which *remote* or external apps are loaded.
    The host app’s Module Federation configuration stores the list of remote apps
    that need to load within it. In our use cases of microfrontends, the host app
    also contains information about the different routes and the mapping of the routes
    to the respective remote apps.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是根应用，其中加载了*远程*或外部应用。主机应用的模块联邦配置存储了需要在其内部加载的远程应用列表。在我们的微前端用例中，主机应用还包含有关不同路由及其与相应远程应用映射的信息。
- en: 'Webpack’s configuration for Module Federation in the host app should look like
    this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 主应用中Webpack对模块联邦的配置应该如下所示：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding code is simple to understand. We let Module Federation know the
    name of the host app and provide a list of remote apps and the path to their corresponding
    `remoteEntry` file in the `remotes` object.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码易于理解。我们让模块联邦知道主机应用的名字，并提供远程应用列表以及它们对应的`remoteEntry`文件在`remotes`对象中的路径。
- en: Remote Apps
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 远程应用
- en: Remote apps, as you would have guessed, are apps that load dynamically within
    the host app. These remote apps are also referred to as *containers* in Module
    Federation terminology. The JS bundle of these remote apps is usually exposed
    via a single `.js` file usually called `remoteEntry.js`, which the host app looks
    out for.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，远程应用是在主机应用中动态加载的应用。在模块联邦术语中，这些远程应用也被称为*容器*。这些远程应用的JS包通常通过一个单一的`.js`文件暴露，通常称为`remoteEntry.js`，这是主机应用所寻找的。
- en: 'Every remote app is exposed in Webpack’s Module Federation configuration in
    the following way:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 每个远程应用都以以下方式在Webpack的模块联邦配置中公开：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Every remote app needs to have a unique name defined in its `name` property,
    and this name needs to match the names that are part of the `remotes` object defined
    in the host app’s Module Federation configuration.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 每个远程应用都需要在其`name`属性中定义一个唯一名称，并且这个名称需要与主机应用模块联邦配置中定义的`remotes`对象中的名称相匹配。
- en: remoteEntry.js
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: remoteEntry.js
- en: The `remoteEntry.js` file is a small JS file that is created by Module Federation
    at runtime. It contains metadata for each of the remote apps. The host app relies
    on the `remoteEntry.js` file to know which modules to load into.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`remoteEntry.js`文件是一个由模块联邦在运行时创建的小型JS文件。它包含每个远程应用的元数据。主机应用依赖于`remoteEntry.js`文件来知道要加载哪些模块。'
- en: Use cases for Module Federation are not just limited to building microfrontends;
    they can also be used to dynamically load common libraries or a module such as
    a design system, for example, negating the need to publish these common libraries
    as `npm` packages and having to rebuild and re-deploy every time a common library
    has changed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 模块联邦的使用案例不仅限于构建微前端；它们还可以用来动态加载公共库或模块，例如设计系统，例如，无需将这些公共库作为`npm`包发布，每次公共库发生变化时都无需重新构建和重新部署。
- en: 'The following diagram helps to explain how Module Federation works:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表有助于解释模块联邦是如何工作的：
- en: '![Figure 5.1 – Module Federation with three micro apps loaded in real time](img/Figure_5.01_B18987.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1 – 实时加载三个微应用的模块联邦](img/Figure_5.01_B18987.jpg)'
- en: Figure 5.1 – Module Federation with three micro apps loaded in real time
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – 实时加载三个微应用的模块联邦
- en: From the diagram, we see that we have apps running on ports `3001`, `3002`,
    and `3003`. Each of them has its metadata exposed in its respective `remoteEntry.js`
    files. These apps are dynamically loaded into the host app that is running on
    port `3000` via Module Federation.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 从图中，我们看到我们有在端口`3001`、`3002`和`3003`上运行的应用。每个应用都在其各自的`remoteEntry.js`文件中公开了其元数据。这些应用通过模块联邦动态加载到在端口`3000`上运行的主机应用中。
- en: It may be prudent to know that it is not just apps. Any kind of JS module can
    be dynamically imported into Module Federation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这一点可能很谨慎：这不仅仅是应用。任何类型的JS模块都可以动态导入到模块联邦中。
- en: In the next section, we will put all of this into practice.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将把这些内容付诸实践。
- en: Setting up Microfrontends with a Host and Remote app
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用主机和远程应用设置微前端
- en: We are going to take our multi-SPA app and convert it into a microfrontend with
    a Host and Remote app using Module Federation. As mentioned earlier, the main
    benefit of this approach is that users get a true single-page experience while
    still ensuring that each app is independently built and deployed.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把我们的多SPA应用转换成一个带有主机和远程应用的微前端，使用模块联邦。如前所述，这种方法的主要好处是用户可以获得真正的单页体验，同时确保每个应用都是独立构建和部署的。
- en: 'Let us see what it takes for us to do this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们为此需要做什么：
- en: '![Figure 5.2 – Module Federation setup](img/Figure_5.02_B18987.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 模块联邦设置](img/Figure_5.02_B18987.jpg)'
- en: Figure 5.2 – Module Federation setup
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 模块联邦设置
- en: You will notice that *Figure 5**.2* is similar to *Figure 5**.1* and explains
    the implementation details of Module Federation. We see that the Host app contains
    the header component and runs on port `4200`. We then have our Catalog and Checkout
    apps running on ports `4202` and `4201`. We aim to load these remote apps dynamically
    whenever the correct route is called.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到 *图 5**.2* 与 *图 5**.1* 类似，并解释了模块联邦的实现细节。我们看到主应用程序包含头部组件，并在端口 `4200` 上运行。然后我们有我们的目录和检查应用程序在端口
    `4202` 和 `4201` 上运行。我们的目标是动态加载这些远程应用程序，每当调用正确的路由时。
- en: 'To convert our multi-SPA into a module-federated microfrontend, we will need
    to make the following changes:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们的多 SPA 转换为模块化联邦的微前端，我们需要进行以下更改：
- en: Create a new Host app that we’ll call App-shell.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 App-shell 的新主应用程序。
- en: Remove the header component from each SPA and move it into App-shell.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从每个单页应用程序（SPA）中删除头部组件并将其移动到 App-shell。
- en: Define the remote apps, namely Catalog and Checkout, that need to be loaded
    into the host app.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义需要加载到主应用程序中的远程应用程序，即目录和检查应用程序。
- en: Define the remote entry for the Catalog and Checkout micro apps.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义目录和检查微应用程序的远程入口。
- en: Let us get started. Open up the e-buy app that you built in the previous chapter.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。打开您在前一章中构建的 e-buy 应用程序。
- en: 'You may also download it from the Git repo:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以从 Git 仓库下载它：
- en: '[https://github.com/PacktPublishing/Building-Micro-Frontends-with-React/tree/main/ch4/ebuy](https://github.com/PacktPublishing/Building-Micro-Frontends-with-React/tree/main/ch4/ebuy)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Micro-Frontends-with-React/tree/main/ch4/ebuy](https://github.com/PacktPublishing/Building-Micro-Frontends-with-React/tree/main/ch4/ebuy)'
- en: In the coming subsections, we will see how to create our host and remote apps,
    but first, we will clean up our existing apps and prep them to use Module Federation.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的小节中，我们将看到如何创建我们的主应用程序和远程应用程序，但首先，我们将清理现有的应用程序，并准备它们使用模块联邦。
- en: Clean up
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清理
- en: With Module Federation, the host app takes care of routing, and there is no
    need for us to use the proxy configurations we defined in the `proxy.conf.json`
    file. So, we will delete this file and remove the unnecessary configuration from
    the `project.json` file.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模块联邦，主应用程序负责路由，我们不需要使用我们在 `proxy.conf.json` 文件中定义的代理配置。因此，我们将删除此文件，并从 `project.json`
    文件中删除不必要的配置。
- en: 'Go ahead and delete `/apps/catalog/proxy.conf.json` and, in the `catalog/project.json`
    file, delete the following line:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然后继续删除 `/apps/catalog/proxy.conf.json`，并在 `catalog/project.json` 文件中删除以下行：
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'While we’re at it, we can also get rid of `baseRef`, which we defined in our
    `checkout/project.json` file. Locate this line and delete it:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程中，我们还可以删除我们在 `checkout/project.json` 文件中定义的 `baseRef`。找到此行并将其删除：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Setting up the App-shell host app
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 App-shell 主应用程序
- en: With this, we are now set to start migrating our multi-SPA apps to Module Federation.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们现在已准备好开始将我们的多 SPA 应用程序迁移到模块联邦。
- en: 'Nx Console has a nifty generator for creating a host and remote apps for Module
    Federation. Follow these steps:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Nx 控制台有一个用于创建模块联邦的主应用程序和远程应用程序的便捷生成器。按照以下步骤操作：
- en: 'Create a React host app:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 React 主应用程序：
- en: '**Nx Console** | **Generate** | **@nrwl/react – host Generate a host** **react
    application**'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**Nx 控制台** | **生成** | **@nrwl/react – 主生成一个主** **react 应用程序**'
- en: '![Figure 5.3 – Selecting the host app generator from Nx Dev Console](img/Figure_5.03_B18987.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – 从 Nx 开发控制台选择主应用程序生成器](img/Figure_5.03_B18987.jpg)'
- en: Figure 5.3 – Selecting the host app generator from Nx Dev Console
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 从 Nx 开发控制台选择主应用程序生成器
- en: 'Enter the following information in this form:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此表单中输入以下信息：
- en: '**Name**: **app-shell**'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**: **app-shell**'
- en: '**devServerPort**: **4200**'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**devServerPort**: **4200**'
- en: '**e2eTestrunner**: **none**'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**e2eTestrunner**: **无**'
- en: '**remotes**: We will leave this blank and add it manually due to a bug that
    doesn’t allow multiple app names'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**remotes**: 由于一个不允许多个应用程序名称的 bug，我们将留空并手动添加。'
- en: After you hit the `apps/app-shell/module-federation.config.js`.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您点击 `apps/app-shell/module-federation.config.js` 后。
- en: 'Open up the file and, in the **remotes** array, add Catalog and Checkout as
    the remote apps:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开文件，在 **remotes** 数组中添加目录和检查作为远程应用程序：
- en: '[PRE5]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now let us open up the `React.Suspence` and React Router’s `Route`.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们打开 `React.Suspence` 和 React Router 的 `Route`。
- en: 'We will tweak this boilerplate file:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将调整此模板文件：
- en: '[PRE6]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see from the preceding code, we first import the `Header` component
    into App-shell.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您从前面的代码中看到的，我们首先将 `Header` 组件导入到 App-shell。
- en: You will also notice that we are using dynamic imports to import our Catalog
    and Checkout apps using `React.lazy`. These lines will currently be throwing errors
    as it is unable to find the module.
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您还会注意到我们正在使用动态导入来使用`React.lazy`导入我们的Catalog和Checkout应用。这些行目前会抛出错误，因为它无法找到模块。
- en: 'To solve this, create a file called **/apps/app-shell/src/remotes.d.ts** with
    the following code:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了解决这个问题，创建一个名为**/apps/app-shell/src/remotes.d.ts**的文件，并添加以下代码：
- en: '[PRE7]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `remotes.d.ts` file is used to provide TypeScript type declarations for
    remotes in a Module Federation setup.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`remotes.d.ts`文件用于在模块联邦设置中为远程提供TypeScript类型声明。'
- en: Further down in the JSX, you will notice that we import the Catalog app on the
    `/` and `/catalog` routes while we import the Checkout app on the `/``checkout`
    route.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在JSX的下方，您会注意到我们在`/`和`/catalog`路由上导入Catalog应用，而在`/checkout`路由上导入Checkout应用。
- en: This more or less completes the setup for the host app.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上完成了宿主应用的设置。
- en: Setting up our Remote apps
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置我们的远程应用
- en: Setting up our remote apps will take a bit of work. Let us crack on and work
    on them one at a time.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 设置我们的远程应用需要一些工作。让我们逐一解决这些问题。
- en: 'Here’s what we need to do in order to convert an existing React app within
    Nx to a remote app:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将现有的Nx中的React应用转换为远程应用，我们需要做以下几步：
- en: Create remote entries in the **module-federation.config.js** file.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**module-federation.config.js**文件中创建远程入口。
- en: Swap the app builder in **project.json** to use the module-federation plugin.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**project.json**中的应用构建器更改为使用模块联邦插件。
- en: Add a **serve-static** executor.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个**serve-static**执行器。
- en: Use a custom Webpack configuration that defines the remote entry modules.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义的Webpack配置，该配置定义了远程入口模块。
- en: 'Let us carry out the preceding changes in the Catalog app to start with. Follow
    these steps:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从Catalog应用开始执行前面的更改。按照以下步骤操作：
- en: 'In the **apps/catalog** folder, create a new file called **module-federation.config.js**
    and add the following code:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**apps/catalog**文件夹中，创建一个名为**module-federation.config.js**的新文件，并添加以下代码：
- en: '[PRE8]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is where we define the Catalog remote app and the module path that it exposes.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是我们定义目录远程应用及其暴露的模块路径的地方。
- en: Next, we need to make a couple of changes to the **apps/catalog/project.json**
    file.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要对**apps/catalog/project.json**文件进行一些更改。
- en: 'First, we add a new command under the targets and call it **serve-static**:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在目标下添加一个新的命令，命名为**serve-static**：
- en: '[PRE9]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice that we intend to run our app on `4201`, so let’s also make sure the
    `serve` command also uses port `4201`.
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们打算在`4201`上运行我们的应用，所以让我们也确保`serve`命令也使用端口号`4201`。
- en: 'Make sure the port under the regular **serve** command is defined within the
    **options** object:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在常规**serve**命令下的端口号在**options**对象中定义：
- en: '[PRE10]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is because the Module Federation plugin expects the port to be defined
    within the `options` object. If not, it will use a default port, which can lead
    to very interesting bugs.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是因为模块联邦插件期望在`options`对象中定义端口号。如果没有定义，它将使用默认端口号，这可能导致非常有趣的错误。
- en: 'Refer to this line in the source code: [https://github.com/nrwl/nx/blob/master/packages/react/src/module-federation/with-module-federation.ts#L29](https://github.com/nrwl/nx/blob/master/packages/react/src/module-federation/with-module-federation.ts#L29).'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 参考源代码中的这一行：[https://github.com/nrwl/nx/blob/master/packages/react/src/module-federation/with-module-federation.ts#L29](https://github.com/nrwl/nx/blob/master/packages/react/src/module-federation/with-module-federation.ts#L29)。
- en: 'Next, under the **serve** object, we update the executor to use **module-federation
    dev-server**:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在**serve**对象下，我们更新执行器以使用**module-federation dev-server**：
- en: '[PRE11]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, ensure we have **WebpackConfig** with a custom Webpack configuration:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，确保我们有**WebpackConfig**带有自定义Webpack配置：
- en: '[PRE12]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now let us update **webpack.config.js** with the following code:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们更新**webpack.config.js**文件，添加以下代码：
- en: '[PRE13]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now let us repeat the same steps for the Checkout app:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对Checkout应用重复相同的步骤：
- en: 'In the **apps/checkout/** folder, create a new file called **module-federation.config.js**
    with the following code:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**apps/checkout/**文件夹中，创建一个名为**module-federation.config.js**的新文件，并添加以下代码：
- en: '[PRE14]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, it is identical to what we had on the Catalog app. The only
    difference is that we changed the `name` value to `checkout`.
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，它与Catalog应用中的配置相同。唯一的区别是我们将`name`值更改为`checkout`。
- en: 'Next, let us add the **serve-static** command to the **targets** object in
    the **apps/checkout/project.json** file:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们将**serve-static**命令添加到**apps/checkout/project.json**文件中的**targets**对象：
- en: '[PRE15]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the same file, we continue to update the executor:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件中，我们继续更新执行器：
- en: '[PRE16]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Then under the **serve.options** update the port number to **4202**.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后在**serve.options**下更新端口号为**4202**。
- en: 'We also update **webpackConfig**:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还更新了**webpackConfig**：
- en: '[PRE17]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Since there are no changes to the `webpack.config.js` file, we can simply copy
    and paste this file from the Catalog app.
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于`webpack.config.js`文件没有变化，我们可以简单地从Catalog应用复制并粘贴此文件。
- en: Finally, we will update the **Header** component to use the **Link** component
    from **ReactRouter** so that we get that single-page experience.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将更新**Header**组件以使用来自**ReactRouter**的**Link**组件，以便我们获得单页应用体验。
- en: 'Open up the **/libs/ui/src/lib/header.tsx** file and update the following to
    use **<Link>** instead of **<a>**:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**/libs/ui/src/lib/header.tsx**文件，并将以下内容更新为使用**<Link>**而不是**<a>**：
- en: '[PRE18]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Don’t forget to import the **<****Link>** command:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要忘记导入**<Link>**命令：
- en: '[PRE19]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Before we try testing, let us not forget to remove the header component from
    the respective Catalog app located at **/apps/catalog/src/app/app.tsx** and the
    Checkout app at **/****apps/checkout/src/app/app.tsx**.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们尝试测试之前，别忘了从位于**/apps/catalog/src/app/app.tsx**的相应Catalog应用和位于**/apps/checkout/src/app/app.tsx**的Checkout应用中移除头部组件。
- en: 'Let’s do a quick test on the terminal. Run the following command:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在终端上快速测试一下。运行以下命令：
- en: '[PRE20]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Once everything is running without any errors, open up `/assets` folder of the
    App-shell app.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一切运行无误后，打开App-shell应用的**/assets**文件夹。
- en: In the multi-SPA approach, the Catalog app was the default route and was sort
    of acting like the host app. Since App-shell is now our host, we will need to
    copy the images from the **/catalog/src/assets** folder into the **app-shell/src/assets**
    folder. Once you have done this, the images should load up into the app.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在多SPA方法中，Catalog应用是默认路由，并且有点像宿主应用。由于App-shell现在是我们的宿主，我们需要将**/catalog/src/assets**文件夹中的图片复制到**app-shell/src/assets**文件夹中。一旦完成这个操作，图片应该会加载到应用中。
- en: Navigate between the Catalog and Checkout apps. Add items to your cart and enjoy
    seeing the apps work nicely.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Catalog应用和Checkout应用之间导航。将商品添加到购物车，并享受看到应用良好工作的乐趣。
- en: Since everything is going well, and since each micro app team should be able
    to work on their individual apps, let us also make sure that we can run each app
    individually.
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于一切进展顺利，并且每个微应用团队都应该能够独立工作在自己的应用上，让我们也确保我们可以单独运行每个应用。
- en: 'Run **pnpm nx serve catalog** and you’ll notice you get an error:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行**pnpm nx serve catalog**，你会注意到你得到一个错误：
- en: '[PRE21]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is due to Module Federation treating the Catalog app as a bidirectional
    host and not being able to eagerly load the shared modules.
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是因为模块联邦将Catalog应用视为双向宿主，并且无法急切地加载共享模块。
- en: 'You can read more about it here:'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在这里了解更多信息：
- en: '[https://webpack.js.org/concepts/module-federation/#uncaught-error-shared-module-is-not-available-for-eager-consumption](https://webpack.js.org/concepts/module-federation/#uncaught-error-shared-module-is-not-available-for-eager-consumption)'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://webpack.js.org/concepts/module-federation/#uncaught-error-shared-module-is-not-available-for-eager-consumption](https://webpack.js.org/concepts/module-federation/#uncaught-error-shared-module-is-not-available-for-eager-consumption)'
- en: To overcome this issue, we need to define an asynchronous boundary to split
    out the initialization code of a larger chunk and avoid any additional roundtrips
    to the server.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了克服这个问题，我们需要定义一个异步边界来分割出更大块初始化代码，并避免任何额外的服务器往返。
- en: To solve it, we need to make a couple of tweaks. In the Catalog app, let us
    first rename **/apps/catalog/src/main.tsx** to **bootstrap.tsx**.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要做一些调整。在Catalog应用中，我们首先将**/apps/catalog/src/main.tsx**重命名为**bootstrap.tsx**。
- en: 'Next, we create a new file called **main.ts** within the same **src** folder
    and have a single line importing bootstrap:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们在同一个**src**文件夹内创建一个名为**main.ts**的新文件，并有一个单独的行导入bootstrap：
- en: '[PRE22]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we need to ensure that this newly created **main.ts** file is what is
    being used as the entry point, so now, in our **project.json** file for the Catalog
    app, we update the **main** property within the **build >** **options** object:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要确保这个新创建的**main.ts**文件是作为入口点使用的，因此现在，在我们的Catalog应用的项目.json文件中，我们需要更新**build
    > options**对象内的**main**属性：
- en: '[PRE23]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Repeat the same steps for the Checkout app. Now, you should be able to run the
    apps as a module-federated microfrontend or each app individually.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对Checkout应用重复相同的步骤。现在，你应该能够以模块联邦微前端或每个应用独立的方式运行应用。
- en: You may have also noticed that at the start of this chapter, we referred to
    the `remoteEntry.js` file as the entry file for the remote apps and that we didn’t
    really define one.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也注意到，在本章的开头，我们提到了`remoteEntry.js`文件作为远程应用的入口文件，并且我们实际上并没有定义一个。
- en: However, if you look at your dev tools’ network tab, you will notice there are
    two `remoteEntry.js` files being called from ports `4201` and `4202` respectively.
    This is Nx and Module Federation doing a bit of magic here.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你查看你的开发工具的网络标签页，你会注意到有两个 `remoteEntry.js` 文件分别从端口 `4201` 和 `4202` 被调用。这是
    Nx 和模块联邦在这里进行一些魔法操作。
- en: Important note
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you dig into the source code in this file, you will notice the filename being
    defined as part of the **ModuleFederationPlugin** configuration ([https://github.com/nrwl/nx/blob/master/packages/react/src/module-federation/with-module-federation.ts](https://github.com/nrwl/nx/blob/master/packages/react/src/module-federation/with-module-federation.ts)).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你深入查看这个文件中的源代码，你会注意到文件名被定义为 **ModuleFederationPlugin** 配置的一部分 ([https://github.com/nrwl/nx/blob/master/packages/react/src/module-federation/with-module-federation.ts](https://github.com/nrwl/nx/blob/master/packages/react/src/module-federation/with-module-federation.ts))。
- en: 'The screenshot in *Figure 5**.4* shows the `remoteEntry.js` file being called
    from the respective apps:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5.4* 中的截图显示了 `remoteEntry.js` 文件从相应的应用中被调用：'
- en: '![Figure 5.4 – RemoteEntry.js](img/Figure_5.04_B18987.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4 – RemoteEntry.js](img/Figure_5.04_B18987.jpg)'
- en: Figure 5.4 – RemoteEntry.js
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – RemoteEntry.js
- en: 'If you are keen to explicitly define the file and stay as close as possible
    to the native workings of Module Federation, then go ahead and create a file in
    `apps/catalog/src/remote-entry.js` with the following line:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你渴望明确地定义文件并尽可能接近模块联邦的原生工作方式，那么请创建一个文件在 `apps/catalog/src/remote-entry.js`
    中，包含以下行：
- en: '[PRE24]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Update the `exposes` value in the `apps/catalog/module-federation.js` file
    to read as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `apps/catalog/module-federation.js` 文件中的 `exposes` 值更新为以下内容：
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: With that, we have completed the section on using Module Federation and successfully
    converted our multi-SPA app into a module-federated microfrontend.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经完成了关于使用模块联邦的章节，并成功将我们的多 SPA 应用转换为模块联邦微前端。
- en: In this section, we saw what minimal steps are required to get Module Federation
    working and what extra steps, such as defining the remotes and exposing the module
    names, are needed to allow each app to work independently.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了要使模块联邦工作所需的最小步骤，以及需要额外步骤，如定义远程和暴露模块名称，以允许每个应用独立工作。
- en: In the next section, we will see how to further break down a remote app into
    a true micro-app microfrontend.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何进一步将远程应用分解为真正的微应用微前端。
- en: Extending Module Federation to a true Micro-apps Pattern
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将模块联邦扩展到真正的微应用模式
- en: Imagine you are part of a team that manages a very large e-Commerce app (think
    of Amazon.com). For such large sites, it is a common practice to have teams that
    own a single organism-level component ([https://atomicdesign.bradfrost.com/chapter-2/#organisms](https://atomicdesign.bradfrost.com/chapter-2/#organisms))
    instead of the entire mini app.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你是一个管理一个非常大的电子商务应用（比如 Amazon.com）的团队的成员。对于这样的大型网站，拥有一个拥有单个有机级组件（[https://atomicdesign.bradfrost.com/chapter-2/#organisms](https://atomicdesign.bradfrost.com/chapter-2/#organisms)）而不是整个迷你应用的团队是一种常见的做法。
- en: For example, we have a dedicated team that works exclusively on the Product
    Recommendations component. This component is injected into, say, the Catalog app.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们有一个专门的小组，他们专门负责产品推荐组件。这个组件被注入到，比如说，目录应用中。
- en: In such a case, it would be prudent to create another micro app called Recommendations
    and dynamically import it into the Catalog app. This would allow for true, federated,
    micro-app pattern architecture.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，创建另一个名为推荐的微应用并将其动态导入到目录应用中将是明智的。这将允许实现真正的、联邦化的微应用模式架构。
- en: '![Figure 5.5 – Tree of remote apps with Module Federation](img/Figure_5.05_B18987.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5 – 使用模块联邦的远程应用树](img/Figure_5.05_B18987.jpg)'
- en: Figure 5.5 – Tree of remote apps with Module Federation
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – 使用模块联邦的远程应用树
- en: As you can see from the preceding diagram, we can further break down our Catalog
    and Checkout apps into smaller organism-level components and have each of them
    load into the Catalog app remotely via Module Federation.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的图中所见，我们可以进一步将目录和结账应用分解为更小的有机级组件，并通过模块联邦让每个组件远程加载到目录应用中。
- en: Important note
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Remember, while this may seem very cool, it is important that we don’t overdo
    it by converting every single organism into a module-federated micro app. It is
    important to follow the principles of microfrontends mentioned in [*Chapter 2*](B18987_02.xhtml#_idTextAnchor029),
    namely, *breaking down the app into the largest independently deployable app owned
    by a single team* and not necessarily the smallest.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，虽然这看起来非常酷，但我们不应该过度操作，将每个单一的组织体都转换为模块联邦的微应用程序。重要的是要遵循第 [*第2章*](B18987_02.xhtml#_idTextAnchor029)
    中提到的微前端原则，即 *将应用程序分解为单个团队拥有的最大独立部署的应用程序*，而不一定是最小的。
- en: Having said that, and assuming you do have an independent team owning the Recommendations
    micro app, let us go about creating the micro app.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，假设你确实有一个拥有 Recommendations 微应用程序的独立团队，让我们着手创建微应用程序。
- en: Creating the Recommendations Remote Micro app
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 Recommendations 远程微应用程序
- en: 'Let us use our trusted Nx dev console and the `GENERATE` command and follow
    these steps:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用我们信任的 Nx 开发控制台和 `GENERATE` 命令，按照以下步骤操作：
- en: 'Select **@nrwl/react - remote Generate a remote application** and use the following
    information while leaving the rest as their defaults:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **@nrwl/react - remote Generate a remote application** 并在保持其余默认设置的情况下使用以下信息：
- en: '**Name**: **recommendations**'
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**：**recommendations**'
- en: '**e2eTestRunner**: **none**'
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**e2eTestRunner**：**none**'
- en: '**host**: **catalog**'
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主机**：**catalog**'
- en: '**devServerPort**: **4203**'
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**devServerPort**：**4203**'
- en: Use the **Generate** command and verify that the **recommendations** app has
    been successfully created.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **Generate** 命令并验证 **recommendations** 应用程序是否已成功创建。
- en: 'Let us quickly edit **apps/recommendations/src/app.tsx** to remove the boilerplate
    code and leave it with a simple message:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们快速编辑 **apps/recommendations/src/app.tsx** 文件，移除样板代码，并留下一个简单的消息：
- en: '[PRE26]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Building a full-fledged Recommendations micro app is beyond the scope of this
    book.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个完整的 Recommendations 微应用程序超出了本书的范围。
- en: Run **npx nx serve recommendations** and verify that the app loads up properly
    on port **4203**.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 **npx nx serve recommendations** 并验证应用程序是否在端口 **4203** 上正确加载。
- en: Keep it running while we work on adding it as a remote to our Catalog app.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们添加它作为远程应用程序到 Catalog 应用程序的同时，保持其运行。
- en: Adding Recommendations as a Remote app to Catalog
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 Recommendations 作为远程应用程序添加到 Catalog
- en: 'Since we want the Recommendations micro app to load within Catalog, as a remote
    app, we need to convert Catalog to behave like a host. We do this using the following
    steps:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望 Recommendations 微应用程序作为远程应用程序加载到 Catalog 中，我们需要将 Catalog 转换为类似主机的行为。我们通过以下步骤来完成：
- en: 'Open up the **apps/catalog/module-federation.config.js** file and add the **remotes**
    entry to it:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **apps/catalog/module-federation.config.js** 文件，并向其中添加 **remotes** 条目：
- en: '[PRE27]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, let us create a **remotes.d.ts** file within the **apps/catalog/src**
    folder using the following line:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们在 **apps/catalog/src** 文件夹内创建一个 **remotes.d.ts** 文件，使用以下行：
- en: '[PRE28]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, let us import and call the Recommendations app into our **apps/catalog/src/app/app.tsx**
    file:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们将 Recommendations 应用程序导入并调用到我们的 **apps/catalog/src/app/app.tsx** 文件中：
- en: '[PRE29]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the **jsx** part of the component, here is how we call our Recommendations
    component:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件的 **jsx** 部分，这是我们调用 Recommendations 组件的方式：
- en: '[PRE30]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Open up a new terminal window and run the following command:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的终端窗口并运行以下命令：
- en: '[PRE31]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If everything goes as planned, you will see the Catalog app with the Recommendations
    component loaded within it. With this, we come to the end of this section.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切按计划进行，你将看到带有 Recommendations 组件的 Catalog 应用程序。有了这个，我们就到了本节的结尾。
- en: In this section, we saw how we can use Module Federation to further break down
    a host app into smaller micro apps and have them all working together as a tree
    of remote apps.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了如何使用模块联邦进一步将主应用程序分解成更小的微应用程序，并使它们作为一个远程应用程序的树状结构协同工作。
- en: In the next section, we will see how to set up state management within our micro
    apps microfrontend.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何在我们的微前端微应用程序中设置状态管理。
- en: State management with Module Federation
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模块联邦进行状态管理
- en: As you may have noticed by now, our custom state management system, which uses
    `sessionStorage`, continues to work seamlessly with Module Federation. This is
    because, from a React perspective, it all looks like a regular React application,
    with modules being lazy-loaded. So, one of the benefits of Module Federation is
    that we can use any of the regular state management concepts, such as prop drilling,
    context API, or libraries such as Redux or Zustand, to manage the state.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如您现在可能已经注意到的，我们的自定义状态管理系统，它使用 `sessionStorage`，与模块联邦无缝协作。这是因为从 React 的角度来看，它看起来就像一个普通的
    React 应用程序，模块是懒加载的。因此，模块联邦的一个好处是我们可以使用任何常规的状态管理概念，例如属性钻取、上下文 API 或 Redux 或 Zustand
    等库来管理状态。
- en: In this section, we will make use of the Zustand state management library as
    it is extremely user-friendly and has zero boilerplate code.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 Zustand 状态管理库，因为它极其用户友好，且没有样板代码。
- en: Now, logically, especially for those who use a lot of context API, we would
    be inclined to have the store within App-shell and have the other micro apps consume
    it. However, with Module Federation, this would not be ideal, because the store
    would need to be exposed as a remote app and imported into other micro apps that
    act as hosts. If you try plotting this, it kind of feels like a cyclic dependency
    of sorts, where App-shell acts as a host for all other components but the store
    located in it is a remote for other components.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从逻辑上讲，尤其是对于那些大量使用上下文 API 的人来说，我们可能会倾向于将 store 放在 App-shell 中，并让其他微应用程序消费它。然而，使用模块联邦，这并不理想，因为
    store 需要作为一个远程应用程序暴露，并导入作为宿主的其他微应用程序。如果你尝试绘制这个，它有点像某种循环依赖，其中 App-shell 作为所有其他组件的宿主，但位于其中的
    store 是其他组件的远程。
- en: 'The following diagram better illustrates the problem of this cyclic flow:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图更好地说明了这种循环流程的问题：
- en: '![Figure 5.6 – Cyclic flow between App-shell and the store](img/Figure_5.06_B18987.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6 – App-shell 和 store 之间的循环流程](img/Figure_5.06_B18987.jpg)'
- en: Figure 5.6 – Cyclic flow between App-shell and the store
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – App-shell 和 store 之间的循环流程
- en: 'When working with Module Federation, it is preferable to have a unidirectional
    flow of how the remote and host apps are loaded in. With that in mind, it would
    be more prudent to have our store as its own independent micro app and have it
    defined as a remote app to all the other apps that consume it. With this new structure,
    the diagram in *Figure 5**.6* can be redrawn:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用模块联邦时，最好有一个单向流程来描述远程和宿主应用程序的加载方式。考虑到这一点，最好将我们的 store 作为其独立的微应用程序，并使其对所有使用它的其他应用程序定义为一个远程应用程序。有了这种新的结构，*图
    5.6* 中的图可以重新绘制：
- en: '![Figure 5.7 – Unidirectional remotes for the Store app](img/Figure_5.07_B18987.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.7 – Store 应用程序的单一方向远程连接](img/Figure_5.07_B18987.jpg)'
- en: Figure 5.7 – Unidirectional remotes for the Store app
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 – Store 应用程序的单一方向远程连接
- en: As evident from *Figure 5**.7*, the unidirectional flow of remotes for the Store
    app looks a lot cleaner, and it ensures that App-shell isn’t getting unnecessarily
    bloated with business logic and state.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 5.7* 所示，Store 应用程序的远程单向流程看起来要干净得多，并确保 App-shell 不会不必要地膨胀业务逻辑和状态。
- en: 'Since we are going to use Zustand for state management, this would be a good
    time for us to install it. Run the following command:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们打算使用 Zustand 进行状态管理，这将是安装它的好时机。运行以下命令：
- en: '[PRE32]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let us now create our Store remote app using the steps we used to create our
    Recommendations remote app:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们按照创建我们的 Recommendations 远程应用程序的步骤来创建我们的 Store 远程应用程序：
- en: Using Nx Console and the **@nrwl/react - remote Generate a remote application**
    file, create the Store micro app.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Nx Console 和 **@nrwl/react - remote Generate a remote application** 文件，创建
    Store 微应用程序。
- en: 'Fill in the form with the following information, and leave the rest as their
    defaults:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下信息填写表格，其余部分保留默认值：
- en: '**Name**: **store**'
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**: **store**'
- en: '**e2eTestRunner**: **none**'
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**e2eTestRunner**: **none**'
- en: '**host**: (leave this blank because we will manually add the hosts)'
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**宿主**: （留空，因为我们将会手动添加宿主）'
- en: '**devServerPort**: **4204**'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**devServerPort**: **4204**'
- en: Once the app has been created, let us go about setting up our store. To demonstrate
    the working of the state and store across the different micro apps, we will have
    a **Like** button in the host app. Clicking it will increment the like count.
    We will also display the count within the Recommendations app. Then, we will have
    a **Reset** button in the Recommendations micro app that will reset the store
    and verify that the like count has reset in all places.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了应用，让我们着手设置我们的存储库。为了展示不同微应用之间状态和存储的工作情况，我们在宿主应用中添加一个 **Like** 按钮。点击它将增加喜欢计数。我们还会在推荐应用中显示计数。然后，在推荐微应用中我们将有一个
    **重置** 按钮，该按钮将重置存储库并验证所有地方的喜欢计数是否已重置。
- en: 'Let us get started:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: Navigate to the **/apps/store/src** folder and create a new file called **store.tsx**.
    This is where we will define our store and hooks.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 **/apps/store/src** 文件夹并创建一个名为 **store.tsx** 的新文件。这是我们定义存储和钩子的地方。
- en: Note
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Zustand is super easy to work with. Have a look at the documentation at [https://docs.pmnd.rs/zustand/getting-started/introduction](https://docs.pmnd.rs/zustand/getting-started/introduction).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Zustand 非常易于使用。请查看 [https://docs.pmnd.rs/zustand/getting-started/introduction](https://docs.pmnd.rs/zustand/getting-started/introduction)
    的文档。
- en: 'Begin in the **store.tsx** file by importing Zustand and defining the **LikeCount**
    interface:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **store.tsx** 文件开始，导入 Zustand 并定义 **LikeCount** 接口：
- en: '[PRE33]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, we create our **useStore** hook and define the **initial state**, **increment**,
    and **reset** functions. This is the standard way to do so:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建我们的 **useStore** 钩子并定义 **初始状态**、**增加** 和 **重置** 函数。这是这样做的一种标准方式：
- en: '[PRE34]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: And that is it! Our store with the `useStore` hook is ready to be consumed.
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 就这样！我们的存储库和 `useStore` 钩子已经准备好被使用了。
- en: 'Next, we need to expose this as a remote app. We will do this by making two
    additional changes. In the **apps/store/src/remote-entry.ts** file, modify the
    following line to the following text:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要将其作为远程应用公开。我们将通过进行两项额外更改来实现这一点。在 **apps/store/src/remote-entry.ts**
    文件中，将以下行修改为以下文本：
- en: '[PRE35]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, we let App-shell and the Recommendations app know that they need to use
    Store as a remote app. We do this by adding Store to the remote array in the respective
    **module-federation.config.js** files in App-shell and the Recommendations app:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们让 App-shell 和推荐应用知道它们需要将 Store 作为远程应用使用。我们通过在 App-shell 和推荐应用的相应 **module-federation.config.js**
    文件中的远程数组中添加 Store 来实现这一点：
- en: '[PRE36]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here is what we have in the `apps/recommendations/module-federation.config.js`
    file:'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是 `apps/recommendations/module-federation.config.js` 文件中的内容：
- en: '[PRE37]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The next thing we need to do is declare the **store** module in the **remotes.d.ts**
    file app-shell file:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步，我们需要在 app-shell 文件的 **remotes.d.ts** 文件中声明 **store** 模块：
- en: '[PRE38]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We will need to do the same in the Recommendations app. Since the **remotes.d.ts**
    file doesn’t exist, we can create a new file with the following line in **/apps/recommendations/src/remotes.d.ts**:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要在推荐应用中做同样的事情。由于 **remotes.d.ts** 文件不存在，我们可以在 **/apps/recommendations/src/remotes.d.ts**
    中创建一个新文件，包含以下行：
- en: '[PRE39]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We now have the store hooked up so that Recommendations and App-shell can read
    and write to our Store micro app.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将存储库连接起来，以便推荐和 App-shell 可以读取和写入我们的 Store 微应用。
- en: Adding the Like button to the host app
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将“喜欢”按钮添加到宿主应用
- en: In this section, we will create a **Like** button that increments the like count
    and gets stored in the store.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个 **Like** 按钮，该按钮增加喜欢计数并将其存储在存储库中。
- en: 'Now that we have set up the remotes, let us import the store into our app shell
    and create the `/apps/app-shell/src/app/app.tsx` file. Follow these steps:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了远程服务器，让我们将存储库导入到我们的应用外壳中，并创建 `/apps/app-shell/src/app/app.tsx` 文件。按照以下步骤操作：
- en: 'Import **useStore**:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 **useStore**：
- en: '[PRE40]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, de-structure the count and increment within the **App** function:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在 **App** 函数中解构 count 和 increment：
- en: '[PRE41]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, in our JSX, we add our button after the **<****Header/>** component:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在我们的 JSX 中，我们在 **<****Header/>** 组件之后添加我们的按钮：
- en: '[PRE42]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Restart all the apps. You can also make use of the following custom command
    that we created to serve all apps:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动所有应用。您还可以使用我们创建的以下自定义命令来服务所有应用：
- en: '[PRE43]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We’ve got the state working with Zustand within the host app, and as you can
    tell, it is refreshingly simple and devoid of any boilerplate code. But the true
    purpose of us setting up the state and store is to ensure that this state can
    be shared with other micro apps. In our case, it will be the Recommendations app,
    right at the bottom of the federation hierarchy.
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在主应用中通过 Zustand 实现了状态管理，如您所见，它非常简单，没有多余的模板代码。但设置状态和存储库的真正目的是确保这个状态可以被其他微应用共享。在我们的例子中，它将是位于联盟层次结构底部的推荐应用。
- en: 'In the **apps/recommendations/src/app/app.tsx** file, our code should look
    very similar to the following:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**apps/recommendations/src/app/app.tsx**文件中，我们的代码应该看起来非常类似于以下内容：
- en: '[PRE44]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: That’s it!
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 就这样！
- en: 'Run your apps and play around with the **Like** button. Reset it and verify
    that the count stays in sync between the host and the Recommendations app:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行您的应用，并尝试使用**喜欢**按钮。重置它并验证主应用和推荐应用之间的计数是否保持同步：
- en: '![Figure 5.8 – Complete working app with shared state across micro apps](img/Figure_5.08_B18987.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.8 – 微应用间共享状态的完整工作应用](img/Figure_5.08_B18987.jpg)'
- en: Figure 5.8 – Complete working app with shared state across micro apps
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8 – 微应用间共享状态的完整工作应用
- en: Our app works great, but let us make sure it’s performant as well!
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用运行得很好，但让我们确保它也具有高性能！
- en: Avoiding Unnecessary Re-rendering
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免不必要的重新渲染
- en: When working with the state, a very important performance-related point to check
    is avoiding unnecessary re-rendering. This is especially true when the state is
    being shared between different components or when it is being prop drilled.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理状态时，一个非常重要的性能相关点是避免不必要的重新渲染。这在状态在不同组件之间共享或通过属性钻取时尤其正确。
- en: One way to verify that is to go into **Developer Tools**, open up the **Rendering**
    pane, select **Paint flashing** and **Frame Rendering Stats**, and verify that
    when you click on the buttons, only the necessary items within the components
    are updating.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 验证这一点的办法是进入**开发者工具**，打开**渲染**面板，选择**闪烁绘制**和**帧渲染统计**，并验证当您点击按钮时，只有组件内的必要项目会更新。
- en: 'In Chrome, you can access this panel by opening up **Developer Tools**, going
    into **More Tools**, and then selecting the **Rendering** pane:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Chrome 浏览器中，您可以通过打开**开发者工具**，进入**更多工具**，然后选择**渲染**面板来访问此面板：
- en: '![Figure 5.9 – Rendering pane in the developer consoles](img/Figure_5.09_B18987.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.9 – 开发者控制台中的渲染面板](img/Figure_5.09_B18987.jpg)'
- en: Figure 5.9 – Rendering pane in the developer consoles
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9 – 开发者控制台中的渲染面板
- en: As you can see from *Figure 5**.9*, once we have **Paint flashing** enabled,
    you will see a green rectangle encapsulating the sections of the page that re-render
    due to a change or user interaction. The ideal state is when only a small part
    of the page flashes when the user interacts with it. **Frame Rendering Stats**
    displays the frame rate as the user is interacting with the page. The frame rate
    should ideally stay close to 60 fps for a smooth user experience.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从**图 5.9**中看到，一旦我们启用了**闪烁绘制**，您将看到绿色矩形包围了由于变化或用户交互而重新渲染的页面部分。理想的状态是当用户与之交互时，只有页面的一小部分闪烁。**帧渲染统计**显示了用户与页面交互时的帧率。帧率理想情况下应接近
    60 fps，以提供流畅的用户体验。
- en: And with that, we come to the end of this section regarding state management
    with Zustand in a module-federated application. In this section, we learned the
    benefits of defining the Store app as a separate micro app. It is then dynamically
    imported into the other micro apps. We learned how to go about setting up the
    store as a module-federated module. We then saw how the host app and the Recommendations
    app can share state via the shared store. Finally, we were also able to turn on
    paint flashing and frame rendering to verify that as the state changes, only the
    necessary elements within the apps update, and it doesn’t cause components that
    haven’t changed to be re-rendered.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们就来到了本节关于模块联盟应用中 Zustand 状态管理的结束。在本节中，我们学习了将 Store 应用定义为单独的微应用的优点。然后它被动态导入到其他微应用中。我们学习了如何设置存储库作为模块联盟模块。然后我们看到主应用和推荐应用如何通过共享存储库共享状态。最后，我们还能够打开闪烁绘制和帧渲染，以验证当状态变化时，只有应用内的必要元素更新，并且不会导致未更改的组件重新渲染。
- en: Summary
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We’ve finally come to the end of another interesting chapter. We started by
    learning about Module Federation and how it is a game-changer in the way we build
    and maintain apps. We learned some of the basic concepts of Module Federation,
    such as host apps, remote apps, `remoteEntry`, and more.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于来到了另一个有趣章节的结尾。我们开始学习模块联邦以及它如何改变我们构建和维护应用的方式。我们学习了模块联邦的一些基本概念，例如宿主应用、远程应用、`remoteEntry`等。
- en: We then saw how to convert our multi-SPA app into a module-federated app with
    an app shell and how to load the Catalog and Checkout apps as remote apps. Then,
    we further broke things down to include smaller micro apps within these apps to
    create a tree of module-federated micro apps. Finally, we saw some of the best
    practices of managing the state and saw how we can look at tools such as Zustand
    to manage the state between these different micro apps.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们看到了如何将我们的多SPA应用转换为具有应用壳的模块联邦应用，以及如何将目录和结账应用作为远程应用加载。接着，我们将这些应用进一步拆分，包括更小的微应用，以创建模块联邦微应用的树状结构。最后，我们看到了一些管理状态的最佳实践，并了解了如何使用诸如Zustand这样的工具来管理不同微应用之间的状态。
- en: In the next chapters, we will see how to build these apps for production and
    how to deploy them to static storage on the cloud.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将了解如何构建这些应用以供生产使用，以及如何将它们部署到云端的静态存储上。
