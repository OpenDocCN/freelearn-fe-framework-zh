- en: Chapter 4. Divide and Conquer with the Module Pattern
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。模块模式的分而治之
- en: In this chapter, we will be introduced to the concepts of Modules and Namespacing
    and see how they can lead to more robust implementations. We will showcase how
    these design principles can be used in applications, by demonstrating some of
    the most commonly used development patterns to create **Modules** in JavaScript.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍模块和命名空间的概念，并看看它们如何带来更健壮的实现。我们将展示这些设计原则如何在应用程序中使用，通过展示一些最常用的开发模式来创建JavaScript中的**模块**。
- en: 'In this chapter, we will:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Review the concept of Modules and Namespacing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复习模块和命名空间的概念
- en: Introduce the Object Literal Pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍对象字面量模式
- en: Introduce the Module Pattern and its variants
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍模块模式及其变种
- en: Introduce the Revealing Module Pattern and its variants
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍揭示模块模式及其变种
- en: Have a small dive into ES5 Strict Mode and ES6 Modules
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简要介绍ES5严格模式和ES6模块
- en: Explain how Modules can be used and benefit jQuery applications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释模块如何用于jQuery应用程序产生益处
- en: Modules and Namespaces
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块和命名空间
- en: The two main practices of this chapter are Modules and Namespaces, which are
    used together in order to structure and organize our code. We will first analyze
    the main concept of Modules that is code encapsulation and right after this, we
    will proceed to Namespacing, which is used to logically organize an implementation.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的两个主要实践是模块和命名空间，它们一起使用以便结构化和组织我们的代码。我们将首先分析模块的主要概念，即代码封装，然后我们将继续命名空间，用于逻辑上组织实现。
- en: Encapsulating internal parts of an implementation
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 封装实现的内部部分
- en: While developing a large-scale and complex web application, the need for a well-defined,
    structured architecture becomes clear from the beginning. In order to avoid creating
    a spaghetti code implementation, where different parts of our code call each other
    in a chaotic way, we have to split our application into small, self-contained
    parts.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发大规模和复杂的Web应用程序时，从一开始就需要一个定义良好，结构化的架构的需求变得清晰。为了避免创建代码混乱的实现，其中我们的代码的不同部分以混乱的方式相互调用，我们必须将应用程序分割为小的，独立的部分。
- en: These self-contained pieces of code can be defined as **Modules**. To document
    this architecture principle, **Computer Science** has defined concepts such as
    **Separation of Concerns**, where the role, operation, and the exposed API of
    each Module should be strictly defined and focused on providing a generic solution
    to a specific problem.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这些独立的代码片段可以被定义为**模块**。为了记录这个架构原则，**计算机科学**已经定义了诸如**关注分离**之类的概念，其中每个模块的角色，操作和公开API都应严格定义并专注于为特定问题提供通用解决方案。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on **Encapsulation** and **Separation of Concerns**, you
    can visit [https://developer.mozilla.org/en-US/docs/Glossary/Encapsulation](https://developer.mozilla.org/en-US/docs/Glossary/Encapsulation)
    and [http://aspiringcraftsman.com/2008/01/03/art-of-separation-of-concerns/](http://aspiringcraftsman.com/2008/01/03/art-of-separation-of-concerns/).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有关**封装**和**关注分离**的更多信息，您可以访问[https://developer.mozilla.org/en-US/docs/Glossary/Encapsulation](https://developer.mozilla.org/en-US/docs/Glossary/Encapsulation)和[http://aspiringcraftsman.com/2008/01/03/art-of-separation-of-concerns/](http://aspiringcraftsman.com/2008/01/03/art-of-separation-of-concerns/)。
- en: Avoiding global variables with Namespaces
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免使用全局变量和命名空间
- en: In JavaScript, the `window` object is also known as the **Global Namespace**,
    where each declared variable and function identifier is attached by default. A
    **Namespace** can be defined as a naming context where each identifier has to
    be unique. The main concept of **Namespacing** is to provide a way to logically
    group all the related pieces of a distinct and self-contained part of an application.
    In other words, it suggests that we create groups with related functions and variables
    and make them accessible under the same umbrella identifier. This helps to avoid
    naming collisions between different parts of an application and other JavaScript
    libraries that are used, since we only need to keep all the identifiers unique
    under each different Namespace.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，`window`对象也被称为**全局命名空间**，其中每个声明的变量和函数标识符默认附加在其上。**命名空间**可以定义为每个标识符必须是唯一的命名上下文。**命名空间**的主要概念是提供一种逻辑分组应用程序不同和独立一部分所有相关部分的方式。换句话说，它建议我们创建相关函数和变量的组，并使它们在相同的标识符下可访问。这有助于避免不同应用程序部分和所使用的其他JavaScript库之间的命名冲突，因为我们只需要在每个不同的命名空间下保持所有标识符唯一。
- en: A good example of Namespacing is the mathematical functions and constants that
    JavaScript provides, which are grouped under the built-in JavaScript object called
    `Math`. Since JavaScript provides more than 40 short-named mathematical identifiers,
    such as `E`, `PI`, and `floor()`, in order to avoid naming conflicts and grouping
    them together, it was designed to make them accessible as properties of the `Math`
    object that acts as the Namespace of this built-in library.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的名称空间的例子是JavaScript提供的数学函数和常量，它们被分组到名为`Math`的内置JavaScript对象下。由于JavaScript提供了40多个短命名的数学标识符，如`E`、`PI`和`floor()`，为了避免命名冲突并将它们分组在一起，它们被设计成作为`Math`对象的属性可访问，该对象充当了这个内置库的命名空间。
- en: Without proper Namespacing, each function and variable needs to be uniquely
    named through the entire application, and collisions could happen between the
    identifiers of different application parts or even with those of a third-party
    library that an application uses. Finally, while Modules provide a way to isolate
    each independent part of your application, Namespacing provides a way to structure
    your different Modules to what becomes the architecture of the application.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 没有适当的名称空间，每个函数和变量必须在整个应用程序中具有唯一的名称，不同应用程序部分的标识符之间或者甚至与应用程序使用的第三方库的标识符之间可能发生冲突。最终，虽然模块提供了隔离应用程序每个独立部分的方法，但名称空间提供了一种将不同模块结构化成应用程序架构的方法。
- en: The benefits of these patterns
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 这些模式的好处
- en: Designing an application architecture based on Modules and namespacing leads
    to better code organization and clearly separated parts. In such architectures,
    Modules are used to group together parts of the implementation that are related,
    while Namespaces connect them to each other to create the application structure.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 基于模块和名称空间设计应用程序架构有助于更好地组织代码并明确分离部分。在这样的架构中，模块用于组合相关的实现部分，而名称空间将它们连接在一起以创建应用程序结构。
- en: '![The benefits of these patterns](img/00017.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![这些模式的好处](img/00017.jpeg)'
- en: This architecture helps to coordinate large developer teams, enabling the implementation
    of independent parts to take place in parallel. It can also shorten the development
    time needed to add a new functionality to the existing implementation. This is
    because the existing pieces that are used can be located easily and the added
    implementation has less chance of conflicting with the existing code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构有助于协调大型开发团队，使独立部分的实现可以并行进行。它还可以缩短向现有实现中添加新功能所需的开发时间。这是因为可以轻松定位使用的现有部分，并且添加的实现很少与现有代码发生冲突的可能性。
- en: The resulting code structures are not only cleanly separated, but since each
    Module is designed to achieve a single goal, there is a good chance that it can
    also be used in other similar applications. As an added benefit, since the role
    of each Module is strictly defined, it also makes tracing the origin of a bug
    a lot easier in a large codebase.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由此产生的代码结构不仅干净分离，而且由于每个模块被设计来实现单一目标，它们也有很大可能性在其他类似的应用程序中使用。作为额外好处，由于每个模块的角色严格定义，因此在大型代码库中追踪错误的起源也变得更加容易。
- en: The wide acceptance
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 广泛接受
- en: Both the community and the enterprise world realized that, in order to have
    maintainable, large frontend applications written in JavaScript, they should end
    up with a set of best practices that should be incorporated in every part of their
    implementations.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 社区和企业界意识到，为了编写在JavaScript中的可维护的大型前端应用程序，他们应该最终得出一套最佳实践，并应该将这些最佳实践纳入他们实现的每个部分中。
- en: The acceptance and adoption of Modules and Namespacing in JavaScript implementations
    is clearly visible in the best practices and coding style guides that the community
    and enterprises have released.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript实现中模块和名称空间的接受和采用在社区和企业发布的最佳实践和代码风格指南中清晰可见。
- en: 'For example, Google''s JavaScript Style Guide (available at [https://google.github.io/styleguide/javascriptguide.xml#Naming](https://google.github.io/styleguide/javascriptguide.xml#Naming))
    describes and suggests adopting namespacing in our implementations:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，谷歌的JavaScript风格指南（可在[https://google.github.io/styleguide/javascriptguide.xml#Naming](https://google.github.io/styleguide/javascriptguide.xml#Naming)找到）描述并建议在我们的实现中采用名称空间：
- en: ALWAYS prefix identifiers in the global scope with a unique pseudo namespace
    related to the project or library.
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 始终使用与项目或库相关的唯一伪命名空间作为全局范围标识符的前缀。
- en: 'Moreover, the jQuery JavaScript Style Guide (available at [https://contribute.jquery.org/style-guide/js/#global-variables](https://contribute.jquery.org/style-guide/js/#global-variables))
    suggests using global variables so that:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，jQuery JavaScript 风格指南（可在 [https://contribute.jquery.org/style-guide/js/#global-variables](https://contribute.jquery.org/style-guide/js/#global-variables)
    获取）建议使用全局变量，以便：
- en: Each project may expose at most one global variable.
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 每个项目最多只能公开一个全局变量。
- en: 'Another example of acceptance among the developer community, comes from the
    Mozilla Developer Network. Its guide for object-oriented JavaScript (available
    at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript#Namespace](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript#Namespace))
    also suggests using Namespaces, to wrap the implementation of our application
    under a single exposed variable, using something as simple as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员社区中另一个被接受的例子来自 Mozilla Developer Network。它的对象导向 JavaScript 指南（可在 [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript#Namespace](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript#Namespace)
    获取）还建议使用命名空间，将应用程序的实现封装在一个单一的暴露变量下，使用以下简单的方法：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Object Literal Pattern
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象字面量模式
- en: The Object Literal Pattern is probably the simplest way to wrap all the related
    parts of an implementation under an umbrella object that works as a Module. The
    name of this pattern accurately describes the way it is used. The developer just
    needs to declare a variable and assign an object with all the related parts that
    need to be encapsulated into this Module.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对象字面量模式可能是将实现的所有相关部分封装在一个作为模块的伞对象下的最简单方式。这种模式的名称准确地描述了它的使用方式。开发人员只需声明一个变量并将需要封装到该模块中的所有相关部分赋值给一个对象即可。
- en: 'Let''s see how we can create a Module that provides unique integers to a page,
    in a similar way how `jquery.guid` does it:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建一个模块，以类似于 `jquery.guid` 的方式为页面提供唯一的整数：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As seen above, a simple rule that you can follow in order to adopt this pattern
    is to define all the variables and functions that each implementation needs as
    properties of an object. Our code is reusable and does not pollute the Global
    Namespace, other than just defining a single variable name for our Module, `simpleguid`
    in this case.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，您可以遵循的一个简单规则是将每个实现所需的所有变量和函数定义为对象的属性。我们的代码是可重用的，不会污染全局命名空间，除了为我们的模块定义一个单一变量名，例如在本例中是
    `simpleguid`。
- en: We can access the Module properties internally, either by using the `this` keyword,
    such as `this.guid`, or using the full name of the Module such as `simpleguid.guid`.
    In order to use the above Module in our code, we just need to access its property
    by using its name. For example, calling the `simpleguid.getNext()` method will
    return to our code the next-in-order numeric guid and also change the Module's
    state by increasing the internal counter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `this` 关键字（例如 `this.guid`）或使用模块的全名（例如 `simpleguid.guid`）在内部访问模块属性。为了在我们的代码中使用上述模块，我们只需通过其名称访问其属性。例如，调用
    `simpleguid.getNext()` 方法将向我们的代码返回下一个顺序数字 guid，并通过增加内部计数器改变模块的状态。
- en: One of the negatives of this pattern is that it does not provide any privacy
    to the internal parts of the Module. All the internal parts of the Module can
    be accessed and be overridden by external code, even though we ideally prefer
    to only expose the `simpleguid.init()` and `simpleguid.getNext()` methods. There
    are several naming conventions that describe prepending or appending an underscore
    (_) to the names of properties that are intended only for internal use, but this
    technically doesn't fix this disadvantage.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的一个负面方面是它不提供对模块内部部分的任何隐私。模块的所有内部部分都可以被外部代码访问和覆盖，即使我们理想地只希望公开 `simpleguid.init()`
    和 `simpleguid.getNext()` 方法。有几种命名约定描述了将下划线 (_) 添加到仅用于内部使用的属性名称的开头或结尾，但从技术上讲，这并不能解决这个缺点。
- en: Another disadvantage is that writing a big Module using an object literal can
    easily get tiring. It's true that JavaScript developers are used to end their
    variables and function definitions with semicolons (`;`), and trying to write
    a big Module using commas (`,`) after each property can easily lead to syntactic
    errors.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个缺点是，使用对象字面量编写一个大型模块很容易让人感到疲倦。 JavaScript 开发人员习惯于在变量和函数定义后加上分号 (`;`)，尝试使用逗号
    (`,`) 在每个属性后编写一个大型模块很容易导致语法错误。
- en: 'Even though this pattern makes it easy to declare nested Namespaces for a Module,
    it can also lead to big code structures with bad readability in case we need several
    levels of nesting. For example, let''s take a look at the following skeleton of
    a Todo application:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管此模式使得声明模块的嵌套命名空间变得容易，但在需要多层嵌套的情况下，也可能导致代码结构庞大且难以阅读。例如，让我们看一下以下Todo应用程序的框架：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Fortunately, this can be easily fixed by splitting the object literal to multiple
    assignments for each submodule (and preferably to different files) as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这可以通过将对象字面量拆分为每个子模块的多个赋值（最好是到不同的文件）来轻松解决，如下所示：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The Module Pattern
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块模式
- en: The key concept of the basic Module Pattern is to provide a simple function,
    class, or object that the rest of the application can use, through a well-known
    variable name. It enables us to provide a minimal API for a Module, by hiding
    the parts of the implementation that do not need to be exposed. This way, we also
    avoid polluting the Global Namespace with variables and utility functions that
    are needed for internal use by our Module.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 基本模块模式的关键概念是提供一个简单的函数、类或对象，供应用程序的其余部分使用，通过一个众所周知的变量名。它使我们能够为模块提供一个最小的API，通过隐藏不需要暴露的实现部分。这样，我们还可以避免用于我们模块的内部使用的变量和实用函数污染全局命名空间。
- en: The IIFE building block
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IIFE构建块
- en: In this subsection, we will get a small introduction to the IIFE Design Pattern
    since it's an integral part for all the variants of the Module Pattern that we
    will see in this chapter. The **Immediately Invoked Function Expression** (**IIFE**)
    is a very commonly used Design Pattern among JavaScript developers because of
    the clean way in which it isolates blocks of code. In the Module Pattern, an IIFE
    is used to wrap all the implementation in order to avoid polluting the Global
    Namespace and provide privacy to the declarations to the Module itself.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将简要介绍IIFE设计模式，因为它是我们将在本章中看到的所有模块模式变体的一个重要部分。**立即调用函数表达式**（**IIFE**）是JavaScript开发人员中非常常用的设计模式，因为它以清晰的方式隔离了代码块。在模块模式中，IIFE用于包装所有实现，以避免污染全局命名空间，并向模块本身提供声明的隐私。
- en: Each IIFE creates a Closure with the variables and functions declared inside
    it. The Closure that is created enables the exposed function of the IIFE to keep
    references to the rest of the declarations of their environment and access them
    normally when executed from other parts of an implementation. As a result, the
    non-exposed declarations of the IIFE do not leak outside it, but are kept private
    and are accessible only by the functions that are part of the created Closure.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 每个IIFE都创建了一个闭包，其中声明的变量和函数。创建的闭包使得IIFE的公开函数能够在其他部分的实现中被执行时保留对其环境余下声明的引用，并且正常访问它们。因此，IIFE的非公开声明不会泄漏到外部，而是被保持私有，并且只能被创建的闭包中的函数访问。
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on IIFEs and Closures, you can visit [https://developer.mozilla.org/en-US/docs/Glossary/IIFE](https://developer.mozilla.org/en-US/docs/Glossary/IIFE)
    and [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多关于IIFE和闭包的信息，您可以访问[https://developer.mozilla.org/en-US/docs/Glossary/IIFE](https://developer.mozilla.org/en-US/docs/Glossary/IIFE)
    和 [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures)。
- en: 'An IIFE is most commonly used as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: IIFE最常用的用法如下：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Since the preceding code construct might look bizarre on first sight, let''s
    see the pieces that it is composed from. An IIFE is almost equivalent to declaring
    an anonymous function, assigning it to a variable, and then executing it, as shown
    in the following code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前面的代码构造在第一眼看起来可能很奇怪，让我们看看它由哪些部分组成。IIFE几乎等价于声明一个匿名函数，将其赋值给一个变量，然后执行它，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding code, we define a function expression and execute it using
    `tmp()`. Since, in JavaScript, we can use parentheses around an identifier without
    changing its meaning, we can also execute the stored function with `(tmp)();`.
    The final step, in order to turn the preceding code into an IIFE, is to replace
    the `tmp` variable with the actual anonymous function declaration.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了一个函数表达式，并使用`tmp()`执行它。由于在JavaScript中，我们可以在标识符周围使用括号而不改变其含义，我们也可以使用`(tmp)();`来执行存储的函数。最后一步，为了将前面的代码转换为IIFE，是将`tmp`变量替换为实际的匿名函数声明。
- en: As we saw earlier, the only difference is that, with an IIFE, we do need to
    declare a variable just to hold the function itself. We only create an anonymous
    function and invoke it immediately right after defining it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的那样，唯一的区别在于，使用 IIFE 时，我们确实需要声明一个变量来保存函数本身。我们只创建一个匿名函数，并在定义后立即调用它。
- en: Since the creation of an IIFE can be achieved in several ways, which might look
    like an exercise of JavaScript's rules, the community of JavaScript developers
    has concluded to the above code structure as a point of reference for this pattern.
    This way of creating an IIFE is considered to have better readability and is used
    by large libraries and as a result of its adoption, developers can easily recognize
    it inside large JavaScript implementations.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可以通过几种方式创建 IIFE，这可能看起来像是对 JavaScript 规则的一种练习，JavaScript 开发者社区已经得出结论，将上述代码结构作为此模式的参考点。这种创建
    IIFE 的方式被认为具有更好的可读性，并且被大型库所使用，作为其被采用的结果，开发人员可以在大型 JavaScript 实现中轻松识别它。
- en: 'An example of the less-widely-used ways to create an IIFE is the following
    code structure:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 IIFE 的不常用方式的示例是以下代码结构：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The simple IIFE Module Pattern
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单的 IIFE 模块模式
- en: 'Since there is no actual name for this pattern, it is recognized by the fact
    that the defined Module returns a single entity. For reference on how to create
    a reusable library using this pattern, we will rewrite the `simpleguid` Module
    that we saw earlier. The resulting implementation will look as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此模式没有实际名称，因此它被认为是定义的模块返回单个实体的事实。为了参考如何使用此模式创建可重用库，我们将重新编写之前看到的`simpleguid`模块。得到的实现将如下所示：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This pattern uses an IIFE to define an object that acts as the Module container,
    attaches properties to it, and later returns it. The variable `simpleguid` in
    the first line of the preceding code is used as the Namespace of the Module and
    is assigned with the value that is returned by the IIFE. The methods and properties
    that are defined on the returned object are the only exposed parts of the Modules
    and constitute its public API.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式使用 IIFE 定义一个充当模块容器的对象，将属性附加到该对象上，然后将其返回。前面代码的第一行中的变量`simpleguid`用作模块的命名空间，并赋予了
    IIFE 返回的值。在返回对象上定义的方法和属性是模块的唯一公开部分，并构成其公共 API。
- en: Once again, this pattern allows us to use the `this` keyword, in order to access
    the exposed methods and properties of our Module. Furthermore, it also provides
    the flexibility to execute any required initialization code before completing
    the Module's definition.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这种模式允许我们使用`this`关键字，以便访问我们模块的公开方法和属性。此外，它还提供了在完成模块定义之前执行任何所需初始化代码的灵活性。
- en: Unlike the **Object Literal Pattern**, the **Module Pattern** enables us to
    create actual private members in our Modules. Variables declared inside the IIFE,
    that are not attached to the return value, such as the `guid` variable, act as
    private members and are only accessible inside the Module by rest members of the
    created Closure.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 与**对象字面量模式**不同，**模块模式**使我们能够在模块中创建实际的私有成员。在 IIFE 中声明的变量，不附加到返回值的变量，比如`guid`变量，作为私有成员，只能被创建闭包的其他成员在模块内部访问。
- en: 'Lastly, in case we need to define a nested Namespace, all we have to do is
    change the assignment of the value returned by the IIFE. As an example of an application
    structured with submodules, let''s see how we will define the exporting submodule
    for the Todo application skeleton that we saw earlier:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们需要定义嵌套的命名空间，我们所需做的就是更改 IIFE 返回的值的赋值。作为应用程序用子模块结构化的示例，让我们看看如何为之前看到的 Todo
    应用程序骨架定义导出子模块：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Given that our application's Namespace `myTodoApp` has already been defined
    earlier, the `exports` submodule can be defined as a simple property on it. A
    good practice to follow will be to create one file for each one of the above Modules,
    using the IIFEs as the landmarks to split your code. A widely used naming convention,
    which is also suggested by Google's JavaScript Style Guide, is to use lowercase
    naming for your files and add dashes to separate submodules. For example, by following
    this naming convention, the preceding code should be defined in two files named
    as `mytodoapp.js` and `mytodoapp-exports.js` for each Module, respectively.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于我们应用的命名空间`myTodoApp`已在之前定义过了，`exports`子模块可以定义为其上的一个简单属性。要遵循的一个良好实践是为上述每个模块创建一个文件，使用IIFE作为代码拆分的标志。一个广泛使用的命名约定，也是由Google的JavaScript样式指南建议的，是为文件使用小写命名，并使用破折号分隔子模块。例如，按照这个命名约定，前面的代码应该分别定义在名为`mytodoapp.js`和`mytodoapp-exports.js`的两个文件中。
- en: How it is used by jQuery
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它如何被jQuery使用
- en: 'The **Module** **Pattern** is used within jQuery itself, in order to isolate
    the source code of the CSS selector engine (**Sizzle**), which powers the `$()`
    function, from the rest of the jQuery source. From the beginning, Sizzle was a
    big part of the jQuery source, which is currently counting about 2135 lines of
    code; since 2009, it has been split into a separate project named Sizzle, so it
    can be more easily maintained, be developed independently, and be reusable by
    other libraries:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**模块模式**被jQuery本身使用，以隔离CSS选择器引擎（**Sizzle**）的源代码，它为`$()`函数提供支持，并将其与jQuery源代码的其余部分隔离开来。从一开始，Sizzle就是jQuery源代码的一个重要部分，目前大约有2135行代码；自2009年以来，它已经拆分为一个名为Sizzle的独立项目，这样就更容易维护，可以独立开发，并且可以被其他库重复使用：'
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Sizzle** is added to the jQuery''s source inside an IIFE, while its main
    function is returned and assigned to `jQuery.find` for use.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**Sizzle**被添加到jQuery的源码中的IIFE内部，而其主要功能则被返回并分配给`jQuery.find`以供使用。'
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on Sizzle, you can visit [https://github.com/jquery/sizzle](https://github.com/jquery/sizzle).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Sizzle的更多信息，请访问[https://github.com/jquery/sizzle](https://github.com/jquery/sizzle)。
- en: The Namespace Parameter Module variant
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名空间参数模块变体
- en: 'In this variant, instead of returning an object from our IIFE and then assigning
    it to the variable that acts as the Namespace of the Module, we create the Namespace
    and pass it as a parameter to the IIFE itself:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个变体中，我们不是从IIFE返回对象，然后将其分配给充当模块的命名空间的变量，而是创建命名空间并将其作为参数传递给IIFE本身：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The last line of the Module definition tests whether the Module is already defined;
    in case it is not, it initializes it to an empty object literal and assigns it
    to the global object (`window`). In any case, the `simpleguid` parameter in the
    first line of the IIFE will hold the Module's Namespace.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 模块定义的最后一行检查模块是否已经定义；如果没有，则将其初始化为空对象文字，并将其分配给全局对象（`window`）。无论如何，在IIFE的第一行中，`simpleguid`参数都将保存模块的命名空间。
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The above expression is almost equivalent to writing:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 上述表达式几乎等同于写成：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Using the logical OR operator (`||`) makes the expression both shorter and more
    readable. Moreover, this is a pattern that most web developers have learned to
    easily recognize, and it appears in a lot of development patterns and best practices.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用逻辑或运算符（`||`）使表达式更简短且更易读。此外，这是大多数Web开发人员已经学会轻松识别的模式，在许多开发模式和最佳实践中都有出现。
- en: Once again, this pattern allows us to use the `this` keyword to access public
    members from within the exported methods of the Module. At the same time, it allows
    us to keep some functions and variables private, which will be accessible only
    by other functions of the Module.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这种模式允许我们使用`this`关键字从模块的导出方法中访问公共成员。同时，它还允许我们保持一些函数和变量私有，这些私有函数和变量只能被模块的其他函数访问。
- en: Even though it's considered a good practice to define each Module to its own
    JS file, this variant also allows us to split the implementation of large Modules
    to more than one file. This benefit comes as a result of checking whether the
    Module is already defined, before initializing it to an empty object. This might
    be useful in some cases, with the only limitation being that each partial file
    of a Module can access the private members defined in its own IIFE.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 即使将每个模块定义为自己的JS文件被认为是一种良好的做法，此变体还允许我们将大型模块的实现分割到多个文件中。这个好处来自于在将其初始化为空对象之前检查模块是否已经定义。这在某些情况下可能会有用，唯一的限制是每个模块的部分文件都可以访问其自己IIFE中定义的私有成员。
- en: 'Moreover, in order to avoid repetition, we can use a simpler identifier for
    the parameter of the IIFE and write our Module as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了避免重复，我们可以为IIFE的参数使用更简单的标识符，并将我们的模块编写为如下所示：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When it comes to applications with nested Namespaces, this pattern might start
    feeling a little uncomfortable to read. The last line of the Module definition
    will start to get longer for every extra level of nested namespacing that we define.
    For example, let''s see how the `exports` submodule of our Todo application would
    look:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及具有嵌套命名空间的应用程序时，这种模式可能开始感觉阅读起来有点不舒服。每个额外的嵌套命名空间级别所定义的模块定义的最后一行将会变得越来越长。例如，让我们看一下我们的Todo应用程序的`exports`子模块将会是怎样的：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As you can see, each extra level of the nested Namespace needs to be added
    on both sides of the assignment that is passed as a parameter to the IIFE. For
    applications with complex features that lead to multiple levels of nested Namespaces,
    this could lead to Module definitions looking something like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，每个额外级别的嵌套命名空间都需要在作为IIFE参数传递的赋值两侧添加。对于具有复杂功能并导致多级嵌套命名空间的应用程序，这可能导致模块定义看起来像这样：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Moreover, if we want to provide the same safety guaranties, as in the original
    code sample, then we would need to add similar safe checks for each Namespace
    level. With this in mind, the `exports` Module of our Todo application that we
    saw earlier would need to have the following form:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们想要提供与原始代码示例相同的安全保证，那么我们需要为每个命名空间级别添加类似的安全检查。考虑到这一点，我们之前看到的Todo应用程序的`exports`模块将需要具有以下形式：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As seen in the preceding code, we used the comma operator (`,`) to separate
    each namespace existence check and wrapped the whole expression in an extra pair
    of parenthesis so that the whole expression is used as the first parameter of
    the IIFE. Using the comma operator (`,`) to join expressions will lead them to
    be evaluated in order and pass the result of the last evaluated expression as
    the parameter of the IIFE, and that result will be used as the Namespace of the
    Module. Keep in mind that, for each extra nested Namespace level, we need to add
    an extra existence check expression using the comma operator (`,`).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的代码中所示，我们使用逗号运算符（`,`）来分隔每个命名空间的存在检查，并将整个表达式包装在额外的括号对中，以便整个表达式作为IIFE的第一个参数使用。使用逗号运算符（`,`）将表达式连接起来将导致它们按顺序计算，并将最后评估的表达式的结果作为IIFE的参数传递，并且该结果将用作模块的命名空间。请记住，对于每个额外的嵌套命名空间级别，我们都需要使用逗号运算符（`,`）添加额外的存在检查表达式。
- en: 'A disadvantage of this pattern, especially when used for nested namespacing,
    is that the Namespace definition of the Module is at the end of the file. Even
    though it is highly recommended to name your JS files so that they properly represent
    the Modules that they contain, for example, `mytodoapp.exports.js`; not having
    the Namespace near the top of the file can sometimes be counterproductive or misleading.
    An easy work-around for this problem would be to define the Namespace before the
    IIFE and then pass it as a parameter. For example, the preceding code using this
    technique would be transformed to something as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的一个缺点，尤其是在用于嵌套命名空间时，是模块的命名空间定义在文件末尾。即使强烈建议为JS文件命名，以便它们正确表示包含的模块，例如，`mytodoapp.exports.js`；但是，没有命名空间在文件顶部附近有时可能会产生反效果或误导性。解决这个问题的一个简单方法是在IIFE之前定义命名空间，然后将其作为参数传递。例如，使用这种技术的前述代码将转换为以下形式：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The IIFE-contained Module variant
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IIFE包含的模块变体
- en: 'Like in the previous variants of the Module Pattern, this variant does not
    actually have a specific variant name, but is recognized by the way the code is
    structured. The key concept of this variant is to move all the Module''s code
    inside the IIFE:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 像在模块模式的以前变体一样，这种变体实际上并没有一个特定的变体名称，但是通过代码结构的方式进行识别。这种变体的关键概念是将所有模块的代码移至IIFE中：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This variant looks very similar to the previous one and mainly differs in the
    way that the Namespace is created. First of all, it keeps the Namespace check
    and initialization near the top of the Module, like a heading, making our code
    more readable regardless of whether we use a separate file for the Module or not.
    Like other variants of the Module Pattern, it supports private members for our
    Modules and also allows us to use the `this` keyword to access public methods
    and properties, making our code look more object-oriented.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这种变体看起来与前一种非常相似，主要区别在于命名空间的创建方式。首先，它将命名空间检查和初始化保持在模块的顶部附近，就像一个标题，使得我们的代码更具可读性，无论我们是否为模块使用单独的文件。与模块模式的其他变体一样，它支持模块的私有成员，并且还允许我们使用`this`关键字来访问公共方法和属性，使得我们的代码看起来更符合面向对象的特性。
- en: 'Regarding implementations with nested Namespaces, the code structure of the
    `exports` submodule of our Todo application skeleton will look as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 关于具有嵌套命名空间的实现，我们的待办应用程序骨架的`exports`子模块的代码结构如下所示：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As seen in the preceding code, we also borrowed the Namespace definition checks
    from the previous variant and, likewise, applied it to every level of nested namespacing.
    Even though this is not absolutely necessary, it brings the benefits that we discussed
    earlier such as enabling us to split a Module definition into several files and
    even results in a more error-tolerant implementation regarding the import order
    of the application's Modules.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，我们还从以前的变体中借用了命名空间定义检查，并同样将其应用到嵌套命名空间的每个级别。即使这并非绝对必要，但它带来了我们之前讨论过的好处，比如使我们能够将模块定义分割为多个文件，并且甚至导致应用程序模块导入顺序方面的实现更容错。
- en: The Revealing Module Pattern
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 揭示模块模式
- en: 'The **Revealing Module Pattern** is a variant of the **Module Pattern** with
    a known and widely recognized name. What makes this pattern special is that it
    combines the best parts of the **Object Literal Pattern** and the **Module Pattern**.
    All the members of the Module are declared inside an IIFE, which at the end, returns
    an **Object Literal** containing only the public members of the Module and is
    assigned to the variable that acts as our Namespace:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**揭示模块模式**是**模块模式**的一种变体，具有一个广为人知和认可的名称。使得这种模式特殊的是它结合了**对象字面量模式**和**模块模式**的最佳部分。模块的所有成员都声明在一个IIFE内部，最终返回一个仅包含模块公共成员的**对象字面量**，并分配给作为我们命名空间的变量：'
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: One of the main benefits of this pattern that differentiates it from other variants
    is that it allows us to write all the code of our Module inside the IIFE, just
    like we would if they would be declared on the **Global Namespace**. Moreover,
    this pattern does not require any variation on the way that the public and private
    members are declared, making the code of the Module look uniform.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式与其他变体区别最大的一个主要好处是它允许我们像在**全局命名空间**中声明代码一样，在IIFE内部编写所有模块的代码。此外，这种模式不需要在声明公共和私有成员的方式上做任何变化，使得模块代码看起来统一。
- en: Since the returned Object Literal defines the publicly available members of
    the Module, it is also a convenient easy way to inspect its public API, even if
    it is written by someone else. Moreover, in case we need to expose a private method
    on our Module's API, all we need to do is add an extra property to the returned
    Object Literal without changing any part of its definition. Additionally, the
    use of an Object Literal enables us to change the exposed identifiers for the
    Module's API, without changing the names used by the Module's implementation internally.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于返回的对象字面量定义了模块的公开成员，因此这也是一种方便的方法来检查其公共API，即使它是由其他人编写的。此外，如果我们需要在模块的API中公开一个私有方法，我们只需向返回的对象字面量中添加一个额外的属性，而无需更改其定义的任何部分。此外，使用对象字面量使我们能够更改模块API的公开标识符，而不需要更改模块内部实现使用的名称。
- en: Even if this is not clearly visible, the `this` keyword can be used for calls
    between the public members of the Module. Unfortunately, using the `this` keyword
    *is discouraged* for this pattern, since it breaks the uniformity of the function
    declarations and can easily lead to errors, especially when changing the visibility
    of a public method to private.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这不太明显，`this`关键字也可以用于模块的公共成员之间的调用。不幸的是，*对于此模式而言，使用`this`关键字是不鼓励的*，因为它会破坏函数声明的统一性，并且很容易导致错误，特别是在将公共方法的可见性更改为私有时。
- en: 'Since the Namespace definition is kept outside the body of the IIFE, this pattern
    clearly separates the Namespace definition from the actual implementation of the
    Module. Using this pattern to define a Module in a nested Namespace does not affect
    the Module''s implementation, which will not look different at any point from
    a top-level Namespace Module. Rewriting the `exports` submodule of our Todo skeleton
    application using this pattern will make it look like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于命名空间定义被保留在 IIFE 的体外，这种模式清晰地将命名空间定义与模块的实际实现分开。在嵌套命名空间中使用此模式来定义模块不会影响模块的实现，任何时候它都不会与顶级命名空间模块有所不同。重写我们的
    Todo 骨架应用程序的`exports`子模块，使用此模式将使其看起来像这样：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As a result of this separation, we have less code repetition and we can easily
    change the Namespace of a Module without affecting its implementation at all.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种分离，我们减少了代码重复，并且可以轻松地更改模块的命名空间，而不会对其实现造成任何影响。
- en: Using ES5 Strict Mode
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ES5 严格模式
- en: A small but precious addition to all the Module Patterns that use IIFEs as their
    basic building blocks, is the use of **Strict Mode** for JavaScript execution.
    This was standardized in the fifth edition of JavaScript, and is an opt-in execution
    mode with slightly different semantics, in order to prevent some of the common
    pitfalls of JavaScript, but also having backwards compatibility in mind.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有将 IIFE 作为其基本构建块的模块模式的一个小但宝贵的补充，是使用**严格模式**来执行 JavaScript。这在 JavaScript 的第五版中标准化，是一种选择性的执行模式，具有略微不同的语义，以防止
    JavaScript 的一些常见陷阱，但也考虑了向后兼容性。
- en: Under this mode, the JavaScript runtime engine will prevent you from accidentally
    creating a global variable and polluting the Global Namespace. Even in not-so-large
    applications, it is quite possible that a `var` declaration before the initial
    assignment of a variable can be missing, automatically promoting that to a global
    variable. To prevent this case, strict mode throws an error in case an assignment
    is issued to an undeclared variable. The following image show the error that is
    thrown by Firefox and Chrome when a Strict Mode violation happens.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在此模式下，JavaScript 运行时引擎将防止您意外创建全局变量并污染全局命名空间。即使在不是特别大的应用程序中，也很有可能在变量的初始赋值之前缺少`var`声明，自动将其提升为全局变量。为了防止这种情况，严格模式在向未声明的变量发出赋值时会抛出错误。以下图像显示了
    Firefox 和 Chrome 在发生严格模式违规时抛出的错误。
- en: '![Using ES5 Strict Mode](img/00018.jpeg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![使用 ES5 严格模式](img/00018.jpeg)'
- en: This mode can be enabled by adding the `"use strict";` or `'use strict';` statement
    before any other statements. Even though this can be enabled on the global scope,
    it is highly recommended that you enable it only inside the scope of a function.
    Enabling it on the global scope might make third-party libraries that are non-strict-mode
    compliant stop working or misbehave. On the other hand, the best place to enable
    Strict Mode is inside the IIFE of a Module. The Strict Mode will be recursively
    applied to all nested Namespaces, methods, and functions of that IIFE.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在任何其他语句之前添加`"use strict";`或`'use strict';`语句来启用此模式。尽管可以在全局范围内启用它，但强烈建议仅在函数范围内启用它。在全局范围内启用它可能会使不符合严格模式的第三方库停止工作或行为异常。另一方面，启用严格模式的最佳位置是在模块的
    IIFE 内部。严格模式将递归地应用于该 IIFE 的所有嵌套命名空间、方法和函数。
- en: Note
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on JavaScript's strict execution mode, you can visit [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 JavaScript 严格执行模式的更多信息，您可以访问 [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode)。
- en: Introducing ES6 Modules
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入 ES6 模块
- en: Even though JavaScript initially had no built-in packaging and namespacing support
    like other programming languages, web developers filled the gaps by defining and
    adopting some design patterns for this purpose. These software development practices
    worked around the missing features of JavaScript and allowed large and scalable
    implementations of complex applications on a programming language that some years
    ago was mostly used for form validation.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 JavaScript 最初没有像其他编程语言一样内置的打包和命名空间支持，但 Web 开发人员通过定义并采用一些设计模式来填补这些空白。这些软件开发实践解决了
    JavaScript 缺失的功能，并允许在这种一些年前大多用于表单验证的编程语言上进行大规模和可扩展的复杂应用程序实现。
- en: This was until the 6th version of JavaScript, commonly referred to as ES6, was
    released as a standard on June 2015 and introduced the concept of Modules as part
    of the language.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 直到 2015 年 6 月作为标准发布的 JavaScript 第 6 版（通常称为 ES6），引入了模块的概念作为语言的一部分。
- en: Note
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: ES6 is an abbreviation of ECMAScript 6th edition, which is also referred to
    as Harmony or ECMAScript 2015, where ECMAScript is the term that is used for the
    standardization process of JavaScript. The specification can be found at [http://www.ecma-international.org/ecma-262/6.0/index.html#sec-modules](http://www.ecma-international.org/ecma-262/6.0/index.html#sec-modules).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 是 ECMAScript 第 6 版的缩写，也称为 Harmony 或 ECMAScript 2015，其中 ECMAScript 是 JavaScript
    的标准化过程使用的术语。规范可在 [http://www.ecma-international.org/ecma-262/6.0/index.html#sec-modules](http://www.ecma-international.org/ecma-262/6.0/index.html#sec-modules)
    找到。
- en: 'As an example of ES6 Modules, we will see one of the many ways in which the
    `simpleguid` Module can be written:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 ES6 模块的示例，我们将看到 `simpleguid` 模块的许多编写方式之一：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we save this as a file named `es6simpleguid.js`, then we can import and
    use it in a different file by simply writing the following code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将此保存为名为 `es6simpleguid.js` 的文件，则我们可以通过简单地编写以下代码在不同的文件中导入并使用它：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Since **ES6 Modules** are by default in Strict Mode, writing your Modules today
    using your preferred Module Pattern variant with Strict Mode enabled will make
    your transition to ES6 Modules easier. Some of the above patterns require very
    few changes to achieve this. For example, in the IIFE-contained Module Pattern
    variant, all that is needed is remove the IIFE and the `"use strict";` statement,
    replace the creation of the Module's Namespace with a variable, and use the `export`
    keyword on it.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 **ES6 模块** 默认处于严格模式，因此今天使用首选模块模式变体编写模块，并启用严格模式，将使您更容易过渡到 ES6 模块。上述某些模式需要进行非常少的更改才能实现这一点。例如，在
    IIFE-contained 模块模式变体中，只需要删除 IIFE 和 `"use strict";` 语句，用变量替换模块的命名空间，并在其上使用 `export`
    关键字。
- en: Unfortunately, at the time of writing this book, no browser has 100% support
    for ES6 Modules. As a result, special loaders or tools that transpile ES6 to ES5
    are required so that we can start writing our code using the new features of ES6.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在撰写本书时，没有任何浏览器对 ES6 模块提供 100% 的支持。因此，需要特殊的加载程序或工具将 ES6 转译为 ES5，以便我们可以开始使用
    ES6 的新功能编写我们的代码。
- en: Note
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information, you can visit ES6 Module loader's documentation page at
    [https://github.com/ModuleLoader/es6-module-loader](https://github.com/ModuleLoader/es6-module-loader),
    and Babel transpiler (earlier known as ES6toES5) at [http://babeljs.io/](http://babeljs.io/).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 欲知详情，可访问 ES6 模块加载器的文档页面 [https://github.com/ModuleLoader/es6-module-loader](https://github.com/ModuleLoader/es6-module-loader)，和
    Babel 转译器（之前称为 ES6toES5） [http://babeljs.io/](http://babeljs.io/)。
- en: Using Modules in jQuery applications
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 jQuery 应用程序中使用模块
- en: 'In order to demonstrate how the Module Pattern can lead to a better application
    structure, we will reimplement the dashboard example that we saw in the previous
    chapters. We will include all the functionalities that we have seen until now,
    including the counter of the open information boxes. The HTML and CSS code used
    is exactly the same as in the previous chapter and, as a result, our dashboard
    looks exactly the same as before:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示模块模式如何带来更好的应用程序结构，我们将重新实现前几章中所见的仪表板示例。我们将包括到目前为止所见的所有功能，包括打开信息框的计数器。所使用的
    HTML 和 CSS 代码与前一章完全相同，因此我们的仪表板看起来与以前完全相同：
- en: '![Using Modules in jQuery applications](img/00019.jpeg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![在 jQuery 应用程序中使用模块](img/00019.jpeg)'
- en: For this demonstration, we will refactor our JavaScript code into four small
    Modules using the simple IIFE-contained Module variant. The `dashboard` Module
    will act as the main entry of code execution and also as the central coordination
    point of the dashboard application. The `categories` submodule will be responsible
    for the implementation of the upper-top part of our dashboard. This includes category
    selection, the presentation of appropriate buttons, and the handling of button
    clicks. The `informationBox` submodule will be responsible for the main part of
    our dashboard. It will provide methods to create and remove information boxes
    from the dashboard. Finally, the counter submodule will be responsible for keeping
    the field with the number of the currently open information boxes up-to-date,
    responding to the user actions.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行演示，我们将将我们的 JavaScript 代码重构为四个小模块，使用简单的 IIFE 封装的 Module 变体。`dashboard` 模块将充当代码执行的主要入口，也将充当
    dashboard 应用程序的中央协调点。`categories` 子模块将负责实现我们的 dashboard 顶部的上部分。这包括类别选择，适当按钮的呈现和按钮点击的处理。`informationBox`
    子模块将负责我们的 dashboard 的主要部分。它将提供创建和删除 dashboard 中信息框的方法。最后，计数器子模块将负责保持当前打开的信息框数字段最新，并响应用户操作。
- en: 'A single change that we need to make to the HTML of the page in order to support
    this multimodule architecture is limited to the way in which the JavaScript files
    are included:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这种多模块架构，我们需要对页面的 HTML 中包含 JavaScript 文件的方式做出一些限制：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Tip
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Even if this multifile structure makes the development and debugging processes
    a lot easier, it is recommended that we combine all these files before moving
    our application to a production environment. Several tools specialized for this
    job exist; for example, the very simple and effective grunt-contrib-concat project
    that is available at [https://github.com/gruntjs/grunt-contrib-concat](https://github.com/gruntjs/grunt-contrib-concat).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这种多文件结构使得开发和调试过程变得更加容易，我们仍建议在将应用移至生产环境之前将所有这些文件合并。有几个专门用于此任务的工具存在；例如，非常简单有效的
    grunt-contrib-concat 项目，可在 [https://github.com/gruntjs/grunt-contrib-concat](https://github.com/gruntjs/grunt-contrib-concat)
    获取。
- en: The main dashboard module
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主要的 dashboard 模块
- en: 'The resulting code for the `dashboard` module will look as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`dashboard` 模块的最终代码将如下所示：'
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As we already mentioned, the `dashboard` module will be the central point of
    our application. Since this is the starting point of execution for our application,
    its main duty is to do all the required initializations for itself and each submodule.
    The invocation of the `init()` method is wrapped inside a call to the `$(document).ready()`
    method so that its execution is delayed until the DOM tree of the page is fully
    loaded.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们先前提到的，`dashboard` 模块将是我们应用的中心点。由于这是我们应用执行的起始点，它的主要职责是为自身和每个子模块执行所有必需的初始化。调用
    `init()` 方法被包装在对 `$(document).ready()` 方法的调用内，以便其执行被延迟直到页面的 DOM 树完全加载。
- en: One important thing to note is that, during the initialization, we do a DOM
    traversal in order to find the container element of the dashboard and store it
    to a public property of the Module named `$container`. This element will be used
    by all the methods of the dashboard that need to access the DOM tree, in order
    to scope their code inside that container element, removing the need to constantly
    traverse the whole DOM tree using complex selectors. Keeping references to key
    DOM elements and reusing them in the different submodules, can make the application
    snappier and also lessen the chance of accidentally interfering with the rest
    of the page; thus, leading to less bugs that are also easier to resolve.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，在初始化期间，我们进行 DOM 遍历以找到 dashboard 的容器元素，并将其存储到 Module 的一个公共属性 `$container`
    中。此元素将被 dashboard 的所有需要访问 DOM 树的方法使用，以便将它们的代码范围限定在该容器元素内，避免使用复杂选择器不断遍历整个 DOM 树。保留关键
    DOM 元素的引用并在不同的子模块中重用它们，可以使应用程序更加灵活，并减少意外干扰页面的机会；从而导致更少且更易于解决的错误。
- en: Tip
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Cache elements but avoid memory leaks.**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**缓存元素但避免内存泄漏。**'
- en: Keep in mind that maintaining references to DOM elements that are constantly
    added and removed from the page adds extra complexity to our application. This
    can even lead to memory leaks in case we are accidentally keeping a reference
    to an element that has already been removed from the page. For such elements,
    such as the information boxes, it might be safer and more effective to have delegated
    handling for the events triggered on them and to do a scoped DOM traversal when
    needed, in order to retrieve a jQuery object with fresh references of the elements.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，保持对不断添加和移除页面的 DOM 元素的引用会给我们的应用程序增加额外的复杂性。这甚至可能导致内存泄漏，如果我们不小心保留对已从页面中移除的元素的引用。对于这样的元素，如信息框，更安全、更有效的方法可能是对它们触发的事件进行委派处理，并在需要时进行范围限定的
    DOM 遍历，以检索具有新引用的元素的 jQuery 对象。
- en: The categories module
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类别模块
- en: 'Let''s proceed with the `categories` submodule:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续进行 `categories` 子模块：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This submodule's initialization method uses the reference to the `$container`
    element that the main Module provides and adds two observers to the page. The
    first handles the `change` event on the `<select>` category and calls the `selectCategory()`
    method with the numeric value of the selected category. The `selectCategory()`
    method of this submodule will then handle revealing the appropriate category items,
    decoupling it from the event handling code and making it a reusable functionality
    available to the entire application.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此子模块的初始化方法使用主模块提供的 `$container` 元素的引用，并向页面添加了两个观察者。第一个处理 `<select>` 类别上的 `change`
    事件，并调用 `selectCategory()` 方法，传递所选类别的数值。该子模块的 `selectCategory()` 方法然后将处理显示适当的类别项，将其与事件处理代码解耦，并使其成为整个应用程序可重用的功能。
- en: Right after this, we create a single **Delegated Event Observer** that handles
    the `click` event on the `<button>` category item. It extracts the text of the
    `<button>` pressed and calls the `openNew()` method of the `informationBox` submodule
    that contains all the implementation related to information boxes. In a non-demo
    grade application, a parameter to such a method would probably be an identifier
    instead of a text value that would be used to retrieve more details from a remote
    server.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们创建了一个单一的**委托事件观察者**，处理 `<button>` 类别项上的 `click` 事件。它提取了按下的 `<button>`
    的文本，并调用包含所有与信息框相关的实现的 `informationBox` 子模块的 `openNew()` 方法。在非演示级别的应用程序中，此类方法的参数可能是一个标识符，而不是用于从远程服务器检索更多详细信息的文本值。
- en: The informationBox module
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信息框模块
- en: 'The `informationBox` submodule that contains the implementation parts related
    to the main area of our dashboard has the following form:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 包含与我们仪表板主要区域相关的实现部分的 `informationBox` 子模块具有以下形式：
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The first thing that this submodule's initialization code does is retrieve and
    store a reference of the container that holds the information boxes to the `$boxContainer`
    variable, using the `$container` property of the dashboard for scoping.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此子模块初始化代码的第一件事是使用仪表板的 `$container` 属性来检索并存储容纳信息框的容器的引用到 `$boxContainer` 变量中，从而进行作用域限定。
- en: The `openNew()` method is responsible for creating the HTML required for a new
    information box and adding it to the dashboard using the `$boxContainer` variable,
    which acts like a private member of the Module, and is used for caching the reference
    of the previously assigned DOM element. This is a good practice that can improve
    the application's performance, since the stored element is never removed from
    the page and is used during the initialization and the `openNew()` methods of
    the Module. This way, we no longer need to execute slow DOM traversals every time
    the `openNew()` method is called.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`openNew()` 方法负责创建新信息框所需的 HTML，并使用 `$boxContainer` 变量将其添加到仪表板中，该变量像模块的私有成员一样，用于缓存先前分配的
    DOM 元素的引用。这是一个很好的实践，可以提高应用程序的性能，因为存储的元素从未从页面中移除，并且在初始化和 `openNew()` 方法调用时都会使用。这样，我们就不再需要在每次调用
    `openNew()` 方法时执行缓慢的 DOM 遍历了。'
- en: The `close()` method, on the other hand, is responsible for removing an existing
    information box from the dashboard. It receives a jQuery composite collection
    object as a parameter related to the target information box, which is based on
    the way that the `$.fn.closest()` method works, and can either be the box element
    container or any of its descendants.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`close()` 方法负责从仪表板中移除现有的信息框。它接收一个与目标信息框相关的 jQuery 组合集合对象作为参数，这是基于 `$.fn.closest()`
    方法的工作方式，可以是框元素容器或其任何后代。
- en: Tip
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Implementations of methods that provide flexibility regarding the way that they
    can be called can make them usable by more parts of a large application. The next
    logical step for this method, which is left as an exercise to the reader, would
    be to make it accept as a parameter, the index, or an identifier of the information
    box that needs to be closed.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 提供灵活性的方法实现方式可以使它们被大型应用程序中的更多部分使用。对于此方法的下一个逻辑步骤，留给读者作为练习的是使其接受参数，即需要关闭的信息框的索引或标识符。
- en: The counter module
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计数器模块
- en: 'Lastly, here is how we rewrote the `counter` implementation, which we saw in
    the previous chapter, as an independent submodule:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里是我们如何将我们在上一章中看到的`counter`实现重写为一个独立的子模块：
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: For this submodule, we are using the `$counter` variable as a private member
    to cache a reference to the element that displays the count. Another private member
    of the Module is the `dashboardItemCounter` variable, which at any point of time
    will hold the number of visible information boxes in the dashboard. Keeping such
    information on the members of our Modules reduces the times we need to reach the
    DOM tree to extract information on the state of the application, making the implementation
    more efficient.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此子模块，我们使用`$counter`变量作为私有成员来缓存对显示计数的元素的引用。模块的另一个私有成员是`dashboardItemCounter`变量，它在任何时间点都将保存仪表板中可见信息框的数量。将这些信息保存在模块的成员中可以减少我们需要到达
    DOM 树以提取应用程序状态信息的次数，从而使实现更加高效。
- en: Tip
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Preserving the state of the application in the properties of JavaScript objects
    or Modules instead of reaching the DOM to extract them, is a very good practice
    that makes the application's architecture more object-oriented, and is also adopted
    by most of the modern web development frameworks.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序的状态保留在 JavaScript 对象或模块的属性中，而不是到 DOM 中提取它们，这是一种非常好的做法，可以使应用程序的架构更加面向对象，并且也被大多数现代
    Web 开发框架采纳。
- en: During the initialization of the Module, we are giving an initial value to our
    counter variable so that we are no longer dependent on the initial HTML of the
    page and have a more robust implementation. Moreover, we are attaching two **Delegated
    Event Observers**, one for clicks that will lead to the creation of new information
    boxes and another one for clicks that will close them.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块初始化期间，我们给计数器变量赋予一个初始值，以便我们不再依赖页面的初始 HTML，并且拥有更健壮的实现。此外，我们附加了两个**委托事件观察器**，一个用于导致创建新信息框的点击，另一个用于关闭它们的点击。
- en: Overview of the implementation
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现概述
- en: With the above, we completed the rewrite of the dashboard skeleton application
    to a modular architecture. All the available actions are exposed as public methods
    of each of our submodules that can be invoked programmatically and this way they
    are decoupled from the events that trigger them.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以上内容，我们将仪表板骨架应用程序重写为模块化架构。所有可用操作都公开为每个子模块的公共方法，可以通过编程方式调用，这样它们就与触发它们的事件解耦了。
- en: A good exercise for the reader would be to promote the decoupling even further,
    by also adopting the Publisher/Subscriber Pattern in the above implementation.
    The fact that the code is already structured into Modules will make such change
    a lot easier to implement.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对于读者来说，一个很好的练习是通过在上述实现中采用发布者/订阅者模式来进一步推动解耦。代码已经结构化为模块，这样的更改将更容易实现。
- en: Another part that can be implemented in a different way is the way in which
    the submodules are initialized. Instead of explicitly orchestrating the initialization
    of each Module in our main dashboard Module, we could instead initialize each
    submodule on its own by wrapping the invocation of the `init()` method in a `$(document).ready()`
    call and issuing its initialization right after its declaration. On the other
    hand, not having a central point to coordinate the initializations and relying
    on page events can feel less deterministic. Another way to implement it would
    be like the Publisher/Subscriber Pattern, by exposing a `registerForInit()` method
    on our main Module, which would keep track of the Modules that have been requested
    to be initialized using an array.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可以以不同方式实现的部分是子模块的初始化方式。我们可以不再明确地在主仪表板模块中协调每个模块的初始化，而是通过在`$(document).ready()`调用中包装`init()`方法的调用并在声明后立即进行初始化来独立地初始化每个子模块。另一方面，没有一个中心点来协调初始化并依赖页面事件可能会感觉不够确定。另一种实现方式可能是像发布者/订阅者模式一样，在我们的主模块上暴露一个`registerForInit()`方法，它将通过数组跟踪已被请求进行初始化的模块。
- en: Note
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more jQuery code organization tips, you can visit [http://learn.jquery.com/code-organization/concepts/](http://learn.jquery.com/code-organization/concepts/).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多jQuery代码组织技巧，您可以访问[http://learn.jquery.com/code-organization/concepts/](http://learn.jquery.com/code-organization/concepts/)。
- en: Summary
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned the concepts of Modules and Namespaces and also
    the benefits that come from their adoption in large applications. We had an in-depth
    analysis of the most widely adopted patterns and compared their benefits and limitations.
    We learned by example how to develop Modules using the Object Literal Pattern,
    the variants of the Module Pattern, and the Revealing Module Pattern.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章节中，我们学习了模块和命名空间的概念，还有它们在大型应用中采用时带来的好处。我们深入分析了最广泛采用的模式，并比较了它们的优点和局限性。我们通过示例学习了如何使用对象字面量模式、模块模式的变体以及揭示模块模式来开发模块。
- en: We continued with a small introduction to ES5's Strict Mode and saw how it can
    benefit today's Modules. Then we proceeded by learning some details about the
    standardized but not yet widely supported **ES6 Modules**. Lastly, we saw how
    the architecture of the dashboard application can change dramatically after using
    the Module Pattern in its implementation.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续简要介绍ES5的严格模式，并看到它如何有益于当今的模块。然后我们学习了一些关于标准化但尚未广泛支持的**ES6模块**的细节。最后，我们看到在实施中使用模块模式后，仪表板应用程序的架构如何出现了巨大变化。
- en: Now that we have completed our introduction on how to use Modules and Namespaces,
    we can move on to the next chapter where we will be introduced to the facade pattern.
    In the next chapter, we will learn about the philosophy of facades and the uniform
    way that they define how code abstractions should be created so that they are
    easily understandable and reusable by other developers.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了关于如何使用模块和命名空间的介绍，我们可以继续下一章节，在下一章节中我们将介绍外观模式。在下一章节中，我们将学习关于外观的哲学，以及它们定义代码抽象的统一方式，使其易于其他开发人员理解和重复使用。
