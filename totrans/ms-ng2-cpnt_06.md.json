["```js\n@Injectable()\nconstructor(@Inject(DataProvider) dataProvider,\n                   @Inject(UserService) userService) {\nexport class ActivityService {\n    // We're exposing a replay subject that will emit events \n    // whenever the activities list change\n this.change = new ReplaySubject(1);\n    this.dataProvider = dataProvider;\n    this.userService = userService;\n    this.activities = [];\n\n    // We're creating a subscription to our datastore to get \n    // updates on activities\n    this.activitiesSubscription = this.dataProvider.getLiveChanges()\n      .map((change) => change.doc)\n .filter((document) => document.type === 'activity')\n      .subscribe((changedActivity) => {\n        this.activities = this.activities.slice();\n        // Since activities can only be added we can assume that \n        // this change is a new activity\n this.activities.push(changedActivity);\n        // Sorting the activities by time to make sure there's no \n        // sync issue messing with the ordering\n        this.activities.sort((a, b) => \n          a.time > b.time ? -1 : a.time < b.time ? 1 : 0);\n this.change.next(this.activities);\n      });\n  }\n\n  // This method is logging a new activity\n  logActivity(subject, category, title, message) {\n    // Using the DataProvider to create a new document in our\n    // datastore\n this.dataProvider.createOrUpdateDocument({\n type: 'activity',\n user: this.userService.currentUser,\n time: new Date().getTime(),\n subject,\n category,\n title,\n message\n });\n  }\n}\n```", "```js\n@Component({\n  selector: 'ngc-app',\n  …\n providers: [ProjectService, UserService, ActivityService]\n})\n```", "```js\n...\nimport {ActivityService} from '../activities/activity-service/activity-service';\nimport {limitWithEllipsis} from '../utilities/string-utilities';\n\n@Component({\n  selector: 'ngc-task-list',\n  ...\n})\nexport class TaskList {\n  …\n // Subject for logging activities\n @Input() activitySubject;\n\n  onTaskUpdated(task, updatedData) {\n    ...\n // Creating an activity log for the updated task\n this.activityService.logActivity(\n this.activitySubject.id,\n 'tasks',\n 'A task was updated',\n 'The task \"${limitWithEllipsis(oldTask.title, 30)}\" was updated on #${this.activitySubject.document.data._id}.'\n );\n  }\n\n  onTaskDeleted(task) {\n    ...\n // Creating an activity log for the deleted task\n this.activityService.logActivity(\n this.activitySubject.id,\n 'tasks',\n 'A task was deleted',\n 'The task \"${limitWithEllipsis(removed.title, 30)}\" was deleted from #${this.activitySubject.document.data._id}.'\n );\n  }\n\n  addTask(title) {\n    ...\n // Creating an activity log for the added task\n this.activityService.logActivity(\n this.activitySubject.id,\n 'tasks',\n 'A task was added',\n 'A new task \"${limitWithEllipsis(title, 30)}\" was added to #${this.activitySubject.document.data._id}.'\n );\n  }\n  ...\n}\n```", "```js\n<ngc-task-list [tasks]=\"project.tasks\"\n [activitySubject]=\"project\"\n             (tasksUpdated)=\"updateTasks($event)\"></ngc-task-list>\n```", "```js\n<?xml version=\"1.0\" encoding=\"utf-8\"?>  \n<svg version=\"1.1\"  \n     width=\"20px\" height=\"20px\">\n  <circle cx=\"10\" cy=\"10\" r=\"10\" fill=\"black\" />\n</svg>\n```", "```js\n<!doctype html>\n<title>Minimalistic Circle</title>\n<svg width=\"20px\" height=\"20px\">\n  <circle id=\"circle\" cx=\"10\" cy=\"10\" r=\"10\" fill=\"black\">\n</svg>\n<script>\n  document\n    .getElementById('circle')\n    .addEventListener('click', function(event) {\n      event.target.setAttribute('fill', 'red');\n    });\n</script>\n```", "```js\n<!doctype html>\n<title>Minimalistic Circle</title>\n<svg width=\"20px\" height=\"20px\">\n  <circle class=\"circle\" cx=\"10\" cy=\"10\" r=\"10\">\n</svg>\n```", "```js\n.circle {\n  fill: black;\n}\n```", "```js\n@Component({\n  selector: 'awesome-circle',\n  template: `\n    <svg [attr.width]=\"size\" [attr.height]=\"size\">\n      <circle [attr.cx]=\"size/2\" [attr.cy]=\"size/2\"\n              [attr.r]=\"size/2\" fill=\"black\" />\n    </svg>\n  `\n})\nexport class AwesomeCircle {\n @Input() size;\n}\n```", "```js\n<awesome-circle [size]=\"20\"></awesome-circle>\n```", "```js\n@Component({\n  selector: '[awesomeCircle]',\n  template: `\n <svg:circle [attr.cx]=\"size/2\" [attr.cy]=\"size/2\"\n [attr.r]=\"size/2\" fill=\"black\" />\n  '\n})\nexport class AwesomeCircle {\n  @Input('awesomeCircle') size;\n}\n\n@Component({\n  selector: 'app'\n  template: `\n   <svg width=\"20\" height=\"20\">\n    <g [awesomeCircle]=\"20\"></g>\n   </svg>\n  `,\n  directives: [AwesomeCircle]\n})\nexport class App {}\n```", "```js\nimport styles from './activity-slider.css!text';\n\n@Component({\n  selector: 'ngc-activity-slider',\n  host: {\n    class: 'activity-slider'\n  },\n styles: [styles],\n encapsulation: ViewEncapsulation.Native,\n  …\n})\nexport class ActivitySlider {\n  // The input expects a list of activities\n @Input() activities;\n  // If the selection of date range changes within our slider \n  // component, we'll emit a change event\n @Output() selectionChange = new EventEmitter();\n\n  constructor(@Inject(ElementRef) elementRef) {\n    // We'll use the host element for measurement when drawing\n    // the SVG\n this.sliderElement = elementRef.nativeElement;\n    // The padding on each side of the slider\n this.padding = 20;\n  }\n\n  ngAfterViewInit() {\n    // We'll need a reference to the overlay rectangle so we can \n    // update its position and width\n this.selectionOverlay = this.sliderElement\n .shadowRoot.querySelector('.selection-overlay');\n  }\n}\n```", "```js\n.slide {\n  fill:#f9f9f9;\n}\n\n.activity {\n  fill:#3699cb;\n}\n\n.time {\n  fill:#bbb;\n  font-size:14px;\n}\n\n.tick {\n  stroke:#bbb;\n  stroke-width:2px;\n  stroke-dasharray:3px;\n}\n\n.selection-overlay {\n  fill:#d9d9d9;\n}\n```", "```js\nthis.sliderElement = elementRef.nativeElement;\n```", "```js\n// Getting the total available width of the slider\ntotalWidth() {\n return this.sliderElement.clientWidth - this.padding * 2;\n}\n\n// Projects a time stamp into percentage for positioning\nprojectTime(time) {\n let position = this.padding +\n (time - this.timeFirst) / this.timeSpan * this.totalWidth();\n return position / this.sliderElement.clientWidth * 100;\n}\n\n// Projects a pixel value back to a time value. This is required \n// for calculating time stamps from user selection.\nprojectLength(length) {\n return this.timeFirst + (length - this.padding) / this.totalWidth() * this.timeSpan;\n}\n\n```", "```js\nngOnChanges(changes) {\n  // If the activities input changes we need to re-calculate and \n  // re-draw\n  if (changes.activities && changes.activities.currentValue) {\n    const activities = changes.activities.currentValue;\n    // For later calculations we set aside the times of the \n    // first and the last activity\n    if (activities.length === 1) {\n      // If we only have one activity we use the same time for \n      // first and last\n this.timeFirst = this.timeLast = activities[0].time;\n    } else if (activities.length > 1) {\n      // Take first and last time\n this.timeFirst = activities[activities.length - 1].time;\n this.timeLast = activities[0].time;\n    } else {\n      // No activities yet, so we use the current time for both \n      // first and last\n this.timeFirst = this.timeLast = new Date().getTime();\n    }\n\n    // The time span is the time from the first activity to the \n    // last activity. We need to limit to lower 1 for not messing \n    // up later calculations.\n this.timeSpan = Math.max(1, this.timeLast - this.timeFirst);\n  }\n}\n```", "```js\n<svg width=\"100%\" height=\"70px\">\n  …\n  <rect x=\"0\" y=\"30\" width=\"100%\" height=\"40\" \n        class=\"slide\"></rect>\n  <rect *ngFor=\"let activity of activities\"\n [attr.x]=\"projectTime(activity.time) + '%'\"\n        height=\"40\" width=\"2px\" y=\"30\" class=\"activity\"></rect>\n</svg>\n```", "```js\nngOnChanges(changes) {\n  // If the activities input changes we need to re-calculate and \n  // re-draw\n  if (changes.activities && changes.activities.currentValue) {\n    ...\n    // Re-calculate the ticks that we display on top of the slider\n this.computeTicks();\n  ...\n}\n\n// This function computes 5 ticks with their time and position on \n// the slider\ncomputeTicks() {\n const count = 5;\n const timeSpanTick = this.timeSpan / count;\n this.ticks = Array.from({length: count}).map(\n (element, index) => {\n return this.timeFirst + timeSpanTick * index;\n });\n}\n...\n```", "```js\n...\n<g *ngFor=\"let tick of ticks\">\n  <text [attr.x]=\"projectTime(tick) + '%'\" y=\"14\" class=\"time\"> \n    {{tick | calendarTime}}</text>\n  <line [attr.x1]=\"projectTime(tick) + '%'\"\n [attr.x2]=\"projectTime(tick) + '%'\"\n        y1=\"30\" y2=\"70\" class=\"tick\"></line>\n</g>\n...\n```", "```js\nngOnChanges(changes) {\n  // If the activities input changes we need to re-calculate and \n  // re-draw\n  if (changes.activities && changes.activities.currentValue) {\n    ...\n    // Setting the selection to the full range\n this.selection = {\n start: this.timeFirst,\n end: this.timeLast\n };\n // Selection changed so we need to emit event\n this.selectionChange.next(this.selection);\n  }\n}\n```", "```js\n  <rect *ngIf=\"selection\"\n [attr.x]=\"projectTime(selection.start) + '%'\"\n [attr.width]=\"projectTime(selection.end) - projectTime(selection.start) + '%'\"\n        y=\"30\" height=\"40\" class=\"selection-overlay\"></rect>\n```", "```js\n...\n// If the component receives a mousedown event, we need to start a \n// new selection\n@HostListener('mousedown', ['$event'])\nonMouseDown(event) {\n  // Starting a new selection by setting selection start and end \n  // to the projected time of the clicked position.\n this.selection.start = this.selection.end = \n this.projectLength(event.offsetX);\n  // Selection changed so we need to emit event an\n this.selectionChange.next(this.selection);\n  // Setting a flag so we know that the user is currently moving \n  // the selection\n this.modifySelection = true;\n}\n\n// We also need to track mouse moves within our slider component\n@HostListener('mousemove', ['$event'])\nonMouseMove(event) {\n  // We should only modify the selection if the component is in \n  // the correct mode\n if (this.modifySelection) {\n // Update the selection end with the projected time from the \n // mouse coordinates\n this.selection.end = Math.max(this.selection.start, \n this.projectLength(event.offsetX));\n // Selection changed so we need to emit event an\n this.selectionChange.next(this.selection);\n    // To prevent side effects, we should stop propagation and \n    // prevent browser default\n    event.stopPropagation();\n    event.preventDefault();\n  }\n}\n\n// If the user is releasing the mouse button, we should stop the \n// modify selection mode\n@HostListener('mouseup')\nonMouseUp() {\n this.modifySelection = false;\n}\n\n// If the user is leaving the component with the mouse, we should \n// stop the modify selection mode\n@HostListener('mouseleave')\nonMouseLeave() {\n this.modifySelection = false;\n}\n...\n```", "```js\n<img [attr.src]=\"activity.user.pictureDataUri\"\n [attr.alt]=\"activity.user.name\"\n     class=\"activity__user-image\">\n<div [class.activity__info--align-right]=\"isAlignedRight()\"\n     class=\"activity__info\">\n  <h3 class=\"activity__title\">{{activity.title}}</h3>\n  <p class=\"activity__author\">\n by {{activity.user.name}} {{activity.time | fromNow}}\n  </p>\n  <p>{{activity.message}}</p>\n</div>\n```", "```js\nimport {FromNowPipe} from '../../pipes/from-now';\n\n@Component({\n  selector: 'ngc-activity',\n  …\n  // We are using the FromNow pipe to display relative times \n  // within our template\n pipes: [FromNowPipe]\n})\nexport class Activity {\n @Input() activity;\n  // Input that should be a string 'left' or 'right' and will \n  // determine the activity alignment using CSS\n @Input() alignment;\n @Input() @HostBinding('class.activity--start-mark') startMark;\n @Input() @HostBinding('class.activity--end-mark') endMark;\n\n  // Function with that will tell us if the activity should be \n  // aligned to the right. It's used for setting a modifier class \n  // on the info element.\n isAlignedRight() {\n return this.alignment === 'right';\n }\n}\n```", "```js\n@Component({\n  selector: 'ngc-activities',\n  ...\n directives: [ActivitySlider, Activity]\n})\nexport class Activities {\n @Input() activitySubject;\n\n  constructor(@Inject(ActivityService) activityService) {\n    this.activityService = activityService;\n  }\n\n  ngOnChanges(changes) {\n    if (changes.activitySubject) {\n      // If we have a subscription to the activities service \n      // already we need to unsubscribe first\n      if (this.activitiesChangeSubscription) {\n        this.activitiesChangeSubscription.unsubscribe();\n      }\n\n      // When the project data is updated we need to filter for \n      // activities again\n      this.activitiesChangeSubscription = \n        this.activityService.change.subscribe((activities) => {\n        // Filter for all activities that have the project ID as subject\n this.activities = activities\n .filter((activity) => activity.subject === this.activitySubject.document.data._id);\n this.onSelectionChange();\n      });\n    }\n  }\n```", "```js\n  // If the selection within the activity slider changes, we need \n  // to filter out activities again\n onSelectionChange(selection = this.selection) {\n    this.selection = selection;\n    // Store filtered activities that fall into the date range \n    // selection specified by the slider\n this.selectedActivities = this.selection ? this.activities.filter(\n (activity) => activity.time >= this.selection.start\n && activity.time <= this.selection.end\n );\n }\n\n```", "```js\n  // Get an alignment string based on the index. Activities with \n  // even index get aligned left while odds get aligned right.\n getAlignment(index) {\n return index % 2 === 0 ? 'left' : 'right';\n }\n\n  // Function to determine if an activity index is first\n isFirst(index) {\n return index === 0;\n }\n\n  // Function to determine if an activity index is last\n isLast(index) {\n return index === this.selectedActivities.length - 1;\n }\n\n```", "```js\n  // If the component gets destroyed, we need to unsubscribe from \n  // the activities change observer\n ngOnDestroy() {\n this.activitiesChangeSubscription.unsubscribe();\n }\n}\n```", "```js\n<ngc-activity-slider [activities]=\"activities\"\n (selectionChange)=\"onSelectionChange($event)\">\n</ngc-activity-slider>\n<div class=\"activities__l-container\">\n  <ngc-activity \n *ngFor=\"let activity of selectedActivities, let index = index\"\n [activity]=\"activity\"\n [alignment]=\"getAlignment(index)\"\n [startMark]=\"isLast(index)\"\n [endMark]=\"isFirst(index)\">\n  </ngc-activity>\n</div>\n```"]