<html><head></head><body>
		<div id="_idContainer163">
			<h1 id="_idParaDest-271" class="chapter-number"><a id="_idTextAnchor273"/>11</h1>
			<h1 id="_idParaDest-272"><a id="_idTextAnchor274"/>Reusable Components</h1>
			<p>In this chapter, we will build a checklist component and use various patterns to make it highly reusable but still <span class="No-Break">strongly typed.</span></p>
			<p>We will start by using TypeScript <strong class="bold">generics</strong> to strongly type the data passed to the component. Then, we will use the <strong class="bold">props spreading</strong> pattern to make the component API-flexible, and allow consumers of the component to custom render parts of the component using the <strong class="bold">render props</strong> pattern. After that, we will learn how to make custom hooks and use this to extract logic for checked items and how to make the state within a component controllable to change the <span class="No-Break">component’s behavior.</span></p>
			<p>We’ll cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Creating <span class="No-Break">the project</span></li>
				<li>Using <span class="No-Break">generic props</span></li>
				<li>Using <span class="No-Break">props spreading</span></li>
				<li>Using <span class="No-Break">render props</span></li>
				<li>Adding <span class="No-Break">checked functionality</span></li>
				<li>Creating <span class="No-Break">custom hooks</span></li>
				<li>Allowing the internal state to <span class="No-Break">be controlled</span></li>
			</ul>
			<h1 id="_idParaDest-273"><a id="_idTextAnchor275"/>Technical requirements</h1>
			<p>We will use the following technologies in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li><strong class="bold">Node.js</strong> and <strong class="bold">npm</strong>: You can install them <span class="No-Break">here: </span><a href="https://nodejs.org/en/download/"><span class="No-Break">https://nodejs.org/en/download/</span></a><span class="No-Break">.</span></li>
				<li><strong class="bold">Visual Studio Code</strong>: You can install it <span class="No-Break">here: </span><a href="https://code.visualstudio.com/"><span class="No-Break">https://code.visualstudio.com/</span></a><span class="No-Break">.</span></li>
			</ul>
			<p>All the code snippets in this chapter can be found online <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter11"><span class="No-Break">https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter11</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-274"><a id="_idTextAnchor276"/>Creating the project</h1>
			<p>In this section, we will create<a id="_idIndexMarker868"/> the project for the app we will build and its folder structure. The folder structure will be straightforward because it contains a single page with the checklist component we <span class="No-Break">will build.</span></p>
			<p>We will develop the app using Visual Studio Code as in previous chapters, so open Visual Studio Code and carry out the <span class="No-Break">following steps:</span></p>
			<ol>
				<li>Create the project using Create React App. See <a href="B19051_03.xhtml#_idTextAnchor072"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Setting up React and TypeScript</em>, if you can’t remember the steps <span class="No-Break">for this.</span></li>
				<li>We will style the app with Tailwind CSS, so install this into the project and configure it. See <a href="B19051_05.xhtml#_idTextAnchor127"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">Approaches to Styling Frontends</em>, if you can’t remember the steps <span class="No-Break">for this.</span></li>
			</ol>
			<p>That completes the <span class="No-Break">project setup.</span></p>
			<h1 id="_idParaDest-275"><a id="_idTextAnchor277"/>Using generic props</h1>
			<p>In this section, we’ll take some time<a id="_idIndexMarker869"/> to understand how to create our own generic types and also learn about the <strong class="source-inline">keyof</strong> TypeScript feature, which is useful for generic types. We will use this knowledge to build the first iteration of the checklist component with a generic type for <span class="No-Break">its props.</span></p>
			<h2 id="_idParaDest-276"><a id="_idTextAnchor278"/>Understanding generics</h2>
			<p>We have used generics<a id="_idIndexMarker870"/> throughout this book. For example, the <strong class="source-inline">useState</strong> hook has an optional generic parameter for the type of <span class="No-Break">state variable:</span></p>
			<pre class="source-code">
const [visible, setVisible] = useState<strong class="bold">&lt;boolean&gt;</strong>()</pre>
			<p>Generic parameters in a function allow that function to be reusable with different types and be strongly typed. The following function returns the first element in an array, or <strong class="source-inline">null</strong> if the array is empty. However, the function only works with a <span class="No-Break"><strong class="source-inline">string</strong></span><span class="No-Break"> array:</span></p>
			<pre class="source-code">
function first(array: Array&lt;string&gt;): string | null {
  return array.length === 0 ? null : array[0];
}</pre>
			<p>Generics allows us to make<a id="_idIndexMarker871"/> this function usable with any type <span class="No-Break">of array.</span></p>
			<h3>Generic functions</h3>
			<p>Although we have used generic functions<a id="_idIndexMarker872"/> throughout this book, we haven’t created our own generic function yet. Generic type parameters are defined in angled brackets before the <span class="No-Break">function’s parentheses:</span></p>
			<pre class="source-code">
function someFunc<strong class="bold">&lt;T1, T2, ...&gt;</strong>(...) {
 ...
}</pre>
			<p>The name of a generic type can be anything you like, but it should be meaningful so that it is easy <span class="No-Break">to understand.</span></p>
			<p>Here is a generic version of the function we saw earlier. Now, it can work with arrays containing any type <span class="No-Break">of element:</span></p>
			<pre class="source-code">
function first<strong class="bold">&lt;Item&gt;</strong>(array: Array&lt;<strong class="bold">Item</strong>&gt;): <strong class="bold">Item</strong> | null {
  return array.length === 0 ? null : array[0];
}</pre>
			<p>The function has a single generic parameter called <strong class="source-inline">Item</strong>, which is used in the type of the <strong class="source-inline">array</strong> function parameter, as well as the function’s <span class="No-Break">return type.</span></p>
			<h3>Generic types</h3>
			<p>Custom types<a id="_idIndexMarker873"/> can be generic as well. For a <strong class="source-inline">type</strong> alias, its generic parameters are defined in angled brackets after the <span class="No-Break">type name:</span></p>
			<pre class="source-code">
type TypeName<strong class="bold">&lt;T1, T2, …&gt;</strong> = {
 ...
}</pre>
			<p>For example, the props of a React component can be generic. An example of a generic props type is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
type Props<strong class="bold">&lt;Item&gt;</strong> = {
  items: <strong class="bold">Item</strong>[];
  ...
};</pre>
			<p>The <strong class="source-inline">Props</strong> type has a single generic parameter<a id="_idIndexMarker874"/> called <strong class="source-inline">Item</strong>, which is used in the type of the <span class="No-Break"><strong class="source-inline">items</strong></span><span class="No-Break"> prop.</span></p>
			<h3>Generic React components</h3>
			<p>Generic props can be integrated<a id="_idIndexMarker875"/> into a generic function to produce a generic React component. Here’s an example of a generic <span class="No-Break"><strong class="source-inline">List</strong></span><span class="No-Break"> component:</span></p>
			<pre class="source-code">
type Props<strong class="bold">&lt;Item&gt;</strong> = {
  items: <strong class="bold">Item</strong>[];
};
export function List&lt;<strong class="bold">Item</strong>&gt;({ items }: Props&lt;<strong class="bold">Item</strong>&gt;) {
  ...
}</pre>
			<p>The <strong class="source-inline">items</strong> prop in the <strong class="source-inline">List</strong> component can now have any type, making the component flexible <span class="No-Break">and reusable.</span></p>
			<p>Now that we understand how to create a component with generic props, we will create the first iteration of the <span class="No-Break">checklist component.</span></p>
			<h2 id="_idParaDest-277"><a id="_idTextAnchor279"/>Creating a basic list component</h2>
			<p>We will now start to create<a id="_idIndexMarker876"/> our reusable component. In this iteration, it will be a basic list containing some primary and secondary text obtained from an array <span class="No-Break">of data.</span></p>
			<p>Carry out the <span class="No-Break">following steps:</span></p>
			<ol>
				<li value="1">Start by creating a folder for the component called <strong class="source-inline">Checklist</strong> in the <strong class="source-inline">src</strong> folder. Then, create a file called <strong class="source-inline">Checklist.tsx</strong> in <span class="No-Break">this folder.</span></li>
				<li>Open <strong class="source-inline">Checklist.tsx</strong> and add the following <span class="No-Break"><strong class="source-inline">Props</strong></span><span class="No-Break"> type:</span><pre class="source-code">
type Props&lt;Data&gt; = {</pre><pre class="source-code">
  data: Data[];</pre><pre class="source-code">
  id: keyof Data;</pre><pre class="source-code">
  primary: keyof Data;</pre><pre class="source-code">
  secondary: keyof Data;</pre><pre class="source-code">
};</pre></li>
			</ol>
			<p>Here is an explanation of <span class="No-Break">each prop:</span></p>
			<ul>
				<li>The <strong class="source-inline">data</strong> prop is the data that drives the items in <span class="No-Break">the list</span></li>
				<li>The <strong class="source-inline">id</strong> prop is the property’s name in each data item that uniquely identifies <span class="No-Break">the item</span></li>
				<li>The <strong class="source-inline">primary</strong> prop is the property’s name in each data item that contains the main text to render in <span class="No-Break">each item</span></li>
				<li>The <strong class="source-inline">secondary</strong> prop is the property’s name in each data item that includes the supplementary text to render in <span class="No-Break">each item</span></li>
			</ul>
			<p>This is the first time we have encountered the <strong class="source-inline">keyof</strong> operator in a type annotation. It queries the type specified after it for the property names and constructs a union type from them, so the type for <strong class="source-inline">id</strong>, <strong class="source-inline">primary</strong>, and <strong class="source-inline">secondary</strong> will be a union type of all the property names for each <span class="No-Break">data item.</span></p>
			<ol>
				<li value="3">Next, start to implement the component function <span class="No-Break">as follows:</span><pre class="source-code">
export function Checklist&lt;Data&gt;({</pre><pre class="source-code">
  data,</pre><pre class="source-code">
  id,</pre><pre class="source-code">
  primary,</pre><pre class="source-code">
  secondary,</pre><pre class="source-code">
}: Props&lt;Data&gt;) {</pre><pre class="source-code">
  return (</pre><pre class="source-code">
    &lt;ul className="bg-gray-300 rounded p-10"&gt;</pre><pre class="source-code">
      {data.map((item) =&gt; {</pre><pre class="source-code">
      })}</pre><pre class="source-code">
    &lt;/ul&gt;</pre><pre class="source-code">
  );</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>The component renders<a id="_idIndexMarker877"/> a gray, unordered list element with rounded corners. We also map over the data items where we will eventually render <span class="No-Break">each item.</span></p>
			<ol>
				<li value="4">We will start by implementing the function inside <strong class="source-inline">data.map</strong>. The function checks whether the unique identifier (<strong class="source-inline">idValue</strong>) is a string or number, and if not, it won’t render anything. The function also checks that the primary text property (<strong class="source-inline">primaryText</strong>) is a string, and again, if not, doesn’t <span class="No-Break">render anything:</span><pre class="source-code">
{data.map((item) =&gt; {</pre><pre class="source-code">
  <strong class="bold">const idValue = item[id] as unknown;</strong></pre><pre class="source-code">
<strong class="bold">  if (</strong></pre><pre class="source-code">
<strong class="bold">    typeof idValue !== 'string' &amp;&amp;</strong></pre><pre class="source-code">
<strong class="bold">    typeof idValue !== 'number'</strong></pre><pre class="source-code">
<strong class="bold">  ) {</strong></pre><pre class="source-code">
<strong class="bold">    return null;</strong></pre><pre class="source-code">
<strong class="bold">  }</strong></pre><pre class="source-code">
<strong class="bold">  const primaryText = item[primary] as unknown;</strong></pre><pre class="source-code">
<strong class="bold">  if (typeof primaryText !== 'string') {</strong></pre><pre class="source-code">
<strong class="bold">    return null;</strong></pre><pre class="source-code">
<strong class="bold">  }</strong></pre><pre class="source-code">
<strong class="bold">  const secondaryText = item[secondary] as unknown;</strong></pre><pre class="source-code">
}</pre></li>
				<li>Finish the implementation<a id="_idIndexMarker878"/> by rendering the list item <span class="No-Break">as follows:</span><pre class="source-code">
{data.map((item) =&gt; {</pre><pre class="source-code">
  ...</pre><pre class="source-code">
  <strong class="bold">return (</strong></pre><pre class="source-code">
<strong class="bold">    &lt;li</strong></pre><pre class="source-code">
<strong class="bold">      key={idValue}</strong></pre><pre class="source-code">
<strong class="bold">      className="bg-white p-6 shadow rounded mb-4         last:mb-0"</strong></pre><pre class="source-code">
<strong class="bold">    &gt;</strong></pre><pre class="source-code">
<strong class="bold">      &lt;div className="text-xl text-gray-800 pb-1"&gt;</strong></pre><pre class="source-code">
<strong class="bold">        {primaryText}</strong></pre><pre class="source-code">
<strong class="bold">      &lt;/div&gt;</strong></pre><pre class="source-code">
<strong class="bold">      {typeof secondaryText === 'string' &amp;&amp; (</strong></pre><pre class="source-code">
<strong class="bold">        &lt;div className="text-sm text-gray-500"&gt;</strong></pre><pre class="source-code">
<strong class="bold">          {secondaryText}</strong></pre><pre class="source-code">
<strong class="bold">        &lt;/div&gt;</strong></pre><pre class="source-code">
<strong class="bold">      )}</strong></pre><pre class="source-code">
<strong class="bold">    &lt;/li&gt;</strong></pre><pre class="source-code">
<strong class="bold">  );</strong></pre><pre class="source-code">
})}</pre></li>
			</ol>
			<p>The list items are rendered with a white background and rounded corners. The primary text is rendered<a id="_idIndexMarker879"/> as large, gray text with the secondary text rendered <span class="No-Break">much smaller.</span></p>
			<ol>
				<li value="6">Create a new file in the <strong class="source-inline">Checklist</strong> folder called <strong class="source-inline">index.ts</strong> and export the <strong class="source-inline">Checklist</strong> component <span class="No-Break">into it:</span><pre class="source-code">
export * from './Checklist';</pre></li>
			</ol>
			<p>This file will simplify <strong class="source-inline">import</strong> statements for the <span class="No-Break"><strong class="source-inline">Checklist</strong></span><span class="No-Break"> component.</span></p>
			<ol>
				<li value="7">The final step before seeing the component in action is to add it to the component tree in the app. Open <strong class="source-inline">App.tsx</strong> and replace the content within it with <span class="No-Break">the following:</span><pre class="source-code">
import { Checklist } from './Checklist';</pre><pre class="source-code">
function App() {</pre><pre class="source-code">
  return (</pre><pre class="source-code">
    &lt;div className="p-10"&gt;</pre><pre class="source-code">
      &lt;Checklist</pre><pre class="source-code">
        data={[</pre><pre class="source-code">
          { id: 1, name: 'Lucy', role: 'Manager' },</pre><pre class="source-code">
          { id: 2, name: 'Bob', role: 'Developer' },</pre><pre class="source-code">
        ]}</pre><pre class="source-code">
        id="id"</pre><pre class="source-code">
        primary="name"</pre><pre class="source-code">
        secondary="role"</pre><pre class="source-code">
      /&gt;</pre><pre class="source-code">
    &lt;/div&gt;</pre><pre class="source-code">
  );</pre><pre class="source-code">
}</pre><pre class="source-code">
export default App;</pre></li>
			</ol>
			<p>We reference the <strong class="source-inline">Checklist</strong> component and pass some data into it. Notice how type-safe the <strong class="source-inline">id</strong>, <strong class="source-inline">primary</strong>, and <strong class="source-inline">secondary</strong> attributes are – we are forced to enter a valid property<a id="_idIndexMarker880"/> name with the <span class="No-Break">data items.</span></p>
			<ol>
				<li value="8">Run the app by entering <strong class="source-inline">npm start</strong> in the terminal. The checklist component appears as <span class="No-Break">shown here:</span></li>
			</ol>
			<div>
				<div id="_idContainer159" class="IMG---Figure">
					<img src="image/B19051_11_01.jpg" alt="Figure 11.1 – Our basic checklist component"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1 – Our basic checklist component</p>
			<p>Currently, the component renders a basic list – we will add the checked functionality later in <span class="No-Break">this chapter.</span></p>
			<p>That completes this section on <span class="No-Break">generic props.</span></p>
			<p>To recap, here are some <span class="No-Break">key points:</span></p>
			<ul>
				<li>TypeScript generics allow reusable code to be <span class="No-Break">strongly typed.</span></li>
				<li>Functions can have generic parameters that are referenced within <span class="No-Break">the implementation.</span></li>
				<li>Types can also have generic parameters that are referenced within <span class="No-Break">the implementation.</span></li>
				<li>A React component can be made generic by feeding a generic props type into a generic function component. The component implementation will then be based on <span class="No-Break">generic props.</span></li>
			</ul>
			<p>Next, we will learn about a pattern that allows the prop type to inherit props from an <span class="No-Break">HTML element.</span></p>
			<h1 id="_idParaDest-278"><a id="_idTextAnchor280"/>Using props spreading</h1>
			<p>In this section, we’ll learn about a pattern called <strong class="bold">props spreading</strong>. This pattern is useful when you want<a id="_idIndexMarker881"/> to use all the props from an HTML element in the implementation of a component. In our checklist component, we will use this pattern to add all the props for the <strong class="source-inline">ul</strong> element. This will allow consumers of the component to specify props, such as the height and width of <span class="No-Break">the checklist.</span></p>
			<p>So, carry out the <span class="No-Break">following steps:</span></p>
			<ol>
				<li value="1">Open <strong class="source-inline">Checklist.tsx</strong> and import the following type <span class="No-Break">from React:</span><pre class="source-code">
import { ComponentPropsWithoutRef } from 'react';</pre></li>
			</ol>
			<p>This type allows us to reference the props of an HTML element such as <strong class="source-inline">ul</strong>. It is a generic type that takes the HTML element name as a <span class="No-Break">generic parameter.</span></p>
			<ol>
				<li value="2">Add the props from the <strong class="source-inline">ul</strong> element to the component props type <span class="No-Break">as follows:</span><pre class="source-code">
type Props&lt;Data&gt; = {</pre><pre class="source-code">
  data: Data[];</pre><pre class="source-code">
  id: keyof Data;</pre><pre class="source-code">
  primary: keyof Data;</pre><pre class="source-code">
  secondary: keyof Data;</pre><pre class="source-code">
} <strong class="bold">&amp; ComponentPropsWithoutRef&lt;'ul'&gt;</strong>;</pre></li>
				<li>Add a <strong class="bold">rest parameter</strong> called <strong class="source-inline">ulProps</strong> to collect<a id="_idIndexMarker882"/> all the props<a id="_idIndexMarker883"/> for the <strong class="source-inline">ul</strong> element into a single <span class="No-Break"><strong class="source-inline">ulProps</strong></span><span class="No-Break"> variable:</span><pre class="source-code">
export function Checklist&lt;Data&gt;({</pre><pre class="source-code">
  data,</pre><pre class="source-code">
  id,</pre><pre class="source-code">
  primary,</pre><pre class="source-code">
  secondary,</pre><pre class="source-code">
  <strong class="bold">...ulProps</strong></pre><pre class="source-code">
}: Props&lt;Data&gt;) {</pre><pre class="source-code">
  ...</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>This is the first time we have used rest parameters in this book. They collect multiple arguments that are passed into the function into an array, so any props that aren’t called <strong class="source-inline">data</strong>, <strong class="source-inline">id</strong>, <strong class="source-inline">primary</strong>, or <strong class="source-inline">secondary</strong> will be collected into the <strong class="source-inline">ulProps</strong> array. For more<a id="_idIndexMarker884"/> information on rest parameters, <span class="No-Break">see </span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters"><span class="No-Break">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters</span></a><span class="No-Break">.</span></p>
			<ol>
				<li value="4">Now, we can spread <strong class="source-inline">ulProps</strong> onto the <strong class="source-inline">ul</strong> element using the <span class="No-Break">spread syntax:</span><pre class="source-code">
export function Checklist&lt;Data&gt;({</pre><pre class="source-code">
  data,</pre><pre class="source-code">
  id,</pre><pre class="source-code">
  primary,</pre><pre class="source-code">
  secondary,</pre><pre class="source-code">
  ...ulProps</pre><pre class="source-code">
}: Props&lt;Data&gt;) {</pre><pre class="source-code">
  return (</pre><pre class="source-code">
    &lt;ul</pre><pre class="source-code">
      className="bg-gray-300 rounded p-10"</pre><pre class="source-code">
<strong class="bold">      {...ulProps}</strong></pre><pre class="source-code">
    &gt;...&lt;/ul&gt;</pre><pre class="source-code">
  );</pre><pre class="source-code">
}</pre></li>
				<li>We can use this new<a id="_idIndexMarker885"/> feature of <strong class="source-inline">Checklist</strong> to specify the list height and width. Open <strong class="source-inline">App.tsx</strong> and add the following <strong class="source-inline">style</strong> attribute, as well as more <span class="No-Break">data items:</span><pre class="source-code">
&lt;Checklist</pre><pre class="source-code">
  data={[</pre><pre class="source-code">
    { id: 1, name: 'Lucy', role: 'Manager' },</pre><pre class="source-code">
    { id: 2, name: 'Bob', role: 'Developer' },</pre><pre class="source-code">
    <strong class="bold">{ id: 3, name: 'Bill', role: 'Developer' },</strong></pre><pre class="source-code">
<strong class="bold">    { id: 4, name: 'Tara', role: 'Developer' },</strong></pre><pre class="source-code">
<strong class="bold">    { id: 5, name: 'Sara', role: 'UX' },</strong></pre><pre class="source-code">
<strong class="bold">    { id: 6, name: 'Derik', role: 'QA' }</strong></pre><pre class="source-code">
  ]}</pre><pre class="source-code">
  id="id"</pre><pre class="source-code">
  primary="name"</pre><pre class="source-code">
  secondary="role"</pre><pre class="source-code">
  <strong class="bold">style={{</strong></pre><pre class="source-code">
<strong class="bold">    width: '300px',</strong></pre><pre class="source-code">
<strong class="bold">    maxHeight: '380px',</strong></pre><pre class="source-code">
<strong class="bold">    overflowY: 'auto'</strong></pre><pre class="source-code">
<strong class="bold">  }}</strong></pre><pre class="source-code">
/&gt;</pre></li>
				<li>If the app isn’t running, run<a id="_idIndexMarker886"/> it by entering <strong class="source-inline">npm start</strong> in the terminal. The checklist component appears sized as <span class="No-Break">we expect:</span></li>
			</ol>
			<div>
				<div id="_idContainer160" class="IMG---Figure">
					<img src="image/B19051_11_02.jpg" alt="Figure 11.2 – The sized checklist component"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2 – The sized checklist component</p>
			<p>The component now has a fixed height with a vertical scrollbar as a result of the style we passed into <span class="No-Break">the component.</span></p>
			<p>That completes our use of the props spreading pattern. Here’s a recap of the <span class="No-Break">key points:</span></p>
			<ul>
				<li>We intersect the props type with <strong class="source-inline">ComponentPropsWithoutRef</strong> to add props for the HTML element we want to <span class="No-Break">spread onto</span></li>
				<li>We use a rest parameter in the component props to collect all the HTML element props into <span class="No-Break">an array</span></li>
				<li>We can then spread<a id="_idIndexMarker887"/> the rest parameter onto the HTML element in <span class="No-Break">the JSX</span></li>
			</ul>
			<p>Next, we will learn about a pattern that allows consumers to render parts of <span class="No-Break">a component.</span></p>
			<h1 id="_idParaDest-279"><a id="_idTextAnchor281"/>Using render props</h1>
			<p>In this section, we will learn about the <strong class="bold">render props</strong> pattern and use it to allow the consumer of the component<a id="_idIndexMarker888"/> to render items within the <span class="No-Break">checklist component.</span></p>
			<h2 id="_idParaDest-280"><a id="_idTextAnchor282"/>Understanding the render props pattern</h2>
			<p>A way of making a component<a id="_idIndexMarker889"/> highly reusable is to allow the consumer to render internal elements within it. The <strong class="source-inline">children</strong> prop on a <strong class="source-inline">button</strong> element is an example of this because it allows us to specify any button content <span class="No-Break">we like:</span></p>
			<pre class="source-code">
&lt;button&gt;We can specify any content here&lt;/button&gt;</pre>
			<p>The render props pattern allows us to use a prop other than <strong class="source-inline">children</strong> to provide this capability. This is useful when the <strong class="source-inline">children</strong> prop is already used for something else, as in the <span class="No-Break">following example:</span></p>
			<pre class="source-code">
&lt;Modal <strong class="bold">heading={&lt;h3&gt;Enter Details&lt;/h3&gt;}</strong>&gt;
  Some content
&lt;/Modal&gt;</pre>
			<p>Here, <strong class="source-inline">heading</strong> is a render prop in a <span class="No-Break"><strong class="source-inline">Modal</strong></span><span class="No-Break"> component.</span></p>
			<p>Render props are useful when allowing the consumer to render elements associated with the data passed into the component because the render prop can be <span class="No-Break">a function:</span></p>
			<pre class="source-code">
&lt;List
  data={[...]}
<strong class="bold">  renderItem={(item) =&gt; &lt;div&gt;{item.text}&lt;/div&gt;}</strong>
/&gt;</pre>
			<p>The preceding example has a render prop called <strong class="source-inline">renderItem</strong> that renders each list item in a <strong class="source-inline">List</strong> component. The data<a id="_idIndexMarker890"/> item is passed into it so it can include its properties in the list item. This is similar to what we will implement next for our <span class="No-Break">checklist component.</span></p>
			<h2 id="_idParaDest-281"><a id="_idTextAnchor283"/>Adding a renderItem prop</h2>
			<p>We will add a prop called <strong class="source-inline">renderItem</strong> to the checklist<a id="_idIndexMarker891"/> that allows consumers to take control of the rendering of the list items. Carry out the <span class="No-Break">following steps:</span></p>
			<ol>
				<li value="1">Open <strong class="source-inline">Checklist.tsx</strong> and add the <strong class="source-inline">ReactNode</strong> type to the React <span class="No-Break"><strong class="source-inline">import</strong></span><span class="No-Break"> statement:</span><pre class="source-code">
import { ComponentPropsWithoutRef<strong class="bold">, ReactNode </strong>} from 'react';</pre></li>
			</ol>
			<p><strong class="source-inline">ReactNode</strong> represents an element that React can render. Therefore, we will use <strong class="source-inline">ReactNode</strong> as the return type for our <span class="No-Break">render prop.</span></p>
			<ol>
				<li value="2">Add a render prop called <strong class="source-inline">renderItem</strong> to the <span class="No-Break"><strong class="source-inline">Props</strong></span><span class="No-Break"> type:</span><pre class="source-code">
type Props&lt;Data&gt; = {</pre><pre class="source-code">
  data: Data[];</pre><pre class="source-code">
  id: keyof Data;</pre><pre class="source-code">
  primary: keyof Data;</pre><pre class="source-code">
  secondary: keyof Data;</pre><pre class="source-code">
<strong class="bold">  renderItem?: (item: Data) =&gt; ReactNode;</strong></pre><pre class="source-code">
} &amp; React.ComponentPropsWithoutRef&lt;'ul'&gt;;</pre></li>
			</ol>
			<p>The prop is a function that takes in the data item and returns what needs rendering. We have made the prop optional because we will provide a default implementation for list items but also allow consumers to <span class="No-Break">override it.</span></p>
			<ol>
				<li value="3">Add <strong class="source-inline">renderItem</strong> to the component <span class="No-Break">function parameters:</span><pre class="source-code">
export function Checklist&lt;Data&gt;({</pre><pre class="source-code">
  data,</pre><pre class="source-code">
  id,</pre><pre class="source-code">
  primary,</pre><pre class="source-code">
  secondary,</pre><pre class="source-code">
<strong class="bold">  renderItem,</strong></pre><pre class="source-code">
  ...ulProps</pre><pre class="source-code">
}: Props&lt;Data&gt;) {</pre><pre class="source-code">
  ...</pre><pre class="source-code">
}</pre></li>
				<li>In the JSX, at the top of the mapping<a id="_idIndexMarker892"/> function, add an <strong class="source-inline">if</strong> statement to check whether the <strong class="source-inline">renderItem</strong> prop has been specified. If <strong class="source-inline">renderItem</strong> has been specified, call it with the data item, and return its result from the <span class="No-Break">mapping function:</span><pre class="source-code">
&lt;ul ...&gt;</pre><pre class="source-code">
  {data.map((item) =&gt; {</pre><pre class="source-code">
    <strong class="bold">if (renderItem) {</strong></pre><pre class="source-code">
<strong class="bold">      return renderItem(item);</strong></pre><pre class="source-code">
<strong class="bold">    }</strong></pre><pre class="source-code">
    const idValue = item[id] as unknown;</pre><pre class="source-code">
    ...</pre><pre class="source-code">
  })}</pre><pre class="source-code">
&lt;/ul&gt;</pre></li>
			</ol>
			<p>So, if <strong class="source-inline">renderItem</strong> has been specified, it will be called to get the element to render as the list item. If <strong class="source-inline">renderItem</strong> hasn’t been specified, it will render the list item as it <span class="No-Break">previously did.</span></p>
			<ol>
				<li value="5">To try the new prop<a id="_idIndexMarker893"/> out, open <strong class="source-inline">App.tsx</strong> and add the following <span class="No-Break"><strong class="source-inline">renderItem</strong></span><span class="No-Break"> attribute:</span><pre class="source-code">
&lt;Checklist</pre><pre class="source-code">
  ...</pre><pre class="source-code">
  <strong class="bold">renderItem={(item) =&gt; (</strong></pre><pre class="source-code">
<strong class="bold">    &lt;li key={item.id} className="bg-white p-4       border-b-2"&gt;</strong></pre><pre class="source-code">
<strong class="bold">      &lt;div className="text-xl text-slate-800 pb-1"&gt;</strong></pre><pre class="source-code">
<strong class="bold">        {item.name}</strong></pre><pre class="source-code">
<strong class="bold">      &lt;/div&gt;</strong></pre><pre class="source-code">
<strong class="bold">      &lt;div className="text-slate-500"&gt;{item.role}&lt;/div&gt;</strong></pre><pre class="source-code">
<strong class="bold">    &lt;/li&gt;</strong></pre><pre class="source-code">
<strong class="bold">  )}</strong></pre><pre class="source-code">
/&gt;</pre></li>
			</ol>
			<p>The list items are now rendered as flat, white items with a border <span class="No-Break">between them.</span></p>
			<ol>
				<li value="6">If the app isn’t running, run it by entering <strong class="source-inline">npm start</strong> in the terminal. The checklist component appears with the overridden <span class="No-Break">list items:</span></li>
			</ol>
			<div>
				<div id="_idContainer161" class="IMG---Figure">
					<img src="image/B19051_11_03.jpg" alt="Figure 11.3 – Overridden list items"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3 – Overridden list items</p>
			<ol>
				<li value="7">Before continuing to the next section, remove the use of <strong class="source-inline">renderItem</strong> in the <strong class="source-inline">Checklist</strong> element in <strong class="source-inline">App.tsx</strong>. The default rendering of list items should <span class="No-Break">then appear.</span></li>
			</ol>
			<p>That completes this section<a id="_idIndexMarker894"/> on the render props pattern. To recap, here are some <span class="No-Break">key points:</span></p>
			<ul>
				<li>The render props pattern allows a component consumer to override the rendering of parts of <span class="No-Break">the component</span></li>
				<li>A render prop can either be an element or a function that returns <span class="No-Break">an element</span></li>
				<li>A common use case for a render prop is a data-driven list in which the rendering of list items can <span class="No-Break">be overridden</span></li>
			</ul>
			<p>Next, we will add checked functionality to our <span class="No-Break">checklist component.</span></p>
			<h1 id="_idParaDest-282"><a id="_idTextAnchor284"/>Adding checked functionality</h1>
			<p>Currently, our checklist component<a id="_idIndexMarker895"/> doesn’t contain the ability to check items, so we will now add checkboxes to the list of items, giving users the ability to check them. We will track the checked items using a <span class="No-Break">React state.</span></p>
			<p>So, carry out the following steps to add this functionality to <span class="No-Break">our component:</span></p>
			<ol>
				<li value="1">Open <strong class="source-inline">Checklist.tsx</strong> and add <strong class="source-inline">useState</strong> to the React <span class="No-Break"><strong class="source-inline">import</strong></span><span class="No-Break"> statement:</span><pre class="source-code">
import {</pre><pre class="source-code">
  ComponentPropsWithoutRef,</pre><pre class="source-code">
  ReactNode<strong class="bold">,</strong></pre><pre class="source-code">
<strong class="bold">  useState</strong></pre><pre class="source-code">
} from 'react';</pre></li>
			</ol>
			<p>We will use the state to store the IDs of the <span class="No-Break">checked items.</span></p>
			<ol>
				<li value="2">At the top of the component<a id="_idIndexMarker896"/> implementation, add the state for the IDs of the <span class="No-Break">checked items:</span><pre class="source-code">
const [checkedIds, setCheckedIds] = useState&lt;IdValue[]&gt;([]);</pre></li>
			</ol>
			<p>We have referenced an <strong class="source-inline">IdValue</strong> type that we haven’t defined yet – we’ll define this after we have finished the component implementation in <span class="No-Break"><em class="italic">step 6</em></span><span class="No-Break">.</span></p>
			<ol>
				<li value="3">Add checkboxes to the list of items <span class="No-Break">as follows:</span><pre class="source-code">
&lt;li</pre><pre class="source-code">
  key={idValue}</pre><pre class="source-code">
  className="bg-white p-6 shadow rounded mb-4 last:mb-0"</pre><pre class="source-code">
&gt;</pre><pre class="source-code">
  <strong class="bold">&lt;label className="flex items-center"&gt;</strong></pre><pre class="source-code">
<strong class="bold">    &lt;input</strong></pre><pre class="source-code">
<strong class="bold">      type="checkbox"</strong></pre><pre class="source-code">
<strong class="bold">      checked={checkedIds.includes(idValue)}</strong></pre><pre class="source-code">
<strong class="bold">      onChange={handleCheckChange(idValue)}</strong></pre><pre class="source-code">
<strong class="bold">    /&gt;</strong></pre><pre class="source-code">
    <strong class="bold">&lt;div className="ml-2"&gt;</strong></pre><pre class="source-code">
      &lt;div className="text-xl text-gray-800 pb-1"&gt;</pre><pre class="source-code">
        {primaryText}</pre><pre class="source-code">
      &lt;/div&gt;</pre><pre class="source-code">
      {typeof secondaryText === 'string' &amp;&amp; (</pre><pre class="source-code">
        &lt;div className="text-sm text-gray-500"&gt;</pre><pre class="source-code">
          {secondaryText}</pre><pre class="source-code">
        &lt;/div&gt;</pre><pre class="source-code">
      )}</pre><pre class="source-code">
<strong class="bold">    &lt;/div&gt;</strong></pre><pre class="source-code">
<strong class="bold">  &lt;/label&gt;</strong></pre><pre class="source-code">
&lt;/li&gt;</pre></li>
			</ol>
			<p>The <strong class="source-inline">checkedIds</strong> state powers the <strong class="source-inline">checked</strong> attribute of the checkbox by checking whether the list item’s ID is contained <span class="No-Break">within it.</span></p>
			<p>We will implement<a id="_idIndexMarker897"/> the referenced <strong class="source-inline">handleCheckChange</strong> function in the next step. Notice that the reference calls the function passing the ID of the list item that has <span class="No-Break">been checked.</span></p>
			<ol>
				<li value="4">Start to implement the <strong class="source-inline">handleCheckChange</strong> function in the component <span class="No-Break">as follows:</span><pre class="source-code">
const [checkedIds, setCheckedIds] = useState&lt;IdValue[]&gt;([]);</pre><pre class="source-code">
<strong class="bold">const handleCheckChange = (checkedId: IdValue) =&gt; () =&gt; {};</strong></pre><pre class="source-code">
return ...</pre></li>
			</ol>
			<p>This is a function that returns the handler function. This complexity is because a basic checked handler doesn’t pass in the list item’s ID. This approach<a id="_idIndexMarker898"/> is called <strong class="bold">currying</strong>, and more information on it can be found<a id="_idIndexMarker899"/> at the following <span class="No-Break">link: </span><a href="https://javascript.info/currying-partials"><span class="No-Break">https://javascript.info/currying-partials</span></a><span class="No-Break">.</span></p>
			<ol>
				<li value="5">Complete the handler implementation <span class="No-Break">as follows:</span><pre class="source-code">
const handleCheckChange = (checkedId: IdValue) =&gt; () =&gt; {</pre><pre class="source-code">
  <strong class="bold">const isChecked = checkedIds.includes(checkedId);</strong></pre><pre class="source-code">
<strong class="bold">  let newCheckedIds = isChecked</strong></pre><pre class="source-code">
<strong class="bold">    ? checkedIds.filter(</strong></pre><pre class="source-code">
<strong class="bold">        (itemCheckedid) =&gt; itemCheckedid !== checkedId</strong></pre><pre class="source-code">
<strong class="bold">      )</strong></pre><pre class="source-code">
<strong class="bold">    : checkedIds.concat(checkedId);</strong></pre><pre class="source-code">
<strong class="bold">  setCheckedIds(newCheckedIds);</strong></pre><pre class="source-code">
};</pre></li>
			</ol>
			<p>The implementation<a id="_idIndexMarker900"/> updates the list item’s ID to the <strong class="source-inline">checkedIds</strong> state if the list item has been checked and removes it if it <span class="No-Break">is unchecked.</span></p>
			<ol>
				<li value="6">Next, let’s define the <strong class="source-inline">IdValue</strong> type. Create a new file in the <strong class="source-inline">Checklist</strong> folder called <strong class="source-inline">types.ts</strong> with the definition <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">IdValue</strong></span><span class="No-Break">:</span><pre class="source-code">
export type IdValue = string | number;</pre></li>
			</ol>
			<p>Here, the list item’s ID can be a <strong class="source-inline">string</strong> or <span class="No-Break"><strong class="source-inline">number</strong></span><span class="No-Break"> value.</span></p>
			<ol>
				<li value="7">Move back to <strong class="source-inline">Checklist.tsx</strong> and <span class="No-Break">import </span><span class="No-Break"><strong class="source-inline">IdValue</strong></span><span class="No-Break">:</span><pre class="source-code">
import { IdValue } from './types';</pre></li>
			</ol>
			<p>The compilation errors should now <span class="No-Break">be resolved.</span></p>
			<ol>
				<li value="8">If the app isn’t running, run it by entering <strong class="source-inline">npm start</strong> in the terminal. The checklist component appears with checkboxes for each <span class="No-Break">list item:</span></li>
			</ol>
			<div>
				<div id="_idContainer162" class="IMG---Figure">
					<img src="image/B19051_11_04.jpg" alt="Figure 11.4 – Checkboxes for list items"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.4 – Checkboxes for list items</p>
			<p>The checklist component<a id="_idIndexMarker901"/> now includes checkboxes. However, there is an opportunity to make the checked logic reusable – we’ll cover this in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-283"><a id="_idTextAnchor285"/>Creating custom hooks</h1>
			<p>In this section, we’ll learn about custom<a id="_idIndexMarker902"/> React hooks. Then, we will use this knowledge to extract the checked logic from the checklist component into a reusable <span class="No-Break">custom hook.</span></p>
			<h2 id="_idParaDest-284"><a id="_idTextAnchor286"/>Understanding custom hooks</h2>
			<p>As well as standard hooks<a id="_idIndexMarker903"/> such as <strong class="source-inline">useState</strong>, React allows us to create our own custom hooks. Custom hooks allow logic to be isolated and reused across <span class="No-Break">multiple components.</span></p>
			<p>A custom hook is defined using a function with a name that starts with the word <em class="italic">use</em>. This naming convention helps ESLint check for problems with the use of the custom hook. Here’s a custom hook that provides <span class="No-Break">toggling logic:</span></p>
			<pre class="source-code">
export function useToggle() {
  const [toggleValue, setToggleValue] = useState(false);
  function toggle() {
    setToggleValue(!toggleValue);
  }
  return {toggleValue, toggle};
};</pre>
			<p>The custom hook contains the state of the current toggle value, which is either <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong>. It also includes a function called <strong class="source-inline">toggle</strong>, which toggles the current value. The current toggle value and the <strong class="source-inline">toggle</strong> function are returned from the custom hook in an <span class="No-Break">object structure.</span></p>
			<p>Note that an object structure<a id="_idIndexMarker904"/> doesn’t have to be returned. If the custom hook only returns a single item, then that item can be returned directly. If the custom hook returns two things (as in the preceding example), it can return a tuple (as <strong class="source-inline">useState</strong> does). An object structure is better for more than two items because the object keys make it clear what each <span class="No-Break">item is.</span></p>
			<p>Another trait of a custom hook is that it uses other standard React hooks. For example, the <strong class="source-inline">useToggle</strong> custom hook uses <strong class="source-inline">useState</strong>. If the custom hook doesn’t call a React hook or another custom hook, it’s just a regular function rather than a <span class="No-Break">custom hook.</span></p>
			<p>This custom hook can then be used in the implementation of a component <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
<strong class="bold">const { toggleValue, toggle } = useToggle();</strong>
return (
  &lt;div className="App"&gt;
    &lt;button onClick={<strong class="bold">toggle</strong>}&gt;{<strong class="bold">toggleValue</strong> ? 'ON' : 'OFF'}&lt;/button&gt;
  &lt;/div&gt;
);</pre>
			<p>The toggle value (<strong class="source-inline">toggleValue</strong>) and the <strong class="source-inline">toggle</strong> function are destructured from the return value of the custom hook. The toggle value is used to render text <strong class="bold">ON</strong> or <strong class="bold">OFF</strong> inside the button content depending on whether it is <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong>. The <strong class="source-inline">toggle</strong> function is also assigned to the click handler of <span class="No-Break">the button.</span></p>
			<p>Custom hooks can take in parameters<a id="_idIndexMarker905"/> as well. In the example here, we have added a default value in the <span class="No-Break"><strong class="source-inline">useToggle</strong></span><span class="No-Break"> hook:</span></p>
			<pre class="source-code">
<strong class="bold">type Params = {</strong>
<strong class="bold">  defaultToggleValue?: boolean;</strong>
<strong class="bold">};</strong>
export function useToggle(<strong class="bold">{ defaultToggleValue }: Params</strong>) {
  const [toggleValue, setToggleValue] = useState(
    <strong class="bold">defaultToggleValue</strong>
  );
  ...
}</pre>
			<p>In the preceding example, the parameters are in an object structure. An object structure is nice when there are multiple parameters and nothing breaks when new parameters <span class="No-Break">are added.</span></p>
			<p>Arguments are passed into the custom hook in an object. Here’s an example of using <strong class="source-inline">useToggle</strong> with its value initially <span class="No-Break">being </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
const { toggleValue, toggle } = useToggle(<strong class="bold">{</strong>
<strong class="bold">  defaultToggleValue: true</strong>
<strong class="bold">}</strong>);</pre>
			<p>Now that we understand how to create and use custom hooks, we will put this into practice in our <span class="No-Break">checklist component.</span></p>
			<h2 id="_idParaDest-285"><a id="_idTextAnchor287"/>Extracting checked logic into a custom hook</h2>
			<p>We will extract the logic for checked<a id="_idIndexMarker906"/> items into a custom hook. This will allow<a id="_idIndexMarker907"/> potential future components to use the logic and clean up the code <span class="No-Break">a little.</span></p>
			<p>The custom hook will be called <strong class="source-inline">useChecked</strong> and will contain the state for the checked list item IDs. The hook will also include a handler that can be attached to the checkboxes, updating the checked list item <span class="No-Break">ID’s state.</span></p>
			<p>To do this, carry<a id="_idIndexMarker908"/> out the <span class="No-Break">following</span><span class="No-Break"><a id="_idIndexMarker909"/></span><span class="No-Break"> steps:</span></p>
			<ol>
				<li value="1">In the <strong class="source-inline">Checklist</strong> folder, create a file for the custom hook <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">useChecked.ts</strong></span><span class="No-Break">.</span></li>
				<li>Open <strong class="source-inline">useChecked.ts</strong> and add the following <span class="No-Break"><strong class="source-inline">import</strong></span><span class="No-Break"> statements:</span><pre class="source-code">
import { useState } from 'react';</pre><pre class="source-code">
import { IdValue } from './types';</pre></li>
			</ol>
			<p>The hook will use React state that is typed <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">IdValue</strong></span><span class="No-Break">.</span></p>
			<ol>
				<li value="3">Start to implement the function for the custom hook by initializing <span class="No-Break">the state:</span><pre class="source-code">
export function useChecked() {</pre><pre class="source-code">
  const [checkedIds, setCheckedIds] =     useState&lt;IdValue[]&gt;([]);</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>The hook doesn’t have any parameters. The <strong class="source-inline">useState</strong> call is exactly the same as the one currently in the <strong class="source-inline">Checklist</strong> component – this could be copied and pasted into the <span class="No-Break">custom hook.</span></p>
			<ol>
				<li value="4">Add a checked handler to the custom hook. This can be copied from the implementation of the <span class="No-Break"><strong class="source-inline">Checklist</strong></span><span class="No-Break"> component:</span><pre class="source-code">
export function useChecked() {</pre><pre class="source-code">
  const [checkedIds, setCheckedIds] =     useState&lt;IdValue[]&gt;([]);</pre><pre class="source-code">
  <strong class="bold">const handleCheckChange = (checkedId: IdValue) =&gt; () =&gt; {</strong></pre><pre class="source-code">
<strong class="bold">    const isChecked = checkedIds.includes(checkedId);</strong></pre><pre class="source-code">
<strong class="bold">    let newCheckedIds = isChecked</strong></pre><pre class="source-code">
<strong class="bold">      ? checkedIds.filter(</strong></pre><pre class="source-code">
<strong class="bold">          (itemCheckedid) =&gt; itemCheckedid !== checkedId</strong></pre><pre class="source-code">
<strong class="bold">        )</strong></pre><pre class="source-code">
<strong class="bold">      : checkedIds.concat(checkedId);</strong></pre><pre class="source-code">
<strong class="bold">    setCheckedIds(newCheckedIds);</strong></pre><pre class="source-code">
<strong class="bold">  };</strong></pre><pre class="source-code">
}</pre></li>
				<li>The last task in the custom hook<a id="_idIndexMarker910"/> implementation is to return<a id="_idIndexMarker911"/> the checked IDs and the <span class="No-Break">handler function:</span><pre class="source-code">
export function useChecked() {</pre><pre class="source-code">
  ...</pre><pre class="source-code">
<strong class="bold">  return { handleCheckChange, checkedIds };</strong></pre><pre class="source-code">
}</pre></li>
				<li>Next, open <strong class="source-inline">Checklist.tsx</strong> and remove the state definition and the <strong class="source-inline">handleCheckChange</strong> handler function. Also, remove <strong class="source-inline">useState</strong> and <strong class="source-inline">IdValue</strong> from the <strong class="source-inline">import</strong> statements, as they <span class="No-Break">are redundant.</span></li>
				<li>Still in <strong class="source-inline">Checklist.tsx</strong>, import the <strong class="source-inline">useChecked</strong> hook we <span class="No-Break">just created:</span><pre class="source-code">
import { useChecked } from './useChecked';</pre></li>
				<li>Add a call to <strong class="source-inline">useChecked</strong> and destructure the checked IDs and the <span class="No-Break">handler function:</span><pre class="source-code">
export function Checklist&lt;Data&gt;({ ... }: Props&lt;Data&gt;) {</pre><pre class="source-code">
<strong class="bold">  const { checkedIds, handleCheckChange } = useChecked();</strong></pre><pre class="source-code">
  return ...</pre><pre class="source-code">
}</pre></li>
				<li>If the app isn’t running, run it by entering <strong class="source-inline">npm start</strong> in the terminal. The checklist component<a id="_idIndexMarker912"/> will appear and behave<a id="_idIndexMarker913"/> as it did before we made <span class="No-Break">these changes.</span></li>
			</ol>
			<p>That completes the implementation and use of the custom hook. To recap, here are some <span class="No-Break">key points:</span></p>
			<ul>
				<li>Custom hooks make code a little cleaner and are reusable because they isolate logic, which can <span class="No-Break">be complex.</span></li>
				<li>Custom hooks must start <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">use</strong></span><span class="No-Break">.</span></li>
				<li>Custom hooks must use a standard React hook or another <span class="No-Break">custom hook.</span></li>
				<li>A custom hook is just a function that returns useful things for components to use. Using an object structure for the returned items is ideal when returning many items because the object keys make it clear what each <span class="No-Break">item is.</span></li>
				<li>A custom hook can have parameters. Using an object structure for the parameters is ideal for many items and doesn’t break anything when new parameters <span class="No-Break">are added.</span></li>
			</ul>
			<p>Next, we will cover a pattern that will allow the consumer of a component to control some of its behavior with <span class="No-Break">the state.</span></p>
			<h1 id="_idParaDest-286"><a id="_idTextAnchor288"/>Allowing the internal state to be controlled</h1>
			<p>In this section, we’ll learn how<a id="_idIndexMarker914"/> to allow consumers of a component to control its internal state. We will use this pattern in the checklist component so that users can check just a <span class="No-Break">single item.</span></p>
			<h2 id="_idParaDest-287"><a id="_idTextAnchor289"/>Understanding how the internal state can be controlled</h2>
			<p>Allowing consumers of a component<a id="_idIndexMarker915"/> to control the state allows the behavior of a component to be tweaked if that behavior is driven by the state. Let’s go through an example using the <strong class="source-inline">useToggle</strong> custom hook we covered in the last section when learning about <span class="No-Break">custom hooks.</span></p>
			<p>Two additional props are required to allow the internal state to be controlled – one for the current state value and one for a change handler. These additional props are <strong class="source-inline">toggleValue</strong> and <strong class="source-inline">onToggleValueChange</strong> <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">useToggle</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
type Params = {
  defaultToggleValue?: boolean;
  <strong class="bold">toggleValue?: boolean;</strong>
<strong class="bold">  onToggleValueChange?: (toggleValue: boolean) =&gt; void;</strong>
};
export function useToggle({
  defaultToggleValue,
<strong class="bold">  toggleValue,</strong>
<strong class="bold">  onToggleValueChange,</strong>
}: Params) {
  ...
}</pre>
			<p>These props are marked as optional because this pattern doesn’t force the consumer of the component to control the state – it’s a feature they can opt <span class="No-Break">in to.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">The consumer of the component will never specify both <strong class="source-inline">defaultToggleValue</strong> and <strong class="source-inline">toggleValue</strong>. <strong class="source-inline">defaultToggleValue</strong> should only be used when the consumer doesn’t want to control <strong class="source-inline">toggleValue</strong> with the state. When the consumer does want to control <strong class="source-inline">toggleValue</strong> with the state, they can set the initial value of <span class="No-Break">their state.</span></p>
			<p>The <strong class="source-inline">toggleValue</strong> prop now<a id="_idIndexMarker916"/> clashes with the <strong class="source-inline">toggleValue</strong> state because they have the same name, so the state needs to <span class="No-Break">be renamed:</span></p>
			<pre class="source-code">
const [<strong class="bold">resolvedToggleValue</strong>, <strong class="bold">setResolvedToggleValue</strong>] =
  useState(defaultToggleValue);
function toggle() {
  <strong class="bold">setResolvedToggleValue</strong>(!<strong class="bold">resolvedToggleValue</strong>);
}
return { <strong class="bold">resolvedToggleValue</strong>, toggle };</pre>
			<p>The default value of the internal state now needs to consider that there might be a prop controlling <span class="No-Break">the state:</span></p>
			<pre class="source-code">
const [resolvedToggleValue, setResolvedToggleValue] =
  useState(defaultToggleValue <strong class="bold">|| toggleValue</strong>);</pre>
			<p>When the state is changed, the change handler is called, if it has <span class="No-Break">been defined:</span></p>
			<pre class="source-code">
function toggle() {
  <strong class="bold">if (onToggleValueChange) {</strong>
<strong class="bold">    onToggleValueChange(!resolvedToggleValue);</strong>
<strong class="bold">  } else {</strong>
    setResolvedToggleValue(!resolvedToggleValue);
  <strong class="bold">}</strong>
}</pre>
			<p>Again, it’s important that we still update the internal state in case the consumer isn’t controlling <span class="No-Break">the state.</span></p>
			<p>The last step in implementing<a id="_idIndexMarker917"/> this pattern is to update the internal state when the controlled state is updated. We can do this with <strong class="source-inline">useEffect</strong> <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
useEffect(() =&gt; {
  const isControlled = toggleValue !== undefined;
  if (isControlled) {
    setResolvedToggleValue(toggleValue);
  }
}, [toggleValue]);</pre>
			<p>The effect is triggered when the state prop changes. We check whether the state prop is being controlled; if so, the internal state is updated with <span class="No-Break">its value.</span></p>
			<p>Here’s an example of controlling <strong class="source-inline">toggleValue</strong> <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">useToggle</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
const [toggleValue, setToggleValue] = useState(false);
const onCount = useRef(0);
const { resolvedToggleValue, toggle } = useToggle({
  toggleValue,
  onToggleValueChange: (value) =&gt; {
    if (onCount.current &gt;= 3) {
      setToggleValue(false);
    } else {
      setToggleValue(value);
      if (value) {
        onCount.current++;
      }
    }
  },
});</pre>
			<p>This example stores the toggle value in its own state and passes it to <strong class="source-inline">useToggle</strong>. <strong class="source-inline">onToggleValueChange</strong> is handled by updating the state value. The logic for setting the state value only allows it to be <strong class="source-inline">true</strong> up to <span class="No-Break">three times.</span></p>
			<p>So, this use case has overridden<a id="_idIndexMarker918"/> the default behavior of the toggle so that it can only be set to <strong class="source-inline">true</strong> up to <span class="No-Break">three times.</span></p>
			<p>Now that we understand how to allow the internal state to be controlled, we will use it in our <span class="No-Break">checklist component.</span></p>
			<h2 id="_idParaDest-288"><a id="_idTextAnchor290"/>Allowing checkedIds to be controlled</h2>
			<p>At the moment, our checklist component<a id="_idIndexMarker919"/> allows many items to be selected. If we allow the <strong class="source-inline">checkedIds</strong> state to be controlled by the consumer, they can change the checklist component so that they can select just a <span class="No-Break">single item.</span></p>
			<p>So, carry out the <span class="No-Break">following steps:</span></p>
			<ol>
				<li value="1">We will start in <strong class="source-inline">useChecked.ts</strong>. Add <strong class="source-inline">useEffect</strong> to the React <span class="No-Break"><strong class="source-inline">import</strong></span><span class="No-Break"> statement:</span><pre class="source-code">
import { useState<strong class="bold">, useEffect</strong> } from 'react';</pre></li>
				<li>Add new parameters for the controlled checked IDs and the <span class="No-Break">change handler:</span><pre class="source-code">
<strong class="bold">type Params = {</strong></pre><pre class="source-code">
<strong class="bold">  checkedIds?: IdValue[];</strong></pre><pre class="source-code">
<strong class="bold">  onCheckedIdsChange?: (checkedIds: IdValue[]) =&gt; void;</strong></pre><pre class="source-code">
<strong class="bold">};</strong></pre><pre class="source-code">
export function useChecked(<strong class="bold">{</strong></pre><pre class="source-code">
<strong class="bold">  checkedIds,</strong></pre><pre class="source-code">
<strong class="bold">  onCheckedIdsChange,</strong></pre><pre class="source-code">
<strong class="bold">}: Params</strong>) {</pre><pre class="source-code">
  ...</pre><pre class="source-code">
}</pre></li>
				<li>Update the internal<a id="_idIndexMarker920"/> state name to <strong class="source-inline">resolvedCheckedIds</strong> and default it to the passed-in <strong class="source-inline">checkedIds</strong> parameter <span class="No-Break">if defined:</span><pre class="source-code">
export function useChecked({</pre><pre class="source-code">
  checkedIds,</pre><pre class="source-code">
  onCheckedIdsChange,</pre><pre class="source-code">
}: Params) {</pre><pre class="source-code">
  const [<strong class="bold">resolvedCheckedIds, setResolvedCheckedIds</strong>] =</pre><pre class="source-code">
    useState&lt;IdValue[]&gt;(<strong class="bold">checkedIds ||</strong> []);</pre><pre class="source-code">
  const handleCheckChange = (checkedId: IdValue) =&gt; () =&gt; {</pre><pre class="source-code">
    const isChecked = <strong class="bold">resolvedCheckedIds</strong>.      includes(checkedId);</pre><pre class="source-code">
    let newCheckedIds = isChecked</pre><pre class="source-code">
      ? <strong class="bold">resolvedCheckedIds</strong>.filter(</pre><pre class="source-code">
          (itemCheckedid) =&gt; itemCheckedid !== checkedId</pre><pre class="source-code">
        )</pre><pre class="source-code">
      : <strong class="bold">resolvedCheckedIds</strong>.concat(checkedId);</pre><pre class="source-code">
    <strong class="bold">setResolvedCheckedIds</strong>(newCheckedIds);</pre><pre class="source-code">
  };</pre><pre class="source-code">
  return { handleCheckChange, <strong class="bold">resolvedCheckedIds</strong> };</pre><pre class="source-code">
}</pre></li>
				<li>Update the <strong class="source-inline">handleCheckChange</strong> handler to call the passed-in change handler <span class="No-Break">if defined:</span><pre class="source-code">
const handleCheckChange = (checkedId: IdValue) =&gt; () =&gt; {</pre><pre class="source-code">
  const isChecked = resolvedCheckedIds.    includes(checkedId);</pre><pre class="source-code">
  let newCheckedIds = isChecked</pre><pre class="source-code">
    ? resolvedCheckedIds.filter(</pre><pre class="source-code">
        (itemCheckedid) =&gt; itemCheckedid !== checkedId</pre><pre class="source-code">
      )</pre><pre class="source-code">
    : resolvedCheckedIds.concat(checkedId);</pre><pre class="source-code">
  <strong class="bold">if (onCheckedIdsChange) {</strong></pre><pre class="source-code">
<strong class="bold">    onCheckedIdsChange(newCheckedIds);</strong></pre><pre class="source-code">
<strong class="bold">  } else {</strong></pre><pre class="source-code">
    setResolvedCheckedIds(newCheckedIds);</pre><pre class="source-code">
  <strong class="bold">}</strong></pre><pre class="source-code">
};</pre></li>
				<li>The last task in <strong class="source-inline">useCheck.ts</strong> is to synchronize the controlled checked IDs with the internal<a id="_idIndexMarker921"/> state. Add the following <strong class="source-inline">useEffect</strong> hook to <span class="No-Break">achieve this:</span><pre class="source-code">
useEffect(() =&gt; {</pre><pre class="source-code">
  const isControlled = checkedIds !== undefined;</pre><pre class="source-code">
  if (isControlled) {</pre><pre class="source-code">
    setResolvedCheckedIds(checkedIds);</pre><pre class="source-code">
  }</pre><pre class="source-code">
}, [checkedIds]);</pre></li>
				<li>Now, open <strong class="source-inline">Checklist.tsx</strong> and import the <span class="No-Break"><strong class="source-inline">IdValue</strong></span><span class="No-Break"> type:</span><pre class="source-code">
import { IdValue } from './types';</pre></li>
				<li>Add the new props<a id="_idIndexMarker922"/> for the controlled checked IDs and the <span class="No-Break">change handler:</span><pre class="source-code">
type Props&lt;Data&gt; = {</pre><pre class="source-code">
  data: Data[];</pre><pre class="source-code">
  id: keyof Data;</pre><pre class="source-code">
  primary: keyof Data;</pre><pre class="source-code">
  secondary: keyof Data;</pre><pre class="source-code">
  renderItem?: (item: Data) =&gt; ReactNode;</pre><pre class="source-code">
  <strong class="bold">checkedIds?: IdValue[];</strong></pre><pre class="source-code">
<strong class="bold">  onCheckedIdsChange?: (checkedIds: IdValue[]) =&gt; void;</strong></pre><pre class="source-code">
} &amp; ComponentPropsWithoutRef&lt;'ul'&gt;;</pre><pre class="source-code">
export function Checklist&lt;Data&gt;({</pre><pre class="source-code">
  data,</pre><pre class="source-code">
  id,</pre><pre class="source-code">
  primary,</pre><pre class="source-code">
  secondary,</pre><pre class="source-code">
  renderItem,</pre><pre class="source-code">
  <strong class="bold">checkedIds,</strong></pre><pre class="source-code">
<strong class="bold">  onCheckedIdsChange,</strong></pre><pre class="source-code">
  ...ulProps</pre><pre class="source-code">
}: Props&lt;Data&gt;) {}</pre></li>
				<li>Pass these props to <strong class="source-inline">useChecked</strong> and rename<a id="_idIndexMarker923"/> the destructured <strong class="source-inline">checkedIds</strong> <span class="No-Break">variable </span><span class="No-Break"><strong class="source-inline">resolvedCheckedIds</strong></span><span class="No-Break">:</span><pre class="source-code">
const { <strong class="bold">resolvedCheckedIds</strong>, handleCheckChange } = useChecked(<strong class="bold">{</strong></pre><pre class="source-code">
<strong class="bold">  checkedIds,</strong></pre><pre class="source-code">
<strong class="bold">  onCheckedIdsChange,</strong></pre><pre class="source-code">
<strong class="bold">}</strong>);</pre><pre class="source-code">
return (</pre><pre class="source-code">
  &lt;ul className="bg-gray-300 rounded p-10" {...ulProps}&gt;</pre><pre class="source-code">
    {data.map((item) =&gt; {</pre><pre class="source-code">
      ...</pre><pre class="source-code">
      return (</pre><pre class="source-code">
        &lt;li ... &gt;</pre><pre class="source-code">
          &lt;label className="flex items-center"&gt;</pre><pre class="source-code">
            &lt;input</pre><pre class="source-code">
              type="checkbox"</pre><pre class="source-code">
              checked={<strong class="bold">resolvedCheckedIds</strong>.                includes(idValue)}</pre><pre class="source-code">
              onChange={handleCheckChange(idValue)}</pre><pre class="source-code">
            /&gt;</pre><pre class="source-code">
            ...</pre><pre class="source-code">
          &lt;/label&gt;</pre><pre class="source-code">
        &lt;/li&gt;</pre><pre class="source-code">
      );</pre><pre class="source-code">
    })}</pre><pre class="source-code">
  &lt;/ul&gt;</pre><pre class="source-code">
);</pre></li>
				<li>Open <strong class="source-inline">index.ts</strong> in the <strong class="source-inline">Checklist</strong> folder. Export the <strong class="source-inline">IdValue</strong> type because consumers of the component can now pass in <strong class="source-inline">checkedIds</strong>, which is an array of <span class="No-Break">this type:</span><pre class="source-code">
export type { IdValue } from './types';</pre></li>
			</ol>
			<p>The <strong class="source-inline">type</strong> keyword after the <strong class="source-inline">export</strong> statement is required by TypeScript when exporting a named type already exported from the <span class="No-Break">referenced file.</span></p>
			<ol>
				<li value="10">Now, open <strong class="source-inline">App.tsx</strong> and import <strong class="source-inline">useState</strong> from React, as well<a id="_idIndexMarker924"/> as the <span class="No-Break"><strong class="source-inline">IdValue</strong></span><span class="No-Break"> type:</span><pre class="source-code">
<strong class="bold">import { useState } from 'react';</strong></pre><pre class="source-code">
import {</pre><pre class="source-code">
  Checklist,</pre><pre class="source-code">
  <strong class="bold">IdValue</strong></pre><pre class="source-code">
} from './Checklist';</pre></li>
				<li>Define the state in the <strong class="source-inline">App</strong> component for the single <span class="No-Break">checked ID:</span><pre class="source-code">
function App() {</pre><pre class="source-code">
  <strong class="bold">const [checkedId, setCheckedId] = useState&lt;IdValue |     null&gt;(</strong></pre><pre class="source-code">
<strong class="bold">    null</strong></pre><pre class="source-code">
<strong class="bold">  );</strong></pre><pre class="source-code">
  ...</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>The state is <strong class="source-inline">null</strong> when there is no checked item. This can’t be set to <strong class="source-inline">undefined</strong> because <strong class="source-inline">Checklist</strong> will think <strong class="source-inline">checkedIds</strong> <span class="No-Break">is uncontrolled.</span></p>
			<ol>
				<li value="12">Create a handler for when an item <span class="No-Break">is checked:</span><pre class="source-code">
function handleCheckedIdsChange(newCheckedIds: IdValue[]) {</pre><pre class="source-code">
  const newCheckedIdArr = newCheckedIds.filter(</pre><pre class="source-code">
    (id) =&gt; id !== checkedId</pre><pre class="source-code">
  );</pre><pre class="source-code">
  if (newCheckedIdArr.length === 1) {</pre><pre class="source-code">
    setCheckedId(newCheckedIdArr[0]);</pre><pre class="source-code">
  } else {</pre><pre class="source-code">
    setCheckedId(null);</pre><pre class="source-code">
  }</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>The handler stores the checked ID in the state or sets the state to <strong class="source-inline">null</strong> if the checked item has <span class="No-Break">been unchecked.</span></p>
			<ol>
				<li value="13">Pass the checked ID<a id="_idIndexMarker925"/> and the change handler to the <strong class="source-inline">Checklist</strong> element <span class="No-Break">as follows:</span><pre class="source-code">
&lt;Checklist</pre><pre class="source-code">
  ...</pre><pre class="source-code">
  <strong class="bold">checkedIds={checkedId === null ? [] : [checkedId]}</strong></pre><pre class="source-code">
<strong class="bold">  onCheckedIdsChange={handleCheckedIdsChange}</strong></pre><pre class="source-code">
/&gt;;</pre></li>
				<li>Let’s give this a try. If the app isn’t running, run it by entering <strong class="source-inline">npm start</strong> in the terminal. You will find that only a single list item can <span class="No-Break">be checked.</span></li>
			</ol>
			<p>That completes this section on allowing the internal state to be controlled. Here’s <span class="No-Break">a recap:</span></p>
			<ul>
				<li>This pattern is useful because it changes the <span class="No-Break">component’s behavior</span></li>
				<li>The component must expose a prop to control the state value and another for its <span class="No-Break">change handler</span></li>
				<li>Internally, the component still manages the state and synchronizes it with the consumer’s <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">useEffect</strong></span></li>
				<li>If the state is controlled, the consumer’s change handler is called in the internal <span class="No-Break">change handler</span></li>
			</ul>
			<h1 id="_idParaDest-289"><a id="_idTextAnchor291"/>Summary</h1>
			<p>In this chapter, we created a reusable checklist component and used many useful patterns along <span class="No-Break">the way.</span></p>
			<p>We started by learning how to implement generic props, which allow a component to be used with varying data types but still be strongly typed. We used this to allow varying data to be passed into the checklist component without sacrificing <span class="No-Break">type safety.</span></p>
			<p>We learned how to allow consumers of a component to spread props onto an internal element. A common use case is spreading props onto the internal container element to allow the consumer to size it, which is what we did with the <span class="No-Break">checklist component.</span></p>
			<p>The render prop pattern is one of the most useful patterns when developing reusable components. We learned that it allows the consumer to take responsibility for rendering parts of the component. We used this pattern to override the rendering of list items in our <span class="No-Break">checklist component.</span></p>
			<p>Custom hooks isolate logic and are useful for sharing logic across components and keeping the code within a component clean. Custom hooks must call a standard React hook directly or indirectly. We extracted the checked logic from our checklist component into a <span class="No-Break">custom hook.</span></p>
			<p>The last pattern we learned about was allowing a component’s internal state to be controlled. This powerful pattern allows the consumer of the component to tweak its behavior. We used this to only allow a single list item to be checked in our <span class="No-Break">checklist component.</span></p>
			<p>In the next chapter, we will learn how to write automated tests for <span class="No-Break">React components.</span></p>
			<h1 id="_idParaDest-290"><a id="_idTextAnchor292"/>Questions</h1>
			<p>Answer the following questions to check what you have learned in <span class="No-Break">this chapter:</span></p>
			<ol>
				<li value="1">The snippet of the following component renders options and one can <span class="No-Break">be selected:</span><pre class="source-code">
type Props&lt;TOption&gt; = {</pre><pre class="source-code">
  options: TOption[];</pre><pre class="source-code">
  value: string;</pre><pre class="source-code">
  label: string;</pre><pre class="source-code">
};</pre><pre class="source-code">
export function Select({</pre><pre class="source-code">
  options,</pre><pre class="source-code">
  value,</pre><pre class="source-code">
  label,</pre><pre class="source-code">
}: Props&lt;TOption&gt;) {</pre><pre class="source-code">
  return ...</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>The following TypeScript error is raised on the component props parameter though: <strong class="bold">Cannot find name ‘TOption’</strong>. What is <span class="No-Break">the problem?</span></p>
			<ol>
				<li value="2">The <strong class="source-inline">value</strong> and <strong class="source-inline">label</strong> props from the component in <em class="italic">question 1</em> should only be set to a property name in the <strong class="source-inline">options</strong> value. What type can we give <strong class="source-inline">value</strong> and <strong class="source-inline">label</strong> so that TypeScript includes them in its <span class="No-Break">type checking?</span></li>
				<li>A prop called <strong class="source-inline">option</strong> has been added to the <strong class="source-inline">Select</strong> component from the previous question <span class="No-Break">as follows:</span><pre class="source-code">
type Props&lt;TOption&gt; = {</pre><pre class="source-code">
  ...,</pre><pre class="source-code">
  <strong class="bold">option: ReactNode;</strong></pre><pre class="source-code">
};</pre><pre class="source-code">
export function Select&lt;TOption&gt;({</pre><pre class="source-code">
  ...,</pre><pre class="source-code">
  <strong class="bold">option</strong></pre><pre class="source-code">
}: Props&lt;TOption&gt;) {</pre><pre class="source-code">
  return (</pre><pre class="source-code">
    &lt;div&gt;</pre><pre class="source-code">
      &lt;input /&gt;</pre><pre class="source-code">
      {options.map((option) =&gt; {</pre><pre class="source-code">
        <strong class="bold">if (option) {</strong></pre><pre class="source-code">
<strong class="bold">          return option;</strong></pre><pre class="source-code">
<strong class="bold">        }</strong></pre><pre class="source-code">
        return ...</pre><pre class="source-code">
      })}</pre><pre class="source-code">
    &lt;/div&gt;</pre><pre class="source-code">
  );</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p><strong class="source-inline">option</strong> is supposed to allow the consumer of the component to override the rendering of the options. Can you spot the flaw in <span class="No-Break">the implementation?</span></p>
			<ol>
				<li value="4">The following is a <strong class="source-inline">Field</strong> component that renders a <strong class="source-inline">label</strong> element and an <span class="No-Break"><strong class="source-inline">input</strong></span><span class="No-Break"> element:</span><pre class="source-code">
type Props = {</pre><pre class="source-code">
  label: string;</pre><pre class="source-code">
} &amp; ComponentPropsWithoutRef&lt;'input'&gt;;</pre><pre class="source-code">
export function Field({ ...inputProps, label }: Props) {</pre><pre class="source-code">
  return (</pre><pre class="source-code">
    &lt;&gt;</pre><pre class="source-code">
      &lt;label&gt;{label}&lt;/label&gt;</pre><pre class="source-code">
      &lt;input {...inputProps} /&gt;</pre><pre class="source-code">
    &lt;/&gt;</pre><pre class="source-code">
  );</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>There is a problem with the implementation though – can you <span class="No-Break">spot it?</span></p>
			<ol>
				<li value="5">How could the consumer specify props to spread onto the <strong class="source-inline">label</strong> element in the <strong class="source-inline">Field</strong> component from the previous question? Note that we still want the consumer to spread props onto the <span class="No-Break"><strong class="source-inline">input</strong></span><span class="No-Break"> element.</span></li>
				<li>A custom hook has been added to the <strong class="source-inline">Field</strong> component from the previous question. The custom hook is called <strong class="source-inline">useValid</strong>, which validates that the field has been filled in <span class="No-Break">with something:</span><pre class="source-code">
<strong class="bold">export function useValid() {</strong></pre><pre class="source-code">
<strong class="bold">  function validate(value: string) {</strong></pre><pre class="source-code">
<strong class="bold">    return (</strong></pre><pre class="source-code">
<strong class="bold">      value !== undefined &amp;&amp; value !== null &amp;&amp; value !==         ''</strong></pre><pre class="source-code">
<strong class="bold">    );</strong></pre><pre class="source-code">
<strong class="bold">  }</strong></pre><pre class="source-code">
<strong class="bold">  return validate;</strong></pre><pre class="source-code">
<strong class="bold">}</strong></pre><pre class="source-code">
export function Field({ ... }: Props) {</pre><pre class="source-code">
  <strong class="bold">const [valid, setValid] = useState(true);</strong></pre><pre class="source-code">
<strong class="bold">  const validate = useValid();</strong></pre><pre class="source-code">
  return (</pre><pre class="source-code">
    &lt;&gt;</pre><pre class="source-code">
      &lt;label {...labelProps}&gt;{label}&lt;/label&gt;</pre><pre class="source-code">
      &lt;input</pre><pre class="source-code">
        {...inputProps}</pre><pre class="source-code">
        <strong class="bold">onBlur={(e) =&gt; {</strong></pre><pre class="source-code">
<strong class="bold">          setValid(validate(e.target.value));</strong></pre><pre class="source-code">
<strong class="bold">        }}</strong></pre><pre class="source-code">
      /&gt;</pre><pre class="source-code">
<strong class="bold">      {!valid &amp;&amp; &lt;span&gt;Please enter something&lt;/span&gt;}</strong></pre><pre class="source-code">
    &lt;/&gt;</pre><pre class="source-code">
  );</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>What is wrong with <span class="No-Break">the implementation?</span></p>
			<ol>
				<li value="7">How many render props can a function <span class="No-Break">component have?</span></li>
			</ol>
			<h1 id="_idParaDest-291"><a id="_idTextAnchor293"/>Answers</h1>
			<ol>
				<li value="1">The generic type must be defined in the component function as well as <span class="No-Break">the prop:</span><pre class="source-code">
export function Select<strong class="bold">&lt;TOption&gt;</strong>({</pre><pre class="source-code">
  options,</pre><pre class="source-code">
  value,</pre><pre class="source-code">
  label,</pre><pre class="source-code">
}: Props&lt;TOption&gt;) {</pre><pre class="source-code">
  return ...</pre><pre class="source-code">
}</pre></li>
				<li>The <strong class="source-inline">keyof</strong> operator can be used to ensure <strong class="source-inline">value</strong> and <strong class="source-inline">label</strong> are keys <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">options</strong></span><span class="No-Break">:</span><pre class="source-code">
type Props&lt;TOption&gt; = {</pre><pre class="source-code">
  options: TOption[];</pre><pre class="source-code">
  value: keyof TOption;</pre><pre class="source-code">
  label: keyof TOption;</pre><pre class="source-code">
};</pre></li>
				<li>The consumer is likely to need the data for the option, so the prop should be a function containing the data as <span class="No-Break">a parameter:</span><pre class="source-code">
type Props&lt;TOption&gt; = {</pre><pre class="source-code">
  ...,</pre><pre class="source-code">
  renderOption: (<strong class="bold">option: TOption</strong>) =&gt; ReactNode;</pre><pre class="source-code">
};</pre><pre class="source-code">
export function Select&lt;TOption&gt;({</pre><pre class="source-code">
  options,</pre><pre class="source-code">
  value,</pre><pre class="source-code">
  label,</pre><pre class="source-code">
  renderOption,</pre><pre class="source-code">
}: Props&lt;TOption&gt;) {</pre><pre class="source-code">
  return (</pre><pre class="source-code">
    &lt;div&gt;</pre><pre class="source-code">
      &lt;input /&gt;</pre><pre class="source-code">
      {options.map((option) =&gt; {</pre><pre class="source-code">
        if (renderOption) {</pre><pre class="source-code">
          <strong class="bold">return</strong> <strong class="bold">renderOption(option);</strong></pre><pre class="source-code">
        }</pre><pre class="source-code">
        return ...</pre><pre class="source-code">
    &lt;/div&gt;</pre><pre class="source-code">
  );</pre><pre class="source-code">
}</pre></li>
				<li>There is a syntax error because the rest parameter is the first parameter. The rest parameter must be the <span class="No-Break">last one:</span><pre class="source-code">
export function Field({ label, <strong class="bold">...inputProps</strong> }: Props) {</pre><pre class="source-code">
  ...</pre><pre class="source-code">
}</pre></li>
				<li>A <strong class="source-inline">labelProps</strong> prop could be added using the <strong class="source-inline">ComponentPropsWithoutRef</strong> type. This could then be spread onto the <span class="No-Break"><strong class="source-inline">label</strong></span><span class="No-Break"> element:</span><pre class="source-code">
type Props = {</pre><pre class="source-code">
  label: string;</pre><pre class="source-code">
  <strong class="bold">labelProps: ComponentPropsWithoutRef&lt;'label'&gt;;</strong></pre><pre class="source-code">
} &amp; ComponentPropsWithoutRef&lt;'input'&gt;;</pre><pre class="source-code">
export function Field({</pre><pre class="source-code">
  label,</pre><pre class="source-code">
  <strong class="bold">labelProps</strong>,</pre><pre class="source-code">
  ...inputProps</pre><pre class="source-code">
}: Props) {</pre><pre class="source-code">
  return (</pre><pre class="source-code">
    &lt;&gt;</pre><pre class="source-code">
      &lt;label <strong class="bold">{...labelProps}</strong>&gt;{label}&lt;/label&gt;</pre><pre class="source-code">
      &lt;input {...inputProps} /&gt;</pre><pre class="source-code">
    &lt;/&gt;</pre><pre class="source-code">
  );</pre><pre class="source-code">
}</pre></li>
				<li><strong class="source-inline">useValid</strong> doesn’t call a standard React hook. A better implementation would be to extract the state into the custom hook <span class="No-Break">as well:</span><pre class="source-code">
export function useValid() {</pre><pre class="source-code">
  <strong class="bold">const [valid, setValid] = useState(true);</strong></pre><pre class="source-code">
  function validate(value: string) {</pre><pre class="source-code">
    <strong class="bold">setValid(</strong></pre><pre class="source-code">
      value !== undefined &amp;&amp; value !== null &amp;&amp; value !== ''</pre><pre class="source-code">
    <strong class="bold">)</strong>;</pre><pre class="source-code">
  }</pre><pre class="source-code">
  <strong class="bold">return { valid,</strong> validate <strong class="bold">}</strong>;</pre><pre class="source-code">
}</pre><pre class="source-code">
export function Field({ ... }: Props) {</pre><pre class="source-code">
  const <strong class="bold">{ valid,</strong> validate <strong class="bold">}</strong> = useValid();</pre><pre class="source-code">
  return (</pre><pre class="source-code">
    &lt;&gt;</pre><pre class="source-code">
      &lt;label {...labelProps}&gt;{label}&lt;/label&gt;</pre><pre class="source-code">
      &lt;input</pre><pre class="source-code">
        {...inputProps}</pre><pre class="source-code">
        onBlur={(e) =&gt; {</pre><pre class="source-code">
<strong class="bold">          validate(e.target.value);</strong></pre><pre class="source-code">
        }}</pre><pre class="source-code">
      /&gt;</pre><pre class="source-code">
      {!valid &amp;&amp; &lt;span&gt;Please enter something&lt;/span&gt;}</pre><pre class="source-code">
    &lt;/&gt;</pre><pre class="source-code">
  );</pre><pre class="source-code">
}</pre></li>
				<li>There is no limit on the number of render props a component <span class="No-Break">can have.</span></li>
			</ol>
		</div>
		<div>
			<div id="_idContainer164" class="IMG---Figure">
			</div>
		</div>
	</body></html>