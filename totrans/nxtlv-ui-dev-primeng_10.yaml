- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Exploring Optimization Techniques for Angular Applications
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Angular应用程序的优化技术
- en: In today’s digital age, users expect applications to be fast and responsive.
    A slight delay can lead to decreased user satisfaction and can even impact business
    metrics. By understanding and implementing performance optimization techniques,
    you ensure that your applications meet user expectations, leading to better user
    engagement, higher retention rates, and positive user feedback. So, as we delve
    deeper into the world of Angular and PrimeNG, it’s essential to ensure our applications
    are not just functional and aesthetically pleasing but also perform at their peak.
    This chapter is dedicated to equipping you with the tools and techniques to optimize
    the performance of Angular applications that utilize PrimeNG components.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今的数字时代，用户期望应用程序快速且响应灵敏。轻微的延迟可能会导致用户满意度下降，甚至影响业务指标。通过理解和实施性能优化技术，你确保你的应用程序满足用户期望，从而提高用户参与度、提高留存率和积极的用户反馈。因此，当我们深入Angular和PrimeNG的世界时，确保我们的应用程序不仅功能齐全且美观，而且性能达到顶峰是至关重要的。本章致力于为你提供工具和技术，以优化使用PrimeNG组件的Angular应用程序的性能。
- en: Throughout this chapter, you’ll delve into the core concepts of performance
    optimization. We’ll unravel some popular techniques, such as lazy loading, `trackBy`
    via `*ngFor`, pure pipes, bundle optimization, and more. As we progress, you’ll
    be introduced to the subtle nuances of change detection strategies, gaining a
    comprehensive understanding of their profound implications on performance. To
    round off, we’ll immerse you in hands-on sessions with Angular’s built-in performance
    tools. These tools stand out as true game-changers that are adept at pinpointing
    and rectifying performance bottlenecks.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将深入了解性能优化的核心概念。我们将揭示一些流行的技术，例如懒加载、通过`*ngFor`的`trackBy`、纯管道、包优化等。随着我们的进展，你将了解变更检测策略的微妙之处，从而全面理解它们对性能的深远影响。最后，我们将通过Angular内置的性能工具进行实战演练。这些工具是真正的变革者，擅长定位和纠正性能瓶颈。
- en: 'This chapter will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introducing Angular performance optimization
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Angular性能优化
- en: Working with performance profiling and analysis
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用性能分析和分析
- en: Implementing lazy loading and deferring
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现懒加载和延迟加载
- en: Working with change detection
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用变更检测
- en: Optimizing data binding
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化数据绑定
- en: Working with code and bundle optimization
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用代码和包优化
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter contains various working code samples on Angular optimization.
    You can find the related source code in the `chapter-10` folder in this book’s
    GitHub repository: [https://github.com/PacktPublishing/Next-Level-UI-Development-with-PrimeNG/tree/main/apps/chapter-10](https://github.com/PacktPublishing/Next-Level-UI-Development-with-PrimeNG/tree/main/apps/chapter-10).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含各种关于Angular优化的工作代码示例。你可以在本书GitHub仓库的`chapter-10`文件夹中找到相关源代码：[https://github.com/PacktPublishing/Next-Level-UI-Development-with-PrimeNG/tree/main/apps/chapter-10](https://github.com/PacktPublishing/Next-Level-UI-Development-with-PrimeNG/tree/main/apps/chapter-10)。
- en: Introducing Angular performance optimization
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Angular性能优化
- en: Every developer dreams of building applications that are both feature-rich and
    blazing fast. But as we add more features and complexity to our Angular applications,
    we might inadvertently introduce performance bottlenecks. That’s where **Angular
    performance optimization** comes into play. Let’s dive deep into understanding
    this crucial aspect of Angular development.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 每个开发者都梦想着构建功能丰富且速度极快的应用程序。但随着我们在Angular应用程序中添加更多功能和复杂性，我们可能会无意中引入性能瓶颈。这就是**Angular性能优化**发挥作用的地方。让我们深入了解Angular开发的这一关键方面。
- en: What is Angular performance optimization?
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是Angular性能优化？
- en: '**Angular performance optimization** refers to the practice of improving the
    performance and responsiveness of Angular applications by applying various techniques,
    strategies, and best practices. It involves identifying and addressing performance
    bottlenecks, reducing unnecessary computations, optimizing rendering processes,
    and minimizing load times. By optimizing the performance of Angular applications,
    we can enhance user satisfaction, minimize user exits, and improve overall application
    success.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**Angular 性能优化**是指通过应用各种技术、策略和最佳实践来提高 Angular 应用程序的性能和响应性。它涉及识别和解决性能瓶颈、减少不必要的计算、优化渲染过程和最小化加载时间。通过优化
    Angular 应用的性能，我们可以提高用户满意度，减少用户退出，并提高整体应用程序的成功率。'
- en: Major performance issues in Angular applications
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular 应用程序中的主要性能问题
- en: 'Angular is a powerful framework, but like any tool, it’s not immune to performance
    issues. Some of the common culprits are as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 是一个强大的框架，但像任何工具一样，它并非对性能问题免疫。一些常见的原因如下：
- en: '**Slow initial load time**: When an Angular application has a large code base,
    loading all the required resources can be time-consuming. Slow initial load times
    can significantly impact user perception and engagement.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓慢的初始加载时间**：当一个 Angular 应用程序拥有庞大的代码库时，加载所有必需的资源可能会很耗时。缓慢的初始加载时间会显著影响用户的感知和参与度。'
- en: '**Excessive change detection**: Angular’s default change detection mechanism
    can be computationally expensive, especially in large applications with frequent
    updates. Inefficient change detection can lead to unnecessary rendering and performance
    degradation.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过度变化检测**：Angular 的默认变化检测机制可能计算成本高昂，尤其是在大型应用程序中，频繁更新时。低效的变化检测可能导致不必要的渲染和性能下降。'
- en: '**Memory leaks**: These can occur when components or services are not destroyed
    properly, particularly in cases where you overlook unsubscribing from an observable,
    leading to increased memory usage over time.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存泄漏**：当组件或服务没有被正确销毁时，可能会发生这种情况，尤其是在你忽略取消订阅可观察对象的情况下，这会导致随着时间的推移内存使用量增加。'
- en: '**Complex computations**: Running complex algorithms or computations, especially
    in real-time scenarios such as animations, can slow down the application.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂的计算**：运行复杂的算法或计算，尤其是在实时场景如动画中，可能会减慢应用程序。'
- en: '**Inadequate lazy loading**: Loading all components and modules upfront, even
    if they are not immediately required, can result in increased initial load times.
    A lack of proper lazy loading techniques can impact the application’s performance
    negatively.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不足的懒加载**：即使组件不是立即需要的，也预先加载所有组件和模块，这可能会导致初始加载时间增加。缺乏适当的懒加载技术可能会对应用程序的性能产生负面影响。'
- en: Popular optimization techniques
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流行的优化技术
- en: 'To address these performance issues and optimize the performance of Angular
    applications, developers employ various techniques and strategies. Here are some
    popular optimization options:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些性能问题并优化 Angular 应用的性能，开发者采用各种技术和策略。以下是一些流行的优化选项：
- en: '**Performance profiling and analysis**: Angular provides built-in performance
    tools and techniques that allow us to profile and analyze the performance of our
    applications. Tools such as Angular DevTools help identify performance bottlenecks
    and provide insights for optimization.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能分析和分析**：Angular 提供了内置的性能工具和技术，允许我们分析和分析我们应用程序的性能。例如，Angular DevTools 工具可以帮助识别性能瓶颈并提供优化的见解。'
- en: '**Lazy loading and deferring**: They are techniques that load modules or components
    on-demand, rather than upfront. By implementing lazy loading and deferring in
    our Angular applications, we can reduce the initial load time and improve overall
    performance.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**懒加载和延迟加载**：它们是按需加载模块或组件的技术，而不是预先加载。通过在我们的 Angular 应用程序中实现懒加载和延迟加载，我们可以减少初始加载时间并提高整体性能。'
- en: '`Default` strategy and the `OnPush` strategy. By choosing the appropriate change
    detection strategy based on the application’s requirements, we can minimize unnecessary
    change detection and improve performance.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`默认` 策略和 `OnPush` 策略。根据应用程序的需求选择适当的变化检测策略，我们可以最小化不必要的检测并提高性能。'
- en: '`trackBy` function usage, helps minimize unnecessary updates and improve rendering
    performance. Optimized data binding ensures that only the necessary components
    are updated when changes occur.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trackBy` 函数的使用，有助于最小化不必要的更新并提高渲染性能。优化的数据绑定确保在发生变化时，只有必要的组件被更新。'
- en: '**Code and bundle optimization**: Minifying and bundling JavaScript and CSS
    files, tree shaking, and code splitting are techniques that are used to optimize
    the size and loading speed of Angular applications. These optimizations reduce
    network requests and improve overall performance.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码和包优化**：最小化、打包 JavaScript 和 CSS 文件、摇树优化和代码拆分是用于优化 Angular 应用程序大小和加载速度的技术。这些优化减少了网络请求并提高了整体性能。'
- en: Now that we understand Angular performance optimization and its significance,
    in the following sections, we will explore these techniques in detail. We will
    start with performance profiling and analysis.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 Angular 性能优化及其重要性，在接下来的章节中，我们将详细探讨这些技术。我们将从性能分析和分析开始。
- en: Introducing performance profiling and analysis
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入性能分析和分析
- en: '**Performance profiling** is similar to a health checkup for your application.
    It involves monitoring the application’s operations, understanding where it spends
    most of its time, and identifying potential bottlenecks. **Analysis**, on the
    other hand, is the subsequent step where this data is interpreted, issues are
    pinpointed, and strategies for performance enhancement are devised.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**性能分析**类似于您应用程序的健康检查。它涉及监控应用程序的操作，了解它大部分时间花在哪里，并识别潜在的瓶颈。另一方面，**分析**是后续步骤，其中这些数据被解释，问题被定位，并制定性能提升策略。'
- en: When is performance profiling and analysis used?
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能分析和分析何时使用？
- en: 'The need for performance profiling and analysis arises in the following situations:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下需要性能分析和分析：
- en: Parts of an application seem slower than expected
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序的部分似乎比预期慢
- en: There’s a desire to ensure that new implementations don’t degrade performance
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有确保新实现不会降低性能的愿望
- en: Large-scale applications need to optimize resource-intensive operations
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大型应用程序需要优化资源密集型操作
- en: The goal is to offer users a seamless experience, characterized by swift load
    times and fluid interactions
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标是向用户提供无缝体验，特点是快速加载时间和流畅的交互
- en: How does performance profiling and analysis work in Angular?
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular 中性能分析和分析是如何工作的？
- en: Performance profiling captures data about an application’s behavior during runtime.
    For Angular developers, a game-changer in this space is the **Angular DevTools**
    extension ([https://angular.io/guide/devtools](https://angular.io/guide/devtools)).
    This browser extension, tailored for Angular applications, offers insights into
    component tree structures and change detection cycles and even provides a dedicated
    performance profiling feature. It’s an indispensable tool that complements the
    browser’s native developer tools.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 性能分析捕获了应用程序在运行时行为的数据。对于 Angular 开发者来说，这个领域的变革者就是 **Angular DevTools** 扩展程序 ([https://angular.io/guide/devtools](https://angular.io/guide/devtools))。这个针对
    Angular 应用程序定制的浏览器扩展程序，提供了对组件树结构和变更检测周期的洞察，甚至提供了专门的性能分析功能。它是浏览器原生开发者工具的补充，不可或缺的工具。
- en: 'To utilize the Angular DevTools extension for performance profiling, follow
    these steps:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Angular DevTools 扩展程序进行性能分析，请按照以下步骤操作：
- en: Install the Angular DevTools extension in your preferred web browser. The extension
    is available for Chrome and Firefox and can be installed from the respective browser’s
    extension marketplace. In this section, I will use the Chrome browser.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您首选的网页浏览器中安装 Angular DevTools 扩展程序。扩展程序适用于 Chrome 和 Firefox，可以从相应浏览器的扩展程序市场安装。在本节中，我将使用
    Chrome 浏览器。
- en: Open the Chrome DevTools by right-clicking on an element of your Angular application
    and selecting **Inspect** (or by using the *Ctrl* + *Shift* + *I* keyboard shortcut).
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键单击您的 Angular 应用程序中的元素并选择 **Inspect**（或使用 *Ctrl* + *Shift* + *I* 键盘快捷键）来打开
    Chrome DevTools。
- en: In the Chrome DevTools, click on the **Angular** tab to switch to the Angular
    DevTools view.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Chrome DevTools 中，点击 **Angular** 选项卡以切换到 Angular DevTools 视图。
- en: '![Figure 10.1 – The Angular DevTools tab](img/B18805_10_01.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1 – Angular DevTools 选项卡](img/B18805_10_01.jpg)'
- en: Figure 10.1 – The Angular DevTools tab
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – Angular DevTools 选项卡
- en: 'Within the Angular DevTools, you can enable the performance profiling feature
    by clicking on the red circle to collect performance data related to rendering,
    change detection, and other Angular-specific activities:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Angular DevTools 中，您可以通过点击红色圆圈来启用性能分析功能，以收集与渲染、变更检测和其他 Angular 特定活动相关的性能数据：
- en: '![Figure 10.2 – Angular DevTools profiling](img/B18805_10_02.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.2 – Angular DevTools 性能分析](img/B18805_10_02.jpg)'
- en: Figure 10.2 – Angular DevTools profiling
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 – Angular DevTools 性能分析
- en: With performance profiling enabled, interact with your Angular application and
    perform typical user actions. The Angular DevTools extension will collect performance
    data in real time.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在启用性能分析的情况下，与你的Angular应用程序交互并执行典型的用户操作。Angular DevTools扩展将实时收集性能数据。
- en: Use Angular DevTools to inspect various performance metrics and identify areas
    of concern. For example, you can analyze the time spent on rendering individual
    components, the number of change detection cycles, or the duration of network
    requests.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Angular DevTools检查各种性能指标并确定关注区域。例如，你可以分析渲染单个组件所花费的时间、变更检测周期的数量或网络请求的持续时间。
- en: Based on the collected performance data, identify components, directives, or
    services that contribute to performance bottlenecks. Look for areas where rendering
    or change detection takes a significant amount of time or where unnecessary data
    fetching occurs.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据收集到的性能数据，确定对性能瓶颈有贡献的组件、指令或服务。寻找渲染或变更检测花费大量时间或发生不必要的数据获取的区域。
- en: Once performance bottlenecks have been identified, make targeted optimizations
    to the code, component structure, or data fetching mechanisms. This may involve
    optimizing change detection strategies, implementing memoization techniques, or
    introducing pagination or caching for data fetching.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦确定了性能瓶颈，就对代码、组件结构或数据获取机制进行有针对性的优化。这可能涉及优化变更检测策略、实现记忆化技术或引入分页或缓存以进行数据获取。
- en: After applying optimizations, reanalyze the performance of your Angular application
    using the Angular DevTools. Validate that the optimizations have improved the
    identified performance bottlenecks and have not introduced new issues. Iterate
    on the optimization process if further improvements are necessary.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用优化后，使用Angular DevTools重新分析你的Angular应用程序的性能。验证优化是否改善了已识别的性能瓶颈，并且没有引入新的问题。如果需要进一步改进，请迭代优化过程。
- en: By following these steps and utilizing the Angular DevTools extension, you can
    gain valuable insights into Angular applications’ performance characteristics.
    This enables you to make informed optimizations and improve the overall performance
    of the applications.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这些步骤并利用Angular DevTools扩展，你可以深入了解Angular应用程序的性能特征。这使你能够进行有针对性的优化并提高应用程序的整体性能。
- en: Note
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It’s easy to fall into the trap of over-optimization. Always weigh the benefits
    of optimization against the effort and complexity introduced. For example, if
    the component in question is relatively simple and the performance gains from
    implementing advanced optimization techniques are negligible or difficult to measure,
    it might be more practical to stick with the default change detection strategy
    provided by Angular. This ensures a balance between optimization and development
    effort, avoiding unnecessary complexity and potential trade-offs in code maintainability
    and readability.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 容易陷入过度优化的陷阱。始终权衡优化的好处与引入的努力和复杂性。例如，如果所讨论的组件相对简单，并且实施高级优化技术带来的性能提升微不足道或难以衡量，那么坚持使用Angular提供的默认变更检测策略可能更为实际。这确保了优化和开发努力之间的平衡，避免了不必要的复杂性以及代码可维护性和可读性方面的潜在权衡。
- en: Performance profiling and analysis serve as the magnifying glass, revealing
    the intricate details of our application’s behavior and efficiency. In the next
    section, we’ll delve into the realm of lazy loading, a technique that promises
    to further enhance our application’s responsiveness and speed.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 性能分析和分析就像放大镜，揭示了我们的应用程序行为和效率的复杂细节。在下一节中，我们将深入探讨懒加载这一技术，它承诺将进一步增强我们应用程序的响应性和速度。
- en: Implementing lazy loading and deferring
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现懒加载和延迟加载
- en: '**Lazy loading** and **deferring** are design patterns in which content is
    loaded only when it’s needed or requested, rather than loading everything upfront.
    This approach optimizes resource allocation and improves performance. Here is
    a detailed explanation of these concepts:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**懒加载**和**延迟加载**是设计模式，其中内容仅在需要或请求时加载，而不是一次性加载所有内容。这种方法优化了资源分配并提高了性能。以下是这些概念的详细解释：'
- en: '**Lazy loading**: Lazy loading is a design pattern in which content, such as
    Angular routes, components, or services, is loaded dynamically and on-demand,
    rather than everything being uploaded upfront. By implementing lazy loading, unnecessary
    resources are not loaded initially, resulting in a smaller initial bundle size
    and improved application startup times. This approach is particularly useful in
    large-scale applications, where loading all resources upfront can lead to performance
    degradation.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**懒加载**：懒加载是一种设计模式，其中内容，如Angular路由、组件或服务，是动态和按需加载的，而不是一开始就上传所有内容。通过实现懒加载，初始时不会加载不必要的资源，从而减小初始包的大小并提高应用程序的启动时间。这种方法在大型应用程序中特别有用，因为一开始就加载所有资源可能会导致性能下降。'
- en: '**Deferring**: Deferring is a design pattern that involves delaying the loading
    or execution of certain resources, such as scripts or assets, until they are needed.
    In the context of web development, deferring typically refers to deferring the
    loading of JavaScript files or other resources that are not essential for the
    initial rendering and functionality of a web page. By deferring the loading of
    non-critical resources, the web page can be rendered and displayed more quickly,
    improving the perceived performance and overall user experience. This technique
    is often employed to prioritize and optimize the loading of critical resources,
    allowing the page to be usable as soon as possible while non-essential resources
    are loaded in the background.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延迟加载**：延迟加载是一种设计模式，涉及延迟加载或执行某些资源，如脚本或资产，直到它们被需要。在Web开发中，延迟通常指的是延迟加载对网页初始渲染和功能非必要的JavaScript文件或其他资源。通过延迟加载非关键资源，网页可以更快地渲染和显示，提高感知性能和整体用户体验。这种技术通常用于优先和优化关键资源的加载，允许页面尽快可用，同时非必要资源在后台加载。'
- en: When are lazy loading and deferring used?
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 懒加载和延迟加载何时使用？
- en: 'Lazy loading and deferring are especially beneficial in the following scenarios:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 懒加载和延迟加载在以下场景中特别有益：
- en: '**Large applications**: For applications with numerous features and components,
    loading everything at once can be resource-intensive. Lazy loading ensures that
    only the necessary components are loaded, improving the initial load time.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大型应用程序**：对于具有众多功能和组件的应用程序，一次性加载所有内容可能会消耗大量资源。懒加载确保只加载必要的组件，从而提高初始加载时间。'
- en: '**User roles and permissions**: In applications where different users have
    different roles and permissions, lazy loading can be used to load components based
    on user roles, ensuring that users only download the features they have access
    to.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户角色和权限**：在具有不同用户角色和权限的应用程序中，可以使用懒加载根据用户角色加载组件，确保用户只下载他们可以访问的功能。'
- en: '**Network efficiency**: For users with slower internet connections, downloading
    a large application can be time-consuming. Lazy loading can help by reducing the
    initial download size.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络效率**：对于网络连接较慢的用户，下载大型应用程序可能耗时。懒加载可以通过减少初始下载大小来帮助。'
- en: '**Feature-rich platforms**: In platforms where certain features are used less
    frequently than others, it makes sense to defer those lesser-used features to
    improve the initial load time of the platform, resulting in faster rendering.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能丰富的平台**：在某些功能使用频率低于其他功能的平台上，将那些较少使用的功能延迟加载以提高平台的初始加载时间是有意义的，从而实现更快的渲染。'
- en: Example of lazy loading
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 懒加载示例
- en: 'Imagine an eCommerce platform built using Angular. This platform has various
    routes such as **Home**, **Product Listings**, **Product Details**, **Cart**,
    and **User Profile**. In a traditional loading approach, when a user visits the
    site, they would download all these routes/components upfront, even if they’re
    just browsing the **Home** page. For example, without lazy loading, the routing
    will look like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个使用Angular构建的电子商务平台。该平台有各种路由，如**首页**、**产品列表**、**产品详情**、**购物车**和**用户资料**。在传统的加载方法中，当用户访问网站时，他们会预先下载所有这些路由/组件，即使他们只是浏览**首页**。例如，如果没有使用懒加载，路由将看起来像这样：
- en: '[PRE0]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this code, the routing name is associated with a component. When the user
    navigates to the `home` page, `HomeComponent` will be displayed:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，路由名称与组件相关联。当用户导航到`home`页面时，将显示`HomeComponent`：
- en: '![Figure 10.3 – Page without lazy loading](img/B18805_10_03.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3 – 未使用懒加载的页面](img/B18805_10_03.jpg)'
- en: Figure 10.3 – Page without lazy loading
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – 未使用懒加载的页面
- en: You’ll notice that when the application is loaded, it loads all the necessary
    scripts from the beginning. As you can see, the main bundle size is **820 kB**
    and is loaded in **1.40 s**. When you navigate to other routes, their scripts
    are already ready-loaded. This could lead to unnecessary data consumption and
    a delay in page rendering, especially if the user never visits certain sections,
    such as **Cart** or **User Profile**, during their session. Let’s see how lazy
    loading can improve the current implementation.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，当应用程序加载时，它从开始就加载所有必要的脚本。如您所见，主包大小为 **820 kB**，加载时间为 **1.40 s**。当您导航到其他路由时，它们的脚本已经预先加载。这可能导致不必要的数据消耗和页面渲染延迟，尤其是如果用户在会话期间从未访问过某些部分，如
    **购物车** 或 **用户资料**。让我们看看懒加载如何改进当前实现。
- en: 'With lazy loading, the application can be structured to load the routes more
    intelligently:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用懒加载，应用程序可以被构建为更智能地加载路由：
- en: Initially, only the **Home** page is loaded when a user visits the site
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始情况下，当用户访问网站时，只加载 **主页**。
- en: If a user decides to view a product, the **Products** page is loaded on the
    fly
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户决定查看产品，**产品** 页面将即时加载。
- en: When the user wants to check their shopping cart, the **Cart** page is loaded
    just in time
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户想要检查他们的购物车时，**购物车** 页面将及时加载。
- en: If they decide to view or edit their profile, the **User Profile** page is then
    loaded
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果他们决定查看或编辑他们的资料，那么随后将加载 **用户资料** 页面。
- en: 'Here’s a basic example of how lazy loading can be implemented:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个懒加载如何实现的基本示例：
- en: '[PRE1]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code snippet, the `loadComponent` property is utilized to define
    functions that will load the respective component, but only when the routes are
    activated. This ensures that users only download the parts of the application
    they are actively engaging with, leading to faster load times and more efficient
    use of resources.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，使用 `loadComponent` 属性定义了将在路由激活时加载相应组件的函数。这确保了用户只下载他们正在积极交互的应用程序部分，从而加快加载时间并更有效地使用资源。
- en: 'Here is the result:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这是结果：
- en: '![Figure 10.4 – Page with lazy loading](img/B18805_10_04.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.4 – 带有懒加载的页面](img/B18805_10_04.jpg)'
- en: Figure 10.4 – Page with lazy loading
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4 – 带有懒加载的页面
- en: As you can see, the website only loads `main.js` and `HomeComponent` for the
    first navigation. You’ll observe a significant enhancement as the main bundle
    size has decreased from `CartComponent` if you navigate to the cart route, which
    is initiated from `app.routes.ts`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，网站仅在第一次导航时加载 `main.js` 和 `HomeComponent`。如果您导航到购物车路由，您将观察到主要包大小从 `CartComponent`
    显著减少，该路由是从 `app.routes.ts` 启动的。
- en: Example of PrimeNG deferring
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PrimeNG 延迟渲染示例
- en: PrimeNG’s **Defer** directive is a tool that’s designed to delay the loading
    of content until it enters the viewport. In essence, it’s a form of lazy loading,
    but for various types of content. By deferring the initialization of content until
    it’s needed, we can significantly improve the initial load time of a page.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: PrimeNG 的 **Defer** 指令是一个旨在延迟内容加载直到它进入视口的工具。本质上，它是一种懒加载的形式，但适用于各种类型的内容。通过将内容的初始化推迟到需要时，我们可以显著提高页面的初始加载时间。
- en: Take the eCommerce site as an example. The site lists hundreds of products on
    its `Defer`, we can optimize this.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以电子商务网站为例。该网站在其 `Defer` 中列出了数百个产品，我们可以进行优化。
- en: 'To do so, first, ensure you’ve imported `DeferModule` from PrimeNG:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，首先，请确保您已从 PrimeNG 导入 `DeferModule`：
- en: '[PRE2]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, let’s see how a PrimeNG `Defer` can be set up to display the product list:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何设置 PrimeNG 的 `Defer` 来显示产品列表：
- en: '[PRE3]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let’s break this down:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下：
- en: '`<div pDefer>`: The purpose of the `pDefer` directive is to defer the rendering
    of its contents until later in the rendering cycle. This directive must be followed
    by an `ng-template` element.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<div pDefer>`: `pDefer` 指令的目的是将内容的渲染推迟到渲染周期中的较晚阶段。此指令之后必须跟一个 `ng-template`
    元素。'
- en: '`<p-card *ngFor="let product of products">`: This element utilizes the `*ngFor`
    directive to iterate over an array of `products`, rendering one `<p-card>` for
    each product in the array.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<p-card *ngFor="let product of products">`: 此元素使用 `*ngFor` 指令遍历 `products`
    数组，为数组中的每个产品渲染一个 `<p-card>`。'
- en: After the implementation, the content of the product list will not appear until
    it becomes visible in the scroll.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在实施后，产品列表的内容将不会显示，直到它在滚动中变得可见。
- en: 'PrimeNG `Defer` is also beneficial when you want to fetch product data from
    an API after the product list is in the viewport, which will greatly enhance the
    performance of your application. Here is an example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: PrimeNG 的 `Defer` 组件在你希望在产品列表已进入视口后从 API 获取产品数据时也非常有益，这将大大提高你应用程序的性能。以下是一个示例：
- en: '[PRE4]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let’s break down the code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解代码：
- en: '`<div pDefer (onLoad)="loadAnotherProducts()">`: This `<div>` element is using
    the `pDefer` directive, which defers the loading products and rendering of its
    contents until the element is in the viewport.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<div pDefer (onLoad)="loadAnotherProducts()">`：此 `<div>` 元素使用 `pDefer` 指令，该指令将产品的加载和内容渲染延迟到元素进入视口。'
- en: '`loadAnotherProducts() { ... }`: This method is executed when the `(onLoad)`
    event is triggered. Inside the method, it calls `this.productService.loadProducts()`
    to load the products and assign the result to the `anotherProducts` property in
    the component.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loadAnotherProducts() { ... }`：当 `(onLoad)` 事件被触发时执行此方法。在方法内部，它调用 `this.productService.loadProducts()`
    来加载产品并将结果分配给组件中的 `anotherProducts` 属性。'
- en: Note
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you are working with `Table`, `Tree`, or a long list of items, you can implement
    `Virtual Scroller` or `Pagination` to help enhance performance and increase user
    experience.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在处理 `Table`、`Tree` 或长列表项，你可以实现 `Virtual Scroller` 或 `Pagination` 来帮助提高性能并增强用户体验。
- en: 'Harnessing the power of lazy loading and deferring can significantly enhance
    the performance of our applications, ensuring that users only load what they need
    when they need it. In the next section, we’ll delve into another crucial aspect
    of Angular performance: understanding and managing change detection.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 利用懒加载和延迟加载的强大功能可以显著提高我们应用程序的性能，确保用户在需要时才加载他们所需的内容。在下一节中，我们将深入探讨 Angular 性能的另一个关键方面：理解和管理变更检测。
- en: Working with change detection
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与变更检测一起工作
- en: '**Change detection** is the process by which Angular determines if components
    need to be updated in response to data changes. Whenever the data-bound properties
    of a component change, Angular checks if the view needs to be updated to reflect
    those changes. This process is automatic, but it’s essential to understand its
    workings to optimize performance.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**变更检测**是 Angular 确定组件是否需要根据数据更改进行更新的过程。每当组件的数据绑定属性更改时，Angular 会检查视图是否需要更新以反映这些更改。此过程是自动的，但了解其工作原理对于优化性能至关重要。'
- en: How does change detection work?
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变更检测是如何工作的？
- en: 'The change detection process in Angular follows a unidirectional flow. It starts
    from the root component and traverses down the component tree, checking for changes
    in each component. Here’s a brief overview of how change detection works in Angular:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 中的变更检测过程遵循单向流。它从根组件开始，遍历组件树，检查每个组件中的更改。以下是 Angular 中变更检测工作原理的简要概述：
- en: '**Initialization**: During component initialization, Angular sets up the component’s
    change detector and initializes the component’s properties and bindings.'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**初始化**：在组件初始化期间，Angular 设置组件的变更检测器并初始化组件的属性和绑定。'
- en: '`Default` strategy triggers change detection for a component whenever any of
    its input properties change or when an event binding is fired. Take the following
    component tree as an example:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Default` 策略在组件的任何输入属性更改或事件绑定被触发时触发变更检测。以下是一个组件树的示例：'
- en: '![  Figure 10.5 – Change detection – the default strategy](img/B18805_10_05.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.5 – 变更检测 – 默认策略](img/B18805_10_05.jpg)'
- en: Figure 10.5 – Change detection – the default strategy
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5 – 变更检测 – 默认策略
- en: When an event occurs on the `ProductList` component, the change detection process
    initiates, propagating from the root level (`AppComponent`) through all of its
    descendant components.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `ProductList` 组件发生事件时，变更检测过程开始，从根级别（`AppComponent`）开始，通过所有其子组件进行传播。
- en: 'On the other hand, the `OnPush` strategy triggers change detection only when
    an input property changes or when the component receives an event from its template
    or a component in its view hierarchy. In the same scenario previously illustrated
    in *Figure 10.5*, introducing the `OnPush` change detection strategy to the `ProductListDefer`
    component alters the behavior of the change detection process:'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，`OnPush` 策略仅在输入属性更改或组件从其模板或视图层次结构中的组件接收事件时触发变更检测。在之前图 10.5 中展示的相同场景中，向
    `ProductListDefer` 组件引入 `OnPush` 变更检测策略会改变变更检测过程的行为：
- en: '![  Figure 10.6 – Change detection – the OnPush strategy](img/B18805_10_06.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.6 – 变更检测 – OnPush 策略](img/B18805_10_06.jpg)'
- en: Figure 10.6 – Change detection – the OnPush strategy
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6 – 变更检测 – OnPush 策略
- en: Now, when an event occurs on the `ProductList` component, change detection is
    limited to the hierarchy from `AppComponent` to `Products` and down to `ProductList`.
    Notably, there is no change detection on the `ProductListDefer` component because
    no new reference is passed to the `ProductListDefer` component.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当 `ProductList` 组件上发生事件时，变更检测仅限于从 `AppComponent` 到 `Products` 以及到 `ProductList`
    的层次结构。值得注意的是，在 `ProductListDefer` 组件上没有变更检测，因为没有将新的引用传递给 `ProductListDefer` 组件。
- en: '**Change detection cycle**: Angular’s change detection system follows a cyclic
    process. In each cycle, the change detection process is performed for all components
    in the component tree. It involves the following steps:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**变更检测周期**: Angular 的变更检测系统遵循循环过程。在每个周期中，变更检测过程会对组件树中的所有组件执行。它包括以下步骤：'
- en: '**Change detection check**: Angular checks the component’s properties, bindings,
    and other inputs to detect changes. It compares the current values with the values
    that were stored during the previous change detection cycle.'
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**变更检测检查**: Angular 检查组件的属性、绑定和其他输入以检测变更。它将当前值与上一次变更检测周期中存储的值进行比较。'
- en: '**Update view**: If a change is detected, Angular updates the component’s view
    by updating the DOM elements associated with the changed properties or bindings.'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**更新视图**: 如果检测到变更，Angular 通过更新与变更属性或绑定相关的 DOM 元素来更新组件的视图。'
- en: '**Propagation**: If the component’s view is updated, Angular propagates the
    changes to the child components in the component tree, triggering their change
    detection process recursively.'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**传播**: 如果组件的视图被更新，Angular 将更改传播到组件树中的子组件，触发它们的变更检测过程递归执行。'
- en: '`ChangeDetectorRef` class provides a set of functions to interact with the
    change detection mechanism:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ChangeDetectorRef` 类提供了一套与变更检测机制交互的函数：'
- en: '`markForCheck()`: This function marks the component and its ancestors as needing
    checking during the next change detection cycle. Even if the component is not
    directly involved in the change, marking it for check ensures that its view will
    be updated.'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`markForCheck()`: 此函数将组件及其祖先标记为在下一个变更检测周期中需要检查。即使组件没有直接参与变更，标记为检查也确保其视图将被更新。'
- en: '`detach()`: This function detaches the component’s change detector from the
    change detector tree. This means that the component will be skipped during the
    change detection process until it is reattached.'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`detach()`: 此函数将组件的变更检测器从变更检测树中分离出来。这意味着在重新附加之前，组件将在变更检测过程中被跳过。'
- en: '`detectChanges()`: Invoking `detectChanges()` triggers a change detection cycle
    for the component and its descendants. This is particularly useful when you want
    to manually check for changes in response to specific events.'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`detectChanges()`: 调用 `detectChanges()` 触发组件及其后代的变更检测周期。这在您希望针对特定事件手动检查变更时特别有用。'
- en: '`reattach()`: This function reverses the effect of `detach()`. It reattaches
    the component’s change detector to the change detector tree, allowing it to participate
    in subsequent change detection cycles.'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reattach()`: 此函数抵消了 `detach()` 的效果。它将组件的变更检测器重新附加到变更检测树中，使其能够参与后续的变更检测周期。'
- en: One of the pivotal elements in Angular’s change detection mechanism is `zone.js`.
    This library plays a crucial role by “monkey-patching” most asynchronous operations
    in a browser, such as user interactions, HTTP requests, and timers.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 变更检测机制中的一个关键元素是 `zone.js`。这个库通过“猴子补丁”浏览器中的大多数异步操作（如用户交互、HTTP 请求和定时器）发挥关键作用。
- en: Note
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '**Monkey patching** is a technique that allows for the modification, extension,
    or even suppression of the default behavior of a code segment, all without requiring
    any direct changes to its source code.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**猴子补丁**是一种技术，允许修改、扩展甚至抑制代码段默认行为，而无需对其源代码进行任何直接更改。'
- en: When these operations are completed, `zone.js` notifies Angular to run change
    detection. Essentially, it acts as a watchdog, keeping an eye on all asynchronous
    tasks. Once any of these tasks are complete, `zone.js` informs Angular to check
    components and update the view if necessary.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些操作完成后，`zone.js` 通知 Angular 运行变更检测。本质上，它充当看门狗，监视所有异步任务。一旦这些任务中的任何一个完成，`zone.js`
    就会通知 Angular 检查组件并在必要时更新视图。
- en: For instance, when a user clicks a button, `zone.js` detects this interaction
    and tells Angular that something might have changed. Angular then runs the change
    detection process, checking if there are any actual changes to update in the view.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当用户点击按钮时，`zone.js` 检测到这种交互并告诉Angular可能发生了变化。然后Angular运行变更检测过程，检查是否有任何实际更改需要更新到视图中。
- en: Note
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For third-party scripts, one of the techniques that can help improve the performance
    of your application is to load the script and run the logic outside of Angular
    NgZone ([https://angular.io/api/core/NgZone#runoutsideangular](https://angular.io/api/core/NgZone#runoutsideangular)).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第三方脚本，可以帮助提高应用程序性能的技术之一是在Angular NgZone之外加载脚本并运行逻辑（[https://angular.io/api/core/NgZone#runoutsideangular](https://angular.io/api/core/NgZone#runoutsideangular)）。
- en: How change detection strategies affect performance
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变更检测策略如何影响性能
- en: The default change detection strategy is thorough but can be inefficient for
    large applications or complex component trees. Every minor data change triggers
    a check across all components, which can lead to lag or janky animations, especially
    on slower devices.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 默认变更检测策略非常彻底，但对于大型应用程序或复杂的组件树可能不够高效。每次数据发生微小变化时，都会触发对所有组件的检查，这可能导致延迟或卡顿的动画，尤其是在较慢的设备上。
- en: One way to improve performance is to utilize the `OnPush` strategy, in which
    we’re telling Angular to be more selective about when it checks for changes. This
    can lead to a noticeable performance boost as Angular will skip checking components
    that we know haven’t changed. However, it also means we need to be more mindful
    of when and how data changes to ensure our views remain up to date.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 提高性能的一种方法是通过使用 `OnPush` 策略，其中我们告诉Angular更谨慎地选择何时检查更改。这可能导致明显的性能提升，因为Angular将跳过检查那些我们知道没有发生变化的组件。然而，这也意味着我们需要更加注意何时以及如何更改数据，以确保我们的视图保持最新。
- en: Imagine that we have two lists that display a list of products using PrimeNG
    components. By default, Angular checks for changes in this component and all its
    children every time something happens in our application. However, if our product
    lists don’t change frequently, this can be overkill and lead to performance issues.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有两个列表，使用PrimeNG组件显示产品列表。默认情况下，Angular会在应用程序中发生任何事件时检查此组件及其所有子组件的更改。然而，如果我们的产品列表不经常更改，这可能过于冗余，并导致性能问题。
- en: 'Let’s look into the details of the default change detection strategy. Here
    is the sample code for the **Products** page:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解默认变更检测策略的细节。以下是**产品**页面的示例代码：
- en: '[PRE5]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding code snippet is an example of an Angular component called `ProductsComponent`.
    Let’s break down the code and explain its functionality:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段是一个名为 `ProductsComponent` 的Angular组件示例。让我们分析代码并解释其功能：
- en: '`<input type="text" pInputText (keyup)="filterProduct()" ... />`: This defines
    a PrimeNG input field that executes the `filterProduct()` method whenever a key
    is released in the input field'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<input type="text" pInputText (keyup)="filterProduct()" ... />`: 这定义了一个PrimeNG输入字段，每当在输入字段中释放按键时，都会执行
    `filterProduct()` 方法'
- en: '`<primengbook-product-list [products]="..." />`: This represents a custom component
    called `primengbook-product-list` and binds the `filteredProducts` or `anotherProducts`
    property of the component to the `products` input property'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<primengbook-product-list [products]="..." />`: 这代表一个名为 `primengbook-product-list`
    的自定义组件，并将组件的 `filteredProducts` 或 `anotherProducts` 属性绑定到 `products` 输入属性'
- en: 'This is an example of a standalone component utilizing the default change detection
    strategy, which is set to `Default` by default. Let’s observe how the application
    behaves in this scenario:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用默认变更检测策略的独立组件示例，默认情况下设置为 `Default`。让我们观察在这个场景下应用程序的行为：
- en: '![Figure 10.7 – A page using the default change detection strategy](img/B18805_10_07.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图10.7 – 使用默认变更检测策略的页面](img/B18805_10_07.jpg)'
- en: Figure 10.7 – A page using the default change detection strategy
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 – 使用默认变更检测策略的页面
- en: As you can see, after we type the keyword for filtering products, it rerenders
    the two lists of products and the total time spent for the entire app is 4.4 ms,
    even though we only do the search on one product list.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在输入过滤产品关键字后，它重新渲染了两个产品列表，整个应用程序的总耗时为4.4毫秒，尽管我们只在一个产品列表上进行了搜索。
- en: 'The ideal situation is that when you search, it will only touch one product
    list. To optimize the code so that it follows this, we can set the change detection
    strategy to `OnPush` in `ProductListComponent`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 理想的情况是，当你搜索时，它只会触及一个产品列表。为了优化代码以遵循这一点，我们可以在`ProductListComponent`中将变更检测策略设置为`OnPush`：
- en: '[PRE6]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With this setup, Angular will only check the one `ProductListComponent` for
    changes when its input properties change. This means that Angular won’t waste
    cycles checking unrelated components. Let’s see how the application performs this
    time:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种设置下，当输入属性更改时，Angular只会检查一个`ProductListComponent`以查找更改。这意味着Angular不会浪费周期检查无关组件。让我们看看这次应用程序的表现：
- en: '![Figure 10.8 – The page with the default change detection strategy](img/B18805_10_08.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图10.8 – 使用默认变更检测策略的页面](img/B18805_10_08.jpg)'
- en: Figure 10.8 – The page with the default change detection strategy
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8 – 使用默认变更检测策略的页面
- en: You’ll notice that when we search, our application only rerenders one product
    list, which reduced the time spent from 4.4 ms to 1.1 ms in total. This is a significant
    improvement if your application is complex.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，当我们搜索时，我们的应用程序只会重新渲染一个产品列表，这使总耗时从4.4毫秒减少到1.1毫秒。如果你的应用程序很复杂，这将是一个显著的改进。
- en: Potential pitfalls of OnPush
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OnPush的潜在陷阱
- en: While `OnPush` is powerful, it’s not without its quirks. One common issue you
    may run into is that changes made inside the component (such as user interactions)
    won’t trigger change detection. This can lead to situations where the UI doesn’t
    update, even though the data has changed.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`OnPush`功能强大，但它并非没有问题。你可能遇到的一个常见问题是，在组件内部（如用户交互）所做的更改不会触发变更检测。这可能导致即使数据已更改，UI也不会更新的情况。
- en: 'Another challenge is when working with objects and arrays. If you modify an
    object or array that’s an input property, but the reference remains the same,
    Angular won’t detect the change. This is where libraries such as `immutable.js`
    or Angular Signals come into play:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个挑战是在处理对象和数组时。如果你修改了一个作为输入属性的数组或对象，但引用保持不变，Angular将无法检测到变更。这就是像`immutable.js`或Angular
    Signals这样的库发挥作用的地方：
- en: '`List`, `Map`, and `Set` that, by design, cannot be modified after creation.
    This immutability ensures that any change to data results in a new object reference,
    making it more efficient for Angular to detect differences. Furthermore, `Immutable.js`
    encourages the use of pure functions when modifying data, creating new instances
    of data structures while preserving the original data. Angular can then efficiently
    identify changes by comparing object references.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List`、`Map`和`Set`在创建后不能被修改。这种不可变性确保了任何对数据的更改都会导致新的对象引用，这使得Angular检测差异更加高效。此外，`Immutable.js`鼓励在修改数据时使用纯函数，在保留原始数据的同时创建新的数据结构实例。然后，Angular可以通过比较对象引用来有效地识别更改。'
- en: '`update` also enforces an immutable approach, which is a usual practice when
    working with `OnPush` change detection.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update`还强制执行不可变方法，这在与`OnPush`变更检测一起工作时是一种常见做法。'
- en: I highly recommend using Signals when it’s ready for production to optimize
    the rendering updates since it is a built-in solution from Angular instead of
    a third-party library.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议在生产准备就绪时使用Signals来优化渲染更新，因为它是一个来自Angular的内置解决方案，而不是第三方库。
- en: 'In the realm of Angular, understanding change detection strategies is pivotal
    for ensuring our applications run efficiently. Next, let’s delve into another
    crucial aspect of Angular performance: optimizing data binding to further enhance
    our app’s responsiveness and speed.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular领域，理解变更检测策略对于确保我们的应用程序高效运行至关重要。接下来，让我们深入了解Angular性能的另一个关键方面：优化数据绑定，以进一步增强我们应用程序的响应性和速度。
- en: Optimizing data binding
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化数据绑定
- en: At its core, **data binding** in Angular is about keeping your view and component
    data in sync. It’s the magic that allows a change in your component data to reflect
    instantly in your view and vice versa. However, not all data changes are equal.
    Some are frequent and minor, while others are rare but significant. Optimized
    data binding is about being selective, updating the view only when truly necessary,
    and doing so in the most efficient manner.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，**数据绑定**的核心是保持视图和组件数据的一致性。这是允许组件数据的变化立即反映在视图上，反之亦然的魔法。然而，并非所有数据更改都是平等的。有些是频繁且微小的，而有些则是罕见但重要的。优化的数据绑定是关于选择性的，只在真正必要时更新视图，并以最有效的方式进行。
- en: When is optimized data binding used?
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用优化的数据绑定？
- en: 'Optimized data binding techniques are typically employed in the following scenarios:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 优化的数据绑定技术通常在以下场景中应用：
- en: '**Large datasets**: When working with large datasets, updating the entire view
    whenever a small portion of the data changes can be inefficient. Optimized data
    binding techniques help identify and update only the relevant portions of the
    view, minimizing unnecessary updates and improving performance.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大数据集**：当处理大数据集时，每次数据的一小部分更改时更新整个视图可能效率低下。优化的数据绑定技术有助于识别和更新视图的相关部分，最小化不必要的更新并提高性能。'
- en: '**Frequent updates**: In applications where data changes frequently, traditional
    data binding approaches can lead to excessive re-rendering and unnecessary DOM
    manipulations. Optimized data binding techniques help optimize data change detection
    and update processes to reduce overhead and improve responsiveness.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**频繁更新**：在数据频繁更改的应用程序中，传统的数据绑定方法可能导致过度重绘和不必要的 DOM 操作。优化的数据绑定技术有助于优化数据更改检测和更新过程，以减少开销并提高响应性。'
- en: '**Complex computation**: In some cases, data binding involves computationally
    expensive operations, such as sorting or filtering large arrays. Optimized data
    binding techniques can optimize these operations by selectively updating only
    the affected parts of the view, rather than re-rendering the entire dataset.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂计算**：在某些情况下，数据绑定涉及计算密集型操作，如对大数组进行排序或过滤。优化的数据绑定技术可以通过仅更新视图受影响的部分来优化这些操作，而不是重新渲染整个数据集。'
- en: A few optimized data binding techniques
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一些优化的数据绑定技术
- en: 'Optimizing data binding in Angular revolves around a few key strategies:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 优化 Angular 中的数据绑定围绕几个关键策略：
- en: '`*ngFor` to loop through items, by default, Angular checks each item in the
    list to detect changes. By using a `trackBy` function, you can instruct Angular
    to track items based on their unique IDs, reducing unnecessary checks.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*ngFor` 用于遍历项目，默认情况下，Angular 会检查列表中的每个项目以检测更改。通过使用 `trackBy` 函数，您可以指示 Angular
    根据其唯一 ID 跟踪项目，从而减少不必要的检查。'
- en: '**Pure pipes**: Pipes transform data in your template. A pure pipe only re-evaluates
    when the input changes, making it more efficient than its impure counterparts.
    It’s crucial to bear in mind that making external requests within pipes can cause
    performance issues and should be avoided.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纯管道**：管道在您的模板中转换数据。纯管道仅在输入更改时重新评估，这使得它比其不纯的对应物更高效。务必记住，在管道中执行外部请求可能会引起性能问题，应避免这样做。'
- en: '`OnPush` change detection strategy, Angular only triggers change detection
    for a component when its input properties change or when an event is raised within
    the component.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnPush` 更改检测策略，Angular 仅在组件的输入属性更改或组件内部引发事件时触发更改检测。'
- en: '**Immutable data structures**: Using immutable data structures can improve
    data binding performance. Immutable objects are not modified directly; instead,
    they create new instances when changes occur. This allows Angular to detect changes
    more efficiently and optimize rendering.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可变数据结构**：使用不可变数据结构可以提高数据绑定的性能。不可变对象在更改发生时不会直接修改；相反，它们在更改发生时创建新的实例。这允许 Angular
    更高效地检测更改并优化渲染。'
- en: In the following sections, we will explore examples of the `trackBy` function
    and pure pipes.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨 `trackBy` 函数和纯管道的示例。
- en: Optimized data binding example – the trackBy function
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化数据绑定示例 - `trackBy` 函数
- en: Imagine an eCommerce platform displaying a list of products. Each product has
    a name, price, and rating. With thousands of products, any change in the product
    list, such as a price update, could potentially trigger a massive view update.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个电子商务平台显示产品列表。每个产品都有一个名称、价格和评分。随着产品数量的增加，任何产品列表中的更改，如价格更新，都可能触发大量的视图更新。
- en: 'Using the `trackBy` function, we can ensure that only the affected product
    gets updated in the view:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `trackBy` 函数，我们可以确保只有受影响的产品在视图中得到更新：
- en: '[PRE7]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, the `trackBy` function ensures that Angular only updates the
    view for products with actual change based on product id value.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`trackBy` 函数确保 Angular 只根据产品 ID 值的实际更改更新产品的视图。
- en: 'PrimeNG also seamlessly supports the `trackBy` function. Since version 16.x,
    PrimeNG provides the `trackBy` property, where you can pass `trackBy` function
    to the data binding in the `DataView`, `OrderList`, `PickList`, and `Tree` components.
    Here’s an example of how to use it:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: PrimeNG 也无缝支持 `trackBy` 函数。自 16.x 版本以来，PrimeNG 提供了 `trackBy` 属性，您可以将 `trackBy`
    函数传递到 `DataView`、`OrderList`、`PickList` 和 `Tree` 组件的数据绑定中。以下是如何使用它的示例：
- en: '[PRE8]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As demonstrated in the `DataView` component, you can assign the `trackByProductId`
    function to the `trackBy` property. This configuration ensures that the view is
    only updated when the product ID value changes.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如`DataView`组件所示，你可以将`trackByProductId`函数分配给`trackBy`属性。这种配置确保只有当产品ID值发生变化时，视图才会更新。
- en: Optimized data binding example – pure pipes
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化数据绑定示例 – 纯管道
- en: Suppose you have an Angular application that displays a list of products. Each
    product has properties such as name, price, and quantity. The application also
    allows the user to calculate the product’s pricing using a calculation based on
    the existing product quantity.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个Angular应用程序，它显示产品列表。每个产品都有名称、价格和数量等属性。该应用程序还允许用户使用基于现有产品数量的计算来计算产品的定价。
- en: 'Without using pure pipes, you might have a component template that looks like
    this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 不使用纯管道时，你的组件模板可能看起来像这样：
- en: '[PRE9]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this example, the `calculateTotal` function is called for each product to
    calculate the total price based on the existing product quantity. Consider the
    scenario where the `calculateTotal` function is a custom function that performs
    a complex calculation. Let’s look at the result:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`calculateTotal`函数为每个产品调用，根据现有产品数量计算总价。考虑以下场景，`calculateTotal`函数是一个执行复杂计算的定制函数。让我们看看结果：
- en: '![Figure 10.9 – Calculating the total price from the template](img/B18805_10_09.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图10.9 – 从模板计算总价](img/B18805_10_09.jpg)'
- en: Figure 10.9 – Calculating the total price from the template
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9 – 从模板计算总价
- en: As you can see, without any optimization, every time a change is made to the
    product or the page, the `calculateTotal` function would be called for all products,
    even if only a single product’s quantity has changed. This leads to unnecessary
    executions, even if only a single product’s quantity has changed, resulting in
    20 executions, as indicated in the console log. This can lead to redundant recalculations
    and harm performance, particularly when working with extensive datasets.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在没有任何优化的情况下，每次对产品或页面进行更改时，`calculateTotal`函数都会为所有产品调用，即使只有单个产品的数量发生变化。这会导致不必要的执行，即使只有单个产品的数量发生变化，也会导致20次执行，如控制台日志中所示。这可能导致冗余的重新计算并损害性能，尤其是在处理大量数据集时。
- en: 'To optimize the performance using pure pipes, you can create a custom pure
    `pipe` called `TotalPipe` that calculates the total price for a given product:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用纯管道优化性能，你可以创建一个自定义纯`pipe`，称为`TotalPipe`，它计算给定产品的总价：
- en: '[PRE10]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, `TotalPipe` has been declared as a pure pipe by setting the
    `pure` property to `true` in the `@Pipe` decorator. This ensures that the pipe
    will only recalculate its output when the quantity value changes.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`TotalPipe`通过在`@Pipe`装饰器中将`pure`属性设置为`true`被声明为一个纯管道。这确保了管道只有在数量值发生变化时才会重新计算其输出。
- en: 'Now, you can use `TotalPipe` in your component template:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在你的组件模板中使用`TotalPipe`：
- en: '[PRE11]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'By using `TotalPipe`, the calculation of the total price is now delegated to
    the pipe. If a change is made to the quantity of a product, only the affected
    product’s total price will be recalculated; the other products will remain unaffected:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`TotalPipe`，现在将总价的计算委托给了管道。如果更改了产品的数量，只有受影响产品的总价将被重新计算；其他产品将保持不变：
- en: '![Figure 10.10 – Calculating the total price from the pipe](img/B18805_10_10.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图10.10 – 从管道计算总价](img/B18805_10_10.jpg)'
- en: Figure 10.10 – Calculating the total price from the pipe
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10 – 从管道计算总价
- en: As we can see, when there is a change in the quality or product, it only affects
    one product instead of there being 20 changes (*Figure 10**.9*), as in the previous
    approach. This optimization significantly improves performance, especially when
    dealing with large datasets or complex calculations.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，当产品质量或产品发生变化时，它只会影响一个产品，而不是像之前的方法那样有20个变化（**图10.9**），这显著提高了性能，尤其是在处理大量数据集或复杂计算时。
- en: 'In conclusion, optimizing data binding in web applications is essential for
    improving performance and reducing unnecessary re-rendering. By following best
    practices, you can minimize the impact of data binding on application performance.
    Now, let’s transition to the next topic: code and bundle optimization.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，优化Web应用程序中的数据绑定对于提高性能和减少不必要的重新渲染至关重要。通过遵循最佳实践，你可以最小化数据绑定对应用程序性能的影响。现在，让我们过渡到下一个主题：代码和捆绑优化。
- en: Working with code and bundle optimization
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与代码和捆绑优化一起工作
- en: '**Code and bundle optimization** refers to the process of optimizing the code
    base and the resulting bundles in a web application to enhance its performance
    and efficiency. It involves analyzing, restructuring, and minimizing code to eliminate
    redundancies, reduce file sizes, and improve execution speed.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码和包优化**是指优化 Web 应用程序中的代码库和生成的包的过程，以提高其性能和效率。它涉及分析、重构和最小化代码，以消除冗余、减少文件大小并提高执行速度。'
- en: Optimizing both the code and bundle size is essential for delivering faster-loading
    web applications, reducing bandwidth usage, and enhancing the overall user experience.
    It helps ensure that the application loads quickly, responds promptly to user
    interactions, and performs efficiently across a range of devices and network conditions.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 优化代码和包大小对于提供快速加载的 Web 应用程序、减少带宽使用和提升整体用户体验至关重要。它有助于确保应用程序快速加载，对用户交互做出及时响应，并在各种设备和网络条件下高效运行。
- en: When is code and bundle optimization used?
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用代码和包优化？
- en: 'Optimization isn’t just a one-time task; it’s an ongoing process. As soon as
    our application starts to grow, or when we notice performance issues, it’s time
    to consider optimization. It’s especially crucial for the following aspects:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 优化不仅仅是一项一次性任务；它是一个持续的过程。一旦我们的应用程序开始增长，或者当我们注意到性能问题时，就是考虑优化的时间了。对于以下方面来说，它尤其重要：
- en: Large applications with extensive code bases
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有广泛代码库的大型应用程序
- en: Apps that rely on several third-party libraries or frameworks
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖于多个第三方库或框架的应用程序
- en: Applications targeting regions with slower internet connections
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 针对网络连接较慢地区的应用程序
- en: Projects aiming for faster load times and improved user experience
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旨在实现更快的加载时间和改进用户体验的项目
- en: Utilizing Source Map Explorer for bundle optimization
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用 Source Map Explorer 进行包优化
- en: One of the most effective tools for understanding the composition of your application’s
    bundles is **Source Map Explorer**. It provides a visual representation of the
    different parts of your bundle, making it easier to identify large chunks of code
    or unnecessary libraries that might be affecting your app’s performance.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 理解您应用程序包组成的最高效工具之一是 **Source Map Explorer**。它提供了您包不同部分的视觉表示，使得识别可能影响应用程序性能的大量代码块或不必要的库变得更容易。
- en: 'Before diving into its usage, let’s set up Source Map Explorer:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解其用法之前，让我们设置 Source Map Explorer：
- en: 'You can add Source Map Explorer to your project by using `npm` or `yarn`. Run
    the following command in your project directory:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过使用 `npm` 或 `yarn` 将 Source Map Explorer 添加到您的项目中。在您的项目目录中运行以下命令：
- en: '[PRE12]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To generate source maps during the build process, you need to adjust the Angular
    build configuration. In your `angular.json` file, locate the `sourceMap` option
    within your application’s build configurations and set it to `true`:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构建过程中生成源映射，您需要调整 Angular 的构建配置。在您的 `angular.json` 文件中，找到您应用程序的构建配置中的 `sourceMap`
    选项，并将其设置为 `true`：
- en: '[PRE13]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With the tool installed and the configuration adjusted, you’re ready to analyze
    your bundles:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了工具并调整了配置后，您就可以准备分析您的包了：
- en: 'First, you need to create a production build of your Angular application with
    source maps. Use the following command to do so:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您需要创建一个带有源映射的生产构建版本的 Angular 应用程序。使用以下命令来完成此操作：
- en: '[PRE14]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After building, navigate to the `dist` folder (or wherever your build artifacts
    are located). You’ll find several `.js` and `.js.map` files. To analyze a specific
    bundle, use Source Map Explorer, like so:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建（build）完成后，导航到 `dist` 文件夹（或您的构建工件所在的任何位置）。您将找到几个 `.js` 和 `.js.map` 文件。要分析特定的包，请使用
    Source Map Explorer，如下所示：
- en: '[PRE15]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Source Map Explorer will present a visual treemap of your bundle. Each section
    represents a portion of your code or an imported library. The size and position
    of each section correlate with its size in the bundle. Hovering over a section
    will display more detailed information. Here is an example:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Source Map Explorer 将展示您包的视觉树状图。每个部分代表您代码的一部分或一个导入的库。每个部分的大小和位置与其在包中的大小相对应。将鼠标悬停在一个部分上会显示更详细的信息。以下是一个示例：
- en: '![Figure 10.11 – Visual map of the bundle](img/B18805_10_11.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.11 – 包的视觉映射](img/B18805_10_11.jpg)'
- en: Figure 10.11 – Visual map of the bundle
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.11 – 包的视觉映射
- en: The treemap’s visual representation makes it easier to spot large libraries
    or chunks of code. If you see a library that you don’t recognize or seems disproportionately
    large, it might be worth investigating further. You can research the unfamiliar
    library, analyze its dependencies, review its usage in your code base, and seek
    community feedback to understand its purpose and impact on performance.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 树状图的视觉表示使得更容易发现大型库或代码块。如果你看到你不认识的库或看起来不成比例地大，可能值得进一步调查。你可以研究这个不熟悉的库，分析其依赖关系，审查它在你的代码库中的使用情况，并寻求社区反馈以了解其目的和性能影响。
- en: Note
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: While source maps are invaluable for development and analysis, they can expose
    your application’s code structure. Always ensure that source maps are not served
    in a production environment unless you want to debug on production.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然源映射对于开发和分析来说非常有价值，但它们可能会暴露你的应用程序的代码结构。始终确保在生产环境中不提供源映射，除非你希望在生产环境中进行调试。
- en: In the web development world, optimizing your code and bundles is essential
    to achieving the best application performance. Through tools and techniques such
    as Source Map Explorer, we’ve learned how to dissect and refine our application
    bundles for peak efficiency. As we wrap up this chapter, let’s take a moment to
    reflect on the key takeaways.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络开发世界中，优化你的代码和包对于实现最佳应用程序性能至关重要。通过使用源映射探索器等工具和技术，我们学会了如何剖析和精炼我们的应用程序包以实现峰值效率。在我们结束本章之前，让我们花点时间反思关键要点。
- en: Summary
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Throughout this chapter, we delved deep into the world of performance and optimization.
    We embarked on a journey to understand the intricacies of Angular performance,
    from the foundational concepts of lazy loading to the advanced techniques of code
    and bundle optimization.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了性能和优化的世界。我们踏上了一段旅程，以了解Angular性能的复杂性，从懒加载的基础概念到代码和包优化的高级技术。
- en: At this point, you’re equipped with the knowledge of how to optimize Angular
    applications, especially those utilizing PrimeNG components. We’ve seen firsthand
    the transformative power of efficient change detection strategies, the nuances
    of optimized data binding, and the importance of analyzing and refining our application
    bundles. These techniques are not just theoretical; they have practical implications
    that can drastically improve the user experience of your applications.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经掌握了如何优化Angular应用程序的知识，特别是那些使用PrimeNG组件的应用程序。我们亲眼见证了高效变更检测策略的变革力量，优化数据绑定的微妙之处，以及分析和精炼我们的应用程序包的重要性。这些技术不仅仅是理论上的；它们具有实际意义，可以极大地改善你应用程序的用户体验。
- en: Why is this so crucial? In the fast-paced digital age, every millisecond counts.
    Users expect seamless, lightning-fast applications, and even the slightest delay
    can impact user retention and satisfaction. By implementing the strategies we’ve
    discussed, you’re not just enhancing your application’s performance; you’re also
    ensuring that your users have the best experience possible.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这如此关键？在快节奏的数字时代，每一毫秒都很重要。用户期望无缝、闪电般快速的应用程序，即使是微小的延迟也可能影响用户保留率和满意度。通过实施我们讨论过的策略，你不仅提高了应用程序的性能；你还确保了用户获得最佳体验。
- en: As we transition to the next chapter, we’ll shift our focus to building reusable
    components that can be easily integrated and adapted across various parts of our
    applications. This will empower you to write code that’s not only efficient but
    also modular and maintainable. So, gear up for another exciting journey where
    we’ll delve into the best practices and techniques for crafting versatile Angular
    components.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们过渡到下一章时，我们将把重点转向构建可重用组件，这些组件可以轻松集成和适应我们应用程序的各个部分。这将使你能够编写既高效又模块化、易于维护的代码。因此，准备好开始另一段激动人心的旅程，我们将深入探讨构建多才多艺的Angular组件的最佳实践和技术。
