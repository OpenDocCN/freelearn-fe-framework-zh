<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Working with Microservices</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, we created a gateway and two microservices using JHipster; now, let's see how we can further develop our microservices to include our domain model and additional business logic. Since we are converting our online shop monolith to a microservice architecture, we will see how the domain model we created using JDL can be converted into a microservice domain model. But before we can start, we need to set up some tools in order to work with microservices.</p>
<p>So in this chapter, we will see the following topics:</p>
<ul>
<li>How to set up JHipster Registry</li>
<li>How to run the microservice setup locally</li>
<li>Creating the domain model using JDL</li>
<li>Generating the domain model in JHipster</li>
</ul>
<p>Let's get started!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up JHipster Registry locally</h1>
                </header>
            
            <article>
                
<p><span>We have created our gateway and two microservice applications. The microservices have two different databases. So far, it has been easy and simple to create those with JHipster. </span></p>
<p>JHipster provides two different options we have previously seen, Consul and JHipster Registry. For our use case, let's go with JHipster Registry. We have already learned about JHipster Registry in <a href="673932d7-7927-4a12-8c02-86197cc8d3aa.xhtml" target="_blank">Chapter 8</a>, <em>Introduction to Microservice Server-Side Technologies.</em> Now, we will see how to set up and start it in our local development environment.</p>
<p><span>Now, these three services basically act as Eureka clients. We need a service registry that registers and deregisters the application as and when the application is started and stopped, respectively; this is JHipster Registry.</span> The Eureka<span> server (JHipster Registry server) acts as a master to all the Eureka clients.</span></p>
<p>Since JHipster Registry, as the name suggests, acts as a registry service, all microservice applications and the gateway will register/deregister themselves when the application starts and stops.</p>
<p>Let's recap a little bit of what we learned already. The JHipster Registry is made up of a Eureka server and Spring Cloud Config server and they help in the following </p>
<ul>
<li><strong>The Eureka server </strong>helps in service discovery and load balancing the requests.</li>
<li><strong>The Spring Cloud Config server</strong> acts as a single place where we will manage the external properties of applications across environments. It also provides a dashboard for users. With this, users can manage and monitor the application.</li>
</ul>
<p>This makes JHipster Registry an ideal <span>choice for both monolithic and microservice architectures.</span></p>
<div class="packt_infobox">If you are developing microservice applications where different services are written in different languages, and if you prefer consistency over availability of services, then you can choose Consul.</div>
<div>
<p>There are three ways in which we can set up JHipster Registry to run locally. </p>
<p>We can either download the WAR file (pre-packaged) and run it directly, or clone our GitHub repository and run from there. We can also use a Docker container to run it. We will see how to do each of these now.</p>
</div>
<div class="packt_tip">You can choose to use JHipster Registry while generating monolithic applications as well. Just select <span class="packt_screen">yes</span> for the question <span class="packt_screen">Do you want to use the JHipster Registry to configure, monitor and scale your application?</span> during generation.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using a pre-packaged WAR file</h1>
                </header>
            
            <article>
                
<p><span>Download the latest version of the pre-packaged executable WAR file from the </span>registry releases page (<a href="https://github.com/jhipster/jhipster-registry/releases">https://github.com/jhipster/jhipster-registry/releases</a>):</p>
<ol>
<li>Open your terminal and then type the following command, replacing <kbd>&lt;version&gt;</kbd> with the latest one. If you are using Windows and do not have <kbd>curl</kbd> set up, you can also download the file by visiting the link in a browser:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt; curl https://github.com/jhipster/jhipster-registry/releases/download/v<em>&lt;version&gt;</em>/jhipster-registry-<em>&lt;version&gt;</em>.war</strong> </pre>
<ol start="2">
<li>This will download the latest WAR file from the JHipster Registry project. Once downloaded, we can run JHipster Registry using the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt; ./jhipster-registry-&lt;version&gt;.war --security.user.password=admin --jhipster.security.authentication.jwt.secret=secret-key --spring.cloud.config.server.native.search.locations=file:./central-config</strong></pre>
<p>Note that we pass a few values to our registry server; they are:</p>
<pre><strong>--security.user.password=admin</strong></pre>
<p class="mce-root">Since JHipster Registry is built on top of the JHipster application, it will have the default admin user. For that admin user, we provide the password with the Spring property <kbd>security.user.password</kbd>:</p>
<pre><strong>--jhipster.security.authentication.jwt.secret=secret-key</strong></pre>
<p>Then we define the JWT token for the application in two ways. We can either set the information in the environment variable and use that, or else add this key value when we define the secret. This also uses the <kbd>spring config</kbd> property to set the property:</p>
<pre><strong>--spring.cloud.config.server.native.search.locations</strong></pre>
<ol start="3">
<li>Finally, we tell the JHipster Registry where to find the central configurations that are available for the Spring Cloud Config server.</li>
</ol>
<p>Before we see what value to pass in here, we need to know about the Spring profiles in the context of <kbd>spring-cloud-config</kbd>. Spring Cloud Config supports <kbd>native</kbd> and <kbd>git</kbd> profiles by default.</p>
<p>In a <kbd>native</kbd> profile, the Cloud Config server expects its properties to be defined in a file, and we have to pass in the file location to the JHipster Registry. On the other hand, the <kbd>git</kbd> profile will expect <kbd>--spring.cloud.config.server.git.uri</kbd> to be set.</p>
<p>For example, the sample JHipster config file for the the registry is as follows:</p>
<pre>configserver:<br/>    name: JHipster Registry config server<br/>    status: Connected to the JHipster Registry config server using ...<br/>jhipster:<br/>    security:<br/>        authentication:<br/>            jwt:<br/>               secret: awesome-my-secret-token-to-change-in-production</pre>
<p>This can be seen in the Spring Cloud Configuration page of the Registry as well:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b8e07533-0801-4208-9a96-c5446ee1a212.png"/></div>
<p><span>Just like the JHipster app provides</span> <kbd>dev</kbd><span> and</span> <kbd>prod</kbd><span> profiles, JHipster Registry also supports</span> <kbd>dev</kbd><span> and <kbd>prod</kbd> profiles. By default, it will start in the </span><kbd>dev</kbd><span> profile when started, but we can make it run in a </span><kbd>prod</kbd><span> profile using </span> <kbd>--spring.profiles.active=prod,git</kbd>, <span>passing in the</span> <kbd>git</kbd> <span>URL, and then defining the configuration properties there. For production mode,</span> <kbd>git</kbd><span> is the preferred profile to use on a Spring Cloud Server.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building from source</h1>
                </header>
            
            <article>
                
<p>If you want to work on leading-edge technology and are interested in exploring the latest features added to the JHipster Registry, then you can go a step further and clone the repository from GitHub:</p>
<ol>
<li>Navigate to your preferred folder and run the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt; git clone https://github.com/jhipster/jhipster-registry</strong></pre>
<ol start="2">
<li>Once cloned, navigate to the folder using the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt; cd jhipster-registry</strong></pre>
<ol start="3">
<li>Run the application in dev mode as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt; ./mvnw</strong> </pre>
<p style="padding-left: 60px">You can also run it in prod mode as follows:</p>
<pre style="padding-left: 60px"><strong>&gt; ./mvnw -Pprod</strong></pre>
<ol start="4">
<li>You can also package and run the WAR file:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt; ./mvnw -Pprod package</strong><br/><strong>&gt; target/jhipster-registry-&lt;version&gt;.war --spring.profiles.active=prod,git</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Docker mode</h1>
                </header>
            
            <article>
                
<p>You can also start JHipster Registry from the provided Docker image. The application that we generated already has the <kbd>docker-compose</kbd> file required.</p>
<p>For example, in the gateway application we created, look for the <kbd>docker-compose</kbd> file under <kbd>src/main/docker/jhipster-registry.yml</kbd>.</p>
<p>We can start the JHipster Registry by typing the following command in the terminal:</p>
<pre><strong>&gt; cd gateway</strong><br/><strong>&gt; docker-compose -f src/main/docker/jhipster-registry.yml up</strong></pre>
<p>The <kbd>docker compose</kbd> file (<kbd>src/main/docker/jhipster-registry.yml</kbd><span>) contains:</span></p>
<pre>version: 2<br/>services:<br/>    jhipster-registry: <br/>        image: jhipster/jhipster-registry:v3.2.3<br/>        volumes:<br/>            - ./central-server-config:/central-config<br/>        environment:<br/>            - SPRING_PROFILES_ACTIVE=dev<br/>            - SECURITY_USER_PASSWORD=admin<br/>            - JHIPSTER_REGISTRY_PASSWORD=admin<br/>            - SPRING_CLOUD_CONFIG_SERVER_NATIVE_SEARCH_LOCATION= file:./central-config<br/>        ports:<br/>            -8761:8761</pre>
<p>This defines the image as <kbd>jhipster-registry</kbd> with a version (the latest). It also defines a volume to mount the <kbd>central-config</kbd>, which is required by the Spring Cloud Config server to define the application properties for the microservice application and gateway. The environment variables such as the Spring profile, password for the admin, and cloud config search location<span> are also defined </span>here. The port in which it is exposed (<kbd>8761</kbd>) is also specified.</p>
<div class="packt_infobox">Of course, this needs Docker to be installed and running on the machine.</div>
<p>In all preceding cases (when they are successful), it boots up JHipster Registry on port <kbd>8761</kbd> and uses native mode by default (unless otherwise changed explicitly). You can actually navigate to <kbd>http://localhost:8761</kbd> to access JHipster Registry and then log in to the application with the password that we used when we started the application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running a generated application locally</h1>
                </header>
            
            <article>
                
<p>So we are all set now. We have generated a gateway application, we have a microservice with an SQL DB that runs with H2 in a dev profile and MySQL in a prod profile (invoice application), we have a microservice with MongoDB (notification application), and finally we just finished setting up our JHipster Registry locally. Now it is time to start everything locally and see how seamless our microservice setup works.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Gateway application pages</h1>
                </header>
            
            <article>
                
<p>We head over to terminal now and then go to the <kbd>e-commerce-app</kbd> folder. Navigate to the <kbd>online-store</kbd> folder and start the gateway application in dev mode:</p>
<pre><strong>&gt; cd online-store</strong><br/><strong>&gt; ./gradlew</strong></pre>
<p>This will start our <span class="packt_screen">Gateway</span> application on port <kbd>8080</kbd>. Let's open <kbd>http://localhost:8080</kbd> in our favorite browser:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/2b34359a-b72a-4ad4-9bb8-e5b6ff99a76f.png"/></div>
<p>Then we can click on the <span class="packt_screen">sign in</span> button on the home page or <kbd>Account/sign in</kbd> from the top menu, and then enter the username and password as <kbd>admin</kbd> and <kbd>admin</kbd> respectively.</p>
<p>Once logged in as an admin user, you can see the administration menu:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/18d5069d-ba32-4469-bdf7-415cfe37f2e0.png"/></div>
<p>In the administration menu, you can find the following pages:</p>
<div class="CDPAlignCenter CDPAlign"><img height="273" src="assets/0a89eeb0-f2d6-4559-bec3-8c4efe731566.png" width="171"/></div>
<p>This includes the following:</p>
<p><strong>Gateway</strong>: The Gateway page will show the list of microservice applications for which this application acts as a gateway. It <span>will also show the routes and the services that handle the route, and the available servers for the route:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1b64e45f-7f30-4b41-902f-a899e61bb50b.png"/></div>
<p>Currently, there is no microservice application booted up, so the page is empty. We will see how this page is changed once we start our notification and invoice services. </p>
<p><strong>User management</strong>: This is similar to monolithic user management and holds the basic user information and management.</p>
<p><strong>Metrics</strong>: The Metrics page holds the information about JVM metrics and service/DB statistics. This is, again, similar to the monolithic application. Added to that, this also shows the metric statistics for the microservice applications registered.</p>
<p><strong>Health</strong>: The Health page shows the basic health information of the various services that we have in our application:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a95d6deb-60a4-4873-a3dc-30e512e2c334.png"/></div>
<p>Similar to the monolithic application, it shows <span class="packt_screen">Disk space</span> and <span class="packt_screen">Database</span>. But added to that it also shows the health of the Discovery network (that is, the discoveryClient and the Eureka server). It also shows the microservice config server's health, which is <kbd>spring-cloud-config-server</kbd>, and then shows the health of the circuit breaker we use (Hystrix). </p>
<p>Configuration, Audits, Logs, and API pages are similar to the monolithic application we saw earlier.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JHipster Registry pages</h1>
                </header>
            
            <article>
                
<p>Since we have started the registry server at port <kbd><span>8761</span></kbd>, we can visit <kbd>http://localhost:8761</kbd> and log in with <kbd>admin</kbd> as the username and <kbd>admin</kbd> (the password that we have provided when starting the application) as the password.</p>
<p><span>Upon logging in, JHipster Registry shows the following information in the form of a dashboard:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/cf0453ee-976f-48c5-ab72-57d55afd1e1b.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">System status</h1>
                </header>
            
            <article>
                
<p>This panel will show the environment in which the application is running and how long the application has been running (System uptime). </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Below renew threshold</h1>
                </header>
            
            <article>
                
<p>Our applications will have to send heartbeat signals to the registry service to notify the registry that the application is alive and running. The registry services rely on this heartbeat signal to register and deregister the application. That is, the existence of the application is determined with the help of this heartbeat ping. This is what will happen in the renew phase.</p>
<p>However, when the Eureka server is booting up, it will try to get all the information about instance registries from the nearby service. If the nearby service fails for any reason, then it will try to connect to all of its peers to fetch the information. If the Eureka server was able to fetch the information for all the servers, then it will set the renewal threshold based on the information received. Based on this information, JHipster Registry will hold the information on whether the current level is below the renewal threshold specified and notify users in the UI.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Instances registered</h1>
                </header>
            
            <article>
                
<p>This will show basic information about the instances that have been registered with the registry. Since we have only booted up the gateway service, we will see only one instance here. Basically, this will list all the instances that are connected to this registry service.</p>
<p>It shows the status of the system, the name of the system, and then the instance ID. The instance ID is generated based on the configuration in the <kbd>application.yml</kbd> of JHipster Registry. It assigns a random value.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">General info and health</h1>
                </header>
            
            <article>
                
<p>It also shows general information about the JHipster Registry service and health information of the cluster of services, similar to the gateway health. The data here is fetched with the help of Spring Actuator health and metric endpoints.</p>
<div class="packt_infobox">Note the <span class="packt_screen">UNKNOWN</span> in the <strong>Health</strong> section (refer to the preceding screenshot). It tells us that the Eureka server is not running in a highly available mode, or only one instance of JHipster Registry is running. When you boot another instance of the registry (that is, make the application highly available) it goes off.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Application listing page</h1>
                </header>
            
            <article>
                
<p><span>This page lists the applications that are registered in the JHipster Registry service.</span></p>
<p>Navigate to <span class="packt_screen">Administration</span> |<span class="packt_screen"> <span class="packt_screen">Gateway</span></span>:</p>
<div class="CDPAlignCenter CDPAlign"><img height="279" src="assets/c68e9920-23a1-4e30-b4c8-7f7bf3598e04.png" width="518"/></div>
<p>It shows the following information:</p>
<ul>
<li>The current instance ID and its name</li>
<li>The current status of the instance</li>
<li>The version that is deployed</li>
<li>The profile</li>
<li>The zone in which it is deployed</li>
</ul>
<div class="packt_infobox">The version number is fetched from the <kbd>build.gradle</kbd> or <kbd>pom.xml</kbd> for Gradle and Maven projects respectively.<br/>
<span>The zone here normally refers to an Amazon zone. It is used by Ribbon to route the request to the nearest server. This configuration is useless if you don't use Amazon, and this is why we force it to <em>primary</em> (otherwise the load balancing algorithm would be wrong).</span></div>
<p><span>All the pages in the administration module will have a drop-down menu that lists the various instances that are registered, and we can select that instance to view its metrics, health, configuration, and other information depending on the page we are on.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Metrics page</h1>
                </header>
            
            <article>
                
<p>By default, this will show Registry's JVM metrics and its service statistics:</p>
<div class="CDPAlignCenter CDPAlign"><img height="408" src="assets/0657f768-31b3-454b-8218-653752c5e25a.png" width="450"/></div>
<p>We can select any instance from the drop-down menu provided and see its statistics, thus, making JHipster Registry a single point of information that provides all the necessary insight into your microservice architecture. For example, u<span>pon selecting the <span class="packt_screen">Gateway</span> application instance, we will get gateway-related information:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/57618e00-e5af-4658-9c91-1a6eeb491f9c.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Health page</h1>
                </header>
            
            <article>
                
<p>The health page will list the health of the Registry itself and all the instances that are connected to it. <span>For example, u</span><span>pon selecting the gateway application instance, we will get  gateway-related information:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/48a8763a-2e6c-4590-aab4-7ebf5e6f4e87.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuration page</h1>
                </header>
            
            <article>
                
<p>Similar to the health and metrics pages, JHipster Registry will provide detailed configuration of all the instances connected to it and we can choose the instances from the drop-down menu:</p>
<p>The following image shows configuration screen for the Gateway application</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/2f49b534-e49c-4c7a-b48b-35f8bfcff894.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Logs page</h1>
                </header>
            
            <article>
                
<p>Similar to the preceding pages, the log page will also show the real-time logs of the application. This is really useful for debugging and getting more information when there is a failure:</p>
<div class="packt_infobox">The logs are formatted at the application level. The console here shows <kbd>tail -f</kbd> for consolidating logs. </div>
<p>The following image shows logs from the Gateway application:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1dc8fee6-d096-4d45-8e92-b7ac19c3af45.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Swagger API endpoints</h1>
                </header>
            
            <article>
                
<p>The microservice architecture relies heavily on API calls between gateway and services, services and registry, and gateway and registries. So it is essential for developers and users to get to know the API endpoints that they can access, as well as the information required to access those endpoints. </p>
<p>This can be a lot of work. Fortunately, libraries such as Swagger come to the rescue. We just have to add the standard comments to the methods, and then the Swagger API will do the necessary work to extract information from them and convert them into a beautiful user interface:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1b9b74bb-9c3a-4e94-966d-64a09d6b3367.png"/></div>
<p>The preceding image shows the default generated Swagger UI page. It lists all the endpoints available, and then provides the list of operations that it provides. It shows the playground where we can frame requests and test them for output.</p>
<div class="packt_tip">Normally, the Swagger API docs are available only in development mode. If you are developing an API service and if there is a need to expose this to end users or external developers using your service, you can enable it in production by setting the <span class="packt_screen">swagger</span> <span>profile, along with</span> <kbd>prod</kbd>, <span>by setting <kbd>spring.profiles.active=prod,swagger</kbd></span>.</div>
<p>Similar to the other pages, this also lists the various instances that are connected to this registry service and we can select them from the drop-down menu (upper-right corner) to see what APIs are provided by various applications:</p>
<div class="CDPAlignCenter CDPAlign"><img height="366" src="assets/8291b0b3-59d3-41f8-8410-90af0bcfab02.png" width="680"/></div>
<p>The listed operations in the gateway API will provide the following information:</p>
<div class="CDPAlignCenter CDPAlign"><img height="400" src="assets/01fc07f9-d529-4471-bece-a88c4b3db9ed.png" width="708"/></div>
<p>It lists all the operations that are available in the <kbd>AccountResource</kbd> file. It shows the method type (<kbd>GET</kbd> / <kbd>POST</kbd> / <kbd>PUT</kbd> / <kbd>DELETE</kbd>), and then the endpoint and the method name that is present in the <kbd>AccountResource</kbd> file:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ca90823e-e343-4ff6-9b8c-ee59f3c5b52d.png"/></div>
<p>Upon clicking any one of the endpoints, it shows detailed information about the response classes, response errors, response content type, and also how the response object is structured. In addition to this, it also shows how the model object is constructed. These are particularly helpful for end users who want to access these APIs:</p>
<pre>UserDTO {<br/>    activated (boolean, optional),<br/>    authorities (Array[string], optional),<br/>    createdBy (string, optional),<br/>    createdDate (string, optional),<br/>    email (string, optional),<br/>    firstName (string, optional),<br/>    id (integer, optional),<br/>    imageUrl (string, optional),<br/>    langKey (string, optional),<br/>    lastModifiedDate (string, optional),<br/>    lastModifiedBy (string optional),<br/>    lastName (string, optional),<br/>    login (string)<br/>}</pre>
<p>Next, there is an option to try out the endpoint upon clicking the button:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ebbd03a7-a9ed-46b1-93c7-aaaa52cc89fc.png"/></div>
<p>It shows the request and its response. It also shows how to frame the request, along with the authentication token. It provides the response code and the response header information that is returned by the server, which is also extremely useful for API programmers:</p>
<div class="CDPAlignCenter CDPAlign"><img height="155" src="assets/6e347b5a-f5cf-4b28-936f-bedc37248ead.png" width="511"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running invoice and notification applications locally</h1>
                </header>
            
            <article>
                
<p>We have started the gateway and the registry services. We can then go to our invoice and notification application folders and then run them locally:</p>
<pre><strong>&gt; cd invoice</strong><br/><strong>&gt; ./gradlew</strong></pre>
<p>Open another terminal and run the following command:</p>
<pre><strong>&gt; cd notification</strong><br/><strong>&gt; ./gradlew</strong></pre>
<p>This will run them in <kbd>8081</kbd> and <kbd>8082</kbd> ports respectively:</p>
<div class="CDPAlignCenter CDPAlign"><img height="47" src="assets/9e38cf2c-0561-428a-84ad-c9cbf73ba485.png" width="457"/></div>
<p>Upon starting the application, it will also try to connect to JHipster Registry and register itself. You can watch for the preceding message once your server has started, to make sure that it is connected to JHipster Registry. </p>
<p>You can alternatively test this via your <span class="packt_screen">Gateway</span> application. Log in to your <span class="packt_screen">Gateway</span> application and then navigate to <span class="packt_screen">Administration</span> | <span class="packt_screen">Gateway</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5fe810da-73f5-4835-a2cd-b359544f3bb3.png"/></div>
<p>Here, you can see the two microservice applications, <span class="packt_screen">invoice</span> and <span class="packt_screen">notification</span>, are booted up and they are available at their respective URLs.</p>
<p>You can also check the JHipster Registry service to list the registered instances:</p>
<div class="CDPAlignCenter CDPAlign"><img height="143" src="assets/b8c09632-408d-46eb-bd63-4be24e62b416.png" width="416"/></div>
<p>Similarly, all the other pages in JHipster Registry will start to show the invoice and notification as one of the instances, and we can get their health, configuration, logs, and metrics right from JHipster Registry.</p>
<p>If you have followed along with the book, this will be the directory structure you will have:</p>
<div class="CDPAlignCenter CDPAlign"><img height="84" src="assets/ccd353fd-9500-4200-ad98-10e736fb2156.png" width="229"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"> Modeling entities in JDL </h1>
                </header>
            
            <article>
                
<p>Since we have already used the JDL studio when we were setting up our monolithic application, it's time to update it. </p>
<p>As discussed in the previous chapter, we will move the entities from a monolithic application to a gateway application, then, remove the invoice-related entities from the monolithic application, use them in our invoice microservice, and then update the related invoice references in that. Finally, we create entities for the notification microservice. </p>
<p>The following diagram shows our new JDL entity model: </p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/9b90e1c3-001b-4550-b64e-c1cfb3bd4e9c.png"/></div>
<p>The invoice is a perfect candidate to move out into a separate service. We can completely decouple invoice and its dependencies, but this will cause one problem in our current application—the <kbd>ProductOrder</kbd> entity is related to the <kbd>Invoice</kbd> table and we have to remove this dependency while keeping the relationship (but not as a foreign key) as an indirect key in <kbd>ProductOrder</kbd> that connects with the <kbd>Invoice</kbd> entity.</p>
<p>This can be achieved in two ways. We can change the foreign key into just another column in the <kbd>ProductOrder</kbd> entity, or create another entity called <kbd>InvoiceOrder</kbd> that just holds InvoiceIDs and <kbd>ProductOrder</kbd> IDs and map it to the <kbd>ProductOrder</kbd> entity.</p>
<p>The former keeps the table structure more or less the same and allows easier migration. The latter will increase isolation at the cost of normalization, and they are heavily used in high-performance applications. As you see, both have their own merits and demerits. The approach you should take depends purely on your requirement. We will consider the first approach.</p>
<p>As a first step, we will remove the relationship from Product owner in JDL defined in <kbd>online-store.jh</kbd> as shown for:</p>
<pre>relationship OneToMany {<br/>     ...<br/>     <strong>ProductOrder{invoice} to Invoice{order},</strong><br/>     ...<br/>}</pre>
<p>Remove the highlighted line and move all the invoice-related entities to the <kbd>invoice-jdl.jh</kbd> file.</p>
<p>Then, go to the Product Order entity, add an <kbd>invoiceId</kbd> field, and mark it as the <kbd>Long</kbd> type. It is an optional field and hence doesn't need the required keyword:</p>
<pre>entity ProductOrder {<br/>    placedDate Instant required<br/>    status OrderStatus required<br/>    <strong>invoiceId Long</strong><br/>    code String required<br/>}</pre>
<p>Entities for microservices can be tagged using the <span>microservice keyword supported by JDL. This helps JHipster to identify entities that belong to a specific microservice. It follows the same JDL options syntax that we saw earlier:</span></p>
<p><span><kbd>&lt;OPTION&gt; &lt;ENTITIES | * | all&gt; [with &lt;VALUE&gt;] [except &lt;ENTITIES&gt;]</kbd></span></p>
<ul>
<li><kbd>microservice</kbd> keyword</li>
<li>Followed by the names of the entity, comma separated if multiple</li>
<li>Followed by the <kbd>with</kbd> keyword</li>
<li>Followed by the name of the microservice</li>
</ul>
<div class="packt_infobox">We should use different files for microservices' entities, so that we create two files, <kbd>invoice-jdl.jh</kbd> and <kbd>notification-jdl.jh</kbd>, that contain the entities related to invoice and notification respectively, along with the original.</div>
<p>Then, we map the existing <kbd>Invoice</kbd> entity to the microservice in our JDL:</p>
<pre>microservice Invoice, Shipment with Invoice<br/>entity Invoice {<br/>    date Instant required<br/>    details String<br/>    status InvoiceStatus required<br/>    paymentMethod PaymentMethod required<br/>    paymentDate Instant required<br/>    paymentAmount BigDecimal required<br/>}<br/><br/>enum InvoiceStatus {<br/>    PAID, ISSUED, CANCELLED<br/>}<br/><br/>entity Shipment {<br/>    trackingCode String<br/>    date Instant required<br/>    details String<br/>}<br/><br/>enum PaymentMethod {<br/>    CREDIT_CARD, CASH_ON_DELIVERY, PAYPAL<br/>}<br/><br/>relationship OneToMany {<br/>    Invoice{shipment} to Shipment{invoice}<br/>}<br/><br/>service * with serviceClass<br/>paginate Invoice, Shipment with pagination<br/>microservice * with invoice</pre>
<p>Then, it is time to create another JDL file to hold the notification service details. Create a file called <strong>notification-jdl.jh</strong> and add the entities for notifications into it:</p>
<pre>entity Notification {<br/>    date Instant required<br/>    details String<br/>    sentDate Instant required<br/>    format NotificationType required<br/>    userId Long required<br/>    productId Long required<br/>}<br/><br/>enum NotificationType {<br/>    EMAIL, SMS, PARCEL<br/>}</pre>
<p>Then, we bind these entities to the <kbd>Notification</kbd> microservice, with the following:</p>
<pre>microservice * with notification</pre>
<p>That is it. We have defined the domain model for our microservices.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Entity generation on microservices</h1>
                </header>
            
            <article>
                
<p>Our JDL is ready to use now. The next step will be generating the entities in the gateway and the services. To start with, we will download our JDL files from the JDL studio. Once downloaded, we will move the files into our gateway and microservice applications respectively.</p>
<p>Once moved, run the following command after navigating into the gateway application folder. This will create the entities for the gateway and also create the UI for the microservice entities in the gateway:</p>
<pre><strong>&gt; cd e-commerce-app/online-store </strong><br/><strong>&gt; jhipster import-jdl online-store.jh</strong><br/><strong>&gt; jhipster import-jdl ../notification/notification-jdl.jh --skip-ui-  <br/>   grouping</strong><br/><strong>&gt; jhipster import-jdl ../invoice/invoice-jdl.jh --skip-ui-grouping</strong></pre>
<div class="packt_infobox">The <kbd>--skip-ui-grouping</kbd> flag disables the client-side entity component grouping behavior for microservices introduced in JHipster 5.x. This helps us to cherry-pick our changes from the monolithic application without many conflicts. This grouping behavior is useful when you have entities with the same name in different services.</div>
<p>Run the following command for the notification service so that the backend for the entities are created there:</p>
<pre><strong>&gt; cd e-commerce-app/notification </strong><br/><strong>&gt; jhipster import-jdl notification-jdl.jh<br/></strong></pre>
<p>Run the following command for the invoice service so that the backends for the entities are created there:</p>
<pre><strong>&gt; cd e-commerce-app/invoice </strong><br/><strong>&gt; jhipster import-jdl invoice-jdl.jh</strong></pre>
<p>JHipster will ask about overwriting the modified files; please select the applicable ones. We will use <kbd>"a" -&gt;</kbd>, which means that it will overwrite everything.</p>
<p>Don't forget to cherry-pick any changes we made to entities originally in the monolith back to our gateway and microservices.</p>
<p>Don't forget to commit the changes in each of the services and gateway. You could also init the entire <kbd>e-commerce-app</kbd> folder as a <kbd>git</kbd> source if you like, by running <kbd>git init</kbd>:</p>
<pre><strong>&gt; cd e-commerce-app</strong><br/><strong>&gt; git init</strong><br/><strong>&gt; git add --all</strong><br/><strong>&gt; git commit -am "entities generated using JDL"</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Explaining the generated  code</h1>
                </header>
            
            <article>
                
<p><span>In the notification service, once we have generated the application, the following files were created:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/24baa8ee-5736-4ae8-9d4c-53d1c8f7ac89.png"/></div>
<p>As you can see, this will only generate the backend files and not the frontend files, since they are already generated in the gateway service.</p>
<p>Similarly, running the <kbd>jhipster import-jdl</kbd> command in the invoice application will generate similar Java files: </p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/cb672b0d-0c9f-4eab-85cf-7ac4cc798af7.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Gateway application</h1>
                </header>
            
            <article>
                
<p>In the Gateway application, the entire frontend (including the entities in microservices) will be generated. Since JHipster produces proxy-based microservices, all the frontend code will live in the Gateway application:</p>
<div class="CDPAlignCenter CDPAlign"><img height="211" src="assets/0201c4c8-1f97-47ab-9aad-c6145d776a63.png" width="350"/></div>
<p><kbd>ProductOrder.Java</kbd> will remove the <kbd>Invoice</kbd> as a foreign key and then use the long value that we passed in here:</p>
<div>
<pre>/**<br/>* A Product Owner<br/>*/<br/>...<br/>public class ProductOrder implements Serializable {<br/>...<br/>@Column(name = "invoice_id")<br/>private Long invoiceId;<br/>...<br/>}</pre></div>
<p><span>So, the application is generated completely. Now, it is time to run it.</span></p>
<p>Fire up three consoles (since we need to run three applications). If we have the applications running already, then we just need to compile them and Spring devtools will auto reload the applications. Make sure the registry is already running as well:</p>
<ul>
<li>In console 1, navigate to the gateway and then start the server with <kbd>./gradlew</kbd> if it is not already running, otherwise compile with <kbd><kbd>./gradlew compileJava</kbd></kbd></li>
<li>In console 2, navigate to the invoice and then start the server with<kbd> ./gradlew</kbd><span> if it is not already running, otherwise compile with </span><kbd>./gradlew compileJava</kbd></li>
<li>In console 3, navigate to the notification and then start the server with<kbd> ./gradlew</kbd><span> if it is not already running, otherwise compile with </span><kbd>./gradlew compileJava</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Explaining the generated pages</h1>
                </header>
            
            <article>
                
<p>Once the application has started successfully, it is time to spin up your favorite browser and navigate to the gateway server at <kbd>http://localhost:8080</kbd>.</p>
<p>Once logged in, you can see that t<span>he entities are generated in the gateway application and they are available under the entity <span class="packt_screen">nav</span> menu.</span></p>
<p>It includes all the gateway entities and also the microservice entities:</p>
<div class="CDPAlignCenter CDPAlign"><img height="242" src="assets/4ccffb10-6c53-4ac5-9366-0e0860e8bd19.png" width="236"/></div>
<p>This is the invoice screen created in the gateway application:</p>
<div class="CDPAlignCenter CDPAlign"><img height="408" src="assets/47eb47e0-b724-4685-bdc1-6048ea1ff23e.png" width="487"/></div>
<p>Try to create a few entities to verify that everything is working fine.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Since we have done a lot of things in this chapter, let's recap what we have done so far.</p>
<p>We have successfully generated a gateway and two microservices. We have downloaded JHipster Registry and then started it locally. We have successfully segregated and generated the entity files for a notification and invoice service. We have finally booted up all our applications and saw how things are generated, and were able to create the microservice application. Last but not least, we have also committed all our changes to Git (in other words, reached a checkpoint).</p>


            </article>

            
        </section>
    </body></html>