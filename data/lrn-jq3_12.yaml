- en: Advanced DOM Manipulation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级 DOM 操作
- en: Throughout this book, we have used jQuery's powerful DOM manipulation methods
    to alter the content of the document. We have now seen several ways in which we
    can insert new content, move existing content around, or remove content altogether.
    We also know how to alter the attributes and properties of elements to suit our
    needs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们已经使用了 jQuery 强大的 DOM 操作方法来改变文档的内容。我们已经看到了几种插入新内容、移动现有内容或完全删除内容的方法。我们也知道如何更改元素的属性和属性以满足我们的需求。
- en: 'In [Chapter 5](fa35636a-37d4-49b9-ba72-aa6596bab015.xhtml), *Manipulating the
    DOM*, we were introduced to these important techniques. In this more advanced
    chapter, we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 5 章](fa35636a-37d4-49b9-ba72-aa6596bab015.xhtml) *操作 DOM* 中，我们介绍了这些重要技术。在这个更高级的章节中，我们将涵盖：
- en: Sorting page elements using `.append()`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `.append()` 排序页面元素
- en: Attaching custom data to elements
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 附加自定义数据到元素
- en: Reading HTML5 data attributes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取 HTML5 数据属性
- en: Creating elements from JSON data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 JSON 数据创建元素
- en: Extending the DOM manipulation system using CSS hooks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 CSS 钩子扩展 DOM 操作系统
- en: Sorting table rows
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序表格行
- en: The majority of the topics we're investigating in this chapter can be demonstrated
    through sorting the rows of a table. This common task is a useful way to assist
    users in quickly finding the information they need. There are, naturally, a number
    of ways to do this.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们正在研究的大多数主题都可以通过对表格行进行排序来演示。这个常见的任务是帮助用户快速找到他们所需信息的有效方法。当然，有许多方法可以做到这一点。
- en: Sorting tables on the server
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在服务器上排序表格
- en: A common solution for data sorting is to perform it on the server. Data in tables
    often comes from a database, which means that the code that pulls it out of the
    database can request it in a given sort order (using, for example, the SQL language's
    `ORDER BY` clause). If we have server-side code at our disposal, it is straightforward
    to begin with a reasonable default sort order.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 数据排序的常见解决方案是在服务器上执行。表格中的数据通常来自数据库，这意味着从数据库中提取数据的代码可以请求以给定的排序顺序（例如，使用 SQL 语言的
    `ORDER BY` 子句）提取数据。如果我们有服务器端代码可供使用，那么从一个合理的默认排序顺序开始是很简单的。
- en: 'Sorting is most useful, though, when the user can determine the sort order.
    A common user interface for this is to make the table headers (`<th>`) of sortable
    columns into links. These links can go to the current page, but with a query string
    appended indicating the column to sort by, as shown in the following code snippet:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当用户可以确定排序顺序时，排序就变得最有用了。这方面的常见用户界面是将可排序列的表头(`<th>`)转换为链接。这些链接可以指向当前页面，但附加了一个查询字符串来指示按哪一列排序，如下面的代码片段所示：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The server can react to the query string parameter by returning the database
    contents in a different order.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器可以通过返回数据库内容的不同顺序来响应查询字符串参数。
- en: Sorting tables using Ajax
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Ajax 排序表格
- en: 'This setup is simple, but requires a page refresh for each sort operation.
    As we have seen, jQuery allows us to eliminate such page refreshes by using *Ajax*
    methods. If we have the column headers set up as links as before, we can add jQuery
    code that will translate those links into Ajax requests:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设置很简单，但是每次排序操作都需要页面刷新。正如我们所见，jQuery 允许我们通过使用 *Ajax* 方法来消除这种页面刷新。如果我们像以前一样将列标题设置为链接，我们可以添加
    jQuery 代码来将那些链接转换为 Ajax 请求：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now when the anchors are clicked, jQuery sends an Ajax request to the server
    for the same page. When jQuery is used to make a page request using Ajax, it sets
    the `X-Requested-With` HTTP header to `XMLHttpRequest` so that the server can
    determine that an Ajax request is being made. The server code can be written to
    send back only the content of the `<tbody>` element itself, and not the surrounding
    page, when this parameter is present. This way we can use the response to replace
    the content of the existing `<tbody>` element.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当锚点被点击时，现在 jQuery 会向服务器发送一个 Ajax 请求以获取相同的页面。当 jQuery 用于使用 Ajax 发送页面请求时，它会将 `X-Requested-With`
    HTTP 头设置为 `XMLHttpRequest`，以便服务器可以确定正在进行 Ajax 请求。当此参数存在时，服务器代码可以编写为仅在回送 `<tbody>`
    元素本身的内容，而不是周围的页面。通过这种方式，我们可以使用响应来替换现有 `<tbody>` 元素的内容。
- en: This is an example of **progressive enhancement**. The page works perfectly
    well without any JavaScript at all, as the links for server-side sorting are still
    present. When JavaScript is available, however, we hijack the page request and
    allow the sort to occur without a full page load.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这是**渐进增强**的一个例子。页面即使没有任何 JavaScript 也能正常工作，因为仍然存在用于服务器端排序的链接。但是，当 JavaScript
    可用时，我们会劫持页面请求，允许排序而无需完全重新加载页面。
- en: Sorting tables within the browser
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在浏览器中排序表
- en: There are times, though, when we either don't want to wait for server responses
    when sorting or don't have a server-side scripting language available to us. A
    viable alternative in this case can be to perform the sorting entirely on the
    browser using JavaScript and jQuery's DOM manipulation methods.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 但是有时候，当我们在排序时不想等待服务器响应或者没有服务器端脚本语言可用时。在这种情况下，一个可行的替代方法是完全在浏览器中使用 JavaScript
    和 jQuery 的 DOM 操作方法进行排序。
- en: 'In order to demonstrate the various techniques in this chapter, we will set
    up three separate jQuery sorting mechanisms. Each will accomplish the same goal,
    but in a unique way. Our examples will sort the table using:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示本章中的各种技术，我们将设置三个单独的 jQuery 排序机制。每个都将以独特的方式完成相同的目标。我们的示例将使用以下方法对表进行排序：
- en: Data extracted from the HTML content
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 HTML 内容中提取的数据
- en: HTML5 custom data attributes
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML5 自定义数据属性
- en: A JSON representation of the table data
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表数据的 JSON 表示
- en: 'The tables that we''ll be sorting will have different HTML structures to accommodate
    the varying JavaScript techniques, but each contains columns listing books, their
    author names, release dates, and prices. The first table has this simple structure:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要排序的表具有不同的 HTML 结构，以适应不同的 JavaScript 技术，但每个表都包含列出书籍、作者姓名、发布日期和价格的列。第一个表具有简单的结构：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Getting the example code
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 获取示例代码
- en: You can access the example code from the following GitHub repository: [https://github.com/PacktPublishing/Learning-jQuery-3](https://github.com/PacktPublishing/Learning-jQuery-3).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从以下 GitHub 代码库访问示例代码：[https://github.com/PacktPublishing/Learning-jQuery-3](https://github.com/PacktPublishing/Learning-jQuery-3)。
- en: 'Before we enhance the table with JavaScript, the first few rows look like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们用 JavaScript 增强表格之前，前几行如下所示：
- en: '![](img/5297_12_01.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_12_01.png)'
- en: Moving and inserting elements revisited
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动和插入元素的再次访问
- en: Over the course of the coming examples, we will build a flexible sorting mechanism
    that works on each of the columns. To do this, we will use the jQuery DOM manipulation
    methods to insert some new elements and move other existing elements to new positions
    within the DOM. We will start with the most straightforward piece of the puzzle--linking
    the table headers.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的示例中，我们将构建一个灵活的排序机制，可以在每一列上工作。为此，我们将使用 jQuery 的 DOM 操作方法来插入一些新元素并将其他现有元素移动到
    DOM 中的新位置。我们将从最简单的部分开始--链接表头。
- en: Adding links around existing text
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在现有文本周围添加链接
- en: 'We''d like to turn the table headers into links that sort the data by their
    respective columns. We can use jQuery''s `.wrapInner()` method to add them; we
    recall from [Chapter 5](https://cdp.packtpub.com/learning_jquery_3_0/wp-admin/post.php?post=37&action=edit#post_30),
    *Manipulating the DOM*, that `.wrapInner()` places a new element (in this case
    an `<a>` element) *inside* the matched element, but *around* child elements:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想将表头转换为按其各自列排序数据的链接。我们可以使用 jQuery 的 `.wrapInner()` 方法来添加它们；我们回想起 [第 5 章](https://cdp.packtpub.com/learning_jquery_3_0/wp-admin/post.php?post=37&action=edit#post_30)
    *DOM 操作* 中，`.wrapInner()` 将一个新元素（在本例中为 `<a>` 元素） *插入* 匹配的元素内，但在*周围*子元素：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Listing 12.1
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.1
- en: 'We skipped the first `<th>` element of each table (using `.slice()`) because
    it contains no text other than white space, as there is no need to either label
    or sort the cover photos. We then added a class of `sort` to the remaining `<th>`
    elements so we can distinguish them in our CSS from their non-sortable counterparts.
    Now the header rows look like so:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们跳过了每个表的第一个 `<th>` 元素（使用 `.slice()`）因为它除了空格之外没有文本，因此没有必要对封面照片进行标记或排序。然后，我们对剩余的
    `<th>` 元素添加了一个 `sort` 类，以便在 CSS 中将其与不可排序的元素区分开。现在，标题行如下所示：
- en: '![](img/5297_12_02.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_12_02.png)'
- en: This is an example of progressive enhancement's counterpart, **graceful degradation**.
    Unlike the Ajax solution discussed earlier, this technique cannot function without
    JavaScript; we are assuming the server has no scripting language available to
    it for the purposes of this example. Since JavaScript is required for the sort
    to work, we are adding the `sort` class and the anchors through code only, thereby
    making sure that the interface indicates that sorting is possible only if the
    script can run. And since we're actually creating links rather than simply adding
    visual styles to indicate that the headers can be clicked, we provide the added
    benefit of accessibility for users who need to navigate to the headers with the
    keyboard (by pressing the *Tab* key). The page **degrades** into one that is still
    functional, albeit without sorting available.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这是渐进增强的对应，**优雅降级**的一个例子。与前面讨论的 Ajax 解决方案不同，这种技术在没有 JavaScript 的情况下无法工作；我们假设服务器在这个例子中没有可用于目的的脚本语言。由于
    JavaScript 是必需的，以使排序工作，我们只通过代码添加 `sort` 类和锚点，从而确保界面只在脚本运行时表明可以排序。而且，由于我们实际上是创建链接而不仅仅是添加视觉样式以指示标题可以点击，因此我们为需要使用键盘导航到标题的用户提供了额外的辅助功能（通过按*Tab*键）。页面**退化**为一个仍然可以使用但无法进行排序的页面。
- en: Sorting simple JavaScript arrays
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对简单的 JavaScript 数组进行排序
- en: To perform the sort, we will be taking advantage of JavaScript's built-in `.sort()`
    method. It does an in-place sort on an array, and can take a **comparator** **function**
    as an argument. This function compares two items in the array and should return
    a positive or negative number depending on which item should come first in the
    sorted array.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行排序，我们将利用 JavaScript 的内置`.sort()`方法。它对数组进行原地排序，并可以接受一个**比较器函数**作为参数。此函数比较数组中的两个项目，并根据应该在排序后的数组中排在前面的项目返回正数或负数。
- en: 'For example, take a simple array of numbers:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，取一个简单的数字数组：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can sort this array by calling `arr.sort()`. After this, the items are in
    the following order:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用 `arr.sort()` 来对该数组进行排序。之后，项目的顺序如下：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'By default, as we see here, the items are sorted **lexicographically** (in
    alphabetical order). In this case, it might make more sense to sort the items
    *numerically*. To do this, we can supply a comparator function to the `.sort()`
    method:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如我们在这里看到的，项目按**字母顺序**（按字母顺序）排序。在这种情况下，可能更合理地按*数字*排序。为此，我们可以向 `.sort()`
    方法提供一个比较函数：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This function returns a negative number if `a` should come first in the sorted
    array, a positive number if `b` should come first, and zero if the order of the
    items does not matter. With this information in hand, the `.sort()` method can
    sequence the items appropriately:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数如果 `a` 应该在排序后的数组中排在 `b` 之前，则返回负数；如果 `b` 应该在 `a` 之前，则返回正数；如果项目的顺序无关紧要，则返回零。有了这些信息，`.sort()`
    方法可以适当地对项目进行排序：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We will next apply this `.sort()` method to our table rows.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将这个`.sort()`方法应用到我们的表格行上。
- en: Sorting DOM elements
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对 DOM 元素进行排序
- en: 'Let''s perform a sort on the `Title` column of the table. Note that while we
    added the `sort` class to it and the others, this column''s header cell already
    has a `sort-alpha` class provided by the HTML. The other header cells received
    similar treatment depending on the type of sorting for each, but for now we''ll
    focus on the `Title` header, which requires a straightforward alphabetical sort:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对表格的 `Title` 列执行排序。请注意，虽然我们将 `sort` 类添加到它和其他列，但此列的标题单元格已经有一个由 HTML 提供的 `sort-alpha`
    类。其他标题单元格根据每个排序类型接受了类似的处理，但现在我们将专注于 `Title` 标题，它需要一个简单的按字母顺序排序：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Listing 12.2
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.2
- en: Once we have found the index of the clicked header cell, we retrieve an array
    of all the data rows. This is a great example of how `.get()` is useful in transforming
    a jQuery object into an array of DOM nodes; even though jQuery objects act like
    arrays in many respects, they don't have all of the native array methods available,
    such as `.pop()` or `.shift()`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们找到了点击的标题单元格的索引，我们就会检索所有数据行的数组。这是一个很好的例子，说明了`.get()`如何将 jQuery 对象转换为 DOM
    节点数组；尽管 jQuery 对象在许多方面都像数组一样，但它们并没有所有可用的本机数组方法，比如`.pop()`或`.shift()`。
- en: Internally, jQuery actually does define a few methods that act like native array
    methods. For example, `.sort()`, `.push()`, and `.splice()` are methods of jQuery
    objects. However, since these methods are for internal use and not publicly documented,
    we cannot rely on them behaving in expected ways in our own code, and should thus
    avoid calling them on jQuery objects.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，jQuery 实际上定义了一些类似原生数组方法的方法。例如，`.sort()`、`.push()` 和 `.splice()` 都是 jQuery
    对象的方法。然而，由于这些方法是内部使用的，并且没有公开文档记录，我们不能指望它们在我们自己的代码中以预期的方式运行，因此应避免在 jQuery 对象上调用它们。
- en: Now that we have an array of DOM nodes, we can sort them, but to do this, we
    need to write an appropriate comparator function. We want to sort the rows according
    to the textual contents of the relevant table cells, so this will be the information
    the comparator function will examine. We know which cell to look at because we
    captured the column index with the `.index()` call. We use jQuery's `$.trim()`
    function to strip out leading and trailing white space, and then we convert the
    text to uppercase because string comparisons in JavaScript are case-sensitive
    while our sort should be case-insensitive.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个 DOM 节点数组，我们可以对它们进行排序，但要做到这一点，我们需要编写一个适当的比较器函数。我们想根据相关表格单元格的文本内容对行进行排序，因此这将是比较器函数要检查的信息。我们知道要查看哪个单元格，因为我们使用
    `.index()` 调用捕获了列索引。我们使用 jQuery 的 `$.trim()` 函数去除前导和尾随空格，然后将文本转换为大写，因为 JavaScript
    中的字符串比较是区分大小写的，而我们的排序应该是不区分大小写的。
- en: 'Our array is now sorted, but note that the call to `.sort()` has not changed
    the DOM itself. To do this, we need to call DOM manipulation methods to move the
    rows around. We do this one row at a time, reinserting each into the table as
    we loop through them. Since `.append()` does not clone nodes, this *moves* them
    rather than copying them. Our table is now sorted:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的数组已经排序了，但请注意，对 `.sort()` 的调用并没有改变 DOM 本身。要做到这一点，我们需要调用 DOM 操作方法来移动行。我们一次移动一行，将每行重新插入表格中。由于
    `.append()` 不会克隆节点，而是*移动*它们，因此我们的表格现在已经排序了：
- en: '![](img/image_12_001-1.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_12_001-1.jpg)'
- en: Storing data alongside DOM elements
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据存储在 DOM 元素旁边
- en: Our code works, but it is quite slow. The culprit is the comparator function,
    which is doing a lot of work. This comparator will be called many times during
    the course of a sort, which means that it needs to be fast.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码可以运行，但速度相当慢。问题在于比较器函数，它执行了大量的工作。在排序过程中，这个比较器将被调用多次，这意味着它需要很快。
- en: Array sorting performance
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 数组排序性能
- en: The actual sort algorithm used by JavaScript is not defined by the standard.
    It may be a simple sort such as a **bubble** **sort** (worst case of Θ(*n*²) in
    computational complexity terms), or a more sophisticated approach such as a **quick
    sort** (which is Θ(*n* log *n*) on average). It is safe to say, though, that doubling
    the number of items in an array will more than double the number of times the
    comparator function is called.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 使用的实际排序算法没有在标准中定义。它可能是一个简单的排序，比如**冒泡排序**（在计算复杂度方面的最坏情况是 Θ(*n*²)），或者更复杂的方法，比如**快速排序**（平均情况下是
    Θ(*n* log *n*)）。不过可以肯定的是，将数组中的项数翻倍将会使比较器函数被调用的次数增加超过两倍。
- en: 'The remedy for our slow comparator is to **pre-compute** the keys for the comparison.
    We can do most of the expensive work in an initial loop and store the result with
    jQuery''s `.data()` method, which sets or retrieves arbitrary information associated
    with page elements. Then we can simply examine the keys within the comparator
    function, and our sort is markedly faster:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 解决我们慢比较器的方法是**预先计算**比较所需的键。我们可以在初始循环中完成大部分昂贵的工作，并使用 jQuery 的 `.data()` 方法将结果存储起来，该方法用于设置或检索与页面元素相关联的任意信息。然后我们只需在比较器函数中检查这些键，我们的排序就会明显加快：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Listing 12.3
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.3
- en: The `.data()` method, paired with its complement `.removeData()`, provides a
    data storage mechanism that is a convenient alternative to **expando** **properties**,
    or non-standard properties added directly to DOM elements.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`.data()` 方法和它的补充 `.removeData()` 提供了一个数据存储机制，它是一种方便的替代方案，用于**扩展属性**，或者直接添加到
    DOM 元素的非标准属性。'
- en: Performing additional pre-computation
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行额外的预计算
- en: 'Now we want to apply the same kind of sorting behavior to the Author(s) column
    of our table. Because its table header cell has the `sort-alpha` class, the Author(s)
    column can be sorted with our existing code. Ideally, though, authors should be
    sorted by last name, not first. Since some books have multiple authors, and some
    authors have middle names or initials listed, we need outside guidance to determine
    what part of the text to use as our sort key. We can supply this guidance by wrapping
    the relevant part of the cell in a tag:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们希望将相同类型的排序行为应用于我们表格的作者一栏。因为表头单元格具有`sort-alpha`类，作者一栏可以使用我们现有的代码进行排序。但理想情况下，作者应该按照姓氏而不是名字排序。由于一些书籍有多位作者，有些作者列出了中间名或缩写，我们需要外部指导来确定要用作排序键的文本部分。我们可以通过在单元格中包装相关部分来提供这些指导：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now we have to modify our sorting code to take this tag into account without
    disturbing the existing behavior for the `Title` column, which is already working
    well. By prepending the marked sort key to the key we have previously calculated,
    we can sort first on the last name if it is called out, but on the whole string
    as a fallback:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须修改我们的排序代码，以考虑这个标记，而不影响`Title`列的现有行为，因为它已经运行良好。通过将标记排序键放在之前计算过的键的前面，我们可以先按照姓氏排序，如果指定的话，但是在整个字符串上作为后备进行排序：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Listing 12.4
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.4
- en: 'Sorting by the Author(s) column now uses the provided key, thereby sorting
    by last name:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在按照作者一栏对提供的键进行排序，从而按照姓氏排序：
- en: '![](img/image_12_002-1.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_12_002-1.jpg)'
- en: If two last names are identical, the sort uses the entire string as a tiebreaker
    for positioning.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个姓氏相同，则排序会使用整个字符串作为定位的决定因素。
- en: Storing non-string data
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储非字符串数据
- en: 'Our user should be able to sort not just by the Title and Author(s) columns,
    but the Publish Date and Price columns as well. Since we streamlined our comparator
    function, it can handle all kinds of data, but first the computed keys will need
    to be adjusted for other data types. For example, in the case of prices, we need
    to strip off the leading `$` character and parse the rest so that we can compare
    them numerically:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的用户应该能够不仅按照标题和作者一栏进行排序，还可以按照发布日期和价格一栏进行排序。由于我们简化了比较函数，它可以处理各种类型的数据，但首先计算出的键需要针对其他数据类型进行调整。例如，在价格的情况下，我们需要去掉前导的`$`字符并解析剩余部分，以便我们可以进行数字比较：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The regular expression used here removes any leading characters other than numbers
    and decimal points, passing the result on to `parseFloat()`. The result of `parseFloat()`
    then needs to be checked, because if no number can be extracted from the text,
    `NaN` (**Not a Number**) is returned. This can wreak havoc on `.sort()`, so we
    set any non-number to `0`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此处使用的正则表达式除了数字和小数点以外的任何前导字符，将结果传递给`parseFloat()`。然后需要检查`parseFloat()`的结果，因为如果无法从文本中提取数字，将返回`NaN`（**不是一个数字**）。这可能对`.sort()`造成严重影响，所以将任何非数字设为`0`。
- en: 'For the date cells, we can use the JavaScript `Date` object:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于日期单元格，我们可以使用 JavaScript 的 `Date` 对象：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The dates in this table contain a month and year only; `Date.parse()` requires
    a fully specified date. To accommodate this, we prepend the string with `1`, so
    that `September 2010` becomes `1 September 2010`. Now that we have a complete
    date, `Date.parse()` can convert it into a **timestamp**, which can be sorted
    using our normal comparator.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此表中的日期仅包含月份和年份； `Date.parse()`需要一个完全规定的日期。为了适应这一点，我们在字符串前面加上`1`，这样`September
    2010`就变成了`1 September 2010`。现在我们有了一个完整的日期，`Date.parse()`可以将其转换为**时间戳**，可以使用我们正常的比较器进行排序。
- en: 'We can place these expressions into three separate functions, so that later
    we can call the appropriate one based on the class applied to the table header:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些表达式放入三个单独的函数中，以便稍后可以根据应用于表头的类调用适当的函数：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Listing 12.5
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.5
- en: We've modified the script to store `keyType` data for each column header cell
    based on its class name. We strip off the `sort-` portion of the class so that
    we're left with `alpha`, `numeric`, or `date`. By making each sort function a
    method of the `sortKeys` object, we can use **array notation** and pass in the
    value of the header cell's `keyType` data to call the appropriate function.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已修改脚本，为每个列头单元格存储基于其类名的`keyType`数据。我们去掉类名的`sort-`部分，这样就剩下`alpha`、`numeric`或`date`。通过将每个排序函数作为`sortKeys`对象的方法，我们可以使用**数组表示法**，并传递表头单元格的`keyType`数据的值来调用适当的函数。
- en: 'Typically when we call methods, we use **dot notation**. This is, in fact,
    the way we call methods of the jQuery object throughout this book. For example,
    to add a class of `bar` to `<div class="foo">`, we write `$(''div.foo'').addClass(''bar'')`.
    Because JavaScript allows properties and methods to be represented in either dot
    or array notation, we could also write it as `$(''div.foo'')[''addClass''](''bar'')`.
    It doesn''t make much sense to do this most of the time, but it can be a great
    way to conditionally call methods without using a bunch of `if` statements. For
    our `sortKeys` object, we could call the `alpha` method like `sortKeys.alpha($cell)`
    or `sortKeys[''alpha'']($cell)` or, if the method name is stored in a `keyType` constant,
    `sortKeys[keyType]($cell)`. We''ll use this third variation inside the `click`
    handler:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们调用方法时，我们使用**点符号**。事实上，在本书中，我们调用 jQuery 对象的方法就是这样的。例如，要向`<div class="foo">`添加一个`bar`类，我们写`$('div.foo').addClass('bar')`。因为
    JavaScript 允许以点符号或数组符号表示属性和方法，所以我们也可以写成`$('div.foo')['addClass']('bar')`。大多数情况下这样做没有太多意义，但这可以是一种有条件地调用方法而不使用一堆`if`语句的好方法。对于我们的`sortKeys`对象，我们可以像这样调用`alpha`方法`sortKeys.alpha($cell)`或`sortKeys['alpha']($cell)`或者，如果方法名存储在一个`keyType`常量中，`sortKeys[keyType]($cell)`。我们将在`click`处理程序内使用这种第三种变体：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Listing 12.6
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.6
- en: 'We can now sort by Publish Date or Price as well:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们也可以按发布日期或价格排序：
- en: '![](img/image_12_003-1.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_12_003-1.jpg)'
- en: Alternating sort directions
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交替排序方向
- en: Our final sorting enhancement is to allow for both **ascending** and **descending**
    sort orders. When the user clicks on a column that is already sorted, we want
    to reverse the current sort order.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最终排序增强是允许**升序**和**降序**排序顺序。当用户点击已经排序的列时，我们希望反转当前的排序顺序。
- en: 'To reverse a sort, all we have to do is to invert the values returned by our
    comparator. We can do this with a simple `direction` argument to the sort comparator:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要反转排序，我们只需反转比较器返回的值。我们可以通过简单的`direction`参数来做到这一点：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If `direction` equals `1`, then the sort will be the same as before. If it
    equals `-1`, the sort will be reversed. By combining this concept with some classes
    to keep track of the current sort order of a column, achieving alternating sort
    directions is simple:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`direction`等于`1`，那么排序将与之前相同。如果它等于`-1`，则排序将被反转。通过将这个概念与一些类结合起来以跟踪列的当前排序顺序，实现交替排序方向就变得简单了：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Listing 12.7
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.7
- en: 'As a side benefit, since we use classes to store the sort direction, we can
    style the column headers to indicate the current order:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个额外的好处，由于我们使用类来存储排序方向，我们可以将列标题样式化以指示当前顺序：
- en: '![](img/image_12_004-1.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_12_004-1.jpg)'
- en: Using HTML5 custom data attributes
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 HTML5 自定义数据属性
- en: 'So far, we''ve been relying on the content within the table cells to determine
    the sort order. While we''ve managed to sort the rows correctly by manipulating
    that content, we can make our code more efficient by outputting more HTML from
    the server in the form of **HTML5 data attributes**. The second table in our example
    page includes these attributes:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直依赖表格单元格内的内容来确定排序顺序。虽然我们已经通过操作内容来正确排序行，但我们可以通过以**HTML5 数据属性**的形式从服务器输出更多的
    HTML 来使我们的代码更高效。我们示例页面中的第二个表格包含了这些属性：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice that each `<th>` element (except the first) has a `data-sort` attribute
    and each `<tr>` element has a `data-book` attribute. We first saw custom data
    attributes in [Chapter 7](e101ee08-ea8f-40f0-966c-e00b6af852ed.xhtml), *Using
    Plugins*, where we provided information in attributes for plugin code to use.
    Here, we will use jQuery to access the attribute values ourselves. To retrieve
    the value, we pass the part of the attribute's name after `data-` to the `.data()`
    method. For example, we write `$('th').first().data('sort')` to get the value
    of the first `<th>` element's `data-sort` attribute.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每个`<th>`元素（除了第一个）都有一个`data-sort`属性，每个`<tr>`元素都有一个`data-book`属性。我们在[第 7 章](e101ee08-ea8f-40f0-966c-e00b6af852ed.xhtml)中首次看到自定义数据属性，*使用插件*，在那里我们提供了插件代码使用的属性信息。在这里，我们将使用
    jQuery 自己来访问属性值。要检索值，我们将`data-`后的属性名部分传递给`.data()`方法。例如，我们写`$('th').first().data('sort')`来获取第一个`<th>`元素的`data-sort`属性的值。
- en: 'When we use the `.data()` method to get the value of a data attribute, jQuery
    converts the value to a number, array, object, Boolean, or null if it determines
    that it is one of those types. Objects must be denoted using JSON syntax, as we
    are doing here. Because the JSON format requires double quotes for its keys and
    string values, we need to use single quotes to surround the attribute value:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `.data()` 方法获取数据属性的值时，如果 jQuery 确定它是其中一种类型，它会将值转换为数字、数组、对象、布尔值或 null。对象必须使用
    JSON 语法表示，就像我们在这里做的一样。因为 JSON 格式要求其键和字符串值使用双引号括起来，所以我们需要使用单引号来包围属性值：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Since jQuery converts this JSON string to an object for us, getting at the
    values we want is simple. To get the value of the `key` property, for example,
    we write:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 jQuery 会将 JSON 字符串转换为对象，因此我们可以简单地获取我们想要的值。例如，要获取`key`属性的值，我们写：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Once a custom data attribute is retrieved in this way, the data is stored internally
    by jQuery and the HTML `data-*` attribute itself is no longer accessed or modified.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦以这种方式检索了自定义数据属性，数据就被 jQuery 内部存储起来，HTML `data-*` 属性本身不再被访问或修改。
- en: 'One great benefit of using data attributes here is that the stored values can
    be different from the table cell content. In other words, all of the work that
    we had to do in the first table to finesse the sorting--converting strings to
    upper case, changing the date format, converting the price to a number--is already
    taken care of. This allows us to write much simpler and more efficient sorting
    code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里使用数据属性的一个很大的好处是，存储的值可以与表格单元格内容不同。换句话说，我们在第一个表格中必须做的所有工作以调整排序--将字符串转换为大写，更改日期格式，将价格转换为数字--已经处理过了。这使我们能够编写更简单、更高效的排序代码：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Listing 12.8
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 第 12.8 节
- en: 'The simplicity of this approach is clear: the `sortKey` constant is set with
    `.data(''sort'').key` and is then used to compare the rows'' sort values with
    `$(a).data(''book'')[sortKey]` and `$(b).data(''book'')[sortKey]`. The efficiency
    is evident in that there is no need to loop through the rows first and call one
    of the `sortKeys` functions each time before calling the `sort` function. With
    this combination of simplicity and efficiency, we''ve also improved the code''s
    performance and made it easier to maintain.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的简单性是显而易见的：`sortKey`常量被设置为`.data('sort').key`，然后用它来比较行的排序值和`$(a).data('book')[sortKey]`以及`$(b).data('book')[sortKey]`。其效率表现在无需先循环遍历行，然后每次在调用`sort`函数之前调用`sortKeys`函数之一。通过这种简单和高效的结合，我们还提高了代码的性能并使其更易于维护。
- en: Sorting and building rows with JSON
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JSON 排序和构建行
- en: So far in this chapter, we have been moving in the direction of outputting more
    and more information from the server into HTML so that our client-side scripts
    can remain as lean and efficient as possible. Now let's consider a different scenario,
    one in which a whole new set of information is displayed when JavaScript is available.
    Increasingly, web applications rely on JavaScript to deliver content as well as
    manipulate it once it arrives. In our third table sorting example, we'll do the
    same.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们一直在朝着将更多信息从服务器输出到 HTML 中的方向前进，以便我们的客户端脚本尽可能保持简洁和高效。现在让我们考虑一个不同的情景，即在
    JavaScript 可用时显示一整套新的信息。越来越多的 Web 应用程序依赖于 JavaScript 传递内容以及一旦内容到达后对其进行操作。在我们的第三个表格排序示例中，我们将做同样的事情。
- en: 'We''ll start by writing three functions:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先编写三个函数：
- en: '`buildAuthors()`: This builds a string list of author names'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buildAuthors()`: 这个函数用于构建作者名称的字符串列表。'
- en: '`buildRow()`: This builds the HTML for a single table row'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buildRow()`: 这个函数用于构建单个表格行的 HTML。'
- en: '`buildRows()`: This builds the HTML for the entire table by mapping the rows
    built by `buildRow()`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buildRows()`: 这个函数通过映射`buildRow()`构建的行来构建整个表格的 HTML。'
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Listing 12.9
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 第 12.9 节
- en: 'For our purposes, we could get by with a single function to handle both tasks,
    but by using three separate functions, we leave open the possibility of building
    and inserting a single row at some other point. These functions will get their
    data from the response to an Ajax request:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，我们可以使用一个函数来处理这两个任务，但是通过使用三个独立的函数，我们留下了在其他时间点构建和插入单个行的可能性。这些函数将从对 Ajax
    请求的响应中获取它们的数据：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Listing 12.10
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 第 12.10 节
- en: We shouldn't have to wait for the DOM to be ready before making an Ajax call.
    There's two promises that need to resolve before we can call `buildRows()` with
    JSON data. First, we need the actual JSON data to come back from the server. Second,
    we need to ensure that the DOM is ready to be manipulated. So, we simply create
    a new promise that's resolved when these two things happen, by using `Promise.all()`.
    The `$.getJSON()` function returns a promise, and `$.ready` is a promise that's
    resolved when the DOM is ready.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行Ajax调用之前，我们不应该等待DOM准备就绪。在我们可以使用JSON数据调用`buildRows()`之前，有两个promise需要解决。首先，我们需要来自服务器的实际JSON数据。其次，我们需要确保DOM已准备好进行操作。因此，我们只需创建一个新的promise，在这两件事发生时解决它，使用`Promise.all()`。`$.getJSON()`函数返回一个promise，而`$.ready`是一个在DOM准备就绪时解决的promise。
- en: Also worth noting is that we need to treat the `authors` data differently because
    it comes from the server as an array of objects with `first_name` and `last_name`
    properties, while everything else arrives as a string or a number. We loop through
    the array of authors--even though for most rows the array consists of only one--and
    concatenate the first name and the last. We then join the array values with a
    comma and a space to end up with a formatted list of names.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得注意的是，我们需要以不同方式处理`authors`数据，因为它作为一个具有`first_name`和`last_name`属性的对象数组从服务器返回，而其他所有数据都作为字符串或数字返回。我们遍历作者数组--尽管对于大多数行，该数组只包含一个作者--并连接名字和姓氏。然后，我们使用逗号和空格将数组值连接起来，得到一个格式化的姓名列表。
- en: The `buildRow()` function assumes that the text we're getting from the JSON
    file is safe for consumption. Since we're concatenating `<img>`, `<td>`, and `<tr>`
    tags along with the text content into a single text string, we need to be sure
    that the text content has no unescaped `<`, `>`, or `&` characters. One way to
    ensure HTML-safe strings is to process them on the server, converting all instances
    of `<` to `&lt;`, `>` to `&gt;`, and `&` to `&amp;`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`buildRow()`函数假设我们从JSON文件中获取的文本是安全可用的。由于我们将`<img>`、`<td>`和`<tr>`标签与文本内容连接成一个字符串，我们需要确保文本内容没有未转义的`<`、`>`或`&`字符。确保HTML安全字符串的一种方法是在服务器上处理它们，将所有的`<`转换为`&lt;`，`>`转换为`&gt;`，并将`&`转换为`&amp;`。'
- en: Modifying the JSON object
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改JSON对象
- en: 'The work we''re doing with the `authors` array is fine if we only plan to call
    the `buildRows()` function once. However, since we intend to call it each time
    the rows are sorted, it''s a good idea to have the author information formatted
    ahead of time. While we''re at it, we can format the title and the author information
    for sorting as well. Unlike the second table, in which each row had sortable data
    in the `data-book` attribute and display data in the table cells, the JSON data
    we''re retrieving for the third table comes in only one flavor. Still, by writing
    one more function, we can include modified values for sorting and displaying before
    we ever get to the table building functions:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`authors`数组的处理很好，如果我们只计划调用`buildRows()`函数一次的话。然而，由于我们打算每次对行进行排序时都调用它，提前格式化作者信息是个好主意。趁机我们也可以对标题和作者信息进行排序格式化。与第二个表格不同的是，第三个表格检索到的JSON数据只有一种类型。但是，通过编写一个额外的函数，我们可以在到达构建表格函数之前包含修改后的排序和显示值：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Listing 12.11
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.11
- en: 'By passing our JSON data through this function, we add two properties to each
    row''s object: `authorsFormatted` and `titleFormatted`. These properties will
    be used for the displayed table contents, preserving the original `authors` and
    `title` properties for sorting. The properties used for sorting are also converted
    to uppercase to make the sort operation case insensitive. We''ve also added a
    new separator argument to the `buildAuthors()` function so that we can use it
    here.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将我们的JSON数据传递给这个函数，我们为每一行的对象添加了两个属性：`authorsFormatted`和`titleFormatted`。这些属性将用于显示的表格内容，保留原始的`authors`和`title`属性用于排序。用于排序的属性也转换为大写，使排序操作不区分大小写。我们还在`buildAuthors()`函数中添加了一个新的分隔符参数，以便在这里使用它。
- en: 'When we call this `prepRows()` function immediately inside the `$.getJSON()`
    callback function, we store the returned value of the modified JSON object in
    the `rows` variable and use that one for sorting and building. This means that
    we also need to change the `buildRow()` function to take advantage of the simplicity
    that our advance preparation has afforded it:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们立即在 `$.getJSON()` 回调函数内调用这个 `prepRows()` 函数时，我们将修改后的 JSON 对象的返回值存储在 `rows`
    变量中，并将其用于排序和构建。这意味着我们还需要改变 `buildRow()` 函数以利用我们提前准备的简便性：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Listing 12.12
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 12.12
- en: Rebuilding content on demand
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根据需要重建内容
- en: 'Now that we''ve prepared the content for both sorting and displaying, we''re
    ready to once again implement the column heading modification and the sorting
    routine:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经为排序和显示准备好了内容，我们可以再次实现列标题修改和排序例程：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Listing 12.13
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 12.13
- en: 'The code inside the `click` handler is nearly identical to the handler for
    the second table in *Listing 12.8*. The one notable difference is that here we
    insert elements into the DOM only once per sort. In tables one and two, even after
    our other optimizations, we sorted the actual DOM elements and then looped through
    them one-by-one, appending each one in turn to arrive at the new order. For example,
    in *Listing 12.8* table rows are reinserted in a loop like so:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`click` 处理程序中的代码与*清单 12.8*中第二个表格的处理程序几乎相同。唯一显著的区别是，这里我们每次排序只向 DOM 中插入一次元素。在表格一和表格二中，即使经过其他优化，我们也是对实际的
    DOM 元素进行排序，然后逐个循环遍历它们，将每一个依次附加以达到新的顺序。例如，在*清单 12.8*中，表格行是通过循环重新插入的：'
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This type of repetitive DOM insertion can be quite costly from a performance
    perspective, especially with a large number of rows. Compare that with our latest
    approach in *Listing 12.13*:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这种重复的 DOM 插入在性能上可能是相当昂贵的，特别是当行数很大时。与我们在*清单 12.13*中的最新方法相比：
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `buildRows()` function returns a string of HTML representing the rows and
    inserts it in one fell swoop, replacing the rows instead of moving the existing
    ones around.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`buildRows()` 函数返回表示行的 HTML 字符串，并一次性插入，而不是移动现有行。'
- en: Revisiting attribute manipulation
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视属性操作
- en: By now, we are used to getting and setting values that are associated with DOM
    elements. We have done this with simple methods such as `.attr()`, `.prop()`,
    and `.css()`, convenient shorthands such as `.addClass()`, `.css()`, and `.val()`,
    and complex bundles of behavior such as `.animate()`. Even the simple methods,
    though, do quite a bit of work for us behind the scenes. We can get even more
    utility out of them if we better understand what they do.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在，我们已经习惯于获取和设置与 DOM 元素相关的值。我们使用了简单的方法，例如 `.attr()`、`.prop()` 和 `.css()`，方便的快捷方式，例如
    `.addClass()`、`.css()` 和 `.val()`，以及复杂的行为捆绑，例如 `.animate()`。即使是简单的方法，它们也在幕后为我们做了很多工作。如果我们更好地理解它们的工作原理，我们可以更有效地利用它们。
- en: Using shorthand element creation syntax
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用简写元素创建语法
- en: We often create new elements in our jQuery code by providing an HTML string
    to the `$()` function or to DOM insertion functions. For example, we create a
    large HTML fragment in *Listing 12.9 *in order to produce many DOM elements. This
    technique is fast and concise. There are circumstances when it is not ideal. We
    might, for instance, want to escape special characters from text before it is
    used, or apply style rules that are browser-dependent. In these cases, we can
    create the element and then chain on additional jQuery methods to alter it, as
    we have done many times already. In addition to this standard technique, the `$()`
    function itself provides an alternative syntax to achieve the same result.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常通过将 HTML 字符串提供给 `$()` 函数或 DOM 插入函数来在我们的 jQuery 代码中创建新元素。例如，我们在*清单 12.9*中创建一个大的
    HTML 片段以产生许多 DOM 元素。这种技术快速而简洁。在某些情况下，它并不理想。例如，我们可能希望在使用文本之前对特殊字符进行转义，或者应用浏览器相关的样式规则。在这些情况下，我们可以创建元素，然后链式附加额外的
    jQuery 方法来修改它，就像我们已经做过很多次一样。除了这种标准技术之外，`$()` 函数本身提供了一种实现相同结果的替代语法。
- en: 'Suppose we want to introduce headings prior to each of the tables in our document.
    We can use an `.each()` loop to iterate over the tables and create an appropriately-named
    heading:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想在文档中的每个表格之前引入标题。我们可以使用 `.each()` 循环来遍历表格并创建一个适当命名的标题：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Listing 12.14
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 12.14
- en: Providing an options object as the second argument to the `$()` function has
    the same effect as first creating the element then passing that object to the
    `.attr()` method. As we know, this method lets us set DOM attributes such as the
    `id` value of the element and its `class`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 将选项对象作为第二个参数传递给 `$()` 函数与首先创建元素然后将该对象传递给 `.attr()` 方法具有相同的效果。正如我们所知，这个方法让我们设置
    DOM 属性，如元素的 `id` 值和其 `class`。
- en: 'The rest of the options in our example are:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们示例中的其他选项包括：
- en: The text inside the element
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素内的文本
- en: Custom additional data
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义额外数据
- en: A click handler
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击处理程序
- en: An object containing CSS properties
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含 CSS 属性的对象
- en: These are not DOM attributes, yet they get set all the same. The shorthand `$()`
    syntax is able to handle these because it first checks to see if a jQuery method
    exists with the given name, and if so, it calls it instead of setting the attribute
    of that name.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这些不是 DOM 属性，但它们仍然被设置。简写的 `$()` 语法能够处理这些，因为它首先检查给定名称的 jQuery 方法是否存在，如果存在，则调用它而不是设置该名称的属性。
- en: Because jQuery gives methods precedence over attribute names, we must take care
    in cases where meaning might be ambiguous; for example, the `size` attribute of
    `<input>` elements, which cannot be set this way because a `.size()` method also
    exists.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 jQuery 会将方法优先于属性名称，所以在可能产生歧义的情况下，我们必须小心；例如，`<input>` 元素的 `size` 属性，因为存在 `.size()`
    方法，所以不能以这种方式设置。
- en: This shorthand `$()` syntax, along with the `.attr()` function, can handle even
    more features through the use of **hooks**.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简写的 `$()` 语法，连同 `.attr()` 函数，通过使用**钩子**可以处理更多功能。
- en: DOM manipulation hooks
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DOM 操作钩子
- en: Many jQuery methods that get and set properties can be extended for special
    cases by defining the appropriate hooks. These hooks are arrays in the jQuery
    namespace with names such as `$.cssHooks` and `$.attrHooks`. In general, hooks
    are objects holding a `get` method that retrieves the requested value, and a `set`
    method that provides a new value.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 jQuery 方法可以通过定义适当的钩子来扩展特殊情况下的获取和设置属性。这些钩子是在 jQuery 命名空间中的数组，名称如 `$.cssHooks`
    和 `$.attrHooks`。通常，钩子是包含一个 `get` 方法以检索请求的值和一个 `set` 方法以提供新值的对象。
- en: 'Hook types include:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 钩子类型包括：
- en: '| **Hook type** | **Method altered** | **Example usage** |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| **钩子类型** | **修改的方法** | **示例用法** |'
- en: '| `$.attrHooks` | `.attr()` | Prevents the `type` attribute of an element from
    being changed. |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `$.attrHooks` | `.attr()` | 阻止更改元素的 `type` 属性。 |'
- en: '| `$.cssHooks` | `.css()` | Provides special handling for `opacity` in Internet
    Explorer. |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `$.cssHooks` | `.css()` | 为 Internet Explorer 提供 `opacity` 的特殊处理。 |'
- en: '| `$.propHooks` | `.prop()` | Corrects the behavior of the `selected` property
    in Safari. |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `$.propHooks` | `.prop()` | 修正了 Safari 中 `selected` 属性的行为。'
- en: '| `$.valHooks` | `.val()` | Allows radio buttons and checkboxes to report a
    consistent value across browsers. |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `$.valHooks` | `.val()` | 允许单选按钮和复选框在各个浏览器中报告一致的值。 |'
- en: Usually the work performed by these hooks is completely hidden to us, and we
    can benefit from them without thinking much about what is going on. Sometimes,
    though, we might want to extend the behavior of jQuery's methods by adding hooks
    of our own.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 通常这些钩子执行的工作对我们完全隐藏，我们可以从中受益而不用考虑正在发生什么。不过，有时候，我们可能希望通过添加自己的钩子来扩展 jQuery 方法的行为。
- en: Writing a CSS hook
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写 CSS 钩子
- en: 'The code in *Listing 12.14* injects a CSS property called `glowColor` onto
    the page. This has no effect on the page at the moment, as such a property does
    not exist. Instead, we are going to extend `$.cssHooks` to add support for this
    newly invented property. We will add a soft glow around the text using the CSS3
    `text-shadow` property when `glowColor` is set on an element:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12.14* 中的代码将一个名为 `glowColor` 的 CSS 属性注入到页面中。目前，这对页面没有任何影响，因为这样的属性并不存在。相反，我们将扩展
    `$.cssHooks` 以支持这个新发明的属性。当在元素上设置 `glowColor` 时，我们将使用 CSS3 的 `text-shadow` 属性在文本周围添加柔和的辉光：'
- en: '[PRE30]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Listing 12.15
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.15
- en: A hook consists of a `get` method and a `set` method for an element. To keep
    our example as brief and simple as possible, we are only defining `set` at this
    time.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 钩子由元素的 `get` 方法和 `set` 方法组成。为了尽可能简洁和简单，我们目前只定义了 `set`。
- en: 'With this hook in place, we now have a 2-pixel soft green glow around the heading
    text:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个钩子，现在我们在标题文本周围有一个 2 像素的柔和绿色辉光：
- en: '![](img/5297_12_07.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_12_07.png)'
- en: 'While the new hook works as advertised, it lacks many features that we might
    expect. Some of these shortcomings include:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然新的钩子按照广告展示的效果工作，但它缺少许多我们可能期望的功能。其中一些缺点包括：
- en: The size of the glow is not customizable
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 辉光的大小不可定制
- en: The effect is mutually exclusive with other uses of `text-shadow` or `filter`
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个效果与 `text-shadow` 或 `filter` 的其他用法是互斥的
- en: The `get` callbacks are unimplemented, so we cannot test for the current value
    of the property
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get` 回调未实现，所以我们无法测试属性的当前值'
- en: The property cannot be animated
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该属性无法进行动画处理
- en: With enough work and additional code, we could surmount all of these obstacles.
    In practice, we rarely have to define our own hooks, however; skilled plugin developers
    have created hooks for a wide variety of needs, including most CSS3 properties.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 只要付出足够的工作和额外的代码，我们就能克服所有这些障碍。然而，在实践中，我们很少需要定义自己的钩子；有经验的插件开发人员已经为各种需要创建了钩子，包括大多数
    CSS3 属性。
- en: Finding hooks
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找钩子
- en: The plugin landscape changes rapidly, so new hooks will crop up all the time,
    and we cannot hope to list them all here. For a sampling of what is possible,
    see Brandon Aaron's collection of CSS hooks at
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 插件的形势变化很快，所以新的钩子会不断出现，我们无法希望在这里列出所有的钩子。要了解可能的一些内容，请参阅 Brandon Aaron 的 CSS 钩子集合。
- en: '[https://github.com/brandonaaron/jquery-cssHooks](https://github.com/brandonaaron/jquery-cssHooks).'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/brandonaaron/jquery-cssHooks](https://github.com/brandonaaron/jquery-cssHooks)。'
- en: Summary
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have solved a common problem--sorting a data table--in three
    different ways, comparing the benefits of each approach. In doing so, we practiced
    the DOM modification techniques that  we have learned earlier and explored the
    `.data()` method for getting and setting data associated with any DOM element
    or attached using HTML5 data attributes. We also pulled back the curtain on several
    DOM modification routines, learning how to extend them for our own purposes.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们用三种不同的方式解决了一个常见问题--对数据表进行排序--并比较了每种方法的优点。这样做的过程中，我们练习了我们之前学到的 DOM 修改技术，并探索了
    `.data()` 方法，用于获取和设置与任何 DOM 元素相关联的数据，或者使用 HTML5 数据属性附加。我们还揭开了几个 DOM 修改例程的面纱，学习了如何为我们自己的目的扩展它们。
- en: Further reading
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: A complete list of DOM manipulation methods is available in *Appendix C* of
    this book, or in the official jQuery documentation at [http://api.jquery.com/](http://api.jquery.com/).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的 *附录 C* 中提供了完整的 DOM 操作方法列表，或者在官方 jQuery 文档中查看 [http://api.jquery.com/](http://api.jquery.com/)。
- en: Exercises
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: The challenge exercise may require the use of the official jQuery documentation
    at [http://api.jquery.com/](http://api.jquery.com/).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战性练习可能需要使用官方 jQuery 文档 [http://api.jquery.com/](http://api.jquery.com/)。
- en: Modify the key computation for the first table so that titles and authors are
    sorted by length rather than alphabetically.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改第一个表的关键计算，使标题和作者按长度而不是字母顺序排序。
- en: Use the HTML5 data in the second table to compute the sum of all of the book
    prices and insert this sum into the heading for that column.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用第二个表中的 HTML5 数据计算所有书的价格总和，并将这个总和插入到该列的标题中。
- en: Change the comparator used for the third table so that titles containing the
    word jQuery come first when sorted by title.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改用于第三个表的比较器，使包含单词 jQuery 的标题首先按标题排序。
- en: 'Challenge: Implement the `get` callback for the `glowColor` CSS hook.'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 挑战：为 `glowColor` CSS 钩子实现 `get` 回调。
