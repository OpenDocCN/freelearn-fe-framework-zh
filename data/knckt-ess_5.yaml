- en: Chapter 5. Getting Data from the Server
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章 从服务器获取数据
- en: We now have a cart application. To make it work as a real-world app, we need
    it to get data from a server. However, this book is focused on how to develop
    a project using KnockoutJS, not on how to configure and run a server.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了一个购物车应用程序。要使其像真实世界的应用程序一样工作，我们需要从服务器获取数据。然而，本书侧重于如何使用 KnockoutJS 开发项目，而不是如何配置和运行服务器。
- en: Fortunately, this situation occurs in every project. Frontend developers begin
    to work just with the data specification and without any backend servers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这种情况在每个项目中都会发生。前端开发人员开始仅使用数据规范，而没有任何后端服务器。
- en: 'In this chapter, we are going to build a fully-functional frontend communication
    layer without a server at the backend. To succeed in this task, we are going to
    mock our data layer with fake objects. When we remove the mock layer, our application
    will be able to work with real data. This will help us to develop our applications
    faster and safer: faster because we don''t need to wait for a real server response,
    and safer, because our data manipulation doesn''t affect the real server.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们将构建一个完全功能的前端通信层，而无需后端服务器。要成功完成这项任务，我们将使用虚假对象模拟我们的数据层。当我们移除模拟层时，我们的应用将能够使用真实数据。这将帮助我们更快、更安全地开发我们的应用程序：更快，因为我们不需要等待真实服务器的响应，更安全，因为我们的数据操作不会影响真实服务器。
- en: REST services
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST 服务
- en: In this chapter, you are going to learn how to make the frontend layer communicate
    with the backend layer.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何使前端层与后端层通信。
- en: You are not building a simple web page. You are building a web application.
    This means that your project does not only contain data to display to the user,
    along with some anchors to click on and navigate. This web page also has a logic
    and model layer behind, and this makes it more complex than a simple web page.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你不是在构建一个简单的网页，你正在构建一个 web 应用程序。这意味着你的项目不仅包含要显示给用户的数据，还有一些可点击的锚点和导航。这个网页还有一个逻辑和模型层，这使得它比一个简单的网页更复杂。
- en: 'To communicate with the server the frontend uses web services. The **W3C**
    (short for **World Wide Web Consortium**) defines a web service as a software
    system designed to support interoperable machine-to-machine interaction over a
    network. There are many protocols you can use to perform this interaction: SOAP,
    POX, REST, RPC, and so on.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 前端与服务器通信使用 Web 服务。W3C（代表 World Wide Web Consortium）定义 Web 服务为一种设计用于在网络上支持可互操作的机器对机器交互的软件系统。你可以使用许多协议来执行此交互：SOAP、POX、REST、RPC
    等。
- en: 'Nowadays in web development, RESTful services are most used. This is because
    the **REST** (short for **Representational State Transfer**) protocol has some
    characteristics that make it easy to use in such apps:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在 web 开发中，RESTful 服务被最多使用。这是因为 REST（代表 Representational State Transfer）协议具有一些特性，使其在这种应用程序中易于使用：
- en: They are based on URI
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是基于 URI 的
- en: Communication is made using internet media types (usually JSON, but it could
    be XML or others)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通信使用互联网媒体类型（通常为 JSON，但也可以是 XML 或其他格式）
- en: 'HTTP methods are standard: `GET`, `POST`, `PUT`, `DELETE`'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP 方法是标准的：`GET`、`POST`、`PUT`、`DELETE`
- en: It is possible to use hyperlinks to reference the state of a resource
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用超链接来引用资源的状态
- en: 'To understand these concepts, we are going to see some examples. Considering
    the cart scenario, suppose you want to retrieve all your products, do the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这些概念，我们将看一些示例。考虑到购物车场景，假设你想检索所有你的产品，那么请执行以下操作：
- en: 'Define the entry point to the API. RESTful protocol is URI based as:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 API 的入口点。RESTful 协议是基于 URI 的，如下所示：
- en: '[PRE0]'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now you want to retrieve all your products, so define a URI that points to
    this resource as:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你想检索所有你的产品，因此定义一个指向此资源的 URI 如下所示：
- en: '[PRE1]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Since this is a retrieve operation, the HTTP header should contain the `GET`
    method as follows:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这是一个检索操作，因此 HTTP 头应包含如下所示的 `GET` 方法：
- en: '[PRE2]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To take advantage of the HTTP protocol, you can send metadata in the header;
    for example, the type of the data you are sending and the data you want to receive,
    in the following manner:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了利用 HTTP 协议，你可以在头部发送元数据；例如，你要发送的数据类型以及你要接收的数据，如下所示：
- en: '[PRE3]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The server will respond with some data in the expected format and some information
    that usually comes within HTTP headers, like the status of the operation: `HTTP/1.1
    200 OK`. Following are the formats:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器将以预期格式回应一些数据和通常包含在 HTTP 头中的一些信息，例如操作的状态：`HTTP/1.1 200 OK`。以下是格式：
- en: 2xx, if all goes fine
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一切顺利，则 2xx
- en: 4xx, if there is an error on the frontend
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4xx，如果前端出现错误
- en: 5xx, if there is an error on the server side
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 5xx，如果服务器端出现错误
- en: 'In case you want to update or delete an object, attach the ID of this object
    to the URI and use the corresponding header. For example, to edit or delete a
    product, call this URI using the proper method: `PUT` to edit and `DELETE` to
    remove. The server will manage these requests properly looking for the information
    in the URI and headers, for instance:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要更新或删除一个对象，请将该对象的ID附加到URI并使用相应的标头。例如，要编辑或删除一个产品，使用适当的方法调用此URI：`PUT`进行编辑和`DELETE`进行删除。服务器将适当处理这些请求，查找URI和标头中的信息，例如：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To know more about REST and RESTful services, refer to [http://en.wikipedia.org/wiki/Representational_state_transfer](http://en.wikipedia.org/wiki/Representational_state_transfer).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关REST和RESTful服务的更多信息，请参阅[http://en.wikipedia.org/wiki/Representational_state_transfer](http://en.wikipedia.org/wiki/Representational_state_transfer)。
- en: Defining CRUD
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义CRUD
- en: 'When you define a service to send and receive data, this object should usually
    perform a minimum level of behavior. You can identify this behavior through the
    acronym **CRUD**:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当您定义一个用于发送和接收数据的服务时，此对象通常应执行最低程度的行为。您可以通过缩写**CRUD**来识别此行为：
- en: '**Create (C)**: You need to send a message to the server with a new object
    to persist it in a database. The HTTP `POST` verb is used for such requests.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建（C）**：您需要向服务器发送一条消息，其中包含要将其持久化在数据库中的新对象。HTTP的`POST`动词用于此类请求。'
- en: '**Retrieve (R)**: The service should be able to send a request to get a collection
    of objects or just one specific object. The `GET` verb is used for such requests.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检索（R）**：该服务应能够发送请求以获取对象集合或仅特定对象。用于此类请求的是`GET`动词。'
- en: '**Update (U)**: This is a request to update an object. By convention, the `PUT`
    verb is used for such requests.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更新（U）**：这是一个更新对象的请求。按照惯例，用于此类请求的是`PUT`动词。'
- en: '**Delete (D)**: This is a request to delete an object. The `DELETE` verb is
    used for such requests.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除（D）**：这是一个删除对象的请求。用于此类请求的是`DELETE`动词。'
- en: More operations can be implemented, and sometimes you do not need to code all
    CRUD methods. You should adapt your code to the application requirements and define
    only operations that the application needs. Remember that writing more code than
    the application needs means creating the possibility of writing more errors in
    the code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 可以实现更多操作，有时您不需要编写所有CRUD方法。您应根据应用程序的要求调整代码，并仅定义应用程序需要的操作。请记住，编写比应用程序需要的更多代码意味着在代码中创造更多错误的可能性。
- en: Singleton resources
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例资源
- en: In this application, we will refer to resources as objects that are related
    to the URI contained in the API server. This means that to manage the `/products`
    URI we are going to have a `ProductResource` object that will manage the CRUD
    operations for this URI.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在此应用程序中，我们将资源称为与API服务器中包含的URI相关的对象。这意味着要管理`/products`URI，我们将拥有一个名为`ProductResource`的对象，该对象将管理此URI的CRUD操作。
- en: We will create this object as a singleton to guarantee that we have just one
    object managing each URI in our application. For more information on singleton,
    refer to [http://en.wikipedia.org/wiki/Singleton_pattern](http://en.wikipedia.org/wiki/Singleton_pattern).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建此对象作为单例，以确保我们在应用程序中只有一个对象管理每个URI。有关单例的更多信息，请参阅[http://en.wikipedia.org/wiki/Singleton_pattern](http://en.wikipedia.org/wiki/Singleton_pattern)。
- en: Setting CRUD operations in the resource
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在资源中设置CRUD操作
- en: We are going to define some services to define CRUD operations for our products
    and orders. A common mistake that some developers make is setting CRUD operations
    within model classes. Best practice says that it is better to separate models
    and communication layers.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一些服务来为我们的产品和订单定义CRUD操作。一些开发人员常犯的一个常见错误是在模型类中设置CRUD操作。最佳实践表明，最好将模型和通信层分开。
- en: 'To prepare your project, create a folder called `services`. In this folder,
    store files that will contain CRUD operations. Perform the following steps:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为准备您的项目，请创建一个名为`services`的文件夹。在此文件夹中，存储包含CRUD操作的文件。执行以下步骤：
- en: 'Create two files in the new folder. They represent two communication services:
    `OrderResource.js` and `ProductResource.js`.'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新文件夹中创建两个文件。它们代表两个通信服务：`OrderResource.js`和`ProductResource.js`。
- en: 'Open the `ProductResource.js` file and define basic CRUD operations as follows:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`ProductResource.js`文件，并定义基本的CRUD操作如下：
- en: '[PRE5]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is the skeleton of the CRUD service. You use the `all` and `get` methods
    to define the retrieve operation. The `all` method will return all the products,
    and `get` just the product with the ID passed as the parameter. The `create` method
    will create a product and the `update` method will update a product. The `remove`
    method will perform the delete operation. We call it `remove` because `delete`
    is a reserved word in the JavaScript language.
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是 CRUD 服务的骨架。你可以使用 `all` 和 `get` 方法来定义检索操作。`all` 方法将返回所有产品，而 `get` 方法只返回传递的
    ID 的产品。`create` 方法将创建一个产品，而 `update` 方法将更新一个产品。`remove` 方法将执行删除操作。我们称其为 `remove`，因为
    `delete` 是 JavaScript 语言中的保留字。
- en: To implement the body of these methods, use jQuery AJAX calls ([http://api.jquery.com/jquery.ajax/](http://api.jquery.com/jquery.ajax/)).
    Such requests to the server are asynchronous and use a concept called promise
    ([http://api.jquery.com/promise/](http://api.jquery.com/promise/)). A **promise**
    is just an object that will contain a value in the future. This value is handled
    by using a callback function.![Setting CRUD operations in the resource](img/7074OS_05_02.jpg)
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实现这些方法的主体，请使用 jQuery AJAX 调用 ([http://api.jquery.com/jquery.ajax/](http://api.jquery.com/jquery.ajax/))。这样向服务器发出的请求是异步的，并使用一个称为
    promise 的概念 ([http://api.jquery.com/promise/](http://api.jquery.com/promise/))。**Promise**
    只是一个将来会包含一个值的对象。这个值通过使用回调函数来处理。
- en: 'Promise diagram: a promise executes asynchronous code'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Promise 图表：一个 promise 执行异步代码
- en: 'To define the `retrieve` method, you need to define the configuration of the
    AJAX request. Calling this method will return a promise. You can handle the data
    contained inside this promise in the view-model in the following manner:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要定义 `retrieve` 方法，你需要定义 AJAX 请求的配置。调用此方法将返回一个 promise。你可以按照以下方式在视图模型中处理此 promise
    中包含的数据：
- en: '[PRE6]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Notice that you just need to define the type of response and endpoint that the
    server has available to get the data (you can see more parameters in the jQuery
    documentation provided earlier). Also complete the `CREATE`, `UPDATE`, and `DELETE`
    methods. Remember to respect the verbs (`POST`, `PUT`, and `DELETE`).
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，你只需要定义服务器可用于获取数据的响应类型和端点。此外，完成 `CREATE`、`UPDATE` 和 `DELETE` 方法。记住要尊重动词 (`POST`、`PUT`
    和 `DELETE`)。
- en: '[PRE7]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Remember that you are building a REST API, so follow the conventions of the
    architecture. This means that a URL for an entity should be named as a plural.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 记住你正在构建一个 REST API，所以要遵循架构的约定。这意味着实体的 URL 应该以复数形式命名。
- en: To get all products, use the `/products` URL. To get just one product, still
    use the `/products` URL, but also add the ID of the product to the URI. For example,
    `/products/7` will return the product with the ID number `7`. If the relationship
    is deeper, for example, "the customer 5 has messages", define the route as `/customers/5/messages`.
    If you want to read the message with ID `1` from user `5`, use `/customers/5/message/1`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取所有产品，使用 `/products` URL。要获取一个产品，仍然使用 `/products` URL，但也将产品的 ID 添加到 URI 中。例如，`/products/7`
    将返回 ID 为 `7` 的产品。如果关系更深入，例如，“客户 5 有消息”，则将路由定义为 `/customers/5/messages`。如果要从用户
    `5` 中读取消息 ID 为 `1` 的消息，则使用 `/customers/5/message/1`。
- en: There are some cases where you can use singular names, such as `/customers/5/configuration/`,
    because a user usually has just one configuration. It is up to you to define when
    words should be pluralized. The only requirement is to be consistent. If you prefer
    to use all names in the singular you can do so, there is no problem. Pluralizing
    the name is just a convention, not a rule.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有些情况下，你可以使用单数名称，比如 `/customers/5/configuration/`，因为一个用户通常只有一个配置。何时使用复数形式取决于你。唯一的要求是保持一致性。如果你更喜欢使用所有名称的单数形式，也可以，没有问题。将名称变为复数只是一种约定，而不是规则。
- en: Using resources in the view-model
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在视图模型中使用资源
- en: 'Now that we have created our product resource, we will use it in our view-model
    to get our data back by following these steps:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了我们的产品资源，我们将在我们的视图模型中使用它来通过以下步骤获取我们的数据：
- en: 'First of all, link the `ProductResource.js` file in the `index.html` file,
    as follows:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在 `index.html` 文件中链接 `ProductResource.js` 文件，如下所示：
- en: '[PRE8]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Since the resource works asynchronously, you can't apply bindings at the end
    of the file because the data may not be ready yet. Therefore, bindings should
    be applied when the data has arrived.
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于资源是异步工作的，所以不能在文件末尾应用绑定，因为数据可能还没有准备好。因此，应在数据到达时应用绑定。
- en: 'To do this, create a method called `activate`. This method will be fired at
    the end of the file, on the same line we called `ko.applyBindings` earlier, in
    the following manner:'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要做到这一点，请创建一个名为`activate`的方法。此方法将在文件末尾触发，在我们之前调用`ko.applyBindings`的同一行上，方式如下：
- en: 'Take this line of code:'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取此行代码：
- en: '[PRE9]'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Replace it with this one:'
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用这个替换它：
- en: '[PRE10]'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now define the `activate` method in the view-model:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在视图模型中定义`activate`方法：
- en: '[PRE11]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When you call the `all` method a jQuery promise is returned. To manage the
    results of the promise, jQuery offers a promise API:'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当您调用`all`方法时，将返回一个jQuery承诺。为了管理承诺的结果，jQuery提供了一个承诺API：
- en: '`.done(callback)`: This method is triggered when a promise is resolved with
    success. This means that a status different from 5xx or 4xx has been received.'
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.done(callback)`：当承诺以成功解决时触发此方法。这意味着收到了与5xx或4xx不同的状态。'
- en: '`.fail(callback)`: You can use this method to handle a rejected promise. It
    is triggered by 5xx and 4xx headers.'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.fail(callback)`：您可以使用此方法来处理被拒绝的承诺。它由5xx和4xx头触发。'
- en: '`.then(successCb, errorCb)`: This method gets two callbacks as parameters.
    The first one is called if the promise is resolved and the second one if the promise
    is rejected.'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.then(successCb, errorCb)`：此方法以两个回调作为参数。第一个在承诺解决时调用，第二个在承诺被拒绝时调用。'
- en: '`.always(callback)`: The callback passed to this method runs in both cases.'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.always(callback)`：传递给此方法的回调在两种情况下运行。'
- en: By using HTTP headers you avoid sending extra information in the body response
    to know that you have got an error. It is important to know about the protocol
    you are using (HTTP in this case) and try to use all its advantages, in this case,
    the possibility of sending information in its header.
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过使用HTTP头，您可以避免在响应主体中发送额外的信息以了解您是否收到了错误。了解您正在使用的协议（在本例中为HTTP）并尝试使用它的所有优势是很重要的，比如在本例中，可以在其标头中发送信息的可能性。
- en: 'Now it is time to define the `allCallbackSuccess` method:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是定义`allCallbackSuccess`方法的时候了：
- en: '[PRE12]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: A jQuery AJAX callback always has the response as the first parameter. In this
    case, you get a JSON response with all the items in the catalog.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个jQuery AJAX回调总是将响应作为第一个参数。在这种情况下，您会收到一个JSON响应，其中包含目录中的所有项目。
- en: The first step is to initialize the catalog as an empty array. Once the catalog
    is initialized, iterate over the collection of items. This collection is stored
    inside a data object. It is a good practice to isolate data within other variables.
    This is just in case you want to add metadata to the response. Once you have the
    catalog ready, link it to the `filteredCatalog` method.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一步是将目录初始化为空数组。一旦目录初始化完成，就可以对项目集合进行迭代。该集合存储在一个数据对象中。将数据隔离在其他变量中是一个好习惯。这只是为了以防您想向响应添加元数据。一旦目录准备就绪，请将其链接到`filteredCatalog`方法。
- en: When you we have the initial data ready, that is the moment you can call the
    `ko.applyBindings` method. If you call it outside the scope of callback you can't
    be sure that the catalog will have all the items inside. This is because resources
    perform operations asynchronously and that means that the code is not executed
    sequentially. It is executed when the promise returned by the resource has data
    available.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们准备好初始数据时，这就是您可以调用`ko.applyBindings`方法的时刻。如果您在回调范围之外调用它，您不能确定目录是否已经包含了所有项目。这是因为资源执行操作是异步的，这意味着代码不是按顺序执行的。当资源返回的承诺有数据可用时，它才被执行。
- en: 'The last step is to run the `activate` method at the end of the file, as follows:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是在文件末尾运行`activate`方法，如下所示：
- en: '[PRE13]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If we run our application, it will not work because there is no server to attend
    to our requests. We will get a 404 error. To solve this problem, we are going
    to mock our AJAX calls and data.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 运行我们的应用程序，它将无法工作，因为没有服务器来处理我们的请求。我们会得到一个404错误。为了解决这个问题，我们将模拟我们的AJAX调用和数据。
- en: '![Using resources in the view-model](img/7074OS_05_03.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![在视图模型中使用资源](img/7074OS_05_03.jpg)'
- en: Making AJAX calls without a server behind will throw a 404 error
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有服务器支持的情况下进行AJAX调用会引发404错误
- en: Using Mockjax to mock HTTP requests
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Mockjax模拟HTTP请求
- en: '**Mocking** **data** just means replacing the `$.ajax` calls with another function
    that emulates its behavior. Mocking is a commonly-used technique when following
    a test-driven development paradigm.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**Mocking** **data**意味着用另一个模拟其行为的函数替换`$.ajax`调用。在遵循测试驱动开发范 paradigm 时，模拟是一种常用的技术。'
- en: 'To mock jQuery AJAX calls, we are going to use a library called Mockjax. To
    install Mockjax in the application, follow these steps:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要模拟jQuery AJAX调用，我们将使用一个名为Mockjax的库。要在应用程序中安装Mockjax，请按照以下步骤操作：
- en: Download the library from [https://github.com/jakerella/jquery-mockjax](https://github.com/jakerella/jquery-mockjax).
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://github.com/jakerella/jquery-mockjax](https://github.com/jakerella/jquery-mockjax)下载该库。
- en: Save it into the `vendors` folder.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其保存到`vendors`文件夹中。
- en: 'Add a reference in the `index.html` page, just after the jQuery library. To
    do this, use the `<script>` tag, as shown here:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`index.html`页面中添加一个引用，就在jQuery库后面。为此，使用`<script>`标签，如下所示：
- en: '[PRE14]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Create a folder called `mocks` and create a `product.js` file inside it.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`mocks`的文件夹，并在其中创建一个名为`product.js`的文件。
- en: 'In the `product.js` file, define a mock calling the `$.mockjax` function, as
    follows:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`product.js`文件中，定义一个调用`$.mockjax`函数的模拟，如下所示：
- en: '[PRE15]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this definition, you are mocking the request called inside the `ProducResource.all()`
    method. To define the mock you just need to define these parameters:'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个定义中，你正在模拟`ProducResource.all()`方法内部调用的请求。要定义模拟，你只需要定义这些参数：
- en: '**url**: The URL you want to mock'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**url**：你想要模拟的URL'
- en: '**type**: The type of request'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**type**：请求的类型'
- en: '**dataType**: The kind of data you expect'
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**dataType**：你期望的数据类型'
- en: '**responseTime**: The duration the response is going to take'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**responseTime**：响应所需的持续时间'
- en: '**responseText**: The body of the response'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**responseText**：响应体'
- en: Generating mock data with MockJSON
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MockJSON生成模拟数据
- en: 'Once you have mocked the HTTP call, you need to send some data in the response.
    You have different possibilities:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你模拟了HTTP调用，你需要在响应中发送一些数据。你有不同的可能性：
- en: 'You can hand-write the data in the `responseText` attribute of the `$.mockjax`
    call:'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以手写数据到`$.mockjax`调用的`responseText`属性中：
- en: '[PRE16]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can use a function to generate the mock data:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用一个函数来生成模拟数据：
- en: '[PRE17]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can use a library that generates complex and random data in the response.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用一个在响应中生成复杂和随机数据的库。
- en: This third option can be performed with a library called `mockJSON`. You can
    download it from the GitHub repository at [https://github.com/mennovanslooten/mockJSON](https://github.com/mennovanslooten/mockJSON).
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这第三个选项可以通过一个叫做`mockJSON`的库来执行。你可以从GitHub仓库[https://github.com/mennovanslooten/mockJSON](https://github.com/mennovanslooten/mockJSON)下载它。
- en: This library allows you to generate data templates to create random data. This
    helps you to keep your fake data more realistic. You can see on the screen many
    different kinds of data. This will help you to check more data display possibilities,
    such as words that overflow inside containers or text that is too long or too
    short and appears ugly on the screen.
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个库允许你生成数据模板来创建随机数据。这有助于使你的虚假数据更加真实。你可以在屏幕上看到许多不同类型的数据。这将帮助你检查更多的数据显示可能性，比如文字是否溢出容器或者文字过长或过短在屏幕上看起来很难看。
- en: 'To generate a random element, define a mock template like this:'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要生成一个随机元素，定义一个模拟模板如下：
- en: '[PRE18]'
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This template says that you want to generate between 5 and 10 elements that
    have the following structure:'
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个模板表示你想要生成5到10个具有以下结构的元素：
- en: The ID will be a number between 1 and 100
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ID将是介于1到100之间的数字。
- en: The product name will be a value stored in the `PRODUCTNAME` array
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品名称将是存储在`PRODUCTNAME`数组中的值。
- en: The price will be a number between 10 and 500
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 价格将是介于10到500之间的数字。
- en: The stock will be a number between 1 and 9
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 股票价格将是介于1到9之间的数字。
- en: 'To generate the product name array, you just need to add an array or a function
    to the `$.mockJSON.data` object, as follows:'
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要生成产品名称数组，你只需要将一个数组或一个函数添加到`$.mockJSON.data`对象中，如下所示：
- en: '[PRE19]'
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You can generate any kind of data you can imagine. Just create a function and
    return an array with the values you want to generate, or define a function that
    generates a random result, a number, a unique ID, and so on.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以生成任何你能想象到的数据。只需创建一个函数，返回一个你想要生成的值的数组，或者定义一个生成随机结果、数字、唯一ID等的函数。
- en: 'To return this as a response, attach this template to the response text. Your
    code should look like this:'
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将其作为响应返回，请将此模板附加到响应文本。你的代码应该如下所示：
- en: '[PRE20]'
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Add the `mocks/product.js` file at the end of the `index.html` file with the
    `<script>` tag and see how you get new random data each time you refresh the web
    page.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在`index.html`文件的末尾使用`<script>`标签添加`mocks/product.js`文件，然后查看每次刷新网页时如何获得新的随机数据。
- en: '![Generating mock data with MockJSON](img/7074OS_05_04.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![使用MockJSON生成模拟数据](img/7074OS_05_04.jpg)'
- en: When a mock call is done, we see this message in the console
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当进行模拟调用时，我们会在控制台中看到这条消息
- en: Retrieving a product by ID
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过ID检索产品
- en: To obtain just one product from our API, we are going to fake the `get` method
    of `ProductResource`. The `ProductResource.get` method will be fired when we click
    on the name of the product in the catalog list.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要从我们的 API 获取一个产品，我们将伪造 `ProductResource` 的 `get` 方法。 即当我们在目录列表中点击产品名称时，`ProductResource.get`
    方法将被激活。
- en: This URI has the product's ID in the last segment of the URI. This means that
    a product with ID=1 will generate a URI like `/products/1`. A product with ID=2
    will generate a URI like `/products/2`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此 URI 在 URI 的最后一段包含产品的ID。 这意味着ID=1的产品将生成类似 `/products/1` 的URI。 ID=2的产品将生成类似
    `/products/2` 的URI。
- en: This implies, therefore, that we can't set the URL as a fixed string. We need
    to use a regular expression.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这意味着我们无法将 URL 设置为固定字符串。 我们需要使用正则表达式。
- en: 'If you need more information about regular expressions check this link:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要更多关于正则表达式的信息，请查看此链接：
- en: '[https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/Regular_Expressions](https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/Regular_Expressions)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/Regular_Expressions](https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/Regular_Expressions)'
- en: 'In order to complete the code to retrieve a product, follow these steps:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成代码以检索产品，请按照以下步骤进行：
- en: 'Add a `mockjax` call to mock the URI. It should use the `GET` HTTP method.
    Attach the regular expression to the `url` attribute, as follows:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `mockjax` 调用来模拟 URI。它应该使用 `GET` HTTP 方法。将正则表达式附加到 `url` 属性，如下所示：
- en: '[PRE21]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create a template that returns a single product object. To generate a random
    description you can use the `@LOREM_IPSUM` magic variable that will return random
    text. It works in the same way you built the `@PRODUCTNAME` variable. Let''s create
    a template using the following code:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个返回单个产品对象的模板。要生成随机描述，您可以使用 `@LOREM_IPSUM` 魔术变量，它会返回随机文本。它的使用方式与构建 `@PRODUCTNAME`
    变量的方式相同。让我们使用以下代码创建一个模板：
- en: '[PRE22]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Attach the following template to the `responseText` variable:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下模板附加到 `responseText` 变量：
- en: '[PRE23]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the `viewmodel.js` file, create a method that uses the `ProductResource`
    object to retrieve the product. The method will display an alert box when the
    data becomes available.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `viewmodel.js` 文件中，创建一个方法，该方法使用 `ProductResource` 对象检索产品。 该方法在数据可用时将显示一个警告框。
- en: '[PRE24]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Bind the `showDescription` method to the `catalog.html` template:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `showDescription` 方法绑定到 `catalog.html` 模板上：
- en: '[PRE25]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Expose the `showDescription` method in the view-model interface:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在视图模型接口中公开 `showDescription` 方法：
- en: '[PRE26]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Test how you get a description in the alert box.![Retrieving a product by ID](img/7074OS_05_05.jpg)
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试如何在警告框中获取描述。![按ID检索产品](img/7074OS_05_05.jpg)
- en: Clicking on the product name will display the product description
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 点击产品名称将显示产品描述
- en: Creating a new product
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新产品
- en: 'To create a product, follow the same steps as in the previous section:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个产品，请按照前一节中的相同步骤进行：
- en: 'Add an AJAX mock call in the `mocks/product.js` file:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`mocks/product.js` 文件中添加一个 AJAX 模拟调用：
- en: '[PRE27]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You should keep in mind some considerations:'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您应该记住一些注意事项：
- en: You should use the `POST` verb to create an object. Actually, you can use any
    verb you want, but as per the RESTful API conventions, the `POST` verb is the
    one you should use to create new objects.
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您应该使用 `POST` 动词来创建对象。实际上，您可以使用任何您想要的动词，但根据 RESTful API 的约定，`POST` 动词是您应该用来创建新对象的一个。
- en: The response text is a message that provides some information about the result.
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应文本是提供有关结果的一些信息的消息。
- en: 'The result itself is managed by the headers:'
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果本身由标头管理：
- en: If you get a `2xx` value in the status, the `done` method is fired.
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在状态中获得 `2xx` 值，则会触发 `done` 方法。
- en: If you get a `4xx` or `5xx` error, the `fail` method is called.
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果收到 `4xx` 或 `5xx` 错误，则调用 `fail` 方法。
- en: 'Go to the `modelview.js` file and update the `addProduct` function:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到 `modelview.js` 文件并更新 `addProduct` 函数：
- en: '[PRE28]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Obviously, you can't send Knockout observables to the server. To convert objects
    that contain observables into plain JSON objects, use the `ko.to` `JS` function.
    This function iterates over the objects and extracts the value of each observable.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 显而易见，您不能将 Knockout observables 发送到服务器。 要将包含 observables 的对象转换为普通 JSON 对象，请使用
    `ko.to` `JS` 函数。 此函数会遍历对象并提取每个 observable 的值。
- en: You can find information about `ko.to` `JS` and other methods at [http://knockoutjs.com/documentation/json-data.html](http://knockoutjs.com/documentation/json-data.html).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [http://knockoutjs.com/documentation/json-data.html](http://knockoutjs.com/documentation/json-data.html)
    上找到关于 `ko.to` `JS` 和其他方法的信息。
- en: Maybe you have noticed that when you add a new product, the stock goes down
    by one. This is because when you use the `ko.toJS` function in the product it
    executes all functions it has. So, to use it you should avoid methods that manipulate
    the object and can change its values internally. We are going to solve this issue
    in the next section.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你已经注意到了，当你添加一个新产品时，库存会减少一个。这是因为当你在产品中使用`ko.toJS`函数时，它会执行所有的函数。因此，为了使用它，你应该避免那些会操作对象并可能在内部改变其值的方法。我们将在下一节中解决这个问题。
- en: Test that the application sends data when you call the `addProduct` method.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 测试应用程序在调用`addProduct`方法时是否发送数据。
- en: '![Creating a new product](img/7074OS_05_06.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![创建新产品](img/7074OS_05_06.jpg)'
- en: Adding new products uses the AJAX call; pay attention to URL and type fields
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新产品时使用AJAX调用；注意URL和类型字段
- en: Separation of concerns – behavior and data
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关注关注点分离 - 行为和数据
- en: We have found a problem in our application. When we use the `ko.toJS` function,
    the result is not as expected. This is a common scenario in software development.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在应用程序中发现了一个问题。当我们使用`ko.toJS`函数时，结果与预期不符。这是软件开发中常见的情况。
- en: We have made a bad choice setting some logic in our models and we need to fix
    it. To solve this problem, we are going to separate the data and these behaviors.
    We are going to use some classes that we will call services.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在模型中设置了一些逻辑，这是一个错误的选择，我们需要修复它。为了解决这个问题，我们将数据和这些行为分开。我们将使用一些我们称之为服务的类。
- en: Services will manage the logic of our models. This means that each model will
    have a related service that will manage its state.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 服务将管理我们模型的逻辑。这意味着每个模型都会有一个相关的服务来管理其状态。
- en: Creating the product service
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建产品服务
- en: 'If you look in the `models/product.js` file, you can see that the model contains
    some logic:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`models/product.js`文件，你会发现该模型包含一些逻辑：
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We are going to move this logic and some more to a service with the following
    steps:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下步骤将此逻辑和更多内容移动到一个服务中：
- en: Create a folder called `services`.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`services`的文件夹。
- en: Inside it, create a file called `ProductService`.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中，创建一个名为`ProductService`的文件。
- en: 'Create a singleton object and add the `hasStock` and `decreaseStock` functions,
    as follows:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个单例对象，并添加`hasStock`和`decreaseStock`函数，如下所示：
- en: '[PRE30]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Update the `add-to-cart-button` component:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`add-to-cart-button`组件：
- en: '[PRE31]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Notice that you need also to create a service to manage the cart item logic.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你还需要创建一个服务来管理购物车商品的逻辑。
- en: Creating the CartProduct service
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建`CartProduct`服务
- en: 'The cart item service also extracts the logic of the `CartProduct` model. To
    create this service, follow these steps:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 购物车商品服务还提取了`CartProduct`模型的逻辑。要创建此服务，请按照以下步骤操作：
- en: Create a file called `CartProductService.js` in the `service` folder.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`service`文件夹中创建一个名为`CartProductService.js`的文件。
- en: Remove the `addUnit` and `removeUnit` methods from the `CartProduct` model.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`CartProduct`模型中删除`addUnit`和`removeUnit`方法。
- en: 'Update the service with these methods:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下方法更新服务：
- en: '[PRE32]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Updating a product
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新产品
- en: 'In our catalog, we will want to update the value of our product. To complete
    this action, follow these steps:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的目录中，我们将希望更新我们产品的价值。要完成此操作，请按照以下步骤操作：
- en: 'First, to update a product you need to mock the URI that handles the action:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，要更新一个产品，你需要模拟处理该操作的URI：
- en: '[PRE33]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Add a button in each row in the `catalog.html` view, in the same cell you have
    the `add-to-cart-button` component:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`catalog.html`视图的每一行中添加一个按钮，在您有`add-to-cart-button`组件的相同单元格中：
- en: '[PRE34]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, open a modal with the data of this product:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用这个产品的数据打开一个模态框：
- en: '[PRE35]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `tmpProduct` will contain a copy of the object you are going to edit:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`tmpProduct`将包含您要编辑的对象的副本：'
- en: '[PRE36]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `selectedProduct` will contain the original product you are going to edit:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`selectedProduct`将包含您要编辑的原始产品：'
- en: '[PRE37]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Create the `clone` function in the `ProductService` resource:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ProductService`资源中创建`clone`函数：
- en: '[PRE38]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Create the `refresh` function in the `ProductService` resource. This method
    allows the service to refresh the product without losing the reference into the
    cart.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ProductService`资源中创建`refresh`函数。此方法允许服务在不丢失对购物车中产品的引用的情况下刷新产品。
- en: '[PRE39]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Add both methods to the service interface:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这两个方法添加到服务接口中：
- en: '[PRE40]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Create the `edit-product-modal.html` template to display the edit modal. This
    template is a copy of the `create-product-modal.html` template. You just need
    to update the form tag line, as follows:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`edit-product-modal.html`模板以显示编辑模态框。此模板是`create-product-modal.html`模板的副本。你只需要更新form标签行，如下所示：
- en: '[PRE41]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You also need to update the `button` bindings:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还需要更新`button`绑定：
- en: '[PRE42]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, define the `cancelEditon` and the `saveProduct` method:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，定义`cancelEditon`和`saveProduct`方法：
- en: '[PRE43]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Finally, add these methods to the view-model API.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将这些方法添加到视图模型API中。
- en: Now you can test how to update different values of the product.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以测试如何更新产品的不同值。
- en: Deleting a product
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除产品
- en: To delete a product, follow some simple steps as you did with the `CREATE` and
    `UPDATE` methods.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除产品，按照与`CREATE`和`UPDATE`方法相同的简单步骤进行操作。
- en: 'The first step is to create the mocks in the `mocks/products.js` file, as follows:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是在`mocks/products.js`文件中创建模拟内容，如下所示：
- en: '[PRE44]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This method is quite easy. Just add a button like the edit button and then the
    action to remove it.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这种方法非常简单。只需添加一个类似编辑按钮的按钮，然后删除它。
- en: '[PRE45]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Create a function to remove the product from the cart. This function iterates
    over the cart items and locates the cart item which is related to the removed
    product. Once this item is located, you can remove it as a normal item using the
    `removeFromCart` function:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数来从购物车中移除产品。此函数遍历购物车项目并找到与移除产品相关的购物车项目。一旦找到该项目，就可以使用`removeFromCart`函数将其删除为普通项目：
- en: '[PRE46]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Add a button in the catalog template next to the edit button:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在目录模板中添加一个按钮，位于编辑按钮旁边：
- en: '[PRE47]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '![Deleting a product](img/7074OS_05_07.jpg)'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![删除产品](img/7074OS_05_07.jpg)'
- en: Edit and delete buttons
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编辑和删除按钮
- en: Sending the order to the server
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将订单发送到服务器
- en: 'Once you can communicate with the server to manage our products, it''s time
    to send the order. For this purpose, follow these instructions:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您可以与服务器通信来管理我们的产品，就是时候发送订单了。为此，请按照以下说明进行：
- en: 'Create a file named `resources/OrderResource.js` with this content:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`resources/OrderResource.js`的文件，并添加以下内容：
- en: '[PRE48]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Mock the call by creating a file called `mocks/order.js` and adding this code:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建名为`mocks/order.js`的文件并添加以下代码来模拟调用：
- en: '[PRE49]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Update the `finishOrder` method in the `viewmodel.js` file:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`viewmodel.js`文件中的`finishOrder`方法：
- en: '[PRE50]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: One of the requirements of our application is that the user has the option to
    update personal data. We are going to allow the user to attach personal data to
    the order. This is important because when we send an order, we need to know who
    is going to receive it.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的要求之一是，用户可以更新个人数据的选项。我们将允许用户将个人数据附加到订单中。这很重要，因为当我们发送订单时，我们需要知道谁将收到订单。
- en: 'Create a new file in the `models` folder called `Customer.js`. It will contain
    the following function that will generate a customer:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`models`文件夹中创建一个名为`Customer.js`的新文件。它将包含以下函数，用于生成客户：
- en: '[PRE51]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Link it to the view-model:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 链接到视图模型：
- en: '[PRE52]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Create also an observable array to store the countries that are available to
    sell:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要创建一个用于存储可销售国家的可观察数组：
- en: '[PRE53]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Create a form in the order template to show a form to complete the customer
    data:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在订单模板中创建一个表单，以显示一个完成客户数据的表单：
- en: '[PRE54]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Send this information with the order request using the `finishOrder` method:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`finishOrder`方法将此信息与订单请求一起发送：
- en: '[PRE55]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Our AJAX communication is complete. Now you can add and remove the `mocks/*.js`
    files from your project to get fake data or real data. While using this method,
    you don't need to have a server running behind your application when you are developing
    frontend issues.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 AJAX 通讯已经完成。现在，您可以在项目中添加和移除`mocks/*.js`文件，以获取虚假数据或真实数据。在使用此方法时，当您开发前端问题时，无需在应用程序后面运行服务器。
- en: '![Sending the order to the server](img/7074OS_05_08.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![将订单发送到服务器](img/7074OS_05_08.jpg)'
- en: Once personal data is provided you can close the order
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦提供了个人数据，您就可以关闭订单
- en: Handling AJAX errors
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理 AJAX 错误
- en: 'We have built the happy path of our application. But in the real world an error
    can occur during communication with the server. To manage this there are two ways:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建了应用程序的正常路径。但在现实世界中，在与服务器的通讯过程中可能会发生错误。要处理这种情况有两种方法：
- en: 'The `fail` method of the AJAX promise:'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AJAX 承诺的`fail`方法：
- en: '[PRE56]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'A global AJAX error handler:'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个全局的 AJAX 错误处理程序：
- en: '[PRE57]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: If you have a consistent error format, the global handler is a very good choice
    to handle errors.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一致的错误格式，全局处理程序是处理错误的非常好的选择。
- en: 'To test an error, update the status attribute of one mock from 200 to 404 or
    501:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试错误，请将一个模拟的状态属性从 200 更新为 404 或 501：
- en: '[PRE58]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Validating data
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证数据
- en: Now you can send and receive data, but what happens if the user sets some data
    that is not allowed on the server? You have no control over user input. It is
    important that if some values are not allowed, you alert the user to it. To validate
    Knockout data, there is a library called Knockout Validation (which can be found
    at [https://github.com/Knockout-Contrib/Knockout-Validation](https://github.com/Knockout-Contrib/Knockout-Validation))
    that makes this very easy.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以发送和接收数据了，但是如果用户设置了服务器不允许的一些数据会发生什么？您无法控制用户输入。如果某些值不允许，重要的是要提醒用户。要验证Knockout数据，有一个名为Knockout
    Validation的库（可在[https://github.com/Knockout-Contrib/Knockout-Validation](https://github.com/Knockout-Contrib/Knockout-Validation)找到），可以使这变得非常容易。
- en: This library extends the observables with some values that allow you to validate
    the data when it changes. We are now going to update our models to add some kind
    of validation.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 此库通过为可观察对象添加一些值来扩展可观察对象，以使您在数据更改时能够验证数据。我们现在将更新我们的模型以添加某种验证。
- en: Extending the product model
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展产品模型
- en: 'To validate our models using the Knockout Validation library, we are going
    to extend our model''s attributes. **Extenders** are a basic feature of Knockout.
    Using extenders we can add some properties to our observables to increase their
    behavior. For more information on extenders, please refer to the following link:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用Knockout Validation库验证我们的模型，我们将扩展我们模型的属性。**扩展器**是Knockout的基本功能。使用扩展器，我们可以向我们的可观察对象添加一些属性以增强其行为。有关扩展器的更多信息，请参阅以下链接：
- en: '[http://knockoutjs.com/documentation/extenders.html](http://knockoutjs.com/documentation/extenders.html)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://knockoutjs.com/documentation/extenders.html](http://knockoutjs.com/documentation/extenders.html)'
- en: 'We are going to extend our product model with some properties that will allow
    us to validate data by following these steps:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过以下步骤扩展我们的产品模型以添加一些属性，以允许我们验证数据：
- en: Go to the `models/Product.js` file.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`models/Product.js`文件。
- en: 'Update the `name` field. It should have at least three letters and should contain
    just letters, numbers, and dashes:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`name`字段。它应至少包含三个字母，并且应仅包含字母、数字和破折号：
- en: '[PRE59]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Update the `price` to allow just numbers, and set a range (maximum and minimum
    values) for it:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`price`以仅允许数字，并为其设置范围（最大和最小值）：
- en: '[PRE60]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Do the same with the `stock`:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`stock`也执行同样的操作：
- en: '[PRE61]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Create a validation group to know when the full object is valid:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个验证组以确定何时整个对象是有效的：
- en: '[PRE62]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This error variable will contain an observable array. When this array has no
    elements, all observables have a correct value.
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此错误变量将包含一个可观察数组。当此数组没有元素时，所有可观察对象均具有正确的值。
- en: 'In the `add-to-catalog-modal.html` template, enable the create button only
    if all values in the product are valid:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`add-to-catalog-modal.html`模板中，仅在产品中的所有值都有效时才启用创建按钮：
- en: '[PRE63]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Add the same button to the `edit-product-modal.html` template:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`edit-product-modal.html`模板中添加相同的按钮：
- en: '[PRE64]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'If you want to set a style for the error messages, you just need to define
    CSS rules for the `validationMessage` class, as follows. A `span` element will
    be shown next to the element that is bound with the validated observable:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果要为错误消息设置样式，只需为`validationMessage`类定义CSS规则，如下所示。将显示一个`span`元素，显示在与验证的可观察对象绑定的元素旁边：
- en: '[PRE65]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Extending the customer model
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展客户模型
- en: 'You also need to validate the customer data. These are the rules for validation:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要验证客户数据。以下是验证规则：
- en: A first name is required
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名字是必需的
- en: A last name is required and it needs a minimum of three characters
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 姓是必需的，且至少需要三个字符
- en: An address is required and it needs a minimum of five characters
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地址是必需的，且至少需要五个字符
- en: An e-mail address is required and must match the built-in e-mail pattern
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子邮件地址是必需的，并且必须与内置的电子邮件模式匹配
- en: The zip code is required and must contain five numbers
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 邮政编码是必需的，且必须包含五个数字
- en: 'To achieve this task, make some updates in the code, as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成此任务，请按照以下方式更新代码：
- en: 'Extend the customer object in the `models/Customer.js` file:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`models/Customer.js`文件中扩展客户对象：
- en: '[PRE66]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Enable the buy button if the customer data is completed and valid in the `order.html`
    template:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果客户数据已完成并且有效，请在`order.html`模板中启用购买按钮。
- en: '[PRE67]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Show the user information in the `finish-order-modal.html` template:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`finish-order-modal.html`模板中显示用户信息。
- en: '[PRE68]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '![Extending the customer model](img/7074OS_05_09.jpg)'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![扩展客户模型](img/7074OS_05_09.jpg)'
- en: Validation messages that appear if information in the fields is not valid
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果字段中的信息无效，则显示验证消息。
- en: Now our models are validated and we know that the data we are sending has a
    valid format.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的模型已经验证，并且我们知道我们发送的数据具有有效的格式。
- en: To view the complete code of the application, you can download the code of this
    chapter from [https://github.com/jorgeferrando/knockout-cart/tree/chapter5](https://github.com/jorgeferrando/knockout-cart/tree/chapter5).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看应用程序的完整代码，你可以从[https://github.com/jorgeferrando/knockout-cart/tree/chapter5](https://github.com/jorgeferrando/knockout-cart/tree/chapter5)下载本章的代码。
- en: Summary
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to communicate with our application using jQuery
    to perform AJAX calls. You also learned how easy it is to apply validation to
    our models using the Knockout Validation library, which uses the `extend` method
    native to Knockout to increase the behavior of observables.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何使用jQuery与我们的应用程序进行通信以执行AJAX调用。 你还学会了使用Knockout Validation库对我们的模型应用验证有多么容易，该库使用了Knockout本身的`extend`方法来增强可观察对象的行为。
- en: 'You experienced one of the problems that KnockoutJS has: you need to serialize
    the objects to send them to the server and you need to wrap them in observables
    when they come from the server. To solve this, you have the `ko.toJS` method,
    but this implies having objects without code that allows them to update their
    values.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 你经历了KnockoutJS的一个问题：你需要将对象序列化后发送到服务器，并且需要在从服务器返回时将它们包装在可观察对象中。 要解决这个问题，你可以使用`ko.toJS`方法，但这意味着对象没有允许它们更新值的代码。
- en: In the next chapter, you will learn how to manage dependencies between files
    using RequireJS and the module pattern.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，你将学会如何使用RequireJS和模块模式来管理文件之间的依赖关系。
