<html><head></head><body>
		<div id="_idContainer066">
			<h1 id="_idParaDest-153"><em class="italic"><a id="_idTextAnchor176"/>Chapter 9</em>: Implementing Server-Side Rendering</h1>
			<p>With our progress from the last chapter, we are now serving multiple pages under different paths with our <strong class="bold">React</strong> application. Currently, all of the routing happens directly on the client. In this chapter, we will look at the advantages and disadvantages of <strong class="bold">server-side rendering</strong> (<strong class="bold">SSR</strong>). By the end of the chapter, you will have configured <strong class="bold">Graphbook</strong> to serve all pages as pre-rendered HTML from the server instead of the client.</p>
			<p>This chapter covers the following topics:</p>
			<ul>
				<li>Introducing SSR</li>
				<li>Setting up SSR in <strong class="bold">Express.js</strong> to render React on the server</li>
				<li>Enabling <strong class="bold">JSON Web Token</strong> (<strong class="bold">JWT</strong>) authentication in connection with SSR</li>
				<li>Running all of our <strong class="bold">GraphQL</strong> queries in the React tree</li>
			</ul>
			<h1 id="_idParaDest-154"><a id="_idTextAnchor177"/>Technical requirements</h1>
			<p>The source code for this chapter is available in the following <strong class="bold">GitHub</strong> repository:</p>
			<p><a href="https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter09">https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter09</a></p>
			<h1 id="_idParaDest-155"><a id="_idTextAnchor178"/>Introducing SSR</h1>
			<p>First, you have to understand the differences between using a server-side-rendered and a client-side-rendered <a id="_idIndexMarker719"/>application. There are numerous things to bear in mind when transforming a pure client-side-rendered application to support SSR. In our application, the current user flow begins with the client requesting a standard <strong class="source-inline">index.html</strong> file. This file includes only a small number of things, such as a small <strong class="source-inline">body</strong> object with one <strong class="source-inline">div</strong> element, a <strong class="source-inline">head</strong> tag with some very basic <strong class="source-inline">meta</strong> tags, and a vital <strong class="source-inline">script</strong> tag that downloads the bundled <strong class="bold">JavaScript</strong> file created by <strong class="bold">webpack</strong>. The server <a id="_idIndexMarker720"/>merely serves the <strong class="source-inline">index.html</strong> and the <strong class="source-inline">bundle.js</strong> files. Then, the client's browser begins processing the React <a id="_idIndexMarker721"/>markup that we wrote. When React has finished evaluating the code, we see the HTML of the application that we wanted to see. All CSS files or images are also <a id="_idIndexMarker722"/>downloaded from our server, but only when React has <a id="_idIndexMarker723"/>inserted the HTML into the browser's <strong class="bold">Document Object Model</strong> (<strong class="bold">DOM</strong>). During the rendering by React, the <strong class="bold">Apollo</strong> components are executed <a id="_idIndexMarker724"/>and all of the queries are sent. These queries are, of course, handled by our backend and database.</p>
			<p>In comparison with SSR, the client-side approach is straightforward. Before the development of <strong class="bold">Angular</strong>, <strong class="bold">Ember</strong>, <strong class="bold">React</strong>, and other JavaScript frameworks, the conventional approach was to have a backend that implemented all of the business logic and also a high number of <a id="_idIndexMarker725"/>templates or functions that returned valid HTML. The backend queried the database, processed the data, and inserted the data into the HTML. The HTML was directly served at the request of the client. The browser then downloaded the JavaScript, CSS, and image files according to the HTML. Most of the time, the JavaScript was only responsible for allowing dynamic content or layout changes, rather than rendering the entire application. This could include drop-down menus, accordions, or just pulling new data from the backend via <strong class="bold">Ajax</strong>. The main HTML of the application, however, was <a id="_idIndexMarker726"/>directly returned from the backend, which resulted in a monolith application. A significant benefit of this solution is that the client does not need to process all of the business logic, as it has already been done on the server.</p>
			<p>However, when we talk about SSR in the context of React applications, we are referring to something different. At this point in the book, we have written a React application that renders on the client. We do not want to re-implement the rendering for the backend in a slightly different way. We also don't want to lose the ability to change data, pages, or the layout dynamically in the browser, as we already have an excellent working application with many interaction possibilities for the user.</p>
			<p>An approach that allows us to make use of the pre-rendered HTML – as well as the dynamic <a id="_idIndexMarker727"/>features provided by React – is called <strong class="bold">universal rendering</strong>. With universal rendering, the first request of the client includes a pre-rendered HTML page. The HTML should be the exact HTML that the client generates when processing it on its own. If this is the case, React can reuse the HTML provided by the server. Since SSR not only involves reusing HTML but also saving requests made by Apollo, the client also needs a starting cache that React can rely on. The server makes all of the requests before <a id="_idIndexMarker728"/>sending the rendered HTML and inserts a state variable for Apollo and React into the HTML. The result is that on the first request by the client, our frontend should not need to rerender or refresh any HTML or data that is returned by the server. For all following actions, such as navigating to other pages or sending messages, the same client-side React code from before is used. In other words, SSR is only used on the first page load. Afterward, these features do not require SSR because the client-side code continues to work dynamically, as it did before.</p>
			<p>Let's get started with writing some code.</p>
			<h1 id="_idParaDest-156"><a id="_idTextAnchor179"/>Setting up SSR in Express.js to render React on the server</h1>
			<p>In this example, the first step is to implement basic SSR on the backend. We are <a id="_idIndexMarker729"/>going to extend this functionality later to validate the authentication of the user. An authenticated user allows us to execute Apollo or GraphQL requests rather than only  render the pure React markup. First, we need some new packages. Because we are going to use universally rendered React code, we require an advanced webpack configuration. Therefore, we will install the following packages:</p>
			<p class="source-code">npm install --save-dev webpack-dev-middleware webpack-hot-middleware @babel/cli</p>
			<p>Let's quickly go through the packages that we are installing. We only need these packages for development:</p>
			<ul>
				<li>The first webpack module, called <strong class="source-inline">webpack-dev-middleware</strong>, allows the backend to serve bundles that are generated by webpack, but from memory and without creating files. This is convenient for cases in which we need to run JavaScript directly and do not want to use separate files.</li>
				<li>The second package, called <strong class="source-inline">webpack-hot-middleware</strong>, only handles client-side updates. If a new version of a bundle is created, the client is notified, and the bundle is exchanged.</li>
				<li>The last <a id="_idIndexMarker730"/>package, called <strong class="source-inline">@babel/cli</strong>, allows us to introduce the great features that <strong class="bold">Babel</strong> provides to our backend. We are going to use React code that has to be transpiled.</li>
			</ul>
			<p>In a production environment, it is not recommended to use these packages. Instead, the bundle is built once before deploying the application. The client downloads the bundle when the application has gone live.</p>
			<p>For development with SSR enabled, the backend uses these packages to distribute the bundled React code to the client after the SSR has finished. The server itself relies on the plain <strong class="source-inline">src</strong> files and not on the webpack bundle that the client receives.</p>
			<p>We also depend on one further essential package, shown as follows:</p>
			<p class="source-code">npm install --save node-fetch</p>
			<p>To set up <strong class="bold">Apollo Client</strong> on the backend, we require a replacement of the standard <strong class="source-inline">window.fetch</strong> method. Apollo Client uses this to send GraphQL requests, which is why we install <strong class="source-inline">node-fetch</strong> as <a id="_idIndexMarker731"/>a polyfill. We are going to set up Apollo Client for the backend later in this chapter.</p>
			<p>Before starting with the primary work, ensure that your <strong class="source-inline">NODE_ENV</strong> environment variable is set to <strong class="source-inline">development</strong>.</p>
			<p>Then, head over to the server's <strong class="source-inline">index.js</strong> file, where all of the Express.js magic happens. We didn't cover this file in the previous chapter because we are going to adjust it now to support SSR including the routing directly.</p>
			<p>First, we will set up the development environment for SSR, as this is essential for our next tasks. Follow these steps to get your development environment ready for SSR:</p>
			<ol>
				<li>The first step is to import two new webpack modules: <strong class="source-inline">webpack-dev-middleware</strong> and <strong class="source-inline">webpack-hot-middleware</strong>. These should only be used in a development environment, so we should require them conditionally by checking the environment variables. In a production environment, we generate the webpack bundles in advance. In order to only use the new packages in development, put the following code underneath the setup for the Express.js helmet:<p class="source-code">if(process.env.NODE_ENV === 'development') {</p><p class="source-code">  const devMiddleware = </p><p class="source-code">    require('webpack-dev-middleware');</p><p class="source-code">  const hotMiddleware = </p><p class="source-code">    require('webpack-hot-middleware');</p><p class="source-code">  const webpack = require('webpack');</p><p class="source-code">  const config = </p><p class="source-code">    require('../../webpack.server.config');</p><p class="source-code">  const compiler = webpack(config);</p><p class="source-code">  app.use(devMiddleware(compiler));</p><p class="source-code">  app.use(hotMiddleware(compiler));</p><p class="source-code">}</p></li>
				<li>After loading <a id="_idIndexMarker732"/>these packages, we will also require webpack, as we will parse a new webpack configuration file. The new configuration file is only used for the SSR.</li>
				<li>After both webpack and the configuration file have been loaded, we will use the <strong class="source-inline">webpack(config)</strong> command to parse the configuration and create a new webpack instance.</li>
				<li>Next, we are going to create the webpack configuration file. To do this, we pass the created webpack instance to our two new modules. When a request reaches the server, the two packages take action according to the configuration file.</li>
			</ol>
			<p>The new configuration file has only a few small differences as compared to the original configuration file, but these have a big impact. Create the new <strong class="source-inline">webpack.server.config.js</strong> file, and <a id="_idIndexMarker733"/>enter the following configuration:</p>
			<p class="source-code">const path = require('path');</p>
			<p class="source-code">const webpack = require('webpack');</p>
			<p class="source-code">const buildDirectory = 'dist';</p>
			<p class="source-code">module.exports = {</p>
			<p class="source-code">  mode: 'development',</p>
			<p class="source-code">  entry: [</p>
			<p class="source-code">    'webpack-hot-middleware/client',</p>
			<p class="source-code">    './src/client/index.js'</p>
			<p class="source-code">  ],</p>
			<p class="source-code">  output: {</p>
			<p class="source-code">    path: path.join(__dirname, buildDirectory),</p>
			<p class="source-code">    filename: 'bundle.js',</p>
			<p class="source-code">    publicPath: '/'</p>
			<p class="source-code">  },</p>
			<p class="source-code">  module: {</p>
			<p class="source-code">    rules: [</p>
			<p class="source-code">      {</p>
			<p class="source-code">        test: /\.js$/,</p>
			<p class="source-code">        exclude: /node_modules/,</p>
			<p class="source-code">        use: {</p>
			<p class="source-code">          loader: 'babel-loader',</p>
			<p class="source-code">        },</p>
			<p class="source-code">      },</p>
			<p class="source-code">      {</p>
			<p class="source-code">        test: /\.css$/,</p>
			<p class="source-code">        use: ['style-loader', 'css-loader'],</p>
			<p class="source-code">      },</p>
			<p class="source-code">      {</p>
			<p class="source-code">        test: /\.(png|woff|woff2|eot|ttf|svg)$/,</p>
			<p class="source-code">        loader: 'url-loader?limit=100000',</p>
			<p class="source-code">      </p>
			<p class="source-code">      },</p>
			<p class="source-code">    ],</p>
			<p class="source-code">  },</p>
			<p class="source-code">  plugins: [</p>
			<p class="source-code">    new webpack.HotModuleReplacementPlugin(),</p>
			<p class="source-code">    new webpack.NamedModulesPlugin(),</p>
			<p class="source-code">  ],</p>
			<p class="source-code">};</p>
			<p>We have made three changes in the preceding configuration in comparison to the original <strong class="source-inline">webpack.client.config.js</strong> file, and these are as follows:</p>
			<ul>
				<li>In the <strong class="source-inline">entry</strong> property, we now have multiple entry points. The <strong class="source-inline">index</strong> file for the frontend code, as before, is one entry point. The second one is the new <strong class="source-inline">webpack-hot-middleware</strong> module, which initiates the connection between the <a id="_idIndexMarker734"/>client and the server. The connection is used to send the client notifications to update the bundle to a newer version.</li>
				<li>I removed the <strong class="source-inline">devServer</strong> field, as this configuration does not require webpack to start its own server. Express.js is the web server, which we are already using when loading the configuration.</li>
				<li>The plugins are entirely different from those of the client's webpack configuration. We do not need <strong class="source-inline">CleanWebpackPlugin</strong>, as this cleans the <strong class="source-inline">dist</strong> folder, nor the <strong class="source-inline">HtmlWebpackPlugin</strong> plugin, which inserts the <a id="_idIndexMarker735"/>webpack bundles into the <strong class="source-inline">index.html</strong> file; this is handled by the server differently. These plugins are only useful for client-side development. Now, we have <strong class="source-inline">HotModuleReplacementPlugin</strong> , which enables <strong class="bold">Hot Module Replacement</strong> (<strong class="bold">HMR</strong>). It allows for JavaScript and CSS to be exchanged <a id="_idIndexMarker736"/>on the fly. Next, <strong class="source-inline">NamedModulesPlugin</strong> displays the relative paths for modules injected by HMR. Both plugins are only recommended for use in development.</li>
			</ul>
			<p>The webpack preparation is now finished.</p>
			<p>Now, we have to focus on how to render React code and how to serve the generated HTML. However, we cannot use the existing React code that we have written. First, there are specific adjustments that we have to make to the main files: <strong class="source-inline">index.js</strong>, <strong class="source-inline">App.js</strong>, <strong class="source-inline">router.js</strong>, and <strong class="source-inline">apollo/index.js</strong>. Many packages that we use, such as <strong class="bold">React Router</strong> or Apollo Client, have default settings or modules that we have to <a id="_idIndexMarker737"/>configure differently when they are executed on the server.</p>
			<p>We will begin with the root of our React application, which is the <strong class="source-inline">index.js</strong> file. We are going to implement an individual SSR <strong class="source-inline">index</strong> file, as there are server-specific adjustments to do.</p>
			<p>Create a new folder called <strong class="source-inline">ssr</strong> inside the <strong class="source-inline">server</strong> folder. Then, insert the following code into an <strong class="source-inline">index.js</strong> file inside the <strong class="source-inline">ssr</strong> folder:</p>
			<p class="source-code">import React from 'react';</p>
			<p class="source-code">import { ApolloProvider } from '@apollo/client';</p>
			<p class="source-code">import App from './app';</p>
			<p class="source-code">const ServerClient = ({ client, location, context }) =&gt; {</p>
			<p class="source-code">  return(</p>
			<p class="source-code">    &lt;ApolloProvider client={client}&gt;</p>
			<p class="source-code">      &lt;App location={location} context={context}/&gt;</p>
			<p class="source-code">    &lt;/ApolloProvider&gt;</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p class="source-code">export default ServerClient</p>
			<p>The preceding code is a modified version of our client <strong class="source-inline">index.js</strong> root file. The changes that the file has gone through are listed as follows:</p>
			<ul>
				<li>Instead of using the <strong class="source-inline">ReactDOM.render</strong> function to insert the HTML into the DOMNode with the <strong class="source-inline">root</strong> ID, we are now exporting a React component. The returned <a id="_idIndexMarker738"/>component is called <strong class="source-inline">ServerClient</strong>. There is no DOM that we can access to let <strong class="source-inline">ReactDOM</strong> render anything, so we skip this step when rendering on the server.</li>
				<li>The <strong class="source-inline">ApolloProvider</strong> component now receives Apollo Client directly from the <strong class="source-inline">ServerClient</strong> properties, whereas we previously set up Apollo Client directly inside this file by importing the <strong class="source-inline">index.js</strong> file from the <strong class="source-inline">apollo</strong> folder and passing it to the provider. You will soon see why we are doing this.</li>
				<li>The last change we made was to extract a <strong class="source-inline">location</strong> and a <strong class="source-inline">context</strong> property. We pass these properties to the <strong class="source-inline">App</strong> component. In the original version, there were no properties passed to the <strong class="source-inline">App</strong> component. Both properties are required in order to configure React Router to work with SSR. We are going to implement the properties later in the chapter.</li>
			</ul>
			<p>Before looking at why we made these changes in more detail, let's create the new <strong class="source-inline">App</strong> component for the backend. Create an <strong class="source-inline">app.js</strong> file next to the <strong class="source-inline">index.js</strong> file in the <strong class="source-inline">ssr</strong> folder, and insert the following code:</p>
			<p class="source-code">import React, { useState } from 'react';</p>
			<p class="source-code">import { Helmet } from 'react-helmet';</p>
			<p class="source-code">import { withApollo } from '@apollo/client/react/hoc';</p>
			<p class="source-code">import Router from '../../client/router';</p>
			<p class="source-code">import { useCurrentUserQuery } from '../../client/apollo/queries/currentUserQuery';</p>
			<p class="source-code">import '../../client/components/fontawesome';</p>
			<p class="source-code">const App = ({ location, context }) =&gt; {</p>
			<p class="source-code">  const { data, loading, error } = useCurrentUserQuery();</p>
			<p class="source-code">  const [loggedIn, setLoggedIn] = useState(false);</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;div className="container"&gt;</p>
			<p class="source-code">      &lt;Helmet&gt;</p>
			<p class="source-code">        &lt;title&gt;Graphbook - Feed&lt;/title&gt;</p>
			<p class="source-code">        &lt;meta name="description" content="Newsfeed of all </p>
			<p class="source-code">          your friends on Graphbook" /&gt;</p>
			<p class="source-code">      &lt;/Helmet&gt;</p>
			<p class="source-code">      &lt;Router loggedIn={loggedIn}</p>
			<p class="source-code">        changeLoginState={setLoggedIn} location={location}</p>
			<p class="source-code">          context={context} /&gt;</p>
			<p class="source-code">    &lt;/div&gt;</p>
			<p class="source-code">  )</p>
			<p class="source-code">}</p>
			<p class="source-code">export default withApollo(App)</p>
			<p>The following are a few changes that we made:</p>
			<ul>
				<li>The first change, in comparison to the original client-side <strong class="source-inline">App</strong> component, was to adjust the <strong class="source-inline">import</strong> statements to load the router and the <strong class="source-inline">fontawesome</strong> component from the <strong class="source-inline">client</strong> folder, as they do not exist in the <strong class="source-inline">server</strong> folder.</li>
				<li>The second change was to remove the <strong class="source-inline">useEffect</strong> Hooks and the <strong class="source-inline">localStorage</strong> access. We did this because the authentication that we built uses the <strong class="source-inline">localStorage</strong> access. This is fine for client-side authentication. Neither <strong class="bold">Node.js</strong> nor the server supports such storage, in general. Also, the <strong class="source-inline">useEffect</strong> Hook is only <a id="_idIndexMarker739"/>called on the client side. This is why we remove <a id="_idIndexMarker740"/>the authentication when moving our application to SSR. We are going to replace the <strong class="source-inline">localStorage</strong> implementation with cookies in a later step. For the moment, the user stays logged out of the server.</li>
				<li>The last change involves passing the two new properties, <strong class="source-inline">context</strong>  and <strong class="source-inline">location</strong>, to the <strong class="source-inline">Router</strong> component in the preceding code.</li>
			</ul>
			<p>React Router provides instant support for SSR. Nevertheless, we need to make some adjustments. The best way is that we use the same router for the backend and frontend, so we do not need to define routes twice, which is inefficient and can lead to problems. Open the <strong class="source-inline">router.js</strong> file inside the <strong class="source-inline">client</strong> folder and follow these steps:</p>
			<ol>
				<li value="1">Change the <strong class="source-inline">import</strong> statement for the <strong class="source-inline">react-router-dom</strong> package to look like the following:<p class="source-code">import { BrowserRouter, StaticRouter, Route, Redirect, Switch } from 'react-router-dom';</p></li>
				<li>Insert the following code to extract the correct router:<p class="source-code">let Router;</p><p class="source-code">if(typeof window !== typeof undefined) {</p><p class="source-code">  Router = BrowserRouter;</p><p class="source-code">}</p><p class="source-code">else {</p><p class="source-code">  Router = StaticRouter;</p><p class="source-code">}</p><p>After importing the React Router package, we check whether the file is executed on the server or the client by looking for the <strong class="source-inline">window</strong> object. Since there is no <strong class="source-inline">window</strong> object in Node.js, this is a sufficient check. An alternative approach would be to set up the <strong class="source-inline">Switch</strong> component, including the routes, in a separate file. This <a id="_idIndexMarker741"/>approach would allow us to import the routes directly into the correct router if we create two separate router files for client-side and server-side rendering.</p><p>If we are on the client side, we use <strong class="source-inline">BrowserRouter</strong>, and if not, we use <strong class="source-inline">StaticRouter</strong>. Here, the logic is that with <strong class="source-inline">StaticRouter</strong>, we are in a stateless environment, where we render all routes with a fixed location. The <strong class="source-inline">StaticRouter</strong> component does not allow for the location to be changed by redirects because no user interaction can happen when using SSR. The other components, <strong class="source-inline">Route</strong>, <strong class="source-inline">Redirect</strong>, and <strong class="source-inline">Switch</strong>, can be used as before.</p><p>Regardless of which routers are extracted, we save them in the <strong class="source-inline">Router</strong> variable. We then use them in the return statement of the <strong class="source-inline">routing</strong> component.</p></li>
				<li>We prepared the <strong class="source-inline">context</strong> and <strong class="source-inline">location</strong> properties, which are passed from the top <strong class="source-inline">ServerClient</strong> component to the <strong class="source-inline">Router</strong> variable. If we are on the server, these properties should be filled, because the <strong class="source-inline">StaticRouter</strong> object requires them. You can replace the <strong class="source-inline">Router</strong> tag in the bottom <strong class="source-inline">Routing</strong> component, as follows:<p class="source-code">&lt;Router context={this.props.context} location={this.props.location}&gt;</p><p>The <strong class="source-inline">location</strong> object holds the path that the router should render. The <strong class="source-inline">context</strong> variable stores all of the information the <strong class="source-inline">Router</strong> component processes, such as redirects. We can inspect this variable after rendering the <strong class="source-inline">Router</strong> component to trigger the redirects manually. This behavior is the big <a id="_idIndexMarker742"/>difference between <strong class="source-inline">BrowserRouter</strong> and <strong class="source-inline">StaticRouter</strong>. In the first case, <strong class="source-inline">BrowserRouter</strong> redirects the user automatically, but <strong class="source-inline">StaticRouter</strong> does not.</p></li>
			</ol>
			<p>The crucial components to render our React code successfully have now been prepared. However, there are still some modules that we have to initialize before rendering anything with React. Open the <strong class="source-inline">index.js</strong> server file again. At the moment, we are serving the <strong class="source-inline">dist</strong> path statically on the root/path for <strong class="bold">client-side rendering</strong> (<strong class="bold">CSR</strong>), which <a id="_idIndexMarker743"/>can be found at <strong class="source-inline">http://localhost:8000</strong>. When moving to SSR, we have to serve the HTML generated by our React application at the <strong class="source-inline">/</strong> path instead.</p>
			<p>Furthermore, any other path, such as <strong class="source-inline">/app</strong>, should also use SSR to render those paths on the server. Remove the current <strong class="source-inline">app.get</strong> method at the bottom of the file, which is right before the <strong class="source-inline">app.listen</strong> method. Then, insert the following code as a replacement:</p>
			<p class="source-code">app.use('/', express.static(path.join(root, 'dist/client'), { index: false }));</p>
			<p class="source-code">app.get('*', (req, res) =&gt; {</p>
			<p class="source-code">  res.status(200);</p>
			<p class="source-code">  res.send('&lt;!doctype html&gt;');</p>
			<p class="source-code">  res.end();</p>
			<p class="source-code">});</p>
			<p>The first line of the code should replace the old static route. It introduces a new option called <strong class="source-inline">index</strong>, which will disable serving the <strong class="source-inline">index.html</strong> file at the root path.</p>
			<p>The asterisk (<strong class="source-inline">*</strong>) that we are using in the preceding code can overwrite any path that is defined later in the Express.js routing. Always remember that the <strong class="source-inline">services</strong> routine that we use in Express.js can implement new paths, such as <strong class="source-inline">/graphql</strong>, that we do not want to overwrite. To avoid this, put the code at the bottom of the file, below the <strong class="source-inline">services</strong> setup. The route catches any requests sent to the backend.</p>
			<p>You can try out this route by running the <strong class="source-inline">npm run server</strong> command. Just visit <strong class="source-inline">http://localhost:8000</strong> to do this.</p>
			<p>Currently, the preceding catch-all route only returns an empty site, with a status of <strong class="source-inline">200</strong>. Let's change this. The logical step would be to load and render the <strong class="source-inline">ServerClient</strong> component from the <strong class="source-inline">index.js</strong> file of the <strong class="source-inline">ssr</strong> folder, as it is the starting <a id="_idIndexMarker744"/>point of the React SSR code. The <strong class="source-inline">ServerClient</strong> component, however, requires an initialized Apollo Client instance, as we explained before. We are going to create a special Apollo Client instance for SSR next.</p>
			<p>Create a <strong class="source-inline">ssr/apollo.js</strong> file, as it does not exist yet. We will set up Apollo Client in this file. The content is nearly the same as the original setup for the client:</p>
			<p class="source-code">import { ApolloClient } from 'apollo-client';</p>
			<p class="source-code">import { InMemoryCache } from 'apollo-cache-inmemory';</p>
			<p class="source-code">import { onError } from 'apollo-link-error';</p>
			<p class="source-code">import { ApolloLink } from 'apollo-link';</p>
			<p class="source-code">import { HttpLink } from 'apollo-link-http';</p>
			<p class="source-code">import fetch from 'node-fetch';</p>
			<p class="source-code">export default (req) =&gt; {</p>
			<p class="source-code">  const AuthLink = (operation, next) =&gt; {</p>
			<p class="source-code">    return next(operation);</p>
			<p class="source-code">  };</p>
			<p class="source-code">  const client = new ApolloClient({</p>
			<p class="source-code">    ssrMode: true,</p>
			<p class="source-code">    link: ApolloLink.from([</p>
			<p class="source-code">      onError(({ graphQLErrors, networkError }) =&gt; {</p>
			<p class="source-code">        if (graphQLErrors) {</p>
			<p class="source-code">          graphQLErrors.map(({ message, locations, path,</p>
			<p class="source-code">            extensions }) =&gt; {</p>
			<p class="source-code">            console.log('[GraphQL error]: Message:</p>
			<p class="source-code">              ${message}, </p>
			<p class="source-code">                Location: ${locations}, Path: ${path}');</p>
			<p class="source-code">          });</p>
			<p class="source-code">          if (networkError) {</p>
			<p class="source-code">            console.log('[Network error]:</p>
			<p class="source-code">              ${networkError}');</p>
			<p class="source-code">          }</p>
			<p class="source-code">        }</p>
			<p class="source-code">      }), </p>
			<p class="source-code">      AuthLink,</p>
			<p class="source-code">      new HttpLink({</p>
			<p class="source-code">        uri: 'http://localhost:8000/graphql',</p>
			<p class="source-code">        credentials: 'same-origin',</p>
			<p class="source-code">        fetch</p>
			<p class="source-code">      })</p>
			<p class="source-code">    ]),</p>
			<p class="source-code">    cache: new InMemoryCache(),</p>
			<p class="source-code">  });</p>
			<p class="source-code">  return client;</p>
			<p class="source-code">};</p>
			<p>However, there are a few changes that we made to get the client working on the server. These changes were pretty big, so we created a separate file for the server-side Apollo Client <a id="_idIndexMarker745"/>setup. Take a look at the changes (as follows) to understand the differences between the frontend and the SSR setup for Apollo Client:</p>
			<ul>
				<li>Instead of using the <strong class="source-inline">createUploadLink</strong> function that we introduced to allow the user to upload images or other files, we are now using the standard <strong class="source-inline">HttpLink</strong> class again. You could use the <strong class="source-inline">UploadClient</strong> function, but the functionalities it provides won't be used on the server, as the server won't upload files.</li>
				<li>The <strong class="source-inline">AuthLink</strong> function skips to the next link, as we have not implemented server-side authentication yet.</li>
				<li>The <strong class="source-inline">HttpLink</strong> object receives the <strong class="source-inline">fetch</strong> property, which is filled by the <strong class="source-inline">node-fetch</strong> package that we installed at the beginning of the chapter. This is used instead of the <strong class="source-inline">window.fetch</strong> method, which is not available in Node.js.</li>
				<li>Rather than exporting the <strong class="source-inline">client</strong> object directly, we export a wrapping function that accepts a <strong class="source-inline">request</strong> object. We pass it as a parameter in the Express.js route. As you can see in the preceding code example, we haven't used the object yet, but that will change soon.</li>
			</ul>
			<p>Import the <strong class="source-inline">ApolloClient</strong> component at the top of the server <strong class="source-inline">index.js</strong> file, as follows:</p>
			<p class="source-code">import ApolloClient from './ssr/apollo';</p>
			<p>The imported <strong class="source-inline">ApolloClient</strong> function accepts the <strong class="source-inline">request</strong> object of our Express.js server.</p>
			<p>Add the following line to the top of the new Express.js catch-all route:</p>
			<p class="source-code">const client = ApolloClient(req);</p>
			<p>This way, we set up a new <strong class="source-inline">client</strong> instance that we can hand over to our <strong class="source-inline">ServerClient</strong> component.</p>
			<p>We can continue and implement the rendering of our <strong class="source-inline">ServerClient</strong> component. To make the future code work, we have to load React and, of course, the <strong class="source-inline">ServerClient</strong> component itself:</p>
			<p class="source-code">import React from 'react';</p>
			<p class="source-code">import Graphbook from './ssr/';</p>
			<p>The <strong class="source-inline">ServerClient</strong> component is imported under the <strong class="source-inline">Graphbook</strong> name. We import React because we <a id="_idIndexMarker746"/>use the standard <strong class="bold">JSX</strong> syntax when rendering our React code.</p>
			<p>Now that <a id="_idIndexMarker747"/>we have access to Apollo Client and the <strong class="source-inline">ServerClient</strong> component, insert the following two lines below the <strong class="source-inline">ApolloClient</strong> setup in the Express.js route:</p>
			<p class="source-code">const context= {};</p>
			<p class="source-code">const App = (&lt;Graphbook client={client} location={req.url}</p>
			<p class="source-code">  context= {context}/&gt;);</p>
			<p>We pass the initialized <strong class="source-inline">client</strong> variable to the <strong class="source-inline">Graphbook</strong> component. We use the regular React syntax to pass all properties. Furthermore, we set the <strong class="source-inline">location</strong> property to the request object's <strong class="source-inline">url</strong> object, to tell the router which path to render. The <strong class="source-inline">context</strong> property is passed as an empty object.</p>
			<p>However, why do we pass an empty object as <strong class="source-inline">context</strong> to the router at the end?</p>
			<p>The reason is that after rendering the <strong class="source-inline">Graphbook</strong> component to HTML, we can access the <strong class="source-inline">context</strong> object and see whether a redirect (or something else) would have been triggered regularly. As we mentioned before, redirects have to be implemented by the backend code. The <strong class="source-inline">StaticRouter</strong> component of React Router does not make assumptions about the Node.js web server that you are using. That is why <strong class="source-inline">StaticRouter</strong> does not execute them automatically. Tracking and post-processing these events is possible with the <strong class="source-inline">context</strong> variable.</p>
			<p>The resulting React object is saved to a new variable, which is called <strong class="source-inline">App</strong>. Now, there should be no errors if you start the server with <strong class="source-inline">npm run server</strong> and visit <strong class="source-inline">http://localhost:8000</strong>. Still, we see an empty page. That happens because we only return an empty HTML page; we haven't rendered the React <strong class="source-inline">App</strong> object to HTML. To render the object to HTML, import the following package at the top of the server <strong class="source-inline">index.js</strong> file:</p>
			<p class="source-code">import ReactDOM from 'react-dom/server';</p>
			<p>The <strong class="source-inline">react-dom</strong> package not only provides bindings for the browser but also provides a special module for the server, which is why we use the <strong class="source-inline">/server</strong> suffix when importing it. The returned module provides a number of server-only functions.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To learn some more advanced features of SSR and the dynamics behind it, you should read up on the official <a id="_idIndexMarker748"/>documentation of the server package of <strong class="source-inline">react-dom</strong> at <a href="https://reactjs.org/docs/react-dom-server.html">https://reactjs.org/docs/react-dom-server.html</a>.</p>
			<p>We can translate the React <strong class="source-inline">App</strong> object into HTML by using the <strong class="source-inline">ReactDOM.rendertoString</strong> function. Insert the following line of code beneath the <strong class="source-inline">App</strong> object:</p>
			<p class="source-code">const content = ReactDOM.renderToString(App);</p>
			<p>This function generates HTML and stores it inside the <strong class="source-inline">content</strong> variable. The HTML can be <a id="_idIndexMarker749"/>returned to the client now. If you return pre-rendered HTML from the server, the client goes through it and checks whether its current state would match the returned HTML. The comparison is made by identifying certain points in the HTML, such as the <strong class="source-inline">data-reactroot</strong> property.</p>
			<p>If, at any point, the markup between the server-rendered HTML and that which the client would generate does not match, an error is thrown. The application will still work, but the client will not be able to make use of SSR; the client will replace the complete markup returned from the server by rendering everything again. In this case, the server's HTML response is thrown away. This is, of course, very inefficient and not what we are aiming for. </p>
			<p>We have to return the rendered HTML to the client. The HTML that we have rendered begins with the root <strong class="source-inline">div</strong> tag and not the <strong class="source-inline">html</strong> tag. We must wrap the <strong class="source-inline">content</strong> variable inside a template that includes the surrounding HTML tags. So, create a <strong class="source-inline">template.js</strong> file inside the <strong class="source-inline">ssr</strong> folder, and enter the following code to implement <a id="_idIndexMarker750"/>the template for our rendered HTML:</p>
			<p class="source-code">import React from 'react';</p>
			<p class="source-code">import ReactDOM from 'react-dom/server';</p>
			<p class="source-code">const htmlTemplate = (content) =&gt; {</p>
			<p class="source-code">  return '</p>
			<p class="source-code">    &lt;html lang="en"&gt;</p>
			<p class="source-code">      &lt;head&gt;</p>
			<p class="source-code">        &lt;meta charSet="UTF-8"/&gt;</p>
			<p class="source-code">        &lt;meta name="viewport" content="width=device-width, </p>
			<p class="source-code">          initial-scale=1.0"/&gt;</p>
			<p class="source-code">        &lt;meta httpEquiv="X-UA-Compatible"</p>
			<p class="source-code">          content="ie=edge"/&gt;</p>
			<p class="source-code">        &lt;link rel="shortcut icon" </p>
			<p class="source-code">          href="data:image/x-icon;," type="image/x-icon"&gt; </p>
			<p class="source-code">        ${(process.env.NODE_ENV === 'development')? "":</p>
			<p class="source-code">          "&lt;link rel='stylesheet' href='/bundle.css'/&gt;"}</p>
			<p class="source-code">      &lt;/head&gt;</p>
			<p class="source-code">      &lt;body&gt;</p>
			<p class="source-code">        ${ReactDOM.renderToStaticMarkup(&lt;div id="root" </p>
			<p class="source-code">          dangerouslySetInnerHTML={{ __html: content </p>
			<p class="source-code">            }}&gt;&lt;/div&gt;)}</p>
			<p class="source-code">        &lt;script src="/bundle.js"&gt;&lt;/script&gt;</p>
			<p class="source-code">      &lt;/body&gt;</p>
			<p class="source-code">    &lt;/html&gt;</p>
			<p class="source-code">  ';</p>
			<p class="source-code">};</p>
			<p class="source-code">export default htmlTemplate;</p>
			<p>The preceding code is pretty much the same HTML markup as that in the <strong class="source-inline">index.html</strong> file that we usually serve to the client. The difference is that here, we use React and <strong class="source-inline">ReactDOM</strong> .</p>
			<p>First, we export a function, which accepts the <strong class="source-inline">content</strong> variable with the rendered HTML.</p>
			<p>Then, we render a <strong class="source-inline">link</strong> tag inside the <strong class="source-inline">head</strong> tag, which downloads the CSS bundle if we are <a id="_idIndexMarker751"/>in a production environment. For our current development scenario, there is no bundled CSS.</p>
			<p>The important part is that we use a new <strong class="source-inline">ReactDOM</strong> function called <strong class="source-inline">rendertoStaticMarkup</strong> inside the <strong class="source-inline">body</strong> tag. This function inserts the React <strong class="source-inline">root</strong> tag into the body of our HTML template. Before, we used the <strong class="source-inline">renderToString</strong> method, which included special React tags, such as the <strong class="source-inline">data-reactroot</strong> property. Now, we use the <strong class="source-inline">rendertoStaticMarkup</strong> function to generate standard HTML without special React tags. The only parameter that we pass to the function is the <strong class="source-inline">div</strong> tag with the <strong class="source-inline">root</strong> ID and a new property, <strong class="source-inline">dangerouslySetInnerHTML</strong>. This attribute is a replacement for the regular <strong class="source-inline">innerHTML</strong> attribute, but for use in React. It lets React insert the HTML inside the root <strong class="source-inline">div</strong> tag. As the name suggests, it is dangerous to do this, but only if it is done on the client, as there is no possibility for <strong class="bold">cross-site scripting</strong> (<strong class="bold">XSS</strong>) attacks on the server. We use <a id="_idIndexMarker752"/>the <strong class="source-inline">ReactDOM.renderToStaticMarkup</strong> function to make use of the attribute. The inserted HTML was initially rendered with the <strong class="source-inline">renderToString</strong> function so that it would include all of the critical React HTML attributes and the wrapping <strong class="source-inline">div</strong> tag with the <strong class="source-inline">root</strong> ID. It can then be reused in the browser by the frontend code without any problems.</p>
			<p>We require this <strong class="source-inline">template.js</strong> file in the server <strong class="source-inline">index</strong> file, at the top of the file:</p>
			<p class="source-code">import template from './ssr/template';</p>
			<p>The template function can now be used directly in the <strong class="source-inline">res.send</strong> method, as follows:</p>
			<p class="source-code">res.send('&lt;!doctype html&gt;\n${template(content)}');</p>
			<p>We do not only return a <strong class="source-inline">doctype</strong> object anymore; we also respond with the return value of the <strong class="source-inline">template</strong> function. As you should see, the <strong class="source-inline">template</strong> function accepts the rendered <strong class="source-inline">content</strong> variable as a parameter and composes it to a valid HTML document.</p>
			<p>At this point, we have managed to get our first version of a server-side-rendered React application working. You can prove this by right-clicking in your browser window and choosing <a id="_idIndexMarker753"/>to view the source code. The window shows you the original HTML that is returned by the server. The output equals the HTML from the <strong class="source-inline">template</strong> function, including the login and signup forms. </p>
			<p>Nevertheless, there are two problems that we face:</p>
			<ul>
				<li>There is no description meta <strong class="source-inline">head</strong> tag included in the server response. Something must have gone wrong with React <strong class="source-inline">Helmet</strong>.</li>
				<li>When logged in on the client side and, for example, viewing the news feed under the <strong class="source-inline">/app</strong> path, the server responds without having rendered the news feed or the login form. Normally, React Router would have redirected us to the login form since we are not logged in on the server side. However, since we use <strong class="source-inline">StaticRouter</strong>, we have to initiate the redirect separately, as we explained before. We are going to implement the authentication in a separate step.</li>
			</ul>
			<p>We will start with the first issue. To fix the problem with React <strong class="source-inline">Helmet</strong>, import it at the top of the server <strong class="source-inline">index.js</strong> file, as follows:</p>
			<p class="source-code">import { Helmet } from 'react-helmet';</p>
			<p>Now, before setting the response status with <strong class="source-inline">res.status</strong>, you can extract the React <strong class="source-inline">Helmet</strong> status, as follows:</p>
			<p class="source-code">const head = Helmet.renderStatic();</p>
			<p>The <strong class="source-inline">renderStatic</strong> method is specially made for SSR. We can use it after having rendered the React application with the <strong class="source-inline">renderToString</strong> function. It gives us all of the <strong class="source-inline">head</strong> tags that would have been inserted throughout our code. Pass this <strong class="source-inline">head</strong> variable to the <strong class="source-inline">template</strong> function as a second parameter, as follows:</p>
			<p class="source-code">res.send('&lt;!doctype html&gt;\n${template(content, head)}');</p>
			<p>Go back to the <strong class="source-inline">template.js</strong> file from the <strong class="source-inline">ssr</strong> folder. Add the <strong class="source-inline">head</strong> parameter to the exported function's signature. Then, add the following two new lines of code to the HTML's <strong class="source-inline">head</strong> tag:</p>
			<p class="source-code">${head.title.toString()}</p>
			<p class="source-code">${head.meta.toString()}</p>
			<p>The <strong class="source-inline">head</strong> variable extracted from React <strong class="source-inline">Helmet</strong> holds a property for each <strong class="source-inline">meta</strong> tag. These tags provide a <strong class="source-inline">toString</strong> function that returns a valid HTML tag, which you can directly <a id="_idIndexMarker754"/>enter into the document's <strong class="source-inline">head</strong> object. The first problem should be fixed: all <strong class="source-inline">head</strong> tags are now inside the server's HTML response.</p>
			<p>Let's focus on the second problem. The server response returns an empty React <strong class="source-inline">root</strong> tag when visiting a <strong class="source-inline">PrivateRoute</strong> component. As we explained previously, the reason for this is that the naturally initiated redirect does not get through to us, as we are using <strong class="source-inline">StaticRouter</strong>. We are redirected away from the <strong class="source-inline">PrivateRoute</strong> component because the authentication is not implemented for the server-side-rendered code. The first thing to fix is to handle the redirect, and we should also at least respond with the login form, instead of an empty React <strong class="source-inline">root</strong> tag. Later, we need to fix the authentication problem.</p>
			<p>You would not notice this problem without viewing the source code of the server's response. The frontend downloads the <strong class="source-inline">bundle.js</strong> file and triggers the rendering on its own, as it knows about the authentication status of the user. The user would not notice that. Still, it is more efficient if the server sends the correct HTML directly. The HTML will be wrong if the user is logged in, but in the case of an unauthenticated user, the login form is pre-rendered by the server as it initiates the redirects.</p>
			<p>To fix this issue, we can access the <strong class="source-inline">context</strong> object that has been filled by React Router after it has used the <strong class="source-inline">renderToString</strong> function. The final Express.js route should look like the following code example:</p>
			<p class="source-code">app.get('*', (req, res) =&gt; {</p>
			<p class="source-code">  const client = ApolloClient(req);</p>
			<p class="source-code">  const context= {};</p>
			<p class="source-code">  const App = (&lt;Graphbook client={client} </p>
			<p class="source-code">    location={req.url} context= {context}/&gt;);</p>
			<p class="source-code">  const content = ReactDOM.renderToString(App);</p>
			<p class="source-code">  if (context.url) {</p>
			<p class="source-code">    res.redirect(301, context.url);</p>
			<p class="source-code">  } else {</p>
			<p class="source-code">    const head = Helmet.renderStatic();</p>
			<p class="source-code">    res.status(200);</p>
			<p class="source-code">    res.send('&lt;!doctype html&gt;\n${template(content, </p>
			<p class="source-code">      head)}');</p>
			<p class="source-code">    res.end();</p>
			<p class="source-code">  }</p>
			<p class="source-code">});</p>
			<p>The condition for rendering the correct route on the server is that we inspect the <strong class="source-inline">context.url</strong> property. If it is filled, we can initiate a redirect with Express.js. This will navigate the <a id="_idIndexMarker755"/>browser to the correct path. If the property is not filled, we can return the HTML generated by React.</p>
			<p>This route renders the React code correctly up to the point at which authentication is required. The SSR route correctly renders all public routes, but none of the secure routes. That means that we only respond with the login form at the moment, as it is the only route that doesn't require authentication.</p>
			<p>The next step is to implement authentication in connection with SSR to fix this huge issue.</p>
			<h1 id="_idParaDest-157"><a id="_idTextAnchor180"/>Authentication with SSR</h1>
			<p>You should have noticed that we have removed most of the authentication logic from the server-side React code. The reason for this is that <strong class="source-inline">localStorage</strong> cannot be transmitted to the <a id="_idIndexMarker756"/>server on the initial loading of a page, which is the only case <a id="_idIndexMarker757"/>where SSR can be used at all. This leads to the problem that we cannot render the correct route because we cannot verify whether a user is logged in. The authentication has to be transitioned to cookies, which are sent with every request.</p>
			<p>It is important to understand that cookies also introduce some security issues. We will continue to use the regular HTTP authorization header for the GraphQL API that we have written. If we <a id="_idIndexMarker758"/>use cookies for the GraphQL API, we will expose our application to potential <strong class="bold">cross-site request forgery</strong> (<strong class="bold">CSRF</strong>) attacks. The frontend code continues to send all GraphQL requests with the HTTP authorization header.</p>
			<p>We will only use the cookies to verify the authentication status of a user and to initiate requests to our GraphQL API for the SSR of the React code. The SSR GraphQL requests will include the authorization cookie's value in the HTTP authorization header. Our GraphQL API only reads and verifies this header and does not accept cookies. As long as you do not mutate data when loading a page and only query for the data to render, there will be no security issues.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">As the topic of CSRF and XSS is important, I recommend that you read up on it in order to fully understand how <a id="_idIndexMarker759"/>to protect yourself and your users. You can find a great article at <a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)">https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)</a>.</p>
			<p>So, just follow these instructions to get authentcation on SSR running:</p>
			<ol>
				<li value="1">The first thing to do is install a new package with <strong class="source-inline">npm</strong>, as follows:<p class="source-code"><strong class="bold">npm install --save cookies</strong></p><p>The <strong class="source-inline">cookies</strong> package allows us to easily interact through the Express.js <strong class="source-inline">request</strong> object with the cookies sent by the browser. Instead of manually parsing and reading through the cookie string (which is just a comma-separated list), you can access the cookies with simple <strong class="source-inline">get</strong> and <strong class="source-inline">set</strong> methods. To get this package working, you have to initialize it inside Express.js.</p></li>
				<li>Import the <strong class="source-inline">cookies</strong> and <strong class="source-inline">jwt</strong> packages, and also extract the <strong class="source-inline">JWT_SECRET</strong> string from the environment variables at the top of the server <strong class="source-inline">index.js</strong> file:<p class="source-code">import Cookies from 'cookies';</p><p class="source-code">import JWT from 'jsonwebtoken';</p><p class="source-code">const { JWT_SECRET } = process.env;</p><p>To use the <strong class="source-inline">cookies</strong> package, we are going to set up a new middleware route.</p></li>
				<li>Insert the <a id="_idIndexMarker760"/>following code before initializing the webpack <a id="_idIndexMarker761"/>modules and the services routine:<p class="source-code">app.use(</p><p class="source-code">  (req, res, next) =&gt; {</p><p class="source-code">    const options = { keys: ['Some random keys'] }; </p><p class="source-code">    req.cookies = new Cookies(req, res, options); </p><p class="source-code">    next();</p><p class="source-code">  }</p><p class="source-code">);</p><p>This new Express.js middleware initializes the <strong class="source-inline">cookies</strong> package under the <strong class="source-inline">req.cookies</strong> property for every request that it processes. The first parameter of the <strong class="source-inline">Cookies</strong> constructor is the request, the second is the response object, and the last is an <strong class="source-inline">options</strong> parameter. This takes an array of <strong class="source-inline">keys</strong> with which the cookies are signed. The keys are required if you want to sign your cookies for security reasons. You should take care of this in a production environment. You can also specify a <strong class="source-inline">secure</strong> property, which ensures that the cookies are only transmitted on secure HTTPS connections.</p></li>
				<li>We can now extract the <strong class="source-inline">authorization</strong> cookie and verify the authentication of the user. To do this, replace the beginning of the SSR route with the following code in the server's <strong class="source-inline">index.js</strong> file:<p class="source-code">app.get('*', async (req, res) =&gt; {</p><p class="source-code">  const token = req.cookies.get('authorization', </p><p class="source-code">    { signed: true });</p><p class="source-code">  var loggedIn;</p><p class="source-code">  try {</p><p class="source-code">    await JWT.verify(token, JWT_SECRET);</p><p class="source-code">    loggedIn = true;</p><p class="source-code">  } catch(e) {</p><p class="source-code">    loggedIn = false;</p><p class="source-code">  }</p><p>Here, I have <a id="_idIndexMarker762"/>added the <strong class="source-inline">async</strong> declaration to the callback function <a id="_idIndexMarker763"/>because we use the <strong class="source-inline">await</strong> statement inside it. The second step is to extract the <strong class="source-inline">authorization</strong> cookie from the request object with <strong class="source-inline">req.cookies.get</strong>. Importantly, we specify the <strong class="source-inline">signed</strong> field in the <strong class="source-inline">options</strong> parameter, because only then will it successfully return the signed cookies.</p><p>The extracted value represents the JWT that we generate when a user logs in. We can verify this with the typical approach that we implemented in <a href="B17337_06_Final_ASB_ePub.xhtml#_idTextAnchor141"><em class="italic">Chapter 6</em></a>, <em class="italic">Authentication with Apollo and React</em>. That is, we use the <strong class="source-inline">await</strong> statement when verifying the JWT. If an error is thrown, the user is not logged in. The state is saved in the <strong class="source-inline">loggedIn</strong> variable.</p></li>
				<li>Pass the <strong class="source-inline">loggedIn</strong> variable to the <strong class="source-inline">Graphbook</strong> component, as follows:<p class="source-code">const App = (&lt;Graphbook client={client} loggedIn={loggedIn} location={req.url} context={context}/&gt;);</p><p>Now, we can access the <strong class="source-inline">loggedIn</strong> property inside <strong class="source-inline">index.js</strong> from the <strong class="source-inline">ssr</strong> folder.</p></li>
				<li>Extract the <strong class="source-inline">loggedIn</strong> state from the properties, and pass it to the <strong class="source-inline">App</strong> component in the <strong class="source-inline">ssr</strong> folder's <strong class="source-inline">index.js</strong> file, as follows:<p class="source-code">&lt;App location={location} context={context} loggedIn={loggedIn}/&gt;</p><p>Inside the <strong class="source-inline">App</strong> component, we do not need to set the <strong class="source-inline">loggedIn</strong> state directly to <strong class="source-inline">false</strong>, but we <a id="_idIndexMarker764"/>can take the property's value because it is <a id="_idIndexMarker765"/>determined before the <strong class="source-inline">App</strong> component is rendered. This flow is different from the client procedure, where the <strong class="source-inline">loggedIn</strong> state is determined inside the <strong class="source-inline">App</strong> component.</p></li>
				<li>Change the <strong class="source-inline">App</strong> component in the <strong class="source-inline">app.js</strong> file in order to match the following code:<p class="source-code">const App = ({ location, context, loggedIn: loggedInProp }) =&gt; {</p><p class="source-code">  const { data, loading, error } = </p><p class="source-code">    useCurrentUserQuery();</p><p class="source-code">  const [loggedIn, setLoggedIn] = </p><p class="source-code">    useState(loggedInProp);</p><p>Here, the result is that we pass down the <strong class="source-inline">loggedIn</strong> value from our Express.js route, over the <strong class="source-inline">Graphbook</strong> and <strong class="source-inline">App</strong> components, to our <strong class="source-inline">Router</strong> component. This already accepts the <strong class="source-inline">loggedIn</strong> property in order to render the correct path for the user. At the moment, we still do not set the cookie on the backend when a user successfully logs in.</p></li>
				<li>Open the <strong class="source-inline">resolvers.js</strong> file of our GraphQL server to fix that. We will change a few lines for the <strong class="source-inline">login</strong> and <strong class="source-inline">signup</strong> functions. Both resolver functions need the same changes, as both set the authentication token after login or signup. So, insert the following code directly above the return statement:<p class="source-code">context.cookies.set(</p><p class="source-code">  'authorization',</p><p class="source-code">  token, { signed: true, expires: expirationDate, </p><p class="source-code">    httpOnly: true, secure: false, sameSite: 'strict'</p><p class="source-code">      }</p><p class="source-code">);</p><p>The preceding function <a id="_idIndexMarker766"/>sets the cookies for the user's browser. The context <a id="_idIndexMarker767"/>object is only the Express.js <strong class="source-inline">request</strong> object where we have initialized the cookies package. The properties of the <strong class="source-inline">cookies.set</strong> function are pretty self-explanatory, but let's describe them as follows:</p><p>a. The <strong class="source-inline">signed</strong> field specifies whether the keys entered during the initialization of the <strong class="source-inline">cookies</strong> object should be used to sign the cookie's value.</p><p>b. The <strong class="source-inline">expires</strong> property takes a <strong class="source-inline">date</strong> object. It represents the time until which the cookie is valid. You can set the property to whatever date you want, but I would recommend a short period, such as one day. Insert the following code above the <strong class="source-inline">context.cookies.set</strong> statement in order to initialize the <strong class="source-inline">expirationDate</strong> variable correctly:</p><p class="source-code">const cookieExpiration = 1;</p><p class="source-code">const expirationDate = new Date(); </p><p class="source-code">expirationDate.setDate(</p><p class="source-code">  expirationDate.getDate() + cookieExpiration</p><p class="source-code">);</p><p>c. The <strong class="source-inline">httpOnly</strong> field secures the cookie so that it is not accessible by client-side JavaScript.</p><p>d. The <strong class="source-inline">secure</strong> property has the same meaning as it did when initializing the <strong class="source-inline">Cookie</strong> package. It restricts cookies to SSL connections only. This is a must when going to <a id="_idIndexMarker768"/>production, but it cannot be used when developing, as most <a id="_idIndexMarker769"/>developers develop locally, without an SSL certificate.</p><p>e. The <strong class="source-inline">sameSite</strong> field takes either <strong class="source-inline">strict</strong> or <strong class="source-inline">lax</strong> as a value. I recommend setting it to <strong class="source-inline">strict</strong>, as you want your GraphQL API or server to receive the cookie with every request, but you also want to exclude all cross-site requests, as this could be dangerous.</p></li>
				<li>Now, we should clean up our code. Since we are using cookies, we can remove the <strong class="source-inline">localStorage</strong> authentication flow in the frontend code. Open the <strong class="source-inline">App.js</strong> file in the <strong class="source-inline">client</strong> folder. Remove the <strong class="source-inline">componentWillMount</strong> method, as we are reading from <strong class="source-inline">localStorage</strong> there.<p>The cookies are automatically sent with any request, and they do not need a separate binding as  <strong class="source-inline">localStorage</strong> does. That also means that we need a special <strong class="source-inline">logout</strong> mutation that removes the cookie from the browser. JavaScript is not able to access or remove the cookie because we specified it as <strong class="source-inline">httpOnly</strong>. Only the server can delete it from the client.</p></li>
				<li>Create a new <strong class="source-inline">logout.js</strong> file inside the <strong class="source-inline">mutations</strong> folder in order to create a <strong class="source-inline">logout</strong> mutation Hook. The content should look like the following:<p class="source-code">import { gql, useMutation } from '@apollo/client';</p><p class="source-code">export const LOGOUT = gql'</p><p class="source-code">  mutation logout {</p><p class="source-code">    logout {</p><p class="source-code">      success</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">';</p><p class="source-code">export const useLogoutMutation = () =&gt; useMutation(LOGOUT);</p><p>The preceding Hook only sends a simple <strong class="source-inline">logout</strong> mutation, without any parameters or further logic. </p></li>
				<li>We should use <a id="_idIndexMarker770"/>the function inside the <strong class="source-inline">logout.js</strong> file <a id="_idIndexMarker771"/>of the <strong class="source-inline">bar</strong> folder in order to send the GraphQL request. Import the component at the top of the file, as follows:<p class="source-code">import { useLogoutMutation } from '../../apollo/mutations/logout';</p></li>
				<li>Replace the <strong class="source-inline">logout</strong> method with the following code, in order to send the mutation upon clicking the <strong class="bold">Logout</strong> button:<p class="source-code">const [logoutMutation] = useLogoutMutation();</p><p class="source-code">const logout = () =&gt; {</p><p class="source-code">  logoutMutation().then(() =&gt; {</p><p class="source-code">    localStorage.removeItem('jwt');</p><p class="source-code">    changeLoginState(false);</p><p class="source-code">    client.stop();</p><p class="source-code">    client.resetStore();</p><p class="source-code">  });</p><p class="source-code">}</p><p>Here, we have wrapped the original functions inside the call to the <strong class="source-inline">logoutMutation</strong> function. This sends the GraphQL request to our server.</p></li>
				<li>To implement the mutation on the backend, add one line to the GraphQL <strong class="source-inline">RootMutation</strong> type, inside <strong class="source-inline">schema.js</strong>:<p class="source-code">logout: Response @auth</p><p>It's required that <a id="_idIndexMarker772"/>the user that's trying to log out is authorized, so <a id="_idIndexMarker773"/>we use the <strong class="source-inline">@auth</strong> directive.</p></li>
				<li>The corresponding resolver function is as follows. Add it to the <strong class="source-inline">resolvers.js</strong> file in the <strong class="source-inline">RootMutation</strong> property:<p class="source-code">logout(root, params, context) {</p><p class="source-code">  context.cookies.set(</p><p class="source-code">    'authorization',</p><p class="source-code">    '', { signed: true, expires: new Date(), httpOnly:</p><p class="source-code">      true, secure: false, sameSite: 'strict' }</p><p class="source-code">  );</p><p class="source-code">  return {</p><p class="source-code">    message: true</p><p class="source-code">  };</p><p class="source-code">},</p><p>The resolver function is minimal. It removes the cookie by setting the expiration date to the current time. This removes the cookie on the client when the browser receives the response because it is expired at that point. This behavior is an advantage in comparison to <strong class="source-inline">localStorage</strong>.</p></li>
			</ol>
			<p>We have completed everything to make the authorization work with SSR. It is a very complex task, since <a id="_idIndexMarker774"/>authorization, SSR, and CSR have effects on the whole <a id="_idIndexMarker775"/>application. Every framework out there has its own approach to implementing this feature, so please take a look at them too.</p>
			<p>If you look at the source code returned from our server after the rendering, you should see that the login form is returned correctly, as it was before. Furthermore, the server now recognizes whether the user is logged in. However, the server does not yet return the rendered news feed, the application bar, or the chats. Only a loading message is included in the returned HTML. The client-side code also does not recognize that the user is logged in. We will take a look at these problems in the next section.</p>
			<h1 id="_idParaDest-158"><a id="_idTextAnchor181"/>Running Apollo queries with SSR</h1>
			<p>By nature, GraphQL queries via <strong class="source-inline">HttpLink</strong> are asynchronous. We have implemented a <strong class="source-inline">loading</strong> component to show the user a loading message while the data is being fetched. </p>
			<p>This is the same thing that is happening while rendering our React code on the server. All of the routing is <a id="_idIndexMarker776"/>evaluated, including whether we are <a id="_idIndexMarker777"/>logged in. If the correct route is found, all GraphQL requests are sent. The problem is that the first rendering of React returns the loading state, which is sent to the client by our server. The server does not wait until the GraphQL queries are finished and it has received all of the responses to render our React code.</p>
			<p>We will fix this problem now. The following is a list of things that we have to do:</p>
			<ul>
				<li>We need to implement authentication for the SSR Apollo Client instance. We already did this for the routing, but now, we need to pass the cookie to the server-side GraphQL request too.</li>
				<li>We need to use a React Apollo-specific method to render the React code asynchronously in order to wait for all responses of the GraphQL requests.</li>
				<li>Importantly, we need to return the Apollo cache state to the client. Otherwise, the client will re-fetch everything, as its state is empty upon the first load of the page.</li>
			</ul>
			<p>Let's get started, as follows:</p>
			<ol>
				<li value="1">The first step is to pass the <strong class="source-inline">loggedIn</strong> variable from the Express.js SSR route to the <strong class="source-inline">ApolloClient</strong> function as a second parameter. Change the <strong class="source-inline">ApolloClient</strong> call inside the server's <strong class="source-inline">index.js</strong> file to the following line of code:<p class="source-code">const client = ApolloClient(req, loggedIn);</p><p>Change the <a id="_idIndexMarker778"/>signature of the exported function <a id="_idIndexMarker779"/>from the <strong class="source-inline">apollo.js</strong> file to also include this second parameter.</p></li>
				<li>Replace the <strong class="source-inline">AuthLink</strong> function inside the Apollo Client's setup for SSR with the following code:<p class="source-code">const AuthLink = (operation, next) =&gt; {</p><p class="source-code">  if(loggedIn) {</p><p class="source-code">    operation.setContext(context =&gt; ({</p><p class="source-code">      ...context,</p><p class="source-code">      headers: {</p><p class="source-code">        ...context.headers,</p><p class="source-code">        Authorization: </p><p class="source-code">          req.cookies.get('authorization')</p><p class="source-code">      },</p><p class="source-code">    }));</p><p class="source-code">  }</p><p class="source-code">  return next(operation)</p><p class="source-code">};</p><p>This <strong class="source-inline">AuthLink</strong> adds the cookies to the GraphQL requests by using the <strong class="source-inline">request</strong> object given by Express.js. The <strong class="source-inline">request</strong> object already holds the initialized cookies package, which we use to extract the authorization cookie. This only needs to be done if the user has been verified as logged in previously.</p></li>
				<li>Import a new function from the Apollo package inside the server's <strong class="source-inline">index.js</strong> file. Replace the import of the <strong class="source-inline">ReactDOM</strong> package with the following line of code:<p class="source-code">import { renderToStringWithData } from "@apollo/client/react/ssr";</p></li>
				<li>Originally, we used the <strong class="source-inline">ReactDOM</strong> server methods to render the React code to HTML. These <a id="_idIndexMarker780"/>functions are synchronous; that is why the GraphQL request did not finish. To wait for all GraphQL <a id="_idIndexMarker781"/>requests, replace all of the lines – beginning from the <strong class="source-inline">rendertoString</strong> function until the end of the SSR route inside the server's <strong class="source-inline">index.js</strong> file. The result should look as follows:<p class="source-code">renderToStringWithData(App).then((content) =&gt; {</p><p class="source-code">  if (context.url) {</p><p class="source-code">    res.redirect(301, context.url);</p><p class="source-code">  } else {</p><p class="source-code">    const head = Helmet.renderStatic();</p><p class="source-code">    res.status(200);</p><p class="source-code">    res.send('&lt;!doctype html&gt;\n${template(content,</p><p class="source-code">      head)}');</p><p class="source-code">    res.end();</p><p class="source-code">  }</p><p class="source-code">});</p><p>The <strong class="source-inline">renderToStringWithData</strong> function renders the React code, including the data received by the Apollo requests. Since the method is asynchronous, we wrap the rest of our code inside a callback function.</p><p>Now, if you take a look at the HTML returned by your server, you should see the correct markup, including chats, images, and everything else. The problem is that the <a id="_idIndexMarker782"/>client does not know that all of the HTML is <a id="_idIndexMarker783"/>already there and can be reused. The client would re-render everything.</p></li>
				<li>To let the client reuse the HTML that our server sends, we have to include Apollo Client's state with our response. Inside the preceding callback, access Apollo Client's state by inserting the following code:<p class="source-code">const initialState = client.extract();</p><p>The <strong class="source-inline">client.extract</strong> method returns a big object, holding all cache information that the client has stored after using the <strong class="source-inline">renderToStringWithData</strong> function.</p></li>
				<li>The state must be passed to the <strong class="source-inline">template</strong> function as a third parameter. So, change the <strong class="source-inline">res.send</strong> call to the following:<p class="source-code">res.send('&lt;!doctype html&gt;\n${template(content, head, initialState)}');</p></li>
				<li>Inside the <strong class="source-inline">template.js</strong> file, extend the function declaration and append the <strong class="source-inline">state</strong> variable as a third parameter, after the <strong class="source-inline">head</strong> variable.</li>
				<li>Insert the <strong class="source-inline">state</strong> variable, with the following line of code, inside the HTML body and above the <strong class="source-inline">bundle.js</strong> file. If you add it below the <strong class="source-inline">bundle.js</strong> file, it won't work correctly:<p class="source-code">${ReactDOM.renderToStaticMarkup(&lt;script dangerouslySetInnerHTML=</p><p class="source-code">{{__html: 'window.__APOLLO_STATE__=${JSON.stringify(state).replace</p><p class="source-code">(/&lt;/g, '\\u003c')}'}}/&gt;)}</p><p>We use the <strong class="source-inline">renderToStaticMarkup</strong> function to insert another <strong class="source-inline">script</strong> tag. It sets a large, stringified JSON object as Apollo Client's starting <a id="_idIndexMarker784"/>cache value. The JSON object <a id="_idIndexMarker785"/>holds all of the results of the GraphQL requests returned while rendering our server-side React application. We directly store the JSON object as a string in a new field inside the <strong class="source-inline">window</strong> object. The <strong class="source-inline">window</strong> object is helpful since you can directly access the field globally.</p></li>
				<li>Apollo has to know about the state variable. It can be used by Apollo Client to initialize its cache with the specified data, instead of having to send all of the GraphQL requests again. Open the <strong class="source-inline">index.js</strong> file from the client's <strong class="source-inline">apollo</strong> folder. The last property of the initialization process is the cache. We need to set our <strong class="source-inline">__APOLLO_STATE__</strong> instance as the starting value of the cache. Replace the <strong class="source-inline">cache</strong> property with the following code:<p class="source-code">cache: new InMemoryCache().restore(window.__APOLLO_STATE__)</p><p>We create the <strong class="source-inline">InMemoryCache</strong> instance and run its <strong class="source-inline">restore</strong> method, where we insert the value from the window object. Apollo Client should recreate its cache from this variable.</p></li>
				<li>We have now set up the cache for Apollo. It will no longer run unnecessary requests for which the results already exist. Now, we can finally reuse the HTML, with one last change. We have to change <strong class="source-inline">ReactDOM.render</strong> to <strong class="source-inline">ReactDOM.hydrate</strong> in the client's <strong class="source-inline">index.js</strong> file. The difference between these functions is that React reuses the HTML if it was correctly rendered by our server. In this case, React only attaches some necessary event listeners. If you use the <strong class="source-inline">ReactDOM.render</strong> method, it dramatically slows down the initial rendering process, as it compares the initial DOM with the current DOM and may change it accordingly.</li>
			</ol>
			<p>The last problem that we have is that the client-side code does not show the logged-in state of our <a id="_idIndexMarker786"/>application after refreshing a page. The server returns the correct markup with all the data, but the frontend redirects us to the login <a id="_idIndexMarker787"/>form. The reason for this is that we statically set the <strong class="source-inline">loggedIn</strong> state variable to <strong class="source-inline">false</strong> in the <strong class="source-inline">App.js</strong> file of the client-side code.</p>
			<p>The best way to check whether the user is authenticated is to verify whether the <strong class="source-inline">__APOLLO_STATE__</strong> field on the window object is filled and has a <strong class="source-inline">currentUser</strong> object attached. If that is the case, we can assume that the user was able to fetch their own data record, so they must be logged in. To change our <strong class="source-inline">App.js</strong> file accordingly, add the following condition to the <strong class="source-inline">loggedIn</strong> state variable:</p>
			<p class="source-code">(typeof window.__APOLLO_STATE__ !== typeof undefined &amp;&amp; typeof window.__APOLLO_STATE__.ROOT_QUERY !== typeof undefined &amp;&amp; typeof window.__APOLLO_STATE__.ROOT_QUERY.currentUser !== typeof undefined)</p>
			<p>As you can see in the preceding code, we verify whether the Apollo starting cache variable includes a <strong class="source-inline">ROOT_QUERY</strong> property with the <strong class="source-inline">currentUser</strong> subfield . The <strong class="source-inline">ROOT_QUERY</strong> property is filled if any query can be fetched successfully. The <strong class="source-inline">currentUser</strong> field is only filled if the authenticated user was successfully requested.</p>
			<p>If you execute <strong class="source-inline">npm run server</strong>, you will see that everything now works perfectly. Take a look at the markup that's returned; you will see either the login form or, when logged in, all of the content of the page that you are visiting. You can log in on the client, the news feed is fetched dynamically, you can refresh the page, and all of the posts are directly there, without the need for a single GraphQL request, as the server returned the data side by side with the HTML. This works not only for the <strong class="source-inline">/app</strong> path but for any path that you implement.</p>
			<p>We are now finished with the SSR setup.</p>
			<p>So far, we have only looked at the developmental part of SSR. When we get to the point where we <a id="_idIndexMarker788"/>want to make a production <a id="_idIndexMarker789"/>build and publish our application, there are a few other things that we will have to consider, which we will look at in <a href="B17337_12_Final_ASB_ePub.xhtml#_idTextAnchor204"><em class="italic">Chapter 12</em></a>, <em class="italic">Continuous Deployment with CircleCI and AWS</em>.</p>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor182"/>Summary</h1>
			<p>In this chapter, we changed a lot of the code that we have programmed so far. You learned the advantages and disadvantages of offering SSR. The main principles behind React Router, Apollo, and authentication with cookies while using SSR should be clear by now. It takes a lot of work to get SSR running, and it needs to be managed with every change made to your application. Nevertheless, it has excellent performance and user experience benefits for your users.</p>
			<p>In the next chapter, we will look at how to offer real-time updates through <strong class="bold">Apollo Subscriptions</strong>, instead of using the old and inefficient polling approach.</p>
		</div>
	</body></html>