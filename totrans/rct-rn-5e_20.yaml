- en: '18'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '18'
- en: Building Responsive Layouts with Flexbox
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Flexbox构建响应式布局
- en: In this chapter, you’ll get a feel for what it’s like to lay components out
    on the screen of mobile devices. Thankfully, React Native polyfills many CSS properties
    that you might have used in the past to implement page layouts in web applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将感受到在移动设备屏幕上布局组件的感觉。幸运的是，React Native填充了许多你过去可能用于在Web应用程序中实现页面布局的CSS属性。
- en: 'Before you dive into implementing layouts, you’ll get a brief introduction
    to Flexbox and using CSS style properties in React Native apps: it’s not quite
    what you’re used to with regular CSS style sheets. Then, you’ll implement several
    React Native layouts using Flexbox.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在你深入实现布局之前，你将简要了解Flexbox以及如何在React Native应用程序中使用CSS样式属性：它并不完全像你习惯的常规CSS样式表那样。然后，你将使用Flexbox实现几个React
    Native布局。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introducing Flexbox
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Flexbox
- en: Introducing React Native styles
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍React Native样式
- en: Using the Styled Components library
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Styled Components库
- en: Building Flexbox layouts
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建Flexbox布局
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter18](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter18).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本章中存在的代码文件，链接为[https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter18](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter18)。
- en: Introducing Flexbox
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Flexbox
- en: Before the flexible box layout model was introduced to CSS, the various approaches
    used to build layouts were convoluted and prone to errors. For example, we used
    **floats**, which were originally intended for text wrapping around images, for
    table-based layouts. **Flexbox** solves this by abstracting many of the properties
    that you would normally have to provide in order to make the layout work.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在引入灵活的盒模型布局模型到CSS之前，用于构建布局的各种方法都是复杂的，并且容易出错。例如，我们使用了**浮动**，它最初是为了让文本围绕图像而设计的，用于表格布局。**Flexbox**通过抽象出许多你通常需要提供的属性来解决这一问题，以便使布局工作。
- en: 'In essence, the Flexbox model is what it probably sounds like to you: a box
    model that’s flexible. That’s the beauty of Flexbox: its simplicity. You have
    a box that acts as a container, and you have **child** elements within that box.
    Both the container and the **child** elements are flexible in how they’re rendered
    on the screen, as illustrated here:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，Flexbox模型可能对你来说听起来就是这样：一个灵活的盒模型。这就是Flexbox的美丽之处：它的简单性。你有一个充当容器的盒子，你在这个盒子内有**子元素**。容器和**子元素**在屏幕上的渲染方式都是灵活的，如下所示：
- en: '![Picture 1](img/B19636_18_01.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](img/B19636_18_01.png)'
- en: 'Figure 18.1: Flexbox elements'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.1：Flexbox元素
- en: Flexbox containers have a direction, either column (up/down) or row (left/right).
    This actually confused me when I was first learning about Flexbox; my brain refused
    to believe that rows were organized beside each other from left to right. Rows
    are stacked on top of one another! The key thing to remember is that it’s the
    direction in which the box flexes, not the direction in which boxes are placed
    on the screen.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Flexbox容器有一个方向，要么是列（上/下），要么是行（左/右）。这实际上在我最初学习Flexbox时让我感到困惑；我的大脑拒绝相信行是从左到右并排组织的。行是堆叠在一起的！要记住的关键点是，它是盒子伸缩的方向，而不是盒子在屏幕上放置的方向。
- en: For a more in-depth treatment of Flexbox concepts, refer to [https://css-tricks.com/snippets/css/a-guide-to-Flexbox](https://css-tricks.com/snippets/css/a-guide-to-Flexbox).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Flexbox概念的更深入探讨，请参阅[https://css-tricks.com/snippets/css/a-guide-to-Flexbox](https://css-tricks.com/snippets/css/a-guide-to-Flexbox)。
- en: Now that we’ve covered the basics of Flexbox layouts at a high level, it’s time
    to learn how styles in React Native applications work.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经从高层次上了解了Flexbox布局的基础知识，是时候学习React Native应用程序中的样式是如何工作的了。
- en: Introducing React Native styles
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍React Native样式
- en: It’s time to implement your first React Native app, beyond the boilerplate that’s
    generated by **Expo**. I want to make sure that you feel comfortable using React
    Native style sheets before you start implementing Flexbox layouts in the next
    section.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候实现你的第一个React Native应用程序了，超越由**Expo**生成的样板代码。我想确保你在开始下一节实现Flexbox布局之前，对使用React
    Native样式表感到舒适。
- en: 'Here’s what a React Native style sheet looks like:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是React Native样式表的样子：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is a **JavaScript** module, not a CSS module. If you want to declare React
    Native styles, you need to use plain objects. Then, you call `StyleSheet.create()`
    and export this from the style module. Note that style names are pretty similar
    to the web CSS, except that they are written in camel case; for example, `justifyContent`
    rather than `justify-content`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 **JavaScript** 模块，而不是 CSS 模块。如果你想声明 React Native 样式，你需要使用纯对象。然后，你调用 `StyleSheet.create()`
    并从样式模块导出它。请注意，样式名称与 web CSS 非常相似，只是它们是驼峰式命名的；例如，`justifyContent` 而不是 `justify-content`。
- en: 'As you can see, this style sheet has three styles: `container`, `box`, and
    `boxText`. Within the `container` style, there’s a call to `Platform.select()`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个样式表有三个样式：`container`、`box` 和 `boxText`。在 `container` 样式中，有一个对 `Platform.select()`
    的调用：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This function will return different styles based on the platform of the mobile
    device. Here, you’re handling the top padding of the top-level `container` view.
    You’ll probably use this code in most of your apps to make sure that your React
    components don’t render underneath the status bar of the device. Depending on
    the platform, the padding will require different values. If it’s iOS, `paddingTop`
    is `20`. If it’s Android, `paddingTop` will be the value of `StatusBar.currentHeight`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将根据移动设备的平台返回不同的样式。在这里，你正在处理顶级 `container` 视图的顶部填充。你可能会在大多数应用中使用这段代码来确保你的
    React 组件不会渲染在设备的状态栏下方。根据平台的不同，填充需要不同的值。如果是 iOS，`paddingTop` 是 `20`。如果是 Android，`paddingTop`
    将是 `StatusBar.currentHeight` 的值。
- en: The preceding `Platform.select()` code is an example of a case where you need
    to implement a workaround for differences in the platform. For example, if `StatusBar.currentHeight`
    was available on iOS and Android, you wouldn’t need to call `Platform.select()`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的 `Platform.select()` 代码是一个需要实现平台差异解决方案的例子。例如，如果 `StatusBar.currentHeight`
    在 iOS 和 Android 上都可用，你就不需要调用 `Platform.select()`。
- en: 'Let’s see how these styles are imported and applied to React Native components:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些样式是如何导入并应用到 React Native 组件中的：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The styles are assigned to each component via the `style` property. You’re trying
    to render a box with some text in the middle of the screen. Let’s make sure that
    this looks as we expect it to.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 样式是通过 `style` 属性分配给每个组件的。你正在尝试渲染一个在屏幕中间带有文本的盒子。让我们确保它看起来像我们预期的那样。
- en: '![Picture 2](img/B19636_18_02.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片 2](img/B19636_18_02.png)'
- en: 'Figure 18.2: Box in the middle of a screen'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.2：屏幕中间的盒子
- en: We have found out how to apply styles to components using a built-in module,
    but there is more than one way to define styles. We also have the option to write
    CSS in React Native. Let’s quickly go through it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经找到了如何使用内置模块应用样式的办法，但定义样式的方法不止一种。我们还有在 React Native 中编写 CSS 的选项。让我们快速了解一下。
- en: Using the Styled Components library
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Styled Components 库
- en: '**Styled Components** is a CSS-in-JS library that styles React Native components
    using plain CSS. With this approach, you don’t need to define style classes via
    objects and provide style props. The CSS itself is determined via tagged template
    literals provided by `styled-components`.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**Styled Components** 是一个 CSS-in-JS 库，它使用纯 CSS 来设置 React Native 组件的样式。使用这种方法，你不需要通过对象定义样式类并提供样式属性。CSS
    本身是通过 `styled-components` 提供的标签模板字面量来确定的。'
- en: 'To install `styled-components`, run this command in your project:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 `styled-components`，在你的项目中运行以下命令：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let’s try to rewrite components from the *Introducing React Native styles*
    section. This is what our `Box` component looks like:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 *介绍 React Native 样式* 部分的组件。这是我们的 `Box` 组件的样子：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this example, we’ve got two components, `Box` and `BoxText`. Now we can
    use them as usual, but without any other additional styling props:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有两个组件，`Box` 和 `BoxText`。现在我们可以像平常一样使用它们，但不需要任何其他额外的样式属性：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In further sections, I will use `StyleSheet` objects, but I will avoid `styled-components`
    for performance reasons. If you want to learn more about `styled-components`,
    you can read more here: [https://styled-components.com/](https://styled-components.com/).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我将使用 `StyleSheet` 对象，但为了避免性能问题，我会避免使用 `styled-components`。如果你想了解更多关于
    `styled-components` 的信息，你可以在这里阅读更多：[https://styled-components.com/](https://styled-components.com/)。
- en: Perfect! Now that you have an idea of how to set styles on React Native elements,
    let’s use Flexbox to start creating some screen layouts.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！现在你已经了解了如何在 React Native 元素上设置样式，让我们使用 Flexbox 开始创建一些屏幕布局。
- en: Building Flexbox layouts
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 Flexbox 布局
- en: In this section, you’ll learn about several potential layouts that you can use
    in your React Native applications. I want to stay away from the idea that one
    layout is better than another. Instead, I’ll show you how powerful the Flexbox
    layout model is for mobile screens so that you can design the kind of layout that
    best suits your application.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将了解你可以在你的React Native应用程序中使用的一些潜在布局。我不想强调一个布局比另一个布局更好。相反，我会向你展示Flexbox布局模型在移动屏幕上的强大之处，这样你就可以设计最适合你应用程序的布局。
- en: Simple three-column layout
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单的三列布局
- en: To start things off, let’s implement a simple layout with three sections that
    flex in the column direction (top to bottom). We’ll look at the result we are
    aiming for first.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们实现一个简单的布局，包含三个在列方向（从上到下）上伸缩的部分。我们首先看看我们想要达到的结果。
- en: '![Picture 3](img/B19636_18_03.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片3](img/B19636_18_03.png)'
- en: 'Figure 18.3: Simple three-column layout'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.3：简单三列布局
- en: The idea, in this example, is that you style and label the three screen sections
    so that they stand out. In other words, these components wouldn’t necessarily
    have any styling in a real application since they’re used to arrange other components
    on the screen.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，想法是这样的：你给三个屏幕部分添加样式和标签，使它们突出。换句话说，在真实的应用程序中，这些组件可能不会有任何样式，因为它们是用来在屏幕上排列其他组件的。
- en: 'Now, let’s take a look at the components used to create this screen layout:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看创建这个屏幕布局所使用的组件：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The container view (the outermost `<View>` component) is the column and the
    child views are the rows. The `<Text>` component is used to label each row. In
    terms of HTML elements, `<View>` is similar to a `<div>` element, while `<Text>`
    is similar to a `<p>` element.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 容器视图（最外层的`<View>`组件）是列，子视图是行。`<Text>`组件用于标记每一行。从HTML元素的角度来看，`<View>`类似于`<div>`元素，而`<Text>`类似于`<p>`元素。
- en: Maybe this example could have been called a three-row layout since it has three
    rows. But, at the same time, the three layout sections are flexing in the direction
    of the column that they’re in. Use the naming convention that makes the most conceptual
    sense to you.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 也许这个例子可以被称为三行布局，因为它有三行。但与此同时，这三个布局部分正在它们所在的列方向上伸缩。使用对你最有概念意义的命名约定。
- en: 'Now, let’s take a look at the styles used to create this layout:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看创建这个布局所使用的样式：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `flex` and `flexDirection` properties of `container` enable the layout of
    the rows to flow from top to bottom. The `alignItems` and `justifyContent` properties
    align the child elements to the center of the container and add space around them,
    respectively.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`container`的`flex`和`flexDirection`属性使得行的布局可以从上到下流动。`alignItems`和`justifyContent`属性分别将子元素对齐到容器的中心，并在它们周围添加空间。'
- en: 'Let’s see how this layout looks when you rotate the device from a portrait
    orientation to a landscape orientation:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当您将设备从纵向旋转到横向时，这个布局看起来如何：
- en: '![Picture 4](img/B19636_18_04.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片4](img/B19636_18_04.png)'
- en: 'Figure 18.4: Landscape orientation'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.4：横幅方向
- en: Flexbox automatically figured out how to preserve the layout for you. However,
    you can improve on this a little bit. For example, the landscape orientation now
    has a lot of wasted space to the left and right. You could create your own abstraction
    for the boxes that you’re rendering. In the following section, we’ll improve on
    this layout.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Flexbox自动为你解决了布局问题。然而，你可以稍微改进一下。例如，横幅方向现在左右两侧有很多浪费的空间。你可以为你要渲染的盒子创建自己的抽象。在下一节中，我们将改进这个布局。
- en: Improved three-column layout
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改进的三列布局
- en: 'There are a few things that I think you can improve on from the last example.
    Let’s fix the styles so that the children of the Flexbox could stretch to take
    advantage of the available space. Do you remember, in the last example, when you
    rotated the device from a portrait orientation to a landscape orientation? There
    was a lot of wasted space. It would be nice to have the components automatically
    adjust themselves. Here’s what the new style module looks like:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 有几件事情我认为你可以从上一个例子中改进。让我们调整样式，使得Flexbox的子元素可以拉伸以利用可用空间。你还记得在最后一个例子中，当您将设备从纵向旋转到横向时吗？有很多浪费的空间。如果组件能自动调整自己会很好。下面是新样式模块的样子：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The key change here is the `alignSelf` property. This tells elements with the
    `box` style to change their `width` or `height` (depending on the `flexDirection`
    of their container) to fill space. Also, the `box` style no longer defines a `width`
    property because this will be computed on the fly now.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 关键的改变在于 `alignSelf` 属性。这告诉具有 `box` 样式的元素根据其容器的 `flexDirection` 改变其 `width` 或
    `height`（取决于容器的 `flexDirection`），以填充空间。此外，`box` 样式不再定义 `width` 属性，因为这将现在实时计算。
- en: 'Here’s what the sections look like in portrait mode:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是在纵向模式下的部分外观：
- en: '![Picture 5](img/B19636_18_05.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片 5](img/B19636_18_05.png)'
- en: 'Figure 18.5: Improved three-column layout in portrait orientation'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.5：纵向布局中的改进三列布局
- en: Now, each section takes the full width of the screen, which is exactly what
    you want to happen. The issue of wasted space was actually more prevalent in landscape
    orientation, so let’s rotate the device and see what happens to these sections
    now.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每个部分都占据了屏幕的全宽，这正是你想要的。实际上，浪费空间的问题在横向布局中更为普遍，所以让我们旋转设备，看看这些部分现在会发生什么。
- en: '![Picture 6](img/B19636_18_06.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片 6](img/B19636_18_06.png)'
- en: 'Figure 18.6: Improved three-column layout in landscape orientation'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.6：横向布局中的改进三列布局
- en: 'Now your layout is utilizing the entire width of the screen, regardless of
    orientation. Lastly, let’s implement a proper `Box` component that can be used
    by `App.js` instead of having repetitive style properties in place. Here’s what
    the `Box` component looks like:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在布局正在利用屏幕的整个宽度，无论方向如何。最后，让我们实现一个可以由 `App.js` 使用的正确 `Box` 组件，而不是在布局中放置重复的样式属性。以下是
    `Box` 组件的外观：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You now have the beginnings of a nice layout. Next, you’ll learn about flexing
    in the other direction: left to right.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经有了良好的布局基础。接下来，你将学习关于其他方向的弹性：从左到右。
- en: Flexible rows
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 灵活的行
- en: 'In this section, you’ll learn how to make screen layout sections stretch from
    top to bottom. To do this, you need a **flexible row**. Here is what the styles
    for this screen look like:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何使屏幕布局部分从顶部延伸到底部。要做到这一点，你需要一个 **灵活的行**。以下是该屏幕的样式：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here’s the `App` component, using the same `Box` component that you implemented
    in the previous section:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 `App` 组件，使用你在上一节中实现的相同的 `Box` 组件：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here’s what the resulting screen looks like in portrait mode:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是在纵向模式下的屏幕结果：
- en: '![Picture 7](img/B19636_18_07.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片 7](img/B19636_18_07.png)'
- en: 'Figure 18.7: Flexible rows in portrait orientation'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.7：纵向布局中的灵活行
- en: The two columns stretch all the way from the top of the screen to the bottom
    because of the `alignSelf` property, which doesn’t actually specify which direction
    to stretch in. The two `Box` components stretch from top to bottom because they’re
    displayed in a **flex row**. Note how the spacing between these two sections goes
    from left to right? This is because of the container’s `flexDirection` property,
    which has a value of `row`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `alignSelf` 属性，两列从屏幕顶部延伸到底部，实际上并没有指定拉伸的方向。两个 `Box` 组件从顶部到底部拉伸，因为它们以 **flex
    行** 的形式显示。注意这两个部分之间的间距是如何从左到右变化的？这是因为容器具有 `flexDirection` 属性，其值为 `row`。
- en: Now, let’s see how this flex direction impacts the layout when the screen is
    rotated to a landscape orientation.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这个弹性方向如何影响屏幕旋转到横向布局时的布局。
- en: '![Picture 8](img/B19636_18_08.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片 8](img/B19636_18_08.png)'
- en: 'Figure 18.8: Flexible rows in landscape orientation'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.8：横向布局中的灵活行
- en: Since **Flexbox** has a `justifyContent` style property value of `space-around`,
    space is added proportionally to the left, the right, and in between the sections.
    In the following section, you’ll learn about flexible grids.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 **Flexbox** 的 `justifyContent` 样式属性值为 `space-around`，空间会按比例添加到左侧、右侧以及部分之间。在下一节中，你将了解灵活的网格。
- en: Flexible grids
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 灵活的网格
- en: Sometimes, you need a screen layout that flows like a grid. For example, what
    if you have several sections that are the same width and height, but you’re not
    sure how many of these sections will be rendered? Flexbox makes it easy to build
    a row that flows from left to right until the end of the screen is reached. Then,
    it automatically continues rendering elements from left to right on the next row.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你需要一个像网格一样流动的屏幕布局。例如，如果你有多个宽度相同、高度相同的部分，但你不确定这些部分将渲染多少个？Flexbox 使得构建从左到右流动直到屏幕末尾的行变得容易。然后，它将自动在下一行从左到右渲染元素。
- en: 'Here’s an example layout in portrait mode:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个纵向模式下的布局示例：
- en: '![Picture 9](img/B19636_18_09.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片 9](img/B19636_18_09.png)'
- en: 'Figure 18.9: Flexible grids in portrait orientation'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.9：纵向布局的灵活网格
- en: The beauty of this approach is that you don’t need to know in advance how many
    columns are in a given row. The dimensions of each child determine what will fit
    in a given row.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点是您不需要事先知道给定行中有多少列。每个子组件的尺寸决定了什么可以放入给定行中。
- en: 'To see the styles used to create this layout, you can follow this link: [https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter18/flexible-grids/styles.ts](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter18/flexible-grids/styles.ts).'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看创建此布局所使用的样式，您可以点击此链接：[https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter18/flexible-grids/styles.ts](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter18/flexible-grids/styles.ts).
- en: 'Here’s the `App` component that renders each section:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是渲染每个部分的`App`组件：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Lastly, let’s make sure that the landscape orientation works with this layout:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们确保横向布局与这个布局兼容：
- en: '![Picture 10](img/B19636_18_10.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片 10](img/B19636_18_10.png)'
- en: 'Figure 17.10: Flexible grids in landscape orientation'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.10：横向布局的灵活网格
- en: You may have noticed that there’s some superfluous space on the right side.
    Remember, these sections are only visible in this book because we want them to
    be visible. In a real app, they’re just grouping other React Native components.
    However, if the space to the right of the screen becomes an issue, play around
    with the margin and the width of the child components.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到右侧有一些多余的空间。记住，这些部分之所以在这个书中可见，是因为我们希望它们可见。在实际应用中，它们只是对其他React Native组件进行分组。然而，如果屏幕右侧的空间成为问题，您可以尝试调整子组件的边距和宽度。
- en: Now that you have an understanding of how **flexible grids** work, we’ll look
    at flexible rows and columns next.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了**灵活网格**的工作原理，我们将接下来查看灵活的行和列。
- en: Flexible rows and columns
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 灵活的行和列
- en: 'Let’s learn how to combine rows and columns to create a sophisticated layout
    for your app. For example, sometimes, you need the ability to nest columns within
    rows or rows within columns. To see the `App` component of an application that
    nests columns within rows, you can follow this link: [https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter18/flexible-rows-and-columns/App.tsx](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter18/flexible-rows-and-columns/App.tsx).'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何组合行和列来为您的应用创建一个复杂的布局。例如，有时您需要将列嵌套在行内或行嵌套在列内的能力。要查看嵌套列在行内的应用的`App`组件，您可以点击此链接：[https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter18/flexible-rows-and-columns/App.tsx](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter18/flexible-rows-and-columns/App.tsx).
- en: 'You’ve created abstractions for the layout pieces (`<Row>` and `<Column>`)
    and the content piece (`<Box>`). Let’s see what this screen looks like:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经为布局组件（`<Row>`和`<Column>`）和内容组件（`<Box>`）创建了抽象。让我们看看这个屏幕看起来像什么：
- en: '![Picture 11](img/B19636_18_11.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片 11](img/B19636_18_11.png)'
- en: 'Figure 18.11: Flexible rows and columns'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.11：灵活的行和列
- en: This layout probably looks familiar because you’ve done it in the *Flexible
    grids* section. The key difference as compared to *Figure 18.9* is in how these
    content sections are ordered.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个布局可能看起来很熟悉，因为您在*灵活网格*部分已经做过。与*图 18.9*相比，关键的区别在于这些内容部分的顺序。
- en: For example, **#2** doesn’t go to the right of **#1**, it goes below it. This
    is because we’ve placed **#1** and **#2** in `<Column>`. The same happens with
    **#3** and **#4**. These two columns are placed in a row. Then, the next row begins,
    and so on.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，**#2**不会放在**#1**的右边，它会放在下面。这是因为我们将**#1**和**#2**放在了`<Column>`中。**#3**和**#4**也是同样的情况。这两个列被放置在同一行中。然后，下一行开始，以此类推。
- en: 'This is just one of many possible layouts that you can achieve by nesting row
    Flexboxes and column Flexboxes. Let’s take a look at the `Row` component now:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是通过嵌套行Flexbox和列Flexbox所能实现的可能布局之一。现在让我们看看`Row`组件：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This component applies the row style to the `<View>` component. The end result
    is cleaner JSX markup in the `App` component when creating a complex layout. Finally,
    let’s look at the `Column` component:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件将行样式应用于`<View>`组件。当创建复杂布局时，`App`组件中的最终结果是更干净的JSX标记。最后，让我们看看`Column`组件：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This looks just like the `Row` component, just with a different style applied
    to it. It also serves the same purpose as `Row`: to enable simpler JSX markup
    for layouts in other components.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来就像`Row`组件，只是应用了不同的样式。它也服务于与`Row`相同的目的：为其他组件中的布局提供更简单的JSX标记。
- en: Summary
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced you to styles in React Native. Though you can use many
    of the same CSS style properties that you’re used to, the CSS style sheets used
    in web applications look very different. Namely, they’re composed of plain JavaScript
    objects.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向你介绍了 React Native 中的样式。虽然你可以使用许多你熟悉的相同 CSS 样式属性，但用于 Web 应用的 CSS 样式表看起来非常不同。具体来说，它们由纯
    JavaScript 对象组成。
- en: 'Then, you learned how to work with the main React Native layout mechanism:
    **Flexbox**. This is the preferred way of laying out most web applications these
    days, so it makes sense to be able to reuse this approach in a Native app. You
    created several different layouts, and you saw how they looked in portrait and
    landscape orientation.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你学习了如何使用 React Native 的主要布局机制：**Flexbox**。这是目前大多数 Web 应用布局的首选方式，因此能够在原生应用中重用这种方法是有意义的。你创建了几个不同的布局，并看到了它们在纵向和横向方向上的外观。
- en: In the next chapter, you’ll start implementing navigation for your app.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将开始为你的应用实现导航功能。
