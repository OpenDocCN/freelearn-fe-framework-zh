- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Writing Your First Application with React Hooks
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 React Hooks 编写您的第一个应用程序
- en: After learning about the State Hook in-depth, we are now going to make use of
    it by creating a blog application from scratch. In this chapter, we are first
    going to learn how to structure React apps in a way that scales well. Then, we
    are going to define the components that we are going to need to cover the basic
    features of a blog application. Finally, we are going to use Hooks to introduce
    state to our application! Throughout this chapter, we are also going to learn
    about JSX and various JavaScript features. At the end of this chapter, we are
    going to have a basic blog application, where we can log in, register, and create
    posts.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解 State Hook 之后，我们现在将利用它从头开始创建一个博客应用程序。在本章中，我们首先将学习如何以可扩展的方式结构化 React 应用程序。然后，我们将定义我们需要用到的组件，以覆盖博客应用程序的基本功能。最后，我们将使用
    Hooks 将状态引入我们的应用程序！在本章中，我们还将了解 JSX 和各种 JavaScript 功能。在本章结束时，我们将拥有一个基本的博客应用程序，我们可以登录、注册和创建帖子。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Structuring React projects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构化 React 项目
- en: Implementing static React components
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现静态 React 组件
- en: Implementing stateful components with Hooks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Hooks 实现有状态的组件
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'A fairly recent version of Node.js should already be installed. The Node Package
    Manager (`npm`) also needs to be installed (it should come with Node.js). For
    more information on how to install Node.js, please check out the official website:
    [https://nodejs.org/](https://nodejs.org/).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 应已安装一个相当新的 Node.js 版本。还需要安装 Node 包管理器 (`npm`)（它应随 Node.js 一起安装）。有关如何安装 Node.js
    的更多信息，请访问官方网站：[https://nodejs.org/](https://nodejs.org/)。
- en: 'We are going to use **Visual Studio Code** (**VS Code**) for the guides in
    this book, but everything should work similarly in any other editor. For more
    information on how to install VS Code, please refer to the official website: [https://code.visualstudio.com](https://code.visualstudio.com).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的指南中，我们将使用 **Visual Studio Code** （**VS Code**），但任何其他编辑器都应该以类似的方式工作。有关如何安装
    VS Code 的更多信息，请参阅官方网站：[https://code.visualstudio.com](https://code.visualstudio.com)。
- en: 'In this book, we use the following versions:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们使用以下版本：
- en: Node.js v22.14.0
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js v22.14.0
- en: '`npm` v10.9.2'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npm` v10.9.2'
- en: Visual Studio Code v1.97.2
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code v1.97.2
- en: The versions mentioned in the preceding list are the ones used in the book.
    While installing a newer version should not be an issue, please note that certain
    steps might work differently on a newer version. If you are having an issue with
    the code and steps provided in this book, please try using the mentioned versions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 上列版本是本书中使用的版本。虽然安装较新版本通常不会有问题，但请注意，某些步骤在较新版本上可能会有所不同。如果您在使用本书提供的代码和步骤时遇到问题，请尝试使用提到的版本。
- en: 'You can find the code for this chapter on GitHub: [https://github.com/PacktPublishing/Learn-React-Hooks-Second-Edition/tree/main/Chapter03](https://github.com/PacktPublishing/Learn-React-Hooks-Second-Edition/tree/main/Chapter03).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 上找到本章的代码：[https://github.com/PacktPublishing/Learn-React-Hooks-Second-Edition/tree/main/Chapter03](https://github.com/PacktPublishing/Learn-React-Hooks-Second-Edition/tree/main/Chapter03)。
- en: It is highly recommended that you write the code on your own. Do not simply
    run the code examples that are provided with the book. It is important to write
    the code yourself to be able to learn and understand it properly. However, if
    you run into any issues, you can always refer to the code example.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议您亲自编写代码。不要简单地运行书中提供的代码示例。自己编写代码对于正确学习和理解代码非常重要。然而，如果您遇到任何问题，您始终可以参考代码示例。
- en: Structuring React projects
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构化 React 项目
- en: After learning about the principles of React, how to use the State Hook, and
    how Hooks work internally, we are now going to make use of the real State Hook
    to develop a blog application. In this section, we are going to structure the
    folders in a way that will allow us to scale the project later.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解 React 原则、如何使用 State Hook 以及 Hooks 内部工作原理之后，我们现在将利用真实的 State Hook 来开发一个博客应用程序。在本节中，我们将以允许我们以后扩展项目的方式结构化文件夹。
- en: Folder structure
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件夹结构
- en: There are many ways that projects can be structured, and different structures
    can do well for different projects. Usually, it’s a good idea to create a `src/`
    folder for all source code, to distinguish it from assets and configuration files.
    Inside this folder, one possible structure is to group the files by features.
    Another popular way to structure projects is to group the files by routes. For
    some projects, it might make sense to additionally separate by file type, such
    as `src/api/` and `src/components/`. However, for our project, we are mainly going
    to focus on the **user interface** (**UI**). So, we are going to group our files
    by features in the `src/` folder.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 项目可以有多种结构，不同的结构可能适合不同的项目。通常，创建一个`src/`文件夹来存放所有源代码是一个好主意，以区分资源和配置文件。在这个文件夹内，一种可能的组织方式是按特性分组文件。另一种流行的项目组织方式是按路由分组文件。对于某些项目，可能还需要按文件类型进一步分离，例如`src/api/`和`src/components/`。然而，对于我们的项目，我们主要将关注**用户界面**（**UI**）。因此，我们将在`src/`文件夹中按特性分组文件。
- en: It is a good idea to start with a simple structure at first, and only nest more
    deeply when you actually need it. Do not spend too much time thinking about the
    file structure when starting a project because, usually, you do not know upfront
    how files should be grouped, and it may change later anyway. However, do try to
    avoid generic names for folders and files, such as `utils`, `common`, or `shared`.
    Use a term as specific as possible and broaden it when the structure evolves.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 首先从一个简单的结构开始是个好主意，只有在你真正需要的时候才进行更深的嵌套。在项目开始时不要花太多时间思考文件结构，因为通常你事先不知道文件应该如何分组，而且它可能以后还会改变。然而，尽量避免使用通用的文件夹和文件名，如`utils`、`common`或`shared`。使用尽可能具体的术语，并在结构演变时进行扩展。
- en: Defining the features
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义特性
- en: 'We first have to think about which features we are going to implement in our
    blog application. At the bare minimum, we want to implement the following features:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先必须考虑我们将在博客应用中实现哪些特性。至少，我们想要实现以下特性：
- en: Registering users
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册用户
- en: Logging in/out
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录/登出
- en: Viewing a single post
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看单个帖子
- en: Creating a new post
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新帖子
- en: Listing posts
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出帖子
- en: Coming up with an initial structure
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制定初始结构
- en: 'From our defined features, we can abstract a couple of feature groups:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们定义的特性中，我们可以抽象出一组功能组：
- en: User (registering, logging in/logging out)
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户（注册、登录/登出）
- en: Post (creating, viewing, listing)
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帖子（创建、查看、列出）
- en: 'We could now just keep it very simple and create all the components in the
    `src/` folder, without any nesting. However, since we already have a quite clear
    picture of the features that a blog application is going to need, we can already
    come up with a folder structure:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以保持非常简单，在`src/`文件夹中创建所有组件，而不需要任何嵌套。然而，由于我们已经对博客应用将需要的特性有了相当清晰的了解，我们可以提前制定一个文件夹结构：
- en: '`src/`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/`'
- en: '`src/user/`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/user/`'
- en: '`src/post/`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/post/`'
- en: 'Let’s set up the initial folder structure now:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在设置初始的文件夹结构：
- en: 'Copy the `Chapter01_3` folder to a new `Chapter03_1` folder by executing the
    following command:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令将`Chapter01_3`文件夹复制到新的`Chapter03_1`文件夹：
- en: '[PRE0]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Open the new `Chapter03_1` folder in VS Code.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code中打开新的`Chapter03_1`文件夹。
- en: Inside the `Chapter03_1` folder, create new `src/user/` and `src/post/` folders.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chapter03_1`文件夹内，创建新的`src/user/`和`src/post/`文件夹。
- en: Component structure
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件结构
- en: The idea of components in React is to have each component deal with a single
    task or UI element. We should try to make components as fine-grained as possible,
    in order to be able to reuse code. If we find ourselves copying and pasting code
    from one component to another, it might be a good idea to break out this common
    code into a separate component that we can reuse.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: React中组件的理念是让每个组件处理单个任务或UI元素。我们应该尽量使组件尽可能细粒度，以便能够重用代码。如果我们发现自己正在从一个组件复制粘贴代码到另一个组件，可能将这个通用代码提取到一个可以重用的单独组件中是个好主意。
- en: 'Usually, when developing software, we start with a UI mock-up. For our blog,
    this would look as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在开发软件时，我们首先从UI原型开始。对于我们的博客，它看起来如下：
- en: '![Figure 3.1 – An initial mock-up of our blog application](img/B31327_03_01.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – 我们博客应用的初始原型](img/B31327_03_01.png)'
- en: Figure 3.1 – An initial mock-up of our blog application
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 我们博客应用的初始原型
- en: When splitting components, we use the **single responsibility principle**, which
    states that every module should have responsibility over a single encapsulated
    part of the functionality.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在拆分组件时，我们使用**单一职责原则**，该原则指出每个模块应该只负责功能的一个封装部分。
- en: 'In the mock-up, we can draw boxes around each component and subcomponent, and
    give them names. Keep in mind that each component should have exactly one responsibility.
    We start with the fundamental components that make up this app:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在原型中，我们可以在每个组件和子组件周围绘制方框，并给它们命名。请记住，每个组件应该只有一个职责。我们从这个应用的基本组件开始：
- en: '![Figure 3.2 – Mapping out the fundamental components in our mock-up](img/B31327_03_02.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2 – 在我们的原型中绘制基本组件](img/B31327_03_02.png)'
- en: Figure 3.2 – Mapping out the fundamental components in our mock-up
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 在我们的原型中绘制基本组件
- en: We mapped out a `Logout` component for the logout (which will be replaced with
    `Login`/`Register` components in the logged-out state), a `CreatePost` component
    to render a form to create new posts, and a `Post` component for the actual posts.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们绘制了一个`Logout`组件用于登出（在登出状态下将被`Login`/`Register`组件替换），一个`CreatePost`组件用于渲染创建新帖子的表单，以及一个`Post`组件用于实际的帖子。
- en: 'Now that we mapped out the fundamental components, we are going to look at
    which components logically belong together, therefore, forming a group. To do
    so, we now map out the container components, which we need in order to group the
    components together:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经绘制了基本组件，我们将查看哪些组件在逻辑上属于一组，因此形成一个组。为此，我们现在绘制容器组件，这是我们为了将组件组合在一起所需要的：
- en: '![Figure 3.3 – Mapping out the container components in our mock-up](img/B31327_03_03.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3 – 在我们的原型中绘制容器组件](img/B31327_03_03.png)'
- en: Figure 3.3 – Mapping out the container components in our mock-up
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – 在我们的原型中绘制容器组件
- en: We mapped out a `PostList` component, which is used to group posts together,
    and then a `UserBar` component to deal with login/logout and registration. Finally,
    we mapped out an `App` component to group everything else together and define
    the structure of our app.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们绘制了一个`PostList`组件，用于将帖子分组，然后一个`UserBar`组件用于处理登录/登出和注册。最后，我们绘制了一个`App`组件，将其他所有内容组合在一起并定义我们应用的结构。
- en: Now that we are done with structuring our React project, we can move on to implementing
    the static components.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了React项目的结构化，我们可以继续实现静态组件。
- en: Implementing static components
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现静态组件
- en: Before we start adding state to our blog application via Hooks, we are going
    to model the basic features of our application as static React components. Doing
    this means that we must deal with the static view structure of our application.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们通过Hooks向我们的博客应用添加状态之前，我们将使用静态React组件来模拟我们应用的基本功能。这样做意味着我们必须处理我们应用静态视图结构。
- en: It makes sense to deal with the static structure first, as it will avoid having
    to move dynamic code to different components later. Furthermore, it is easier
    to deal only with HTML (and CSS) first—helping us get started with projects quickly.
    Then, we can move on to implementing dynamic code and handling state.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 首先处理静态结构是有意义的，因为它将避免以后需要将动态代码移动到不同的组件中。此外，首先只处理HTML（和CSS）更容易——帮助我们快速开始项目。然后，我们可以继续实现动态代码和处理状态。
- en: Doing this step by step, instead of implementing everything at once, helps us
    to quickly get started with new projects without having to think about too much
    at once, and reduces the amount of restructuring we will have to do later!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 逐步进行，而不是一次性实现所有内容，这有助于我们快速开始新项目，而不必一次性思考太多，并且减少了我们以后需要重构的量！
- en: Implementing the user-related static components
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现与用户相关的静态组件
- en: 'We are going to start with the simplest feature in terms of static components,
    that is, implementing user-related functionality. As we have seen from our mock-up,
    we are going to need four components here:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从静态组件中最简单的功能开始，即实现与用户相关的功能。正如我们从我们的原型中看到的，我们在这里需要四个组件：
- en: A `Login` component, which we are going to show when the user is not logged
    in yet
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个在用户尚未登录时将要显示的`Login`组件
- en: A `Register` component, which we are also going to show when the user is not
    logged in yet
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个在用户尚未登录时也将要显示的`Register`组件
- en: A `Logout` component, which is going to be shown after the user is logged in
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个在用户登录后将要显示的`Logout`组件
- en: A `UserBar` component, which will display the other components conditionally
    depending on the user’s login state
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`UserBar`组件，它将根据用户的登录状态有条件地显示其他组件
- en: We are going to start by defining the first three components, which are all
    standalone components. Finally, we will define the `UserBar` component, which
    depends on the other components being defined.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先定义前三个组件，它们都是独立组件。最后，我们将定义依赖于其他组件的`UserBar`组件。
- en: The Login component
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 登录组件
- en: 'First, we will define the `Login` component, where we will show two fields:
    a **Username** field and a **Password** field. Additionally, we will show a **Login**
    button. Let’s get started:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将定义`Login`组件，我们将展示两个字段：一个**用户名**字段和一个**密码**字段。此外，我们还将展示一个**登录**按钮。让我们开始吧：
- en: 'Inside the previously set up `Chapter03_1` folder, create a new file for our
    component: `src/user/Login.jsx`.'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在之前设置的`Chapter03_1`文件夹内，为我们的组件创建一个新文件：`src/user/Login.jsx`。
- en: 'In the newly created `src/user/Login.jsx` file, define a component, which does
    not accept any props for now:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新创建的`src/user/Login.jsx`文件中，定义一个组件，目前它不接受任何属性：
- en: '[PRE1]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Render a `<form>` that prevents the default action of submitting the form and
    refreshing the page:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染一个`<form>`，防止表单的默认提交行为和刷新页面：
- en: '[PRE2]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, we are using an **anonymous function** (also called **arrow function**)
    to define the `onSubmit` handler. Anonymous functions are defined as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用一个**匿名函数**（也称为**箭头函数**）来定义`onSubmit`处理程序。匿名函数的定义如下：
- en: If they do not have any arguments, we could write `() => { ... }`, instead of
    `function () { ... }`
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它们没有参数，我们可以写`() => { ... }`，而不是`function () { ... }`
- en: With arguments, we could write `(arg1, arg2) => { ... }`, instead of `function
    (arg1, arg2) { ... }`
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有参数的情况下，我们可以写`(arg1, arg2) => { ... }`，而不是`function (arg1, arg2) { ... }`
- en: If we do not use brackets, `{ }`, the result from the statement in the function
    body will also automatically be returned from the function, which is usually not
    an issue with event handlers, though.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不使用括号`{ }`，函数体中的语句的结果也将自动从函数返回，尽管这通常在事件处理程序中不是问题。
- en: 'Then, render two fields to input the username and password, and a button to
    submit the login form:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，渲染两个输入字段来输入用户名和密码，以及一个提交登录表单的按钮：
- en: '[PRE3]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using semantic HTML such as `<form>` and `<label>` makes your app easier to
    navigate for people using accessibility assistance software, such as screen readers.
    Additionally, when using semantic HTML, keyboard shortcuts, such as submitting
    forms by pressing the *Enter*/*Return* key, automatically work. We used the `htmlFor`
    and `id` attributes to make sure screen readers know which input field the label
    belongs to. The `id` prop needs to be unique across the whole page, but for the
    `name` prop, it is enough to be unique within the form.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用语义化HTML，如`<form>`和`<label>`，可以使你的应用对使用辅助软件（如屏幕阅读器）的人更容易导航。此外，当使用语义化HTML时，键盘快捷键，如通过按*Enter*/*Return*键提交表单，将自动工作。我们使用了`htmlFor`和`id`属性来确保屏幕阅读器知道标签属于哪个输入字段。`id`属性在整个页面中必须是唯一的，但对于`name`属性，只要在表单内是唯一的就足够了。
- en: The static `Login` component is now implemented, so let’s render it to see what
    it looks like.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经实现了静态的`Login`组件，让我们渲染它来看看它的样子。
- en: Rendering the Login component
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 渲染登录组件
- en: 'Follow these steps to render the `Login` component:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤渲染`Login`组件：
- en: First, edit `src/App.jsx` and *remove* all existing code from it.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，编辑`src/App.jsx`并*删除*其中的所有现有代码。
- en: 'Then, import the `Login` component, as follows:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，按照以下方式导入`Login`组件：
- en: '[PRE4]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Define and export the `App` component, which simply renders the `Login` component
    for now:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义并导出`App`组件，目前它只是简单地渲染`Login`组件：
- en: '[PRE5]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If we are only returning a single component, we can omit the brackets in the
    `return` statement. Instead of writing `return (<Login />)`, we can simply write
    `return <Login />`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只返回一个组件，我们可以在`return`语句中省略括号。而不是写`return (<Login />)`，我们可以简单地写`return <Login
    />`。
- en: 'Run the `dev` server by opening a terminal (the **Terminal** | **New Terminal**
    menu option in VS Code) and executing the following command:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过打开终端（VS Code中的**终端** | **新终端**菜单选项）并执行以下命令来运行`dev`服务器：
- en: '[PRE6]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Open the link to the dev server in your browser, and you should see the `Login`
    component being rendered. If you change the code, it should refresh automatically,
    so you can keep the dev server running throughout this chapter.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的浏览器中打开dev服务器的链接，你应该会看到`Login`组件正在被渲染。如果你更改代码，它应该会自动刷新，所以你可以在这个章节中一直运行dev服务器。
- en: '![Figure 3.4 – The first component of our blog application: a login with username
    and password](img/B31327_03_04.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4 – 我们博客应用的第一组件：带有用户名和密码的登录](img/B31327_03_04.png)'
- en: 'Figure 3.4 – The first component of our blog application: a login with username
    and password'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 – 我们博客应用的第一组件：带有用户名和密码的登录
- en: As we can see, the static `Login` component renders fine in React.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，静态的`Login`组件在React中渲染良好。
- en: The Register component
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注册组件
- en: The static `Register` component will be very similar to the `Login` component,
    with an additional field to repeat the password. One might get the idea to merge
    them into one component if they are so similar and add a prop to toggle the additional
    field. However, in this case, it is better to have each component deal with only
    one functionality. Later, we are going to extend the static components with dynamic
    code; then, `Register` and `Login` will have vastly different logic and we will
    need to split them up again.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 静态的`Register`组件将与`Login`组件非常相似，多了一个重复密码的字段。如果它们如此相似，有人可能会想到将它们合并为一个组件，并添加一个prop来切换额外字段。然而，在这种情况下，最好让每个组件只处理一个功能。稍后，我们将使用动态代码扩展静态组件；然后，`Register`和`Login`将具有截然不同的逻辑，我们需要再次将它们分开。
- en: 'Nevertheless, let’s start working on the code for the `Register` component:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，让我们开始编写`Register`组件的代码：
- en: Create a new `src/user/Register.jsx` file.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`src/user/Register.jsx`文件。
- en: 'Define a form with **Username** and **Password** fields, similar to the `Login`
    component:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个包含**用户名**和**密码**字段的表单，类似于`Login`组件：
- en: '[PRE7]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Please note that you should prefer spacing via CSS rather than using the `<br
    />` HTML tag. However, we are focusing on the UI structure and integration with
    Hooks in this book, so we simply use HTML whenever possible.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，你应该优先使用CSS进行间距设置，而不是使用`<br />`HTML标签。然而，在这本书中，我们专注于UI结构和与Hooks的集成，因此我们尽可能简单地使用HTML。
- en: 'Next, add a **Repeat password** field:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加一个**重复密码**字段：
- en: '[PRE8]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, add a **Register** button:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加一个**注册**按钮：
- en: '[PRE9]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Again, we can edit `src/App.jsx` to show our new component, as follows:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，我们可以编辑`src/App.jsx`来显示我们的新组件，如下所示：
- en: '[PRE10]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As we can see, the `Register` component looks very similar to the `Login` component,
    but with an additional field and different text on the button.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`Register`组件看起来与`Login`组件非常相似，但多了一个字段，并且按钮上的文本不同。
- en: The Logout component
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注销组件
- en: 'Next, we will define the `Logout` component, which is going to display the
    name of the currently logged-in user, and a button to log out:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义`Logout`组件，该组件将显示当前登录用户的名称，以及一个注销按钮：
- en: Create a new file called `src/user/Logout.jsx`.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`src/user/Logout.jsx`的新文件。
- en: 'Edit the `src/user/Logout.jsx` file and define a component that takes a `username`
    property:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/user/Logout.jsx`文件，并定义一个接受`username`属性的组件：
- en: '[PRE11]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we use **destructuring** to extract the `username` key from the `props`
    object. React passes all component props as the first argument to a function in
    a single object. Using destructuring on the first argument is similar to doing
    `const { username } = this.props` in a class component.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用**解构**从`props`对象中提取`username`键。React将所有组件prop作为单个对象传递给函数的第一个参数。在第一个参数上使用解构类似于在类组件中执行`const
    { username } = this.props`。
- en: 'Inside it, return a form that shows the currently logged-in user and a **Logout**
    button:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中，返回一个表单，显示当前登录用户和一个**注销**按钮：
- en: '[PRE12]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can now replace the `Register` component with the `Logout` component in
    `src/App.jsx` to see our newly defined component (do not forget to pass the `username`
    prop to it!):'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以将`Register`组件替换为`Logout`组件在`src/App.jsx`中，以查看我们新定义的组件（不要忘记传递`username`prop给它！）：
- en: '[PRE13]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now that the `Logout` component is defined, we can move on to the `UserBar`
    component.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经定义了`Logout`组件，我们可以继续编写`UserBar`组件。
- en: The UserBar component
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户栏组件
- en: Now, it is time to put our user-related components together into a `UserBar`
    component, where we are going to conditionally show either the `Login` and `Register`
    components or the `Logout` component, depending on whether the user is already
    logged in or not.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候将我们的用户相关组件组合成一个`UserBar`组件了，我们将根据用户是否已经登录，有条件地显示`Login`和`Register`组件或`Logout`组件。
- en: 'Let’s get started implementing the `UserBar` component:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始实现`UserBar`组件：
- en: Create a new `src/user/UserBar.jsx` file.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`src/user/UserBar.jsx`文件。
- en: 'Inside it, import the `Login`, `Logout`, and `Register` components:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中，导入`Login`、`Logout`和`Register`组件：
- en: '[PRE14]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Define the `UserBar` component and a variable for the `username`. For now,
    we just set it to a static value:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `UserBar` 组件和一个 `username` 变量。目前，我们将其设置为静态值：
- en: '[PRE15]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, we check whether the user is logged in or not. If the user is logged
    in, we display the `Logout` component, and pass the `username` to it:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们检查用户是否已登录。如果用户已登录，我们显示 `Logout` 组件，并将其 `username` 传递给它：
- en: '[PRE16]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Otherwise, we show the `Login` and `Register` components. Here, we can use
    `React.Fragment` (shorthand syntax: `<>` and `</>`) instead of a `<div>` container.
    This keeps our UI tree clean, as the components will simply be rendered side by
    side instead of being wrapped in another element:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，我们显示 `Login` 和 `Register` 组件。在这里，我们可以使用 `React.Fragment`（简写语法：`<>` 和 `</>`）而不是
    `<div>` 容器。这使我们的 UI 树保持清洁，因为组件将简单地并排渲染，而不是被另一个元素包裹：
- en: '[PRE17]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Edit `src/App.jsx` and show the `UserBar` component, as follows:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `src/App.jsx` 并显示 `UserBar` 组件，如下所示：
- en: '[PRE18]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As you can see, the `UserBar` component is successfully rendering the `Login`
    and `Register` components:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`UserBar` 组件成功渲染了 `Login` 和 `Register` 组件：
- en: '![Figure 3.5 – The UserBar component when no user is logged in yet](img/B31327_03_05.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5 – 用户尚未登录时的 UserBar 组件](img/B31327_03_05.png)'
- en: Figure 3.5 – The UserBar component when no user is logged in yet
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 用户尚未登录时的 UserBar 组件
- en: 'You can try editing the static `username` variable to see it render the `Logout`
    component instead. Edit `src/user/UserBar.jsx` and adjust it as follows:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以尝试编辑静态的 `username` 变量，看看它是否会渲染 `Logout` 组件。编辑 `src/user/UserBar.jsx` 并按照以下方式调整：
- en: '[PRE19]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After making this change, the `UserBar` component renders the `Logout` component:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 进行此更改后，`UserBar` 组件将渲染 `Logout` 组件：
- en: '![Figure 3.6 – The UserBar component after defining the username](img/B31327_03_06.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.6 – 定义 username 后的 UserBar 组件](img/B31327_03_06.png)'
- en: Figure 3.6 – The UserBar component after defining the username
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – 定义 username 后的 UserBar 组件
- en: Later in this chapter, we are going to add Hooks to our application, so that
    we can log in and have the state change dynamically, without having to edit the
    code!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将向我们的应用程序添加 Hooks，这样我们就可以动态地登录并改变状态，而无需编辑代码！
- en: Implementing posts
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现帖子
- en: 'After implementing all the user-related components, we can now move on to implementing
    posts in our blog app. We are going to define the following components:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现所有用户相关组件后，我们现在可以继续在我们的博客应用程序中实现帖子。我们将定义以下组件：
- en: A `Post` component to display a single post
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于显示单个帖子的 `Post` 组件
- en: A `CreatePost` component for creating new posts
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于创建新帖子的 `CreatePost` 组件
- en: A `PostList` component to display a list of all posts
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `PostList` 组件用于显示所有帖子的列表
- en: The Post component
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Post` 组件'
- en: We have already thought about which elements a post has when creating the mock-up.
    A post should have a title, content, and an author (the user who wrote the post).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在创建原型时已经考虑了帖子应该包含哪些元素。帖子应该有一个标题、内容和作者（撰写帖子的用户）。
- en: 'Let’s implement the `Post` component now:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来实现 `Post` 组件：
- en: Create a new `src/post/Post.jsx` file.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `src/post/Post.jsx` 文件。
- en: 'Inside it, render all props in a way that resembles the mock-up:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中，以类似于原型的方式渲染所有属性：
- en: '[PRE20]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As always, we can test our component by editing the `src/App.jsx` file:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 和往常一样，我们可以通过编辑 `src/App.jsx` 文件来测试我们的组件：
- en: '[PRE21]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now that the static `Post` component has been implemented, we can move on to
    the `CreatePost` component.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在静态的 `Post` 组件已经实现，我们可以继续进行 `CreatePost` 组件的开发。
- en: The CreatePost component
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建帖子组件
- en: We need to implement a form to create a new post. Here, we pass `username` as
    a prop to the component, as the author should always be the currently logged-in
    user. Then, we show the author and provide an input field for the title and a
    `<textarea>` element for the content of the blog post.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现一个表单来创建新帖子。在这里，我们将 `username` 作为属性传递给组件，因为作者始终是当前登录的用户。然后，我们显示作者并提供一个标题输入字段和一个
    `<textarea>` 元素用于博客帖子的内容。
- en: 'Let’s implement the `CreatePost` component now:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来实现 `CreatePost` 组件：
- en: Create a new `src/post/CreatePost.jsx` file.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `src/post/CreatePost.jsx` 文件。
- en: 'Inside it, define the component according to the mock-up:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中，根据原型定义组件：
- en: '[PRE22]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As always, we can test our component by editing the `src/App.jsx` file, as
    follows:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 和往常一样，我们可以通过编辑 `src/App.jsx` 文件来测试我们的组件，如下所示：
- en: '[PRE23]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As we can see, the `CreatePost` component renders fine. We can now move on to
    the `PostList` component.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`CreatePost` 组件渲染良好。我们现在可以继续进行 `PostList` 组件的开发。
- en: The PostList component
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 帖子列表组件
- en: 'After implementing the other post-related components, we can now implement
    the most important part of our blog app: the feed of blog posts. For now, the
    feed is simply going to show a list of blog posts.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现其他与帖子相关的组件后，我们现在可以实施我们博客应用最重要的部分：博客帖子的流。目前，流将简单地显示博客帖子的列表。
- en: 'Let’s start implementing the `PostList` component now:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们开始实现`PostList`组件：
- en: Create a new `src/post/PostList.jsx` file.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`src/post/PostList.jsx`文件。
- en: 'First, we import `Fragment` and the `Post` component:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入`Fragment`和`Post`组件：
- en: '[PRE24]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, we define the `PostList` function component, accepting a `posts` array
    as a prop. If `posts` is not defined, we set it to an empty array by default:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义接受一个`posts`数组作为属性的`PostList`函数组件。如果`posts`未定义，我们默认将其设置为空数组：
- en: '[PRE25]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we render all posts by using the `.map` function and the spread syntax:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用`.map`函数和展开语法来渲染所有帖子：
- en: '[PRE26]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We return the `<Post>` component for each post and pass all the keys from the
    `post` object to the component as props. We do this by using the spread syntax,
    which has the same effect as listing all the keys from the object manually as
    props, like so:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每个帖子返回`<Post>`组件，并将`post`对象的所有键作为属性传递给组件。我们通过使用展开语法来完成此操作，这具有与手动将对象的所有键作为属性列出相同的效果，如下所示：
- en: '[PRE27]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If we are rendering a list of elements, we have to give each element a unique
    `key` prop. React uses this `key` prop to efficiently compute the difference between
    two lists when the data has changed. It is best practice to use a unique ID for
    the `key` prop, such as a database ID, so that React can keep track of items changing
    in a list. In this case, however, we do not have such an ID, so we simply fall
    back to using the index.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在渲染元素列表，我们必须为每个元素提供一个唯一的`key`属性。React使用这个`key`属性在数据发生变化时高效地计算两个列表之间的差异。使用唯一的ID作为`key`属性的最佳实践，例如数据库ID，这样React可以跟踪列表中变化的项目。然而，在这种情况下，我们没有这样的ID，所以我们简单地回退到使用索引。
- en: 'We used the `map` function, which applies a function to all the elements of
    an array. This is similar to using a `for` loop and storing all the results, but
    it is more concise, declarative, and easier to read! Alternatively, we could do
    the following instead of using the `map` function:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`map`函数，它将一个函数应用于数组的所有元素。这与使用`for`循环并存储所有结果类似，但更简洁、声明性更强，更容易阅读！作为使用`map`函数的替代方案，我们可以这样做：
- en: '[PRE28]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: However, using this style is *not* recommended with React.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，不建议在React中使用这种风格。
- en: 'In the mock-up, we have a horizontal line after each blog post. We can implement
    this without an additional `<div>` container element, by using `Fragment`, as
    follows:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在原型中，每个博客帖子后面都有一个水平线。我们可以通过使用`Fragment`而不添加额外的`<div>`容器元素来实现这一点，如下所示：
- en: '[PRE29]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Using `Fragment` instead of an additional `<div>` container keeps the DOM tree
    clean and reduces the amount of nesting.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Fragment`而不是额外的`<div>`容器元素可以保持DOM树整洁并减少嵌套的数量。
- en: The `key` prop always has to be added to the uppermost parent element that is
    rendered within the `map` function. In this case, we had to move the `key` prop
    from the `Post` component to the `Fragment`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`key`属性必须始终添加到在`map`函数中渲染的最高父元素。在这种情况下，我们必须将`key`属性从`Post`组件移动到`Fragment`。'
- en: 'Again, we test our component by editing the `src/App.jsx` file:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，我们通过编辑`src/App.jsx`文件来测试我们的组件：
- en: '[PRE30]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now, we can see that our app lists all the posts that we defined in the `posts`
    array.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到我们的应用列出了我们在`posts`数组中定义的所有帖子。
- en: As we can see, listing multiple posts via the `PostList` component works fine.
    We can now move on to putting the app together.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，通过`PostList`组件列出多个帖子工作得很好。现在我们可以继续组装应用。
- en: Putting the app together
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组装应用
- en: After implementing all components to reproduce the mock-up, we only have to
    put everything together in the `App` component. Then, we will have successfully
    reproduced the mock-up!
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现所有组件以重现原型后，我们只需在`App`组件中将所有内容组合在一起。然后，我们就成功重现了原型！
- en: 'Let’s start modifying the `App` component and putting our app together:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从修改`App`组件并组装我们的应用开始：
- en: Edit `src/App.jsx` and *remove* all the current code.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/App.jsx`并*删除*所有当前代码。
- en: 'First, import the `UserBar`, `CreatePost`, and `PostList` components:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导入`UserBar`、`CreatePost`和`PostList`组件：
- en: '[PRE31]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, define some mock data for the app:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，为应用定义一些模拟数据：
- en: '[PRE32]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, define the `App` component and return a container with some padding:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，定义`App`组件并返回一个带有一些填充的容器：
- en: '[PRE33]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, render the `UserBar` and `CreatePost` components, passing the `username`
    prop to the `CreatePost` component:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，渲染 `UserBar` 和 `CreatePost` 组件，并将 `username` 属性传递给 `CreatePost` 组件：
- en: '[PRE34]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, display the `PostList` component, passing the `posts` prop to it:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，显示 `PostList` 组件，并将 `posts` 属性传递给它：
- en: '[PRE35]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'After saving the file, the browser should automatically refresh, and we can
    now see the full UI:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件后，浏览器应自动刷新，我们现在可以看到完整的 UI：
- en: '![Figure 3.7 – Full implementation of our static blog app, according to the
    mock-up](img/B31327_03_07.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.7 – 根据原型完全实现我们的静态博客应用程序](img/B31327_03_07.png)'
- en: Figure 3.7 – Full implementation of our static blog app, according to the mock-up
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – 根据原型完全实现我们的静态博客应用程序
- en: As we can see, now, all the static components that we defined earlier are rendered
    together in one `App` component.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，现在，我们之前定义的所有静态组件都在一个 `App` 组件中一起渲染。
- en: '**Example code**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例代码**'
- en: The example code for this section can be found in the `Chapter03/Chapter03_1`
    folder. Check the `README.md` file inside the folder for instructions on how to
    set up and run the example.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 本节示例代码位于 `Chapter03/Chapter03_1` 文件夹中。请检查文件夹内的 `README.md` 文件，了解如何设置和运行示例。
- en: Our app now looks just like the mock-up, so, we can now move on to making all
    the components dynamic using Hooks.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序现在看起来就像原型一样，所以，我们现在可以继续使用 Hooks 来使所有组件动态化。
- en: Implementing stateful components with Hooks
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Hooks 实现状态化组件
- en: Now that we have implemented the static structure of our application, we are
    going to add State Hooks to it to be able to handle state and dynamic interactions!
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了应用程序的静态结构，我们将添加状态 Hooks 来处理状态和动态交互！
- en: 'First, let’s create a new folder for the stateful implementation:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们为状态实现创建一个新的文件夹：
- en: 'Copy the `Chapter03_1` folder to a new `Chapter03_2` folder, as follows:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Chapter03_1` 文件夹复制到新的 `Chapter03_2` 文件夹中，如下所示：
- en: '[PRE36]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Open the new `Chapter03_2` folder in VS Code.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 中打开新的 `Chapter03_2` 文件夹。
- en: Adding Hooks for the user features
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为用户功能添加 Hooks
- en: To add Hooks for the user features, we are going to have to replace the static
    `username` variable with a Hook. Then, we need to adjust the value when we log
    in, register, and log out.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了添加用户功能的 Hooks，我们需要将静态的 `username` 变量替换为一个 Hook。然后，我们需要在登录、注册和注销时调整值。
- en: Adjusting UserBar
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调整用户栏
- en: When we created the `UserBar` component, we statically defined a `username`
    variable. We are now going to replace it with a State Hook!
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建 `UserBar` 组件时，我们静态地定义了一个 `username` 变量。我们现在将用状态 Hook 来替换它！
- en: 'Let’s start modifying the `UserBar` component to make it dynamic:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始修改 `UserBar` 组件，使其动态化：
- en: 'Edit `src/user/UserBar.jsx` and import the `useState` Hook, as follows:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `src/user/UserBar.jsx` 并导入 `useState` Hook，如下所示：
- en: '[PRE37]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '*Remove* the following line of code:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*删除* 以下代码行：'
- en: '[PRE38]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*Replace* it with a State Hook, using an empty username as the default value:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '*替换* 它为一个使用空用户名作为默认值的 State Hook：'
- en: '[PRE39]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, pass the `setUsername` function to the `Logout` component:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将 `setUsername` 函数传递给 `Logout` 组件：
- en: '[PRE40]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: For simplicity and to make it easier to follow where the state is being handled,
    we are passing the `username` and `setUsername` function from the State Hook directly
    down to the other components. In real-world projects, it would be better to use
    specific names for the handlers instead, such as `onLogout`. This reduces coupling
    between components.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化并更容易跟踪状态处理的位置，我们将直接从状态 Hook 将 `username` 和 `setUsername` 函数传递到其他组件。在实际项目中，最好使用特定的名称来命名处理程序，例如
    `onLogout`。这减少了组件之间的耦合。
- en: 'Also, pass the `setUsername` function to the `Login` and `Register` components,
    respectively:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，将 `setUsername` 函数分别传递给 `Login` 和 `Register` 组件：
- en: '[PRE41]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now, the `UserBar` component handles setting the username dynamically. However,
    we still need to modify the other components to add the handlers.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`UserBar` 组件可以动态地设置用户名。然而，我们仍然需要修改其他组件以添加处理程序。
- en: 'Edit `src/user/Logout.jsx` and define a `handleSubmit` function, as follows:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `src/user/Logout.jsx` 并定义一个 `handleSubmit` 函数，如下所示：
- en: '[PRE42]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In React 19, **Form Actions** were introduced as an advanced way of handling
    form submissions. We are going to learn more about Form Actions in [*Chapter 7*](Chapter_07.xhtml#_idTextAnchor169),
    *Using Hooks for Handling Forms*. In this chapter, we will be focusing on using
    the State Hook and the traditional way of handling forms using an `onSubmit` handler
    function.
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在React 19中，**表单操作**被引入作为一种处理表单提交的高级方式。我们将在[*第7章*](Chapter_07.xhtml#_idTextAnchor169)中学习更多关于表单操作的内容，*使用Hooks处理表单*。在本章中，我们将专注于使用State
    Hook和传统的使用`onSubmit`处理函数处理表单的方式。
- en: 'Then, replace the existing `onSubmit` handler with the newly defined function:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，用新定义的函数替换现有的`onSubmit`处理程序：
- en: '[PRE43]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Edit `src/user/Login.jsx` and define a `handleSubmit` function, as follows:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/user/Login.jsx`并定义一个`handleSubmit`函数，如下所示：
- en: '[PRE44]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As we can see, we can directly access the value of the `username` field from
    the form by using `e.target.elements`. The key of the `form` element is equivalent
    to the `name` prop on the `<input>` element.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们可以通过使用`e.target.elements`直接访问表单中`username`字段的值。`form`元素的键等同于`<input>`元素的`name`属性。
- en: 'Edit `src/user/Register.jsx` and define a `handleSubmit` function, as follows:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/user/Register.jsx`并定义一个`handleSubmit`函数，如下所示：
- en: '[PRE45]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: You can now try registering, logging in, and logging out, and see how the state
    changes across components.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以尝试注册、登录和登出，并查看状态在组件间如何变化。
- en: Adding validation
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加验证
- en: When trying out the `login` and `register` features, you may have noticed that
    there is no validation going on. For simple validation, such as required fields,
    we can directly use HTML features. HTML validation will prevent the user from
    submitting the form if a field is invalid and show a popup telling the user what’s
    wrong with it. However, for more complex validation, such as checking whether
    the repeated password is the same, we will need to use a State Hook to keep track
    of the error state of the form.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试`login`和`register`功能时，你可能已经注意到没有进行验证。对于简单的验证，如必填字段，我们可以直接使用HTML功能。HTML验证将阻止用户提交表单，如果字段无效，会弹出一个提示告诉用户哪里出了问题。然而，对于更复杂的验证，如检查重复密码是否相同，我们需要使用State
    Hook来跟踪表单的错误状态。
- en: 'Let’s get started implementing validation now:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始实现验证：
- en: 'Edit `src/user/Login.jsx` and add the `required` prop to the following `input`
    fields:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/user/Login.jsx`并给以下`input`字段添加`required`属性：
- en: '[PRE46]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Edit `src/user/Register.jsx` and add the `required` prop as well:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/user/Register.jsx`并添加`required`属性：
- en: '[PRE47]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In the `src/user/Register.jsx` file, also import the `useState` function:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/user/Register.jsx`文件中，也导入`useState`函数：
- en: '[PRE48]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then, add a new State Hook to keep track of the error state:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加一个新的State Hook来跟踪错误状态：
- en: '[PRE49]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This kind of state is called **local state**, as it is only needed within one
    component.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这种状态被称为**局部状态**，因为它只需要在一个组件内使用。
- en: 'In the `handleSubmit` function, check whether the `password` and `password-repeat`
    fields are the same. If not, set the error state and return from the function:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`handleSubmit`函数中，检查`password`和`password-repeat`字段是否相同。如果不相同，设置错误状态并从函数中返回：
- en: '[PRE50]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Early returns from functions, if a certain condition is not met, are usually
    preferable over nesting `if` clauses. Returning early keeps the function easy
    to read and avoids problems where code is accidentally executed.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不满足某些条件，函数的早期返回通常比嵌套`if`语句更可取。早期返回使函数易于阅读，并避免代码意外执行的问题。
- en: 'After the `if` clause, if the passwords are the same, reset the error state
    and process the registration:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`if`语句之后，如果密码相同，重置错误状态并处理注册：
- en: '[PRE51]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'At the end of the form, before the **Register** button, we insert an error
    message if the error state got triggered:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在表单末尾，在**注册**按钮之前，如果错误状态被触发，我们插入一条错误信息：
- en: '[PRE52]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'If we try registering now but do not properly repeat the password, we can see
    the following error message:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在尝试注册但密码没有正确重复，我们可以看到以下错误信息：
- en: '![Figure 3.8 – Validation and an error message implemented using Hooks](img/B31327_03_08.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图3.8 – 使用Hooks实现的验证和错误信息](img/B31327_03_08.png)'
- en: Figure 3.8 – Validation and an error message implemented using Hooks
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 – 使用Hooks实现的验证和错误信息
- en: Now that we have successfully implemented validation, we can move on to passing
    the username to the `CreatePost` component.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功实现了验证，我们可以继续将用户名传递给`CreatePost`组件。
- en: Passing the user to CreatePost
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将用户传递给CreatePost
- en: 'As you might have noticed, the `CreatePost` component still uses the hardcoded
    username. To be able to access the username there, we need to move the Hook from
    the `UserBar` component up into the `App` component:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经注意到的，`CreatePost`组件仍然使用硬编码的用户名。为了能够在那里访问用户名，我们需要将钩子从`UserBar`组件移动到`App`组件中：
- en: 'Edit `src/user/UserBar.jsx` and *cut/remove* the following Hook definition:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/user/UserBar.jsx`并*剪切/删除*以下钩子定义：
- en: '[PRE53]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then, adjust the function definition to accept these two as props:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，调整函数定义以接受这两个属性：
- en: '[PRE54]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '*Remove* the following `useState` import:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*删除*以下`useState`导入：'
- en: '[PRE55]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, edit `src/App.jsx` and import the `useState` function there:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编辑`src/App.jsx`并从那里导入`useState`函数：
- en: '[PRE56]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '*Remove* the following line of code:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*删除*以下代码行：'
- en: '[PRE57]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Inside the `App` function component, add the Hook we removed earlier:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`App`函数组件内部，添加我们之前移除的钩子：
- en: '[PRE58]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This kind of state is called **global state**, as it is needed across multiple
    components throughout the blog app, which is also why we moved the State Hook
    up into the `App` component.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这种状态被称为**全局状态**，因为它在整个博客应用中的多个组件中都需要，这也是为什么我们将状态钩子移动到`App`组件中的原因。
- en: 'Then, pass down the `username` value and `setUsername` function to the `UserBar`
    component:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将`username`值和`setUsername`函数传递给`UserBar`组件：
- en: '[PRE59]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In [*Chapter 5*](Chapter_05.xhtml#_idTextAnchor127), *Implementing React Contexts*,
    we are going to learn a better solution to provide the logged-in state to other
    components. For now, we are just going to pass down the value and function, though.
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在[*第五章*](Chapter_05.xhtml#_idTextAnchor127)《实现React上下文》中，我们将学习一个更好的解决方案来将登录状态提供给其他组件。现在，我们只是将值和函数传递下去。
- en: 'Finally, make sure the `CreatePost` component is only rendered when the user
    is logged in (`username` is defined):'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，确保`CreatePost`组件仅在用户登录时渲染（`username`已定义）：
- en: '[PRE60]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Now that the user features are fully implemented, we can move on to using Hooks
    to implement the post features!
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用户功能已完全实现，我们可以继续使用钩子来实现帖子功能！
- en: Adding Hooks for the post features
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为帖子功能添加钩子
- en: After implementing the user features, we are now going to implement the dynamic
    creation of posts. We do so by first adjusting the `App` component, then we modify
    the `CreatePost` component to be able to insert new posts.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现了用户功能之后，我们现在将实现帖子的动态创建。我们首先调整`App`组件，然后修改`CreatePost`组件以能够插入新帖子。
- en: Adjusting the App component
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调整`App`组件
- en: Similar to the `username` state, we are going to define `posts` as a global
    state in the `App` component and provide it to other components from there.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 与`username`状态类似，我们将在`App`组件中定义`posts`作为全局状态，并从那里提供给其他组件。
- en: 'Let’s get started adjusting the `App` component:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始调整`App`组件：
- en: 'Edit `src/App.jsx` and rename the current `posts` array to `defaultPosts`:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/App.jsx`并将当前的`posts`数组重命名为`defaultPosts`：
- en: '[PRE61]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Then, define a new Hook for the `posts` state inside of the `App` function:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`App`函数内部定义一个新的`posts`状态钩子：
- en: '[PRE62]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, pass `setPosts` as a prop to the `CreatePost` component:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`setPosts`作为属性传递给`CreatePost`组件：
- en: '[PRE63]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: After providing the state to the `CreatePost` component, let’s continue by adjusting
    it.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在将状态提供给`CreatePost`组件后，让我们继续调整它。
- en: Adjusting the CreatePost component
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调整`CreatePost`组件
- en: 'We now need to use the `setPosts` function to insert a new post when the **Create**
    button is pressed, as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要使用`setPosts`函数在按下**创建**按钮时插入一个新的帖子，如下所示：
- en: 'Edit `src/post/CreatePost.jsx` and adjust the function definition to accept
    the `setPosts` prop:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/post/CreatePost.jsx`并调整函数定义以接受`setPosts`属性：
- en: '[PRE64]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Next, define a `handleSubmit` function, in which we first gather all the values
    we need:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，定义一个`handleSubmit`函数，在其中我们首先收集所有需要的值：
- en: '[PRE65]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Here, we shortened the `{ title: title }` object assignment to `{ title }`,
    which has the same effect.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，我们将`{ title: title }`对象赋值简写为`{ title }`，它们具有相同的效果。'
- en: 'Then, we insert the new post into the array:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将新帖子插入到数组中：
- en: '[PRE66]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Here, we are using a function to get the current value of the State Hook, then
    returning a new value with the new post inserted into the array.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用一个函数来获取状态钩子的当前值，然后返回一个新值，其中包含插入到数组中的新帖子。
- en: 'Finally, we reset the form to clear all input fields:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将重置表单以清除所有输入字段：
- en: '[PRE67]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We still need to assign the newly defined function to the `onSubmit` handler,
    as follows:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们仍然需要将新定义的函数分配给`onSubmit`处理程序，如下所示：
- en: '[PRE68]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Now, we can log in and create a new post, and it will be inserted at the beginning
    of the feed!
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以登录并创建一个新的帖子，它将被插入到动态流的开始处！
- en: '![Figure 3.9 – The first version of our blog app using Hooks, after inserting
    a new post](img/B31327_03_09.png)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![图3.9 – 使用Hooks插入新帖子后的我们的博客应用的第一版](img/B31327_03_09.png)'
- en: Figure 3.9 – The first version of our blog app using Hooks, after inserting
    a new post
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 – 使用Hooks插入新帖子后的我们的博客应用的第一版
- en: '**Example code**'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例代码**'
- en: The example code for this section can be found in the `Chapter03/Chapter03_2`
    folder. Check the `README.md` file inside the folder for instructions on how to
    set up and run the example.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 本节示例代码可在`Chapter03/Chapter03_2`文件夹中找到。请检查文件夹内的`README.md`文件，以获取设置和运行示例的说明。
- en: Summary
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we developed our own blog application from scratch! We started
    with a mock-up and then created static components to resemble it. Afterward, we
    implemented Hooks to allow for dynamic behavior. Throughout the chapter, we learned
    how to deal with local and global state using Hooks. Furthermore, we learned how
    to use multiple Hooks, and in which components to define Hooks and store state.
    We also learned how to solve common use cases, such as form validation and submission.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从零开始开发了自己的博客应用！我们从一个原型开始，然后创建了静态组件来模拟它。之后，我们实现了Hooks以允许动态行为。在整个章节中，我们学习了如何使用Hooks处理本地和全局状态。此外，我们学习了如何使用多个Hooks，以及在哪些组件中定义Hooks和存储状态。我们还学习了如何解决常见用例，例如表单验证和提交。
- en: In the next chapter, [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor103), *Using
    the Reducer and Effect Hooks*, we are going to learn about the Reducer Hook, which
    allows us to deal with certain state changes more easily. Furthermore, we are
    going to learn about the Effect Hook, which allows us to run code with side effects.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，[*第4章*](Chapter_04.xhtml#_idTextAnchor103)，*使用Reducer和Effect钩子*，我们将学习Reducer钩子，它使我们能够更容易地处理某些状态变化。此外，我们还将学习Effect钩子，它允许我们运行具有副作用代码。
- en: Questions
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'To recap what we have learned in this chapter, try to answer the following
    questions:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回顾本章学到的内容，尝试回答以下问题：
- en: What are good ways to structure folders in React?
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在React中，有哪些好的文件夹结构方式？
- en: Which principle should we use when splitting up React components?
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在拆分React组件时，我们应该使用哪个原则？
- en: What does the `map` function do?
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`map`函数的作用是什么？'
- en: How does destructuring work, and when do we use it?
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解构是如何工作的，我们何时使用它？
- en: How does the spread operator work, and when do we use it?
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展运算符是如何工作的，我们何时使用它？
- en: How do we deal with form validation and submission?
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何处理表单验证和提交？
- en: Where should local State Hooks be defined?
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该在哪里定义本地状态钩子？
- en: What is global state?
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是全局状态？
- en: Where should global State Hooks be defined?
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该在哪里定义全局状态钩子？
- en: Further reading
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'If you are interested in more information about the concepts that we have learned
    in this chapter, take a look at the following link:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对本章学到的概念有更多兴趣，请查看以下链接：
- en: 'Official docs on *Thinking in React*: [https://react.dev/learn/thinking-in-react](https://react.dev/learn/thinking-in-react)'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*思考React*的官方文档：[https://react.dev/learn/thinking-in-react](https://react.dev/learn/thinking-in-react)'
- en: Learn more on Discord
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Discord上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入这本书的Discord社区——在那里你可以分享反馈，向作者提问，并了解新版本——请扫描下面的二维码：
- en: '[https://packt.link/wnXT0](Chapter_03.xhtml)'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/wnXT0](Chapter_03.xhtml)'
- en: '![](img/image_%283%29.png)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_%283%29.png)'
