- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Performance Optimization in Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Performance is always a concern in any product that you build for end users.
    It is a critical element in increasing the chances of someone using your app for
    the first time becoming a customer. Now, we can’t really improve an app’s performance
    until we identify potential possibilities for improvement and the methods to achieve
    this. In this chapter, you’ll learn some methods to deploy when it comes to improving
    Angular applications. You’ll learn how to analyze, optimize, and improve your
    Angular app’s performance using several techniques. Here are the recipes we’re
    going to cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `OnPush` change detection to prune component subtrees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detaching the change detector from components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running `async` events outside Angular with `runOutsideAngular`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `trackBy` for lists with `*ngFor`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving heavy computation to pure pipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using web workers for heavy computation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using performance budgets for auditing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing bundles with `webpack-bundle-analyzer`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the recipes in this chapter, ensure your setup is complete as per the ''Technical
    Requirements'' in the ''Angular-Cookbook-2E'' GitHub repository. For setup details,
    visit: [https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/docs/technical-requirements.md](https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/docs/technical-requirements.md).
    The starter code for this chapter is located at [https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/start/apps/chapter12](https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/start/apps/chapter12).'
  prefs: []
  type: TYPE_NORMAL
- en: Using OnPush change detection to prune component subtrees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In today’s world of modern web applications, performance is one of the key factors
    for a great **User Experience** (**UX**) and, ultimately, conversions for a business.
    In this recipe, the first recipe of this chapter, we’re going to discuss the fundamental
    or the most basic optimization you can do with your components wherever it seems
    appropriate, which is by using the `OnPush` change detection strategy. The app
    we’re working with has some performance issues, particularly with the `UserCardComponent`
    class. This is because it uses a getter function, `randomColor`, to generate a
    random color for its background. Behind the scenes, that function uses a `factorial`
    function to add more processing time. But that is just to demonstrate a component
    that can cause the UI to hang if there is some complex calculation happening,
    along with multiple change detections being triggered.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with resides in `start/apps/chapter12/ng-on-push-strategy`
    inside the cloned repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should open the app in a new browser tab, and you should see the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_12_01.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 12.1: The ng-on-push-strategy app running at http://localhost:4200'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click the button that says **Click Me** or try to search for some user. You’ll
    see that the app is too slow and often hangs. Now that we have the project served
    on the browser, let’s see the steps of the recipe in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’re going to add some code to monitor how many times the `randomColor` getter
    gets called. This will show the number of times the change detection in Angular
    gets triggered by default. We will also fix the issue and make it more performant
    (as much as we can) using the `OnPush` change detection strategy. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s make sure that the app is not too slow for your machine so that
    it makes your laptop/PC hang. Open the `src/app/app.config.ts` file and adjust
    the value of the `RANDOMIZATION_COUNT` token from `9` to whatever suits you best.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then try to search for a user named `Irineu` by entering their name in the search
    box. You’ll notice that the app still hangs and that it takes a few seconds to
    show the user. You’ll also notice that you don’t even see the typed letters in
    the search box as you type them. That is, there is a delay in rendering.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s add some logic to the code. We’ll check how many times Angular calls the
    `idUsingFactorial` method when the page loads.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s create a service that we will use to track the number of times a particular
    user card for a particular person is called. Run the following command from the
    workspace’s root folder to create a service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Choose `@schematics/angular:service` when asked.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the content of the `src/app/services/logs.service.ts` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, inject the `LogService` in the `src/app/component/user-card/user-card.component.ts`
    file. We will also create a getter (`log`) function to get the count for the user,
    and we will update the count whenever the `randomColor` getter is called. Update
    the mentioned file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will use the log in the template of the user card component to show
    the count. Update the `src/app/component/user-card/user-card.component.html` file
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you look at the application now, you should see the **Color Generation Count**
    as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_12_02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 12.2: Color Generation Count being shown on page load'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, click the **Click Me** button. Then, focus (click) the **Quick Search**
    input and then click outside. Repeat this a few times and you should see that
    the colors are regenerated even though the cards are not supposed to be re-rendered.
    *Figure 12.3* shows how it should look:![](img/B18469_12_03.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 12.3: Logs after interacting with the app without searching for anything'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Notice that if you start searching for something, you’ll get even more re-renders.
    That’s because each key up and/or key down event will trigger more re-renders.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To fix the issue, we will use the `OnPush` strategy and see how it changes
    the behavior of the user card component with respect to Angular’s change detection
    strategy. Update the `user-card.component.ts` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, if you try clicking the **Click Me** button, focus in the search input
    and click outside, or do whatever else (apart from searching for users), you will
    see no change in the **Color Generation Count** for the cards, as shown in *Figure
    12.4*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_12_04.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 12.4: The OnPush strategy preventing unnecessary renders'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Great! By using the `OnPush` strategy, we were able to improve the overall performance
    of our `UserCardComponent`. The rest was just for fun. Now you know how to use
    this strategy, see the next section to understand how it works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Angular by default uses the `Default` change detection strategy—or technically,
    it is the `ChangeDetectionStrategy.Default` enum from the `@angular/core` package.
    Since Angular doesn’t know about every component we create, it uses the default
    strategy to not encounter any surprises. This means that the framework will check
    for changes in the whole component tree whenever something might have changed.
    This might include user events, timers, XHRs, promises, etc. In a complex UI with
    lots of bindings, this can lead to performance degradation, especially when most
    of these components don’t change frequently or depend only on specific inputs.
  prefs: []
  type: TYPE_NORMAL
- en: But as developers, if we know that a component will not change unless one of
    its `@Input()` variables changes, we can—and we should—use the `OnPush` change
    detection strategy for that component. Why? Because it tells Angular to not run
    change detection until an `@Input()` variable for the component changes. This
    strategy is an absolute winner for presentational components (sometimes called
    `dumb` components), which are just supposed to show data using `@Input()` variables/attributes
    and emit `@Output()` events on interactions. These presentational components usually
    do not hold any business logic such as heavy computation, using services to make
    **HTTP** calls, and so on. Therefore, it is easier for us to use the `OnPush`
    strategy in these components because they would only show different data when
    any of the `@Input()` attributes from the parent component change, that is, their
    reference should change. For example, if we had an array of users, there should
    be a completely new array now in order to run the change detection. If it is the
    same array but we have only added or removed an item, change detection with `OnPush`
    will not be triggered.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are now using the `OnPush` strategy on our `UserCardComponent`, it
    only triggers change detection when we replace the entire `users` array upon searching.
    This happens after the `500ms` debounce (*line 31* in the `users.component.ts`
    file), so we only do it when the user stops typing. So, essentially, before the
    optimization, the default change detection was triggering on each keypress being
    a browser event, and now, it doesn’t.
  prefs: []
  type: TYPE_NORMAL
- en: IMPORTANT NOTE
  prefs: []
  type: TYPE_NORMAL
- en: As you now know, the `OnPush` strategy only triggers the Angular change detection
    mechanism when one or more of the `@Input()` bindings changes. This means that
    if we change a property within the component (`UserCardComponent`), it will not
    be reflected in the view because the change detection mechanism won’t run in this
    case, since that property isn’t an `@Input()` binding. You would have to mark
    the component as dirty so that Angular could check the component and run change
    detection. You’ll do this using the `ChangeDetectorRef` service—specifically,
    with the `markForCheck` method.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Angular `ChangeDetectionStrategy` official documentation: [https://angular.io/api/core/ChangeDetectionStrategy](https://angular.io/api/core/ChangeDetectionStrategy)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `markForCheck` method official documentation: [https://angular.io/api/core/ChangeDetectorRef#markforcheck](https://angular.io/api/core/ChangeDetectorRef#markforcheck
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detaching the change detector from components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we learned how to use the `OnPush` strategy in our components
    to avoid Angular change detection running unless one of the `@Input()` bindings
    has changed. There is, however, another way to tell Angular to not run change
    detection at all for a particular component and its subtree. This cuts the component
    and its subtree from the change detection cycle completely, as shown in *Figure
    12.5*, which can result in an increase in the overall performance. This is also
    handy when you want full control of when to run change detection. In this recipe,
    you’ll learn how to completely detach the change detector from an Angular component
    to gain performance improvements.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18469_12_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.5: Change detector detached from component tree'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with resides in `start/apps/chapter12/ng-cd-ref`
    inside the cloned repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should open the app in a new browser tab, and you should see the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_12_06.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 12.6: The ng-cd-ref app running at http://localhost:4200'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click the button that says **Click Me** Or try to search for some user. You’ll
    see that the app is too slow and often hangs. Now that we have the project served
    on the browser, let’s see the steps of the recipe in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app we’re working with has some performance issues, particularly with the
    `UserCardComponent` class. This is because it uses a getter function, `randomColor`,
    to generate a random color for its background. Behind the scenes, that function
    uses a `factorial` function to add more processing time. But that is just to demonstrate
    a component that can cause the UI to hang if there is some complex calculation
    happening along with multiple change detections being triggered. We’re going to
    add some code to monitor how many times the `randomColor` getter gets called.
    This will show the number of times the change detection in Angular gets triggered
    by default. We will also fix the issue and make it more performant (as much as
    we can) by detaching the change detector completely from a particular component.
    Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s make sure that the app is not too slow for your machine so that
    it makes your laptop/PC hang. Open the `src/app/app.config.ts` file and adjust
    the value of the `RANDOMIZATION_COUNT` token from `9` to whatever suits you best.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then try to search for a user named `Irineu` by entering their name in the search
    box. You’ll notice that the app still hangs and that it takes a few seconds to
    show the user. You’ll also notice that you don’t even see the letters in the search
    box as you type them. That is, there is a delay in rendering.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s add some logic to the code. We’ll check how many times Angular calls the
    `idUsingFactorial` method when the page loads.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s create a service that we will use to track the number of times a particular
    user card for a particular person is called. Run the following command from the
    workspace’s root folder to create a service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Choose `@schematics/angular:service` when asked.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the content of the `src/app/services/logs.service.ts` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, inject the `LogService` in the `src/app/component/user-card/user-card.component.ts`
    file. We will also create a getter (`log`) function to get the count for the user,
    and we will update the count whenever the `randomColor` getter is called. Update
    the mentioned file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will use the log in the template of the user card component to show
    the count. Update the `src/app/component/user-card/user-card.component.html` file
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you look at the application now, you should see the **Color Generation Count**
    as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_12_07.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 12.7: Color Generation Count being shown on page load'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, click the **Click Me** button. Then focus (click) the **Quick Search**
    input and then click outside. Repeat this a few times and you should see that
    the colors are regenerated even though the cards are not supposed to be re-rendered.
    *Figure 12.8* shows how it should look:![](img/B18469_12_08.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 12.8: Logs after interacting with the app without searching for anything'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Notice that if you start searching for something, you’ll get even more re-renders.
    That’s because each key up and/or key down event will trigger more re-renders.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To fix the issue, we will detach the change detector reference from the `user-card`
    components when the component loads so there is no re-render afterward. This is
    assuming that the content of the card never changes. Update the `user-card.component.ts`
    file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, if you try clicking the **Click Me** button, focus on the search input
    and click outside, or do whatever else (apart from searching for users), you will
    see no change in the **Color Generation Count** for the cards, as shown in *Figure
    12.9*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_12_09.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 12.9: Detached change detector preventing unnecessary renders'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: But what if something had to change in the components later? How do we get full
    control over the change detection?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s assume that the app has a feature that changes the user’s name. We’ll
    hardcode the logic to change the last name of the first user. In this case, we
    would have to tell Angular to run the change detection. Let’s update the `users.component.html`
    file to update the **Click Me** button in the `src/app/users/users.component.html`
    file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s update the TypeScript file to add the function that updates the user’s
    name. Update the `src/app/users/users.component.ts` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you click the **Update Irineu’s Name** button, you’ll see no change in the
    UI. That is because the change detector is still detached from each user card
    component. So, the name changes, but you can’t see the change on the UI. See *Figure
    12.10*, in which the Angular (Chrome) DevTools show the value being updated in
    the component, but the UI doesn’t reflect it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_12_10.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 12.10: User card not re-rendering due to detached change detector'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To fix the issue, we will query the `UserCard` components on the users page
    and will manually run the `ChangeDetectorRef.detectChanges` method on the desired
    component. Update the `src/app/users/users.component.ts` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, if you click the **Update Irineu’s Name** button four times, you should
    see the count of the first user card to be `5`, while the rest of the cards still
    render `1` time, as shown in *Figure 12.11*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_12_11.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 12.11: Fully controlled change detection'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Great! Within a few steps, by using the `ChangeDetectorRef` service from Angular,
    we were able to improve the overall performance of our `UserCardComponent`. Not
    only did we improve it, but we also fully controlled it from the parent component
    (`UsersComponent`) according to our use case. Now you know how to use the `ChangeDetectorRef`
    service, see the next section to understand how it works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ChangeDetectorRef` service provides a range of important methods to control
    change detection in Angular. In the recipe, we use the `detach` method in our
    component’s (`UserCardComponent` class’s) `ngAfterViewInit` method to detach the
    Angular change detection mechanism from the component as soon as it is rendered
    for the first time. As a result, no change detection is triggered on the `UserCardComponent`
    class. This is because Angular has a change detection tree in which each component
    is a node. When we detach a component from the change detection tree, that component
    (as a tree node) is detached, and so are its child components (or nodes). By doing
    this, we end up with absolutely no change detection happening for the `UserCardComponent`
    class. If there were any other components being used in the `UserCardComponent`,
    they would not have the change detection run for them either. As a result, when
    we click the button or focus and blur the input on the users page, nothing is
    rendered, even after we update the first user’s name as we did in the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, when we need to show the changed name of the first user on the
    view, which requires the Angular change detection mechanism to be triggered, we
    use the `detectChanges` method from the `ChangeDetectorRef` instance, right after
    we’ve assigned the updated users array to the `users` property in the `UsersComponent`
    class. As a result, Angular runs the change detection mechanism, and we see the
    updated name on the first user card. This gives us the ultimate power to decide
    whether we want to detach the change detection completely, reattach it, or manually
    run it for the only cases that require change detection.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand how the recipe works, see the next section for some
    useful links.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ChangeDetectorRef` official documentation: [https://angular.io/api/core/ChangeDetectorRef](https://angular.io/api/core/ChangeDetectorRef
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running async events outside Angular with runOutsideAngular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Angular runs its change detection mechanism on a couple of things, including—but
    not limited to—all browser events, such as `keyup`, `keydown`, `click`, and so
    on. It also runs change detection on `setTimeout`, `setInterval`, and Ajax HTTP
    calls. If we had to avoid running change detection on any of these events, we’d
    have to tell Angular not to trigger change detection on them—for example, if you
    use the `setInterval` method in your Angular component, it will trigger an Angular
    change detection cycle each time its callback method is called. This can lead
    to a huge amount of change detection cycles and your app might even hang. An ideal
    situation would be to be able to still use the `setInterval` method and so on
    without triggering the change detection. In this recipe, you’ll learn how to do
    exactly that. You will learn how to execute code blocks outside of `zone.js` using
    the `NgZone` service, particularly using the `runOutsideAngular` method. See *Figure
    12.12* to understand the structure of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18469_12_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.12: Component hierarchy for the ng-run-outside-angular app'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with resides in `start/apps/chapter12/ng-run-outside-angular`
    inside the cloned repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should open the app in a new browser tab, and you should see the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_12_13.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 12.13: The ng-run-outside-angular app running on http://localhost:4200'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have the app running, let’s see the steps of the recipe in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have an app that shows a watch. However, the change detection right now
    in the app is not optimal, and we have plenty of room for improvement. We’ll try
    to remove any unnecessary change detection using the `runOutsideAngular` method
    from `ngZone`. Let us get started:'
  prefs: []
  type: TYPE_NORMAL
- en: The clock values are constantly updating. Thus, we have change detection running
    for each update cycle. Open the Chrome DevTools and switch to the **Console**
    tab. Type **appLogs** and press *Enter* to see how many times the change detection
    has run for `WatchComponent` and for the components rendering hours, minutes,
    seconds, and milliseconds. It should look like this:![](img/B18469_12_14.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 12.14: The appLogs object reflecting the number of change detection
    runs'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To measure performance, let’s reduce our observation span in terms of time.
    Let us add some code to turn off the interval timer in 4 seconds from the app’s
    start for the clock. Modify the `watch-box.component.ts` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Refresh the app and wait for 4 seconds for the clock to stop. Then, type `appLogs`
    multiple times in the **Console** tab, press *Enter*, and see the results. The
    clock stops but the animation is still running. You should see that change detection
    for the **watchComponentRender** key still increases, as follows:![](img/B18469_12_15.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 12.15: Change detection still running for the watch component'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s also stop the animation inside the watch after 4 seconds. Update the
    `watch.component.ts` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Refresh the app and wait for the animation to stop. Have a look at the `appLogs`
    object in the Chrome DevTools. You should see that change detection stops for
    the `watch` key, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_12_16.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 12.16: Change detection stops after we stop the animation interval'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The desired outcome is to keep running the animation and the clock and not
    have additional change detection cycles running. For this, let’s just stop the
    watch for now. To do that, update the `watch-box.component.ts` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Since we have now stopped the clock, the values for `appLogs` for the `watchComponentRender`
    key are now only based on the animation for these 4 seconds. Refresh the app and
    wait for the animation to stop. Type `appLogs` in the Chrome DevTools (in the
    **Console** tab). You should now see a value between `250` and `270` for the `watchComponentRender`
    key.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let us avoid running change detection on the animation by running the interval
    outside the `ngZone` service. We will use the `runOutsideAngular` method for this.
    Update the `watch.component.ts` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Refresh the app and wait for about 5 seconds. If you check the `appLogs` object
    now, you should see a decrease in the overall number of change detection runs
    for each of the properties, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_12_17.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 12.17: The appLogs object after using runOutsideAngular() in WatchComponent'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Yay! Notice that the value for the `watch` key in the `appLogs` object has decreased
    from about `260` to `4` now. This means that our animation now does not contribute
    to change detection at all, and the `watch` component only renders 4 times in
    4 seconds.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Remove the usage of `clearInterval` from the animation for the `WatchComponent`
    class. Thus, the background circle (blue circle) animation should start again.
    Modify the `watch.component.ts` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, remove the usage of `clearInterval` from the `WatchBoxComponent` class
    and uncomment `setInterval` to run the clock. Update the `watch-box.component.ts`
    file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Refresh the app and check the value of the `appLogs` object after a few seconds,
    multiple times. You should see something like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_12_18.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 12.18: The appLogs object after performance optimization with runOutsideAngular()'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Looking at the preceding screenshot, you might ask, “*Ahsan! What is this? We
    still have an enormous number for the change detection runs for the* `watchComponentRender`
    *key compared to the milliseconds passed. How is this performant exactly?*” Glad
    you asked! I will tell you why in the *How it works…* section.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As a last step, stop the Angular server and run the following command to start
    the server in production mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate to `https://localhost:4200` again. Wait for a few seconds and then
    check the `appLogs` object in the **Console** tab multiple times. You should see
    the object, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18469_12_19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.19: The appLogs object using the production build'
  prefs: []
  type: TYPE_NORMAL
- en: Boom! If you look at the preceding screenshot, you should see that the change
    detection run count for the `watchComponentRender` key is always just a few cycles
    more than the `milliseconds` key. This means that the `WatchComponent` class is
    (almost) only re-rendered whenever we have the value of the `@Input()` `milliseconds`
    binding updated. But why a few cycles more? See the next section to understand
    how it works!
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we begin by looking at the `appLogs` object, which contains
    some key-value pairs. The value for each key-value pair represents the number
    of times Angular ran change detection for a particular component. The `hours`,
    `milliseconds`, `minutes`, and `seconds` keys represent the `WatchTimeComponent`
    instance for each of the values shown on the clock. The `watchComponentRender`
    key represents the `WatchComponent` instance’s change detection cycles.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the beginning of the recipe, we see that the value of the `watch` key is
    more than twice the value of the `milliseconds` key. Why do we care about the
    `milliseconds` key at all? Because the `@Input()` attribute binding `milliseconds`
    changes most frequently in our application—that is, it changes every 1 **Millisecond**
    (**ms**). The second most frequently changed values are the `xCoordinate` and
    `yCoordinate` properties within the `WatchComponent` class, which change every
    30 ms. The `xCoordinate` and `yCoordinate` values are not bound directly to the
    template (the HTML) because they change the **CSS** variables of the `stopWatch`
    view child. This happens inside the `animate` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Thus, changing these values should not trigger change detection. We begin by
    limiting the testing time to run the clock, using the `clearInterval` method in
    the `WatchBoxComponent` class so that the clock stops within 4 seconds, and we
    can evaluate the numbers. In *Figure 12.15*, we see that even after the clock
    stops, the change detection mechanism keeps triggering for the `WatchComponent`
    class. This increases the count for the `watch` key in the `appLogs` object as
    time passes. We then stop the animation by using `clearInterval` in the `WatchComponent`
    class. This stops the background (blue circle) animation after 4 seconds as well.
    In *Figure 12.16*, we see that the count for the `watch` key stops increasing
    after the animation stops.
  prefs: []
  type: TYPE_NORMAL
- en: We then try to see the count of change detection only based on the animation.
    In *step 6*, we stop the clock. Therefore, we only get a count based on the animation
    in the `appLogs` object for the `watch` key, which is a value between `250` and
    `270`.
  prefs: []
  type: TYPE_NORMAL
- en: We then introduce the magic `runOutsideAngular` method into our code. This method
    is part of the `NgZone` service. The `NgZone` service is packaged with the `@angular/core`
    package. The `runOutsideAngular` method accepts a method as a parameter. This
    method is executed outside the Angular zone. This means that the `setTimeout`
    and `setInterval` methods used inside the `runOutsideAngular` method do not trigger
    the Angular change detection cycle. But technically, why are we running this `setInterval`
    outside the zone? Because our interval calls the `animate` method, which updates
    the CSS variables `--x` and `--y`. And since they automatically trigger the animation
    and no other property of the `WatchComponent` class must be shown in the UI (requiring
    a re-render), we can move this code to the `runOutsideAngular` method. You can
    see in *Figure 12.17* that the count drops to `4` after using the `runOutsideAngular`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: We then remove the `clearInterval` usage from both the `WatchBoxComponent` and
    the `WatchComponent` classes—that is, to run the clock and the background (blue
    circle) animation again, as we did in the beginning. In *Figure 12.18*, we see
    that the count for the `watch` key is around twice the value of the `milliseconds`
    key. Now, why exactly is it that it’s around double? This is because, in development
    mode, Angular runs the change detection mechanism *twice* to ensure there are
    no *side effects*. For example, an update to a `state` property initiating a change
    detection in another (child) component, and so on. Therefore, in *step 9* and
    *step 10*, we run the application in production mode, and in *Figure 12.19*, we
    see that the value for the `watch` key is just a few cycles greater than the value
    for the `milliseconds` key, which means that the animation does not trigger any
    change detection for our application anymore.
  prefs: []
  type: TYPE_NORMAL
- en: But why does the `watchComponentRender` key have a few more cycles compared
    to the `milliseconds` key? That is because the `WatchComponent` is the parent
    component of the component displaying milliseconds (`WatchTimeComponent`). There
    could be a few change detection cycles based on browser interactions, but if you
    refresh the app and have no interaction at all with the app, the difference between
    `watchComponentRender` to the milliseconds count would be as low as one change
    detection cycle in production mode.
  prefs: []
  type: TYPE_NORMAL
- en: Brilliant, isn’t it? If you find this recipe useful, do let me know on my socials.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand how it works, see the next section for further reading.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `NgZone` official documentation: [https://angular.io/api/core/NgZone](https://angular.io/api/core/NgZone)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Angular `ChangeDetectorRef` official documentation: [https://angular.io/api/core/ChangeDetectorRef](https://angular.io/api/core/ChangeDetectorRef)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using trackBy for lists with *ngFor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lists are an essential part of most of the apps we build today. If you’re building
    an Angular app, there’s a great chance you will use the `*ngFor` directive at
    some point for rendering lists. The `*ngFor` directive allows us to loop over
    arrays or objects generating HTML for each item. However, if we are rendering
    large lists, using `*ngFor` without caution may cause performance issues, especially
    when the source for `*ngFor` is changed completely (the entire array is replaced).
    In this recipe, we’ll learn how we can improve the performance of lists using
    the `*ngFor` directive with the `trackBy` function. Let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with resides in `start/apps/chapter12/ng-for-trackby`
    inside the cloned repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should open the app in a new browser tab, and you should see the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_12_20.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 12.20: The ng-for-trackby app running on http://localhost:4200'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have the app running, let’s see the steps of the recipe in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have an app that has a list of 10,000 users displayed on the view. Since
    we’re not using a virtual scroll (from `@angular/material`, for example), and
    are using a standard `*ngFor` list, we do face some performance issues now. Notice
    that when you refresh the app, even after the loader is hidden, you see a blank
    white box for about 2–3 seconds before the list appears. If your machine is stuck
    for too long, you can modify the value of the `USERS_LIMIT` variable in the `data.service.ts`
    file. Let us start the recipe to reproduce the performance issues, and we will
    fix them afterward:'
  prefs: []
  type: TYPE_NORMAL
- en: First, open the Chrome DevTools and look at the **Console** tab. You should
    see the **User card created** message logged 10,000 times. This message will be
    logged any time a user card component (instance of the `UserCardComponent` class)
    is created/initiated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, delete the first item by using the *delete* button on the card. You should
    see the same message (**User card created**) logged again 9,999 times now, as
    shown in the following screenshot. This means we recreate the `list-item` component
    for the remaining 9,999 items:![](img/B18469_12_21.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 12.21: Logs shown again after deleting an item'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, click the first item (this updates the first item according to the existing
    code). You should again see the **User card created** logs, as shown in *Figure
    12.22*. This means we recreate all the 9,999 list items when updating any item
    from the list. You will notice that the update to the first item’s name in the
    **User Interface** (**UI**) is reflected in about 2–3 seconds:![](img/B18469_12_22.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 12.22: Logs shown again after updating an item'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let’s fix the performance issue by using the `trackBy` function. Open
    the `users-list.component.ts` file and update it, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, update the `users-list.component.html` file to use the `trackByFn` method
    we just created, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, refresh the app, delete the first item, and then click the (new) first
    list item to update it. You will notice that the item is updated immediately,
    and we do not log the **User card created** message again anymore, as shown in
    *Figure 12.23*:![](img/B18469_12_23.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 12.23: No further logs after updating an item using the trackBy function'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Great! You now know how to use the `trackBy` function with the `*ngFor` directive
    to optimize the performance of lists in Angular. To understand all the magic behind
    the recipe, see the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `*ngFor` directive allows us to loop over **iterables** and render multiple
    HTML elements or components. When working with an array of primitives (Boolean,
    string, or number values), Angular tracks each item by its value to identify elements.
    However, when dealing with objects, Angular tracks them by memory location, like
    how JavaScript handles object equality checks. This means that if you just change
    a property in an object of the array, it will not re-render the template for that
    object. However, if you provide a new object in its place (different reference
    in memory), the content for the item will be re-rendered. This is what we do in
    this recipe to reproduce the performance issue. Since we replace the entire array
    when we update or delete an item, Angular treats the array as a new resource to
    iterate over. In the `data.service.ts` file, we have the following code for the
    `updateUser` method inside the service named `DataService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we use the object spread operator ( `{ … }` ) to return a new object
    for each item in the array. This ends up telling the `*ngFor` directive to re-render
    the UI for each item in the `listItems` array in the `UserListComponent` class.
    Suppose you are already rendering 1,000 users. If you search for a term that returns
    100 users from the server, ideally, Angular should not re-render those 100 users
    as they were already rendered in the view. Angular, however, would re-render the
    UI for all the list items because of the following potential reasons (but not
    limited to these):'
  prefs: []
  type: TYPE_NORMAL
- en: The sorting/placement of the users could have changed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The length of the users could have changed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we want to avoid using the object reference as the unique identifier for
    each list item. For our use case, we know that each user’s ID is unique; therefore,
    we use the `trackBy` function to tell Angular to use the user’s ID as the unique
    identifier. Now, even if we return a new object for each user after a user update
    from the `updateUser` method (as previously shown), Angular does not re-render
    all the list items. This is because the new objects (users) have the same ID and
    Angular uses it to track them. Pretty cool, right?
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have learned how the recipe works, see the next section to view
    a link for further reading.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `NgForOf` official documentation: [https://angular.io/api/common/NgForOf](https://angular.io/api/common/NgForOf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving heavy computation to pure pipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Angular, we have a particular way of writing components. Since Angular is
    heavily opinionated, we already have a lot of guidelines from the community and
    the Angular team on what to consider when writing components—for example, making
    HTTP calls directly from a component is considered a *not-so-good* practice. Similarly,
    if we have heavy computation in a component that triggers with each change detection
    cycle, this is also not considered a good practice. Imagine that the view depends
    upon a transformed version of the data using a computation constantly. This would
    cause a lot of computation and processing for each render cycle. One good technique
    can be to move the heavy computation using Angular (pure) pipes (especially if
    the computation happens with each change detection cycle).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with resides in `start/apps/chapter12/ng-pipes-perf`
    inside the cloned repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should open the app in a new browser tab, and you should see the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_12_24.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 12.24: The ng-pipes-perf app running at http://localhost:4200'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click the button that says **Click Me** Or try to search for some user. You’ll
    see that the app is too slow and gets hung often. Now that we have the project
    served on the browser, let’s see the steps of the recipe in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app we’re working with has some performance issues, particularly with the
    `UserCardComponent` class. This is because it uses a getter function, `randomColor`,
    to generate a random color for its background. Behind the scenes, that function
    uses a `factorial` function to add more processing time. But that is just to demonstrate
    a component that can cause the UI to hang if there is some complex calculation
    happening along with multiple change detections being triggered. We’re going to
    add some code to monitor how many times the `randomColor` getter gets called.
    This will show the number of times the change detection in Angular gets triggered
    by default. We will also fix the issue and make it more performant (as much as
    we can) by detaching the change detector completely from a particular component.
    Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s make sure that the app is just slow enough for your machine that
    it makes your laptop/PC hang. Open the `src/app/app.config.ts` file and adjust
    the value of the `RANDOMIZATION_COUNT` token from `9` to whatever suits you best.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, try to search for a user named `Irineu` by entering their name in the
    search box. You’ll notice that the app still hangs and that it takes a few seconds
    to show the user. You’ll also notice that you don’t even see the letters in the
    search box as you type them. That is, there is a delay in rendering.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s add some logic to the code. We’ll check how many times Angular calls the
    `idUsingFactorial` method when the page loads.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s create a service that we will use to track the number of times a particular
    user card for a particular person is called. Run the following command from the
    workspace’s root folder to create a service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Choose `@schematics/angular:service` when asked.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the content of the `src/app/services/logs.service.ts` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, inject the `LogService` in the `src/app/component/user-card/user-card.component.ts`
    file. We will also create a getter (`log`) function to get the count for the user,
    and we will update the count whenever the `randomColor` getter is called. Update
    the mentioned file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will use the log in the template of the user card component to show
    the count. Update the `src/app/component/user-card/user-card.component.html` file
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you look at the application now, you should see the **Color Generation Count**
    as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_12_25.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 12.25: Color Generation Count being shown on page load'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, click the **Update Irineu’s Name** button. Then focus (click) the **Quick
    Search** input and then click outside. Repeat this a few times and you should
    see that the colors are regenerated, even though the cards are not supposed to
    be re-rendered. *Figure 12.26* shows how it should look:![](img/B18469_12_26.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 12.26: Logs after interacting with the app without searching for anything'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Notice that if you start searching for something, you’ll get even more re-renders.
    That’s because each key up and/or key down event will trigger more re-renders.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To fix the issue, we will create an Angular pipe. We’ll move the computation
    to generate the random colors for this user card to this Angular pipe. In the
    project root, run the following command in the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Use the `@schematics/angular:pipe` schematic when asked.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, move the `randomColor` getter function and the `factorial` function from
    the `user-card.component.ts` file to the Angular pipe’s file, `pipes/random-color.pipe.ts`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure to delete those functions (the `randomColor` getter and `factorial`)
    from the `src/app/component/user-card/user-card.component.ts` file. Remove any
    unused imports as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, add the `randomColor` pipe to the user card component in the `user-card.component.ts`
    file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, update the `user-card.component.html` file to use the `randomColor` pipe
    instead of the getter we were using before. The code should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, refresh the app and repeat *step 7*. You will see that the color is only
    generated for the first card and the other cards do not re-render, as shown in
    *Figure 12.27*:![](img/B18469_12_27.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 12.27: Colors regenerating only for the first card'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Boom! Now that you know how to optimize performance by moving heavy computation
    to pure Angular pipes, see the next section to understand how this works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we know, Angular by default runs change detection on each browser event triggered
    in the app. And since we’re using a `randomColor` getter in the component template
    (UI), this function runs each time Angular runs the change detection cycle. This
    causes more computation and performance issues. This would also hold true if we
    used a function call instead of a getter.
  prefs: []
  type: TYPE_NORMAL
- en: We can take a step back from the initial implementation and think about what
    the `randomColor` getter does. It works with a `for` loop based on the factorial
    of the `randomizationCount` property. This is just to add a lot of processing
    time for this example, but you can imagine any heavy computation involved in the
    change detection cycle causing the performance issue. And in these cases, we either
    use pure functions or perhaps memoization.
  prefs: []
  type: TYPE_NORMAL
- en: A pure function is a function that always returns the same output, given the
    same input. Memoization is a technique in which, if the inputs are not changed
    (that is, the function is called with the same inputs as the previous time), a
    cached output is returned, and the heavy computation is skipped. Luckily, Angular
    pure pipes are pure functions and memorized, as they are only called when the
    inputs change. If that’s not the case, the pipe’s transform function will not
    be called, and the component won’t be re-rendered.
  prefs: []
  type: TYPE_NORMAL
- en: In the recipe, we move the computation to a newly created Angular pipe. The
    pipe’s `transform` method receives `randomizationCount` as the first value, and
    the `user` (of type `IUser`) as the second input. The pipe then uses the `randomColor`
    method and, ultimately, the `factorial` method to calculate a random color. When
    we start typing in the search box, the values for the user cards do not change.
    This results in the pipe not being triggered until we get back a new set of users
    based on the search query. Once we get the result, the user cards are re-rendered
    and hence we get new colors for them. As a result, there is no unnecessary computation
    running due to browser events, thus optimizing performance and unblocking the
    UI thread.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Angular pure and impure pipes official documentation: [https://angular.io/guide/pipes#pure-and-impure-pipes](https://angular.io/guide/pipes#pure-and-impure-pipes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using web workers for heavy computation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If your Angular application does a lot of computation during an action, there’s
    a high chance that it will block the UI thread. This will cause a lag in rendering
    the UI because it blocks the main JavaScript thread. Web workers allow us to run
    heavy computation in the background thread, thus freeing the UI thread as it is
    not blocked. In this recipe, we’re going to use an application that does a heavy
    computation in the `UserService` class. It creates a unique ID for each user card
    and saves it into `localStorage`. However, it loops a couple of thousand times
    before doing so, which causes our application to hang for a while. In this recipe,
    we’ll move the heavy computation from the components to a web worker and will
    also add a fallback in case web workers aren’t available.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with resides in `start/apps/chapter12/ng-ww-perf`
    inside the cloned repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should open the app in a new browser tab, and you should see the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_12_28.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 12.28: The ng-ww-perf app running at http://localhost:4200'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have the app running, let’s see the steps of the recipe in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you open the app, you’ll notice that it takes some time before the user
    cards are rendered. We can also see the number of times the random color for the
    user card background is generated. If you type something, or click the **Update
    Irineu’s Name** button, you will see that the UI thread is blocked until we have
    some computation finished. The culprit is the `randomColor` getter method in the
    `UserCardComponent` class. This ultimately generates a random color after running
    a `for` loop based on the `RANDOMIZATION_COUNT` token’s value before rendering
    the color. This happens inside the `generateRandomColor` method inside the `src/app/utils.ts`
    file. Let’s start the recipe to improve the performance of the app. We’ll start
    by implementing a web worker:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll first create a web worker. Run the following command in the workspace’s
    root:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Choose `@nx/angular:web-worker` when asked.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, update the code inside the `workers/random-color.worker.ts` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s replace the `randomColor` getter in the `UserCardComponent` class with
    a regular property. Update the `user-card.component.ts` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure to remove the `randomColor` getter function. Otherwise, TypeScript
    will throw errors since we can’t have a property and a getter method having the
    same name.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we’ll use the worker in the `user-card.component.ts` file. Update it,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'So far, we have just added a listener for when we’ll receive the generated
    color from the worker. But first, we must send a message from the component to
    the worker, so it generates a random color. Update the `user-card.component.ts`
    file to use the `OnChanges` life cycle hook. We’ll use it to send a message to
    the worker:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let’s ensure that the worker is destroyed (terminated) when the respective
    user card is destroyed. Update the `user-card.component.ts` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Refresh the app and notice how long it takes for the user cards to render. They
    should appear much faster than before. Also, you should be able to see the following
    logs reflecting the communication from the app to the web worker, and vice versa:![](img/B18469_12_29.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 12.29: Logs showing messages to and from the app to web workers'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Woohoo! The power of web workers! And now you know how to use web workers in
    an Angular app to move heavy computation to them. Since you’ve finished the recipe,
    see the next section on how this works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we discussed in the recipe’s description, web workers allow us to run and
    execute code in a separate thread from the main JavaScript (or UI thread). At
    the beginning of the recipe, whenever we refresh the app or search for a user,
    it blocks the UI thread. We sometimes see the loader being hung, or a white screen.
    This is until a random color is generated for each card. We begin the recipe by
    creating a web worker using the NX **Command-line Interface** (**CLI**). This
    creates a `random-color.worker.ts` file, which contains some boilerplate code
    to receive messages from the UI thread and send a message back to it as a response.
  prefs: []
  type: TYPE_NORMAL
- en: 'The CLI command also updates the `project.json` file by adding a `webWorkerTsConfig`
    property. The value against the `webWorkerTsConfig` property is the path to the
    `tsconfig.worker.json` file, and the CLI command also creates this `tsconfig.worker.json`
    file. If you open the `tsconfig.worker.json` file, you should see the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: However, in our NX workspace, we have a `tsconfig.base.json` file instead of
    `tsconfig.json`. So, we fixed it.
  prefs: []
  type: TYPE_NORMAL
- en: In the web worker file, we have the `addEventListener` method call, which receives
    messages from the UI thread to the worker. Notice that we expect to receive the
    `randomizationCount` property from the UI thread so we can use it in the `generateRandomColor`
    method from the `utils.ts` file.
  prefs: []
  type: TYPE_NORMAL
- en: The worker file also has a method named `getRandomColorWorker`. This returns
    a new instance of the worker every time it is called. Since we call it from our
    user card components, each card gets a new instance of the worker.
  prefs: []
  type: TYPE_NORMAL
- en: Then, in our `UserCardComponent` class, we get a new instance of the worker
    for each component and use the `ngOnInit` life cycle hook to add an event listener
    to the worker. This way, whenever the worker sends a message, the user card component
    can read it—that is, it will get the generated color and assign it to the `randomColor`
    property. This, in turn, will set the `backgroundColor` of the user card. Notice
    that the `ngOnInit` life cycle hook only registers a listener for the messages
    sent by the worker. But first, we have to tell the worker to generate random colors.
    For this, we use the `ngOnChanges` life cycle hook. In the hook, we observe the
    value of the user input. If it changes, we send a message to the worker to generate
    a random color for the specific user card. If you click on the **Update Irineu’s
    Name** button, you will see consecutive logs from and to the user card. Note that
    moving the color generation to the worker in this way also results in other components
    not being re-rendered again when we have any of the browser events (click, key
    up, etc.) triggering. Finally, we use the `ngOnDestroy` life cycle hook to terminate
    the worker to avoid memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: Note that in the `ngOnChanges` hook, we are also falling back to the regular
    usage of the methods in the `utils.ts` file if the browser does not support workers.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Angular official documentation on web workers: [https://angular.io/guide/web-worker](https://angular.io/guide/web-worker)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'MDN web worker documentation: [https://developer.mozilla.org/en-US/docs/Web/API/Worker](https://developer.mozilla.org/en-US/docs/Web/API/Worker)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using performance budgets for auditing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In today’s world, most of the population has a good internet connection to use
    everyday applications, be it a mobile app or a web app, and it is fascinating
    how much data we ship to our end users as a business. The amount of JavaScript
    shipped to users has an ever-increasing trend now, and if you’re working on a
    web app, you might want to use performance budgets to make sure the bundle size
    doesn’t exceed a certain limit. With Angular apps, setting the budget sizes is
    a breeze. In this recipe, you’re going to learn how to use the performance budgets
    to ensure small bundle sizes for our Angular apps.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with resides in `start/apps/chapter12/ng-perf-budgets`
    inside the cloned repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to build the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should build the app, and you should see the following in the terminal:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_12_30.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 12.30: Build output for production mode, without performance budgets'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Notice that the bundle size for the `main.*.js` file is about 294 **Kilobytes**
    (**KB**) now. And now that we have built the app, let’s see the steps of the recipe
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have an app that is small in terms of bundle size at the moment. However,
    this could grow into a huge app with upcoming business requirements. For the sake
    of this recipe, we’ll increase the bundle size deliberately and will then use
    performance budgets to stop the Angular build from being generated for production
    if the bundle size exceeds the budget. Let’s begin the recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `app.component.ts` file and update it, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, build the app again by running the following command from the workspace’s
    root folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see that the bundle size for the `main.*.js` file is now somewhat
    around 1.10 **megabytes** (**MB**). This is a huge increase in size compared to
    the original ~294 KB, as you can see in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_12_31.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 12.31: The bundle size for main.*.js increased to 1.10 MB'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Since we’re using NX for our recipes, we already have the budgets set by NX.
    However, if you had a regular Angular application (without NX), you would update
    the `angular.json` file to add the budgets.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the `project.json` file within the `start/apps/chapter12/ng-perf-budgets`
    folder and update it. The property that we’re targeting is `targets.build.configurations.production.budgets`.
    The updated code should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that we have only changed `maximumWarning` from `500kb` to `800kb` for
    the `initial` bundle.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s improve our application by not importing the entire libraries in the
    `app.component.ts` file, and by using the `date-fns` package instead of `moment.js`.
    Run the following command from the workspace’s root folder to install the `date-fns`
    package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, update the `app.component.ts` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the `npm run build ng-perf-budgets` command again. You should see a decreased
    bundle size and the build being generated successfully, as follows:![](img/B18469_12_32.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 12.32: Reduced bundle size after using date-fns and optimized imports'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Boom! You just learned how to use performance budgets in Angular. These budgets
    can be used to throw warnings and errors based on your configuration. Note that
    the budgets can be modified based on changing business requirements. However,
    as engineers, we have to be cautious about what we set as performance budgets
    to not ship JavaScript over a certain limit to the end users.
  prefs: []
  type: TYPE_NORMAL
- en: Since you’ve finished the recipe, see the next section on how this works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Angular performance budgets are guidelines set for the acceptable limits of
    various performance metrics in Angular applications. These budgets help ensure
    that the application’s performance remains within acceptable bounds and does not
    degrade significantly as the code base grows or changes. The most critical performance
    metric you can work with is the initial bundle size. This is what the user’s device
    will load first as the main set of JavaScript files, and they are eagerly loaded.
    In this recipe, we have two issues. First, we use `moment.js`, which is a library
    that is not *tree-shakable*. This means if we import the library, the whole library
    is included in the final bundle, whereas tree-shakable libraries have *the code
    not being used* in the application removed by the build tools when you build them.
    The second problem we introduced is that we included the entire library, `three`,
    in our component, which is tree-shakable, but our import is inaccurate. We introduced
    these problems to see the bundle size increase. But as we saw, in NX, we can use
    any Angular app’s `project.json` file to manage the performance budgets. If you
    were working on an Angular CLI-based application, you would do the same in the
    `angular.json` file. In practice, you will be using a warning threshold and an
    error threshold, which ensures you’re not shipping huge JavaScript bundles to
    the end users.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Performance budgets with the Angular CLI official documentation: [https://web.dev/performance-budgets-with-the-angular-cli/](https://web.dev/performance-budgets-with-the-angular-cli/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Boosting Angular App Performance* *with Performance Budgets*: [https://www.codewithahsan.dev/blog/angular-performance-budgets](https://www.codewithahsan.dev/blog/angular-performance-budgets)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing bundles with webpack-bundle-analyzer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we looked at configuring budgets for our Angular app,
    and this is useful because you get to know when the overall bundle size exceeds
    a certain threshold, although you don’t get to know how much each part of the
    code contributes to the final bundles. This is what we call *analyzing* the bundles,
    and in this recipe, you will learn how to use `webpack-bundle-analyzer` to audit
    the bundle sizes and the factors contributing to them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with resides in `start/apps/chapter12/ng-perf-wba`
    inside the cloned repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to build the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should build the app, and you should see the following in the terminal:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_12_33.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 12.33: The ng-perf-wba app running at http://localhost:4200'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have built the app, let’s see the steps of the recipe in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have an app that is small in terms of bundle size at the moment. However,
    this could grow into a huge app with upcoming business requirements. For the sake
    of this recipe, we’ll increase the bundle size deliberately and will then use
    `webpack-bundle-analyzer` to observe the packages contributing to the large bundle
    sizes. Let’s begin the recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `app.component.ts` file and update it, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, build the app again by running the following command from the workspace
    root:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see that the bundle size for the `main.*.js` file is now somewhat
    around 1.10 MB. This is a huge increase in size compared to the original ~294
    KB. As a result, the **Initial Total** size became 1.15 MB and the build failed,
    as you can see in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_12_34.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 12.34: The build failing due to an increased bundle size'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We’ll first create a build with the `stats.json` file, which contains the bundle
    information in the JSON format. To do that, run the following command from the
    workspace root:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, run the following command from the workspace root to have the `stats.json`
    file read by the `webpack-bundle-analyzer`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will spin up a server with the bundle analysis. You should see a new tab
    opened in your default browser, and it should look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_12_35.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 12.35: Bundle analysis using webpack-bundle-analyzer'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Notice that the `lib` folder takes a huge portion of the bundle size— around
    562 KB, which you can check by just doing a mouseover on the **lib** box. The
    overall bundle size is 1.16 MB. Let’s try to optimize the bundle size. Let’s install
    the `date-fns` package so that we can use it instead of `moment.js`. Run the following
    command from your project root:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, update the `app.component.ts` file to use the `date-fns` package’s `format`
    method instead of using the `moment().format` method. We’ll also just import the
    `Scene` class from the `Three.js` package instead of importing the whole library.
    The code should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Repeat *step 3* and *step 4* to build the app again and to analyze via `webpack-bundle-analyzer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once `webpack-bundle-analyzer` runs, you should see the analysis, as shown
    in the following screenshot. Notice that we don’t have the `moment.js` file or
    the `lib` block anymore, and the overall bundle size has reduced from 1.16 MB
    to about 835 KB:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_12_36.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 12.36: Bundle analysis after optimization'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Woohoo! You now know how to use the `webpack-bundle-analyzer` package to audit
    bundle sizes in Angular applications. This is a great way of improving overall
    performance because you can identify the chunks causing the increase in the bundle
    size and then optimize the bundles. If you run `npm run serve ng-perf-wba` from
    the workspace root before and after the optimization, you will see the same console
    logs, which show that we kept the existing functionality and optimized the bundles
    anyway.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Getting started with webpack: [https://webpack.js.org/guides/getting-started/](https://webpack.js.org/guides/getting-started/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `webpack-bundle-analyzer` GitHub repository: [https://github.com/webpack-contrib/webpack-bundle-analyzer](https://github.com/webpack-contrib/webpack-bundle-analyzer)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/AngularCookbook2e](Chapter_12.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code1388317275422265.png)'
  prefs: []
  type: TYPE_IMG
