- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a Router-First Line-of-Business App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you read in *Chapter 3*, *Architecting an Enterprise App*, **Line-of-Business**
    (**LOB**) applications are the bread and butter of the software development world.
  prefs: []
  type: TYPE_NORMAL
- en: In this and the remaining chapters of the book, we’ll set up a new application
    with rich features that can meet the demands of an LOB application with scalable
    architecture and engineering best practices that will help you start small and
    be able to grow your solution quickly if there’s demand. We will follow the router-first
    design pattern, relying on reusable components to create a grocery store LOB application
    named LemonMart. We’ll discuss designing around major data entities and the importance
    of completing high-level mock-ups for your application before implementing various
    conditional navigation elements, which may change significantly during the design
    phase.
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this project is provided on GitHub at [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart),
    including various stages of development in the `Projects` folder. The project
    is supported by unit tests using Jasmine and E2E tests using Cypress, environment
    variables, Angular Material, and a **Continuous Integration and** **Continuous
    Delivery** (**CI/CD**) pipeline leveraging CircleCI. You can find more information
    on CI/CD in *Chapter 10*, *Releasing to Production with CI/CD*.
  prefs: []
  type: TYPE_NORMAL
- en: LemonMart is a separate Angular repo. For enterprise or full-stack development,
    you may ask, why is it not configured as a monorepo? In *Chapter 5*, *Designing
    Authentication and Authorization*, we cover how to create a monorepo using Git’s
    submodule feature. For a more opinionated and ergonomic approach to working on
    large Angular applications, I urge you to consider Nx. Its smart build system
    alone can save hours of build time. Check it out at [https://nx.dev](https://nx.dev).
    However, a deep dive of this tool is outside the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Feeling adventurous? Run the following command to create your Nx workspace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In this chapter, we’re going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating LemonMart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating router-enabled modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Branding, customization, and Material icons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feature modules with lazy loading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the walking skeleton
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common testing module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing around major data entities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High-level UX design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *Chapters 5* to *9*, we will evolve LemonMart to demonstrate the aforementioned
    concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most up-to-date versions of the sample code for the book are on GitHub at
    the following linked repository. The repository contains the final and completed
    state of the code. You can verify your progress at the end of this chapter by
    looking for the end-of-chapter snapshot of code under the `projects` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'For *Chapter 4*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clone the repo: [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute `npm install` on the root folder to install dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The end state of the project is reflected at:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the stage name to any `ng` command to act only on that stage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the `dist/stage7` folder at the root of the repository will contain
    the compiled result.
  prefs: []
  type: TYPE_NORMAL
- en: Beware that the source code provided in the book and the version on GitHub are
    likely to be different. The ecosystem around these projects is ever-evolving.
    Between changes to how the Angular CLI generates new code, bug fixes, new versions
    of libraries, or side-by-side implementations of multiple techniques, there’s
    a lot of variation that’s impossible to account for. If you find errors or have
    questions, please create an issue, or submit a pull request on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Read more about updating Angular in the supplemental guide *Keeping Angular
    and Tools Evergreen* at [https://angularforenterprise.com/evergreen](https://angularforenterprise.com/evergreen).
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s start by creating LemonMart^™, a fully featured LOB app you can
    use as a template to kickstart your next professional project. LemonMart is a
    robust and realistic project that can support feature growth and different backend
    implementations, and it comes with a complete and configurable authentication
    and authorization solution out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: Since its introduction in 2018, LemonMart has served over 257,000 lemons to
    more than 32,500 developers. Zesty!
  prefs: []
  type: TYPE_NORMAL
- en: You can always clone the finished project from GitHub, [https://www.github.com/duluca/lemon-mart](https://www.github.com/duluca/lemon-mart),
    whenever needed. Let’s jump right into it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating LemonMart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LemonMart will be a mid-sized line-of-business application with over 90 code
    files. We will start our journey by creating a new Angular app, with routing and
    Angular Material configured.
  prefs: []
  type: TYPE_NORMAL
- en: It is presumed that you have installed all the requisite software mentioned
    in *Appendix A*, *Setting Up Your Development Environment*. If you have not, execute
    the following commands for your OS to configure your environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Windows PowerShell, execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'On macOS Terminal, execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: For more information, refer to [https://github.com/duluca/web-dev-environment-setup](https://github.com/duluca/web-dev-environment-setup).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a router-first app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create LemonMart as a standalone project, which means a root module
    is not required to bootstrap the application, and all components created within
    the application will be configured as a standalone component. We will implement
    a modular architecture using lazy-loaded feature modules and selectively use lazy-loaded
    standalone components for components shared across feature modules. With the router-first
    approach, we want to enable routing early on in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create the new application, with routing already configured, by executing
    this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A new `app.routes.ts` file has been created for us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will be defining `routes` inside the routes array.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Observe that the `routes` are provided in `app.config.ts`, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Ultimately, `ApplicationConfig` is consumed by `bootstrapApplication` in `main.ts`,
    which kicks off the application bootstrap process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Execute your project by running `npm start`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring Angular and VS Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Apply the following configuration steps to your project using `mrm`, a command-line
    tool to help keep configuration files in projects in sync:'
  prefs: []
  type: TYPE_NORMAL
- en: The following scripts do not require you to use VS Code. If you wish to use
    another IDE like WebStorm, the `npm` scripts that are configured will run equally
    well.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about `mrm` at [https://mrm.js.org/docs/getting-started](https://mrm.js.org/docs/getting-started).
  prefs: []
  type: TYPE_NORMAL
- en: 'Apply the Angular VS Code configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Apply the `npm` scripts for the Docker configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement an `npm` script to build your application in production mode named
    `build:prod`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By default, Angular will build your code in production mode. However, this behavior
    can be changed in `angular.json`. For this reason, I prefer to explicitly request
    a production build for code that’s intended to be shipped, to avoid mistakes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: These settings are continually tweaked to adapt to the ever-evolving landscape
    of extensions, plug-ins, Angular, and VS Code. Alternatively, you can use the
    Angular Evergreen extension for VS Code to run the configuration commands with
    one click.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Note that if the preceding configuration scripts fail to execute, the following
    `npm` scripts will also fail. In this case, you have two options: revert your
    changes and ignore these scripts, or manually implement these scripts as covered
    in earlier chapters (or as demonstrated on GitHub).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Execute `npm run style:fix`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute `npm run lint:fix`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute `npm start`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refer to *Appendix A*, *Setting Up Your Development Environment*, for further
    configuration details.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on the `mrm` tasks, refer to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/expertly-simple/mrm-task-angular-vscode](https://github.com/expertly-simple/mrm-task-angular-vscode)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/expertly-simple/mrm-task-npm-docker](https://github.com/expertly-simple/mrm-task-npm-docker)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/expertly-simple/mrm-task-npm-aws](https://github.com/expertly-simple/mrm-task-npm-aws)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Angular Material and styles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Several years ago, it was a necessary practice to apply a reset or normalize
    CSS stylesheet to themed projects to account for discrepancies in how browsers
    handled layout or spacing. However, current browsers are more faithful to the
    CSS specification, so a legacy reset stylesheet can be overkill. Below, I implement
    `styles.scss` with reset parameters like `body { margin: 0 }` and `html, body
    { height: 100% }`.'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to check out a modern version of a normalize stylesheet, I recommend
    [https://github.com/sindresorhus/modern-normalize](https://github.com/sindresorhus/modern-normalize).
    It’s easy to set up and works seamlessly when imported in `styles.scss`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also need to set up Angular Material and configure a theme to use:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install Angular Material:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that since this is a standalone project, we will need to import the required
    Material modules and `FlexModule` on each individual component that requires it.
    When the `@ngbracket/ngx-layout` package implements a root-level provider, adding
    `FlexModule` manually won’t be needed anymore.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Append common CSS to `styles.scss` as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Update your application’s title in `index.html`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will apply custom branding to the app later in this chapter. Next, let’s
    start designing our line-of-business application.
  prefs: []
  type: TYPE_NORMAL
- en: Designing LemonMart
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is important to build a rudimentary roadmap to follow, from the database
    to the frontend, while also avoiding over-engineering. This initial design phase
    is critical to the long-term health and success of your project, where any existing
    silos between teams must be broken down and an overall technical vision must be
    well understood by all members of the team. This is easier said than done, and
    there are volumes of books written on the topic.
  prefs: []
  type: TYPE_NORMAL
- en: In engineering, there’s no right answer to a problem, so it is important to
    remember that no person can ever have all the answers or a crystal-clear vision.
    It is important that technical and non-technical leaders create a safe space with
    opportunities for open discussion and experimentation as part of the culture.
    The humility and empathy that come along with being able to court such uncertainty
    as a team is as important as any single team member’s technical capability. Every
    team member must be comfortable leaving their egos at the door because our collective
    goal will be to grow and evolve an application to ever-changing requirements during
    the development cycle. You will know that you have succeeded if individual parts
    of the software you created are easily replaceable by anyone.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s start by developing a roadmap and identifying the scope of our application.
    For this, we will be defining user roles and then building a site map to create
    a vision of how our app might work.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying user roles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first step of our design will be to think about who is using the application
    and why.
  prefs: []
  type: TYPE_NORMAL
- en: 'We envision four user states, or roles, for LemonMart:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authenticated**: any authenticated user would have access to their profile'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cashier**, whose sole role is to check out customers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clerk**, whose sole role is to perform inventory-related functions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Manager**, who can perform all actions a cashier and a clerk can perform
    but also has access to administrative functions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this in mind, we can start to create a high-level design for our app.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying high-level modules with a site map
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Develop a high-level site map of your application, as shown in the following
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a login page  Description automatically generated with medium
    confidence](img/B20960_04_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: Landing pages for users'
  prefs: []
  type: TYPE_NORMAL
- en: 'I used MockFlow.com’s SiteMap tool to create the site map shown: [https://sitemap.mockflow.com](https://sitemap.mockflow.com).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon first examination, three high-level modules emerge as lazy-loading candidates:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Point of Sale**(**POS**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inventory**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Manager**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The cashier will only have access to the **POS** module and component. The
    clerk will only have access to the **Inventory** module, which will include additional
    screens for the **Stock Entry**, **Products**, and **Categories** management components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing text, screenshot, line  Description automatically generated](img/B20960_04_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: Inventory pages'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the **Manager** will be able to access all three modules with the
    **Manager** module, including user management and receipt lookup components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B20960_04_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: Manager pages'
  prefs: []
  type: TYPE_NORMAL
- en: There will be great benefits from enabling lazy loading for all three modules;
    since Cashiers and Clerks will never use components belonging to other user roles,
    there’s no reason to send those bytes down to their devices. As the **Manager**
    module gains more advanced reporting features or new roles are added to the application,
    the **POS** module will be unaffected by the bandwidth and memory impact of an
    otherwise growing application.
  prefs: []
  type: TYPE_NORMAL
- en: This means fewer support calls and consistent performance on the same hardware
    for much longer.
  prefs: []
  type: TYPE_NORMAL
- en: Generating router-enabled modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have our high-level components defined as **Manager**, **Inventory**,
    and **POS**, we can define them as modules. These modules will be different from
    the ones you’ve created for routing and Angular Material. We can create the user
    profile as a component on the app module; however, note that the user profile
    will only ever be used for already-authenticated users, so it makes sense to define
    a fourth module only meant for authenticated users in general. This way, you will
    ensure that your app’s first payload remains as minimal as possible. In addition,
    we will create a `home` component to contain the landing experience for our app
    so that we can keep implementation details out of `app.component`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate `manager`, `inventory`, `pos`, and `user` feature modules by specifying
    their names and routing capabilities:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note the abbreviated command structure, where `ng generate module manager` becomes
    `ng g m manager`, and similarly, `--module` becomes `-m`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Verify that you don’t have CLI errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that using `npx` on Windows may throw an error such as `Path must be a
    string. Received undefined`. This error doesn’t seem to affect the successful
    operation of the command, which is why it is critical always to inspect what the
    CLI tool generates.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Verify that the folder and the files are created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s examine how `ManagerModule` has been configured. Remember that a feature
    module is decorated by the `@NgModule` annotation. In Angular apps configured
    with a root `NgModule`, you’ll notice that it implements the `bootstrap` property,
    whereas a feature module does not implement this. See the generated code below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we specified the `--routing` option, a `routing` module has been created
    and imported into `ManagerModule`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note that `RouterModule` is being configured using `forChild`, as opposed to
    the optional `forRoot` method, either configured in an `AppRouting` module or
    a router provider in `ApplicationConfig`. By specifying the context, we allow
    the router to understand the proper relationship between routes defined in different
    module contexts. For example, all child routes defined in `ManagerRoutingModule`
    will be prepended by the route segment `/manager`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Be sure to execute `style` and `lint` `fix` commands before moving on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s design how the landing page for LemonMart will look and work.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the home route
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the following mock-up as the landing experience for LemonMart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a login box  Description automatically generated with low
    confidence](img/B20960_04_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.4: LemonMart landing experience'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the LocalCast Weather app, we don’t want a lot of layout markup in `AppComponent`.
    The `AppComponent` is the root element of your entire application; therefore,
    it should only contain elements that will persistently appear throughout your
    application. In the following annotated mock-up, the toolbar marked as **1** will
    be persistent throughout the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'The area marked as **2** will house the `home` component, which itself will
    contain a login user control marked as **3**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer login  Description automatically generated with
    medium confidence](img/B20960_04_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.5: LemonMart layout structure'
  prefs: []
  type: TYPE_NORMAL
- en: It’s best practice to create your default or landing component as a separate
    element in Angular. This helps reduce the amount of code that must be loaded and
    logically executed on every page, but it also results in a more flexible architecture
    when utilizing the router.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate the `home` component with an inline template and styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note that a component with an inline template and a style is also called a **Single
    File Component** or an **SFC**.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you are ready to configure the router.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up default routes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s get started with setting up a simple route for LemonMart. We need to
    set up the `/` route (also known as the empty route) and the `/home` route to
    display the `HomeComponent`. We also need a wildcard route to capture all undefined
    routes and display a `PageNotFoundComponent`, which must also be created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s put together the route configuration above step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a path for `'home'` and direct the router to render `HomeComponent` by
    setting the `component` property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the default path of the application `''` to be redirected to `'/home'`.
    By setting the `pathMatch` property, we always ensure that this specific instance
    of the `home` route will be rendered as the landing experience; otherwise, in
    its default prefix setting, `pathMatch` considers an empty path to be a prefix
    of all routes, resulting in an endless redirect loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `pageNotFound` component with an inline template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure a wildcard route for `PageNotFoundComponent` as the last entry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By configuring the wildcard route as the last entry, we handle any route that
    is not matched gracefully by redirecting it to `PageNotFoundComponent`. The wildcard
    path must be the last property in the array; otherwise, routes defined after will
    not be considered.
  prefs: []
  type: TYPE_NORMAL
- en: RouterLink
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When a user lands on the `PageNotFoundComponent`, we would like them to be
    able to get back to the `HomeComponent` using the `routerLink` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On `PageNotFoundComponent`, replace the inline template to link back to `home`
    using `routerLink`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This navigation can also be done via an `<a href>` tag implementation; however,
    in more dynamic and complicated navigation scenarios, you will lose features such
    as automatic active link tracking or dynamic link generation.
  prefs: []
  type: TYPE_NORMAL
- en: The Angular bootstrap process will ensure that `AppComponent` is inside the
    `<app-root>` element in `index.html`. However, we must manually define where we
    would like `HomeComponent` to render to finalize the router configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Router outlet
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`AppComponent` is considered a root element for the root router defined in
    `app-routes.ts`, which allows us to define outlets within this root element to
    dynamically load any content we wish using the `<router-outlet>` element:'
  prefs: []
  type: TYPE_NORMAL
- en: Configure `AppComponent` to use inline templates and styles, deleting any existing
    content in the `html` and `scss` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the toolbar for your application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the name of your application as a button link so that it takes the user
    to the home page when clicked on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import `RouterLink`, `RouterOutlet`, and `MatToolbarModule` in the component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add `<router-outlet>` for the content to render:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, the contents of `home` will render inside `<router-outlet>`.
  prefs: []
  type: TYPE_NORMAL
- en: Branding, customization, and Material icons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To construct an attractive and intuitive toolbar, we must introduce some iconography
    and branding to the app so that the users can easily navigate through the app
    with the help of familiar icons.
  prefs: []
  type: TYPE_NORMAL
- en: Branding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In terms of branding, you should ensure that your web app has a custom color
    palette and integrates with desktop and mobile browser features to bring forward
    your app’s name and iconography.
  prefs: []
  type: TYPE_NORMAL
- en: Color palette
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Pick a color palette using the **Material Color** tool, located at [https://m2.material.io/design/color/the-color-system.html#tools-for-picking-colors](https://m2.material.io/design/color/the-color-system.html#tools-for-picking-colors).
    For LemonMart, I picked the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Primary Color**- `#2E7D32`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Secondary Color**- `#C6FF00`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You may either implement your theme in `styles.scss` or create a separate theme
    file. A separate file is useful if you intend to further customize individual
    components.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Add a file named `lemonmart-theme.scss`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Move theme-related CSS from `styles.scss` over to the new file. Theme-related
    content will be above the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update `styles.scss` to include the new theme in the first line of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Configure your custom theme with the chosen color palette.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can also grab LemonMart-related assets from GitHub at [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart).
  prefs: []
  type: TYPE_NORMAL
- en: For the LocalCast Weather app, we replaced the `favicon.ico` file to brand our
    app in the browser. While this would’ve been enough 10 years ago, today’s devices
    vary wildly, and each platform can leverage optimized assets better to represent
    your web app within its operating system. Next, let’s implement a more robust
    favicon.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a browser manifest and icons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You must ensure the browser shows the correct title text and icon in a **Browser**
    tab. Further, a manifest file should be created that implements specific icons
    for various mobile operating systems so that if a user pins your website, a desirable
    icon is displayed similarly to other app icons on the phone. This will ensure
    that if a user favorites or pins your web app on their mobile device’s home screen,
    they’ll get a native-looking app icon:'
  prefs: []
  type: TYPE_NORMAL
- en: Create or obtain an SVG version of your website’s logo from a designer or a
    site like [https://www.flaticon.com](https://www.flaticon.com).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this case, I will be using the likeness of the Eureka lemon:![A picture containing
    yellow, banana  Description automatically generated](img/B20960_04_06.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.6: LemonMart’s signature logo'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When using images you find online, pay attention to applicable copyrights.
    In this case, I have purchased a license to be able to publish this lemon logo,
    but you may grab your own copy at the following URL, given that you provide the
    required attribution to the author of the image: [https://www.flaticon.com/free-icon/lemon_605070](https://www.flaticon.com/free-icon/lemon_605070).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Generate the `favicon.ico` and manifest files using a tool such as [https://realfavicongenerator.net](https://realfavicongenerator.net).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adjust settings for iOS, Android, Windows, and macOS Safari to your liking.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the generator, be sure to set a version number, as favicons can be notorious
    for caching; a random version number will ensure that users always get the latest
    version.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download and extract the generated `favicons.zip` file into your `src` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the `angular.json` file to include the new assets in your app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Insert the generated code in the `<head>` section of `index.html`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Place the generated code between the favicon declaration and the CSS style imports.
    The order does matter. Browsers load data top-down. You want your application’s
    icon to be parsed before the user must wait for CSS files to be downloaded.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Ensure that your new favicon displays correctly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once your basic branding work has been completed, consider whether you’d like
    to establish a more unique look and feel with theming.
  prefs: []
  type: TYPE_NORMAL
- en: Custom themes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may further customize Material’s look and feel to achieve a unique experience
    for your app by leveraging tools listed at [https://m2.material.io/resources](https://m2.material.io/resources)
    and some other tools that I have discovered, which are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Material Design Theme Palette Generator will generate the necessary code to
    define your custom color palette to create truly unique themes at [http://mcg.mbitson.com](http://mcg.mbitson.com)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Color Blender helps with finding midway points between two colors, which is
    useful when defining in-between colors for the color swatches, located at [https://meyerweb.com/eric/tools/color-blend](https://meyerweb.com/eric/tools/color-blend)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In 2021, Google announced **Material 3**, aka Material You, a dynamic theming
    system that adapts to user preferences around OS-level color use. In 2023, Angular
    Material is still based on Material 2\. The Angular team transitioned to new **Material
    Design Components for Web** (**MDC**) style components in Angular 15 and will
    deprecate the old styles with Angular 17\. The MDC-style components support adjustable
    density and are more dynamic as a result. After this milestone, the Angular team
    plans to tackle the implementation of Material You.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can follow this thread for updates: [https://github.com/angular/components/issues/22738](https://github.com/angular/components/issues/22738).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There is a wealth of information at [https://material.io](https://material.io)
    on the in-depth philosophy behind the Material design, with great sections on
    things like the color system, [https://material.io/design/color/the-color-system.html](https://material.io/design/color/the-color-system.html),
    which dives deep into selecting the right color palette for your brand and other
    topics, such as creating a dark theme for your app.
  prefs: []
  type: TYPE_NORMAL
- en: It is very important to distinguish your brand from other apps or your competitors.
    Creating a high-quality custom theme will be a time-consuming process; however,
    the benefits of creating a great first impression with your users are considerable.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will show you how to add custom icons to your Angular apps.
  prefs: []
  type: TYPE_NORMAL
- en: Custom icons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let’s add your custom branding to your Angular app. You will need the
    `svg` icon you used to create your favicon:'
  prefs: []
  type: TYPE_NORMAL
- en: Place the image under `src/assets/img/icons`, named `lemon.svg`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `app.config.ts`, add `provideHttpClient()` as a provider so that the `.svg`
    file can be requested over HTTP.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update `AppComponent` to register the new .`svg` file as an icon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Beware that adding an `svg` icon from a URL resource doesn’t work in a **Server-Side
    Rendering** (**SSR**) configuration. Instead, you can add your `svg` icon as a
    `const` string in a TypeScript file import and register it as shown below:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Import `MatIconModule`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Following the pattern in the documentation for `MatToolbar`, found at [https://material.angular.io/components/toolbar](https://material.angular.io/components/toolbar),
    add the icon to the toolbar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, let’s add the remaining icons for the menu, user profile, and logout.
  prefs: []
  type: TYPE_NORMAL
- en: Material icons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Angular Material works out of the box with the Material Design icon font, automatically
    imported into your app as a web font in `index.html`. It is possible to self-host
    the font; however, if you go down that path, you don’t get the benefit if the
    user’s browser has already cached the font from when they visited another website,
    which could save the speed and latency of downloading a 42-56 KB file in the process.
    The complete list of icons can be found at [https://fonts.google.com/icons](https://fonts.google.com/icons).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s update the toolbar with some icons and set up the home page with
    a minimal template for a fake login button:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensure that the Material icons `<link>` tag has been added to `index.html`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Instructions on self-hosting can be found under the **Self Hosting** section
    at [http://google.github.io/material-design-icons/#getting-icons](http://google.github.io/material-design-icons/#getting-icons).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once configured, working with Material icons is easy.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: On `AppComponent`, update the toolbar to place a **Menu** button to the left
    of the title.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `fxFlex` directive so that the remaining icons are right-aligned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import `FlexModule` and `MatButtonModule`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add user profile and logout icons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On `HomeComponent`, add a minimal template for a login experience, replacing
    any existing content. Don’t forget to import `FlexModule` and `MatButtonModule`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Your app should look similar to this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B20960_04_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.7: LemonMart with minimal login'
  prefs: []
  type: TYPE_NORMAL
- en: There’s still some work to be done in terms of implementing and showing/hiding
    the menu, profile, and logout icons, given the user’s authentication status. We
    will cover this functionality in *Chapter 7*, *Working with REST and GraphQL APIs*.
  prefs: []
  type: TYPE_NORMAL
- en: To debug the router, get a visualization of your routes, and tightly integrate
    Angular with Chrome debugging features, use Angular DevTools, available from Chrome
    Web Store (also compatible with Microsoft Edge) or Firefox add-ons at [https://angular.dev/tools/devtools](https://angular.dev/tools/devtools).
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve set up basic routing for your app, we can move on to setting
    up lazily loaded modules with subcomponents. If you’re unfamiliar with troubleshooting
    and debugging Angular, please refer to [https://angular.dev/tools/devtools](https://angular.dev/tools/devtools)
    before moving forward.
  prefs: []
  type: TYPE_NORMAL
- en: Feature modules with lazy loading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two ways resources are loaded: eagerly or lazily. When the browser
    loads up `index.html` for your app, it starts processing it from top to bottom.
    First, the `<head>` element is processed, then `<body>`. For example, the CSS
    resources we defined in `<head>` of our app will be downloaded before our app
    is rendered because our Angular app is defined as `<script>` in `<body>` of the
    HTML file.'
  prefs: []
  type: TYPE_NORMAL
- en: When you use the `ng build` command, Angular leverages the webpack module bundler
    to combine all the JavaScript, HTML, and CSS into minified and optimized JavaScript
    bundles.
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t leverage lazy loading in Angular, the entire contents of your app
    will be eagerly loaded. The user won’t see the first screen of your app until
    all screens are downloaded and loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy loading allows the Angular build process, working in tandem with webpack,
    to separate your web application into different JavaScript files called chunks.
    We can enable this chunking by separating out portions of the application into
    feature modules. Feature modules and their dependencies can be bundled into separate
    chunks. Remember that the root module and its dependencies will always be in the
    first downloaded chunk. So, by chunking our application’s JavaScript bundle size,
    we keep the size of the initial chunk at a minimum. With a minimal first chunk,
    no matter how big your application grows, the time to First Meaningful Paint remains
    constant. Otherwise, your app would take longer and longer to download and render
    as you add more features and functionality to it. Lazy loading is critical to
    achieving a scalable application architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following graphic to determine which routes are eagerly loaded
    and which ones are lazily loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a system  Description automatically generated](img/B20960_04_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.8: Angular router eager vs lazy loading'
  prefs: []
  type: TYPE_NORMAL
- en: 'The black triangles are standalone components, and the black circles are components
    that depend on a module. `rootRouter` defines three routes: `a`, `b`, and `c`.
    `/master` and `/detail` represent named router outlets, which are covered in *Chapter
    9*, *Recipes – Master/Detail, Data Tables, and NgRx*. Route `a` is the default
    route for the app. Routes `a` and `c` are connected to `rootRouter` with a solid
    line, whereas route `b` is connected using a dashed line. In this context, route
    `b` is configured as a lazy-loaded route. This means route `b` will dynamically
    load a feature module, `BModule`, containing `childRouter`. `childRouter` can
    define any number of components, even reusing route names that were reused elsewhere.
    In this case, `b` defines two additional routes: `/b/a` and `/b/b`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the example router definition for `rootRouter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the definitions for routes `/b/a`, `/b/b`, `/c/a`, and `/c/b` do
    not exist in `rootRouter`. See the example router definition for `childRouter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the routes defined in `childRouter` are independent of the ones
    defined in `rootRouter`. Child routes exist in a hierarchy, where `/b` is the
    parent path. To navigate to `BAComponent`, you must use the path `/b/a`, and to
    navigate to `CAComponent`, you use `/c/a`.
  prefs: []
  type: TYPE_NORMAL
- en: Given this example configuration, every component defined in `rootRouter` and
    their dependencies would be in the first chunk of our app and thus eagerly loaded.
    The first chunk would include the components `A`, `Master`, `Detail`, and `PageNotFound`.
    The second chunk would contain the components `BA` and `BB`. This second chunk
    would not be downloaded or loaded until the user navigated to a path starting
    with `/b`; thus, it’s lazily loaded. In a standalone configuration, this chunking
    can be granular at the component level.
  prefs: []
  type: TYPE_NORMAL
- en: I cover lazy loading standalone components in *Chapter 8*, *Recipes – Reusability,
    Forms, and Caching*, when we add shared components used across different modules.
  prefs: []
  type: TYPE_NORMAL
- en: You can read about it more in detail at [https://angular.io/guide/standalone-components#lazy-loading-a-standalone-component](https://angular.io/guide/standalone-components#lazy-loading-a-standalone-component).
  prefs: []
  type: TYPE_NORMAL
- en: We will now go over how to set up a feature module with components and routes.
    We will also use Angular DevTools to observe the effects of our various router
    configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring feature modules with components and routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The manager module needs a landing page, as shown in this mock-up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B20960_04_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.9: Manager’s dashboard'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by creating the home screen for `ManagerModule`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `ManagerHome` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To create the new component under the `manager` folder, we must prefix `manager/`before
    the component name. Since this is another landing page, it is unlikely to be complicated
    enough to require separate HTML and CSS files. You can use `--inline-style` (alias
    `-s`) and/or `--inline-template` (alias `-t`) to avoid creating additional files.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Verify that your folder structure looks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Configure the `ManagerHome` component’s route in `manager-routing.module.ts`,
    similar to how we configured the `Home` `component` in `app.route.ts`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that `http://localhost:4200/manager` doesn’t resolve to a component yet,
    because our Angular app isn’t aware that `ManagerModule` exists. Eager-loading
    modules in a standalone project simply don’t make sense; we will only consider
    the lazy loading of a feature module.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s implement lazy loading for `ManagerModule`, so Angular can navigate
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy loading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Lazy loading code may seem like black magic (aka misunderstood) code. To load
    routes from a different module, we know we can’t simply import them; otherwise,
    they will be eagerly loaded. The answer lies in configuring a route using the
    `loadChildren` attribute with an inline `import` statement informing the router
    how to load a feature module in `app.routes.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `app.routes.ts`, implement or update the `''manager''` path with the `loadChildren`
    attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Lazy loading is achieved via a clever trick that avoids using an `import` statement
    at the file level. A function delegate is set to the `loadChildren` property,
    which contains an inline `import` statement defining the location of the feature
    module file, such as `./manager/manager.module`, allowing us to refer to `ManagerModule`
    in a type-safe manner without fully loading it. The inline `import` statement
    can be interpreted during the build process to create a separate JavaScript chunk
    that can be downloaded only when needed. `ManagerModule` is self-sufficient as
    a feature module; it manages all its child dependencies and routes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `manager-routing.module.ts` routes, considering that `manager` is
    now their root route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can now update the route for `ManagerHomeComponent` to a more meaningful
    `'home'` path. This path won’t clash with the one found in `app.routes.ts` because,
    in this context, `'home'` resolves to `'manager/home'` and, similarly, where `path`
    is empty, the URL will look like `http://localhost:4200/manager`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Restart your `ng serve` or `npm start` command, so Angular can chunk the app
    properly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to `http://localhost:4200/manager`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Confirm that lazy loading is working by observing the CLI output contains a
    new **Lazy Chunk Files** section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have successfully set up a feature module with lazy loading. Next, let’s
    implement the walking skeleton for LemonMart.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the walking skeleton
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the site map we created for LemonMart earlier in the chapter, we need
    to create the walking skeleton navigation experience for the app. To create this
    experience, we must create some buttons to link all modules and components together.
    We will go at this module by module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start, update the `Login` button on `HomeComponent` to navigate to
    the `''manager''` path using the `routerLink` attribute and rename the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can navigate to the `ManagerHome` component by clicking on the **Login**
    button.
  prefs: []
  type: TYPE_NORMAL
- en: The manager module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we already enabled lazy loading for `ManagerModule`, let’s go ahead and
    complete the rest of the navigational elements for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the current setup, `ManagerHomeComponent` renders in `<router-outlet>` defined
    in `AppComponent`''s template, so when the user navigates from `HomeComponent`
    to `ManagerHomeComponent`, the toolbar implemented in `AppComponent` remains in
    place. See the following mock-up for **Manager’s Dashboard**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A close-up of a login form  Description automatically generated with low
    confidence](img/B20960_04_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.10: App-wide and feature module toolbars'
  prefs: []
  type: TYPE_NORMAL
- en: The app-wide toolbar remains in place no matter where we navigate to. Imagine
    that we can implement a similar toolbar for the feature module that persists throughout
    `ManagerModule`. So, the navigational **User Management** and **Receipt Look-up**
    buttons would always be visible. This allows us to create a consistent UX for
    navigating subpages across modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement a secondary toolbar, we need to replicate the parent-child relationship
    between `AppComponent` and `HomeComponent`, where the parent implements the toolbar
    and `<router-outlet>` so that child elements can be rendered in there:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating the base `manager` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `--flat` option skips directory creation and places the component directly
    under the `manager` folder, just like `AppComponent` residing directly under the
    `app` folder.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `ManagerComponent`, implement a navigational toolbar with `activeLink` tracking:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In a standalone project, every new component is created as a standalone component.
    This means that every component must import its own dependencies. Don’t forget
    to granularly import every feature used in the template.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create components for the subpages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the parent-children routing. We know that we need the following routes
    to be able to navigate to our subpages, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To target `<router-outlet>` defined in `ManagerComponent`, we need to create
    a parent route first and then specify routes for the subpages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now be able to navigate through the app. When you click on the **Login
    as Manager** button, you will be taken to the page shown here. The clickable targets
    are highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B20960_04_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.11: Manager’s Dashboard with all router links highlighted'
  prefs: []
  type: TYPE_NORMAL
- en: If you click on **LemonMart**, you will be taken to the home page. If you click
    on **Manager’s Dashboard**, **User Management**, or **Receipt Lookup**, you will
    be navigated to the corresponding subpage, while the active link will be bold
    and underlined on the toolbar.
  prefs: []
  type: TYPE_NORMAL
- en: User module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Upon login, users can access their profiles and view a list of actions they
    can access in the LemonMart app through a side navigation menu. In *Chapter 6*,
    *Implementing Role-Based Navigation*, when we implement authentication and authorization,
    we will be receiving the role of the user from the server. Based on the user’s
    role, we can automatically navigate or limit the options users can see. We will
    implement these components in this module so that they will only be loaded once
    a user is logged in. To complete the walking skeleton, we will ignore authentication-related
    concerns:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the necessary components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Implement routing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start with implementing the lazy loading in `app.routes.ts`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As explained earlier, ensure that the `PageNotFoundComponent` route is always
    the last route in `app.routes.ts` – because it has a wildcard matcher, it will
    overwrite routes defined after it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now implement the child routes in `user-routing.module.ts`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are implementing routing for `NavigationMenuComponent` because it’ll be directly
    used as an HTML element. In addition, since `UserModule` doesn’t have a landing
    page, there’s no default path defined.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `AppComponent`, wire up the `user` and `logout` icons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Icon buttons can be cryptic, so it’s a good idea to add tooltips. For tooltips
    to work, switch from the `mat-icon-button` directive to the `mat-mini-fab` directive
    and ensure you import `MatTooltipModule` as required. In addition, ensure that
    you add `aria-label` for icon-only buttons so that users with disabilities relying
    on screen readers can still navigate your web application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Ensure that the app works.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You’ll note that the two buttons are too close to each other, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![A green and white flag  Description automatically generated with low confidence](img/B20960_04_12.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 4.12: Toolbar with icons'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can fix the icon layout issue by adding `fxLayoutGap="8px"` to `<mat-toolbar>`;
    however, now the lemon logo is too far apart from the app name, as shown:![](img/B20960_04_13.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.13: Toolbar with padded icons'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The logo layout issue can be fixed by merging the icon and the button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As shown in the following screenshot, the grouping fixes the layout issue:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B20960_04_14.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 4.14: Toolbar with grouped and padded elements'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Another alternative is to wrap the text around `<span>`; however, in that case,
    you need to add some padding to maintain the look:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is more desirable from a UX perspective; now, users can return to the home
    page by clicking on the lemon.
  prefs: []
  type: TYPE_NORMAL
- en: POS and inventory modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our walking skeleton presumes the role of the manager. To be able to access
    all the components we are about to create, we need to enable the manager to be
    able to access the POS and inventory modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `ManagerComponent` with two new buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Note that these router links will navigate us out of the realm of `ManagerModule`,
    so it is normal for the manager-specific secondary toolbar to disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it’ll be up to you to implement the last two remaining modules. For the
    two new modules, I provide high-level steps and refer you to a previous module
    on which you can model the new one. If you get stuck, refer to the `projects/stage7`
    folder on the GitHub project at [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart).
  prefs: []
  type: TYPE_NORMAL
- en: PosModule
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`PosModule` is very similar to `UserModule`, except that `PosModule` was a
    default path. `PosComponent` will be the default component. This has the potential
    to be a complicated component with some subcomponents, so don’t use inline templates
    or styles:'
  prefs: []
  type: TYPE_NORMAL
- en: Create `PosComponent`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register `PosComponent` as the default path.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure lazy loading for `PosModule`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that the app works.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now let’s implement `InventoryModule`.
  prefs: []
  type: TYPE_NORMAL
- en: InventoryModule
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`InventoryModule` is very similar to `ManagerModule`, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B20960_04_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.15: Inventory Dashboard mock-up'
  prefs: []
  type: TYPE_NORMAL
- en: Create a base `Inventory` component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register `MaterialModule`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create **Inventory Home**, **Stock Entry**, **Products**, and **Categories**
    components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure parent-children routes in `inventory-routing.module.ts`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure lazy loading for `InventoryModule`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a secondary toolbar for internal `InventoryModule` navigation in `InventoryComponent`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Ensure that the app works, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with low
    confidence](img/B20960_04_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.16: LemonMart Inventory Dashboard'
  prefs: []
  type: TYPE_NORMAL
- en: Now that the walking skeleton of the app is completed, it is important to inspect
    the CLI output to ensure that all expected modules or components are being lazy
    loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to resolve any testing errors before moving on. Ensure that `npm test`
    and `npm run e2e` execute without errors.
  prefs: []
  type: TYPE_NORMAL
- en: Common testing module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a lot of modules to deal with, it becomes tedious to configure
    the imports and providers for each `spec` file individually. For this purpose,
    create a common testing module to contain a generic configuration that you can
    reuse across the board.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, start by creating a new .`ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: Create `common/common.testing.ts`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Populate it with common testing providers, fakes, and modules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'I have provided a `commonTestingModules` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s see a sample use of this shared configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: While `commonTestingModules` is convenient, as your application grows, it’ll
    start slowing down test runs by importing unnecessary modules. Standalone components
    go a long way to mitigate this issue since they bring their own imports with them.
    Be mindful not to overload this convenience module.
  prefs: []
  type: TYPE_NORMAL
- en: Stop! Did you ensure all your unit tests are passing? To ensure your tests are
    always passing, implement a CI pipeline in CircleCI, as demonstrated in *Chapter
    10*, *Releasing to Production with CI/CD*.
  prefs: []
  type: TYPE_NORMAL
- en: With your tests up and running, the walking skeleton for LemonMart is completed.
    Now, let’s look ahead and start thinking about what kinds of data entities we
    might be working with.
  prefs: []
  type: TYPE_NORMAL
- en: Designing around major data entities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fourth step in router-first architecture is achieving a stateless, data-driven
    design. To achieve this, it helps a lot to organize your APIs around major data
    components. This will roughly match how you consume data in various components
    in your Angular application. We will start off by defining our major data components
    by creating a rough data **Entity Relationship Diagram** (**ERD**). In *Chapter
    5*, *Designing Authentication and Authorization*, we will review the design and
    implementation of an API for the user data entity using Swagger.io and Express.js
    for REST and Apollo for GraphQL.
  prefs: []
  type: TYPE_NORMAL
- en: Defining entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start by looking at what kind of entities you would like to store and
    how these entities might relate to one another.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a sample design for LemonMart, created using [draw.io](http://draw.io):'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B20960_04_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.17: ERD for LemonMart'
  prefs: []
  type: TYPE_NORMAL
- en: Currently, whether your entities are stored in a SQL or NoSQL database is inconsequential.
    My suggestion is to stick to what you know, but if you’re starting from scratch,
    a NoSQL database like MongoDB will offer the most flexibility as your implementation
    and requirements evolve.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, you will need CRUD APIs for each entity. Considering these data elements,
    we can also imagine user interfaces around these CRUD APIs. Let’s do that next.
  prefs: []
  type: TYPE_NORMAL
- en: High-level UX design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mock-ups are important in determining what kind of components and user controls
    we will need throughout the app. Any user control or component that will be used
    across components must be defined at the root level, and others must be scoped
    with their own modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier in this chapter, we identified the sub modules and designed landing
    pages for them to complete the walking skeleton. Now that we have defined the
    major data components, we can complete mock-ups for the rest of the app. When
    designing screens at a high level, keep several things in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: Can a user complete common tasks required for their role with as little navigation
    as possible?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can users readily access all information and functionality of the app through
    visible elements on the screen?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can a user search for the data they need easily?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once a user finds a record of interest, can they drill down into detailed records
    or view related records with ease?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is that pop-up alert necessary? You know users won’t read it, right?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that there’s no one right way to design any UX, which is why when designing
    screens, you should always keep modularity and reusability in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an artifacts wiki
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier in the chapter, it is important to document every artifact
    you create. Wikis offer a way to create living documentation that can be collaboratively
    updated or edited. While Slack, Teams, email, and whiteboards offer good collaboration
    opportunities, their ephemeral nature leaves much to be desired.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, as you generate various design artifacts, such as mock-ups or design decisions,
    take care to post them on a wiki reachable by all team members:'
  prefs: []
  type: TYPE_NORMAL
- en: On GitHub, switch over to the **Wiki** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You may check out my sample wiki at [https://github.com/duluca/lemon-mart/wiki](https://github.com/duluca/lemon-mart/wiki),
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B20960_04_18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.18: GitHub.com LemonMart wiki'
  prefs: []
  type: TYPE_NORMAL
- en: When creating a wiki page, ensure that you cross-link between any other documentation
    available, such as **Readme**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that GitHub shows subpages on the wiki under **Pages**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: However, an additional summary is helpful, such as the **Design Artifacts**
    section, since some people may miss the navigational element on the right.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you complete mock-ups, post them on the wiki.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can see a summary view of the wiki here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B20960_04_19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.19: Summary view of LemonMart mock-ups'
  prefs: []
  type: TYPE_NORMAL
- en: Now that your artifacts are in a centralized place, it is accessible to all
    team members. They can add, edit, update, or groom the content. This way, your
    wiki becomes useful, living documentation of the information that your team needs,
    as opposed to a piece of documentation you feel like you’re being forced to create.
    Raise your hand if you’ve ever found yourself in that situation!
  prefs: []
  type: TYPE_NORMAL
- en: Next, integrate your mock-ups into your app, so you can collect early feedback
    from your stakeholders and test out the flow of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging mock-ups in your app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Place the mock-ups in the walking skeleton app so that testers can better envision
    the functionality that is yet to be developed. See an example of this idea in
    action here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B20960_04_20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.20: Using mock-ups in the UI to verify the flow of the app'
  prefs: []
  type: TYPE_NORMAL
- en: This will also be helpful when designing and implementing your authentication
    and authorization workflow. With the mock-ups completed, we need to implement
    a backend in *Chapter 5*, *Designing Authentication and Authorization*, before
    we can continue the implementation of LemonMart’s authentication and authorization
    workflow in *Chapter 6*, *Implementing Role-Based Navigation*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you mastered effectively using the Angular CLI to create major
    Angular components and scaffolding. You created the branding of your app, leveraging
    custom and built-in Material iconography.
  prefs: []
  type: TYPE_NORMAL
- en: You learned how to debug complicated router configurations with Angular DevTools.
    Finally, you began building router-first apps, defining user roles early on, designing
    with lazy loading in mind, and nailing down a walking-skeleton navigation experience
    early on. We went over designing around major data entities. We also covered the
    importance of completing and documenting the high-level UX design of our entire
    app so that we can properly design a great conditional navigation experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'To recap, to pull off a router-first implementation, you need to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: Develop a roadmap and scope.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Design with lazy loading in mind.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a walking-skeleton navigation experience.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Achieve a stateless, data-driven design.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enforce a decoupled component architecture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Differentiate between user controls and components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Maximize code reuse with TypeScript and ES6.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this chapter, you executed steps 1-3; in the following chapters, you will
    execute steps 4-7\. In *Chapter 5*, *Designing Authentication and Authorization*,
    you will see a concrete full-stack implementation using the minimal MEAN stack.
    In *Chapter 6*, *Implementing Role-Based Navigation,* and *Chapter 7*, *Working
    with REST and GraphQL APIs*, we will tap into OOP design and inheritance and abstraction,
    along with a deep dive into security considerations and designing a conditional
    navigation experience. *Chapter 8*, *Recipes – Reusability, Forms, and Caching*,
    and *Chapter 9*, *Recipes – Master/Detail, Data Tables, and NgRx*, will tie everything
    together by sticking to a decoupled component architecture, smartly choosing between
    creating user controls and components, and maximizing code reuse with various
    TypeScript, RxJS, and Angular coding techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we haven’t implemented a lazy loading component. As a challenge, following
    the documentation at [https://angular.io/guide/standalone-components](https://angular.io/guide/standalone-components),
    update `app.route.ts` so that `PageNotFoundComponent` is lazy loaded. After you
    complete your update, verify that the CLI output correctly shows the new chunked
    file, and also open up the **Network** tab in DevTools to watch the chunks being
    downloaded as you navigate the app.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'DevTools overview: [https://angular.io/guide/devtools](https://angular.io/guide/devtools)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Material Design: [https://m3.material.io](https://m3.material.io)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Getting Started with Standalone Components*, Google, August 30, 2023: [https://angular.io/guide/standalone-components](https://angular.io/guide/standalone-components)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Webpack module bundler: [https://webpack.js.org/](https://webpack.js.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions as best as possible to ensure you’ve understood
    the key concepts from this chapter without googling anything. Do you know if you
    got all the answers right? Visit [https://angularforenterprise.com/self-assessment](https://angularforenterprise.com/self-assessment)
    for more:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between the root module and a feature module?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the benefits of lazy loading?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How’s a standalone component different from a module?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why do we create a walking skeleton of our application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What’s the benefit of designing around major data entities?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should we create wikis for our projects?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
