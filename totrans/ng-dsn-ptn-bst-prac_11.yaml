- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Micro Frontend with Angular Elements
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As your application grows and becomes more complex, one team alone is not enough
    to maintain the growth rate, and new people are needed to handle other parts of
    the application as they appear. At this point, the architecture of your project
    needs to evolve, and one possibility is to divide your application into several
    projects that are integrated as one. This practice was born in the world of backend
    services and appears in the frontend world under the name of **micro frontends**.
    In this chapter, we will learn how to apply this principle in an Angular project.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Micro frontend – concepts and application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Slicing your application in the micro frontend
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a micro frontend application with standalone components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing a page to be loaded by the base application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamically loading micro frontends
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to assess when it is necessary
    to use a micro frontend, how to organize your Angular projects, and how to integrate
    it into a cohesive application.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow the instructions in this chapter, you’ll need the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code ([https://code.visualstudio.com/Download](https://code.visualstudio.com/Download))
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js 18 or higher ([https://nodejs.org/en/download/](https://nodejs.org/en/download/))
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code files for this chapter are available at [https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch11](https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch11).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Before you start reading this chapter, remember to run the backend of the application
    found in the `gym-diary-backend` folder with the `npm` `start` command.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Micro frontend – concepts and application
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In 2014, an article by Martin Fowler and James Lewis ([https://martinfowler.com/articles/microservices.html](https://martinfowler.com/articles/microservices.html))
    shook the world of development with the formalization of the concept of microservices.
    Focused on the development of backend services, the idea of dividing a large system
    (known as a monolith) into small, independent services focused on just one aspect
    of the business was undoubtedly a milestone for system architecture.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Not long after, this concept was applied to the frontend world, with one of
    the main articles written by Cam Jackson ([https://martinfowler.com/articles/micro-frontends.html](https://martinfowler.com/articles/micro-frontends.html)).
    The basic idea of the *micro frontend* is the same as its sibling, *microservices*,
    which consists of dividing a large frontend project (monolith) into small, independent
    projects focused on one aspect of the business. However, the concerns are different,
    of course. In microservices, we worry about databases and communication protocols,
    whereas on the frontend, we need to worry about packet size, accessibility, and
    user experience.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by analyzing whether you need to use this type of architecture for
    your project.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: When to use a micro frontend
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A big but very true cliché in systems architecture is that there is no silver
    bullet – that is, there is no one-size-fits-all solution for all problems – and
    micro frontends cannot escape this cliché. The main advantage of this architecture,
    before any technical aspect, is its organizational aspect.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: When we use the micro frontend, we are separating an independent part focused
    on one aspect of the business that will be handled by a team specializing in that
    aspect. With this, your project can scale across different teams dealing with
    specific subjects that will be integrated into an experience for your user. Each
    team has autonomy in the delivery cycle of this project, with independence from
    build, deployment, and testing. Independence can reach a level where teams can
    work with different versions of Angular and even different frameworks such as
    React and Vue, although this is not highly recommended, as we will discuss in
    the next section.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: When not to use a micro frontend project
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another software engineering cliché is that there is no free lunch, and choosing
    to use micro frontends has its costs and challenges.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: The first challenge is the performance issue of your frontend. As we saw in
    [*Chapter 1*](B19562_01.xhtml#_idTextAnchor017), *Starting Projects the Right
    Way*, in a **single-page application** (**SPA**), the user’s browser downloads
    the application bundle containing the Angular framework code, in addition to the
    code that your team produced. After this download, the browser interprets the
    bundle and renders the pages for the user. This entire process must be as quick
    and efficient as possible because, while it is occurring, the user cannot interact
    with the screen, causing frustration.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Now imagine this process happening in every part of your system because, to
    guarantee version and even framework independence, each micro frontend carries
    its framework engine in the specific version. There are techniques and tools such
    as webpack’s module federation ([https://webpack.js.org/concepts/module-federation/](https://webpack.js.org/concepts/module-federation/)),
    but you and your team must evaluate this challenge.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Another care we must take is concerning the user experience and the design of
    the components on screen because, for them, the components between interfaces
    must be fundamentally the same to guarantee cohesion in their experience.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: This challenge can be overcome by implementing a design system – that is, a
    single design guide for your company’s components, preferably with a library that
    supports it. An example of a design system is Google’s Material Design.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a basic understanding of micro frontends, let’s move on to
    the next section, where we will explore how to split our application into micro
    frontends.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Slicing your application into micro frontends
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To maximize gains from the micro frontend architecture and minimize the risks
    defined in the previous section, we need to create microservices that are as independent
    as possible and that make sense for your team’s organization.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最大限度地从微前端架构中获得收益并最小化前一部分定义的风险，我们需要创建尽可能独立且对团队组织有意义的微服务。
- en: The most common type of project organization is the verticalization of functionalities
    – that is, for one project you might have an entire user journey, such as a product
    purchase screen, another project for product registration, and another for the
    administration module of the application.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的项目组织类型是功能垂直化 – 也就是说，对于一个项目，你可能有一个完整的用户旅程，例如产品购买屏幕，另一个项目用于产品注册，另一个用于应用的管理模块。
- en: '![Figure 11.1 – Micro frontend division](img/B19562_11_1.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1 – 微前端划分](img/B19562_11_1.jpg)'
- en: Figure 11.1 – Micro frontend division
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – 微前端划分
- en: This diagram exemplifies the concept of division using an Angular application.
    In each project, we have all the components for the user experience.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此图使用Angular应用程序展示了划分的概念。在每一个项目中，我们都有用户体验的所有组件。
- en: You may be wondering, “*Can I achieve this same separation using Angular modules?*”
    and the answer is yes, you can. If a team takes care of all the modules for your
    company’s organization or the teams can organize themselves into just one project,
    you can (and even should) do this.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，“*我能否使用Angular模块实现这种相同的分离？*”答案是肯定的，你可以。如果一个团队负责你公司组织的所有模块，或者团队可以组织成只有一个项目，那么你可以（甚至应该）这样做。
- en: We need to keep in mind that the reason for dividing your project into micro
    frontends is to meet an organizational requirement of your project, and teams
    want to have deployment and development independence.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要记住，将你的项目划分为微前端的原因是为了满足项目的一个组织需求，并且团队希望拥有部署和开发的独立性。
- en: With the basic concepts in mind, we will exemplify how to implement them in
    our gym diary project.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在心中牢记基本概念后，我们将展示如何在我们的健身日记项目中实现它们。
- en: Creating a micro frontend application with standalone components
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用独立组件创建微前端应用程序
- en: 'To exemplify the use of the micro frontend architecture in our gym diary, we
    will create a form to define new exercises for our users. Let’s create another
    Angular project, simulating a new team that will specifically take care of this
    functionality. In your operating system’s command line, use the following command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的健身日记中展示微前端架构的使用，我们将创建一个表单来定义用户的新练习。让我们创建另一个Angular项目，模拟一个专门负责这个功能的团队。在你的操作系统命令行中，使用以下命令：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We learned about the `ng new` command in [*Chapter 1*](B19562_01.xhtml#_idTextAnchor017),
    *Starting Projects the Right Way*, but here we are using some parameters that
    we haven’t seen before. We are using the `skip-git` parameter because, in this
    example, we are creating it in the same Git project (which already has the `gym-diary`
    and `gym-backend` projects). The `routing` parameter is set to `false` because
    our project will be loaded in the diary application route, and the `style` parameter
    is set to `CSS` so the Angular CLI does not need to ask what type of styling our
    project will have.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第一章*](B19562_01.xhtml#_idTextAnchor017)，“正确开始项目”，学习了`ng new`命令，但在这里我们使用了一些之前没有见过的参数。我们使用`skip-git`参数是因为，在这个例子中，我们是在同一个Git项目中创建的（该项目中已经包含了`gym-diary`和`gym-backend`项目）。`routing`参数设置为`false`，因为我们的项目将在日记应用的路由中加载，`style`参数设置为`CSS`，这样Angular
    CLI就不需要询问我们的项目将有什么类型的样式。
- en: The biggest difference in this command is `standalone`, which parameterized
    our project to create all components as standalone by default. But you might be
    wondering what a `standalone` component is. Created from version 15 of Angular,
    this feature allows you to create a component without using Angular modules (`NgModule`).
    Although modules are very important, as we saw in [*Chapter 2*](B19562_02.xhtml#_idTextAnchor081),
    *Organizing Your Application*, there are cases in which they are not very useful
    and make the project unnecessarily complicated. A good example of this is in small
    projects with a limited scope, such as this micro frontend, where we will not
    have multiple routes or lazy loading.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start creating the exercise form, let’s add and configure the Tailwind
    CSS framework, as we want to have a style compatible with our main application.
    Inside the created project folder, run the following command from the command
    line of your operating system:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This command will add development dependencies to the project and create configuration
    files in the Tailwind CSS framework.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `tailwind.config.js` file, make the following changes:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this file, we are telling Angular that it will apply the Tailwind CSS framework
    to all HTML files in the `src` folder.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, add the following lines of code to the `app.component.css` file:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With these CSS variables, the component will have access to the `tailwindcss`
    class.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'We will then create a service that will be responsible for interacting with
    our backend’s exercise API. On the command line, we will use the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Note a detail of our architecture: we already have a service that queries the
    exercise API in our main project, but we cannot reuse it here because they are
    independent projects, and certain code duplication is a cost of this architecture.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the best practices, we will create our API as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we are recreating the types that represent the API data. For more details
    about TypeScript interfaces, you can consult [*Chapter 3*](B19562_03.xhtml#_idTextAnchor112),
    *TypeScript Patterns* *for Angular*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'In the created service, we will add interaction with the backend:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the service, we are making HTTP requests to consult exercises and add new
    ones. For more details about Angular services, you can consult [*Chapter 5*](B19562_05.xhtml#_idTextAnchor163),
    *Angular Services and the Singleton Pattern*, and [*Chapter 9*](B19562_09.xhtml#_idTextAnchor242),
    *Exploring Reactivity* *with RxJS*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: However, we are experiencing an error because we are not importing the `HttpClientModule`
    module. But how can we import it if we don’t have a module in a standalone component?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'In a project without modules, the import happens in the component itself; for
    services, we have the `app.config.ts` file, and we will add the import to it:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that we are importing the `provideHttpClient` provider and not the module.
    This happens because this provider was created by the Angular team to handle these
    standalone application cases.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'In the main components of the application, we will code its behavior as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let’s first highlight the component configuration in the `@Component` decorator
    metadata. The `standalone` property means that this component can be used directly
    without being declared in any module. In the `imports` property, we declare its
    dependencies, which are `CommonModule`, the basis for any Angular component, and
    `ReactiveFormsModule`, as we will be developing a reactive form (for more details
    about the form, read [*Chapter 6*](B19562_06.xhtml#_idTextAnchor186), *Handling
    User Input: Forms*). In the component, we are injecting `NonNullableFormBuilder`
    and `ExercisesService` and we take the initial list and assign it to the `exerciseList$`
    attribute. We create the form object with the `formBuilder` service, and finally,
    we create the `newExercise` method responsible for the **Submit** button.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: As we will have the list of exercises in the same form, in the `subscribe` method,
    we assign the `exerciseList$` attribute again to refresh the list.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'To finish the component, let’s create its template as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the first part, we have the list of exercises, and here we are using Angular’s
    `async` pipe to subscribe and search the list (for more details, read [*Chapter
    9*](B19562_09.xhtml#_idTextAnchor242), *Exploring Reactivity* *with RxJS*).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same template file, we will add the form:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We created a reactive form with just the **Description** field and added simple
    validation.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'By running our application with the `ng serve` command, we will have the following
    interface:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Exercise form](img/B19562_11_2.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – Exercise form
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: With our micro frontend project ready, we can prepare it to be consumed by our
    main application.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Preparing a page to be loaded by the base application
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our micro frontend project ready, we need to prepare it to be consumed
    by another application. There are several ways to share micro frontends, from
    the simplest (and obsolete), with the use of iframes, to more modern, but complex,
    solutions such as module federation.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will use an approach widely used in the market, which is
    the use of Web Components. Web Components is a specification that aims to standardize
    components created by different frameworks into a model that can be consumed between
    them. In other words, by creating an Angular component following this specification,
    an application created in React or Vue could consume this component. Although
    Web Components was not created with micro frontend projects in mind, we can see
    that its definition fits perfectly for what we need.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'Like almost everything in the Angular framework, to create this type of component,
    we don’t need to do it manually, as the Angular team created a tool for this:
    Angular elements. An Angular element component is a common component but *transpiled*
    to the Web Components standard, packaging not only our code but also the Angular
    rendering engine, making it framework agnostic.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add it to our `gym_exercises` project on the command line of our operating
    system with the following command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With the preceding command, we add the `angular/elements` dependency to our
    project, and to use it, we will make a change to the `angular.json` file:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The component generated by Angular elements will encapsulate the Tailwind CSS
    framework, so we need to increase the component size budget a little to avoid
    errors when building the project.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'The next change we must make is to the project’s `main.ts` file:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This file is responsible for configuring the initialization of an Angular project,
    and we normally do not change it as we want standard SPA build and execution behavior.
    However, here, we need to change it to inform Angular that the result of this
    project will be a web component generated by the Angular elements package. Here,
    we are configuring the project so that the application will generate a web component
    whose tag name will be `exercise-form`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to change the `index.html` file to understand this new tag so that
    we can render our micro frontend for testing:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we change the default `<app-root>` Angular component with the Web Components
    `<exercise-form> tag`. Our main application will be our micro frontend JavaScript,
    but the change to `index.html` will allow you and your team to maintain the micro
    frontend without needing to load the main project.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have a challenge in that, despite creating a web component, the project
    build is creating it in three files and with hashes, which is correct if our application
    is not a micro frontend, but in our case, we would like to have all the code in
    a single file and without the hash. We can do this manually, but the community
    has a package that automates this treatment: the `ngx-build-plus` package.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add it to the command line with the help of the Angular CLI:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To serve this micro frontend, we will use the `http-server` package, and add
    it with `npm` on the command line:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, let’s create some `npm` scripts to make running `mfe` easier. In the
    `package.json` file, we will make the following change:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the `build` script, we specify our intention to run it, resulting in a single
    generated file (`--single-bundle`). We also instruct it to retain and encapsulate
    the CSS (`--bundle-styles --keep-styles`) while ensuring that the generated file’s
    name does not include any type of hash (`--output-hashing=none`).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: The `serve-mfe` script uses the `http-server` service to publish the contents
    of the `dist` folder that will contain the compiled micro frontend.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run our project with the following command and check the micro frontend
    we created:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: By accessing `http://127.0.0.1:8080`, we can see that our micro frontend application
    is being generated successfully.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: With our micro frontend ready to be consumed, in the next section, we will consume
    it in the main application.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically loading micro frontends
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s prepare our main application gym diary to consume the micro frontend
    that we prepared previously. To do this, let’s start by creating a new module
    in the application. On the command line, we will use the following Angular CLI
    commands:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: With the preceding commands, we create the module with the generated route file
    and a component that will be responsible for loading `mfe`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s adjust the `exercise-routing.module.ts` file to target the component:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the `routes` array, we define a base route for the exercise registration
    component as it will be loaded via lazy loading.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will refactor the `home-routing.module.ts` file as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Our `HomePage` module contains the menu, and in this section, we are adding
    the new module to be loaded in the correct area of the interface.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'To finish adding this new module, let’s change the `home.component.html` file:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: With the new menu item added to the `home` template, we now have the task of
    including the micro frontend generated in the other project in our interface.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, we have a community package called `@angular-extensions` that allows
    us to load our micro frontend simply using a directive, as we will see later.
    But first, let’s install this dependency in our project using the following command:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once installed, we can change the `ExerciseModule` module:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this file, we are first adding the library module called `LazyElementsModule`
    to have access to the directive that we will use in the component. Furthermore,
    we have a new property in the metadata called `schemas`. In it, we are informing
    Angular with the `CUSTOM_ELEMENTS_SCHEMA` token that this module will receive
    elements from outside the project. By default, Angular checks whether the tag
    used in the template exists in the project or in the HTML standard, such as the
    `input` tag.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: As we are going to import the `exercise-form` tag defined by our micro frontend
    here, this attribute will prevent Angular from carrying out this check at the
    project compile time.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `exercise.component.ts` file, we will add a new attribute:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, we are defining the address where the micro frontend’s main files will
    be served.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let’s change the component template:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, we are declaring the new `exercise-form` element, and to load it, we use
    the `axLazyElement` directive assigning the micro frontend address.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'To run our project, make sure the micro frontend is being served with the `npm
    run serve-mfe` command. With everything configured, we can see the result of our
    work:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19562_11_3.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – Exercise form dynamically loaded into the main application
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the architecture of micro frontends and how to
    apply one to an Angular project.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了微前端架构以及如何将其应用于Angular项目。
- en: We learned about the concept of the architecture, its advantages, and its trade-offs.
    We explored how the main reason for opting for this architecture is its flexibility
    in relation to the organizational structure of each team, as several teams can
    work on different parts of the frontend project independently.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解了架构的概念、其优势及其权衡。我们探讨了选择这种架构的主要原因是其与每个团队组织结构的灵活性，因为几个团队可以独立地工作在前端项目的不同部分。
- en: We also learned how we can ideally divide our application into micro frontends.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了如何理想地将我们的应用程序划分为微前端。
- en: With all these concepts, we applied our project by creating a small application
    using Angular’s standalone components feature and preparing it to be loaded by
    another project using the Angular elements library.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些概念的基础上，我们通过创建一个小型应用程序并利用Angular的独立组件功能，以及准备使用Angular元素库加载它，来应用我们的项目。
- en: Finally, we performed dynamic loading in our main application with the help
    of the `@``angular-extensions/elements` library.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在主应用程序中借助`@angular-extensions/elements`库实现了动态加载。
- en: In the next chapter, we will explore the best practices for deploying an Angular
    application.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨部署Angular应用程序的最佳实践。
