- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Advanced Session Management
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级会话管理
- en: Session management is crucial to building good user experiences. Persisting
    session data can increase the user’s experience and productivity by remembering
    user settings, selections, and preferences.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 会话管理对于构建良好的用户体验至关重要。通过记住用户设置、选择和偏好，持久化会话数据可以提高用户体验和生产力。
- en: We learned how to manage user sessions in [*Chapter 8*](B17399_08.xhtml#_idTextAnchor119),
    *Session Management*. In this chapter, we will work on advanced session management
    patterns.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第8章*](B17399_08.xhtml#_idTextAnchor119)，*会话管理*中学习了如何管理用户会话。在本章中，我们将研究高级会话管理模式。
- en: 'This chapter is split into two sections:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章分为两个部分：
- en: Managing visitor sessions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理访客会话
- en: Implementing pagination
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现分页
- en: First, we will implement visitor sessions and use Remix’s cookie helper to redirect
    the user to the right page after login or signup. Next, we will learn how to add
    pagination with Remix and Prisma. We will practice pagination by applying it to
    the expense and invoice lists in BeeRich.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将实现访客会话，并使用Remix的cookie辅助函数在登录或注册后重定向用户到正确的页面。接下来，我们将学习如何使用Remix和Prisma添加分页。我们将通过将分页应用于BeeRich中的费用和发票列表来练习分页。
- en: After reading this chapter, you will know how to use cookies to persist arbitrary
    session data in Remix. You will also understand the difference between Remix’s
    session cookie and cookie helpers. Additionally, you'll learn when to store session
    data in a cookie versus in a database. Finally, you will understand how to implement
    pagination with Remix.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章后，您将了解如何使用cookie在Remix中持久化任意会话数据。您还将理解Remix的会话cookie和cookie辅助函数之间的区别。此外，您还将学习何时将会话数据存储在cookie中，而不是数据库中。最后，您将了解如何使用Remix实现分页。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find the code for this chapter here: [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/15-advanced-session-management](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/15-advanced-session-management).
    No extra setup is required for this chapter.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到本章的代码：[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/15-advanced-session-management](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/15-advanced-session-management)。本章不需要额外的设置。
- en: Managing visitor sessions
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理访客会话
- en: In [*Chapter 8*](B17399_08.xhtml#_idTextAnchor119), *Session Management*, we
    used Remix’s session cookie helpers to implement a login and signup flow. In this
    section, we will use Remix’s cookie helper to persist additional session data.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第8章*](B17399_08.xhtml#_idTextAnchor119)，*会话管理*中，我们使用了Remix的会话cookie辅助函数来实现登录和注册流程。在本节中，我们将使用Remix的cookie辅助函数来持久化额外的会话数据。
- en: You might remember from [*Chapter 8*](B17399_08.xhtml#_idTextAnchor119), *Session
    Management*, that cookies are added on the server to an HTTP response using the
    **Set-Cookie** header. Once received, the browser attaches the cookie to all subsequent
    HTTP requests using the **Cookie** header.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得在[*第8章*](B17399_08.xhtml#_idTextAnchor119)，*会话管理*中，cookie是通过**Set-Cookie**头在服务器上添加到HTTP响应中的。一旦收到，浏览器会使用**Cookie**头将cookie附加到所有后续的HTTP请求中。
- en: In Remix, we can access incoming HTTP requests in our `loader` and `action`
    functions. In our loaders and actions, we can use Remix’s cookie helper functions
    to parse the cookie data from the request headers and use it to improve the user
    experience.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在Remix中，我们可以在`loader`和`action`函数中访问传入的HTTP请求。在我们的加载器和操作中，我们可以使用Remix的cookie辅助函数来解析请求头中的cookie数据，并使用它来提升用户体验。
- en: In BeeRich, we already utilize a cookie to handle the authentication of our
    users. However, there are plenty of other use cases for cookies.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在BeeRich中，我们已利用cookie来处理用户的身份验证。然而，cookie还有许多其他用例。
- en: 'Consider the following advanced use case: we aim to offer visitors a taste
    of our app’s functionality without requiring an account. Visitors should be able
    to directly interact with the content. At some point, the visitor decides to create
    an account. Now, we want to ensure that the data associated with the visitor is
    transferred to the new user account. How can we make this work?'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下高级用例：我们旨在向访客提供我们应用程序功能的一瞥，而不需要账户。访客应能够直接与内容互动。在某个时刻，访客决定创建账户。现在，我们想要确保与访客关联的数据被转移到新的用户账户。我们如何实现这一点？
- en: Depending on the use case, session data can be persisted using local storage,
    cookies, memory, or databases. We could store all generated data directly in local
    storage or a cookie and only commit it to the database once the user account has
    been created. However, this only works if the data is not meant to be visible
    to other users.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 根据使用场景，会话数据可以使用本地存储、cookies、内存或数据库进行持久化。我们可以直接将所有生成数据存储在本地存储或cookie中，并在用户账户创建后一次性提交到数据库。然而，这种方法仅适用于数据不打算对其他用户可见的情况。
- en: What if we want to treat the visitor-generated content like the content of any
    other user? First, we must assign the visitor a unique identifier that can be
    tracked across different page transitions. Whenever the visitor triggers a mutation,
    we associate the persisted data with the unique identifier. Once the visitor signs
    up, we migrate all data associated with the visitor identifier to the new user
    account.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望将访客生成的内容视为任何其他用户的内容？首先，我们必须为访客分配一个唯一的标识符，以便在不同页面转换之间进行跟踪。每当访客触发一个变更时，我们将持久化数据与唯一标识符关联。一旦访客注册，我们将与访客标识符关联的所有数据迁移到新的用户账户。
- en: Generating a unique session identifier is a common pattern when handling sessions,
    and storing it in a cookie is a great way to ensure we have access to the identifier
    on the server. This example illustrates how powerful cookies are. Cookies can
    be utilized to implement complex user interfaces and features. However, cookies
    can also be used to persist short-living session data.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理会话时生成一个唯一的会话标识符是一个常见的模式，将其存储在cookie中是确保我们可以在服务器上访问标识符的好方法。这个例子说明了cookie有多么强大。cookie可以用来实现复杂用户界面和功能。然而，cookie也可以用来持久化短暂会话数据。
- en: Let’s practice working with Remix’s cookie helpers by implementing a redirect
    flow after login and signup in BeeRich. If a user attempts to visit a dashboard
    page without authorization, we currently redirect to the login page. Once the
    user logs in or signs up, we navigate the user to `/dashboard`. We now want to
    update this logic and navigate the user to the initially requested dashboard page.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在BeeRich中实现登录和注册后的重定向流程来练习使用Remix的cookie助手。如果一个用户未经授权尝试访问仪表板页面，我们目前将其重定向到登录页面。一旦用户登录或注册，我们将用户导航到`/dashboard`。现在我们想要更新这个逻辑，并将用户导航到最初请求的仪表板页面。
- en: 'We’ll start by creating a visitor cookie:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个访客cookie：
- en: Create a `visitors.server.ts` file in `app/modules`.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app/modules`中创建一个`visitors.server.ts`文件。
- en: 'Next, import `createCookie` from Remix and create a `visitorCookie` object:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，从Remix导入`createCookie`并创建一个`visitorCookie`对象：
- en: '[PRE0]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `createCookie` function receives a cookie name parameter and a configuration
    object. A list of possible configuration options can be found in the Remix documentation:
    [https://remix.run/docs/en/2/utils/cookies#createcookie](https://remix.run/docs/en/2/utils/cookies#createcookie).'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`createCookie`函数接收一个cookie名称参数和一个配置对象。可以在Remix文档中找到可能的配置选项列表：[https://remix.run/docs/en/2/utils/cookies#createcookie](https://remix.run/docs/en/2/utils/cookies#createcookie)。'
- en: 'Rember that Remix offers both a cookie helper utility and a session cookie
    helper utility. Refer to `session.server.ts`, where we utilize Remix’s `createCookieSessionStorage`
    function. `createCookieSessionStorage` provides three functions:'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记住，Remix提供了cookie助手实用工具和会话cookie助手实用工具。参考`session.server.ts`，我们在这里使用了Remix的`createCookieSessionStorage`函数。`createCookieSessionStorage`提供了三个函数：
- en: '`getSession`'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getSession`'
- en: '`commitSession`'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`commitSession`'
- en: '`destroySession`'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`destroySession`'
- en: 'In comparison, Remix’s `createCookie` function only provides two functions:
    `parse` and `serialize`.'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 相比之下，Remix的`createCookie`函数只提供了两个函数：`parse`和`serialize`。
- en: Session cookies are one of many implementations of Remix’s session abstraction.
    On the other hand, `createCookie` provides a simple helper to read (`parse`) and
    write (`serialize`) a cookie to and from cookie headers.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 会话cookie是Remix会话抽象的多种实现之一。另一方面，`createCookie`提供了一个简单的助手来读取（`parse`）和写入（`serialize`）cookie到和从cookie头。
- en: We use Remix’s session helpers to implement user session flows, while `createCookie`
    is a utility for reading and writing to and from cookies.
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用Remix的会话助手来实现用户会话流程，而`createCookie`是一个用于读写cookie的实用工具。
- en: 'Next, define the type of data that we will store in the visitor cookie:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，定义我们将存储在访客cookie中的数据类型：
- en: '[PRE1]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Our goal is to persist the URL the visitor wants to visit before we redirect
    them to the login page.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的目标是在将访客重定向到登录页面之前，持久化访客想要访问的URL。
- en: For instance, imagine a user is logged in and working on the dashboard of BeeRich.
    The user then returns a few days later and wants to continue managing their finances
    with BeeRich. Since the session has expired, BeeRich redirects the user to the
    login page. So far, we’ve navigated the user back to the dashboard after a successful
    login but do not remember where exactly the user left off. Let’s change that!
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，想象一个用户登录并正在使用BeeRich的仪表板。几天后，该用户想继续使用BeeRich管理他们的财务。由于会话已过期，BeeRich将用户重定向到登录页面。到目前为止，我们在用户成功登录后已将其导航回仪表板，但我们不记得用户确切地停在了哪里。让我们改变这一点！
- en: 'In `visitors.server.ts`, create a function to get the cookie data from a request:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`visitors.server.ts`中创建一个函数来从请求中获取cookie数据：
- en: '[PRE2]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We use the cookie object to parse the `Cookie` header and extract the visitor
    cookie data.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用cookie对象来解析`Cookie`头并提取访客cookie数据。
- en: 'Similarly, create a function to write the visitor cookie data to the `Set-Cookie`
    header:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，创建一个函数将访客cookie数据写入`Set-Cookie`头：
- en: '[PRE3]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With these utilities in place, we can read the cookie data on incoming requests
    and write the cookie to the response when the user is redirected to login.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有这些实用工具在位，我们可以读取传入请求的cookie数据，并在用户被重定向到登录时将cookie写入响应。
- en: 'Import `setVisitorCookieData` in `app/modules/session/session.server.ts`:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app/modules/session/session.server.ts`中导入`setVisitorCookieData`：
- en: '[PRE4]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, update the `requireUserId` function to add the visitor cookie when redirecting
    to log in:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，更新`requireUserId`函数，在重定向到登录时添加访客cookie：
- en: '[PRE5]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, open the `_layout.login.tsx` route module and import the `getVisitorCookieData`
    function:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开`_layout.login.tsx`路由模块并导入`getVisitorCookieData`函数：
- en: '[PRE6]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Update the `_layout.login.tsx` route module’s `action` function so that it
    reads `redirectUrl` from the visitor cookie:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`_layout.login.tsx`路由模块的`action`函数，使其从访客cookie中读取`redirectUrl`：
- en: '[PRE7]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Test the implementation by running BeeRich locally.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在本地运行BeeRich来测试实现。
- en: Start by logging in and visiting a route on the dashboard. For instance, navigate
    to an expense details page. Copy the URL from the URL bar for easy access and
    log out from BeeRich.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，登录并访问仪表板上的一个路由。例如，导航到支出详情页面。从地址栏复制URL以方便访问，然后从BeeRich注销。
- en: Now, enter the copied URL into the URL bar. Since we are logged out, we are
    redirected to log in.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将复制的URL输入到地址栏中。由于我们已注销，我们被重定向到登录页面。
- en: Next, log in to your account and notice the redirect back to the requested dashboard
    page.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，登录到您的账户并注意重定向回请求的仪表板页面。
- en: Play around with the implementation a bit more. Notice that it doesn’t matter
    how often you leave the login page, close the browser tab, or reload it. For the
    five minutes before the cookie expires, the cookie persists and remembers the
    user’s latest requested URL.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实现上稍作尝试。注意，无论你离开登录页面多少次，关闭浏览器标签或重新加载它，都不会影响结果。在cookie过期前的五分钟内，cookie会持续存在并记住用户最新的请求URL。
- en: Great job! Would the same flow also make sense for signup? In BeeRich, not as
    much, as all dashboard URLs are account specific. However, imagine an application
    where you can invite your coworkers to collaborate. You may share an invite link
    for a project. A coworker joining for the first time would then be redirected
    to log in but navigate to sign up to create a new account. From there, we could
    take advantage of the visitor cookie to read the invite URL and navigate the new
    user to the collaborative project.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！同样的流程也适用于注册吗？在BeeRich中，并不适用，因为所有仪表板URL都是针对特定账户的。然而，想象一个你可以邀请同事协作的应用程序。你可能可以分享一个项目的邀请链接。第一次加入的同事将被重定向到登录页面，但会导航到注册页面以创建新账户。从那里，我们可以利用访客cookie来读取邀请URL并将新用户导航到协作项目。
- en: Practice working with the visitor cookie by implementing the same flow on the
    signup page. Follow the implementation from the `_layout.login.tsx action` function
    and read the visitor cookie data in the `_layout.signup.tsx action` function to
    navigate the user accordingly.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在注册页面上实现相同的流程来练习使用访客cookie。遵循`_layout.login.tsx action`函数的实现，并在`_layout.signup.tsx
    action`函数中读取访客cookie数据，以便相应地引导用户。
- en: In this section, you practiced working with Remix’s `createCookie` helper and
    learned more about advanced session management implementations. You now know the
    difference between Remix’s session cookie and cookie utilities. Next, we will
    implement pagination with Remix.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你练习了使用Remix的`createCookie`辅助函数，并了解了高级会话管理实现。你现在知道Remix的会话cookie和cookie实用工具之间的区别。接下来，我们将使用Remix实现分页。
- en: Implementing pagination
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现分页
- en: Pagination is an important pattern when working with large and user-generated
    lists of objects. Pagination divides the content into separate pages and thereby
    limits the number of objects that must be loaded for a given page. Pagination
    aims to reduce load times and improve performance.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 分页是在处理大型和用户生成对象列表时的重要模式。分页将内容分成单独的页面，从而限制了给定页面必须加载的对象数量。分页旨在减少加载时间并提高性能。
- en: 'In this section, we will implement pagination in BeeRich for expenses and invoices:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将为BeeRich中的费用和发票实现分页：
- en: 'First, open the `dashboard.expenses.tsx` route module and define a constant
    for the page size:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开`dashboard.expenses.tsx`路由模块，并定义一个页面大小的常量：
- en: '[PRE8]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The page size defines the number of expenses we will show at once in the expenses
    overview list. To see more expenses, the user has to navigate to the next page.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 页面大小定义了我们在费用概览列表中一次显示的费用数量。要查看更多费用，用户必须导航到下一页。
- en: 'Update the `loader` function in `dashboard.expenses.tsx` and access a new search
    parameter named `page`:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`dashboard.expenses.tsx`中的`loader`函数，并访问一个名为`page`的新搜索参数：
- en: '[PRE9]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: import type { Prisma } from '@prisma/client';
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: import type { Prisma } from '@prisma/client';
- en: '[PRE10]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, update the expenses database query so that it only queries a total of
    10 expenses for the current page, skipping all previous pages:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，更新费用数据库查询，使其只为当前页面查询总共10项费用，跳过所有之前的页面：
- en: '[PRE11]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Update the `loader` function’s return statement so that it returns both the
    expenses list and the count:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`loader`函数的返回语句，使其返回费用列表和计数：
- en: '[PRE12]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Update the `useLoaderData` call so that it reads the updated loader data:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`useLoaderData`调用，使其读取更新的加载器数据：
- en: '[PRE13]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: const [searchParams] = useSearchParams();const searchQuery = searchParams.get('q')
    || '';showPagination to either show or hide the pagination buttons.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: const [searchParams] = useSearchParams();const searchQuery = searchParams.get('q')
    || '';showPagination用于显示或隐藏分页按钮。
- en: '[PRE14]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add the following form below the expenses list (`<ul>…</ul>`):'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在费用列表（`<ul>…</ul>`）下方添加以下表单：
- en: '[PRE15]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, update the search form to reset the pagination whenever the search
    filter changes:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，更新搜索表单，以便在搜索过滤器更改时重置分页：
- en: '[PRE16]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The number of expenses may change when updating the search filter. Hence, we
    need to reset the pagination.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在更新搜索过滤器时，费用数量可能会发生变化。因此，我们需要重置分页。
- en: Run BeeRich locally and play around with the implementation. Notice that the
    URL is updated on every navigation between the pages.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本地运行BeeRich并尝试实现。注意，在页面之间导航时，URL会更新。
- en: What happens if an expense is created or deleted?
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果创建或删除费用会发生什么？
- en: Remix revalidates all loader data after every mutation. When we add an expense,
    the `loader` function is called, and the `count` loader data is updated. This
    ensures that the pagination buttons are added if the expenses exceed the first
    page. It turns out that the `loader` revalidation fixes stale data issues in almost
    every chapter of this book!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Remix在每次突变后都会重新验证所有加载器数据。当我们添加费用时，会调用`loader`函数，并更新`count`加载器数据。这确保了如果费用超过第一页，将添加分页按钮。结果证明，加载器重新验证几乎解决了本书几乎每个章节中的陈旧数据问题！
- en: Similarly, the count value is updated on deletion. However, because we redirect
    the user back to their current page after deletion, the user may remain on a page
    without expenses. For instance, if we have 11 expenses and delete the last remaining
    expense on the second page, the user ends up on an empty page.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在删除时更新计数值。然而，由于我们在删除后会将用户重定向回他们当前页面，用户可能仍然停留在没有费用的页面上。例如，如果我们有11项费用，并在第二页删除最后剩下的费用，用户最终会停留在空页面上。
- en: 'This is fine if we keep the pagination **Previous** button on the page so that
    the user can navigate to the previous page. We ensure this by always showing the
    pagination buttons if the user is not currently on the first page:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在页面上保留分页**上一页**按钮，以便用户可以导航到上一页，这是可以的。我们通过始终显示分页按钮来确保这一点，如果用户当前不在第一页：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It seems like we have all the edge cases covered! Nice work!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们已经涵盖了所有边缘情况！做得好！
- en: 'Let''s take a moment to reflect on our development journey with BeeRich. We
    have come a long way since kicking off our work on BeeRich. From the ground up,
    we''ve built an extensive feature set, including:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花点时间反思一下我们与BeeRich一起的开发之旅。自从我们开始BeeRich的工作以来，我们已经走了很长的路。从头开始，我们构建了一个功能丰富的功能集，包括：
- en: A routing hierarchy with nested routes
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有嵌套路由的路由层次结构
- en: SQLite database integration with multiple schemas
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与多个模式的SQLite数据库集成
- en: Forms for managing expenses and income
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理费用和收入的表单
- en: User login, signup, and logout flows
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户登录、注册和注销流程
- en: Server-side access authorization
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器端访问授权
- en: File upload capabilities
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件上传功能
- en: Pending, optimistic, and real-time UIs
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 待定、乐观和实时 UI
- en: Various caching techniques
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种缓存技术
- en: Deferred data loading with React streaming and Remix’s `defer`
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 React streaming 和 Remix 的 `defer` 进行延迟数据加载
- en: Pagination for expense and invoice lists
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 费用和发票列表的分页
- en: 'Congratulations on completing BeeRich, a full stack web application that fully
    utilizes Remix and the web platform. Now is your chance to take over BeeRich and
    keep practicing. You could start by adding the two search parameters: `q` and
    `page` to more links and redirects to persist them across different user actions
    and navigations. Or maybe there is something you wanted to change for a while
    already? Now is the time!'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你完成 BeeRich，这是一个充分利用 Remix 和 Web 平台的全栈 Web 应用程序。现在是时候接管 BeeRich 并继续练习了。你可以从为更多链接和重定向添加两个搜索参数
    `q` 和 `page` 开始，以在不同用户操作和导航中持久化它们。或者，也许你已经有一段时间想要改变某些内容了？现在是时候了！
- en: And as always, practice what you have learned in this chapter by implementing
    the same pagination logic on the income route for the invoices list. Refer to
    the Prisma and Remix documentation if you get stuck. If you need more guidance,
    refer
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 并且，一如既往地，通过在发票列表的收入路由上实现相同的分页逻辑来练习本章学到的内容。如果遇到困难，请参考 Prisma 和 Remix 文档。如果你需要更多指导，请参考
- en: to the implementation on the expense routes.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 到实施在费用路由上。
- en: In this section, we implemented pagination in Remix using URL search parameters.
    You learned how to carry over search parameters across different form submissions
    and practiced advanced session management in Remix.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们使用 URL 搜索参数在 Remix 中实现了分页。你学习了如何在不同的表单提交之间传递搜索参数，并在 Remix 中练习了高级会话管理。
- en: Summary
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about advanced session management patterns with
    Remix and wrapped up your work on BeeRich.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了使用 Remix 的高级会话管理模式，并完成了 BeeRich 的工作。
- en: Remix offers a `createCookie` helper function for working with cookie data.
    The function returns a cookie abstraction for parsing and serializing cookie data
    to and from request headers.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 提供了一个 `createCookie` 辅助函数来处理 cookie 数据。该函数返回一个 cookie 抽象，用于将 cookie 数据解析和序列化到请求头中。
- en: After reading this chapter, you know how to use `createCookie` to store and
    access arbitrary user session data in a cookie. You practiced working with cookies
    by adding a visitor cookie to the login and signup flow in BeeRich that persists
    the URL the visitor wants to access.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章之后，你了解了如何使用 `createCookie` 在 cookie 中存储和访问任意用户会话数据。你通过在 BeeRich 的登录和注册流程中添加访客
    cookie 来练习与 cookie 一起工作，该 cookie 持续保存访客想要访问的 URL。
- en: You also learned how to implement a simple pagination feature with Remix and
    Prisma. Pagination is a pattern that can improve performance and avoid long loading
    times when working with data lists. Utilizing pagination limits the amount of
    data that needs to be fetched for each page load.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你还学会了如何使用 Remix 和 Prisma 实现简单的分页功能。分页是一种可以提高性能并避免处理数据列表时长时间加载时间的模式。利用分页可以限制每次页面加载需要获取的数据量。
- en: In the next chapter, we will learn more about deploying Remix applications on
    the edge.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习更多关于在边缘部署 Remix 应用程序的内容。
- en: Further reading
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can find more information about working with search parameters via MDN
    Web Docs: [https://developer.mozilla.org/en-US/docs/Web/API/URL/searchParams](https://developer.mozilla.org/en-US/docs/Web/API/URL/searchParams).'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 MDN Web Docs 中找到更多关于通过搜索参数工作的信息：[https://developer.mozilla.org/en-US/docs/Web/API/URL/searchParams](https://developer.mozilla.org/en-US/docs/Web/API/URL/searchParams)。
- en: 'You can reference the Remix documentation to learn more about the `createCookie`
    helper function: [https://remix.run/docs/en/2/utils/cookies](https://remix.run/docs/en/2/utils/cookies).'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过参考 Remix 文档来了解更多关于 `createCookie` 辅助函数的信息：[https://remix.run/docs/en/2/utils/cookies](https://remix.run/docs/en/2/utils/cookies)。
- en: 'You can read more about pagination with Prisma in the Prisma documentation:
    [https://www.prisma.io/docs/concepts/components/prisma-client/pagination](https://www.prisma.io/docs/concepts/components/prisma-client/pagination).'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Prisma 文档中了解更多关于分页的信息：[https://www.prisma.io/docs/concepts/components/prisma-client/pagination](https://www.prisma.io/docs/concepts/components/prisma-client/pagination)。
