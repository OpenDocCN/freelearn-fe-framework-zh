- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Styling and Populating the Funbook App
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Funbook应用进行样式化和填充
- en: In the previous chapter, we planned what surfaces and components will be needed
    for our app based on the design file. We also got comfortable previewing and debugging
    the app – at least I hope you got comfortable, my dear reader! Whether you’re
    using an iPhone or Android simulator or a real device with the Expo Go app, make
    sure you prefer checking your app that way. There’s no wrong answer for previewing
    apps built with Expo. In this chapter, we will style our surfaces and components.
    We will finally see an app that looks, hopefully, close to the design! After that,
    we will add some real data.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们根据设计文件规划了我们的应用所需的界面和组件。我们还熟悉了预览和调试应用的过程——至少我希望您已经熟悉了，亲爱的读者！无论您是使用iPhone或Android模拟器，还是使用带有Expo
    Go应用的实体设备，请确保您以这种方式检查您的应用。使用Expo构建的应用预览没有错误答案。在本章中，我们将对我们的界面和组件进行样式化。我们最终将看到一个看起来希望接近设计的应用！之后，我们将添加一些真实数据。
- en: 'Here’s a very short list of what we’re planning to achieve in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们计划在本章中实现的一些非常简短的列表：
- en: Creating and styling components
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和样式化组件
- en: Pulling in data for the app
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为应用拉取数据
- en: By the end of this chapter, we will have a good-looking app that fetches data
    from an external API. Feel free to follow closely or write your own code.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将拥有一个看起来不错的应用程序，它可以从外部API获取数据。您可以随时密切关注或编写自己的代码。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In order to follow along with this chapter, you will need some knowledge of
    JavaScript and ReactJS. If you have followed along the first two chapters of this
    book, you should be able to go forward without any issues.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随本章内容，您需要具备一些JavaScript和ReactJS的知识。如果您已经跟随了本书的前两章，您应该能够无任何问题地继续前进。
- en: Feel free to use an IDE of your choice, as React Native does not need any specific
    functionality. Currently, the most popular IDEs for frontend developers are Microsoft’s
    Visual Studio Code, Atom, Sublime Text, and WebStorm.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以自由选择您喜欢的IDE，因为React Native不需要任何特定功能。目前，前端开发者中最受欢迎的IDE是微软的Visual Studio Code、Atom、Sublime
    Text和WebStorm。
- en: The code snippets provided in this chapter are here to illustrate what we should
    be doing with the code. They do not provide the whole picture. For a better experience
    of coding along, open the GitHub repo in your IDE and look at the files in there.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供的代码片段旨在说明我们应该如何使用代码。它们并不提供完整的画面。为了更好地跟随代码编写过程，请在您的IDE中打开GitHub仓库并查看其中的文件。
- en: 'If you get stuck or lost, you can check the code in the GitHub repo: [https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-4](https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-4).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遇到困难或迷失方向，可以查看GitHub仓库中的代码：[https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-4](https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-4)。
- en: Creating and styling components
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和样式化组件
- en: It’s time to create some real components! Let’s start with the home surface.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候创建一些真正的组件了！让我们从主页面开始。
- en: 'I like to work from top to bottom, so we will start with the header. Our free
    design template includes the app name (“Socially”) and a bell icon at the top
    of the feed surface. We won’t be implementing notifications in our example app,
    so we’ll overlook this part of the design file. Adding styles to the header is
    done through React Navigation. We will add the following properties to `<Tab.Navigator>`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢从上到下工作，所以我们首先从标题栏开始。我们的免费设计模板包括应用名称（“Socially”）和位于信息流顶部的铃铛图标。在我们的示例应用中，我们不会实现通知功能，所以我们将忽略设计文件中的这部分。标题栏的样式是通过React
    Navigation添加的。我们将向`<Tab.Navigator>`添加以下属性：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As we analyzed the home surface before, we know we need to create two parts
    of this surface: a list of avatars and a list of cards with images. The list of
    avatars will use a horizontal `FlatList` component. The first item on the list
    is different; it’s a button used by the user to add content. We’ll add a `ListHeaderComponent`
    property to `FlatList`, where we will add this special item. Let’s create a placeholder
    component for now:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在分析主页面前面所分析的，我们知道我们需要创建主页面的两个部分：一个头像列表和一个带有图片的卡片列表。头像列表将使用水平`FlatList`组件。列表上的第一个项目是不同的；它是一个用户用来添加内容的按钮。我们将向`FlatList`添加一个`ListHeaderComponent`属性，我们将在这里添加这个特殊项目。现在让我们创建一个占位符组件：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code, we created a component named `ListHeaderComponent`, so
    we can import it into `FlatList`. So far, this component only displays placeholder
    text.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个名为 `ListHeaderComponent` 的组件，因此我们可以将其导入到 `FlatList` 中。到目前为止，此组件只显示占位文本。
- en: I added a few profile images exported from the design file into the `assets`
    folder. We’ll use them for our list of avatars.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我将设计文件中导出的几个个人头像图片添加到了 `assets` 文件夹中。我们将使用它们来构建头像列表。
- en: 'Here’s what the `ListOfAvatars` component looks like:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 `ListOfAvatars` 组件的样子：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Remember to import the necessary components from `FlatList`. You may also notice
    I set up a very simple data array to be fed into the list of avatars. We’ll manage
    connecting this component to our sample data later.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住从 `FlatList` 中导入必要的组件。您可能还会注意到我设置了一个非常简单的数据数组，用于填充头像列表。我们将在稍后管理将此组件连接到我们的示例数据。
- en: 'If you prefer to look at this code on your screen instead of the book, you
    can always look in the repo. The code we are working on currently can be found
    in the `chapter-3` branch: [https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-3](https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-3).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢在屏幕上查看此代码而不是在书中，您始终可以在仓库中查看。我们目前正在工作的代码可以在 `chapter-3` 分支中找到：[https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-3](https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-3)。
- en: Once we have `FlatList` set up with links to actual images, we can change the
    `<Text>` component for an `<Image>` component, feed it data from our array, add
    some styles so that the images are rounded, and we’re done!
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置了 `FlatList` 并与实际图像建立了链接，我们就可以将 `<Text>` 组件更改为 `<Image>` 组件，从我们的数组中提供数据，添加一些样式使图像呈圆形，然后我们就完成了！
- en: 'We’ll add a list of cards, which will be very similar to the list of avatars.
    We’ll also use an array with temporary data and add some styling, and we should
    end up with a component looking like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一张卡片列表，它将与头像列表非常相似。我们还将使用一个临时数据的数组并添加一些样式，最终我们应该得到一个看起来像这样的组件：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The surface component called `Feed` should only concern itself with importing
    the correct children components and general styling. It looks like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为 `Feed` 的表面组件应该只关注导入正确的子组件和通用样式。它看起来是这样的：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And the **Feed** surface of our app should look like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用中的 **Feed** 表面应该看起来像这样：
- en: '![Figure 4.1 – An iPhone simulator screenshot of the Feed surface ](img/Figure_4.01_B18396.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – `Feed` 表面的 iPhone 模拟器截图](img/Figure_4.01_B18396.jpg)'
- en: Figure 4.1 – An iPhone simulator screenshot of the Feed surface
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – `Feed` 表面的 iPhone 模拟器截图
- en: You can leave your app as is, or you can copy some styling tweaks that I added
    in the GitHub repo. We’re not focusing on styles in this book, so we’re not going
    to go over them in detail; nonetheless, I encourage you to have a look around.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以保持您的应用原样，或者您可以复制我在 GitHub 仓库中添加的一些样式调整。在这本书中，我们不会专注于样式，所以我们将不会详细讨论它们；不过，我鼓励您四处看看。
- en: The **Feed** surface is looking quite similar to the design, so we can move
    forward to the **Conversations** surface.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**Feed** 表面看起来与设计非常相似，因此我们可以继续前进到 **Conversations** 表面。'
- en: 'Our `<ConversationsNavigation>`, where we will create a Stack Navigator:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `<ConversationsNavigation>`，我们将在这里创建一个 Stack Navigator：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The most interesting option we’re setting in this component is this one:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在此组件中，我们设置的最有趣的选项是这一项：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This line of code tells `Messages` surface. If you test your app now, you will
    notice this is not happening yet. We also need to set this parameter at the time
    the user will choose to go to the `Messages` surface, which means we need to set
    it when `Conversation` is clicked. We will create the `Conversations` surface
    with an input box at the top, followed by a list of conversations in `FlatList`.
    Each item in the list will be wrapped in a <`Pressable`> component, which will
    look like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码告诉 `Messages` 表面。如果您现在测试您的应用，您会注意到这还没有发生。我们还需要在用户选择进入 `Messages` 表面时设置此参数，这意味着我们需要在点击
    `Conversation` 时设置它。我们将创建一个带有顶部输入框的 `Conversations` 表面，后面跟着 `FlatList` 中的对话列表。列表中的每个项目都将包裹在一个
    `<Pressable>` 组件中，它看起来像这样：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When our users choose a conversation, this conversation will pass the assigned
    `name` parameter to the `Messages` surface, which in turn will display this name
    as the header. We can now add a list of dummy messages and conditional styling,
    which will style differently messages from the user and to the user. A useful
    thing to remember for message lists is to use the `inverted` prop on the `FlatList`
    component of messages. After all, we want the latest item to appear at the bottom
    of the list.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的用户选择一个对话时，这个对话会将分配的`name`参数传递给`Messages`界面，界面随后将显示这个名称作为标题。现在我们可以添加一个假消息列表和条件样式，这些样式将根据消息是来自用户还是发送给用户而有所不同。对于消息列表来说，记住在消息的`FlatList`组件上使用`inverted`属性是个有用的技巧。毕竟，我们希望最新的条目出现在列表的底部。
- en: 'You may notice at this point that the `Conversations` surface and the `Messages`
    surface do not have the bottom tabs visible. The best way to achieve this functionality
    is to move our <`ConversationsNavigation`> out of the tab navigator and move it
    into the main stack navigator. The surfaces listed in the main stack will be displayed
    above the surfaces in the Tab Navigator, plus we will be able to use the pre-configured
    back button provided by the React Navigation library. Here’s what the `App.js`
    root component should look like:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，此时`Conversations`界面和`Messages`界面都没有显示底部标签。实现这种功能最好的方法是，将我们的`<ConversationsNavigation>`从标签导航器移出，并移入主堆栈导航器。主堆栈中列出的界面将显示在标签导航器中的界面之上，此外我们还可以使用React
    Navigation库提供的预配置的返回按钮。以下是`App.js`根组件应该看起来像什么：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In order to have a button for our **Conversations** surface displayed in the
    tabs, we will need to create an empty dummy surface and pass it into the Tab Navigator:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的**Conversations**界面的按钮在标签中显示，我们需要创建一个空的虚拟界面并将其传递给Tab Navigator：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We’ll add a floating button at the bottom of the **Conversations** surface,
    and we’re done!
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`Conversations`界面的底部添加一个浮动按钮，这样我们就完成了！
- en: I’m going over these code changes fairly quickly, because we don’t want to spend
    too much time focusing on styling or React Navigation tips and tricks. We want
    to be up and running with an app that’s close to something you may find in the
    real world, so we can start playing with state and data management. Feel free
    to go over all code changes in the GitHub repo, where you can also ask questions
    and raise issues.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我会很快地浏览这些代码更改，因为我们不希望花太多时间关注样式或React Navigation技巧和窍门。我们希望尽快运行一个接近现实世界中的应用程序，这样我们就可以开始玩转状态和数据管理。请随意查看GitHub仓库中的所有代码更改，在那里你也可以提问和提出问题。
- en: We’ll continue our progress by adding content to the `FlatList` components that
    will display added images and favorited images.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续通过向`FlatList`组件添加内容来推进我们的进度，这些组件将显示添加的图片和收藏的图片。
- en: 'We will finish up this surface by adding a custom component to the `Tab Navigator`
    for the central item, the black button for adding posts. We can add any custom
    component that we want as the tab bar icon:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过向`Tab Navigator`的中央项目添加自定义组件来完成这个界面，这个黑色按钮用于添加帖子。我们可以添加任何我们想要的作为标签栏图标的自定义组件：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If you look closely, you will notice that the styling for this button is very
    similar to the floating button on the `Conversations` surface. In cases where
    we’re repeating a lot of code, it’s a good idea to abstract it into a separate
    file. This is called **Don’t Repeat Yourself** (**DRY**) programming. We don’t
    want to go too far, making abstractions for every little thing. There’s another
    programming principle called **Write Everything Twice** (**WET**) programming,
    which advocates writing verbose code, especially when starting a new project.
    My personal preference is **Avoid Hasty Abstractions** (**AHA**) programming,
    proposed by *Kent C. Dodds*. This approach marries DRY and WET principles and
    encourages us programmers to find the best use cases for abstractions while not
    overusing them.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察，你会发现这个按钮的样式与`Conversations`界面上浮动的按钮非常相似。在我们需要重复大量代码的情况下，将其抽象到单独的文件中是个好主意。这被称为**不要重复自己**（**DRY**）编程。我们不想走得太远，为每一件小事都做抽象。还有一种编程原则叫做**写两次**（**WET**）编程，它主张编写冗长的代码，尤其是在开始一个新项目时。我个人的偏好是**避免仓促抽象**（**AHA**）编程，这是由*Kent
    C. Dodds*提出的。这种方法结合了DRY和WET原则，并鼓励我们程序员在不过度使用它们的同时，找到抽象的最佳用例。
- en: In this specific case, we are repeating styling. We can easily create a class
    called something like `floatingButton` and apply it to both of our components.
    We could also use the `<FloatingButton>` styled component. There are more ways
    to achieve this goal of having reusable styles, but we are not going to dive into
    them. I’ll do some cleanup in our components, and I’ll meet you right back here
    in a few moments so that we can hook up some real data from our (almost) real
    API.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的情况下，我们正在重复样式。我们可以轻松创建一个名为`floatingButton`的类并将其应用于我们的两个组件。我们也可以使用`<FloatingButton>`样式组件。还有更多方法可以实现具有可重用样式的目标，但我们不会深入探讨。我将在我们的组件中进行一些清理，并在几分钟后在这里与你见面，这样我们就可以连接到我们的（几乎）真实API的一些真实数据。
- en: Pulling in data for the app
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拉取应用数据
- en: Welcome back! Did you take a moment to look at our app code? Did you clone the
    repo from the `chapter-3` branch, or did you create your own components following
    the broad strokes I described previously? Either way, I’m glad you’re here! Let’s
    fetch some data and use some state!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎回来！你有没有花点时间看看我们的应用代码？你是否从`chapter-3`分支克隆了仓库，或者你是否根据我之前描述的大致轮廓创建了你的组件？无论如何，我很高兴你在这里！让我们获取一些数据并使用一些状态！
- en: 'A quick reminder about the data we’ll be using: I set up GitHub Pages in the
    `/docs` folder, which you can find here: [https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/docs](https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/docs).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们将使用的数据的一个快速提醒：我在`/docs`文件夹中设置了GitHub Pages，你可以在这里找到：[https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/docs](https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/docs)。
- en: 'You can preview every JSON file right in the GitHub UI. You can also view the
    raw contents of any file by clicking the **Raw** button:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接在GitHub UI中预览每个JSON文件。你还可以通过点击**原始**按钮查看任何文件的原始内容：
- en: '![Figure 4.2 – GitHub UI with the Raw button circled in red ](img/Figure_4.02_B18396.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2 – GitHub UI，红色圆圈圈出了原始按钮](img/Figure_4.02_B18396.jpg)'
- en: Figure 4.2 – GitHub UI with the Raw button circled in red
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – GitHub UI，红色圆圈圈出了原始按钮
- en: The text file visible after clicking this button is what you could see as an
    API response.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 点击此按钮后可见的文本文件就是你可以看到的API响应。
- en: We’ll start with fetching the list of users. This list contains user IDs and
    links to user avatars. Our API depends on us to manage the user avatars everywhere
    in the app and passes them in this one endpoint only.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从获取用户列表开始。这个列表包含用户ID和用户头像的链接。我们的API依赖于我们在整个应用中管理用户头像，并且只通过这个端点传递它们。
- en: So, let’s check where we need the list of users. We need it on the `App.js`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们检查我们需要用户列表的地方。我们需要它在`App.js`中。
- en: 'The first thing we’ll do is fetch our data in the parent:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的是在父组件中获取数据：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once we have our data fetched and inside the `userList` object, we can pass
    it as a prop from the parent component to the children. According to the React
    Navigation docs, you can pass additional props through the render callback of
    the navigator. Here’s what it would look like for the `Home` component:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获取了数据并将其放入`userList`对象中，我们就可以将其作为属性从父组件传递给子组件。根据React Navigation文档，你可以在导航器的渲染回调中传递额外的属性。以下是`Home`组件的示例：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Once we have the `userList` prop in the `Home` surface, we should be done, yes?
    Unfortunately, no. The `Home` surface is a parent for the tab navigator, so we
    need to do the whole song and dance of adding the render callback for the `Feed`
    surface. Once we get to the `Feed` surface, we will need to pass the `userList`
    prop to the `ListOfAvatars` component… This is starting to be a bit much, don’t
    you think? This is a taste of what would be called prop drilling in a bigger app.
    Passing an object through multiple surfaces and components is not only tedious
    but also error-prone. This sort of setup is brittle – it suffices that one component
    in the chain changes, and the whole app may become unusable. What can we do to
    avoid this? We can use **React Context**. This is also the strategy recommended
    by the maintainers of React Navigation.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在`Home`界面中有了`userList`属性，我们就应该完成了，对吧？不幸的是，不是的。`Home`界面是标签导航器的父组件，因此我们需要为`Feed`界面添加整个渲染回调过程。一旦我们到达`Feed`界面，我们需要将`userList`属性传递给`ListOfAvatars`组件……这开始变得有点多了，不是吗？这是在大应用中被称为属性钻取的一个例子。通过多个界面和组件传递对象不仅繁琐，而且容易出错。这种设置很脆弱——只要链中的任何一个组件发生变化，整个应用可能就无法使用。我们能做些什么来避免这种情况呢？我们可以使用**React
    Context**。这也是React Navigation维护者推荐的战略。
- en: What is context?
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是上下文？
- en: Context is used to pass data down the component tree without having to thread
    the props manually through every component.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文用于在组件树中传递数据，而无需手动将props传递到每个组件。
- en: 'The first step we need to take is to create our context with an initial value:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要采取的第一个步骤是创建我们的上下文并设置初始值：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, we need to wrap the parent component in a Context Provider with an updated
    value:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要将父组件包裹在一个带有更新值的Context Provider中：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The last piece of the context puzzle is how to use it, or “consume it.” Once
    the context is provided to the parent, we can consume it in any one of its children
    through the `<Context.Consumer>` component. We will add this consumer to our list
    of avatars:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文拼图的最后一部分是如何使用它，或者说“消费它”。一旦上下文提供给父组件，我们就可以通过`<Context.Consumer>`组件在其任何一个子组件中消费它。我们将把这个消费者添加到我们的头像列表中：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: And there we go! We successfully fetched external data, fed it to our app, and
    passed the data around with the help of React Context. Using context offers a
    much better developer experience; however, it does come with its own set of issues.
    The biggest issue that you should always keep in mind when using context is that
    any change to the context will cause a re-render of the component where the `Provider`
    is placed, along with all the children of the said component. This means that
    if we were to have an API where the user can add or remove other users to their
    list, every time they would do this, the entire app would have to re-render. Sometimes,
    that’s what we want; we want to have the avatar list and the list of images in
    `Feed` updated. We also want to update the `Conversations` surface in such a case.
    But what about the `Profile` and `Add` `Post` surfaces? We will not be answering
    those questions now, as we’re working with an example app. However, every time
    you decide to use React’s Context, you should ask yourself where to place the
    Provider and what will happen when the data of the context changes.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 好了！我们成功获取了外部数据，将其提供给我们的应用，并借助React Context传递数据。使用上下文提供了更好的开发者体验；然而，它也带来了一系列问题。在使用上下文时，你应该始终牢记的最大问题是，上下文中的任何更改都会导致放置`Provider`的组件及其所有子组件的重新渲染。这意味着如果我们有一个API，用户可以添加或删除他们列表中的其他用户，每次他们这样做时，整个应用都需要重新渲染。有时，我们希望这样；我们希望更新头像列表和`Feed`中的图片列表。我们也希望在这种情况下更新`Conversations`界面。但是关于`Profile`和`Add
    Post`界面呢？我们现在不会回答这些问题，因为我们正在处理一个示例应用。然而，每次你决定使用React的Context时，你应该问自己Provider应该放在哪里，以及当上下文的数据发生变化时会发生什么。
- en: 'Let’s continue fetching real data for other parts of our app. We’d like to
    display images on `Feed`. We’ll start by fetching data in the `ListOfCards` component
    with a `useEffect` hook:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续为我们的应用的其他部分获取真实数据。我们希望在`Feed`上显示图片。我们将从使用`useEffect`钩子在`ListOfCards`组件中获取数据开始：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Once our card items are fetched and passed on to the `Card` component, we can
    do something more with them – namely, we can check the author ID against the user
    list in our context and display the correct username and avatar thanks to this
    information.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的卡片项被获取并传递给`Card`组件，我们可以对它们做更多的事情——也就是说，我们可以将作者ID与上下文中的用户列表进行比对，并利用这些信息显示正确的用户名和头像。
- en: 'We will add the same context consumer to the `Card` component as the one we
    added to `ListOfAvatars`, but that is not going to be enough in this case. Once
    we get the whole list, we also need to find the user whose ID matches the author
    ID of the card. We’ll adjust the way we pass the context value, and we’ll filter
    the `userList` array:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把与`ListOfAvatars`组件中添加的相同上下文消费者添加到`Card`组件中，但在这个情况下这还不够。一旦我们获取了整个列表，我们还需要找到与卡片作者ID匹配的用户ID。我们将调整传递上下文值的方式，并过滤`userList`数组：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We created a variable called `currentUser`, which is an array holding precisely
    one item – the user who posted the specific card. Unfortunately, this variable
    is accessible to the `Card` component only. If we wanted to use the same information,
    for example, on a modal that would open when we tap the image, we would have to
    either nest the modal component in the `Card` component or search for the current
    user again. You will see an example of this issue in our very own app in a few
    moments, when we’ll be working with the `Conversations` surface.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`currentUser`的变量，它是一个包含精确一个项目的数组——即发布特定卡片的用户。不幸的是，这个变量只能被`Card`组件访问。如果我们想在例如点击图片时打开的模态框中使用相同的信息，我们不得不将模态组件嵌套在`Card`组件中，或者再次搜索当前用户。您将在我们自己的应用中看到这个问题的例子，在我们接下来与`Conversations`界面工作的时候。
- en: On the other hand, we have composed another surface using the `Card` component
    – the `Favorites` surface. All we must do to have it working correctly is fetch
    the `Favorites` data. All the rest should fall into place.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们使用`Card`组件组合了另一个表面——`Favorites`表面。我们只需获取`Favorites`数据即可使其正确工作。其余的都应该会自动就位。
- en: If you encounter any problems with loading data from our example API hosted
    on GitHub pages, start by making sure the data is fetched. You can do so by using
    `console.log` in your code and looking in the terminal to see whether the object
    is fetched or not. Then, you need to check whether you have all the names and
    object keys spelled and nested correctly. If you get stuck at any point, remember
    that you can always go to the repo hosted on GitHub, clone it, and look around
    at any stage you would like.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在从GitHub页面上的示例API加载数据时遇到任何问题，首先确保数据已被获取。您可以通过在代码中使用`console.log`并查看终端来检查对象是否已被获取。然后，您需要检查您是否正确拼写并嵌套了所有的名称和对象键。如果您在任何地方卡住了，请记住您始终可以前往GitHub上托管的项目，克隆它，并在您喜欢的任何阶段查看。
- en: 'Let’s move on to the next component that needs to fetch data – `Conversations`.
    As I mentioned before, we will need to tweak and repeat some code we already wrote
    for the `Card` component used in the `Feed` and `Favorites` surfaces. In `Conversations`,
    we will also fetch the user list and search for the current user. Make sure to
    spell everything correctly. The sneaky API author named everything differently!
    Here’s what my `Conversations` component looks like:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到下一个需要获取数据的组件——`Conversations`。正如我之前提到的，我们需要调整并重复一些我们之前为`Feed`和`Favorites`表面中使用的`Card`组件编写的代码。在`Conversations`中，我们还将获取用户列表并搜索当前用户。请确保一切拼写正确。那个偷偷摸摸的API作者把一切都命名为不同的名称！以下是我的`Conversations`组件的样子：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Please pay attention to `[0]` after `currentUser`. We used a filter function
    on an array, and we have an array as a result. Omitting `[0]` means the app will
    not be displaying any data because it will see an array instead of an object.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`currentUser`后面的`[0]`。我们在一个数组上使用了一个过滤器函数，结果是一个数组。省略`[0]`意味着应用程序将不会显示任何数据，因为它会看到一个数组而不是一个对象。
- en: 'We have our list of conversations; now’s the time to fetch the specific conversation
    when one is tapped by the user. The action of redirecting to the messages screen
    happens in the `<ConversationItem>` component in `FlatList` on the `Conversations`
    surface. The `Messages` surface is a part of the same stack navigator as the `Conversations`,
    which means we could go two ways here:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了会话列表；现在是时候在用户点击时获取特定的会话了。重定向到消息屏幕的动作发生在`Conversations`表面的`FlatList`中的`<ConversationItem>`组件上。`Messages`表面是同一个栈导航器的一部分，这意味着我们可以从这里选择两个方向：
- en: Add context to the `<ConversationsNavigation>` component, set its value when
    a conversation is tapped, and consume it on the `Messaging` surface.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`<ConversationsNavigation>`组件添加上下文，在会话被点击时设置其值，并在`Messaging`表面消费它。
- en: Pass the conversation ID as a route parameter, along with user data.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将会话ID作为路由参数传递，同时传递用户数据。
- en: The second approach is very tempting because it’s simple. We’re just adding
    a piece of data that’s already accessible to us, and we’re passing it through
    the navigation to the correct place. There’s nothing inherently wrong with this
    approach that I could criticize off the bat. It is foreseeable, however, that
    in a real-world app, you would end up writing very big or duplicated objects to
    be passed around in the `route` params. As per the React Navigation documentation,
    even though using route params is convenient, they should not be used as a replacement
    for a global app state. Manually passing data through route params can lead to
    bugs and an app showing outdated data. If you’d like a little bit of exercise,
    you could implement this solution in your own copy of the `FunBook` app right
    now.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法非常有吸引力，因为它很简单。我们只是添加了一块我们已经有权限访问的数据，并通过导航传递到正确的位置。这种方法的本质并没有什么可以立即批评的地方。然而，在现实世界的应用程序中，您可能会编写非常大的或重复的对象，并将它们作为`route`参数传递。根据React
    Navigation文档，尽管使用路由参数很方便，但它们不应作为全局应用程序状态的替代品。手动通过路由参数传递数据可能会导致错误，并使应用程序显示过时的数据。如果您想稍微锻炼一下，您现在就可以在自己的`FunBook`应用程序副本中实现这个解决方案。
- en: When you’re ready, come back here and I’ll walk you through creating and consuming
    the new context for the conversations.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当你准备好了，请回到这里，我会带你一步步创建和消费用于会话的新上下文。
- en: 'We’ll start like before, by creating the context with its initial value:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将像以前一样开始，创建具有初始值的上下文：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'I’ve decided to hold the functions to create context in a separate file, called
    `context.js` for simplicity’s sake. Once the context is created, we need to wrap
    it around the correct component. In this case, we will need to add the Provider
    around the nested `Stack` `Navigator` of the `Conversations` surface. Let’s add
    the following code to the `<``ConversationsNavigation>` component:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我决定将创建上下文的函数放在一个单独的文件中，为了简单起见，我们将其命名为`context.js`。一旦上下文被创建，我们需要将其包裹在正确的组件周围。在这种情况下，我们需要在`Conversations`表面的嵌套`Stack``Navigator`周围添加Provider。让我们在`<ConversationsNavigation>`组件中添加以下代码：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You will notice we are passing both the value and the `setter` function to the
    context this time. This is because we will need to set the value of the context
    deeper in the tree, in the `<ConversationItem>` component. Not to worry though;
    passing functions through context is 100% a-okay!
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到这次我们传递了值和`setter`函数到上下文中。这是因为我们将在树中更深的地方，在`<ConversationItem>`组件中设置上下文的值。不过不用担心；通过上下文传递函数是完全没问题！
- en: 'What about multiple contexts, you may ask, when you notice that `<ConversationItem>`
    is already wrapped in `<UserListContext.Consumer>`? Again, this is totally fine.
    You can have just as many wrappers as you need and like! Here’s what our component
    with two contexts will look like:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当你注意到`<ConversationItem>`已经被`<UserListContext.Consumer>`包裹时，你可能会问关于多个上下文的问题。这完全没问题。你可以拥有你需要的任何数量的包装器！以下是我们的具有两个上下文的组件的样子：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now that we’re setting the context, let’s consume it in the `Messages` surface.
    We need to first get the conversation ID from the context and then fetch the correct
    `JSON` file for the given conversation. We’ll add `<ConversationContext.Consumer>`
    as a wrapper on the `Messages` surface:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经设置了上下文，让我们在`Messages`表面消费它。我们需要首先从上下文中获取对话ID，然后获取给定对话的正确`JSON`文件。我们将在`Messages`表面添加`<ConversationContext.Consumer>`作为包装器：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once we get the conversation ID, we’ll use it in the `ListOfMessages` component
    to fetch the data pertinent to the given screen:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获取到对话ID，我们将在`ListOfMessages`组件中使用它来获取与给定屏幕相关的数据：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: And there we go! We’ve done some solid work here; it’s time for a pat on the
    back. We have multiple components fetching data and passing it around when necessary.
    We’ve set up the `Feed` component, `Favorites`, `Conversations`, and `Messaging`.
    The last surface left is `Profile`. I will leave it to you, dear reader, to manage
    data on this surface. I trust that you have learned enough in this chapter to
    be able to do it on your own.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们做到了！在这里我们做了一些扎实的工作；现在是时候给自己鼓掌了。我们设置了多个组件来获取数据并在必要时传递它。我们已经设置了`Feed`组件、`Favorites`、`Conversations`和`Messaging`。最后剩下的表面是`Profile`。我将把它留给你，亲爱的读者，来管理这个表面的数据。我相信你已经在本章中学到了足够多的知识，能够独立完成它。
- en: When you go to the book repo, you will find all work related to this chapter
    on a branch called `chapter-3`. You can browse through commits to see how the
    app development progressed, or you can simply check out the final state of the
    app. In the next chapter, we will see whether we can replace all our context,
    props, and filtering users with a more global solution called Redux. Onward and
    upward!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当你访问书籍仓库时，你将在名为`chapter-3`的分支上找到与本章节相关的所有工作。你可以浏览提交记录来查看应用开发的进展，或者你可以简单地查看应用的最终状态。在下一章中，我们将看到我们是否可以用一个更全局的解决方案Redux来替换所有的上下文、props和过滤用户。继续前进，不断进步！
- en: Summary
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have done a lot of great work in this chapter! There’s a very specific sort
    of satisfaction when you see an app that looks nice and works smoothly, isn’t
    there?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中做了很多出色的工作！当你看到一款看起来很棒且运行流畅的应用时，你会有一种非常特别的满足感，对吧？
- en: Here’s where we are at after this chapter – we have an app that’s styled according
    to design. This app pulls in external data from an API. I admit that our app is
    rather simple. There are many more functionalities that could be added to a social
    media clone app. And there’s nothing stopping you from doing just that. You can
    play around and add and delete whatever you want. I will also add a few more functionalities,
    maybe a modal, or a functioning “like” button, and I’ll see you in [*Chapter 5*](B18396_05.xhtml#_idTextAnchor056),
    where we’ll start investigating our first state management solution – Redux.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章之后，我们达到了这样的境地——我们有一个按照设计风格定制的应用。这个应用从 API 中拉取外部数据。我承认我们的应用相当简单。还有很多更多功能可以添加到社交媒体克隆应用中。没有任何东西阻止你这样做。你可以随意添加和删除任何你想要的东西。我还会添加一些更多功能，也许是一个模态框，或者一个功能性的“点赞”按钮，我们将在[*第五章*](B18396_05.xhtml#_idTextAnchor056)中见面，在那里我们将开始调查我们的第一个状态管理解决方案——Redux。
- en: Further reading
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '[https://www.digitalocean.com/community/tutorials/what-is-dry-development](https://www.digitalocean.com/community/tutorials/what-is-dry-development):
    DRY programming.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.digitalocean.com/community/tutorials/what-is-dry-development](https://www.digitalocean.com/community/tutorials/what-is-dry-development):
    DRY 编程。'
- en: '[https://betterprogramming.pub/when-dry-doesnt-work-go-wet-6befda0444bf](https://betterprogramming.pub/when-dry-doesnt-work-go-wet-6befda0444bf):
    WET programming.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://betterprogramming.pub/when-dry-doesnt-work-go-wet-6befda0444bf](https://betterprogramming.pub/when-dry-doesnt-work-go-wet-6befda0444bf):
    WET 编程。'
- en: '[https://kentcdodds.com/blog/aha-programming](https://kentcdodds.com/blog/aha-programming):
    AHA programming.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://kentcdodds.com/blog/aha-programming](https://kentcdodds.com/blog/aha-programming):
    AHA 编程。'
- en: '[https://reactnavigation.org/docs/hello-react-navigation/#passing-additional-props](https://reactnavigation.org/docs/hello-react-navigation/#passing-additional-props):
    Passing additional props in React Navigation.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://reactnavigation.org/docs/hello-react-navigation/#passing-additional-props](https://reactnavigation.org/docs/hello-react-navigation/#passing-additional-props):
    在 React Navigation 中传递额外的 props。'
- en: '[https://reactjs.org/docs/context.html](https://reactjs.org/docs/context.html):
    React Context.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://reactjs.org/docs/context.html](https://reactjs.org/docs/context.html):
    React Context。'
- en: '[https://reactnavigation.org/docs/params/#what-should-be-in-params](https://reactnavigation.org/docs/params/#what-should-be-in-params):
    React Navigation – what should be in params?'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://reactnavigation.org/docs/params/#what-should-be-in-params](https://reactnavigation.org/docs/params/#what-should-be-in-params):
    React Navigation – params 中应该包含什么？'
- en: Part 3 – Exploring Various Libraries for State Management in React Native
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分 – 探索 React Native 中各种状态管理库
- en: In this part, we will start with Redux and its Toolkit; we will learn why they
    were created, how to configure them, and how to use them for managing liked images
    in the example app. Next, we will learn about MobX, what problems it wants to
    solve, and how to configure it and use it to manage liked images in the Funbook
    app. Then, we will learn about XState, what the mathematical bases for this library
    are, how to configure it, and how to visualize data thanks to its Visualizer.
    Finally, we will implement it for managing liked images in the Funbook app. Next
    comes Jotai; we will see why it was created and what problems it solves. Then,
    we will configure it for the Funbook app and use it to manage liked images. Finally,
    we will learn about React Query (or TanStack Query). We will learn why this library
    is even mentioned in a book about state management. Then, we will configure it
    and use it for fetching liked images in the Funbook app.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，我们将从 Redux 和其工具包开始；我们将学习它们为什么被创建，如何配置它们，以及如何在示例应用中用它们来管理点赞的图片。接下来，我们将学习关于
    MobX 的内容，它想要解决什么问题，以及如何配置和使用它来在 Funbook 应用中管理点赞的图片。然后，我们将学习关于 XState 的内容，这个库的数学基础是什么，如何配置它，以及如何利用其可视化器来可视化数据。最后，我们将将其实现用于在
    Funbook 应用中管理点赞的图片。接下来是 Jotai；我们将了解它为什么被创建以及它解决了什么问题。然后，我们将为 Funbook 应用配置它并使用它来管理点赞的图片。最后，我们将学习关于
    React Query（或 TanStack Query）。我们将了解为什么这个库在一本关于状态管理的书中被提及。然后，我们将配置它并用于在 Funbook
    应用中获取点赞的图片。
- en: 'This part includes the following chapters:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '[*Chapter 5*](B18396_05.xhtml#_idTextAnchor056), *Implementing Redux in Our
    Funbook App*'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第五章*](B18396_05.xhtml#_idTextAnchor056)，*在我们的 Funbook 应用中实现 Redux*'
- en: '[*Chapter 6*](B18396_06.xhtml#_idTextAnchor072), *Using MobX as a State Manager
    in a React Native App*'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第六章*](B18396_06.xhtml#_idTextAnchor072)，*在 React Native 应用中使用 MobX 作为状态管理器*'
- en: '[*Chapter 7*](B18396_07.xhtml#_idTextAnchor084), *Untangling Complex Flows
    in React Native Apps with XState*'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第七章*](B18396_07.xhtml#_idTextAnchor084)，*使用 XState 在 React Native 应用中解开复杂流程*'
- en: '[*Chapter 8*](B18396_08.xhtml#_idTextAnchor097), [*Integrating Jotai in a React
    Native App*](https://epic.packtpub.services/index.php?module=oss_Chapters&action=DetailView&record=254c4c24-4e8a-0b72-fab6-61f37807c398)'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B18396_08.xhtml#_idTextAnchor097), [*在React Native应用程序中集成Jotai*](https://epic.packtpub.services/index.php?module=oss_Chapters&action=DetailView&record=254c4c24-4e8a-0b72-fab6-61f37807c398)'
- en: '[*Chapter 9*](B18396_09.xhtml#_idTextAnchor110), *Using React Query for Server-Side
    - Driven State Management*'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B18396_09.xhtml#_idTextAnchor110), *使用React Query进行服务器端驱动状态管理*'
