- en: Integrating Data Visualization with an Expense Tracking Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据可视化集成到支出跟踪应用程序中
- en: These days, it is easy to collect and add data to applications on the internet.
    As more and more data becomes available, it becomes necessary to process the data
    and present insights extracted from this data in meaningful and appealing visualizations
    to end users. In this chapter, we will learn how to use MERN stack technologies
    along with Victory—a charting library for React—to easily integrate data visualization
    features in a full-stack application. We will extend the MERN skeleton application
    to build an expense tracking application, which will incorporate data processing
    and visualization features for expense data recorded by a user over time.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这些天，收集和添加数据到互联网上的应用程序变得很容易。随着越来越多的数据变得可用，处理数据并将从这些数据中提取的见解以有意义和吸引人的可视化形式呈现给最终用户变得必要。在本章中，我们将学习如何使用
    MERN 堆栈技术以及 Victory——一个用于 React 的图表库，以便轻松地将数据可视化功能集成到全栈应用程序中。我们将扩展 MERN 骨架应用程序来构建支出跟踪应用程序，该应用程序将包含用户随时间记录的支出数据的数据处理和可视化功能。
- en: After going through the implementation of these features, you should have a
    grasp of how to utilize the MongoDB aggregation framework and the Victory charting
    library to add data visualization features of your choice to any full-stack MERN
    web application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了这些功能的实现之后，您应该掌握了如何利用 MongoDB 聚合框架和 Victory 图表库将您选择的数据可视化功能添加到任何全栈 MERN 网络应用程序中。
- en: 'In this chapter, we will build an expense tracking application integrated with
    data visualization features by covering the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过以下主题来构建一个集成了数据可视化功能的支出跟踪应用程序：
- en: Introducing MERN Expense Tracker
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 MERN 支出跟踪器
- en: Adding expense records
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加支出记录
- en: Visualizing expense data over time
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随时间可视化支出数据
- en: Introducing MERN Expense Tracker
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 MERN 支出跟踪器
- en: 'The MERN Expense Tracker application will allow users to keep track of their
    day-to-day expenses. Users who are signed in to their accounts will be able to
    add their expense records with details such as expense description, category,
    amount, and when the given expense was incurred or paid. The application will
    store these expense records and extract meaningful data patterns to give the user
    a visual representation of how their expense habits fare as time progresses. The
    following screenshot shows the home page view for a signed-in user on the MERN
    Expense Tracker application, and it gives the user an overview of their expenses
    for the current month:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: MERN 支出跟踪器应用程序将允许用户跟踪他们的日常支出。登录账户的用户将能够添加他们的支出记录，包括支出描述、类别、金额以及给定支出发生或支付的时间。应用程序将存储这些支出记录并提取有意义的数据模式，以使用户能够看到他们的支出习惯随时间如何发展。以下截图显示了
    MERN 支出跟踪器应用程序上登录用户的首页视图，并提供了用户当前月份支出的概述：
- en: '![](img/8092ee10-448d-4cea-a31a-05dc85c6f382.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8092ee10-448d-4cea-a31a-05dc85c6f382.png)'
- en: The code for the complete MERN Expense Tracker application is available on GitHub
    at: [https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter10/mern-expense-tracker](https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter10/mern-expense-tracker). You
    can clone this code and run the application as you go through the code explanations
    for the rest of this chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的 MERN 支出跟踪器应用程序代码可在 GitHub 上找到：[https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter10/mern-expense-tracker](https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter10/mern-expense-tracker)。您可以将此代码克隆并运行，在阅读本章剩余部分的代码解释时，您可以运行应用程序。
- en: 'In this chapter, we will extend the MERN skeleton to build the expense tracking
    application with data visualization features. The views required for these expense
    tracking and visualization features will be developed by extending and modifying
    the existing React components in the MERN skeleton application. The component
    tree in the following screenshot shows all the custom React components that make
    up the MERN Expense Tracker frontend developed in this chapter:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将扩展 MERN 骨架以构建具有数据可视化功能的支出跟踪应用程序。这些支出跟踪和可视化功能所需的视图将通过扩展和修改 MERN 骨架应用程序中现有的
    React 组件来开发。以下截图显示了本章中开发的 MERN 支出跟踪器前端的所有自定义 React 组件的组件树：
- en: '![](img/035a54ab-1da5-46e3-9db1-032248a6af3e.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/035a54ab-1da5-46e3-9db1-032248a6af3e.png)'
- en: We will add new React components to implement views for creating expense records,
    listing and modifying already recorded expenses, and displaying reports giving
    insights into expenses incurred by a user over time. We will also modify existing
    components such as the Home component to render an overview of current expenses
    by a user. Before we can implement visualizations for the user's expense data,
    we need to start by adding the capability to record day-to-day expenses on the
    application. In the next section, we will discuss how to implement this feature
    allowing signed-in users to create and modify their expense records on the application.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加新的React组件来实现创建费用记录、列出和修改已记录的费用以及显示报告的视图，这些报告可以提供用户随时间产生的费用的洞察。我们还将修改现有的组件，如Home组件，以渲染用户当前费用的概览。在我们能够实现用户费用数据的可视化之前，我们需要首先添加记录日常费用的功能。在下一节中，我们将讨论如何实现这个功能，允许已登录的用户在应用程序中创建和修改他们的费用记录。
- en: Adding expense records
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加费用记录
- en: In the MERN Expense Tracker application, a user who is signed in will be able
    to create and manage their expense records. To enable these features of adding
    and managing expense records, we will need to define how to store expense details,
    and implement the full-stack slices that will let users create new expenses, view
    these expenses, and update or delete existing expenses on the application.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在MERN费用追踪器应用程序中，已登录的用户将能够创建和管理他们的费用记录。为了启用添加和管理费用记录的功能，我们需要定义如何存储费用详情，并实现全栈切片，使用户能够创建新的费用、查看这些费用以及更新或删除应用程序中的现有费用。
- en: In the following sections, first, we will define the Expense model with a Mongoose
    Schema to store the details of each expense record. Then, we will discuss implementations
    for the backend APIs and frontend views that are needed to allow a user to create
    new expenses, view a list of their expenses, and modify existing expenses by either
    editing details of or deleting an expense from the application.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，首先，我们将使用Mongoose模式定义费用模型以存储每个费用记录的详情。然后，我们将讨论实现后端API和前端视图的方法，这些方法允许用户创建新的费用、查看他们的费用列表以及通过编辑费用详情或从应用程序中删除费用来修改现有费用。
- en: Defining an Expense model
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义费用模型
- en: 'We will implement a Mongoose model to define an Expense model for storing the
    details of each expense record. This model will be defined in `server/models/expense.model.js`,
    and the implementation will be similar to other Mongoose Model implementations
    covered in previous chapters, such as the Course model defined in [Chapter 6](c58ac055-5a1e-4bf4-b8a6-c9b311cf267a.xhtml), *Building
    a Web-Based Classroom Application*. The Expense schema in this model will have
    simple fields to store details about each expense, such as a title, the amount,
    category, and date when it was incurred, along with a reference to the user who
    created the record. The code defining the expense fields are given in the following
    list with explanations:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个Mongoose模型来定义一个用于存储每个费用记录详情的费用模型。此模型将在`server/models/expense.model.js`中定义，其实现将与之前章节中覆盖的其他Mongoose模型实现类似，例如在[第6章](c58ac055-5a1e-4bf4-b8a6-c9b311cf267a.xhtml)中定义的课程模型，*构建基于Web的教室应用程序*。此模型中的费用模式将具有简单的字段来存储关于每个费用的详情，例如标题、金额、类别以及费用发生时的日期，以及一个指向创建记录的用户引用。定义费用字段的代码及其解释如下：
- en: '**Expense title**: The `title` field will describe the expense. It is declared
    to be a `String` type and will be a required field:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**费用标题**：`title`字段将描述费用。它被声明为`String`类型，并且是一个必填字段：'
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Expense amount**: The `amount` field will store the monetary cost of the
    expense as a value of the `Number` type, and it will be a required field with
    a minimum allowed value of 0:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**费用金额**：`amount`字段将存储费用的货币成本，作为`Number`类型的值，并且它将是一个必填字段，最小允许值为0：'
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Expense category**: The `category` field will define the expense type, so
    expenses can be grouped by this value. It is declared to be a `String` type and
    will be a required field:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**费用类别**：`category`字段将定义费用类型，以便可以根据此值对费用进行分组。它被声明为`String`类型，并且是一个必填字段：'
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Incurred on**: The `incurred_on` field will store the date-time when the
    expense was incurred or paid. It is declared to be a `Date` type and will default
    to the current date-time if no value is provided:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发生日期**：`incurred_on`字段将存储费用发生或支付时的日期时间。它被声明为`Date`类型，如果没有提供值，则默认为当前日期时间：'
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Notes**: The `notes` field, defined as a `String` type, will allow the recording of
    additional details or notes for a given expense record:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注意事项**：`notes`字段，定义为`String`类型，将允许记录给定费用记录的额外详细信息或备注：'
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Expense recorded by**: The `recorded_by` field will reference the user who
    is creating the expense record:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**记录费用的人**：`recorded_by`字段将引用创建费用记录的用户：'
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Created and updated at times**: The `created` and `updated` fields will be `Date` types,
    with `created` generated when a new expense is added, and `updated` changed when
    any expense details are modified:'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建和更新时间**：`created`和`updated`字段将是`Date`类型，`created`字段在添加新费用时生成，而`updated`字段在修改任何费用详情时更改：'
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The fields added to this schema definition will enable us to implement all the
    expense-related features in MERN Expense Tracker. In the next section, we will
    start developing these features by implementing the full-stack slice that will
    allow users to create new expense records.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到此模式定义中的字段将使我们能够实现MERN费用追踪器中的所有费用相关功能。在下一节中，我们将通过实现允许用户创建新费用记录的全栈切片来开始开发这些功能。
- en: Creating a new expense record
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新的费用记录
- en: In order to create a new expense record on the application, we will need to
    integrate a full-stack slice that allows the user to fill out a form view in the
    frontend, and then save the entered details to a new expense document in the database
    in the backend. To implement this feature, in the following sections, we will
    add a create expense API in the backend, along with a way to fetch this API in
    the frontend, and a create new expense form view that takes user input for expense
    details.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在应用程序中创建新的费用记录，我们需要集成一个全栈切片，允许用户在前端填写表单视图，然后在后端将输入的详细信息保存到数据库中的新费用文档中。为了实现此功能，在以下章节中，我们将添加一个创建费用API，以及在前端获取此API的方法，以及一个用于获取费用详情的用户输入的新费用表单视图。
- en: The create expense API
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建费用API
- en: For the implementation of the create expense API that will allow creating new
    expenses in the database, we will first add a `POST` route, as shown in the following
    code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现允许在数据库中创建新费用的创建费用API，我们首先添加一个`POST`路由，如下所示。
- en: '`mern-expense-tracker/server/routes/expense.routes.js`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-expense-tracker/server/routes/expense.routes.js`：'
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: A `POST` request to this route at `/api/expenses` will first ensure that the
    requesting user is signed in with the `requireSignin` method from the `auth` controllers,
    before invoking the `create` method to add a new expense record in the database.
    This `create` method is defined in the following code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 向`/api/expenses`路由发送`POST`请求将首先确保请求用户已通过`auth`控制器中的`requireSignin`方法登录，然后调用`create`方法在数据库中添加新的费用记录。此`create`方法在以下代码中定义。
- en: '`mern-expense-tracker/server/controllers/expense.controller.js`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-expense-tracker/server/controllers/expense.controller.js`：'
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this `create` method, we set the `recorded_by` field to the user currently
    signed in, before using the expense data provided in the request body to save
    the new expense in the Expense collection in the database.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`create`方法中，我们将`recorded_by`字段设置为当前登录的用户，然后使用请求体中提供的费用数据在数据库中的费用集合中保存新的费用。
- en: The `expense.routes.js` file containing the expense routes will be very similar
    to the `user.routes` file. To load these new expense routes in the Express app,
    we need to mount the expense routes in `express.js`, as shown in the following
    code, in the same way that we did for the auth and user routes.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 包含费用路由的`expense.routes.js`文件将与`user.routes`文件非常相似。为了在Express应用中加载这些新的费用路由，我们需要在`express.js`中挂载费用路由，如下所示，就像我们为auth和用户路由所做的那样。
- en: '`mern-expense-tracker/server/express.js`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-expense-tracker/server/express.js`：'
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This create expense API endpoint is now ready in the backend and can be used
    in the frontend to make a `POST` request. To fetch this API in the frontend, we
    will add a corresponding `create` method in `api-expense.js`, similar to the other
    API implementations that we discussed in previous chapters, such as the *Creating
    a new auction* section from [Chapter 9](48801a75-cf6a-4eb8-b294-65314e749e9d.xhtml),
    *Adding Real-Time Bidding Capabilities to the Marketplace*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个创建费用API端点现在已在后端准备好，可以在前端使用以发送`POST`请求。为了在前端获取此API，我们将在`api-expense.js`中添加相应的`create`方法，类似于我们在前几章中讨论的其他API实现，例如来自[第9章](48801a75-cf6a-4eb8-b294-65314e749e9d.xhtml)的*创建一个新的拍卖*部分，*向市场添加实时竞标功能*。
- en: This fetch method will be used in the frontend component that will display a
    form where the user can enter details of the new expense and save it on the application.
    In the next section, we will implement the React component that will render the
    form for recording a new expense.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 此获取方法将在前端组件中使用，该组件将显示一个表单，用户可以在其中输入新费用的详细信息并将其保存到应用程序中。在下一节中，我们将实现一个React组件，该组件将渲染用于记录新费用的表单。
- en: The NewExpense component
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新增费用组件
- en: Signed-in users on this expense tracking application will interact with a form
    view in order to enter details of a new expense record. This form view will be
    rendered in the `NewExpense` component, which will allow users to create a new
    expense by entering the expense title, the amount spent, the category of the expense,
    the date-time of when the expense was incurred, and any additional notes.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在此费用跟踪应用程序上签到的用户将通过表单视图来输入新的费用记录的详细信息。此表单视图将在`NewExpense`组件中渲染，这将使用户能够通过输入费用标题、花费金额、费用类别、费用发生的时间以及任何附加说明来创建新的费用。
- en: 'This form will render as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此表单将呈现如下：
- en: '![](img/214b657c-665b-4b1d-a4a3-40b417767811.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/214b657c-665b-4b1d-a4a3-40b417767811.png)'
- en: 'The implementation for this `NewExpense` component is similar to other form
    implementations that we have discussed previously, such as the `Signup` component
    implementation from [Chapter 4](6f2ca10a-8079-4e3a-9d42-a3db8e85b9d9.xhtml),* Adding
    a React Frontend to Complete MERN*. The only different field in this form component
    is the date-time input for the Incurred on timing. Clicking on this field will
    render a date-time picker widget, as shown in the following screenshot:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此`NewExpense`组件的实现与其他我们之前讨论过的表单实现类似，例如来自[第4章](6f2ca10a-8079-4e3a-9d42-a3db8e85b9d9.xhtml)的`Signup`组件实现，*添加React前端以完成MERN*。此表单组件中唯一不同的字段是用于“发生时间”的日期时间输入。点击此字段将显示日期时间选择器小部件，如下面的截图所示：
- en: '![](img/4e19ff40-3364-4d0d-a006-57c91a3a525b.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/4e19ff40-3364-4d0d-a006-57c91a3a525b.png)'
- en: 'To implement this date-time picker for the form, we will use Material-UI Pickers
    along with a date management library. Before we can integrate these libraries,
    we first need to install the following Material-UI Pickers and `date-fns` modules
    by running the following `yarn` command from the command line:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现此表单的日期时间选择器，我们将使用Material-UI Pickers以及一个日期管理库。在我们能够集成这些库之前，我们首先需要通过在命令行运行以下`yarn`命令来安装以下Material-UI
    Pickers和`date-fns`模块：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Once these modules are installed, we can import the required components and
    modules in the `NewExpense` component and add the date-time picker widget to the
    form, as shown in the following code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了这些模块，我们就可以在`NewExpense`组件中导入所需的组件和模块，并将日期时间选择器小部件添加到表单中，如下面的代码所示。
- en: '`mern-expense-tracker/client/expense/NewExpense.js`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-expense-tracker/client/expense/NewExpense.js`：'
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This widget will render options to pick a year, month, date, and time along
    with a TODAY button to set the current time as the selected value. When the user
    is done picking a date-time, we will capture the value with the `handleDateChange`
    method and set it to state with the other expense-related values collected from
    the form. The `handleDateChange` method is defined as follows.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此小部件将渲染选择年、月、日和时间的选项，以及一个设置当前时间为选定值的TODAY按钮。当用户完成日期时间的选择后，我们将使用`handleDateChange`方法捕获值，并将其与其他从表单收集的费用相关值一起设置到状态中。`handleDateChange`方法定义如下。
- en: '`mern-expense-tracker/client/expense/NewExpense.js`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-expense-tracker/client/expense/NewExpense.js`：'
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Using this, we will have a `date` value set for the `incurred_on` field in the
    new expense record.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此功能，我们将为新的费用记录中的`incurred_on`字段设置一个`date`值。
- en: This `NewExpense` component can only be viewed by signed-in users. So, we will
    add a `PrivateRoute` in the `MainRouter` component, which will render this form
    only for authenticated users at `/expenses/new`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此`NewExpense`组件只能由已签到的用户查看。因此，我们将在`MainRouter`组件中添加一个`PrivateRoute`，这样只有在`/expenses/new`路径的认证用户才能渲染此表单。
- en: '`mern-expense-tracker/client/MainRouter.js`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-expense-tracker/client/MainRouter.js`：'
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This link can be added to any view, such as the Menu component, to be rendered
    conditionally when users are signed in. Now that it is possible to add new expense
    records in this expense tracking application, in the next section, we will discuss
    the implementation to fetch and list these expenses from the database in the backend
    to the views in the frontend.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此链接可以添加到任何视图中，例如菜单组件，当用户登录时条件性地渲染。现在，由于可以在本费用跟踪应用程序中添加新的费用记录，在下一节中，我们将讨论从后端到前端视图的实现，以获取和列出这些费用。
- en: Listing expenses
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出费用
- en: In MERN Expense Tracker, users will be able to view the list of expenses that
    they already recorded on the application and incurred within a provided date range.
    In the following sections, we will add this ability by implementing a backend
    API to retrieve the list of expenses recorded by the currently signed-in user,
    and add a frontend view that will use this API to render the returned list of
    expenses to the end user.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在MERN费用跟踪器中，用户将能够查看他们在应用程序中已记录并在提供的日期范围内产生的费用列表。在以下各节中，我们将通过实现后端API来检索当前已登录用户记录的费用列表，并添加一个前端视图，该视图将使用此API将返回的费用列表渲染给最终用户。
- en: The expenses by user API
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户费用API
- en: We will implement an API to get the expenses recorded by a specific user and
    incurred between a provided date range. The request for this API will be received
    at `'/api/expenses'`, with the route defined in `expense.routes.js` as follows.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个API来获取特定用户在提供的日期范围内记录的费用。对此API的请求将在`'/api/expenses'`接收，路由在`expense.routes.js`中定义如下。
- en: '`mern-expense-tracker/server/routes/expense.routes.js`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-expense-tracker/server/routes/expense.routes.js`:'
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: A `GET` request to this route will first ensure that the requesting user is
    signed in, before invoking the controller method to fetch the expenses from the
    database. In this application, users will only be able to view their own expenses.
    After the user authentication is confirmed, in the `listByUser` controller method
    we query the Expense collection in the database using date range specified in
    the request and the ID of the user who is signed in. The `listByUser` method is
    defined in the following code.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对此路由的`GET`请求将首先确保请求用户已登录，然后调用控制器方法从数据库中检索费用。在这个应用程序中，用户只能查看他们自己的费用。在用户身份验证确认后，在`listByUser`控制器方法中，我们使用请求中指定的日期范围和已登录用户的ID在数据库中查询Expense集合。`listByUser`方法在以下代码中定义。
- en: '`mern-expense-tracker/server/controllers/expense.controller.js`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-expense-tracker/server/controllers/expense.controller.js`:'
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this method, we start by gathering the first day and the last day of the
    date range specified in the request query. From the database, we then retrieve
    the expenses incurred by the signed-in user within these dates. The signed-in
    user is matched against the user referenced in the `recorded _by` field. The `find`
    query against the Expense collection using these values will return matching expenses
    sorted by the `incurred_on` field, with the recently incurred expenses listed
    first.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，我们首先收集请求查询中指定的日期范围的起始日和最后一天。然后，我们从数据库中检索在此日期范围内由已登录用户产生的费用。已登录用户与`recorded
    _by`字段中引用的用户进行匹配。使用这些值对Expense集合执行`find`查询将返回按`incurred_on`字段排序的匹配费用，最近产生的费用将列在前面。
- en: The API to retrieve expenses recorded by a specific user can be used in the
    frontend to retrieve and display the expenses to the end user. To fetch this API
    in the frontend, we will add a corresponding `listByUser` method in `api-expense.js`,
    as shown in the following code.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 用于检索特定用户记录的费用API可以在前端使用，以检索和向最终用户显示费用。为了在前端获取此API，我们将在`api-expense.js`中添加相应的`listByUser`方法，如下所示。
- en: '`mern-expense-tracker/client/expense/api-expense.js`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-expense-tracker/client/expense/api-expense.js`:'
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this method, before making the request to the list expenses API, we form
    the query string containing the date range with the `queryString` library. Then,
    this query string is attached to the request URL.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，在向列出费用API发出请求之前，我们使用`queryString`库形成包含日期范围的查询字符串。然后，将此查询字符串附加到请求URL。
- en: This fetch method will be used in the `Expenses` component to retrieve and show
    the expenses to the user. We will take a look at the implementation of the `Expenses` component
    in the next section.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此获取方法将在`Expenses`组件中使用，以检索并向用户显示费用。我们将在下一节中查看`Expenses`组件的实现。
- en: The Expenses component
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 费用组件
- en: 'The list of expenses retrieved from the database will be rendered using a React
    component called `Expenses`. This component, on the initial load, will render
    the expenses incurred by the signed-in user in the current month. In this view,
    the user will also have the option to pick a date range to retrieve expenses incurred
    within specific dates, as shown in the following screenshot:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据库检索到的支出列表将使用名为`Expenses`的React组件进行渲染。该组件在初始加载时，将渲染当前月份由已登录用户发生的支出。在这个视图中，用户还可以选择日期范围以检索特定日期内发生的支出，如图所示：
- en: '![](img/fee16c3c-cc06-4cb4-9b14-aea6d4f3ab59.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fee16c3c-cc06-4cb4-9b14-aea6d4f3ab59.png)'
- en: While defining the `Expenses` component, we first use a `useEffect` hook to
    make a fetch call to the list expenses API in order to retrieve the initial list
    of expenses. We also initialize the values that are necessary for making this
    request and for rendering the response to be received from the server, as shown
    in the following code.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义`Expenses`组件时，我们首先使用`useEffect`钩子调用获取支出列表API的fetch调用，以检索初始支出列表。我们还初始化了进行此请求和渲染从服务器接收到的响应所必需的值，如图所示。
- en: '`mern-expense-tracker/client/expense/Expenses.js`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-expense-tracker/client/expense/Expenses.js`:'
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We first determine the dates of the first day and the last day of the current
    month. These dates are set in the state to be rendered in the search form fields
    and provided as the date range query parameters in the request to the server.
    Because we will only fetch the expenses associated with the current user, we retrieve
    the signed-in user's `auth` credentials to be sent with the request. If the request
    to the server results in an error, we will redirect the user to the login page.
    Otherwise, we will set the received expenses in the state to be rendered in the
    view.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先确定当前月份的第一天和最后一天的日期。这些日期被设置为在搜索表单字段中渲染，并作为请求服务器的日期范围查询参数提供。因为我们只会获取与当前用户相关的支出，所以我们检索已登录用户的`auth`凭证，以便与请求一起发送。如果服务器请求导致错误，我们将用户重定向到登录页面。否则，我们将接收到的支出设置在状态中，以便在视图中渲染。
- en: In the view part of the `Expenses` component, we will add a form to search by
    date range, before iterating through the resulting expenses array to render individual
    expense details. In the following sections, we will look at the implementation
    of the search form and expenses list in the component view.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在“支出”组件的视图部分，我们将在遍历结果支出数组以渲染单个支出详情之前，添加一个表单以按日期范围搜索。在接下来的章节中，我们将查看组件视图中的搜索表单和支出列表的实现。
- en: Searching by date range
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过日期范围搜索
- en: In the `Expenses` view, users will have the option to view a list of expenses
    incurred within a specific date range. To implement a search form that allows
    users to pick a start and end date for the range, we will use `DatePicker` components
    from Material-UI Pickers.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在“支出”视图中，用户将可以选择查看在特定日期范围内发生的支出列表。为了实现一个允许用户选择开始和结束日期范围的搜索表单，我们将使用来自Material-UI
    Pickers的`DatePicker`组件。
- en: In the view, we will add two `DatePicker` components to collect the first day
    and the last day of the query range, and also add a button to initiate the search,
    as shown in the following code.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图中，我们将添加两个`DatePicker`组件来收集查询范围的开始和结束日期，并添加一个按钮来启动搜索，如图所示。
- en: '`mern-expense-tracker/client/expense/Expenses.js`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-expense-tracker/client/expense/Expenses.js`:'
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When a user interacts with the `DatePicker` components to select a date, we
    will invoke the `handleSearchFieldChange` method to get the selected `date` value.
    This method gets the `date` value and sets it to either the `firstDay` or `lastDay`
    value in the state accordingly. The `handleSearchFieldChange` method is defined
    in the following code.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户与`DatePicker`组件交互以选择日期时，我们将调用`handleSearchFieldChange`方法来获取选定的`date`值。此方法获取`date`值并将其相应地设置为状态中的`firstDay`或`lastDay`值。`handleSearchFieldChange`方法定义如下。
- en: '`mern-expense-tracker/client/expense/Expenses.js`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-expense-tracker/client/expense/Expenses.js`:'
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: After the two dates are selected and set in state, when the user clicks on the
    Search button, we will invoke the `searchClicked` method. In this method, we make
    another call to the list expenses API with the new dates sent in the query parameters.
    The `searchClicked` method is defined as follows.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择了两个日期并将它们设置在状态中之后，当用户点击搜索按钮时，我们将调用`searchClicked`方法。在这个方法中，我们使用新的日期作为查询参数再次调用列表支出API。`searchClicked`方法定义如下。
- en: '`mern-expense-tracker/client/expense/Expenses.js`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-expense-tracker/client/expense/Expenses.js`:'
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Once the expenses resulting from this new query are received from the server,
    we set it to the state to be rendered in the view. In the next section, we will
    look at the implementation for displaying this retrieved list of expenses.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦从服务器接收到此新查询产生的费用，我们将将其设置到状态中以便在视图中渲染。在下一节中，我们将查看显示检索到的费用列表的实现。
- en: Rendering expenses
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染费用
- en: In the `Expenses` component view, we iterate through the list of expenses retrieved
    from the database and display each expense record to the end user in a Material-UI
    `ExpansionPanel` component. In the `ExpansionPanel` component, we show details
    of the individual expense record in the *Summary* section. Then, on the expansion
    of the panel, we will give the user the option to edit details of the expense
    or delete the expense, as discussed in the next section.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Expenses` 组件视图中，我们遍历从数据库检索到的费用列表，并在 Material-UI `ExpansionPanel` 组件中将每个费用记录显示给最终用户。在
    `ExpansionPanel` 组件中，我们在 *摘要* 部分显示单个费用记录的详细信息。然后，在面板展开时，我们将给用户提供编辑费用详细信息或删除费用的选项，如下一节所述。
- en: In the following code added to the view code after the search form elements,
    we use `map` to iterate through the `expenses` array and render each `expense`
    in an `ExpansionPanel` component.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在搜索表单元素之后添加到视图代码中的以下代码，我们使用 `map` 来遍历 `expenses` 数组，并在 `ExpansionPanel` 组件中渲染每个
    `expense`。
- en: '`mern-expense-tracker/client/expense/Expenses.js`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-expense-tracker/client/expense/Expenses.js`:'
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The expense details are rendered in the `ExpansionPanelSummary` component, giving
    the user an overview of the expense that they recorded on the application. The
    `ExpansionPanelDetails` component will contain the options to modify the given
    expense and complete the feature allowing users to manage the expenses they have
    recorded on the application. In the next section, we will discuss the implementation
    of these options to modify the recorded expense.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 费用详情在 `ExpansionPanelSummary` 组件中渲染，使用户能够了解他们在应用程序中记录的费用概述。`ExpansionPanelDetails`
    组件将包含修改给定费用和完成允许用户管理他们在应用程序中记录的费用功能的选项。在下一节中，我们将讨论实现这些修改记录费用的选项。
- en: Modifying an expense record
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改费用记录
- en: Users on MERN Expense Tracker will be able to modify the expenses they have
    already recorded on the application by either updating the details of an expense
    or deleting the expense record altogether.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: MERN 费用追踪器的用户将能够通过更新费用详情或完全删除费用记录来修改他们在应用程序中已记录的费用。
- en: 'In the frontend of the application, they will receive these modification options
    in the expenses list after expanding to see details of an individual expense in
    the list, as shown in the following screenshot:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序的前端，用户在展开查看列表中单个费用的详细信息后，将在费用列表中接收到这些修改选项，如下面的截图所示：
- en: '![](img/7800c168-2271-4a4f-8c2e-3f75507ee3ec.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7800c168-2271-4a4f-8c2e-3f75507ee3ec.png)'
- en: To implement these expense modification features, we will have to update the
    view to render this form and the delete option. Additionally, we will add edit
    and delete expense API endpoints on the server. In the following sections, we
    will discuss how to render these edit and delete elements in the frontend, and
    then implement the edit and delete APIs in the backend.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这些费用修改功能，我们必须更新视图以渲染此表单和删除选项。此外，我们将在服务器上添加编辑和删除费用 API 端点。在以下章节中，我们将讨论如何在前端渲染这些编辑和删除元素，然后实现后端的编辑和删除
    API。
- en: Rendering the edit form and delete option
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染编辑表单和删除选项
- en: We will render the edit expense form and delete option in the `Expenses` component
    view. For each expense record rendered in a Material-UI `ExpansionPanel` component
    in this view, we will add form fields in the `ExpansionPanelDetails` section,
    with each field pre-populated with the corresponding expense detail value. Users
    will be able to interact with these form fields to change the values and then
    click on the Update button to save the changes to the database. We will add these
    form fields in the view along with the Update button and delete option, as shown
    in the following code.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `Expenses` 组件视图中渲染编辑费用表单和删除选项。对于在此视图中以 Material-UI `ExpansionPanel` 组件渲染的每个费用记录，我们将在
    `ExpansionPanelDetails` 部分添加表单字段，每个字段预先填充相应的费用详情值。用户将能够与这些表单字段交互以更改值，然后点击更新按钮将更改保存到数据库。我们将在视图中添加这些表单字段以及更新按钮和删除选项，如下面的代码所示。
- en: '`mern-expense-tracker/client/expense/Expenses.js`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-expense-tracker/client/expense/Expenses.js`:'
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The form fields added here are similar to the fields added in the `NewExpense`
    component to create new expense records. When the user interacts with these fields
    to update the values, we invoke the `handleChange` method with the corresponding
    index of the given expense in the `expenses` array, the name of the field, and
    the changed value. The `handleChange` method is defined in the following code.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里添加的表单字段与在 `NewExpense` 组件中添加的字段类似，用于创建新的费用记录。当用户与这些字段交互以更新值时，我们将使用给定费用在 `expenses`
    数组中的相应索引、字段名称和更改值调用 `handleChange` 方法。`handleChange` 方法定义如下。
- en: '`mern-expense-tracker/client/expense/Expenses.js`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-expense-tracker/client/expense/Expenses.js`:'
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The expense object at the given index in the `expenses` array is updated with
    the changed value of the specified field and set to state. This will render the
    view with the latest values as the user is updating the edit form. When the user
    is done making changes and clicks on the `Update` button, we will invoke the `clickUpdate`
    method, which is defined as follows.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `expenses` 数组中给定索引处的费用对象更新为指定字段的更改值，并将其设置为状态。这将使用户在更新编辑表单时渲染带有最新值的视图。当用户完成更改并点击
    `Update` 按钮时，我们将调用 `clickUpdate` 方法，该方法定义如下。
- en: '`mern-expense-tracker/client/expense/Expenses.js`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-expense-tracker/client/expense/Expenses.js`:'
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this `clickUpdate` method, we send the updated expense to the backend in
    a fetch call to an edit expense API. The implementation of this edit expense API
    is discussed in the next section.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 `clickUpdate` 方法中，我们通过向编辑费用 API 发起一个 fetch 调用来将更新的费用发送到后端。这个编辑费用 API 的实现将在下一节中讨论。
- en: The `DeleteExpense` component added to the edit form renders a Delete button
    and uses the `expense` object passed as a prop to delete the associated expense
    from the database by calling the delete expense API. The implementation for this
    `DeleteExpense` is similar to the `DeleteShop` component discussed in [Chapter
    7](03fd3b4a-b7fd-4b42-ad7e-5bc34b5612b0.xhtml), *Exercising MERN Skills with an
    Online Marketplace*. In the next section, we will discuss the implementation of
    the edit and delete expense APIs used by the edit form and delete the option to
    relay the expense-related updates made by the user to the Expense collection in
    the database.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `DeleteExpense` 组件添加到编辑表单中，它会渲染一个删除按钮，并使用作为属性传递的 `expense` 对象通过调用删除费用 API
    从数据库中删除相关的费用。这个 `DeleteExpense` 的实现与在 [第 7 章](03fd3b4a-b7fd-4b42-ad7e-5bc34b5612b0.xhtml)
    中讨论的 `DeleteShop` 组件类似，即 *使用在线市场锻炼 MERN 技能*。在下一节中，我们将讨论编辑和删除费用 API 的实现，这些 API
    由编辑表单使用，并将用户在数据库的 Expense 集合中做出的费用相关更新传递给删除选项。
- en: Editing and deleting an expense in the backend
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在后端编辑和删除费用
- en: In order to complete the edit and delete expense operations initiated by signed-in
    users from the frontend, we need to have the corresponding APIs in the backend.
    The route for these API endpoints that will accept the update and delete requests
    can be declared in the following code.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成由前端登录用户发起的编辑和删除费用操作，我们需要在后端有相应的 API。以下代码中可以声明这些 API 端点的路由，它们将接受更新和删除请求。
- en: '`mern-expense-tracker/server/routes/expense.routes.js`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-expense-tracker/server/routes/expense.routes.js`:'
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: A `PUT` or `DELETE` request to this route will first ensure that the current
    user is signed in with the `requireSignin` `auth` controller method, before checking
    authorization and performing any operations in the database.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对此路由的 `PUT` 或 `DELETE` 请求将首先确保当前用户已通过 `requireSignin` `auth` 控制器方法登录，然后检查授权并在数据库中执行任何操作。
- en: The `:expenseId` parameter in the route URL, `/api/expenses/:expenseId`, will
    invoke the `expenseByID` controller method, which is similar to the `userByID` controller
    method. It retrieves the expense from the database and attaches it to the request
    object to be used in the `next` method. The `expenseByID` method is defined in
    the following code.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 路由 URL 中的 `:expenseId` 参数，`/api/expenses/:expenseId`，将调用 `expenseByID` 控制器方法，该方法类似于
    `userByID` 控制器方法。它从数据库中检索费用并将其附加到请求对象中，以便在 `next` 方法中使用。`expenseByID` 方法定义如下。
- en: '`mern-expense-tracker/server/controllers/expense.controller.js`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-expense-tracker/server/controllers/expense.controller.js`:'
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The expense object retrieved that is from the database will also contain the
    name and ID details of the user who recorded the expense, as we specified in the `populate()` method.
    For these API endpoints, next, we verify that this expense object was actually
    recorded by the signed-in user with the `hasAuthorization` method, which is defined
    in the expense controller as follows.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据库检索到的费用对象还将包含记录费用的用户的名称和ID详情，正如我们在`populate()`方法中指定的。对于这些API端点，接下来我们将使用`hasAuthorization`方法验证此费用对象是否确实是由已登录的用户记录的，该方法在费用控制器中如下定义。
- en: '`mern-expense-tracker/server/controllers/expense.controller.js`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-expense-tracker/server/controllers/expense.controller.js`:'
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Once it has been confirmed that the user trying to update the expense is the
    one who recorded it and if it is a `PUT` request, then the `update` method is
    invoked next to update the expense document with the new changes in the Expense
    collection. The `update` controller method is defined in the following code.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确认尝试更新费用的用户是记录该费用的用户，并且如果是`PUT`请求，则接下来将调用`update`方法来更新费用文档，并在Expense集合中应用新的更改。`update`控制器方法在以下代码中定义。
- en: '`mern-expense-tracker/server/controllers/expense.controller.js`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-expense-tracker/server/controllers/expense.controller.js`:'
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The method retrieves the expense details from `req.expense`, then uses the `lodash` module
    to extend and merge the changes that came in the request body to update the expense
    data. Before saving this updated expense to the database, the `updated` field
    is populated with the current date to reflect the last updated timestamp. On the
    successful save of this update, the updated expense object is sent back in the
    response.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法从`req.expense`检索费用详情，然后使用`lodash`模块将请求体中传入的更改扩展并合并到费用数据中，以更新费用数据。在将此更新后的费用保存到数据库之前，`updated`字段被填充为当前日期，以反映最后更新的时间戳。在成功保存此更新后，更新的费用对象将作为响应发送回。
- en: If it is a `DELETE` request instead of a `PUT` request, the `remove` method
    is invoked instead in order to delete the specified expense document from the
    collection in the database. The `remove` controller method is defined in the following
    code.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是`DELETE`请求而不是`PUT`请求，则会调用`remove`方法来从数据库中的集合中删除指定的费用文档。`remove`控制器方法在以下代码中定义。
- en: '`mern-expense-tracker/server/controllers/expense.controller.js`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-expense-tracker/server/controllers/expense.controller.js`:'
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `remove` operation in this method will permanently delete the expense from
    the application.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法中的`remove`操作将永久删除应用程序中的费用。
- en: We have all the features in place for users on the application to start recording
    and managing their day-to-day expenses. We defined an Expense model for storing
    expense data, and backend APIs and frontend views for creating new expenses, displaying
    a list of expenses for a given user, and modifying an existing expense. We are
    now ready to implement data visualization features based on the expense data that
    will be recorded by users on the application over time. We will discuss these
    implementations in the next section.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为应用程序上的用户提供了所有功能，以便他们开始记录和管理日常费用。我们定义了一个Expense模型来存储费用数据，以及后端API和前端视图来创建新的费用、显示特定用户的费用列表以及修改现有费用。我们现在准备实现基于用户在应用程序上记录的费用数据的数据可视化功能。我们将在下一节中讨论这些实现。
- en: Visualizing expense data over time
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 随时间可视化费用数据
- en: Aside from allowing users to keep logs of their expenses, the MERN Expense Tracker
    application will process the collected expense data to give users insights into
    their spending habits over time. We will implement simple data aggregation and
    visualization features to demonstrate how the MERN stack can accommodate such
    requirements in any full-stack application. To enable these features, we will
    utilize MongoDB's aggregation framework and also the React-based charting and
    data visualization library—Victory—by Formidable.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 除了允许用户记录他们的费用外，MERN费用跟踪应用程序还将处理收集到的费用数据，以使用户能够了解他们的消费习惯随时间的变化。我们将实现简单的数据聚合和数据可视化功能，以展示MERN堆栈如何满足任何全栈应用程序的此类要求。为了启用这些功能，我们将利用MongoDB的聚合框架，以及由Formidable提供的基于React的图表和数据可视化库——Victory。
- en: In the following sections, we will first add features to summarize a user's
    expenses in the current month and also show how they are doing compared to previous
    months. Then, we will add different Victory charts to give them a visual representation
    of their spending patterns over a month, and a year, and per expense category.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们首先将添加功能来总结用户当前月份的费用，并展示他们与之前月份相比的表现。然后，我们将添加不同的Victory图表，以提供他们在一个月、一年以及每个费用类别上的支出模式的可视化表示。
- en: Summarizing recent expenses
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结近期费用
- en: When a user signs in to their account on the application, they will see a preview
    of the expenses they incurred so far in the current month. They will also see
    a comparison of how much more or less they are spending in each category in comparison
    to the averages from previous months. To implement these features, we will have
    to add backend APIs that will run aggregation operations on the relevant expense
    data in the database and return the computed results to be rendered in the frontend.
    In the following sections, we will implement the full-stack slices—first to show
    a preview of all the expenses incurred so far in the current month, and then a
    comparison of the average expenses per category with respect to expenditures in
    the current month.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在应用程序上登录他们的账户时，他们将看到他们在当前月份到目前为止产生的费用预览。他们还将看到与之前月份的平均值相比，每个类别的花费更多或更少的比较。为了实现这些功能，我们必须添加后端API，这些API将在数据库中的相关费用数据上运行聚合操作，并将计算结果返回到前端进行渲染。在接下来的章节中，我们将实现全栈切片——首先展示当前月份到目前为止产生的所有费用预览，然后展示与当前月份支出相比的每个类别的平均费用。
- en: Previewing expenses in the current month
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预览当前月份的费用
- en: 'After a user signs in to the application, we will show a preview of their current
    expenses, including their total expenditure for the current month and how much
    they spent on the current date and the day before. This preview will be displayed
    to the end user, as shown in the following screenshot:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 用户登录应用程序后，我们将展示他们当前费用的预览，包括他们当前月份的总支出以及他们在当前日期和前一天的花费。这个预览将显示给最终用户，如下面的截图所示：
- en: '![](img/60c1cf6a-5c2f-4a1f-9c37-ed181fd420b3.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/60c1cf6a-5c2f-4a1f-9c37-ed181fd420b3.png)'
- en: In order to implement this feature, we need to add a backend API that will process
    the existing expense data to return these three values, so it can be rendered
    in a React component. In the following sections, we will take a look at the implementation
    and integration of this API with a frontend view to complete this preview feature.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个功能，我们需要添加一个后端API来处理现有的费用数据，以返回这三个值，以便在React组件中渲染。在接下来的章节中，我们将查看这个API的实现和与前端视图的集成，以完成预览功能。
- en: The current month preview API
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当前月份预览API
- en: We will add an API to the backend that will return the preview of expenses incurred
    so far in the current month. To implement this API, we will first declare a `GET`
    route, as shown in the following code.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后端添加一个API，该API将返回当前月份到目前为止产生的费用预览。为了实现这个API，我们首先声明一个`GET`路由，如下面的代码所示。
- en: '`mern-expense-tracker/server/routes/expense.routes.js`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-expense-tracker/server/routes/expense.routes.js`:'
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: A `GET` request to this route at `'/api/expenses/current/preview'` will first
    ensure the requesting client is a signed-in user, and then it will invoke the
    `currentMonthPreview` controller method. In this method, we will use MongoDB's
    aggregation framework to perform three sets of aggregations on the Expense collection
    and retrieve the total expenses for the current month, the current date, and the
    day before.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 向`'/api/expenses/current/preview'`这个路由发送一个`GET`请求，首先会确保请求客户端已经登录，然后它会调用`currentMonthPreview`控制器方法。在这个方法中，我们将使用MongoDB的聚合框架对费用集合执行三组聚合操作，以检索当前月份、当前日期以及前一天的总费用。
- en: The `currentMonthPreview` controller method will be defined with the following
    structure, where we first determine the dates needed to find matching expenses,
    and then we perform the aggregations before returning the results in the response.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`currentMonthPreview`控制器方法将按照以下结构定义，我们首先确定查找匹配费用所需的日期，然后执行聚合操作，最后在响应中返回结果。'
- en: '`mern-expense-tracker/server/controllers/expense.controller.js`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-expense-tracker/server/controllers/expense.controller.js`:'
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We first determine the dates for the current month's first day and last day,
    then the dates for today, tomorrow, and yesterday with the minutes and seconds
    set to zero. We will need these dates to specify the ranges for finding the matching
    expenses that were incurred in the current month, today, and yesterday. Then,
    with these values and the signed-in user's ID reference, we construct the aggregation
    pipelines necessary to retrieve the total expenses for the current month, today,
    and yesterday. We group these three different aggregation pipelines using the
    `$facet` stage in MongoDB's aggregation framework, as shown in the following code.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先确定当前月份的第一天和最后一天的日期，然后确定今天、明天和昨天的日期，分钟和秒数设置为零。我们需要这些日期来指定查找当前月份、今天和昨天的匹配费用的范围。然后，使用这些值和已登录用户的ID引用，我们构建检索当前月份、今天和昨天的总费用的聚合管道。我们使用MongoDB聚合框架中的`$facet`阶段将这些三个不同的聚合管道分组，如下面的代码所示。
- en: '`mern-expense-tracker/server/controllers/expense.controller.js`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-expense-tracker/server/controllers/expense.controller.js`:'
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: For each aggregation pipeline, we first match the expenses using the date range
    values for the `incurred_on` field, and also the `recorded_by` field with the
    current user's reference, so the aggregation is only performed on the expenses
    recorded by the current user. Then, the matching expenses in each pipeline are
    grouped to calculate the total amount spent.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个聚合管道，我们首先使用`incurred_on`字段的日期范围值匹配费用，以及与当前用户引用的`recorded_by`字段，因此聚合操作仅对当前用户记录的费用执行。然后，每个管道中匹配的费用被分组以计算总支出金额。
- en: In the faceted aggregation operation result, each pipeline has its own field
    in the output document where the results are stored as an array of documents.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在分面聚合操作的结果中，每个管道在输出文档中都有自己的字段，结果作为文档数组存储。
- en: After the aggregation operations are completed, we access the computed results
    and compose the response to be sent back in the response to the requesting client.
    This API can be used in the frontend with a fetch request. You can define a corresponding
    fetch method to make the request, similar to other API implementations. Then,
    the fetch method can be used in a React component to retrieve and render these
    aggregated values to the user. In the next section, we will discuss the implementation
    of this view to render the preview of current expenses for a user.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合操作完成后，我们访问计算结果并组合响应以发送回请求客户端。这个API可以在前端使用fetch请求。你可以定义一个相应的fetch方法来发起请求，类似于其他API实现。然后，这个fetch方法可以在React组件中使用来检索和渲染这些聚合值给用户。在下文中，我们将讨论实现此视图以渲染用户当前支出预览的细节。
- en: Rendering the preview of current expenses
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染当前支出的预览
- en: We can give the user a glimpse of their current expenses in any React component,
    which is accessible to a signed-in user and added to the frontend of the application.
    To retrieve the expense totals and render these in the view, we can call the current
    month preview API either in a `useEffect` hook or when a button is clicked on.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在任何React组件中向用户提供当前支出的概览，该组件对已登录用户是可访问的，并添加到应用程序的前端。为了检索支出总额并在视图中渲染这些数据，我们可以在`useEffect`钩子中调用当前月份预览API，或者在按钮被点击时调用。
- en: In the MERN Expense Tracker application, we render these details in a React
    component that is added to the home page. We use a `useEffect` hook, as shown
    in the following code, to retrieve the current expense preview data.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在MERN支出跟踪应用程序中，我们使用React组件渲染这些详细信息，并将其添加到主页上。我们使用`useEffect`钩子，如下面的代码所示，来检索当前的支出预览数据。
- en: '`mern-expense-tracker/client/expense/ExpenseOverview.js`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-expense-tracker/client/expense/ExpenseOverview.js`:'
- en: '[PRE33]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Once the data is received from the backend, we set it to state in a variable
    called `expensePreview`, so the information can be displayed in the view. In the
    view of the component, we use this state variable to compose an interface with
    these details as desired. In the following code, we render the total expenses
    for the current month, for the current date, and for the day before.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦从后端接收到数据，我们将它设置到名为`expensePreview`的状态变量中，以便在视图中显示信息。在组件的视图中，我们使用这个状态变量来组合一个界面，以显示这些详细信息。在下面的代码中，我们渲染了当前月份、当前日期和前一天的总支出。
- en: '`mern-expense-tracker/client/expense/ExpenseOverview.js`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-expense-tracker/client/expense/ExpenseOverview.js`:'
- en: '[PRE34]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: These values are only rendered if the corresponding value is returned in the
    aggregation results from the backend; otherwise, we render a "`0`."
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值只有在后端聚合结果中返回相应的值时才会渲染；否则，我们将渲染一个"`0`"。
- en: With this current expenses preview feature implemented, we are able to process
    the expense data recorded by the user to give them an idea of how much they are
    spending currently. In the next section, we will follow similar implementation
    steps to inform the user about their spending status for each expense category.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现当前支出预览功能，我们能够处理用户记录的支出数据，让他们了解他们当前的支出情况。在下一节中，我们将遵循类似的实现步骤，告知用户每个支出类别的支出状况。
- en: Tracking current expenses by category
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按类别跟踪当前支出
- en: 'In this application, we will give the user an overview of how much they are
    currently spending in each expense category in comparison to previous averages.
    For each category, we will display the monthly average based on previous expense
    data, show the total spent so far in the current month, and show the difference
    to indicate whether they are spending extra or are saving money in the current
    month. The following screenshot shows what this feature will look like to the
    end user for their expense data:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用中，我们将向用户提供一个概述，展示他们目前在每个支出类别中的支出情况，并与之前的平均值进行比较。对于每个类别，我们将显示基于之前支出数据的月平均支出，展示当前月份到目前为止的总支出，并显示差异，以表明他们是否在本月额外支出或节省了钱。以下截图显示了最终用户将如何看到这个功能：
- en: '![](img/d2f06c77-b483-4b80-9079-4ad1551ce9c8.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d2f06c77-b483-4b80-9079-4ad1551ce9c8.png)'
- en: To implement this feature, we need to add a backend API that will process the
    existing expense data to return the monthly average along with the total spent
    in the current month for each category, so it can be rendered in a React component.
    In the following sections, we will look at the implementation and integration
    of this API and frontend view to complete this feature to track expenses by category.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这个功能，我们需要添加一个后端API，该API将处理现有的支出数据，以返回每个类别的月平均支出以及当前月份的总支出，以便可以在React组件中渲染。在接下来的章节中，我们将探讨这个API的实现和集成，以及前端视图的整合，以完成按类别跟踪支出的功能。
- en: The current expenses by category API
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当前支出按类别API
- en: We will add an API to the backend that will return the average monthly expenses
    and the total spent in the current month for each expense category. To implement
    this API, we will first declare a `GET` route, as shown in the following code.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后端添加一个API，该API将返回每个支出类别的平均月支出和当前月份的总支出。为了实现这个API，我们首先声明一个`GET`路由，如下面的代码所示。
- en: '`mern-expense-tracker/server/routes/expense.routes.js`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-expense-tracker/server/routes/expense.routes.js`:'
- en: '[PRE35]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: A `GET` request to this route at `'/api/expenses/by/category'` will first ensure
    that the requesting client is a signed-in user, and then it will invoke the `expenseByCategory` controller
    method. In this method, we will use different features of MongoDB's aggregation
    framework to separately calculate the monthly expense averages for each category
    and the total spent in the current month per category, before combining the two
    results to return these two values associated with each category to the requesting
    client.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 对`'/api/expenses/by/category'`这个路由的`GET`请求将首先确保请求客户端已登录，然后它将调用`expenseByCategory`控制器方法。在这个方法中，我们将使用MongoDB聚合框架的不同特性来分别计算每个类别的月平均支出和每个类别的当前月份总支出，然后将这两个结果合并，返回与每个类别相关联的这两个值给请求客户端。
- en: The `expenseByCategory` controller method will be defined with the following
    structure, where we first determine the dates required to find matching expenses,
    and then we perform the aggregations before returning the results in the response.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`expenseByCategory`控制器方法将按照以下结构定义，我们首先确定查找匹配支出所需的日期，然后执行聚合操作，最后在响应中返回结果。'
- en: '`mern-expense-tracker/server/controllers/expense.controller.js`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-expense-tracker/server/controllers/expense.controller.js`:'
- en: '[PRE36]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In this method, we will use an aggregation pipeline containing a `$facet` with
    two sub-pipelines for calculating the monthly average per category and the total
    spent per category in the current month. Then, we take these two resulting arrays
    from the sub-pipelines to merge the results. The code for this aggregation pipeline
    is defined in the following code.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们将使用包含一个`$facet`和两个子管道的聚合管道，用于计算每个类别的月平均支出和当前月份的每个类别的总支出。然后，我们将从子管道中取这两个结果数组来合并结果。这个聚合管道的代码定义在下面的代码中。
- en: '`mern-expense-tracker/server/controllers/expense.controller.js`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-expense-tracker/server/controllers/expense.controller.js`:'
- en: '[PRE37]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: While projecting the output of the sub-pipelines in the `$facet` stage, we make
    sure that the keys of the result objects are `_id` and `value` in both output
    arrays, so they can be merged uniformly. Once the faceted aggregation operations
    are done, we use a `$setUnion` on the results to combine the arrays. Then, we
    make the resulting combined array the new root document in order to run a `$group`
    aggregation on it to merge the values for the averages and totals per category.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在`$facet`阶段的子管道输出投影时，我们确保结果对象的键在两个输出数组中都是`_id`和`value`，以便可以统一合并。一旦完成分面聚合操作，我们使用`$setUnion`对结果进行操作以合并数组。然后，我们将合并后的数组作为新的根文档，以便对其运行`$group`聚合以合并每个类别的平均值和总值。
- en: The final output from this aggregation pipeline will contain an array with an
    object for each expense category. Each object in this array will have the category
    name as the `_id` value and a `mergedValues` object containing the average and
    total values for the category. Then, this final output array generated from the
    aggregation is sent back in the response to the requesting client.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个聚合管道的最终输出将包含一个数组，其中每个支出类别都有一个对象。这个数组中的每个对象都将具有类别名称作为`_id`值，以及一个包含该类别平均和总值的`mergedValues`对象。然后，这个由聚合生成的最终输出数组被发送回请求客户端的响应中。
- en: We can use this API in the frontend with a fetch request. You can define a corresponding
    fetch method to make the request, similar to other API implementations. Then,
    the fetch method can be used in a React component to retrieve and render these
    aggregated values to the user. In the next section, we will discuss the implementation
    of this view to render the comparison of expenses in each category by a user in
    the current month versus previous months.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在前端使用fetch请求使用这个API。你可以定义一个相应的fetch方法来发起请求，类似于其他API实现。然后，这个fetch方法可以在React组件中使用来检索并渲染这些聚合值给用户。在下一节中，我们将讨论这个视图的实现，以展示用户在当前月份与上个月相比，每个类别的支出比较。
- en: Rendering an overview of expenses per category
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染每个类别的支出概览
- en: Besides informing the user of how much they are spending currently, we can give
    them an idea of how they are doing in comparison to previous expenditures. We
    can tell them whether they are spending more or saving money in the current month
    for each category. We can implement a React component, that calls the current
    expenses by category API to render the average and total values sent by the backend
    and also displays the computed difference between these two values.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 除了告知用户他们当前的支出情况外，我们还可以给他们一个与之前支出相比的情况。我们可以告诉他们，在当前月份的每个类别中，他们是支出更多还是节省了钱。我们可以实现一个React组件，该组件调用当前按类别支出的API来渲染后端发送的平均和总值，并显示这两个值之间的计算差异。
- en: The API can be fetched either in a `useEffect` hook or when a button is clicked
    on. In the MERN Expense Tracker application, we render these details in a React
    component that is added to the home page. We use a `useEffect` hook, as shown
    in the following code, to retrieve the expenses per category data.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: API可以通过`useEffect`钩子或点击按钮来获取。在MERN支出跟踪应用程序中，我们将在主页上添加的React组件中渲染这些详细信息。我们使用以下代码中的`useEffect`钩子来检索每个类别的支出数据。
- en: '`mern-expense-tracker/client/expense/ExpenseOverview.js`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-expense-tracker/client/expense/ExpenseOverview.js`:'
- en: '[PRE38]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We will set the values received from the backend to the state in an `expenseCategories` variable,
    and render its details in the view. This variable will contain an array, which
    we will iterate through in the view code to display three values for each category—the
    monthly average, the current month's total expenditure, and the difference between
    the two with an indication of whether money was saved or not.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把从后端接收到的值设置到`expenseCategories`状态变量中，并在视图中渲染其详细信息。这个变量将包含一个数组，我们将在视图代码中遍历这个数组，为每个类别显示三个值——每月平均数、当前月份的总支出，以及这两个值之间的差异，并指示是否节省了钱。
- en: In the following code, we use a `map` to iterate over the received data array
    and, for each item in the array, generate the view to display the average and
    total values received with the item. Besides this, we also show a computed value
    using these two values.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们使用`map`来遍历接收到的数据数组，并为数组中的每个项目生成视图以显示接收到的平均和总值。除此之外，我们还使用这两个值显示一个计算值。
- en: '`mern-expense-tracker/client/expense/ExpenseOverview.js`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-expense-tracker/client/expense/ExpenseOverview.js`:'
- en: '[PRE39]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: For each item in the array, we first render the category name, then the headings
    of the three values we will display. The third heading is rendered conditionally
    depending on whether the current total is more or less than the monthly average.
    Then, under each heading, we render the corresponding values for the monthly average,
    the current total—which will be zero if no value was returned—and then the difference
    between this average and the total. For the third value, we render the absolute
    value of the computed difference between the average and total values using `Math.abs()`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数组中的每个项目，我们首先渲染类别名称，然后渲染我们将显示的三个值的标题。第三个标题根据当前总金额是否多于或少于月平均金额有条件地渲染。然后，在每个标题下，我们渲染月平均金额、当前总金额（如果没有返回值，则将为零）以及这个平均金额和总金额之间的差异。对于第三个值，我们使用`Math.abs()`函数渲染平均金额和总金额之间计算出的差异的绝对值。
- en: 'Based on this difference, we also render the divider under the category name
    with different colors to indicate whether money was saved, extra money was spent,
    or the same amount of money was spent. To determine the color, we define a method
    called `indicateExpense`, as shown in the following code:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个差异，我们还在类别名称下方渲染不同颜色的分隔线，以指示是否节省了资金、额外花费了资金，或者花费了相同金额的资金。为了确定颜色，我们定义了一个名为`indicateExpense`的方法，如下面的代码所示：
- en: '[PRE40]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: A different color is returned if the current total is more than, less than,
    or equal to the monthly average. This gives the user a quick visual indicator
    of how they are faring in terms of incurring expenses per category for the current
    month.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前总金额多于、少于或等于月平均金额，将返回不同的颜色。这使用户能够快速直观地了解他们在当前月份按类别产生费用的表现。
- en: We have added simple data visualization features to the expense tracking application
    by utilizing existing capabilities of MERN stack technologies such as the aggregation
    framework in MongoDB. In the next section, we will demonstrate how to add even
    more complex data visualization features into this application by integrating
    an external charting library.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过利用MERN堆栈技术（如MongoDB中的聚合框架）的现有功能，向费用跟踪应用程序添加了简单的数据可视化功能。在下一节中，我们将演示如何通过集成外部图表库来向此应用程序添加更复杂的数据可视化功能。
- en: Displaying expense data charts
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示费用数据图表
- en: Graphs and charts are time-tested mechanisms for visualizing complex data patterns.
    In the MERN Expense Tracker application, we will add simple charts using Victory
    to report expense patterns over time in graphical representations to the user.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图表和图表是可视化复杂数据模式的经时间考验的机制。在MERN费用跟踪应用程序中，我们将通过图形表示向用户报告费用模式随时间的变化，并添加简单的图表使用Victory。
- en: Victory is an open source charting and data visualization library for React
    and React Native developed by Formidable. Different types of charts are available
    as modular components that can be customized and added to any React application.
    To learn more about Victory, visit [https://formidable.com/open-source/victory](https://formidable.com/open-source/victory).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Victory是一个由Formidable开发的针对React和React Native的开源图表和数据可视化库。不同类型的图表作为模块化组件提供，可以自定义并添加到任何React应用程序中。要了解更多关于Victory的信息，请访问[https://formidable.com/open-source/victory](https://formidable.com/open-source/victory)。
- en: 'Before we get started with integrating Victory charts in the code, we will
    need to install the module by running the following command from the command line:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始将Victory图表集成到代码中之前，我们需要通过在命令行中运行以下命令来安装模块：
- en: '[PRE41]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the expense tracking application, we will add three different charts as a
    part of the interactive expense reports presented to the user. The three charts
    will include a scatter plot showing the expenses incurred in a given month, a
    bar chart showing the total expenses incurred per month in a given year, and a
    pie chart showing the average expenditure per category within a provided date
    range.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在费用跟踪应用程序中，我们将添加三个不同的图表，作为向用户展示的交互式费用报告的一部分。这三个图表将包括一个散点图，显示在给定月份发生的费用，一个条形图，显示在给定年份每月发生的总费用，以及一个饼图，显示在提供的日期范围内每个类别的平均支出。
- en: For each chart, we will add a corresponding backend API to retrieve the relevant
    expense data and a React component to the frontend that will use the retrieved
    data to render the associated Victory chart. In the following sections, we will
    implement the full-stack slices necessary to add a scatter plot chart for a month's
    expenses, a bar chart showing a year's monthly expenses, and a pie chart displaying
    the average expenses per category over a given period of time.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个图表，我们将添加相应的后端API来检索相关的支出数据，并在前端添加一个React组件，该组件将使用检索到的数据来渲染相关的Victory图表。在以下章节中，我们将实现添加一个月度支出散点图、展示一年每月支出的条形图以及显示特定时间段内平均按类别支出的饼图所需的全栈切片。
- en: A month's expenses in a scatter plot
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 散点图中的一个月支出
- en: 'We will show the expenses incurred by a user over a given month in a scatter
    plot. This will provide them with a visual overview of how their expenses pan
    out over a month. The following screenshot shows how the scatter plot will render
    with user expense data:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过散点图展示用户在给定月份发生的支出。这将为他们提供一个关于其一个月内支出情况的视觉概述。以下截图显示了散点图如何使用户支出数据呈现：
- en: '![](img/9dd8ba80-3981-4919-a0e7-cdda0e660b71.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9dd8ba80-3981-4919-a0e7-cdda0e660b71.png)'
- en: We plot the expense amounts versus the day of the month when it was incurred
    on the *y* axis and *x* axis, respectively. Hovering over a plotted bubble displays
    how much was spent on which date for that specific expense record. In the following
    sections, we will implement this feature by first adding a backend API that will
    return the expenses for the given month in the format needed to render it in a
    Victory Scatter chart. Then, we will add a React component that will retrieve
    this data from the backend and render it in the Victory Scatter chart.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在y轴上绘制支出金额，在x轴上绘制该月支出发生的日期。将鼠标悬停在绘制的气泡上，将显示该特定支出记录在哪个日期花费了多少钱。在以下章节中，我们将通过首先添加一个后端API来实现此功能，该API将返回所需格式以在Victory散点图中渲染的给定月份的支出。然后，我们将添加一个React组件，该组件将从后端检索这些数据并在Victory散点图中渲染。
- en: The scatter plot data API
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 散点图数据API
- en: We will add an API to the backend that will return the expenses incurred over
    a given month in the data format needed to render the scatter chart in the frontend.
    To implement this API, we will first declare a `GET` route, as shown in the following
    code.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后端添加一个API，该API将返回给定月份发生的支出，并使用前端渲染散点图所需的数据格式。为了实现此API，我们首先声明一个`GET`路由，如下面的代码所示。
- en: '`mern-expense-tracker/server/routes/expense.routes.js`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-expense-tracker/server/routes/expense.routes.js`:'
- en: '[PRE42]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: A `GET` request to this route at `'/api/expenses/plot'` will first ensure that
    the requesting client is a signed-in user, and then it will invoke the `plotExpenses` controller
    method. The request will also take the value of the given month in a URL query
    parameter, which will be used in the `plotExpenses` method to determine the dates
    of the first day and the last day of the provided month. We will need these dates
    to specify the range for finding the matching expenses that were incurred in the
    specified month and recorded by the authenticated user while aggregating the expenses
    into the data format needed for the chart. The `plotExpenses` method is defined
    in the following code.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 对`'/api/expenses/plot'`此路由的`GET`请求将首先确保请求客户端已登录，然后它将调用`plotExpenses`控制器方法。请求还将通过URL查询参数获取给定月份的值，该值将在`plotExpenses`方法中使用，以确定所提供月份的第一天和最后一天。我们需要这些日期来指定查找在指定月份发生的并记录在认证用户中的匹配支出的范围，并将支出汇总到图表所需的数据格式中。`plotExpenses`方法定义在以下代码中。
- en: '`mern-expense-tracker/server/controllers/expense.controller.js`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-expense-tracker/server/controllers/expense.controller.js`:'
- en: '[PRE43]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We run a simple aggregation operation that finds the matching expenses and returns
    an output containing the values in the format needed for the *y* axis and *x*
    axis values of the scatter chart. The final result of the aggregation contains
    an array of objects, with each object containing an `x` attribute and a `y` attribute.
    The `x` attribute contains the day of the month value from the `incurred_on` date.
    The `y` attribute contains the corresponding expense amount. This final output
    array generated from the aggregation is sent back in the response to the requesting
    client.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行一个简单的聚合操作，找到匹配的支出，并返回一个包含散点图 *y* 轴和 *x* 轴所需格式的值的输出。聚合的最终结果包含一个对象数组，每个对象包含一个
    `x` 属性和一个 `y` 属性。`x` 属性包含来自 `incurred_on` 日期的月份值。`y` 属性包含相应的支出金额。从聚合生成的最终输出数组被发送回请求客户端的响应。
- en: We can use this API in the frontend with a fetch request. You can define a corresponding
    fetch method to make the request, similar to other API implementations. Then,
    the fetch method can be used in a React component to retrieve and render this
    array of `x` and `y` values in a scatter plot chart. In the next section, we will
    discuss the implementation of this view to render a scatter chart showing the
    expenses incurred over a given month.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用此 API 在前端通过 fetch 请求。您可以定义一个相应的 fetch 方法来发出请求，类似于其他 API 实现。然后，fetch 方法可以在
    React 组件中使用，以检索并渲染散点图中的 `x` 和 `y` 值数组。在下一节中，我们将讨论此视图的实现，以渲染显示给定月份发生的支出的散点图。
- en: The MonthlyScatter component
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MonthlyScatter 组件
- en: We will implement a React component that calls the scatter plot data API to
    render the received array of expenses incurred over a given month in a Victory
    Scatter chart.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个 React 组件，该组件调用散点图数据 API，以在 Victory Scatter 图表中渲染给定月份发生的支出数组。
- en: The API can be fetched either in a `useEffect` hook or when a button is clicked
    on. In the MERN Expense Tracker application, we render this scatter chart in a
    React component called `MonthlyScatter`. When this component loads, we render
    a scatter chart for expenses in the current month. We also add a `DatePicker` component
    to allow users to select the desired month and retrieve data for that month with
    a button click. In the following code, we retrieve the initial scatter plot data
    with a `useEffect` hook when the component loads.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: API 可以通过 `useEffect` 钩子或点击按钮时获取。在 MERN 支出跟踪应用程序中，我们在名为 `MonthlyScatter` 的 React
    组件中渲染这个散点图。当这个组件加载时，我们渲染当前月份的支出散点图。我们还添加了一个 `DatePicker` 组件，允许用户选择所需的月份，并通过点击按钮检索该月份的数据。在下面的代码中，当组件加载时，我们使用
    `useEffect` 钩子检索初始散点图数据。
- en: '`mern-expense-tracker/client/report/MonthlyScatter.js`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-expense-tracker/client/report/MonthlyScatter.js`:'
- en: '[PRE44]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: When the plotted data is received from the backend and set in the state, we
    can render it in a Victory Scatter chart. Additionally, we can add the following
    code in the component view to render a customized scatter chart with labels.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当从后端接收到绘制的数据并将其设置在状态中时，我们可以在 Victory Scatter 图表中渲染它。此外，我们可以在组件视图中添加以下代码以渲染带有标签的自定义散点图。
- en: '`mern-expense-tracker/client/report/MonthlyScatter.js`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-expense-tracker/client/report/MonthlyScatter.js`:'
- en: '[PRE45]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We place a `VictoryScatter` component in a `VictoryChart` component, giving
    us the flexibility to customize the scatter chart wrapper and place axis label
    texts outside the scatter chart. We pass the data to `VictoryScatter`, indicate
    which value the bubble property is based on, customize the styles, and specify
    the size range and labels for each bubble.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `VictoryScatter` 组件放置在 `VictoryChart` 组件中，这给了我们自定义散点图包装器和将轴标签文本放置在散点图外的灵活性。我们向
    `VictoryScatter` 传递数据，指出气泡属性基于哪个值，自定义样式，并指定每个气泡的大小范围和标签。
- en: This code plots and renders the scatter chart against the data provided with
    the amount spent versus the day of the month on the *y* axis and *x* axis, respectively.
    In the next section, we will follow similar steps to add a bar chart to graphically
    display the monthly expenses in a given year.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码根据提供的数据绘制并渲染散点图，其中金额支出与月份的某一天分别对应于 *y* 轴和 *x* 轴。在下一节中，我们将遵循类似的步骤添加柱状图，以图形方式显示给定年份的月度支出。
- en: Total expenses per month in a year
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一年中的每月总支出
- en: 'We will show the user a bar chart representing their total monthly expenses
    over a given year. This will give them an overview of how their expenses are spread
    out annually. The following screenshot shows how the bar chart will render with
    user expense data:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向用户展示一个表示他们在给定年份内每月总费用的条形图。这将让他们了解他们的费用是如何在一年中分布的。以下截图显示了条形图将如何使用用户费用数据渲染：
- en: '![](img/cd85f5ff-22b3-4a73-b64b-895a21ff103d.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cd85f5ff-22b3-4a73-b64b-895a21ff103d.png)'
- en: Here, we populate the bar chart with the total expense value corresponding to
    each month in a given year. We add the monthly total value as labels to each bar.
    On the x-axis, we show the short name of each month. In the following sections,
    we will implement this feature by first adding a backend API that will return
    the total expenses incurred per month over a given year and in the format needed
    to render it in a Victory Bar chart. Then, we will add a React component that
    will retrieve this data from the backend and render it in the Victory Bar chart.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用给定年份中每个月的总费用值填充条形图。我们将每月总价值作为标签添加到每个条形上。在x轴上，我们显示每个月的简称。在接下来的章节中，我们将通过首先添加一个后端API来实现这个功能，该API将返回给定年份每月发生的总费用，并且格式适合在前端渲染条形图。然后，我们将添加一个React组件，该组件将从后端检索这些数据并在Victory
    Bar图表中渲染。
- en: The yearly expenses API
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 年度费用API
- en: We will add an API to the backend that will return the total monthly expenses
    incurred over a given year in the data format needed to render the bar chart in
    the frontend.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后端添加一个API，该API将返回给定年份内每月发生的总费用，并且格式适合在前端渲染条形图。
- en: To implement this API, we will first declare a `GET` route, as shown in the
    following code.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这个API，我们首先将声明一个`GET`路由，如下面的代码所示。
- en: '`mern-expense-tracker/server/routes/expense.routes.js`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-expense-tracker/server/routes/expense.routes.js`:'
- en: '[PRE46]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: A `GET` request to this route at `'/api/expenses/yearly'` will first ensure
    that the requesting client is a signed-in user, and then it will invoke the `yearlyExpenses` controller
    method. The request will also take the value of the given year in a URL query
    parameter, which will be used in the `yearlyExpenses` method to determine the
    dates of the first day and the last day of the provided year. We will need these
    dates to specify the range for finding the matching expenses that were incurred
    in the specified year and recorded by the authenticated user while aggregating
    the total monthly expenses into the data format needed for the chart. The `yearlyExpenses` method
    is defined in the following code.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 对`'/api/expenses/yearly'`这个路由的`GET`请求将首先确保请求客户端是一个已登录的用户，然后它将调用`yearlyExpenses`控制器方法。请求还将从URL查询参数中获取给定年份的值，该值将在`yearlyExpenses`方法中使用，以确定所提供年份的第一天和最后一天。我们需要这些日期来指定查找在指定年份发生并由认证用户记录的匹配费用的范围，并在将总月度费用聚合到图表所需的数据格式时使用。`yearlyExpenses`方法在下面的代码中定义。
- en: '`mern-expense-tracker/server/controllers/expense.controller.js`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-expense-tracker/server/controllers/expense.controller.js`:'
- en: '[PRE47]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We run an aggregation operation that finds the matching expenses, groups the
    expenses by month to calculate the total, and returns an output containing the
    values in the format needed for the *y* axis and *x* axis values of the bar chart.
    The final result of the aggregation contains an array of objects, with each object
    containing an `x` attribute and a `y` attribute.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行一个聚合操作，找到匹配的费用，按月份分组费用以计算总和，并返回一个包含条形图y轴和x轴值所需格式的值的输出。聚合的最终结果包含一个对象数组，每个对象包含一个`x`属性和一个`y`属性。
- en: The `x` attribute contains the month value from the `incurred_on` date. The `y` attribute
    contains the corresponding total expense amount for that month. This final output
    array generated from the aggregation is sent back in the response to the requesting
    client.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`x`属性包含`incurred_on`日期的月份值。`y`属性包含该月的相应总费用金额。从聚合生成的最终输出数组将发送回请求客户端。'
- en: We can use this API in the frontend with a fetch request. You can define a corresponding
    fetch method to make the request, similar to other API implementations. Then,
    the fetch method can be used in a React component to retrieve and render this
    array of `x` and `y` values in a bar chart. In the next section, we will discuss
    the implementation of this view to render a bar chart showing the total monthly
    expenses incurred over a given year.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用此API在前端使用fetch请求。您可以定义一个相应的fetch方法来发出请求，类似于其他API实现。然后，fetch方法可以在React组件中使用来检索并渲染在柱状图中显示的`x`和`y`值的数组。在下一节中，我们将讨论实现此视图以渲染显示给定年份总月度支出的柱状图。
- en: The YearlyBar component
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 年度柱状图组件
- en: We will implement a React component that calls the yearly expenses data API
    to render the received array of expenses incurred monthly over a given year in
    a Victory Bar chart.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个React组件，该组件调用年度支出数据API，以在Victory Bar图表中渲染给定年份每月发生的支出数组。
- en: The API can be fetched either in a `useEffect` hook or when a button is clicked
    on. In the MERN Expense Tracker application, we render this bar chart in a React
    component called `YearlyBar`. When this component loads, we render a bar chart
    for expenses in the current year. We also add a `DatePicker` component to allow
    users to select the desired year and retrieve data for that year with a button
    click. In the following code, we retrieve the initial yearly expense data with
    a `useEffect` hook when the component loads.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: API可以通过`useEffect`钩子或当按钮被点击时获取。在MERN支出跟踪应用程序中，我们在名为`YearlyBar`的React组件中渲染此柱状图。当此组件加载时，我们渲染当前年份的支出柱状图。我们还添加了一个`DatePicker`组件，允许用户选择所需的年份，并通过按钮点击检索该年份的数据。在下面的代码中，我们在组件加载时使用`useEffect`钩子检索初始年度支出数据。
- en: '`mern-expense-tracker/client/report/YearlyBar.js`:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-expense-tracker/client/report/YearlyBar.js`:'
- en: '[PRE48]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: With the data received from the backend and set in the state, we can render
    it in a Victory Bar chart. We can add the following code in the component view
    to render a customized bar chart with labels and only the *x* axis displayed.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用从后端接收并设置在状态中的数据在Victory Bar图表中渲染。我们可以在组件视图中添加以下代码来渲染一个带有标签且仅显示*x*轴的自定义柱状图。
- en: '`mern-expense-tracker/client/report/YearlyBar.js`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-expense-tracker/client/report/YearlyBar.js`:'
- en: '[PRE49]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The month values returned from the database are zero-based indices, so we define
    our own array of month name strings to map to these indices. To render the bar
    chart, we place a `VictoryBar` component in a `VictoryChart` component, giving
    us the flexibility to customize the bar chart wrapper, and also the *y* axis with
    a `VictoryAxis` component, which is added without any props so that a *y* axis
    is not displayed at all.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库返回的月份值是零基索引，因此我们定义了自己的月份名称字符串数组来映射这些索引。为了渲染柱状图，我们在`VictoryChart`组件中放置了一个`VictoryBar`组件，这使我们能够自定义柱状图包装器，并且还使用`VictoryAxis`组件添加了*y*轴，因为没有添加任何属性，所以*y*轴根本不会显示。
- en: We pass the data to `VictoryBar` and also define the categories for the *x*
    axis values using the month strings so that all months of the year are displayed
    on the chart, even if a corresponding total value does not exist yet. We render
    individual labels for each bar to show the total expense value for each month.
    To map the *x* axis value with the correct month string, we specify it in the
    `x` prop for the `VictoryBar` component.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将数据传递给`VictoryBar`，并使用月份字符串定义*x*轴值的类别，以便在图表上显示整年的所有月份，即使尚未存在相应的总值。我们为每个柱状图渲染单独的标签，以显示每个月的总支出值。为了将*x*轴值与正确的月份字符串映射，我们在`VictoryBar`组件的`x`属性中指定它。
- en: This code plots and renders the bar chart against the data provided, with the
    monthly expense totals mapped for each month. In the next section, we will follow
    similar steps to add a pie chart to graphically display the average expenses per
    category in a given date range.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码根据提供的数据绘制并渲染柱状图，将每个月的支出总额映射到每个月。在下一节中，我们将遵循类似的步骤添加饼图，以图形方式显示给定日期范围内的平均支出类别。
- en: Average expenses per category in a pie chart
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 饼图中的平均支出类别
- en: 'We can render a pie chart showing how much users spend on average per expense
    category over a given period of time. This will help users visualize which categories
    consume more or less of their wealth over time. The following screenshot shows
    how the pie chart will render with user expense data:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以渲染一个饼图，显示用户在给定时间段内平均在每个支出类别上花费的金额。这将帮助用户可视化哪些类别随着时间的推移消耗了更多或更少的财富。以下截图显示了饼图将如何使用用户支出数据渲染：
- en: '![](img/7d31b4ff-2eb5-45d6-85d8-105670706600.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7d31b4ff-2eb5-45d6-85d8-105670706600.png)'
- en: We populate the pie chart with each category and its average expenditure value,
    showing the corresponding name and amount as labels. In the following sections,
    we will implement this feature by first adding a backend API that will return
    the average expenses per category over the given date range and in the format
    needed to render it in a Victory Pie chart. Then, we will add a React component
    that will retrieve this data from the backend and render it in the Victory Pie
    chart.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用每个类别及其平均支出值填充饼图，显示相应的名称和金额作为标签。在接下来的章节中，我们将通过首先添加一个后端 API 来实现此功能，该 API 将返回给定日期范围内每个类别的平均支出以及用于在
    Victory Pie 图表中渲染的格式。然后，我们将添加一个 React 组件，该组件将从后端检索这些数据并在 Victory Pie 图表中渲染。
- en: The average expenses by category API
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按类别平均支出 API
- en: We will add an API to the backend that will return the average expenses incurred
    in each category over a given time period and in the data format needed to render
    the pie chart in the frontend. To implement this API, we will first declare a
    `GET` route, as shown in the following code.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后端添加一个 API，该 API 将返回在给定时间段内每个类别的平均支出以及用于在前端渲染饼图的所需数据格式。为了实现此 API，我们首先声明一个
    `GET` 路由，如下面的代码所示。
- en: '`mern-expense-tracker/server/routes/expense.routes.js`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-expense-tracker/server/routes/expense.routes.js`:'
- en: '[PRE50]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: A `GET` request to this route at `'/api/expenses/category/averages'` will first
    ensure that the requesting client is a signed-in user, and then it will invoke
    the `averageCategories` controller method. The request will also take the values
    of the given date range in URL query parameters, which will be used in the `averageCategories` method
    to determine the dates of the first day and the last day of the provided range. We
    will need these dates to specify the range for finding the matching expenses that
    were incurred in the specified date range and recorded by the authenticated user
    while aggregating the expense averages per category into the data format needed
    for the chart. The `averageCategories` method is defined in the following code.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `'/api/expenses/category/averages'` 路由的 `GET` 请求将首先确保请求客户端已登录，然后它将调用 `averageCategories`
    控制器方法。请求还将通过 URL 查询参数获取给定日期范围的值，这些值将在 `averageCategories` 方法中使用，以确定提供的范围的起始日期和结束日期。我们需要这些日期来指定在指定日期范围内找到匹配的支出，这些支出由认证用户记录并在聚合每个类别的支出平均值到图表所需的数据格式时进行。`averageCategories`
    方法在以下代码中定义。
- en: '`mern-expense-tracker/server/controllers/expense.controller.js`:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-expense-tracker/server/controllers/expense.controller.js`:'
- en: '[PRE51]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We run an aggregation operation that finds the matching expenses, groups the
    expenses by category to first calculate the total and then the average, and returns
    an output containing the values in the format needed for the *y* and *x* values
    of the pie chart. The final result of the aggregation contains an array of objects,
    with each object containing an `x` attribute and a `y` attribute. The `x` attribute
    contains the category name as the value. The `y` attribute contains the corresponding
    average expense amount for that category. This final output array generated from
    the aggregation is sent back in the response to the requesting client.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行一个聚合操作，找到匹配的支出，按类别分组支出以首先计算总数然后计算平均值，并返回一个包含饼图 *y* 和 *x* 值所需格式的输出。聚合的最终结果包含一个对象数组，每个对象包含一个
    `x` 属性和一个 `y` 属性。`x` 属性包含类别名称作为值。`y` 属性包含该类别的相应平均支出金额。从聚合生成的最终输出数组将发送回请求客户端。
- en: We can use this API in the frontend with a fetch request. You can define a corresponding
    fetch method to make the request, similar to other API implementations. Then,
    the fetch method can be used in a React component to retrieve and render this
    array of `x` and `y` values in a pie chart. In the next section, we will discuss
    the implementation of this view to render a pie chart showing the average expenses
    incurred per category over a given date range.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在前端使用 fetch 请求使用此 API。您可以定义一个相应的 fetch 方法来发送请求，类似于其他 API 实现。然后，fetch 方法可以在
    React 组件中使用，以检索并渲染饼图中的 `x` 和 `y` 值数组。在下一节中，我们将讨论此视图的实现，以渲染一个饼图，显示在给定日期范围内每个类别的平均支出。
- en: The CategoryPie component
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CategoryPie 组件
- en: We will implement a React component that calls the average expenses by category
    API to render the received array of average expenses incurred per category in
    a Victory Pie chart.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个React组件，该组件调用按类别平均支出API，以在Victory饼图中渲染接收到的每个类别平均支出的数组。
- en: The API can be fetched either in a `useEffect` hook or when a button is clicked
    on. In the MERN Expense Tracker application, we render this pie chart in a React
    component called `CategoryPie`. When this component loads, we render a pie chart
    for the average expenses incurred per category in the given month. We also add
    two `DatePicker` components to allow users to select the desired date range and
    retrieve data for that range with a button click. In the following code, we retrieve
    the initial average expense data with a `useEffect` hook when the component loads.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: API可以通过`useEffect`钩子或当按钮被点击时获取。在MERN支出跟踪应用程序中，我们在名为`CategoryPie`的React组件中渲染这个饼图。当这个组件加载时，我们渲染给定月份每个类别平均支出的饼图。我们还添加了两个`DatePicker`组件，允许用户选择所需的日期范围，并通过点击按钮检索该范围的数据。在下面的代码中，我们使用`useEffect`钩子在组件加载时检索初始平均支出数据。
- en: '`mern-expense-tracker/client/report/CategoryPie.js`:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-expense-tracker/client/report/CategoryPie.js`:'
- en: '[PRE52]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: With the data received from the backend and set in state, we can render it in
    a Victory Pie chart. We can add the following code in the component view to render
    a customized pie chart with individual text labels for each slice and a center
    label for the chart.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从后端接收并设置在状态中的数据，我们可以在Victory饼图中渲染它。我们可以在组件视图中添加以下代码来渲染一个带有每个切片的单独文本标签和图表中心标签的自定义饼图。
- en: '`mern-expense-tracker/client/report/CategoryPie.js`:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-expense-tracker/client/report/CategoryPie.js`:'
- en: '[PRE53]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: To render the pie chart with a separate center label, we place a `VictoryPie` component
    in an `svg` element, giving us the flexibility to customize the pie chart wrapping
    and a separate circular label using a `VictoryLabel` outside the pie chart code.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 要渲染带有单独中心标签的饼图，我们将`VictoryPie`组件放置在一个`svg`元素中，这使我们能够自定义饼图包装，并使用`VictoryLabel`在饼图代码外部添加一个单独的圆形标签。
- en: We pass the data to `VictoryPie`, define customized labels for each slice, and
    make the pie chart standalone so that the center label can be placed over the
    chart. This code plots and renders the pie chart against the data provided with
    the average expense displayed for each category.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将数据传递给`VictoryPie`，为每个切片定义自定义的标签，并使饼图独立，以便中心标签可以放置在图表上。此代码根据提供的数据绘制并渲染饼图，每个类别显示平均支出。
- en: We have added three different Victory charts to the application based on the
    user-recorded expense data, which was processed as needed and retrieved from the
    database in the backend. The MERN Expense Tracker application is complete with
    abilities that allow users to record their day-to-day expenses, and then visualize
    data patterns and expenditure habits extracted from the expense data recorded
    over time.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已根据用户记录的支出数据添加了三个不同的Victory图表到应用程序中，这些数据经过必要的处理，并从后端数据库中检索。MERN支出跟踪应用程序功能齐全，允许用户记录他们的日常支出，并可视化从记录的支出数据中提取的数据模式和支出习惯。
- en: Summary
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we extended the MERN skeleton application to develop an expense
    tracking application with data visualization features. We designed an Expense
    model for recording expense details and implemented the full-stack **CRUD** (**Create**,
    **Read**, **Update**, **Delete**) functionalities that allowed signed-in users
    to record their day-to-day expenses, see a list of their expenses, and modify
    existing expense records.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将MERN骨架应用程序扩展为开发一个具有数据可视化功能的支出跟踪应用程序。我们设计了一个支出模型来记录支出细节，并实现了全栈**CRUD**（**创建**、**读取**、**更新**、**删除**）功能，允许已登录用户记录他们的日常支出，查看他们的支出列表，并修改现有的支出记录。
- en: We added data processing and visualization features that gave users an overview
    of their current expenses and also an idea of how much more or less they are spending
    per expense category. We also incorporated different types of charts to show users
    their expenditure patterns over various time ranges.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了数据处理和可视化功能，使用户能够了解他们的当前支出，并了解他们在每个支出类别上花费的更多或更少的金额。我们还集成了不同类型的图表，以显示用户在不同时间范围内的支出模式。
- en: While implementing these features, we learned about some of the data processing
    options with the aggregation framework in MongoDB and also incorporated some of
    the customizable chart components from Victory. You can explore the aggregation
    framework and the Victory library further to incorporate more complex data visualization
    features in your own full-stack applications.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现这些功能的过程中，我们了解到了MongoDB中聚合框架的一些数据处理选项，并且还整合了一些来自Victory的可定制图表组件。您可以进一步探索聚合框架和Victory库，以便在您自己的全栈应用程序中整合更复杂的数据可视化功能。
- en: In the next chapter, we will explore even more advanced possibilities with MERN
    stack technologies as we build a media streaming application by extending the
    MERN skeleton.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过扩展MERN骨架来构建一个媒体流应用程序，我们将探索MERN堆栈技术的一些更高级的可能性。
