- en: '*Chapter 3*: Next.js Basics and Built-In Components'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next.js is not only about server-side rendering. It provides some incredibly
    useful built-in components and functions that we can use to create performant,
    dynamic, and modern websites.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we're going to take a look at some concepts at the core of
    Next.js, such as routing systems, client-side navigation, serving optimized images,
    handling metadata, and more. These notions will be very beneficial once we move
    on to building some real-world applications with this framework.
  prefs: []
  type: TYPE_NORMAL
- en: We will also take a closer look at the `_app.js` and `_document.js` pages, which
    will allow us to customize our web app behavior in several ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How the routing system works, both on the client and server sides
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to optimize navigation between pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How Next.js serves static assets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to optimize image serving via automatic image optimization and the new `Image`
    component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to dynamically handle HTML metadata from any component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the `_app.js` and `_document.js` files and how can they be customized?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To run the code examples in this chapter, you need to have both Node.js and
    npm installed on your local machine.
  prefs: []
  type: TYPE_NORMAL
- en: If you prefer, you can use an online IDE such as [https://repl.it](https://repl.it)
    or [https://codesandbox.io](https://codesandbox.io); they both support Next.js,
    and you don't need to install any dependency on your computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the code for this chapter on the GitHub repository: [https://github.com/PacktPublishing/Real-World-Next.js](https://github.com/PacktPublishing/Real-World-Next.js).'
  prefs: []
  type: TYPE_NORMAL
- en: Routing system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you're coming from client-side React, you might be familiar with libraries
    such as *React Router*, *Reach Router*, or *Wouter*. They allow you to create
    client-side routes only, meaning that all the pages will be created and rendered
    on the client side; no server-side rendering is involved.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next.js uses a different approach: filesystem-based pages and routes. As seen
    in Chapter 2, *Exploring Different Rendering Strategies*, a default Next.js project
    ships with a `pages/` directory. Every file inside that folder represents a new
    page/route for your application.'
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, when talking about a page, we refer to a React component exported
    from any of the `.js`, `.jsx`, `.ts`, or `.tsx` files inside the `pages/` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make things a bit clearer, let''s say that we want to create a simple website
    with just two pages; the first one will be the home page, while the second one
    will be a simple contact page. To do that, we will only need to create two new
    files inside our `pages/` folder: `index.js` and `contacts.js`. Both files will
    need to export a function returning some JSX content; it will be rendered on the
    server side and sent to the browser as standard HTML.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we''ve just seen, a page must return valid JSX code, so let''s make a very
    simple and concise `index.js` page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If we run `yarn dev` or `npm run dev` in our terminal, then move to [http://localhost:3000](http://localhost:3000)
    in our browser, we will only see the **This is the homepage** message appear on
    the screen. We've just made our first page!
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do the same with our contact page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Given that we've called our contact page `contacts.js`, we can navigate to http://localhost:3000/contacts
    and see the contacts list displayed on the browser. If we want to move that page
    to http://localhost:3000/contact-us, we can just rename our `contacts.js` file
    to `contact-us.js`, and Next.js will automatically rebuild the page using the
    new route name for us.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's try to make things a bit harder. We're building a blog, so we want
    to create a route for each post. We also want to create a `/posts` page that will
    show every post present on the website.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, we will use a dynamic route as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We haven't mentioned yet that we can create nested routes using folders inside
    our `pages/` directory. If we want to make a `/posts` route, we can create a new
    `index.js` file inside the `pages/posts/` folder, export a function containing
    some JSX code, and visit http://localhost:3000/posts.
  prefs: []
  type: TYPE_NORMAL
- en: We then want to create a dynamic route for every blog post so that we don't
    have to manually create a new page every time we want to publish an article on
    our website. To do that, we can create a new file inside the `pages/posts/` folder,
    `pages/posts/[slug].js`, where `[slug]` identifies a route variable that can contain
    any value, depending on what the user types in the browser's address bar. In that
    case, we're creating a route containing a variable called `slug`, which can vary
    for every blog post. We can export a simple function returning some JSX code from
    that file and then browse to http://localhost:3000/posts/my-firstpost, http://localhost:3000/posts/foo-bar-baz,
    or any other http://localhost:3000/posts/* route. Whatever route you browse to,
    it will always render the same JSX code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also nest multiple dynamic routes inside the `pages/` folder; let''s
    say that we want our post page structure to be as follows: `/posts/[date]/[slug]`.
    We can just add a new folder called `[date]` inside our `pages/` directory and
    move the `slug.js` file inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We can now visit [http://localhost:3000/posts/2021-01-01/my-first-post](http://localhost:3000/posts/2021-01-01/my-first-post)
    and see the JSX content we've created previously. Once again, both the `[date]`and
    `[slug]` variables can represent whatever you want, so feel free to experiment
    by calling different routes on the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Until now, we have always used route variables to render the same page, but
    these variables are mainly meant for creating highly dynamic pages with different
    content depending on the route variables we're using. Let's see how to render
    different content depending on the variables in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: Using route variables inside our pages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Route variables are incredibly useful for creating very dynamic page content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take an easy example: a greetings page. Inside the project used in the
    previous section, let''s create the following file: `pages/greet/[name].js`. We''re
    going to use Next.js'' built-in `getServerSideProps` function to dynamically get
    the `[name]` variable from the URL and greet the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, open your favorite browser and go to http://localhost:3000/greet/Mitch;
    you should see a "`name` variable, so feel free to try with some different names!
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: When using both the `getServerSideProps` and `getStaticProps` functions, remember
    that they *must* return an object. Also, if you want to pass any prop from one
    of those two functions to your page, make sure to pass them inside the returning
    object's `props` property.
  prefs: []
  type: TYPE_NORMAL
- en: Being able to get data from the URL is fundamental for many reasons. In the
    previous code example, we made a simple greetings page, but we could have used
    the `[name]` variable for other purposes, such as getting that user data from
    a database to show their profile. We will take a closer look at data fetching
    in [*Chapter 4*](B16985_04_Final_SB_epub.xhtml#_idTextAnchor053), *Organizing
    the Code Base and Fetching Data in Next.js*.
  prefs: []
  type: TYPE_NORMAL
- en: There are times when you need to fetch route variables from your components
    rather than your pages. Next.js makes this effortless thanks to a React hook that
    we'll see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using route variables inside components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we have learned how to use route variables inside our
    pages. Next.js does not allow us to use both `getServerSideProps` and `getStaticProps`
    functions outside of our pages, so how are we supposed to use them inside other
    components?
  prefs: []
  type: TYPE_NORMAL
- en: 'Next.js makes this effortless thanks to the `useRouter` hook; we can import
    it from the `next/router` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'It works just like any other React hook (a function that lets you interact
    with the React state and life cycle in function components), and we can instantiate
    it inside any component. Let''s refactor the previous greetings page as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are extracting the `query` parameter from the `useRouter`
    hook. It contains both our route variables (in this case, it only contains the
    `name` variable) and the parsed query string parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can observe how Next.js passes both route variables and query strings via
    the `useRouter` hook by trying to append any query parameter to our URL and log
    the `query` variable inside our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If we now try to call the following URL, http://localhost:3000/greet/Mitch?learning_nextjs=true,
    we will see the following object logged inside our terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Next.js does not throw any error if you try to append a query parameter with
    the same key as your routing variable. You can easily try that by calling the
    following URL: http://localhost:3000/greet/Mitch?name=Christine. You will notice
    that Next.js will give precedence to your route variable, such that you will see
    **Hello, Mitch!** displayed on the page.'
  prefs: []
  type: TYPE_NORMAL
- en: Client-side navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have already seen so far, Next.js is not only about rendering React on
    the server. It provides several ways to optimize your website's performance, and
    one of these optimizations is how it handles client-side navigation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, it supports the HTML standard `<a>` tags for linking pages, but it
    also provides a more optimized way for navigating between different routes: the
    `Link` component.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can import it as a standard React component and use it for linking different
    pages or sections of our website. Let''s look at an easy example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: By default, Next.js will preload every single `Link` found on the viewport,
    meaning that once we click on one of the links, the browser will already have
    all the data needed to render the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can disable this feature by passing the `preload={false}` prop to the `Link`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Starting with Next.js 10, we're also able to link pages with dynamic route variables
    with ease.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that we want to link the following page: `/blog/[date]/[slug].js`.
    With previous versions of Next.js, we needed to add two different props:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `href` prop tells Next.js which page we want to render, and the `as` prop
    will tell how we want to display it in the browser's address bar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thanks to the enhancements introduced in Next.js 10, we no longer need to use
    the `as` prop as the `href` prop is enough for setting both the page we want to
    render and the URL displayed in the browser''s address bar. For instance, we can
    now write our links as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Although the legacy method for linking dynamic pages using the `Link` component
    is still working in Next.js >10, the framework's newest version makes it way easier.
    If you have some experience with previous Next.js versions or you're willing to
    upgrade to version >10, keep that new feature in mind as it will simplify the
    development of components, including dynamic links.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we are building complex URLs, we can also pass an object to the `href` prop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the user clicks that link, Next.js will redirect the browser to the following
    URL: http://localhost:3000/blog/2020-01-01/happy-new-year?foo=bar.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the router.push method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is another way to move between your Next.js website pages: by using the
    `useRouter` hook.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s pretend that we want to give access to a given page only to logged-in
    users, and we already have a `useAuth` hook for that. We can use the `useRouter`
    hook to dynamically redirect a user if, in this case, they''re not logged in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we're using the `useEffect` hook to run the code on the client
    side only. In that case, if the user isn't logged in, we use the `router.push`
    method to redirect them to the login page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like with the `Link` component, we can create more complex page routes
    by passing an object to the `push` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Once the `router.push` function has been called, the browser will be redirected
    to http://localhost:3000/blog/2020-01-01/happy-new-year?foo=bar.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Next.js won't be able to prefetch all the linked pages as it does with the `Link`
    component.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `router.push` method is handy when you need to redirect a user on
    the client side after a certain action occurs, but it's not recommended to be
    used as a default way for handling client-side navigation.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we've seen how Next.js handles navigation through static and dynamic
    routes and how to force redirection and navigation on both the client and server
    sides programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we're going to look at how Next.js helps us to serve static
    assets and optimize images on the fly for improved performance and SEO scores.
  prefs: []
  type: TYPE_NORMAL
- en: Serving static assets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the term **static asset**, we refer to all of those non-dynamic files,
    such as images, fonts, icons, compiled CSS, and JS files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to serve those assets is by using the default `/public` folder
    provided by Next.js. In fact, every file inside this folder will be considered
    and served as a static asset. We can prove that by creating a new file called
    `index.txt` and putting it inside the `/public` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If we now try to launch the server, when we go to [http://localhost:3000/index.txt](http://localhost:3000/index.txt),
    we will see the text **Hello, world!** displayed in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 4*](B16985_04_Final_SB_epub.xhtml#_idTextAnchor053), *Organizing
    the Code Base and Fetching Data in Next.js*, we will take a closer look at organizing
    the public folder for serving common CSS and JS files, images, icons, and all
    the other types of static files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Serving static assets is relatively easy. However, a specific type of file
    can critically affect your website performance (and SEO): the image file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the time, serving non-optimized images will worsen your user experience,
    as they may take some time to load, and once they do, they''ll move part of the
    layout after the rendering, which can cause many problems in terms of UX. When
    this occurs, we''re talking about **Cumulative Layout Shift (CLS)**. Here is a
    simple representation of how CLS works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Representation of how CLS works'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16985_03_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – Representation of how CLS works
  prefs: []
  type: TYPE_NORMAL
- en: In the first browser tab, the image has not been loaded yet, so the two text
    areas look quite close to each other. After the image loads, it shifts the second
    text area down. If the user were reading the second text area, they would easily
    miss the mark.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to learn more about CLS, I''d recommend the following article:
    [https://web.dev/cls](https://web.dev/cls).'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, Next.js makes it easy to avoid CLS, and it does so with a new built-in
    `Image` component. We will take a look at this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Next.js' automatic image optimization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Starting with Next.js 10, the framework introduced a new helpful `Image` component
    and automatic image optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Before Next.js introduced these two new features, we had to optimize every image
    using an external tool and then write down a complex `srcset` property for every
    HTML `<img>` tag to set responsive images for different screen sizes.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, automatic image optimization will take care of serving your images using
    modern formats (such as **WebP**) to all those browsers that support it. But it
    will also be able to fall back on older image formats, such as *png* or *jpg*,
    in case the browser you're using doesn't support it. It also resizes your images
    to avoid serving heavy pictures to the client as it would negatively affect the
    asset's download speed.
  prefs: []
  type: TYPE_NORMAL
- en: One great thing to keep in mind is that automatic image optimization works on-demand,
    as it optimizes, resizes, and renders the image only when the browser has requested
    it. This is important as it will work with any external data source (any CMS or
    image service, such as Unsplash or Pexels), and it won't slow down the build phase.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can try this feature on our local machine in a few minutes to see in person
    how it works. Let''s say that we want to serve the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Picture by Łukasz Rawa on Unsplash (https://unsplash.com/@lukasz_rawa)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16985_03_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2 – Picture by Łukasz Rawa on Unsplash ([https://unsplash.com/@lukasz_rawa](https://unsplash.com/@lukasz_rawa))
  prefs: []
  type: TYPE_NORMAL
- en: 'Using standard HTML tags, we could just do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: However, we may also want to use the `srcset` property for responsive images,
    so we'll actually need to optimize the picture for different screen resolutions,
    which involves some extra steps for serving our assets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next.js makes it very easy by just configuring the `next.config.js` file and
    using the `Image` component. We just said that we want to serve images coming
    from Unsplash, so let''s add that service hostname to our `next.config.js` file,
    under the `images` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: That way, every time we use an image coming from that hostname inside an `Image`
    component, Next.js will automatically optimize it for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s try to import that image inside a page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Opening the browser, you will notice that the image is stretched to fit both
    the `width` and `height` props specified in your `Image` component.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Representation of the image component we just created'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16985_03_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.3 – Representation of the image component we just created
  prefs: []
  type: TYPE_NORMAL
- en: 'We can crop our image to fit the desired dimensions using the optional `layout`
    prop. It accepts four different values: `fixed`, `intrinsic`, `responsive`, and
    `fill`. Let''s look at these in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fixed` works just like the `img` HTML tag. If we change the viewport size,
    it will keep the same size, meaning that it won''t provide a responsive image
    for smaller (or bigger) screens.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`responsive` works in the opposite way to `fixed`; as we resize our viewport,
    it will serve differently optimized images for our screen size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`intrinsic` is halfway between `fixed` and `responsive`; it will serve different
    image sizes as we resize down our viewport, but it will leave the largest image
    untouched on bigger screens.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fill` will stretch the image according to its parent element''s width and
    height; however, we can''t use `fill` alongside the `width` and `height` props.
    You can use `fill` *or* `width` and `height`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So now, if we want to fix our English Setter image to display it properly on
    our screen, we can refactor our `Image` component as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we wrapped the `Image` component with a fixed size `div` and
    the CSS `position` property set to `relative`. We also removed both the `width`
    and `height` props from our `Image` component, as it will stretch following its
    parent `div` sizes.
  prefs: []
  type: TYPE_NORMAL
- en: We also added the `objectFit` prop set to `cover` so that it will crop the image
    according to its parent `div` size, and that's the final result.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Representation of the image component with the layout prop set
    to "fill"'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16985_03_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 – Representation of the image component with the layout prop set
    to "fill"
  prefs: []
  type: TYPE_NORMAL
- en: 'If we now try to inspect the resulting HTML on the browser, we will see that
    the `Image` component generated many different image sizes, which will be served
    using the `srcset` property of a standard `img` HTML tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: One last thing worth mentioning is that if we inspect the image format on Google
    Chrome or Firefox, we will see that it has been served as `WebP`, even if the
    original image served from Unsplash was a `jpeg`. If we now try to render the
    same page on iOS with Safari, Next.js will serve the original `jpeg` format, as
    (at the time of writing) that iOS browser does not yet support the `WebP` format.
  prefs: []
  type: TYPE_NORMAL
- en: As said at the beginning of this section, Next.js runs automatic image optimization
    on-demand, meaning that if a given image is never requested, it will never be
    optimized.
  prefs: []
  type: TYPE_NORMAL
- en: The whole optimization phase occurs on the server where Next.js is running.
    If you're running a web app containing tons of images, it could affect your server
    performance. In the next section, we'll see how to delegate the optimization phase
    to external services.
  prefs: []
  type: TYPE_NORMAL
- en: Running automatic image optimization on external services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, automatic image optimization runs on the same server as Next.js.
    Of course, if you''re running your website on a small server with low resources,
    this could potentially affect its performance. For that reason, Next.js allows
    you to run automatic image optimization on external services by setting the `loader`
    option inside your `next.config.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''re deploying your web app to Vercel, you don''t actually need to set
    up any loader in your `next.config.js` file as Vercel will take care of optimizing
    and serving the image files for you. Otherwise, you can use the following external
    services:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Akamai: [https://www.akamai.com](https://www.akamai.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Imgix: [https://www.imgix.com](https://www.imgix.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cloudinary: [https://cloudinary.com](https://cloudinary.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you don''t want to use any of these services, or you want to use your custom
    image optimization server, you can use the `loader` prop directly inside your
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This way, you'll be able to serve images coming from any external service and
    this allows you to take advantage of custom image optimization servers or free,
    open source projects such as *Imgproxy* ([https://github.com/imgproxy/imgproxy](https://github.com/imgproxy/imgproxy))
    or *Thumbor* (https://github.com/thumbor/thumbor).
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: 'When you''re using custom loaders, keep in mind that every service has its
    own APIs for resizing and serving images. For instance, to serve an image from
    *Imgproxy*, you would need to call it with the following URL: https://imgproxy.example.com/<auth-key>/fill/500/500/sm/0/plain/https://example.com/images/myImage.jpg.
    With *Thumbor*, you''d need to call it with a different URL schema: [https://thumbor.example.com/500x500/smart/example.com/images/myImage.jpg](https://thumbor.example.com/500x500/smart/example.com/images/myImage.jpg).'
  prefs: []
  type: TYPE_NORMAL
- en: Before creating a custom loader, read the documentation of your image optimization
    server.
  prefs: []
  type: TYPE_NORMAL
- en: Correctly serving images has become more and more complex during the last years,
    but it is worth spending some time fine-tuning that process as it can affect our
    user experience in many critical ways. Thankfully, Next.js makes it quite effortless
    thanks to its built-in components and optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: However, we should also think of web scrapers, bots, and web spiders when we're
    building a web app! I'm referring to web technologies that will look at our web
    page's metadata for taking actions such as indexing, linking, and evaluation.
    We'll see how to handle metadata in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Handling metadata
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Correctly handling metadata is a crucial part of modern web development. To
    keep it simple, let''s think about when we share a link on Facebook or Twitter.
    If we share the React website ([https://reactjs.org](https://reactjs.org)) on
    Facebook, we will see the following card appear inside our post:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Open Graph data of https://reactjs.org'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16985_03_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.5 – Open Graph data of [https://reactjs.org](https://reactjs.org
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: To know which data should be displayed inside the card, Facebook uses a protocol
    called **Open Graph** ([https://ogp.me](https://ogp.me)). In order to give that
    information to any social network or website, we need to add some metadata to
    our pages.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we haven't yet talked about how to set open graph data, HTML titles,
    or HTML meta tags dynamically. While a website could technically work even without
    that data, search engines would penalize your pages, as they would miss important
    information. The user experience could also be negatively affected as these meta
    tags would help the browser create an optimized experience for our users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, Next.js provides a great way of solving these problems: the built-in
    `Head` component. Indeed, this component allows us to update the `<head>` section
    of our HTML page from any component, meaning that we can dynamically change, add,
    or delete any metadata, link, or script at runtime depending on our user''s navigation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start with one of the most common dynamic parts of our metadata: the
    HTML `<title>` tag. Let''s set up a new Next.js project and then create two new
    pages.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first page we will create is `index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The second page is `about.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Running the server, you will be able to navigate between those two pages and
    see that the `<title>` content changes depending on the route you're visiting.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's make things a bit more complex. We want to create a new component
    that only displays a button. Once we click on it, our page title will change depending
    on the page we're currently on; we can always roll back to the original title
    by clicking on the button again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new folder, `components/`, in your project root and a new file,
    `components/Widget.js`, inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Great! Now let's edit both our `index.js` and `about.js` pages to include that
    component.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by opening the `index.js` file and importing the `Widget` component
    and then we''re going to render it inside a new `<div>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s do the same thing with the `about.js` page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: After this title is refactored, every time we click on `<title>` element.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: 'If multiple components are trying to update the same meta tag, Next.js occasionally
    will duplicate the same tag but with different content. For instance, if we have
    two components editing the `<title>` tag, we could end up having two distinct
    `<title>` tags inside our `<head>`. We can avoid that by adding the `key` prop
    to our HTML tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<title key=''htmlTitle''>some content</title>`. This way, Next.js will look
    for every HTML tag with that specific key and update it instead of adding a new
    one.'
  prefs: []
  type: TYPE_NORMAL
- en: So far, we've seen how to handle metadata inside our pages and components, but
    there are cases where you want to use the same meta tags on different components.
    In those cases, you may not want to rewrite all the metadata from scratch for
    each component, so here comes the concept of grouping metadata by creating a whole
    component just for handling that kind of HTML tag. We'll take a closer look at
    this approach in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Grouping common meta tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, we may want to add many other meta tags to our website to improve
    its SEO performance. The problem is that we could easily end up creating huge
    page components containing basically the same tags. For that reason, it is common
    practice to create one or more components (depending on your needs) to handle
    most of the common `head` meta tags.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say that we want to add a blog section to our website. We may want to
    add support for open graph data, Twitter cards, and other metadata for our blog
    posts, so we could easily group all this common data inside a `PostHead` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new file, `components/PostHead.js`, and add the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create a mock for our posts. We will create a new folder called
    `data` and a file called `posts.js` inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! Now we only need to create a `[slug]` page to display our posts. The
    full route will be `/blog/[slug]`, so let''s create a new file called `[slug].js`
    inside `pages/blog/` and add the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If we now go to http://localhost:3000/blog/dog-of-the-day-the-english-setter
    and inspect the resulting HTML, we will see the following tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now, try to browse other blog posts and see how the HTML content changes for
    each one of them.
  prefs: []
  type: TYPE_NORMAL
- en: This approach is not mandatory, but it allows you to logically separate head-related
    components from other components, leading to a more organized code base.
  prefs: []
  type: TYPE_NORMAL
- en: But what if we need the same meta tags (or, at least, some common basic data)
    on every page? We don't actually need to rewrite every single tag or import a
    common component on each page. We'll see in the next section how to avoid that
    by customizing our `_app.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing _app.js and _document.js pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are certain cases where you need to take control over page initialization,
    so that every time we render a page, Next.js will need to run certain operations
    before sending the resulting HTML to the client. To do that, the framework allows
    us to create two new files, called `_app.js` and `_document.js`, inside our `pages/`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: The _app.js page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, Next.js ships with the following [pages/_app.js](http://pages/_app.js)
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the function is just returning the Next.js page component (the
    `Component` prop) and its props (`pageProps`).
  prefs: []
  type: TYPE_NORMAL
- en: 'But now, let''s say that we want to share a navigation bar between all the
    pages without manually importing that component on each page. We can start by
    creating the navbar inside `components/Navbar.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: That is a really simple navigation bar with just three links that will allow
    us to navigate our website.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to import it inside our `_app.js` page as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: If we now create two more pages (`about.js` and `contacts.js`), we will see
    that the navbar component will be rendered on any page.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's make it a bit more complex by adding support for both dark and light
    themes. We'll do that by creating a React context and wrapping the `<Component
    />` component inside our `_app.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a context in `components/themeContext.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s go back to our `_app.js` file and create the theme state, inline
    CSS styles, and wrap the page component in a context provider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Last but not least, we need to add a button for toggling dark/light themes.
    We''re going to add it to our navigation bar, so let''s open the `components/Navbar.js`
    file and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: If you try to toggle the dark theme, and then navigate between all the website
    pages using the navigation bar, you will see that Next.js keeps the theme state
    consistent between every route.
  prefs: []
  type: TYPE_NORMAL
- en: One important thing to remember when customizing the `_app.js` page is that
    it is not meant for running data fetching using `getServerSideProps` or `getStaticProps`,
    as other pages do. Its main use cases are maintaining state between pages during
    navigation (dark/light themes, items in a cart, and so on), adding global styles,
    handling page layouts, or adding additional data to the page props.
  prefs: []
  type: TYPE_NORMAL
- en: If, for some reason, you absolutely need to fetch data on the server side every
    time you want to render a page, you can still use the built-in `getInitialProps`
    function, but it has a cost. You'll lose automatic static optimization in dynamic
    pages, as Next.js will need to perform server-side rendering for every single
    page.
  prefs: []
  type: TYPE_NORMAL
- en: 'If that cost is acceptable for your web app, you can easily use that built-in
    method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: While a custom `_app.js` file allows us to customize the way we render page
    components, there might be cases where it cannot help; for example, when we need
    to customize HTML tags such as `<html>` or `<body>`. We will learn how to do that
    right in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The _document.js page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we're writing Next.js page components, we don't need to define fundamental
    HTML tags, such as `<head>`, `<html>`, or `<body>`. We've already seen how to
    customize the `<head>` tag using the `Head` component, but we will need a change
    of approach for both `<html>` and `<body>`tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to render those two essential tags, Next.js uses a built-in class
    called `Document`, and it allows us to extend it by creating a new file called
    `_document.js` inside our `pages/` directory, just like we do for our `_app.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break down the `_document.js` page we''ve just created. First, we start
    by importing the `Document` class, which we''re going to extend to add our custom
    scripts. We then import four mandatory components in order for our Next.js application
    to work:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Html`: The `<html>` tag for our Next.js application. We can pass any standard
    HTML property (such as `lang`) to it as a prop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Head`: We can use this component for all the tags common to all the application
    pages. This is *not* the `Head` component we''ve seen in the previous chapter.
    They behave similarly, but we should use it only for code that is common to all
    the website pages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Main`: This will be the place where Next.js renders our page components. The
    browser won''t initialize every component outside `<Main>`, so if we need to share
    common components between our pages, we should place them inside the `_app.js`
    file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NextScript`: If you''ve tried to inspect an HTML page generated by Next.js,
    you may have noticed that it adds some custom JavaScript scripts to your markup.
    Inside those scripts, we can find all the code required to run client-side logic,
    React hydration, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing any of the preceding four components will break our Next.js application,
    so make sure to import them before editing your `_document.js` page.
  prefs: []
  type: TYPE_NORMAL
- en: Just like `_app.js`, `_document.js` does not support server-side data fetching
    methods such as `getServerSideProps` and `getStaticProps`. We still get access
    to the `getInitialProps` method, but we should avoid putting data fetching functions
    inside it as this would disable automatic site optimization, forcing the server
    to server-side render the page on each request.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we've covered many important concepts that make Next.js a great
    framework to work with. We now know how to serve images correctly and with minimum
    effort, navigate between pages by pre-fetching the destination page, dynamically
    create and delete custom metadata, and create dynamic routes to make the user
    experience even more dynamic. We've also taken a look at customizing the `_app.js`
    and `_document.js` files, which will allow us to keep our user interface consistent
    between all the application pages with minimum effort.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we've always avoided calling external REST APIs, as it introduces an
    extra layer of complexity for our application. We will cover this topic in the
    next chapter, understanding how to integrate *REST* and *GraphQL* APIs on both
    the client and server sides.
  prefs: []
  type: TYPE_NORMAL
