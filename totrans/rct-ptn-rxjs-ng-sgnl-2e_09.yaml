- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Demystifying Multicasting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Multicasting** refers to sharing the same Observable execution among multiple
    subscribers. This concept can be challenging to grasp initially, especially for
    those unfamiliar with reactive programming paradigms. However, it’s very useful
    and solves many problems in web applications.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I will demystify this concept, explaining when and where to
    use it, how RxJS subjects are involved, and its advantages.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Explaining multicasting versus unicasting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring RxJS subjects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Highlighting the advantages of multicasting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter assumes that you have a basic understanding of RxJS.
  prefs: []
  type: TYPE_NORMAL
- en: All the source code in this chapter is used for demonstration purposes, so you
    don’t need access to this book’s GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining multicasting versus unicasting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get into explaining multicasting versus unicasting, let’s start by
    explaining another key concept, known as a producer, which we will be using a
    lot in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: A **producer** is the source that produces the Observable values – for example,
    DOM events, WebSockets, and HTTP requests are considered producers. It is any
    data source that’s used to get values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Observables fall into two types:'
  prefs: []
  type: TYPE_NORMAL
- en: Cold, or unicast, Observables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hot, or multicast, Observables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s understand the difference between them.
  prefs: []
  type: TYPE_NORMAL
- en: Unicasting and cold Observables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A cold Observable in RxJS is like a personal storytelling session. Imagine you’re
    sharing a story with a friend. You narrate the story right there with them, and
    it’s unique to your interaction. Each time you share the story with a different
    friend, it’s like starting a new session with a fresh narrative.
  prefs: []
  type: TYPE_NORMAL
- en: 'In RxJS terms, this means that the Observable itself generates the data it
    emits. Each time someone subscribes to the Observable, they get a private storytelling
    session. The story (or data) isn’t shared between different listeners – it’s a
    one-on-one experience. This is why we call cold Observables “unicast” – each emitted
    value is observed by only one subscriber:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Unicast cold Observable](img/B21180_09_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – Unicast cold Observable
  prefs: []
  type: TYPE_NORMAL
- en: So, by default, Observables in RxJS are cold – they create and deliver data
    to each subscriber individually, just like your personalized storytelling sessions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of a cold Observable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let’s break down what’s happening in this code.
  prefs: []
  type: TYPE_NORMAL
- en: Here, `Math.random()` is our producer – it is called inside the Observable.
    So, data is produced by the Observable itself.
  prefs: []
  type: TYPE_NORMAL
- en: The first ubscriber will get two random values after the subscription, and the
    second subscriber will get two different values after the subscription. Every
    subscriber starts a new execution, leading to a new invocation of `Math.random()`,
    which results in distinct values.
  prefs: []
  type: TYPE_NORMAL
- en: Each subscriber gets its own unique set of items. It begins to emit items only
    after the observer subscribes to it. Since there are two different executions,
    every Observable will receive a different value. This means that data is unicast
    and not shared among the subscribers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Briefly looking at a real-world example, when a user logs into an application,
    their personal profile or dashboard information is fetched and displayed. This
    data is unique to each user and should not be shared across multiple users. Using
    a cold Observable ensures that each user receives personalized data upon logging
    in, maintaining privacy and security. So, to summarize, for cold Observables,
    the following applies:'
  prefs: []
  type: TYPE_NORMAL
- en: The Observable itself generates the data it emits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It starts to emit data only after the observer subscribes to it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each observer (or subscriber) gets its own unique set of items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s look at hot Observables.
  prefs: []
  type: TYPE_NORMAL
- en: Multicasting and hot Observables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Multicasting in RxJS is like hosting a live radio show. Imagine you’re broadcasting
    a show from a studio, and listeners can tune in at any time to hear the same content.
    Once you start broadcasting, anyone who tunes in can hear the same music, interviews,
    or discussions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In RxJS terms, a hot or multicast Observable is an Observable whose emitted
    values are shared among subscribers. There’s a single source of data, just like
    the radio station broadcasting content. When you subscribe to a multicasting Observable,
    you’re joining the “broadcast,” and you’ll receive the same data as anyone else
    who’s tuned in:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Multicast hot Observable](img/B21180_09_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Multicast hot Observable
  prefs: []
  type: TYPE_NORMAL
- en: Unlike cold Observables, where each subscriber gets a private session, multicasting
    allows multiple subscribers to listen to the same stream of data simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of a hot Observable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Let’s break down what’s happening in this code.
  prefs: []
  type: TYPE_NORMAL
- en: We created an Observable using the `fromEvent` function of RxJS. This Observable
    will emit clicks happening on the DOM document when subscribing to.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more details about `fromEvent`, please refer to [https://rxjs.dev/api/index/function/fromEvent](https://rxjs.dev/api/index/function/fromEvent).
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the data is emitted outside the Observable and, as you may have
    guessed, both subscribers will get the same data. This means that the subscribers
    share the same instance of the DOM click event. So, the hot Observable shares
    data between multiple subscribers. We call this behavior multicasting. In other
    words, the Observable multicasts to all subscribers.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at another real-world scenario, consider a chat application where you
    might have a global chat service that exposes a hot Observable representing the
    stream of incoming messages from all users in the chat room. Multiple components,
    such as message feeds and notifications, can subscribe to this hot Observable
    to display new messages in real-time without needing to create separate Observables
    for each component.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to summarize, for hot Observables, the following applies:'
  prefs: []
  type: TYPE_NORMAL
- en: Data is produced outside the Observable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It may begin emitting items as soon as it is created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The emitted items are shared between the subscribers (multicasting)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transforming cold Observables into hot Observables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we want to transform the cold Observable into a hot one, we have to move
    the producer outside the Observable – this way, our subscribers will receive the
    same data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s revisit our example with the cold Observable. Instead of generating values
    within the Observable, we’ll pre-calculate the value by using `Math.random()`
    outside the Observable, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you may have noticed, after executing this code, all subscribers receive
    the same pre-calculated value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, before we wrap up this section, let’s just quickly summarize unicasting
    and multicasting:'
  prefs: []
  type: TYPE_NORMAL
- en: You should use *unicasting* when you want each subscriber to own independent
    executions and separate data streams for each subscriber.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, you should use *multicasting* when you want to make sure
    multiple subscribers share the same execution and results, particularly in scenarios
    involving hot Observables, broadcasting, or caching results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multicasting also helps optimize and improve performance when executing data
    is expensive. As a quick final example, suppose that the Observable’s execution
    is issuing a network request. If we choose a cold Observable (or unicasting),
    then a network request will be raised for every subscriber. Instead, multicasting
    is a better fit for this particular scenario as it will share the execution of
    the network requests among subscribers and consequently avoid redundant request
    calls.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we understand multicasting and hot Observables, let’s explore the most
    popular ways to multicast values to observers in RxJS, namely RxJS subjects.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring RxJS subjects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Subjects** are special types of Observables. While plain Observables are
    unicast, subjects are multicast, allowing values to be broadcast to all subscribers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can consider subjects as observers and Observables at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can subscribe to subjects to get values emitted by the producer (that’s
    why they act as Observables):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.3 – An RxJS subject](img/B21180_09_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – An RxJS subject
  prefs: []
  type: TYPE_NORMAL
- en: 'You can send values, errors, and completes by using the `next`, `error`, and
    `complete` methods that are available in the `Observer` interface (that’s why
    they act as observers):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In short, a subject maintains a list of subscribers and notifies them when a
    new value is emitted. But to go a bit deeper, there are multiple types of subjects
    in RxJS. Let’s explore the most used ones.
  prefs: []
  type: TYPE_NORMAL
- en: A plain subject
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`plainSubject` is the parent type of all subjects. Let’s see a quick example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we created `plainSubject$`, which emitted `10` and `20`
    as values. Afterward, we created two subscribers that logged the incoming values,
    the errors, and the completion of the stream. Finally, `plainSubject$` emitted
    a value of `30`.
  prefs: []
  type: TYPE_NORMAL
- en: After executing this code, notice that only `30` is traced twice in the console.
    This means that the subscribers only received `30`. Why have they not received
    `10` and `20`? Because those values were emitted before the subscription to `plainSubject$`
    and every emission that occurs before the subscription will get lost. This is
    how a regular subject multicasts values.
  prefs: []
  type: TYPE_NORMAL
- en: And that’s how plain subjects behave and emit values.
  prefs: []
  type: TYPE_NORMAL
- en: You can use subjects as a communication hub in your web application to share
    data between different Angular components, as we explored in [*Chapter 7*](B21180_07.xhtml#_idTextAnchor107),
    *Sharing Data between* *Angular Components*.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, subjects can be used to manage the authentication state in a web application.
    For instance, you can use a subject to emit a value whenever the user logs in
    or logs out. This emitted value can then be used to conditionally display certain
    components or trigger specific behaviors based on the user’s authentication status.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to keep a buffer of previous values emitted to subscribers coming
    late to the game, then `ReplaySubject` can help!
  prefs: []
  type: TYPE_NORMAL
- en: replaySubject
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`replaySubject` is a subject variant, similar to `plainSubject`, but with an
    in-memory feature: they remember and replay previous messages to new subscribers.
    Replay subjects have a memory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explain how it works by exploring the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, all the values were replayed to the new subscribers. Now, to
    control the buffer size (the number of values you want the `Replay` subject to
    store), you can pass it as a parameter when creating `ReplaySubject`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This will only replay the last two values. The console output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As a real-world use case, let’s consider a chat application where a user joins
    the chat room late. With `ReplaySubject`, they can still see previous messages
    that were sent before they joined. This is useful for providing a complete chat
    history to new users.
  prefs: []
  type: TYPE_NORMAL
- en: With that, let’s move on to the other variant of `Subject` – `BehaviorSubject`.
  prefs: []
  type: TYPE_NORMAL
- en: BehaviorSubject
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`BehaviorSubject` is just `ReplaySubject` with a buffer size equal to one,
    so it can only replay only previous item. We used `BehaviorSubject` in [*Chapter
    5*](B21180_05.xhtml#_idTextAnchor083), *Combining Streams*.'
  prefs: []
  type: TYPE_NORMAL
- en: '`BehaviorSubject` requires an initial value and always retains the last value
    so that it can emit it to new subscribers. In other words, if you have any subscribers
    coming late to the game, they will get the previous value that was emitted by
    the stream. This will always give you value when you subscribe.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, `behaviourSubject$` is created and has an initial value of `1`. Then,
    `behaviourSubject` emitted `10`, `20`, and `50`, respectively. Right after we
    subscribed two times to `behaviourSubject$`, both subscribers will immediately
    receive the last value emitted by `behaviourSubject$`, which is `50` – that’s
    why `50` is traced two times in the console. Finally, `behaviourSubject$` emitted
    `30`; consequently, the subscribers will receive `30` and trace it.
  prefs: []
  type: TYPE_NORMAL
- en: 'If no values were emitted before the subscription, then `behaviourSubject$`
    will emit the initial value, which is `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As another example, imagine that you’re building a weather app that displays
    the current temperature. You can use `BehaviorSubject` to represent the temperature
    data. Whenever the temperature changes, you update `BehaviorSubject` with the
    new value. Subscribers to `BehaviorSubject` will always receive the latest temperature,
    even if they start using the app after the temperature has changed multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, `PlainSubject`, `BehaviorSubject`, and `ReplaySubject` are the
    most used subjects in RxJS, which is why we discussed them here. However, there
    are other types of subjects, such as `WebSocketSubject`, which are used much less
    (though we will explore that one more in [*Chapter 12*](B21180_12.xhtml#_idTextAnchor180),
    *Processing Real-Time Updates*). For details about the other types, refer to [https://rxjs.dev/guide/subject](https://rxjs.dev/guide/subject).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also many useful RxJS operators for multicasting (or sharing values/executions)
    in RxJS 6, namely `multicast`, `publish`, `share`, `shareReplay`, `publishReplay`,
    `publishLast`, and `refcount`. For more details about these operators, you can
    check the official docs: [https://rxjs.dev/api/operators](https://rxjs.dev/api/operators).'
  prefs: []
  type: TYPE_NORMAL
- en: In version 7, multicasting operators were consolidated to `share`, `connectable`,
    and `connect`. The other multicasting APIs are now deprecated and will be deleted
    in RxJS 8\. The only operator that wasn’t deprecated is `shareReplay` because
    it is very popular. It is now a wrapper around the highly configurable `share`
    operator.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are using RxJS 7 in this book, I think it is useless to go through
    all the deprecated operators. Instead, we focus on the `share` operator as it
    satisfies most cases. We will learn the behavior of the `share` operator by considering
    a real-world use case in the next chapter, [*Chapter 10*](B21180_10.xhtml#_idTextAnchor159),
    *Boosting Performance with* *Reactive Caching*.
  prefs: []
  type: TYPE_NORMAL
- en: For details about RxJS 7 multicasting operators, refer to [https://rxjs.dev/deprecations/multicasting](https://rxjs.dev/deprecations/multicasting).
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a good understanding of multicasting and the different ways
    of implementation provided by RxJS, let’s explore the main advantages of multicasting.
  prefs: []
  type: TYPE_NORMAL
- en: Highlighting the advantages of multicasting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Multicasting in RxJS or having the ability to share the same Observable execution
    among multiple subscribers has many advantages. Here are some key ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Optimizing resources*: Multicasting helps optimize resources by avoiding redundant
    treatments. When dealing with expensive operations such as raising HTTP networks
    or performing complex computations, multicasting helps you do the work once and
    share the results among all subscribers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Consistent data and results*: Multicasting ensures that all subscribers receive
    the same set of values emitted by the Observable. This can be crucial in scenarios
    where consistency in data is essential, and you want all subscribers to observe
    the same data sequence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Broadcasting*: Multicasting gives you the possibility to send, once and for
    all, the same set of values to multiple subscribers at the same time. This is
    what we call broadcast, and it is beneficial when you have a complex application
    with multiple components that need to react to the same set of values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Late subscribers*: Multicasting allows late subscribers to receive the same
    values as subscribers who joined earlier. This is achieved by using `BehaviorSubject`
    and `ReplaySubject`, plus some multicast RxJS operators such as the `shareReplay`
    operator, something we will explain in [*Chapter 10*](B21180_10.xhtml#_idTextAnchor159),
    *Boosting Performance with* *Reactive Caching*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When designing applications with RxJS, multicasting is a powerful mechanism
    that should be put on the table because it enhances performance, efficiency, consistency,
    and interaction between the different parts of your app. However, it’s essential
    to use multicasting carefully and be aware of potential pitfalls, depending on
    your specific use case. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Data alteration*: Multicasting inherently shares the same data stream across
    all subscribers. If a subscriber modifies the data within its subscription logic
    (for example, using operators such as `map` or `filter`), this modification can
    unintentionally affect what other subscribers receive. This can lead to unexpected
    behavior and debugging challenges.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, imagine a multicast Observable emitting a list of products. A component
    subscribes and filters the list to only show products with discounts. However,
    this filtering modifies the original data stream. If another component later subscribes,
    expecting the complete product list, it will only receive the discounted products
    due to the unintended modification in the first subscription. That’s why keeping
    the subject private and exposing only the read-only part of the data through the
    `asObservable()` method is a common and effective practice. This ensures that
    external components or consumers cannot directly modify the internal state of
    the subject. Instead, they can only observe the emitted values without interfering
    with the data stream.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Memory leaks*: Unlike unicast Observables, which complete after a single subscriber
    unsubscribes, multicasting continues emitting data so long as at least one subscriber
    remains. This can lead to memory leaks if you’re not careful about managing subscriptions,
    especially when dealing with infinite or long-lived Observables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, imagine a multicast Observable that emits real-time stock prices.
    If components subscribe to this Observable but don’t unsubscribe when they are
    no longer needed, the Observable will continue emitting, potentially causing memory
    leaks as references to the Observable and its internal state accumulate.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We will explore other multicasting pitfalls and best practices in the next chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, I walked you through the most important concepts and vocabulary
    to understand multicasting. We started by explaining the role of a producer, after
    which we learned the difference between cold and hot Observables, leading us to
    the definition of multicasting and unicasting. Then, we explored RxJS subjects,
    the different types of subjects, and the use cases of each before introducing
    multicasting operators in RxJS.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll practice all of this in a real-world use case. We
    will learn how to put an efficient mechanism of caching in place in our Recipe
    app by using multicasting in RxJS and, more specifically, by combining multicasting
    operators and subjects.
  prefs: []
  type: TYPE_NORMAL
