- en: '*Chapter 11*: Creating Authenticated Experiences'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第11章*：创建认证体验'
- en: Within the context of this book, **authentication** is the act of verifying
    that a user is who they say they are within a website. Once their identity has
    been verified, we can show the individual content that's only meant for them.
    This might be their profile page, delivery address, bank details, and more. In
    this chapter, we're going to focus more on how to implement routing for use with
    authentication services instead of focusing on how to implement authentication
    services or what content to display when a user is authenticated. We will remind
    ourselves of how this is done in traditional React applications before applying
    this knowledge to Gatsby sites with two different client-side implementations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的上下文中，**认证**是指验证用户在网站中是否是他们所说的那个人。一旦他们的身份得到验证，我们就可以展示只有他们才能看到的内容。这可能包括他们的个人资料页面、送货地址、银行详情等等。在本章中，我们将更多地关注如何实现用于认证服务的路由，而不是关注如何实现认证服务或用户认证时显示什么内容。在将此知识应用于具有两种不同客户端实现的Gatsby站点之前，我们将回顾一下在传统React应用程序中是如何做到这一点的。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Routing and authentication in React applications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React应用程序中的路由和认证
- en: Authentication using client-only routes within Gatsby
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Gatsby中使用客户端路由进行认证
- en: Site-wide authentication using context within Gatsby
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Gatsby中使用上下文进行全局认证
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To complete this chapter, you will need to have completed [*Chapter 10*](B15983_10_ePub_RK.xhtml#_idTextAnchor141),
    *Creating Gatsby Plugins*. You will also need a GitHub account.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章，你需要完成[*第10章*](B15983_10_ePub_RK.xhtml#_idTextAnchor141)，*创建Gatsby插件*。你还需要一个GitHub账户。
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter11](https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter11).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在[https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter11](https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter11)找到。
- en: Routing and authentication in React applications
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React应用程序中的路由和认证
- en: To achieve authenticated experiences, we will be using **routing**. Before jumping
    into how we do this in Gatsby, let's familiarize ourselves with how routing works
    within React applications. Routing is the process of navigating a user around
    different parts of an application.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现认证体验，我们将使用**路由**。在我们深入探讨如何在Gatsby中实现路由之前，让我们先熟悉一下React应用程序中的路由工作原理。路由是用户在应用程序的不同部分之间导航的过程。
- en: For this example, I will be bootstrapping a React project using `create-react-app`.
    I have included steps for its installation but feel free to skip them and use
    your own React implementation. *Keep this section's demo separate from your Gatsby
    project*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我将使用`create-react-app`启动一个React项目。我已经包括了其安装步骤，但你可以选择跳过它们并使用你自己的React实现。*请将本节的示例与你的Gatsby项目分开*。
- en: Important Note
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In the following example, we will be using the `@reach/router` package for routing.
    Gatsby uses `@reach/router` under the hood, so by using the package here in React,
    it will be easy to recognize patterns when we move on to implementing them in
    Gatsby.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将使用`@reach/router`包进行路由。Gatsby底层使用`@reach/router`，因此在我们转向在Gatsby中实现它们时，使用这个包在React中会很容易识别模式。
- en: 'As React developers, routing is a common part of building applications – let''s
    remind ourselves of the routing basics:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 作为React开发者，路由是构建应用程序的常见部分——让我们回顾一下路由基础知识：
- en: 'Create a new folder for this demo. Open a terminal within this new folder and
    run the following command:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此示例创建一个新的文件夹。在这个新文件夹中打开一个终端，并运行以下命令：
- en: '[PRE0]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the same terminal, run the following command:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个终端中，运行以下命令：
- en: '[PRE1]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Open `src/App.js` and replace it with the following code:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`src/App.js`，将其替换为以下代码：
- en: '[PRE2]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we have imported `Router` and `Link` from the `@reach/router` package.
    We have also created a `Nav` component that we can use to access the routes. This
    `Nav` component utilizes the `Link` component from `@reach/router` to provide
    navigation between routes.
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们已从`@reach/router`包中导入了`Router`和`Link`。我们还创建了一个`Nav`组件，我们可以用它来访问路由。这个`Nav`组件利用了`@reach/router`中的`Link`组件来提供路由间的导航。
- en: 'Append `src/App.js` with the following code:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`src/App.js`中：
- en: '[PRE3]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we have defined a couple of dummy components to route between – a `home`
    page and an `about` page. This should all be very familiar to you.
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一些用于路由之间的虚拟组件——一个“主页”和一个“关于”页面。所有这些都应该对你来说非常熟悉。
- en: 'Finally, append `src/App.js` with the following code:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将以下代码添加到`src/App.js`中：
- en: '[PRE4]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is where the magic happens. By wrapping the components in a `Router` component,
    we can switch out which component is displayed based on the current URL path.
    In this instance, if the user is at the `/` path (the route URL) they will see
    the `HomePage` component, while if `path` is `/about`, they will see the `AboutPage`
    component. They can use the `Nav` component within these two pages to navigate
    between the two of them.
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这就是魔法发生的地方。通过将组件包裹在`Router`组件中，我们可以根据当前的URL路径切换显示哪个组件。在这个例子中，如果用户位于`/`路径（路由URL），他们将看到`HomePage`组件，而如果`path`是`/about`，他们将看到`AboutPage`组件。他们可以使用这两个页面中的`Nav`组件在它们之间导航。
- en: Start the project by running `npm start` from the root directory to try it out.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在根目录下运行`npm start`来启动项目以尝试它。
- en: It's important to remember that navigating between routes is fast because all
    the routes are loaded when the router renders. As we move into Gatsby, it's important
    to make sure we only use routers when it is necessary as we might be adding page
    weight to include components that a user may never have any intention of seeing.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，在路由之间导航是快速的，因为所有路由都是在路由器渲染时加载的。当我们进入Gatsby时，确保我们只在必要时使用路由器非常重要，因为我们可能会添加页面重量来包含用户可能永远不会看到的组件。
- en: Now that we have gone through a basic routing example, let's start adding pages
    that can only be accessed once a user has logged in. We will do this with **private
    routes**.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经通过一个基本的路由示例，接下来让我们开始添加只有用户登录后才能访问的页面。我们将通过**私有路由**来实现这一点。
- en: Private routes
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 私有路由
- en: 'A private route behaves the same as the other components that are wrapped in
    a `Router`, except it has an authentication condition. If the condition is not
    satisfied, instead of seeing the requested content, the user will be redirected
    to a login screen to authenticate. Let''s try this out now by turning our about
    page that was previously public into a private route:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 私有路由的行为与其他被`Router`包裹的组件相同，除了它有一个认证条件。如果条件不满足，用户将不会看到请求的内容，而是会被重定向到登录屏幕进行认证。现在让我们通过将之前公开的关于页面转换为私有路由来尝试一下：
- en: 'First, we are going to need to define our authentication condition. For this
    example, we are going to keep it simple. To be considered "authenticated," the
    user must have called the `login` function, which we will trigger via a button
    on the login page. To achieve this condition, we are going to create a context
    that can store the current authentication state. Create a new file called `auth-context.js`
    and add the following code:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要定义我们的认证条件。在这个例子中，我们将保持简单。要被认为是“认证的”，用户必须已经调用了`login`函数，我们将通过登录页面上的按钮来触发它。为了实现这个条件，我们将创建一个可以存储当前认证状态的上下文。创建一个名为`auth-context.js`的新文件，并添加以下代码：
- en: '[PRE5]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we are setting up the boilerplate of our authorization context. We are
    creating a `useAuth` hook to access the context values that we will be defining
    in the next step.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们正在设置我们的授权上下文的模板。我们正在创建一个`useAuth`钩子来访问我们将在下一步定义的上下文值。
- en: 'Within the `auth-context.js` file''s `AuthProvider`, add the following code:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`auth-context.js`文件中的`AuthProvider`中添加以下代码：
- en: '[PRE6]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we have created a `useState` value called `authenticated` to track whether
    the user is authenticated or not. We then created a `login` function that sets
    `authenticated` to `true`. It is within this function that you would make a request
    to your authentication service and verify the user before authenticating. Most
    likely, you will also have some information about the user that you could store
    in your state or local storage. If you do add additional information, be sure
    to clear it within the `logout` function. For the time being, the `logout` function
    just sets `authenticated` to `false` and navigates a user back to the login page.
    Within `AuthContext.Provider`, we expose the `login` and `logout` functions, as
    well as the `authenticated` state, to the rest of the application.
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为 `authenticated` 的 `useState` 值来跟踪用户是否已认证。然后我们创建了一个将 `authenticated`
    设置为 `true` 的 `login` 函数。在这个函数中，你会向你的认证服务发送请求并验证用户，然后进行认证。很可能会也有一些关于用户的信息可以存储在你的状态或本地存储中。如果你添加了额外的信息，确保在
    `logout` 函数中清除它。目前，`logout` 函数只是将 `authenticated` 设置为 `false` 并将用户导航回登录页面。在 `AuthContext.Provider`
    中，我们暴露了 `login` 和 `logout` 函数，以及 `authenticated` 状态，给应用程序的其他部分。
- en: 'Navigate to your React application''s `index.js` file and modify it with the
    following code:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到你的 React 应用程序的 `index.js` 文件，并使用以下代码进行修改：
- en: '[PRE7]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Our authentication condition is now defined, so we can utilize it to create
    a private route component. Create a new file called `PrivateRoute.js` and add
    the following code:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的认证条件现在已经定义，因此我们可以利用它来创建一个私有路由组件。创建一个名为 `PrivateRoute.js` 的新文件，并添加以下代码：
- en: '[PRE8]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This `PrivateRoute` component uses the `authenticated` state from the `useAuth`
    hook to conditionally render a given component. If the user is authenticated,
    the component will be rendered. If, however, they are not authenticated, the user
    will be navigated to the `login` route instead.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个 `PrivateRoute` 组件使用 `useAuth` 钩子中的 `authenticated` 状态来有条件地渲染一个给定的组件。如果用户已认证，该组件将被渲染。然而，如果他们未认证，用户将被导航到
    `login` 路由。
- en: 'Return to your `App.js` file and update the file with the following imports:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回你的 `App.js` 文件并更新文件，以下为导入：
- en: '[PRE9]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we are importing the `useAuth` hook and our newly created `PrivateRoute`
    component.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们正在导入 `useAuth` 钩子和我们新创建的 `PrivateRoute` 组件。
- en: 'Modify the `HomePage` component with the following code:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码修改 `HomePage` 组件：
- en: '[PRE10]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Modify the `AboutPage` component with the following code:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码修改 `AboutPage` 组件：
- en: '[PRE11]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is the path we intend to make private in this demo. If a user is on this
    page, we can assume they have been authenticated and render a logout button to
    allow them to trigger the `logout` function.
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是我们在本演示中打算使其私有的路径。如果一个用户在这个页面上，我们可以假设他们已经认证，并渲染一个注销按钮，允许他们触发 `logout` 函数。
- en: 'Add a `LoginPage` component to `App.js`:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `LoginPage` 组件添加到 `App.js` 中：
- en: '[PRE12]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is a basic implementation that uses the `login` function from `useAuth`
    to log a user in. In your application, you would probably want to flesh this out
    with inputs where users enter their email and password. You would then pass this
    to the `login` function so that it can be used as part of the authorization request.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个基本的实现，它使用 `useAuth` 中的 `login` 函数来登录用户。在你的应用程序中，你可能希望用用户输入电子邮件和密码的输入字段来完善它。然后你将传递这些信息给
    `login` 函数，以便它可以用作授权请求的一部分。
- en: 'Finally, update your `App` function so that it includes your `PrivateRoute`
    component:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，更新你的 `App` 函数，使其包括你的 `PrivateRoute` 组件：
- en: '[PRE13]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Start the project by running `npm start` from the root directory. If you try
    to navigate to `/about`, you will notice that you will be redirected to `/login`
    until you have clicked the login button.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在根目录下运行 `npm start` 来启动项目。如果你尝试导航到 `/about`，你会注意到你将被重定向到 `/login`，直到你点击了登录按钮。
- en: We now have a firm grasp on routing and private routes, so let's take the knowledge
    we have gained in this section and apply it to Gatsby.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在对路由和私有路由有了牢固的掌握，所以让我们将本节中获得的知识应用到 Gatsby 上。
- en: Authentication using client-only routes within Gatsby
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Gatsby 中使用仅客户端路由进行身份验证
- en: 'While not common practice, we can use routers inside Gatsby pages too. Normally,
    Gatsby abstracts all the routing away so that we don''t have to worry about it,
    but authentication is one example where we need to bring the control over routing
    back into our hands. We will be creating what is known as client-only routes.
    To demonstrate this within our project, we are going to create a page at `/private`.
    As its name might suggest, this path contains a private page that we will lock
    behind authentication. Let''s get started:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这不是常见的做法，但我们也可以在Gatsby页面中使用路由器。通常，Gatsby会将所有路由抽象化，这样我们就不必担心它，但身份验证是我们需要将路由控制权重新掌握在我们手中的一个例子。我们将创建所谓的客户端路由。为了在我们的项目中演示这一点，我们将在`/private`创建一个页面。正如其名称可能暗示的那样，此路径包含一个受保护的页面，我们将通过身份验证来锁定它。让我们开始吧：
- en: Important Note
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: This example will conflict with the *Site-wide authentication using context
    within Gatsby* section's code. It's best to choose one of these two methods to
    implement instead of trying to combine them.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例将与“在Gatsby中使用上下文进行全局身份验证”部分的代码发生冲突。最好选择这两种方法中的一种来实现，而不是尝试将它们结合起来。
- en: Create a new folder inside `src` called `context`.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src`目录内创建一个名为`context`的新文件夹。
- en: 'Create a new file called `auth-context.js` and add the following code:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`auth-context.js`的新文件，并添加以下代码：
- en: '[PRE14]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we are setting up an authentication context in the same way we did within
    the example code from the *Routing and authentication in React applications* section.
    Note that we are still importing `navigate` from `@reach/router` instead of the
    Gatsby library.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们正在以与“React应用程序中的路由和身份验证”示例代码中相同的方式设置身份验证上下文。请注意，我们仍然从`@reach/router`导入`navigate`，而不是从Gatsby库中导入。
- en: 'Add the following within `AuthProvider`:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AuthProvider`中添加以下内容：
- en: '[PRE15]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We set up this `auth-context.js` file in the same way we did with the React
    demo, except this time, we navigate to `/private` on a successful login.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们以与React演示相同的方式设置了`auth-context.js`文件，但这次我们在登录成功后导航到`/private`。
- en: Important Note
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: Within this section, you will see code that looks very similar to the React
    demo from the previous section. Please note that while they are similar, they
    are not the same. Don't be tempted to copy and paste them from the React example.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在本节中，您将看到与上一节中的React演示代码非常相似的代码。请注意，尽管它们很相似，但它们并不相同。不要被诱惑从React示例中复制粘贴它们。
- en: 'Add the following to your `gatsby-browser.js` and `gatsby-ssr.js` files:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到你的`gatsby-browser.js`和`gatsby-ssr.js`文件中：
- en: '[PRE16]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We want to ensure that the authentication context is available throughout the
    application. By adding the preceding code to both `gatsby-browser.js` and `gatsby-ssr.js`,
    we can be sure it is accessible everywhere.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们希望确保身份验证上下文在整个应用程序中可用。通过在`gatsby-browser.js`和`gatsby-ssr.js`中添加前面的代码，我们可以确保它可以在任何地方访问。
- en: Create a new file within `src/components` called `PrivateRoute.js`.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/components`目录内创建一个名为`PrivateRoute.js`的新文件。
- en: 'Add the following code to the newly created `PrivateRoute.js`:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到新创建的`PrivateRoute.js`文件中：
- en: '[PRE17]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is a Gatsby-friendly implementation of the `PrivateRoute` component. Note
    that we are switching out the `@reach/router` part of `navigate` for Gatsby's
    implementation. This is because Gatsby's implementation will handle the redirect
    in a way that is suitable for a Gatsby project. Without this switch, you will
    be presented with a white screen when `navigate` is called. You will also notice
    that we are passing in a prop called `basepath`. As our router will not sit at
    the top of the application, the `PrivateRoute` component must know the router's
    base path location to ensure it navigates the respective users to it.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是`PrivateRoute`组件的Gatsby友好实现。请注意，我们正在将`navigate`中的`@reach/router`部分替换为Gatsby的实现。这是因为Gatsby的实现将以适合Gatsby项目的方式处理重定向。如果不进行此替换，当调用`navigate`时，您将看到一个空白屏幕。您还会注意到我们传递了一个名为`basepath`的属性。因为我们的路由器不会位于应用程序的顶部，所以`PrivateRoute`组件必须知道路由器的基路径位置，以确保将相应的用户导航到那里。
- en: Create a new folder inside `src/pages` called `private`.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/pages`目录内创建一个名为`private`的新文件夹。
- en: Inside this new folder, create a new file called `[...].js`. Using Gatsby's
    `/private`. This step is vitally important as Gatsby does not know the router
    we will set up, so it needs to understand that if it sees a path beginning with
    `/private`, such as `/private/login`, it needs to be handled by this file instead
    of erroring out with a 404 status code.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个新文件夹中，创建一个名为 `[...].js` 的新文件。使用 Gatsby 的 `/private`。这一步至关重要，因为 Gatsby 不了解我们将设置的路由器，因此它需要理解如果它看到以
    `/private` 开头的路径，例如 `/private/login`，它需要由这个文件处理，而不是以 404 状态码报错。
- en: 'Add the following code to `src/pages/private/[...].js`:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `src/pages/private/[...].js` 文件中：
- en: '[PRE18]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we are defining the two possible paths that will be visible. Either you
    will be shown `AuthenticatedPage` or, if you are not logged in, you will see the
    login page. These components both make use of the `useAuth` hook to retrieve the
    functions they require.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们定义了两个可能可见的路径。要么你会看到 `AuthenticatedPage`，要么如果你没有登录，你会看到登录页面。这两个组件都使用了 `useAuth`
    钩子来检索它们所需的函数。
- en: 'Append the following code to `src/pages/private/[...].js`:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `src/pages/private/[...].js` 文件中：
- en: '[PRE19]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Within this step, we have defined our `basepath` – this must match the Gatsby
    page's path (which, in this instance, is `/private`). We pass this value as a
    prop both to `Router` and `PrivateRoute`. This example is different from the React
    example in that the base path is the path that requires authentication.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一步中，我们定义了我们的 `basepath` —— 这必须与 Gatsby 页面的路径匹配（在这个例子中是 `/private`）。我们将此值作为属性传递给
    `Router` 和 `PrivateRoute`。这个例子与 React 例子不同，因为基本路径是需要认证的路径。
- en: Start the project by running `npm start` from the root directory. If you try
    to navigate to `/private`, you will notice that you are redirected to `/private/login`,
    and clicking the login button will redirect you to `/private`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在根目录中运行 `npm start` 来启动项目。如果你尝试导航到 `/private`，你会注意到你被重定向到 `/private/login`，点击登录按钮将重定向你到
    `/private`。
- en: With that, we've learned how to add routing within a particular section of our
    Gatsby site. Now, let's turn our attention to an implementation that you can use
    when your whole site requires authentication.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们已经学会了如何在 Gatsby 网站的一个特定部分中添加路由。现在，让我们将注意力转向一个当你整个网站需要认证时可以使用的实现。
- en: Site-wide authentication using context within Gatsby
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Gatsby 中使用上下文实现网站范围的认证
- en: 'There may be situations where you want the entirety of your Gatsby site to
    be behind authentication. For example, you may have made a documentation site
    only meant for employees of your company. Let''s look at how we can use context
    to turn every page into a private route:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有这样的情况，你希望你的整个 Gatsby 网站都在认证之后。例如，你可能只为你公司的员工创建了文档网站。让我们看看我们如何使用上下文将每个页面都转换为私有路由：
- en: 'First, let''s create a login component in the `components` folder. Call this
    file `Login.js` and add the following code to it:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们在 `components` 文件夹中创建一个登录组件。将此文件命名为 `Login.js` 并添加以下代码：
- en: '[PRE20]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You'll notice that, unlike the last `Login` component we created, we are not
    retrieving the `login` function from the context. The reason for this will become
    clear when we create the context.
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你会注意到，与之前我们创建的 `Login` 组件不同，我们不是从上下文中检索 `login` 函数。这个原因将在我们创建上下文时变得清晰。
- en: Create a folder called `context` in `src`.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src` 中创建一个名为 `context` 的文件夹。
- en: 'Create a file in `context` called `auth-context.js` and add the following code:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `context` 文件夹中创建一个名为 `auth-context.js` 的文件并添加以下代码：
- en: '[PRE21]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Add the following code within `AuthProvider`:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `AuthProvider` 中添加以下代码：
- en: '[PRE22]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add the following to your `gatsby-browser.js` and `gatsby-ssr.js` files:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到你的 `gatsby-browser.js` 和 `gatsby-ssr.js` 文件中：
- en: '[PRE23]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We want to ensure that the authentication context is available throughout the
    application. By adding this file to both `gatsby-browser.js` and `gatsby-ssr.js`,
    we can ensure it is accessible everywhere.
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们希望确保认证上下文在应用程序的任何地方都是可用的。通过将此文件添加到 `gatsby-browser.js` 和 `gatsby-ssr.js`，我们可以确保它在任何地方都可以访问。
- en: Start the project by running `npm start` from the root directory and navigate
    to any page on the site. You should find that you are prompted to log in before
    being able to view the page.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在根目录中运行 `npm start` 并导航到网站上的任何页面来启动项目。你应该会发现你需要在查看页面之前被提示登录。
- en: Now that we have looked at two different ways to achieve authenticated experiences
    within Gatsby applications, let's summarize what we have learned.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了两种在 Gatsby 应用程序中实现认证体验的方法，让我们总结一下我们学到了什么。
- en: Summary
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored routing and authenticated experiences. We reminded
    ourselves of how routing works in React and created private routes for use with
    `@reach/router`. Then, we ported this knowledge into Gatsby and created a private
    page that was only accessible by logging in. Finally, we investigated how we can
    use context to wrap our whole application in authentication for situations that
    require it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了路由和认证体验。我们回顾了React中的路由工作原理，并为`@reach/router`创建了私有路由。然后，我们将这些知识应用到Gatsby中，创建了一个只有通过登录才能访问的私有页面。最后，我们研究了如何使用上下文来为需要认证的情况将整个应用程序包裹在认证中。
- en: In the next chapter, we will learn about another advanced concept – how to use
    sockets to create experiences that make use of real-time data.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习另一个高级概念——如何使用套接字来创建利用实时数据的体验。
