<html><head></head><body>
		<div id="_idContainer015" class="calibre2">
			<h1 id="_idParaDest-30" class="chapter-number"><a id="_idTextAnchor029" class="pcalibre1 calibre6 pcalibre"/>2</h1>
			<h1 id="_idParaDest-31" class="calibre7"><a id="_idTextAnchor030" class="pcalibre1 calibre6 pcalibre"/>Key Principles and Components of Microfrontends</h1>
			<p class="calibre3">Microfrontends<a id="_idIndexMarker041" class="pcalibre1 calibre6 pcalibre"/> are a double-edged sword. When done right, they can bring a great amount of joy and productivity to teams; however, if not implemented the right way, they can make things <span>way worse.</span></p>
			<p class="calibre3">Having said that, there are a couple of key principles and considerations we need to keep in mind when building a <span>microfrontend architecture.</span></p>
			<p class="calibre3">In this chapter, we will look at the key design principles of a microfrontend architecture and why it is important to treat them as sacrosanct. The reason we emphasize these principles is that they lay the foundation of the microfrontend architecture. Teams may not be able to extract all the benefits of a microfrontend pattern if they choose to ignore these principles. Then, we will look at the key components that are critical to any <span>microfrontend architecture.</span></p>
			<p class="calibre3">In this chapter, we will cover the <span>following topics:</span></p>
			<ul class="calibre15">
				<li class="calibre14">Understanding the <span>Key Principles</span></li>
				<li class="calibre14">The key Components of a <span>Microfrontend Architecture</span></li>
			</ul>
			<p class="calibre3">By the end of this chapter, you will have a better understanding of the guiding principles and key considerations that teams need to keep in mind when designing a <span>microfrontend architecture.</span></p>
			<h1 id="_idParaDest-32" class="calibre7"><a id="_idTextAnchor031" class="pcalibre1 calibre6 pcalibre"/>Understanding the Key Principles</h1>
			<p class="calibre3">It’s important that<a id="_idIndexMarker042" class="pcalibre1 calibre6 pcalibre"/> all software teams lay down a set of rules and guiding principles that all team members and the code they write adhere to. This ensures that when teams discuss certain technical approaches, they can validate them against these guidelines. This, in turn, ensures that the teams can focus on the outcomes by mapping them against these key guidelines and not get too obsessed with the nuances of the process. This helps teams to arrive at decisions a <span>lot faster.</span></p>
			<p class="calibre3">In the following sections, we will look at the key principles that teams must adhere to when following a <span>microfrontend pattern.</span></p>
			<h2 id="_idParaDest-33" class="calibre5"><a id="_idTextAnchor032" class="pcalibre1 calibre6 pcalibre"/>Domain Driven Teams</h2>
			<p class="calibre3"><em class="italic">Dan Abramov</em>, who leads the React project at Meta, once tweeted the question, “<em class="italic">Is Microfrontends solving a technology problem or an </em><span><em class="italic">organizational problem?</em></span><span>”</span></p>
			<p class="calibre3">When you think about it, a lot of problems we see in today’s software development do stem from the way teams <span>are organized.</span></p>
			<p class="calibre3">Domain Driven Design<a id="_idIndexMarker043" class="pcalibre1 calibre6 pcalibre"/> is a <a id="_idIndexMarker044" class="pcalibre1 calibre6 pcalibre"/>well-established concept in the microservices world. Backend microservice teams are <a id="_idIndexMarker045" class="pcalibre1 calibre6 pcalibre"/>commonly organized around these domain models. With microfrontends, we extend the same thinking to the frontend world, and by re-organizing the frontend teams within these domain models, we are now able to create vertically sliced teams, where a domain-driven team can own the responsibility of a business functionality from end to end and is able to <span>work independently.</span></p>
			<p class="calibre3">For us to be successful with microfrontends, it is critical that the micro apps and teams that own them are mapped to these domain models and the business value they aim <span>to provide.</span></p>
			<p class="calibre3">Let’s have a quick look at what a Domain Driven Team might <span>look like:</span></p>
			<div class="calibre2">
				<div id="_idContainer014" class="img---figure">
					<img src="image/Figure_2.01_B18987.jpg" alt="Figure 2.1 – Domain-driven teams" class="calibre4"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 2.1 – Domain-driven teams</p>
			<p class="calibre3">The <a id="_idIndexMarker046" class="pcalibre1 calibre6 pcalibre"/>preceding diagram shows three <a id="_idIndexMarker047" class="pcalibre1 calibre6 pcalibre"/>domain-driven teams for an e-commerce application, namely <strong class="bold">Catalog Team</strong>, <strong class="bold">Checkout Team</strong>, and <strong class="bold">User Account Team</strong>. Within each team, you will see that they have dedicated team members who play the roles of frontend, backend, and <span>integration engineers.</span></p>
			<h2 id="_idParaDest-34" class="calibre5"><a id="_idTextAnchor033" class="pcalibre1 calibre6 pcalibre"/>Isolating Failure</h2>
			<p class="calibre3">Microfrontends are inherently designed to be “decentralized.” One of the many benefits of that is isolating failures and reducing the blast radius of an error. A common problem with monolith <strong class="bold">Single Page Apps</strong> (<strong class="bold">SPAs</strong>) is that<a id="_idIndexMarker048" class="pcalibre1 calibre6 pcalibre"/> a single line of <a id="_idIndexMarker049" class="pcalibre1 calibre6 pcalibre"/>error in any one of the modules would prevent an entire application from being compiled, or a runtime error would cause an entire page to <span>error out.</span></p>
			<p class="calibre3">When designing a microfrontend architecture, you need to ensure graceful service degradation if one or more of the <span>microfrontends fail.</span></p>
			<p class="calibre3">If one microfrontend is dependent on another for its functioning, then we are breaking one of the key principles of microfrontends, which should be avoided at <span>all costs.</span></p>
			<h2 id="_idParaDest-35" class="calibre5"><a id="_idTextAnchor034" class="pcalibre1 calibre6 pcalibre"/>Deploying Independently</h2>
			<p class="calibre3">Another key principle of a <a id="_idIndexMarker050" class="pcalibre1 calibre6 pcalibre"/>microfrontend architecture is the ability to deploy each app independently without having to redeploy the <span>other apps.</span></p>
			<p class="calibre3">When a new app is deployed, it should immediately be available to a user and should not require a restart of the host app or the servers for the changes to <span>take effect.</span></p>
			<p class="calibre3">An interesting observation with different teams working on microfrontends is that while, from an architecture standpoint, these micro apps can be updated independently, the DevOps pipelines that deploy these microfrontends are designed to deploy all the apps simultaneously, thereby negating the benefits of <span>independent deployment.</span></p>
			<p class="calibre3">It is critical that the DevOps pipelines are also designed such that when any app is ready for deployment, only the relevant pipeline runs and deploys the app, without impacting the <span>other apps.</span></p>
			<p class="calibre3">This misconfiguration of the DevOps pipelines mainly stems from the problem where there are separate DevOps teams that are responsible for building the pipelines and <span>production deployments.</span></p>
			<p class="calibre3">The best way to <a id="_idIndexMarker051" class="pcalibre1 calibre6 pcalibre"/>fix this is to ensure that we have “full life cycle teams,” who are responsible for building the app and also responsible for deploying it to production. These teams work closely with the DevOps teams to build the CI and CD pipelines and then take over the control of managing and <span>running them.</span></p>
			<h2 id="_idParaDest-36" class="calibre5"><a id="_idTextAnchor035" class="pcalibre1 calibre6 pcalibre"/>Preferring Runtime Integrations</h2>
			<p class="calibre3">A common <a id="_idIndexMarker052" class="pcalibre1 calibre6 pcalibre"/>discussion in the context of microfrontends is build time integrations versus runtime integrations. With build time integrations, the different teams build and publish their micro apps either to a version control system or an artifact repository, such as NPM <span>or Nexus.</span></p>
			<p class="calibre3">Then, during building time, all these micro apps are brought together to build a single app bundle, which is then deployed to production. We strongly discourage this pattern of build-time integration, as it breaks the aforementioned principle of independent deployment. A pattern like this may be suitable where you have scheduled releases that happen either once or twice a month. However, in that case, you probably would be better off with a monolith single-page app and don’t really have to deal with all the complexities of a <span>microfrontend architecture.</span></p>
			<p class="calibre3">Always prefer runtime integrations when designing a <span>microfrontend architecture.</span></p>
			<p class="calibre3">Your micro apps should immediately be available for use the moment they are deployed. This ensures that each team can continuously deploy their micro apps to production and are not dependent on other teams to make their <span>app available.</span></p>
			<p class="calibre3">In most microfrontend patterns, we can make use of a host application or a shell app that keeps a tab of the different micro apps that load within it, but care must be taken to ensure that this host/app shell is built with scalability in mind. If the process of checking for new versions of a micro app takes up a lot of CPU or memory resources, then there is a high risk that it will become a single point of failure when your application scales, in terms of the micro apps and the traffic <span>it receives.</span></p>
			<h2 id="_idParaDest-37" class="calibre5"><a id="_idTextAnchor036" class="pcalibre1 calibre6 pcalibre"/>Avoiding the “Distributed Monolith” trap</h2>
			<p class="calibre3"><strong class="bold">Don’t Repeat Yourself</strong> (<strong class="bold">DRY</strong>) has a slightly different meaning in the microservice/microfrontend <a id="_idIndexMarker053" class="pcalibre1 calibre6 pcalibre"/>world. Most developers associate DRY with <a id="_idIndexMarker054" class="pcalibre1 calibre6 pcalibre"/>code reusability. When working with microfrontends, teams can go overboard creating libraries and utilities, which eventually get imported and used in each of the micro apps. Now, as each team’s needs grow, they start adding functionality to these common libraries and utilities, in the hope that it will be beneficial to other teams. However, the problem it creates is that additional unused code is now being imported into the other micro apps (while tree shaking will solve this problem, in most cases, mainly due to poor coding practices, tree shaking doesn’t work well, and we end up with unnecessary code imported into the apps). Another problem with these shared libraries is that there is a much higher risk of introducing breaking changes, with changes made for one micro app now breaking the other micro apps. By going overboard with code reusability, we end up with what’s commonly called a “distributed monolith,” which is essentially the worst of <span>both worlds.</span></p>
			<p class="calibre3">It’s okay to have some shared libraries or, if using TypeScript, a shared types/interfaces file, but we must avoid creating large <span>common libraries.</span></p>
			<p class="calibre3">In the microservice/microfrontend world, DRY essentially refers to automating tasks so that you don’t have to manually repeat the steps for each microservice or micro app. These could be things such as automating quality gates, or performance and security checks as part of the <span>developers’ pipelines.</span></p>
			<h2 id="_idParaDest-38" class="calibre5"><a id="_idTextAnchor037" class="pcalibre1 calibre6 pcalibre"/>Technology agnostic</h2>
			<p class="calibre3">Another principle of a <a id="_idIndexMarker055" class="pcalibre1 calibre6 pcalibre"/>microfrontend architecture is that it should be technology agnostic, meaning that each of the micro apps could “in theory” be built using different frameworks/languages. However, just because it’s possible doesn’t mean teams should go all out and use either Vue, Angular, or React to build out different <span>micro apps.</span></p>
			<p class="calibre3">There are multiple reasons why this should <span>be avoided:</span></p>
			<ul class="calibre15">
				<li class="calibre14">Multiple libraries/frameworks mean an additional payload being sent down the wire to <span>users’ devices</span></li>
				<li class="calibre14">It makes it difficult to rotate team members, and moving from one team to another means having to get comfortable with a <span>new framework/library</span></li>
			</ul>
			<p class="calibre3">The primary <a id="_idIndexMarker056" class="pcalibre1 calibre6 pcalibre"/>reason for this principle is to allow for incremental upgrades, either from an older version to a newer version of the same library or to explore the benefits of a <span>new framework.</span></p>
			<h2 id="_idParaDest-39" class="calibre5"><a id="_idTextAnchor038" class="pcalibre1 calibre6 pcalibre"/>Granular Scaling</h2>
			<p class="calibre3">When planning out a deployment<a id="_idIndexMarker057" class="pcalibre1 calibre6 pcalibre"/> strategy for your microfrontend, you must ensure that it supports granular scaling. By granular scaling, what we mean is that if a certain set of pages is getting a lot of traffic, either due to a marketing campaign or something similar, then only the servers serving those pages should scale, while the rest of the pods serving other parts of your microfrontend can remain at their regular levels. This ensures optimal cloud and <span>hosting costs.</span></p>
			<h2 id="_idParaDest-40" class="calibre5"><a id="_idTextAnchor039" class="pcalibre1 calibre6 pcalibre"/>Culture of Automation and DevOps</h2>
			<p class="calibre3">A strong <a id="_idIndexMarker058" class="pcalibre1 calibre6 pcalibre"/>culture of automation and DevOps is critical for the long-term success of a <span>microfrontend architecture.</span></p>
			<p class="calibre3">As you can imagine with microfrontends, since we break up a single app into smaller apps, all the activities associated with tasks such as compiling the app and running quality, performance, and security checks will now need to be done multiple times for each of the apps. If we don’t have automation processes for all of the aforementioned items, then the overall development and release of these apps will take a lot longer than what it would have been with <span>a monolith.</span></p>
			<p class="calibre3">Hence, it is important to invest time and effort into building these automation processes, most of which are generally done as part of the <span>DevOps pipelines.</span></p>
			<p class="calibre3">Teams can also invest in tooling and building code generators and micro app templates that can help speed up the creation of newer micro apps. They can also run linters, security, and other quality checks automatically as part of the <span>DevOps pipelines.</span></p>
			<p class="calibre3">With this, we come to the end of this section, where we saw some of the important principles that teams must keep in mind when designing a <span>microfrontend architecture.</span></p>
			<p class="calibre3">We saw how principles such as domain-driven teams, independent deployments, and granular scaling allow teams to move consistently and quickly. We saw how teams should avoid falling into the trap of a distributed monolith and build a pattern that uses build-time integrations, and finally, we saw how keeping the architecture technology agnostic and <a id="_idIndexMarker059" class="pcalibre1 calibre6 pcalibre"/>focusing on automation helps an architecture to easily evolve and <span>become future-proof.</span></p>
			<p class="calibre3">In the next section, we will look at some of the important components of the <span>microfrontend architecture.</span></p>
			<h1 id="_idParaDest-41" class="calibre7"><a id="_idTextAnchor040" class="pcalibre1 calibre6 pcalibre"/>The key Components of a Microfrontend Architecture</h1>
			<p class="calibre3">After spending time <a id="_idIndexMarker060" class="pcalibre1 calibre6 pcalibre"/>going through the principles of a microfrontend, now let’s look at some of the key components of a <span>microfrontend architecture.</span></p>
			<p class="calibre3">In this section, we will look at the essential components any microfrontend architecture needs to have, and we will look at some of the nuances associated <span>with them.</span></p>
			<p class="calibre3">After completing this section, you will be aware of the four basic components that make up any <span>microfrontend architecture.</span></p>
			<h2 id="_idParaDest-42" class="calibre5"><a id="_idTextAnchor041" class="pcalibre1 calibre6 pcalibre"/>Routing Engine</h2>
			<p class="calibre3">As we saw in the previous chapter, depending on the type of microfrontend pattern you aim to build, the <a id="_idIndexMarker061" class="pcalibre1 calibre6 pcalibre"/>routing engine<a id="_idIndexMarker062" class="pcalibre1 calibre6 pcalibre"/> for your app will be partially or fully decoupled from <span>your apps.</span></p>
			<p class="calibre3">There are multiple approaches we can take. We can use NGINX as a reverse proxy and have a list of all the primary routes that map to the respective apps in the multi-SPA pattern. If the apps are deployed in a Kubernetes cluster, we can make use of Ingress routes to map the primary routes to the respective apps. We will go into more detail about this in <a href="B18987_08.xhtml#_idTextAnchor119" class="pcalibre1 calibre6 pcalibre"><span><em class="italic">Chapter 8</em></span></a>, <em class="italic">Deploying Microfrontends to Kubernetes</em>, where we will look at deploying these microfrontends in <span>the cloud.</span></p>
			<h2 id="_idParaDest-43" class="calibre5"><a id="_idTextAnchor042" class="pcalibre1 calibre6 pcalibre"/>A global state and a Communication Channel</h2>
			<p class="calibre3">In addition to<a id="_idIndexMarker063" class="pcalibre1 calibre6 pcalibre"/> routing, the next important thing to design well in your microfrontend architecture is the communication channel between the different apps and also the notion of a global state, which can be shared between the <span>different apps.</span></p>
			<p class="calibre3">With a monolith SPA, the most common practice is to use a single global store such as Redux or MobX, where everything is written into that store and read from it. With microfrontends, the recommendation is to avoid such global client-side stores and instead let each micro app get its data from the backend API, as that is the real source <span>of truth.</span></p>
			<p class="calibre3">However, there would be a genuine need for client-side state management to avoid making unnecessary calls to the backend, to fetch things such as <strong class="source-inline">user_id</strong> or a cart count. For things such as these, we can look to use a really thin global store in the app shell or maybe even look toward <strong class="source-inline">localStorage</strong> or <strong class="source-inline">IndexedDB</strong> to store the values that are needed to make <span>API calls.</span></p>
			<p class="calibre3">With a micro app <a id="_idIndexMarker064" class="pcalibre1 calibre6 pcalibre"/>microfrontend pattern, it also becomes important to establish a common communication channel that the different apps use to communicate with each other. A classic use case would be when clicking on the <strong class="bold">Add to Cart</strong> button on a product page, the mini cart present in the header is automatically incremented. In such cases, an event-driven communication channel <span>works best.</span></p>
			<h2 id="_idParaDest-44" class="calibre5"><a id="_idTextAnchor043" class="pcalibre1 calibre6 pcalibre"/>Source code Version Control</h2>
			<p class="calibre3">Another important <a id="_idIndexMarker065" class="pcalibre1 calibre6 pcalibre"/>item that teams need to agree on is how they plan to organize their Git repositories. Two schools of thought prevail here – organizing your apps in a polyrepo or a monorepo. Let’s look at <span>their nuances.</span></p>
			<h3 class="calibre9">Polyrepos</h3>
			<p class="calibre3">Polyrepos<a id="_idIndexMarker066" class="pcalibre1 calibre6 pcalibre"/> are where you have each of your multi-SPAs or micro apps managed in its own independent Git repository. These are easiest to start with and give complete team independence. From a DevOps standpoint too, they are a lot easier to manage. However, this approach has a few drawbacks. There is a higher risk of teams becoming siloed and reduced inter-team collaboration. Another drawback is duplication and higher maintenance costs for tooling, such as DevOps pipelines and automation scripts, which need to be duplicated and updated in each of <span>the repos.</span></p>
			<h3 class="calibre9">Monorepos</h3>
			<p class="calibre3">In a monorepo<a id="_idIndexMarker067" class="pcalibre1 calibre6 pcalibre"/> structure, all your multi-SPAs or micro apps are co-located in a single Git repo, with each app located within its own <span>individual folder.</span></p>
			<p class="calibre3">Monorepos are starting to become a de facto approach for many frontend teams to manage their code repositories. The main advantage of monorepos is increased team collaboration, as everybody is able to see every other team’s code and provide valuable feedback. Tooling and automation scripts can be centralized, whereby optimizations done by one team are immediately available for other teams to follow. Some of the drawbacks of monorepos include DevOps setups being a bit complicated. Teams also need to set up fine-grained folder-level permissions to prevent teams from overwriting each other’s code. In the grand scheme of things, monorepos provide more advantages and, hence, are a preferred approach to managing the source code for <span>your microfrontends.</span></p>
			<h2 id="_idParaDest-45" class="calibre5"><a id="_idTextAnchor044" class="pcalibre1 calibre6 pcalibre"/>A Component Library</h2>
			<p class="calibre3">When <a id="_idIndexMarker068" class="pcalibre1 calibre6 pcalibre"/>building microfrontends, it is critical to ensure a consistent look and feel as a user navigates through the different apps. The way we achieve that is by ensuring all apps make use of a common design system and component library. It is also recommended that all teams use a common theming and styling engine to ensure that all the components look and behave the same, irrespective of which app they are <span>served in.</span></p>
			<p class="calibre3">A common pattern is to publish a component library<a id="_idIndexMarker069" class="pcalibre1 calibre6 pcalibre"/> as an NPM module and set up all the other apps to import and use it. Each time a new version of the component library is published, teams will need to update their respective apps to the <span>latest version.</span></p>
			<p class="calibre3">An emerging trend, thanks to monorepos, is to build directly from source. What this means is that a component library is stored within the <strong class="source-inline">libs</strong> section of the monorepo and the components are directly linked from the library path. The main advantage of this method is that every <a id="_idIndexMarker070" class="pcalibre1 calibre6 pcalibre"/>time teams build their app, they automatically receive the latest version of<a id="_idIndexMarker071" class="pcalibre1 calibre6 pcalibre"/> the <span>component library.</span></p>
			<p class="calibre3">In this section, we learned about the key components of a microfrontend architecture, namely a routing engine, a global state, and a communication channel. We also saw the distinctions between a polyrepo and monorepo and saw why frontend teams prefer to use monorepos. Finally, we also learned about the component library and different ways teams consume components from a <span>common library.</span></p>
			<h1 id="_idParaDest-46" class="calibre7"><a id="_idTextAnchor045" class="pcalibre1 calibre6 pcalibre"/>Summary</h1>
			<p class="calibre3">With that, we come to the end of our second chapter. We started the chapter by looking at the key principles we need to keep in mind. We saw why it is important to break teams down based on domain models, and why it is critical for teams to be able to independently deploy their own apps. We learned about the misconceptions associated with code reuse and how it can lead to a distributed monolith trap. We also saw the importance of DevOps and an automation culture. Finally, we learned about the four key components of a microfrontend. Everything that we learned in this chapter we will put into practice in the coming chapters, as we go about building our very own <span>microfrontend application.</span></p>
			<p class="calibre3">In the next chapter, we will dive deeper into monorepos versus polyrepos and learn how it’s more about team culture than technology. We will also start off by setting up our code repository as a monorepo to set up the foundation for <span>future work.</span></p>
		</div>
	</body></html>