- en: Create a Router-First Line-of-Business App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个以路由为首选的LOB应用
- en: Line-of-Business (**LOB**) applications are the bread and butter of the software
    development world. As defined in Wikipedia, LOB is a general term, which refers
    to a product or a set of related products that serve a particular customer transaction
    or business need. LOB apps present a good opportunity to demonstrate a variety
    of features and functionality without getting into contorted or specialized scenarios
    that large enterprise applications usually require. In a sense, they are the 80-20
    learning experience. I must, however, point out a curious thing about LOB apps—if
    you end up building a semi-useful LOB app, the demand for it will grow uncontrollably,
    and you will quickly become the victim of your own success. This is why you should
    treat the start of every new project as an opportunity, a coding-kata if you will, to
    get better at creating more flexible architectures.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Line-of-Business（**LOB**）应用程序是软件开发世界的支柱。根据维基百科的定义，LOB是一个通用术语，指的是服务于特定客户交易或业务需求的产品或一组相关产品。LOB应用程序提供了展示各种功能和功能的良好机会，而无需涉及大型企业应用程序通常需要的扭曲或专业化场景。在某种意义上，它们是80-20的学习经验。但是，我必须指出关于LOB应用程序的一个奇怪之处——如果您最终创建了一个半有用的LOB应用程序，其需求将不受控制地增长，您将很快成为自己成功的受害者。这就是为什么您应该把每个新项目的开始视为一个机会，一个编码的开拓，以更好地创建更灵活的架构。
- en: In this chapter and the remaining chapters, we’ll set up a new application with
    rich features that can meet the demands of a LOB application with a scalable architecture
    and engineering best practices that will help you start small and be able to grow
    your solution quickly if there’s demand. We will follow the Router-first design
    pattern, relying on reusable components to create a grocery store LOB named LemonMart.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和其余章节中，我们将使用可扩展的架构和工程最佳实践建立一个功能丰富的新应用程序，以满足具有可扩展架构的LOB应用程序的需求。我们将遵循以路由为首选的设计模式，依靠可重用组件创建一个名为LemonMart的杂货店LOB。
- en: 'In this chapter, you will learn to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学会以下内容：
- en: Effectively use CLI to create major Angular Components and CLI Scaffolds
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效地使用CLI来创建重要的Angular组件和CLI脚手架
- en: Learn how to build Router-first Apps
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何构建以路由为首选的应用程序
- en: Branding, Custom and Material Iconography
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 品牌、定制和素材图标
- en: Debug complicated apps with Augury
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Augury调试复杂应用程序
- en: Enable lazy loading
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用延迟加载
- en: Create a walking skeleton
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个步行骨架
- en: 'The code samples provided in this book require Angular version 5 and 6\. Angular
    5 code is runtime compatible with Angular 6\. Angular 6 will be supported in LTS
    until October 2019\. The most up-to-date versions of the code repositories may
    be found at the following URLs:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本书提供的代码示例需要Angular版本5和6。Angular 5代码与Angular 6运行时兼容。Angular 6将在2019年10月之前得到长期支持。代码存储库的最新版本可在以下网址找到：
- en: LocalCast Weather at [Github.com/duluca/local-weather-app](https://github.com/duluca/local-weather-app)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [Github.com/duluca/local-weather-app](https://github.com/duluca/local-weather-app)
    上的LocalCast天气
- en: LemonMart at [Github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [Github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart) 上的LemonMart
- en: Angular cheat sheet
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 速查表
- en: Before we dive in to creating our LOB app, I have included a cheat sheet for
    you to familiarize yourself with common Angular syntax and CLI commands, because
    going forward, this syntax and these commands will be used without their purpose
    explicitly explained. Take some time to review and orient yourself with new Angular
    syntax, major components, CLI scaffolds, and common pipes. You may find the list
    especially useful if your background is with AngularJS, since you will need to
    unlearn some old syntax.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始创建LOB应用程序之前，我为您提供了一个速查表，让您熟悉常见的Angular语法和CLI命令，因为在今后，这些语法和命令将被使用，而不需要明确解释它们的目的。花些时间审查和熟悉新的Angular语法、主要组件、CLI脚手架和常见管道。如果您的背景是AngularJS，您可能特别需要这个列表，因为您需要放弃一些旧的语法。
- en: Binding
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定
- en: 'Binding, or data binding, refers to an automatic, one or two-way connection
    between a variable in code and a value displayed or input in an HTML template
    or another component:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定，或数据绑定，指的是代码中的变量和HTML模板或其他组件中显示或输入的值之间的自动单向或双向连接：
- en: '| **Type** | **Syntax ** | **Data direction** |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **语法 ** | **数据方向** |'
- en: '| Interpolation Property'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '| 插值属性'
- en: Attribute
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 属性
- en: Class
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 类
- en: Style | `{{expression}}``[target]="expression"``bind-target="expression"` |
    One-way from data source
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 样式 | `{{expression}}``[target]="expression"``bind-target="expression"` | 从数据源单向传输
- en: to view target |
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 用于查看目标 |
- en: '| Event | `(target)="statement"` `on-target="statement"` | One-way from view
    target'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '| 事件 | `(target)="statement"` `on-target="statement"` | 从视图目标到单向'
- en: to data source |
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 用于数据源 |
- en: '| Two-way | `[(target)]="expression"` `bindon-target="expression"` | Two-way
    |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 双向绑定 | `[(target)]="expression"` `bindon-target="expression"` | 双向绑定 |'
- en: Source: [https://angular.io/guide/template-syntax#binding-syntax-an-overview](https://angular.io/guide/template-syntax#binding-syntax-an-overview)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：[https://angular.io/guide/template-syntax#binding-syntax-an-overview](https://angular.io/guide/template-syntax#binding-syntax-an-overview)
- en: Built-in directives
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置指令
- en: 'Directives encapsulate coded behaviors that can be applied as attributes to
    HTML elements or other components:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 指令封装编码行为，可应用为 HTML 元素或其他组件的属性：
- en: '| **Name** | **Syntax ** | **Purpose** |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **语法** | **目的** |'
- en: '| Structural Directives | `*ngIf``*ngFor``*ngSwitch` | Controls structural
    layout of the HTML and if elements get added or removed from the DOM |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 结构指令 | `*ngIf``*ngFor``*ngSwitch` | 控制 HTML 的结构布局，以及根据需要在 DOM 中添加或移除元素 |'
- en: '| Attribute Directives | `[class]``[style]``[(model)]` | Listens to and modifies
    the behavior of other HTML elements, attributes, properties, and components, such
    as CSS classes, HTML styles, and HTML form elements |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 属性指令 | `[class]``[style]``[(model)]` | 监听并修改其他 HTML 元素、属性、属性和组件的行为，如 CSS
    类、HTML 样式和 HTML 表单元素 |'
- en: Structural Directives Source: [https://angular.io/guide/structural-directives](https://angular.io/guide/structural-directives)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 结构指令来源：[https://angular.io/guide/structural-directives](https://angular.io/guide/structural-directives)
- en: Attribute Directives Source: [https://angular.io/guide/template-syntax#built-in-attribute-directives](https://angular.io/guide/template-syntax#built-in-attribute-directives)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 属性指令来源：[https://angular.io/guide/template-syntax#built-in-attribute-directives](https://angular.io/guide/template-syntax#built-in-attribute-directives)
- en: Common pipes
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见的管道
- en: Pipes modify how a data-bound value is displayed in the HTML template.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '管道修改了在 HTML 模板中显示数据绑定值的方式。  '
- en: '| **Name** | **Purpose** | **Usage** |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **目的** | **用法** |'
- en: '| Date | Formats a date according to locale rules | `{{date_value &#124; date[:format]}}`
    |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 日期 | 根据语言环境规则，格式化日期 | `{{date_value &#124; date[:format]}}` |'
- en: '| Text Transformation | Transforms text to uppercase, lowercase, or title case
    | `{{value &#124; uppercase}}``{{value &#124; lowercase}}``{{value &#124; titlecase
    }}` |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 文本转换 | 将文本转换为大写、小写或标题格式 | `{{value &#124; uppercase}}``{{value &#124; lowercase}}``{{value
    &#124; titlecase }}` |'
- en: '| Decimal | Formats a number according to locale rules | `{{number &#124; number[:digitInfo]}}`
    |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 十进制 | 根据语言环境规则，格式化数字 | `{{number &#124; number[:digitInfo]}}` |'
- en: '| Percent | Formats a number as a percentage according to locale rules | `{{number
    &#124; percent[:digitInfo]}}` |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 百分比 | 根据语言环境规则，将数字格式化为百分比形式 | `{{number &#124; percent[:digitInfo]}}` |'
- en: '| Currency | Formats a number as currency with currency code and symbol according
    to locale rules | `{{number &#124; currency[:currencyCode [:symbolDisplay[:digitInfo]]]}}`
    |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 货币 | 根据语言环境规则，格式化数字为带有货币代码和符号的货币形式 | `{{number &#124; currency[:currencyCode
    [:symbolDisplay[:digitInfo]]]}}` |'
- en: Pipes Source: [https://angular.io/guide/pipes](https://angular.io/guide/pipes)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 管道来源：[https://angular.io/guide/pipes](https://angular.io/guide/pipes)
- en: Starter commands, major components, and CLI scaffolds
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 起始命令、主要组件和 CLI 脚手架
- en: 'Starter commands help generate new projects or add dependencies. Angular CLI
    commands help create major components by automatically generating boilerplate
    scaffolding code with ease. For the list of full set of commands, visit [https://github.com/angular/angular-cli/wiki](https://github.com/angular/angular-cli/wiki):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 起始命令帮助生成新项目或添加依赖项。Angular CLI 命令可通过自动生成易用的样板脚手架代码来快速创建主要组件。有关完整命令列表，请访问[https://github.com/angular/angular-cli/wiki](https://github.com/angular/angular-cli/wiki)：
- en: '| **Name** | **Purpose ** | **CLI Command** |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **目的** | **CLI 命令** |'
- en: '| New | Creates a new Angular application with initialized git repository,
    package.json, and routing already configured. Run from parent folder. | `npx @angular/cli
    new project-name --routing` |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 新建 | 创建一个新的 Angular 应用，并已配置好初始化的 git 仓库、package.json，并已配置好路由。从父级文件夹运行。 |
    `npx @angular/cli new project-name --routing` |'
- en: '| Update | Updates Angular, RxJS, and Angular Material dependencies. Rewrites
    code, if necessary, to maintain compatibility. | `npx ng update` |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 更新 | 更新 Angular、RxJS 和 Angular Material 依赖项。根据需要重写代码以保持兼容性。 | `npx ng update`
    |'
- en: '| Add Material | Installs and configures Angular Material dependencies. | `npx
    ng add @angular/material` |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 添加材料 | 安装和配置 Angular Material 依赖项。 | `npx ng add @angular/material` |'
- en: '| Module | Creates a new  `@NgModule` class. Uses `--routing` to add routing
    for submodules. Optionally, import new module into a parent module using `--module`.
    | `ng g module new-module` |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 模块 | 创建一个新的`@NgModule`类。使用`--routing`为子模块添加路由。可选择使用`--module`将新模块导入到父模块中。
    | `ng g module new-module` |'
- en: '| Component | Creates a new `@Component` class. Uses `--module` to specify
    parent module. Optionally, use `--flat` to skip directory creation, `-t` for an
    inline template, and `-s` for an inline style. | `ng g component new-component`
    |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 组件 | 创建一个新的`@Component`类。使用`--module`指定父模块。可选择使用`--flat`跳过目录创建，`-t`用于内联模板，`-s`用于内联样式。
    | `ng g component new-component` |'
- en: '| Directive | Creates a new `@Directive` class. Optionally, uses `--module`
    to scope directives for a given submodule. | `ng g directive new-directive` |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 创建一个新的`@Directive`类。可选择使用`--module`为给定子模块定义指令的作用域。 | `ng g directive
    new-directive` |'
- en: '| Pipe | Creates a new `@Pipe` class. Optionally, use `--module` to scope pipes
    for a given submodule. | `ng g pipe new-pipe` |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 管道 | 创建一个新的`@Pipe`类。可选择使用`--module`为给定子模块定义管道的作用域。 | `ng g pipe new-pipe`
    |'
- en: '| Service | Creates a new `@Injectable` class. Uses `--module` to provide a 
    service for a given submodule. Services are not automatically imported to a module.
    Optionally use `--flat` false to create service under a directory. | `ng g service
    new-service` |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 服务 | 创建一个新的`@Injectable`类。使用`--module`为给定子模块提供服务。服务不会自动导入到模块中。可选择使用`--flat`
    false将服务创建在一个目录下。 | `ng g service new-service` |'
- en: '| Guard | Creates a new `@Injectable` class, which implements the Route lifecycle
    hook `CanActivate`. Uses `--module` to provide a guard for a given submodule.
    Guards are not automatically imported to a module. | `ng g guard new-guard` |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 守卫 | 创建一个新的`@Injectable`类，实现了路由生命周期钩子`CanActivate`。使用`--module`为给定的子模块提供守卫。守卫不会自动导入到一个模块中。
    | `ng g guard new-guard` |'
- en: '| Class | Creates a bare-bones class. | `ng g class new-class` |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 类 | 创建一个基础的类。 | `ng g class new-class` |'
- en: '| Interface | Creates a bare-bones interface. | `ng g interface new-interface`
    |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 接口 | 创建一个基本的接口。 | `ng g interface new-interface` |'
- en: '| Enum | Creates a bare-bones enum. | `ng g enum new-enum` |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 枚举 | 创建一个基础的枚举。 | `ng g enum new-enum` |'
- en: In order to properly scaffold some of the components listed earlier under a
    custom module, such as `my-module`, you can prepend the module name before the
    name of what you intend to generate, for example, `ng g c my-module/my-new-component`.
    Angular CLI will properly wire up and place the new component under the `my-module` folder.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确地在自定义模块下生成之前列出的一些组件，比如`my-module`，你可以在你想要生成的名字之前加上模块名，比如`ng g c my-module/my-new-component`。Angular
    CLI将正确配置并将新组件放置在`my-module`文件夹下。
- en: Configure Angular CLI autocomplete
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Angular CLI自动补全
- en: 'You get an autocomplete experience when working with Angular CLI. Execute the
    appropriate command for your `*nix` environment:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Angular CLI时，可以获得自动补全的体验。在你的`*nix`环境中执行相应的命令：
- en: 'For bash shell:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于bash shell：
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For zsh shell:'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于zsh shell：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For Windows users using git bash shell:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于使用git bash shell的Windows用户：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Router-first architecture
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以路由为中心的架构
- en: The Angular router, shipped in the `@angular/router` package, is a central and
    critical part of building **single-page-applications** (**SPAs**) that act and
    behave like regular websites that are easy to navigate using browser controls
    or the zoom or microzoom controls.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Angular路由器，包含在`@angular/router`包中，是构建**单页面应用程序**（**SPAs**）的核心且关键的部分，它的行为表现就像是可以使用浏览器控件或缩放控件轻松导航的普通网站。
- en: Angular Router has advanced features such as lazy loading, router outlets, auxiliary
    routes, smart active link tracking, and the ability to be expressed as an `href`,
    which enables a highly flexible Router-first app architecture leveraging stateless
    data-driven components using RxJS `SubjectBehavior`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Angular Router具有高级功能，例如延迟加载，路由出口，辅助路由，智能活动链接跟踪，以及可以被表示为一个`href`的能力，这使得可以利用无状态数据驱动组件使用RxJS
    `SubjectBehavior`来实现高度灵活的以路由为中心的应用架构。
- en: Large teams can work against a single-code base, with each team responsible
    of a module's development, without stepping on each other's toes, while enabling
    easy continuous integration. Google, with its billions of lines of code, works
    against a single code base for a very good reason. Integration, after the fact,
    is very expensive.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 大型团队可以针对单一代码库进行工作，每个团队负责一个模块的开发，而不会互相影响，同时可以实现简单的持续集成。Google有着数十亿行代码，选择针对单一代码库工作是有着非常好的理由的。事后的集成是非常昂贵的。
- en: Small teams can remix their UI layouts on the fly to quickly respond to changes
    without having to rearchitect their code. It is easy to underestimate the amount
    of time wasted due to late game changes in layout or navigation. Such changes
    are easier to absorb by larger teams but a costly endeavor for small teams.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 小团队可以动态重新排列其UI布局，以快速对变化做出响应，而无需重新构建其代码。很容易低估由于布局或导航的后期变更而浪费的时间量。对于大团队来说，这些变化更容易吸收，但对于小团队来说是一次代价高昂的努力。
- en: With lazy-loading, all developers benefit from sub-second first meaningful paints,
    because the file size of the core user experience that's delivered to the browser
    is kept at a minimum at build time. The size of a module impacts download and
    loading speed, because the more a browser has to do, the longer it will take for
    a user to see the first screen of the app. By defining lazy-loaded modules, each
    module can be packaged as separated files, which can be downloaded and loaded
    individually and as needed. Smart active link tracking results in a superior developer
    and user experience, making it very easy to implement highlighting features to
    indicate to the user the current tab or portion of the app that is currently active.
    Auxiliary routes maximize the reuse of components and help pull off complicated
    state transitions with ease. With auxiliary routes, you can render multiple master
    and detail views using only a single outer template. You can also control how
    the route is displayed to the user in the browser's URL bar and compose routes
    using `routerLink`, in templates, and `Router.navigate`, in code, driving complicated
    scenarios.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通过延迟加载，所有开发人员都可以受益于亚秒级的第一意义性绘制，因为在构建时，向浏览器传递的核心用户体验的文件大小被保持在最低限度。模块的大小影响下载和加载速度，因为浏览器需要执行的操作越多，用户看到应用程序的第一个屏幕就需要的时间就越长。通过定义延迟加载的模块，每个模块可以作为单独的文件打包，可以单独下载和加载，并根据需要使用。智能活动链接跟踪会产生卓越的开发人员和用户体验，使得实现突出显示功能来指示用户当前活动的选项卡或应用程序部分非常容易。辅助路由最大化了组件的重用，并帮助轻松实现复杂的状态转换。通过辅助路由，您可以仅使用单个外部模板呈现多个主视图和详细视图。您还可以控制路由如何在浏览器的URL栏中显示，并使用`routerLink`在模板中和`Router.navigate`在代码中组成路由，从而驱动复杂的场景。
- en: 'In order to pull off a router-first implementation, you need to do this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现路由器优先的实现，您需要这样做：
- en: Define user roles early on
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 早期定义用户角色
- en: Design with lazy loading in mind
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计时考虑延迟加载
- en: Implement a walking-skeleton navigation experience
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实施一个步行骨架导航体验
- en: Design around major data components
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 围绕主要数据组件进行设计
- en: Enforce a decoupled component architecture
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 强制执行解耦的组件架构
- en: Differentiate between user controls and components
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 区分用户控件和组件
- en: Maximize code reuse
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最大化代码复用
- en: User roles normally indicate the job function of a user, such as a manager or
    data-entry specialist. In technical terms, they can be thought of as a group of
    actions that a particular class of user is allowed to execute. Defining user roles
    help identify sub modules that can then be configured to be lazy loaded. After
    all, a data-entry specialist won't ever see most of the screens that a manager
    can, so why deliver those assets to those users and slow down their experience? Lazy
    loading is critical in creating a scalable application architecture, not only
    from an application perspective, but also from a high-quality and efficient development
    perspective. Configuring lazy loading can be tricky, which is why it is important
    to nail down a walking-skeleton navigation experience early on.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 用户角色通常表示用户的工作职能，比如经理或数据输入专员。在技术术语中，它们可以被视为特定用户类别被允许执行的一组操作。定义用户角色有助于识别可以配置为延迟加载的子模块。毕竟，数据输入专员永远不会看到大多数经理可以看到的屏幕，那么为什么要向这些用户提供这些资源并减慢他们的体验呢？延迟加载对于创建可扩展的应用程序架构至关重要，不仅从应用程序的角度来看，还从高质量和高效的开发角度来看。配置延迟加载可能会有些棘手，这就是为什么早期确定一个步行骨架导航体验非常重要的原因。
- en: Identifying major data components that your users will work with, such as invoice
    or people objects, will help you avoid over-engineering your application. Designing
    around major data components will inform API design early on and help define `BehaviorSubject`
    data anchors that you will use to achieve a stateless, data-driven design to ensure
    a decoupled component architecture.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 确定用户将使用的主要数据组件，例如发票或人员对象，将帮助您避免过度设计您的应用程序。围绕主要数据组件进行设计将及早通知API设计，并帮助定义您将使用的`BehaviorSubject`数据锚定来实现无状态、数据驱动的设计，以确保解耦的组件架构。
- en: Finally, identify self-contained user controls that encapsulate unique behaviors
    that you wish to create for your app. User controls will likely be created as
    directives or components that have data-binding properties and tightly-coupled
    controller logic and templates. Components, on the other hand, will leverage router
    lifecycle events to parse parameters and perform CRUD operations on data. Identifying
    these component reuses early on will result in creating more flexible components
    that can be reused in multiple contexts as orchestrated by the router, maximizing
    code reuse.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，识别自包含的用户控件，它们封装了您希望为您的应用程序创建的独特行为。用户控件可能会作为具有数据绑定属性和紧密耦合的控制器逻辑和模板的指令或组件进行创建。另一方面，组件将利用路由生命周期事件来解析参数并对数据执行
    CRUD 操作。早期识别这些组件的重用将导致创建更灵活的组件，可以在路由器协调下在多个上下文中重用，最大程度地提高代码重用率。
- en: Creating LemonMart
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 LemonMart
- en: LemonMart will be a mid-sized line-of-business application with over 90 code
    files. We will start our journey by creating a new Angular app with routing and
    Angular Material configured from the get go.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: LemonMart 将是一个具有超过 90 个代码文件的中型业务应用程序。我们将通过从一开始就创建一个配置了路由和 Angular Material 的新
    Angular 应用程序来开始我们的旅程。
- en: Creating a Router-first app
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个以路由为主的应用
- en: 'With the Router-first approach, we will want to enable routing early on in
    our application:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 采用路由优先的方法时，我们希望在应用程序早期就启用路由：
- en: 'You can create the new application with routing already configured by executing
    this command:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过执行此命令创建已经配置了路由的新应用：
- en: 'Ensure that `@angular/cli` is not installed globally, or you may run into errors:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 确保没有全局安装 `@angular/cli`，否则可能会遇到错误：
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A new `AppRoutingModule` file has been created for us:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们创建了一个新的 `AppRoutingModule` 文件：
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We will be defining routes inside the routes array. Note that routes array is
    passed in to be configured as the root routes for the application, the default
    root route being `/`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在路由数组中定义路由。请注意，路由数组被传递以配置为应用程序的根路由，默认的根路由是 `/`。
- en: 'When configuring your `RouterModule`, you can pass in additional options to
    customize the default behavior of the Router, such as when you attempt to load
    a route that is already being displayed, instead of taking no action, you can
    force a reload of the component. To enable this behavior, create your router like `RouterModule.forRoot(routes,
    { onSameUrlNavigation: ''reload'' })`.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '在配置你的 `RouterModule` 时，可以传入额外的选项来自定义路由的默认行为，例如当你尝试加载已经显示的路由时，而不是不采取任何行动，你可以强制重新加载组件。要启用这种行为，请这样创建你的路由 `RouterModule.forRoot(routes,
    { onSameUrlNavigation: ''reload'' })`。 '
- en: 'Finally, `AppRoutingModule` is registered with `AppModule`, as shown:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，注册 `AppRoutingModule` 到 `AppModule`，如下所示：
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Configuring Angular.json and Package.json
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 Angular.json 和 Package.json
- en: 'You should complete these steps before moving forward:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，你应该完成以下步骤：
- en: Modify `angular.json` and `tslint.json` to enforce your settings and coding
    standards
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `angular.json` 和 `tslint.json` 以强制执行你的设置和编码规范
- en: Install `npm i -D prettier`
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 `npm i -D prettier`
- en: Add `prettier` settings to `package.json`
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `package.json` 中添加 `prettier` 设置
- en: Configure your development serve port to other than `4200`, such as `5000`
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将开发服务器端口配置为非`4200`，例如`5000`
- en: Add the `standardize` script and update `start` and `build` scripts
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `standardize` 脚本并更新 `start` 和 `build` 脚本
- en: Add npm Scripts for Docker to `package.json`
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `package.json` 中为 Docker 添加 npm 脚本
- en: Establish dev norms and document it in your project, `npm i -D dev-norms` then
    `npx dev-norms create`
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建立开发规范并在项目中记录，使用 `npm i -D dev-norms` 然后执行 `npx dev-norms create`
- en: If you use VS Code, set up the `extensions.json` and `settings.json` files
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你使用 VS Code，需要设置 `extensions.json` 和 `settings.json` 文件
- en: 'You may configure the TypeScript Hero extension to auto organize and prune
    import statements, but adding `"typescriptHero.imports.organizeOnSave": true`
    to `settings.json`. If combined with the setting `"files.autoSave": "onFocusChange"`
    you may find that the tool aggressively cleans unused imports as you are trying
    to type them out. Ensure that this setting works for you and doesn''t collide
    with any other tools or VS Code''s own import organization feature.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以配置 TypeScript Hero 扩展来自动整理和修剪导入语句，只需在 `settings.json` 中添加 `"typescriptHero.imports.organizeOnSave":
    true`。如果与设置 `"files.autoSave": "onFocusChange"` 结合使用，你可能会发现该工具在你努力输入时会积极地清理未使用的导入项。确保该设置适合你并且不会与任何其他工具或
    VS Code 自己的导入组织功能发生冲突。'
- en: Execute `npm run standardize`
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 `npm run standardize`
- en: Refer to [Chapter 10](4628e6f3-23d6-4aa7-a842-d1df666718de.xhtml),*Prepare Angular
    App for Production Release*, for further configuration details.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 参考[第10章]()，*准备Angular应用进行生产发布*，获取更多配置详细信息。
- en: You can get the npm Scripts for Docker at [bit.ly/npmScriptsForDocker](http://bit.ly/npmScriptsForDocker) and
    npm Scripts for AWS at [bit.ly/npmScriptsForAWS](http://bit.ly/npmScriptsForAWS).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[bit.ly/npmScriptsForDocker](http://bit.ly/npmScriptsForDocker)获取适用于Docker的npm脚本，以及在[bit.ly/npmScriptsForAWS](http://bit.ly/npmScriptsForAWS)获取适用于AWS的npm脚本。
- en: Configuring Material and Styles
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Material和样式
- en: 'We will also need to set up Angular Material and configure a theme to use,
    as covered in Chapter 11, *Enhance Angular App with Angular Material*:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要设置Angular Material并配置要使用的主题，如第11章*使用Angular Material增强Angular应用*：
- en: 'Install Angular Material:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Angular Material：
- en: '[PRE6]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Import and export `MatButtonModule`, `MatToolbarModule`, and `MatIconModule`
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入和导出`MatButtonModule`，`MatToolbarModule`，和`MatIconModule`
- en: Configure your default theme and register other Angular dependencies
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置默认主题并注册其他 Angular 依赖项
- en: Add common css to `styles.css` as shown below,
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将通用css添加到`styles.css`中，如下所示，
- en: '[PRE7]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Refer to [Chapter 11](96bc5869-a891-4695-a315-de55d8abc6b8.xhtml), *Enhance
    Angular App with Angular Material*, for further configuration details.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 参考[第11章]()，*使用Angular Material增强Angular应用*，获取更多配置详细信息。
- en: Designing LemonMart
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计LemonMart
- en: It is important to build a rudimentary road map to follow, from the database
    to the frontend, while also avoiding over-engineering. This initial design phase
    is critical to the long-term health and success of your project, where any existing
    silos between teams must be broken down and an overall technical vision well understood
    by all members of the team. This is easier said than done, and there are volumes
    of books written on the topic.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个从数据库到前端的基本路线图非常重要，同时要避免过度工程化。这个初始设计阶段对项目的长期健康和成功至关重要，在这个阶段任何现有的团队隔离必须被打破，并且整个团队必须对整体技术愿景有很好的理解。这比说起来要容易得多，关于这个话题已经有大量的书籍写成。
- en: In engineering, there's no one right answer to a problem, so it is important
    to remember that no one person can ever have all the answers nor a crystal clear
    vision. It is important that technical and non-technical leaders create a safe
    space with opportunities for open discussion and experimentation as part of the
    culture. The humility and empathy that comes along with being able to court such
    uncertainty as a team is as important as any single team member's technical capabilities.
    Every team member must be comfortable with checking their egos out at the door
    because our collective goal will be to grow and evolve an application to ever-changing
    requirements during the development cycle. You will know that you have succeeded
    if individual parts of the software you created is easily replaceable by anyone.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在工程中，没有一个问题有唯一正确答案，所以重要的是要记住没有人能拥有所有答案，也没有一个清晰的愿景。技术和非技术领导者们创造一个安全的空间，鼓励开放讨论和实验，作为文化的一部分是非常重要的。对于整个团队来说，对这种不确定性的谦卑和同理心和任何单独团队成员的技术能力一样重要。每个团队成员都必须习惯于把自己的自负留在门外，因为我们共同的目标将是在开发周期期间根据不断变化的要求发展和演变应用。如果你成功了，你会发现你创建的软件中的每个部分都可以轻松被任何人替代。
- en: Identifying user roles
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别用户角色
- en: The first step of our design will be to think about you using the application
    and why.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计的第一步是考虑你为什么要使用这个应用。
- en: 'We envision four user states or roles for LemonMart:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构想了LemonMart的四种用户状态或角色：
- en: Authenticated, any authenticated user would have access to their profile
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经过身份验证的用户，任何经过身份验证的用户都可以访问他们的个人资料
- en: Cashier, whose sole role is to check out customers
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 出纳，他们的唯一角色是为客户结账
- en: Clerk, whose sole role is to perform inventory-related functions
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 职员，他们的唯一角色是执行与库存相关的功能
- en: Manager, who can perform all actions a cashier and a clerk can perform but also
    have access to administrative functions
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经理，可以执行出纳和职员所能执行的所有操作，但也可以访问管理功能
- en: With this in mind, we can start a high-level design of our app.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个想法，我们可以开始设计我们应用的高层结构。
- en: Identifying high-level modules with site map
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用站点地图识别高级模块
- en: 'Develop a high-level site map of your application, as shown:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 开发你的应用的高级站点地图，如下所示：
- en: '![](img/b4beb082-f0f8-44ca-a697-89567f380298.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b4beb082-f0f8-44ca-a697-89567f380298.png)'
- en: Landing pages for users
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 用户的登陆页面
- en: I used MockFlow.com's SiteMap tool to create the site map
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用MockFlow.com的SiteMap工具创建了站点地图
- en: shown at [https://sitemap.mockflow.com](https://sitemap.mockflow.com).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 显示在[https://sitemap.mockflow.com](https://sitemap.mockflow.com)上。
- en: 'Upon first examination, three high-level modules emerge as lazy-loading candidates:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次检查时，三个高级模块显现出延迟加载的候选项：
- en: Point of Sale (POS)
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 销售点（POS）
- en: Inventory
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 库存
- en: Manager
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 管理员
- en: Cashier will only have access to the POS module and component. The Clerk will
    only have access to the Inventory module, which will include additional screen
    for Stock Entry, Products, and Categories management components.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 收银员只能访问 POS 模块和组件。店员只能访问库存模块，该模块将包括额外的屏幕，用于库存录入，产品和类别管理组件。
- en: '![](img/b50bc6a5-20a7-4e3a-9944-db949ec9ef40.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b50bc6a5-20a7-4e3a-9944-db949ec9ef40.png)'
- en: Inventory pages
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 库存页面
- en: Finally, the Manager will be able to access all three modules with the Manager
    module, including User management and Receipt lookup components.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，管理员将能够使用管理员模块访问所有三个模块，包括用户管理和收据查找组件。
- en: '![](img/49c79ce6-4bb5-4fba-904b-73f0bc978f3f.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/49c79ce6-4bb5-4fba-904b-73f0bc978f3f.png)'
- en: Manager pages
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 管理员页面
- en: There's a great benefit to enable lazy-loading for all three modules since cashiers
    and clerks will never use components belonging to other user roles, there's no
    reason to send those bytes down to their devices. This means as the Manager module
    gains more advanced reporting features or new roles are added to the application,
    the POS module will be unaffected by the bandwidth and memory impact of an otherwise
    growing application. This means fewer support calls and consistent performance
    on the same hardware for a much longer period of time.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 启用所有三个模块的延迟加载有很大的好处，因为收银员和店员永远不会使用属于其他用户角色的组件，所以没有理由将这些字节发送到他们的设备上。这意味着当管理员模块获得更先进的报告功能或应用程序添加新角色时，POS
    模块将不受应用程序带宽和内存增长的影响。这意味着减少了支持电话，并保持了长时间使用相同硬件的一致性性能。
- en: Generating router-enabled modules
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成经过路由启用的模块
- en: 'Now that we have our high-level components defined as Manager, Inventory, and
    POS, we can define them as modules. These modules will be different from the ones
    you''ve created so far, for routing and Angular Material. We can create the user
    profile as a component on the app module; however, note that user profile will
    only ever be used for already authenticated users, so it makes sense to define
    a fourth module only meant for authenticated users in general. This way, you will
    ensure that your app''s first payload remains as minimal as possible. In addition,
    we will create a Home component to contain the landing experience for our app
    so that we can keep implementation details out of `app.component`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的高级组件——管理员，库存和 POS，我们可以将它们定义为模块。这些模块将与您迄今创建的模块不同，因为它们涉及路由和Angular
    Material。我们可以将用户配置文件创建为应用程序模块上的一个组件；不过请注意，用户配置文件只能供已经经过身份验证的用户使用，因此定义一个仅供一般经过身份验证的用户使用的第四个模块是有意义的。这样，您将确保您的应用程序的第一个有效载荷尽可能保持最小。此外，我们将创建一个主页组件，以包含应用程序的着陆体验，这样我们就可以将实现细节保持在`app.component`之外：
- en: 'Generate `manager`, `inventory`, `pos`, and `user` modules, specifying their
    target module and routing capabilities:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成`manager`，`inventory`，`pos`和`user` 模块，指定它们的目标模块和路由功能：
- en: '[PRE8]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you have configured `npx` to automatically recognize `ng` as a command, you
    can save some more keystrokes so that you won't have to append `npx` to your commands
    every time. Do not globally install `@angular/cli`. Note the abbreviate command
    structure, where `ng generate module manager` becomes `ng g m manager`, and similarly,
    `--module` becomes `-m`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经配置`npx`来自动识别`ng`作为命令，您可以节省更多按键，这样您将不必在每次命令后附加`npx`。不要全局安装`@angular/cli`。请注意缩写命令结构，其中`ng
    generate module manager`变成了`ng g m manager`，同样，`--module`变成了`-m`。
- en: Verify that you don't have CLI errors.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证您的 CLI 是否没有错误。
- en: Note that using `npx` on Windows may encounter an error such as Path must be
    a string. Received undefined. This error doesn't seem to have any effect on the
    successful operation of the command, which is why it is critical to always inspect
    what the CLI tool generated.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在 Windows 上使用`npx`可能会遇到错误，如路径必须是字符串。接收到未定义的错误。这个错误似乎对命令的成功操作没有任何影响，这就是为什么始终检查
    CLI 工具生成的内容是至关重要的。
- en: 'Verify the folder and the files are created:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证已创建的文件夹和文件：
- en: '[PRE9]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Examine how `ManagerModule` has been wired.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`ManagerModule`如何连接。
- en: 'A child module implements an `@NgModule` similar to `app.module`. The biggest
    difference is that a child module does not implement the `bootstrap` property,
    which is required for your root module, to initialize your Angular app:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 子模块实现了类似于 `app.module` 的 `@NgModule`。最大的区别在于，子模块不实现 `bootstrap` 属性，而这个属性对于根模块是必需的，以初始化你的
    Angular 应用程序：
- en: '[PRE10]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Since we have specified the `-m` option, the module has been imported into
    `app.module`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们指定了 `-m` 选项，该模块已经被导入到 `app.module` 中：
- en: '[PRE12]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In addition, because we also specified the `--routing` option, a routing module
    has been created and imported into `ManagerModule`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，因为我们还指定了 `--routing` 选项，一个路由模块已经被创建并导入到 `ManagerModule` 中：
- en: '[PRE13]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that `RouterModule` is being configured using `forChild`, as opposed to `forRoot`,
    which was the case for the `AppRouting` module. This way, the router understands
    the proper relationship between routes defined in different modules' contexts
    and can correctly prepend `/manager` to all child routes in this example.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`RouterModule` 正在使用 `forChild` 进行配置，而不是像 `AppRouting` 模块的情况下使用 `forRoot`。这样，路由器就能理解不同模块上下文中定义的路由之间的正确关系，并且能够在这个示例中正确地在所有子路由之前添加
    `/manager`。
- en: The CLI doesn't respect your `tslint.json` settings. If you have correctly configured
    your VS Code environment with prettier, your Code Styling preferences will be
    applied as you work on each file or, globally, when you run the prettier command.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: CLI 不遵循你的 `tslint.json` 设置。如果你已经正确配置了你的 VS Code 环境，并使用 prettier，那么当你在每个文件上工作时，或者在全局运行
    prettier 命令时，你的代码样式偏好将被应用。
- en: Designing the home route
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计主页路由
- en: 'Consider the following mock-up as the landing experience for LemonMart:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 请将以下模拟作为 LemonMart 的着陆体验考虑：
- en: '![](img/3f5d646c-4efd-4ecb-930c-3f099ff6e0fd.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3f5d646c-4efd-4ecb-930c-3f099ff6e0fd.png)'
- en: LemonMart Landing Experience
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: LemonMart 着陆体验
- en: Unlike the `LocalCastWeather` app, we don't want all this markup to be in the `App`
    component. The `App` component is the root element of your entire application;
    therefore, it should only contain elements that will persistently appear throughout
    your application. In the following annotated mock-up, the toolbar marked as 1
    will be persistent throughout the app.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `LocalCastWeather` 应用程序不同，我们不希望所有这些标记都出现在 `App` 组件中。`App` 组件是整个应用程序的根元素；因此，它应该只包含在整个应用程序中始终出现的元素。在以下带注释的实例中，标记为1的工具栏将在整个应用程序中持续存在。
- en: 'The area marked as 2 will house the home component, which itself will contain
    a login user control, marked as 3:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 标记为2的区域将容纳主页组件，它本身将包含一个登陆用户控件，标记为3：
- en: '![](img/fb7ef832-d649-4970-be2d-d88f0e0f1a51.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fb7ef832-d649-4970-be2d-d88f0e0f1a51.png)'
- en: LemonMart Layout Structure
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: LemonMart 布局结构
- en: 'It is a best practice to create your default or landing component as a separate
    element in Angular. This helps reduce the amount of code that must be loaded and
    logic executed in every page, but it also results in a more flexible architecture
    when utilizing the router:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 将默认或着陆组件作为 Angular 中的单独元素是最佳实践。这有助于减少必须在每个页面加载和执行的代码量，同时在利用路由器时也会产生更灵活的体系结构：
- en: 'Generate the `home` component with inline template and styles:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内联模板和样式生成 `home` 组件：
- en: '[PRE14]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, you are ready to configure the router.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经准备好配置路由器。
- en: Setting up default routes
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置默认路由
- en: 'Let''s get started with setting up a simple route for LemonMart:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始为 LemonMart 设置一个简单的路由：
- en: 'Configure your `home` route:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置你的 `home` 路由：
- en: '[PRE15]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We first define a path for `'home'` and inform the router to render `HomeComponent`
    by setting the component property. Then, we set the default path of the application
    `''` to be redirected to `'/home'`. By setting the `pathMatch` property, we always
    ensure that this very specific instance of the home route will be rendered as
    the landing experience.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先为 `'home'` 定义一个路径，并通过设置组件属性告知路由器渲染 `HomeComponent`。然后，我们将应用程序的默认路径 `''`
    重定向到 `'/home'`。通过设置 `pathMatch` 属性，我们始终确保这个非常特定的主页路由实例将作为着陆体验呈现。
- en: Create a `pageNotFound` component with an inline template
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有内联模板的 `pageNotFound` 组件
- en: 'Configure a wildcard route for `PageNotFoundComponent`:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置 `PageNotFoundComponent` 的通配符路由：
- en: '[PRE16]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This way, any route that is not matched will be directed to the `PageNotFoundComponent`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，任何没有匹配的路由都将被重定向到 `PageNotFoundComponent`。
- en: RouterLink
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RouterLink
- en: 'When a user lands on the `PageNotFoundComponent`, we would like them to be
    redirected to the `HomeComponent` using the `RouterLink` direction:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户登陆到 `PageNotFoundComponent` 时，我们希望他们通过 `RouterLink` 方向重定向到 `HomeComponent`：
- en: 'Implement an inline template to link back to home using `routerLink`:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实施内联模板以使用`routerLink`链接回主页：
- en: '[PRE17]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This navigation can also be done via an `<a href>` tag implementation; however,
    in more dynamic and complicated navigation scenarios, you will lose features such
    as automatic active link tracking or dynamic link generation.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过`<a href>`标签实现此导航；但是，在更动态和复杂的导航场景中，您将失去诸如自动活动链接跟踪或动态链接生成等功能。
- en: The Angular bootstrap process will ensure that `AppComponent` is inside the
    `<app-root>` element in your `index.html`. However, we must manually define where
    we would like `HomeComponent` to render, to finalize the router configuration.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Angular引导流程将确保`AppComponent`在您的`index.html`中的`<app-root>`元素内。但是，我们必须手动定义我们希望`HomeComponent`渲染的位置，以完成路由器配置。
- en: Router outlet
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由器出口
- en: '`AppComponent` is considered a root element for the root router defined in
    `app-routing.module`, which allows us to define outlets within this root element
    to dynamically load any content we wish using the `<router-outlet>` element:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppComponent`被视为`app-routing.module`中定义的根路由的根元素，这使我们能够在这个根元素中定义出口，以使用`<router-outlet>`元素动态加载我们希望的任何内容：'
- en: Configure `AppComponent` to use inline template and styles
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置`AppComponent`以使用内联模板和样式
- en: Add the toolbar for your application
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的应用程序添加工具栏
- en: Add the name of your application as a button link so that it takes the user
    to the home page when clicked on
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的应用程序名称添加为按钮链接，以便在点击时将用户带到主页
- en: 'Add `<router-outlet>` for the content to render:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `<router-outlet>` 以渲染内容：
- en: '[PRE18]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, the contents of home will render inside `<router-outlet>`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，主页的内容将在`<router-outlet>`内渲染。
- en: Branding, Custom, and Material Icons
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 品牌、自定义和Material图标
- en: In order to construct an attractive and intuitive toolbar, we must introduce
    some iconography and branding to the app so that the users can easily navigate
    through the app with the help of familiar icons.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为构建一个吸引人且直观的工具栏，我们必须向应用程序引入一些图标和品牌，以便用户可以轻松地通过熟悉的图标在应用程序中进行导航。
- en: Branding
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 品牌
- en: In terms of branding, you should ensure that your web app should have custom
    color palette and integrate with desktop and mobile browser features to bring
    forward your app's name and iconography.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在品牌方面，您应确保您的Web应用程序应具有自定义调色板，并与桌面和移动浏览器功能集成，以展示您的应用程序名称和图标。
- en: Color palette
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调色板
- en: 'Pick a color palette using the Material Color tool, as discussed in [Chapter
    11](96bc5869-a891-4695-a315-de55d8abc6b8.xhtml), *Enhance Angular App with Angular
    Material*. Here''s the one I picked for LemonMart:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Material Color工具选择一个调色板，如[第11章](96bc5869-a891-4695-a315-de55d8abc6b8.xhtml)，*使用Angular
    Material增强Angular应用程序* 中所述。这是我为LemonMart选择的调色板：
- en: '[PRE19]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Implementing browser manifest and icons
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现浏览器清单和图标
- en: 'You need to ensure that the browser shows the correct title text and icon in
    a Browser tab. Further, a manifest file should be created that implements specific
    icons for various mobile operating systems, so that if a user pins your website,
    a desirable icon is displayed similar to other app icons on a phone. This will
    ensure that if a user favorites or pin your web app on their mobile device''s
    home screen, they''ll get a native-looking app icon:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要确保浏览器在浏览器标签中显示正确的标题文本和图标。此外，应创建一个清单文件，为各种移动操作系统实现特定图标，这样，如果用户将您的网站置为书签，就会显示一个理想的图标，类似于手机上的其他应用图标。这将确保用户在手机设备的主屏幕上收藏或将您的Web应用程序置为书签时可以获得一个原生外观的应用程序图标：
- en: Create or obtain an SVG version of your website's logo from a designer or site
    like [https://www.flaticon.com](https://www.flaticon.com)
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建或从设计师或网站（如[https://www.flaticon.com](https://www.flaticon.com)）获取您网站的标志的SVG版本
- en: 'In this case, I will be using a particular lemon image:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种情况下，我将使用特定的柠檬图片：
- en: '![](img/7728c712-6fd0-4162-ab73-fb7a2d267725.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7728c712-6fd0-4162-ab73-fb7a2d267725.jpg)'
- en: LemonMart's signature logo
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: LemonMart的标志性标识
- en: When using images you find on the internet, pay attention to applicable copyrights.
    In this case, I have purchased a license to be able to publish this lemon logo,
    but you may grab your own copy at the following URL, given that you provide the
    required attribution to the author of the image: [https://www.flaticon.com/free-icon/lemon_605070](https://www.flaticon.com/free-icon/lemon_605070).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用互联网上找到的图像时，请注意适用的版权。在这种情况下，我已经购买了许可证以发布这个柠檬标志，但是您可以在以下URL获得您自己的副本，前提是您向图像的作者提供所需的归属声明：[https://www.flaticon.com/free-icon/lemon_605070](https://www.flaticon.com/free-icon/lemon_605070)。
- en: Generate `favicon.ico` and manifest files using a tool such as [https://realfavicongenerator.net](https://realfavicongenerator.net)
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用[https://realfavicongenerator.net](https://realfavicongenerator.net)等工具生成`favicon.ico`和清单文件
- en: Adjust settings for iOS, Android, Windows Phone, macOS, and Safari to your liking
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据你的喜好调整 iOS、Android、Windows Phone、macOS 和 Safari 的设置
- en: Ensure that you set a version number, favicons can be notorious with caching;
    a random version number will ensure that users always get the latest version
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你设置版本号，网站图标在缓存方面可能让人头疼；一个随机的版本号将确保用户总是得到最新的版本
- en: Download and extract the generated `favicons.zip` file into your `src` folder
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载并解压生成的`favicons.zip`文件到你的`src`文件夹中
- en: 'Edit the `angular.json` file to include the new assets in your app:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`angular.json`文件以在你的应用程序中包括新资源：
- en: '[PRE20]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Insert the generated code in the `<head>` section of your `index.html`:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将生成的代码插入到你的`index.html`的`<head>`部分中：
- en: '[PRE21]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Ensure that your new favicon displays correctly
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你的新网站图标正确显示
- en: To further your branding, consider configuring a custom Material theme and leveraging
    [https://material.io/color](https://material.io/color/)
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步发展你的品牌，考虑配置一个自定义的Material主题并利用[https://material.io/color](https://material.io/color/)
- en: Custom icons
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义图标
- en: 'Now, let''s add your custom branding inside your Angular app. You will need
    the svg icon you used to create your favicon:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在你的Angular应用程序中添加自定义的品牌。你需要用来创建网站图标的 svg 图标：
- en: Place the image under `src/app/assets/img/icons`, named `lemon.svg`
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图片放在`src/app/assets/img/icons`下，命名为`lemon.svg`
- en: Import `HttpClientModule` to `AppComponent` so that the `.svg` file can be requested
    over HTTP
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`HttpClientModule`导入`AppComponent`，以便通过 HTTP 请求`.svg`文件
- en: 'Update `AppComponent` to register the new svg file as an icon:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`AppComponent`以注册新的svg文件为图标：
- en: '[PRE22]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add the icon to the toolbar:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图标添加到工具栏：
- en: '[PRE23]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now let's add the remaining icons for menu, user profile, and logout.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加菜单、用户资料和退出的其余图标。
- en: Material icons
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Material图标
- en: Angular Material works out of the box with Material Design icons, which can
    be imported into your app as a web font in your `index.html`. It is possible to
    self-host the font; however, if you go down that path, you also don't get the
    benefit of the user's browser having already cached the font when they visited
    another website, saving the speed and latency of downloading a 42-56 KB file in
    the process. The complete list of icons can be found at [https://material.io/icons/](https://material.io/icons/).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Angular Material可以与Material Design图标直接使用，可以在你的`index.html`中作为 Web 字体引入你的应用程序。你可以自行托管这个字体；不过，如果选择这条路线，你也无法享受用户在访问其他网站时已经缓存了字体的好处，这就会导致浏览器在下载
    42-56 KB 文件时节省速度和延迟。完整的图标列表可以在[https://material.io/icons/](https://material.io/icons/)找到。
- en: 'Now let''s update the toolbar with some icons and setup the home page with
    a minimal template for a fake login button:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在工具栏上添加一些图标，并为主页设置一个最小的假登录按钮的模板：
- en: 'Ensure Material icons `<link>` tag has been added to `index.html`:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保Material图标的`<link>`标签已经添加到`index.html`中：
- en: '[PRE24]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Instructions on how to self-host can be found under the Self Hosting section
    at [http://google.github.io/material-design-icons/#getting-icons](http://google.github.io/material-design-icons/#getting-icons).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如何自行托管的说明可以在[http://google.github.io/material-design-icons/#getting-icons](http://google.github.io/material-design-icons/#getting-icons)的自行托管部分找到。
- en: Once configured, working with Material icons is easy.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 配置完成后，使用Material图标很容易。
- en: Update the toolbar to place a Menu button to the left of the title.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新工具栏，使菜单按钮位于标题左侧。
- en: Add an `fxFlex` so that the remaining icons are right aligned.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`fxFlex`，使其余图标右对齐。
- en: 'Add user profile and logout icons:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加用户资料和退出图标：
- en: '[PRE25]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add a minimal template for a login:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为登录添加一个最小的模板：
- en: '[PRE26]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Your app should look similar to this screenshot:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序应该看起来与这个截图类似：
- en: '![](img/da684805-2472-4ba0-b4f9-86e3595124b1.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da684805-2472-4ba0-b4f9-86e3595124b1.png)'
- en: LemonMart with minimal login
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 最小登录的LemonMart
- en: There's still some work to be done, in terms of implementing and showing/hiding
    the menu, profile, and logout icons, given the user's authentication status. We
    will cover this functionality in [Chapter 14](c1386d03-1f04-49e0-a623-bc5c64be089c.xhtml),
    *Design Authentication and Authorization*. Now that you've set up basic routing
    for your app, you need to learn how to debug your Angular app before we move on
    to setting up lazily loaded modules with subcomponents.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些工作要做，就是在用户的认证状态下实现和显示/隐藏菜单、资料和退出图标。我们将在 [Chapter 14](c1386d03-1f04-49e0-a623-bc5c64be089c.xhtml)
    *设计认证和授权* 中介绍这个功能。现在你已经为你的应用程序设置了基本路由，需要学会如何调试你的Angular应用程序，然后再进行设置懒加载模块和子组件。
- en: Angular Augury
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular Augury
- en: 'Augury is a Chrome Dev Tools extension for debugging and profiling Angular
    applications. It is a purpose-built tool to help developers visually navigate
    the component tree, inspect the state of the router, and enable break point debugging
    by source-mapping between the generated JavaScript code and the TypeScript code
    that the developer coded in. You can download Augury from [augury.angular.io](http://augury.angular.io).
    Once installed, when you open Chrome Dev Tools for your Angular app, you''ll note
    a new tab for Augury, as illustrated:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Augury 是用于调试和分析 Angular 应用的 Chrome Dev Tools 扩展。这是一个专门为帮助开发人员直观地浏览组件树、检查路由器状态，并通过对开发人员编写的
    TypeScript 代码和生成的 JavaScript 代码进行源映射来启用断点调试的工具。您可以从[augury.angular.io](http://augury.angular.io)下载
    Augury。安装完成后，当您打开 Chrome Dev Tools 查看您的 Angular 应用时，您会注意到一个新的 Augury 选项卡，如下图所示：
- en: '![](img/77a0c9d5-5c32-476d-b2e3-78dbc2c1ab49.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![图3](img/77a0c9d5-5c32-476d-b2e3-78dbc2c1ab49.png)'
- en: Chrome Dev Tools Augury
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome Dev Tools Augury
- en: 'Augury provides useful and critical information in understanding how your Angular
    app is behaving at runtime:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Augury 在理解您的 Angular 应用在运行时的行为方面提供了有用且关键的信息：
- en: Current Angular version is listed, in this case, as version 5.1.2
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当前的 Angular 版本列在此处，例如，版本为 5.1.2
- en: Component Tree
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组件树
- en: Router Tree shows all the routes that have been configured in the app
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 路由器树显示了应用程序中已配置的所有路由
- en: NgModules shows the `AppModule` and Sub-Modules of the app
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: NgModules 显示了应用程序的`AppModule`和子模块
- en: Component Tree
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件树
- en: 'The Component Tree tab shows how all app components are related and how they
    interact with each other:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: “组件树”选项卡显示了所有应用程序组件的关系以及它们如何相互交互：
- en: 'Select a particular component, such as `HomeComponent`, as follows:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择特定的组件，例如`HomeComponent`，如下所示：
- en: '![](img/52ec135a-aa7e-4736-b2d2-d5cbb7b028b7.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图2](img/52ec135a-aa7e-4736-b2d2-d5cbb7b028b7.png)'
- en: Augury Component Tree
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Augury 组件树
- en: The Properties tab on the right-hand side will display a link called View Source,
    which you can use to debug your component. Further below, you will be able to
    observe the state of properties of the component, such as the displayLogin boolean,
    including services that you have injected into the component and their state.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧的“属性”标签页将显示一个名为“查看源代码”的链接，您可以使用它来调试您的组件。在下面更深的位置，您将能够观察到组件的属性状态，例如显示的登录布尔值，以及您注入到组件中的服务及其状态。
- en: You can change the value of any property by double-clicking on the value. For
    example, if you would like to change the value of displayLogin to `false`, simply
    double-click on the blue box that contains the true value and type in false. You
    will be able to observe the effects of your changes in your Angular app.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过双击值来更改任何属性的值。例如，如果您想将`displayLogin`的值更改为`false`，只需双击包含真值的蓝色框，并键入false即可。您将能够观察到您的更改对您的
    Angular 应用的影响。
- en: In order to observe the runtime component hierarchy of `HomeComponent`, you
    can observe the Injector Graph.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 为了观察`HomeComponent`的运行时组件层次结构，您可以观察注入器图。
- en: 'Click on the Injector Graph tab, as shown:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“注入器图”选项卡，如下所示：
- en: '![](img/56a2334d-f80e-447f-8cce-06693543920e.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![图1](img/56a2334d-f80e-447f-8cce-06693543920e.png)'
- en: Augury Injector Graph
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: Augury 注入器图
- en: This view shows how your selected component came to be rendered. In this case,
    we can observe that `HomeComponent` was rendered within `AppComponent`. This visualization
    can be very helpful in tracking down the implementation of a particular component
    in an unfamiliar code base or where a deep component tree exists.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 此视图展示了您选择的组件是如何渲染出来的。在这种情况下，我们可以观察到`HomeComponent`是在`AppComponent`内部渲染的。这种可视化对于追踪陌生代码库中特定组件的实现或存在深层组件树的情况非常有帮助。
- en: Break point debugging
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断点调试
- en: Let me restate, for the record, that `console.log` statements shall never be
    checked in to your repository. In general, they are a waste of your time, because
    it requires editing code and later cleaning up your code. Furthermore, Augury
    already provides the state of your components, so in straightforward cases, you
    should be able to leverage it observe or coerce state.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我再次重申一下，`console.log`语句绝对不应该提交到你的代码库。一般来说，它们只会浪费你的时间，因为这需要编辑代码，之后还得清理你的代码。此外，Augury
    已经提供了组件的状态，所以在简单的情况下，你应该能够利用它来观察或转换状态。
- en: There are some niche use cases, where `console.log` statements can be useful. These
    are mostly asynchronous workflows that operate in parallel and are dependent on
    timely user interaction. In these cases, console logs can help you better understand
    the flow of events and interaction between various components.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 有些特定用例，`console.log`语句可能会很有用。这些大多是操作在并行运行且依赖及时用户交互的异步工作流。在这些情况下，控制台日志可以帮助您更好地理解事件流和各个组件之间的交互。
- en: Augury is not yet sophisticated enough to resolve asynchronous data or data
    returned via functions. There are other common cases, where you would like to
    observe the state of properties as they are being set, and even be able to change
    their values on the fly to force your code to execute branching logic in `if`-`else`
    or `switch` statements. For these cases, you should be using break point debugging.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: Augury还不够复杂，无法解析异步数据或通过函数返回的数据。还有其他常见情况，您可能想观察属性状态在设置时的变化，甚至能够在运行时改变它们的值，以强制代码执行`if`-`else`或`switch`语句的分支逻辑。对于这些情况，您应该使用断点调试。
- en: 'Let''s presume that some basic logic exists on `HomeComponent`, which sets
    a `displayLogin` `boolean`, based on an `isAuthenticated` value retrieved from
    an `AuthService`, as demonstrated:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`HomeComponent`上存在一些基本逻辑，根据从`AuthService`获取的`isAuthenticated`值设置`displayLogin`布尔值，如下所示：
- en: '[PRE27]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now observe the state of the value of `displayLogin` and the `isAuthenticated`
    function as they are being set, then observe the change in the value of `displayLogin`:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在观察`displayLogin`的值和`isAuthenticated`函数在设置时的状态，然后观察`displayLogin`值的变化：
- en: Click on the View Source link on `HomeComponent`
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`HomeComponent`上的查看源链接
- en: Drop a break point on the first line inside the `ngOnInit` function
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ngOnInit`函数内的第一行上放一个断点
- en: Refresh the page
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 刷新页面
- en: 'Chrome Dev Tools will switch over to the Source tab, and you''ll see your break
    point hit, as highlighted in blue here:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Chrome Dev工具将切换到源选项卡，您将看到断点命中并在此处以蓝色突出显示：
- en: '![](img/8e106845-3195-4a27-b870-7846a6d37e01.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e106845-3195-4a27-b870-7846a6d37e01.png)'
- en: Chrome Dev Tools break point debugging
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome Dev工具断点调试
- en: Hover over `this.displayLogin` and observe that its value is set to `true`
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 悬停在`this.displayLogin`上，观察其值已设置为`true`
- en: If hovering over `this.authService.isAuthenticated()`, you will not be able
    to observe its value
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果悬停在`this.authService.isAuthenticated()`上，您将无法观察其值
- en: While your break point is hit, you can access the current scope of the state
    in the console, which means you can execute the function and observe its value.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在断点命中时，您可以在控制台中访问当前范围的状态，这意味着您可以执行函数并观察其值。
- en: 'Execute `isAuthenticated()` in the console:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台中执行`isAuthenticated()`
- en: '[PRE28]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You'll observe that it returns `true`, which is what `this.displayLogin` is
    set to. You can still coerce the value of `displayLogin` in the console.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 您会观察到它返回`true`，这就是`this.displayLogin`的值。您仍然可以在控制台中强制`displayLogin`的值。
- en: 'Set `displayLogin` to `false`:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`displayLogin`设置为`false`
- en: '[PRE29]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If you observe the value of `displayLogin`, either by hovering over it or retrieving
    it from the control, you'll see that the value is set to `false`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果观察`displayLogin`的值，无论是悬停在上面还是从控制台检索，您会看到值被设置为`false`。
- en: Leveraging break point debugging basics, you can debug complicated scenarios
    without changing your source code at all.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 利用断点调试基础知识，您可以在一点也不改变源代码的情况下调试复杂的场景。
- en: Router Tree
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由树
- en: 'The Router Tree tab will display the current state of the router. This can
    be a very helpful tool in visualizing the relationship between routes and components,
    as shown:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 路由树选项卡将显示路由器的当前状态。这可以是一个非常有用的工具，可以直观地展示路由和组件之间的关系，如下所示：
- en: '![](img/122bac61-a7ce-438c-b1a1-36abd2c4044e.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![](img/122bac61-a7ce-438c-b1a1-36abd2c4044e.png)'
- en: Augury Router Tree
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: Augury路由树
- en: The preceding router tree demonstrates a deeply nested routing structure with
    master-detail views. You can see the absolute path and parameters required to
    render a given component by clicking on the circular node.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 上述路由树展示了一个深套的路由结构，带有主细节视图。您可以通过点击圆形节点来看到呈现给定组件所需的绝对路径和参数。
- en: As you can see, for `PersonDetailsComponent`, it can get complicated to determine,
    exactly, the set of parameters needed to render this detail portion of a master-detail
    view.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，对于`PersonDetailsComponent`，确定渲染这个主细节视图的一系列参数可能会变得复杂。
- en: NgModules
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NgModules
- en: 'The NgModules tab displays the `AppModule` and any other submodule that is
    currently loaded into memory:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: NgModules选项卡显示`AppModule`和当前加载到内存中的任何其他子模块：
- en: Launch the `/home` route of the app
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动应用的`/home`路由
- en: 'Observe the NgModules tab, as follows:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察NgModules标签，如下所示：
- en: '![](img/1f7e47e0-937e-41a1-9dd2-1f115597640b.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1f7e47e0-937e-41a1-9dd2-1f115597640b.png)'
- en: Augury NgModules
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: Augury NgModules
- en: You'll note that only the `AppModule` is loaded. However, since our application
    has a lazy-loaded architecture, none of our other modules are yet loaded.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到仅加载了`AppModule`。然而，由于我们的应用程序采用了延迟加载的架构，我们的其他模块尚未被加载。
- en: Navigate to a page in the `ManagerModule`
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`ManagerModule`中的一个页面
- en: Then, navigate to a page in the `UserModule`
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，导航到`UserModule`中的一个页面
- en: Finally, navigate back to the `/home` route
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，导航回`/home`路由
- en: 'Observe the NgModules tab, as shown:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察NgModules标签，如下所示：
- en: '![](img/eb0747c8-e2c8-4467-a657-3e6db3ac2781.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb0747c8-e2c8-4467-a657-3e6db3ac2781.png)'
- en: Augury NgModules with Three Modules
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 带有三个模块的Augury NgModules
- en: Now, you'll observe that three modules have been loaded into memory.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您会观察到已加载进内存的三个模块。
- en: NgModules is an important tool to visualize the impact of your design and architecture.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: NgModules是一个重要的工具，可以可视化设计和架构的影响。
- en: Submodules with lazy loading
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 具有延迟加载的子模块
- en: Lazy loading allows the Angular build process, powered by webpack, to separate
    our web application into different JavaScript files called chunks. By separating
    out portions of the application into separate submodules, we allow these modules
    and their dependencies to be bundled into separate chunks, thus keeping the initial JavaScript
    bundle size to a minimum. As the application grows, the time to first meaningful
    paint remains a constant, instead of consistently increasing over time. Lazy loading
    is critical to achieving a scalable application architecture.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 懒加载允许由 webpack 提供支持的 Angular 构建流程将我们的 Web 应用程序分隔成不同的 JavaScript 文件，称为块。通过将应用程序的各部分分开为单独的子模块，我们允许这些模块及其依赖项捆绑到单独的块中，从而将初始
    JavaScript 捆绑大小保持在最小限度。随着应用程序的增长，首次有意义的呈现时间保持不变，而不是随时间持续增加。懒加载对实现可扩展的应用程序架构至关重要。
- en: We will now go over how to set up a submodule with components and routes. We
    will also use Augury to observe the effects of our various router configurations.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将介绍如何设置带有组件和路由的子模块。我们还将使用Augury来观察我们不同路由配置的效果。
- en: Configuring submodules with components and routes
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置子模块的组件和路由
- en: 'The manager module needs a landing page, as shown in this mock-up:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 管理员模块需要一个着陆页面，如此示意图所示：
- en: '![](img/37bfa672-ea69-4f47-bf18-0d3fb718dfab.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![](img/37bfa672-ea69-4f47-bf18-0d3fb718dfab.png)'
- en: Manager's Dashboard
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 管理员仪表板
- en: 'Let''s start by creating the home screen for the `ManagerModule`:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建`ManagerModule`的主屏幕：
- en: 'Create the `ManagerHome` component:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`ManagerHome`组件：
- en: '[PRE30]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In order to create the new component under the `manager` folder, we must prefix
    `manager/` in front of the component name. In addition, we specify that the component
    should be imported and declared with the `ManagerModule`. Since this is another
    landing page, it is unlikely to be complicated enough to require separate HTML
    and CSS files. You can use `--inline-style` (alias `-s`) and/or `--inline-template`
    (alias `-t`) to avoid creating additional files.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在`manager`文件夹下创建新组件，我们必须在组件名称前加上`manager/`前缀。另外，我们指定该组件应该被`ManagerModule`导入和声明。由于这是另一个着陆页，可能不够复杂需要额外的
    HTML 和 CSS 文件。您可以使用`--inline-style`（别名`-s`）和/或`--inline-template`（别名`-t`）来避免创建额外的文件。
- en: 'Verify that your folder structure looks as follows:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认您的文件夹结构如下所示：
- en: '[PRE31]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Configure the `ManagerHome` component''s route with `manager-routing.module`,
    similar to how we configured the `Home` component with `app-route.module`:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`manager-routing.module`配置`ManagerHome`组件的路由，类似于我们如何使用`app-route.module`配置`Home`组件：
- en: '[PRE32]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You will note that `http://localhost:5000/manager` doesn't actually resolve
    to a component yet, because our Angular app isn't aware that `ManagerModule` exists.
    Let's first try the brute-force, eager-loading approach to import `manager.module`
    and register the manager route with our app.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到`http://localhost:5000/manager`实际上并不解析为一个组件，因为我们的 Angular 应用程序不知道`ManagerModule`的存在。让我们首先尝试蛮力、饥饿加载的方法，导入`manager.module`并在我们的应用程序中注册管理器路由。
- en: Eager loading
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预加载
- en: 'This section is purely an exercise to demonstrate how the concepts we have
    learned so far in importing and registering routes doesn''t result in a scalable
    solution, regardless of eagerly or lazily loading components:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 此部分纯粹是为了演示我们迄今学到的导入和注册路由的概念，并不会产生可扩展的解决方案，无论是急切加载还是懒加载组件：
- en: 'Import the `manager.module` to `app.module`:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`manager.module`导入到`app.module`中：
- en: '[PRE33]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You will note that `http://localhost:5000/manager` still doesn't render its
    home component.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现`http://localhost:5000/manager`仍然不能渲染其主页组件。
- en: 'Use Augury to debug the router state, as shown:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Augury调试路由器状态，如图所示：
- en: '![](img/7ff737cd-253a-4696-8099-e8954525ec07.png)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7ff737cd-253a-4696-8099-e8954525ec07.png)'
- en: Router Tree with Eager Loading
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 带有预加载的路由器树
- en: It seems as if the `/manager` path is correctly registered and pointed at the
    correct component, `ManagerHomeComponent`. The issue here is that the `rootRouter` configured
    in `app-routing.module` isn't aware of the `/manager` path, so the `**` path is
    taking precedence and rendering the `PageNotFoundComponent` instead.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看起来`/manager`路径在正确地注册并指向正确的组件`ManagerHomeComponent`。这里的问题是，在`app-routing.module`中配置的`rootRouter`没有意识到`/manager`路径，所以`**`路径占据优先地位，导致呈现`PageNotFoundComponent`。
- en: 'As a final exercise, implement the `''manager''` path in `app-routing.module`
    and assign `ManagerHomeComponent` to it as you would normally:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后的练习，在`app-routing.module`中实现`'manager'`路径，并像平常一样将`ManagerHomeComponent`指定给它：
- en: '[PRE34]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You'll now note that `http://localhost:5000/manager` renders correctly, by displaying
    `manager-home works!`; however, if you debug the router state through Augury,
    you will note that the `/manager` is registered twice.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你会注意到`http://localhost:5000/manager`正确地渲染，显示`manager-home works!`；然而，如果通过Augury调试路由器状态，你会注意到`/manager`被注册了两次。
- en: This solution doesn't scale well, because it forces all developers to maintain
    a single master file to import and configure every module. It is ripe for merge
    conflicts and frustration, hoping that team members do not register the same route
    multiple times.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案不太可扩展，因为它要求所有开发者维护一个单一的主文件来导入和配置每个模块。这会导致合并冲突和沮丧，希望团队成员不会多次注册相同的路由。
- en: 'It is possible to engineer a solution to divide up the modules into multiple
    files. Instead of the standard `*-routing.module`, you can implement the Route
    array in `manager.module` and export it. Consider the following example:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 可以设计一种解决方案将模块分成多个文件。你可以在`manager.module`中实现Route数组并将其导出，而不是使用标准的`*-routing.module`。考虑以下示例：
- en: '[PRE35]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'These files will then need to be individually imported into `app-routing.module`
    and configured using the `children` attribute:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 然后这些文件需要逐个被导入到`app-routing.module`中，并且使用`children`属性进行配置：
- en: '[PRE36]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This solution will work and it is a correct solution, as demonstrated by the
    Augury Router tree here:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案能够运行，是一个正确的解决方案，就像Augury Router树所展示的那样：
- en: '![](img/076e3b5e-6610-49bf-9327-82e885ce29ce.png)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![](img/076e3b5e-6610-49bf-9327-82e885ce29ce.png)'
- en: Router Tree with children routes
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 带有子路由的路由器树
- en: There are no duplicate registrations, because we removed `manager-routing.module`.
    In addition, we don't have to import `ManagerHomeComponent` outside of `manager.module`,
    resulting in a much better scalable solution. However, as the app grows, we must
    still register modules with `app.module`, and the submodules are still coupled
    to the parent `app.module` in potentially unpredictable ways. Further, this code
    can't be chunked, because any code that is imported using import is viewed as
    a hard dependency.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 没有重复注册，因为我们删除了`manager-routing.module`。此外，我们不必在`manager.module`之外导入`ManagerHomeComponent`，从而得到一个更好的可扩展解决方案。然而，随着应用的增长，我们仍然必须在`app.module`中注册模块，并且子模块仍然与父`app.module`以可能不可预测的方式耦合。此外，这段代码无法被分块，因为使用import导入的任何代码都被视为硬依赖。
- en: Lazy loading
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 懒加载
- en: Now that you understand how eager-loading of modules work, you will be able
    to better understand the code we are about to write, which may otherwise seem
    like black-magic, and magical (aka misunderstood) code always leads to spaghetti
    architectures.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你理解了模块的预加载是如何工作的，你将能更好地理解我们即将编写的代码，否则这些代码可能会看起来像黑魔法一样，并且神秘（也就是被误解的）代码总是导致混乱的架构。
- en: 'We will now evolve the eager-loading solution to be a lazy-loading one. In
    order to load routes from a different module, we know we can''t simply import
    them, otherwise they will be eagerly loaded. The answer lies in configuring a
    route using the `loadChildren` attribute with string informing the Router how
    to load a submodule in `app-routing.module.ts`:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将前面的预加载解决方案演变为懒加载的方式。为了从不同的模块加载路由，我们知道不能简单地导入它们，否则它们将被急切加载。答案就在于在`app-routing.module.ts`中配置路由时使用`loadChildren`属性，并提供字符串告知路由器如何加载子模块：
- en: Ensure that any module you intend to lazy load is *not* imported in ``app.module``
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你打算懒加载的任何模块都*不*被导入到``app.module``中
- en: Remove any routes added to `ManagerModule`
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除`ManagerModule`中添加的任何路由
- en: Ensure that `ManagerRoutingModule` is imported into `ManagerModule`
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保将`ManagerRoutingModule`导入到`ManagerModule`中
- en: 'Implement or update the manager path with the `loadChildren` attribute:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现或更新带有`loadChildren`属性的管理路径：
- en: '[PRE37]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Lazy loading is achieved via a clever trick that avoids using an `import` statement.
    A string literal with two parts is defined, where the first part defines the location
    of the module file, such as `app/manager/manager.module`, and the second part
    defines the class name of the module. A string can be interpreted during the build
    process and at runtime, to dynamically create chunks, load the right module and
    instantiate the correct class. `ManagerModule` then acts as if its own Angular
    app and manages all of its children dependencies and routes.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一个巧妙的技巧实现了惰性加载，避免使用`import`语句。定义了一个由两部分组成的字符串文字，其中第一部分定义了模块文件的位置，如`app/manager/manager.module`，第二部分定义了模块的类名。这样的字符串可以在构建过程和运行时进行解释，以动态创建块，加载正确的模块并实例化正确的类。`ManagerModule`然后就像它自己的Angular应用程序一样，管理着它的所有子依赖项和路由。
- en: 'Update the `manager-routing.module` routes, considering that manager is now
    their root route:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`manager-routing.module`路由，考虑到manager现在是它们的根路由：
- en: '[PRE38]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We can now update the route for `ManagerHomeComponent` to a more meaningful
    `'home'` path. This path won't clash with the one found in `app-routing.module`,
    because in this context, `'home'` resolves to `'manager/home'` and, similarly,
    where path is empty, the URL will look like `http://localhost:5000/manager`.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将`ManagerHomeComponent`的路由更新为更有意义的`'home'`路径。这个路径不会与`app-routing.module`中的路径冲突，因为在这个上下文中，`'home'`解析为`'manager/home'`，同样地，当路径为空时，URL将看起来像`http://localhost:5000/manager`。
- en: 'Confirm that lazy loading is working by looking at Augury, as follows:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过观察Augury确认惰性加载是否正常运行，如下所示：
- en: '![](img/31d5b987-9e37-42c7-a579-988f2dad9381.png)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![](img/31d5b987-9e37-42c7-a579-988f2dad9381.png)'
- en: Router Tree with lazy loading
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 通过惰性加载的路由树
- en: The root node for `ManagerHomeComponent` is now named `manager [Lazy]`.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`ManagerHomeComponent`的根节点现在被命名为`manager [Lazy]`。'
- en: Completing the walking skeleton
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成步行骨架
- en: 'Using the sitemap, we have created for LemonMart, from earlier in the chapter,
    we need to complete the walking skeleton navigation experience for the app. In
    order to create this experience, we will need to create some buttons to link all
    modules and components together. We will go to this module by module:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们在本章早些时候为LemonMart创建的站点地图，我们需要完成应用的步行骨架导航体验。为了创建这种体验，我们需要创建一些按钮来链接所有模块和组件。我们将逐个模块进行：
- en: 'Before we start, update the login button on `home.component` to link to the
    `Manager` module:'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开始之前，更新`home.component`上的登录按钮，将其链接到`Manager`模块：
- en: '[PRE39]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Manager module
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理员模块
- en: Since we already enabled lazy loading for `ManagerModule`, let's go ahead and
    complete the rest of the navigational elements for it.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经为`ManagerModule`启用了惰性加载，让我们继续完成它的其余导航元素。
- en: In the current setup, `ManagerHomeComponent` renders in the `<router-outlet>`
    defined in `app.component`, so when the user navigates from `HomeComponent` to
    `ManagerHomeComponent`, the toolbar implemented in `app.component` remains a constant.
    If we implement a similar toolbar that persists throughout `ManagerModule`, we
    can create a consistent UX for navigating subpages across modules.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前设置中，`ManagerHomeComponent`在`app.component`中定义的`<router-outlet>`中呈现，因此当用户从`HomeComponent`导航到`ManagerHomeComponent`时，`app.component`中实现的工具栏保持不变。如果我们实现一个类似的工具栏，使其在`ManagerModule`中保持不变，我们可以为跨模块导航子页面创建一个一致的用户体验。
- en: 'For this to work, we need to replicate the parent-child relationship between
    `app.component` and `home/home.component`, where the parent implements the toolbar
    and a `<router-outlet>` so that children elements can be rendered in there:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 为实现这一点，我们需要在`app.component`和`home/home.component`之间复制父子关系，其中父级实现了工具栏和一个`<router-outlet>`，以便子元素可以在那里呈现。
- en: 'Start by creating the base `manager` component:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建基本的`manager`组件：
- en: '[PRE40]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `--flat` option skips directory creation and places the component directly
    under the `manager` folder, just like `app.component` residing directly under
    the `app` folder.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '`--flat`选项跳过目录创建，直接将组件放在`manager`文件夹下，就像`app.component`直接放在`app`文件夹下一样。'
- en: 'Implement a navigational toolbar with `activeLink` tracking:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有`activeLink`跟踪的导航工具栏：
- en: '[PRE41]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: It must be noted that submodules don't automatically have access to services
    or components created in parent modules. This is an important default behavior
    to preserve a decoupled architecture. However, there are certain cases where it
    is desirable to share some amount of code. In this case, `mat-toolbar` needs to
    be reimported. Since the `MatToolbarModule` is already loaded in `src/app/material.module.ts`,
    we can just import this module into `manager.module.ts` and there will not be
    a performance or memory penalty for doing so.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 必须注意，子模块不会自动访问父模块创建的服务或组件。这是为了保持解耦的架构的重要默认行为。然而，也有一些情况下希望分享一些代码。在这种情况下，`mat-toolbar`
    需要重新导入。由于 `MatToolbarModule` 已经在 `src/app/material.module.ts` 中加载，我们只需要在 `manager.module.ts`
    中导入这个模块，这样做不会带来性能或内存的损耗。
- en: '`ManagerComponent` should be imported into `ManagerModule`:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ManagerComponent` 应该被引入到 `ManagerModule` 中：'
- en: '[PRE42]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Create components for the subpages:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为子页面创建组件：
- en: '[PRE43]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Create the parent/children routing. We know that we need the following routes
    to be able to navigate to our subpages, as follows:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建父/子路由。我们知道我们需要以下路由才能导航到我们的子页面，如下：
- en: '[PRE44]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In order to target the `<router-outlet>` defined in `manager.component`, we
    need to create a parent route first and then specify routes for the subpages:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定位到在 `manager.component` 中定义的 `<router-outlet>`，我们需要先创建父路由，然后为子页面指定路由：
- en: '[PRE45]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You should now be able to navigate through the app. When you click on the Login
    as Manager button, you will be taken to the page shown here. The clickable targets
    are highlighted, as shown:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该能够浏览整个应用了。当你点击登录为管理者的按钮时，你将被带到这里显示的页面。可点击的目标被高亮显示，如下所示：
- en: '![](img/da476e0e-d0b1-400e-ab4a-bf00c34246fc.png)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da476e0e-d0b1-400e-ab4a-bf00c34246fc.png)'
- en: Manager's Dashboard with clickable targets highlighted
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 带有可点击目标高亮显示的 Manager's Dashboard
- en: If you click on LemonMart, you will be taken to the home page. If you click
    on Manager's Dashboard, User Management or Receipt Lookup, you will be navigated
    to the corresponding subpage, while active link will be bold and underlined on
    the toolbar.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击 LemonMart，你将被带到主页。如果你点击 Manager's Dashboard，User Management 或 Receipt
    Lookup，你将被导航到相应的子页面，同时工具栏上的活动链接将是粗体和下划线。
- en: User module
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户模块
- en: 'Upon login, users will be able to access their profiles and view a list of
    actions they can access in the LemonMart app through a side navigation menu. In
    [Chapter 14](c1386d03-1f04-49e0-a623-bc5c64be089c.xhtml), *Design Authentication
    and Authorization*, when we implement authentication and authorization, we will
    be receiving the role of the user from the server. Based on the role of the user,
    we will be able to automatically navigate or limit the options users can see.
    We will implement these components in this module so that they will only be loaded
    once a user is logged in. For the purpose of completing the walking skeleton,
    we will ignore authentication-related concerns:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，用户将能够通过侧边导航菜单访问他们的个人资料，并查看他们可以在 LemonMart 应用程序中访问的操作列表。在[第14章](c1386d03-1f04-49e0-a623-bc5c64be089c.xhtml)，*设计认证和授权*，当我们实现认证和授权时，我们将从服务器接收到用户的角色。根据用户的角色，我们将能够自动导航或限制用户可以看到的选项。我们将在这个模块中实现这些组件，以便它们只有在用户登录后才被加载。为了完成骨架层，我们将忽略与认证相关的问题：
- en: 'Create the necessary components:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建必要的组件：
- en: '[PRE47]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Implement routing:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现路由：
- en: 'Start with implementing the lazy loading in `app-routing`:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 从在 `app-routing` 中实现延迟加载开始：
- en: '[PRE48]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Ensure that  `PageNotFoundComponent` route is always the last route in `app-routing.module`.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 确保 `PageNotFoundComponent` 路由总是在 `app-routing.module` 中的最后一个路由。
- en: 'Now implement the child routes in `user-routing`:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在 `user-routing` 中实现子路由：
- en: '[PRE49]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We are implementing routing for `NavigationMenuComponent`, because it'll be
    directly used as an HTML element. In addition, since `userModule` doesn't have
    a landing page, there's no default path defined.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在为 `NavigationMenuComponent` 实现路由，因为它将直接被用作 HTML 元素。另外，由于 `userModule` 没有一个登陆页面，没有默认路径定义。
- en: 'Wire up the user and logout icons:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接用户和注销图标：
- en: '[PRE50]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Icon buttons can be cryptic, so it's a good idea to add tooltips to them. In
    order for tooltips to work, switch from the `mat-icon-button` directive to the `mat-mini-fab`
    directive and ensure that you import `MatTooltipModule` in `material.module`.
    In addition, ensure that you add `aria-label` for icon only buttons so that users
    with disabilities relying on screen readers can still navigate your web application.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 图标按钮可能难以理解，因此添加工具提示对它们是个好主意。为了使工具提示正常工作，切换到`mat-mini-fab`指令并确保在`material.module`中导入`MatTooltipModule`，此外，确保为只有图标的按钮添加`aria-label`，这样依赖于屏幕阅读器的残障用户仍然能够浏览您的
    Web 应用。
- en: Ensure that the app works.
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保应用程序正常工作。
- en: 'You''ll note that the two buttons are too close to each other, as follows:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到两个按钮离得太近，如下所示：
- en: '![](img/cb91cc12-4942-4b77-91f3-2140190899b0.png)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cb91cc12-4942-4b77-91f3-2140190899b0.png)'
- en: Toolbar with icons
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 带图标的工具栏
- en: 'You can fix the icon layout issue by adding `fxLayoutGap="8px"` to `<mat-toolbar>`;
    however, now the lemon logo is too far apart from the app name, as shown:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过在`<mat-toolbar>`中添加`fxLayoutGap="8px"`来解决图标布局问题；但是现在柠檬标识离应用名称太远了，如下所示：
- en: '![](img/c3cefbb7-5579-4074-8cb8-1040b0458795.png)'
  id: totrans-416
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c3cefbb7-5579-4074-8cb8-1040b0458795.png)'
- en: Toolbar with padded icons
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 带填充图标的工具栏
- en: 'The logo layout issue can be fixed by merging the icon and the button:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过合并图标和按钮来解决标识布局问题：
- en: '[PRE51]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'As shown in the following screenshot, the grouping fixes the layout issue:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 如下截图所示，分组修复了布局问题：
- en: '![](img/13163991-6945-422d-a9bc-3859d916a9a6.png)'
  id: totrans-421
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13163991-6945-422d-a9bc-3859d916a9a6.png)'
- en: Toolbar with grouped and padded elements
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 带有分组和填充元素的工具栏
- en: This is a more desirable from a UX perspective as well; now users can go back
    to the home page by clicking on the lemon as well.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户体验的角度来看这更加理想；现在用户可以通过点击柠檬回到主页。
- en: POS and inventory modules
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: POS 和库存模块
- en: Our walking skeleton presumes the role of the manager. To be able to access
    all components we are about to create, we need to enable the manager to be able
    to access pos and inventory modules.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的基本架构假定经理的角色。为了能够访问我们即将创建的所有组件，我们需要使经理能够访问 POS 和库存模块。
- en: 'Update `ManagerComponent` with two new buttons:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 使用两个新按钮更新`ManagerComponent`：
- en: '[PRE52]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note that these router links will navigate use out of `ManagerModule`, so it
    is normal for the toolbar to disappear.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些路由链接将导航我们离开`ManagerModule`，因此工具栏消失是正常的。
- en: Now, it'll be up to you to implement the last two remaining modules.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由您来实现最后的两个模块。
- en: POS module
  id: totrans-430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: POS 模块
- en: 'POS module is very similar to the user module, except that `PosComponent` will
    be the default route. This will be a complicated component with some subcomponents,
    so ensure that it is created with a directory:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: POS 模块与用户模块非常相似，除了`PosComponent`将成为默认路由。这将是一个复杂的组件，带有一些子组件，因此确保它是通过目录创建的：
- en: Create the `PosComponent`
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`PosComponent`
- en: Register `PosComponent` as the default route
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册`PosComponent`作为默认路由
- en: Configure lazy loading for `PosModule`
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置`PosModule`的懒加载
- en: Ensure that the app works
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保应用程序正常工作
- en: Inventory module
  id: totrans-436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 库存模块
- en: 'Inventory module is very similar to `ManagerModule`, as shown:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 库存模块与`ManagerModule`非常相似，如下所示：
- en: '![](img/accdce61-5a0f-4140-ba5a-0ecd8e79d133.png)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![](img/accdce61-5a0f-4140-ba5a-0ecd8e79d133.png)'
- en: Inventory Dashboard mock-up
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 库存仪表板模拟
- en: Create a base `Inventory` component
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建基本的`Inventory`组件
- en: Register the `MaterialModule`
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册`MaterialModule`
- en: Create Inventory Dashboard, Stock Entry, Products, and Categories components
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建库存仪表板、库存录入、产品和类别组件
- en: Configure parent-children routes in `inventory-routing.module`
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`inventory-routing.module`中配置父子路由
- en: Configure lazy loading for ``InventoryModule``
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置`InventoryModule`的懒加载
- en: 'Ensure that app works, as shown:'
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保应用程序正常工作，如下所示：
- en: '![](img/520d2c6b-4597-4ccf-a386-8e444457afa9.png)'
  id: totrans-446
  prefs: []
  type: TYPE_IMG
  zh: '![](img/520d2c6b-4597-4ccf-a386-8e444457afa9.png)'
- en: LemonMart Inventory Dashboard
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: LemonMart 库存仪表板
- en: Now that the walking skeleton of the app is completed, it is important to inspect
    the router tree to ensure that lazy loading has been configured correctly and
    module aren't unintentionally being eager loaded.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用程序的基本架构已经完成，检查路由树以确保懒加载已正确配置，并且模块不会被意外急加载是非常重要的。
- en: Inspect router tree
  id: totrans-449
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查路由树
- en: 'Navigate to the base route of the app and use Augury to inspect the router
    tree, as illustrated:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 转到应用程序的基本路由，并使用 Augury 检查路由树，如图所示：
- en: '![](img/30f96a6d-a4c2-42fc-8235-c5a800e074db.png)'
  id: totrans-451
  prefs: []
  type: TYPE_IMG
  zh: '![](img/30f96a6d-a4c2-42fc-8235-c5a800e074db.png)'
- en: Router Tree with eager loading mistakes
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 路由树与急加载错误
- en: Everything, but initially required components, should be denoted with the [Lazy]
    attribute. If, for some reason, routes are not denoted with [Lazy], chances are
    that they are mistakenly being imported in `app.module` or some other component.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 一切，除了最初需要的组件，应该带有[Lazy]属性。 如果由于某种原因，路由未带有[Lazy]标记，那么它们可能被错误地导入到`app.module`或其他某个组件中。
- en: In the preceding screenshot, you may note that `ProfileComponent` and `LogoutComponent`
    are eagerly loaded, whereas the `user` module is correctly labeled as [Lazy].
    Even multiple visual inspections through the tooling and the code base may leave
    you searching for the culprit. However, if you run a global search for `UserModule`,
    you'll quickly discover that it was being imported into `app.module`.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述截图中，您可能会注意到`ProfileComponent`和`LogoutComponent`是急加载的，而`user`模块正确地标记为[Lazy]。
    即使通过工具和代码基础进行多次视觉检查，也可能让您一直寻找问题所在。 但是，如果全局搜索`UserModule`，您将很快发现它正在被导入到`app.module`中。
- en: 'To be on the safe side make sure to remove any import statements for modules
    in `app.module` and your file should look like the one below:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保险起见，请确保删除`app.module`中的任何模块导入语句，您的文件应该像下面这样：
- en: '[PRE53]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The next screenshot shows the corrected router tree:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 下一张截图展示了更正后的路由树：
- en: '![](img/87fb2c48-5d43-48d6-bf92-c48c0346a9e0.png)'
  id: totrans-458
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87fb2c48-5d43-48d6-bf92-c48c0346a9e0.png)'
- en: Router Tree with lazy loading
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 带有延迟加载的路由树
- en: Ensure that `npm test` and `npm run e2e` executes without errors before moving
    on.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续前进之前，请确保`npm test`和`npm run e2e`执行时没有错误。
- en: Common Testing Module
  id: totrans-461
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用测试模块
- en: Now that we have a lot of modules to deal with, it becomes tedious to configure
    the imports and providers for each spec file individually. For this purpose, I
    recommend creating a common testing module to contain generic configuration that
    you can reuse across the board.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有大量的模块要处理，为每个规范文件单独配置导入和提供者变得乏味。 为此，我建议创建一个通用的测试模块，其中包含可以在整个项目中重用的通用配置。
- en: First start by creating a new `.ts` file.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个新的`.ts`文件。
- en: Create `common/common.testing.ts`
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`common/common.testing.ts`
- en: 'Populate it with common testing providers, fakes and modules, shown as follows:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用常见的测试提供程序、伪造品和模块填充，如下所示：
- en: I have provided fake implementations of `ObservableMedia`, `MatIconRegistry`,
    `DomSanitizer`, along with arrays for `commonTestingProviders` and `commonTestingModules`.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 我提供了`ObservableMedia`、`MatIconRegistry`、`DomSanitizer`的伪造实现，以及`commonTestingProviders`和`commonTestingModules`的数组。
- en: '[PRE54]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now let''s see a sample use of this shared configuration file:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何使用共享配置文件的示例：
- en: '[PRE55]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Most other modules will just need `commonTestingModules` to be imported.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数其他模块只需导入`commonTestingModules`即可。
- en: Don't move on until all your tests are passing!
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有测试通过之前，请不要继续前进！
- en: Summary
  id: totrans-472
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you mastered how to effectively use Angular CLI to create major
    Angular components and scaffolds. You created the branding of your app, leveraging
    custom and built-in Material iconography. You learned how to debug complicated
    Angular apps with Augury. Finally, you began building Router-first apps, defining
    user roles early on, designing with lazy loading in mind and nailing down a walking-skeleton
    navigation experience early on.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学会了如何有效地使用Angular CLI创建主要的Angular组件和脚手架。 您创建了应用程序的品牌，利用自定义和内置Material图标。
    您学会了如何使用Augury调试复杂的Angular应用程序。 最后，您开始构建基于路由的应用程序，及早定义用户角色，设计时考虑懒加载，并及早确定行为骨架导航体验。
- en: 'To recap, in order to pull off a Router-first implementation, you need to do
    this:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，为了完成基于路由的实现，您需要执行以下操作：
- en: Define user roles early on
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 早期定义用户角色
- en: Design with lazy loading in mind
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计时考虑懒加载
- en: Implement a walking-skeleton navigation experience
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现行为骨架导航体验
- en: Design around major data components
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 围绕主要数据组件进行设计
- en: Enforce a decoupled component architecture
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 强制执行解耦的组件架构
- en: Differentiate between user controls and components
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 区分用户控件和组件
- en: Maximize code reuse
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最大化代码重用
- en: In this chapter, you executed steps 1-3; in the next three chapters, you will
    execute steps 4-7\. In [Chapter 13](215237a5-318b-4de2-82a8-4e40e438b228.xhtml),
    *Continuous Integration and API Design, *we will go over designing around major
    data components and enable Continuous Integration to ensure a high-quality deliverable.
    In [Chapter 14](c1386d03-1f04-49e0-a623-bc5c64be089c.xhtml), *Design Authentication
    and Authorization*, we will deep dive into security considerations and design
    a conditional navigation experience. In [Chapter 15](3da8e826-b070-415b-b3ce-d535358db5de.xhtml),
    *Angular App Design and Recipes*, we will tie everything together by sticking
    to a decoupled component architecture, smartly choosing between creating user
    controls versus components and maximizing code reuse with various TypeScript,
    RxJS, and Angular coding techniques.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您执行了步骤1-3；在接下来的三章中，您将执行步骤4-7。在[第13章](215237a5-318b-4de2-82a8-4e40e438b228.xhtml)中，*持续集成和API设计*，我们将讨论围绕主要数据组件进行设计，并实现持续集成以确保高质量的交付。在[第14章](c1386d03-1f04-49e0-a623-bc5c64be089c.xhtml)中，*设计身份验证和授权*，我们将深入探讨安全考虑因素，并设计有条件的导航体验。在[第15章](3da8e826-b070-415b-b3ce-d535358db5de.xhtml)中，*Angular应用设计和配方*，我们将通过坚持解耦组件架构，巧妙选择创建用户控件与组件，并利用各种TypeScript、RxJS和Angular编码技术来最大程度地重用代码，将所有内容紧密结合在一起。
