- en: Building the Multitrack Player
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建多轨道播放器
- en: We've made it to the keystone of NativeScript development: Direct access to Objective-C/Swift
    APIs on iOS and Java APIs on Android via TypeScript.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到达了NativeScript开发的关键点：通过TypeScript直接访问iOS上的Objective-C/Swift API和Android上的Java
    API。
- en: This is, by far, one of the most unique aspects of NativeScript and opens up
    many opportunities to you as a mobile developer. In particular, our app is going
    to need to take advantage of rich native audio APIs on both iOS and Android to
    achieve its core competency of delivering a compelling multitrack recording/mixing
    experience to our users.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝对是NativeScript最独特的方面之一，为移动开发者打开了许多机会。特别是，我们的应用将需要充分利用iOS和Android上丰富的本地音频API，以实现其核心竞争力，为用户提供引人入胜的多轨录音/混音体验。
- en: Understanding how to code against these APIs will be essential to unlocking
    your mobile app's full potential. Additionally, learning how to integrate existing
    NativeScript plugins, which may already provide consistent APIs on both iOS and
    Android, can help you reach your goals even faster. Leveraging the best performance
    each platform can deliver will be the focus of our journey in Part 3.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何针对这些API进行编码将是解锁您的移动应用的全部潜力所必不可少。此外，学习如何集成现有的NativeScript插件，这些插件可能已经在iOS和Android上提供了一致的API，可以帮助您更快地实现目标。利用每个平台可以提供的最佳性能将是我们在第三部分旅程的重点。
- en: 'In this chapter, we will cover the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Integrating the Nativescript-audio plugin
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成Nativescript-audio插件
- en: Creating a model for our track player for future scalability
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的轨道播放器创建一个模型，以便未来扩展
- en: Working with RxJS observables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RxJS可观察对象
- en: Understanding Angular's NgZone with third-party libraries and view bindings
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Angular的NgZone与第三方库和视图绑定
- en: Handling audio playback sync with multiple audio sources
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理多个音频源的音频播放同步
- en: Taking advantage of Angular's bindings, as well as NativeScript's native event
    bindings, to achieve the exact usability we're after
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用Angular的绑定，以及NativeScript的本地事件绑定，实现我们所追求的精确可用性
- en: Building a custom shuttle slider for our player controls using Angular platform-specific
    directives
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Angular平台特定指令为我们的播放器控件构建自定义快进滑块
- en: Implementing our multitrack player via the nativescript-audio plugin
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过nativescript-audio插件实现我们的多轨道播放器
- en: Luckily, the NativeScript community has published a plugin that provides us
    with a consistent API to use across both iOS and Android to get going with an
    audio player. Feel free to browse [http://plugins.nativescript.org](http://plugins.nativescript.org), *the
    official source for NativeScript plugins,* before implementing features, in order to
    determine if an existing plugin may work for your project.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，NativeScript社区发布了一个插件，为我们提供了一个一致的API，可以在iOS和Android上使用，以启动音频播放器。在实施功能之前，可以随意浏览[http://plugins.nativescript.org](http://plugins.nativescript.org)，*这是NativeScript插件的官方来源*，以确定现有插件是否适用于您的项目。
- en: 'In this case, the **nativescript-audio** plugin found at [http://plugins.nativescript.org/plugin/nativescript-
    audio](http://plugins.nativescript.org/plugin/nativescript-audio) contains what
    we need to start integrating the player portion of our app''s features, and it
    works on both iOS and Android. *It even provides a recorder we may be able to
    use*. Let''s start by installing it:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，**nativescript-audio**插件位于[http://plugins.nativescript.org/plugin/nativescript-audio](http://plugins.nativescript.org/plugin/nativescript-audio)，其中包含了我们开始集成应用程序功能的播放器部分所需的内容，并且可以在iOS和Android上运行。*它甚至提供了一个我们可能可以使用的录音机*。让我们开始安装它：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The NativeScript framework allows you to integrate with any npm module, opening
    up a dizzying array of integration possibilities, including NativeScript specific
    plugins. In fact, if you ever run into a situation where an npm module is giving
    you trouble (perhaps, because it relies on a node API not compatible in the NativeScript
    environment), there's even a plugin to help you deal with that at [https://www.npmjs.com/package/nativescript-nodeify](https://www.npmjs.com/package/nativescript-nodeify).
    It is described in detail at [https://www.nativescript.org/blog/how-to-use-any-npm-module-with-nativescript](https://www.nativescript.org/blog/how-to-use-any-npm-module-with-nativescript).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: NativeScript框架允许您集成任何npm模块，打开了令人眼花缭乱的集成可能性，包括NativeScript特定的插件。实际上，如果您遇到npm模块给您带来麻烦的情况（也许是因为它依赖于NativeScript环境中不兼容的node
    API），甚至有一个插件可以帮助您处理这个问题：[https://www.npmjs.com/package/nativescript-nodeify](https://www.npmjs.com/package/nativescript-nodeify)。详细描述在[https://www.nativescript.org/blog/how-to-use-any-npm-module-with-nativescript](https://www.nativescript.org/blog/how-to-use-any-npm-module-with-nativescript)。
- en: Whenever integrating with a NativeScript plugin, create a model or Angular service
    around its integration to provide isolation around that integration point.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 每当与NativeScript插件集成时，创建一个模型或Angular服务，围绕其集成提供隔离。
- en: '**Try to isolate third-party plugin integration points by creating a reusable
    model or Angular service around that plugin**. This will not only provide your
    app with nice scalability into the future, but will give you more flexibility
    down the road if you need to swap that plugin out with something different and/or
    provide different implementations on iOS or Android.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**尝试通过创建可重用的模型或Angular服务来隔离第三方插件的集成点**。这不仅会为您的应用程序提供良好的可扩展性，而且在将来如果需要用不同的插件替换它或在iOS或Android上提供不同的实现时，还会为您提供更多的灵活性。'
- en: Building the TrackPlayerModel for our multitrack player
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的多音轨播放器构建TrackPlayerModel。
- en: We need each track to have its own instance of an audio player, as well as to
    expose an API to load the track's audio file. This will also provide a good place
    to expose the track's duration once the audio file is loaded.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要每个音轨都有自己的音频播放器实例，并公开一个API来加载音轨的音频文件。这也将是一个很好的地方，在音频文件加载后公开音轨的持续时间。
- en: 'Since this model will likely be shared across the entire app (foreseeably with
    recording playback in the future as well), we will create this with our other
    models in `app/modules/shared/models/track-player.model.ts`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个模型很可能会在整个应用程序中共享（预计将来还会有录音播放），我们将与我们的其他模型一起创建在`app/modules/shared/models/track-player.model.ts`中：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We start by importing the sweet NativeScript community audio player `TNSPlayer`
    from the `nativescript- audio` plugin. We then define a simple interface to implement
    for our model which, will reference `trackId`, its `duration`, and a `readonly`
    getter for the `player` instance. Then, we include that interface to use with
    our implementation, which constructs an instance of `TNSPlayer` with itself. Since
    we want a flexible model that can load its track file at any time, we provide
    a `load` method taking `ITrack` that utilizes the `initFromFile` method. This,
    in turn, asynchronously fetches the track's total duration (returned as a string,
    so we use `+duration`) to store the number on the model before resolving the track's
    initialization completes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从`nativescript-audio`插件中导入甜美的NativeScript社区音频播放器`TNSPlayer`。然后，我们定义一个简单的接口来实现我们的模型，它将引用`trackId`，它的`duration`，以及`player`实例的`readonly`
    getter。然后，我们包括该接口以与我们的实现一起使用，该实现使用自身构造了`TNSPlayer`的实例。由于我们希望一个灵活的模型可以随时加载其音轨文件，我们提供了一个接受`ITrack`的`load`方法，该方法利用`initFromFile`方法。这反过来会异步获取音轨的总持续时间（以字符串形式返回，因此我们使用`+duration`）来存储模型上的数字，然后解析音轨的初始化完成。
- en: 'For consistency and standards, just be sure to also export this new model from
    `app/modules/shared/models/index.ts`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了一致性和标准，确保还要从`app/modules/shared/models/index.ts`导出这个新模型：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Lastly, we provide a getter for the player instance that `PlayerService` will
    use. This brings us to our next step: open `app/modules/player/services/player.service.ts`.
    We are going to change up our initial implementation a bit with our latest developments;
    have a look at this in totality and we will explain afterward:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们为播放器实例提供一个getter，`PlayerService`将使用它。这将引导我们迈出下一步：打开`app/modules/player/services/player.service.ts`。我们将根据最新的开发情况稍微改变我们的初始实现；全面查看后，我们将在此之后解释：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The cornerstone of `PlayerService` at this point is to not only manage the
    hard work of playing multiple tracks in the mix, but to provide a state, which
    our views can observe to reflect the composition''s state. Hence, we have the
    following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此时`PlayerService`的基石不仅是管理混音中播放多个曲目的艰苦工作，而且提供一个状态，我们的视图可以观察以反映组合的状态。因此，我们有以下内容：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Our view will need to know the playing state as well as `duration` and `currentTime`.
    Using `Subject` for the `playing$` and `duration$` states will work well, since
    they are as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的视图还需要知道播放状态以及“持续时间”和“当前时间”。对于`playing$`和`duration$`状态，使用`Subject`将很好地工作，因为它们如下：
- en: They can emit values directly
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以直接发出值
- en: They don't need to emit an initial value
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不需要发出初始值
- en: They don't need any observable composition
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不需要任何可观察的组合
- en: On the other hand, `currentTime$` is going to be set up with some composition
    in mind, since its value will be dependent on an intermittent state that may develop
    over time (more on this shortly!). In other words, the `playing$` state is a value
    we control and emit directly via play actions made by the user (or internally
    based on player state) and the `duration$` state is a value we emit directly as
    a result of all our track's players becoming initialized and ready**. **
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`currentTime$`将根据一些组合设置，因为它的值将取决于随时间可能发展的间歇状态（稍后详细介绍！）。换句话说，`playing$`状态是我们通过用户的播放操作（或基于播放器状态的内部操作）直接控制和发出的值，而`duration$`状态是我们直接作为所有曲目播放器初始化和准备就绪的结果发出的值**。**
- en: '`currentTime` is a value that the player does not emit automatically via a
    player event but rather a value we must check for intermittently. Therefore, we
    compose `Observable.interval(1000)` that will auto emit our mapped value representing
    the longest track''s player instance''s actual `currentTime` every 1 second upon
    its subscription.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`currentTime`是播放器不会自动通过播放器事件发出的值，而是我们必须间歇性地检查的值。因此，我们组合`Observable.interval(1000)`，它将在订阅时每1秒自动发出我们映射的值，表示最长曲目播放器实际的`currentTime`。'
- en: The other `private` references help maintain the internal state for the service's
    use. Most interestingly, we will keep a reference to `_longestTrack`, since our
    composition's total duration will always be based on the longest track and, hence,
    will also be used to track `currentTime`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 其他“私有”引用帮助维护服务的内部状态。最有趣的是，我们将保留对“_longestTrack”的引用，因为我们的组合总持续时间将始终基于最长的曲目，并且也将用于跟踪“currentTime”。
- en: This set up will provide the essentials of what our view will need to suffice
    proper user interaction.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设置将提供我们的视图需要的基本内容以满足适当的用户交互。
- en: '*RxJS does not include any operators by default. Therefore, `Observable.interval(1000)`
    and `.map` will crash your app right now if you are to run it!*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*RxJS默认不包含任何操作符。因此，如果你现在运行`Observable.interval(1000)`和`.map`，你的应用程序将崩溃！*'
- en: The minute you start working more with RxJS, it's a good idea to create an `operators.ts`
    file to import all your RxJS operators into. Then, import that file in your root
    `AppComponent`, so you don't end up with those operator imports scattered everywhere
    throughout your codebase.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您开始更多地使用RxJS，最好创建一个`operators.ts`文件来将所有RxJS操作符导入其中。然后，在根`AppComponent`中导入该文件，这样您就不会在整个代码库中到处散布这些操作符导入。
- en: 'Create `app/operators.ts` with the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`app/operators.ts`，内容如下：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, open `app/app.component.ts` and import that file on the very first line:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，打开`app/app.component.ts`并在第一行导入该文件：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, we are free to use map, interval, and any other `rxjs` operators we need
    anywhere in our code, provided we import them into that single file.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以自由地在代码的任何地方使用map、interval和任何其他`rxjs`操作符，只要我们将它们导入到那个单一的文件中。
- en: 'The next bit of our service is rather self-explanatory:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们服务的下一部分相当不言自明：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Our `playing` setter ensures that the internal state, `_playing`, is updated,
    as well as our `playing$` subject''s value emitted for any subscribers needing
    to react to this state change. Convenient getters are also added for good measure.
    The next setter for our composition gets rather interesting, as this is where
    we interact with our new `TrackPlayerModel`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`playing`设置器确保内部状态`_playing`得到更新，并且我们的`playing$`主题的值被发出，以便任何需要对此状态变化做出反应的订阅者。为了保险起见，还添加了方便的获取器。我们合成的下一个设置器变得相当有趣，因为这是我们与新的`TrackPlayerModel`进行交互的地方：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Whenever we set the active composition, we first ensure our service''s internal
    `_trackPlayers` reference is properly cleaned up and cleared with `this._resetTrackPlayers()`.
    We then set up a local method `initTrackPlayer` that can be called iteratively,
    given the async nature of each player''s `load` method to ensure each track''s
    player is properly loaded with the audio file, including its duration. After each
    successful load, we add to our collection of `_trackPlayers`, iterate, and continue
    until all the audio files are loaded. When complete, we call `this._updateTotalDuration()`
    to determine the final duration of our composition of tracks:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们设置活动合成时，我们首先确保我们服务的内部`_trackPlayers`引用被正确清理和清除`this._resetTrackPlayers()`。然后设置一个本地方法`initTrackPlayer`，可以被迭代调用，考虑到每个播放器的`load`方法的异步性，以确保每个曲目的播放器都正确加载了音频文件，包括其持续时间。在每次成功加载后，我们将添加到我们的`_trackPlayers`集合中，进行迭代，并继续，直到所有音频文件都加载完成。完成后，我们调用`this._updateTotalDuration()`来确定我们曲目合成的最终持续时间：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Since the track with the longest duration should always be used to determine
    the total duration of the entire composition, we use `Math.max` to determine what
    the longest duration is and then store a reference to the track. Because multiple
    tracks could have the same duration, it doesn't really matter which track is used,
    just as long as one matches the longest duration. This `_longestTrack` will be
    our *pace setter* if you will, as it will be used to determine `currentTime` of
    the entire composition. Lastly, we emit the longest duration as `totalDuration`
    via our `duration$` subject for any subscribing observers.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于具有最长持续时间的曲目应始终用于确定整个合成的总持续时间，我们使用`Math.max`来确定最长持续时间，然后存储对曲目的引用。因为多个曲目可能具有相同的持续时间，所以使用哪个曲目并不重要，只要有一个与最长持续时间匹配即可。这个`_longestTrack`将是我们的“节奏设置者”，因为它将用于确定整个合成的`currentTime`。最后，我们通过我们的`duration$`主题将最长持续时间作为`totalDuration`发出给任何订阅观察者。
- en: 'The next couple of methods provide the basis of our composition''s overall
    playback control:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几种方法提供了我们合成的整体播放控制的基础：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Our primary play button in our UI will use the `togglePlay` method to control
    playback and, hence, is used to toggle the internal state as well as engage all
    the track player's play or pause methods.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们UI中的主要播放按钮将使用`togglePlay`方法来控制播放，因此也用于切换内部状态以及启用所有音轨播放器的播放或暂停方法。
- en: Let the music play!
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让音乐播放！
- en: To try all this out, let's add three sample audio files from a jazz track composed
    by the exquisite *Jesper Buhl Trio* called *What Is This Thing Called Love*. The
    tracks are already separated by drums, bass, and piano. We can add these `.mp3`
    files to an `app/audio` folder.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尝试所有这些，让我们从由精美的*Jesper Buhl Trio*创作的爵士乐曲*What Is This Thing Called Love*中添加三个示例音频文件。这些音轨已经分为鼓、贝斯和钢琴。我们可以将这些`.mp3`文件添加到`app/audio`文件夹中。
- en: 'Let''s modify our demo composition''s tracks in `MixerService` to provide references
    to these new real audio files. Open `app/modules/mixer/services/mixer.service.ts`
    and make the following modifications:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改`MixerService`中演示曲目的音轨，以提供对这些新的真实音频文件的引用。打开`app/modules/mixer/services/mixer.service.ts`并进行以下修改：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s now provide an input to our player controls, which will take our selected
    composition. Open `app/modules/mixer/components/mixer.component.html`, and make
    the following highlighted modification:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为我们的播放控件提供一个输入，它将接受我们选择的组合。打开`app/modules/mixer/components/mixer.component.html`，并进行以下突出显示的修改：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, in `PlayerControlsComponent` at `app/modules/player/components/player-
    controls/player-controls.component.ts`, we can now observe the state of `PlayerService` via
    its various observables:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`app/modules/player/components/player-controls/player-controls.component.ts`中的`PlayerControlsComponent`中，我们现在可以通过其各种可观察对象观察`PlayerService`的状态：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The cornerstone of `PlayerControlComponent` is now its ability to set the active
    composition via `this.playerService.composition = this.composition` inside `ngOnInit`,
    which is when the composition input is ready, as well as subscribe to the various
    states provided by `PlayerService` to update our UI. Most interesting here is
    the `playing$` subscription that manages the `currentTime$` subscription based
    on whether it''s playing or not. If you recall, our `currentTime$` observable
    started with `Observable.interval(1000)`, meaning every one second, it will emit
    the longest track''s `currentTime`, shown here again for reference:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayerControlComponent`的基石现在是通过`this.playerService.composition = this.composition`在`ngOnInit`中设置活动组合的能力，这是在准备好组合输入时，以及订阅`PlayerService`提供的各种状态来更新我们的UI。这里最有趣的是`playing$`订阅，它根据是否正在播放来管理`currentTime$`的订阅。如果您还记得，我们的`currentTime$`可观察对象以`Observable.interval(1000)`开始，这意味着每一秒它将发出最长音轨的`currentTime`，这里再次显示供参考：'
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We only want to update `currentTime` of `Slider` when playback is engaged; hence,
    the subscription when the `playing$` subject emit is `true`, which will allow
    our component to receive the player's `currentTime` every second. When `playing$`
    emit is `false`, we unsubscribe, to no longer receive the `currentTime` updates.
    Excellent.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只想在播放时更新`Slider`的`currentTime`；因此，当`playing$`主题发出`true`时，我们订阅，这将允许我们的组件每秒接收播放器的`currentTime`。当`playing$`发出`false`时，我们取消订阅，不再接收`currentTime`的更新。太棒了。
- en: We also subscribe to our `duration$` subject to update the Slider's maxValue.
    Lastly, we ensure all subscriptions are cleaned up via their `Subscription` references
    inside `ngOnDestroy`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还订阅了我们的`duration$`主题以更新Slider的最大值。最后，我们通过它们在`ngOnDestroy`中的`Subscription`引用确保所有订阅都被清理。
- en: 'Let''s take a look at our view bindings now for `PlayerControlsComponent` at
    `app/modules/player/components/player-controls/player-controls.component.html`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看`app/modules/player/components/player-controls/player-controls.component.html`中`PlayerControlsComponent`的视图绑定：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If you run the app, you can now select the Demo composition and play music on
    both iOS and Android.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行该应用程序，现在可以在iOS和Android上选择演示曲目并播放音乐。
- en: '*MUSIC TO OUR EARS! This is pretty awesome. In fact, it''s friggin'' sweet!!*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*音乐到我们的耳朵！这相当棒。事实上，它非常棒！*'
- en: 'There are a couple things you may notice or desire at this point:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您可能会注意到或希望有一些事情：
- en: After choosing the Play button, it properly changes to Stop, but when playback
    reaches the end, it does not return to its original Play text.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择播放按钮后，它会正确地变为停止，但当播放到末尾时，它不会返回到原来的播放文本。
- en: '`Slider` should also return to position 0 to reset playback.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “滑块”也应该返回到位置0以重置播放。
- en: The total `duration` and `currentTime` on iOS uses seconds; however, Android
    uses milliseconds.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iOS上的总“持续时间”和“当前时间”使用秒；然而，Android使用毫秒。
- en: On iOS, you may notice a very subtle playback sync issue on all the tracks if
    you choose to play/pause many times during the playback of the composition's demo
    tracks.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在iOS上，如果您选择在演奏作品的演示曲目播放期间多次播放/暂停，您可能会注意到所有曲目上都有一个非常微妙的播放同步问题。
- en: The current time and duration labels are needed.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要当前时间和持续时间标签。
- en: '**Playback seeking** would be nice to be able to shuttle our slider to control
    the position of playback.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**播放搜索**很好能够使用滑块来控制播放位置。'
- en: Polishing the implementation
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完善实现
- en: 'We''re missing a few important pieces in our model and service to really polish
    off our implementation. Let''s start with handling completion and error conditions
    with our track player instances. Open `TrackPlayerModel` at `app/modules/shared/models/track-player.model.ts` and
    add the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模型和服务中缺少一些重要的部分，以真正完善我们的实现。让我们从处理曲目播放器实例的完成和错误条件开始。打开`app/modules/shared/models/track-player.model.ts`中的`TrackPlayerModel`，并添加以下内容：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We start by defining the shape of each track error with `IPlayerError`. Then,
    we define references to the `_completeHandler` and `_errorHandler` functions captured via
    the `load` arguments, which now require complete and error callbacks. We assign
    those both before assigning the model's internal `this._trackComplete`and `this._trackError`
    (*using the `.bind(this)` syntax to ensure the function scope is locked to itself*)to
    `completeCallback` and `errorCallback` of `TNSPlayer`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义每个曲目错误的形状为`IPlayerError`。然后，我们通过`load`参数捕获对`_completeHandler`和`_errorHandler`函数的引用，现在需要完成和错误回调。我们在分配模型的内部`this._trackComplete`和`this._trackError`之前分配这两个回调（使用`.bind(this)`语法确保函数范围被锁定到自身）到`TNSPlayer`的`completeCallback`和`errorCallback`。
- en: '`completeCallback` and`errorCallback` will fire outside the zone. This is why
    we inject `NgZone` and use `ngZone.run()` later in the chapter. We can avoid that
    by creating a callback with the `zonedCallback` function. It will make sure that
    the callback will be executed in the same zone as the code that creates the callback.
    For example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: “completeCallback”和“errorCallback”将在区域外触发。这就是为什么我们在后面的章节中注入“NgZone”并使用“ngZone.run()”。我们可以通过使用“zonedCallback”函数创建回调来避免这种情况。它将确保回调将在创建回调的代码相同的区域中执行。例如：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This provides us the ability to internally handle each condition before dispatching
    out those conditions.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了在分派这些条件之前内部处理每个条件的能力。
- en: 'One such internal condition is resetting each audio player back to zero when
    it completes playing, so we simply call the `seekTo` method of `TNSPlayer`to reset
    it. We mark a *TODO,* because although this works well when all the tracks are
    the same length (*as is the case with our Demo tracks*), this will most certainly
    become potentially problematic in the future when we start recording our own varied
    multitracks with different lengths. Imagine we have two tracks in a composition:
    track 1 with a duration of 1 minute and track 2 a duration of 30 seconds. If we
    play the composition to 45 seconds and hit pause, track 2 would have called its
    completion handler already and reset back to 0\. We then hit play to resume. Track
    1 resumes from 45 seconds but track 2 is back at 0\. *We will address that when
    we get there, so don''t fret about it!* At this point, we are polishing our first
    phase implementation.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个内部条件是在播放完成时将每个音频播放器重置为零，因此我们只需调用`TNSPlayer`的`seekTo`方法进行重置。我们标记了一个*TODO*，因为虽然这在所有音轨长度相同时效果很好（*就像我们的演示音轨*），但当我们开始录制不同长度的多轨音轨时，这肯定会在未来变得有问题。想象一下，我们有两个音轨：音轨1的持续时间为1分钟，音轨2的持续时间为30秒。如果我们播放到45秒并暂停，音轨2已经调用了它的完成处理程序并重置为0。然后我们点击播放以恢复。音轨1从45秒处恢复，但音轨2又回到了0。*我们会在那时解决这个问题，所以不要为此担心！*此时，我们正在完善我们的第一阶段实现。
- en: Lastly, we call out to the assigned `completeHandler` to let the caller know
    which trackId has completed. For `trackError`, we simply call out passing along
    `trackId` and `error`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用分配的`completeHandler`来让调用者知道哪个trackId已经完成。对于`trackError`，我们只需传递`trackId`和`error`。
- en: 'Now, let''s go back to `PlayerService` and wire this in. Open `app/modules/player/services/player.service.ts` and
    make the following modifications:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到`PlayerService`并将其连接起来。打开`app/modules/player/services/player.service.ts`并进行以下修改：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We've added another subject, `complete$`, to allow view components to subscribe
    to when the track playback completes. Additionally, we have added two callback
    handlers, `_trackComplete` and `_trackError`, which we pass along to our `load`
    method of `TrackPlayerModel`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经添加了另一个主题，`complete$`，以允许视图组件订阅音轨播放完成时的情况。此外，我们添加了两个回调处理程序，`_trackComplete`和`_trackError`，我们将它们传递给`TrackPlayerModel`的`load`方法。
- en: However, if we were to try and update view bindings as a result of the `complete$`
    subscriptions firing in any view component, you would notice something puzzling.
    **The view would not update!**
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们试图更新视图绑定以响应任何视图组件中`complete$`订阅的触发，你会注意到一些令人困惑的事情。**视图不会更新！**
- en: Anytime you integrate with third-party libraries, take note of callback handlers
    coming from the library, which you may intend to update a view binding. Inject
    NgZone and wrap with `this.ngZone.run(() => ...` where needed.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 每当与第三方库集成时，请注意来自库的回调处理程序，这可能需要更新视图绑定。在需要时注入NgZone并用`this.ngZone.run(() => ...`进行包装。
- en: Third-party libraries that provide callbacks may often need to run through Angular's NgZone.
    The great folks at Thoughtram published a great article on Zones if you'd like
    to learn more, at [https://blog.thoughtram.io/angular/2016/02/01/zones-in-angular-2.html](https://blog.thoughtram.io/angular/2016/02/01/zones-in-angular-2.html).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 提供回调的第三方库通常需要通过Angular的NgZone运行。Thoughtram的伟大人员发表了一篇关于Zone的精彩文章，如果你想了解更多，请访问[https://blog.thoughtram.io/angular/2016/02/01/zones-in-angular-2.html](https://blog.thoughtram.io/angular/2016/02/01/zones-in-angular-2.html)。
- en: The third-party library **nativescript-audio** integrates with the iOS and Android
    native audio players and provides callbacks you can wire up to handle completion
    and error conditions. These callbacks are executed asynchronously within the context
    of the native audio players and, because they are not handled within the context
    of user events like a tap, or a result of a network request, or a timer like `setTimeout`,
    we need to ensure the result and the subsequent code execution take place within
    Angular's NgZone if we intend them to result in updating view bindings.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方库**nativescript-audio**集成了iOS和Android本机音频播放器，并提供了可以连接到处理完成和错误条件的回调。这些回调在本机音频播放器的上下文中异步执行，因为它们不是在用户事件的上下文中处理，比如点击，或者网络请求的结果，或者像`setTimeout`这样的定时器，如果我们打算它们导致更新视图绑定，我们需要确保结果和随后的代码执行发生在Angular的NgZone中。
- en: 'Since we intend for the `complete$` subject to result in view binding updates
    (*specifically, resetting our slider*), we will inject NgZone and wrap our callback
    handling. Back in `app/modules/player/services/player.service.ts`, let''s make
    the following adjustment:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们打算让`complete$`主题导致视图绑定更新（*特别是重置我们的滑块*），我们将注入NgZone并包装我们的回调处理。回到`app/modules/player/services/player.service.ts`，让我们进行以下调整：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, we will be clear when using this new `complete$` subject to react to our
    service''s state in our view components. Let''s adjust `PlayerControlsComponent`
    at `app/modules/player/components/player- controls/player-controls.component.ts` to
    observe the `complete$` subject to reset our `currentTime` binding:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们在视图组件中使用这个新的`complete$`主题来响应我们服务的状态时，我们将会清楚。让我们调整`PlayerControlsComponent`在`app/modules/player/components/player-controls/player-controls.component.ts`中观察`complete$`主题来重置我们的`currentTime`绑定：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: iOS Audio Player reports `duration` and `currentTime` in seconds, whereas Android
    reports in milliseconds. We need to standardize that!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: iOS音频播放器以秒为单位报告`duration`和`currentTime`，而Android以毫秒报告。我们需要标准化！
- en: 'Let''s add a method to `PlayerService` to standardize the time, so we can rely
    on both the platforms providing time in seconds:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向`PlayerService`添加一个方法来标准化时间，这样我们就可以依赖两个平台都提供以秒为单位的时间：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We are able to take advantage of the `isIOS` Boolean provided by the `platform`
    module from NativeScript to conditionally adjust our time for Android's milliseconds
    to seconds conversion.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用NativeScript提供的`platform`模块中的`isIOS`布尔值来有条件地调整我们的时间，将Android的毫秒转换为秒。
- en: Using the `isIOS` and/or `isAndroid` Boolean from NativeScript's `platform`
    module is a very effective way to make platform adjustments across your codebase
    where needed.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用NativeScript的`platform`模块中的`isIOS`和/或`isAndroid`布尔值是在需要时跨代码库进行平台调整的非常有效的方法。
- en: '**So what about that subtle playback sync issue with multiple tracks on iOS
    ?**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**那么在iOS上有关多个曲目的微妙播放同步问题呢？**'
- en: On iOS, you may notice a very subtle playback sync issue on all the tracks if
    you choose play/pause many times during the 14 seconds of playback on the composition's
    demo tracks. We could surmise this could also happen on Android at some point.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS上，如果您在演示曲目的14秒播放期间多次选择播放/暂停，您可能会注意到所有曲目都有一个非常微妙的播放同步问题。我们可以推测这也可能在某个时候发生在Android上。
- en: Using NativeScript's strengths by tapping directly into the native API of the
    underlying iOS AVAudioPlayer instance from the nativescript-audio plugin
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用NativeScript的优势，直接利用nativescript-audio插件中底层iOS AVAudioPlayer实例的本机API
- en: Let's insert some safeguards into our play/pause logic to help ensure our tracks
    stay in sync to the best of our programming abilities. The **nativescript-audio**
    plugin offers an iOS-only method called `playAtTime`. It works in tandem with
    the special `deviceCurrentTime` property, as described in Apple's documentation
    for this very purpose at [https://developer.apple.com/reference/avfoundation/avaudioplayer/1387462-devicecurrenttime?
    language=objc](https://developer.apple.com/reference/avfoundation/avaudioplayer/1387462-devicecurrenttime?language=objc).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的播放/暂停逻辑中插入一些保护措施，以帮助确保我们的曲目在我们的编程能力范围内保持同步。**nativescript-audio**插件提供了一个仅适用于iOS的方法，称为`playAtTime`。它与特殊的`deviceCurrentTime`属性一起工作，正如苹果的文档中为此目的描述的那样。
- en: 'Since `deviceCurrentTime` is not exposed by the nativescript-audio plugin,
    we can access the native property directly via the `ios` getter. Let''s adjust
    the `play` method of `PlayerService`to use it:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`nativescript-audio`插件没有暴露`deviceCurrentTime`，我们可以通过`ios` getter直接访问原生属性。让我们调整`PlayerService`的`play`方法来使用它：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Since `track.player` is our instance of `TNSPlayer`, we can access the underlying
    native platform player instance (for iOS, it's `AVAudioPlayer`) via its **ios**
    getter to access `deviceCurrentTime` directly. We provide a very short start delay
    for good measure, add that into the first track's `deviceCurrentTime`, and use
    that to start all of our tracks at precisely the same time, which works wonderfully! Because
    `playAtTime` is not published via the TypeScript definitions with the nativescript-audio
    plugin, we simply type-cast the player instance (`<any>track.player`) before calling
    the method to suffice the tsc compiler. Since there is no equivalent on Android,
    we will just use the standard media player's play method, which works well for
    Android.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`track.player`是我们的`TNSPlayer`实例，我们可以通过其**ios** getter访问底层的原生平台播放器实例（对于iOS，它是`AVAudioPlayer`）来直接访问`deviceCurrentTime`。我们为了保险起见提供了一个非常短的起始延迟，将其加入到第一首曲目的`deviceCurrentTime`中，并使用它来确保我们的所有曲目在同一时间开始，这非常有效！由于`playAtTime`没有通过`nativescript-audio`插件的TypeScript定义发布，我们在调用该方法之前只需对播放器实例进行类型转换（`<any>track.player`）即可满足tsc编译器。由于在Android上没有等效的方法，我们将只使用标准的媒体播放器的播放方法，这对Android来说效果很好。
- en: 'Let''s now adjust our pause method with a similar safeguard:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在用类似的保护措施来调整我们的暂停方法：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: By using the first track's `currentTime` as the **pace setter**, we pause each
    track in our mix and ensure they remain at exactly the same time by seeking to
    the same `currentTime` immediately after pausing. This helps ensure that, when
    we resume play, they all start from the same point in time. Let's put all this to
    use in the next section when we build a custom shuttle slider.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用第一首曲目的`currentTime`作为**pace setter**，我们暂停我们混音中的每一首曲目，并确保它们通过立即定位到相同的`currentTime`保持在完全相同的时间。这有助于确保当我们恢复播放时，它们都从同一时间点开始。让我们在下一节中利用所有这些内容来构建一个自定义的穿梭滑块。
- en: Creating a custom ShuttleSliderComponent
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个自定义的ShuttleSliderComponent
- en: We can't have a multitrack studio experience without the ability to shuttle
    back and forth through our mix! Let's double down on `Slider` and enhance its
    capabilities by combining the best of all the options NativeScript and Angular
    provide us. In the process, our player controls will start to become much more
    useful.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能没有能够在我们的混音中来回穿梭的能力！让我们加倍努力，通过结合NativeScript和Angular提供给我们的所有选项的优势来增强`Slider`的功能。在这个过程中，我们的播放控件将开始变得更加有用。
- en: 'Starting at the high level, open `app/modules/player/components/player-controls/player-controls.component.html`
    and replace it with the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次开始，打开`app/modules/player/components/player-controls/player-controls.component.html`并用以下内容替换它：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We are replacing `GridLayout` with `StackLayout` to change up our player control''s
    layout a bit. Let''s go with a full-width slider stacked on top of our play/pause
    button. What we''re after is similar to the Apple Music app on an iPhone, where
    the slider is full width with the current time and duration displayed underneath.
    Now, let''s build our custom `shuttle-slider` component and create `app/modules/player/components/player-controls/shuttle-
    slider.component.html` with the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在用`StackLayout`替换`GridLayout`，以改变一下我们播放器控件的布局。让我们使用一个全宽的滑块叠放在播放/暂停按钮上。我们想要的效果类似于iPhone上的Apple
    Music应用，滑块是全宽的，当前时间和持续时间显示在下面。现在，让我们构建我们的自定义`shuttle-slider`组件，并创建`app/modules/player/components/player-controls/shuttle-slider.component.html`，内容如下：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here's where things are going to get very interesting. We are going to combine
    Angular bindings where useful, like these bindings: `[maxValue]="duration"` and `[text]="durationDisplay"` .
    However for the rest of our usability wiring we will want more fine grained and
    manual control. For instance, our containing `GridLayout` via `#sliderArea` is
    going to be the area the user is going to be able to touch to shuttle back/forth
    instead of the `Slider` component itself, and we are going to completely disable
    user interaction with the Slider itself (hence, the `slim-slider` directive attribute,
    you see). The slider is going to instead be used just for its visual representation
    of time.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的事情将变得非常有趣。我们将结合Angular绑定在有用的地方，比如这些绑定：`[maxValue]="duration"`和`[text]="durationDisplay"`。然而，对于我们其余的可用性布线，我们将需要更精细的和手动的控制。例如，我们的包含`GridLayout`通过`#sliderArea`将成为用户可以触摸进行穿梭的区域，而不是`Slider`组件本身，我们将完全禁用用户与滑块本身的交互（因此，你看到的`slim-slider`指令属性）。滑块将仅用于时间的视觉表示。
- en: 'The reason we will be doing this is because we want this interaction to kick
    off several programmatic actions:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要这样做的原因是因为我们希望这种交互能够启动几个程序化的动作：
- en: Pause playback (if playing) while shuttling
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在穿梭时暂停播放（如果正在播放）
- en: Update the current time display label as we move back/forth
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在来回移动时更新当前时间显示标签
- en: Kick off the `seekTo` commands to our track player's instances in a controlled
    manner; hence, reducing extraneous seek commands
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以受控方式启动`seekTo`命令到我们的轨道播放器实例，从而减少多余的搜索命令
- en: Resume playback when no longer shuttling if it was playing before attempting
    to shuttle
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果之前正在播放，那么在不再进行穿梭时恢复播放
- en: If we used `Slider` with an Angular binding to `currentTime` via the `currentTime$`
    observable, which in turn was being controlled by our interaction with it in addition
    to the state of our track's players, things would be coupled too tightly to achieve the
    fine grain control we need.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`Slider`和Angular绑定到`currentTime`通过`currentTime$` observable，这取决于我们与其交互以及轨道播放器状态的控制，事情会耦合得太紧，无法实现我们需要的精细控制。
- en: 'The beauty of what we are about to do here serves as an exemplary testament
    to how flexible the combination of Angular with NativeScript really is. Let''s
    start programming our interactions in `app/modules/player/components/player-controls/shuttle-slider.component.ts`; here''s
    the complete setup for you to view in full, which we will break down in a moment:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将要做的事情之美，是对Angular与NativeScript的灵活组合的一个很好的证明。让我们开始在`app/modules/player/components/player-controls/shuttle-slider.component.ts`中编写我们的交互；这是完整的设置，你可以在这里查看，我们马上就会分解：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: For a rather small component footprint, there's a ton of great stuff going on
    here! Let's break it down.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个相当小的组件占用空间，这里发生了很多很棒的事情！让我们来分解一下。
- en: 'Let''s look at those property decorators, starting with `@Input`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看那些属性装饰器，从`@Input`开始：
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, we have our `@ViewChild` references:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有我们的`@ViewChild`引用：
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We can then access those `ElementRef` instances in our component to programmatically
    work with them; however, not right away. Since `ElementRef` is a proxy wrapper
    to the view component, its underlying `nativeElement` (our actual NativeScript
    component) is only accessible once Angular's component lifecycle hook `ngAfterViewInit`
    fires.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在组件中访问这些“ElementRef”实例，以便以编程方式处理它们；但是，不是立即。由于“ElementRef”是视图组件的代理包装器，只有在Angular的组件生命周期钩子“ngAfterViewInit”触发后，才能访问其底层的“nativeElement”（我们实际的NativeScript组件）。
- en: 'Learn all about Angular''s component lifecycle hooks here:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里了解有关Angular组件生命周期钩子的所有信息：
- en: '[https://angular.io/docs/ts/latest/guide/lifecycle- hooks.html.](https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html.](https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html)'
- en: 'Therefore, we assign private references to our actual NativeScript components
    here:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在这里为我们的实际NativeScript组件分配私有引用：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We also take this opportunity to reference the overall screen width using the
    **density-independent pixel** (**dip**) units via the `screen` utility from the
    `platform` module. This will allow us to do some calculations using our user's
    finger position on our `sliderArea` StackLayout to adjust the actual value of
    `Slider`. We then make a call to set up our essential event handlers.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还利用这个机会使用“platform”模块的“screen”实用程序来引用整体屏幕宽度，使用**密度无关像素**（**dip**）单位。这将允许我们使用用户在“sliderArea”
    StackLayout上的手指位置进行一些计算，以调整“Slider”的实际值。然后，我们调用设置我们必要的事件处理程序。
- en: 'Using our `_sliderArea` reference to the containing StackLayout, we add a `touch`
    gesture listener to capture any touches the user makes to our slider area:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的“_sliderArea”引用来包含StackLayout，我们添加了一个“touch”手势监听器，以捕获用户在滑块区域上的任何触摸：
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This allows us to grab the `X` position of their finger via `args.getX()`. We
    use that to divide into the user's device screen width to determine a percentage
    from the left to the right. Since our calculation is not exactly precise, we make
    a small adjustment when the user passes the 50% mark. This usability works well
    for our use case right now, but we will reserve the option to improve that later;
    however, it's perfectly fine for now.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够通过“args.getX()”抓取用户手指的“X”位置。我们用它来除以用户设备屏幕宽度，以确定从左到右的百分比。由于我们的计算不是完全精确的，当用户通过50%标记时，我们进行了一些小的调整。这种可用性目前非常适合我们的用例，但是我们将保留以后改进的选项；但是，现在它完全可以。
- en: 'We then multiply the duration by this percentage to get our `seekTo` mark to
    update our value of  `Slider` in order to get immediate UI updates using manual
    precision:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将持续时间乘以这个百分比，以获得我们的“seekTo”标记，以更新我们的“Slider”值，以便使用手动精度获得即时UI更新：
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, we are actually using our NativeScript components directly without Angular's
    bindings or NgZone in the mix. This can be very handy in cases where you need
    fine grained and performance control of your UI. Since we want the `Slider` track
    to move immediately with the user's finger, as well as the time display label
    formatted with standard musical timecode to represent real time as they interact,
    we set their values directly at the appropriate time.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们实际上直接使用我们的NativeScript组件，而不使用Angular的绑定或NgZone。在需要对UI进行精细控制和性能控制的情况下，这可能非常方便。由于我们希望“Slider”轨道能够立即随用户手指移动，以及时间显示标签使用标准音乐时间码格式表示实时交互，我们在适当的时间直接设置它们的值。
- en: We then use a seek delay timeout to ensure we don't make extraneous seek commands
    to our multitrack player. Each movement by the user will further delay making
    an actual seek command until they rest where they want it. We also use our `isIOS`
    Boolean to convert the time as appropriately needed by each platform audio player
    (seconds for iOS and milliseconds for Android).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用寻找延迟超时来确保我们不会向我们的多轨播放器发出多余的寻找命令。用户的每次移动都会进一步延迟实际的寻找命令，直到他们停在他们想要的位置。我们还使用我们的
    `isIOS` 布尔值来根据每个平台音频播放器的需要适当地转换时间（iOS 为秒，Android 为毫秒）。
- en: 'Most interesting might be our `ngOnChanges` lifecycle hook:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最有趣的可能是我们的 `ngOnChanges` 生命周期钩子：
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Angular calls its `ngOnChanges()` method whenever it detects changes to the
    ***input properties*** of the component (or directive).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Angular 检测到组件（或指令）的 ***输入属性*** 发生变化时，它会调用其 `ngOnChanges()` 方法。
- en: This is a wonderful way for `ShuttleSliderComponent` to react to its `Input`
    property changes, `currentTime`, and `duration`. Here, we simply update our slider
    and the current time display label manually via `this._updateSlider(this.currentTime)`
    only when it does fire with a valid number. Lastly, we also ensure we update our
    duration display label. This method will fire every second the PlayerService's
    `currentTime$` observable fires while an active subscription exists. **Nice!**
    Oh, and don't forget to add `ShuttleSliderComponent` to the `COMPONENTS` array
    to be included with the module.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `ShuttleSliderComponent` 对其 `Input` 属性变化、`currentTime` 和 `duration` 做出反应的绝妙方式。在这里，我们只在它确实发出有效数字时通过
    `this._updateSlider(this.currentTime)` 手动更新我们的滑块和当前时间显示标签。最后，我们还确保更新我们的持续时间显示标签。只要存在活动订阅，该方法将在
    `PlayerService` 的 `currentTime$` observable 每秒触发一次。**不错！** 哦，别忘了将 `ShuttleSliderComponent`
    添加到 `COMPONENTS` 数组中，以便与模块一起包含。
- en: 'We now need to actually implement this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要实际实现这一点：
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We are going to use a couple more nifty observable tricks with our seeking
    state. Let''s open our PlayerService in `app/modules/player/services/player.service.ts`
    and add the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用更多巧妙的 observable 技巧来处理我们的寻找状态。让我们打开 `app/modules/player/services/player.service.ts`
    中的 `PlayerService`，并添加以下内容：
- en: '[PRE34]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We are introducing three new observable operators `switchMap`, `never`, and
    `of`, which we need to ensure are also imported in our `app/operators.ts` file:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入了三个新的 observable 操作符 `switchMap`、`never` 和 `of`，我们需要确保它们也被导入到我们的 `app/operators.ts`
    文件中：
- en: '[PRE35]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`switchMap` allows our observable to switch streams based on several conditions,
    helping us to manage whether `currentTime` needs to emit updates or not. Clearly,
    when seeking, we don''t need to react to the `currentTime` changes. Therefore,
    we switch our Observable stream to `Observable.never()` while `this._seeking`
    is true, ensuring our observer is never called.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`switchMap` 允许我们的 observable 根据几个条件切换流，帮助我们管理 `currentTime` 是否需要发出更新。显然，在寻找时，我们不需要对
    `currentTime` 的变化做出反应。因此，当 `this._seeking` 为 true 时，我们将我们的 Observable 流切换到 `Observable.never()`，确保我们的观察者永远不会被调用。'
- en: In our `seeking` setter, we adjust the internal state reference (`this._seeking`)
    ,and if it was currently `this._playing` and had not yet been paused due to seeking
    (hence, `!this._seekPaused`), we immediately pause playback (only once). We then
    set up another timeout to delay resuming playback an additional 400 milliseconds
    after `seekTo` has been fired from the component if it was playing when seek started
    (hence, the check on `this._seekPaused`).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `seeking` setter 中，我们调整内部状态引用（`this._seeking`），如果它当前是 `this._playing` 并且由于寻找而尚未暂停（因此
    `!this._seekPaused`），我们立即暂停播放（仅一次）。然后，我们设置另一个超时，延迟在组件触发 `seekTo` 后的额外 400 毫秒恢复播放，如果在寻找开始时正在播放（因此，检查
    `this._seekPaused`）。
- en: This way, the user is free to move their finger across our shuttle slider as
    much as they'd like and as quickly as they'd like. They will see immediate UI
    updates to the `Slider` track as well as the current time display label in real
    time; all the while we are avoiding extraneous `seekTo` commands being sent to
    our multitrack player until they come to rest, providing a really nice user experience.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，用户可以自由地在我们的滑块上移动手指，尽可能快地移动。他们将实时看到`Slider`轨道的即时UI更新，以及当前时间显示标签；与此同时，我们避免了向我们的多轨播放器发送多余的`seekTo`命令，直到它们停下来，提供了一个非常好的用户体验。
- en: Creating SlimSliderDirective for iOS and Android native API modifications
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为iOS和Android本机API修改创建SlimSliderDirective
- en: 'We still have a directive to create for that `slim-slider` attribute we had
    on `Slider`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要为`Slider`上的`slim-slider`属性创建一个指令：
- en: '[PRE36]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We are going to create platform-specific directives, since we will tap into
    the slider's actual native API on iOS and Android to disable user interaction
    and hide the thumb for a seamless appearance.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建特定于平台的指令，因为我们将在iOS和Android上利用滑块的实际本机API来禁用用户交互并隐藏拇指，以实现无缝外观。
- en: 'For iOS, create `app/modules/player/directives/slider.directive.ios.ts` with
    the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 对于iOS，创建`app/modules/player/directives/slider.directive.ios.ts`，并进行以下操作：
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We gain access to the underlying native iOS `UISlider` instance via NativeScript's
    `ios` getter off the `Slider` component itself. We use Apple's API reference documentation
    ([https://developer.apple.com/reference/uikit/uislider](https://developer.apple.com/reference/uikit/uislider))
    to locate an appropriate API to disable interaction via the `userInteractionEnabled`
    flag and hide the thumb by setting a blank as the thumb. Perfect.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通过NativeScript的`Slider`组件本身的`ios`获取器，我们可以访问底层的本机iOS `UISlider`实例。我们使用苹果的API参考文档（[https://developer.apple.com/reference/uikit/uislider](https://developer.apple.com/reference/uikit/uislider)）来找到一个适当的API，通过`userInteractionEnabled`标志来禁用交互，并通过设置空白作为拇指来隐藏拇指。完美。
- en: 'For Android, create `app/modules/player/directives/slider.directive.android.ts`
    with the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Android，创建`app/modules/player/directives/slider.directive.android.ts`，并进行以下操作：
- en: '[PRE38]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We gain access to the native `android.widget.SeekBar` instance via the `android`
    getter on the `Slider` component. We use Android's API reference documentation
    ([https://developer.android.com/reference/android/ widget/SeekBar.html](https://developer.android.com/reference/android/widget/SeekBar.html))
    to locate the SeekBar's API and disable user interaction by overriding `OnTouchListener`,
    and we hide the thumb by setting its Drawable alpha to 0.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`Slider`组件上的`android`获取器，我们可以访问本机的`android.widget.SeekBar`实例。我们使用Android的API参考文档（[https://developer.android.com/reference/android/widget/SeekBar.html](https://developer.android.com/reference/android/widget/SeekBar.html)）来找到SeekBar的API，并通过覆盖`OnTouchListener`来禁用用户交互，并通过将其Drawable
    alpha设置为0来隐藏拇指。
- en: 'Now, create `app/modules/player/directives/slider.directive.d.ts`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建`app/modules/player/directives/slider.directive.d.ts`：
- en: '[PRE39]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This will allow us to import and use our `SlimSlider` class as a standard ES6
    module; Create `app/modules/player/directives/index.ts`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许我们导入和使用我们的`SlimSlider`类作为标准的ES6模块；创建`app/modules/player/directives/index.ts`：
- en: '[PRE40]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: At runtime, NativeScript will only build the appropriate platform-specific files
    into the target platform, completely excluding nonapplicable code. This is a very
    powerful way to create platform-specific functionality in your codebase.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，NativeScript只会将适当的特定于平台的文件构建到目标平台中，完全排除不适用的代码。这是在代码库中创建特定于平台功能的非常强大的方式。
- en: 'To finish up, let''s just ensure our directives are declared in `PlayerModule`
    at `app/modules/player/player.module.ts` with the following changes:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们确保我们的指令在`PlayerModule`中声明，位于`app/modules/player/player.module.ts`，进行以下更改：
- en: '[PRE41]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We should now see this on iOS with our playback paused at 6 seconds:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该在iOS上看到这一点，我们的播放暂停在6秒处：
- en: '![](../images/00034.jpeg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00034.jpeg)'
- en: 'For Android, it will be as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Android，将如下进行：
- en: '![](../images/00035.jpeg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00035.jpeg)'
- en: 'You can now observe the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以观察到以下内容：
- en: All the three tracks play together in a perfect mix
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有三个轨道一起完美混合播放
- en: Playback can be shuttled via the slider whether it's playing or not
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论是否正在播放，都可以通过滑块进行播放
- en: The play/pause toggle
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放/暂停切换
- en: When playback reaches the end, our controls properly reset
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当播放到达结尾时，我们的控制会正确重置
- en: And it all works on iOS and Android. An amazing feat, without question.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 而且这一切都在iOS和Android上运行。毫无疑问，这是一个了不起的成就。
- en: Summary
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We are now fully immersed in the rich world of NativeScript, having introduced
    plugin integration as well as direct access to native APIs on iOS and Android.
    To top it off, we have a really neat multitrack player with full playback control,
    including shuttling through the mix!
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在完全沉浸在NativeScript丰富的世界中，引入了插件集成以及直接访问iOS和Android的原生API。最重要的是，我们有一个非常棒的多轨播放器，具有完整的播放控制，包括混音播放！
- en: The exciting combination of Angular, including its RxJS observable underpinnings,
    is really starting to shine through, where we've been able to take advantage of
    view bindings where needed and react to service event streams with powerful observable
    compositions, all while still retaining the ability to manually control our UI
    with fine grain control. Whether our view needs an Angular directive to enrich
    its capabilities or manual touch gesture control via raw NativeScript capabilities,
    we have it all at our fingertips now.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 令人兴奋的Angular组合，包括其RxJS可观察对象的基础，真的开始显现出来，我们已经能够利用视图绑定，以及通过强大的可观察组合来响应服务事件流，同时仍然保留了手动控制我们的UI的能力。无论我们的视图是否需要Angular指令来丰富其功能，还是通过原始NativeScript功能进行手动触摸手势控制，现在我们都可以轻松实现。
- en: The fact that all along we are building a fully native iOS and Android app is
    truly mind blowing.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在构建一个完全原生的iOS和Android应用程序，这真是令人惊叹。
- en: In the next chapter, we will continue to dig further into native APIs and plugins
    as we bring recording into our app's abilities to deliver on the core requirements
    of our multi-track recording studio mobile app.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续深入研究原生API和插件，将录音引入我们的应用程序，以满足我们多轨录音工作室移动应用程序的核心要求。
