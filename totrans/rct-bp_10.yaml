- en: Chapter 10. Making a Game
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章. 制作游戏
- en: In this final chapter, we're going to create the most complex blueprint yet.
    We're going to create a game engine and a single screen action game. When you're
    finished with this chapter, you'll appreciate why developing with ReactJS is often
    compared to developing games. When we make games in HTML5, we use the canvas.
    Drawing on canvas is very similar to how we render the browser in ReactJS. We
    update the canvas continuously, discarding the previous content and render the
    new content immediately.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后，我们将创建迄今为止最复杂的蓝图。我们将创建一个游戏引擎和一个单屏动作游戏。当你完成本章后，你会理解为什么使用ReactJS进行开发经常被比作开发游戏。当我们用HTML5制作游戏时，我们使用canvas。在canvas上绘制与我们在ReactJS中渲染浏览器的方式非常相似。我们持续更新canvas，丢弃之前的内容，并立即渲染新内容。
- en: We'll be making an action game with a playable wizard character facing a horde
    of monsters while on a picnic. Armed with a fireball spell, the player must defeat
    all the enemies before he's able to relax and enjoy his lunch.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将制作一个动作游戏，玩家将扮演一个可玩的角色，面对一群怪物，同时野餐。装备了火球法术的玩家必须击败所有敌人，才能放松并享受他的午餐。
- en: 'These are the topics we''ll cover in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: The optimal Webpack configuration with dynamic SCSS transpiling
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有动态SCSS转换的最佳Webpack配置
- en: Scripting with ShellJS
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ShellJS进行脚本编写
- en: Static type checking with Flow
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Flow进行静态类型检查
- en: Creating an HTML5 canvas game engine
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建HTML5 canvas游戏引擎
- en: Responding to keyboard events
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应键盘事件
- en: Creating and drawing image entities
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和绘制图像实体
- en: Moving computer-controlled entities on the screen
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在屏幕上移动由计算机控制的实体
- en: Brute force collision detection
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制力碰撞检测
- en: Setting up a game title and a game over scenario
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置游戏标题和游戏结束场景
- en: So let's get started!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧！
- en: The optimal Webpack configuration
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳Webpack配置
- en: We're going to implement a few of the newer technologies, and once again, we're
    going to modify our Webpack configuration and build process. We're going to add
    type checking with Flow, a better solution for copying our assets and creating
    our production `index.html` file. Finally, we'll add support for inline import
    and instant transpiling of SCSS.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一些较新的技术，并且再次修改我们的Webpack配置和构建过程。我们将添加使用Flow的类型检查，这是复制我们的资源和创建我们的生产`index.html`文件的一个更好的解决方案。最后，我们将添加对内联导入和即时转换SCSS的支持。
- en: SCSS is an extension to CSS that allows you to write CSS with features that
    don't exist in regular CSS, such as nesting, mixins, inheritance, and variables.
    It's called a **preprocessor**, which is like a transpiler where you write code
    in one language and convert it into another language before use. In this case,
    we will write code in SCSS and convert it into regular CSS before the browser
    parses it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: SCSS是CSS的扩展，允许你使用在常规CSS中不存在的功能编写CSS，例如嵌套、混入、继承和变量。它被称为**预处理器**，就像是一个编译器，你可以在其中用一种语言编写代码，并在使用之前将其转换为另一种语言。在这种情况下，我们将用SCSS编写代码，并在浏览器解析之前将其转换为常规CSS。
- en: 'In order to do all of this, we''ll need to add a few new packages from `npm`
    and make changes to our Webpack configuration. Note, we''re going to start with
    the production Webpack scaffold we made in [Chapter 8](ch08.html "Chapter 8. Deploying
    Your App to the Cloud"), *Deploying Your App to the Cloud*. This scaffold has
    the following structure:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成所有这些，我们需要添加一些来自`npm`的新包，并修改我们的Webpack配置。注意，我们将从我们在[第8章](ch08.html "第8章。将您的应用程序部署到云")中制作的生成Webpack脚手架开始，*将您的应用程序部署到云*。这个脚手架具有以下结构：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In both `Webpack-development.config.js` and `Webpack-production.config.js`,
    add this code inside the `loader` section (between the square brackets):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Webpack-development.config.js`和`Webpack-production.config.js`中，在`loader`部分（方括号之间）添加以下代码：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that we're going to keep the Babel loader and then add another loader beneath,
    which will make sure Webpack understands the `scss` prefix.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将保留Babel加载器，然后在下面添加另一个加载器，以确保Webpack理解`scss`前缀。
- en: 'In both the `configuration` files, add this import:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个配置文件中，添加以下导入：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And, add this plugin code to the `plugins` section:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将此插件代码添加到`plugins`部分：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This plugin will take a template `index.ejs` file and copy it to the output
    path defined earlier in the configuration file as `index.html`. It will also insert
    the generated script files created with Webpack.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此插件将模板`index.ejs`文件复制到配置文件中之前定义的输出路径作为`index.html`。它还将插入Webpack生成的脚本文件。
- en: 'For `Webpack-development.config.js`, the output section should look like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Webpack-development.config.js`，输出部分应如下所示：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For `Webpack-production.config.js`, it should look like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Webpack-production.config.js`，它应该看起来像这样：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We also need to add the `index.ejs` file and its contents. Add them using this
    code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要添加 `index.ejs` 文件及其内容。使用以下代码添加它们：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Notice that we've skipped both the *CSS* and the scripts and that we've added
    the page title by injecting `htmlWebpackPlugin`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经跳过了 *CSS* 和脚本，并且通过注入 `htmlWebpackPlugin` 添加了页面标题。
- en: 'With these two changes, we can remove the `cpFile` plugin and the `cpFile`
    code in our `server-production.js` file. The `cpFile` plugin did two things: it
    copied `assets/index.prod.html` to `public/assets/index.html` and `app.css` in
    `assets` to `public/assets`. We''ll still need to copy the assets content, but
    since we''ll be copying a lot of files, we''ll need a smarter way to do this than
    simply copying file after file.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个更改之后，我们可以移除 `cpFile` 插件以及 `server-production.js` 文件中的 `cpFile` 代码。`cpFile`
    插件做了两件事：它将 `assets/index.prod.html` 复制到 `public/assets/index.html`，并将 `assets`
    中的 `app.css` 复制到 `public/assets`。我们仍然需要复制资源内容，但由于我们将复制大量文件，我们需要一种比简单地逐个复制文件更智能的方法来做这件事。
- en: Scripting with ShellJS
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 ShellJS 编写脚本
- en: We're going to employ **ShellJS** to copy our assets instead. This `npm` package
    is an alternative to ordinary bash scripts with the added benefit of support across
    environments. This means that the scripts we make will work for Windows users
    as well as for Mac/Linux users.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 **ShellJS** 来复制我们的资源。这个 `npm` 包是普通 bash 脚本的替代品，并且增加了跨环境支持的好处。这意味着我们编写的脚本将适用于
    Windows 用户以及 Mac/Linux 用户。
- en: 'We''ll need to add a script to copy our files, so add a new folder called `scripts`
    and add a file called `assets.js` to it. Then, add this code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加一个脚本来复制我们的文件，因此添加一个名为 `scripts` 的新文件夹，并在其中添加一个名为 `assets.js` 的文件。然后，添加以下代码：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We also need to update our `package.json` file with a run script so that we
    can run ShellJS when packaging our app. Open the file and replace the `start`
    command with the following three lines:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更新我们的 `package.json` 文件，添加一个运行脚本，以便在打包我们的应用程序时运行 ShellJS。打开文件，并将 `start`
    命令替换为以下三行：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We also need to update our `server` file, so open `server-production.js` and
    replace it with this content:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更新我们的 `server` 文件，因此打开 `server-production.js` 并将其替换为以下内容：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we need to add all the packages we''ve been importing. Do this by executing
    the following command:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加我们导入的所有包。通过执行以下命令来完成此操作：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can remove the two packages we don''t need anymore using this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下方法移除我们不再需要的两个包：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You also need a complete set of assets for the game. You can clear out the current
    `assets` folder and use the contents available at [http://reactjsblueprints-chapter10.herokuapp.com/assets.zip](http://reactjsblueprints-chapter10.herokuapp.com/assets.zip).
    The graphics in our game contain a selection of tiles from a public domain roguelike
    tileset called **RLTiles**. You can find the original tileset at [http://rltiles.sf.net](http://rltiles.sf.net).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要一套完整的游戏资源。您可以清空当前的 `assets` 文件夹，并使用在 [http://reactjsblueprints-chapter10.herokuapp.com/assets.zip](http://reactjsblueprints-chapter10.herokuapp.com/assets.zip)
    可用的内容。我们游戏中的图形包含来自公共领域 rogue-like 图块集 **RLTiles** 的图块选择。您可以在 [http://rltiles.sf.net](http://rltiles.sf.net)
    找到原始图块集。
- en: Phew! That was a lot of changes, but we're finally ready to start programming
    the game. You should be able to run `npm run dev` to run the development server
    and `npm start` to build and run the production server.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 呼呼！这有很多变化，但我们终于准备好开始编写游戏了。您应该能够运行 `npm run dev` 来运行开发服务器，以及 `npm start` 来构建和运行生产服务器。
- en: Static typechecking with Flow
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Flow 进行静态类型检查
- en: We're going to type check our code with **Flow**. This is not part of our code
    base, but you'll see the syntax everywhere in our engine and game code.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 **Flow** 对我们的代码进行类型检查。这不是我们代码库的一部分，但您将在我们的引擎和游戏代码的每个地方看到这种语法。
- en: Flow is designed to find type errors in JavaScript programs. It has one major
    benefit when compared to a fully typed language, such as **TypeScript**. You have
    the freedom to use it when you feel like. This means that you can mix typed code
    with non-typed code and keep on programming generally, as you've always done with
    the added benefit of being able to automatically spot type errors.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Flow 被设计用来在 JavaScript 程序中查找类型错误。与完全类型化的语言（如 **TypeScript**）相比，它有一个主要的好处。您可以在想使用时使用它。这意味着您可以将类型化代码与非类型化代码混合，并继续像以前一样编程，同时增加了能够自动检测类型错误的好处。
- en: The downside is that the Flow binary is only available on Mac and Linux. There's
    an experimental Windows binary available, but it's not always up to date. The
    upside is that if you're on Windows, your code will still execute, but you won't
    be able to find any potential errors.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点是 Flow 二进制文件仅在 Mac 和 Linux 上可用。有一个实验性的 Windows 二进制文件可用，但它并不总是最新的。优点是，如果你在
    Windows 上，你的代码仍然会执行，但你将无法找到任何潜在的错误。
- en: Note
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Install Flow by visiting [http://flowtype.org/docs/getting-started.html](http://flowtype.org/docs/getting-started.html)
    and following the instructions.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通过访问 [http://flowtype.org/docs/getting-started.html](http://flowtype.org/docs/getting-started.html)
    并按照说明进行操作来安装 Flow。
- en: 'You need a special configuration file in the root of your project called `.flowconfig`
    (no name before the dot). Add the file with this content:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在项目根目录中有一个特殊的配置文件，名为 `.flowconfig`（点号前没有名称）。添加文件并包含以下内容：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This configuration tells *Flow* to check the contents of the `source` folder
    while ignoring a few selected dependencies in `node_modules`, which it picks up
    through the reference in the `source` folder files.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置告诉 *Flow* 检查 `source` 文件夹的内容，同时忽略 `node_modules` 中的一些选定的依赖项，这些依赖项是通过 `source`
    文件夹中的引用获取的。
- en: When Flow is installed and the configuration file is added, you can start checking
    your code by executing `flow` from your command line. It will initialize a server
    on the first run and then report errors for every run after that.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Flow 安装完成并添加了配置文件后，你可以通过在命令行中执行 `flow` 来开始检查你的代码。第一次运行时，它将初始化一个服务器，然后报告之后的每次运行的错误。
- en: 'A typical error looks like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的错误看起来像这样：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, Flow has figured out that the call to shuffle is called with an array,
    but the `shuffle` function is defined to expect an array with objects. The error
    is easy to fix because shuffle should expect an array with a collection of values
    and not an array with an object.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Flow 已经确定 shuffle 调用是用一个数组进行的，但 `shuffle` 函数被定义为期望一个包含对象的数组。这个错误很容易修复，因为
    shuffle 应该期望一个包含一系列值的数组，而不是包含对象的数组。
- en: By using annotations, you code with intent, and Flow makes it easy to spot whether
    you're using functions the way you intended, as witnessed by the preceding error.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用注解，你用意图编写代码，Flow 使得检查你是否以你期望的方式使用函数变得容易，正如前面错误所见证的那样。
- en: Creating an HTML5 canvas engine
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个 HTML5 画布引擎
- en: 'The game is divided into two parts: the engine and the game. For projects like
    these, it''s worthwhile to have a plan for how the app is going to look at the
    final stage. It''s natural to separate the pure game engine parts from the game
    parts because this makes it easier to repurpose them later and use them for other
    games.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏分为两个部分：引擎和游戏。对于这类项目，制定一个关于应用最终外观的计划是值得的。将纯游戏引擎部分与游戏部分分开是很自然的，因为这使得它们在以后更容易重用，并用于其他游戏。
- en: Usually, when you make a game, you base it off a premade engine, but we're not
    going to do that. We're going to make an engine all by ourselves. We'll implement
    just the features that we need, but feel free to extend and add engine pieces
    of your own when we're done.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当你制作一个游戏时，你会基于一个现成的引擎，但我们不会这么做。我们将完全自己制作一个引擎。我们将实现我们需要的所有功能，但在我们完成之后，你可以自由地扩展并添加自己的引擎组件。
- en: 'The engine should be placed as a subfolder inside `source`. This is the structure:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 应将引擎放置在 `source` 内部的子文件夹中。这是结构：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The main file is `index.js`, which simply acts as a central import/export hub.
    Let''s start by creating the `engine` folder and `index.js`. It should have this
    content:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 主文件是 `index.js`，它简单地充当一个中央导入/导出中心。让我们首先创建 `engine` 文件夹和 `index.js`。它应该包含以下内容：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We'll be using all of these components in our game. Let's create each one and
    look at what they do.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在游戏中使用所有这些组件。让我们创建每一个，并看看它们的作用。
- en: 'Let''s start with the `video` folder and `loadImage.js`. Add this code to the
    folder:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `video` 文件夹和 `loadImage.js` 开始。将此代码添加到文件夹中：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Adding a comment line with `@flow` tells *Flow* to use its type-checking ability
    on this file. The `setImage` function is then defined with two arguments: `ctx`
    and `image`. The `ctx` argument is cast to an object and `image` to an image.
    If we had cast the image to a string, *Flow* would immediately have told us that
    the type was incompatible with the `setImage` function call.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中添加一行注释 `@flow` 告诉 *Flow* 在此文件上使用其类型检查功能。然后定义 `setImage` 函数，它有两个参数：`ctx`
    和 `image`。`ctx` 参数被转换为对象，`image` 被转换为图像。如果我们把图像转换为字符串，*Flow* 会立即告诉我们类型与 `setImage`
    函数调用不兼容。
- en: Enough with Flow; let's examine what this file does. It has two functions, but
    only one is exported. The `loadImage` function takes an image and fetches it to
    the `image` variable, namely `bgImage`. This is a network call so the module can't
    return the image immediately, but we tell the function to execute the `setImage`
    function as soon as the image is loaded. This function will then draw the image
    on to the canvas that we passed in.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 不再使用Flow；让我们看看这个文件做了什么。它有两个函数，但只有一个被导出。`loadImage`函数接受一个图像并将其获取到`image`变量，即`bgImage`。这是一个网络调用，因此模块不能立即返回图像，但我们将函数设置为在图像加载后立即执行`setImage`函数。然后该函数将在我们传入的画布上绘制图像。
- en: 'The next file is `clear.js`, which needs to be added to the `source/engine/video`
    folder as well. Add this code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个文件是`clear.js`，它还需要添加到`source/engine/video`文件夹中。向其中添加以下代码：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When called, this completely clears the canvas.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当被调用时，这将完全清除画布。
- en: 'The next file is `shuffle.js` in the `source/engine/math` folder. Add it with
    this code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个文件是`shuffle.js`，位于`source/engine/math`文件夹中。添加它并使用以下代码：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This line fetches a random number between `0` and the number of remaining items
    in the counter. The single pipe is a bitwise `or` operator, which in this case
    removes the fraction. It works much in the same way as `Math.floor()` but is faster
    because bitwise operators are primitive. It''s arguably more convoluted and harder
    to understand, so wrapping the math operation with `Math.floor()` is a good idea
    if you want the code to be more readable. We''ll then assign the item to the `temp`
    variable in sequence, and move the current item at the random number to the current
    counter in the array:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码在`0`和剩余项目数之间获取一个随机数。单个管道是一个位运算符，在这种情况下用于去除小数部分。它的工作方式与`Math.floor()`非常相似，但速度更快，因为位运算符是原生的。它可能更复杂，更难理解，所以如果你想让代码更易读，用`Math.floor()`包装数学操作是个好主意。然后我们将按顺序将项目分配给`temp`变量，并将随机数处的当前项目移动到数组中的当前计数器：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we''ll set the array at the random number to the item in sequence.
    This ensures that all items are accounted for:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将随机数设置到数组中的项目顺序。这确保了所有项目都被计算在内：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As the name suggests, the `shuffle` function accepts an array collection and
    then shuffles it using a loop over all the items in the input array.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，`shuffle`函数接受一个数组集合，然后通过遍历输入数组中的所有项目来对其进行洗牌。
- en: 'The second file in the `math` folder is `sign.js`. Add this code to it:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`math`文件夹中的第二个文件是`sign.js`。向其中添加以下代码：'
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Sign is a mathematical expression that returns an integer that indicates the
    sign of a number. We'll use the built-in `sign` function if available, or our
    own if not. We'll use this when setting up movement for enemy entities targeting
    the player.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 符号是一个数学表达式，它返回一个整数，表示数字的符号。如果可用，我们将使用内置的`sign`函数，否则将使用我们自己的。我们将使用它来设置针对玩家的敌人实体的移动。
- en: 'Next is the `input` folder. Add `keyboard.js` with this code to it:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`input`文件夹。向其中添加`keyboard.js`并添加以下代码：
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This file adds an event listener that registers keys when the player pushes
    any keys on the keyboard and deletes them from the key array when the event listener
    detects that the key is being released (the user is no longer pressing the key
    down).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件添加了一个事件监听器，当玩家在键盘上按下任何键时注册键，并在事件监听器检测到键被释放（用户不再按下键）时从键数组中删除它们。
- en: 'Let''s add the `entity` folder. Here we''ll add five files. The first one is
    `targetEntity.js`. Add this code to it:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加`entity`文件夹。在这里我们将添加五个文件。第一个是`targetEntity.js`。向其中添加以下代码：
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We'll use this file to set one entity on the path towards the position of another
    entity. In the game we're making, we will use this code to direct an enemy entity
    to the player or vice versa. The entity is an object that has a certain size,
    position, and velocity, and the code works by changing the `x` and `y` position
    of the `entityA` object.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用此文件来设置一个实体在另一个实体位置路径上的一个实体。在我们制作的游戏中，我们将使用此代码来指导一个敌人实体指向玩家或反之亦然。实体是一个具有一定大小、位置和速度的对象，代码通过改变`entityA`对象的`x`和`y`位置来实现。
- en: We'll use the `sign` method to set the correct sign. If we don't do this, it
    will most likely move away from the entity instead of moving towards it.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`sign`方法设置正确的符号。如果我们不这样做，它很可能会远离实体而不是朝向它移动。
- en: 'Next up is `randomMove.js`. Add the file and this code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`randomMove.js`。添加文件并添加以下代码：
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When `entity.tick` reaches zero, a new direction will be calculated. Now check
    this out:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当`entity.tick`达到零时，将计算一个新的方向。现在看看这个：
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In order to make the direction recalculation a little more random, the new
    tick value is set between a value of `0` and `50`. Let''s move on to another function:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使方向重新计算更加随机，新的tick值被设置为`0`到`50`之间的一个值。让我们继续到另一个函数：
- en: '[PRE26]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This function implements a random direction for computer-controlled entities.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数实现了计算机控制实体的随机方向。
- en: 'The next file we''ll create is `drawEntity.js`. Add this code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要创建的文件是`drawEntity.js`。添加以下代码：
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This file is similar to `loadImage`, except that we''ll add a state to the
    entity by setting two variables: `_creating` and `_sprite`. We''ll use this in
    the game later by only actually drawing entities that have a proper `ImageData`
    object (contained in `_sprite`).'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件与`loadImage`类似，但我们将通过设置两个变量`_creating`和`_sprite`为实体添加一个状态。我们将在游戏中稍后使用它，只实际绘制具有适当的`ImageData`对象（包含在`_sprite`中）的实体。
- en: 'The final file in the `entity` folder is `createEntity.js`. Add this code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`entity`文件夹中的最后一个文件是`createEntity.js`。添加以下代码：'
- en: '[PRE28]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This provides the entity with an ID, take a look at the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这为实体提供了一个ID，请看以下内容：
- en: '[PRE29]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Flag it so we don''t try to create the entity twice. Let''s take a look at
    the following code snippet:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 标记它，这样我们就不尝试创建实体两次。让我们看一下下面的代码片段：
- en: '[PRE30]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We''re almost done with the engine. We''ll need to add one more folder and
    file, `collision` and `bruteForce.js`, respectively. Add it with this code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了引擎。我们需要添加一个额外的文件夹和文件，分别是`collision`和`bruteForce.js`。使用以下代码添加它：
- en: '[PRE31]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This function will compare the positions of two entities and determine whether
    they're occupying the same space. For small canvases and a limited number of entities
    on screen, it's the fastest collision detection you can conceivably implement.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将比较两个实体的位置并确定它们是否占据相同的空间。对于小画布和屏幕上有限的实体数量，这是你可以想象到的最快的碰撞检测实现。
- en: You now have a small working game engine. Let's move on and start implementing
    the game.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有一个小型的工作游戏引擎。让我们继续并开始实现游戏。
- en: Creating the game
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建游戏
- en: 'The game itself is going to be larger than the engine. This is not uncommon,
    especially for HTML5 games, but brace yourself because we''re going to add a lot
    of files. Let''s take a look at the following screenshot:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏本身将比引擎更大。这对HTML5游戏来说并不罕见，但请做好准备，因为我们将要添加很多文件。让我们看一下下面的截图：
- en: '![Creating the game](img/B04943_10_01.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![创建游戏](img/B04943_10_01.jpg)'
- en: 'This is the file structure for the game (excluding the engine):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是游戏的文件结构（不包括引擎）：
- en: '[PRE32]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Let's start with the `root` source files.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`root`源文件开始。
- en: 'Add this to `index.jsx`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容添加到`index.jsx`：
- en: '[PRE33]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `Config` file is where we''ll provide the game with all of the content,
    as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`Config`文件是我们将提供游戏所有内容的文件，如下所示：'
- en: '[PRE34]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We display either the title or the game screen when the player starts the game.
    We implement the switch by providing the components with a `setState` callback,
    which means that anytime we want to switch to a scene, we can use `this.props.cb(scene)`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家开始游戏时，我们显示标题或游戏屏幕。我们通过为组件提供一个`setState`回调来实现切换，这意味着任何时候我们想要切换到场景，我们都可以使用`this.props.cb(scene)`。
- en: 'Next, add `polyfills.js` with this code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加`polyfills.js`，代码如下：
- en: '[PRE35]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This is a shim to provide support for `requestAnimationFrame` for the browsers
    that don't support it yet. As you can see in the code, it will implement `setTimeOut`
    if `requestAnimationFrame` is not supported. We want to use `requestAnimationFrame`
    because it's more efficient than `setTimeOut`, which is less accurate and also
    wastes a lot of cycles by rendering when it's not necessary.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个垫片，用于为尚未支持`requestAnimationFrame`的浏览器提供支持。正如你在代码中所见，如果`requestAnimationFrame`不受支持，它将实现`setTimeOut`。我们想使用`requestAnimationFrame`因为它比`setTimeOut`更高效，`setTimeOut`不够准确，而且在不需要渲染时也会浪费很多周期。
- en: 'Let''s add `title.jsx`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加`title.jsx`：
- en: '[PRE36]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Start the game if the player hits space on the keyboard. The next is as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家在键盘上按下空格键，则开始游戏。下面是下一步：
- en: '[PRE37]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This avoids updating the game if the canvas has not yet been initialized. The
    following code tells the game to listen for keyboard input:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这避免了在画布尚未初始化时更新游戏。以下代码告诉游戏监听键盘输入：
- en: '[PRE38]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This is the main game loop:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这是主游戏循环：
- en: '[PRE39]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Even though this is a title scene, we treat it as a mini game and update it
    accordingly. This enables us to easily animate the title screen using entities
    and game logic and use the same input methods as in the game, let''s take a look
    at the following code snippet:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是一个标题场景，但我们将其视为一个迷你游戏并相应地更新它。这使得我们能够轻松地使用实体和游戏逻辑来动画化标题屏幕，并使用与游戏中相同的输入方法，让我们看一下下面的代码片段：
- en: '[PRE40]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, add `style.scss` with this code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加`style.scss`并使用以下代码：
- en: '[PRE41]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'And finally, we add the game itself. Add `game.jsx` with this code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加游戏本身。添加`game.jsx`并使用以下代码：
- en: '[PRE42]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We''ll need to create all of these components in order for the game to work.
    When developing a game, it''s quite common to inline these components. When iterating
    the game, you''ll get a feel for how to separate them into distinct components
    and how you can shape them for reuse, let''s take a look at the following code
    snippet:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建所有这些组件，以便游戏能够正常运行。在开发游戏时，通常会将这些组件内联。在迭代游戏时，你会了解如何将它们分离成独立的组件，以及如何对它们进行修改以实现复用。让我们看一下以下代码片段：
- en: '[PRE43]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This is a countdown that will be used when the game is over and the player
    is returned to the title screen, take a look at the following code snippet:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个倒计时，将在游戏结束后，玩家返回到标题屏幕时使用。请看以下代码片段：
- en: '[PRE44]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This is another countdown. It''s used whenever the player is shooting and prevents
    the player from spamming the board with projectiles, let''s take a look at the
    following code snippet:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这又是一个倒计时。它用于玩家射击时，防止玩家在板上用弹射物进行垃圾邮件式攻击。让我们看一下以下代码片段：
- en: '[PRE45]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The game board is 512 x 512 pixels and each individual entity is 32 x 32 pixels.
    It''s easier to visualize the placement on the board by dividing the board size
    by the entity size. By looking at this value, it''s easy to understand that the
    current player is placed in the middle of the board. It might be a little harder
    if we had used the precise pixel value, which is 256 x 256\. Now, let''s look
    at the next step:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏板是512 x 512像素，每个单独的实体是32 x 32像素。通过将板大小除以实体大小，可以更容易地可视化板上的放置。通过查看这个值，很容易理解当前玩家被放置在板的中间。如果我们使用了精确的像素值，即256
    x 256，可能会稍微困难一些。现在，让我们看看下一步：
- en: '[PRE46]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Whenever the `gameOver` flag has been set to `true`, we tell the game to pause
    and start the counter that will return the player to the title screen when the
    counter hits zero, take a look at the following code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当`gameOver`标志被设置为`true`时，我们告诉游戏暂停，并启动一个计数器，当计数器达到零时，将玩家返回到标题屏幕。请看以下代码：
- en: '[PRE47]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This is a single player game, but you could add more players to the game by
    extending the `players` array in `config` and switch them by iterating the `current_player_no`
    variable. This function is responsible for drawing the player and any enemies
    and projectiles:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个单人游戏，但你可以通过在`config`中的`players`数组中添加更多玩家来扩展游戏，并通过迭代`current_player_no`变量来切换他们。这个函数负责绘制玩家以及任何敌人和弹射物：
- en: '[PRE48]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This function draws the score and the player health at the top of the screen:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数在屏幕顶部绘制得分和玩家生命值：
- en: '[PRE49]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This is a rather advanced function that handles all the key input in the game:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当高级的函数，用于处理游戏中的所有键输入：
- en: '[PRE50]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'It requires the `Config` object for calculating the position of the projectiles,
    the keys for handling the moving and shooting actions, the `player` object, and
    a modifier that can be used to speed up or down the movement. It also requires
    that you pass the function that creates a projectile and two callbacks: the first
    for adding the projectile to the `entities` array and the second a setter for
    the `coolDown` variable. The higher this last value is, the fewer projectiles
    the player can fire. For every iteration, the projectile moves according to its
    velocity:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 它需要`Config`对象来计算弹射物的位置，处理移动和射击动作的键，`player`对象，以及一个可以用来加快或减慢移动速度的修饰符。它还要求你传递创建弹射物的函数和两个回调：第一个用于将弹射物添加到`entities`数组，第二个用于设置`coolDown`变量。这个最后值越高，玩家能发射的弹射物就越少。对于每一次迭代，弹射物都会根据其速度移动：
- en: '[PRE51]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The following loop is necessary to check whether any of the projectiles collide
    with any of the monsters:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下循环是必要的，用于检查是否有任何弹射物与任何怪物发生碰撞：
- en: '[PRE52]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'It''s a loop within a loop, which is something we generally should be careful
    with because it can be a major source of slowdown. Now check out the following
    code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个嵌套循环，我们通常应该小心处理，因为它可能是性能下降的主要原因。现在，看看以下代码：
- en: '[PRE53]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'As illustrated, if the projectile collides with an enemy, the enemy loses 20
    health points and we remove the projectile from the entities array. This makes
    sure it''s not drawn in the next run of the game loop. The next check removes
    the enemy if its health is less than zero:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如上图所示，如果弹射物与敌人碰撞，敌人会损失20点生命值，并且我们将弹射物从实体数组中移除。这确保了它不会在游戏循环的下一轮中被绘制。下一个检查会移除生命值小于零的敌人：
- en: '[PRE54]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This function takes care of removing projectiles that have escaped the canvas.
    This is important because we don''t want to keep the list of elements that we
    calculate as small as possible. We move on to the next loop:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数负责移除逃离画布的弹丸。这很重要，因为我们不想保留我们计算出的元素列表尽可能小。我们继续到下一个循环：
- en: '[PRE55]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This loop checks whether the enemies are close to or are colliding with the
    player. If they are close, it should head straight for the player. Try increasing
    the range to make the game more difficult.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环检查敌人是否接近或与玩家发生碰撞。如果它们接近，它们应该直接向玩家移动。尝试增加范围以使游戏更具挑战性。
- en: If they collide, the player loses health.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它们发生碰撞，玩家会失去生命值。
- en: 'If none of these occur, we provide a random direction for the entity:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些情况都没有发生，我们为实体提供一个随机的方向：
- en: '[PRE56]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Any time a player clears out the current set of enemies, they advance to the
    next level:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 每当玩家清空当前的一组敌人时，他们就会进入下一级：
- en: '[PRE57]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Each level comes with more enemies. This check makes sure that we add as many
    `enemy` entities as the current level dictates:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 每个级别都会带来更多的敌人。这个检查确保我们添加的 `enemy` 实体数量与当前级别的要求相符：
- en: '[PRE58]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'If the player is out of health, we store the current canvas image and use that
    as the game over screen. We then clear out the entities and set the `gameOver`
    flag:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家的生命值耗尽，我们将当前画布的图像存储起来，并将其用作游戏结束屏幕。然后，我们清除实体并设置 `gameOver` 标志：
- en: '[PRE59]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'When mounting the game, we reset the score, level, and current enemy. This
    lets us start fresh when the player has hit game over and presses space to play
    again:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当挂载游戏时，我们重置得分、级别和当前敌人。这样，当玩家击中游戏结束并按下空格键重新开始游戏时，我们可以从头开始：
- en: '[PRE60]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The following screenshot shows the game with the player visible, with enemy
    entities swarming the player and a score and a health bar in the title bar. At
    the bottom of the screen, you see the player name (randomly picked from the `name`
    array) and the current difficulty level:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了玩家可见的游戏画面，敌人实体正在蜂拥而至，标题栏中有一个得分和生命条。屏幕底部，你可以看到玩家的名字（从 `name` 数组中随机选择）和当前的难度级别：
- en: '![Creating the game](img/B04943_10_02.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![创建游戏](img/B04943_10_02.jpg)'
- en: 'That''s it for the game file, but as you noticed, we have several more files
    to add. We''ll need to add two new folders: `components` and `config`. Let''s
    start with `config`. Add this folder and the `index.js` file. Then, add this content:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是游戏文件的全部内容，但正如你所注意到的，我们还有更多文件要添加。我们需要添加两个新的文件夹：`components` 和 `config`。让我们从
    `config` 开始。添加这个文件夹和 `index.js` 文件。然后，添加以下内容：
- en: '[PRE61]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We haven''t added any pickups to the game, but it''d be a good idea to do this
    and add various items such as health, different weapons, and so on, let''s take
    a look at the following code:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有在游戏中添加任何拾取物，但这是一个好主意，并添加各种物品，如生命、不同的武器等等，让我们看一下以下代码：
- en: '[PRE62]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We''ll add a single player and give them a random name from the list of names
    and a random image from the list of players, let''s take a look at the following
    code snippet:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为玩家添加一个单独的玩家，并从玩家名单中随机选择一个名字，以及从玩家名单中随机选择一个图片，让我们看一下以下代码片段：
- en: '[PRE63]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Next, add `config/players.js` with this content:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加 `config/players.js` 并包含以下内容：
- en: '[PRE64]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This file adds variety to the game. It can also be useful if and when we add
    more players to the game.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件为游戏增添了多样性。如果我们添加更多玩家到游戏中，它也可能很有用。
- en: 'Finally, add `config/beasts.js` with this content:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加 `config/beasts.js` 并包含以下内容：
- en: '[PRE65]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We're done with the configuration, so let's add all the game components.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了配置，所以让我们添加所有的游戏组件。
- en: 'Add `components/addEntity.js` with this code:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 添加 `components/addEntity.js` 并包含以下代码：
- en: '[PRE66]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We add variety with `shuffle` and `Math.random`. We want their movement to be
    erratic, and we want some to move faster than others.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过 `shuffle` 和 `Math.random` 添加多样性。我们希望它们的移动是随机的，并且希望其中一些比其他移动得更快。
- en: 'Add `components/addProjectile.js` with this code:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 添加 `components/addProjectile.js` 并包含以下代码：
- en: '[PRE67]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This code is quite similar to the previous one, so it's worth considering whether
    the two files can be joined. There's a popular acronym in computer science called
    **DRY**, which stands for **Don't Repeat Yourself**. The intention is to identify
    code that is conceptually repetitive, such as `addEntity` and `addProjectile`,
    and then make an effort to make one single function.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与上一段非常相似，因此值得考虑是否可以将这两个文件合并。在计算机科学中有一个流行的缩写词 **DRY**，代表 **Don't Repeat Yourself**（不要重复自己）。其目的是识别概念上重复的代码，例如
    `addEntity` 和 `addProjectile`，然后努力将其合并成一个单一的功能。
- en: 'The next file we''re going to add is `checkCollision.js`. Add it with this
    code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要添加的文件是 `checkCollision.js`。添加它并包含以下代码：
- en: '[PRE68]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We'll reuse the `bruteForce` collision check and display a little **Ouch** over
    the player's entity whenever it collides with something.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重用 `bruteForce` 碰撞检测，并在玩家实体与任何东西碰撞时在其上方显示一个小小的 **Ouch**。
- en: 'Next, add `components/drawEntities.js` and add this code:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，添加 `components/drawEntities.js` 并使用以下代码：
- en: '[PRE69]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This is used in the game loop to draw all the entities on the screen. The order
    is important because the entity that is drawn first will be overlapped by the
    next entity that is drawn. If you draw the player first, the projectiles and the
    enemies will appear on top of the player in collisions.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏循环中，此代码用于绘制屏幕上的所有实体。顺序很重要，因为首先绘制的实体将被下一个绘制的实体覆盖。如果你先绘制玩家，投射物和敌人将出现在玩家上方，发生碰撞时。
- en: 'Next, add `components/drawGameOver.js` with this code:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，添加 `components/drawGameOver.js` 并使用以下代码：
- en: '[PRE70]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Then add `components/drawGameWon.js` with this code:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然后添加 `components/drawGameWon.js` 并使用以下代码：
- en: '[PRE71]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: They're both similar and will display different text depending on whether it's
    a regular game over event or whether the player has completed the game. You can
    add colors and use different fonts and font sizes to make the text more appealing.
    It works much in the same way as CSS, by cascading downwards. Notice that the
    second line of text in the win condition has a smaller font size than the first
    one and how it's arranged to make this happen.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都很相似，并且会根据是常规游戏结束事件还是玩家完成游戏而显示不同的文本。你可以添加颜色，使用不同的字体和字体大小来使文本更具吸引力。它的工作方式与
    CSS 类似，通过向下级联。注意，胜利条件中的第二行文本的字体大小比第一行小，以及它是如何排列以实现这一点的。
- en: 'Next, add `components/drawHud.js` and add this code:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，添加 `components/drawHud.js` 并添加以下代码：
- en: '[PRE72]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Note that the primary difference between this and the other text functions is
    the positioning of the text.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这与其他文本函数的主要区别是文本的位置。
- en: 'Add `components/clearCanvas.js` with this code:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码添加 `components/clearCanvas.js`：
- en: '[PRE73]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This component will replace the current canvas with the provided image. We'll
    use a snapshot from the game just after the `gameOver` flag is set for the game
    over screen.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件将用提供的图像替换当前画布。我们将使用游戏在 `gameOver` 标志设置后的快照作为游戏结束屏幕。
- en: 'Add `components/outOfBunds.js` with this code:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码添加 `components/outOfBunds.js`：
- en: '[PRE74]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This will return `true` if an entity is outside the canvas.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个实体在画布外，这将返回 `true`。
- en: 'Add `components/removeEntity.js` with this code:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码添加 `components/removeEntity.js`：
- en: '[PRE75]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: This file will execute the callback before returning a filtered `entity` array.
    In our code, the callback either contains an empty function or a function that
    updates the score.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件将在返回过滤后的 `entity` 数组之前执行回调。在我们的代码中，回调要么是一个空函数，要么是一个更新得分的函数。
- en: 'Next, add `components/setupGame.js` with this code:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，添加 `components/setupGame.js` 并使用以下代码：
- en: '[PRE76]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Here we add the player entities. Note that we set the position by multiplying
    with the tile size to set the real position on the board:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加玩家实体。注意，我们通过乘以瓦片大小来设置位置，以在板上设置实际位置：
- en: '[PRE77]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: We're almost done with the `components` folder. All we need to do now is add
    one more file and a subfolder with a few `keypress` files.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了 `components` 文件夹。我们现在需要添加一个文件和一个包含几个 `keypress` 文件的子文件夹。
- en: Responding to keyboard events
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应键盘事件
- en: 'First, add `components/keyInput.js` with this code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，添加 `components/keyInput.js` 并使用以下代码：
- en: '[PRE78]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'This function will make sure a projectile is added, but it won''t do anything
    until the `coolDown` variable is at or below zero:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将确保添加一个投射物，但直到 `coolDown` 变量达到或低于零之前，它不会做任何事情：
- en: '[PRE79]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Next, add the `keypress` folder to the `components` folder.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，将 `keypress` 文件夹添加到 `components` 文件夹中。
- en: 'For each file, add the corresponding code, as illustrated here:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个文件，添加相应的代码，如下所示：
- en: 'The code for `a.js` is as follows:'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a.js` 的代码如下：'
- en: '[PRE80]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'For `d.js`, refer to the following:'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `d.js`，请参考以下内容：
- en: '[PRE81]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Here''s the code for `s.js`:'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是 `s.js` 的代码：
- en: '[PRE82]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'For `w.js`, refer to the following:'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `w.js`，请参考以下内容：
- en: '[PRE83]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The code for `down.js`:'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`down.js` 的代码如下：'
- en: '[PRE84]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'For the `up.js` file:'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `up.js` 文件：
- en: '[PRE85]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'We move on to the `left.js` file:'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们继续到 `left.js` 文件：
- en: '[PRE86]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Now, the `right.js` file:'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，是 `right.js` 文件：
- en: '[PRE87]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'For `space.js`, refer to the following:'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `space.js`，请参考以下内容：
- en: '[PRE88]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'And finally, the `index.js` file:'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，是 `index.js` 文件：
- en: '[PRE89]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Our game is now complete and ready to be played. At the current setting, the
    game is probably too difficult, but with a little bit of balancing, it should
    be possible to make it easier for the player to win. Let''s take a look at the
    following screenshot:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏现在已完成，并准备好被玩。在当前设置下，游戏可能太难，但通过一点平衡，应该可以使玩家更容易获胜。让我们看看以下截图：
- en: '![Responding to keyboard events](img/B04943_10_03.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![响应键盘事件](img/B04943_10_03.jpg)'
- en: Further improvements
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步改进
- en: 'You can improve the game in a number of ways. Here''s a list of things you
    can add:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过多种方式改进游戏。以下是你可以添加的项目列表：
- en: Add sound with WebAudio
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用WebAudio添加声音
- en: Restrict the number of fireballs the player can fire at one time, or add a limit
    to how many fireballs the player has and add pickups to increase that limit
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制玩家一次可以发射的火球数量，或者限制玩家拥有的火球数量，并添加拾取物品来增加这个限制
- en: Utilize resource caching to preload all assets
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用资源缓存来预加载所有资产
- en: Sprite animation
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精灵动画
- en: Bonus pickups for increased playability, for instance, hearts for increasing
    health or new weapons for wielding more damage
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加游戏可玩性的奖励拾取物品，例如，增加生命值的心形或造成更多伤害的新武器
- en: Have the enemies fire at the player
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让敌人向玩家开火
- en: Provide the reader with alternate controls (moving with arrow keys and shoot
    with `wsad`)
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为读者提供替代控制方式（使用箭头键移动，使用`wsad`射击）
- en: Add more screens and a better progression between levels
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加更多屏幕和更好的关卡间进度
- en: Add a transition effect between the levels, rewarding the player with encouraging
    text saying that progress has been made, and then introduce the next enemy entity
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在关卡之间添加过渡效果，奖励玩家鼓励性的文字，说明已经取得了进步，然后介绍下一个敌人实体
- en: Add a possibility to pause the game
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加暂停游戏的可能性
- en: Add a fullscreen option
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加全屏选项
- en: Summary
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You've made a game engine and a game in ReactJS. That's quite an achievement.
    We started using Flowtype and we optimized the way we create `React.js` projects
    with Webpack.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经制作了一个ReactJS的游戏引擎和游戏。这是一个相当大的成就。我们开始使用Flowtype，并优化了我们使用Webpack创建`React.js`项目的方式。
- en: If you want to check out what we just created, visit [https://reactjsblueprints-chapter10.herokuapp.com/](https://reactjsblueprints-chapter10.herokuapp.com/).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看我们刚刚创建的内容，请访问[https://reactjsblueprints-chapter10.herokuapp.com/](https://reactjsblueprints-chapter10.herokuapp.com/)。
- en: I sincerely hope you enjoyed this chapter and the book, and I hope that by completing
    all these projects, you now have a solid foundation for creating your own projects
    in ReactJS.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我真诚地希望你喜欢这一章和这本书，并且希望通过完成所有这些项目，你现在为在ReactJS中创建自己的项目打下了坚实的基础。
