- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Architecture for Large-Scale Web Apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we explored building and scaling large-scale applications
    in Vue 3\. We discussed why we need Vue.js performance optimization, the primary
    reasons behind poor Vue performance, how to check your Vue.js application’s bundle
    size, and optimizing the performance of an enterprise Vue application using different
    methods such as asynchronous/lazy component loading, WebP images, and image compression
    and code splitting.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to handle a sizable enterprise-ready project,
    from managing larger file structures to using the micro frontend architecture.
    We will also learn how to handle the internationalization and localization of
    our Vue.js 3 project.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following key topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: File architecture and structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Micro frontend architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internationalization and localization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will know how to architect large-scale web apps
    with Vue 3, how to implement structures and file architecture using the law of
    predictability, and how to use community-recommended packages to inform predictability
    in your Vue.js 3 enterprise-ready application.
  prefs: []
  type: TYPE_NORMAL
- en: You will also learn how to use micro frontend architecture to your advantage
    and how to implement an Atomic Design with Storybook to streamline your component
    directory and make your enterprise project less difficult to understand.
  prefs: []
  type: TYPE_NORMAL
- en: And lastly, you will learn how to add and properly integrate internationalization
    in to your Vue application and about the benefits this brings.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get started with this chapter, I recommend you read through [*Chapter 3*](B17237_03.xhtml#_idTextAnchor087),
    *Scaling Performance in Vue.js 3*, where we elucidate the building and scaling
    of large-scale applications in Vue 3.
  prefs: []
  type: TYPE_NORMAL
- en: All the code files for this chapter can be found at [https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-4](https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-4).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding file architecture and structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Structuring your project depends solely on the preference of your organization
    and how easy it is to access files and folders when fixing bugs and adding new
    features.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will explore different principles that will give you an
    idea of how you can structure your project to incorporate best practices, standards,
    and easy-to-access files.
  prefs: []
  type: TYPE_NORMAL
- en: What is the most effective way to structure your project to scale and keep it
    maintainable and extendable the more it grows?
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a common question in the software development industry but there is
    no one-size-fits-all method. It all depends on the principle of predictability,
    as discussed in this article: [https://vueschool.io/articles/vuejs-tutorials/how-to-structure-a-large-scale-vue-js-application/](https://vueschool.io/articles/vuejs-tutorials/how-to-structure-a-large-scale-vue-js-application/).'
  prefs: []
  type: TYPE_NORMAL
- en: The principle of predictability is simply the ability to go from point A to
    point B in any code base to intuitively go from a feature request or bug report
    to the location in the code base where the said task can be addressed. Furthermore,
    it’s the ability to quickly or easily understand a particular code base based
    on the standard use of community or popular libraries and tools.
  prefs: []
  type: TYPE_NORMAL
- en: To elaborate, when a code base uses standard, community-agreed, and popular
    libraries or tools, it gives a great developer experience as developers are already
    familiar with these tools.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will delve deeper into discussing predictability and
    how we can achieve it in Vue 3.
  prefs: []
  type: TYPE_NORMAL
- en: Predictability in Vue 3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How to achieve predictability in Vue 3 is very simple, as stated previously;
    it boils down to using Vue 3 standards and style guides.
  prefs: []
  type: TYPE_NORMAL
- en: For example, just imagine buying a new iPhone 13 ProMax in a different size;
    it will be awkward since you must have certainly predicted the size to stay the
    same from your reviews.
  prefs: []
  type: TYPE_NORMAL
- en: The approach applies to the mindsets of developers toward a new code base; we
    expect most libraries, component names, files, and folder structures to follow
    Vue 3 community standards and style guide with a little adjustment to suit the
    organization’s use case (if any).
  prefs: []
  type: TYPE_NORMAL
- en: So how can we achieve predictability in Vue 3? In the following subsections,
    we will look at a few ways to achieve standards in your enterprise Vue 3 application.
  prefs: []
  type: TYPE_NORMAL
- en: Community-wide standards for predictability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you’re coming from Vue 2, you should already be familiar with the standards
    that exist within it. We will discuss adding more Vue 3 specific standards from
    there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Vue has the following pages where you can look out for community standards:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by reviewing the official Vue.js style guide ([https://v3.vuejs.org/style-guide/#rule-categories](https://v3.vuejs.org/style-guide/#rule-categories))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always use the scaffolding generated by the Vue **command-line interface** (**CLI**)
    or Vite in Vue 3 ([https://vuejs.org/guide/quick-start.html](https://vuejs.org/guide/quick-start.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The official Vue.js libraries are found under the *Community* *Guide* ([https://vuejs.org/about/community-guide.html](https://vuejs.org/about/community-guide.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use one of the most popular component frameworks such as Vuetify ([https://vuetifyjs.com/en/](https://vuetifyjs.com/en/))
    or Quasar ([https://quasar.dev/](https://quasar.dev/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Official libraries and component libraries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using official libraries and component libraries not only brings functionality
    to your project but also enforces standards and allows you to build applications
    following standard and generally acceptable patterns according to the Vue community.
  prefs: []
  type: TYPE_NORMAL
- en: For example, Vuex is a state management system that prides itself on implementing
    a pattern and a library together because it enforces a standard to follow when
    building Vue applications.
  prefs: []
  type: TYPE_NORMAL
- en: Another great example is Vue Router, which enables developers to build routing
    systems in ways that are adaptable to other projects.
  prefs: []
  type: TYPE_NORMAL
- en: And the good thing about all of this is when a developer who has built with
    these libraries is added to a new code base, using these tools, it becomes predictable.
  prefs: []
  type: TYPE_NORMAL
- en: Standard file structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another important aspect of project standards is the file structure. The file
    structure is an arguable aspect of project standards because different organizations
    and projects use different structures and Vue does not provide detailed documentation
    specifying a structure.
  prefs: []
  type: TYPE_NORMAL
- en: However, when you use the official Vue CLI, it provides a starting point for
    creating a standard folder and file structure that is widely used in the Vue.js
    world, and it’s most familiar for Vue developers around the world.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block shows how to create a new Vue 3 project using the
    official Vue 3 standalone CLI called Vite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the official project scaffolding using the Vue
    3 official CLI called Vite:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Official Vue CLI file structure](img/Figure_4.01_B17237.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Official Vue CLI file structure
  prefs: []
  type: TYPE_NORMAL
- en: The initial structure used in the preceding screenshot should already be familiar
    to many developers, therefore making it predictable. Always stick with Vue’s initial
    structure, build on it, and only change it for a good reason.
  prefs: []
  type: TYPE_NORMAL
- en: Recommended component rules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Vue component directory is where the confusion begins because thousands
    of files and Vue components can be created, and it becomes very difficult to manage
    with time.
  prefs: []
  type: TYPE_NORMAL
- en: Adapting your code base to follow the official Vue 3 style guide is a starting
    point for a predictable code base and you can learn a lot about making your folder
    and file structure more predictable for developers from there. The style guide
    provides lots of community-wide standards and best practices for the Vue ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the most important points are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we have the **Single-File Component** (**SFC**) style guide, which states
    a lot of points to follow, with the important one being that your components should
    be named in PascalCase.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secondly, an SFC ([https://vuejs.org/guide/scaling-up/sfc.html](https://vuejs.org/guide/scaling-up/sfc.html))
    should always order the `<script>`, `<template>`, and `<style>` tags consistently,
    with `<style>` at the end. This is because the `script` and `template` tags are
    always necessary while the style tag is optional.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It also states that, when possible, each component should be defined in its
    own dedicated file (SFC). This is where Storybook or Atomic Design, in general,
    comes in to play as we will see in the following sections.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, component names should always be multi-worded to not conflict
    with any existing or future HTML elements. Don’t create a `Table` component or
    a `Button` component since there are HTML tags with those names already; you can
    create a multi-word such as the following `DataTable` or `CustomButton`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most importantly, tightly coupled child components should be prefixed with their
    parent component’s name, such as `TodoListItem` in a `TodoList` component. The
    method also helps in debugging, as developers can easily spot components with
    names in error messages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vue.js has a full style guide at [https://vuejs.org/style-guide/](https://vuejs.org/style-guide/)
    with a number of other standards that will help your project be more predictable
    for a community-wide audience of developers.
  prefs: []
  type: TYPE_NORMAL
- en: Recommended community-wide standards for predictability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Over the years, the Vue community has developed and argued on numerous different
    standards that should be used by Vue developers for a more predictive code base.
  prefs: []
  type: TYPE_NORMAL
- en: In the following subsections, we will discuss a handful of these standards and
    how to implement them in your enterprise project.
  prefs: []
  type: TYPE_NORMAL
- en: A flat component directory
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A flat component directory entails giving a specific naming convention to your
    Vue components and your team, sticking with that convention throughout application
    development.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use a single or nested directory structure, but the naming convention
    should stay the same. The next two screenshots show different ways to implement
    the flat component directory. The following screenshot shows a single flat component
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Single flat component directory](img/Figure_4.02_B17237.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Single flat component directory
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows a nested flat component directory:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 4.3 – Nested flat compo\uFEFF\uFEFFnent directory](img/Figure_4.03_B17237.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Nested flat component directory
  prefs: []
  type: TYPE_NORMAL
- en: Standardized route/page naming convention
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another important improvement to the principle of predictability is having proper
    and well-defined route/page naming conventions throughout your team and project.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, using routes/page naming conventions used in Laravel or AdonisJS
    makes it easy for developers who have prior knowledge of these frameworks to quickly
    predict the code base. The same is applicable if you define your custom convention
    and stick with it through your team. It allows new members to easily predict and
    understand your code base.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows how you can structure your routes to be predictable
    based on routing standards from Laravel and AdonisJS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Showing the pattern that can be adopted](img/Figure_4.04_B17237.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Showing the pattern that can be adopted
  prefs: []
  type: TYPE_NORMAL
- en: You should always reference your routes properly with their name when using
    them in router links and programmatically for more consistency and flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Also, note that not all routes will fit this pattern exactly, as some routes
    will be cruddier than others. If this happens, a good recommendation is to continue
    using PascalCase for your route names for consistency.
  prefs: []
  type: TYPE_NORMAL
- en: A more comprehensive file structure
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Using the basic file structure from the Vue CLI is a great starting point for
    predictability and can be extended from there to include other files and directories
    in a way that standardizes our enterprise project for better predictability.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows how to extend the file structure to include
    other necessary files and directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Extending the file structure from the default Vue CLI structure](img/Figure_4.05_B17237.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – Extending the file structure from the default Vue CLI structure
  prefs: []
  type: TYPE_NORMAL
- en: The additional files and folders will solely depend on your team, organization,
    or project, but the additional folders in *Figure 4**.5* are the structure we
    have defined for the project we are building, and extending it from the default
    Vue CLI structure makes it more predictable.
  prefs: []
  type: TYPE_NORMAL
- en: Also, providing a `README.md` file ([https://changelog.md/](https://changelog.md/))
    in the root of a standard directory explaining the purpose of the directory and
    any rules for what should be included in it or how to use the directory files
    is very useful. This comes in handy, especially for those standards that aren’t
    community-wide standards.
  prefs: []
  type: TYPE_NORMAL
- en: While we tend to make our code base predictable enough for developers, no matter
    how well the project uses community-wide standards and Vue style guides, there
    are cases where we need to define specific files and folders that are generic
    to our project or team.
  prefs: []
  type: TYPE_NORMAL
- en: While creating a predictable code base is great for larger projects and teams
    using the steps and patterns discussed in the previous sections, there is still
    a lot to explore, and in the next section, we will explore different patterns,
    architectures, and structures that can be used to structure your larger-scale
    enterprise projects.
  prefs: []
  type: TYPE_NORMAL
- en: Different frontend architectural patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will explore different architectural patterns we can use
    to structure our enterprise Vue 3 applications.
  prefs: []
  type: TYPE_NORMAL
- en: Micro frontend architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Micro frontend is the first architecture that comes to mind when it comes to
    structuring enterprise frontend projects. As expressed in the official documentation,
    it extends the concept of microservices in the backend to the frontend world.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of a micro frontend comes from the buzzword microservices ([https://martinfowler.com/articles/microservices.html](https://martinfowler.com/articles/microservices.html))
    used in a backend web application to split gigantic blocks into a smaller, more
    manageable code base.
  prefs: []
  type: TYPE_NORMAL
- en: This approach to software development makes it easier for teams to manage, maintain,
    and deploy larger and enterprise applications faster.
  prefs: []
  type: TYPE_NORMAL
- en: This concept, which has changed the way backend applications have been developed
    over many years, is introduced into frontend projects in the form of micro frontends.
  prefs: []
  type: TYPE_NORMAL
- en: According to Martin Fowler ([https://martinfowler.com/articles/micro-frontends.html](https://martinfowler.com/articles/micro-frontends.html)),
    “*Micro Frontend is an architectural style where independently deliverable frontend
    applications are composed into a* *greater whole*.”
  prefs: []
  type: TYPE_NORMAL
- en: In recent years, since the initial adoption, there has been tremendous adoption
    of this concept in larger projects, thereby bringing the benefits of microservices
    into frontend projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some key benefits that come with implementing the micro frontend
    architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: It comes with more scalable organizations with decoupled and autonomous teams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It brings smaller, more cohesive, and maintainable code bases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The provides the ability to upgrade, update, or even rewrite parts of the frontend
    in a more incremental fashion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As much as there are tremendous benefits to using this architecture in your
    enterprise project as outlined in the official documentation, the pattern requires
    a steep learning curve, a higher number of team expatriates, and a large number
    of team members.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows an end-to-end example of teams using a micro frontend
    for the Pinterest demo application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – An end-to-end example of teams using a micro frontend](img/Figure_4.06_B17237.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – An end-to-end example of teams using a micro frontend
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a diagram of how structuring the Pinterest demo application will look
    using the micro frontend architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – A screenshot of a micro frontend in action](img/Figure_4.07_B17237.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – A screenshot of a micro frontend in action
  prefs: []
  type: TYPE_NORMAL
- en: From the screenshot, we can easily separate each of the features into a different
    service and have a dedicated team of frontend engineers to work on it.
  prefs: []
  type: TYPE_NORMAL
- en: Micro frontend is one of the best architectural patterns to use in enterprise
    applications because the core ideas behind a micro frontend are having isolated
    team code, it being technology-agnostic, ownership, and so on. These features
    make developing enterprise applications a breeze. However, other patterns are
    also widely used, and we will explore them in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Atomic Design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Atomic Design ([https://bradfrost.com/blog/post/atomic-web-design/](https://bradfrost.com/blog/post/atomic-web-design/))
    is a methodology for crafting design systems. Brad Frost first introduced it for
    creating scalable design systems using ideas from chemistry.
  prefs: []
  type: TYPE_NORMAL
- en: From chemistry class, we know that matter comprises atoms that bond together
    to form molecules, which in turn combine to form more complex organisms and ultimately
    create all the matter in the universe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can break down our components into fundamental building blocks
    and work up from there. These building blocks can be divided into five components
    from the chemistry example, as listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: Atoms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Molecules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organisms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This diagram from Rohan Kamath ([https://blog.kamathrohan.com/atomic-design-methodology-for-building-design-systems-f912cf714f53](https://blog.kamathrohan.com/atomic-design-methodology-for-building-design-systems-f912cf714f53))
    gives a clear illustration of the Atomic Design elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – Atomic Design elements explained (source: https://blog.kamathrohan.com/atomic-design-methodology-for-building-design-systems-f912cf714f53)](img/Figure_4.08_B17237.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.8 – Atomic Design elements explained (source: https://blog.kamathrohan.com/atomic-design-methodology-for-building-design-systems-f912cf714f53)'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore each of these components to understand them.
  prefs: []
  type: TYPE_NORMAL
- en: Atoms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In science class, we learned that atoms are the basic building blocks of matter.
    But when applied to web interfaces, atoms are the HTML tags such as `input`, `label`,
    and so on. They can also be customized to include abstract elements such as color
    palettes, fonts, or animations.
  prefs: []
  type: TYPE_NORMAL
- en: Atoms are not very useful on their own except when combined with other elements
    to form molecules.
  prefs: []
  type: TYPE_NORMAL
- en: Molecules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we start combining atoms, things start to get a little interesting and
    tangible.
  prefs: []
  type: TYPE_NORMAL
- en: The smallest unit of a compound is called a molecule, and it comprises groups
    of atoms bonded together. In web interfaces, these molecules take on their own
    properties and serve as the backbone of any design system.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, a form input, label, or button is not very useful as standalone
    functionality, but when combined as a form, they become very useful because they
    can actually do something. Furthermore, by combining atoms to form useful components,
    these components become reusable and can also be combined to form organisms.
  prefs: []
  type: TYPE_NORMAL
- en: Organisms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An organism is the combination of different molecules used to form a relatively
    complex and distinct section of a component.
  prefs: []
  type: TYPE_NORMAL
- en: An organism is designed to consist of different or similar molecule types. For
    instance, a molecule can consist of a primary navigation, a list of social media
    channels, a search form, and a logo.
  prefs: []
  type: TYPE_NORMAL
- en: The wonderful part of building an organism from molecules is that it encourages
    creating standalone, portable, or reusable components.
  prefs: []
  type: TYPE_NORMAL
- en: Templates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Templates will already be familiar to the web development world; they are predefined
    groups of organisms stitched together to form a page. In templates, the designs
    start to come together, and the layout of the page becomes structured and visible.
  prefs: []
  type: TYPE_NORMAL
- en: Each template contains all related abstract molecules, organisms, and atoms
    in some cases. Since templates are visible pages or part of a page, clients can
    start to see the final design.
  prefs: []
  type: TYPE_NORMAL
- en: With templates, you can create different versions of your design, whether high
    fidelity, low fidelity, and so on. Templates are more HTML wireframes and can
    also become the final deliverable.
  prefs: []
  type: TYPE_NORMAL
- en: Pages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A page is a specific instance of a template; in some cases, a complex page can
    contain more than one template combined to form a bigger page.
  prefs: []
  type: TYPE_NORMAL
- en: A page gives an accurate depiction of what the user will ultimately see, and
    they are the highest level of fidelity and most tangible. It is typically where
    most time is spent, and more reviews revolve around it.
  prefs: []
  type: TYPE_NORMAL
- en: In Vue.js, pages represent the different routes users access when navigating
    your application.
  prefs: []
  type: TYPE_NORMAL
- en: Using Atomic Design principles gives us the ability to traverse from abstract
    pages or templates to concrete ones. Because of this, we can create systems that
    promote consistency and scalability while simultaneously showing things in their
    final context.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will learn how to use the Atomic Design pattern to structure
    our enterprise project and use Storybook for the design system.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: A design system is a set of interconnected patterns and standards to manage
    design at scale by reducing redundancy while creating a shared language and visual
    consistency across different pages and channels.
  prefs: []
  type: TYPE_NORMAL
- en: Storybook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Storybook can be implemented with any architectural pattern, such as Atomic
    Design, to build component-driven **user interfaces** (**UIs**) faster. According
    to the official website ([https://storybook.js.org/](https://storybook.js.org/)),
    Storybook is an open-source tool for building UI components and pages in isolation.
    It streamlines UI development, testing, and documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Storybook allows us, the developers, to create and test components in isolation.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to implement Storybook into our project
    and start using the Atomic Design principles to create a maintainable Vue.js 3
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Storybook in Vue.js 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visit the official documentation for Vue implementation ([https://storybook.js.org/docs/vue/get-started/introduction](https://storybook.js.org/docs/vue/get-started/introduction))
    to follow along with the implementation. In Storybook, everything revolves around
    stories. A story describes the state of a rendered component and captures everything
    a component should/can do when rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Storybook
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can use the Storybook CLI to install it in a single command by running it
    inside your existing Vue.js project’s root directory.
  prefs: []
  type: TYPE_NORMAL
- en: Storybook will look into your project’s dependencies during installation and
    provide you with the best configuration available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, depending on your framework, first, build your app and then check that
    everything works by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will start a new development server and open a browser
    window showing you a welcome screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9 – The welcome screen](img/Figure_4.09_B17237.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.9 – The welcome screen
  prefs: []
  type: TYPE_NORMAL
- en: Creating a story is as easy as telling the computer what a particular component
    will do, the properties needed to carry out the task, and the different designs
    a particular component can have. In the next section, we will explore how to create
    a story in Storybook.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a story
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we delve into creating stories (components), let’s make sure we’re in
    sync with our folder structure for this project using Atomic Design and Storybook.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the complete folder structure for implementing
    Atomic Design and the `stories` folder for Storybook:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10 – A screenshot showing the Vue 3 component and the Storybook
    structure](img/Figure_4.10_B17237.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.10 – A screenshot showing the Vue 3 component and the Storybook structure
  prefs: []
  type: TYPE_NORMAL
- en: From the screenshot example, we have restructured our Vue.js project to use
    the Atomic Design principle and folder structures (the red indicator), and Storybook
    added the `stories` folder (the yellow indicator) to help us understand how to
    write our own stories. We can delete the `stories` folder and follow the pattern
    in *Figure 4**.10* to create our story inside the `component` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can start creating stories; remember, a story has to depict a particular
    action or group of related actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a story we created for the `Button` component we will use throughout
    the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: For instance, a button will be created in the `atoms` directory because it is
    a single element, though it can have different properties and actions, such as
    being a blue button, white button, clickable button, disabled button, and so on.
    It’s still a button.
  prefs: []
  type: TYPE_NORMAL
- en: From the story, we can see that the `Button` component will have two sizes (`small`
    and `large`), also, it will have two designs, which are `primary` and `secondary`,
    and additionally, it will accept two properties, namely `primary` and `label`.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn how to write a story to test the properties and actions of the
    button using the official documentation ([https://storybook.js.org/docs/vue/get-started/whats-a-story](https://storybook.js.org/docs/vue/get-started/whats-a-story)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have created all your components and stories, you should have a directory
    like the one shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11 – A screenshot showing a complete directory including Storybook
    stories](img/Figure_4.11_B17237.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.11 – A screenshot showing a complete directory including Storybook
    stories
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, with your project arranged like this, it becomes easy for developers
    to understand the structure and where to find components easily. Members of the
    team can easily test out components with different properties before even using
    them in the real project using Storybook.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore how to create an internationalized application
    in Vue.js 3, which allows your application to not be limited to a single language
    and cultural setting.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing internationalization and localization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The essence of building an enterprise application is to support local markets
    around the world and to achieve this, that’s where internationalization comes
    into place.
  prefs: []
  type: TYPE_NORMAL
- en: The process of preparing software to support local languages and the cultural
    settings of other geographical locations is called **internationalization** (**I18n**).
  prefs: []
  type: TYPE_NORMAL
- en: I18n is often misrepresented as **localization** (**L10n**) and sometimes even
    translation.
  prefs: []
  type: TYPE_NORMAL
- en: While Il8n is a product development approach that is focused on making one code
    base capable of supporting worldwide languages and locale-specific formatting
    and behaviors, L10n makes a product specific to a target market or region(s),
    including translation of the interface and possible adaptation of terminology
    and more.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will first look into the benefits of internationalizing
    the software and further explore how to implement I18n in Vue 3.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of internationalizing software
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The benefits of creating internalized software are enormous and some of these
    are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: It creates higher-quality software that meets the technical and cultural needs
    of multiple locales
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides greater in-country customer acceptance and satisfaction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides a single source code for all languages of the product
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internalized software reduces time, cost, and effort for L10n
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internalized software is simpler, and supports easier maintenance for future
    iterations of the product
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Market acceptance is one of the major problems that arises when software is
    not fully internalized before or after release.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we will look at how to implement I18n in our enterprise Vue 3 application
    right from the development phase.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Vue I18n
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Vue 3, Vue-I18n is a great compatible plugin that is used to implement I18n,
    and it easily integrates some localization features into your Vue.js application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to internationalize your app:'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different ways to install the package according to the official documentation
    (`https://vue-i18n.intlify.dev/installation.html`), but we will install it using
    the `npm` command, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After installation, inside the Vue 3 `main.js` file, add the following script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the preceding setup, you should have internalization added to your Vue
    project, but it will easily get bloated when developers start adding translations.
    So, we recommend creating a `locales` folder where every locale-related configuration
    will be added.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create the folder and the files inside the root directory like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, inside each of the translation files, add the following codes and other
    translations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `index.js` file, add the following scripts to import different locales:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, add the files to your `createI18n` configuration in your `main.js`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Arranging your files and folder in this structure allows for easy adoption
    and maintainability. Let’s look at the final structure of our project, including
    internationalization, in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure \uFEFF4.12 – The final structure of the Vue 3 application](img/Figure_4.12_B17237.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 4.12 – The final structure of the Vue 3 application
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter reviewed in more depth architecting large-scale web apps with Vue
    3\. We discussed the structure and file architecture by diving deeper into the
    law of predictability and how to use community-recommended packages to inform
    predictability in your Vue.js 3 enterprise-ready application.
  prefs: []
  type: TYPE_NORMAL
- en: We also covered in detail how to use micro frontend architecture to your advantage.
    Also, we discussed how to implement an Atomic Design with Storybook to streamline
    your component directory and make your enterprise project less difficult to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we discussed how to add I18n to your Vue application. We also discussed
    the benefits and how to properly integrate I18n into your Vue 3 application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore GraphQL, GraphQL Apollo Server 2, queries,
    mutations, and how to integrate these technologies into your Vue.js 3 application.
    In addition, you will learn how to utilize GraphQL to deliver scalable and high-performing
    applications.
  prefs: []
  type: TYPE_NORMAL
