- en: '*Chapter 8*: Additional Provider Scopes'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*：额外的提供者作用域'
- en: This chapter seeks to explain how to use dependency injection scopes to develop
    more lean components and features in Angular Ivy. To explore these features, we
    will learn how to create a non-singleton service and how to reuse dependencies
    across Angular elements.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在解释如何使用依赖注入作用域在Angular Ivy中开发更精简的组件和功能。为了探索这些功能，我们将学习如何创建非单例服务以及如何在Angular元素之间重用依赖项。
- en: We will introduce the `any` provider scope by revising the theme service so
    that it can accept specific configurations when used in different scenarios using
    the `any` provider scope and rewiring the schools and course modules to be lazy
    loaded.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过修改主题服务，使其能够在使用`any`提供者作用域的不同场景中接受特定配置，并重新配置学校和课程模块以进行懒加载来引入`any`提供者作用域。
- en: We will then wrap up *Part 2, Build a Real-World Application with the Angular
    Ivy Features You Learned* by building a new login element that shows how to share
    information across application boundaries by using the platform provider scope
    for Angular Elements.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将通过构建一个新的登录元素来结束*第2部分，使用您学到的Angular Ivy功能构建真实世界的应用程序*，该元素展示了如何通过使用Angular
    Elements的平台提供者作用域来跨应用程序边界共享信息。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中将涵盖以下主题：
- en: Revisiting the root provider scope
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新审视根提供者作用域
- en: Using the any provider scope for a configurable theme service
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用任何提供者作用域的可配置主题服务
- en: Sharing information across application boundaries using the platform provider
    scope
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用平台提供者作用域在应用程序边界之间共享信息
- en: Before we dive into the details about the new provider scopes, let's take a
    moment to reflect on the services we have introduced so far using the root provider
    scope.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨新提供者作用域的细节之前，让我们花一点时间回顾一下我们迄今为止使用根提供者作用域引入的服务。
- en: Revisiting the root provider scope
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视根提供者作用域
- en: 'So far, we have discussed the following services in the Angular Academy application
    using the root scope provider:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在Angular Academy应用程序中使用根作用域提供者讨论了以下服务：
- en: '`SchoolsService`: Retrieve information about the available schools.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SchoolsService`：检索有关可用学校的详细信息。'
- en: '`CourseService`: Retrieve information about the course.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CourseService`：检索有关课程的详细信息。'
- en: '`ThemeService`: Set and retrieve information about the current theme.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ThemeService`：设置和检索有关当前主题的详细信息。'
- en: 'These services have served us well as singletons in the app so far – and marking
    the services for use with `providedIn: ''root''` via the `Injectable` decorator
    makes it pretty easy to use them for the standard use case. If you have been around
    since the early days of Angular, then you might have been accustomed to injecting
    services as dependencies in each specific module – for example, you might have
    been wondering why `SchoolsService` is not listed in the providers array from
    the schools module here:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '这些服务作为单例在应用程序中一直为我们服务得很好——通过`Injectable`装饰器标记服务以使用`providedIn: ''root''`使得它们在标准用例中很容易使用。如果您从Angular的早期阶段就开始使用，那么您可能已经习惯了在每个特定模块中将服务作为依赖项进行注入——例如，您可能想知道为什么`SchoolsService`没有列在学校的模块的提供者数组中：'
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We do not need to insert explicit providers here as we have had tree-shakable
    providers since Angular version 6\. We can now just rely on the `injectable` decorator.
    This makes the Angular modules a bit leaner and easier to configure, and we can
    provide alternative implementations for the service later.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要在这里插入显式的提供者，因为我们从Angular版本6以来就有可摇树振的提供者。我们现在可以只依赖`injectable`装饰器。这使得Angular模块更加精简且易于配置，我们可以在以后提供服务的替代实现。
- en: Providing singleton services on the root scope sounds useful in itself (it worked
    well in [*Chapter 6*](B16295_06_ePub_RK.xhtml#_idTextAnchor081), *Using Angular
    Components*). But what if we want to have specific service instances per use case?
    It turns out that we can do that by using the any provider scope for the theme
    service and changing the modules to be lazy loaded instead of the default eager
    loading. Let's dig into the details on how to do that.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在根作用域上提供单例服务本身听起来很有用（在第6章[*Chapter 6*](B16295_06_ePub_RK.xhtml#_idTextAnchor081)中效果很好，*使用Angular组件*）。但如果我们想针对每个用例拥有特定的服务实例呢？实际上，我们可以通过使用主题服务的任何提供者作用域并将模块改为懒加载而不是默认的急加载来实现这一点。让我们深入了解如何做到这一点。
- en: Using the any provider scope for a configurable ThemeService
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用可配置的ThemeService的任何提供者作用域
- en: 'Let''s use the any provider scope for a configurable `ThemeService` by injecting
    configurable settings depending on the use case for each module that we load:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用任何提供者作用域为可配置的 `ThemeService` 注入可配置设置，这些设置取决于我们加载的每个模块的使用情况：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We introduced the theme service in [*Chapter 5*](B16295_05_ePub_RK.xhtml#_idTextAnchor075)*,
    Using CSS Custom Properties*. Let''s make that configurable by introducing an
    `InjectionToken` instance for the theme:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第 [*第5章*](B16295_05_ePub_RK.xhtml#_idTextAnchor075)* 中介绍了主题服务，即使用 CSS 自定义属性*。让我们通过引入一个用于主题的
    `InjectionToken` 实例来使其可配置：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The theme token holds configuration settings that implement the `ITheme` interface:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 主题令牌持有实现 `ITheme` 接口的配置设置：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We could then use a `green` theme with these values in `AppModule` via the
    `InjectionToken` token of `theme`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `AppModule` 中使用 `InjectionToken` 令牌 `theme` 通过这些值使用 `green` 主题：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that the configured settings will only be the starting values. The user
    can still change them while the system is running.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，配置的设置将是起始值。用户仍然可以在系统运行时更改它们。
- en: 'Now we can inject the theme settings into the injector scope using the theme
    service. When we are using the any provider scope, we can obtain an instance for
    every lazy-loaded module that injects the service. Here is a snippet that shows
    the relevant parts of how to rewire the modules for lazy loading via an app routing
    module and while running the `green` theme in the `AppModule`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用主题服务将主题设置注入到注入器作用域。当我们使用任何提供者作用域时，我们可以为每个注入服务的懒加载模块获取一个实例。以下是一个片段，展示了如何通过应用程序路由模块重新配置模块以进行懒加载，同时在
    `AppModule` 中运行 `green` 主题：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here we provide default settings for `ThemeService` on the application module
    scope. The dependencies for each module would be dynamically loaded from inside
    `AppRoutingModule` like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在应用程序模块作用域上为 `ThemeService` 提供默认设置。每个模块的依赖项将像这样从 `AppRoutingModule` 内部动态加载：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then we need to establish a routing module for each module. As an example,
    the routing module for the course module looks like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要为每个模块建立路由模块。以课程模块为例，其路由模块看起来如下所示：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We already have the settings defined in the `Provider` scope for the app module
    that uses the course module, so there is no need to redefine it here if we want
    the `green` theme for a module. But if we want to use another theme, then we can
    introduce another theme configuration via the `theme` token like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在应用程序模块的 `Provider` 作用域中定义了设置，该模块使用课程模块，因此如果我们想为模块使用 `green` 主题，则不需要在此处重新定义它。但如果我们想使用另一个主题，则可以通过
    `theme` 令牌引入另一个主题配置，如下所示：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We could then use the `metallic` theme on the lazy-loaded `LoginModule` via
    the platform injector scope like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过平台注入器作用域使用 `metallic` 主题在懒加载的 `LoginModule` 上，如下所示：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Since we are lazy loading the login module, we will now create a new instance
    of the theme service – so that the `login` component can use the `metallic` theme
    instead of the `green` theme like the rest of the application. In this way, we
    can use an instance of the theme service to render the toolbar using the `green`
    theme and the `login` component using the `metallic` theme, like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在懒加载登录模块，我们现在将创建主题服务的新的实例 – 这样 `login` 组件就可以使用 `metallic` 主题而不是像应用程序其余部分一样使用
    `green` 主题。通过这种方式，我们可以使用主题服务的实例使用 `green` 主题渲染工具栏，并使用 `metallic` 主题渲染 `login`
    组件，如下所示：
- en: '![Figure 8.1 –  The login screen. Note that the background here is from the
    metallic theme'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.1 – 登录屏幕。请注意，这里的背景来自金属主题'
- en: '](img/Figure_8.1_B16295.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.1_B16295.jpg)'
- en: Figure 8.1 – The login screen. Note that the background here is from the metallic
    theme
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 登录屏幕。请注意，这里的背景来自金属主题
- en: 'This will be the first screen you see when you start the Angular Academy application.
    Note that the metallic card background is set in the `login.component.scss` file
    using the mechanism you learned about in [*Chapter 5*](B16295_05_ePub_RK.xhtml#_idTextAnchor075)*,
    Using CSS Custom Properties*:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是您启动 Angular Academy 应用程序时看到的第一个屏幕。请注意，金属卡片背景是在 `login.component.scss` 文件中设置的，使用了您在
    [*第5章*](B16295_05_ePub_RK.xhtml#_idTextAnchor075)* 中学习到的机制，即使用 CSS 自定义属性*：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `background` variable will be set in `LoginComponent` like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`background` 变量将在 `LoginComponent` 中设置，如下所示：'
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`LoginComponent` passes user information from `loginForm` to `AuthService`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoginComponent` 将用户信息从 `loginForm` 传递到 `AuthService`：'
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that we are using a very simple way of obtaining a `login` token for the
    `demo` user with the password `demo` here. This example could be extended to call
    the backend of your choice and submit `LoginEvent` after doing so.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在这里使用了一种非常简单的方法来为 `demo` 用户获取 `login` 令牌，密码为 `demo`。这个例子可以被扩展，以调用您选择的后端，并在这样做之后提交
    `LoginEvent`。
- en: 'The idea is that we can react to `LoginEvent` like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 策略是这样的：我们可以像这样对 `LoginEvent` 做出反应：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: By now we hope that you have had the chance to play around with the Angular
    Academy application to see how things are wired together. Did you notice that
    you are redirected directly to the course in the Angular Academy application after
    logging in a second time? The first time you log in, you should be given the opportunity
    to choose a school from a map – and then choose a course from the school. When
    you choose a course, this will be stored via the preference service. This preference
    can then be used to redirect users to courses.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们希望您已经有机会尝试使用 Angular Academy 应用程序，看看事物是如何连接在一起的。您注意到在第二次登录后，您会被直接重定向到
    Angular Academy 中的课程吗？第一次登录时，您应该有机会从地图中选择一所学校——然后从学校中选择一个课程。当您选择一个课程时，这将通过偏好服务进行存储。然后可以使用这个偏好将用户重定向到课程。
- en: The Angular Academy application uses some fairly complex navigation logic that
    is only relevant inside the app – but what if we wanted to share information outside
    of the app? We can do exactly that by using the `platform` provider scope in combination
    with Angular elements.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Angular Academy 应用程序使用一些相当复杂的导航逻辑，这些逻辑仅在应用内部相关——但如果我们想在应用外部共享信息呢？我们可以通过结合使用
    `platform` 提供者作用域和 Angular 元素来实现这一点。
- en: Sharing information across application boundaries using the platform provider
    scope
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用平台提供者作用域在应用程序边界之间共享信息
- en: We can demonstrate how to share information outside of the app by creating a
    tweet button as an Angular element. This Angular element could be used outside
    of the app as well. Let's dig into the details on how to do that.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建一个作为 Angular 元素的推文按钮来展示如何在外部共享信息。这个 Angular 元素也可以在应用外部使用。让我们深入了解如何做到这一点。
- en: 'First, we will start by adding Angular elements to the app by running the following
    command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将通过运行以下命令将 Angular 元素添加到应用中：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then we include the Twitter widgets SDK within the page like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们像这样在页面中包含 Twitter 小部件 SDK：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then we can build a tweet hashtag button using a `TweetCourse` component like
    this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用 `TweetCourse` 组件构建一个推文标签按钮，如下所示：
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `TweetCourse` component uses `CourseService` with the platform provider
    scope to retrieve data:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`TweetCourse` 组件使用 `CourseService` 和平台提供者作用域来检索数据：'
- en: '[PRE17]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we register `TweetCourseComponent` as an Angular element like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们像这样注册 `TweetCourseComponent` 作为 Angular 元素：
- en: '[PRE18]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It can then be used as a web component:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它可以作为一个 Web 组件使用：
- en: '[PRE19]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Since `CourseService` is registered on the platform provider scope, we can now
    use it both from within our new `<tweet-course>` Angular element and inside our
    Angular Academy application.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `CourseService` 已在平台提供者作用域上注册，我们现在可以从我们新的 `<tweet-course>` Angular 元素以及我们的
    Angular Academy 应用程序内部使用它。
- en: 'We insert the `<tweet-course>` element inside the navigation bar for the desktop
    version of the application like this inside the navigation component:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在应用程序桌面版本的导航栏中插入 `<tweet-course>` 元素，如下所示，在导航组件内部：
- en: '[PRE20]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here you see that the `<tweet-course>` element should be rendered in the sidebar
    if you have chosen a course (if you have a `courseId` instance). It should look
    like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到，如果您已经选择了一个课程（如果您有一个 `courseId` 实例），则 `<tweet-course>` 元素应该在侧边栏中渲染。它应该看起来像这样：
- en: '![Figure 8.2 – Introducing the Tweet #AcceleratingIvy button'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.2 – 介绍 Tweet #AcceleratingIvy 按钮'
- en: '](img/Figure_8.2_B16295.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.2_B16295.jpg)'
- en: 'Figure 8.2 – Introducing the Tweet #AcceleratingIvy button'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '图 8.2 – 介绍 Tweet #AcceleratingIvy 按钮'
- en: If you are logged in to Twitter when you press the `#AcceleratingIvy` hashtag.
    If you register another hashtag for your course in the course service, then this
    hashtag will be presented.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在点击 `#AcceleratingIvy` 标签时已登录 Twitter。如果您在课程服务中为您的课程注册另一个标签，那么这个标签将被展示。
- en: Maybe you have other ideas for components that could be used outside of the
    application? Did you notice that we marked `AuthService` as `providedIn:` `'platform'`?
    You could export the `Login` component as an Angular element and update it to
    integrate it into your own application platform to perform single sign-on.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 也许您有其他想法，可以将组件用于应用程序之外？您注意到我们将 `AuthService` 标记为 `providedIn:` `'platform'`
    吗？您可以导出 `Login` 组件作为 Angular 元素，并将其更新以集成到您自己的应用程序平台中，以执行单点登录。
- en: Summary
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started by expanding on the usage of the root provider scope
    and introduced the new any and platform provider scopes in the context of the
    Angular Academy application. We then introduced the any provider scope by applying
    lazy loading via `AppRoutingModule`, which allowed us to use a separate theme
    for `LoginModule`. Finally, we saw how to create a Tweet button that can be used
    with the platform provider scope.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先扩展了根提供者作用域的使用，并在 Angular Academy 应用程序上下文中介绍了新的 `any` 和 `platform` 提供者作用域。然后，我们通过应用
    `AppRoutingModule` 中的延迟加载来介绍 `any` 提供者作用域，这使得我们可以为 `LoginModule` 使用单独的主题。最后，我们看到了如何创建一个可以与平台提供者作用域一起使用的推文按钮。
- en: In the next chapter, we will start on Part 3, Upgrade Your View Engine Application
    and Development Workflow to Angular Ivy of the book and look into migrations and
    more practical aspects of using Angular Ivy.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始介绍本书的第三部分，即升级您的视图引擎应用程序和开发工作流程到 Angular Ivy，并探讨迁移和使用 Angular Ivy
    的更多实际方面。
