- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building a Multiplatform Expense Tracker Using Quasar
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ll iterate the topics and techniques we covered in [*Chapter
    6*](B19563_06.xhtml#_idTextAnchor162). We’ll build a similar app using Vue and
    rely on Supabase to store our data. In this chapter, however, we’ll focus on building
    an app that can be deployed on multiple platforms other than the web.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use Quasar ([https://quasar.dev/](https://quasar.dev/)) as our framework
    of choice since it allows us to choose multiple different types of platforms.
    For the sake of simplicity, we’ll focus on creating a desktop application based
    on Electron ([https://www.electronjs.org/](https://www.electronjs.org/)). Both
    Quasar and Electron are well-maintained open source projects with excellent documentation
    and active communities.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Solidifying what we learned previously
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Familiarizing yourself with different frameworks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the value of platform-agnostic development
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a native app using web technologies
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning the key differences between web and native
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ll be reusing most of the requirements from [*Chapter 6*](B19563_06.xhtml#_idTextAnchor162)
    since we’ll be building an application with similar capabilities. This will help
    you identify how the framework impacts the architecture of an app.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: We’ll be depending heavily on Quasar ([https://quasar.dev/](https://quasar.dev/))
    as our foundational framework. Since the framework also offers UI patterns ([https://quasar.dev/components](https://quasar.dev/components)),
    we don’t need Vuetify in this project. We will use Pinia ([https://pinia.vuejs.org/](https://pinia.vuejs.org/))
    to handle our application state. To store the data, we’ll create a new project
    in Supabase ([https://supabase.com/](https://supabase.com/)), an open source database
    provider with built-in authentication. For the database, I’ve prepared a script
    to create the databases and another one to add example data. We’ll cover those
    steps in the *Setting up the* *database* section.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: The final product is located in this book’s GitHub repository at [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/tree/main/07.expenses](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/tree/main/07.expenses).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the database
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ll start by fulfilling our database needs. We already have a free account
    (see [*Chapter 6*](B19563_06.xhtml#_idTextAnchor162)). We’ll create a new project
    called `expense-tracker`, set a strong database password, and assign a geographically
    close region.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll be redirected to a view that provides you with **Project URL** and **API
    Key** details, as shown in *Figure 7**.1*:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – API settings for our expense-tracker project](img/B19563_07_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – API settings for our expense-tracker project
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Since our application isn’t ready, we need to note the URL and API key down
    in a safe place or simply revisit this page once we get to the application.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用程序尚未准备就绪，我们需要将 URL 和 API 密钥记在一个安全的地方，或者一旦我们到达应用程序，简单重访这个页面。
- en: 'For this project, I’ve prepared a script to create the required tables and
    settings for our database called `example-structure.sql`. Open the SQL Editor
    in Supabase, then paste and run the contents of the script:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我准备了一个脚本，用于创建数据库所需的表和设置，称为 `example-structure.sql`。在 Supabase 中打开 SQL
    编辑器，然后粘贴并运行脚本的内容：
- en: '![Figure 7.2 – Success message after running the example-structure.sql script](img/B19563_07_02.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2 – 运行 example-structure.sql 脚本后的成功消息](img/B19563_07_02.jpg)'
- en: Figure 7.2 – Success message after running the example-structure.sql script
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – 运行 example-structure.sql 脚本后的成功消息
- en: 'Our expense tracker will be able to organize expenses into different categories,
    so I’ve also created a script to insert a set of example categories in the `example-categories.sql`
    file. You can paste the contents and run this file in the SQL Editor too:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的支出跟踪器将能够将支出组织到不同的类别中，因此我还创建了一个脚本，将一组示例类别插入到 `example-categories.sql` 文件中。您可以将内容粘贴到
    SQL 编辑器中并运行此文件：
- en: '![Figure 7.3 – Success message after running the example-categories.sql script](img/B19563_07_03.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3 – 运行 example-categories.sql 脚本后的成功消息](img/B19563_07_03.jpg)'
- en: Figure 7.3 – Success message after running the example-categories.sql script
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – 运行 example-categories.sql 脚本后的成功消息
- en: Now that our database has been set up, we can start creating a new project.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了数据库，我们可以开始创建一个新的项目。
- en: Using Quasar to build a project
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Quasar 构建项目
- en: 'We’re going to follow the default setup and installation guide at [https://quasar.dev/start/quick-start](https://quasar.dev/start/quick-start).
    In the CLI, we’ll run `npm init quasar` and select the configuration, as shown
    in *Figure 7**.4*:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循默认的设置和安装指南，[https://quasar.dev/start/quick-start](https://quasar.dev/start/quick-start)。在
    CLI 中，我们将运行 `npm init quasar` 并选择配置，如图 *图 7.4* 所示：
- en: '![Figure 7.4 – Creating a new project using the Quasar CLI](img/B19563_07_04.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4 – 使用 Quasar CLI 创建新项目](img/B19563_07_04.jpg)'
- en: Figure 7.4 – Creating a new project using the Quasar CLI
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – 使用 Quasar CLI 创建新项目
- en: 'This will install the project and its dependencies. Once the initialization
    is completed, we can navigate to the project folder and install the Supabase JavaScript
    client via the CLI:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装项目和其依赖项。一旦初始化完成，我们可以导航到项目文件夹，并通过 CLI 安装 Supabase JavaScript 客户端：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To conclude the initialization, we’ll create a `.env` file with the Supabase
    API keys:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成初始化，我们将创建一个包含 Supabase API 密钥的 `.env` 文件：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can verify our installation by running the following command in the command
    line:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在命令行中运行以下命令来验证我们的安装：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The example project will be installed, as shown in *Figure 7**.5*:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 示例项目将被安装，如图 *图 7.5* 所示：
- en: '![Figure 7.5 – The default project using Quasar](img/B19563_07_05.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.5 – 使用 Quasar 的默认项目](img/B19563_07_05.jpg)'
- en: Figure 7.5 – The default project using Quasar
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 – 使用 Quasar 的默认项目
- en: 'Since our goal is to work on a desktop app, we can easily run a development
    command for that environment as well:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的目标是开发桌面应用程序，我们可以轻松运行该环境的开发命令：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The first time this command is run, it will need to install some dependencies
    to run the environment. This will result in an output similar to the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行此命令时，需要安装一些依赖项以运行环境。这将产生类似于以下输出的结果：
- en: '![Figure 7.6 – Running Quasar in Electron development mode](img/B19563_07_06.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.6 – 在 Electron 开发模式下运行 Quasar](img/B19563_07_06.jpg)'
- en: Figure 7.6 – Running Quasar in Electron development mode
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 – 在 Electron 开发模式下运行 Quasar
- en: See how easy it is to target a different environment? Of course, Electron is
    very close to our browser environment, so it will behave very similarly. We are
    going to develop and debug our application in the browser. In virtually all cases,
    we can rely on this framework to deliver and compile our code to specific platforms.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 看看如何轻松地针对不同的环境？当然，Electron 非常接近我们的浏览器环境，因此它的行为将非常相似。我们将使用浏览器开发和调试我们的应用程序。在几乎所有情况下，我们可以依赖这个框架将我们的代码交付和编译到特定的平台。
- en: 'Targeting Android or iOS is a bit more complicated. It will make use of Capacitor
    to build a native-like shell that acts as a proxy between the operating system
    and the application. If you’re interested in mobile deployments, I highly recommend
    referring to the Quasar guide: [https://quasar.dev/quasar-cli-vite/developing-capacitor-apps/introduction](https://quasar.dev/quasar-cli-vite/developing-capacitor-apps/introduction).'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 针对 Android 或 iOS 的开发稍微复杂一些。它将使用 Capacitor 来构建一个类似原生的壳，作为操作系统和应用程序之间的代理。如果你对移动部署感兴趣，我强烈建议参考
    Quasar 指南：[https://quasar.dev/quasar-cli-vite/developing-capacitor-apps/introduction](https://quasar.dev/quasar-cli-vite/developing-capacitor-apps/introduction)。
- en: With our app running on the web and Electron, we have our starting point to
    build the expense tracker!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的应用程序在网页和 Electron 上运行时，我们就有了构建支出跟踪器的起点！
- en: Note
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We’re using Quasar as a framework due to its bundling and building capabilities,
    but Quasar also offers a packed library of ready-to-use Vue components ([https://quasar.dev/components](https://quasar.dev/components)).
    In our example code, you will be able to recognize them by the *q-* prefixes in
    the component name. We won’t dive into how the component works, so I’d like to
    refer you to the official (and great) docs, which you can find at [https://quasar.dev/docs](https://quasar.dev/docs)
    and [https://quasar.dev/components](https://quasar.dev/components).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Quasar 作为框架是因为它具有捆绑和构建功能，但 Quasar 还提供了一组丰富的可重用 Vue 组件（[https://quasar.dev/components](https://quasar.dev/components)）。在我们的示例代码中，你将能够通过组件名称中的
    *q-* 前缀来识别它们。我们不会深入探讨组件的工作原理，所以我将向您推荐官方（且非常好）的文档，您可以在 [https://quasar.dev/docs](https://quasar.dev/docs)
    和 [https://quasar.dev/components](https://quasar.dev/components) 找到。
- en: Let’s have a look at how we can connect our Supabase instance with a frontend
    application, shall we?
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将我们的 Supabase 实例与前端应用程序连接，怎么样？
- en: Authenticating with Supabase and Quasar
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Supabase 和 Quasar 进行身份验证
- en: 'Having an application rather than a website means that external hyperlinks,
    such as the OTP method of signing in via Supabase, will not work out of the box.
    Handling these issues is a bit too advanced for this chapter, so we’ll opt for
    signing in via email and password. To have Supabase and our Quasar application
    integrate nicely, I’m loosely basing our implementation on the following online
    resource: [https://dev.to/tvogel/getting-started-with-supabase-and-quasar-v2-kdo](https://dev.to/tvogel/getting-started-with-supabase-and-quasar-v2-kdo).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个应用程序而不是一个网站意味着外部超链接，例如通过 Supabase 的 OTP 登录方法，将无法直接使用。处理这些问题对于本章来说有点过于高级，所以我们选择通过电子邮件和密码进行登录。为了使
    Supabase 和我们的 Quasar 应用程序很好地集成，我将我们的实现大致基于以下在线资源：[https://dev.to/tvogel/getting-started-with-supabase-and-quasar-v2-kdo](https://dev.to/tvogel/getting-started-with-supabase-and-quasar-v2-kdo)。
- en: The `src/boot` folder is meant for scripts that need to be executed before we
    initialize the Vue.js application ([https://quasar.dev/quasar-cli-vite/boot-files/](https://quasar.dev/quasar-cli-vite/boot-files/)).
    In our case, we need to utilize the boot files because we want to execute logic
    before we change a route, to see whether a user has access. This means we need
    to handle our authentication and Supabase client in scripts that are executed
    before the main scripts of our app.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/boot` 文件夹用于在初始化 Vue.js 应用程序之前需要执行的脚本（[https://quasar.dev/quasar-cli-vite/boot-files/](https://quasar.dev/quasar-cli-vite/boot-files/)）。在我们的情况下，我们需要利用启动文件，因为我们希望在更改路由之前执行逻辑，以查看用户是否有权限。这意味着我们需要在执行应用程序主脚本之前，在脚本中处理我们的身份验证和
    Supabase 客户端。'
- en: 'First, we’ll create the `src/boot/supabase.ts` file with the contents of the
    following file: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.1-supabase.ts](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.1-supabase.ts).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个 `src/boot/supabase.ts` 文件，其中包含以下文件的內容：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.1-supabase.ts](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.1-supabase.ts)。
- en: 'We’ll use the `router-auth.ts` file as well and place it in the same folder:
    [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.2-router-auth.ts](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.2-router-auth.ts).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用 `router-auth.ts` 文件，并将其放置在同一个文件夹中：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.2-router-auth.ts](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.2-router-auth.ts)。
- en: 'We can add these scripts to our `quasar.config.js` file by simply referencing
    the file on the `boot` property, which will then look like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在`boot`属性中引用文件来将这些脚本添加到我们的`quasar.config.js`文件中，这样它看起来就会像这样：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding configuration tells our app to run the given scripts before we
    initialize (or boot) the application.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 上述配置告诉我们的应用程序在初始化（或启动）应用程序之前运行给定的脚本。
- en: With our basic boot scripts in place, we can look at our routes.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的基本启动脚本就绪后，我们可以查看我们的路由。
- en: Routes and app structure
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由和应用程序结构
- en: 'Now, we’ll add some routes so that we can build out our app and apply the `router-auth`
    scripts to the correct routes. Let’s remove all of the files from the `src/pages`
    folder, except the `ErrorNotFound.vue` page. We’ll add the following pages with
    the same structure:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加一些路由，以便我们可以构建我们的应用程序并将`router-auth`脚本应用于正确的路由。让我们从`src/pages`文件夹中删除所有文件，除了`ErrorNotFound.vue`页面。我们将添加以下具有相同结构的页面：
- en: '`AccountPage.vue`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AccountPage.vue`'
- en: '`Expenses Page.vue`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Expenses Page.vue`'
- en: '`CategoriesPage.vue`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CategoriesPage.vue`'
- en: 'Replace the contents of `<h1 class="text-h1">Home</h1>` with a relevant title
    for every page using the following template:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下模板，将每个页面的`<h1 class="text-h1">Home</h1>`内容替换为相关标题：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We’ll build the functionalities of each in the *Managing categories* and *Showing
    expenses and an overview* sections. But first, we need to integrate the authentication
    into our routes.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*管理类别*和*显示支出和概览*部分构建每个功能的实现。但在开始之前，我们需要将身份验证集成到我们的路由中。
- en: 'First, let’s look at the `src/router/index.ts` file: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.3-router-index.ts](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.3-router-index.ts).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看`src/router/index.ts`文件：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.3-router-index.ts](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.3-router-index.ts)。
- en: 'We’ll make two changes: we’ll import the `init` function of our Supabase boot
    script (*line 11*) and we’ll execute the function in the route function (*line
    23*). We can now define the routes that lead to the pages we’ve already created.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将进行两项更改：我们将导入Supabase启动脚本中的`init`函数（*第11行*）并在路由函数中执行该函数（*第23行*）。我们现在可以定义通向我们已创建的页面的路由。
- en: 'Let’s look at the `routes.ts` file: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.4-routes.ts](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.4-routes.ts).'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`routes.ts`文件：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.4-routes.ts](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.4-routes.ts)。
- en: 'The file contains familiar code but with a slight difference – for every route
    that requires the user to be logged in, we’ve added a `meta` field:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 文件包含熟悉的代码，但略有不同——对于需要用户登录的每个路由，我们都添加了一个`meta`字段：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Also, the route for the `/auth` route (*lines 29–31*) is different: it doesn’t
    rely on the layout and directly imports the component. This is because the route
    will be the entry point of the app for non-authenticated users.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`/auth`路由（*第29-31行*）是不同的：它不依赖于布局，而是直接导入组件。这是因为该路由将是未认证用户的程序入口点。
- en: Now, if we look in our `src/boot/router-auth.ts` file, we will see that before
    each route change, we check if that meta field exists and then validate that the
    user `session` exists. If not, we redirect the user to the `fullPath` property,
    which translates to the home page.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们查看我们的`src/boot/router-auth.ts`文件，我们将看到在每次路由更改之前，我们都会检查该元字段是否存在，然后验证用户`session`是否存在。如果不存在，我们将用户重定向到`fullPath`属性，这相当于主页。
- en: It’s time to put these features into practice by building signup and login features
    for the app.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候通过构建应用程序的注册和登录功能来将这些功能付诸实践了。
- en: Signing up and logging in
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注册和登录
- en: 'Let’s work on offering users a way of both registering and signing in to our
    app. In our components folder, we’ll create a form for logging in called `FormLogin.vue`:
    [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.5-FormLogin.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.5-FormLogin.vue).'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们努力为用户提供一种注册和登录我们应用的方法。在我们的组件文件夹中，我们将创建一个名为`FormLogin.vue`的登录表单：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.5-FormLogin.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.5-FormLogin.vue).
- en: 'We’ll also create a (very similar) file for signing up called `FormSignUp.vue`:
    [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.6-FormSignUp.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.6-FormSignUp.vue).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将创建一个（非常相似）的用于注册的文件，名为`FormSignUp.vue`：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.6-FormSignUp.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.6-FormSignUp.vue).
- en: The key difference between the two forms is the method we’re calling on submit,
    which is either the `supabase.auth.signInWithPassword` or `supabase.auth.signUp`
    method. We’re not interested in abstracting anything here. It’s not always the
    best approach to try and over-optimize everything that might be repetitive. In
    this case, we prefer readability and simplicity over similar code between the
    two files.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 两种形式之间的关键区别是我们所使用的提交方法，即`supabase.auth.signInWithPassword`或`supabase.auth.signUp`方法。我们在这里并不感兴趣于抽象化任何东西。试图过度优化可能重复的每一件事并不总是最佳方案。在这种情况下，我们更倾向于可读性和简洁性，而不是两个文件之间相似的代码。
- en: 'Let’s incorporate the two forms on a newly created `AuthPage.vue` page:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一个新创建的`AuthPage.vue`页面上整合这两个表单：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, we used the Quasar `tab` component to offer the two forms
    on the page. We should now be able to sign up for a new account. However, there’s
    a small catch.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了Quasar的`tab`组件在页面上提供两个表单。现在我们应该能够注册新账户。然而，有一个小问题。
- en: 'The default settings of Supabase require us to confirm email addresses on signup.
    For simplicity’s sake, we need to disable this feature. Log into your Supabase
    dashboard, navigate to **Authentication** | **Providers**, and then expand the
    **Email** panel. There, we need to disable the **Confirm Email** option, as shown
    in *Figure 7**.7*:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Supabase的默认设置要求我们在注册时确认电子邮件地址。为了简化起见，我们需要禁用此功能。登录您的Supabase仪表板，导航到**身份验证** |
    **提供者**，然后展开**电子邮件**面板。在那里，我们需要禁用**确认电子邮件**选项，如图*图7.7*所示：
- en: '![Figure 7.7 – Disabling the Confirm email option in Supabase](img/B19563_07_07.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图7.7 – 在Supabase中禁用确认电子邮件选项](img/B19563_07_07.jpg)'
- en: Figure 7.7 – Disabling the Confirm email option in Supabase
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 – 在Supabase中禁用确认电子邮件选项
- en: Once we’ve saved this setting, we can register as a new user. You can keep the
    Supabase dashboard open and navigate to **Profiles** to verify your newly created
    account!
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 保存此设置后，我们可以注册为新用户。您可以保持Supabase仪表板打开，并导航到**个人资料**以验证您新创建的账户！
- en: '![Figure 7.8 – Initial logged-in state in the web view](img/B19563_07_08.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图7.8 – 网页视图中的初始登录状态](img/B19563_07_08.jpg)'
- en: Figure 7.8 – Initial logged-in state in the web view
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 – 网页视图中的初始登录状态
- en: In the web app, we’ll be redirected to the (mostly empty) **Account** page,
    as shown in *Figure 7**.8*. Now we’re getting somewhere.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络应用中，我们将被重定向到（大部分为空的）**账户**页面，如图*图7.8*所示。现在我们正在取得进展。
- en: 'First, we’ll slightly modify the existing `src/components/EssentialLink.vue`
    component: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.7-EssentialLink.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.7-EssentialLink.vue).'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将稍微修改现有的`src/components/EssentialLink.vue`组件：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.7-EssentialLink.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.7-EssentialLink.vue).
- en: 'We’re replacing the link with a router link integration. The `<q-item />` component
    provides support so that we can use it as a router link entity out of the box!
    Let’s open `layouts/MainLayout.vue` so that we can change the default layout for
    our use case. You can modify the header any way you see fit, but let’s focus on
    `essentialLinks` constant to reflect the pages we’ve created and want to show
    in **Menu**. We’ll replace it with the following contents:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在用路由链接集成替换链接。`<q-item />` 组件提供了支持，因此我们可以直接将其用作路由链接实体！让我们打开 `layouts/MainLayout.vue`，以便我们可以更改适用于我们用例的默认布局。你可以按任何你喜欢的样子修改标题，但让我们专注于
    `essentialLinks` 常量，以反映我们创建并希望在 **菜单** 中显示的页面。我们将用以下内容替换它：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can, of course, see these changes in the app as soon as you save them!
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以在保存更改后立即在应用中看到这些变化！
- en: We haven’t allowed our users to log out of their session in the app yet. In
    the next section, we’ll make sure our users can sign out as well.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有允许用户在应用中注销会话。在下一节中，我们将确保用户也可以注销。
- en: Logging out
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注销
- en: 'Let’s add a button to sign out as well. We’ll create a standalone component
    for this in the `components` folder called `ButtonSignOut.vue`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个注销按钮。我们将在 `components` 文件夹中创建一个名为 `ButtonSignOut.vue` 的独立组件：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We’re calling the Supabase method of signing out again and instructing the router
    to go to the first entry of its history table.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次调用 Supabase 的注销方法，并指示路由器转到其历史表中的第一个条目。
- en: 'Now, we can flip back to `MainLayout.vue`: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.8-MainLayout.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.8-MainLayout.vue).'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以切换回 `MainLayout.vue`：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.8-MainLayout.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.8-MainLayout.vue)。
- en: If we look at the contents of the `<q-drawer>` component (*lines 20–39*), we
    will see the addition of a logout button (*lines 29–32, 48*). Feel free to add
    the sign-out button to, say, the **Account** page as well.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看 `<q-drawer>` 组件的内容 (*第20-39行*)，我们将看到添加了一个注销按钮 (*第29-32行，第48行*)。你可以自由地将注销按钮添加到，比如说，**账户**页面。
- en: Note
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Since we’re creating new files as well as modifying existing starter files,
    we have mixed coding styles in our app. Sometimes, the code block precedes the
    template, and sometimes, the other way around. For our current implementation,
    this is not problematic, although when collaborating or working on large projects,
    it is highly recommended to use a consistent coding style and strictly keep to
    it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在创建新文件以及修改现有的启动文件，我们的应用中存在混合的编码风格。有时代码块在模板之前，有时则相反。对于我们的当前实现，这并不成问题，尽管在协作或处理大型项目时，强烈建议使用一致的编码风格并严格遵守。
- en: 'So far, we’ve created the basic features for a user-centered app: signing up,
    logging in, and logging out. We’ve also applied the authorization to different
    parts of our app using routes. Now, we’ll focus on adding specific features to
    the app, such as expense tracking.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经为以用户为中心的应用创建了基本功能：注册、登录和注销。我们还使用路由将授权应用于我们应用的各个部分。现在，我们将专注于向应用添加特定功能，例如费用跟踪。
- en: Expense tracking features
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 费用跟踪功能
- en: 'A big part of tracking our future expenses is being able to organize them into
    different categories. We’ll start by adding a Pinia store to work with the category
    data in our app. This is very similar to the exercises we completed in [*Chapter
    6*](B19563_06.xhtml#_idTextAnchor162). Let’s create a `src/store/categories.ts`
    file: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.9-categories.ts](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.9-categories.ts).'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪我们未来费用的一个重要部分是能够将它们组织到不同的类别中。我们将首先在我们的应用中添加一个 Pinia 存储来处理类别数据。这与我们在 [*第6章*](B19563_06.xhtml#_idTextAnchor162)
    中完成的练习非常相似。让我们创建一个 `src/store/categories.ts` 文件：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.9-categories.ts](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.9-categories.ts)。
- en: As you can see, we’re using the `session` and `supabase` scripts from our `boot`
    scripts to interact with the logged-in user session and database connection.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们正在使用 `boot` 脚本中的 `session` 和 `supabase` 脚本来与已登录用户会话和数据库连接交互。
- en: 'To show the categories, we’ll create a component in our components folder called
    `CategoryList.vue`: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.10-CategoryList.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.10-CategoryList.vue).'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示类别，我们将在组件文件夹中创建一个名为 `CategoryList.vue` 的组件：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.10-CategoryList.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.10-CategoryList.vue).
- en: Apart from showing the categories, the `removeOwnCategory` function (*lines
    29–39*) allows users to remove categories that they’ve added themselves. All of
    the actions are dispatched via the store we’ve created.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 除了显示类别外，`removeOwnCategory` 函数（*第 29-39 行*）允许用户删除他们自己添加的类别。所有操作都是通过我们创建的存储进行分发的。
- en: In the next section, we’ll create features to make the app a bit more personal,
    by allowing our users to manage categories for themselves.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将创建一些功能，让我们的用户能够为自己管理类别，从而使应用更加个性化。
- en: Managing categories
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理类别
- en: 'Having a function to remove categories means we have to build a component to
    add custom categories. So, we’ll create a new component called `CategoryAdd.vue`:
    [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.11-CategoryAdd.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.11-CategoryAdd.vue).'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有删除类别的功能意味着我们必须构建一个组件来添加自定义类别。因此，我们将创建一个新的组件，名为 `CategoryAdd.vue`：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.11-CategoryAdd.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.11-CategoryAdd.vue).
- en: This exposes a sticky **floating action button** (**FAB**) that’s tied to toggling
    a small form in a dialog that accepts name and color entries and upserts the entry
    in the database with the user’s profile ID. This is another good example of a
    component with a clear purpose that’s contained in a single file. This is how
    we build complex applications!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这暴露了一个与切换对话框中小表单的切换相关联的粘性**浮动操作按钮**（**FAB**），该表单接受名称和颜色输入，并使用用户的配置文件 ID 在数据库中更新条目。这是另一个组件的例子，它具有明确的目的，并且包含在一个文件中。这就是我们构建复杂应用的方式！
- en: Having the feature of adding personal categories means we can show these individual
    categories together with the default categories.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 具备添加个人类别的功能意味着我们可以将个人类别与默认类别一起显示。
- en: 'To complete the categories functionality, we will import both components we’ve
    just created and list them on `CategoriesPage.vue`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成类别功能，我们将导入我们刚刚创建的两个组件，并在 `CategoriesPage.vue` 上列出它们：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: With our categories in place, we can finalize the app by exposing the feature
    to add expenses!
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的类别就绪后，我们可以通过公开添加费用的功能来最终确定应用！
- en: Adding expenses
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加费用
- en: 'To add expenses, we’ll start by creating a Pinia store. The store will contain
    an overview of expenses for our users and have some methods for retrieving and
    adding expenses. Let’s create a `src/store/expenses.ts` file: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.12-expenses.ts](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.12-expenses.ts).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了添加费用，我们将首先创建一个 Pinia 存储。该存储将包含我们用户的费用概览，并有一些用于检索和添加费用的方法。让我们创建一个 `src/store/expenses.ts`
    文件：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.12-expenses.ts](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.12-expenses.ts).
- en: 'The most important feature of our app is its ability to track expenses! Having
    our store in place, we can create a component specifically for that called `src/components/ExpenseAdd.vue`:
    [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.13-ExpenseAdd.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.13-ExpenseAdd.vue).'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用最重要的功能是其跟踪费用的能力！有了我们的存储，我们可以创建一个专门用于此的组件，名为 `src/components/ExpenseAdd.vue`：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.13-ExpenseAdd.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.13-ExpenseAdd.vue).
- en: As you can see, this component has a lot of similarities with adding a category,
    although this form depends on categories to be present on the Vuetify Select component.
    Both are FAB components that toggle a dialog to facilitate this feature.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个组件与添加类别有很多相似之处，尽管这个表单依赖于Vuetify Select组件中存在类别。两者都是FAB组件，用于切换对话框以方便此功能。
- en: 'We can add our new `ExpenseAdd` component to `ExpensesPage.vue` like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将新的`ExpenseAdd`组件添加到`ExpensesPage.vue`中，如下所示：
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, you should be able to add expenses. You can verify this by looking at the
    tables in the Supabase dashboard. For our users, we’ll have to start creating
    views in the app, so that will be our next step!
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能够添加支出。你可以通过查看Supabase仪表板中的表格来验证这一点。对于我们的用户，我们将在应用中开始创建视图，所以那将是我们的下一步！
- en: Showing expenses and an overview
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 展示支出和概览
- en: 'In the `src/components` folder, we’ll create a `CategoryOverview.vue` component
    that will aggregate the categories and expenses from the database into a combined
    view: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.14-CategoryOverview.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.14-CategoryOverview.vue).'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/components`文件夹中，我们将创建一个`CategoryOverview.vue`组件，该组件将把数据库中的类别和支出聚合到一个组合视图中：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.14-CategoryOverview.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/07.expenses/.notes/7.14-CategoryOverview.vue)。
- en: 'Similar to the category overview, we have another overview of categories, but
    this one is displayed in a slightly different layout. This will serve as our new
    starting point. Let’s finalize `ExpensesPage.vue` by adding the `CategoryOverview`
    component as well:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 与类别概览类似，我们还有一个类别的概览，但这个概览的布局略有不同。这将作为我们的新起点。让我们通过添加`CategoryOverview`组件来最终确定`ExpensesPage.vue`：
- en: '[PRE12]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you run your app and navigate to the **Expenses** page, you should see something
    similar to the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行你的应用并导航到**支出**页面，你应该能看到以下类似的内容：
- en: '![Figure 7.9 – First overview of the Expenses page](img/B19563_07_09.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图7.9 – 支出页面的第一个概览](img/B19563_07_09.jpg)'
- en: Figure 7.9 – First overview of the Expenses page
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9 – 支出页面的第一个概览
- en: 'To add value to this page, we need to start showing our expenses here. We can
    create a specific component for this in the components folder, which we’ll call
    `ExpensesCategoryTotal.vue`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给这个页面增加价值，我们需要开始在这里展示我们的支出。我们可以在组件文件夹中创建一个特定的组件来完成这个任务，我们可以将其命名为`ExpensesCategoryTotal.vue`：
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is a component that we can provide with a category ID, and it will grab
    and tally all the values of `amount` as the total amount for that category. Once
    we’ve done this, we can add the `ExpensesCategoryTotal` component to our overview
    of categories with ease:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个我们可以提供类别ID的组件，它将抓取并汇总该类别的所有`amount`值作为该类别的总金额。一旦我们完成这个任务，我们就可以轻松地将`ExpensesCategoryTotal`组件添加到我们的类别概览中：
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Depending on what expenses you’ve inserted, you will now see an overview of
    the total expenses per category in the tiled overview we created. We’re almost
    there!
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你插入的支出，你现在将看到我们创建的拼贴概览中每个类别的总支出概览。我们几乎完成了！
- en: It would be nice if users could get some more insights into their expenses,
    right? So, let’s add a more detailed overview of the expenses in a certain category.
    Luckily, in our store, the functionality to query the database on expenses per
    category is already exposed. It is an extra call to Supabase, so we want to be
    a bit diligent with additional requests, which means we will only load the data
    when requested.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户能够对他们的支出有更多的了解，那就太好了？所以，让我们在某个特定类别中添加一个更详细的支出概览。幸运的是，在我们的商店中，已经暴露了按类别查询数据库的功能。这是一个额外的对Supabase的调用，所以我们想要对额外的请求保持一定的谨慎，这意味着我们只有在请求时才会加载数据。
- en: 'Let’s start by adding the script to handle the request and store the data in
    the `CategoryOverview.vue` file:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从添加处理请求并将数据存储在`CategoryOverview.vue`文件中的脚本开始：
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, in the template, we’ll call `getExpensesByCategoryId` when clicking on
    a tile. So, let’s modify `<q-card>` and add an `onClick` event:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在模板中，当点击一个拼贴时，我们将调用`getExpensesByCategoryId`。所以，让我们修改`<q-card>`并添加一个`onClick`事件：
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, as a sibling of the masonry style element, we’ll add dialog markup to
    show the expenses of the selected category:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，作为马赛克风格元素的兄弟元素，我们将添加对话框标记来显示所选类别的支出：
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We will need to feed the given collection of expenses into a new component.
    This will be our last component before we finalize our app!
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将给定的费用集合输入到一个新的组件中。这将是我们完成应用程序前的最后一个组件！
- en: 'In the `components` folders, we’ll create an `ExpensesList.vue` component and
    have it receive `expenses` as a prop:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在`components`文件夹中，我们将创建一个`ExpensesList.vue`组件，并让它接收`expenses`作为属性：
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, we can wrap the details of an expense and the categories together with
    `CategoryOverview.vue` by importing the `ExpensesList` component and using that
    list component instead of rendering the raw data:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过导入`ExpensesList`组件并使用该列表组件而不是渲染原始数据，将费用的详细信息与`CategoryOverview.vue`一起包装起来：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: At this point, we have an app where a user can manage categories and add expenses,
    which are shown in an overview.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个应用程序，用户可以管理类别并添加费用，这些费用在概览中显示。
- en: With this as our basis, it would be a good exercise to try and expand the app
    with different functionalities on your own if you like. How would you add a date
    filter to the expenses? At what level would you introduce them and what will they
    affect? Or how about removing expenses?
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以此为基础，如果你喜欢，尝试自己扩展应用程序的不同功能将是一个很好的练习。你将如何添加日期过滤器到费用中？你将在哪个级别引入它们，它们将影响什么？或者，关于删除费用呢？
- en: In the next section, we’ll convert our web application into a desktop application.
    The conversion can be done for every improvement you make in the code, so feel
    free to continue and add some new features later!
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将把我们的Web应用程序转换为桌面应用程序。代码中的每次改进都可以进行转换，所以请随意继续并稍后添加一些新功能！
- en: Building the app with the Quasar CLI
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Quasar CLI构建应用程序
- en: 'The Quasar CLI offers some commands to quickly build and publish an Electron
    app. It is important to realize that at this point, *the output of the default
    build script defaults to supporting only your current operating system and architecture*!
    That’s a good way to test the app, so let’s see what happens. We can generate
    our app code by running the following command in the terminal:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Quasar CLI提供了一些命令，可以快速构建和发布Electron应用程序。重要的是要意识到，在这个阶段，默认构建脚本的输出默认只支持你的当前操作系统和架构！这是一个测试应用程序的好方法，让我们看看会发生什么。我们可以在终端中运行以下命令来生成我们的应用程序代码：
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will take a bit longer to process than spinning up the development server:
    first, Quasar builds the files for the web and then uses that production-ready
    code with Electron to compile a native app. Once the processing is done, you can
    locate the build output files in the `/dist/electron` folder of your project.
    You should also be able to execute your app now!'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这将比启动开发服务器需要更长的时间来处理：首先，Quasar为Web构建文件，然后使用这些生产就绪的代码与Electron编译一个原生应用程序。一旦处理完成，你可以在项目的`/dist/electron`文件夹中找到构建输出文件。现在你也应该能够执行你的应用程序了！
- en: Next, we’ll improve the visual identity of the application by creating and providing
    our custom app icon.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过创建和提供我们自定义的应用程序图标来改进应用程序的视觉识别。
- en: A custom icon
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义图标
- en: With any application, an icon is as important as its name. With our web apps,
    we have omitted that part since there are plenty of resources for adding a favorite
    icon to a website. For our desktop app, however, we’ll recreate the steps for
    adding an icon.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何应用程序中，图标的重要性不亚于其名称。对于我们的Web应用程序，我们已经省略了这一部分，因为有很多资源可以帮助添加网站上的收藏图标。然而，对于我们的桌面应用程序，我们将重新创建添加图标的步骤。
- en: 'I downloaded a suitable icon from `src/assets` folder. Quasar offers a small
    tool called `npx`. We can generate the icon set with the following command:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我从`src/assets`文件夹下载了一个合适的图标。Quasar提供了一个名为`npx`的小工具。我们可以使用以下命令生成图标集：
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If the `npx` command doesn’t work, you can try to install the node package
    globally using the following terminal command:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`npx`命令不起作用，你可以尝试使用以下终端命令全局安装node包：
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once the global installation is done, you can run the package from your projects’
    folder, like so:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦全局安装完成，你可以在项目的文件夹中运行包，如下所示：
- en: '[PRE23]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Once the script is done, you will find the output in the `src-electron/icons`
    folder. That’s all there is to it!
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦脚本完成，你将在`src-electron/icons`文件夹中找到输出。这就是全部内容！
- en: Our default output is only suited for the platform we’re developing with. What
    we’re interested in is building for different platforms as well. We’ll discover
    those options in the next section.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们默认的输出仅适用于我们正在开发的平台。我们感兴趣的是为不同的平台构建。我们将在下一节中了解那些选项。
- en: Packaging for different targets
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为不同目标打包
- en: By default, Quasar uses **Electron Packager** ([https://electron.github.io/electron-packager/main/](https://electron.github.io/electron-packager/main/))
    under the hood to create the package for you. You could change it to **Electron
    Builder** ([https://www.electron.build/index.html](https://www.electron.build/index.html))
    as well, but for this example, we’ll use the default.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Quasar 在幕后使用 **Electron Packager** ([https://electron.github.io/electron-packager/main/](https://electron.github.io/electron-packager/main/))
    为你创建包。你也可以将其更改为 **Electron Builder** ([https://www.electron.build/index.html](https://www.electron.build/index.html))，但在这个例子中，我们将使用默认设置。
- en: 'If you open the `quasar.config.js` file, you can scroll to the `electron` property:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开 `quasar.config.js` 文件，你可以滚动到 `electron` 属性：
- en: '[PRE24]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This is the default setup. Since we’re dealing with the Electron Packager,
    our configuration goes in the `packager` property. To build for additional platforms,
    we can add the target platforms we want to build for as properties (as documented
    in the guide at [https://electron.github.io/electron-packager/main/modules/electronpackager.html#officialplatform](https://electron.github.io/electron-packager/main/modules/electronpackager.html#officialplatform)),
    and for each property, we can add additional configuration. We’ll use the configuration
    properties and default presets to target specific architectures per platform.
    The following configuration will attempt to build the app for macOS (Darwin),
    Linux, and Windows (Win32) and target specific architectures as an example:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这是默认设置。由于我们处理的是 Electron 打包器，我们的配置放在 `packager` 属性中。为了构建额外的平台，我们可以添加我们想要构建的目标平台作为属性（如指南中所述，见[https://electron.github.io/electron-packager/main/modules/electronpackager.html#officialplatform](https://electron.github.io/electron-packager/main/modules/electronpackager.html#officialplatform))，并且对于每个属性，我们可以添加额外的配置。我们将使用配置属性和默认预设来针对每个平台的目标架构。以下配置将尝试为
    macOS (Darwin)、Linux 和 Windows (Win32) 构建应用程序，并作为示例指定特定的架构：
- en: '[PRE25]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, there are some caveats. If I run the preceding code on a Mac or Linux
    machine, I will need to install a Windows emulator to build for that platform.
    The good news is that if you run **HomeBrew** ([https://brew.sh/](https://brew.sh/)),
    you can install **Wine** fairly easily with the following command:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有一些注意事项。如果我在 Mac 或 Linux 机器上运行前面的代码，我需要安装一个 Windows 模拟器来为该平台构建。好消息是，如果你运行
    **HomeBrew** ([https://brew.sh/](https://brew.sh/))，你可以使用以下命令轻松安装 **Wine**：
- en: '[PRE26]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The Quasar CLI provides you with that instruction. For non-macOS users, the
    app that you build will be unsigned. This means that users will need to manually
    accept the gatekeeping security warning. It will also be impossible to publish
    to the app store.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Quasar CLI 为你提供这些指令。对于非 macOS 用户，你构建的应用程序将是未签名的。这意味着用户需要手动接受门卫安全警告。它也将无法发布到应用商店。
- en: With the flexibility that Quasar and Electron offer in terms of native app development,
    it is still a very viable way of delivering apps that need to run on multiple
    platforms. Also, bear in mind that these apps may not be as performant concerning
    applications that were developed specifically for and on a target platform. Development
    is often about tradeoffs. However, having the possibility to develop and deliver
    a web app to a native platform is very useful.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在原生应用程序开发方面，Quasar 和 Electron 提供的灵活性仍然是一种非常可行的交付需要在多个平台上运行的应用程序的方式。此外，请注意，这些应用程序可能不如专门为特定平台开发的应用程序性能出色。开发往往涉及权衡。然而，能够开发和将网络应用程序交付到原生平台是非常有用的。
- en: And remember, the basis of our app is a `-m electron` flag with `-m spa`. It
    will bundle and build our application so that it’s ready for the web.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们应用的基础是一个带有 `-m spa` 的 `-m electron` 标志。它将打包并构建我们的应用程序，使其准备好在网络上运行。
- en: Summary
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we unlocked a powerful capability: we started with what we
    learned in [*Chapter 6*](B19563_06.xhtml#_idTextAnchor162) and built a web application.
    Using Quasar’s available features, we processed our code and deployed our web
    application as a standalone desktop application that’s suitable for multiple platforms.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们解锁了一个强大的功能：我们从一个在 [*第 6 章*](B19563_06.xhtml#_idTextAnchor162) 中学到的内容开始，构建了一个网络应用程序。使用
    Quasar 的可用功能，我们处理了我们的代码，并将我们的网络应用程序作为适合多个平台的独立桌面应用程序部署。
- en: We also adopted another framework to build an app. Instead of Vuetify, we relied
    on the default components that Quasar offers. This way, we’ve seen and experienced
    slight differences in code styles in building applications, using frameworks and
    build tools. We also experienced similarities, for instance, in the usage of Pinia
    as a centralized store.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还采用了另一个框架来构建应用。我们不是使用Vuetify，而是依赖Quasar提供的默认组件。这样，我们在构建应用时看到了并体验到了代码风格上的细微差异，使用框架和构建工具。我们也体验到了相似之处，例如，在Pinia作为集中式存储的使用上。
- en: This way of app building is not always the most suitable. There are some limitations
    and tradeoffs. On the upside, you only have to build one application and can deploy
    it to multiple targets. The cost efficiency of this development method makes it
    a serious candidate for multi-platform strategies.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这种应用构建方式并不总是最合适的。存在一些限制和权衡。优点在于，你只需构建一个应用，就可以部署到多个目标。这种开发方法的成本效益使其成为多平台策略的严肃候选人。
- en: In the next chapter, we’ll work on something fun. We’ll connect multiple devices
    to a single server and build a real-time quiz!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将做一些有趣的事情。我们将连接多个设备到单个服务器，并构建一个实时问答游戏！
- en: 'Part 3: Advanced Applications'
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3部分：高级应用
- en: This part of the book covers complex use cases, and you will learn how to break
    complexity down into individual parts and distribute responsibility accordingly.
    Also, you will learn the difference between, and use cases for, using Vue.Js as
    a frontend framework and adopting a meta-framework such as Nuxt to build server-side
    applications.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分的书籍涵盖了复杂的使用案例，你将学习如何将复杂性分解为单个部分并相应地分配责任。此外，你还将了解使用Vue.Js作为前端框架与采用如Nuxt这样的元框架来构建服务器端应用之间的区别及其用例。
- en: In addition, you will experience the process of investigating by prototyping,
    building, and iterating with experimental frameworks and solutions.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还将通过原型设计、构建和迭代实验性框架和解决方案来体验调查的过程。
- en: 'This part has the following chapters:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分包含以下章节：
- en: '[*Chapter 8*](B19563_08.xhtml#_idTextAnchor233), *Building an Interactive Quiz
    App*'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B19563_08.xhtml#_idTextAnchor233)，*构建交互式问答应用*'
- en: '[*Chapter 9*](B19563_09.xhtml#_idTextAnchor281), *Experimental Object Recognition
    with TensorFlow*'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B19563_09.xhtml#_idTextAnchor281)，*使用TensorFlow进行实验性物体识别*'
