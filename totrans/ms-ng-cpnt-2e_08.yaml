- en: Time Will Tell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our task-management system is shaping up. However, we have not been concerned
    about one crucial aspect of managing our projects so far. Time plays a major role
    in all projects, and it's probably the aspect that is often the most complicated
    to manage.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will add a few features to our task management system that
    will help our users to manage time more efficiently. Reusing some components that
    we created earlier, we will be able to provide a consistent user experience to
    manage time.
  prefs: []
  type: TYPE_NORMAL
- en: 'On a higher level, we will develop the following features to enable time management
    in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Task details**: So far, we did not include a details page of tasks because
    all the necessary information about tasks could be displayed on the task list
    of our project page. As our time management will increase the complexity of our
    tasks quite a bit, we will create a new detail view of project tasks that will
    also be accessible through routing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Efforts management**: We will include some new data on our tasks to manage
    efforts on tasks. Efforts are always represented by an estimated duration of time
    and an effective duration of spent time. We will make both properties of efforts
    optional so that they can exist independently. We will create new components to
    enable users to provide time duration input easily.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a project task detail component to edit task details and enable a new
    route
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying our tag management system to include task tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating new pipes to deal with formatting time durations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating task information components to display task overview information on
    the existing task components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a time duration component that enables users to easily input time durations
    using a no-UI user interaction approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing time effort tracking on tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an SVG component to display progress on tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Task details
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, our task list was sufficient enough to display all details of tasks
    directly in the listing. However, as we will add more details to tasks in this
    chapter, it's time to provide a detailed view where users can edit the task.
  prefs: []
  type: TYPE_NORMAL
- en: We already laid the groundwork for project navigation using the router in [Chapter
    5](237031a7-f616-4811-8486-08b5113d316f.xhtml), *Component-Based Routing*. Adding
    a new routable component that we'll use in the context of our projects will be
    a breeze.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start creating a new task details component, let's introduce a new
    state within our task model. Users should have the additional option to provide
    a task description in addition to the task title. This description will be editable
    on the task details view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open our model file, located in `src/app/model.ts`, and add an optional
    description field to our task interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Okay, so now we can store a description with each of our tasks. When new tasks
    are created on the task list, however, we will still only store the title of the
    task. A user needs to access the new detail view in order to update the description
    of a task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alright, let''s create a new component for our task detail view using the Angular
    CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s open the generated component class file in `src/app/tasks/task-details/task-details.component.ts`
    and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Within the task details, we're enabling the user to edit both the title and
    description of tasks. We're working on a simple UI component to represent the
    task details view. Therefore, we're expecting the task object to be set as a component
    input. The `outUpdateTask` output is used to communicate task updates to our parent
    component. We've also added two methods to be used within our view in order to
    update the task title and description.
  prefs: []
  type: TYPE_NORMAL
- en: We'd also like to support tag selection when a user edits the description of
    a task. For this purpose, we're adding a `tags` input, which can be provided by
    the parent component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alright, let''s now take a look at the template of our component, and see how
    we''ll deal with the task data to provide an interface to edit the details. Open
    the template file located in `src/app/tasks/task-details/task-details.component.html`
    and add the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: By reusing the editor component that we created in [Chapter 4](1682edec-f2b3-4b02-afd8-ed7ef586b712.xhtml),
    *Thinking in Projects*, we can rely on simple UI composition to make the title
    and description of our tasks editable.
  prefs: []
  type: TYPE_NORMAL
- en: As we stored the task data into the `task` member variable on our component,
    we can reference the `title` and `description` fields to create a binding to the
    `content` input property of our editor components.
  prefs: []
  type: TYPE_NORMAL
- en: While the title should only consist of plaintext, we can support the tagging
    functionality that we created in [Chapter 7](70aeeb16-2a1e-4d20-b523-00df06a8398a.xhtml),
    *Components for User Experience*, on the description field of the task. For this,
    we simply pass the list of available tags into the editor component.
  prefs: []
  type: TYPE_NORMAL
- en: We are using the editor components' `outSaveEdit` output property to call our
    update functions for updating the title or description, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: So far, so good. We created a task details component that makes it easy to edit
    the title and description of tasks using our editor UI component. Now, we need
    to create a container component for our task details view and enable it as a child
    route within our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the Angular CLI to create a task details container component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As always, the view of our container components is dead simple. We''re simply
    rendering a UI component and passing down the required data. Let''s do that by
    editing the template of our task details container component, which is located
    in `src/app/container/task-details-container/task-details-container.component.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The task details UI component required a task object to be passed as input
    as well as the list of tags supported by our application. We''ll obtain this data
    using the observables provided from the respective services. When a task is updated
    we''ll receive the `outUpdateTask` output event and call a method `updateTask`
    on our container component. Let''s open the component class located in `src/app/container/task-details-container/task-details-container.component.ts`
    and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: There's nothing new here. We're using a route parameter called `taskId` to obtain
    a specific task from the task list coming from our task service.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only thing left to enable our new task details view is to create a child
    route within our route configuration. Let''s open our route configuration, located
    in `src/app/routes.ts`, to make the necessary modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We added a new child route on our project view, which is now accessible with
    the URL `/projects/:projectId/tasks/:taskId`. By including the parameter `:taskId`
    in the route configuration, we can pass the concerned task ID into the task details
    container component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fantastic! We''ve created a new task details view and enabled it within our
    router. You can preview your changes within the browser and access the details
    view of a task by entering the following URL into your browser: `http://localhost:4200/projects/1/tasks/1`.
    You should now see the details view of the first task within our first project.
    Try editing the title and description before we move on with the integration of
    our task details view.'
  prefs: []
  type: TYPE_NORMAL
- en: Navigating to task details
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to make our task details route navigable, we need to modify our task
    component within the task list. We would like to add a small button to our task
    component that will navigate to the details view. Let''s start with the template
    changes; open our task component template, located in `src/app/tasks/task/task.component.html`,
    and apply the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s move right into our component class and implement the new `showDetails`
    method. Open the file `src/app/tasks/task/task.component.html` and apply the following
    changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Alright, now we need to make sure that we're carrying the event to show task
    details all the way up to the task list container component. Our next step is
    the task list UI component, where we need to delegate the `outShowDetails` output
    of our task component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the template changes in `src/app/tasks/task-list/task-list.component.html`
    and apply the following change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'That was easy! Now, let''s add the changes to the task list component class
    located in `src/app/tasks/task-list/task-list.component.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Great, the next stop in our component tree is the task list container, which
    is where we''ll implement the logic to navigate to the details view. Let''s open
    the template of the task list container, located in `src/app/container/task-list-container/task-list-container.component.html`,
    and create the necessary binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to implement the `showDetails` method within the container
    component class located in `src/app/container/task-list-container/task-list-container.component.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Hurray! We have finally made our task details view navigable using a new navigation
    button on our task component!
  prefs: []
  type: TYPE_NORMAL
- en: Now, you might ask yourself, why have we implemented such a crazy output delegation
    path, just to trigger a navigation? Wouldn't it be much easier to just use a `routerLink`
    directive within the task UI component and be done?
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, that would be much easier. However, there''s a slight problem with
    using router links within simple UI components. By doing so, we rely on a specific
    route configuration being present in our system. Using router links directly within
    UI components restricts them to a very specific context. We''d like to avoid this,
    so we can reuse our components in many different contexts. The only meaningful
    way to solve this issue is to use output delegation and control your navigation
    within container components programmatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5de1ef3b-662b-4706-b963-ca0504b9dc22.png)'
  prefs: []
  type: TYPE_IMG
- en: Newly created task detail view with editable title and description
  prefs: []
  type: TYPE_NORMAL
- en: Enabling tags for tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, the tag-management system that we created in [Chapter 7](70aeeb16-2a1e-4d20-b523-00df06a8398a.xhtml),
    *Components for User Experience*, only supports project tags. As we have now created
    a detail view for tasks, it would be nice to also support task tags directly in
    our tagging system. Our tagging system is quite flexible, and we can implement
    new tags with very little effort.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify our tags service, located in `src/app/tags/tags.service.ts`,
    in order to enable tags for our tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the project service, we're also injecting the task service within
    the constructor of our tags service. Very similar to what we already do for projects,
    we need to create a tag object for every single task within our application. We're
    using the observable provided by the task service and use the `map` operator to
    convert all tasks to tags.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we're using the `combineLatest` observable helper to merge both project
    tags and task tags into a single observable stream. Within a final map operator,
    we're concatenating those two tag lists into a single array.
  prefs: []
  type: TYPE_NORMAL
- en: 'This wasn''t too complicated, right? This relatively simple change results
    in a huge improvement for our users. They can now reference individual tasks everywhere
    in our system where we have enabled tags. By clicking a task tag, we are navigating
    to our newly created task details view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eecd6862-a29c-4085-a312-6bba0a1ea149.png)'
  prefs: []
  type: TYPE_IMG
- en: The editor component of the project comments tab displaying the newly added
    task tags
  prefs: []
  type: TYPE_NORMAL
- en: Managing efforts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will create some components that help us keep track of work
    efforts. Primarily, we will use this to manage efforts on tasks, but this could
    be applied to any part of our application where we need to keep track of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Efforts in our context always consist of two things:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Estimated duration**: This is the duration that is initially estimated for
    the task'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Effective duration**: This is the duration of time that is spent on a given
    task'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For time durations, we assume some time units and rules that will simplify
    the processing of time and align to some working standards. The goal here is not
    to provide razor sharp time management but something that is accurate enough to
    bring value. For this purpose, we define the following working time units:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Minute**: One minute is a regular 60 seconds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hour**: One hour always represents 60 minutes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Day**: One day represents a regular workday of eight hours'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Week**: One week is equivalent to five working days (5 * 8 hours)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When working with durations and efforts we would like to have some type safety,
    and for this reason, we''re introducing a few new interfaces to our model. Let''s
    open our model, located in `src/app/model.ts`, and add the following two interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `short` property on the `TimeUnit` interface will be used to recognize time
    entry by the user. We will use the letters m, h, d, and w for the different time
    units and store how many milliseconds each time frame contains.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we''d like to keep track of the time and efforts spent on tasks, let''s
    also modify our task model. Find the `Task` interface within our model file and
    add the following property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We have added a new optional `efforts` property to our task interface, which
    is storing the efforts spent working on our tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Alright, we have prepared our model for the upcoming time tracking features.
    In the next section, we're going to implement our first UI component to enter
    time durations.
  prefs: []
  type: TYPE_NORMAL
- en: No-UI time duration input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We could now start to write a complex user interface component, where users
    can enter individual time units in different input elements. However, I believe
    it's much more convenient to treat time duration input with a no-UI approach.
  prefs: []
  type: TYPE_NORMAL
- en: Put very simply, no-UI means that we use regular text input to provide user
    interactions. Well, that's nothing new right? Text input is where it all started.
    However, there's a significant trend in providing no-UI interactions lately. By
    combining intelligence in how we process the text input of users, no-UI interactions
    can actually be surprisingly efficient, and outperform complex user interfaces
    by far.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of building a complex user interface to enter time duration, we can
    simply agree on a textual short form to write durations. We can let the user write
    something, such as `1.5d` or `5h 30m`, in order to provide input. Sticking to
    the convention that we established at the beginning of this section, *Managing
    Efforts*, we can build a simple parser that can handle this sort of input.
  prefs: []
  type: TYPE_NORMAL
- en: This approach has several advantages. Besides that, this is one of the most
    efficient ways to enter time durations, and it's also easy for us to implement.
    We can simply reuse our editor component to gather text input from the user. Then,
    we use a conversion process to parse the entered time duration.
  prefs: []
  type: TYPE_NORMAL
- en: Let's spin up a new utility module that helps us deal with these conversions.
    Let's start by creating a new empty file on the path `src/app/utilities/time-utilities.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to have a constant that defines all the units we need for the
    conversion process. Add this first code excerpt to our newly created file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We make use of the `TimeUnit` interface which we've created in our model.
  prefs: []
  type: TYPE_NORMAL
- en: These are all the units that we need to deal with for now. You can see the milliseconds
    being calculated at run-time. We can also write the milliseconds as number literals,
    but calculating them in place provides us with some transparency on how we get
    to these values and we can spear on some comments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at our parsing function, which we can use to parse text input into
    time durations. Append the following code to our file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s analyze the preceding code briefly to explain what we do here:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we define a regular expression that helps us dissect the text representation
    of a duration. This pattern will extract chunks from the text input that are important
    to calculate the duration behind the text representation. These chunks always
    consist of a number, followed by either `w`, `d`, `h`, or `m`. Therefore, the
    text `10w 3d 2h 30m` will be split into the chunks `10w`, `3d`, `2h`, and `30m`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We initialize a `timeSpan` variable with `0`, so we can add all the milliseconds
    from discovered chunks together and later return this sum.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each of the previously-extracted chunks, we now extract the number component
    into a variable called `amount`, and the unit (`w`, `d`, `h`, or `m`) into a variable
    called `unitShortName`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we can look up the data in the `UNITS` constant for the unit of the chunk
    that we will process, multiply the amount of milliseconds of the unit by the amount
    we extract from the chunk, and then add that result to our `timeSpan` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Well, this is quite a neat function we have built here. It accepts a formatted
    time duration string and converts it into milliseconds. This is already half of
    what we need to deal with the textual representation of time durations. The second
    piece is the opposite of what just built. We need a function to convert a duration
    in milliseconds into a formatted duration string. Let''s append another piece
    of code to our file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also explain briefly what the `formatDuration` function does:'
  prefs: []
  type: TYPE_NORMAL
- en: We use the `Array.prototype.reduce` function to format a string that contains
    all time units and their amount. We iterate over all available time units in the
    `UNITS` constant, starting with the largest unit for weeks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then divide the `timeSpan` variable, which is in milliseconds, by the milliseconds
    of the unit, which gives us the amount of the given unit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the amount is greater than or equal to 1, we can add the unit with the given
    amount and unit short name to our formatted string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we could be left with some fractions after the comma in the amount, which
    we will need to encode in smaller units, we subtract the floored version of our
    amount from the `timeSpan` before we return to the `reduce` function again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This process is repeated for every unit, where each unit will only provide a
    formatted output if the amount is greater than or equal to 1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is all we need to convert back and forth between formatted time duration
    and time duration represented in milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll do one more thing before we create the actual component to enter time
    durations. We will create a simple pipe that basically just wraps our `formatTime`
    function. For this, we will create a new pipe using the Angular CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s open the generated file `src/app/pipes/format-duration.pipe.ts` and
    add the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Using the `formatTime` function of our new time utility module, we now have
    the ability to format durations in milliseconds directly in our component templates.
  prefs: []
  type: TYPE_NORMAL
- en: Components to manage efforts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Okay, this is enough time-math for the moment. Let's now use the elements that
    we've created to shape some components that will help us gather user input.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will create two components to manage efforts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Duration component**: The duration component is a simple UI component, enabling
    user input of time durations using the formatted time strings we dealt with in
    the previous topics. It uses an editor component to enable user input and makes
    use of the time formatting pipe as well as the `parseDuration` utility function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Efforts component**:The efforts component is just a composition of two duration
    components that represent the estimated effort and the effective effort spent
    on a given task. Following a strict rule of composition, this component is important
    for us so that we don''t repeat ourselves and instead compose a larger component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start with the duration component and use the Angular CLI to scaffold
    our initial component structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Alright, let''s now open the component class located in `src/app/ui/duration/duration.component.ts`
    and apply the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: There's nothing fancy about this component really, because we created the bulk
    of the logic already and we simply compose a higher component.
  prefs: []
  type: TYPE_NORMAL
- en: For the `duration` input, we expect a time duration in milliseconds, while the
    `outDurationChange` output property will emit the updated duration in milliseconds
    when the user provides some input.
  prefs: []
  type: TYPE_NORMAL
- en: The `editSaved` method serves in the binding to the underlying editor component.
    Whenever the user saves his edits on the editor component, we'll take this input,
    convert the formatted time duration into milliseconds using the `parseDuration`
    function, and re-emit the converted value using the `outDurationChange` output
    property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the template of our component in `src/app/ui/duration/duration.component.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Surprised with how simple our template is? Well, this is exactly what we should
    achieve with higher order components, once we establish a good foundation of base
    components. Well-organized composition radically simplifies our code. The only
    thing that we deal with here is our good old editor component.
  prefs: []
  type: TYPE_NORMAL
- en: We bind the `duration` input property of our duration component to the `content`
    input property of the editor component. As we'd like to pass the formatted time
    duration and not the duration in milliseconds, we use the `formatDuration` pipe
    to convert within the binding expression.
  prefs: []
  type: TYPE_NORMAL
- en: If the editor component notifies us about a saved edit, we call the `editSaved`
    method on our duration component, which will parse the entered duration and re-emit
    the resulting value a s milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: As we initially defined all efforts to consist of an estimated and an effective
    duration, we would now like to create another component that combines these two
    durations within a single component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new efforts component by using the Angular CLI tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Open up the template file of the generated component, located in `src/app/efforts/efforts/efforts.component.html`,
    and add the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: First, we add two duration components, where the first one is used to gather
    input for the estimated time and the later one for effective time.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to this, we provide three small buttons to increase the effective
    duration by a simple click. In this way, the user can quickly add one or four
    hours (half a working day) or a complete working day (which we defined as eight
    hours).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open the file `src/app/efforts/efforts/efforts.component.ts` and implement
    the component class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The component provides an input named `efforts` to provide a `TimeEfforts` object.
    If you take a look at the component template again, the `estimated` and `effective`
    properties of the efforts object are directly bound to the input properties of
    the duration components.
  prefs: []
  type: TYPE_NORMAL
- en: The `estimatedChange` and `effectiveChange` methods are used to create bindings
    to the `outDurationChange` output properties of the respective duration components.
    All we do here is emit an aggregated data object that contains the effective and
    estimated time in milliseconds using the `outEffortsChange` output property.
  prefs: []
  type: TYPE_NORMAL
- en: The `addEffectiveHours` method is used for our quick buttons within the template
    of our efforts component. We calculate the effective property by multiplying the
    number of milliseconds for a working hour with the number of hours passed to the
    function. We use our `UNITS` constant from the time utility module in order to
    get the number of milliseconds for an hour. After we've calculated the new effective
    duration, we're using the `outEffortsChange` output to propagate the update.
  prefs: []
  type: TYPE_NORMAL
- en: That's all we need in order to provide a user input to manage efforts on our
    tasks. To complete this topic, we will add our newly-created efforts component
    to the task details component in order to manage efforts on tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first look at the code changes in the task details component template
    located in `src/app/tasks/task-details/task-details.component.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We're simply including our new efforts component in the task details template.
    Since we have the efforts object already present on our task objects, we can create
    the necessary binding without additional changes in the component class. However,
    for updating the efforts when a user changes the estimated or effective durations,
    we will need to implement a new method `updateEfforts`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open our component class, located in `src/app/tasks/task-details/task-details.component.html`,
    and implement the new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We added a new `updateEfforts` method that deals with the output provided by
    the efforts component. Because the efforts property is part of the task object,
    we can simply reuse the `outUpdateTask` output to delegate the update. Our container
    component is already prepared to deal with task updates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Awesome stuff! We have successfully implemented a no-UI component and used
    the concept of composition to it''s best. You should now be able to preview the
    changes in your browser and manage efforts on the task details view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/47a486de-e505-4bcf-a5a8-1565bd0b6aad.png)'
  prefs: []
  type: TYPE_IMG
- en: Our new Efforts component that consists of two duration input components
  prefs: []
  type: TYPE_NORMAL
- en: The visual efforts timeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although the components that we have created so far to manage efforts provide
    a good way to edit and display effort and time durations, we can still improve
    this with some visual indication.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will create a visual efforts timeline using SVG. This timeline
    should display the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: The total estimated duration as a grey background bar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The total effective duration as a green bar that overlays on the total estimated
    duration bar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A yellow bar that shows any overtime (if the effective duration is greater than
    the estimated duration)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following two figures illustrate the different visual states of our efforts
    timeline component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ca97d17f-6145-460b-b300-3596098de1fd.png)'
  prefs: []
  type: TYPE_IMG
- en: The visual state if the estimated duration is greater than the effective duration
  prefs: []
  type: TYPE_NORMAL
- en: 'If a task''s effective time will be more than the originally estimated time,
    we can show that overtime in a different colour:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0f7283c6-c29b-4f24-9832-0e91848239b2.png)'
  prefs: []
  type: TYPE_IMG
- en: The visual state if the effective duration exceeds the estimated duration (the
    overtime is displayed as a yellow bar)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start fleshing out our visual timeline component by using Angular CLI
    to create our component stubs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Alright, let''s first look at the component class located in `src/app/efforts/efforts-timeline/efforts-timeline.component.ts`
    and implement the necessary logic to render our SVG timeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Our component has only one input. The `efforts` input is a `TimeEfforts` object
    which we're supposed to render on a graphical timeline. All the other properties
    that we need to render our timeline are derived from this efforts object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `OnChanges` lifecycle hook, we set two component member fields, which
    are based on the estimated and effective time:'
  prefs: []
  type: TYPE_NORMAL
- en: '**done**: This contains the width of the green bar in percent, which displays
    the effective duration without overtime that exceeds the estimated duration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**overtime**: This contains the width of the yellow bar in percent that displays
    any overtime, which is any time duration that exceeds the estimated duration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at the template of the efforts timeline component and see how we
    can now use the `done` and `overtime` member fields to draw our timeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the template file located in `src/app/efforts/efforts-timeline/efforts-timeline.component.ts`
    and apply the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Our template is SVG-based, and it contains three rectangles for each of the
    bars that we want to display. The background bar of our efforts timeline will
    always be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Above the remaining bar, we conditionally display the done and the overtime
    bar using the calculated widths from our component class.
  prefs: []
  type: TYPE_NORMAL
- en: That's all we need for representing our efforts timeline. We can now go ahead
    and include the efforts timeline component in our efforts component. This way,
    our users will have visual feedback when they edit the estimated or effective
    duration, and it provides them with a sense of overview.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open the template of the efforts component, located in `src/app/efforts/efforts/efforts.component.html`,
    and apply the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As we have the efforts object readily available in our component, we can simply
    create a binding to the efforts timeline component `efforts` input property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Congratulations! You''ve just put the cherry on the cake with this last change.
    Our users can now not only enter estimations and effective working hours using
    our efforts component, they also have a visual feedback of time available, spent,
    and overtime. Spin up the application in your browser and mess around with the
    new efforts component a bit. I''m sure you''ll enjoy the text-based no-UI input
    elements we''ve just created. Let''s take a look at a screenshot of our efforts
    timeline in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/89446e4a-15ca-42e2-97a5-e838cf2c95ed.png)'
  prefs: []
  type: TYPE_IMG
- en: The Efforts component displaying our newly-created efforts timeline component
    (the overtime of six hours is visualized with the yellow bar)
  prefs: []
  type: TYPE_NORMAL
- en: Recapitulating on efforts management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we have created components that allow users to manage efforts
    easily and add a simple but powerful time tracking to our tasks. We''ve done the
    following to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: We implemented some utility functions to deal with the time math in order to
    convert time durations in milliseconds into formatted time durations and vice
    versa
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We created a pipe to format time durations in milliseconds using our utility
    functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We created a duration UI component, which wraps an editor component and uses
    our time utilities to provide a no-UI kind of input element to enter durations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We created an efforts component that acts as a composition of two duration components
    for estimated and effective time, and provides additional buttons to add effective
    spent time quickly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We integrated the efforts component into the task details component in order
    to manage efforts on tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We created a visual efforts timeline component using SVG, which displays the
    overall progress on a task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we implemented some components that help our users keep track
    of time. They can now log efforts on tasks and manage milestones on projects.
    We created a new task detail view that can be accessed using a navigation link
    on our task list.
  prefs: []
  type: TYPE_NORMAL
- en: Isn't it nice how easy it suddenly seems to implement new functionality when
    using components with proper encapsulation? The great thing about component-oriented
    development is that your development time for new functionality is decreased with
    the number of reusable components that you already created.
  prefs: []
  type: TYPE_NORMAL
- en: Once more, we experienced the power of composition using components, and reusing
    existing components, we were able to easily implement higher components that provide
    more complex functionality.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at how to use the charting library Chartist
    and create some wrapper components that allow us to build reusable charts. Additionally,
    we will build a dashboard for our task management system, where we will see our
    chart components in action.
  prefs: []
  type: TYPE_NORMAL
