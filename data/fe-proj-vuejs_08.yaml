- en: 8\. The State of Vue.js State Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8. Vue.js状态管理的状态
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: By the end of this chapter, you will be able to use and contrast approaches
    for sharing state and holding global state in a Vue.js application. To this end,
    you will use a shared ancestor to hold state required by components that do not
    have a parent-child relationship (sibling components). You will also gain familiarity
    with an event bus in the context of a Vue.js application. As we proceed, you will
    understand how and when to leverage Vuex for state management, and its strengths
    and weaknesses when compared to other solutions such as event buses or Redux.
    Towards the end of the chapter, you will become comfortable with selecting which
    parts of state should be stored globally and locally and how to combine them to
    build a scalable and performant Vue.js application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够使用和对比在Vue.js应用程序中共享状态和保持全局状态的方法。为此，你将使用一个共享的祖先组件来保持那些没有父子关系的组件（兄弟组件）所需的状态。你还将熟悉Vue.js应用程序上下文中的事件总线。随着我们的深入，你将了解何时以及如何利用Vuex进行状态管理，以及与其他解决方案（如事件总线或Redux）相比的优势和劣势。在本章的末尾，你将熟悉选择哪些状态部分应该存储在全局和本地，以及如何将它们结合起来构建一个可扩展且性能良好的Vue.js应用程序。
- en: In this chapter, we will look at the state of Vue.js state management, from
    local state to component-based state sharing patterns to more advanced concepts
    such as leveraging event buses or global state management solutions like Vuex.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Vue.js状态管理的状态，从局部状态到基于组件的状态共享模式，再到更高级的概念，如利用事件总线或Vuex等全局状态管理解决方案。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, we'll explore the concept of state management in Vue.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Vue中状态管理的概念。
- en: In previous chapters, we have seen how to use local state and `props` to hold
    state and share it in a **parent-child** component hierarchy.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了如何使用局部状态和`props`来保持状态并在**父子**组件层次结构中共享它。
- en: We will begin by showing how to leverage `state`, `props`, and `events` to share
    state between components that are not in a **parent-child** configuration. These
    types of components are called **siblings**.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先展示如何利用`state`、`props`和`events`在不是**父子**配置的组件之间共享状态。这类组件被称为**兄弟组件**。
- en: '![Figure 8.1: Child 1 and Child 2 are "sibling" components'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.1: 子组件1和子组件2是“兄弟”组件'
- en: '](img/B15218_08_01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15218_08_01.jpg]'
- en: 'Figure 8.1: Child 1 and Child 2 are "sibling" components'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：子组件1和子组件2是“兄弟”组件
- en: Throughout the chapter, we will be building a **profile card generator** app
    that demonstrates how state flows down the component tree as props in an application,
    and how updates are propagated back up using events, event buses, and store updates.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的整个过程中，我们将构建一个**个人资料卡片生成器**应用程序，以展示状态如何在应用程序中以props的形式向下流动到组件树，以及如何使用事件、事件总线和存储更新来向上传播更新。
- en: Given that we want to build a `Header`, where we will have global controls and
    display the title of the page; a `ProfileForm`, where we will capture data; and
    finally, a `ProfileDisplay`, where we will display the profile card.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们想要构建一个`Header`，其中我们将有全局控件并显示页面标题；一个`ProfileForm`，我们将捕获数据；最后，一个`ProfileDisplay`，我们将显示个人资料卡片。
- en: '![Figure 8.2: Representation of a profile card application component tree'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.2: 表示个人资料卡片应用程序组件树'
- en: '](img/B15218_08_02.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15218_08_02.jpg]'
- en: 'Figure 8.2: Representation of a profile card application component tree'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：表示个人资料卡片应用程序组件树
- en: We have now seen how to reason about a component tree and how our application
    can be structured in a component tree.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了如何推理组件树以及我们的应用程序如何在组件树中结构化。
- en: Holding State in a Common Ancestor Component
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在公共祖先组件中保持状态
- en: To hold state only with component state and props and update it with events,
    we will store it in the nearest common ancestor component.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了仅使用组件状态和`props`来保持状态并使用事件来更新它，我们将将其存储在最近的公共祖先组件中。
- en: State is propagated only through `props` and is updated only through `events`.
    In this case, all the `state` will live in a shared ancestor of the components
    that require state. The App component, since it is the root component, is a good
    default for holding shared state.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 状态仅通过`props`进行传播，并且仅通过`events`进行更新。在这种情况下，所有`state`都将存在于需要状态的组件的共享祖先中。由于App组件是根组件，因此它是保持共享状态的理想默认选项。
- en: '![Figure 8.3: Common ancestor component holds state with props and event propagation'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.3: 公共祖先组件通过props和事件传播保持状态'
- en: '](img/B15218_08_03.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15218_08_03.jpg]'
- en: 'Figure 8.3: Common ancestor component holds state with props and event propagation'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3：常见的祖先组件通过属性和事件传播持有状态
- en: To change the `state`, a component needs to emit an `event` up to the component
    holding state (the shared ancestor). The shared ancestor needs to update `state`
    according to the event data and type. This in turn causes a re-render, during
    which the ancestor component passes updated `props` to the component reading the `state`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改 `state`，组件需要向持有状态（共享祖先）的组件发出 `event`。共享祖先需要根据事件数据和类型更新 `state`。这反过来又会导致重新渲染，在此期间，祖先组件将更新的
    `props` 传递给读取 `state` 的组件。
- en: '![Figure 8.4: Updating a sibling component when the ancestor holds state'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.4：当祖先持有状态时更新兄弟组件]'
- en: '](img/B15218_08_04.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_08_04.jpg)'
- en: 'Figure 8.4: Updating a sibling component when the ancestor holds state'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4：当祖先持有状态时更新兄弟组件
- en: 'To build a header, we need to create an `AppHeader` component in the `AppHeader.vue`
    file, which will contain a template and an `h2` heading with TailwindCSS classes:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个标题，我们需要在 `AppHeader.vue` 文件中创建一个 `AppHeader` 组件，它将包含一个模板和一个带有 TailwindCSS
    类的 `h2` 标题：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will then import it, register it, and render it in the `App.vue` file:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将导入它，注册它，并在 `App.vue` 文件中渲染它：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The output of the preceding code will be as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出将如下所示：
- en: '![Figure 8.5: AppHeader displayed in the profile card generator'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.5：在个人资料卡片生成器中显示的 AppHeader]'
- en: '](img/B15218_08_05.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_08_05.jpg)'
- en: 'Figure 8.5: AppHeader displayed in the profile card generator'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5：在个人资料卡片生成器中显示的 AppHeader
- en: 'We will similarly create an `AppProfileForm` file:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将同样创建一个 `AppProfileForm` 文件：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will create an `AppProfileDisplay` file with the following initial content:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个 `AppProfileDisplay` 文件，其初始内容如下：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Both of our containers (`AppProfileForm` and `AppProfileDisplay`) can now be
    imported and rendered in `App`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的两个容器（`AppProfileForm` 和 `AppProfileDisplay`）现在都可以导入并在 `App` 中渲染：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output of the preceding code will be as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出将如下所示：
- en: '![Figure 8.6: App skeleton with AppHeader, AppProfileForm, and AppProfileDisplay'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.6：带有 AppHeader、AppProfileForm 和 AppProfileDisplay 的 App 骨架]'
- en: '](img/B15218_08_06.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_08_06.jpg)'
- en: 'Figure 8.6: App skeleton with AppHeader, AppProfileForm, and AppProfileDisplay'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6：带有 AppHeader、AppProfileForm 和 AppProfileDisplay 的 App 骨架
- en: 'To add a form field, in this case `name`, we will start by adding an input
    to `AppProfileForm`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加一个表单字段，在这种情况下是 `name`，我们首先将在 `AppProfileForm` 中添加一个输入：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding code will display as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将显示如下：
- en: '![Figure 8.7: AppProfileForm with a name field and label'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.7：带有名称字段和标签的 AppProfileForm]'
- en: '](img/B15218_08_07.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_08_07.jpg)'
- en: 'Figure 8.7: AppProfileForm with a name field and label'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7：带有名称字段和标签的 AppProfileForm
- en: 'To keep track of the name input data, we will add a two-way binding to it using
    `v-model` and set a `name` property in the component''s `data` initializer:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪名称输入数据，我们将使用 `v-model` 添加双向绑定到它，并在组件的 `data` 初始化器中设置一个 `name` 属性：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We will also need a `submit` button that, on click, sends the form data to
    the parent by emitting a `submit` event with the form''s contents:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个 `submit` 按钮，点击时通过发出包含表单内容的 `submit` 事件将表单数据发送到父组件：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will display as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示如下：
- en: '![Figure 8.8: AppProfileForm with a wired-up submit button'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.8：连接好的提交按钮的 AppProfileForm]'
- en: '](img/B15218_08_08.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_08_08.jpg)'
- en: 'Figure 8.8: AppProfileForm with a wired-up submit button'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.8：连接好的提交按钮的 AppProfileForm
- en: The next step is to store the form's state in the `App` component. It is a good
    candidate for storing form state since it is a common ancestor to `AppProfileForm`
    and `AppProfileDisplay`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将表单状态存储在 `App` 组件中。由于它是 `AppProfileForm` 和 `AppProfileDisplay` 的共同祖先，因此它是存储表单状态的理想选择。
- en: 'To begin with, we will need a `formData` attribute returned from `data()`.
    We will also need a way to update `formData`. Hence, we will add an `update(formData)` method:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个由 `data()` 返回的 `formData` 属性。我们还需要一种更新 `formData` 的方法。因此，我们将添加一个 `update(formData)`
    方法：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we need to bind `update()` to the `submit` event emitted by `AppProfileForm`.
    We will do this using the `@submit` shorthand and with the magic event object
    notation as `update($event)`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将 `update()` 绑定到由 `AppProfileForm` 发出的 `submit` 事件。我们将使用 `@submit` 简写和魔法事件对象表示法
    `update($event)` 来完成此操作：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To display the name inside of `AppProfileDisplay`, we will need to add `formData`
    as a prop:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 `AppProfileDisplay` 内显示名称，我们需要将 `formData` 作为属性添加：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We will also need to display the name using `formData.name`. We will add a
    `p-12` class to the container to improve the appearance of the component:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要使用`formData.name`显示名称。我们将向容器添加一个`p-12`类来改善组件的外观：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, `App` needs to pass `formData` to `AppProfileDisplay` as a prop:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`App`需要将`formData`作为prop传递给`AppProfileDisplay`：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We are now able to update the name on the form. When you click on the `Submit`
    button, it will show the name in the profile card display as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在能够更新表单上的名称。当你点击`提交`按钮时，它将在配置文件显示中显示如下：
- en: '![Figure 8.9: App storing state, passing as props to AppProfileDisplay'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.9：App存储状态，作为props传递给AppProfileDisplay'
- en: '](img/B15218_08_09.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_08_09.jpg)'
- en: 'Figure 8.9: App storing state, passing as props to AppProfileDisplay'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9：App存储状态，通过props传递给AppProfileDisplay
- en: We have now seen how to store shared state on the `App` component and how to
    update it from the `AppProfileForm` and display it in `AppProfileDisplay`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到如何在`App`组件上存储共享状态，以及如何从`AppProfileForm`更新它并在`AppProfileDisplay`中显示它。
- en: In the next topic, we will see how to add an additional field to the profile
    card generator.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个主题中，我们将看到如何向配置文件生成器添加一个额外的字段。
- en: 'Exercise 8.01: Adding an Occupation Field to the Profile Card Generator'
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8.01：向配置文件生成器添加职业字段
- en: Following on from the example of storing the `name` shared state, another field
    that would be interesting to capture in a `profile card` is the occupation of
    the individual. To this end, we will add an `occupation` field to `AppProfileForm`
    to capture this extra piece of state, and we'll display it in `AppProfileDisplay`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储`name`共享状态的例子之后，另一个有趣的字段是个人职业。为此，我们将在`AppProfileForm`中添加一个`occupation`字段来捕获这个额外的状态，并在`AppProfileDisplay`中显示它。
- en: To access the code files for this exercise, refer to [https://packt.live/32VUbuH](https://packt.live/32VUbuH).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅[https://packt.live/32VUbuH](https://packt.live/32VUbuH)。
- en: 'The first place to start is by adding the new `occupation` field to `src/components/AppProfileForm`.
    We''ll also take this opportunity to get rid of the `h-64` and `bg-red-200` classes
    from the `section` element (if they''re present), which will mean the form displays
    without a background and without a set height:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先要做的就是在`src/components/AppProfileForm`中添加新的`occupation`字段。我们也将借此机会移除`section`元素上的`h-64`和`bg-red-200`类（如果存在），这意味着表单将没有背景和固定高度：
- en: '[PRE13]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output of the preceding code will be as follows:'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码的输出将如下所示：
- en: '![Figure 8.10: AppProfileForm with the new Occupation field'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图8.10：带有新职业字段的AppProfileForm'
- en: '](img/B15218_08_10.jpg)'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_08_10.jpg)'
- en: 'Figure 8.10: AppProfileForm with the new Occupation field'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.10：带有新职业字段的AppProfileForm
- en: 'To track the value of `occupation` with a two-way data binding, we will add
    a new property to the output of the `data()` property:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使用双向数据绑定跟踪`occupation`的值，我们将向`data()`属性的输出添加一个新属性：
- en: '[PRE14]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We will now apply a two-way data binding from the `occupation` reactive data
    property to the `occupation` input using `v-model`:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将使用`v-model`从`occupation`响应式数据属性到`occupation`输入进行双向数据绑定：
- en: '[PRE15]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For the `occupation` value to be transmitted when `submit` is clicked, we will
    need to add it to the `submitForm` method as a property of the `submit` event payload:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在点击`提交`时传输`occupation`值，我们需要将其添加到`submitForm`方法中作为`submit`事件负载的属性：
- en: '[PRE16]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The final step of adding this field is to display it in the `AppProfileDisplay`
    component. We add a paragraph with a couple of styling classes. We''ll also take
    this opportunity to remove the `h-64` and `bg-blue-200` classes from the container
    (if they are present):'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加此字段的最后一步是在`AppProfileDisplay`组件中显示它。我们添加一个带有几个样式类的段落。我们也将借此机会从容器中移除`h-64`和`bg-blue-200`类（如果存在）：
- en: '[PRE17]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Our browser should look as follows:'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的浏览器应该看起来如下：
- en: '![Figure 8.11: AppProfileForm'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图8.11：AppProfileForm'
- en: '](img/B15218_08_11.jpg)'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_08_11.jpg)'
- en: 'Figure 8.11: AppProfileForm'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11：AppProfileForm
- en: As we have just seen, adding a new field using the common ancestor to manage
    state is a case of passing the data up in an event and back down in the props
    to the reading component.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚刚看到的，使用共同祖先来管理状态添加新字段是一个在事件中向上传递数据并在props中向下传递到读取组件的情况。
- en: We will now see how we can reset the form and profile display with a `Clear`
    button.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将看到如何使用`Clear`按钮重置表单和配置文件显示。
- en: 'Exercise 8.02: Adding a Clear Button to the Profile Card Generator'
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8.02：向配置文件生成器添加清除按钮
- en: When creating a new profile with our application, it is useful to be able to
    reset the profile. To this end, we will add a `Clear` button.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用应用程序创建新配置文件时，能够重置配置文件是有用的。为此，我们将添加一个`Clear`按钮。
- en: A `Clear` button should reset the data in the form but also in `AppProfileDisplay`.
    To access the code files for this exercise, refer to [https://packt.live/2INsE7R](https://packt.live/2INsE7R).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`Clear`按钮应该重置表单中的数据，同时也重置`AppProfileDisplay`中的数据。要访问这个练习的代码文件，请参阅[https://packt.live/2INsE7R](https://packt.live/2INsE7R)。
- en: 'Now let''s look at the steps to perform this exercise:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看执行这个练习的步骤：
- en: 'We want a `Clear` button to be displayed. We will take this opportunity to
    improve the styling of both the `Clear` and `Submit` buttons (in `src/components/AppProfileForm.vue`):'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望显示一个`Clear`按钮。我们将借此机会改进`Clear`和`Submit`按钮的样式（在`src/components/AppProfileForm.vue`中）：
- en: '[PRE18]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To clear the form, we need to reset the `name` and `occupation` fields. We
    can create a `clear` method that will do this (in `src/components/AppProfileForm.vue`):'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要清除表单，我们需要重置`name`和`occupation`字段。我们可以在`src/components/AppProfileForm.vue`中创建一个`clear`方法来完成这个操作：
- en: '[PRE19]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We want to bind the `clear` method to `click` events on the `Clear` button
    to reset the form (in `src/components/AppProfileForm.vue`):'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望将`clear`方法绑定到`Clear`按钮的`click`事件上以重置表单（在`src/components/AppProfileForm.vue`中）：
- en: '[PRE20]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To also clear the contents of `AppProfileDisplay`, we will need to update `formData`
    in `App.vue` by emitting a `submit` event with an empty payload in `src/components/AppProfileForm.vue`:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要清除`AppProfileDisplay`的内容，我们需要通过在`src/components/AppProfileForm.vue`中发出一个带有空有效负载的`submit`事件来更新`App.vue`中的`formData`：
- en: '[PRE21]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When we fill out the form and submit it, it will look as follows:'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们填写表单并提交时，它看起来如下所示：
- en: '![Figure 8.15: AppProfileForm and AppProfileDisplay with data filled out'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图8.15：填写并提交数据的AppProfileForm和AppProfileDisplay'
- en: and submitted with a Clear button
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 并带有清除按钮提交
- en: '](img/B15218_08_15.jpg)'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_08_15.jpg)'
- en: 'Figure 8.15: AppProfileForm and AppProfileDisplay with data filled out and
    submitted with a Clear button'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.15：填写并提交数据的AppProfileForm和AppProfileDisplay，带有清除按钮
- en: 'We can click `Clear` and reset the data displayed in both `AppProfileDisplay`
    and `AppProfileForm` as per the following screenshot:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以点击`Clear`并按照以下截图重置`AppProfileDisplay`和`AppProfileForm`中显示的数据：
- en: '![Figure 8.16: AppProfileForm and AppProfileDisplay after data'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.16：数据清除后的AppProfileForm和AppProfileDisplay'
- en: is cleared (using the Clear button)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 被清除（使用清除按钮）
- en: '](img/B15218_08_16.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_08_16.jpg)'
- en: 'Figure 8.16: AppProfileForm and AppProfileDisplay after data is cleared (using
    the Clear button)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.16：清除数据后的AppProfileForm和AppProfileDisplay（使用清除按钮）
- en: We have now seen how to set up communication between sibling components through
    a common ancestor.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何通过共同祖先设置兄弟组件之间的通信。
- en: Note
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There is quite a bit of bookkeeping and mental work required to keep track of
    all the bits of state that need to stay in sync across the application.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟踪应用程序中需要保持同步的所有状态片段，需要做大量的记录和心智工作。
- en: In the next section, we will look at what an event bus is and how it can help
    alleviate some of the issues we have encountered.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨事件总线是什么以及它如何帮助我们缓解遇到的一些问题。
- en: The Event Bus
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件总线
- en: The second scenario we will look at is when there is a global event bus.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要探讨的第二种情况是当存在全局事件总线时。
- en: The **event bus** is an entity on which we can publish and subscribe to events.
    This allows all the different parts of the application to hold their own state
    and keep it in sync without passing events up to or props down from the common
    ancestors.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件总线**是一个实体，我们可以在这个实体上发布和订阅事件。这允许应用程序的不同部分保持自己的状态并保持同步，而无需将事件传递给或从共同的祖先传递下来。'
- en: '![Figure 8.17: Sequence diagram of a reader component and an updating component
    leveraging an event bus'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.17：利用事件总线的读取组件和更新组件的序列图'
- en: '](img/B15218_08_17.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_08_17.jpg)'
- en: 'Figure 8.17: Sequence diagram of a reader component and an updating component
    leveraging an event bus'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.17：利用事件总线的读取组件和更新组件的序列图
- en: To provide this, our event bus needs to provide a `subscribe` method and `publish`
    method. It's also useful to be able to unsubscribe.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供这一点，我们的事件总线需要提供一个`subscribe`方法和`publish`方法。能够取消订阅也是有用的。
- en: 'The Vue instance is an event bus since it provides three crucial operations:
    `main.js` file:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Vue实例是一个事件总线，因为它提供了三个关键操作：`main.js`文件：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Our event bus has a few methods, namely `$on`, which is the `$on(eventName,
    callback)`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的事件总线有几个方法，即`$on`，它是`$on(eventName, callback)`：
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can then use `$emit` to trigger the subscriber callback. `$emit(eventName,
    payload)` is the event bus'' `$emit` supports two parameters—the name of the event
    (as a string) and a payload, which is optional and can be any object. It can be
    used as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`$emit`来触发订阅者回调。`$emit(eventName, payload)`是事件总线的`$emit`支持两个参数——事件的名称（作为字符串）和负载，这是可选的，可以是任何对象。它可以如下使用：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Running this file in the browser will yield the following console output, where
    the subscriber is registered first, and the callback is then triggered on every
    `$emit`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中运行此文件将产生以下控制台输出，其中首先注册了订阅者，然后在每次`$emit`上触发回调：
- en: '![Figure 18.18: Console output from a Vue.js instance being used as an event
    bus with a subscriber and two event publications'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![图18.18：使用订阅者和两个事件发布的Vue.js实例作为事件总线的控制台输出'
- en: '](img/B15218_08_18.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_08_18.jpg)'
- en: 'Figure 18.18: Console output from a Vue.js instance being used as an event
    bus with a subscriber and two event publications'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.18：使用订阅者和两个事件发布的Vue.js实例作为事件总线的控制台输出
- en: '`$off`, the **unsubscribe** operation, needs to be called with the same parameters
    with which the **subscribe** operation was called. Namely, two parameters, the
    event name (as a string) and the callback (which is run with the event as a parameter
    on every event publication). To use it properly, we need to register a subscriber
    using a reference to a function (as opposed to an inline anonymous function):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`$off`，即**取消订阅**操作，需要使用与**订阅**操作相同的参数调用。即两个参数，事件名称（作为字符串）和回调（在每次事件发布时以事件作为参数运行）。为了正确使用它，我们需要使用函数的引用（而不是内联匿名函数）来注册订阅者：'
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Note that once `$off` is called, the second subscriber does not trigger but
    the initial one does. Your console output when run in the browser will look as
    follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一旦调用 `$off`，第二个订阅者不会触发，但初始订阅者会触发。在浏览器中运行时的控制台输出将如下所示：
- en: '![Figure 8.19: Console output showing the effect of $off'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.19：显示 $off 作用的控制台输出'
- en: '](img/B15218_08_19.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_08_19.jpg)'
- en: 'Figure 8.19: Console output showing the effect of $off'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.19：显示 $off 作用的控制台输出
- en: 'By setting an event bus in the `event-bus.js` file, we can avoid the confusion
    of having to send data up to the `App` component (the common ancestor):'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`event-bus.js`文件中设置事件总线，我们可以避免将数据发送到`App`组件（公共祖先）的混淆：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can `$emit` `profileUpdate` events to the event bus from the `AppProfileForm.vue`
    file on form submission instead of using `this.$emit`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从`AppProfileForm.vue`文件在表单提交时向事件总线`$emit` `profileUpdate`事件，而不是使用`this.$emit`：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the `AppProfileDisplay.vue` file, we can subscribe to `profileUpdate` events
    using `$on` and update `formData` in state. Note that we have removed the `formData`
    prop. We use the `mounted()` and `beforeDestroy()` hooks to subscribe to and unsubscribe
    from the event bus:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AppProfileDisplay.vue`文件中，我们可以使用`$on`订阅`profileUpdate`事件并在状态中更新`formData`。请注意，我们已经移除了`formData`属性。我们使用`mounted()`和`beforeDestroy()`钩子来订阅和取消订阅事件总线：
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The application works as expected. The following screenshot displays how your
    screen will look:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用按预期工作。以下截图显示了您的屏幕将如何显示：
- en: '![Figure 8.20: AppProfileForm and AppProfileDisplay communicating with an event
    bus'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.20：AppProfileForm和AppProfileDisplay通过事件总线进行通信'
- en: '](img/B15218_08_20.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_08_20.jpg)'
- en: 'Figure 8.20: AppProfileForm and AppProfileDisplay communicating with an event
    bus'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.20：AppProfileForm和AppProfileDisplay通过事件总线进行通信
- en: 'Since we have removed the `formData` prop for `AppProfileDisplay`, we can stop
    passing it in the `App.vue` file. Since we are not relying on `submit` events
    from `AppProfileForm`, we can also remove that binding:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们移除了`formData`属性用于`AppProfileDisplay`，我们可以在`App.vue`文件中停止传递它。由于我们不依赖于`AppProfileForm`的`submit`事件，我们也可以删除该绑定：
- en: '[PRE29]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can also remove the unused `App update` and `data` methods from the `App.vue`
    file, which means the whole `App` script section is as follows (only registers
    `components`, not state or handlers):'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以从`App.vue`文件中删除未使用的`App update`和`data`方法，这意味着整个`App`脚本部分如下（仅注册`components`，不注册状态或处理程序）：
- en: '[PRE30]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We have now simplified the application data flow by using an event bus instead
    of storing shared state in a common ancestor component. Now, we will see how to
    move the `Clear` button to the application header in the profile card generator.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在通过使用事件总线而不是在公共祖先组件中存储共享状态来简化了应用数据流。现在，我们将看到如何将“清除”按钮移动到配置文件生成器的应用头部。
- en: 'Exercise 8.03: Moving the Clear Button to the Application Header Profile Card
    Generator'
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8.03：将清除按钮移动到应用头部配置文件生成器
- en: In our profile card generator application, the `Clear` button clears the state
    in the whole application. Its presence inside the form makes the `Clear` button's
    functionality unclear since it looks like it might only affect the form.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的配置卡片生成应用程序中，`清除`按钮清除整个应用程序的状态。它在表单内的存在使得`清除`按钮的功能不明确，因为它看起来可能只会影响表单。
- en: To reflect the fact that the `Clear` button is global functionality, we will
    move it into the header.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了反映`清除`按钮是全局功能的事实，我们将将其移动到标题中。
- en: To access the code files for this exercise, refer to [https://packt.live/2UzFvwZ](https://packt.live/2UzFvwZ).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅[https://packt.live/2UzFvwZ](https://packt.live/2UzFvwZ)。
- en: 'The following steps will help us perform this exercise:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助我们完成这项练习：
- en: 'We will start by creating a `button` in `src/components/AppHeader.vue`:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先在`src/components/AppHeader.vue`中创建一个`按钮`：
- en: '[PRE31]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can import the event bus and create a `clear()` handler in `AppHeader`,
    in which we''ll trigger an update event with an empty payload (in `src/components/AppHeader.vue`):'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在`AppHeader`中导入事件总线并创建一个`clear()`处理程序，其中我们将触发一个带有空有效负载的更新事件（在`src/components/AppHeader.vue`）：
- en: '[PRE32]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We should bind the `clear()` function to the `button` (in `src/components/AppHeader.vue`):'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该将`clear()`函数绑定到`按钮`（在`src/components/AppHeader.vue`）：
- en: '[PRE33]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'At this stage, we should be able to fill out the form and a `Reset` button
    should appear as follows:'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个阶段，我们应该能够填写表格，并且应该出现如下所示的`重置`按钮：
- en: '![Figure 8.21: Form filled out and the Reset button in the header'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.21：填写好的表格和标题中的重置按钮'
- en: '](img/B15218_08_21.jpg)'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_08_21.jpg)'
- en: 'Figure 8.21: Form filled out and the Reset button in the header'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.21：填写好的表格和标题中的重置按钮
- en: 'The `Reset` button only resets the `AppProfileDisplay` data:'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`重置`按钮仅重置`AppProfileDisplay`数据：'
- en: '![Figure 8.22: Form filled out, but the card section has been cleared'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.22：填写好的表格，但卡片部分已被清除'
- en: '](img/B15218_08_22.jpg)'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_08_22.jpg)'
- en: 'Figure 8.22: Form filled out, but the card section has been cleared'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.22：填写好的表格，但卡片部分已被清除
- en: 'For `Reset` to clear the form, we need to subscribe to the `profileUpdate`
    events in the mounted life cycle method of `AppProfileForm` and react to said
    events by resetting the form (using `handleProfileUpdate`):'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使`重置`清除表格，我们需要在`AppProfileForm`的挂载生命周期方法中订阅`profileUpdate`事件，并通过重置表格（使用`handleProfileUpdate`）来响应这些事件：
- en: '[PRE34]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We also take this opportunity to delete the `Clear` button and adjust the `Submit`
    button:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也借此机会删除`清除`按钮并调整`提交`按钮：
- en: '[PRE35]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The form looks as follows when it gets filled out and submitted:'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 表单填写并提交后的样子如下：
- en: '![Figure 8.23: Filled-out and submitted form'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.23：填写并提交的表格'
- en: '](img/B15218_08_23.jpg)'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_08_23.jpg)'
- en: 'Figure 8.23: Filled-out and submitted form'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.23：填写并提交的表格
- en: 'Resetting the form now clears the form fields as well as `AppProfileDisplay`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重置表格会清除表单字段以及`AppProfileDisplay`：
- en: '![Figure 8.24: Resetting the form and the display using the Reset button'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.24：使用重置按钮重置表格和显示'
- en: '](img/B15218_08_24.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_08_24.jpg)'
- en: 'Figure 8.24: Resetting the form and the display using the Reset button'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.24：使用重置按钮重置表格和显示
- en: This final step using the event bus, triggering an event and listening for the
    same event, is part of the basis of the Vuex pattern where events and state updates
    are encapsulated.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用事件总线触发事件并监听相同事件是 Vuex 模式的基础，其中事件和状态更新被封装。
- en: Using the Vuex Pattern in Contrast with Other Patterns Such as Redux
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与其他模式如 Redux 对比使用 Vuex 模式
- en: The final scenario we will look at is using the Vuex pattern. In this case,
    all state is held in a single store. Any updates to the state are dispatched to
    this store. Components read shared and/or global state from the store.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要考虑的最后一个场景是使用 Vuex 模式。在这种情况下，所有状态都保存在单个存储中。对状态的任何更新都会派发到这个存储。组件从存储中读取共享和/或全局状态。
- en: Vuex is both a state management pattern and a library implementation from the
    Vue.js core team. The pattern aims to alleviate issues found when global state
    is shared by different parts of the application. The state of the store cannot
    be directly manipulated. **Mutations** are used to update store state and, since
    store state is reactive, any consumers of the Vuex store will automatically update.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Vuex 既是 Vue.js 核心团队提供的状态管理模式，也是库的实现。该模式旨在减轻当全局状态被应用程序的不同部分共享时发现的问题。存储的状态不能直接操作。**突变**用于更新存储状态，由于存储状态是响应式的，任何
    Vuex 存储的消费者都会自动更新。
- en: Vuex draws inspiration from previous work in the JavaScript state management
    space such as the **Flux** architecture, which popularized the concept of unidirectional
    data flow, and **Redux**, which is a single-store implementation of Flux.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Vuex 从 JavaScript 状态管理空间中的先前工作中汲取灵感，例如 **Flux** 架构，它普及了单向数据流的概念，以及 **Redux**，它是一个
    Flux 的单一存储实现。
- en: 'Vuex is not just another Flux implementation. It is a Vue.js-specific state
    management library. It can therefore leverage Vue.js-specific things such as reactivity
    to improve the performance of updates. The following diagram shows a hierarchy
    of the props and the state updates:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Vuex 不仅仅是一个 Flux 实现。它是一个针对 Vue.js 的特定状态管理库。因此，它可以利用 Vue.js 特定的东西，如响应性，以提高更新性能。以下图表显示了属性和状态更新的层次结构：
- en: '![Figure 8.25: Vuex props and state updates hierarchy'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.25：Vuex 属性和状态更新层次结构'
- en: '](img/B15218_08_25.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_08_25.jpg)'
- en: 'Figure 8.25: Vuex props and state updates hierarchy'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.25：Vuex 属性和状态更新层次结构
- en: 'To update pieces of global state, components trigger an update called a mutation
    in the store. The store knows how to handle this update. It updates state and
    propagates props back down accordingly through Vue.js reactivity:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更新全局状态的部分，组件会触发一个在存储中称为突变的更新。存储知道如何处理这种更新。它更新状态并通过 Vue.js 的响应性相应地向下传播属性：
- en: '![Figure 8.26: Sequence diagram of a global state update with Vuex'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.26：Vuex 全局状态更新序列图'
- en: '](img/B15218_08_26.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_08_26.jpg)'
- en: 'Figure 8.26: Sequence diagram of a global state update with Vuex'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.26：Vuex 全局状态更新序列图
- en: We can extend the existing application using Vuex.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Vuex 扩展现有应用程序。
- en: First, we need to add the `vuex` module using `yarn add vuex` or `npm install
    --save vuex`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要使用 `yarn add vuex` 或 `npm install --save vuex` 命令添加 `vuex` 模块。
- en: 'Next, we need to register Vuex with Vue using `Vue.use()` in the `store.js`
    file:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在 `store.js` 文件中使用 `Vue.use()` 将 Vuex 与 Vue 注册：
- en: '[PRE36]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Finally, we create a Vuex store with a default state. This state includes the
    same `formData` object we have been using in the `store.js` file. We then export
    it using `export default`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建一个具有默认状态的 Vuex 存储。此状态包括我们在 `store.js` 文件中使用的相同的 `formData` 对象。然后我们使用
    `export default` 导出它：
- en: '[PRE37]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, we need to register our store with our main application instance of
    Vue.js in the `main.js` file:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在 `main.js` 文件中将我们的存储与 Vue.js 的主应用程序实例注册：
- en: '[PRE38]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The great thing is that every component has a reference to the store under
    `this.$store`. For example, to access `formData`, we can use `this.$store.state.formData`.
    Using this, we can replace the event bus subscription and local state updates
    in the script section of the `AppProfileDisplay.vue` file with a single computed
    property:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 令人兴奋的是，每个组件都有一个对 `this.$store` 下的存储的引用。例如，要访问 `formData`，我们可以使用 `this.$store.state.formData`。使用这个，我们可以用单个计算属性替换
    `AppProfileDisplay.vue` 文件脚本部分中的事件总线订阅和本地状态更新：
- en: '[PRE39]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: To trigger state updates, we need to define some mutations. In this case, we
    need `profileUpdate` in the `store.js` file. Mutations receive `state` (the current
    state) and `payload` (the store `commit` payload) as properties.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要触发状态更新，我们需要定义一些突变。在这种情况下，我们需要在 `store.js` 文件中定义 `profileUpdate`。突变接收 `state`（当前状态）和
    `payload`（存储 `commit` 负载）作为属性。
- en: '[PRE40]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now that we have got a `profileUpdate` mutation, we can update the `Reset`
    button in the `AppHeader.vue` file to use the Vuex `$store.commit()` function:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经得到了 `profileUpdate` 突变，我们可以在 `AppHeader.vue` 文件中更新 `Reset` 按钮以使用 Vuex
    `$store.commit()` 函数：
- en: '[PRE41]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We should also update the `AppProfileForm.vue` file to commit to the `$store`
    instead of emitting to the event bus:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该更新 `AppProfileForm.vue` 文件，将提交操作提交到 `$store` 而不是通过事件总线发出：
- en: '[PRE42]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The application will now support updating the name and occupation:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序现在将支持更新名称和职业：
- en: '![Figure 8.27: Application with AppProfileForm filled out and submitted'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.27：填写并提交的 AppProfileForm 应用程序'
- en: '](img/B15218_08_27.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_08_27.jpg)'
- en: 'Figure 8.27: Application with AppProfileForm filled out and submitted'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.27：填写并提交的 AppProfileForm 应用程序
- en: 'Unfortunately, the `Reset` button does not clear the form:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`Reset` 按钮没有清除表单：
- en: '![Figure 8.28: Application with AppProfileForm not clearing on Reset button
    click'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.28：在点击 Reset 按钮时未清除 AppProfileForm 的应用程序'
- en: '](img/B15218_08_28.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_08_28.jpg)'
- en: 'Figure 8.28: Application with AppProfileForm not clearing on Reset button click'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.28：在点击 Reset 按钮时未清除 AppProfileForm 的应用程序
- en: 'To reset more efficiently, we will add a `profileClear` mutation in the `store.js`
    file:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更有效地重置，我们将在 `store.js` 文件中添加一个 `profileClear` 突变：
- en: '[PRE43]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We will commit this action instead of `profileUpdate` in the `AppHeader.vue`
    file. Using `profileClear` instead of `profileUpdate` with empty data makes our
    code cleared:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `AppHeader.vue` 文件中将此操作提交为 `profileUpdate` 而不是 `profileUpdate`，使用空数据代替
    `profileUpdate` 使我们的代码清除：
- en: '[PRE44]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally, we will need to subscribe to store changes and reset the local state
    when `profileClear` is committed to the store in the `AppProfileForm` file:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要订阅存储更改，并在 `AppProfileForm` 文件中提交 `profileClear` 到存储时重置本地状态：
- en: '[PRE45]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now the application''s `Reset` button will work correctly with Vuex. Our screen
    should display as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用的“重置”按钮将正确地与 Vuex 一起工作。我们的屏幕应显示如下：
- en: '![Figure 8.29: Application Reset button clearing both the form and the display'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.29：应用程序重置按钮清除表单和显示]'
- en: '](img/B15218_08_29.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_08_29.jpg)'
- en: 'Figure 8.29: Application Reset button clearing both the form and the display'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.29：应用程序重置按钮清除表单和显示
- en: We have now seen how to use the Vuex store to store global state in our application.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了如何使用 Vuex 存储在应用程序中存储全局状态。
- en: 'Exercise 8.04: Adding an Organization Field to the Profile Generator'
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 8.04：将组织字段添加到配置生成器
- en: In a `profile card generator`, in addition to the name and occupation of an
    individual, it's also useful to know where they work, in other words, their organization.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在“配置卡生成器”中，除了个人的姓名和职业外，了解他们在哪里工作，换句话说，他们的组织，也是有用的。
- en: To do this, we will add an `organization` field in `AppProfileForm` and `AppProfileDisplay`.
    To access the code files for this exercise, refer to [https://packt.live/3lIHJGe](https://packt.live/3lIHJGe).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们将在 `AppProfileForm` 和 `AppProfileDisplay` 中添加一个 `organization` 字段。要访问此练习的代码文件，请参阅
    [https://packt.live/3lIHJGe](https://packt.live/3lIHJGe)。
- en: 'We can start by adding a new text input and label to `AppProfileForm`:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以从向 `AppProfileForm` 添加新的文本输入和标签开始：
- en: '[PRE46]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The new field looks as follows:'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 新字段看起来如下：
- en: '![Figure 8.30: Application with a new Organization field'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.30：具有新组织字段的应用程序]'
- en: '](img/B15218_08_30.jpg)'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_08_30.jpg)'
- en: 'Figure 8.30: Application with a new Organization field'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.30：具有新组织字段的应用程序
- en: 'We can then add the `organization` field to the initial state and mutations
    in `src/store.js` so that `organization` gets initialized, set during `profileUpdate`,
    and reset during `profileClear`:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以将 `organization` 字段添加到 `src/store.js` 中的初始状态和突变中，以便 `organization` 被初始化，在
    `profileUpdate` 时设置，并在 `profileClear` 时重置：
- en: '[PRE47]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We need to track `organization` in the local state of the `src/components/AppProfileForm.vue`
    component using `v-model` and initializing it in the `data()` function:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在 `src/components/AppProfileForm.vue` 组件的本地状态中跟踪 `organization`，使用 `v-model`
    并在 `data()` 函数中初始化它：
- en: '[PRE48]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'For the payload of the mutation to contain `organization`, we''ll need to add
    it to the `$store.commit(''profileUpdate'')` payload and also reset it in the
    form when a component triggers a `profileClear` mutation:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使突变的负载包含 `organization`，我们需要将其添加到 `$store.commit('profileUpdate')` 负载中，并在组件触发
    `profileClear` 突变时在表单中重置它：
- en: '[PRE49]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'For `organization` to display, we need to render it in `src/components/AppProfileDisplay.vue`
    using a conditional span (to hide `at` when there is no `organization` set):'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使 `organization` 显示，我们需要在 `src/components/AppProfileDisplay.vue` 中使用条件 span（当没有设置
    `organization` 时隐藏 `at`）来渲染它：
- en: '[PRE50]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The application will now allow us to capture an `organization` field and display
    it.
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应用程序现在将允许我们捕获 `organization` 字段并显示它。
- en: '![Figure 8.31: Profile Card Generator with Organization field support, filled
    out and submitted'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.31：支持组织字段的配置卡生成器，已填写并提交]'
- en: '](img/B15218_08_31.jpg)'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_08_31.jpg)'
- en: 'Figure 8.31: Profile Card Generator with Organization field support, filled
    out and submitted'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.31：支持组织字段的配置卡生成器，已填写并提交
- en: 'It will allow us to clear the profile without any issues too:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 它将允许我们无任何问题地清除配置：
- en: '![Figure 8.32: Profile Card Generator with Organization field support, after
    Reset button click'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.32：支持组织字段的配置卡生成器，点击重置按钮后]'
- en: '](img/B15218_08_32.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_08_32.jpg)'
- en: 'Figure 8.32: Profile Card Generator with Organization field support, after
    Reset button click'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.32：支持组织字段的配置卡生成器，点击重置按钮后
- en: We've now seen how to add a field to an application that uses Vuex. One of the
    biggest benefits of Vuex over an event bus or storing state in an ancestor component
    is that it scales as you add more data and operations. The following activity
    will showcase this strength.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了如何向使用 Vuex 的应用程序添加字段。Vuex 相比于事件总线或存储祖先组件中的状态的最大好处之一是，随着你添加更多数据和操作，它可以进行扩展。以下活动将展示这一优势。
- en: 'Activity 8.01: Adding Email and Phone Number to a Profile Card Generator'
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 8.01：将电子邮件和电话号码添加到个人资料卡片生成器
- en: In a profile generator, you look at a profile to find some information about
    the individual. Email and phone number are often the most crucial pieces of information
    looked for on a profile card. This activity is about adding these details to a
    profile card generator.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在个人资料生成器中，你查看个人资料以获取有关个人的某些信息。电子邮件和电话号码通常是个人资料卡片上寻找的最关键的信息。这个活动是关于将这些详细信息添加到个人资料卡片生成器中。
- en: 'To do this, we will add `Email` and `Phone Number` fields in `AppProfileForm`
    and `AppProfileDisplay`:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们将在 `AppProfileForm` 和 `AppProfileDisplay` 中添加 `Email` 和 `Phone Number`
    字段：
- en: We can start by adding a new `email` input field and label to `AppProfileForm`
    for the `Email` field.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以先向 `AppProfileForm` 添加一个新的 `email` 输入字段和标签，用于 `Email` 字段。
- en: 'We can then add a new `phone` input field (of type `tel`) and a label to `AppProfileForm`
    for the `Phone Number` field:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以在 `AppProfileForm` 中添加一个新的 `phone` 输入字段（类型为 `tel`）和标签，用于 `Phone Number`
    字段：
- en: 'The new fields look as follows:'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 新字段如下所示：
- en: '![Figure 8.33: Application with new Email and Phone Number fields'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.33：包含新电子邮件和电话号码字段的应用程序]'
- en: '](img/B15218_08_33.jpg)'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_08_33.jpg)'
- en: 'Figure 8.33: Application with new Email and Phone Number fields'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.33：包含新电子邮件和电话号码字段的应用程序
- en: We can then add the `email` and `phone` fields to the initial state and mutations
    in `src/store.js` so that organization gets initialized, set during `profileUpdate`,
    and reset during `profileClear`.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以在 `src/store.js` 中的初始状态和突变中添加 `email` 和 `phone` 字段，以便在 `profileUpdate`
    期间设置组织，并在 `profileClear` 期间重置。
- en: We need to track `email` in the local state of the `src/components/AppProfileForm.vue`
    component using `v-model` and initialize it in the `data()` function.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在 `src/components/AppProfileForm.vue` 组件的本地状态中使用 `v-model` 跟踪 `email`，并在
    `data()` 函数中初始化它。
- en: We need to track `phone` in the local state of the `src/components/AppProfileForm.vue`
    component using `v-model` and initialize it in the `data()` function.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在 `src/components/AppProfileForm.vue` 组件的本地状态中跟踪 `phone`，使用 `v-model` 并在
    `data()` 函数中初始化它。
- en: For the payload of the mutation to contain `email` and `phone`, we'll need to
    add it to the `$store.commit('profileUpdate')` payload. We'll also want to reset
    it in the form when a component triggers a `profileClear` mutation.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使突变的负载包含 `email` 和 `phone`，我们需要将其添加到 `$store.commit('profileUpdate')` 负载中。我们还想在组件触发
    `profileClear` 突变时在表单中重置它。
- en: For `email` to display, we need to render it in `src/components/AppProfileDisplay.vue`
    using a conditional paragraph (to hide the `Email` label when there is no email
    set).
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了显示 `email`，我们需要在 `src/components/AppProfileDisplay.vue` 中使用条件段落（在未设置电子邮件时隐藏
    `Email` 标签）来渲染它。
- en: For `phone` to display, we need to render it in `src/components/AppProfileDisplay.vue`
    using a conditional span (to hide the `Phone Number` label when there is no phone
    set).
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了显示 `phone`，我们需要在 `src/components/AppProfileDisplay.vue` 中使用条件 span（在未设置电话时隐藏
    `Phone Number` 标签）来渲染它。
- en: 'The application should look as follows when the form is filled out and submitted:'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当表单填写并提交时，应用程序应如下所示：
- en: '![Figure 8.34: Application with Email and Phone Number fields'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.34：包含电子邮件和电话号码字段的应用程序]'
- en: '](img/B15218_08_34.jpg)'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_08_34.jpg)'
- en: 'Figure 8.34: Application with Email and Phone Number fields'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.34：包含电子邮件和电话号码字段的应用程序
- en: Note
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found via [this link](B15218_Solution_Final_SZ_ePub.xhtml#_idTextAnchor397).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以通过[此链接](B15218_Solution_Final_SZ_ePub.xhtml#_idTextAnchor397)找到。
- en: When to Use Local State and When to Save to Global State
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用本地状态和何时保存到全局状态
- en: As we have seen through the common ancestor, event bus, and Vuex examples, the
    Vue.js ecosystem has solutions for managing shared and global state. What we will
    look at now is how to decide whether something belongs in local state or global
    state.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如通过公共祖先、事件总线、Vuex 示例所见，Vue.js 生态系统有管理共享和全局状态的方法。我们现在将探讨如何决定某物属于本地状态还是全局状态。
- en: A good rule of thumb is that if a prop is passed through a depth of three components,
    it is probably best to put that piece of state in global state and access it that
    way.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的经验法则是，如果一个属性通过三个组件的深度传递，那么最好将这块状态放在全局状态中，并以此方式访问它。
- en: The second way to decide whether something is local or global is to ask the
    question *when the page reloads, does the user expect this information to persist?*.
    Why does this matter? Well, global state is a lot easier to save and persist than
    local state. This is due to global state's nature as *just a JavaScript object*
    as opposed to component state, which is more closely tied to the component tree
    and Vue.js.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 决定某事物是局部还是全局的第二种方法是问自己 *当页面重新加载时，用户是否希望这个信息保持不变？* 这为什么很重要呢？因为全局状态比本地状态更容易保存和持久化。这是由于全局状态的本质是
    *仅仅是一个 JavaScript 对象*，而与组件状态相比，组件状态与组件树和 Vue.js 的联系更为紧密。
- en: Another key idea to bear in mind is that it is very much possible to mix Vuex
    and local state in a component. As we have seen with the `AppProfileForm` examples,
    exercises, and activity, we can selectively sync data from mutations into a component
    using `$store.subscribe`.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要牢记的关键思想是，在组件中混合使用 Vuex 和本地状态是完全可能的。正如我们在 `AppProfileForm` 的示例、练习和活动中所看到的，我们可以使用
    `$store.subscribe` 选择性地从突变中同步数据到组件中。
- en: At the end of the day, there is nothing wrong with wrapping a Vue.js data property
    in a computed property and accessing the computed property to make a potential
    transition to Vuex easier. In this scenario, since all access is already done
    through the computed property, it is just a change from `this.privateData` to
    `this.$store.state.data`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将 Vue.js 的数据属性包装在计算属性中，并通过访问计算属性来使潜在过渡到 Vuex 更容易，这并没有什么问题。在这种情况下，由于所有访问都已经通过计算属性完成，所以只是从
    `this.privateData` 变为 `this.$store.state.data` 的一个变化。
- en: Summary
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: Throughout this chapter, we have looked at different approaches to shared and
    global state management in a Vue.js application.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了在 Vue.js 应用程序中共享和全局状态管理的不同方法。
- en: State in a shared ancestor allows data sharing between sibling components through
    props and events.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在共享祖先中的状态允许通过 props 和事件在兄弟组件之间共享数据。
- en: An event bus has three operations—`Vue.js` application. We have also seen how
    a `Vue.js` instance can be used as an event bus.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 事件总线有三个操作——`Vue.js` 应用。我们也看到了如何将 `Vue.js` 实例用作事件总线。
- en: You know what the Vuex pattern and library entail, how they differ from Redux
    and Flux, as well as the benefits of using a Vuex store over a shared ancestor
    or event bus.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道 Vuex 模式和库包含什么，它们与 Redux 和 Flux 的区别，以及使用 Vuex 存储相对于共享祖先或事件总线的优势。
- en: Finally, we have had a look at what criteria can be used to decide whether state
    should live in local component state or a more global or shared state solution
    such as Vuex. This chapter was an introduction to the state management landscape
    in `Vue.js`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了可以使用哪些标准来决定状态应该存在于本地组件状态还是更全局或共享的状态解决方案，例如 Vuex。这一章是关于 `Vue.js` 中状态管理领域的介绍。
- en: The next chapter will be a deep-dive into writing large-scale `Vue.js` applications
    with Vuex.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将深入探讨使用 Vuex 编写大规模 `Vue.js` 应用程序。
