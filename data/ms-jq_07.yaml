- en: Chapter 7. Advanced Event Handling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第七章。高级事件处理
- en: How many times do you go to a website to perform an action? It might be online
    banking, or perhaps purchasing something from Amazon; in both cases, the sites
    will detect the actions taking place, and respond accordingly.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你有多少次访问网站执行一个操作？它可能是在线银行业务，或者从亚马逊购买东西；在这两种情况下，网站将检测到正在发生的动作，并作出相应的反应。
- en: 'Part of working with jQuery is knowing how and when to respond to different
    types of events. In most cases, people are likely to use the `.on()` or `.off()`
    event handlers to handle them. While this works perfectly well, it just scratches
    the surface of what can be done with event handling. In this chapter, we will
    take a look at some of the tips and tricks we can use to expand our skills when
    it comes to event handling. We will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 jQuery 的一部分是知道何时以及如何响应不同类型的事件。在大多数情况下，人们可能会使用`.on()`或`.off()`事件处理程序来处理它们。虽然这样做完全没问题，但它只是触及了事件处理的表面。在本章中，我们将探讨一些可以帮助我们扩展事件处理技能的技巧和窍门。我们将涵盖以下主题：
- en: Delegating events
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件委托
- en: Using the `$.proxy` function
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`$.proxy`函数
- en: Creating and decoupling custom event types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和解耦自定义事件类型
- en: Namespacing events
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件命名空间
- en: Intrigued? Let's get on with it then!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 有兴趣吗？那我们就开始吧！
- en: Introducing event handling
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍事件处理
- en: A question – how often do you go online to perform a task? I'll bet it's a fair
    few times a week; it could be anything from online banking, to hitting Amazon
    to get that latest DVD (DVDs – who downloads them, I wonder?)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一个问题 - 你多久上线执行一项任务？我敢打赌这是每周都会发生的事情；它可能是任何事情，从在线银行业务到点击亚马逊购买最新的 DVD（DVD - 谁会下载它们，我想知道？）
- en: 'That aside, we can''t escape having to click on a link or a button to advance
    through a process. In most cases, the code behind the event is likely to be the
    ubiquitous click handler, or it could even be `.change()` or `.hover()`. All are
    shorthand forms of the `.on()` (or even `.off()`) event handlers, and are of course
    functionality equivalent to something like the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们无法避免必须点击链接或按钮来通过流程。在大多数情况下，事件背后的代码可能是普遍存在的点击处理程序，或者甚至可能是`.change()`或`.hover()`。所有这些都是`.on()`（甚至`.off()`）事件处理程序的简写形式，并且当然与以下内容的功能等效：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will turn the selected element to a nice shade of red. However, there is
    more to event handling than simply defining an action on a known element. Over
    the next few pages, we're going (to quote a nautical term) to push the boat out,
    and take a look at a few tips and tricks that we can use, to help develop our
    skills further. We'll begin with a look at event delegation.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使所选元素变成一个漂亮的红色。然而，事件处理不仅仅是在已知元素上定义一个操作。在接下来的几页中，我们将（引用一个航海术语）冒险一试，并查看一些可以帮助我们进一步发展技能的提示和技巧。我们将从事件委托开始。
- en: Delegating events
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件委托
- en: Someone once said that the art of being a good manager is to know when to delegate.
    I hope that this wasn't an excuse for them to offload a horrible job to a subordinate,
    although the cynical might say otherwise!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有人曾经说过，成为一名优秀的经理的艺术就是知道什么时候委派任务。我希望这不是他们把一个可怕的工作推卸给下属的借口，尽管愤世嫉俗的人可能会说另外一种看法！
- en: Leaving aside the risk, delegation follows the same principles in jQuery. If
    we need to create an application which requires binding some form of event handler
    to lots of elements of the same type, then we might consider writing event handlers
    to cover each element.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 撇开风险，事件委托遵循着 jQuery 中相同的原则。如果我们需要创建一个需要将某种形式的事件处理程序绑定到大量相同类型元素的应用程序，那么我们可以考虑编写事件处理程序来覆盖每个元素。
- en: It'll work to an extent, but is very wasteful of resources. If the list is large,
    then events will be bound to all of the elements within, which uses more memory
    than is needed. We can get around this by using **event delegation**, where we
    can shift to binding one event handler to a single ancestor element that serves
    multiple descendants, or enable event handling for newly created elements.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 它在某种程度上是有效的，但非常浪费资源。如果列表很大，那么事件将绑定到其中所有的元素，这会比所需的内存更多。我们可以通过使用**事件委托**来解决这个问题，我们可以将一个事件处理程序绑定到一个祖先元素，该元素为多个后代服务，或者为新创建的元素启用事件处理。
- en: There are a few tricks we can use to help us with better managing of events
    using delegation. Before we take a look at them, let's quickly recap the basics
    of how event delegation works.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些技巧可以帮助我们更好地使用委托来管理事件。在我们看看它们之前，让我们快速回顾一下事件委托的基本原理。
- en: Revisiting the basics of event delegation
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新审视事件委托的基础
- en: A question – how often have you used `.on()`, or even `.off()` when coding event
    handlers in jQuery? I'll bet the answer is probably countless times. If you've
    not already used event delegation before, then you're already halfway to using
    it without realizing it!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一个问题——你在使用 jQuery 编写事件处理程序时有多少次使用过`.on()`，甚至`.off()`？我敢打赌答案可能是无数次。如果你之前没有使用过事件委托，那么你已经无意中使用了一半！
- en: Event delegation relies on the use of **event propagation**, or event bubbling
    as it is sometimes known. It is the key to understanding how delegation works.
    Let's work through a quick example.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 事件委托依赖于使用**事件传播**，有时也称为事件冒泡。这是理解委托工作原理的关键。让我们通过一个快速的示例来说明。
- en: 'Imagine we''re using the following HTML code as the basis for a list:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们正在使用以下 HTML 代码作为列表的基础：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Nothing outrageous here – it''s a simple example. Any time one of our anchor
    tags is clicked, a click event is fired for that anchor. The event is dispatched
    in one of the three phases: **capturing**, **target**, and **bubbling**.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么特别的——这是一个简单的示例。每当我们的锚点标签之一被点击时，都会触发一个点击事件。事件在三个阶段之一中分派：**捕获**，**目标**和**冒泡**。
- en: 'It will be captured at the document root, work its way down until it hits its
    target (The `li` tag), before bubbling back up to the document root, as shown
    next:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 它将被捕获到文档根，在命中目标（`li`标签）之前向下工作，然后冒泡回文档根，如下所示：
- en: document root
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档根
- en: '`<html>`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<html>`'
- en: '`<body>`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<body>`'
- en: '`<div #container>`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<div #container>`'
- en: '`<ul #list>`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<ul #list>`'
- en: '`<li>`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<li>`'
- en: '`<a>`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<a>`'
- en: 'Yikes! This means that each time we''re clicking on a link, we''re effectively
    clicking on the whole document! Not great! It''s expensive on resources, and even
    if we were to add additional list items using code such as this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！这意味着每次点击链接时，实际上都在点击整个文档！不好！这会消耗资源，即使我们使用如下代码添加了额外的列表项：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We would find that the aforementioned click handler wouldn't work with these
    items.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会发现上述的点击处理程序不适用于这些项目。
- en: Tip
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The bubbling example used here is somewhat simplified, and doesn't show all
    the various phases. For a useful discussion, head over to the comments posted
    on Stack Overflow at [http://stackoverflow.com/questions/4616694/what-is-event-bubbling-and-capturing](http://stackoverflow.com/questions/4616694/what-is-event-bubbling-and-capturing).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的冒泡示例有些简化，并没有显示所有的各种阶段。要进行有用的讨论，请前往 Stack Overflow 上发布的评论 [http://stackoverflow.com/questions/4616694/what-is-event-bubbling-and-capturing](http://stackoverflow.com/questions/4616694/what-is-event-bubbling-and-capturing)。
- en: Reworking our code
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新调整我们的代码
- en: 'Instead of adding a directly bound handler, we can take advantage of event
    propagation, and rework our handler to listen for **descendant** anchors, instead
    of binding to existing anchor tags only. This can be seen in the following code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用事件传播来重新调整我们的处理程序，监听**后代**锚点，而不是仅绑定到现有锚点标签。这可以在以下代码中看到：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The only difference in the code is that we've moved the `a` selector to the
    second parameter position of the `.on()` method. This creates a single event handler
    against `#list`, with the event bubbling up one level from `a` to `#list`. Event
    delegation removes the need to create multiple event handlers, which is wasteful
    - the code will work equally well with both existing anchor tags within `#list`,
    and with any that are added in the future.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中唯一的区别是我们将`a`选择器移动到`.on()`方法的第二个参数位置。这将创建一个针对`#list`的单个事件处理程序，事件从`a`向上冒泡到`#list`。事件委托消除了创建多个事件处理程序的需要，这是一种浪费资源的做法——代码将同样适用于`#list`内现有的锚点标签，以及将来添加的任何锚点标签。
- en: Tip
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you would like to learn more about event delegation, then it is worth viewing
    the jQuery API documentation, which is at [http://learn.jquery.com/events/event-delegation/](http://learn.jquery.com/events/event-delegation/).
    The jQuery documentation also has a useful section on using `.on()` within delegated
    events at [http://api.jquery.com/on/](http://api.jquery.com/on/).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于事件委托的信息，建议查看 jQuery API 文档，网址是 [http://learn.jquery.com/events/event-delegation/](http://learn.jquery.com/events/event-delegation/)。jQuery
    文档还有一个关于在委托事件中使用`.on()`的有用部分，网址是 [http://api.jquery.com/on/](http://api.jquery.com/on/)。
- en: Supporting older browsers
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持旧版浏览器
- en: 'A small point – if you need to rework older code, then you may see `.bind()`,
    `.live()`, or `.delegate()` as event handlers. All were used to delegate events
    prior to jQuery 1.7, but should now be replaced with `.on()`. In fact, the first,
    `.bind` is a one line function that calls to `.on` (and its partner, `.off()`):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一个小提示 - 如果你需要重构旧代码，那么你可能会看到`.bind()`、`.live()`或`.delegate()`作为事件处理程序。在jQuery
    1.7之前，所有这些都用于委托事件，但现在应该替换为`.on()`。事实上，第一个`.bind`是一个调用`.on`（及其伴侣`.off()`）的单行函数：
- en: '![Supporting older browsers](img/image00395.jpeg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![支持旧版浏览器](img/image00395.jpeg)'
- en: 'The same applies for `.delegate()` and its partner event handler, `.undelegate()`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 同样适用于`.delegate()`及其配对事件处理器`.undelegate()`：
- en: '![Supporting older browsers](img/image00396.jpeg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![支持旧版浏览器](img/image00396.jpeg)'
- en: It should be noted that `.on()` mimics the behaviors found when using `.bind()`
    or `.delegate()`. The former is very resource hungry as it attaches to every single
    element it can match; the latter still has to work out which event handler to
    invoke. However, the scope of this should be smaller in comparison to using the
    `.bind()` method.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意`.on()`模仿了使用`.bind()`或`.delegate()`时发现的行为。前者非常耗资源，因为它会附加到每个可以匹配的元素；后者仍然需要确定要调用哪个事件处理程序。然而，与使用`.bind()`方法相比，这种情况的范围应该较小。
- en: Now that we've delved into the inner workings of `.on()`, let's put it into
    action, and create a simple demo to remind ourselves of how delegation works within
    jQuery.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经深入了解了`.on()`的内部工作原理，让我们将其付诸实践，并创建一个简单的演示来提醒自己jQuery中事件委托的工作方式。
- en: Exploring a simple demonstration
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索一个简单的演示
- en: 'It''s time for a little action, so let''s start with a quick reminder of how
    event delegation works, when using jQuery:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是行动的时候了，让我们快速回顾一下在使用jQuery时事件委托是如何工作的：
- en: Let's start by extracting the files we need from the code download that accompanies
    this book. For this demo, we need the `simpledelegation.html`, `simpledelegation.css`,
    and `jquery-ui.min.css` files.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从伴随本书的代码下载中提取我们需要的文件。对于这个演示，我们需要`simpledelegation.html`、`simpledelegation.css`和`jquery-ui.min.css`文件。
- en: Save the CSS files within the `css` subfolder of our project area. The HTML
    markup needs to be stored in the root area of the project folder.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将CSS文件保存在项目区域的`css`子文件夹中。HTML标记需要存储在项目文件夹的根目录中。
- en: 'In a new file, add the following code—save the file as `simpledelegation.js`,
    and store it in the `js` subfolder of our project area:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新文件中，添加以下代码 - 将文件保存为`simpledelegation.js`，并将其存储在项目区域的`js`子文件夹中：
- en: '[PRE4]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If all is well, we should see the following list of items, when previewing the
    results in a browser:![Exploring a simple demonstration](img/image00397.jpeg)
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切正常，当在浏览器中预览结果时，我们应该看到以下项目列表：![探索一个简单的演示](img/image00397.jpeg)
- en: Try clicking on a number of the links – if you click on any of the remove links,
    then the list item will be removed; clicking on one of the list items will remove
    all of the items from the list.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试点击一些链接 - 如果你点击任何一个移除链接，那么列表项将被移除；点击其中一个列表项将会移除列表中的所有项。
- en: 'The key to this demo is the following one line:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个演示的关键在于以下一行：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Although we have multiple items within the list, we've created one single delegated
    event handler. It bubbles up to the parent of the `<li>` item we clicked, then
    removes it. In this instance, we've separated out the function that is called
    when the event is triggered; this could easily have been incorporated into the
    handler.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管列表中有多个项目，但我们创建了一个单一的委托事件处理程序。它冒泡到我们点击的`<li>`项的父级，然后将其移除。在这种情况下，我们将触发事件时调用的函数分开了出来；这很容易可以合并到处理程序中。
- en: Now that we've revisited the basics of event delegation, let's take a look at
    some of the reasons why event delegation can lead to increased performance, when
    working with a lot of similar elements.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们重新审视了事件委托的基础知识，让我们看看事件委托为何可以在处理许多相似元素时提高性能。
- en: Exploring the implications of using event delegation
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索使用事件委托的影响
- en: The key benefit of implementing delegated events in place of direct equivalents,
    is reducing memory usage and avoiding memory leaks if multiple event handlers
    are present in our code. Normally, we would need to implement an event handler
    for each instance where we need something to happen.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在直接等效物代替委托事件的关键好处是减少内存使用量，避免代码中存在多个事件处理程序时的内存泄漏。通常，我们需要为需要发生某些事情的每个实例实现一个事件处理程序。
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The real impact of using event delegation is around the savings in memory usage,
    gained from where event handler definitions are stored within the internal data
    structure.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用事件委托的真正影响在于内部数据结构中存储事件处理程序定义所带来的内存使用量节约。
- en: Instead, reducing the number of event handlers means that we can reduce memory
    leaks and improve performance (by reducing the amount of code that has to be parsed).
    As long as we are careful about where we bind the event handler, there is a potential
    to dramatically reduce the impact on the DOM and the resulting memory usage, particularly
    in larger applications. The bonus is that if event delegation has been implemented,
    it will apply equally to existing elements that have been defined, as well as
    those that have yet to be created. Directly applied event handlers will not work;
    they can only be applied to elements that already exist prior to the event handler
    being called in the code.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，减少事件处理程序的数量意味着我们可以减少内存泄漏，改善性能（通过减少需要解析的代码量）。只要我们小心绑定事件处理程序的位置，就有潜力显著减少对DOM的影响和由此产生的内存使用量，特别是在更大的应用程序中。好处是，如果已实施事件委托，它将同样适用于已定义的现有元素，以及尚未创建的元素。直接应用的事件处理程序将不起作用；它们只能应用于在代码中调用事件处理程序之前已经存在的元素。
- en: The ability to handle events that exist, and those that have yet to happen,
    sounds like a good thing. After all, why repeat ourselves, if one event handler
    can handle multiple events, right? Absolutely – as long as we manage it carefully!
    If we trigger an event on a specific element, such as an anchor tag for example,
    then this will be allowed to handle the event first. The event will bubble up
    until it reaches document level, or a lower event handler decides to stop event
    propagation. This last part is key – without control, we could end up with unexpected
    results, where event handlers have responded, or not fired, contrary to expectations.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 处理已存在和尚未发生的事件的能力听起来是件好事。毕竟，如果一个事件处理程序可以处理多个事件，那么为什么要重复自己呢？绝对可以 - 只要我们小心管理！如果我们在特定元素上触发事件，例如一个锚点标签，那么这将被允许首先处理事件。事件会冒泡直到达到文档级别，或者更低级别的事件处理程序决定停止事件传播。这最后一部分很关键
    - 没有控制，我们可能会得到意外的结果，其中事件处理程序的响应与预期相反，可能也没有被触发。
- en: Tip
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: To see a detailed explanation of what can happen, take a look at [http://css-tricks.com/capturing-all-events/](http://css-tricks.com/capturing-all-events/).
    It contains links to examples on CodePen that illustrate this issue very well.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要看详细的解释可以发生什么，可以看看[http://css-tricks.com/capturing-all-events/](http://css-tricks.com/capturing-all-events/)。它包含了指向CodePen上很好地说明了这个问题的示例的链接。
- en: To help reduce the impact of event bubbling causing event handlers to fire out
    of turn, we use methods such as `event.stopPropagation()`. This is not the only
    trick we can use, so let's take a moment to explore some of the options available
    when using event delegation.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助减少事件冒泡引起事件处理程序无序触发的影响，我们使用诸如`event.stopPropagation()`之类的方法。这不是我们唯一能使用的技巧，因此让我们花点时间来探讨在使用事件委托时可用的一些选项。
- en: Controlling delegation
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制委托
- en: Taking advantage of event bubbling increases the scope for reducing the number
    of event handlers we need to implement within our code; the downside is the instances
    of unexpected behavior, where event handlers may not be triggered at the desired
    points.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 利用事件冒泡增加了我们在代码中实现的事件处理程序数量的减少的范围；缺点在于出现意外行为的实例，其中事件处理程序可能在期望的点上没有被触发。
- en: 'To control which elements might trigger a delegated event handler, we can use
    one of the following two tricks: `event.stopPropagation()`, or trapping the event
    target and determining if it matches a given set of conditions (such as a specific
    class or `data-` name).'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要控制哪些元素可能触发委托事件处理程序，我们可以使用以下两种技巧之一：`event.stopPropagation()`，或者捕获事件目标并确定它是否符合给定的一组条件（例如特定类或`data-`名称）。
- en: 'Let''s take a look at this second option first – an example block of code might
    look like the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先来看看这第二个选项 - 一个代码块的例子可能如下所示：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'That''s one clumsy way of doing things! Instead, we can simply instigate a
    check on the class name, using a variation of the delegated event handler, as
    shown next:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 那是一种笨拙的做事方式！相反，我们可以简单地对类名进行检查，使用下面显示的委托事件处理程序的变体：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is a really simple trick we can use – it''s so simple, it probably doesn''t
    count as a trick, as such! To see how easy it is to make the change, let''s run
    through a quick demo now:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的技巧，我们可以使用它 - 它非常简单，可能不算是一个技巧！为了看到改变有多容易，让我们现在快速进行一个演示：
- en: From the code download, we need to extract the `propagation-css.html` and `propagation.html`
    files. These contain some simple markup and styles for our basic list. Save the
    CSS file in the `css` subfolder of our project area, and the HTML markup at the
    root of the same area.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从代码下载中，我们需要提取`propagation-css.html`和`propagation.html`文件。这些文件包含了一些简单的标记和样式，用于我们的基本列表。将CSS文件保存在我们项目区域的`css`子文件夹中，将HTML标记保存在同一区域的根目录中。
- en: 'Next, we need to create the event handler that will fire when the conditions
    match. Go ahead and add the following to a new file, saving it as `propagation-css.js`
    in the `js` subfolder of our project area:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建事件处理程序，当条件匹配时将触发。继续添加以下内容到一个新文件中，并将其保存为`propagation-css.js`，保存在我们项目区域的`js`子文件夹中：
- en: '[PRE8]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: At this point, if we preview the results in a browser, we will have a simple
    list, where list items darken if we hover over a specific item. Nothing particularly
    special about this – it's just borrowing some styling from jQuery UI.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，如果我们在浏览器中预览结果，我们将得到一个简单的列表，其中列表项在我们悬停在特定项上时会变暗。这没什么特别的 - 它只是从jQuery UI中借用了一些样式。
- en: 'However, if we fire up a DOM inspector, such as Firebug, and then hover over
    each item, we can see console output is added each time we hover over an item
    with a class of `.yes`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们启动一个DOM检查器，比如Firebug，然后悬停在每个项目上，我们可以看到每次悬停在一个类为`.yes`的项目上时都会添加控制台输出：
- en: '![Controlling delegation](img/image00398.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![控制委托](img/image00398.jpeg)'
- en: So, instead of providing a selector as we did back in *Exploring a simple demonstration*,
    we simply used a class name; the event handler function will only fire if it matches
    the specified class name.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不像*探索一个简单的演示*中那样提供选择器，我们简单地使用了一个类名；只有当事件处理程序函数与指定的类名匹配时，事件处理程序函数才会被触发。
- en: Tip
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'We can even apply a `data-` tag as our check:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以使用`data-`标签作为我们的检查：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Using the stopPropagation() method as an alternative
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 作为替代方法使用stopPropagation()方法
- en: As an alternative, we can use an all-jQuery solution in the form of `stopPropagation()`.
    This prevents the event from bubbling up the DOM tree, and stops any parent handlers
    from being notified of the event.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 作为替代方法，我们可以使用一个全jQuery的解决方案，形式为`stopPropagation()`。这可以防止事件冒泡到DOM树，并阻止任何父处理程序被通知事件。
- en: 'This one-liner is a breeze to implement, although the key to using it is ensuring
    we add it at the right point in our code. If you''ve not used it before, then
    it needs to go within the event handler, immediately after the last command in
    the handler (as highlighted in the following snippet):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行代码的实现非常简单，尽管使用它的关键在于确保我们将其添加到我们代码的正确位置。如果你以前没有使用过它，那么它需要放在事件处理程序内，在处理程序的最后一个命令之后立即添加（如下面的片段中所突出显示的那样）：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As a quick check, try extracting the `propagation-js` files from the code download
    that accompanies this book. Save them in the relevant folders within our project
    area. If we preview them in a browser, we''ll see a simple **span** enclosed within
    a **div**. Refer to the following image:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 作为快速检查，尝试从附带本书的代码下载中提取`propagation-js`文件。将它们保存在我们项目区域内的相关文件夹中。如果我们在浏览器中预览它们，我们会看到一个简单的**span**包含在**div**内。参考下面的图片：
- en: '![Using the stopPropagation() method as an alternative](img/image00399.jpeg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![作为替代方法使用stopPropagation()方法](img/image00399.jpeg)'
- en: 'The key to this demo lies within the DOM Inspector. Try clicking on the grey-brown
    outer ring, or the span within it, and we will see the results of what we''ve
    selected appear in the console log, as shown next:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个演示的关键在于DOM检查器。尝试点击灰褐色的外环，或其中的span，我们将看到我们选择的结果出现在控制台日志中，如下所示：
- en: '![Using the stopPropagation() method as an alternative](img/image00400.jpeg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![作为替代方法使用stopPropagation()方法](img/image00400.jpeg)'
- en: If you comment out the `event.stopPropagation()` line within the code, the click
    event attached to `div` will also be invoked.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在代码中注释掉`event.stopPropagation()`行，那么附加到`div`的点击事件也将被调用。
- en: Tip
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Event propagation should not be stopped unless necessary. There is a useful
    article at [https://css-tricks.com/dangers-stopping-event-propagation/](https://css-tricks.com/dangers-stopping-event-propagation/)
    which discusses the problems you might encounter if propagation is stopped.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 除非必要，否则不应该停止事件传播。有一篇有用的文章位于[https://css-tricks.com/dangers-stopping-event-propagation/](https://css-tricks.com/dangers-stopping-event-propagation/)，其中讨论了如果停止传播可能遇到的问题。
- en: Okay, let's change focus and switch to another key concept within event handling.
    It's time to take a look at using the `$.proxy` function, and why this is needed,
    if event delegation doesn't propagate sufficiently for our needs.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们改变焦点，转到事件处理程序中的另一个关键概念。是时候看看使用 `$.proxy` 函数了，以及为什么需要它，如果事件委托不能满足我们的需要。
- en: Using the $.proxy function
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `$.proxy` 函数
- en: Up until now, we've covered how making use of event bubbling can help us reduce
    the need for lots of event handlers; provided we manage the bubbling carefully,
    then delegation can prove a very useful tool in developing with jQuery.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了如何利用事件冒泡可以帮助我们减少大量事件处理程序的需求；只要我们仔细管理冒泡，委托就可以成为使用 jQuery 进行开发的非常有用的工具。
- en: The flipside of this is that in some instances we may need to give jQuery a
    helping hand; when it doesn't propagate sufficiently high enough up the chain!
    At first this may not make sense, so let me explain what I mean.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 另一面的情况是，在某些情况下，我们可能需要帮助 jQuery；当它的传播不足够高！起初这可能不合理，所以让我解释一下我的意思。
- en: 'Let''s, for argument sake, imagine we have an event handler that has been created
    as an object, and that we want to call it when clicking on a link:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个作为对象创建的事件处理程序，并且当点击链接时，我们想调用它：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If we ran this in a browser, what would you expect to see in the console log
    area?
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中运行这个代码，您期望在控制台日志区域看到什么？
- en: Tip
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: To find out, try extracting the `proxy-before.html` file from the code download
    that accompanies this book. Make sure you have a DOM inspector installed!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出答案，请尝试从随本书附带的代码下载中提取 `proxy-before.html` 文件。确保您安装了 DOM 检查器！
- en: 'If you were expecting to see **Hello, Homer Simpson**, then I will have to
    disappoint you; the answer won''t be what you expect, but instead will be **Hello,
    undefined**, as shown in the following image:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您期望看到 **你好，霍默·辛普森**，那我将让您失望；答案不会是您期望的，而是 **你好，未定义**，如下图所示：
- en: '![Using the $.proxy function](img/image00401.jpeg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![使用 `$.proxy` 函数](img/image00401.jpeg)'
- en: Okay, so what gives?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这是怎么回事？
- en: The reason for this is that the context being used is within the `clickHandler`
    event, and not the `evntHandler` object; we don't have a `myName` property within
    the `clickHandler` event.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是所使用的上下文位于 `clickHandler` 事件中，而不是 `evntHandler` 对象中；我们在 `clickHandler` 事件中没有
    `myName` 属性。
- en: 'Thankfully, there is a simple fix for this. We can use `$.proxy` to force a
    change of context, as shown next:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这有一个简单的解决方法。我们可以使用 `$.proxy` 强制更改上下文，如下所示：
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To see this in action, extract the `proxy-before.html` and `proxy-after.html`
    files from the code download that accompanies this book. If you run them in a
    browser, you will see the same results as shown in the following screenshot:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到这种情况的效果，请从随本书附带的代码下载中提取 `proxy-before.html` 和 `proxy-after.html` 文件。如果在浏览器中运行它们，你将看到与下图中显示的相同的结果：
- en: '![Using the $.proxy function](img/image00402.jpeg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![使用 `$.proxy` 函数](img/image00402.jpeg)'
- en: This is a simple change to make, but it opens up a wide variety of possibilities.
    It is a shorthand method of setting the context for a closure. We could of course
    use the plain JavaScript `.bind()` methods. Instead, using `$.proxy` ensures that
    the function passed in is actually a function, and that a unique ID is passed
    to that function. If we add namespaces to our events, we can be sure that we unbind
    the correct event. The `$.proxy` function is seen as a single function within
    jQuery, even if it is used to bind different events. Using a namespace rather
    than a specific proxied function will avoid unbinding the wrong handler in our
    code.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的改变，但它打开了各种可能性。这是一种设定闭包上下文的简易方法。当然，我们也可以使用纯JavaScript的`.bind()`方法。但是，使用
    `$.proxy` 确保传入的函数是实际上是一个函数，并且向该函数传递了唯一的ID。如果我们给我们的事件添加命名空间，我们可以确保解绑正确的事件。`$.proxy`
    函数被视为 jQuery 中的单个函数，即使它被用来绑定不同的事件。使用命名空间而不是特定的代理函数将避免在代码中解绑错误的处理程序。
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you would like to learn more about using `$.proxy`, then it is worth reading
    the documentation on the main jQuery site, which is available at [http://api.jquery.com/jquery.proxy/](http://api.jquery.com/jquery.proxy/).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于使用 `$.proxy` 的内容，那么值得阅读主要 jQuery 网站上的文档，可以在[http://api.jquery.com/jquery.proxy/](http://api.jquery.com/jquery.proxy/)上找到。
- en: 'To give us a real flavor of what is possible, consider this for a moment: how
    many times have you ended up with functions nested three to four levels deep?
    Consider the following code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们真正了解可能性，考虑一下这个问题：你有多少次最终以三到四层深度嵌套的函数结束了？考虑以下代码：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Rather than working with the above mentioned code, we can refactor it to increase
    readability, by using `$.proxy`, as shown next:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用上述代码，我们可以通过使用`$.proxy`来重构代码以增加可读性，如下所示：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: I think you will agree that this is much easier to read, right?
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为你会同意这样更容易阅读，对吧？
- en: Okay – let's move on. I'm sure we are all familiar with creating event handlers
    in jQuery. However, chances are that you're working with standard event handlers.
    These will work perfectly well, but we're still limited in what we can do.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 好的 - 让我们继续吧。我相信我们都很熟悉在 jQuery 中创建事件处理程序。但是，很可能你正在使用标准事件处理程序。这些可以很好地工作，但我们仍然受限于我们所能做的事情。
- en: Well, let's change that. Using jQuery, we can create custom events that break
    the otherwise familiar mould of what we know is possible, and will allow us to
    create all kinds of event handlers. Let's take a look at how we can do this in
    action.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们改变这一点。使用 jQuery，我们可以创建打破我们知道可能性的常规的自定义事件，并且允许我们创建各种事件处理程序。让我们看看我们如何在实际操作中做到这一点。
- en: Creating and decoupling custom event types
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和解耦自定义事件类型
- en: If you've spent any time developing jQuery, then I am sure you are more than
    familiar with the standard event types that we can use, such as `.click()`, `.hover(),`
    or `.change()`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你花了一些时间开发 jQuery，那么我相信你对我们可以使用的标准事件类型非常熟悉，比如`.click()`、`.hover()`或`.change()`等。
- en: These all serve a useful purpose, but all have one thing in common – we're a
    bit limited in what we can do with them! Our code will be dictated by the extent
    of what these handlers can do. What if we can break this limitation, and create
    *any* type of custom event handler?
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都有用途，但都有一个共同点 - 我们在使用它们时受到了一些限制！我们的代码将受到这些处理程序可以做到的程度的限制。如果我们能打破这种限制，创建*任何*类型的自定义事件处理程序会怎样呢？
- en: 'Of course, we can always combine multiple events together, to be served by
    the same function:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们始终可以将多个事件组合在一起，由同一个函数来处理：
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: But this is still limited to those event handlers that are available out of
    the box. What we need is to break the mould and get creative in designing our
    own handlers.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 但这仍然局限于那些现成的事件处理程序。我们需要的是打破常规，在设计我们自己的处理程序时发挥创意。
- en: No problem – we can use jQuery's special event functionality to build pretty
    much any type of event to suit our needs. This opens up a real world of possibilities,
    which might warrant a book in its own right. Over the next few pages, we'll cover
    a few of the concepts to help get you started on the right path to creating events.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 没问题 - 我们可以使用 jQuery 的特殊事件功能构建几乎任何类型的事件以满足我们的需求。这打开了一个真正的可能性世界，可能需要一本专门的书来介绍。在接下来的几页中，我们将介绍一些概念，以帮助您开始创建事件。
- en: Tip
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: For a more in-depth look at creating custom events, there is a useful article
    on the learn jQuery site, at [http://learn.jquery.com/events/introduction-to-custom-events/](http://learn.jquery.com/events/introduction-to-custom-events/).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要深入了解创建自定义事件，请参阅 learn jQuery 网站上的一篇有用的文章，网址为[http://learn.jquery.com/events/introduction-to-custom-events/](http://learn.jquery.com/events/introduction-to-custom-events/)。
- en: 'The great thing about events is that they act just like their standard cousins,
    including bubbling up the DOM:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 事件的好处是它们的行为就像它们的标准版本一样，包括在 DOM 中冒泡：
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: So, what goes into the makeup of a special event? Special events will often
    take the form of a plugin; the format may be similar, but we'll frequently see
    any one of the several **fixHooks**, which we use to control the behavior of event
    processing in jQuery.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，特殊事件的组成是什么？特殊事件通常采用插件的形式；格式可能类似，但我们经常会看到几个**fixHooks**中的任何一个，我们用它来控制 jQuery
    中事件处理的行为。
- en: Note
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: jQuery special event hooks are a set of per-event-name functions and properties
    that allow code to control the behavior of event processing within jQuery.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 特殊事件钩子是一组按事件名称分组的函数和属性，允许代码控制 jQuery 内部事件处理的行为。
- en: Let's take a moment to have a look at the typical makeup of a special event
    plugin, before diving into an example of such a plugin.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花一点时间来看一下特殊事件插件的典型组成，然后再深入介绍一个这样的插件的示例。
- en: Creating a custom event
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义事件
- en: 'The fixHooks interface provides a route to normalize or extend the event object
    that will override a native browser event. We might typically see a format such
    as the following used in our event plugin:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: fixHooks接口提供了规范或扩展将覆盖本机浏览器事件对象的路径。我们通常会看到类似以下格式的事件插件被使用：
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It''s worth noting that when creating special event types, there are two methods
    that we will use frequently - `.on()`, for binding events, and `.trigger()`, for
    manually firing a specific event when needed. In addition, a special event plugin
    will expose a number of key methods which are useful to learn. Let''s explore
    these for a moment:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在创建特殊事件类型时，我们经常会使用两种方法 - `.on()`，用于绑定事件，以及`.trigger()`，用于在需要时手动触发特定事件。此外，特殊事件插件将公开许多有用的关键方法，值得学习。让我们来探索一下：
- en: '| Name of method / property | Purpose |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: 方法/属性名称 | 目的 |
- en: '| --- | --- |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `noBubble: false` | Boolean set to `false` by default. Indicates whether
    bubbling should be applied to this event type if the .`trigger()` method is called.
    |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `noBubble: false` | 布尔类型，默认值为`false`。指示如果调用`.trigger()`方法，是否应用冒泡到此事件类型。 |'
- en: '| `bindType` | When defined, these string properties specify that a special
    event should be handled like another event type until the event is delivered.
    Use the `bindType` for directly attached events, and `delegateType` for those
    that have been delegated. In both cases, these should be standard DOM types, such
    as `.click()`. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `bindType` | 当定义时，这些字符串属性指定应该如何处理特殊事件类型，直到事件被传递。对于直接附加的事件，请使用`bindType`，对于已委托的事件，请使用`delegateType`。在这两种情况下，这些都应该是标准的DOM类型，例如`.click()`。
    |'
- en: '| `handle: function(event: jQuery.Event, data: Object)` | Calls a handle hook
    when the event has occurred, and jQuery would normally call the user''s event
    handler specified by `.on()` or another event binding method. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `handle: function(event: jQuery.Event, data: Object)` | 当事件发生时调用处理程序钩子，jQuery通常会调用用户通过`.on()`或其他事件绑定方法指定的事件处理程序。
    |'
- en: '| `setup: function(data: Object, namespaces, eventHandle: function)` | Called
    the first time an event of a particular type is attached to an element. This provides
    the hook an opportunity to do processing that will apply to all events of this
    type on this element. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `setup: function(data: Object, namespaces, eventHandle: function)` | 第一次将特定类型的事件附加到元素时调用。这提供了一个机会，可以处理将应用于该元素上此类型的所有事件的处理。
    |'
- en: '| `teardown: function()` | Called when the final event of a particular type
    is removed from an element. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `teardown: function()` | 当特定类型的最终事件从元素中移除时调用。 |'
- en: '| `add: function(handleObj)``remove: function(handleObj)` | Called when an
    event handler is added to an element through an API such as `.on()`, or removed
    when using `.off()`. |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `add: function(handleObj)``remove: function(handleObj)` | 当通过`.on()`等API向元素添加事件处理程序时调用，或者在使用`.off()`时移除时调用。
    |'
- en: '| `_default: function(event: jQuery.Event, data: Object)` | Called when the
    `.trigger()` or `.triggerHandler()` methods are used to trigger an event for the
    special type from code, as opposed to events that originate from within the browser.
    |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `_default: function(event: jQuery.Event, data: Object)` | 当从代码中使用`.trigger()`或`.triggerHandler()`方法触发特殊类型事件时调用，而不是由浏览器内部发起的事件。
    |'
- en: It's worth getting to know these methods well, particularly if you use jQuery
    Mobile in your development. Mobile has a dependency on special events, to produce
    events such as `tap`, `scrollstart`, `scrollstop`, `swipe`, or `orientationchange`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在开发中使用jQuery Mobile，了解这些方法非常重要。移动端依赖特殊事件来产生事件，如`tap`，`scrollstart`，`scrollstop`，`swipe`或`orientationchange`。
- en: Tip
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For more details on each method, take a look at the Gist by Ben Alman, which
    is available at [https://gist.github.com/cowboy/4674426](https://gist.github.com/cowboy/4674426).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解每种方法的更多细节，请查看[https://gist.github.com/cowboy/4674426](https://gist.github.com/cowboy/4674426)上的Ben
    Alman的Gist。
- en: Special events will require a deeper level of knowledge, if you are using them
    to override standard behavior of events such as click or mouseover. To understand
    more of the inner workings, it is worth reading the article on the jQuery Learning
    Site at [http://learn.jquery.com/events/event-extensions/](http://learn.jquery.com/events/event-extensions/).
    Note though – it will get quite complex!
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用特殊事件来覆盖标准事件行为，那么就需要更深入地了解这些特殊事件。如果想要更多地了解内部工作原理，值得阅读jQuery Learning Site上的这篇文章：[http://learn.jquery.com/events/event-extensions/](http://learn.jquery.com/events/event-extensions/)。请注意
    - 这可能会变得非常复杂！
- en: Now that we've seen some of the inner workings of a special event plugin, it's
    time to get stuck in and see something in action. For this, we're going to use
    the jQuery Multiclick plugin produced by James Greene, to show how easy it is
    to capture an action such as triple-clicking, and use it to perform an action.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了一个特殊事件插件的一些内部工作原理，现在是时候投入使用并看到它在实际中的效果了。为此，我们将使用由James Greene制作的jQuery
    Multiclick插件，以展示捕获例如三次点击并将其用于执行操作的简单性。
- en: Working with the Multiclick event plugin
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用多次点击事件插件
- en: 'Creating a custom event can be as simple or as complex as is needed. For this
    demo, we''re going to use the jQuery Multiclick event plugin by James Greene.
    The plugin is available from [http://jamesmgreene.github.io/jquery.multiclick/](http://jamesmgreene.github.io/jquery.multiclick/).
    We''ll use it to post some messages on screen, with the message changing on every
    third click. Refer to the following image:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自定义事件可以简单也可以复杂。对于此演示，我们将使用James Greene的jQuery Multiclick事件插件。该插件可从[http://jamesmgreene.github.io/jquery.multiclick/](http://jamesmgreene.github.io/jquery.multiclick/)获取。我们将使用它在屏幕上发布一些消息，并且在每三次点击时更改消息。参考以下图片：
- en: '![Working with the Multiclick event plugin](img/image00403.jpeg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![使用多次点击事件插件](img/image00403.jpeg)'
- en: 'Let''s take a look at what is involved:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下涉及的内容：
- en: Let's start by extracting the following files from the code download that accompanies
    this book. For this demo, we'll need the `jquery.multiclick.js`, `jquery.min.js`,
    `multiclick.css`, and `multiclick.html` files. Store each of the files in the
    relevant subfolder within our project area.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从附带本书的代码下载中提取以下文件。对于此演示，我们将需要`jquery.multiclick.js`、`jquery.min.js`、`multiclick.css`和`multiclick.html`文件。将每个文件存储在项目区域内的相应子文件夹中。
- en: 'In a new file, add the following code, saving it as `multiclick.js`:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新文件中，添加以下代码，并保存为`multiclick.js`：
- en: '[PRE18]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is required to configure the multiclick plugin, and trigger the appropriate
    responses when the mouse has been clicked.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是配置多次点击插件所必需的，并在鼠标点击时触发相应的响应。
- en: Try running the demo in a browser. If all is well, we should see something similar
    to the screenshot shown at the start of the exercise, once we've clicked on the
    **Click me!** button a few times.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试在浏览器中运行演示。如果一切正常，一旦我们点击**Click me!**按钮几次，我们应该会看到与练习开始时显示的屏幕截图类似的东西。
- en: Although it probably has to be said that this isn't entirely representative
    of a real-world example, the techniques involved are nonetheless the same. The
    plugin is bound to the standard click handler, and will fire if the number of
    clicks reached is a multiple of the value stated in the configuration options
    for the plugin.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可能必须说这并不完全代表一个真实世界的例子，但所涉及的技术仍然是相同的。插件绑定到标准的点击处理程序，并且如果达到的点击次数是插件配置选项中指定值的倍数，则会触发。
- en: Namespacing events
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件命名空间
- en: So far, we've seen how we can delegate events and create handlers that can take
    custom triggers. These methods are perfect if we have a single click event handler,
    but what happens if we need to have multiple click handlers, for example?
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何委托事件并创建可以接受自定义触发器的处理程序。如果我们有一个单击事件处理程序，那么这些方法就非常完美，但是如果我们需要有多个点击处理程序呢？
- en: 'Well, fortunately there''s a simple solution: add a namespace to the event!
    Rather than talk about how it works, let''s take a quick look at the following
    example:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 好在，这里有一个简单的解决方案：给事件添加一个命名空间！而不是讨论它的工作原理，让我们快速看一下以下示例：
- en: '[PRE19]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This code is perfectly acceptable – nothing wrong with this at all. Sure, it
    might not be quite as readable as some might like, but we're not worried about
    that – at least not for now!
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是完全可接受的 - 没有任何问题！当然，这可能不像一些人所希望的那样可读，但我们现在并不担心这一点！
- en: 'The critical point here is if we were to call:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键点是如果我们调用：
- en: '[PRE20]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then we would lose not only the first click handler, but the second one as
    well. This is not ideal. We can fix this by adding a namespace or identifier to
    the command, as shown next:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们不仅会丢失第一个点击处理程序，还会丢失第二个点击处理程序。这不是理想的。我们可以通过添加命名空间或标识符来修复此问题，如下所示：
- en: '[PRE21]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we run the same `.off` command now, then clearly neither event handler will
    be removed. But – suppose we make the following change:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行相同的`.off`命令，显然两个事件处理程序都不会被移除。但是 - 假设我们做出以下更改：
- en: '[PRE22]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now we can safely remove the first event handler, without removing the second.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以安全地移除第一个事件处理程序，而不会移除第二个。
- en: Note
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If we had written `$("#element").off(".firsthandler")` instead, then it would
    have removed all event handlers that had this namespace assigned to them. This
    can be very useful when developing plugins.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们写的是 `$("#element").off(".firsthandler")`，那么它将删除所有拥有该命名空间的事件处理程序。这在开发插件时非常有用。
- en: 'The best way to understand how this works, is to see it in action. Let''s take
    a look at the following simple example now:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这是如何工作的最好方法，就是看它在实际中的表现。现在让我们来看下面这个简单的例子吧：
- en: '[PRE23]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The code for this demo is available in the code download that accompanies this
    book, as the `namespacing.html` file. You will need to extract it and a copy of
    jQuery in order to run the demo.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 此演示的代码可在随书附带的代码下载中找到，名为 `namespacing.html` 文件。您需要提取它以及 jQuery 的副本才能运行演示。
- en: 'Here, we''ve assigned two resize functions. We then remove the second using
    the namespace, which will leave the first completely untouched, as displayed in
    the following image:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们分配了两个调整大小的函数。然后我们使用命名空间删除第二个，这将完全不影响第一个，如下图所示：
- en: '![Namespacing events](img/image00404.jpeg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![事件命名空间](img/image00404.jpeg)'
- en: 'If we use a DOM Inspector to inspect the code, we can clearly see the namespace
    being assigned; to do so, set a breakpoint on line 12, then expand the list on
    the right, as shown in the next image:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 DOM Inspector 来检查代码，我们可以清楚地看到分配的命名空间；要做到这一点，设置一个断点在第 12 行，然后展开右侧的列表，如下图所示：
- en: '![Namespacing events](img/image00405.jpeg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![事件命名空间](img/image00405.jpeg)'
- en: At first, this may seem like a really simple change, but I am a great believer
    in the phrase KISS - you get the idea!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，这可能看起来像是一个非常简单的改变，但我非常相信 KISS 这个短语 - 你懂的！
- en: Tip
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: There is no limit to the depth or number of namespaces used; for example, `resize.layout.headerFooterContent`.
    Namespaces can equally be used with standard event or custom event handlers.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的命名空间的深度或数量没有限制；例如，`resize.layout.headerFooterContent`。命名空间也可以与标准事件或自定义事件处理程序一样使用。
- en: Adding a namespace identifier is a really quick and easy fix that we can apply
    to any event handler. It gives us perfect control over any event handler, particularly
    when assigning functions to multiple instances of the same event type within our
    code.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 添加命名空间标识符是我们可以应用于任何事件处理程序的一个非常快速简便的方法。它使我们对任何事件处理程序都有完美的控制，特别是在我们的代码中为多个实例分配函数到相同事件类型时。
- en: Note
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are frequently creating complex event handlers, then it may be worth
    to take a look at the Eventralize library by Mark Dalgleish, which is available
    from [http://markdalgleish.com/projects/eventralize/](http://markdalgleish.com/projects/eventralize/).
    Note, though, it hasn't had any updates for 2-3 years, but may be worth testing
    it to see if it helps consolidate and simplify your events.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您经常创建复杂的事件处理程序，则可能值得查看 Mark Dalgleish 的 Eventralize 库，该库可从 [http://markdalgleish.com/projects/eventralize/](http://markdalgleish.com/projects/eventralize/)
    获取。注意，它已经有 2-3 年没有更新了，但测试一下看它是否有助于整合和简化您的事件可能是值得的。
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Event handling is key critical to the success of any website or online application.
    If we get it right, it can make for an engaging user experience; getting it wrong
    can lead to some unexpected results! Over the last few pages, we've looked at
    few concepts to help develop our event handling skills; let's take a moment to
    review what we've learnt.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理对于任何网站或在线应用的成功至关重要。如果处理正确，可以打造一个引人入胜的用户体验；而处理不当则可能导致一些意想不到的结果！在过去的几页中，我们已经研究了一些概念，以帮助我们发展事件处理技能；让我们花点时间回顾一下我们学到的东西。
- en: We kicked off with a quick introduction into event handling, before moving swiftly
    onto exploring event delegation as one tool where we can benefit from its use
    in our code. We first looked at the basics of event delegation, before examining
    the implications of using it, and learning how we can control it within our code.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们先快速介绍了事件处理，然后迅速转移到探讨事件委托作为我们能够从中受益的工具之一。我们首先看了事件委派的基础知识，然后检查了使用它的影响，并学习了如何在我们的代码中控制它。
- en: Next up came a look at `$.proxy`, where we saw how jQuery sometimes needs a
    helping hand to ensure that an event is fired within the right context if our
    code means it doesn't propagate sufficiently high enough up the chain.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是查看 `$.proxy`，在那里我们看到 jQuery 有时需要帮助，以确保在我们的代码意味着事件没有在足够高的位置传播时，事件在正确的上下文中被触发。
- en: We then turned our attention to a brief look at creating custom event types
    and handlers, before exploring how such event handlers are constructed. We then
    used the jQuery Multiclick plugin as an example of how we can create these custom
    event handlers, before rounding up the chapter with a look at using namespacing
    to ensure that we can bind or unbind the right event handler in our code.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将注意力转向简要介绍创建自定义事件类型和处理程序，然后探讨这些事件处理程序是如何构建的。然后，我们以jQuery Multiclick插件作为示例，展示了如何创建这些自定义事件处理程序，最后以使用命名空间来确保我们能够在代码中绑定或解除绑定正确的事件处理程序来结束本章。
- en: In the next chapter, we'll be looking at some of the visual ways we can enhance
    our sites – we'll see how applying effects, and managing the resultant effects
    queue can help either make or break the success of our sites.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看一些视觉方式如何增强我们的网站 - 我们将看到如何应用效果，并管理结果效果队列如何帮助我们的网站的成功与否。
