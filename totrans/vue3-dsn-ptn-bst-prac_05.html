<html><head></head><body>
<div id="_idContainer039">
<h1 class="chapter-number" id="_idParaDest-104"><a id="_idTextAnchor130"/><span class="koboSpan" id="kobo.1.1">5</span></h1>
<h1 id="_idParaDest-105"><a id="_idTextAnchor131"/><span class="koboSpan" id="kobo.2.1">Single-Page Applications</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In this chapter, we continue to increase our skills in Vue 3 with the introduction of </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">single-page applications</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.6.1">SPAs</span></strong><span class="koboSpan" id="kobo.7.1">). </span><span class="koboSpan" id="kobo.7.2">We will learn what distinguishes them from regular websites and will dive into their key characteristics. </span><span class="koboSpan" id="kobo.7.3">To put this into action, we will build a new version of our To-Do application using the Vue Router and a different pattern of communication than the previous chapters. </span><span class="koboSpan" id="kobo.7.4">We will also learn authentication methods with </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">code samples.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">By the end of this chapter, you will know </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.11.1">How to create SPAs with </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">Vue 3</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">How to organize your application to make use of the Vue Router with different </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">routing strategies</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">How to reimplement our To-Do application with a practical application of </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">different patterns</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">How to implement different patterns of authentication in </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">your SPA</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.19.1">While the previous chapter was somewhat heavy with foundational knowledge, from now onward, we center more on practical matters. </span><span class="koboSpan" id="kobo.19.2">Because of this, you will need access to the example applications to </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">follow through.</span></span></p>
<h1 id="_idParaDest-106"><a id="_idTextAnchor132"/><span class="koboSpan" id="kobo.21.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.22.1">The code for this chapter can be found on GitHub, </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">at </span></span><a href="https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter05"><span class="No-Break"><span class="koboSpan" id="kobo.24.1">https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter05</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.25.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.26.1">Check out the following video to see the Code in </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">Action: </span></span><a href="https://packt.link/RnAyz"><span class="No-Break"><span class="koboSpan" id="kobo.28.1">https://packt.link/RnAyz</span></span></a></p>
<h1 id="_idParaDest-107"><a id="_idTextAnchor133"/><span class="koboSpan" id="kobo.29.1">What is a SPA?</span></h1>
<p><span class="koboSpan" id="kobo.30.1">To explain what a SPA is, we</span><a id="_idIndexMarker384"/><span class="koboSpan" id="kobo.31.1"> should first explain how we interact with</span><a id="_idIndexMarker385"/><span class="koboSpan" id="kobo.32.1"> the </span><strong class="bold"><span class="koboSpan" id="kobo.33.1">World Wide Web</span></strong><span class="koboSpan" id="kobo.34.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.35.1">WWW</span></strong><span class="koboSpan" id="kobo.36.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.37.1">W3</span></strong><span class="koboSpan" id="kobo.38.1">). </span><span class="koboSpan" id="kobo.38.2">When we enter an address in a web browser, we receive a web page sent by a web server. </span><span class="koboSpan" id="kobo.38.3">In the most basic form, a website is just a collection of pages, mostly what we call “static pages”. </span><span class="koboSpan" id="kobo.38.4">Static in this context means that the same files in the server are sent without modification. </span><span class="koboSpan" id="kobo.38.5">This makes a website very fast and secure. </span><span class="koboSpan" id="kobo.38.6">However, a purely static site does not </span><a id="_idIndexMarker386"/><span class="koboSpan" id="kobo.39.1">offer much interactivity with the end user. </span><span class="koboSpan" id="kobo.39.2">Sometimes this is referred to as </span><strong class="bold"><span class="koboSpan" id="kobo.40.1">Web 1.0</span></strong><span class="koboSpan" id="kobo.41.1">. </span><span class="koboSpan" id="kobo.41.2">Server and browser scripting came in to solve this limitation and gave birth</span><a id="_idIndexMarker387"/><span class="koboSpan" id="kobo.42.1"> to </span><strong class="bold"><span class="koboSpan" id="kobo.43.1">multi-page applications</span></strong><span class="koboSpan" id="kobo.44.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.45.1">MPAs</span></strong><span class="koboSpan" id="kobo.46.1">). </span><span class="koboSpan" id="kobo.46.2">Pages could now be either static or dynamically generated on the server, which in turn could also receive calls for new pages with additional data that processes them and returns a new page in response. </span><span class="koboSpan" id="kobo.46.3">These new pages “generated on the fly” are called </span><strong class="bold"><span class="koboSpan" id="kobo.47.1">dynamic</span></strong><span class="koboSpan" id="kobo.48.1"> and </span><a id="_idIndexMarker388"/><span class="koboSpan" id="kobo.49.1">made it possible to have applications. </span><span class="koboSpan" id="kobo.49.2">These technologies made it possible for blogs, services, and businesses </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">to proliferate.</span></span></p>
<p><span class="koboSpan" id="kobo.51.1">It was with the introduction of key technologies such as asynchronous communications (</span><strong class="bold"><span class="koboSpan" id="kobo.52.1">AJAX</span></strong><span class="koboSpan" id="kobo.53.1">), more powerful JavaScript, local storage methodologies, increased network speeds, and computational power that we came to what is known</span><a id="_idIndexMarker389"/><span class="koboSpan" id="kobo.54.1"> as </span><strong class="bold"><span class="koboSpan" id="kobo.55.1">Web 2.0</span></strong><span class="koboSpan" id="kobo.56.1">. </span><span class="koboSpan" id="kobo.56.2">It was now possible to load a single file into the browser and use JavaScript to take control of the entire interface and interactivity, producing rich and heavily interactive applications without generating new pages on the server. </span><span class="koboSpan" id="kobo.56.3">The SPA only contacts the server to load bits of data, the UI, and so on, as needed. </span><span class="koboSpan" id="kobo.56.4">It is now possible to migrate to web technologies what were traditional “desktop-only” applications, such as text editors, spreadsheets, rich email clients, graphic design suites, and so on. </span><em class="italic"><span class="koboSpan" id="kobo.57.1">Office 365</span></em><span class="koboSpan" id="kobo.58.1">, </span><em class="italic"><span class="koboSpan" id="kobo.59.1">Google Docs</span></em><span class="koboSpan" id="kobo.60.1">, </span><em class="italic"><span class="koboSpan" id="kobo.61.1">Photoshop online</span></em><span class="koboSpan" id="kobo.62.1">, </span><em class="italic"><span class="koboSpan" id="kobo.63.1">Telegram</span></em><span class="koboSpan" id="kobo.64.1">, </span><em class="italic"><span class="koboSpan" id="kobo.65.1">Discord</span></em><span class="koboSpan" id="kobo.66.1">, </span><em class="italic"><span class="koboSpan" id="kobo.67.1">Netflix</span></em><span class="koboSpan" id="kobo.68.1">, </span><em class="italic"><span class="koboSpan" id="kobo.69.1">YouTube</span></em><span class="koboSpan" id="kobo.70.1">, and so on are good examples of SPAs. </span><span class="koboSpan" id="kobo.70.2">It is important to acknowledge that the introduction of SPAs does not invalidate the use of MPAs or make them obsolete—each has its utility in certain contexts. </span><span class="koboSpan" id="kobo.70.3">Most blogs and news sites today are, in fact, MPAs and still constitute a significant part of the internet. </span><span class="koboSpan" id="kobo.70.4">The most complex web applications today include a mixture of MPAs and SPAs, working together. </span><span class="koboSpan" id="kobo.70.5">SPAs can even be installed as hybrid applications on desktop and mobile devices. </span><span class="koboSpan" id="kobo.70.6">We will see how to implement this in </span><a href="B18602_06.xhtml#_idTextAnchor148"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.71.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.72.1">, </span><em class="italic"><span class="koboSpan" id="kobo.73.1">Progressive </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.74.1">Web Applications</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.76.1">Moving forward, with the explosion of distributed and decentralized computing, and smart blockchains, the technology that makes up SPAs has gained even more relevance. </span><span class="koboSpan" id="kobo.76.2">While not fully rooted in general use, this new era in web evolution</span><a id="_idIndexMarker390"/><span class="koboSpan" id="kobo.77.1"> is called </span><strong class="bold"><span class="koboSpan" id="kobo.78.1">Web 3.0</span></strong><span class="koboSpan" id="kobo.79.1">. </span><span class="koboSpan" id="kobo.79.2">We will see in this chapter more about this topic, </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">with examples.</span></span></p>
<p><span class="koboSpan" id="kobo.81.1">All the applications that we have made this far fall into the SPA category, even if we have not used their full potential yet. </span><span class="koboSpan" id="kobo.81.2">Vue 3 is specially designed to create these types of applications, and is one of the most relevant technologies for such an approach, together with </span><em class="italic"><span class="koboSpan" id="kobo.82.1">React</span></em><span class="koboSpan" id="kobo.83.1">, </span><em class="italic"><span class="koboSpan" id="kobo.84.1">Angular</span></em><span class="koboSpan" id="kobo.85.1">, </span><em class="italic"><span class="koboSpan" id="kobo.86.1">Svelte</span></em><span class="koboSpan" id="kobo.87.1">, and others. </span><span class="koboSpan" id="kobo.87.2">But not everything is sugar, glitter, and rainbows. </span><span class="koboSpan" id="kobo.87.3">As with any technology, there are </span><a id="_idIndexMarker391"/><span class="koboSpan" id="kobo.88.1">trade-offs to using SPAs. </span><span class="koboSpan" id="kobo.88.2">In the next table, we list some </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">of them:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-3">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.90.1">Advantages</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.91.1">Disadvantages</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<ul>
<li><span class="koboSpan" id="kobo.92.1">Faster and smarter </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">loading times</span></span></li>
<li><span class="koboSpan" id="kobo.94.1">Local caching for </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">improved performance</span></span></li>
<li><span class="koboSpan" id="kobo.96.1">Rich UIs </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">and interactivity</span></span></li>
<li><span class="koboSpan" id="kobo.98.1">Easier to develop and test </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">than MPAs</span></span></li>
<li><span class="koboSpan" id="kobo.100.1">More efficient use of code and templates, with less network communication (as compared to </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">full-page re/loads)</span></span></li>
</ul>
</td>
<td class="No-Table-Style">
<ul>
<li><span class="koboSpan" id="kobo.102.1">Difficult for search engines to index </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">or discover</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.104.1">Increased complexity</span></span></li>
<li><span class="koboSpan" id="kobo.105.1">Increased load time and slower time for </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">first interactivity</span></span></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.107.1">Table 5.1 – Advantages and trade-offs for SPAs</span></p>
<p><span class="koboSpan" id="kobo.108.1">As you can see, the list </span><a id="_idIndexMarker392"/><span class="koboSpan" id="kobo.109.1">of advantages is by far more important than the disadvantages. </span><span class="koboSpan" id="kobo.109.2">You should consider using a SPA when the application requires significant user interactivity and real-time feedback. </span><span class="koboSpan" id="kobo.109.3">Now that we have a better idea of what a SPA is, let’s see the key concept at the core of their functionality: the </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">application </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.111.1">router</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">.</span></span></p>
<h1 id="_idParaDest-108"><a id="_idTextAnchor134"/><span class="koboSpan" id="kobo.113.1">The Vue 3 router</span></h1>
<p><span class="koboSpan" id="kobo.114.1">Vue is a great</span><a id="_idIndexMarker393"/><span class="koboSpan" id="kobo.115.1"> framework to build SPAs, but without a router, the task would soon become quite complex. </span><span class="koboSpan" id="kobo.115.2">The Vue router is an official plugin that takes over the navigation of the application and matches a URL to a component. </span><span class="koboSpan" id="kobo.115.3">This gives us the advantages of an MPA. </span><span class="koboSpan" id="kobo.115.4">With the router, we can do </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.117.1">Create and manage dynamic routes to components, matching parameters to props automatically </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">if needed</span></span></li>
<li><span class="koboSpan" id="kobo.119.1">Identify routes (addresses and components) by name and trigger navigation </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">by code</span></span></li>
<li><span class="koboSpan" id="kobo.121.1">Load components dynamically when needed, thus reducing the </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">bundle size</span></span></li>
<li><span class="koboSpan" id="kobo.123.1">Create a natural and logical way to approach website navigation and </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">code splitting</span></span></li>
<li><span class="koboSpan" id="kobo.125.1">Control navigation with well-known events, before and after </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">navigation occurred</span></span></li>
<li><span class="koboSpan" id="kobo.127.1">Create page transition animations in a way that is not possible </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">with MPAs</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.129.1">The implementation of the Vue 3 router is simple and follows the same methodology as with other components of the ecosystem. </span><span class="koboSpan" id="kobo.129.2">Let’s take our project from </span><a href="B18602_04.xhtml#_idTextAnchor102"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.130.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.131.1">, </span><em class="italic"><span class="koboSpan" id="kobo.132.1">User Interface Composition with Components</span></em><span class="koboSpan" id="kobo.133.1">, and modify it to use the </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">Vue router.</span></span></p>
<h2 id="_idParaDest-109"><a id="_idTextAnchor135"/><span class="koboSpan" id="kobo.135.1">Installation</span></h2>
<p><span class="koboSpan" id="kobo.136.1">When </span><a id="_idIndexMarker394"/><span class="koboSpan" id="kobo.137.1">starting a new project, you may have noticed that the installer menu gives you the option to install the Vue router. </span><span class="koboSpan" id="kobo.137.2">If you have not selected this option, as we did in our example app, the installation afterward is quite simple. </span><span class="koboSpan" id="kobo.137.3">In a terminal, in the project directory, just execute the </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.139.1">
$ npm install vue-router@4</span></pre>
<p><span class="koboSpan" id="kobo.140.1">The command will download and install the dependencies, just as with any other package in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">node_modules</span></strong><span class="koboSpan" id="kobo.142.1"> directory. </span><span class="koboSpan" id="kobo.142.2">In order to use it in our application, we need to do </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">the following:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.144.1">Create </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">our routes.</span></span></li>
<li><span class="koboSpan" id="kobo.146.1">Link the routes to </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">our components.</span></span></li>
<li><span class="koboSpan" id="kobo.148.1">Include the router in </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">our application.</span></span></li>
<li><span class="koboSpan" id="kobo.150.1">Set our templates where the router will display </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">our components.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.152.1">As with</span><a id="_idIndexMarker395"/><span class="koboSpan" id="kobo.153.1"> much of the framework, the router does not specify in which directories or organization your routes should be placed, or your components for that matter. </span><span class="koboSpan" id="kobo.153.2">However, there is a convention that we will use that has become the de facto standard in the industry. </span><span class="koboSpan" id="kobo.153.3">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">/src</span></strong><span class="koboSpan" id="kobo.155.1"> folder, create the </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">following directories:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">/router</span></strong><span class="koboSpan" id="kobo.158.1"> (or </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">/routes</span></strong><span class="koboSpan" id="kobo.160.1">): Here, we will have our JavaScript files with the routes for </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">our application</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">/views</span></strong><span class="koboSpan" id="kobo.163.1">: This folder will contain the top-level components that match the application navigation (as a </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">best practice)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.165.1">With these directories in place, we are ready to start modifying our application to include route navigation. </span><span class="koboSpan" id="kobo.165.2">Before that, let’s take a look at what we want to achieve with </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">our router.</span></span></p>
<h2 id="_idParaDest-110"><a id="_idTextAnchor136"/><span class="koboSpan" id="kobo.167.1">A new To-Do application</span></h2>
<p><span class="koboSpan" id="kobo.168.1">Our </span><a id="_idIndexMarker396"/><span class="koboSpan" id="kobo.169.1">new application will reuse the components to display our To-Do list, but also will accommodate the creation of multiple lists or projects. </span><span class="koboSpan" id="kobo.169.2">We will display a sidebar with all our projects, and when selecting them, the list will be updated11. </span><span class="koboSpan" id="kobo.169.3">These projects will also be persisted in the browser, so we can come back to them later by using </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">localStorage</span></strong><span class="koboSpan" id="kobo.171.1">. </span><span class="koboSpan" id="kobo.171.2">We will then have a very simple navigation, with two top-level </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">pages (components):</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.173.1">A landing page where we can create </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">new projects</span></span></li>
<li><span class="koboSpan" id="kobo.175.1">A project page where we can work with our </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">to-do list</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.177.1">Following these simple premises, our application once finished will look </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer031">
<span class="koboSpan" id="kobo.179.1"><img alt="Figure 5.1 – Our landing page" src="image/Figure_5.01_B18602.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.180.1">Figure 5.1 – Our landing page</span></p>
<p><span class="koboSpan" id="kobo.181.1">As you can</span><a id="_idIndexMarker397"/><span class="koboSpan" id="kobo.182.1"> see in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.183.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.184.1">.1</span></em><span class="koboSpan" id="kobo.185.1">, the landing page is also the place where we can create new projects. </span><span class="koboSpan" id="kobo.185.2">We use modal dialogs to collect user input, just as we did before. </span><span class="koboSpan" id="kobo.185.3">On the sidebar, we display a link to the </span><strong class="bold"><span class="koboSpan" id="kobo.186.1">Home</span></strong><span class="koboSpan" id="kobo.187.1"> page (the landing page) and a list with all the names of the different projects that we have created. </span><span class="koboSpan" id="kobo.187.2">When you click on each one, the route in the browser (URL) will update as well as the page, and we will see something </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer032">
<span class="koboSpan" id="kobo.189.1"><img alt="Figure 5.2 – A To-Do project page" src="image/Figure_5.02_B18602.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.190.1">Figure 5.2 – A To-Do project page</span></p>
<p><span class="koboSpan" id="kobo.191.1">You may recognize this last screenshot, as it is what our </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">ToDoProject.vue</span></strong><span class="koboSpan" id="kobo.193.1"> component displays. </span><span class="koboSpan" id="kobo.193.2">As a matter of fact, it will require very little modification to reach this result. </span><span class="koboSpan" id="kobo.193.3">For now, let’s begin with </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">the routes.</span></span></p>
<h2 id="_idParaDest-111"><a id="_idTextAnchor137"/><span class="koboSpan" id="kobo.195.1">Routes’ definition and the Router object</span></h2>
<p><span class="koboSpan" id="kobo.196.1">To create</span><a id="_idIndexMarker398"/><span class="koboSpan" id="kobo.197.1"> routes for our project, we need to first define them in their own module. </span><span class="koboSpan" id="kobo.197.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">/router</span></strong><span class="koboSpan" id="kobo.199.1"> directory, create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">index.js</span></strong><span class="koboSpan" id="kobo.201.1"> file with the </span><a id="_idIndexMarker399"/><span class="No-Break"><span class="koboSpan" id="kobo.202.1">following content:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.203.1">/src/router/index.js</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.204.1">
import {</span><strong class="bold"><span class="koboSpan" id="kobo.205.1">createRouter</span></strong><span class="koboSpan" id="kobo.206.1">,</span><strong class="bold"><span class="koboSpan" id="kobo.207.1">createWebHashHistory</span></strong><span class="koboSpan" id="kobo.208.1">} from 'vue-router'       </span><strong class="bold"><span class="koboSpan" id="kobo.209.1">//1</span></strong><span class="koboSpan" id="kobo.210.1">
import Landing from "../views/Landing.vue"                         </span><strong class="bold"><span class="koboSpan" id="kobo.211.1">//2</span></strong><span class="koboSpan" id="kobo.212.1">
const </span><strong class="bold"><span class="koboSpan" id="kobo.213.1">routes </span></strong><span class="koboSpan" id="kobo.214.1">= [
    {path: "/",name: "landing",component: Landing},
    {path: "/project/:id",name: "project",
        component: </span><strong class="bold"><span class="koboSpan" id="kobo.215.1">() =&gt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.216.1">            import(</span></strong><span class="koboSpan" id="kobo.217.1">"../views/ToDoProject.vue"</span><strong class="bold"><span class="koboSpan" id="kobo.218.1">)</span></strong><span class="koboSpan" id="kobo.219.1">,                    </span><strong class="bold"><span class="koboSpan" id="kobo.220.1">//3</span></strong><span class="koboSpan" id="kobo.221.1">
        props: true
}],
</span><strong class="bold"><span class="koboSpan" id="kobo.222.1">router </span></strong><span class="koboSpan" id="kobo.223.1">= createRouter(</span><strong class="bold"><span class="koboSpan" id="kobo.224.1">{</span></strong><span class="koboSpan" id="kobo.225.1">                                            </span><strong class="bold"><span class="koboSpan" id="kobo.226.1">//4</span></strong><span class="koboSpan" id="kobo.227.1">
    history: createWebHashHistory(),                               </span><strong class="bold"><span class="koboSpan" id="kobo.228.1">//5</span></strong><span class="koboSpan" id="kobo.229.1">
    routes,
    scrollBehavior(to, from, savedPosition){return{top:0}}
</span><strong class="bold"><span class="koboSpan" id="kobo.230.1">}</span></strong><span class="koboSpan" id="kobo.231.1">)
export default router;</span></pre>
<p><span class="koboSpan" id="kobo.232.1">We start our file by importing two constructors from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">vue-router</span></strong><span class="koboSpan" id="kobo.234.1"> package, in </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">line </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">//1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">createRouter</span></strong><span class="koboSpan" id="kobo.239.1">, which will create a router object that we can inject into our application as </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">a plugin</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">createWebHashHistory</span></strong><span class="koboSpan" id="kobo.242.1">, which is a constructor that we will pass to our router object and indicates how it will manage the URL rewriting in </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">the browser</span></span></li>
</ul>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">Web hash history</span></strong><span class="koboSpan" id="kobo.245.1"> will display </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">#</span></strong><span class="koboSpan" id="kobo.247.1"> (a numeral sign) in the URL and will indicate that all navigation points to a single file. </span><span class="koboSpan" id="kobo.247.2">All navigation and URL parameters will follow this sign. </span><span class="koboSpan" id="kobo.247.3">It is the easiest method and does not require any special configuration. </span><span class="koboSpan" id="kobo.247.4">However, the other available methods </span><a id="_idIndexMarker400"/><span class="koboSpan" id="kobo.248.1">are </span><strong class="bold"><span class="koboSpan" id="kobo.249.1">Web history</span></strong><span class="koboSpan" id="kobo.250.1"> (also known as </span><em class="italic"><span class="koboSpan" id="kobo.251.1">HTML5 mode</span></em><span class="koboSpan" id="kobo.252.1"> or </span><em class="italic"><span class="koboSpan" id="kobo.253.1">pretty URLs</span></em><span class="koboSpan" id="kobo.254.1">) and </span><strong class="bold"><span class="koboSpan" id="kobo.255.1">Memory</span></strong><span class="koboSpan" id="kobo.256.1">. </span><span class="koboSpan" id="kobo.256.2">Web</span><a id="_idIndexMarker401"/><span class="koboSpan" id="kobo.257.1"> history does not use the hash notation, but does require a special server configuration. </span><span class="koboSpan" id="kobo.257.2">We will see how to accomplish this with examples in </span><a href="B18602_10.xhtml#_idTextAnchor224"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.258.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.259.1">, </span><em class="italic"><span class="koboSpan" id="kobo.260.1">Deploying Your Application</span></em><span class="koboSpan" id="kobo.261.1">. </span><span class="koboSpan" id="kobo.261.2">Memory mode does not modify the URL and is mostly used for web views (as in hybrid frameworks such as NW.js, Electron, Tauri, Cordova, Capacitor, and so on) and </span><strong class="bold"><span class="koboSpan" id="kobo.262.1">server-side rendering</span></strong><span class="koboSpan" id="kobo.263.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.264.1">SSR</span></strong><span class="koboSpan" id="kobo.265.1">). </span><span class="koboSpan" id="kobo.265.2">For</span><a id="_idIndexMarker402"/><span class="koboSpan" id="kobo.266.1"> now, we will stay with the </span><strong class="bold"><span class="koboSpan" id="kobo.267.1">Web hash </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.268.1">history</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.269.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.270.1">In line </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">//2</span></strong><span class="koboSpan" id="kobo.272.1">, we</span><a id="_idIndexMarker403"/><span class="koboSpan" id="kobo.273.1"> import a component using the static notation, and </span><a id="_idIndexMarker404"/><span class="koboSpan" id="kobo.274.1">we define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">routes</span></strong><span class="koboSpan" id="kobo.276.1"> array with our routes. </span><span class="koboSpan" id="kobo.276.2">Each route is represented by an object with at least the </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">following fields:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">path</span></strong><span class="koboSpan" id="kobo.279.1">: A string that represents the URL associated with </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">the component</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">name</span></strong><span class="koboSpan" id="kobo.282.1">: A string that behaves like a unique ID for the route and that we can </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">call programmatically</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">component</span></strong><span class="koboSpan" id="kobo.285.1">: The component </span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">to render</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.287.1">Notice how in line </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">//2</span></strong><span class="koboSpan" id="kobo.289.1"> we import a static component, but in line </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">//3</span></strong><span class="koboSpan" id="kobo.291.1">, we use the dynamic import notation. </span><span class="koboSpan" id="kobo.291.2">This implies that the first route (named </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">"landing"</span></strong><span class="koboSpan" id="kobo.293.1">) will be included in the main bundle, but the second route ( in line </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">//3</span></strong><span class="koboSpan" id="kobo.295.1">, named </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">"project"</span></strong><span class="koboSpan" id="kobo.297.1">) will only be loaded the first time it is needed, from a separate bundle. </span><span class="koboSpan" id="kobo.297.2">Using routes, we can create a strategy for improving our application loading and </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">bundle size.</span></span></p>
<p><span class="koboSpan" id="kobo.299.1">Finally, in line </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">//4</span></strong><span class="koboSpan" id="kobo.301.1">, we create our </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">router</span></strong><span class="koboSpan" id="kobo.303.1"> object using the constructor and passing an options object. </span><span class="koboSpan" id="kobo.303.2">Notice in line </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">//5</span></strong><span class="koboSpan" id="kobo.305.1"> how we pass the </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">history</span></strong><span class="koboSpan" id="kobo.307.1"> field a constructor for our chosen </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">history</span></strong><span class="koboSpan" id="kobo.309.1"> method. </span><span class="koboSpan" id="kobo.309.2">We also pass our routes (obviously), and also as an example here, we create one of the possible </span><em class="italic"><span class="koboSpan" id="kobo.310.1">navigation guards</span></em><span class="koboSpan" id="kobo.311.1">, to make sure that after navigating to each route, the window scrolls all the way to the top. </span><span class="koboSpan" id="kobo.311.2">Without this, we may encounter a strange side effect, with the scroll not changing between “</span><em class="italic"><span class="koboSpan" id="kobo.312.1">pages</span></em><span class="koboSpan" id="kobo.313.1">." </span><span class="koboSpan" id="kobo.313.2">Navigation guards are triggered before and after a navigation event. </span><span class="koboSpan" id="kobo.313.3">They can be used in a multitude of situations, such as authentication control or data preloading. </span><span class="koboSpan" id="kobo.313.4">Please refer to the official documentation for a complete list of guards, with </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">examples (</span></span><a href="https://router.vuejs.org/guide/advanced/navigation-guards.html"><span class="No-Break"><span class="koboSpan" id="kobo.315.1">https://router.vuejs.org/guide/advanced/navigation-guards.html</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.316.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.317.1">In our </span><a id="_idIndexMarker405"/><span class="koboSpan" id="kobo.318.1">second route, we have also included a variant in</span><a id="_idIndexMarker406"/><span class="koboSpan" id="kobo.319.1"> the notation of the path, with the inclusion of a named parameter prefixed by a semicolon (</span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">:id</span></strong><span class="koboSpan" id="kobo.321.1">). </span><span class="koboSpan" id="kobo.321.2">This route will match anything following </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">/project/</span></strong><span class="koboSpan" id="kobo.323.1"> and assign it to a reactive variable, which we can access programmatically (we will see how this works later). </span><span class="koboSpan" id="kobo.323.2">The route also has an additional field, </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">props: true</span></strong><span class="koboSpan" id="kobo.325.1">. </span><span class="koboSpan" id="kobo.325.2">This indicates that the parameter named in the path will be automatically passed as a prop to the component if the component has defined a prop with the same name. </span><span class="koboSpan" id="kobo.325.3">This will become useful and apparent in the </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">next sections.</span></span></p>
<p><span class="koboSpan" id="kobo.327.1">With our routes and router defined, it is time to import them into our </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">main.js</span></strong><span class="koboSpan" id="kobo.329.1"> file and attach them to our application. </span><span class="koboSpan" id="kobo.329.2">The file will look now </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">like this:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.331.1">/src/main.js</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.332.1">
import { createApp } from 'vue'
import router from “./router”
import App from './App.vue'
import Modals from "./plugins/modals"
import styles from "./assets/styles.css"
createApp(App)</span><strong class="bold"><span class="koboSpan" id="kobo.333.1">.use(router)</span></strong><span class="koboSpan" id="kobo.334.1">.use(Modals).mount('#app')</span></pre>
<p><span class="koboSpan" id="kobo.335.1">Easy enough—it is now time to create components that are currently missing and adapt the ones we have. </span><span class="koboSpan" id="kobo.335.2">Before dealing with the code, let’s see which new components the router provides our </span><span class="No-Break"><span class="koboSpan" id="kobo.336.1">application with.</span></span></p>
<h2 id="_idParaDest-112"><a id="_idTextAnchor138"/><span class="koboSpan" id="kobo.337.1">Router template components</span></h2>
<p><span class="koboSpan" id="kobo.338.1">When we </span><a id="_idIndexMarker407"/><span class="koboSpan" id="kobo.339.1">include the router in the application, it injects into the global scope the following </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">new components:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">RouterView</span></strong><span class="koboSpan" id="kobo.342.1">: This</span><a id="_idIndexMarker408"/><span class="koboSpan" id="kobo.343.1"> component provides the placeholder where the route components will </span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">be rendered.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">RouterLink</span></strong><span class="koboSpan" id="kobo.346.1">: Provides </span><a id="_idIndexMarker409"/><span class="koboSpan" id="kobo.347.1">an easy way to link to routes; through the use of handy props and styles, we can control the appearance and final </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">render element.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.349.1">Together with the router and routes definition, these two components in our template make it possible to offer navigation and better organize our code. </span><span class="koboSpan" id="kobo.349.2">Before we dig into their details, let’s see them in action in our application. </span><span class="koboSpan" id="kobo.349.3">Let’s start modifying our </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">App.vue</span></strong><span class="koboSpan" id="kobo.351.1"> component </span><a id="_idIndexMarker410"/><span class="koboSpan" id="kobo.352.1">to turn it into a layout container (</span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">styles omitted):</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.354.1">App.vue</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.355.1">
&lt;script setup&gt;
    import Sidebar from './components/Sidebar/Sidebar.vue';
&lt;/script&gt;
&lt;template&gt;
&lt;div class="app"&gt;
   &lt;Sidebar&gt;&lt;/Sidebar&gt;
   &lt;main&gt;
      &lt;router-view&gt;&lt;/router-view&gt;
   &lt;/main&gt;
&lt;/div&gt;
&lt;/template&gt;</span></pre>
<p><span class="koboSpan" id="kobo.356.1">As you can see, we include a new component, </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">Sidebar</span></strong><span class="koboSpan" id="kobo.358.1">, which will contain the main navigation for our application. </span><span class="koboSpan" id="kobo.358.2">Then, we just place a single </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">&lt;router-view&gt; </span></strong><span class="koboSpan" id="kobo.360.1">component, where our router will render each page. </span><span class="koboSpan" id="kobo.360.2">When it comes to the styles, I will refer to the code in GitHub for the details. </span><span class="koboSpan" id="kobo.360.3">Now, it is time to create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">Sidebar</span></strong><span class="koboSpan" id="kobo.362.1"> component in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">/src/components/Sidebar/Sidebar.vue</span></strong><span class="koboSpan" id="kobo.364.1"> path and copy the code from the repository. </span><span class="koboSpan" id="kobo.364.2">There is a lot to see in this small file. </span><span class="koboSpan" id="kobo.364.3">Let’s start looking into the template and how we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">RouterLink</span></strong><span class="koboSpan" id="kobo.366.1"> instances. </span><span class="koboSpan" id="kobo.366.2">The first one is static and points to the landing page. </span><span class="koboSpan" id="kobo.366.3">Instead of just using a link or an anchor tag, we define the target of the link as an object where we reference the name of the </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">route directly:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.368.1">
&lt;RouterLink </span><strong class="bold"><span class="koboSpan" id="kobo.369.1">:to="{name:'landing'}"</span></strong><span class="koboSpan" id="kobo.370.1"> class="w3-padding" active-class="w3-yellow"&gt;Home&lt;/RouterLink&gt;</span></pre>
<p><span class="koboSpan" id="kobo.371.1">When this component is rendered, by default, it will become an anchor tag, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">href</span></strong><span class="koboSpan" id="kobo.373.1"> attribute will be dynamically converted to the appropriate route. </span><span class="koboSpan" id="kobo.373.2">If we change our route’s definition and give it another path, it won’t affect this code. </span><span class="koboSpan" id="kobo.373.3">It is a good practice to</span><a id="_idIndexMarker411"/><span class="koboSpan" id="kobo.374.1"> reference routes by their names, instead of by their URL. </span><span class="koboSpan" id="kobo.374.2">In the case that we need to pass some query string parameters to the URL, we can easily do it by passing an object with key/value members as a </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">params </span></strong><span class="koboSpan" id="kobo.376.1">attribute. </span><span class="koboSpan" id="kobo.376.2">Here is </span><span class="No-Break"><span class="koboSpan" id="kobo.377.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.378.1">
&lt;RouterLink :to="{name:'search',</span><strong class="bold"><span class="koboSpan" id="kobo.379.1">params:{text:'abc' }</span></strong><span class="koboSpan" id="kobo.380.1">}" &gt;Search&lt;/RouterLink&gt;</span></pre>
<p><span class="koboSpan" id="kobo.381.1">The preceding </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">params</span></strong><span class="koboSpan" id="kobo.383.1"> attribute will be rendered as a URI with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">?text=abc</span></strong><span class="koboSpan" id="kobo.385.1"> query string. </span><span class="koboSpan" id="kobo.385.2">As we mentioned, if the route has the </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">props</span></strong><span class="koboSpan" id="kobo.387.1"> attribute active and the receiving component has defined a prop of the same name, the value will be automatically assigned. </span><span class="koboSpan" id="kobo.387.2">This is a situation that allows us to generate a list of links and pass to our project page the ID of each project, as you can see next in </span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">the file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.389.1">
&lt;div v-for="p in _projects" :key="p.id"&gt;
    &lt;RouterLink </span><strong class="bold"><span class="koboSpan" id="kobo.390.1">:to="{name:'project',params:{id:p.id}}"</span></strong><span class="koboSpan" id="kobo.391.1">&gt;
        {{p.name}}
    &lt;/RouterLink&gt;
&lt;/div&gt;</span></pre>
<p><span class="koboSpan" id="kobo.392.1">When we create a project on the landing page, we automatically assign a unique ID to each one, which we use in the previous code. </span><span class="koboSpan" id="kobo.392.2">Just as with other props, we can watch the changes and react by loading the respective To-Do items for each project. </span><span class="koboSpan" id="kobo.392.3">With that in mind, we modified the </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">ToDoProject.vue</span></strong><span class="koboSpan" id="kobo.394.1"> file to define the prop (no need to define </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">the type):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.396.1">
$props=defineProps(["id"])</span></pre>
<p><span class="koboSpan" id="kobo.397.1">And then, we also set a watcher to detect changes with these lines in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">script </span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">section:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.400.1">
import { </span><strong class="bold"><span class="koboSpan" id="kobo.401.1">watch </span></strong><span class="koboSpan" id="kobo.402.1">} from "vue"
watch(</span><strong class="bold"><span class="koboSpan" id="kobo.403.1">()=&gt;$props.id</span></strong><span class="koboSpan" id="kobo.404.1">, loadProject)</span></pre>
<p><span class="koboSpan" id="kobo.405.1">This watch receives a function that returns the </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">prop</span></strong><span class="koboSpan" id="kobo.407.1"> attribute and then runs the </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">loadProject()</span></strong><span class="koboSpan" id="kobo.409.1"> function. </span><span class="koboSpan" id="kobo.409.2">At this point, you may ask why we need to do this since each URL is different. </span><span class="koboSpan" id="kobo.409.3">The answer is that Vue and the router only load a component the first time it’s needed. </span><span class="koboSpan" id="kobo.409.4">As long as it remains in view, it doesn’t reload it and only updates reactive properties. </span><span class="koboSpan" id="kobo.409.5">Since our </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">script setup</span></strong><span class="koboSpan" id="kobo.411.1"> code only runs during the first load, at the moment of creation, we need a way to detect changes to run non-reactive operations, such as loading the To-Do items for the project </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">localStorage</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.414.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.415.1">You can </span><a id="_idIndexMarker412"/><span class="koboSpan" id="kobo.416.1">follow the rest of the changes in the repository. </span><span class="koboSpan" id="kobo.416.2">There is very little that changes in the components that work with the To-Do list, and that is the point of the encapsulation. </span><span class="koboSpan" id="kobo.416.3">Even the modification of </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">ToDoProject.vue</span></strong><span class="koboSpan" id="kobo.418.1"> is small. </span><span class="koboSpan" id="kobo.418.2">However, there is one design decision that we need to point out: the use of the </span><em class="italic"><span class="koboSpan" id="kobo.419.1">pub/sub model</span></em><span class="koboSpan" id="kobo.420.1"> to keep the sidebar </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">menu synchronized.</span></span></p>
<p><span class="koboSpan" id="kobo.422.1">We have created a singleton with an event bus (</span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">eventBus</span></strong><span class="koboSpan" id="kobo.424.1">). </span><span class="koboSpan" id="kobo.424.2">When we create a new project or delete it, we trigger an update event with </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">this line:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.426.1">
eventBus.emit("</span><strong class="bold"><span class="koboSpan" id="kobo.427.1">#UpdateProjects</span></strong><span class="koboSpan" id="kobo.428.1">")</span></pre>
<p><span class="koboSpan" id="kobo.429.1">We register the listening events in those components that need it during the </span><em class="italic"><span class="koboSpan" id="kobo.430.1">mounting </span></em><span class="koboSpan" id="kobo.431.1">lifecycle event of the component, and we de-register it before is </span><em class="italic"><span class="koboSpan" id="kobo.432.1">unmounted</span></em><span class="koboSpan" id="kobo.433.1">. </span><span class="koboSpan" id="kobo.433.2">In our case, we only need this in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">Sidebar</span></strong><span class="koboSpan" id="kobo.435.1"> component, but we could have it anywhere in our application </span><span class="No-Break"><span class="koboSpan" id="kobo.436.1">as needed:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.437.1">
onMounted(()=&gt;{
    eventBus.on("</span><strong class="bold"><span class="koboSpan" id="kobo.438.1">#UpdateProjects"</span></strong><span class="koboSpan" id="kobo.439.1">, updateProjects)
})
onBeforeUnmount(()=&gt;{
    eventBus.off("</span><strong class="bold"><span class="koboSpan" id="kobo.440.1">#UpdateProjects</span></strong><span class="koboSpan" id="kobo.441.1">", updateProjects)
})</span></pre>
<p><span class="koboSpan" id="kobo.442.1">The name of the event is trivial and does not follow any convention. </span><span class="koboSpan" id="kobo.442.2">In this book, we prefix it with a numeral sign, as a </span><span class="No-Break"><span class="koboSpan" id="kobo.443.1">personal preference.</span></span></p>
<p><span class="koboSpan" id="kobo.444.1">In previous implementations, as well as in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">ToDoProject.vue</span></strong><span class="koboSpan" id="kobo.446.1"> component, we use the parent as the conduit to share information between sibling components, as we discussed previously. </span><span class="koboSpan" id="kobo.446.2">Here, we use another model, the </span><em class="italic"><span class="koboSpan" id="kobo.447.1">pub/sub pattern</span></em><span class="koboSpan" id="kobo.448.1">, to avoid polluting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">App.vue</span></strong><span class="koboSpan" id="kobo.450.1"> component with such a task. </span><span class="koboSpan" id="kobo.450.2">In </span><a href="B18602_07.xhtml#_idTextAnchor173"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.451.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.452.1">, </span><em class="italic"><span class="koboSpan" id="kobo.453.1">Data Flow Management</span></em><span class="koboSpan" id="kobo.454.1">, we will see other approaches for central state management. </span><span class="koboSpan" id="kobo.454.2">Let’s now take a closer look into more examples and details of using the router with more </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">advanced scenarios.</span></span></p>
<h2 id="_idParaDest-113"><a id="_idTextAnchor139"/><span class="koboSpan" id="kobo.456.1">Nested routes, named views, and programmatic navigation</span></h2>
<p><span class="koboSpan" id="kobo.457.1">This far, we</span><a id="_idIndexMarker413"/><span class="koboSpan" id="kobo.458.1"> have created static and dynamic routes, even with some parameters in the address. </span><span class="koboSpan" id="kobo.458.2">But the router can do even more than that. </span><span class="koboSpan" id="kobo.458.3">By using named routes, we </span><a id="_idIndexMarker414"/><span class="koboSpan" id="kobo.459.1">can also create “sub-routes” and named “sub-views” to create deeper navigation trees and </span><span class="No-Break"><span class="koboSpan" id="kobo.460.1">complex layouts.</span></span></p>
<p><span class="koboSpan" id="kobo.461.1">Let’s start with an example. </span><span class="koboSpan" id="kobo.461.2">Suppose we</span><a id="_idIndexMarker415"/><span class="koboSpan" id="kobo.462.1"> have a data structure on three levels, and we want to reactively present this to the user in such a way that they can choose one level, and then “drill down” to the details. </span><span class="koboSpan" id="kobo.462.2">We also want to have this reflected in the URL, in such a way that we can share or reference the full case. </span><span class="koboSpan" id="kobo.462.3">The levels, in this case, would be country, state, and city. </span><span class="koboSpan" id="kobo.462.4">The UI would then look something </span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer033">
<span class="koboSpan" id="kobo.464.1"><img alt="Figure 5.3 – A selection using multiple named views and sub-routes" src="image/Figure_5.03_B18602.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.465.1">Figure 5.3 – A selection using multiple named views and sub-routes</span></p>
<p><span class="koboSpan" id="kobo.466.1">As you can already guess from the screenshot, when the user selects the country, the state list is populated, and the URL is updated. </span><span class="koboSpan" id="kobo.466.2">When selecting a state, the city list is updated... </span><span class="koboSpan" id="kobo.466.3">and finally, when selecting the city, the information appears in the last column. </span><span class="koboSpan" id="kobo.466.4">You may have seen this method of navigation before. </span><span class="koboSpan" id="kobo.466.5">There are multiple ways to implement this, some more efficient than others. </span><span class="koboSpan" id="kobo.466.6">Our intent is to implement this as a learning exercise, so let’s start with the routes’ definition. </span><span class="koboSpan" id="kobo.466.7">Here is a segment of our routes’ </span><span class="No-Break"><span class="koboSpan" id="kobo.467.1">definition array:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.468.1">
{
path: "/directory", name: "directory",
component: () =&gt; import("../views/Directory.vue"),
children:[
{ path:"</span><strong class="bold"><span class="koboSpan" id="kobo.469.1">:country</span></strong><span class="koboSpan" id="kobo.470.1">", name: "states", props: true,
  component: ()=&gt;import("../views/State.vue"),
  </span><strong class="bold"><span class="koboSpan" id="kobo.471.1">children:[</span></strong><span class="koboSpan" id="kobo.472.1">
       { path:"</span><strong class="bold"><span class="koboSpan" id="kobo.473.1">:state</span></strong><span class="koboSpan" id="kobo.474.1">", name: "cities", props: true,
         component: ()=&gt;import("../views/City.vue")
       } </span><strong class="bold"><span class="koboSpan" id="kobo.475.1"> ]</span></strong><span class="koboSpan" id="kobo.476.1">
} </span><strong class="bold"><span class="koboSpan" id="kobo.477.1">]</span></strong><span class="koboSpan" id="kobo.478.1"> }</span></pre>
<h3><span class="koboSpan" id="kobo.479.1">Nested routes’ definition</span></h3>
<p><span class="koboSpan" id="kobo.480.1">At first </span><a id="_idIndexMarker416"/><span class="koboSpan" id="kobo.481.1">sight, you will notice that not much has changed, save for the inclusion of a new attribute on the route: </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">children[]</span></strong><span class="koboSpan" id="kobo.483.1">. </span><span class="koboSpan" id="kobo.483.2">This attribute receives an array of routes, which in turn can have other children, as we see in the previous code snippet. </span><span class="koboSpan" id="kobo.483.3">Children routes will be rendered in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">RouteView</span></strong><span class="koboSpan" id="kobo.485.1"> component of their parents, and their paths will be concatenated with their parents as well, unless they start with the root (with </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">a backslash).</span></span></p>
<p><span class="koboSpan" id="kobo.487.1">To navigate to each route, we could use any of the methods recognized by the router. </span><span class="koboSpan" id="kobo.487.2">However, it is a good practice to use their names and pass any parameter or query string through an object, and let the router resolve the URL. </span><span class="koboSpan" id="kobo.487.3">As an example, see how in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">Directory.vue</span></strong><span class="koboSpan" id="kobo.489.1"> component we use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.490.1">RouterLink</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.491.1"> element:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.492.1">/src/views/Directory.vue component, lines 13-18</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.493.1">
&lt;div v-for="c in countries" :key="c.code"&gt;
&lt;RouterLink
      :to="</span><strong class="bold"><span class="koboSpan" id="kobo.494.1">{name:'states', params:{country:c.code}}</span></strong><span class="koboSpan" id="kobo.495.1">"
      active-class="selected"&gt;
     {{c.name}}
&lt;/RouterLink&gt;
&lt;/div&gt;</span></pre>
<p><span class="koboSpan" id="kobo.496.1">We have included our </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">RouterLink</span></strong><span class="koboSpan" id="kobo.498.1"> component inside of a loop, to create as many links as needed based on our data. </span><span class="koboSpan" id="kobo.498.2">The target of the link is set to an object, where we pass the name of the route (</span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">states</span></strong><span class="koboSpan" id="kobo.500.1">), and pass parameters respecting the route and props definition for the component. </span><span class="koboSpan" id="kobo.500.2">Notice that the path of the component has been defined as a parameter (it starts with a colon character—</span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">:country</span></strong><span class="koboSpan" id="kobo.502.1">) and it also matches the props definition of the object in </span><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">State.vue</span></strong><span class="koboSpan" id="kobo.504.1">. </span><span class="koboSpan" id="kobo.504.2">This correlation is what enables the router to automatically pass the data </span><span class="No-Break"><span class="koboSpan" id="kobo.505.1">for us.</span></span></p>
<p><span class="koboSpan" id="kobo.506.1">As you </span><a id="_idIndexMarker417"/><span class="koboSpan" id="kobo.507.1">inspect the code, you will notice that in our smallest child component, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">City.vue</span></strong><span class="koboSpan" id="kobo.509.1"> file, we define in our props both country and state. </span><span class="koboSpan" id="kobo.509.2">However, in the route definition, only one parameter appears: the state (</span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">:state</span></strong><span class="koboSpan" id="kobo.511.1">). </span><span class="koboSpan" id="kobo.511.2">Nevertheless, when you run the example, you will notice that the prop is also populated. </span><span class="koboSpan" id="kobo.511.3">This happens because children components inherit, together with the URL path, all the parameters defined in the route of the parents. </span><span class="koboSpan" id="kobo.511.4">In this case, our component then also receives the </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">:country</span></strong><span class="koboSpan" id="kobo.513.1"> parameter that was passed to the parent, even if it doesn’t show up in its </span><span class="No-Break"><span class="koboSpan" id="kobo.514.1">specific route.</span></span></p>
<p><span class="koboSpan" id="kobo.515.1">When you run the application, you will see something similar to </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">this screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer034">
<span class="koboSpan" id="kobo.517.1"><img alt="Figure 5.4 – Nested routes example, with selections" src="image/Figure_5.04_B18602.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.518.1">Figure 5.4 – Nested routes example, with selections</span></p>
<p><span class="koboSpan" id="kobo.519.1">Only two countries have been included from static files, for simplicity. </span><span class="koboSpan" id="kobo.519.2">In a real-life project, this data would be retrieved from </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">a database.</span></span></p>
<p><span class="koboSpan" id="kobo.521.1">We have </span><a id="_idIndexMarker418"/><span class="koboSpan" id="kobo.522.1">used until now “default” </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">RouteView</span></strong><span class="koboSpan" id="kobo.524.1"> components, but the Vue router allows us to include multiple views in one component, by assigning them different names. </span><span class="koboSpan" id="kobo.524.2">We will only see the notation here, as the implementation is trivial. </span><span class="koboSpan" id="kobo.524.3">Consider a component with the </span><span class="No-Break"><span class="koboSpan" id="kobo.525.1">following template:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.526.1">
&lt;div&gt;
    &lt;RouterView </span><strong class="bold"><span class="koboSpan" id="kobo.527.1">name="header"</span></strong><span class="koboSpan" id="kobo.528.1">&gt;&lt;/RouterView&gt;
    &lt;RouterView </span><strong class="bold"><span class="koboSpan" id="kobo.529.1">name="sidebar"</span></strong><span class="koboSpan" id="kobo.530.1">&gt;&lt;/RouterView&gt;
    &lt;RouterView&gt;&lt;/RouterView&gt;
&lt;/div&gt;</span></pre>
<p><span class="koboSpan" id="kobo.531.1">In the preceding code, we give our routes an identification with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">name</span></strong><span class="koboSpan" id="kobo.533.1"> attribute. </span><span class="koboSpan" id="kobo.533.2">We also have a view without a name, in which case it is considered the “default” view, or with the name </span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">default</span></strong><span class="koboSpan" id="kobo.535.1"> as well. </span><span class="koboSpan" id="kobo.535.2">To make use of this new layout, the routes’ definition changes slightly. </span><span class="koboSpan" id="kobo.535.3">In each definition now, we do not have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">component</span></strong><span class="koboSpan" id="kobo.537.1"> attribute, but instead, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.538.1">components</span></strong><span class="koboSpan" id="kobo.539.1"> (in plural) attribute that expects an object. </span><span class="koboSpan" id="kobo.539.2">Each field’s name in the object must match the names given to our </span><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">RouterView</span></strong><span class="koboSpan" id="kobo.541.1"> components and be equal to an object. </span><span class="koboSpan" id="kobo.541.2">For the previous piece of code, the equivalent route definition would be something </span><span class="No-Break"><span class="koboSpan" id="kobo.542.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.543.1">
{ path:"/layout", name: "main",
  components:</span><strong class="bold"><span class="koboSpan" id="kobo.544.1">{</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.545.1">      default: ()=&gt;import('...'),</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.546.1">      header: ()=&gt;import('...'),</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.547.1">      sidebar: ()=&gt;import('...')</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.548.1">}</span></strong><span class="koboSpan" id="kobo.549.1">}</span></pre>
<p><span class="koboSpan" id="kobo.550.1">Using this</span><a id="_idIndexMarker419"/><span class="koboSpan" id="kobo.551.1"> type of definition, we can create complex layouts, as we can also define sub-routes to make use of—for example—the header and sidebar from the parent and only render in the default view. </span><span class="koboSpan" id="kobo.551.2">We have an impressive number of possibilities for building </span><span class="No-Break"><span class="koboSpan" id="kobo.552.1">dynamic UIs.</span></span></p>
<p><span class="koboSpan" id="kobo.553.1">One important topic that we must cover before moving to the next section is that of programmatic navigation. </span><span class="koboSpan" id="kobo.553.2">We have used thus far the new components provided by the router, but we can also trigger navigation directly from our JavaScript without having to rely on the user triggering an event. </span><span class="koboSpan" id="kobo.553.3">For this, the Vue Router provides us with two handy constructors to use in our components’ scripts: </span><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">useRoute</span></strong><span class="koboSpan" id="kobo.555.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">useRouter</span></strong><span class="koboSpan" id="kobo.557.1">. </span><span class="koboSpan" id="kobo.557.2">We import these constructors into our components with the </span><span class="No-Break"><span class="koboSpan" id="kobo.558.1">following line:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.559.1">
import {useRoute, useRouter} from "vue-router"
const     $route=useRoute(),
          $router=useRouter()</span></pre>
<p><span class="koboSpan" id="kobo.560.1">As you can imagine, </span><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">$route</span></strong><span class="koboSpan" id="kobo.562.1"> provides us with information about the current route, while </span><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">$router</span></strong><span class="koboSpan" id="kobo.564.1"> allows us to modify and trigger </span><span class="No-Break"><span class="koboSpan" id="kobo.565.1">navigation events.</span></span></p>
<p><span class="koboSpan" id="kobo.566.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">$router</span></strong><span class="koboSpan" id="kobo.568.1"> object provides several methods, of which the most often used are summarized in </span><span class="No-Break"><span class="koboSpan" id="kobo.569.1">this table:</span></span></p>
<table class="No-Table-Style" id="table002">
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.570.1">Method</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.571.1">Description</span></strong></span></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.572.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">push()</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.574.1">The most important method. </span><span class="koboSpan" id="kobo.574.2">It pushes a new URL into the web history and navigates to the corresponding component. </span><span class="koboSpan" id="kobo.574.3">It is the programmatic equivalent of using </span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">RouterLink</span></strong><span class="koboSpan" id="kobo.576.1">. </span><span class="koboSpan" id="kobo.576.2">It accepts either a string with the URL to navigate or an object with optional attributes. </span><span class="koboSpan" id="kobo.576.3">Here are some examples for each </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">accepted parameter:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.578.1">
// Navigate to an URL
$router.push(</span><strong class="bold"><span class="koboSpan" id="kobo.579.1">"/my/route"</span></strong><span class="koboSpan" id="kobo.580.1">)
// Navigate to a URL, using an object
$router.push(</span><strong class="bold"><span class="koboSpan" id="kobo.581.1">{path: "/my/route"}</span></strong><span class="koboSpan" id="kobo.582.1">)
// Navigate to a route, with parameters
$router.push({
   </span><strong class="bold"><span class="koboSpan" id="kobo.583.1">name:"route-name",</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.584.1">   params:{key:value}</span></strong><span class="koboSpan" id="kobo.585.1">
})
// Navigate to a route, with query strings
$router.push({
   </span><strong class="bold"><span class="koboSpan" id="kobo.586.1">name:"route-name",</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.587.1">   query:{key:value}</span></strong><span class="koboSpan" id="kobo.588.1">
})</span></pre>
<p><span class="koboSpan" id="kobo.589.1">Of course, you can create complex routes by passing parameters and query strings. </span><span class="koboSpan" id="kobo.589.2">What is important to remember is that </span><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">.push </span></strong><span class="koboSpan" id="kobo.591.1">will update the navigation history in </span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">the browser.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.593.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">replace()</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.595.1">Replace the current navigation component, without modifying </span><span class="No-Break"><span class="koboSpan" id="kobo.596.1">the URL.</span></span><span class="koboSpan" id="kobo.597.1">
It accepts the same parameters </span><span class="No-Break"><span class="koboSpan" id="kobo.598.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">.push</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.600.1">.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">go()</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.603.1">This method receives an integer number as a parameter and triggers navigation using the browser’s history. </span><span class="koboSpan" id="kobo.603.2">Positive numbers navigate forward and negative numbers go backward in the navigation history. </span><span class="koboSpan" id="kobo.603.3">Its most common use is for implementing a “go back” link in an application. </span><span class="koboSpan" id="kobo.603.4">Here are </span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">some examples:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.605.1">
// Go back one entry
$router.go(-1)
// Go forward one entry
$router.go(1)</span></pre>
</td>
</tr>
</tbody>
</table>
<p><span class="koboSpan" id="kobo.606.1">As mentioned, these are the most commonly used methods and the ones you should have present. </span><span class="koboSpan" id="kobo.606.2">I can say that using these will cover the vast majority of regular necessities. </span><span class="koboSpan" id="kobo.606.3">A </span><a id="_idIndexMarker420"/><span class="koboSpan" id="kobo.607.1">full list of methods available can be found in the official documentation and allow you to manage also edge cases that may arise. </span><span class="koboSpan" id="kobo.607.2">I encourage you to check them out, at least to be aware of them, at </span><a href="https://router.vuejs.org/api/interfaces/Router.html"><span class="koboSpan" id="kobo.608.1">https://router.vuejs.org/api/interfaces/Router.html</span></a><span class="koboSpan" id="kobo.609.1">#properties. </span><span class="koboSpan" id="kobo.609.2">Some of these edge cases could be: add and remove routes dynamically (</span><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">.addRoute()</span></strong><span class="koboSpan" id="kobo.611.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">.removeRoute()</span></strong><span class="koboSpan" id="kobo.613.1">), retrieve the registered routes (</span><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">.getRoutes()</span></strong><span class="koboSpan" id="kobo.615.1">), check whether a route exists before navigating to it (</span><strong class="source-inline"><span class="koboSpan" id="kobo.616.1">.hasRoute()</span></strong><span class="koboSpan" id="kobo.617.1">), and so on. </span><span class="koboSpan" id="kobo.617.2">We will not use them, so it is not relevant to see them in </span><span class="No-Break"><span class="koboSpan" id="kobo.618.1">detail here.</span></span></p>
<p><span class="koboSpan" id="kobo.619.1">In contrast, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">$route</span></strong><span class="koboSpan" id="kobo.621.1"> object gives us information about the current path (URL) where our component is being rendered. </span><span class="koboSpan" id="kobo.621.2">As with the previous example, here is a list of the most commonly used attributes, and </span><span class="No-Break"><span class="koboSpan" id="kobo.622.1">their function:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table003">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.623.1">Attributes</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.624.1">Description</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.626.1">name</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.627.1">Returns the current name of </span><span class="No-Break"><span class="koboSpan" id="kobo.628.1">the route.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">params</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.631.1">Returns an object with the parameters provided with the path (URL). </span><span class="koboSpan" id="kobo.631.2">If these have been matched to props, the values </span><span class="No-Break"><span class="koboSpan" id="kobo.632.1">may overlap.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.633.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">query</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.635.1">Returns an object with the decoded query string attached to the </span><span class="No-Break"><span class="koboSpan" id="kobo.636.1">current path.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.637.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.638.1">hash</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.639.1">If any, it returns the path in the URL following and including the hash </span><span class="No-Break"><span class="koboSpan" id="kobo.640.1">sign (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.641.1">#</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.642.1">).</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.643.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.644.1">fullPath</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.645.1">Returns a string with the full path of </span><span class="No-Break"><span class="koboSpan" id="kobo.646.1">the route.</span></span></p>
</td>
</tr>
</tbody>
</table>
<p><span class="koboSpan" id="kobo.647.1">In the examples</span><a id="_idIndexMarker421"/><span class="koboSpan" id="kobo.648.1"> of this book, we will use </span><strong class="source-inline"><span class="koboSpan" id="kobo.649.1">.name()</span></strong><span class="koboSpan" id="kobo.650.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.651.1">.params()</span></strong><span class="koboSpan" id="kobo.652.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.653.1">.query()</span></strong><span class="koboSpan" id="kobo.654.1"> on more than one occasion, as they tend to be the most commonly used as well. </span><span class="koboSpan" id="kobo.654.2">A full list of methods and properties can be found in the </span><span class="No-Break"><span class="koboSpan" id="kobo.655.1">official documentation.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.656.1">Important notation differences</span></p>
<p class="callout"><span class="koboSpan" id="kobo.657.1">We have been using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">useRoute</span></strong><span class="koboSpan" id="kobo.659.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.660.1">useRouter</span></strong><span class="koboSpan" id="kobo.661.1"> constructors in the Composition API with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.662.1">script setup</span></strong><span class="koboSpan" id="kobo.663.1"> notation. </span><span class="koboSpan" id="kobo.663.2">In the Options API, there is no need to initialize these objects. </span><span class="koboSpan" id="kobo.663.3">Both are available automatically through </span><strong class="source-inline"><span class="koboSpan" id="kobo.664.1">this.$route</span></strong><span class="koboSpan" id="kobo.665.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.666.1">this.$router</span></strong><span class="koboSpan" id="kobo.667.1">. </span><span class="koboSpan" id="kobo.667.2">Also, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.668.1">$route</span></strong><span class="koboSpan" id="kobo.669.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.670.1">$router</span></strong><span class="koboSpan" id="kobo.671.1"> objects are available automatically in the template, when using the </span><span class="No-Break"><span class="koboSpan" id="kobo.672.1">Composition API.</span></span></p>
<p><span class="koboSpan" id="kobo.673.1">A full code example can be found in the GitHub repository, under </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.674.1">Chapter 5</span></strong></span><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">/Nested Routes</span></strong><span class="koboSpan" id="kobo.676.1">, at this </span><span class="No-Break"><span class="koboSpan" id="kobo.677.1">URL: </span></span><a href="https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/chapter05"><span class="No-Break"><span class="koboSpan" id="kobo.678.1">https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/chapter05</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.679.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.680.1">Now that we know how to handle routes, parameters, and query strings, it is time to look into some common patterns for authentication in SPAs, since different paths (URLs) are necessary for many </span><span class="No-Break"><span class="koboSpan" id="kobo.681.1">of them.</span></span></p>
<h1 id="_idParaDest-114"><a id="_idTextAnchor140"/><span class="koboSpan" id="kobo.682.1">Exploring authentication patterns</span></h1>
<p><span class="koboSpan" id="kobo.683.1">The </span><a id="_idIndexMarker422"/><span class="koboSpan" id="kobo.684.1">power of SPAs becomes apparent when there is also a server behind them providing additional services. </span><span class="koboSpan" id="kobo.684.2">One such service is authentication. </span><span class="koboSpan" id="kobo.684.3">In most applications, there will be the need to identify users and provide additional services based on their rights, status, privacy, group, or any other category pertaining to the context of the application. </span><span class="koboSpan" id="kobo.684.4">A clear example of this is webmail applications, such as </span><em class="italic"><span class="koboSpan" id="kobo.685.1">Outlook</span></em> <span class="No-Break"><span class="koboSpan" id="kobo.686.1">or </span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.687.1">Gmail</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.688.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.689.1">Current web standards provide us with several options to perform asynchronous communications with a server. </span><span class="koboSpan" id="kobo.689.2">These are often</span><a id="_idIndexMarker423"/><span class="koboSpan" id="kobo.690.1"> called </span><strong class="bold"><span class="koboSpan" id="kobo.691.1">AJAX</span></strong><span class="koboSpan" id="kobo.692.1"> (</span><em class="italic"><span class="koboSpan" id="kobo.693.1">AJAX stands for Asynchronous JavaScript and XML</span></em><span class="koboSpan" id="kobo.694.1">). </span><span class="koboSpan" id="kobo.694.2">In the most basic form, we could use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">XMLHttpRequest</span></strong><span class="koboSpan" id="kobo.696.1"> object for these network communications, but the new specifications provide us with a direct function, </span><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">fetch()</span></strong><span class="koboSpan" id="kobo.698.1">, which is more convenient and standard between browsers. </span><span class="koboSpan" id="kobo.698.2">While these methods are perfectly valid, for other uses than simple </span><a id="_idIndexMarker424"/><span class="koboSpan" id="kobo.699.1">needs, it is better to use a library that provides more functionalities built on top of these technologies—for example, one that provides an </span><strong class="bold"><span class="koboSpan" id="kobo.700.1">API</span></strong><span class="koboSpan" id="kobo.701.1"> to match </span><strong class="bold"><span class="koboSpan" id="kobo.702.1">HTTP </span></strong><span class="koboSpan" id="kobo.703.1">request</span><a id="_idIndexMarker425"/><span class="koboSpan" id="kobo.704.1"> methods (</span><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">GET</span></strong><span class="koboSpan" id="kobo.706.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.707.1">POST</span></strong><span class="koboSpan" id="kobo.708.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.709.1">PUT</span></strong><span class="koboSpan" id="kobo.710.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.711.1">OPTIONS</span></strong><span class="koboSpan" id="kobo.712.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.713.1">DELETE</span></strong><span class="koboSpan" id="kobo.714.1">) to easily </span><a id="_idIndexMarker426"/><span class="koboSpan" id="kobo.715.1">consume </span><strong class="bold"><span class="koboSpan" id="kobo.716.1">RESTful APIs</span></strong><span class="koboSpan" id="kobo.717.1"> (where </span><strong class="bold"><span class="koboSpan" id="kobo.718.1">REST</span></strong><span class="koboSpan" id="kobo.719.1"> stands for </span><strong class="bold"><span class="koboSpan" id="kobo.720.1">Representational State Transfer</span></strong><span class="koboSpan" id="kobo.721.1">, a type of architecture used in network communications). </span><span class="koboSpan" id="kobo.721.2">We will see more about this in </span><a href="B18602_08.xhtml#_idTextAnchor186"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.722.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.723.1">, </span><em class="italic"><span class="koboSpan" id="kobo.724.1">Multithreading with Web Workers</span></em><span class="koboSpan" id="kobo.725.1">. </span><span class="koboSpan" id="kobo.725.2">For now, just keep in mind that a library to handle network asynchronous communications is a better path. </span><span class="koboSpan" id="kobo.725.3">In our case, we will use the </span><a id="_idIndexMarker427"/><span class="koboSpan" id="kobo.726.1">excellent </span><strong class="bold"><span class="koboSpan" id="kobo.727.1">Axios</span></strong><span class="koboSpan" id="kobo.728.1"> library (</span><a href="https://axios-http.com/"><span class="koboSpan" id="kobo.729.1">https://axios-http.com/</span></a><span class="koboSpan" id="kobo.730.1">), which you can install in your application with the </span><span class="No-Break"><span class="koboSpan" id="kobo.731.1">following command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.732.1">
$ npm install axios</span></pre>
<p><span class="koboSpan" id="kobo.733.1">Then, in your service or component, you can import and use the library with the </span><span class="No-Break"><span class="koboSpan" id="kobo.734.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.735.1">
import axios from “axios”</span></pre>
<p><span class="koboSpan" id="kobo.736.1">The library exposes methods to match each HTTP request (</span><strong class="source-inline"><span class="koboSpan" id="kobo.737.1">.get()</span></strong><span class="koboSpan" id="kobo.738.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.739.1">.post()</span></strong><span class="koboSpan" id="kobo.740.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.741.1">.put()</span></strong><span class="koboSpan" id="kobo.742.1">, and so on), each one returning a promise that resolves to the result of the request or rejects it in the case </span><span class="No-Break"><span class="koboSpan" id="kobo.743.1">of error.</span></span></p>
<p><span class="koboSpan" id="kobo.744.1">With this introduction, we are ready to see some common patterns for authenticating users in </span><span class="No-Break"><span class="koboSpan" id="kobo.745.1">our applications.</span></span></p>
<h2 id="_idParaDest-115"><a id="_idTextAnchor141"/><span class="koboSpan" id="kobo.746.1">Simple username and password authentication</span></h2>
<p><span class="koboSpan" id="kobo.747.1">This</span><a id="_idIndexMarker428"/><span class="koboSpan" id="kobo.748.1"> is the simplest approach to authenticating users, where the validation of credentials is made by our</span><a id="_idIndexMarker429"/><span class="koboSpan" id="kobo.749.1"> implementation on the server. </span><span class="koboSpan" id="kobo.749.2">In this case, our server backend provides the API to validate a set of credentials, gathered by our SPA. </span><span class="koboSpan" id="kobo.749.3">Traditionally, the credentials are stored in the server, on a database, and the communication will be performed on top of </span><strong class="bold"><span class="koboSpan" id="kobo.750.1">Secure Sockets Layer</span></strong><span class="koboSpan" id="kobo.751.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.752.1">SSL</span></strong><span class="koboSpan" id="kobo.753.1">) or </span><a id="_idIndexMarker430"/><span class="koboSpan" id="kobo.754.1">encrypted communication, which are the same thing. </span><span class="koboSpan" id="kobo.754.2">Let’s see the </span><span class="No-Break"><span class="koboSpan" id="kobo.755.1">workflow graphically:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer035">
<span class="koboSpan" id="kobo.756.1"><img alt="Figure 5.5 – Simple username and password authentication" src="image/Figure_5.05_B18602.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.757.1">Figure 5.5 – Simple username and password authentication</span></p>
<p><span class="koboSpan" id="kobo.758.1">In this</span><a id="_idIndexMarker431"/><span class="koboSpan" id="kobo.759.1"> workflow, the </span><span class="No-Break"><span class="koboSpan" id="kobo.760.1">following occurs:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.761.1">The SPA collects username and password values and transmits them to a specific endpoint in our server </span><span class="No-Break"><span class="koboSpan" id="kobo.762.1">for authentication.</span></span></li>
<li><span class="koboSpan" id="kobo.763.1">The server uses information stored in a database to validate the username </span><span class="No-Break"><span class="koboSpan" id="kobo.764.1">and password.</span></span></li>
<li><span class="koboSpan" id="kobo.765.1">The result of the operation is returned to the client SPA in response to their initial </span><span class="No-Break"><span class="koboSpan" id="kobo.766.1">query (</span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.767.1">1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.768.1">).</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.769.1">Even</span><a id="_idIndexMarker432"/><span class="koboSpan" id="kobo.770.1"> though </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.771.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.772.1">.5</span></em><span class="koboSpan" id="kobo.773.1"> shows the number of steps, consider that all this is done in just one network call and its reply. </span><span class="koboSpan" id="kobo.773.2">Developing the validation code on the server is beyond the scope of this book, but the code inside our service or Vue 3 component would look something similar </span><span class="No-Break"><span class="koboSpan" id="kobo.774.1">to this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.775.1">
import axios from "axios"
import {ref} from "vue"
const _username=ref(""), _password=ref("")
function doSignIn(){
axios.post(</span><strong class="bold"><span class="koboSpan" id="kobo.776.1">"https://my_server_API_URL",</span></strong><span class="koboSpan" id="kobo.777.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.778.1">{username:_username.value,password:_password.value})</span></strong><span class="koboSpan" id="kobo.779.1">
  .then(response=&gt;{
     console.log(</span><strong class="bold"><span class="koboSpan" id="kobo.780.1">response.status)</span></strong><span class="koboSpan" id="kobo.781.1">
     console.log(</span><strong class="bold"><span class="koboSpan" id="kobo.782.1">response.data</span></strong><span class="koboSpan" id="kobo.783.1">)
  }).catch(err=&gt;{...})
}</span></pre>
<p><span class="koboSpan" id="kobo.784.1">As you </span><a id="_idIndexMarker433"/><span class="koboSpan" id="kobo.785.1">can see, the implementation is quite straightforward and depends on our own logic and server API design. </span><span class="koboSpan" id="kobo.785.2">What is important to remember is to check the status of the response (everything between </span><strong class="source-inline"><span class="koboSpan" id="kobo.786.1">200</span></strong><span class="koboSpan" id="kobo.787.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.788.1">299</span></strong><span class="koboSpan" id="kobo.789.1"> is a success) and the data sent back by the server to act accordingly. </span><span class="koboSpan" id="kobo.789.2">Axios handles all the communication and data conversion for us (assuming our API receives and process </span><span class="No-Break"><span class="koboSpan" id="kobo.790.1">JSON data).</span></span></p>
<p><span class="koboSpan" id="kobo.791.1">In the case </span><a id="_idIndexMarker434"/><span class="koboSpan" id="kobo.792.1">of success, we should save the result in our application state and allow access to the user accordingly, mostly by unlocking the navigation to private or restricted routes. </span><span class="koboSpan" id="kobo.792.2">We could apply this protection in a fair number of different ways, the most common being the use of navigation guards, the creation of dynamic routes, and </span><span class="No-Break"><span class="koboSpan" id="kobo.793.1">so on.</span></span></p>
<p><span class="koboSpan" id="kobo.794.1">This method is perfectly valid, and commonly implemented by most applications. </span><span class="koboSpan" id="kobo.794.2">However, it has </span><span class="No-Break"><span class="koboSpan" id="kobo.795.1">several drawbacks:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.796.1">We are responsible for maintaining a database with usernames and passwords (encrypted, please!) and implementing the </span><span class="No-Break"><span class="koboSpan" id="kobo.797.1">validation logic</span></span></li>
<li><span class="koboSpan" id="kobo.798.1">We are legally responsible for handling the user data according to </span><span class="No-Break"><span class="koboSpan" id="kobo.799.1">local legislation</span></span></li>
<li><span class="koboSpan" id="kobo.800.1">We are responsible for the entire security of the system, end </span><span class="No-Break"><span class="koboSpan" id="kobo.801.1">to end</span></span></li>
<li><span class="koboSpan" id="kobo.802.1">The user has to remember or be responsible for their </span><span class="No-Break"><span class="koboSpan" id="kobo.803.1">own credentials</span></span></li>
<li><span class="koboSpan" id="kobo.804.1">We should provide ways to handle edge cases, as well as user problems and </span><span class="No-Break"><span class="koboSpan" id="kobo.805.1">credential retrievals</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.806.1">These drawbacks are in no way a deterrent, but huge bullet points to keep in mind if we go this way. </span><span class="koboSpan" id="kobo.806.2">One way or another, most applications need to have a way to authenticate users, which depends on their own logic and implementation since not all of our users (depending on the context) will be willing to use another form of authentication, as we will </span><span class="No-Break"><span class="koboSpan" id="kobo.807.1">see next.</span></span></p>
<h2 id="_idParaDest-116"><a id="_idTextAnchor142"/><span class="koboSpan" id="kobo.808.1">OpenID and third-party authentication</span></h2>
<p><span class="koboSpan" id="kobo.809.1">Beyond</span><a id="_idIndexMarker435"/><span class="koboSpan" id="kobo.810.1"> security concerns, a major issue when dealing with authentication is how easily these credentials are lost or mishandled by the end user. </span><span class="koboSpan" id="kobo.810.2">This happens to us all. </span><span class="koboSpan" id="kobo.810.3">The more services we access online, the larger the number of credentials a user needs to “remember." </span><span class="koboSpan" id="kobo.810.4">There are many different methods to tackle this issue, to reduce the load on the user in keeping track of all these usernames and passwords. </span><span class="koboSpan" id="kobo.810.5">One </span><a id="_idIndexMarker436"/><span class="koboSpan" id="kobo.811.1">such standard is the </span><strong class="bold"><span class="koboSpan" id="kobo.812.1">OpenID</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.813.1">protocol (</span></span><a href="https://openid.net/"><span class="No-Break"><span class="koboSpan" id="kobo.814.1">https://openid.net/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.815.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.816.1">The OpenID protocol authenticates users without the need to share credentials (usernames and passwords) between sites. </span><span class="koboSpan" id="kobo.816.2">It is based on the workflow of the </span><strong class="bold"><span class="koboSpan" id="kobo.817.1">OAuth 2.0</span></strong><span class="koboSpan" id="kobo.818.1"> protocol, which</span><a id="_idIndexMarker437"/><span class="koboSpan" id="kobo.819.1"> is used to securely shared information and resources without the need to use passwords as well. </span><span class="koboSpan" id="kobo.819.2">This is achieved by sharing tokens between the different actors. </span><span class="koboSpan" id="kobo.819.3">The standard for these communications is to use </span><strong class="bold"><span class="koboSpan" id="kobo.820.1">JSON Web Tokens</span></strong><span class="koboSpan" id="kobo.821.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.822.1">JWTs</span></strong><span class="koboSpan" id="kobo.823.1">). </span><span class="koboSpan" id="kobo.823.2">There </span><a id="_idIndexMarker438"/><span class="koboSpan" id="kobo.824.1">is a lot to unravel in this paragraph, so let’s see each one of these terms in a bit more detail so that we can better understand how this </span><span class="No-Break"><span class="koboSpan" id="kobo.825.1">protocol works.</span></span></p>
<p><span class="koboSpan" id="kobo.826.1">A JWT is a string that contains three sections, separated by a dot (</span><strong class="source-inline"><span class="koboSpan" id="kobo.827.1">.</span></strong><span class="koboSpan" id="kobo.828.1">), and that have been encoded in Base64. </span><span class="koboSpan" id="kobo.828.2">Each section then encodes a JSON object with the </span><span class="No-Break"><span class="koboSpan" id="kobo.829.1">following information:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.830.1">Header</span></strong><span class="koboSpan" id="kobo.831.1">: This contains cryptographic information used to encode the token, such as the algorithm, the type of token (usually </span><strong class="source-inline"><span class="koboSpan" id="kobo.832.1">JWT</span></strong><span class="koboSpan" id="kobo.833.1">), and in some cases even the type of data submitted in </span><span class="No-Break"><span class="koboSpan" id="kobo.834.1">the payload.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.835.1">Payload</span></strong><span class="koboSpan" id="kobo.836.1">: This object contains the information we want (need) to share, and is mostly “free format”, meaning that it can contain any </span><strong class="source-inline"><span class="koboSpan" id="kobo.837.1">key:value</span></strong><span class="koboSpan" id="kobo.838.1"> pair as needed. </span><span class="koboSpan" id="kobo.838.2">However, there are a few well-defined fields that can also be used, such as “</span><strong class="source-inline"><span class="koboSpan" id="kobo.839.1">iat</span></strong><span class="koboSpan" id="kobo.840.1">”(</span><strong class="bold"><span class="koboSpan" id="kobo.841.1">Issued At Time</span></strong><span class="koboSpan" id="kobo.842.1">), which shares the timestamp for the creation of the token. </span><span class="koboSpan" id="kobo.842.2">Most importantly, this object must contain a unique ID for the user (“</span><strong class="source-inline"><span class="koboSpan" id="kobo.843.1">sub</span></strong><span class="koboSpan" id="kobo.844.1">”field, </span><span class="No-Break"><span class="koboSpan" id="kobo.845.1">for subject).</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.846.1">Signature</span></strong><span class="koboSpan" id="kobo.847.1">: The signature is a string form by concatenating the encrypted string representations of the header and payload, expressed in Base64. </span><span class="koboSpan" id="kobo.847.2">For the encryption, a secret key (a password) is used, only known to both the authenticating server and the </span><span class="No-Break"><span class="koboSpan" id="kobo.848.1">website server.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.849.1">When a </span><a id="_idIndexMarker439"/><span class="koboSpan" id="kobo.850.1">website in the workflow receives a token, it decodes and validates it using the secret key, using the same method as the issuer. </span><span class="koboSpan" id="kobo.850.2">If the signatures don’t match, then it is assumed that the token is corrupted or compromised, and it is rejected. </span><span class="koboSpan" id="kobo.850.3">A JWT can be intercepted and decoded by a third party, so this method acts as a failsafe against tampering. </span><span class="koboSpan" id="kobo.850.4">Let’s see an example</span><a id="_idIndexMarker440"/><span class="koboSpan" id="kobo.851.1"> of the </span><a id="_idIndexMarker441"/><span class="koboSpan" id="kobo.852.1">creation of </span><span class="No-Break"><span class="koboSpan" id="kobo.853.1">a token:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.854.1">Header</span></strong><span class="koboSpan" id="kobo.855.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.856.1">{"alg": "HS256", "typ": "JWT"}</span></strong><span class="koboSpan" id="kobo.857.1">. </span><span class="koboSpan" id="kobo.857.2">Here, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.858.1">HS256 </span></strong><span class="koboSpan" id="kobo.859.1">algorithm and declare the type used </span><span class="No-Break"><span class="koboSpan" id="kobo.860.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.861.1">JWT</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.862.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.863.1">Payload</span></strong><span class="koboSpan" id="kobo.864.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.865.1">{"sub":"1234567890","name":"Pablo </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.866.1">D. </span><span class="koboSpan" id="kobo.866.2">Garaguso","iat":</span></strong></span><strong class="source-inline">
</strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.867.1">1516239022}</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.868.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.869.1">Secret encryption key</span></strong><span class="koboSpan" id="kobo.870.1">: </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.871.1">secret key</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.872.1">.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.873.1">With the preceding</span><a id="_idIndexMarker442"/><span class="koboSpan" id="kobo.874.1"> information, a signature field is created with this formula (assuming we have a function that encrypts text using the </span><span class="No-Break"><span class="koboSpan" id="kobo.875.1">HS256 algorithm):</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.876.1">HMACSHA256(base64UrlEncode(header) + "." </span><span class="koboSpan" id="kobo.876.2">+ </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.877.1">base64UrlEncode</span></strong></span><strong class="source-inline"><span class="koboSpan" id="kobo.878.1">
(</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.879.1">payload),"secret key")</span></strong></span></p>
<p><span class="koboSpan" id="kobo.880.1">Finally, the resulting strings in Base64 encoding are concatenated again to give us a perfectly functional token. </span><span class="koboSpan" id="kobo.880.2">Also, notice how each section (header, payload, and signature) appears separated by a </span><span class="No-Break"><span class="koboSpan" id="kobo.881.1">period (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.882.1">.</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.883.1">):</span></span></p>
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.884.1">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwi bmFtZSI6IlBhYmxvIEQuIEdhcmFndXNvIiwiaWF0IjoxNTE2MjM5MDIyfQ.mPr551</span></strong></span><strong class="source-inline">
</strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.885.1">xpsCgmIzp8EZuSCoy7t7iQNpp_iGzIR14E_Jo</span></strong></span></p>
<p><span class="koboSpan" id="kobo.886.1">To test this token, you can use a service such as </span><a href="https://jwt-decoder.com/"><span class="koboSpan" id="kobo.887.1">https://jwt-decoder.com/</span></a><span class="koboSpan" id="kobo.888.1">. </span><span class="koboSpan" id="kobo.888.2">To validate it, however, you will need to use the secret key. </span><span class="koboSpan" id="kobo.888.3">You can test</span><a id="_idIndexMarker443"/><span class="koboSpan" id="kobo.889.1"> this at </span><a href="https://jwt.io"><span class="koboSpan" id="kobo.890.1">https://jwt.io</span></a><span class="koboSpan" id="kobo.891.1">, where you can also find more information about </span><span class="No-Break"><span class="koboSpan" id="kobo.892.1">this standard.</span></span></p>
<p><span class="koboSpan" id="kobo.893.1">In the OpenID protocol, JWTs are used to transmit and validate information between parties, hence why is so important to understand this concept well. </span><span class="koboSpan" id="kobo.893.2">There are several workflows recognized by the protocol. </span><span class="koboSpan" id="kobo.893.3">Let’s see here a simplified representation of the </span><strong class="bold"><span class="koboSpan" id="kobo.894.1">authorization code flow</span></strong><span class="koboSpan" id="kobo.895.1"> (</span><a href="https://openid.net/specs/openid-connect-core-1_0.html"><span class="koboSpan" id="kobo.896.1">https://openid.net/specs/openid-connect-core-1_0.html</span></a><span class="koboSpan" id="kobo.897.1">) of the</span><a id="_idIndexMarker444"/><span class="koboSpan" id="kobo.898.1"> protocol with all the actors, and then see the parts we need to implement this in our Vue </span><span class="No-Break"><span class="koboSpan" id="kobo.899.1">3 SPAs:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer036">
<span class="koboSpan" id="kobo.900.1"><img alt="Figure 5.6 – The OpenID authorization code flow in all its beauty" src="image/Figure_5.06_B18602.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.901.1">Figure 5.6 – The OpenID authorization code flow in all its beauty</span></p>
<p><span class="koboSpan" id="kobo.902.1">As you</span><a id="_idIndexMarker445"/><span class="koboSpan" id="kobo.903.1"> can see, for this workflow to</span><a id="_idIndexMarker446"/><span class="koboSpan" id="kobo.904.1"> happen, we need three actors: 1) our SPA, handling multiple routes, 2) the authentication </span><strong class="bold"><span class="koboSpan" id="kobo.905.1">service provider</span></strong><span class="koboSpan" id="kobo.906.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.907.1">SP</span></strong><span class="koboSpan" id="kobo.908.1">) server, and 3) our own backend server. </span><span class="koboSpan" id="kobo.908.2">It is possible to do the authentication and validation of our backend in the browser, then only needing two actors, but this is not recommended as it exposes the secret key in our JavaScript. </span><span class="koboSpan" id="kobo.908.3">The option is there, however, for embedded applications such as mobile apps where the user has no easy access to the page code (in </span><span class="No-Break"><span class="koboSpan" id="kobo.909.1">hybrid applications).</span></span></p>
<p><span class="koboSpan" id="kobo.910.1">In order to implement the workflow, the client (our application) must register with the authentication service. </span><span class="koboSpan" id="kobo.910.2">The process depends on each entity, but as a result, we will have registered </span><span class="No-Break"><span class="koboSpan" id="kobo.911.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.912.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.913.1">client_id</span></strong><span class="koboSpan" id="kobo.914.1"> identification string, unique to </span><span class="No-Break"><span class="koboSpan" id="kobo.915.1">our application.</span></span></li>
<li><span class="koboSpan" id="kobo.916.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.917.1">secret_key</span></strong><span class="koboSpan" id="kobo.918.1"> value, which will be known only to the authentication server and our backend application. </span><span class="koboSpan" id="kobo.918.2">This will be used to encode and sign </span><span class="No-Break"><span class="koboSpan" id="kobo.919.1">our tokens.</span></span></li>
<li><span class="koboSpan" id="kobo.920.1">A series of </span><em class="italic"><span class="koboSpan" id="kobo.921.1">endpoints</span></em><span class="koboSpan" id="kobo.922.1"> in the authentication server, and in our application where the user will be redirected in each step. </span><span class="koboSpan" id="kobo.922.2">Appropriate exchange of tokens will be done in these redirects as part of the query string in </span><span class="No-Break"><span class="koboSpan" id="kobo.923.1">the URL.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.924.1">So, let’s see </span><a id="_idIndexMarker447"/><span class="koboSpan" id="kobo.925.1">these steps in detail, and how to implement them in our Vue </span><span class="No-Break"><span class="koboSpan" id="kobo.926.1">3 application:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table004">
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.927.1">Step</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.928.1">Description</span></strong></span></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.929.1">1</span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.930.1">The user needs to be authenticated, so we redirect them to the endpoint given to us by the authentication server. </span><span class="koboSpan" id="kobo.930.2">The query string needs to be included with the following (</span><span class="No-Break"><span class="koboSpan" id="kobo.931.1">mandatory) fields:</span></span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.932.1">scope</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.933.1">: </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.934.1">openid</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.935.1">response_type</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.936.1">: </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.937.1">code</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.938.1">client_id</span></strong><span class="koboSpan" id="kobo.939.1">: The client identification given by the </span><span class="No-Break"><span class="koboSpan" id="kobo.940.1">authentication server</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.941.1">redirect_uri</span></strong><span class="koboSpan" id="kobo.942.1">: The same address that we registered with the server where the user will be redirected upon </span><span class="No-Break"><span class="koboSpan" id="kobo.943.1">successful authentication</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.944.1">state</span></strong><span class="koboSpan" id="kobo.945.1">: Any data or application state that we want to receive in return after </span><span class="No-Break"><span class="koboSpan" id="kobo.946.1">the authentication</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.947.1">To prepare the redirection URL, we first create an object with the preceding fields and values, and use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.948.1">URLSearchParams</span></strong><span class="koboSpan" id="kobo.949.1"> creator to create a query string (</span><span class="No-Break"><span class="koboSpan" id="kobo.950.1">see </span></span><a href="https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams"><span class="No-Break"><span class="koboSpan" id="kobo.951.1">https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.952.1">):</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.953.1">const </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.954.1">query_data={scope:"openid", ...},</span></strong></span></p>
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.955.1">query_string=new URLSearchParams(query_data).toString()</span></strong></span></p>
<p><span class="koboSpan" id="kobo.956.1">Next, we can use the location object to execute </span><span class="No-Break"><span class="koboSpan" id="kobo.957.1">the redirection:</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.958.1">location.assign("https://auth_endpoint" + "?" </span><span class="koboSpan" id="kobo.958.2">+ </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.959.1">query_string)</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.960.1">2</span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.961.1">On successful authentication, the authentication server will redirect the user to the endpoint that we registered as the receiver. </span><span class="koboSpan" id="kobo.961.2">The query parameters sent will depend on the result of </span><span class="No-Break"><span class="koboSpan" id="kobo.962.1">the operation:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.963.1">Successful sign-in:</span></span><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.964.1">code</span></strong><span class="koboSpan" id="kobo.965.1">: The </span><strong class="bold"><span class="koboSpan" id="kobo.966.1">code_token</span></strong><span class="koboSpan" id="kobo.967.1"> that needs to be exchanged later for </span><span class="No-Break"><span class="koboSpan" id="kobo.968.1">an </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.969.1">identity_token</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.970.1">.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.971.1">state</span></strong><span class="koboSpan" id="kobo.972.1">: Any data we sent to the server and want back. </span><span class="koboSpan" id="kobo.972.2">We can use this to redirect the user inside our application, </span><span class="No-Break"><span class="koboSpan" id="kobo.973.1">for example.</span></span></li></ul></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.974.1">Unsuccessful sign-in:</span></span><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.975.1">error</span></strong><span class="koboSpan" id="kobo.976.1">: An error code as specified by the protocol (</span><strong class="source-inline"><span class="koboSpan" id="kobo.977.1">interaction_required</span></strong><span class="koboSpan" id="kobo.978.1">,</span><strong class="source-inline"><span class="koboSpan" id="kobo.979.1"> invalid_request_uri</span></strong><span class="koboSpan" id="kobo.980.1">, and </span><span class="No-Break"><span class="koboSpan" id="kobo.981.1">so on).</span></span></li></ul></li>
</ul>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style"/>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.982.1">The redirect will trigger our application being loaded, and the router will render our designated component. </span><span class="koboSpan" id="kobo.982.2">In our script setup, we need to capture the query string passed to us, to be used later in the next step. </span><span class="koboSpan" id="kobo.982.3">One approach to do this without the use of third-party libraries is with the </span><span class="No-Break"><span class="koboSpan" id="kobo.983.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.984.1">
import {useRoute} from "vue-router"
const </span><strong class="bold"><span class="koboSpan" id="kobo.985.1">$route=useRoute()</span></strong><span class="koboSpan" id="kobo.986.1">
if(</span><strong class="bold"><span class="koboSpan" id="kobo.987.1">$route.query.error</span></strong><span class="koboSpan" id="kobo.988.1">){
   // The authentication failed, take action
}else{
   // Authentication succeeded do something
   sendToServer(</span><strong class="bold"><span class="koboSpan" id="kobo.989.1">$route.query.code)</span></strong><span class="koboSpan" id="kobo.990.1">
}</span></pre>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.991.1">3</span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.992.1">In this step, we just send the code received to our backend, which would mean implementing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.993.1">sendToServer()</span></strong><span class="koboSpan" id="kobo.994.1"> function mentioned previously. </span><span class="koboSpan" id="kobo.994.2">Since now we are dealing with our own implementation, the way to do this is trivial. </span><span class="koboSpan" id="kobo.994.3">In this example, we are </span><span class="No-Break"><span class="koboSpan" id="kobo.995.1">using Axios:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.996.1">
import{axios}from "axios"
function sendToServer(</span><strong class="bold"><span class="koboSpan" id="kobo.997.1">code</span></strong><span class="koboSpan" id="kobo.998.1">){
axios
  .post("our server URL", {</span><strong class="bold"><span class="koboSpan" id="kobo.999.1">code</span></strong><span class="koboSpan" id="kobo.1000.1">})
  .then(result=&gt;{
    // Set the token in our headers
    axios.defaults.headers.common={
     </span><strong class="bold"><span class="koboSpan" id="kobo.1001.1">"Authorization":"Bearer " + result.data.identity_token</span></strong><span class="koboSpan" id="kobo.1002.1">
    }
  }).catch(()=&gt;{
   // Handle the error
})}</span></pre>
<p><span class="koboSpan" id="kobo.1003.1">In the previous example, we have sent to our server the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1004.1">code_token</span></strong><span class="koboSpan" id="kobo.1005.1"> string and received from our server the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1006.1">identity_token</span></strong><span class="koboSpan" id="kobo.1007.1"> string as response. </span><span class="koboSpan" id="kobo.1007.2">We then go one step beyond and set the default headers for our application to use the standard </span><strong class="source-inline"><span class="koboSpan" id="kobo.1008.1">Authorization </span></strong><span class="koboSpan" id="kobo.1009.1">header, with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1010.1">Bearer</span></strong><span class="koboSpan" id="kobo.1011.1"> token. </span><span class="koboSpan" id="kobo.1011.2">From then on, our server only needs to check the headers and verify that the operation requested belongs to a </span><span class="No-Break"><span class="koboSpan" id="kobo.1012.1">valid user.</span></span></p>
</td>
</tr>
</tbody>
</table>
<p><span class="koboSpan" id="kobo.1013.1">Implementing the validation of the tokens and </span><em class="italic"><span class="koboSpan" id="kobo.1014.1">steps 4</span></em><span class="koboSpan" id="kobo.1015.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.1016.1">5</span></em><span class="koboSpan" id="kobo.1017.1"> go beyond the scope of this book, as we are focusing on Vue 3 applications. </span><span class="koboSpan" id="kobo.1017.2">As you can see, the part that our SPA needs </span><a id="_idIndexMarker448"/><span class="koboSpan" id="kobo.1018.1">to handle is quite simple and does not really involve much code (some error checking was omitted for the sake </span><span class="No-Break"><span class="koboSpan" id="kobo.1019.1">of brevity).</span></span></p>
<p><span class="koboSpan" id="kobo.1020.1">There is a good number of syndicated authentication services, both free and paid, that we can implement in our application. </span><span class="koboSpan" id="kobo.1020.2">Most common these days is to see badges redirecting users to use them, such as signing in with </span><em class="italic"><span class="koboSpan" id="kobo.1021.1">Google</span></em><span class="koboSpan" id="kobo.1022.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1023.1">Facebook</span></em><span class="koboSpan" id="kobo.1024.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1025.1">Twitter</span></em><span class="koboSpan" id="kobo.1026.1">,</span><em class="italic"><span class="koboSpan" id="kobo.1027.1"> GitHub</span></em><span class="koboSpan" id="kobo.1028.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1029.1">Microsoft</span></em><span class="koboSpan" id="kobo.1030.1">, and so on. </span><span class="koboSpan" id="kobo.1030.2">There are also meta-services that provide all the aforementioned </span><a id="_idIndexMarker449"/><span class="koboSpan" id="kobo.1031.1">providers inside well-packaged libraries, such as </span><strong class="bold"><span class="koboSpan" id="kobo.1032.1">Auth0 </span></strong><span class="koboSpan" id="kobo.1033.1">(</span><a href="https://auth0.com/"><span class="koboSpan" id="kobo.1034.1">https://auth0.com/</span></a><span class="koboSpan" id="kobo.1035.1">, now part of </span><strong class="bold"><span class="koboSpan" id="kobo.1036.1">Okta</span></strong><span class="koboSpan" id="kobo.1037.1">, </span><a href="https://www.okta.com/"><span class="koboSpan" id="kobo.1038.1">https://www.okta.com/</span></a><span class="koboSpan" id="kobo.1039.1">). </span><span class="koboSpan" id="kobo.1039.2">When it comes to implementing this workflow, we are certainly not short </span><span class="No-Break"><span class="koboSpan" id="kobo.1040.1">of options.</span></span></p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor143"/><span class="koboSpan" id="kobo.1041.1">Passwordless or one-time password (OTP) authentication</span></h2>
<p><span class="koboSpan" id="kobo.1042.1">Another</span><a id="_idIndexMarker450"/><span class="koboSpan" id="kobo.1043.1"> solution to remove the use of credentials is to remove them altogether with passwordless access. </span><span class="koboSpan" id="kobo.1043.2">The</span><a id="_idIndexMarker451"/><span class="koboSpan" id="kobo.1044.1"> basic idea is to rely </span><a id="_idIndexMarker452"/><span class="koboSpan" id="kobo.1045.1">on the security of another system (email, mobile texts, authenticator apps, and so on) to validate the user. </span><span class="koboSpan" id="kobo.1045.2">The process generates a time-sensitive “one-time use only” code and sends it to the user through the supporting system via the</span><a id="_idIndexMarker453"/><span class="koboSpan" id="kobo.1046.1"> backend service. </span><span class="koboSpan" id="kobo.1046.2">The frontend service (the application) awaits the right to be entered by the user in a determined time frame. </span><span class="koboSpan" id="kobo.1046.3">For example, a common implementation is for the backend to send a text message to the user’s phone containing the code, which has to be entered into the application before the </span><span class="No-Break"><span class="koboSpan" id="kobo.1047.1">time expires.</span></span></p>
<p><span class="koboSpan" id="kobo.1048.1">Here is a visual representation of this workflow, considering that the user has been registered with an email or phone number. </span><span class="koboSpan" id="kobo.1048.2">These are supposed to be </span><em class="italic"><span class="koboSpan" id="kobo.1049.1">well known</span></em><span class="koboSpan" id="kobo.1050.1">, meaning that the ownership has </span><span class="No-Break"><span class="koboSpan" id="kobo.1051.1">been verified:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer037">
<span class="koboSpan" id="kobo.1052.1"><img alt="Figure 5.7 – Passwordless authentication based on email" src="image/Figure_5.07_B18602.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1053.1">Figure 5.7 – Passwordless authentication based on email</span></p>
<p><span class="koboSpan" id="kobo.1054.1">In the </span><a id="_idIndexMarker454"/><span class="koboSpan" id="kobo.1055.1">preceding workflow, notice that the OTP code never reaches the web application until the user inputs it. </span><span class="koboSpan" id="kobo.1055.2">The</span><a id="_idIndexMarker455"/><span class="koboSpan" id="kobo.1056.1"> validation occurs in the </span><a id="_idIndexMarker456"/><span class="koboSpan" id="kobo.1057.1">backend, not in the frontend. </span><span class="koboSpan" id="kobo.1057.2">This makes our application </span><a id="_idIndexMarker457"/><span class="koboSpan" id="kobo.1058.1">very simple, as it only needs to collect the email first and submit it to the server, and then wait for the specified time for a new input. </span><span class="koboSpan" id="kobo.1058.2">In a service or component, using Axios, this code would look something </span><span class="No-Break"><span class="koboSpan" id="kobo.1059.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1060.1">
const _user_email=ref(""),
      _wait_seconds=ref(0),
      _show_input_code=ref(false),
      _otp_code=ref("")
function </span><strong class="bold"><span class="koboSpan" id="kobo.1061.1">signInUser()</span></strong><span class="koboSpan" id="kobo.1062.1">{
    axios.post("https://requestOTP_url",
                </span><strong class="bold"><span class="koboSpan" id="kobo.1063.1">{email:_user_email.value</span></strong><span class="koboSpan" id="kobo.1064.1">})
    .then(result=&gt;{
        _wait_seconds.value=result.data.wait_time;
        _show_input_code.value=true;
        startOTPtimer();
    }).catch(err=&gt;{...})
}
function </span><strong class="bold"><span class="koboSpan" id="kobo.1065.1">startOTPtimer()</span></strong><span class="koboSpan" id="kobo.1066.1">{
   let interval_id=setInterval(()=&gt;{
   if(_wait_seconds.value&gt;0){_wait_seconds.value--;}
   else{clearInterval(interval_id);}},1000)
}
function </span><strong class="bold"><span class="koboSpan" id="kobo.1067.1">checkOTP()</span></strong><span class="koboSpan" id="kobo.1068.1">{
   axios.post("https://validateOTP_URL",</span><strong class="bold"><span class="koboSpan" id="kobo.1069.1">{code:_otp_code.value}</span></strong><span class="koboSpan" id="kobo.1070.1">)
   .then(result=&gt;{
     if(result.status&gt;200 &amp;&amp; result.status&lt;300){
        </span><strong class="bold"><span class="koboSpan" id="kobo.1071.1">// User validated, proceed to protected route</span></strong><span class="koboSpan" id="kobo.1072.1">
     }else{
        </span><strong class="bold"><span class="koboSpan" id="kobo.1073.1">// Validation failed. </span><span class="koboSpan" id="kobo.1073.2">Redirect to error route</span></strong><span class="koboSpan" id="kobo.1074.1">
     }
 }).catch(err=&gt;{...})
}</span></pre>
<p><span class="koboSpan" id="kobo.1075.1">In the </span><a id="_idIndexMarker458"/><span class="koboSpan" id="kobo.1076.1">preceding </span><a id="_idIndexMarker459"/><span class="koboSpan" id="kobo.1077.1">code, we have omitted the imports and the template, as </span><a id="_idIndexMarker460"/><span class="koboSpan" id="kobo.1078.1">at this point they should be </span><a id="_idIndexMarker461"/><span class="koboSpan" id="kobo.1079.1">trivial for the reader. </span><span class="koboSpan" id="kobo.1079.2">Our template should have at least an input to collect the email of the user, and a second input to collect the OTP code, plus two buttons to trigger on click the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1080.1">signInUser()</span></strong><span class="koboSpan" id="kobo.1081.1"> function and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1082.1">checkOTP()</span></strong><span class="koboSpan" id="kobo.1083.1"> function. </span><span class="koboSpan" id="kobo.1083.2">The first one will pass the email to the backend, and wait for a reply with at least a time in seconds to wait, which we use to start a timer (it is always good to let the user know how much time they have to enter the code). </span><span class="koboSpan" id="kobo.1083.3">Nowadays, for </span><a id="_idIndexMarker462"/><span class="koboSpan" id="kobo.1084.1">emails and text messages, the standard </span><a id="_idIndexMarker463"/><span class="koboSpan" id="kobo.1085.1">is 60 seconds. </span><span class="koboSpan" id="kobo.1085.2">When this happens, we also </span><a id="_idIndexMarker464"/><span class="koboSpan" id="kobo.1086.1">hide the first input and then show the “OTP” input form. </span><span class="koboSpan" id="kobo.1086.2">When the user enters the code and clicks </span><strong class="bold"><span class="koboSpan" id="kobo.1087.1">Submit</span></strong><span class="koboSpan" id="kobo.1088.1">, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1089.1">checkOTP()</span></strong><span class="koboSpan" id="kobo.1090.1"> function is activated, and we pass the code again</span><a id="_idIndexMarker465"/><span class="koboSpan" id="kobo.1091.1"> to the server waiting for a reply. </span><span class="koboSpan" id="kobo.1091.2">On success, we can redirect the user to a protected area according to our application logic. </span><span class="koboSpan" id="kobo.1091.3">Considering the triviality of the template, it would be a good exercise for the reader to create the component and template by themself. </span><span class="koboSpan" id="kobo.1091.4">Then, a possible solution can be found in the code examples, in the </span><a href="B18602_05.xhtml#_idTextAnchor130"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1092.1">Chapter </span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1093.1">5</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1094.1"> folder.</span></span></p>
<p><span class="koboSpan" id="kobo.1095.1">Following a progressive approach to security, the next step is to join the previous approaches into a common new process: </span><strong class="bold"><span class="koboSpan" id="kobo.1096.1">two-factor authentication</span></strong><span class="koboSpan" id="kobo.1097.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.1098.1">2FA</span></strong><span class="koboSpan" id="kobo.1099.1">), which we will </span><span class="No-Break"><span class="koboSpan" id="kobo.1100.1">see now.</span></span></p>
<h2 id="_idParaDest-118"><a id="_idTextAnchor144"/><span class="koboSpan" id="kobo.1101.1">2FA - Two Factors Authentication</span></h2>
<p><span class="koboSpan" id="kobo.1102.1">In 2FA, our </span><a id="_idIndexMarker466"/><span class="koboSpan" id="kobo.1103.1">application merges two </span><a id="_idIndexMarker467"/><span class="koboSpan" id="kobo.1104.1">or more of the previous approaches to validate a user. </span><span class="koboSpan" id="kobo.1104.2">The key concept behind this method is that even a third party or simple username and password are not enough, and the user needs to have a “secondary factor” to be validated—for example, the use of a registered email, phone number (for SMS submission of codes), authentication apps (example: Google Authenticator), a USB device, a security card (with a chip or band reader), and </span><span class="No-Break"><span class="koboSpan" id="kobo.1105.1">so on.</span></span></p>
<p><span class="koboSpan" id="kobo.1106.1">The workflow is simple but does require more from our backend than from our frontend application. </span><span class="koboSpan" id="kobo.1106.2">Once our SPA authenticates our user using any of the methods listed previously, a second request is triggered on the backend to submit the proper query to the security device. </span><span class="koboSpan" id="kobo.1106.3">Let’s assume that our user receives an SMS from our server with a code. </span><span class="koboSpan" id="kobo.1106.4">Our SPA will wait and collect this code during a specific time frame (usually, 60 seconds), and submit it to the backend to a specific endpoint. </span><span class="koboSpan" id="kobo.1106.5">It is the server that then validates the code. </span><span class="koboSpan" id="kobo.1106.6">In reality, this is like having two or multiple passwords, whose validation is made in cascade. </span><span class="koboSpan" id="kobo.1106.7">Any step fails, and the entire operation </span><span class="No-Break"><span class="koboSpan" id="kobo.1107.1">is discarded.</span></span></p>
<p><span class="koboSpan" id="kobo.1108.1">Here’s a visualization of </span><span class="No-Break"><span class="koboSpan" id="kobo.1109.1">the process:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer038">
<span class="koboSpan" id="kobo.1110.1"><img alt="Figure 5.8 – A simplified view of our SPA and server interactions with 2FA" src="image/Figure_5.08_B18602.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1111.1">Figure 5.8 – A simplified view of our SPA and server interactions with 2FA</span></p>
<p><span class="koboSpan" id="kobo.1112.1">As we </span><a id="_idIndexMarker468"/><span class="koboSpan" id="kobo.1113.1">can see from the simplified workflow, the process of validating a user with 2FA (as with passwordless and OTM methods) does not rely so much on the code or some specific cryptography but on the use of clever communication and data isolation. </span><span class="koboSpan" id="kobo.1113.2">The data and validation process never leaves our server or could be visible to an end user, even if opening the code of our SPA. </span><span class="koboSpan" id="kobo.1113.3">In a way, you can think of this workflow as the concatenation of an OpenID or credentials authentication, followed by an </span><span class="No-Break"><span class="koboSpan" id="kobo.1114.1">OTP implementation.</span></span></p>
<p><span class="koboSpan" id="kobo.1115.1">Our application’s main responsibility is just to collect the bits of data that make up each step and relay them to the server. </span><span class="koboSpan" id="kobo.1115.2">In between, we could change the route or update the interface, but this implementation is trivial, so we won’t see specific code here (you can see previously how to programmatically change a route, </span><span class="No-Break"><span class="koboSpan" id="kobo.1116.1">for example).</span></span></p>
<p><span class="koboSpan" id="kobo.1117.1">In general, 2FA is</span><a id="_idIndexMarker469"/><span class="koboSpan" id="kobo.1118.1"> considered a “more secure method”, but it is not without its drawbacks, and it may not be the right fit for every application. </span><span class="koboSpan" id="kobo.1118.2">For example, what happens if you know your username and password, but lose your secondary device (your mobile gets stolen, hacked, and so on)? </span><span class="koboSpan" id="kobo.1118.3">Organizations that use this method often provide a way to recover your identity, often with expensive implementations (think of a bank and phone service). </span><span class="koboSpan" id="kobo.1118.4">In the end, this method does apply one more layer of complexity in the authentication </span><a id="_idIndexMarker470"/><span class="koboSpan" id="kobo.1119.1">of users, and with </span><a id="_idIndexMarker471"/><span class="koboSpan" id="kobo.1120.1">it, another possible point of failure, ending with very frustrated users if not </span><span class="No-Break"><span class="koboSpan" id="kobo.1121.1">handled properly.</span></span></p>
<p><span class="koboSpan" id="kobo.1122.1">Let’s see next another authentication method that is gaining traction as the new kid on the block of authentication patterns: </span><span class="No-Break"><span class="koboSpan" id="kobo.1123.1">Web3 authentication.</span></span></p>
<h2 id="_idParaDest-119"><a id="_idTextAnchor145"/><span class="koboSpan" id="kobo.1124.1">Web3 authentication</span></h2>
<p><span class="koboSpan" id="kobo.1125.1">Before </span><a id="_idIndexMarker472"/><span class="koboSpan" id="kobo.1126.1">we dig into the topic, we need to define what </span><strong class="bold"><span class="koboSpan" id="kobo.1127.1">Web3</span></strong><span class="koboSpan" id="kobo.1128.1"> is. </span><span class="koboSpan" id="kobo.1128.2">There seems to be some confusion as to the extent of the definition, so </span><a id="_idIndexMarker473"/><span class="koboSpan" id="kobo.1129.1">for our purposes, Web3 is believed to be the next iteration or evolution of the internet, where the processing power is done in decentralized and distributed servers, using blockchain technologies. </span><span class="koboSpan" id="kobo.1129.2">The most well-known and popular applications of these technologies nowadays are cryptocurrencies, decentralized self-governing organizations, decentralized finances, play-to-earn games, distributed cloud storage, and </span><span class="No-Break"><span class="koboSpan" id="kobo.1130.1">much more.</span></span></p>
<p><span class="koboSpan" id="kobo.1131.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.1132.1">blockchain</span></strong><span class="koboSpan" id="kobo.1133.1"> is a</span><a id="_idIndexMarker474"/><span class="koboSpan" id="kobo.1134.1"> ledger that is maintained by a network of distributed computers. </span><span class="koboSpan" id="kobo.1134.2">Anything written to it is immutable, and publicly visible by anyone on the network. </span><span class="koboSpan" id="kobo.1134.3">Some blockchains are “smart”, meaning that they can contain not only data but also run applications, much like any backend service. </span><span class="koboSpan" id="kobo.1134.4">The frontend applications that connect to a blockchain are </span><a id="_idIndexMarker475"/><span class="koboSpan" id="kobo.1135.1">called </span><strong class="bold"><span class="koboSpan" id="kobo.1136.1">distributed applications (DApps</span></strong><span class="koboSpan" id="kobo.1137.1">), which are, for the most part, </span><em class="italic"><span class="koboSpan" id="kobo.1138.1">SPAs</span></em><span class="koboSpan" id="kobo.1139.1">. </span><span class="koboSpan" id="kobo.1139.2">For this task, the Vue 3 framework is very well suited, as we have seen thus far. </span><span class="koboSpan" id="kobo.1139.3">A DApp must connect with a backend server that is part of the target blockchain network. </span><span class="koboSpan" id="kobo.1139.4">These types of servers are known as </span><strong class="bold"><span class="koboSpan" id="kobo.1140.1">nodes</span></strong><span class="koboSpan" id="kobo.1141.1">. </span><span class="koboSpan" id="kobo.1141.2">In</span><a id="_idIndexMarker476"/><span class="koboSpan" id="kobo.1142.1"> some cases, the DApp can interact directly with the blockchain. </span><span class="koboSpan" id="kobo.1142.2">Most, if not all, blockchains use cryptocurrencies to regulate operations and reward the contributing nodes supporting the network. </span><span class="koboSpan" id="kobo.1142.3">Cryptocurrencies are logically assigned to a unique blockchain ID called a “wallet”. </span><span class="koboSpan" id="kobo.1142.4">These wallets implement some very smart cryptographic techniques to validate each other when performing operations, through the use of public and private keys. </span><span class="koboSpan" id="kobo.1142.5">A user may have many wallets. </span><span class="koboSpan" id="kobo.1142.6">There are no emails or ways to recover lost keys in a blockchain, and each wallet </span><span class="No-Break"><span class="koboSpan" id="kobo.1143.1">is unique.</span></span></p>
<p><span class="koboSpan" id="kobo.1144.1">In order</span><a id="_idIndexMarker477"/><span class="koboSpan" id="kobo.1145.1"> to resolve all this cryptographic signage and validation, and to make it easier for users, there are special plugins for browsers called “digital wallets," as well as mobile application wallets that also implement web browsing. </span><span class="koboSpan" id="kobo.1145.2">These applications hold the credentials and do the heavy lifting when dealing with the blockchain. </span><span class="koboSpan" id="kobo.1145.3">There are, of course, numerous libraries to do the same tasks in pure JavaScript, but this goes beyond the scope of this book. </span><span class="koboSpan" id="kobo.1145.4">What we will see next is how in our SPA, we can leverage the power of these technologies to identify a user, even automatically when visiting our </span><span class="No-Break"><span class="koboSpan" id="kobo.1146.1">application page.</span></span></p>
<p><span class="koboSpan" id="kobo.1147.1">We will focus mainly on the biggest smart blockchain, the Ethereum network, as an example. </span><span class="koboSpan" id="kobo.1147.2">The same workflow with more or fewer steps applies to other networks using different SDKs, so the migration or incorporation of additional blockchains is not too far away from our examples. </span><span class="koboSpan" id="kobo.1147.3">The basic conceptual workflow is </span><span class="No-Break"><span class="koboSpan" id="kobo.1148.1">as follows:</span></span></p>
<p><span class="koboSpan" id="kobo.1149.1">Import a library to </span><a id="_idIndexMarker478"/><span class="koboSpan" id="kobo.1150.1">connect to the network in our JavaScript, either through a library such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1151.1">web3js</span></strong><span class="koboSpan" id="kobo.1152.1"> (</span><a href="https://www.npmjs.com/package/web3"><span class="koboSpan" id="kobo.1153.1">https://www.npmjs.com/package/web3</span></a><span class="koboSpan" id="kobo.1154.1">), </span><strong class="source-inline"><span class="koboSpan" id="kobo.1155.1">ethjs</span></strong><strong class="bold"> </strong><span class="koboSpan" id="kobo.1156.1">(</span><a href="https://www.npmjs.com/package/ethjs"><span class="koboSpan" id="kobo.1157.1">https://www.npmjs.com/package/ethjs</span></a><span class="koboSpan" id="kobo.1158.1">), or use the one injected directly by a browser wallet—in our </span><a id="_idIndexMarker479"/><span class="koboSpan" id="kobo.1159.1">example, </span><strong class="bold"><span class="koboSpan" id="kobo.1160.1">MetaMask</span></strong><span class="koboSpan" id="kobo.1161.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.1162.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1163.1">window.ethereum</span></strong></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1164.1">Using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1165.1">ethereum</span></strong><span class="koboSpan" id="kobo.1166.1"> object, we request the user to connect their wallet to our site and retrieve the selected </span><span class="No-Break"><span class="koboSpan" id="kobo.1167.1">wallet address</span></span></li>
<li><span class="koboSpan" id="kobo.1168.1">Our application then can send to our backend the wallet ID (that is public) and use it as the unique ID for the </span><span class="No-Break"><span class="koboSpan" id="kobo.1169.1">user’s account</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1170.1">As just mentioned, we will use the object injected</span><a id="_idIndexMarker480"/><span class="koboSpan" id="kobo.1171.1"> by </span><strong class="bold"><span class="koboSpan" id="kobo.1172.1">MetaMask</span></strong><span class="koboSpan" id="kobo.1173.1"> (https://metamask.io/) since it is one of the best-known browser wallets. </span><span class="koboSpan" id="kobo.1173.2">In this case, here is the code that requests the current </span><span class="No-Break"><span class="koboSpan" id="kobo.1174.1">user’s wallet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1175.1">
ethereum
</span><strong class="bold"><span class="koboSpan" id="kobo.1176.1">.request({ method: 'eth_requestAccounts' })</span></strong><span class="koboSpan" id="kobo.1177.1">
.then(
    result=&gt;console.log(result[0]),
    err=&gt;console.log(err)
)</span></pre>
<p><span class="koboSpan" id="kobo.1178.1">That’s it! </span><span class="koboSpan" id="kobo.1178.2">The</span><a id="_idIndexMarker481"/><span class="koboSpan" id="kobo.1179.1"> highlighted line prompts </span><em class="italic"><span class="koboSpan" id="kobo.1180.1">MetaMask </span></em><span class="koboSpan" id="kobo.1181.1">to open a new window and request the user’s permission to connect their wallet to your web application, and then return a handy promise. </span><span class="koboSpan" id="kobo.1181.2">If approved, the result will be an array of strings, where the first position is the wallet address for the current network. </span><span class="koboSpan" id="kobo.1181.3">If rejected, an error will </span><span class="No-Break"><span class="koboSpan" id="kobo.1182.1">be triggered.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1183.1">Tip</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1184.1">With MetaMask, you can open the </span><strong class="bold"><span class="koboSpan" id="kobo.1185.1">Developer Tools</span></strong><span class="koboSpan" id="kobo.1186.1"> in the browser and type in one line the preceding code to </span><span class="No-Break"><span class="koboSpan" id="kobo.1187.1">test it.</span></span></p>
<p><span class="koboSpan" id="kobo.1188.1">Using </span><strong class="bold"><span class="koboSpan" id="kobo.1189.1">MetaMask</span></strong><span class="koboSpan" id="kobo.1190.1">, the</span><a id="_idIndexMarker482"/><span class="koboSpan" id="kobo.1191.1"> same code for</span><a id="_idIndexMarker483"/><span class="koboSpan" id="kobo.1192.1"> the </span><strong class="bold"><span class="koboSpan" id="kobo.1193.1">Ethereum</span></strong><span class="koboSpan" id="kobo.1194.1"> network also works when connected </span><a id="_idIndexMarker484"/><span class="koboSpan" id="kobo.1195.1">to the </span><strong class="bold"><span class="koboSpan" id="kobo.1196.1">Polygon</span></strong><span class="koboSpan" id="kobo.1197.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.1198.1">Binance Smart Chain</span></strong><span class="koboSpan" id="kobo.1199.1"> networks (three for the price of one!). </span><span class="koboSpan" id="kobo.1199.2">Other networks and wallets, such as </span><a id="_idIndexMarker485"/><span class="koboSpan" id="kobo.1200.1">the Phantom wallet, follow the same principle and inject into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1201.1">windows</span></strong><span class="koboSpan" id="kobo.1202.1"> object a new object called </span><strong class="source-inline"><span class="koboSpan" id="kobo.1203.1">.solana</span></strong><span class="koboSpan" id="kobo.1204.1">. </span><span class="koboSpan" id="kobo.1204.2">Check the documentation of your target blockchain to become acquainted with the details of </span><span class="No-Break"><span class="koboSpan" id="kobo.1205.1">each implementation.</span></span></p>
<p><span class="koboSpan" id="kobo.1206.1">Interacting with each blockchain and the code thereof is beyond the scope of this book, so we will limit ourselves to identifying the user by their wallet address. </span><span class="koboSpan" id="kobo.1206.2">Having obtained this identification, it is up to our application logic to store them for future reference, as it acts like the </span><span class="No-Break"><span class="koboSpan" id="kobo.1207.1">user ID.</span></span></p>
<p><span class="koboSpan" id="kobo.1208.1">There are also third-party solutions to authenticate and interact with multiple blockchains, and we should consider them before implementing our </span><span class="No-Break"><span class="koboSpan" id="kobo.1209.1">own solution.</span></span></p>
<h1 id="_idParaDest-120"><a id="_idTextAnchor146"/><span class="koboSpan" id="kobo.1210.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1211.1">In this chapter, we considerably improved our application and created a sound SPA with navigation using the Vue router. </span><span class="koboSpan" id="kobo.1211.2">This is an important concept to segment our application and organize the work between the members of a development team. </span><span class="koboSpan" id="kobo.1211.3">Fractioning our application following the navigation path makes development and maintenance easier to approach and better organized. </span><span class="koboSpan" id="kobo.1211.4">We also learned several authentication standard patterns that we can consider for our applications, covering a good number of scenarios used today in the industry, from the very basic username and password, all the way to the new Web3 DApps. </span><span class="koboSpan" id="kobo.1211.5">We also took time to understand how standard protocols such as OAuth work, as well as OTPs, and how these can be implemented for an extra layer of security as a second-factor authentication. </span><span class="koboSpan" id="kobo.1211.6">All these skills are relevant and necessary for today’s web </span><span class="No-Break"><span class="koboSpan" id="kobo.1212.1">application standards.</span></span></p>
<p><span class="koboSpan" id="kobo.1213.1">In the next chapter, we continue expanding our technical knowledge with the introduction of </span><strong class="bold"><span class="koboSpan" id="kobo.1214.1">progressive web </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1215.1">applications</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1216.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1217.1">PWAs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1218.1">).</span></span></p>
<h1 id="_idParaDest-121"><a id="_idTextAnchor147"/><span class="koboSpan" id="kobo.1219.1">Review questions</span></h1>
<p><span class="koboSpan" id="kobo.1220.1">We have covered multiple different topics and introduced new concepts in this chapter. </span><span class="koboSpan" id="kobo.1220.2">Use the following questions to solidify what you </span><span class="No-Break"><span class="koboSpan" id="kobo.1221.1">just learned:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1222.1">When is better to use a SPA instead of an MPA and </span><span class="No-Break"><span class="koboSpan" id="kobo.1223.1">vice versa?</span></span></li>
<li><span class="koboSpan" id="kobo.1224.1">What are the benefits of using a router in our SPA? </span><span class="koboSpan" id="kobo.1224.2">Name at least three from your </span><span class="No-Break"><span class="koboSpan" id="kobo.1225.1">own analysis.</span></span></li>
<li><span class="koboSpan" id="kobo.1226.1">How can you use views to define the layout of </span><span class="No-Break"><span class="koboSpan" id="kobo.1227.1">your application?</span></span></li>
<li><span class="koboSpan" id="kobo.1228.1">How can you access the parameters and query string passed to your route in </span><span class="No-Break"><span class="koboSpan" id="kobo.1229.1">your JavaScript?</span></span></li>
<li><span class="koboSpan" id="kobo.1230.1">What are some common standard patterns to </span><span class="No-Break"><span class="koboSpan" id="kobo.1231.1">authenticate users?</span></span></li>
<li><span class="koboSpan" id="kobo.1232.1">What are some security considerations when authenticating users in </span><span class="No-Break"><span class="koboSpan" id="kobo.1233.1">a SPA?</span></span></li>
</ul>
</div>
</body></html>