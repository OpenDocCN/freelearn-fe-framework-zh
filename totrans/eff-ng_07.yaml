- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mastering Reactive Programming in Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reactive programming helps improve your applications’ performance and allows
    Angular to make better use of the change detection mechanism, reducing the number
    of times your application needs to be re-rendered.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn about reactive programming. You will learn what
    reactive programming is and how it can be used to improve your Angular applications.
    You will also learn about the RxJS library and how it can manage asynchronous
    data streams reactively. This chapter will teach you how to use different RxJS
    operators, create reusable RxJS operators, reuse sets of RxJS operators, and map
    other Observables into view models using RxJS.
  prefs: []
  type: TYPE_NORMAL
- en: You will also learn about Angular Signals and how Signals are used to reactively
    manage synchronous data streams. Lastly, you will learn how to combine RxJS and
    Signals, when to use RxJS, and when Signals reign supreme.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll be able to reactively manage data streams
    and know everything there is to know about Angular Signals.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is reactive programming?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive programming using RxJS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive programming using Angular Signals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining Signals and RxJS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is reactive programming?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Reactive programming** is a declarative programming paradigm like functional,
    modular, procedural, or **object-orientated programming** (**OOP**). A **programming
    paradigm** is a set of rules and principles specifying how you write your code.
    It is similar to architectural and design patterns, but they operate on a different
    level of abstraction.'
  prefs: []
  type: TYPE_NORMAL
- en: Programming paradigms are high-level concepts that dictate the overall style,
    structure, and approach to writing code, whereas architectural and design patterns
    provide reusable templates or blueprints for structuring code, handling communication
    between components, managing relationships, and solving other common design challenges
    within your code base.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming deals with data streams and the propagation of changes.
    In simple terms, reactive programming dictates how you handle events and data
    changes that can happen at any given time, also known as **asynchronous changes**.
    As the name already implies, you are reacting to changes with reactive programming.
    With reactive programming, the dependent parts of your code will automatically
    be notified of events and data changes so that these parts can react to changes
    automatically. You can think of reactive programming as a system where changes
    are pushed to the parts of your code that need to react upon the changes instead
    of you pulling the current state, checking if it changed, and then updating the
    dependent code accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Highlights of reactive programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Reactive systems optimize resource allocation by subscribing to and processing
    data only when it changes, reducing unnecessary processing and improving overall
    system performance. This approach allows for a more responsive and scalable system
    while conserving computational resources, making it particularly advantageous
    for handling asynchronous data streams efficiently. Some common examples where
    you can use reactive programming to handle data streams and events are HTTP requests,
    form changes, and browser events such as clicks, mouse movements, and keyboard
    events.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming also promotes composability by enabling developers to easily
    compose complex behaviors from simpler ones. Through operators such as `map`,
    `filter`, `merge`, and more, reactive systems allow you to transform, combine,
    and manipulate data streams.
  prefs: []
  type: TYPE_NORMAL
- en: This inherent modularity empowers developers to build more modular and flexible
    applications where different data streams can be seamlessly integrated, transformed,
    and adapted to create sophisticated and easily maintainable systems. This emphasis
    on composability fosters code reusability and promotes the creation of highly
    scalable and adaptable applications.
  prefs: []
  type: TYPE_NORMAL
- en: Another important part of reactive programming is handling events and data changes
    that are non-blocking; this is mainly where the performance boost comes from when
    you start programming reactively. **Non-blocking code** ensures multiple tasks,
    events, and data changes can be executed in parallel. In other words, non-blocking
    code runs the code without waiting for the task to finish, so your code continues
    to the next lines of code directly after the task has started. In contrast, **blocking
    code** will wait until the code has finished before moving to the next line of
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Drawbacks of reactive programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Reactive programming is great, but it is not only sunshine and roses; there
    are also some drawbacks to reactive programming.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive systems can become complex, and the learning curve, especially for
    junior developers, can be steep. Besides some difficult concepts, reactive programming
    can be complicated to debug and harder to test with automated tests. Especially
    when you’re writing unit testing for your applications, a highly reactive system
    can give you some headaches.
  prefs: []
  type: TYPE_NORMAL
- en: You now know what reactive programming is and how it can improve your application’s
    performance and allow you to handle events and data streams effectively. Reactive
    programming provides easy composability of data streams and events and runs your
    code in a non-blocking approach. You also know what challenges reactive programming
    can bring to your code base and that it can be challenging for junior developers
    to understand some reactive patterns. Now, let’s learn more about how reactive
    programming is used within Angular applications.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming in Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reactive programming is integral to the Angular framework. Angular heavily relies
    on *Observables* (we will explain Observables in detail in the next section) and
    has the **RxJS** library built into it to manage Observable data streams in a
    robust and composable manner. **Observables** are a reactive design pattern because
    you have the Observable, or publisher of data, and the subscribers or receivers
    of the data stream. Subscribers are automatically notified when the Observable
    emits a new value and can act upon it accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Observables are utilized in many different aspects within the Angular framework.
    Here are some examples where you can find Observables within the Angular framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '**HTTP requests**: Within the Angular framework, HTTP requests return Observables
    by default. HTTP requests in vanilla JavaScript are handled with Promises.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`events` Observable. With the router `events` Observable, you can listen for
    events such as `NavigationStart`, `NavigationEnd`, `GuardCheckStart`, and `GuardCheckEnd`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`valueChanges` Observable is exposed by the Angular framework. With this Observable,
    you can react to changes within the form or form fields.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ViewChildren` decorator, the `QueryList` object it returns has a `changes`
    event. This `changes` event is an Observable that notifies you when the selection
    that’s made by `ViewChildren` has changed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These examples are just some instances where the Angular framework relies on
    Observables. In the code of applications made with Angular and within libraries
    that are commonly used in combination with Angular, you’ll come across Observables
    in many instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides Observables, Angular also uses reactive programming in other ways,
    such as when handling browser events with the `@``Hostlistener()` decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we used the `@Hostlistener()` decorator to listen
    for `keydown` events and handle them reactively. Another place where Angular uses
    the reactive programming paradigm is with **Angular Signals**, which was introduced
    in Angular 16\. Angular Signals is a system that tracks value changes and notifies
    interested consumers accordingly. The Signals API comes with computed properties
    and effects that are automatically updated or run when a Signal value changes.
    Signals are excellent for handling synchronous values reactively, whereas RxJS
    shines in handling asynchronous data streams. We will dive deeper into the topic
    of Signals in the *Reactive programming with Angular Signals* section of this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know that Angular has reactive programming embedded within the
    framework, from Observables and RxJS to event handling and the new Angular Signals,
    let’s move on to the next section and learn how to use RxJS to its fullest within
    Angular applications.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming using RxJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Regarding reactive programming in the context of Angular applications, RxJS
    stands at its core. **RxJS** is short for **Reactive Extensions Library for JavaScript**.
    As the name reveals, it’s a library for handling reactivity within JavaScript,
    and it is built-in and used by default within the Angular framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'RxJS is used to create, consume, modify, and compose asynchronous and event-based
    data streams. At its core, RxJS revolves around four major concepts: Observables,
    Observers, Subjects, and operators. Let’s dive deep into these concepts individually,
    starting with Observables.'
  prefs: []
  type: TYPE_NORMAL
- en: What are Observables?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Observables** are the cornerstone of RxJS. You can see Observables as a stream
    or a pipeline that emits different values over time in an asynchronous manner.
    To receive the values emitted by the Observable data stream, you subscribe to
    the Observable.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, imagine an Observable data stream as a water pipe. When you turn on the
    tap (subscribe), water (data) flows through the pipe (Observable), and you receive
    drops of water (values) at your end. The water (data) might already be flowing
    before you turn on the tab (subscribe) unless you installed a special system;
    you will only receive water (data) from the moment you have your tab running (subscribe)
    up to the moment you close the tab (unsubscribe). The water (data) might keep
    running to other tabs (subscribers) if they are open. So, in short, to receive
    values from the data flow, you need to subscribe, and all values emitted before
    you subscribe are lost unless you have special logic in place to store these values.
    To stop receiving values, you need to unsubscribe and the data emitting the values
    flows like a stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'Observables come in two types: *hot and cold Observables*. **Cold Observables**
    are unicast, meaning they start fresh for each subscriber. It’s like a movie on
    Netflix; when someone starts the movie, the movie will start from the beginning.
    If someone else starts the same movie on another account or TV, the movie will
    also start from the beginning. Everyone watching gets their own unique viewing
    experience from the moment they start watching.'
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, **hot Observables** are multicast, meaning there is one stream
    of data broadcasted to every subscriber. Hot Observables can be compared to live
    television. Different people can tune in to the live show (the data stream), but
    everything you already missed is gone and will not be replayed for you. Everyone
    watching experiences the same content simultaneously, even if they didn’t start
    watching from the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you clearly understand Observables and know the difference between
    hot and cold Observables, let’s learn about Observers.
  prefs: []
  type: TYPE_NORMAL
- en: Subscribing to Observables with Observers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Observers** are the entities that subscribe to an Observable and receive
    the Observable values in the data stream. You can think of the Observer as the
    person (or subscriber) watching a live show or putting on a Netflix movie. Subscribers
    have two tasks: subscribing to the streams they want to receive and unsubscribing
    from streams they do not want or need to receive anymore.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the most crucial parts is successfully unsubscribing from subscriptions
    the Observer doesn’t need anymore. Not unsubscribing Observables is probably the
    most considerable risk when using Observables in your code and is the most common
    source of problems. You will run into memory leaks if you don’t clean up your
    subscription correctly. Memory leaks will result in strange behavior and a slower
    application and can eventually crash your application if it runs out of memory.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s imagine that you have a subscription to a magazine that is delivered to
    your house every week. If you move to a new address, you need to *unsubscribe*
    from the subscription and create a *new subscription* on the new address. If you
    don’t unsubscribe from the old address and only begin a new subscription for the
    new address, you will start to pay double, and the magazine will be delivered
    to both addresses. If you keep repeating this process, you will eventually run
    out of money, and your life will crash. Within your applications, it’s the same,
    only you don’t pay with money but with memory.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a subscription inside a component, you must unsubscribe when
    the component is destroyed. Otherwise, the subscription will keep running. The
    next time you open the same component, a second subscription starts because the
    old one is still running. As a result, all values will be received by two Observers.
    If you keep repeating this process, you’ll end up with many Observers receiving
    the same value while you only need a single Observer to receive the values. When
    there are too many Observers, the application will run out of memory to process
    all the values, and the app will crash.
  prefs: []
  type: TYPE_NORMAL
- en: Unsubscribing from Observables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unsubscribing from Observables can be done in many different ways. Most commonly,
    in an Angular application, you can unsubscribe inside the `ngOnDestroy` life cycle
    hook. You can unsubscribe manually like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we subscribed to an Observable inside the `ngOnInit`
    life cycle hook and manually unsubscribed in the `ngOnDestroy` life cycle hook
    by calling the `unsubscribe()` and `complete()` methods on the Observable.
  prefs: []
  type: TYPE_NORMAL
- en: This approach may not be the best option when multiple Observables are inside
    your component. If you have five Observables, you must unsubscribe and complete
    all five Observables manually. Doing all subscriptions manually increases the
    risk of missing an Observable, and it will result in a large `ngOnDestroy` method
    with a lot of repetitive code inside.
  prefs: []
  type: TYPE_NORMAL
- en: You also need a local property for all Observables, further polluting your file
    with boilerplate code. In that case, you would need to save the Observable subscription
    in a property so that you can unsubscribe from the subscription in the `ngOnDestroy`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Another better option is to create a `Subscription` object and add all your
    subscriptions to this object by using the `add()` method on the `Subscription`
    object. In this case, you only have to unsubscribe from the `Subscription` object,
    and it will unsubscribe and complete all subscriptions that have been added to
    the `Subscription` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of how you can use the `Subscription` object approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we created a `subscriptions` property and assigned
    it to the `Subscription` object. Next, we used the `subscriptions` property and
    added all the subscriptions to the `subscriptions` property using the `add` method
    of the `Subscription` class. Lastly, inside `ngOnDestroy`, we called the `unsubscribe()`
    method on the `subscriptions` object, which will unsubscribe and complete all
    the inner subscriptions.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `Subscription` class is a good approach, but the syntax of adding
    the active subscriptions to the `Subscription` class looks messy. When you start
    to use RxJS pipeable operators, there is an approach that is more in line with
    the rest of your code. We will discuss pipeable operators in more detail later
    in this section, but for now, I want to show you how you can use them to unsubscribe
    automatically from your subscriptions.
  prefs: []
  type: TYPE_NORMAL
- en: Unsubscribing with the takeUntil() operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, we will take a look at the `takeUntil()` operator. You can add the `takeUntil()`
    operator inside the RxJS pipe method, which is changed on your Observables. The
    `takeUntil()` operator unsubscribes your subscriptions automatically upon a trigger.
    This trigger is commonly an RxJS `Subject` (we will discuss `Subject` in more
    detail later in this section). When we call the next method on this `Subject`,
    the `takeUntil()` operator will be triggered and unsubscribe from the subscription:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we created a `Subject` Observable and named it `destroy$`.
    Next, we used the `pipe()` function on our Observable, and inside the `pipe()`
    function, we added the `takeUntil()` operator. The `takeUntil()` operator received
    the `destroy$` property as a parameter and will be triggered once we call the
    `next()` method on the `destroy$` property. Lastly, inside the `ngOnDestroy` life
    cycle method, we called the `next()` method on the `destroy$` property and finished
    by calling the `complete()` method to complete the `destroy$` Observable itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `takeUntil()` operator is the preferred solution for many Angular
    developers to unsubscribe. This is because it works perfectly well in combination
    with the RxJS `pipe` function and other pipeable operators. There is one last
    option to unsubscribe that I want to show: the `takeUntilDestroyed()` operator.'
  prefs: []
  type: TYPE_NORMAL
- en: Unsubscribing with the takeUntilDestroyed() operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `takeUntilDestroyed()` operator was added by Angular in version 16\. It
    can be used to automatically unsubscribe when the component is destroyed. When
    you declare your subscription inside the injection context (inside the constructor
    or where you declare your properties), you only have to add the `takeUntilDestroyed()`
    operator, and it will manage everything for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: protected readonly destroy = inject(DestroyRef);
  prefs: []
  type: TYPE_NORMAL
- en: ngOnInit() {
  prefs: []
  type: TYPE_NORMAL
- en: this.observable$.pipe(takeUntilDestroyed(this.destroy)).subscribe(…);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: const subject = new Subject<number>();
  prefs: []
  type: TYPE_NORMAL
- en: 'subject.subscribe({next: (v) => console.log(`A: ${v}`)});'
  prefs: []
  type: TYPE_NORMAL
- en: subject.next(1);
  prefs: []
  type: TYPE_NORMAL
- en: 'subject.subscribe({next: (v) => console.log(`B: ${v}`)});'
  prefs: []
  type: TYPE_NORMAL
- en: subject.next(2);
  prefs: []
  type: TYPE_NORMAL
- en: '// Logs:'
  prefs: []
  type: TYPE_NORMAL
- en: // A:1, A:2, B:2
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: const subject = new BehaviorSubject(0); //initial value 0
  prefs: []
  type: TYPE_NORMAL
- en: 'subject.subscribe({next: (v) => console.log(`A: ${v}`)});'
  prefs: []
  type: TYPE_NORMAL
- en: subject.next(1);
  prefs: []
  type: TYPE_NORMAL
- en: 'subject.subscribe({next: (v) => console.log(`B: ${v}`)});'
  prefs: []
  type: TYPE_NORMAL
- en: subject.next(2);
  prefs: []
  type: TYPE_NORMAL
- en: '// Logs:'
  prefs: []
  type: TYPE_NORMAL
- en: // A:0, A:1, B:1, A:2, B:2
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: const subject = new ReplaySubject(100, 500);
  prefs: []
  type: TYPE_NORMAL
- en: subject.subscribe({
  prefs: []
  type: TYPE_NORMAL
- en: 'next: (v) => console.log(`A: ${v}`),'
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: let i = 1;
  prefs: []
  type: TYPE_NORMAL
- en: setInterval(() => subject.next(i++), 200);
  prefs: []
  type: TYPE_NORMAL
- en: setTimeout(() => {
  prefs: []
  type: TYPE_NORMAL
- en: subject.subscribe({
  prefs: []
  type: TYPE_NORMAL
- en: 'next: (v) => console.log(`B: ${v}`),'
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '}, 1000);'
  prefs: []
  type: TYPE_NORMAL
- en: // Logs
  prefs: []
  type: TYPE_NORMAL
- en: // A:1, A:2, A:3, A:4, A:5, B:3, B:4, B:5, A:6, B:6
  prefs: []
  type: TYPE_NORMAL
- en: // ...
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: const subject = new AsyncSubject();
  prefs: []
  type: TYPE_NORMAL
- en: subject.subscribe({
  prefs: []
  type: TYPE_NORMAL
- en: 'next: (v) => console.log(`A: ${v}`),'
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: subject.next(1);
  prefs: []
  type: TYPE_NORMAL
- en: subject.next(2);
  prefs: []
  type: TYPE_NORMAL
- en: subject.subscribe({
  prefs: []
  type: TYPE_NORMAL
- en: 'next: (v) => console.log(`B: ${v}`),'
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: subject.next(3);
  prefs: []
  type: TYPE_NORMAL
- en: subject.complete();
  prefs: []
  type: TYPE_NORMAL
- en: '// Logs:'
  prefs: []
  type: TYPE_NORMAL
- en: // A:3, B3
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'of() operator with three values: 1, 2, and 3. We subscribed to the Observable
    stream that was created with the of() operator and logged the values. This subscription
    will result in three separate logs: value: 1, value: 2, and value: 3. As you can
    see, the of() operator is a pretty simple and straightforward way to create an
    Observable stream.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another commonly used creational operator is the `from()` operator. The `from()`
    operator creates an Observable stream of an array, iterable, Promise, or strings.
    If you transform a string into an Observable stream using the `from()` operator,
    the string will be emitted character by character. Here’s an example of using
    the `from()` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we used the `from()` operator to create an Observable
    stream from an array and a Promise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another useful creational operator is the `fromEvent()` operator. The `fromEvent()`
    operator creates an Observable from an event target such as *click* or *hover*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: const amountExclVat = of(100);
  prefs: []
  type: TYPE_NORMAL
- en: const vatPercentage = of(20);
  prefs: []
  type: TYPE_NORMAL
- en: combineLatest([amountExclVat, vatPercentage]).subscribe({
  prefs: []
  type: TYPE_NORMAL
- en: 'next: ([amount, percentage]) => {'
  prefs: []
  type: TYPE_NORMAL
- en: console.log(‹Total:', amount * (percentage / 100 + 1));
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'combineLatest({ amount: amountExclVat, percentage: vatPercentage }).subscribe({'
  prefs: []
  type: TYPE_NORMAL
- en: 'next: (data) => { console.log(''Total:'', data.amount * (data.percentage /
    100 + 1)) }'
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: const a = new Subject();
  prefs: []
  type: TYPE_NORMAL
- en: const b = new Subject();
  prefs: []
  type: TYPE_NORMAL
- en: combineLatest([a, b]).subscribe({
  prefs: []
  type: TYPE_NORMAL
- en: 'next: ([a, b]) => { console.log(‹data›, a, b) }'
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: a.next(1);
  prefs: []
  type: TYPE_NORMAL
- en: setTimeout(() => { b.next(2) }, 5000);
  prefs: []
  type: TYPE_NORMAL
- en: setTimeout(() => { a.next(10) }, 10000);
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'forkJoin({ posts: this.http.get(''…''), post2: this.http.get(''…)}).subscribe(console.log);'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'concat() operator is used when you have multiple inner Observables, and the
    order of the emission and completion of these inner Observables is essential.
    So, if you have two inner Observables, concat() will emit all the values of the
    first inner Observable until that Observable is completed. All the values that
    have been emitted by the second Observable before the first Observable has been
    completed will not be emitted by concat().When the first Observable has been completed,
    the `concat()` operator subscribes to the second Observable and starts to emit
    the values emitted by the second Observable. If you have even more inner Observables,
    this process will be repeated, and `concat()` will subscribe to the next Observable
    when the previous Observable is completed:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: const a = new Subject();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: const b = new Subject();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: merge(a, b).subscribe(console.log);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b.next('B:1');
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: a.next('A:1');
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: a.next('A:2');
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b.next('B:2');
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '// Logs: B:1, A:1, A:2, B:2'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: const observable = of(1, 1, 2, 3, 4, 4, 5);
  prefs: []
  type: TYPE_NORMAL
- en: observable.pipe(
  prefs: []
  type: TYPE_NORMAL
- en: distinctUntilChanged(),
  prefs: []
  type: TYPE_NORMAL
- en: filter(value => value < 5),
  prefs: []
  type: TYPE_NORMAL
- en: map(value => value as number * 10)
  prefs: []
  type: TYPE_NORMAL
- en: ).subscribe(results => {console.log('results:', results)});
  prefs: []
  type: TYPE_NORMAL
- en: '// Logs: 10, 20, 30, 40'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: ngOnInit() {
  prefs: []
  type: TYPE_NORMAL
- en: this.urlObservable.pipe(
  prefs: []
  type: TYPE_NORMAL
- en: map((url) => this.http.get(url)),
  prefs: []
  type: TYPE_NORMAL
- en: concatAll()
  prefs: []
  type: TYPE_NORMAL
- en: ).subscribe((data) => { console.log('data ==>', data) })
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: this.urlObservable.pipe(
  prefs: []
  type: TYPE_NORMAL
- en: concatMap((url) => this.http.get(url)),
  prefs: []
  type: TYPE_NORMAL
- en: ).subscribe(……)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: const clicks = fromEvent(document, 'click');
  prefs: []
  type: TYPE_NORMAL
- en: clicks.pipe(
  prefs: []
  type: TYPE_NORMAL
- en: concatMap(() => interval(1000).pipe(take(4))),
  prefs: []
  type: TYPE_NORMAL
- en: ).subscribe(number => console.log(number));
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: const clicks = fromEvent(document, 'click');
  prefs: []
  type: TYPE_NORMAL
- en: clicks.pipe(
  prefs: []
  type: TYPE_NORMAL
- en: mergeMap(() => interval(1000).pipe(take(4))),
  prefs: []
  type: TYPE_NORMAL
- en: ).subscribe(x => console.log(x));
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: const clicks = fromEvent(document, 'click');
  prefs: []
  type: TYPE_NORMAL
- en: clicks.pipe(
  prefs: []
  type: TYPE_NORMAL
- en: switchMap(() => interval(1000).pipe(take(4))),
  prefs: []
  type: TYPE_NORMAL
- en: ).subscribe(x => console.log(x));
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: const clicks = fromEvent(document, 'click');
  prefs: []
  type: TYPE_NORMAL
- en: clicks.pipe(
  prefs: []
  type: TYPE_NORMAL
- en: exhaustMap(() => interval(1000).pipe(take(4))),
  prefs: []
  type: TYPE_NORMAL
- en: ).subscribe(x => console.log(x));
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: export const discardOdd = () => pipe(
  prefs: []
  type: TYPE_NORMAL
- en: 'filter((v: number) => !(v % 2)),'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: of(1, 2, 4, 5, 6, 7).pipe(discardOddDoubleEven()).subscribe(console.log);
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: const discardOddDoubleEven = () => pipe(
  prefs: []
  type: TYPE_NORMAL
- en: 'filter((v: number) => !(v % 2)),'
  prefs: []
  type: TYPE_NORMAL
- en: 'map((v: number) => v * 2)'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: expenses = signal<ExpenseModel[]>([ …… ]);
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: <div class="container">
  prefs: []
  type: TYPE_NORMAL
- en: <h1>Expenses Overview</h1>
  prefs: []
  type: TYPE_NORMAL
- en: <table>
  prefs: []
  type: TYPE_NORMAL
- en: <tr>
  prefs: []
  type: TYPE_NORMAL
- en: <th>Description</th>
  prefs: []
  type: TYPE_NORMAL
- en: ……
  prefs: []
  type: TYPE_NORMAL
- en: </tr>
  prefs: []
  type: TYPE_NORMAL
- en: '@for (expense of expenses(); track expense.id){'
  prefs: []
  type: TYPE_NORMAL
- en: <tr>
  prefs: []
  type: TYPE_NORMAL
- en: <td>{{ expense.description }}</td>
  prefs: []
  type: TYPE_NORMAL
- en: ……
  prefs: []
  type: TYPE_NORMAL
- en: </tr>
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: </table>
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'date: new FormControl<string | null>(null, [Validators.required]),'
  prefs: []
  type: TYPE_NORMAL
- en: 'tags: new FormArray<FormControl<string | null>>(['
  prefs: []
  type: TYPE_NORMAL
- en: new FormControl(''),
  prefs: []
  type: TYPE_NORMAL
- en: '])'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: showAddExpenseModal = signal(false);
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: <bt-libs-modal [shown]=" showAddExpenseModal()" (shownChange)=" showAddExpenseModal.set(false)"
    [title]="'Add expenses'">
  prefs: []
  type: TYPE_NORMAL
- en: '<bt-libs-ui-add-expense-form #form (addExpense)="onAddExpense($event)" />'
  prefs: []
  type: TYPE_NORMAL
- en: </bt-libs-modal>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'onAddExpense(expenseToAdd: ExpenseModel) {'
  prefs: []
  type: TYPE_NORMAL
- en: this.expenses.update(expenses => [...expenses, expenseToAdd]);
  prefs: []
  type: TYPE_NORMAL
- en: this. showAddExpenseModal.set(false);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: <button (click)="showAddExpenseModal.set(true)">Add expense</button>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'const count: WritableSignal<number> = signal(0);'
  prefs: []
  type: TYPE_NORMAL
- en: 'const double: Signal<number> = count Signal and a computed Signal named double.
    The computed Signal uses the computed function, and the count Signal is used inside
    the callback of the computed function. When the value of the count Signal changes
    to 1, the value of the computed Signal is automatically updated to 2.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to know that the computed Signal will only update when the Signal
    it depends on has a new stable value. Notice how I say *stable value*; this is
    because Signals provide their updates asynchronously and work a bit like the RxJS
    `switchMap` operator, which cancels the previous data stream if a new stream comes
    in before the old stream is finished. So, if you update the Signal multiple times
    in a row without pause in between, the Signal will not stabilize its value, and
    as a result, the computed Signal will only run on the last value change of the
    Signal.
  prefs: []
  type: TYPE_NORMAL
- en: Computed signals are very powerful and also very efficient. The computed Signal
    will not compute a value until the computed value is read for the first time.
    Next, the computed Signal will cache its value, and when you read the computed
    Signal again, it will simply return the cached value without running any computations.
    If the Signal value that the computed signal uses to derive its value from changes,
    the computed Signal will run a new computation and update its value.
  prefs: []
  type: TYPE_NORMAL
- en: Because computed Signals cache their results, you can safely use computationally
    expensive operations such as filtering and mapping arrays inside the callback
    function of your computed Signals. Just like regular Signals, computational Signals
    notify all consumers when their values change. As a result, all consumers of computed
    Signals will show the latest computed value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s add a computed Signal to `ExpensesOverviewComponent` for the total
    amount, including VAT:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we used the `computed` function, and inside the callback of
    the `computed` function, we used the `expenses` Signal to retrieve the current
    list of expenses. We can use the `Array.reduce` function on the `expenses` array
    to retrieve the total costs, including VAT. You can access the computed signal
    the same as you would a regular signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s create a new table row in the HTML template to display the total value.
    You can add the table row below the `for` loop in the HTML template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Suppose you add a new expense using the add expense form. In that case, you’ll
    notice that the total amount is automatically updated because the computed Signal
    uses the `expenses` Signal to evaluate the total amount. When the `expenses` Signal
    changes, the computed Signal will also be updated based on the `expenses` Signal.
  prefs: []
  type: TYPE_NORMAL
- en: 'One last thing that is good to know about computed Signals is that only Signals
    that are used during the computation are tracked. For example, let’s say you add
    a Signal to control if you show or hide the table row summary and another for
    the corresponding button text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now use the following `showSummary` Signal inside the computed Signal
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In this scenario, the computed Signal will only track the `expenses` Signal
    if the `showSummary` Signal is set to `true`. If the `showSummary` Signal is set
    to `false`, the `expenses` Signal is never reached within the `computed` function,
    and because of that, it will not be tracked for changes. So, if you update the
    `expenses` Signal while the `showSummary` Signal is set to `false`, the computed
    Signal will not calculate a new value.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know what computed Signals are, how to use them within your code,
    and how computed Signals update their values, let’s explore Signal effects.
  prefs: []
  type: TYPE_NORMAL
- en: Signal effects
  prefs: []
  type: TYPE_NORMAL
- en: '**Signal effects** are side effects that run each time a Signal changes. You
    can perform any logic you want inside a Signal effect. Some use cases for a Signal
    effect would be logging, updating local storage, showing notifications, or performing
    DOM manipulations that can’t be handled from within the HTML template.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a Signal effect by using the `effect` function and providing
    the `effect` function with a callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: effect(() => {
  prefs: []
  type: TYPE_NORMAL
- en: if (this.showSummary()) {
  prefs: []
  type: TYPE_NORMAL
- en: console.log(‹Updated expenses:›, this.expenses());
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: effect = effect(() => {
  prefs: []
  type: TYPE_NORMAL
- en: console.log(Summary:', this. showSummary ());
  prefs: []
  type: TYPE_NORMAL
- en: console.log('Expenses:', untracked(this.expenses()));
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: injector = inject(Injector);
  prefs: []
  type: TYPE_NORMAL
- en: effect(() => {
  prefs: []
  type: TYPE_NORMAL
- en: console.log(‹Updated expenses:›, this.expenses());
  prefs: []
  type: TYPE_NORMAL
- en: '}, { injector: this.injector });'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: expenseEffect = effect(() => {
  prefs: []
  type: TYPE_NORMAL
- en: console.log(‹Updated expenses:›, this.expenses());
  prefs: []
  type: TYPE_NORMAL
- en: '}, { manualCleanup to true, you have to call the destroy() function on the
    effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also hook into the cleanup of a Signal effect by using a callback function.
    This can be useful when you want to perform some logic when the Signal effect
    is cleaned up. Here’s an example of the `onCleanup` callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides `manualCleanup` and the `onCleanup` callback, there is one last configuration
    option for the Signal effects. By default, you are not allowed to update Signals
    inside a Signal effect; this is because this can easily result in infinite executions
    of the Signal effect. However, you can circumvent this by setting the `allowSignalWrites`
    property on the Signal effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Now that you know all about Signal effects, how to use them, and how you can
    trigger or configure them, let’s learn about Signal component inputs.
  prefs: []
  type: TYPE_NORMAL
- en: Signal component inputs
  prefs: []
  type: TYPE_NORMAL
- en: Since Angular 17.1, you can also use Signals as component input instead of using
    the `@Input()` decorator. Using the `ngOnChanges` life cycle hook.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example of a Signal input and compare it to the `@Input()` decorator
    (you don’t have to add the example in the monorepo, it’s just for explanatory
    purposes):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the Signal input has a much more straightforward approach to
    declaring input properties. You declare a property and assign it with an `input()`
    function; optionally, you can add the arrow syntax to add a type to the Signal
    input. If you want to provide an initial value to your Signal input, you can provide
    it as a function parameter, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Just as with the input decorator, you can also make the input required, use
    an input alias, or create a transform function on the input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, you can make the input required and provide the Signal input
    with a configuration object to give it an alias and transform function. The Signal
    input uses a simpler syntax, helps improve the change detection mechanism, and
    allows you to remove the `ngOnChanges` life cycle hook.
  prefs: []
  type: TYPE_NORMAL
- en: When you combine the Signal input with computed Signals, you can remove the
    `ngOnChanges` life cycle hook because all properties that need to be updated upon
    the input of a specific property can now automatically be updated by using a computed
    Signal based on the input Signal. Any additional logic you want to run can be
    declared inside a Signal effect that reacts to the Signal input.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know more about Signal inputs, let’s learn about Signal queries,
    which are used to interact with HTML elements reactively.
  prefs: []
  type: TYPE_NORMAL
- en: Signal queries
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, you need to select HTML elements from your template and interact with
    them inside your component class. In Angular, this is commonly achieved by using
    the `@ContentChild`, `@ContentChildren`, `@ViewChild`, or `@ViewChildren` decorator.
    In Angular 17.2, a new Signal-based approach was introduced that allows you to
    interact with HTML elements reactively and combine them with computed Signals
    and Signal effects. Using the Signal-based approach instead of decorators offers
    some additional advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: You can make the query results more predictable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All Signal-based queries return a Signal and when there are multiple values,
    the Signals returns a regular array. The decorators return a variety of return
    types and when your query returns multiple values, they return a query list instead
    of a regular array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signal-based queries can be used for HTML elements that change over time because
    they are rendered conditionally or outputted in a `for` loop. The directive approach
    has issues with both scenarios and doesn’t automatically notify you when the template
    is updated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TypeScript can automatically infer the type of the queried HTML element or component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that you know about the advantages of query-based Signals compared to the
    directive approach, let’s explore the syntax of query-based Signals. Instead of
    defining a directive, the Signal-based approach works with simple functions. There
    are four different functions: `viewChild()`, `contentChild()`, `viewChildren()`,
    and `contentChildren()`. You provide the functions with your query selector, similar
    to the query selectors you can use in combination with decorators. Here’s an example
    of how to use Signal queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we used the `viewChild()` query Signal to retrieve
    the `<div>` element with the `#el` ID defined on it and the `<my-component>` element.
    Alternatively, if you want to retrieve multiple elements with the same selector,
    you can use the `viewChildren()` function.
  prefs: []
  type: TYPE_NORMAL
- en: With that, you know how to query template elements using the new Signal-based
    approach. You also learned what advantages the new Signals-based approach has
    over decorators. Decorators can still be used if you prefer them or have them
    within your codebase.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned about Signals. You learned how to create, read,
    and update Signals using the `set()` and `update()` methods. Then, we added some
    Signals in `ExpensesOverviewComponent` and learned about computed Signals. Lastly,
    you learned about Signal effects, Signal component inputs, and query Signals.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, you learned about RxJS; in the next section, you will
    learn how you can combine RxJS and Signals.
  prefs: []
  type: TYPE_NORMAL
- en: Combining Signals and RxJS
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you’ve seen how Signals and RxJS can help you manage data
    changes reactively. Both Signals and RxJS allow you to react when values change
    and create new values by combining multiple data streams or performing side effects
    based on data changes. So, the following questions might arise: Do signals replace
    RxJS? And when do I use Signals, and when do I use RxJS?'
  prefs: []
  type: TYPE_NORMAL
- en: RxJS can sometimes feel daunting and complex, so some developers might be tempted
    to replace RxJS with Signals completely. While this might be possible for some
    applications, both RxJS and Signals have their place within your applications
    and solve different problems and needs. In many scenarios, you can devise a solution
    for your problem using Signals or RxJS, but one of the two will do a better job
    at solving the problem and will handle it with much fewer lines of code. Signals
    are not here to replace RxJS, yet Signals will complement it and, in many scenarios,
    work together with your RxJS code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because Signals and RxJS are supposed to co-exist, Angular created two RxJS
    interoperability functions: `toSignal` function.'
  prefs: []
  type: TYPE_NORMAL
- en: Using toSignal
  prefs: []
  type: TYPE_NORMAL
- en: 'The `toSignal` function is used to transform an Observable into a Signal. The
    `toSignal` function is very similar to the `ASYNC` pipe, only with more flexibility
    and configuration options, and it can be used anywhere in the application. The
    syntax is pretty straightforward; you use the `toSignal` function and supply it
    with an Observable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: injector = inject(Injector);
  prefs: []
  type: TYPE_NORMAL
- en: counter = toSignal(this.countObs$, toSignal function with an additional configuration
    object in which we provided the injector property. There may also be scenarios
    where you don’t want the toSignal function to automatically unsubscribe the Observable
    when the component or injection context is destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might want to stop the Observable earlier or later, depending on your system’s
    needs. For this scenario, you can provide the `toSignal` function with a `manualCleanup`
    configuration, similar to the Signal effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: counter = toSignal(this.countObs$, {undefined as your initial value might cause
    problems inside computed signals or Signal effects that use the Signal with the
    undefined value.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, some Observables emit a synchronous value upon subscription;
    think of `BehaviorSubject`, for example. If you use an Observable that emits a
    synchronous value upon subscription, you also need to configure this inside the
    `toSignal` function using the `requireSync` configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: By setting the `requireSync` option to `true`, the `toSignal` function enforces
    that the initial value upon subscription is received synchronously, skipping the
    initial `undefined` value and typing the Signal as `undefined`. Lastly, you can
    configure how the `toSignal` function should handle errors that happen in the
    Observable.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, if the Observable throws an error, the Signal will throw the error
    whenever the Signal is read. You can also set the `rejectErrors` option to `true`;
    in that case, the `toSignal` function will ignore the error and keep returning
    the last good value the Observable emitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: counter = toSignal(this.countObs$);
  prefs: []
  type: TYPE_NORMAL
- en: countObs$ = toObservable function behind the scenes, Angular will use a Signal
    effect to track the values of the Signal you use inside the toObservable function
    and emit the updated values to the Observable. Because Angular uses a Signal effect
    to update the values of the Observable, it will only emit stabilized changes in
    the Signal. So, if you set the Signal multiple times in a row without an interval,
    the Observable that’s created with toObservable will only emit the last value
    when the Signal is stabilized.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the `toObservable` function uses the current injection context
    to create the Signal effect; if you declare the `toObservable` function outside
    the injection context or if you want to create the Signal effect inside another
    injection context, you can provide the `toObservable` function with an injection
    context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: id = input(0);
  prefs: []
  type: TYPE_NORMAL
- en: product = toSignal(
  prefs: []
  type: TYPE_NORMAL
- en: toObservable(this.id).pipe(
  prefs: []
  type: TYPE_NORMAL
- en: switchMap((id) => this.service.getProduct(id as number)),
  prefs: []
  type: TYPE_NORMAL
- en: ),
  prefs: []
  type: TYPE_NORMAL
- en: '{ initialValue: null }'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
