- en: '*Chapter 3*: Hooking into React'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned to perform actions inside a function component
    with our crafted states. In this chapter, we will go through the challenges we
    face in creating a good state solution, and then see how *React* builds the solution
    with the underlying Hook. We will then introduce what a hook is and get to know
    it, as well as its calling order, and learn how to avoid running into conditional
    hook issues in real applications. The chapter also includes two bonus topics in
    the *Appendix* section, *React Fiber* and *Current and WorkInProgress Scenes*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating good state solution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing a React Hook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a hook?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Questions and answers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Appendix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a good state solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: States are quite capable. A component without states is like a function without
    variables. It would lack capabilities of reasoning. A piece of UI logic relies
    on states to work upon continuous interactions from users.
  prefs: []
  type: TYPE_NORMAL
- en: 'We built a custom state in the previous chapter as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Though this approach works, there are a few problems we need to address before
    we can be seriously considered using it with *React*. We'll mention these problems
    one by one as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'The location where the states are allocated is the first major problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `states` variable is allocated as a global variable, but normally
    we'd be first interested in states specific to a component. In other words, we
    need to find a place to define local states.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second problem of using states is the unique key to identify each of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As in the preceding state usage, after we name the state `comp_a`, we have to
    carry this key for any actions involving this state. In a typical application,
    we could have lots of states like that; if each has to be defined with a unique
    string, we would have to come up with a lot of unique names. It would be quite
    some work to keep track of all the used names, not to mention that the variable
    holding the state inside the function component already has a name, `a`. It's
    a bit cumbersome to have both the variable name and key string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other than these two major problems, there are other minor things we need to
    consider. In demonstrating the usage of the state, we render the `Title` component
    when we need to request a new update:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Explicitly knowing which component we need to update for each action we perform
    can be a challenge to developers. It would be better if the engine can help us
    here to hide away this detail by figuring out what the components are that need
    to be updated. This is exactly what *React* does best; we should wire it with
    the engine to perform the right update. Last but not least, we know that the states
    can be used for different purposes since the underlying concept is a persistency
    mechanism. If done properly, we should be able to create some sort of infrastructure
    upon which we can add additional functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding is a list of issues that a good state solution should consider.
    With these in mind, let's take a look at how *React* approaches this state problem.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing a React Hook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The state is mostly local to a component, at least as far as this book is mostly
    concerned. The natural place for storage would be under a component instance because
    a component in *React* defines a piece of UI. So, where is the component instance
    of a function component in *React* stored?
  prefs: []
  type: TYPE_NORMAL
- en: It turns out that a component isn't the smallest unit in *React*. There's a
    more granular structure called fiber, which is used to represent a piece of element.
    A fiber performs all the tasks for this element. The element can be as simple
    as `h1`, `div` elements, or it can be an artificial element that does things differently.
    For instance, a "fragment" element can group other elements without displaying
    itself, or a "memo" element can remember all the elements from the last update.
  prefs: []
  type: TYPE_NORMAL
- en: Actually, a function component is one of the artificial elements that a fiber
    represents. What a function component does is allow us to define what elements
    it can display, so whenever it's invoked, it can figure out what DOM elements
    the screen needs to update. You can find more information in *Appendix A – React
    Fiber* at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, now we find the unit for a component instance; that''s exactly where *React*
    decides to store states. *React* stores them under a `memoizedState` property
    using a Hook structure, as shown in *Figure 3.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Hooks under a fiber'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.01_B17963.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – Hooks under a fiber
  prefs: []
  type: TYPE_NORMAL
- en: The Hook we introduce here is a structure (or a class) to hold a state. This
    is not exactly the *React* hook (function) we will introduce later. Unfortunately,
    *React* uses the same word at both places. To distinguish them, we intentionally
    use *Hook* (with an uppercase *H*) for the structure and *hook* (with a lowercase
    *h*) for the function.
  prefs: []
  type: TYPE_NORMAL
- en: The main functionality of a Hook structure is to hold a single state under the
    `state` property. Instead of having multiple states in an array (or an object),
    multiple states are linked together using a linked list, as shown in *Figure 3.2*.
    One Hook points to another one via its `next` property. When it reaches the end
    of the list, the `next` property of the last Hook is set to be `null`. This is
    how a typical linked list works in programming. The first Hook, if any, is stored
    under the `memoizedState` of the fiber; this way, a fiber can find all Hooks following
    the first one.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Hooks in a Linked List'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.02_B17963.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2 – Hooks in a Linked List
  prefs: []
  type: TYPE_NORMAL
- en: A fiber needs to be updated for the engine to know whether there is any change
    to the screen. In the update function, this is where the Hook gets initialized.
    So next, let's take a look at the update function.
  prefs: []
  type: TYPE_NORMAL
- en: Updating a function component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*React* updates a function component through an `updateFunctionComponent` function.
    The input arguments accept a `Component` function and its `props` input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The main job of the update function is to invoke `Component(props)` to know
    the new `children` element. Taking a `Title` component as an example, when it
    gets to be updated, the `updateFunctionComponent` function invokes `Title()`.
    With that, the engine compares the element returned and what's on the screen and
    commits the difference.
  prefs: []
  type: TYPE_NORMAL
- en: There are two global variables defined in the preceding update function. They
    are quite easy to follow. `updatingFiber` represents the current fiber that is
    under update by the engine, and `prevHook` points to the previously worked Hook
    for this fiber. Before the component is invoked, `updatingFiber` is populated
    by the engine, such as `Title`, and `prevHook` is set to be `null`.
  prefs: []
  type: TYPE_NORMAL
- en: The first time a component is updated, as in a mount, is when the first Hook
    for this fiber is created.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Hook at the mount
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To mount a Hook under the currently updating fiber, *React* creates a new Hook
    object and appends it to the linked list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding `mountHook` function, an empty Hook object is allocated first
    with both `state` and `next` set to `null`. If it's the first Hook to the fiber,
    as `preHook` is `null`, it gets stored under `memoizedState` of the fiber. Otherwise,
    it gets appended to the previous Hook's `next` property. After that, the allocated
    Hook is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining a Hook at the update
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In any other update after the mount, we can access Hooks that *React* created
    at the mount:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding `updateHook` function, a Hook object is obtained by looking
    for the first `memoizedState` Hook under the fiber. After the first Hook, it is
    obtained by following the `next` property of `prevHook`. *React* also keeps `prevHook`
    up to date as we move along the list. The Hook obtained is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Hook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have made the Hook persistent to all updates, we can put it to work
    in a function component, similar to the `_getM` or `_getM2` functions we crafted
    in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a `_useHook` function this time that accepts an `initialState`
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Based on whether the component is under the mount or not via an `isFiberMounting`
    flag, the preceding `_useHook` function obtains a persistent Hook. If it's at
    the mount, *React* assigns `initialState` to the Hook. For any other update, the
    Hook does not get touched. For all cases, `state` under the Hook is returned.
  prefs: []
  type: TYPE_NORMAL
- en: You may wonder how *React* determines the `isFiberMounting` flag; since it's
    wired more deeply with the engine, we put this material in *Appendix B – Current
    and WorkInProgress Scenes* at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: So far we have gone through how *React* implements the Hook under the engine.
    We just bit the hard part, now let us take a look how we can use it.
  prefs: []
  type: TYPE_NORMAL
- en: What is a Hook?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have revealed the stripped-down version of the *React* Hook infrastructure
    and crafted a function using it, let''s give it a spin in a function component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `a` variable is assigned a `0` number upon the mount, and then
    it serves as a state for the rest of the updates.
  prefs: []
  type: TYPE_NORMAL
- en: '`_useHook` is technically a *React* hook function. Though it''s not an officially
    supported one, and we crafted it here to demonstrate the infrastructure, it has
    everything about being a hook function. Let''s take a close look at it.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To distinguish the educational hook that we crafted from the officially supported
    hook, we prefixed the hook name with `_`, as in `_useHook`.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll further explain the nature of a hook being a function as well as its calling
    order in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: A hook is a function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A hook is a function that takes input arguments and returns a value, and it
    carries a `use` name prefix by convention.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we take `useHook` as a generic hook, the following are sample usages of
    hooks with different input arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: A hook takes zero or any number of input arguments. An input argument can be
    used for the initial condition, as the `initialState` parameter in `_useHook`.
    It's important to know that not all input arguments are used for initialization
    purposes because, as you can see in the implementation, input arguments such as
    `initialState` are sent to each update, but it's up to the update whether the
    input argument needs to be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a function, a hook can return a value if needed. The returned value can
    be designed in any format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Not all hooks return a value. If a value is returned, it can be `null`, a number,
    a string, an array, an object, or any JavaScript expression.
  prefs: []
  type: TYPE_NORMAL
- en: Since one return value can become another's input argument, it's not uncommon
    to see a chain usage of hooks, such as the following.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, `i` and `j` are returned from two hooks and then injected
    into another hook to come up with `k` through input arguments. Also, a `text`
    prop is sent to a hook as an input argument. Practically, a hook statement does
    not differ too much from a local assignment statement.
  prefs: []
  type: TYPE_NORMAL
- en: All in all, a hook technically is a function. Don't be intimidated by it just
    because it's a hook. Most of the things you know about functions apply to hooks.
    That being said, a hook is a special function, and it comes with one caveat to
    be aware of – its calling order.
  prefs: []
  type: TYPE_NORMAL
- en: A hook's calling order
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By now, we know that a hook function can be used many times in a function component
    without causing conflicts because each state points to a separate memory space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Remember when we were crafting our naive version of `_getM2` to support multiple
    states, we had to use a key to distinguish the `a` variable from the `b` variable?
    Now, with the Hook infrastructure, we don't do that anymore. Have you wondered
    how it is possible without a state key?
  prefs: []
  type: TYPE_NORMAL
- en: 'At the mount, before a first hook function for `a` is used in the function
    component, there''s no Hook created yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the preceding statement, *React* creates one Hook and puts it
    under the fiber. Then, it sees another hook function for `b`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: After seeing the preceding statement, *React* creates another Hook and puts
    it after the first Hook following the linked list. We are done with the first
    mount update.
  prefs: []
  type: TYPE_NORMAL
- en: Now it comes to the second update; when it sees the first hook function for
    `a` again, it looks into the linked Hooks under the fiber and grabs the first
    Hook. Similarly, when it sees the second hook function for `b`, it continues looking
    into the list and finds the second Hook following the first one.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, *React* does not use a key because the order of the list serves
    as a key and the key is called the calling order of the hooks. As long as the
    first hook for `a` calls first and the second hook for `b` calls second, the location
    of the states stored under the list is marked correctly. So we don't have to consciously
    keep track of the key because after we write all the hook statements, the calling
    order should already be determined.
  prefs: []
  type: TYPE_NORMAL
- en: This design without an explicit key provided by the developer is quite easy
    to use. Except there's one caveat; if we can avoid running into it, this design
    works like a charm practically.
  prefs: []
  type: TYPE_NORMAL
- en: So, here's the caveat. This calling order isn't fixed during the code compilation;
    instead, it's determined at the runtime. What's the difference? The difference
    is that the runtime thing can be changed. To give you an example, we can set up
    a case using an `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional hook issue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s say we have the following `Title` component with two usages of hooks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code logic, what we intend to do is store the `'a'` and `'b'`
    chars in the `a` and `b` variables, respectively. Except, when the flag is `false`,
    an empty char `' '` is stored in the `a` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'To confirm whether the code works, let''s make two updates to this component
    while flipping the `flag` prop. Suppose for the first update that the `flag` prop
    is set as `true` and for the second update, it gets changed to `false`. For this
    setup, it generates the following timeline sketch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: At the first update, both `a` and `b` variables were assigned correctly. But
    when it came to the second update, the `b` variable was set to the `'a'` char.
    This is a bit weird since we never asked to set the `'a'` char to the `b` variable
    in the code. How could that happen?!
  prefs: []
  type: TYPE_NORMAL
- en: 'How could a `_useHook(''b'')` statement end up returning an `''a''` char, and
    where does the `''a''` char even come from? To answer the questions, we need to
    dig down into the Hooks under the fiber behind the `Title` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding timeline sketch, we printed out the states stored under two
    Hooks. `Hook1` stored the `''a''` char and `Hook2` stored the `''b''` char for
    both updates. Let''s take a close look at the second update; what the compiler
    sees is the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding arrangement of the code, we hardcode the `flag` prop with
    `false`. Because of that, the first usage of a hook for `a` is omitted, and we
    end up with one hook statement for `b` only. You can see this information in *Figure
    3.3*, where we have both Hooks and what each hook statement reads:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Conditional Hook mismatch I'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.03_B17963.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.3 – Conditional Hook mismatch I
  prefs: []
  type: TYPE_NORMAL
- en: In the first update, the `a` and `b` variables read from `Hook1` and `Hook2`.
    But in the second update, due to the first hook statement going, the `b` variable
    shifts and reads from `Hook1`. In this update, nothing reads from `Hook2` either.
    Therefore, the `b` variable reads the `'a'` char now.
  prefs: []
  type: TYPE_NORMAL
- en: Playground – Conditional hook I
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to play with this online example at [https://codepen.io/windmaomao/pen/RwLrxbp](https://codepen.io/windmaomao/pen/RwLrxbp).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we changed the `flag` prop from `T` to `F`; we can also test
    this conditional case by changing the `flag` prop from `F` to `T`. Let''s look
    at the timeline sketch if we do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding run, we printed out the `a` and `b` variables as well as
    two Hooks states. You can see that the `a` variables read the `''b''` char in
    the second update! We can make the case clearer using *Figure 3.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Conditional Hook mismatch II'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.04_B17963.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 – Conditional Hook mismatch II
  prefs: []
  type: TYPE_NORMAL
- en: What happened to this case is the following. In the first update, we had one
    hook usage for `b` since the flag is `F`. Since this is the mount, the `'b'` char
    was initialized to `Hook1`, and `Hook2` was omitted. When it came to the second
    update, since `Hook1` had been initialized already, the value can't be initialized
    again, thus it continued to hold the `'b'` char. And `Hook2` this time got finally
    initialized with the `'b'` char. This is why both `a` and `b` stored the `'b'`
    char after the second update. Pretty mind-blowing, isn't it? In a way, this case
    is worse than the previous one, of course; both are incorrectly implemented.
  prefs: []
  type: TYPE_NORMAL
- en: From these two cases, we can conclude that using the `if` statement with the
    hook statement leads to strange behavior. And this is all because the calling
    order of hooks gets changed from update to update, hence the state keys get messed
    up and the states can't be read as intended.
  prefs: []
  type: TYPE_NORMAL
- en: Playground – Conditional hook II
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to play with this online example at [https://codepen.io/windmaomao/pen/oNGbEzq](https://codepen.io/windmaomao/pen/oNGbEzq).
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, it''s not only `if`; any hook statement involving a condition cannot
    be used. Here''s another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we embedded a hook inside a loop iterating an `arr` array.
    Guess how many hook statements we would run into for this case? Not sure? Yes,
    you guessed right – we don't know how many elements the `arr` prop contains; it
    can only be determined at runtime. We will not walk through this case in detail,
    but you can see the code can easily run into a strange issue if the length of
    `arr` changes from 0 to 1, or 1 to 2, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '*React* gives their recommendation in their documentation online: *"Don''t
    call hooks inside loops, conditions, or nested functions. Instead, always use
    hooks at the top level of your React function, before any early returns."* Now
    you have a deeper understanding of why they said that.'
  prefs: []
  type: TYPE_NORMAL
- en: '*React* is fully aware of the severity of this issue because it could jeopardize
    the usage of a hook. Therefore, at the code compilation, the compiler actually
    alerts the developer when it spots the usage of conditional hook usage. Moreover,
    if it ever misses catching the case, at runtime, *React* monitors the hook list
    to find out whether there''s any messing up of hook orders upon a new update.
    If it finds one, you see a warning, as shown in *Figure 3.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – React runtime warning for a conditional hook'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.05_B17963.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.5 – React runtime warning for a conditional hook
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding conditional hooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So now we know we shouldn't have written any conditional hook statements, but
    how can we avoid it? Or, put another way, if we must implement some conditional
    logic involving hooks, what's the right way to do it?
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this problem isn't difficult. We can still write conditional
    statements, just not conditional hook statements. As long as we have a fixed number
    of hooks and a consistent calling order, we can write the hook statement however
    we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to fix our examples, starting with setting `flag` from `T` to `F`
    first. Instead of declaring `_useHook` conditionally, we can declare two of them
    beforehand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we use an auxiliary `_a` variable to hold an `'a'` char.
    The `b` variable holds a `'b'` char as before. This way, no matter what, both
    hooks are maintained with a fixed calling order in all updates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, with that, we can relocate the conditional logic part for `a` after the
    hook statements. We can verify whether this works by looking at the generated
    timeline sketch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can generate the timeline for changing `flag` from `F` to `T`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Both cases turn out to be correctly implemented now. The `a` variable can hold
    the `'a'` char or an empty `' '` based on `flag`, and the `b` variable holds the
    `'b'` char always.
  prefs: []
  type: TYPE_NORMAL
- en: Playground – Conditional hook I
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to play with this online example at [https://codepen.io/windmaomao/pen/KKXVQWV](https://codepen.io/windmaomao/pen/KKXVQWV).
  prefs: []
  type: TYPE_NORMAL
- en: Playground – Conditional hook II
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to play with this online example at [https://codepen.io/windmaomao/pen/MWEKQQJ](https://codepen.io/windmaomao/pen/MWEKQQJ).
  prefs: []
  type: TYPE_NORMAL
- en: 'This writing of moving hook statements to the front of the function is recommended
    by *React*, and it can be applied to the loop case as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we don't know the length of `arr`, so it's better not
    to loop through each hook statement inside the loop. Instead, we can store the
    entire `arr` to a state and then iterate this array afterward. This way, we eliminate
    the possibility of having a variable number of hook statements.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, the previously mentioned caveat is the only issue *React* hooks have,
    and if we run into a conditional statement, we can apply the "right" way by putting
    the hook statement on the front of the function.
  prefs: []
  type: TYPE_NORMAL
- en: In short, a *React* hook is a special function that allows persistent states
    for a function component. Out of the box, *React* provides quite a few hooks based
    on this infrastructure. Starting in the next chapter, we will get to know some
    of the common ones in detail, including `useState`, `useEffect`, `useMemo`, `useContext`,
    and `useRef`. And in [*Chapter 9*](B17963_09_Epub.xhtml#_idTextAnchor314), *Use
    Custom Hooks to Reuse Logic*, we will get toknow how to create our own custom
    hooks to meet our specific needs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned what makes a good state solution, and got
    to know how *React* builds the Hook to provide this solution. You also learned
    what a hook is and its calling order, as well as how to avoid running into a conditional
    hook issuein real applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will get into our first hook in the *React* family,
    with which *React* allows us to define a state to drive a UI display.
  prefs: []
  type: TYPE_NORMAL
- en: Questions and answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some questions and answers to refresh your knowledge:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a *React* hook?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A *React* hook is a special function that allows us to have persistent states
    for a function component. The calling order of hooks is used as an internal key
    of the states, thus, when we use hooks, we don't need to specify a key. We can
    have as many hooks as we want under one function component, and each hook can
    be used for a different purpose.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How can we avoid conditional hooks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each hook with a specific calling order gets stored under the hook list. *React*
    doesn't allow the change of this calling order at runtime, thus we should avoid
    it when using hooks inside a condition, a loop, or any structure that varies its
    calling order. Instead, we can move all hook statements to the front section of
    the function to pre-bake their calling orders while leaving the conditional logic
    afterward before the return statement.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Appendix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Appendix A – React Fiber
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: During the user session with a website, a series of actions is generated. We'd
    expect to have these actions dispatched and have changes applied back to the **Document
    Object Model** (**DOM**). This cycle is what makes it a typical web experience.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – React Fiber with Render and Commit phrases'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.06_B17963.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.6 – React Fiber with Render and Commit phrases
  prefs: []
  type: TYPE_NORMAL
- en: What *React* does for us is to allow the dispatched action to update the changes
    to be reflected on the screen. *React* splits each update into two major phrases,
    the **Render** and the **Commit**, illustrated in the preceding figure. What a
    render does is go through all elements one by one and collect all the changes,
    whereas a commit applies the changes to the UI in one shot.
  prefs: []
  type: TYPE_NORMAL
- en: This engine has a codename, *Fiber*. To facilitate all this, *React* creates
    an internal object called a fiber to represent each element. As we have introduced,
    the element can be a classical element, such as a DOM element, or an artificial
    one, such as a function component. The benefits of having a layer between the
    physical DOM and *React* element are twofold.
  prefs: []
  type: TYPE_NORMAL
- en: A function component (or a class component) is easier for developers to organize
    their UI as well as their logic into a functional unit. Having a fiber wrapping
    a unit like that can offer some generic element behavior as well as add special
    handling to a specific element. For instance, we have introduced `updateFunctionComponent`
    for updating a function component, but for other elements, there are different
    update functions.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, adding an extra layer to the UI engine allows optimization.
    In fact, React Fiber does not update to the screen blindly. In the first update,
    as in the mount, each fiber is created and all DOM elements get created from scratch.
    This update should be very close to the classical update.
  prefs: []
  type: TYPE_NORMAL
- en: However, everything else differs afterward. For a new update, the assumption
    is that only a small part of the screen needs adjusting. So, before *React* updates
    the screen, it goes through all fibers stored in the previous update and compares
    them with the new rendered elements. This comparison is referred to as reconciliation,
    which is to compare the new elements with previous DOM elements to come up with
    the new DOM changes that need to be applied in this update. *React* makes this
    reconciliation very efficient so that only necessary changes are applied to the
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: The optimization is not only limited to reconciliation. To make sure things
    can be done efficiently, a fiber also serves as a unit of work. During each update,
    all fibers are sent to a pipeline where each fiber gets worked on one by one.
    There are certain advantages of doing that. The update work thus isn't treated
    as one or nothing anymore. The engine can finish 9 out of 10 units without hurting
    the integrity of the update job because it can now pause when it's out of resources
    and come back to finish the last unit once it gets enough computational time.
    One of the direct benefits is gaining a quick response to more urgent work in
    the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Appendix B – Current and WorkInProgress Scenes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we said that *React* internally creates a fiber for each element, we lied.
    Actually, for each element, *React* creates two fibers, and the name for these
    two fibers are `current` and `workInProgress`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine the user screen is like a stage with a curtain. The stage facing the
    audience is a current scene, while there''s another work-in-progress scene behind
    the curtain where it can prepare what''s next to show to the audience. While the
    audience enjoys watching the current scene, the work-in-progress scene is getting
    prepared at the same time. Only when the time is right is there a wheeler that
    rotates the current scene behind and pushes the work-in-progress scene to face
    the audience, as shown in *Figure 3.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – React two scenes with current and workInProgress'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.07_B17963.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.7 – React two scenes with current and workInProgress
  prefs: []
  type: TYPE_NORMAL
- en: This is a well-known mechanism behind any show business, including a computer
    screen. *React* is no exception. In order to facilitate the smoothness of a screen
    transition before/after the commit, it uses two scenes in memory, named `current`
    and `workInProgress`.
  prefs: []
  type: TYPE_NORMAL
- en: Initially, both scenes are empty, since the show hasn't started yet. We work
    on the `workInProgress` scene while `current` is empty; this step is called the
    `workInProgress` is done, the stage rotates so that `workInProgress` becomes `current`.
    In programming, it's just a pointer assignment.
  prefs: []
  type: TYPE_NORMAL
- en: Upon any future action, the `workInProgress` scene starts to be prepared again.
    This time, `workInProgress` doesn't need to be created from scratch since it can
    clone unchanged things from `current`, and this step is called the `workInProgress`
    is done, the stage rotates so that `workInProgress` becomes the new `current`
    scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'During either the mount or the update, we pick `workInProgress` to work for
    the future scene while leaving `current` as the finished work from last time,
    except that during the mount, there''s nothing in `current`. So, to tell whether
    any component is under the mount or the update, we can check whether `current`
    is empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Unless you work on the engine, you wouldn't be given two scenes at the same
    time since the developer outside of the core works on `workInProgress` while the
    user watches `current`. To all of them, there's only one scene.
  prefs: []
  type: TYPE_NORMAL
