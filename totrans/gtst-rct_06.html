<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;6.&#xA0;Reacting with Flux"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06" class="calibre1"/>Chapter 6. Reacting with Flux</h1></div></div></div><p class="calibre7">So far in the previous chapters, we have dug deep into the react world. Let's now explore the new dimension of react world, Flux, which is nothing but a unidirectional dataflow architecture. Flux is developed by the Facebook internal development team and is used in order to build client-side web applications at Facebook.</p><p class="calibre7">We will cover the following topics as we go along:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The synopsis of Flux versus the MVC architecture</li><li class="listitem">Actions</li><li class="listitem">Dispatchers</li><li class="listitem">Stores</li><li class="listitem">Controller-Views and Views</li></ul></div></div>

<div class="book" title="Chapter&#xA0;6.&#xA0;Reacting with Flux">
<div class="book" title="An overview of Flux"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch06lvl1sec29" class="calibre1"/>An overview of Flux</h1></div></div></div><p class="calibre7"><span class="strong"><strong class="calibre8">Flux</strong></span> should<a id="id195" class="calibre1"/> not be confused as a framework based on ReactJS. Flux is an architecture and is designed in order to reduce the complexity of a huge application built with <span class="strong"><strong class="calibre8">Model View Controller</strong></span> (<span class="strong"><strong class="calibre8">MVC</strong></span>) architecture and has been designed <a id="id196" class="calibre1"/>as an alternative of MVC.</p><p class="calibre7">The following <a id="id197" class="calibre1"/>are the different Flux components:</p><div class="book"><ul class="itemizedlist"><li class="listitem">View—This is like for any web app, the views (basically the react component) receives the event and passes it to the Actions</li><li class="listitem">Action—They are helper methods (<code class="literal">actionCreators</code>) that pass the data (payload) and <code class="literal">actionType</code>, received from an external API/view to a dispatcher</li><li class="listitem">Dispatcher—These are Central hub of all registered callbacks. It receives the actions and acts as a "traffic controller" before it passes it to the Stores</li><li class="listitem">Store—It is a data layer that stores all the computations and business logic. It is also responsible for storing the application state and the single source of truth for <a id="id198" class="calibre1"/>the application state. It receives the action from the<a id="id199" class="calibre1"/> dispatchers based on the registered callbacks.</li><li class="listitem">Controller-View—This receives the state from the stores based on the <code class="literal">changeEvents</code> and passes it to the React views component via props.</li></ul></div><p class="calibre7">A diagram here illustrates this:</p><div class="mediaobject"><img src="../images/00033.jpeg" alt="An overview of Flux" class="calibre9"/><div class="caption"><p class="calibre25">Typical Flux Data Flow Architecture</p></div></div><p class="calibre10"> </p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Flux versus the MVC architecture"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec30" class="calibre1"/>Flux versus the MVC architecture</h1></div></div></div><p class="calibre7">In a<a id="id200" class="calibre1"/> typical application built on the MVC architecture, the views get updated from the data, which is typically stored in the models. As the application grows, the number of models and views also grow, and there grows the interdependency among the various models. Therefore the views also get tdependent on multiple models, thus increasing the complexity of the application.</p><p class="calibre7">The interdependence of views and models can create diffraction in the source of truth, leading to increased application complexity and unpredictability. As a result, there needs to be a solution to internalize the control by moving all the control into the individual pieces.</p><div class="mediaobject"><img src="../images/00034.jpeg" alt="Flux versus the MVC architecture" class="calibre9"/><div class="caption"><p class="calibre25">Issue with a growing app built with MVC</p></div></div><p class="calibre10"> </p></div>

<div class="book" title="Flux versus the MVC architecture">
<div class="book" title="Flux advantages"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch06lvl2sec46" class="calibre1"/>Flux advantages</h2></div></div></div><p class="calibre7">According to<a id="id201" class="calibre1"/> the Facebook Flux development team, the objects within a Flux application are highly decoupled, and adhere very strongly to the first part of the Law of Demeter: the principle that each object within a system should know as little as possible about the other objects in the system. This results in software that is more.</p><div class="book"><ul class="itemizedlist"><li class="listitem">Maintainable</li><li class="listitem">Adaptable</li><li class="listitem">Testable</li><li class="listitem">Easier and more predictable for new engineering team members to understand</li></ul></div><p class="calibre7">The following is a Flux application structure of our <code class="literal">library_app</code> application.</p><div class="mediaobject"><img src="../images/00035.jpeg" alt="Flux advantages" class="calibre9"/><div class="caption"><p class="calibre25">Our Library App Structure</p></div></div><p class="calibre10"> </p></div></div>

<div class="book" title="Flux versus the MVC architecture">
<div class="book" title="Flux components"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch06lvl2sec47" class="calibre1"/>Flux components</h2></div></div></div><p class="calibre7">Let's dive<a id="id202" class="calibre1"/> into an application, built with Flux architecture with React View. Here, we will be building an app named <code class="literal">library_app</code>. This is a basic Flux-based ReactJS app, where we can borrow books from the <code class="literal">library_app</code> store to our reading list. Once we finish the book, we can strike it off from our reading list.</p><div class="informaltable" title="Note"><h3 class="title2"><a id="note21" class="calibre1"/>Note</h3><p class="calibre7">From  the command line execute:</p><div class="informaltable"><pre class="programlisting">
<span class="strong"><strong class="calibre8">sudo npm install flux</strong></span>
</pre></div><p class="calibre7">The above will install the flux package as a node module and your library_app application will have a directory called node_modules with the flux library installed within it.</p></div></div></div>
<div class="book" title="Actions"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec31" class="calibre1"/>Actions</h1></div></div></div><p class="calibre7"><span class="strong"><strong class="calibre8">Actions</strong></span> are<a id="id203" class="calibre1"/> typically the data that enters into an application, either directly from the View or from an external Web API. Each action is nothing but a JavaScript method, which contains two parts: the <code class="literal">actionType</code> and the actual data. The <code class="literal">actionCreators</code> methods are simply discrete, semantic helper functions that facilitate passing data to the <span class="strong"><em class="calibre12">dispatcher</em></span> in the form of an <span class="strong"><em class="calibre12">action</em></span>. The different types of actions are declared as a JavaScript object, in a file named <code class="literal">App-Constants.js</code>. According to the Flux app hierarchy, the <code class="literal">App-Contstants.js</code> file resides under <code class="literal">src/js/constants</code>. Typical example for such a file looks like the following:</p><div class="informaltable"><pre class="programlisting">module.exports = {
<span class="strong"><strong class="calibre8">        ADD_BOOK: 'ADD_BOOK',</strong></span>
<span class="strong"><strong class="calibre8">        DELETE_BOOK: 'DELETE_BOOK',</strong></span>
<span class="strong"><strong class="calibre8">        INC_BOOK_COUNT: 'INC_BOOK_COUNT',</strong></span>
<span class="strong"><strong class="calibre8">        </strong></span>
<span class="strong"><strong class="calibre8">DEC_BOOK_COUNT: 'DEC_BOOK_COUNT'</strong></span>
}</pre></div><p class="calibre7">Here, <code class="literal">ADD_BOOK</code>, <code class="literal">DELETE_BOOK</code> are the actions.</p><div class="informaltable" title="Note"><h3 class="title2"><a id="note23" class="calibre1"/>Note</h3><p class="calibre7">Actions, by itself, do not contain any functionality of their own. Actions are typically executed by the stores and are available in order to trigger the views. In React, we have handful of helper methods named <code class="literal">actionCreators</code>, which ideally creates the action object and passes the action to the Flux dispatcher (<code class="literal">AppDispatcher</code>).</p></div><p class="calibre7">All the<a id="id204" class="calibre1"/> actions defined in the <code class="literal">AppConstants</code> are declared in the <code class="literal">AppActions</code>.</p><p class="calibre7">The use of constants in the <code class="literal">AppConstants</code>, which declares the action names, helps the developer to understand the app's functionality. As in our case, it deals with books.</p><p class="calibre7">In the following example while adding books in a <code class="literal">library_app</code> store, we are dealing with four <code class="literal">actionTypes</code>:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="literal">ADD_BOOK</code></li><li class="listitem"><code class="literal">DELETE_BOOK</code></li><li class="listitem"><code class="literal">INC_BOOK_COUNT</code></li><li class="listitem"><code class="literal">DEC_BOOK_COUNT</code></li></ul></div><p class="calibre7">The actions (such as <code class="literal">addBook</code>, <code class="literal">removeBook</code>, <code class="literal">incBookCount</code>, and <code class="literal">decBookCount</code>) are unique based on their <code class="literal">actionType</code> attribute. Thus, when these actions are dispatched by the dispatchers to the stores, stores mutates themselves depending on the specific callback registered with the dispatchers.</p><p class="calibre7">Typical action file resides in <code class="literal">library_app/src/js/actions/app-actions.js</code>:</p><div class="informaltable"><pre class="programlisting">var AppConstants = require('../constants/app-constants');
var AppDispatcher = require('../dispatchers/app-dispatchers');

var AppActions = {
  addBook:function(item){
        AppDispatcher.handleViewAction({
          actionType: AppConstants.ADD_BOOK,
          item: item
        })
  },
  removeBook:function(index){
        AppDispatcher.handleViewAction({
          actionType: AppConstants.REMOVE_BOOK,
          index: index
        })
  },
  incBookCount:function(index){
        AppDispatcher.handleViewAction({
          actionType: AppConstants.INC_BOOK_COUNT,
          item: index
        })
  },
  decBookCount:function(index){
        AppDispatcher.handleViewAction({
          actionType: AppConstants.DEC_BOOK_COUNT,
          item: index
        })
  }
}

module.exports =  AppActions;</pre></div></div>
<div class="book" title="Dispatchers"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec32" class="calibre1"/>Dispatchers</h1></div></div></div><p class="calibre7">As the <a id="id205" class="calibre1"/>name aptly defines, <span class="strong"><strong class="calibre8">Flux dispatchers</strong></span> dispatches the actions to the <a id="id206" class="calibre1"/>subsequent stores. Dispatchers can be called as a registry of callbacks. All the stores are registered with the dispatchers.</p><p class="calibre7">Some key points of dispatcher are the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem">There is only one dispatcher per app.</li><li class="listitem">Dispatchers being used as a center for all the registered callbacks.</li><li class="listitem">It functions as a broadcaster of all the actions to the stores. Dispatchers acts as a queue, which sequentially broadcasts the actions. This is different from generic pub-sub systems in the following two ways:<div class="book"><ol class="orderedlist1"><li class="listitem" value="1">Callbacks are not subscribed to particular events. Every payload is dispatched to every registered callback.</li><li class="listitem" value="2">Callbacks can be deferred in whole or part until other callbacks have been executed.</li></ol><div class="calibre22"/></div></li><li class="listitem">The dispatcher has the capability to invoke the callbacks in the order specified, and it waits for other updates (<code class="literal">waitFor()</code> method does that).</li><li class="listitem">In the flux library (<code class="literal">npm install flux</code>) <code class="literal">node_module</code>, the <code class="literal">register()</code> and <code class="literal">dispatch()</code> methods are defined, in the flux <code class="literal">library_app</code>, within the dispatcher class.</li></ul></div><p class="calibre7">See the file located at <code class="literal">library_app/node_modules/Flux/lib/Dispatcher.js</code>:</p><div class="informaltable"><pre class="programlisting">   // Registers a callback to be invoked with every dispatched payload. Returns
   // a token that can be used with `waitFor()`.   

  Dispatcher.prototype.register = function register(callback) {
    var id = _prefix + this._lastID++;
    this._callbacks[id] = callback;
    return id;
  };</pre></div><p class="calibre7">Thus, when <a id="id207" class="calibre1"/>the dispatchers receive the trigger (actions) from the Actions, it dispatches all the actions to the registered stores, one by one. This dispatching-flow is initiated with the <code class="literal">dispatch()</code> method, which passes the payload (data) to the registered store and has the callback registered to it.</p><p class="calibre7">The following code is an excerpt from the <code class="literal">Flux.js</code> library within the <code class="literal">node_modules</code> for the dispatcher:</p><div class="informaltable"><pre class="programlisting">  /**
   * Dispatches a payload to all registered callbacks. The highlighted code below ensures the fact that dispatches cannot be triggered in the middle of another dispatch.

   */

<span class="strong"><strong class="calibre8">  Dispatcher.prototype.dispatch = function dispatch(payload) {</strong></span>
<span class="strong"><strong class="calibre8">    !!this._isDispatching ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Dispatch.dispatch(...): Cannot dispatch in the middle of a dispatch.') : invariant(false) : undefined;</strong></span>
    this._startDispatching(payload);
    try {
      for (var id in this._callbacks) {
        if (this._isPending[id]) {
          continue;
        }
        this._invokeCallback(id);
      }
    } finally {
      this._stopDispatching();
    }
  };</pre></div><p class="calibre7">Let's create <code class="literal">AppDispatcher</code> for our <code class="literal">BookStore</code> app now.</p><p class="calibre7">The file <code class="literal">app-dispatcher.js</code> file should be created under the dispatcher directory of the <code class="literal">src</code>.</p><div class="informaltable" title="Note"><h3 class="title2"><a id="note24" class="calibre1"/>Note</h3><p class="calibre7"><code class="literal">AppDispatcher</code> is an instance of the dispatcher from the Flux package with some additional properties (action in this case).</p><p class="calibre7">It has the <code class="literal">handleViewAction</code> method, which passes the action to be passed to the registered store via the callback.</p></div><p class="calibre7">The following <a id="id208" class="calibre1"/>is the code snippet from our app specific <code class="literal">app-dispatcher</code> class.</p><p class="calibre7">The file location is at <code class="literal">library_app/src/js/dispatchers/app-dispatchers.js</code>:</p><div class="informaltable"><pre class="programlisting">var Dispatcher = require('flux').Dispatcher;
var assign = require('react/lib/Object.assign');

var AppDispatcher = assign(new Dispatcher(),{
        handleViewAction: function(action){
          console.log('action',action);
          this.dispatch ({
            source: 'VIEW_ACTION',
            action: action
          })
        }
});

module.exports = AppDispatcher;</pre></div><p class="calibre7">Before implementing the <code class="literal">library_app</code> store, let's check whether our payload (data) is printing out in the console. In order to do so, a handler function is created in the React <code class="literal">component app.js</code>, which is called when any part of the heading <span class="strong"><strong class="calibre8">My First Flux App</strong></span> is clicked.</p><p class="calibre7">The file location is <code class="literal">library_app/src/js/components/app.js</code>:</p><div class="informaltable"><pre class="programlisting">var React = require('react');
var ReactDOM = require('react-dom');

//call the AppActions directly, before creation of the Store
var AppActions = require('../actions/app-actions');

//create a App component
var App = React.createClass({
        handler: function(){
          AppActions.addBook('This is the book..Sherlock Holmes')
        },
        render:function(){
          return &lt;h1 onClick={this.handler}&gt;My First Flux App &lt;/h1&gt;
        }

});
module.exports = App;</pre></div><div class="informaltable" title="Note"><h3 class="title2"><a id="note25" class="calibre1"/>Note</h3><p class="calibre7">Run the httpster from your application's root directory:</p><div class="informaltable"><pre class="programlisting">
<span class="strong"><strong class="calibre8">doel@doel-Vostro:~/reactjs/ch6_flux_library$httpster</strong></span>
<span class="strong"><strong class="calibre8">Starting HTTPster v1.0.1 on port3333 from /home/doel/reactjs/ch6_flux_library</strong></span>
</pre></div></div><p class="calibre7">Open the<a id="id209" class="calibre1"/> browser and check the console, after clicking on the heading:</p><div class="mediaobject"><img src="../images/00036.jpeg" alt="Dispatchers" class="calibre9"/><div class="caption"><p class="calibre25">A screenshot from library_app</p></div></div><p class="calibre10"> </p><p class="calibre7">For a quick <a id="id210" class="calibre1"/>recap about the flow of our bookstore app till now:</p><p class="calibre7">The default <code class="literal">index.html</code> page serves the static content (Sample Application) on <code class="literal">localhost:3333</code></p><p class="calibre7">The <code class="literal">index.html</code> page internally calls the <code class="literal">main.js</code>, which internally creates the React class and renders the content in the <code class="literal">&lt;App /&gt;</code> React component (from the <code class="literal">src/js/components/app.js</code>). The React component is rendered in the <code class="literal">div</code> tag with ID <code class="literal">main</code></p><p class="calibre7">Once we click on any portion of the <code class="literal">&lt;App /&gt;</code> component (<span class="strong"><strong class="calibre8">My First Flux App</strong></span>), an <code class="literal">onClick</code> event handler triggers the <code class="literal">handler()</code> function, which calls, <code class="literal">AppActions.addBook</code> (<code class="literal">This is the book..Sherlock Holmes</code>), here, <code class="literal">AppActions</code> in the <code class="literal">AppConstant</code>. <code class="literal">AddBook</code> is the specific action to be called with the <code class="literal">payload / item/ data</code> (<code class="literal">This is the book..Sherlock Holmes</code>).</p><p class="calibre7">Once <code class="literal">AppActions.addBook</code> method is called, it is assigned to the callback <code class="literal">handleViewAction</code> of the dispatcher, with the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="literal">actionType</code>: <code class="literal">AppConstants.ADD_BOOK</code></li><li class="listitem"> <code class="literal">item</code>: <code class="literal">This is the book..Sherlock Holmes</code></li><li class="listitem">The <code class="literal">handleViewAction</code> method of the dispatcher passes the action (with <code class="literal">action_type</code> and <code class="literal">item</code>) and logs the output in the console and dispatches it.</li><li class="listitem">We see the following <a id="id211" class="calibre1"/>output in the <code class="literal">console.log</code> after clicking on <span class="strong"><strong class="calibre8">My First Flux App</strong></span>:<p class="calibre24"><code class="literal">action Object { actionType: "ADD_BOOK", item: "This is the book..Sherlock Holmes" }</code></p></li><li class="listitem">This is just a way to pass the JS objects (<code class="literal">item: "This is the book..Sherlock Holmes"</code>) in a uniform and expected manner for the store to handle. It simplifies the data flow of the application and makes tracing and debugging easier.</li></ul></div></div>
<div class="book" title="Stores"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec33" class="calibre1"/>Stores</h1></div></div></div><p class="calibre7">Flux stores<a id="id212" class="calibre1"/> can be comparable with the models in MVC, though essentially they are not the same. From similar point of view, they are the same as all the business logic and computations happen in the Flux store. According to the Facebook team, "Stores manage the state of many objects—they do not represent a single record of data like ORM models do. Nor they are the same as Backbone's collections. More than simply managing a collection of ORM-style objects, stores manages the application state for a <a id="id213" class="calibre1"/>particular <span class="strong"><strong class="calibre8">domain</strong></span> within the application."</p><p class="calibre7">Source <a class="calibre1" href="https://en.wikipedia.org/wiki/Object-relational_mapping">https://en.wikipedia.org/wiki/Object-relational_mapping</a>.</p><div class="blockquote"><blockquote class="blockquote1"><p class="calibre23"><span class="strong"><em class="calibre12">Object Relational Mapping (ORM)  in computer science is a programming technique for converting data between incompatible type systems in object-oriented programming languages. This creates, in effect, a "virtual object database" that can be used from within the programming language. In object-oriented programming, data management tasks act on object-oriented (OO) objects that are almost always nonscalar values. For example, consider an address book entry that represents a single person along with zero or more phone numbers and zero or more addresses. This could be modeled in an object-oriented implementation by "Person object" with attributes/fields to hold each data item that the entry comprises: the person's name, a list of phone numbers, and a list of addresses. The list of phone numbers would itself contain "PhoneNumber objects" and so on. The address book entry is treated as a single object by the programming language (it can be referenced by a single variable containing a pointer to the object, for instance). Various methods can be associated with the object, such as a method to return the preferred phone number, the home address, and so on.</em></span></p></blockquote></div><p class="calibre7">The store(s) receives the action(s) from the dispatchers. Depending on the registered callback (with the dispatcher), the Store decides whether it should respond to the action dispatched by the dispatcher. No objects outside the app are responsible for changing the values within <a id="id214" class="calibre1"/>the Store or the Views. Thus any change, which is brought by the actions, results in the data change based on the registered callbacks and never by any setter methods.</p><p class="calibre7">As the Flux stores update themselves without any external intervention, hence it reduces the complexities typically found in MVC applications. The Flux stores controls what happens within them, only the input is via the dispatchers. In a MVC app, interdependency of various models with various views may lead to instability and complicated test cases.</p><p class="calibre7">A single app can have multiple stores, based on its functionality, but each store deals with a single domain. A store exhibits characteristics of both collection of models and a singleton model of a logical domain.</p><p class="calibre7">The following <a id="id215" class="calibre1"/>is quick recap of Stores Functionality:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Stores register itself with the dispatchers through callbacks.</li><li class="listitem">Computations of the business logic reside in the stores as JS functions.</li><li class="listitem">After the action been dispatched from the dispatcher to the Stores, they are identified by the registered callbacks.</li><li class="listitem">The action is acted upon within stores by the state update.</li><li class="listitem">JS arrays: <code class="literal">_library</code> and <code class="literal">_readingItems</code> store the books available and what the reader wants to read.</li><li class="listitem"><code class="literal">EventEmitter</code> is a class of the events module, which is part of the Node.js core library. In this example, the event emitter function is done by the <code class="literal">eventEmitter.on()</code> method, where the first argument is the event, and the second argument is the function to be added. Thus, the <code class="literal">eventEmitter.on()</code> method simply registers the function. When the the <code class="literal">emit()</code> method is called, then it executes all the functions that are registered with the on method.</li><li class="listitem">The public methods <code class="literal">getReadingList()</code> and <code class="literal">getLibrary()</code> allow us to get the computed data from the <code class="literal">_readingItems</code> and <code class="literal">_readingList</code> JS arrays.</li><li class="listitem"><code class="literal">dispatcherIndex</code> in the <code class="literal">app-stores.js</code> code is used in order to store the return value of the dispatcher's registration method.</li><li class="listitem">The switch statement is the determining factor, in case of a dispatcher's broadcast, for what actions has to be performed. If a relevant action is taken, a change event is emitted and views that are listening for this event update their states.</li></ul></div><p class="calibre7">The following<a id="id216" class="calibre1"/> is the code for <code class="literal">app_stores.js</code> for our <code class="literal">library_app</code>. It has all the business logic and computations of our app:</p><div class="informaltable"><pre class="programlisting">var AppDispatcher = require('../dispatchers/app-dispatchers');
var AppConstants = require('../constants/app-constants');
var assign = require('react/lib/Object.assign');

//eventEmitter allows the Stores to listen/broadcast changes to the 
//Controller-Views/React-Components
var EventEmitter = require('events').EventEmitter;

var CHANGE_EVENT = 'change';

var _library = [];

for(var i=1; i&lt;6; i++){
  _library.push({
    'id': 'Book_' + i,
    'title':'Sherlock Holmes Story ' + i,
    'description': 'Sherlock Series by Sir Arthur Conan Doyle'
  });
}

var _readingItems = [];

function _removeItem(index){
  _readingItems[index].inReadingList = false;
  _readingItems.splice(index, 1);
}

function _increaseItem(index){
  _readingItems[index].qty++;
}

function _decreaseItem(index){
  if(_readingItems[index].qty&gt;1){
    _readingItems[index].qty--;
  }
  else {
    _removeItem(index);
  }
}

function _addItem(item){
  if(!item.inReadingList){
    item['qty'] = 1;
    item['inReadingList'] = true;
    _readingItems.push(item);
  }
  else {
    _readingItems.forEach(function(cartItem, i){
      if(cartItem.id===item.id){
        _increaseItem(i);
      }
    });
  }
}
var AppStore = assign(EventEmitter.prototype, {
  emitChange: function(){
    this.emit(CHANGE_EVENT)
  },
  addChangeListener: function(callback){
    this.on(CHANGE_EVENT, callback)
  },
  removeChangeListener: function(callback){
    this.removeListener(CHANGE_EVENT, callback)
  },
  getReadingList: function(){
    return _readingItems
  },
  getLibrary: function(){
    return _library
  }</pre></div><div class="informaltable" title="Note"><h3 class="title2"><a id="note26" class="calibre1"/>Note</h3><p class="calibre7"><code class="literal">dispatcherIndex</code> is used to store the return value of the Dispatchers registration method. <code class="literal">dispatcherIndex</code> is used in case of <code class="literal">waitFor()</code> method, that is when one part of the app has to wait for another part of the app to get updated.</p></div><p class="calibre7">The<a id="id217" class="calibre1"/> following is the code that shows the <code class="literal">dispatcherIndex</code>:</p><div class="informaltable"><pre class="programlisting">dispatcherIndex: AppDispatcher.register(function(payload){
    var action = payload.action; 
    switch(action.actionType){
      case AppConstants.ADD_BOOK:
        _addItem(payload.action.item);
        break;

      case AppConstants.DELETE_BOOK:
        _removeItem(payload.action.index);
        break;

      case AppConstants.INC_BOOK_COUNT:
        _increaseItem(payload.action.index);
        break;

      case AppConstants.DEC_BOOK:
        _decreaseItem(payload.action.index);
        break;
    }

    AppStore.emitChange();

    return true;
  })
})
module.exports = AppStore;</pre></div></div>
<div class="book" title="Controller-Views and Views"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec34" class="calibre1"/>Controller-Views and Views</h1></div></div></div><p class="calibre7">Views<a id="id218" class="calibre1"/> are primarily the React Views, which essentially<a id="id219" class="calibre1"/> generate the actions. Controller-View listens to our stores, for any <code class="literal">changeEvent</code> been broadcasted. The <code class="literal">emitChange</code> events let our Controller-Views know if any change has to be performed into the state of the view or not. They are essentially React components. In our code, we have five such react components, as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="literal">app-addbooktoreadinglist.js</code></li><li class="listitem"><code class="literal">app-booklist.js</code></li><li class="listitem"><code class="literal">app.js</code></li><li class="listitem"><code class="literal">app-readinglist.js</code></li><li class="listitem"><code class="literal">app-removefromreadinglist.js</code></li></ul></div><p class="calibre7">The following is the code for <code class="literal">app-booklist.js</code>:</p><div class="informaltable"><pre class="programlisting">var React = require('react');
var AppStore = require('../stores/app-stores');
var AddBookToReadingList = require('./app-addbooktoreadinglist')

function getLibrary(){
  return {items: AppStore.getLibrary()}
}

var BookList = React.createClass({
  getInitialState:function(){
    return getLibrary()
  },
  render:function(){
    var items = this.state.items.map(function(item){
      return (
        &lt;tr key={item.id}&gt;
          &lt;td&gt;{item.title}&lt;/td&gt;
          &lt;td&gt;&lt;AddBookToReadingList item={item} /&gt;&lt;/td&gt;
        &lt;/tr&gt;
      );
    })
    return (
      &lt;table className="table table-hover"&gt;
        {items}
      &lt;/table&gt;
    )
  }
});

module.exports = BookList;</pre></div><p class="calibre7">The<a id="id220" class="calibre1"/> following is the code that is internally called on<a id="id221" class="calibre1"/> the <code class="literal">AddBookToReadingList</code> React component:</p><div class="informaltable"><pre class="programlisting">var React = require('react');
var AppActions = require('../actions/app-actions');

//create a AddBookToLibrary component
var AddBookToReadingList = React.createClass({
        handleClick: function(){
          AppActions.addBook(this.props.item)
        },
        render:function(){
          return &lt;button onClick={this.handleClick}&gt;I want to borrow &lt;/button&gt;
        }

});
module.exports = AddBookToReadingList;</pre></div><p class="calibre7">At the end, the following  component <code class="literal">&lt;Booklist \&gt;</code> is added in the <code class="literal">app.js</code>. This is essentially for<a id="id222" class="calibre1"/> the part where a user can see the books they have in the <code class="literal">ReadingList</code> list section:</p><div class="informaltable"><pre class="programlisting">var React = require('react');
var AppStore = require('../stores/app-stores.js');
var RemoveFromReadingList = require('./app-removefromreadinglist');

function readingItems(){
  return {items: AppStore.getReadingList()}
}

var ReadingList = React.createClass({
  getInitialState:function(){
    return readingItems()
  },
  componentWillMount:function(){
    AppStore.addChangeListener(this._onChange)
  },
  _onChange: function(){
    this.setState(readingItems())
  },
  render:function(){
    var total = 0;
    var items = this.state.items.map(function(item, i){
      return (
          &lt;tr key={i}&gt;
            &lt;td&gt;&lt;RemoveFromReadingList index={i} /&gt;&lt;/td&gt;
            &lt;td&gt;{item.title}&lt;/td&gt;
            &lt;td&gt;{item.qty}&lt;/td&gt;
          &lt;/tr&gt;
      );
    })
    return (
      &lt;table className="table table-hover"&gt;
          &lt;thead&gt;
              &lt;tr&gt;
                &lt;th&gt;&lt;/th&gt;
                &lt;th&gt;Book Name&lt;/th&gt;
                &lt;th&gt;Qty&lt;/th&gt;
                &lt;th&gt;&lt;/th&gt;
              &lt;/tr&gt;
            &lt;/thead&gt;
            &lt;tbody&gt;
          &lt;/table&gt;
    )
  }
});
module.exports = ReadingList</pre></div></div>
<div class="book" title="Revisiting the code"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec35" class="calibre1"/>Revisiting the code</h1></div></div></div><p class="calibre7">In each<a id="id223" class="calibre1"/> of the React components (<code class="literal">readingList</code> and <code class="literal">bookList</code>), <code class="literal">getInitialState()</code> is initialized with the store public method <code class="literal">getReadingList()</code> and <code class="literal">getLibrary()</code>, respectively.</p><p class="calibre7">Various methods are executed at precise points in a component's lifecycle.</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="literal">componentWillMount()</code> is a React lifecycle method. It is invoked once, both on the client and server, immediately before the initial rendering occurs. If you call <code class="literal">setState</code> within this method, <code class="literal">render()</code> will see the updated state and will be executed only once despite change in the state:<div class="informaltable"><pre class="programlisting">componentWillMount:function(){
    AppStore.addChangeListener(this._onChange)
  },
  _onChange: function(){
    this.setState(readingItems())
  }</pre></div></li><li class="listitem">Thus, <code class="literal">componentWillMount()</code> is listening to the <code class="literal">addChangeListener</code> (defined in the <code class="literal">AppStore</code> store). If the <code class="literal">_onChange</code> parameter is passed, then the current object (<code class="literal">_this</code>) is updated (<code class="literal">setState</code>) with the new/updated data/payload (<code class="literal">readingItems</code>).</li><li class="listitem">In order to remove the items from the reading list, the event listener (<code class="literal">handleClick</code>) is unmounted.</li></ul></div><p class="calibre7">The following is the code of app-<code class="literal">removebookfromreadinglist.js</code>:</p><div class="informaltable"><pre class="programlisting">var React = require('react');
var AppActions = require('../actions/app-actions');

//create a DeleteBookFromLibrary component
var DeleteBookFromReadingList = React.createClass({
        handleClicr: function(){
          AppActions.deleteBook(this.props.index)
        },
        render:function(){
          return &lt;button onClick={this.handleClicr}&gt;Book Completed&lt;/button&gt;
        }
});
module.exports = DeleteBookFromReadingList;</pre></div><p class="calibre7">The following<a id="id224" class="calibre1"/> is the code of <code class="literal">app.js</code>:</p><div class="informaltable"><pre class="programlisting">var React = require('react');
var BookList = require('./app-booklist');
var ReadingList = require('./app-readinglist');
//create a App component
var App = React.createClass({
        render:function(){
          return &lt;div&gt;&lt;h1&gt;Book List&lt;/h1&gt;&lt;BookList /&gt;&lt;h1&gt;Reading List&lt;/h1&gt;&lt;ReadingList /&gt;&lt;/div&gt;
        }
});
module.exports = App</pre></div><p class="calibre7">The final view of our <code class="literal">library_app</code> Flux application</p><p class="calibre7">On clicking on the button <span class="strong"><strong class="calibre8">I want to borrow</strong></span>, the corresponding book will come to my Reading List. Once I am done with the book, click on the button <span class="strong"><strong class="calibre8">Book Completed</strong></span>, to remove the book from the reading list.</p><p class="calibre7">The following is a screenshot of our <code class="literal">library_app</code> application.</p><div class="mediaobject"><img src="../images/00037.jpeg" alt="Revisiting the code" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre7">How to run this Flux app will be covered in the building and deployment structure later.</p><p class="calibre7">The following are the details of the components of a Flux-based app:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Actions</li><li class="listitem">Dispatchers (registry of callbacks)</li><li class="listitem">Stores (callbacks registered with dispatchers)</li><li class="listitem">Views</li><li class="listitem">Controllers<a id="id225" class="calibre1"/> Views<div class="mediaobject"><img src="../images/00038.jpeg" alt="Revisiting the code" class="calibre9"/><div class="caption"><p class="calibre25">data flow in Flux app</p></div></div><p class="calibre26"> </p></li></ul></div></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec36" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">Through our <code class="literal">libary_app</code> application, we have explored how the unidirectional data flow in a simple Flux-based application. The users can see the booklist in the views. They can add books in the reading list, thus the actions (adding books ) gets passed to the dispatchers. Internally the dispatchers have the registered callbacks with the stores. The stores then adds/removes the books based on the user's action and computes the business logic and re-renders the changes accordingly again to the views.</p><p class="calibre7">In the next chapter, we will cover React good practices and patterns. This includes practices to develop reusable components, how to structure your components hierarchically to a better data flow, and how to validate your components behavior. In our app, we'll be improving our components developed so far.</p></div></body></html>