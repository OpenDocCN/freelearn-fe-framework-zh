<html><head></head><body><div class="chapter" title="Chapter&#xA0;12.&#xA0;Flux"><div class="titlepage"><div><div><h1 class="title"><a id="ch12"/>Chapter 12. Flux</h1></div></div></div><p>In the previous chapter, we took a look at the various tools in the React ecosystem that are useful in the whole lifetime of an application—development, testing, and production. We also saw how React improves the developer experience using developer tools. We learned about the various testing tools that can be used with React. To summarize it, we saw how to use build tools such as Webpack and Browserify and how they can be used with React.</p><p>In this chapter, we are going to dive deep in Flux as an architecture. We have seen how problems arise during data sharing across components. We will see how we can overcome them by having a single point of data store. Next, we will check out how to use React to overcome this.</p><p>Dispatcher acts as a central hub to manage this data flow and communication and how Actions invoke them. Finally, we will we take a look at the complete data flow that takes place, while building our Social Media Tracker application.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Flux architecture</li><li class="listitem" style="list-style-type: disc">Stores</li><li class="listitem" style="list-style-type: disc">Actions</li><li class="listitem" style="list-style-type: disc">Dispatcher</li><li class="listitem" style="list-style-type: disc">Flux implementations</li></ul></div><p>At the end of chapter, we will be able to start replacing parts of our application that have tight data coupling, with Flux We will be able to set up the necessary groundwork for Flux and easily start using the same in our React views.</p><div class="section" title="Flux architecture and unidirectional flow"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec83"/>Flux architecture and unidirectional flow</h1></div></div></div><p>"Hey <a id="id315" class="indexterm"/>Mike and Shawn!" entered Carla, on a bright morning.</p><p>"Hi Carla, how are you today?"</p><p>"Wonderful. The previous app that you build was nice, the clients liked it. They will soon add more features to it. Meanwhile, we have got another small app to build."</p><p>"Oh, nice. What are we planning to build?" inquired Mike.</p><p>"We need to build a kind of social tracker. To start with, we show a user's reddits, tweets, and so on. We will later extend it to display other information."</p><p>"Got it," iterated Shawn.</p><p>"Have a good day; I will leave it to you."</p><p>"So Shawn, what do you think about the new project?"</p><p>"It should be exciting. Umm… can we explore Flux and use it in the app? We had discussed it <a id="id316" class="indexterm"/>when we were building the last app."</p><p>"Yeah, we can. This will be the perfect opportunity to see how Flux works. Before we start using it, let's go through what Flux actually is."</p><p>"Flux is a simple architecture for React to make use of unidirectional flow. We have discussed previously how unidirectional flow suits React. React follows the render-always model when there are any changes made to data. Data doesn't go other way around, like in the case of two-way bindings."</p><p>"It's not exactly the <a id="id317" class="indexterm"/>
<span class="strong"><strong>Model-View-Controller</strong></span> (<span class="strong"><strong>MVC</strong></span>) way of working. It consists of Model (Stores), Actions and Dispatchers, and finally Views (React Views)."</p><p>"There is no module for complete Flux as a framework as it's not meant to be. Facebook provides the Flux module, which consists of the <span class="strong"><strong>Dispatcher</strong></span>. Other parts such as <span class="strong"><strong>View</strong></span> and <span class="strong"><strong>Stores</strong></span> can be done without much support. Let's go over them one by one, shall we?"</p><p>"Sure. I believe we can go over how they correlate and why exactly are they useful when an app starts to grow."</p><p>"Yup."</p><p>"As you can see in the following image, the various components are tied together and function distinctly. Data flows in a single direction in a cycle."</p><p>"As I mentioned previously, a <a id="id318" class="indexterm"/>
<span class="strong"><strong>Dispatcher</strong></span> acts as the central hub. Whenever an event takes place from the View, such as a user clicks a button or an Ajax call is completed, an action from the Actions is called. The <span class="strong"><strong>Action</strong></span> may also get called from the <span class="strong"><strong>Dispatcher</strong></span>."</p><p>"The Actions are simple constructs that deliver the payload to the <span class="strong"><strong>Dispatcher</strong></span>, which identify what the <span class="strong"><strong>Action</strong></span> is and <a id="id319" class="indexterm"/>other details from the action and data needed to update current state."</p><div class="mediaobject"><img src="graphics/4730_12_01.jpg" alt="Flux architecture and unidirectional flow"/></div><p>"The <span class="strong"><strong>Dispatcher</strong></span> then propagates it to the stores. <span class="strong"><strong>Dispatcher</strong></span> acts like a callback registry, where all stores register themselves. <span class="strong"><strong>Dispatcher</strong></span> notifies and callbacks stores whenever some action takes <a id="id320" class="indexterm"/>place. Irrespective of the action, it is delivered to all the stores."</p><p>"The <span class="strong"><strong>Dispatcher</strong></span> is not doing any complex activities, it just forwards the payload to registered stores, and it doesn't process any data."</p><p>"The responsibility to perform logical and complex decisions and data changes is entrusted with the stores. This helps to make the point of data changes at a single place and avoid changes all around the application, which are harder to track."</p><p>"On receiving a callback from the <a id="id321" class="indexterm"/>
<span class="strong"><strong>Dispatcher</strong></span>, the <span class="strong"><strong>Store</strong></span> decides whether it needs to perform any action or not, based on the <span class="strong"><strong>Action</strong></span> type. Based on the callback, it can update the current store. It can also wait for other stores to be updated. After it is done with the changes, it goes ahead and notifies the view. This can be achieved in our simple Flux version by making use <a id="id322" class="indexterm"/>of an <code class="literal">EventEmitter</code> module which is available <a id="id323" class="indexterm"/>from the events module."</p><p>"Similar to Actions, the Views <a id="id324" class="indexterm"/>register themselves to hear changes in stores. On some changes, an event is emitted by <code class="literal">EventEmitter</code>. Based on the event type, it will call a <code class="literal">View</code> method, which has registered to listen to an event."</p><p>"The <span class="strong"><strong>View</strong></span> receiving the event <a id="id325" class="indexterm"/>can then update its own state, based on the current state of any stores that are available to it. The state update then triggers the <span class="strong"><strong>View</strong></span> update."</p><p>"This process continues with a <span class="strong"><strong>View</strong></span> event, resulting in calls to the <span class="strong"><strong>Actions</strong></span> and <span class="strong"><strong>Dispatcher</strong></span> and so forth."</p><p>"Hope, this is somewhat clear now?" queried Mike.</p><p>"Umm… yeah, let me wrap my head around it. We have actions to perform an <span class="strong"><strong>Action</strong></span>, based on an event. It then notifies the <a id="id326" class="indexterm"/>
<span class="strong"><strong>Dispatcher</strong></span>, which then notifies any store registered to listen for the changes. The Stores then update themselves, based on the action type <a id="id327" class="indexterm"/>and notify the React <a id="id328" class="indexterm"/>Views to update themselves."</p><p>"Correct! Let's <a id="id329" class="indexterm"/>dive in the app right away. We will base our app from the <a id="id330" class="indexterm"/>official Flux example. It will be structured like this."</p><p>
<code class="literal">js/</code>
</p><p>
<code class="literal">├── actions</code>
</p><p>
<code class="literal">│   └── SocialActions.js</code>
</p><p>
<code class="literal">├── app.js</code>
</p><p>
<code class="literal">├── components</code>
</p><p>
<code class="literal">│   └── SocialTracker.react.js</code>
</p><p>
<code class="literal">├── constants</code>
</p><p>
<code class="literal">│   └── SocialConstants.js</code>
</p><p>
<code class="literal">├── dispatcher</code>
</p><p>
<code class="literal">│   └── AppDispatcher.js</code>
</p><p>
<code class="literal">├── stores</code>
</p><p>
<code class="literal">│   └── SocialStore.js</code>
</p><p>
<code class="literal">└── utils</code>
</p><p>
<code class="literal">    └── someutil.js</code>
</p><p>"Now, as Carla mentioned, we need to show the user's data from Twitter and Reddit. For Reddit, it's available openly via API calls, as we will see shortly."</p><p>"For Twitter, we are going to need to set up some groundwork and create a Twitter app. We can create a new one on <a class="ulink" href="https://apps.twitter.com/">https://apps.twitter.com/</a>. I have already created one for our app."</p><div class="mediaobject"><img src="graphics/4730_12_02.jpg" alt="Flux architecture and unidirectional flow"/></div><p>"We are then going <a id="id331" class="indexterm"/>to make use of the <code class="literal">twitter</code> module to access Twitter and <a id="id332" class="indexterm"/>fetch tweets from users. Let's set up a <code class="literal">config.js</code> file to store the preceding access tokens that we have created, as follows:"</p><div class="informalexample"><pre class="programlisting">module.exports ={
  twitter_consumer_key: 'xxxx',
  twitter_consumer_secret: 'xxxx',
  twitter_access_token_key: 'xxxx',
  twitter_access_token_secret: 'xxxx'
}</pre></div><p>"These correspond to the relative keys and secrets that we created in our app. Next, we will create a client to access the data using the preceding credentials."</p><div class="informalexample"><pre class="programlisting">var Twitter = require('twitter');
var config = require('./config');

var client = new Twitter({
  consumer_key: config.twitter_consumer_key,
  consumer_secret: config.twitter_consumer_secret,
  access_token_key: config.twitter_access_token_key,
  access_token_secret: config.twitter_access_token_secret
});</pre></div><p>"We are going to make use of this client in our express server application. As I said, for Reddit, we can hit <a id="id333" class="indexterm"/>Reddit API directly to access reddits. For Twitter, it will <a id="id334" class="indexterm"/>first hit our node <code class="literal">App</code> and return tweets to our React Components."</p><p>"Would you like to define this, Shawn?"</p><p>"Sure."</p><div class="informalexample"><pre class="programlisting">var express= require('express');
var app = new (require('express'))();
var port = 3000

app.get('/tweets.json', function (req, res) {
  var params = {screen_name: req.query.username};
  client.get('statuses/user_timeline', params, function (error, tweets, response) {
    if (!error) {
      res.json(tweets);
    } else {
      res.json({error: error});
    }
  });
});</pre></div><p>"I defined a JSON endpoint here called <code class="literal">tweets.json</code>. It will call the <code class="literal">client.get()</code> method, which is a REST API wrapper to call Twitter API. We invoke the <code class="literal">statuses/user_timeline</code> API to fetch the user timeline for a user, which is passed to us from the request.</p><p>On receiving the response, it will send this back to the React component calling it."</p><p>"Looks good. Now, let's start with the App. We will start by defining the Dispatcher."</p><div class="informalexample"><pre class="programlisting">// AppDispatcher.js
var Dispatcher = require('flux').Dispatcher;

module.exports = new Dispatcher();</pre></div><p>"We define our dispatcher by requiring it from <code class="literal">flux.Dispatcher</code>. We will then use this at various places."</p></div></div>
<div class="section" title="Flux actions"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec84"/>Flux actions</h1></div></div></div><p>"Now we need to <a id="id335" class="indexterm"/>define the actions types that we are going to refer to as constants at various places, such as sending the type from Actions to store, and in our store, deciding what action type has been passed to store to take appropriate actions.</p><div class="informalexample"><pre class="programlisting">//SocialConstants.js
var keyMirror = require('keymirror');

module.exports = keyMirror({
  FILTER_BY_TWEETS: null,
  FILTER_BY_REDDITS: null,
  SYNC_TWEETS: null,
  SYNC_REDDITS: null

});</pre></div><p>"Here, we are using the <a class="ulink" href="https://github.com/STRML/keyMirror">https://github.com/STRML/keyMirror</a> package to create keys and values for the object based on the keys. This will convert into object similar to below."</p><div class="informalexample"><pre class="programlisting">{
FILTER_BY_TWEETS: 'FILTER_BY_TWEETS', 
…
}</pre></div><p>"This is handy when adding new keys to not repeat the same contents again."</p><p>"We can now start using the action constants. They represent four actions that we are going to perform, as follows:"</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">SYNC_TWEETS</code>: This fetches the tweets for a given user</li><li class="listitem" style="list-style-type: disc"><code class="literal">SYNC_REDDITS</code>: This fetches the reddits for a give topic</li><li class="listitem" style="list-style-type: disc"><code class="literal">FILTER_BY_TWEETS</code>: This only displays tweets, instead of tweets and reddits</li><li class="listitem" style="list-style-type: disc"><code class="literal">FILTER_BY_REDDITS</code>: This only displays reddits, instead of tweets and reddits</li></ul></div><p>"Next, let's define the actions that will be called from different places in our views."</p><div class="informalexample"><pre class="programlisting">// file: SocialActions.js
var AppDispatcher = require('../dispatcher/AppDispatcher');
var SocialConstants = require('../constants/SocialConstants');
var assign = require('object-assign');
var JSONUtil = require('../utils/jsonutil');

var SocialActions = {

  filterTweets: function (event) {
    AppDispatcher.dispatch({
      type: SocialConstants.FILTER_BY_TWEETS,
      showTweets: event.target.checked
    });
  },

  filterReddits: function (event) {
    AppDispatcher.dispatch({
      type: SocialConstants.FILTER_BY_REDDITS,
      showReddits: event.target.checked
    });
  },


  syncTweets: function (json) {
    AppDispatcher.dispatch({
      type: SocialConstants.SYNC_TWEETS,
      tweets: json.map((tweet) =&gt; {
        return assign(tweet, {type: 'tweet'})
      }),
      receivedAt: Date.now()
    });
  },

  syncReddits: function (json) {
    AppDispatcher.dispatch({
      type: SocialConstants.SYNC_REDDITS,
      reddits: json.data.children.map((child) =&gt; {
        return assign(child.data, {type: 'reddit'})
      }),
      receivedAt: Date.now()
    });
  },

  fetchTweets: function (username) {
    fetch(`/tweets.json?username=${username}`)
        .then(JSONUtil.parseJSON)
        .then(json =&gt; SocialActions.syncTweets(json)).catch(JSONUtil.handleParseException)
  },

  fetchReddits: function (topic) {
    fetch(`https://www.reddit.com/r/${topic}.json`)
        .then(JSONUtil.parseJSON)
        .then(json =&gt; SocialActions.syncReddits(json)).catch(JSONUtil.handleParseException)
  }
};

module.exports = SocialActions;</pre></div><p>"Let's go through these actions, case-by-case:"</p><div class="informalexample"><pre class="programlisting">  fetchTweets: function (username) {
    fetch(`/tweets.json?username=${username}`)
        .then(JSONUtil.parseJSON)
        .then(json =&gt; SocialActions.syncTweets(json)).catch(JSONUtil.handleParseException)
  }</pre></div><p>"Here, we are using fetch, which is similar to Ajax that we have used before, to fetch tweets from our own <a id="id336" class="indexterm"/>
<code class="literal">tweets.json</code> API, where we are passing the username for which we need to get the tweets. We are making use of JSON utility methods here that we have defined as follows:"</p><div class="informalexample"><pre class="programlisting">var JSONUtil = (function () {
  function parseJSON(response){
    return response.json()
  }
  function handleParseException(ex) {
    console.log('parsing failed', ex)
  }
  return {'parseJSON': parseJSON, 'handleParseException': handleParseException}
}());

module.exports = JSONUtil;</pre></div><p>"They help us convert responses to JSON, or in case of failures, logs them:"</p><p>After we receive a successful response from API, we call <code class="literal">SocialActions.syncTweets(json)</code> method, from the same module.</p><div class="informalexample"><pre class="programlisting">  syncTweets: function (json) {
    AppDispatcher.dispatch({
      type: SocialConstants.SYNC_TWEETS,
      tweets: json.map((tweet) =&gt; {
        return assign(tweet, {type: 'tweet'})
      }),
      receivedAt: Date.now()
    });
  }</pre></div><p>"Next, <code class="literal">syncTweets</code> accepts the JSON. Then, it wraps the JSON into an object payload to be sent to dispatcher. In this object, we are creating a tweets array out of the payload. We are also tagging each object to depict its type as tweet so that we can mix and match the tweets and reddit in same arrays and identity which object it represents: a tweet or reddit."</p><div class="informalexample"><pre class="programlisting">assign(tweet, {type: 'tweet'})</pre></div><p>"We use <code class="literal">Object.assign</code>, which merges two objects together. We use it from the <code class="literal">object-assign</code> package here."</p><p>"Now, we notify the <a id="id337" class="indexterm"/>Dispatcher about the payload to be ultimately delivered to the stores follows"</p><div class="informalexample"><pre class="programlisting">AppDispatcher.dispatch({ payload…});</pre></div><p>"Similarly, we have the <code class="literal">syncReddits</code> method, as follows:"</p><div class="informalexample"><pre class="programlisting">  fetchReddits: function (topic) {
    fetch(`https://www.reddit.com/r/${topic}.json`)
        .then(JSONUtil.parseJSON)
        .then(json =&gt; SocialActions.syncReddits(json)).catch(JSONUtil.handleParseException)
  }</pre></div><p>"This fetches the reddits <a id="id338" class="indexterm"/>from <code class="literal">https://www.reddit.com/r/${topic}.json</code>, for example <a class="ulink" href="https://www.reddit.com/r/twitter.json">https://www.reddit.com/r/twitter.json</a>.</p><p>"After fetching, it delivers the data to <code class="literal">SocialActions.syncReddits(json))</code>, which creates the payloads for the dispatcher, as follows:"</p><div class="informalexample"><pre class="programlisting">  syncReddits: function (json) {
    AppDispatcher.dispatch({
      type: SocialConstants.SYNC_REDDITS,
      reddits: json.data.children.map((child) =&gt; {
        return assign(child.data, {type: 'reddit'})
      }),
      receivedAt: Date.now()
    });
  }</pre></div><p>"Note, how we are passing the type attribute for the actions here. This is to notify the stores what action to take when they receive the payload."</p><p>"Got it. It would be interesting to see how we proceed on the basis of this object."</p><p>"Yup. Next, we have two simple methods that relay the events to the stores, as follows:"</p><div class="informalexample"><pre class="programlisting">  filterTweets: function (event) {
    AppDispatcher.dispatch({
      type: SocialConstants.FILTER_BY_TWEETS,
      showTweets: event.target.checked
    });
  },

  filterReddits: function (event) {
    AppDispatcher.dispatch({
      type: SocialConstants.FILTER_BY_REDDITS,
      showReddits: event.target.checked
    });
  },</pre></div><p>"We are going to use these methods as <code class="literal">onClick</code> methods. On clicking the checkboxes, the value for the checkbox—either reddit or twitter—will be available in <code class="literal">event.target.checked</code>."</p><p>"We wrap these in a <a id="id339" class="indexterm"/>simple object, tag them with the type of action call, and send the same to the Dispatcher. This way, we will know if we are going to display the tweets, reddit, or none."</p></div>
<div class="section" title="Flux stores"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec85"/>Flux stores</h1></div></div></div><p>"Cool, it looks like now we are all set to create our store."</p><p>"Yup Shawn. We <a id="id340" class="indexterm"/>will start by defining the state object that we will keep on updating and using as a store."</p><div class="informalexample"><pre class="programlisting">var AppDispatcher = require('../dispatcher/AppDispatcher');
var EventEmitter = require('events').EventEmitter;
var SocialConstants = require('../constants/SocialConstants');
var assign = require('object-assign');
var _ = require('underscore');

var CHANGE_EVENT = 'change';

var _state = {
  tweets: [],
  reddits: [],
  feed: [],
  showTweets: true,
  showReddits: true
};</pre></div><p>"We have also defined a <code class="literal">CHANGE_EVENT</code> constant that we use as an identifier to <span class="emphasis"><em>listen</em></span> to events of the <span class="emphasis"><em>change</em></span> type from the event emitter in our store."</p><p>"We then define a method to update the states, creating a new one."</p><div class="informalexample"><pre class="programlisting">function updateState(state) {
  _state = assign({}, _state, state);
}</pre></div><p>"This merges the new properties that need to be updated and merged into the existing state and updated the current state."</p><p>"Cool, this looks somewhat similar to the <code class="literal">setState</code> React method," said Shawn.</p><p>"Yup. Now we are <a id="id341" class="indexterm"/>going to define our store that will update the current state."</p><div class="informalexample"><pre class="programlisting">var SocialStore = assign({}, EventEmitter.prototype, {

  getState: function () {
    return _state;
  },

  emitChange: function () {
    this.emit(CHANGE_EVENT);
  },

  addChangeListener: function (callback) {
    this.on(CHANGE_EVENT, callback);
  },

  removeChangeListener: function (callback) {
    this.removeListener(CHANGE_EVENT, callback);
  }
});</pre></div><p>"Here, we are defining our <code class="literal">SocialStore</code> by inheriting from <code class="literal">EventEmitter</code>. This gives it the capability to be used by the components to register to listen on events, <code class="literal">CHANGE_EVENT</code> in our case. The <code class="literal">addChangeListener</code> and <code class="literal">removeChangeListener</code> methods take in methods that should be called on events and remove the listener, as follows:" <code class="literal">this.on(CHANGE_EVENT, callback);</code> and<code class="literal"> this.removeListener(CHANGE_EVENT, callback);</code>
</p><p>"Whenever we want to notify the listeners, we call."</p><div class="informalexample"><pre class="programlisting">this.emit(CHANGE_EVENT);</pre></div><p>"Finally, our views can get the current state from the store using following function:"</p><div class="informalexample"><pre class="programlisting">getState: function () {
    return _state;
  }</pre></div><p>"Finally, Shawn, let's <a id="id342" class="indexterm"/>tie this all together with our Single Dispatcher, as follows:"</p><div class="informalexample"><pre class="programlisting">AppDispatcher.register(function (action) {

  switch (action.type) {

    case SocialConstants.FILTER_BY_TWEETS:
      updateState({
        showTweets: action.showTweets,
        feed: mergeFeed(_state.tweets, _state.reddits, action.showTweets, _state.showReddits)
      });
      SocialStore.emitChange();
      break;

    case SocialConstants.FILTER_BY_REDDITS:
      updateState({
        showReddits: action.showReddits,
        feed: mergeFeed(_state.tweets, _state.reddits, _state.showTweets, action.showReddits)
      });
      SocialStore.emitChange();
      break;
    case SocialConstants.SYNC_TWEETS:
      updateState({
        tweets: action.tweets,
        feed: mergeFeed(action.tweets, _state.reddits, _state.showTweets, _state.showReddits)
      });
      SocialStore.emitChange();
      break;

    case SocialConstants.SYNC_REDDITS:
      updateState({
        reddits: action.reddits,
        feed: mergeFeed(_state.tweets, action.reddits, _state.showTweets, _state.showReddits)
      });
      SocialStore.emitChange();
      break;
    default:
    // no op
  }
});</pre></div><p>"Whenever we have <code class="literal">AppDispatcher.dispatch</code> being called by the payload, the preceding method is invoked."</p><p>"Let's take a look at one of these actions."</p><div class="informalexample"><pre class="programlisting">    case SocialConstants.SYNC_TWEETS:
      updateState({
        tweets: action.tweets,
        feed: mergeFeed(action.tweets, _state.reddits, _state.showTweets, _state.showReddits)
      });
      SocialStore.emitChange();
      break;</pre></div><p>"What we are doing here is calling <code class="literal">updateState</code> to update the current state by providing it with the updated tweets and update the feed, based on the <code class="literal">mergeFeed</code> method."</p><p>"Let's take a look at it."</p><div class="informalexample"><pre class="programlisting">function mergeFeed(tweets, reddits, showTweets, showReddits) {
  let mergedFeed = [];
  mergedFeed = showTweets ? mergedFeed.concat(tweets) : mergedFeed;
  mergedFeed = showReddits ? mergedFeed.concat(reddits) : mergedFeed;

  mergedFeed = _.sortBy(mergedFeed, (feedItem) =&gt; {
    if (feedItem.type == 'tweet') {
      let date = new Date(feedItem.created_at);
      return date.getTime();
    } else if ((feedItem.type == 'reddit')) {
      return feedItem.created_utc * 1000;
    }
  })
  return mergedFeed;
};</pre></div><p>"I have combined various <a id="id343" class="indexterm"/>operations here to be handled, based on whether <code class="literal">showTweets</code>, <code class="literal">showReddits</code> are selected."</p><p>"So, what this method does is that it accepts the tweets and reddit array data, as well as checks whether show reddits or show tweets is checked or not. We build the final feed based on these checked/unchecked fields into the <code class="literal">mergedFeed</code> array."</p><p>"Then, we sort this array of both mixed up tweets and reddits data—<code class="literal">mergedFeed</code>, using <code class="literal">underscorejs</code> method, <code class="literal">sortBy</code>, and we sort the array on the basis of time fields on the two types of objects. In case of tweets, this field is the <code class="literal">created_at</code> field, and in case of reddit, it's the <code class="literal">created_utc</code> field. We normalize the time in UTC timestamp for comparison."</p><p>"Coming back to the sync tweets action, after updating the state, we call the emitter method on store:"</p><div class="informalexample"><pre class="programlisting">      SocialStore.emitChange();</pre></div><p>"This calls our emitter from the store to eventually deliver updates to the components."</p><p>"Got it. I believe the next step is creating our Views."</p><p>"That's right. We will split our view into three components—<code class="literal">Header</code>, <code class="literal">MainSection</code>, and <code class="literal">SocialTracker</code> container component."</p><p>"We start with the <a id="id344" class="indexterm"/>
<code class="literal">Header</code>, as follows:"</p><div class="informalexample"><pre class="programlisting">var React = require('react');
var ReactBootstrap =  require('react-bootstrap');
var Row =  ReactBootstrap.Row, Jumbotron =  ReactBootstrap.Jumbotron;

var Header = React.createClass({

  render: function () {
    return (
        &lt;Row&gt;
          &lt;Jumbotron className="center-text"&gt;
            &lt;h1&gt;Social Media Tracker&lt;/h1&gt;
          &lt;/Jumbotron&gt;
        &lt;/Row&gt;
    );
  }

});

module.exports = Header;</pre></div><p>"It's a simple display component, containing the header."</p><p>"Ah, Mike. I notice you are using the react-bootstrap module. That looks neat. Instead of defining it in plain elements and bootstrap properties, it helps us to wrap them in the React Components with properties."</p><p>"Yup. We are using the <code class="literal">Jumbotron</code> and <code class="literal">Row</code> here. This Row will get wrapped in a bootstrap Grid component."</p><p>"Next, we are going to get our <code class="literal">MainSection</code> component set up, this will show the inputs to get the usernames for Twitter and Reddit topic, as well as check for them:"</p><div class="informalexample"><pre class="programlisting">var React = require('react');
…
var SocialActions = require('../actions/SocialActions');
var SocialStore = require('../stores/SocialStore');
var MainSection = React.createClass({

  getInitialState: function () {
    return assign({twitter: 'twitter', reddit: 'twitter'}, SocialStore.getState());
  },

  componentDidMount: function () {
    SocialStore.addChangeListener(this._onChange);
    this.syncFeed();
  },

  componentWillUnmount: function () {
    SocialStore.removeChangeListener(this._onChange);
  },

  render: function () {

    return (
        &lt;Row&gt;
          &lt;Col xs={8} md={8} mdOffset={2}&gt;
            &lt;Table striped hover&gt;
              &lt;thead&gt;
              &lt;tr&gt;
                &lt;th width='200'&gt;Feed Type&lt;/th&gt;
                &lt;th&gt;Feed Source&lt;/th&gt;
              &lt;/tr&gt;
              &lt;/thead&gt;
              &lt;tbody&gt;
              &lt;tr&gt;
                &lt;td&gt;&lt;Input id='test' type="checkbox" label="Twitter" onChange={SocialActions.filterTweets}
                           checked={this.state.showTweets}/&gt;&lt;/td&gt;
                &lt;td&gt;&lt;Input onChange={this.changeTwitterSource} type="text" addonBefore="@" value={this.state.twitter}/&gt;
                &lt;/td&gt;
              &lt;/tr&gt;
              &lt;tr&gt;
                &lt;th&gt;&lt;Input type="checkbox" label="Reddit" onChange={SocialActions.filterReddits}
                           checked={this.state.showReddits}/&gt;&lt;/th&gt;
                &lt;td&gt;&lt;Input onChange={this.changeRedditSource} type="text" addonBefore="@"
                           value={this.state.reddit}/&gt;&lt;/td&gt;
              &lt;/tr&gt;
              &lt;tr&gt;
                &lt;th&gt;&lt;/th&gt;
                &lt;td&gt;&lt;Button bsStyle="primary" bsSize="large" onClick={this.syncFeed}&gt;Sync Feed&lt;/Button&gt;
                &lt;/td&gt;
              &lt;/tr&gt;
              &lt;/tbody&gt;
            &lt;/Table&gt;
          &lt;/Col&gt;
        &lt;/Row&gt;
    );
  },

  changeTwitterSource: function (event) {
    this.setState({twitter: event.target.value});
  },

  changeRedditSource: function (event) {
    this.setState({reddit: event.target.value});
  },

  syncFeed: function () {
    SocialActions.fetchReddits(this.state.reddit);
    SocialActions.fetchTweets(this.state.twitter);
  },

  _onChange: function () {
    this.setState(SocialStore.getState());
  }

});

module.exports = MainSection;</pre></div><p>"Now the component <a id="id345" class="indexterm"/>is doing a couple of things here. First, it's setting the state on the basis of the store."</p><div class="informalexample"><pre class="programlisting">  getInitialState: function () {
    return assign({twitter: 'twitter', reddit: 'twitter'}, SocialStore.getState());
  },</pre></div><p>"It is also tracking two different fields—Twitter and Reddit—username information. We bind these values based on inputs from the fields, as we have seen before:"</p><div class="informalexample"><pre class="programlisting">  changeTwitterSource: function (event) {
    this.setState({twitter: event.target.value});
  },

  changeRedditSource: function (event) {
    this.setState({reddit: event.target.value});
  },</pre></div><p>"And then use this change handler on the <a id="id346" class="indexterm"/>input fields, like so."</p><div class="informalexample"><pre class="programlisting">&lt;Input onChange={this.changeTwitterSource} type="text" addonBefore="@" value={this.state.twitter}/&gt;</pre></div><p>"Next, we have our <code class="literal">componentDidMount</code> and <code class="literal">componentWillUnmount</code> functions register and de-register them to listen to the events emitted from the <code class="literal">SocialStore</code>:"</p><div class="informalexample"><pre class="programlisting">  componentDidMount: function () {
    SocialStore.addChangeListener(this._onChange);
    this.syncFeed();
  },

  componentWillUnmount: function () {
    SocialStore.removeChangeListener(this._onChange);
  },</pre></div><p>"Here, we register the <code class="literal">_onChange</code> method to be called whenever the changes occur in the <code class="literal">SocialStore</code>. The <code class="literal">_onChange</code> method, in turn, updates the current state of the component, based on state of the store, as follows:"</p><div class="informalexample"><pre class="programlisting">    this.setState(SocialStore.getState());</pre></div><p>"Next, we specify the <code class="literal">SocialAction</code> methods to be called for events such as checking/unchecking Twitter/Reddit display and calling to sync the tweets and reddits. On calling out the syncing data, <code class="literal">syncFeed</code> gets called, which calls the related sync methods from <code class="literal">SocialActions</code>, passing in the current Twitter name and Reddit topic."</p><div class="informalexample"><pre class="programlisting">  syncFeed: function () {
    SocialActions.fetchReddits(this.state.reddit);
    SocialActions.fetchTweets(this.state.twitter);
  },</pre></div><p>"Finally, we are going to wrap everything up with the <code class="literal">SocialTracker</code> component, as follows:"</p><div class="informalexample"><pre class="programlisting">var ArrayUtil = require('../utils/array');
var assign = require('object-assign');
var Header = require('./Header.react');
var MainSection = require('./MainSection.react');
var React = require('react');
var SocialStore = require('../stores/SocialStore');
var SocialActions = require('../actions/SocialActions');
var ReactBootstrap =  require('react-bootstrap');
var Col =  ReactBootstrap.Col, Grid =  ReactBootstrap.Grid, Row =  ReactBootstrap.Row;

var SocialTracker = React.createClass({
  getInitialState: function() {
    return assign({}, SocialStore.getState());
  },
  componentDidMount: function() {
    SocialStore.addChangeListener(this._onChange);
  },
  componentWillUnmount: function() {
    SocialStore.removeChangeListener(this._onChange);
  },
  render: function() {
    return (
        &lt;Grid className="grid"&gt;
          &lt;Header/&gt;
          &lt;MainSection/&gt;
          {this.renderFeed()}
        &lt;/Grid&gt;
    )
  },

  renderFeed: function() {
    var feed = this.state.feed;
    var feedCollection = ArrayUtil.in_groups_of(feed, 3);
    if (feed.length &gt; 0) {
      return feedCollection.map((feedGroup, index) =&gt; {
        console.log(feedGroup);
        return &lt;Row key={`${feedGroup[0].id}${index}`}&gt;
          {feedGroup.map((feed) =&gt; {
            if (feed.type == 'tweet') {
              return &lt;Col md={4} key={feed.id}&gt;&lt;div className="well twitter"&gt;&lt;p&gt;{feed.text}&lt;/p&gt;&lt;/div&gt;&lt;/Col&gt;;
            } else {
              var display = feed.selftext == "" ? `${feed.title}: ${feed.url}` : feed.selftext;
              return &lt;Col md={4} key={feed.id}&gt;&lt;div className="well reddit"&gt;&lt;p&gt;{display}&lt;/p&gt;&lt;/div&gt;&lt;/Col&gt;;
            }
          })}
        &lt;/Row&gt;
      });
    } else {
      return &lt;div&gt;&lt;/div&gt;
    }
  },

  _onChange: function() {
    this.setState(SocialStore.getState());
  }

});

module.exports = SocialTracker;</pre></div><p>"We have the same set up that we used previously to listen to the store updates and update the current state of the component."</p><p>"Nice, I see, all that's <a id="id347" class="indexterm"/>left is looping over the feed and displaying them," continued Shawn.</p><p>"I see that we are displaying the feed in groups of three in a row and applying individual styles, based on whether its a tweet and so on. To divide them in groups, we seem to be using <code class="literal">ArrayUtil</code>."</p><div class="informalexample"><pre class="programlisting">var ArrayUtil = (function () {
  function in_groups_of(arr, n) {
    var ret = [];
    var group = [];
    var len = arr.length;
    for (var i = 0; i &lt; len; ++i) {
      group.push(arr[i]);
      if ((i + 1) % n == 0) {
        ret.push(group);
        group = [];
      }
    }
    if (group.length) ret.push(group);
    return ret;
  };

  return {'in_groups_of': in_groups_of}
}());

module.exports = ArrayUtil;</pre></div><p>"Yup, that's right. With this, it looks like we are all set. We will finally display the component as usual."</p><div class="informalexample"><pre class="programlisting">var React = require('react');
var ReactDOM = require('react-dom');
var SocialTracker = require('./components/SocialTracker.react');

ReactDOM.render(
  &lt;SocialTracker /&gt;,
  document.getElementById('container')
);</pre></div><p>"Let's take a look at <a id="id348" class="indexterm"/>how it looks, shall we?"</p><div class="mediaobject"><img src="graphics/4730_12_03.jpg" alt="Flux stores"/></div><p>"Here's how it looks, without tweets:"</p><div class="mediaobject"><img src="graphics/4730_12_04.jpg" alt="Flux stores"/></div><p>"Here's how it looks, when changing the twitter user:"</p><div class="mediaobject"><img src="graphics/4730_12_05.jpg" alt="Flux stores"/></div><p>"This looks <a id="id349" class="indexterm"/>awesome, Mike!"</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec86"/>Summary</h1></div></div></div><p>We did a deep dive in Flux as an architecture. We saw Dispatcher act as a central hub to transmit our data and Actions to process them. We saw how the main responsibility to manipulate the state and update itself was delegated to the stores themselves. Finally, we saw how they were tied up together and made it easy to be used in views and share stores across the components.</p></div></body></html>