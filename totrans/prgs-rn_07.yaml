- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling Gestures in React Native
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important things that makes good apps stand out against bad
    apps or mobile websites is good gesture handling. While mobile websites only listen
    to simple clicks in most cases, apps can and should be controlled with different
    gestures such as short touches, long touches, swipes, pinching to zoom, or touches
    with multiple fingers. Using these gestures in a very intuitive way is one of
    the most important things to consider when developing an app.
  prefs: []
  type: TYPE_NORMAL
- en: But it doesn’t stop with just listening to these gestures – you have to give
    an immediate response to the user so that they can see (and maybe abort) what
    they are doing. Some gestures need to trigger or control animations and therefore
    have to play together very well with the animation solutions we learned about
    in [*Chapter 6*](B16694_06.xhtml#_idTextAnchor130), *Working with Animations*.
  prefs: []
  type: TYPE_NORMAL
- en: In React Native, there are multiple ways to handle gestures. From simple built-in
    components to very complex third-party gesture handling solutions, you have a
    lot of different options to choose from.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Using built-in components to respond to user gestures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the React Native gesture responder system and React Native `PanResponder`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding React Native Gesture Handler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be able to run the code in this chapter, you have to set up the following
    things:'
  prefs: []
  type: TYPE_NORMAL
- en: A working React Native environment ([bit.ly/prn-setup-rn](http://bit.ly/prn-setup-rn)
    – React Native CLI Quickstart)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A real iOS or Android device for testing gestures and multitouch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To access the code for this chapter, follow this link to the book’s GitHub
    repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Using built-in components to respond to user gestures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React Native ships with multiple components that have built-in gesture responder
    support. Basically, these components are an abstracted use of the gesture responder
    system, which you will learn about in the next section. The gesture responder
    system provides support for handling gestures in React Native, as well as support
    for negotiating which component should handle the user gesture.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest user interaction is a tap with one finger. With different `Touchable`
    components, a `Pressable` component, and a `Button` component, React Native provides
    different options for how to recognize the tap and respond to the user interaction.
  prefs: []
  type: TYPE_NORMAL
- en: Using components to respond to simple taps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simplest components to record user taps are the React Native `Touchable`
    components.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Touchable components
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'React Native provides three different `Touchable` components on iOS and an
    extra fourth `Touchable` component just for Android:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TouchableOpacity`: Provides user feedback automatically by reducing the opacity
    of the tapped element (and all child elements), letting the underlying view shine
    through. You can configure the opacity reduction by setting `activeOpacity`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TouchableHighlight`: Provides user feedback automatically by reducing the
    opacity and showing an underlying color, which darkens or lightens the tapped
    element. You can define the underlying color by setting `underlayColor` and the
    opacity reduction by setting `activeOpacity`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TouchableWithoutFeedback`: Provides no user feedback. You should only use
    this if you have a good reason since every element that responds to touches should
    show visual feedback. One reason could be that you handle the visual feedback
    somewhere else.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TouchableNativeFeedback`: For Android only. Provides user feedback automatically
    by triggering the native Android touch effect. On most devices, this is the well-known
    Android ripple effect, where the component changes the color by growing a circle
    from the point of touch. You can define the ripple effect by setting the `background`
    property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All four `Touchable` components provide four methods to listen to user interaction.
    These methods are called in the order of the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – The onPress call order'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16694_07_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.1 – The onPress call order
  prefs: []
  type: TYPE_NORMAL
- en: 'The important thing to always keep in mind is that `onPress` is called after
    `onPressOut`, while `onLongPress` is called before `onPressOut`. Let’s have a
    look at the methods in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onPressIn`: The method is called immediately when the user starts tapping
    the button.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onPressOut`: The method is called when the user releases the tap or when the
    user moves the finger outside of the component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onPress`: The method is called when the user completes the tap before a long
    press delay (defined in `delayLongPress`) is reached.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onLongPress`: The method is called when the long press delay (defined in `delayLongPress`)
    is reached and the tap wasn’t released in the meantime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these methods, you can already handle a lot of different use cases and
    – never forget – give immediate visual feedback to user touches.
  prefs: []
  type: TYPE_NORMAL
- en: While the `Touchable` components need some own styling, React Native also provides
    a `Button` component, which comes with predefined styles.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the Button component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Under the hood, `Button` uses `TouchableOpacity` on iOS and `TouchableNativeFeedback`
    on Android. `Button` comes with some predefined styling so that you can use it
    without styling it on your own. The following code example shows how simple it
    is to use `Button`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You only have to define an `onPress` method, a button `title`, and the `color`
    of the button. `Button` then handles the rest such as styling and visual user
    feedback. Of course, you can use all other methods of the `Touchable` components,
    too.
  prefs: []
  type: TYPE_NORMAL
- en: '`Button` and `Touchable` are quite old components in React Native. Since they
    work well, you can use them in most cases. But there is also a new implementation
    for handling user taps.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with the Pressable component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Besides the `Touchable` and `Button` components, React Native also comes with
    a `Pressable` component. This is the latest component and is recommended to be
    used due to its advanced support for platform-specific visual feedback.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following code example to understand the advantages of `Pressable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It provides the same methods as the `Touchable` components, but it also has
    ripple support on Android and works with custom styling on iOS. You can provide
    the `style` property as a function and listen to the `pressed` state.
  prefs: []
  type: TYPE_NORMAL
- en: You can also pass a functional component as a child to the `Pressable` component
    and use the `pressed` state there. This means you can change the styling and content
    of the `Pressable` component based on whether it is pressed at the moment or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another advantage is that you can define hit and offset areas for the `Pressable`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Pressable Hit and Press Areas'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16694_07_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.2 – Pressable Hit and Press Areas
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 7.2*, you can see the visible `Pressable` component in the center.
    If you want the touchable area to be larger than the visible element, you can
    do this by setting `hitSlop`. This is a very common thing to do for important
    buttons or important tappable areas of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: While `hitSlop` defines the area where the tap starts, `pressRetentionOffset`
    defines the additional distance outside of the `Pressable` component where the
    tap does not stop. This means when you start a tap inside the Hit Area and move
    your finger outside of the Hit Area, normally `onPressOut` is fired and the tap
    gesture is completed.
  prefs: []
  type: TYPE_NORMAL
- en: But if you have defined an additional Press Area and your gesture stays inside
    this Press Area, the tap gesture is considered a lasting gesture as long as your
    finger moves outside this Press Area. `hitSlop` and `pressRetention` can either
    be set as a `number` value or as a `Rect` value, which means as an `Object` with
    `bottom`, `left`, `right`, and `top` properties.
  prefs: []
  type: TYPE_NORMAL
- en: Hit Area and Press Area are both great methods to improve the user experience
    of your app as, for example, they can make it easier for users to press important
    buttons.
  prefs: []
  type: TYPE_NORMAL
- en: After looking at simple tap handling, let’s continue with scroll gestures.
  prefs: []
  type: TYPE_NORMAL
- en: Working with ScrollView
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The simplest method to handle scroll gestures is React Native `ScrollView`.
    This component makes the content inside of it scrollable if the content is larger
    than `ScrollView` itself. `ScrollView` detects and handles scroll gestures automatically.
    It has a lot of options you can configure, so let’s have a look at the most important
    ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`horizontal`: Defines whether `ScrollView` should be horizontal or vertical.
    The default is vertical.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`decelerationRate`: Defines how fast the scrolling will decelerate when the
    user releases the touch while scrolling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`snapToInterval` or `snapToOffsets`: With these two methods, you can define
    intervals or offsets at which `ScrollView` should stop. This can improve the user
    experience a lot because the scroll view can, for example, always stop so that
    the user can see a complete list element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scrollEventThrottle` for iOS only: Defines how often a scroll event will be
    triggered while scrolling. This is very important for performance and UX reasons.
    The best value for UX is 16, which means the scroll event is fired every 16 ms
    (until RN supports 120 Hz – then, it will become 8 ms).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on what you are doing with the scroll event, this can lead to performance
    problems because the scroll event is sent over the bridge every single time (unless
    you process it directly via the Animated API, as described in [*Chapter 6*](B16694_06.xhtml#_idTextAnchor130),
    *Working with Animations*). So, think about what value you need here and perhaps
    increase it to prevent performance problems.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot more configuration options such as defining over-scroll effects,
    sticky headers, or bounces. If you want to have a complete overview, please have
    a look at the documentation ([https://bit.ly/prn-scrollview](https://bit.ly/prn-scrollview)).
    Since this is not a beginner’s guide, we are focusing on the parts that are important
    to optimize your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Speaking of which, you can of course handle the scroll events by yourself when
    using the `ScrollView` component. This gives you a variety of options on how to
    optimize your UX. `ScrollView` provides the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onScroll`: Fires continuously during scrolling. This is a great tool to add
    awesome user feedback to the scroll gesture by coupling custom animations to the
    scroll event, as we did in [*Chapter 6*](B16694_06.xhtml#_idTextAnchor130), *Working
    with Animations*. But when doing so, you should either work with the Animated
    API with the native driver to prevent the scroll events from being transferred
    over the bridge every 16 ms or use `scrollEventThrottle` to limit the event count.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onScrollBeginDrag`: Fires when the user starts the scrolling gesture.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onScrollEndDrag`: Fires when the user stops the scrolling gesture.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onMomentumScrollBegin`: Fires when `ScrollView` starts moving.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onMomentumScrollEnd`: Fires when `ScrollView` stops moving.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these five methods, you can give your users a lot of different feedback
    for a scroll gesture. From simply informing the user when they are scrolling to
    building advanced animations with `onScroll`, everything is possible.
  prefs: []
  type: TYPE_NORMAL
- en: Notice
  prefs: []
  type: TYPE_NORMAL
- en: '`ScrollView` can become quite slow and memory hungry when it has a very long
    list of elements as children. This is due to `ScrollView` rendering all children
    at once. If you need a more performant version with lazy loading of elements,
    please have a look at React Native `FlatList` or `SectionList`.'
  prefs: []
  type: TYPE_NORMAL
- en: After working with the built-in React Native components, it’s time to have a
    look at handling touches completely by yourself. The first option to do that is
    to work directly with the React Native gesture responder system.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the gesture responder system and PanResponder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The gesture responder system is the foundation of handling gestures in React
    Native. All the `Touchable` components are based on the gesture responder system.
    With this system, you can not only listen to gestures but you can also specify
    which component should be the touch responder.
  prefs: []
  type: TYPE_NORMAL
- en: This is very important because there are several scenarios in which you have
    multiple touch responders on your screen (for example, `Slider` in a `ScrollView`).
    While most of the built-in components negotiate which component should become
    a touch responder and should handle the user input on their own, you have to think
    about it yourself when working directly with the gesture responder system.
  prefs: []
  type: TYPE_NORMAL
- en: The gesture responder system provides a simple API and can be used on any component.
    The first thing you have to do when working with the gesture responder system
    is to negotiate which component should become the responder to handle the gesture.
  prefs: []
  type: TYPE_NORMAL
- en: Becoming a responder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To become a responder, a component must implement one of these negotiation
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onStartShouldSetResponder`: If this method returns `true`, the component wants
    to become the responder at the start of a touch event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onMoveShouldSetResponder`: If this method returns `true`, the component wants
    to become the responder of a touch event. This method is called for every touch
    move event, as long as the component is not the responder.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important tip
  prefs: []
  type: TYPE_NORMAL
- en: These two methods are called on the deepest node first. This means that the
    deepest component will become the responder to the touch event when multiple components
    implement these methods and return `true`. Please keep that in mind when manually
    negotiating the responders.
  prefs: []
  type: TYPE_NORMAL
- en: You can prevent a child component from becoming the responder by implementing
    `onStartShouldSetResponderCapture` or `onMoveShouldSetResponderCapture`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For these responder negotiations, it is important for a component to release
    control if another component asks for it. The gesture responder system also provides
    handlers for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onResponderTerminationRequest`: If this handler returns `true`, the component
    releases the responder when another component wants to become the responder.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onResponseTerminate`: This handler is called when the responder was released.
    This can be due to `onResponderTerminationRequest` returning `true` or due to
    OS behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When a component tries to become the responder, there are two possible outcomes
    from the negotiation, which can both be handled with a handler method:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onResponderGrant`: This handler is called when it successfully became the
    responder and will then listen to touch events. It is best practice to use this
    method to highlight the component so that the user can see the element that responds
    to their touches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onResponderReject`: This handler is called when another component is currently
    the responder and will not release control.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When your component successfully becomes the responder, you can use handlers
    to listen to the touch events.
  prefs: []
  type: TYPE_NORMAL
- en: Handling touches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After becoming the responder, there are two handlers you can use to capture
    the touch events:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onResponderMove`: This handler is called when the user moves their finger
    on the screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onResponderRelease`: This handler is called when the user releases their touch
    from the device’s screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When working with gestures, you normally use `onResponderMove` and process the
    position values of the event it returns. When concatenating the positions, you
    can recreate the path the user draws on the screen. You can then respond to this
    path in the way you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'How this works in practice is shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This example contains two `View`. The outer `View` serves as the touch responder,
    while the inner `View` is a small circle, which changes position based on where
    the user moves the finger. The outer `View` implements the gesture responder system
    handlers, while the inner `View` just returns `false` for `onStartShouldSetResponder`,
    to not become the responder.
  prefs: []
  type: TYPE_NORMAL
- en: You also can see how the gesture responder system works with React Native Animated.
    When `onResponerMove` is called, we process the touch event and set the `pageX`
    and `pageY` values of the event to an `Animated.ValueXY`.
  prefs: []
  type: TYPE_NORMAL
- en: This is the value we then use to calculate the position of the inner `View`.
    When the user removes the finger from the device, `onResponderRelease` is called
    and we use an `Animated.spring` function to revert the `Animated.ValueXY` value
    back to its starting value. This positions the inner `View` back in the middle
    of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows how the code from the example looks on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – An example of the gesture responder system running on an iPhone'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16694_07_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.3 – An example of the gesture responder system running on an iPhone
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can see the starting state (the left-hand screen). Then, the user
    touches the bottom right of the screen and the blue circle follows the touch (mid-screen).
    After the user releases the touch, the blue circle returns to the center of the
    screen from the position where the user last touched the screen over a given time
    period (the right-hand screen shows the circle during the return animation).
  prefs: []
  type: TYPE_NORMAL
- en: Even with this simple example, you can see that the gesture responder system
    is a very powerful tool. You have full control over the touch events and can combine
    them with animations very easily. Nevertheless, most of the time, you won’t use
    the gesture responder system directly. This is because of `PanResponder`, which
    is a lightweight layer on top of the gesture responder system.
  prefs: []
  type: TYPE_NORMAL
- en: Using PanResponder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`PanResponder` basically works exactly as the gesture responder system does.
    It provides a similar API; however, you just have to replace `Responder` with
    `PanResponder`. For example, `onResponderMove` becomes `onPanResponderMove`. The
    difference is that you don’t just get the raw touch events. `PanResponder` also
    provides a state object, which represents the state of the whole gesture. This
    includes the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`stateID`: A unique identifier of the gesture'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dx`: The horizontal distance since the start of the touch gesture'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dy`: The vertical distance since the start of the touch gesture'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vx`: The current horizontal velocity of the touch gesture'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vy`: The current vertical velocity of the touch gesture'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This state object can be very useful when it comes to interpreting and processing
    more complex gestures. Due to this, most libraries and projects use `PanResponder`
    instead of working directly with the gesture responder system.
  prefs: []
  type: TYPE_NORMAL
- en: While the gesture responder system and `PanResponder` are very good options
    to respond to user touches, they also come with some downsides. First of all,
    they have the same limitations as the Animated API without the native driver.
    Since the touch events have to be transferred via the bridge to the JavaScript
    thread, we always are one frame behind.
  prefs: []
  type: TYPE_NORMAL
- en: This may become better with the JSI, but this has to be proven at this point.
    Another limitation is that no API allows us to define any interaction between
    the native gesture handlers. This means there will always be cases, which are
    not solvable with the gesture responder system API.
  prefs: []
  type: TYPE_NORMAL
- en: Because of these limitations, the team at Software Mansion with the support
    of Shopify and Expo built a new solution – React Native Gesture Handler.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding React Native Gesture Handler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React Native Gesture Handler is a third-party library that completely replaces
    the built-in gesture responder system while offering more control and higher performance.
  prefs: []
  type: TYPE_NORMAL
- en: React Native Gesture Handler works best in combination with Reanimated 2 because
    it was written by the same team and relies on the worklets provided by Reanimated
    2\.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: This book refers to React Native Gesture Handler version 2.0\. Version 1 is
    also used in a lot of projects.
  prefs: []
  type: TYPE_NORMAL
- en: The React Native Gesture Handler 2 API is based on `GestureDetectors` and `Gestures`.
    While it does also support the API from version 1, I would recommend using the
    new API, as it is easier to read and understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create the draggable circle example from the previous section, but this
    time we use React Native Gesture Handler and Reanimated 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, you can see how React Native Gesture Handler works. We create
    `GestureDetector` and wrap it with the element representing the target of the
    touch gesture. Then, we create a `Gesture` and assign it to `GestureDetector`.
    In this example, this is a `Pan` gesture, which means it recognizes dragging on
    the screen. `Gesture.Pan` provides a lot of different handlers. In this example,
    we use two:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onUpdate`: This handler is called every time any position of the gesture updates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onEnd`: This handler is called when the gesture is released'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use `onUpdate` to change the value of our Reanimated `sharedValue` and `onEnd`
    to reset the `sharedValue` to the initial state.
  prefs: []
  type: TYPE_NORMAL
- en: We then use the `sharedValue` to create `animatedStyle`, which we assign to
    our `Animated.View`, which is our circle.
  prefs: []
  type: TYPE_NORMAL
- en: 'The outcome on the screen is the same as in the previous section, but we have
    two important advantages here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Better performance**: Since we use Reanimated 2 worklets, our values and
    our calculation don’t have to pass the bridge. The gesture input and the animation
    are completely calculated on the UI thread.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Race`) or whether multiple gestures can become active at a time (`Simultaneous`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to that, React Native Gesture Handler ships with a lot of different
    gestures, such as `Tap`, `Rotation`, `Pinch`, `Fling`, or `ForceTouch`, as well
    as built-in components such as `Button`, `Swipeable`, `Touchable`, or `DrawerLayout`,
    which makes it a very good replacement for the built-in gesture responder system.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to get a deeper understanding of all the possible options you have
    with React Native Gesture Handler, please have a look at the documentation: [bit.ly/prn-gesture-handler](http://bit.ly/prn-gesture-handler).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about React Native’s built-in components and solutions
    to handle user gestures. From simple gestures such as single taps to more complex
    gestures, React Native provides stable solutions to handle gestures. We also had
    a look at React Native Gesture Handler, which is a great third-party replacement
    for these built-in solutions.
  prefs: []
  type: TYPE_NORMAL
- en: I would recommend using React Native’s built-in components and solutions for
    all use cases where you can stick to the standard components. As soon as you start
    writing your own gesture handling, I would recommend using React Native Gesture
    Handler.
  prefs: []
  type: TYPE_NORMAL
- en: After Animations and Gesture Handling, we will proceed with another topic, which
    is very important in terms of performance.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn what different JavaScript engines are, what
    options you have in React Native, and what impact the different engines have on
    performance and other important key metrics.
  prefs: []
  type: TYPE_NORMAL
