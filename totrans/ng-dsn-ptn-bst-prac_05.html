<html><head></head><body>
<div id="_idContainer035">
<h1 class="chapter-number" id="_idParaDest-85"><a id="_idTextAnchor163"/><a id="_idTextAnchor164"/><span class="koboSpan" id="kobo.1.1">5</span></h1>
<h1 id="_idParaDest-86"><a id="_idTextAnchor165"/><span class="koboSpan" id="kobo.2.1">Angular Services and the Singleton Pattern</span></h1>
<p><span class="koboSpan" id="kobo.3.1">One of the great differences between a static web page and a single-page application is the processing capacity and interaction in the user’s browser, giving the feeling of an application installed on the device. </span><span class="koboSpan" id="kobo.3.2">In the Angular framework, the elements for this processing and interaction, not </span><a id="_idIndexMarker234"/><span class="koboSpan" id="kobo.4.1">only with the backend but with the user, are </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">the </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.6.1">services</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.7.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.8.1">This element is so important to Angular that the team created a dependency management system, which allows a simplified way of creating, composing, and using services </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">in components.</span></span></p>
<p><span class="koboSpan" id="kobo.10.1">In this chapter, we will explore this element and learn about the design patterns it uses and the best practices to use in </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">your project.</span></span></p>
<p><span class="koboSpan" id="kobo.12.1">Here we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">following topics:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.14.1">Creating services</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Understanding the dependency </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">injection pattern</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Communication between components </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">using services</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">REST </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">API consumption</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.21.1">By the end of the chapter, you will be able to create reusable and maintainable services, in addition to understanding practices that will improve </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">your productivity.</span></span><a id="_idTextAnchor166"/></p>
<h1 id="_idParaDest-87"><a id="_idTextAnchor167"/><span class="koboSpan" id="kobo.23.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.24.1">To follow the instructions in this chapter, you’ll need </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.26.1">Visual Studio </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">Code (</span></span><a href="https://code.visualstudio.com/Download"><span class="No-Break"><span class="koboSpan" id="kobo.28.1">https://code.visualstudio.com/Download</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.29.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.30.1">Node.js 18 or </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">higher (</span></span><a href="https://nodejs.org/en/download/"><span class="No-Break"><span class="koboSpan" id="kobo.32.1">https://nodejs.org/en/download/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.33.1">)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.34.1">The code files for this chapter are available </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">at </span></span><a href="https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch5"><span class="No-Break"><span class="koboSpan" id="kobo.36.1">https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch5</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.37.1">.</span></span><a id="_idTextAnchor168"/><a id="_idTextAnchor169"/><a id="_idTextAnchor170"/><a id="_idTextAnchor171"/></p>
<h1 id="_idParaDest-88"><a id="_idTextAnchor172"/><span class="koboSpan" id="kobo.38.1">Creating services</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.39.1">Services</span></strong><span class="koboSpan" id="kobo.40.1"> in </span><a id="_idIndexMarker235"/><span class="koboSpan" id="kobo.41.1">Angular are TypeScript classes that aim to implement business logic for our interfaces. </span><span class="koboSpan" id="kobo.41.2">Business logic in a frontend project can seem like a controversial issue because ideally, all logic and processing should take place on the backend, which </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">is correct.</span></span></p>
<p><span class="koboSpan" id="kobo.43.1">Here we are using</span><a id="_idIndexMarker236"/><span class="koboSpan" id="kobo.44.1"> business rules; these rules are generic behaviors that do not depend on a visual component and can be reused in </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">other components.</span></span></p>
<p><span class="koboSpan" id="kobo.46.1">Examples of frontend business rules</span><a id="_idIndexMarker237"/><span class="koboSpan" id="kobo.47.1"> could be </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.49.1">Application </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">state control</span></span></li>
<li><span class="koboSpan" id="kobo.51.1">Communication with </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">the backend</span></span></li>
<li><span class="koboSpan" id="kobo.53.1">Information validations with a fixed rule, such as the number of digits in a </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">telephone number</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.55.1">We are going to put this concept into practice, and in our gym diary application, we are going to create the first service. </span><span class="koboSpan" id="kobo.55.2">In the command line we will use the </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">Angular CLI:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.57.1">
ng generate service diary/services/ExerciseSets</span></pre> <p><span class="koboSpan" id="kobo.58.1">Unlike the component, we can see that the element created by the Angular CLI is composed only of a TypeScript file (and its corresponding unit </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">test file).</span></span></p>
<p><span class="koboSpan" id="kobo.60.1">In this file, we </span><a id="_idIndexMarker238"/><span class="koboSpan" id="kobo.61.1">will see the boilerplate that the Angular </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">CLI generated:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.63.1">
import { Injectable } from '@angular/core';
@Injectable({
  providedIn: 'root'
})
export class ExerciseSetsService {
  constructor() { }
}</span></pre> <p><span class="koboSpan" id="kobo.64.1">Here we have a TypeScript class called </span><strong class="source-inline"><span class="koboSpan" id="kobo.65.1">ExerciseSetsService</span></strong><span class="koboSpan" id="kobo.66.1"> with a decorator called </span><strong class="source-inline"><span class="koboSpan" id="kobo.67.1">@Injectable</span></strong><span class="koboSpan" id="kobo.68.1">. </span><span class="koboSpan" id="kobo.68.2">It is this decorator that characterizes a service in Angular; we will see more details about it later in </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.70.1">Let’s refactor our</span><a id="_idIndexMarker239"/><span class="koboSpan" id="kobo.71.1"> project and place the initial series of sets for our diary in </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">this service.</span></span></p>
<p><span class="koboSpan" id="kobo.73.1">First, we’ll create the methods that will get the initial list and refresh it in </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">the backend:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.75.1">
private setList?: ExerciseSetList;
getInitialList(): ExerciseSetList {
  this.setList = [
    { id: 1, date: new Date(), exercise: 'Deadlift', reps: 15, sets: 3 },
    { id: 2, date: new Date(), exercise: 'Squat', reps: 15, sets: 3 },
    { id: 3, date: new Date(), exercise: 'Barbell row', reps: 15, sets: 3 },
  ];
  return this.setList;
}
refreshList(): ExerciseSetList {
  this.setList = [
    { id: 1, date: new Date(), exercise: 'Deadlift', reps: 15, sets: 3 },
    { id: 2, date: new Date(), exercise: 'Squat', reps: 15, sets: 3 },
    { id: 3, date: new Date(), exercise: 'Barbell row', reps: 15, sets: 3 },
    { id: 4, date: new Date(), exercise: 'Leg Press', reps: 15, sets: 3 },
  ];
  return this.setList;
}</span></pre> <p><span class="koboSpan" id="kobo.76.1">In the service, we move the initialization and refresh of the journal component into the service, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">getInitialList</span></strong><span class="koboSpan" id="kobo.78.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">refreshList</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.80.1"> methods.</span></span></p>
<p><span class="koboSpan" id="kobo.81.1">These methods will be improved when we see the communication with the backend, but here, we are already decoupling the exercise list management business rule from the component that renders the user interface, creating a </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">specific service.</span></span></p>
<p><span class="koboSpan" id="kobo.83.1">Let’s now consider </span><a id="_idIndexMarker240"/><span class="koboSpan" id="kobo.84.1">the method that adds an item to the </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">exercise list:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.86.1">
addNewItem(item: ExerciseSet): ExerciseSetList {
  if (this.setList) {
    this.setList = [...this.setList, item];
  } else {
    this.setList = [item];
  }
  return this.setList;
}</span></pre> <p><span class="koboSpan" id="kobo.87.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">setList</span></strong><span class="koboSpan" id="kobo.89.1"> attribute of the service can be null, so here we use the TypeScript type guard concept (more details in </span><a href="B19562_03.xhtml#_idTextAnchor112"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.90.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.91.1">, </span><em class="italic"><span class="koboSpan" id="kobo.92.1">TypeScript Patterns for Angular</span></em><span class="koboSpan" id="kobo.93.1">) to manipulate the array. </span><span class="koboSpan" id="kobo.93.2">Here, we also use the concept of immutability by returning a new array after adding the </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">new element.</span></span></p>
<p><span class="koboSpan" id="kobo.95.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">DiaryComponent</span></strong><span class="koboSpan" id="kobo.97.1"> component, we will use the service </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">we created:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.99.1">
export class DiaryComponent {
  constructor(private exerciseSetsService: ExerciseSetsService) {}
  exerciseList = this.exerciseSetsService.getInitialList();
  newList() {
    this.exerciseList = this.exerciseSetsService.refreshList();
  }
  addExercise(newSet: ExerciseSet) {
    this.exerciseList = this.exerciseSetsService.addNewItem(newSet);
  }
}</span></pre> <p><span class="koboSpan" id="kobo.100.1">In the component, the first thing we can observe is the use of the class constructor, declaring an </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">exerciseSetsService</span></strong><span class="koboSpan" id="kobo.102.1"> private attribute of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">ExerciseSetsService</span></strong><span class="koboSpan" id="kobo.104.1">. </span><span class="koboSpan" id="kobo.104.2">With this declaration, we have an object instantiated and we refactor our component, replacing the initialization of the list and the refresh action with </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">service methods.</span></span></p>
<p><span class="koboSpan" id="kobo.106.1">From now on, it is no longer a concern of the component how the exercise list is obtained and managed; this is the responsibility of the service, and we can now use this service in other components if necessary. </span><span class="koboSpan" id="kobo.106.2">In this piece of code, you may be wondering why we are using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">ExerciseSetsService</span></strong><span class="koboSpan" id="kobo.108.1"> service if we did not instantiate an object of </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">that </span></span><span class="No-Break"><a id="_idIndexMarker241"/></span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">class.</span></span></p>
<p><span class="koboSpan" id="kobo.111.1">Here, we have a great feature of Angular, which is the dependency injection mechanism, and we will delve into this </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">topi</span><a id="_idTextAnchor173"/><span class="koboSpan" id="kobo.113.1">c next.</span></span></p>
<h1 id="_idParaDest-89"><a id="_idTextAnchor174"/><span class="koboSpan" id="kobo.114.1">Understanding the dependency injection pattern</span></h1>
<p><span class="koboSpan" id="kobo.115.1">In object-oriented</span><a id="_idIndexMarker242"/><span class="koboSpan" id="kobo.116.1"> software development, it is good practice to prioritize composition over inheritance, meaning that a class should be composed of other classes (</span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">preferably interfaces).</span></span></p>
<p><span class="koboSpan" id="kobo.118.1">In our previous example, we can see that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">service</span></strong><span class="koboSpan" id="kobo.120.1"> class comprises the </span><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">DiaryComponent</span></strong><span class="koboSpan" id="kobo.122.1"> component. </span><span class="koboSpan" id="kobo.122.2">Another way to use this service would be </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.124.1">
. </span><span class="koboSpan" id="kobo.124.2">. </span><span class="koboSpan" id="kobo.124.3">.
</span><span class="koboSpan" id="kobo.124.4">export class DiaryComponent {
  private exerciseSetsService: ExerciseSetsService;
  exerciseList: ExerciseSetList;
  constructor() {
    this.exerciseSetsService = new ExerciseSetsService();
    this.exerciseList = this.exerciseSetsService.getInitialList();
  }
. </span><span class="koboSpan" id="kobo.124.5">. </span><span class="koboSpan" id="kobo.124.6">.
</span><span class="koboSpan" id="kobo.124.7">}</span></pre> <p><span class="koboSpan" id="kobo.125.1">Here we modify our code, leaving the creation of the service class object expressly in the component’s constructor method. </span><span class="koboSpan" id="kobo.125.2">Running our code again, we can see that the interface remains </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">the</span></span><span class="No-Break"><a id="_idIndexMarker243"/></span><span class="No-Break"><span class="koboSpan" id="kobo.127.1"> same.</span></span></p>
<p><span class="koboSpan" id="kobo.128.1">This approach, although functional, has some problems, such as </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.130.1">High coupling between the component and the service, which means that we may encounter problems if we need to change the implementation of the service, for example, for the construction of </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">unit tests</span></span></li>
<li><span class="koboSpan" id="kobo.132.1">If the service depends on another class, as we will see with Angular’s HTTP request service, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">HttpClient</span></strong><span class="koboSpan" id="kobo.134.1"> class, we will have to implement this dependency in our component, increasing </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">its complexity</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.136.1">To simplify development and solve the problems we’ve described, Angular has a dependency injection mechanism. </span><span class="koboSpan" id="kobo.136.2">This feature allows us to compose a class just by declaring the object we need in </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">its constructor.</span></span></p>
<p><span class="koboSpan" id="kobo.138.1">Angular, leveraging TypeScript, will use the types defined in this declaration to assemble the dependency tree of the class we need and create the object </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">we require.</span></span></p>
<p><span class="koboSpan" id="kobo.140.1">Let’s return to our code and analyze how this </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">mechanism works:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.142.1">
. </span><span class="koboSpan" id="kobo.142.2">. </span><span class="koboSpan" id="kobo.142.3">.
</span><span class="koboSpan" id="kobo.142.4">export class DiaryComponent {
  constructor(private exerciseSetsService: ExerciseSetsService) {}
  exerciseList = this.exerciseSetsService.getInitialList();
. </span><span class="koboSpan" id="kobo.142.5">. </span><span class="koboSpan" id="kobo.142.6">.
</span><span class="koboSpan" id="kobo.142.7">}</span></pre> <p><span class="koboSpan" id="kobo.143.1">In the code, we declare the dependency of our class in the constructor, creating the </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">exerciseSetsService</span></strong><span class="koboSpan" id="kobo.145.1"> attribute. </span><span class="koboSpan" id="kobo.145.2">With this, we can initialize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">exerciseList</span></strong><span class="koboSpan" id="kobo.147.1"> attribute in </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">its declaration.</span></span></p>
<p><span class="koboSpan" id="kobo.149.1">In </span><a href="B19562_10.xhtml#_idTextAnchor264"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.150.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.151.1">, </span><em class="italic"><span class="koboSpan" id="kobo.152.1">Design for Tests: Best Practices</span></em><span class="koboSpan" id="kobo.153.1">, we will replace the implementation of this service in the test runtime. </span><span class="koboSpan" id="kobo.153.2">All this is possible thanks to Angular’s dependency </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">injection feature.</span></span></p>
<p><span class="koboSpan" id="kobo.155.1">From version 14 of Angular, we have an </span><a id="_idIndexMarker244"/><span class="koboSpan" id="kobo.156.1">alternative for dependency injection that we can use, which w</span><a id="_idTextAnchor175"/><span class="koboSpan" id="kobo.157.1">e will</span><a id="_idTextAnchor176"/> <span class="No-Break"><span class="koboSpan" id="kobo.158.1">see next.</span></span></p>
<h2 id="_idParaDest-90"><a id="_idTextAnchor177"/><span class="koboSpan" id="kobo.159.1">Using the inject() function</span></h2>
<p><span class="koboSpan" id="kobo.160.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">inject()</span></strong><span class="koboSpan" id="kobo.162.1"> function allows</span><a id="_idIndexMarker245"/><span class="koboSpan" id="kobo.163.1"> you to use the same dependency injection feature but in a </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">simpler way.</span></span></p>
<p><span class="koboSpan" id="kobo.165.1">Let’s refactor our </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">component’s code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.167.1">
import { Component, </span><strong class="bold"><span class="koboSpan" id="kobo.168.1">inject</span></strong><span class="koboSpan" id="kobo.169.1"> } from '@angular/core';
import { ExerciseSet } from '../interfaces/exercise-set';
import { ExerciseSetsService } from '../services/exercise-sets.service';
. </span><span class="koboSpan" id="kobo.169.2">. </span><span class="koboSpan" id="kobo.169.3">.
</span><span class="koboSpan" id="kobo.169.4">export class DiaryComponent {
  private exerciseSetsService = inject(ExerciseSetsService);
  exerciseList = this.exerciseSetsService.getInitialList();
. </span><span class="koboSpan" id="kobo.169.5">. </span><span class="koboSpan" id="kobo.169.6">.
</span><span class="koboSpan" id="kobo.169.7">}</span></pre> <p><span class="koboSpan" id="kobo.170.1">Here we remove the constructor declaration for the dependency injection and directly declare the </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">exerciseSetsService</span></strong><span class="koboSpan" id="kobo.172.1"> service. </span><span class="koboSpan" id="kobo.172.2">For the creation of the object, we use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">inject</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.174.1"> function.</span></span></p>
<p><span class="koboSpan" id="kobo.175.1">A point of note is that we are using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">inject</span></strong><span class="koboSpan" id="kobo.177.1"> function of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">@angular/core</span></strong><span class="koboSpan" id="kobo.179.1"> module and not the function present in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">@angular/core/testing</span></strong><span class="koboSpan" id="kobo.181.1"> module, which will be used for </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">another purpose.</span></span></p>
<p><span class="koboSpan" id="kobo.183.1">This method, in addition to being simpler and clearer (the service is being injected by the function), allows the simplification of development, if it is necessary to use inheritance for a specific component. </span><span class="koboSpan" id="kobo.183.2">Remembering that good practice says we should prefer composition over inheritance, but especially in libraries, this feature can </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">be interesting.</span></span></p>
<p><span class="koboSpan" id="kobo.185.1">A point of note for the use of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">inject</span></strong><span class="koboSpan" id="kobo.187.1"> function is that it can only be used in the component’s construction phase, that is, in the declaration of the method’s property or in the class’s </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">constructor method.</span></span></p>
<p><span class="koboSpan" id="kobo.189.1">Any use in another </span><a id="_idIndexMarker246"/><span class="koboSpan" id="kobo.190.1">context will generate the following </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">compilation error:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.192.1">
inject() must be called from an injection context
such as a constructor, a factory function, a field initializer,
or a function used with `runInInjectionContext`.</span></pre> <p><span class="koboSpan" id="kobo.193.1">Let’s now delve into another aspect of Angular services, which is the use of the singleton design pattern, and how we can use this capability for communication </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">between</span><a id="_idTextAnchor178"/><span class="koboSpan" id="kobo.195.1"> components.</span></span></p>
<h1 id="_idParaDest-91"><a id="_idTextAnchor179"/><span class="koboSpan" id="kobo.196.1">Communication between components using services</span></h1>
<p><span class="koboSpan" id="kobo.197.1">A characteristic that we </span><a id="_idIndexMarker247"/><span class="koboSpan" id="kobo.198.1">must understand about Angular services is that, by default, every service instantiated by the dependency injection mechanism has the same reference; that is, a new object is not created, </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">but reused.</span></span></p>
<p><span class="koboSpan" id="kobo.200.1">This is because the dependency injection mechanism implements the singleton design pattern to create and deliver the objects. </span><span class="koboSpan" id="kobo.200.2">The </span><strong class="bold"><span class="koboSpan" id="kobo.201.1">singleton pattern</span></strong><span class="koboSpan" id="kobo.202.1"> is a </span><a id="_idIndexMarker248"/><span class="koboSpan" id="kobo.203.1">design pattern of the creational type and allows the creation of objects whose access will be global in </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">the system.</span></span></p>
<p><span class="koboSpan" id="kobo.205.1">This characteristic</span><a id="_idIndexMarker249"/><span class="koboSpan" id="kobo.206.1"> is important for the service because, as the service deal with reusable business rules, we can use the same instance between components, without having to rebuild the entire object. </span><span class="koboSpan" id="kobo.206.2">In addition, we can take advantage of this characteristic and use services as an alternative for communication </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">between components.</span></span></p>
<p><span class="koboSpan" id="kobo.208.1">Let’s change our gym diary so that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">ListEntriesComponent</span></strong><span class="koboSpan" id="kobo.210.1"> component receives the initial list by service instead </span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">@Input</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.214.1">
export class ListEntriesComponent {
  private exerciseSetsService = inject(ExerciseSetsService);
  exerciseList = this.exerciseSetsService.getInitialList();
  itemTrackBy(index: number, item: ExerciseSet) {
    return item.id;
  }
}</span></pre> <p><span class="koboSpan" id="kobo.215.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">DiaryComponent</span></strong><span class="koboSpan" id="kobo.217.1"> component, we will remove the list from </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">the input:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.219.1">
&lt;main class="mx-auto mt-8 max-w-6xl px-4"&gt;
  &lt;app-list-entries /&gt;
  &lt;app-new-item-button (newExerciseEvent)="addExercise($event)" /&gt;
  &lt;br /&gt;
  &lt;br /&gt;
  &lt;button
    class="rounded bg-blue-500 py-2 px-4 font-bold text-white hover:bg-blue-700"
    (click)="newList()"
  &gt;
    Server Sync
  &lt;/button&gt;
&lt;/main&gt;</span></pre> <p><span class="koboSpan" id="kobo.220.1">Running it again we can see that the list continues to appear. </span><span class="koboSpan" id="kobo.220.2">This is because the instance of the service used in both components is the same. </span><span class="koboSpan" id="kobo.220.3">However, this form of communication requires us to use RxJS to update the values with the buttons on the diary screen. </span><span class="koboSpan" id="kobo.220.4">We will go deeper into this topic in </span><a href="B19562_09.xhtml#_idTextAnchor242"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.221.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.222.1">, </span><em class="italic"><span class="koboSpan" id="kobo.223.1">Exploring Reactivity </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.224.1">with RxJS</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.226.1">We saw that, by default, the </span><a id="_idIndexMarker250"/><span class="koboSpan" id="kobo.227.1">services are singleton, but in Angular, it is possible to change this configuration for another service if you need to solve some corner cases in </span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">your application.</span></span></p>
<p><span class="koboSpan" id="kobo.229.1">When we create a service, it has an </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">@Injectable</span></strong><span class="koboSpan" id="kobo.231.1"> decorator, as in </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">our example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.233.1">
@Injectable({
  providedIn: 'root',
})
export class ExerciseSetsService {</span></pre> <p><span class="koboSpan" id="kobo.234.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">provideIn</span></strong><span class="koboSpan" id="kobo.236.1"> metadata determines the scope of the service. </span><span class="koboSpan" id="kobo.236.2">The value </span><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">'root'</span></strong><span class="koboSpan" id="kobo.238.1"> means that the instance of the service will be unique for every application; that’s why, by default, Angular services </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">are singleton.</span></span></p>
<p><span class="koboSpan" id="kobo.240.1">To change this behavior, let’s first return to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">ListEntriesComponent</span></strong><span class="koboSpan" id="kobo.242.1"> component to receive </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">Input</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.246.1">
export class ListEntriesComponent {
  @Input() exerciseList!: ExerciseSetList;
  itemTrackBy(index: number, item: ExerciseSet) {
    return item.id;
  }
}</span></pre> <p><span class="koboSpan" id="kobo.247.1">Let’s go back to</span><a id="_idIndexMarker251"/><span class="koboSpan" id="kobo.248.1"> inform the attribute in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">DiaryComponent</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.250.1"> component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.251.1">
&lt;main class="mx-auto mt-8 max-w-6xl px-4"&gt;
  &lt;app-list-entries [exerciseList]="exerciseList" /&gt;
  &lt;app-new-item-button (newExerciseEvent)="addExercise($event)" /&gt;
  &lt;br /&gt;
  &lt;br /&gt;
  &lt;button
    class="rounded bg-blue-500 py-2 px-4 font-bold text-white hover:bg-blue-700"
    (click)="newList()"
  &gt;
    Server Sync
  &lt;/button&gt;
&lt;/main&gt;</span></pre> <p><span class="koboSpan" id="kobo.252.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">ExerciseSetsService</span></strong><span class="koboSpan" id="kobo.254.1"> service, we will remove the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">provideIn</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.256.1"> metadata:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.257.1">
@Injectable()
export class ExerciseSetsService {</span></pre> <p><span class="koboSpan" id="kobo.258.1">If we run our application now, the following error </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">will occur:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.260.1">
ERROR Error: Uncaught (in promise): NullInjectorError: R3InjectorError(DiaryModule)[ExerciseSetsService -&gt; ExerciseSetsService -&gt; ExerciseSetsService -&gt; ExerciseSetsService]: NullInjectorError: No provider for ExerciseSetsService!</span></pre> <p><span class="koboSpan" id="kobo.261.1">This error happens when we inform Angular that the service should not be instantiated in the application scope. </span><span class="koboSpan" id="kobo.261.2">To resolve this error, let’s declare the use of the service directly in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">DiaryComponent</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.263.1"> component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.264.1">
@Component({
  templateUrl: './diary.component.html',
  styleUrls: ['./diary.component.css'],
  providers: [ExerciseSetsService],
})
export class DiaryComponent {</span></pre> <p><span class="koboSpan" id="kobo.265.1">So, our system works again, and the component has its own instance of </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">the service.</span></span></p>
<p><span class="koboSpan" id="kobo.267.1">This technique, however, must be used in specific cases where the component must have its own instance </span><a id="_idIndexMarker252"/><span class="koboSpan" id="kobo.268.1">of the services it uses; it is recommended to leave the </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">provideIn</span></strong><span class="koboSpan" id="kobo.270.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">the services.</span></span></p>
<p><span class="koboSpan" id="kobo.272.1">Let’s now start exploring our application’s communication with the back</span><a id="_idTextAnchor180"/><span class="koboSpan" id="kobo.273.1">end </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">using Angular.</span></span></p>
<h1 id="_idParaDest-92"><a id="_idTextAnchor181"/><span class="koboSpan" id="kobo.275.1">REST API consumption</span></h1>
<p><span class="koboSpan" id="kobo.276.1">One of the main uses of Angular services is undoubtedly communication with the backend of the</span><a id="_idIndexMarker253"/><span class="koboSpan" id="kobo.277.1"> application, using the </span><strong class="bold"><span class="koboSpan" id="kobo.278.1">Representational State Transfer</span></strong><span class="koboSpan" id="kobo.279.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.280.1">REST</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">) protocol.</span></span></p>
<p><span class="koboSpan" id="kobo.282.1">Let’s learn about this feature in practice by preparing our project to consume </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">its backend.</span></span></p>
<p><span class="koboSpan" id="kobo.284.1">First, let’s upload the</span><a id="_idIndexMarker254"/><span class="koboSpan" id="kobo.285.1"> backend locally by accessing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">gym-diary-backend</span></strong><span class="koboSpan" id="kobo.287.1"> folder and using the following command in your </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">command-line prompt:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.289.1">
npm start</span></pre> <p><span class="koboSpan" id="kobo.290.1">We can leave this command running and can now create the services for the consumption of </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">the API.</span></span></p>
<p><span class="koboSpan" id="kobo.292.1">To carry out this consumption, Angular has a specialized service – </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">HttpClient</span></strong><span class="koboSpan" id="kobo.294.1">. </span><span class="koboSpan" id="kobo.294.2">To use it, we will first import its module into the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">app.module.ts</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.296.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.297.1">
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { AppRoutingModule } from './app-routing.module';
</span><strong class="bold"><span class="koboSpan" id="kobo.298.1">import { HttpClientModule } from '@angular/common/http';</span></strong><span class="koboSpan" id="kobo.299.1">
import { AppComponent } from './app.component';
@NgModule({
  declarations: [AppComponent],
  imports: [BrowserModule, AppRoutingModule, </span><strong class="bold"><span class="koboSpan" id="kobo.300.1">HttpClientModule</span></strong><span class="koboSpan" id="kobo.301.1">],
  providers: [],
  bootstrap: [AppComponent],
})
export class AppModule {}</span></pre> <p><span class="koboSpan" id="kobo.302.1">Our project’s </span><a id="_idIndexMarker255"/><span class="koboSpan" id="kobo.303.1">backend API returns some JSON, containing the list of exercises for the day. </span><span class="koboSpan" id="kobo.303.2">As good practice, we should create an interface to facilitate typing and the manipulation of the results in our frontend application. </span><span class="koboSpan" id="kobo.303.3">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">exercise-set.ts</span></strong><span class="koboSpan" id="kobo.305.1"> file, we will add the </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">following interface:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.307.1">
export interface ExerciseSetListAPI {
  hasNext: boolean;
  items: ExerciseSetList;
}</span></pre> <p><span class="koboSpan" id="kobo.308.1">Now we can refactor our </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">ExerciseSetsService</span></strong><span class="koboSpan" id="kobo.310.1"> service to </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">use </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">HttpClient</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.314.1">
export class ExerciseSetsService {
  private httpClient = inject(HttpClient);
  private url = 'http://localhost:3000/diary';
  getInitialList(): Observable&lt;ExerciseSetListAPI&gt; {
    return this.httpClient.get&lt;ExerciseSetListAPI&gt;(this.url);
  }
  refreshList(): Observable&lt;ExerciseSetListAPI&gt; {
    return this.httpClient.get&lt;ExerciseSetListAPI&gt;(this.url);
  }
}</span></pre> <p><span class="koboSpan" id="kobo.315.1">First, we inject the </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">HttpClient</span></strong><span class="koboSpan" id="kobo.317.1"> service into our class using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">inject</span></strong><span class="koboSpan" id="kobo.319.1"> function. </span><span class="koboSpan" id="kobo.319.2">We then create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">url</span></strong><span class="koboSpan" id="kobo.321.1"> variable to contain the endpoint of this service that will be used in the </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">service’s methods.</span></span></p>
<p><span class="koboSpan" id="kobo.323.1">Finally, we </span><a id="_idIndexMarker256"/><span class="koboSpan" id="kobo.324.1">refactor the </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">getInitialList</span></strong><span class="koboSpan" id="kobo.326.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">refreshList</span></strong><span class="koboSpan" id="kobo.328.1"> methods to consume the project’s API. </span><span class="koboSpan" id="kobo.328.2">Initially, they have the same implementation, but we will improve this code throughout </span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">the book.</span></span></p>
<p><span class="koboSpan" id="kobo.330.1">An important change was made so that the method does not return the list of exercises, but an Observable that contains the list of exercises. </span><span class="koboSpan" id="kobo.330.2">This occurs because the operation involving consuming a REST API happens asynchronously, and through the use of RxJS and its Observables, Angular handles this asynchronicity. </span><span class="koboSpan" id="kobo.330.3">We will go deeper into this topic in </span><a href="B19562_09.xhtml#_idTextAnchor242"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.331.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.332.1">, </span><em class="italic"><span class="koboSpan" id="kobo.333.1">Exploring Reactivity </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.334.1">with RxJS</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.336.1">Using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">HttpClient</span></strong><span class="koboSpan" id="kobo.338.1"> service to consume a </span><em class="italic"><span class="koboSpan" id="kobo.339.1">GET-type</span></em><span class="koboSpan" id="kobo.340.1"> API, we declare the return type represented here by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">ExerciseSetListAPI</span></strong><span class="koboSpan" id="kobo.342.1"> type and the service’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">get</span></strong><span class="koboSpan" id="kobo.344.1"> method, passing the URL of the endpoint that we are going to consume as </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">a parameter.</span></span></p>
<p><span class="koboSpan" id="kobo.346.1">Let’s now add the other methods to complete </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">our service:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.348.1">
addNewItem(item: ExerciseSet): Observable&lt;ExerciseSet&gt; {
  return this.httpClient.post&lt;ExerciseSet&gt;(this.url, item);
 }
updateItem(id: string, item: ExerciseSet): Observable&lt;ExerciseSet&gt; {
  return this.httpClient.put&lt;ExerciseSet&gt;(`${this.url}/${id}`, item);
  deleteItem(id: string): Observable&lt;boolean&gt; {
    return this.httpClient.delete&lt;boolean&gt;(`${this.url}/${id}`);
  }
}</span></pre> <p><span class="koboSpan" id="kobo.349.1">For the inclusion of a new set, we are using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">POST</span></strong><span class="koboSpan" id="kobo.351.1"> method of the service that calls the API with the verb of the same name. </span><span class="koboSpan" id="kobo.351.2">We always pass the URL and, in this case, the body of the request will be a new set </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">of exercises.</span></span></p>
<p><span class="koboSpan" id="kobo.353.1">To update the set, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">PUT</span></strong><span class="koboSpan" id="kobo.355.1"> method passing the body, and for the URL, we use the string interpolation to pass the </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">id</span></strong><span class="koboSpan" id="kobo.357.1"> value that the API demands in your contract. </span><span class="koboSpan" id="kobo.357.2">Finally, to delete, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">DELETE</span></strong><span class="koboSpan" id="kobo.359.1"> method, and also using interpolation, we pass the </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">id</span></strong><span class="koboSpan" id="kobo.361.1"> value of the element we want </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">to delete.</span></span></p>
<p><span class="koboSpan" id="kobo.363.1">Let’s tailor our </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">DiaryComponent</span></strong><span class="koboSpan" id="kobo.365.1"> component to consume the refactored service. </span><span class="koboSpan" id="kobo.365.2">Our challenge here is to deal with the asynchrony of consuming a REST API via an </span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">HTTP request.</span></span></p>
<p><span class="koboSpan" id="kobo.367.1">First, let’s adjust the</span><a id="_idIndexMarker257"/><span class="koboSpan" id="kobo.368.1"> initialization of the list </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">of exercises:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.370.1">
@Component({
  templateUrl: './diary.component.html',
  styleUrls: ['./diary.component.css'],
})
export class DiaryComponent implements OnInit {
  private exerciseSetsService = inject(ExerciseSetsService);
  exerciseList!: ExerciseSetList;
  ngOnInit(): void {
    this.exerciseSetsService
      .getInitialList()
      .subscribe((dataApi) =&gt; (this.exerciseList = dataApi.items));
  }
}</span></pre> <p><span class="koboSpan" id="kobo.371.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">DiaryComponent</span></strong><span class="koboSpan" id="kobo.373.1"> class, we will implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">OnInit</span></strong><span class="koboSpan" id="kobo.375.1"> interface and create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">onInit</span></strong><span class="koboSpan" id="kobo.377.1"> method. </span><span class="koboSpan" id="kobo.377.2">This method is one of the lifecycle events of Angular components, which means that it will be called at some point by Angular when building and rendering </span><span class="No-Break"><span class="koboSpan" id="kobo.378.1">the interface.</span></span></p>
<p><span class="koboSpan" id="kobo.379.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">onInit</span></strong><span class="koboSpan" id="kobo.381.1"> method is called after building the component, but before rendering the component. </span><span class="koboSpan" id="kobo.381.2">We need to implement this method because the filling of the list of exercises will occur asynchronously. </span><span class="koboSpan" id="kobo.381.3">Implementing this initialization in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">onInit</span></strong><span class="koboSpan" id="kobo.383.1"> method will ensure that the data will be there when Angular starts rendering </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">the screen.</span></span></p>
<p><span class="koboSpan" id="kobo.385.1">In this method, we are </span><a id="_idIndexMarker258"/><span class="koboSpan" id="kobo.386.1">using the service, but as it now returns an Observable, we need to call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">subscribe</span></strong><span class="koboSpan" id="kobo.388.1"> method and, within it, implement the initialization of the list. </span><span class="koboSpan" id="kobo.388.2">As we are using the smart and presentation component architecture, we can implement the button methods in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">DiaryComponent</span></strong><span class="koboSpan" id="kobo.390.1"> smart component </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.392.1">
newList() {
  this.exerciseSetsService
    .refreshList()
    .subscribe((dataApi) =&gt; (this.exerciseList = dataApi.items));
}
addExercise(newSet: ExerciseSet) {
  this.exerciseSetsService
    .addNewItem(newSet)
    .subscribe((_) =&gt; this.newList());
}
deleteItem(id: string) {
  this.exerciseSetsService.deleteItem(id).subscribe(() =&gt; {
    this.exerciseList = this.exerciseList.filter(
      (exerciseSet) =&gt; exerciseSet.id !== id
    );
  });
}
newRep(updateSet: ExerciseSet) {
  const id = updateSet.id ?? </span><span class="koboSpan" id="kobo.392.2">'';
  this.exerciseSetsService
    .updateItem(id, updateSet)
    .subscribe();
}</span></pre> <p><span class="koboSpan" id="kobo.393.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">newList</span></strong><span class="koboSpan" id="kobo.395.1"> method, we</span><a id="_idIndexMarker259"/><span class="koboSpan" id="kobo.396.1"> refactored this to fetch the list elements through the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">refreshList</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.398.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.399.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">addExercise</span></strong><span class="koboSpan" id="kobo.401.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">deleteItem</span></strong><span class="koboSpan" id="kobo.403.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">newRep</span></strong><span class="koboSpan" id="kobo.405.1"> methods, we refactored the previous logic to use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">exe</span><a id="_idTextAnchor182"/><span class="koboSpan" id="kobo.407.1">rciseSetsService</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.408.1"> service.</span></span></p>
<h1 id="_idParaDest-93"><a id="_idTextAnchor183"/><span class="koboSpan" id="kobo.409.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.410.1">In this chapter, we learned about Angular services and how to correctly isolate the business rule from our applications in a simple and reusable way, as well as how Angular services use the singleton pattern for memory and </span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">performance optimization.</span></span></p>
<p><span class="koboSpan" id="kobo.412.1">We worked with and studied Angular’s dependency injection mechanism and noticed how important it is to be able to organize and reuse services between components and other services. </span><span class="koboSpan" id="kobo.412.2">We also learned how to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">inject</span></strong><span class="koboSpan" id="kobo.414.1"> function for Angular services as an alternative to dependency injection via </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">Angular’s constructor.</span></span></p>
<p><span class="koboSpan" id="kobo.416.1">Finally, we worked with one of the main uses of services, communication with the backend, and in this chapter, we began to explore the integration of our frontend applications with </span><span class="No-Break"><span class="koboSpan" id="kobo.417.1">the backend.</span></span></p>
<p><span class="koboSpan" id="kobo.418.1">In the next chapter, we will study the best practices for using forms, the main way that our users enter inf</span><a id="_idTextAnchor184"/><span class="koboSpan" id="kobo.419.1">ormation into </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">our systems.</span></span></p>
</div>


<div class="Content" id="_idContainer036">
<h1 id="_idParaDest-94" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor185"/><span class="koboSpan" id="kobo.1.1">Part 2: Leveraging Angular’s Capabilities</span></h1>
<p><span class="koboSpan" id="kobo.2.1">In this part, you will work with more advanced aspects of Angular and see how you can use the features of this framework for the most common tasks in your applications. </span><span class="koboSpan" id="kobo.2.2">You will learn about best practices for forms, how to correctly use Angular’s routing mechanism, and finally, how to optimize API consumption using the Interceptor design pattern and the </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">RxJS library.</span></span></p>
<p><span class="koboSpan" id="kobo.4.1">This part has the </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">following chapters:</span></span></p>
<ul>
<li><a href="B19562_06.xhtml#_idTextAnchor186"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 6</span></em></a><em class="italic"><span class="koboSpan" id="kobo.7.1">, Handling User Inputs: Forms</span></em></li>
<li><a href="B19562_07.xhtml#_idTextAnchor207"><em class="italic"><span class="koboSpan" id="kobo.8.1">Chapter 7</span></em></a><em class="italic"><span class="koboSpan" id="kobo.9.1">, Routes and Routers</span></em></li>
<li><a href="B19562_08.xhtml#_idTextAnchor225"><em class="italic"><span class="koboSpan" id="kobo.10.1">Chapter 8</span></em></a><em class="italic"><span class="koboSpan" id="kobo.11.1">, Improving Backend Integrations: the Interceptor Pattern</span></em></li>
<li><a href="B19562_09.xhtml#_idTextAnchor242"><em class="italic"><span class="koboSpan" id="kobo.12.1">Chapter 9</span></em></a><em class="italic"><span class="koboSpan" id="kobo.13.1">, Exploring Reactivity with RXJS</span></em></li>
</ul>
</div>
<div>
<div id="_idContainer037">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer038">
</div>
</div>
</body></html>