<html><head></head><body>
		<div id="_idContainer065" class="calibre2">
			<h1 id="_idParaDest-145" class="chapter-number"><a id="_idTextAnchor144" class="pcalibre1 calibre6 pcalibre"/>9</h1>
			<h1 id="_idParaDest-146" class="calibre7"><a id="_idTextAnchor145" class="pcalibre1 calibre6 pcalibre"/>Managing Microfrontends in Production</h1>
			<p class="calibre3">Being able to develop and test web applications on your local computer is great; however, deploying them them to production, maintaining them, and releasing new features while your applications are being visited by hundreds and thousands of visitors takes your software development skills to the next level. This chapter will cover some of the key concepts around deploying and maintaining your microfrontends <span>in production.</span></p>
			<p class="calibre3">In this chapter, we will cover the <span>following topics:</span></p>
			<ul class="calibre15">
				<li class="calibre14"><span>Branching strategies</span></li>
				<li class="calibre14"><span>Versioning</span></li>
				<li class="calibre14"><span>Rollback strategies</span></li>
				<li class="calibre14"><span>Feature toggles</span></li>
			</ul>
			<p class="calibre3">By the end of this chapter, you will have taken the first steps toward reliably maintaining your microfrontend applications <span>in production.</span></p>
			<h1 id="_idParaDest-147" class="calibre7"><a id="_idTextAnchor146" class="pcalibre1 calibre6 pcalibre"/>Foundational components for a strong software delivery model</h1>
			<p class="calibre3">When it <a id="_idIndexMarker404" class="pcalibre1 calibre6 pcalibre"/>comes to deploying and maintaining applications in production, I recommend using <strong class="bold">DevOps Research and Assessment’s</strong> (<strong class="bold">DORA’s</strong>) software <a id="_idIndexMarker405" class="pcalibre1 calibre6 pcalibre"/>delivery maturity model to help prioritize areas to focus on and aspects of your production deployment <a id="_idIndexMarker406" class="pcalibre1 calibre6 pcalibre"/>processes you <span>should optimize.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The software delivery maturity model talks about four key areas—namely, <em class="italic">Deployment frequency</em>, <em class="italic">Lead time for changes</em>, <em class="italic">Time to restore service</em>, and <em class="italic">Change failure rate</em>, and these are categorized as <em class="italic">Elite</em>, <em class="italic">High</em>, <em class="italic">Medium</em>, and <em class="italic">Low</em>. You can read more about this in detail here in the <em class="italic">State of DevOps 2021</em> report: <a href="https://dora.dev/publications/pdf/state-of-devops-2021.pdf" class="pcalibre1 calibre6 pcalibre">https://dora.dev/publications/pdf/state-of-devops-2021.pdf</a>. You can also register and view the rest of the reports at <a href="https://dora.dev/publications/" class="pcalibre1 calibre6 pcalibre">https://dora.dev/publications/</a> <span>and </span><a href="https://cloud.google.com/devops/state-of-devops" class="pcalibre1 calibre6 pcalibre"><span>https://cloud.google.com/devops/state-of-devops</span></a><span>.</span></p>
			<p class="calibre3">We will look at a couple <a id="_idIndexMarker407" class="pcalibre1 calibre6 pcalibre"/>of key components that help you create the right foundation to ensure you are able to move up the maturity <a id="_idIndexMarker408" class="pcalibre1 calibre6 pcalibre"/>model as your team gains more confidence in deploying and managing microfrontends <span>in production.</span></p>
			<h2 id="_idParaDest-148" class="calibre5"><a id="_idTextAnchor147" class="pcalibre1 calibre6 pcalibre"/>Branching strategies</h2>
			<p class="calibre3">In my opinion, the branching strategy is the most critical component that helps you improve the <em class="italic">Deployment frequency</em> and <em class="italic">Lead time for </em><span><em class="italic">changes</em></span><span> metrics.</span></p>
			<p class="calibre3">GitFlow and GitHub<a id="_idIndexMarker409" class="pcalibre1 calibre6 pcalibre"/> Flow are two popular branching strategies for Git-based version control systems, each with its strengths <span>and weaknesses.</span></p>
			<p class="calibre3">GitFlow is a branching model that uses two long-lived branches, <strong class="source-inline">main</strong> and <strong class="source-inline">develop</strong>, as well as feature, release, and <span>hotfix branches.</span></p>
			<p class="calibre3">GitHub Flow, on the other<a id="_idIndexMarker410" class="pcalibre1 calibre6 pcalibre"/> hand, is a simpler and more flexible branching strategy that is suitable for smaller teams and projects. It revolves around a single main branch, typically <strong class="source-inline">master</strong> or <strong class="source-inline">main</strong>, and encourages developers to make changes in feature branches that are then merged into the <strong class="source-inline">main</strong> branch through <span>pull requests.</span></p>
			<p class="calibre3">In our opinion, when working with microfrontends and monorepos, GitHub Flow is the only viable branching strategy. This is primarily because of the <span>following reasons:</span></p>
			<ul class="calibre15">
				<li class="calibre14"><strong class="bold">Simplicity</strong>: GitHub Flow simplifies<a id="_idIndexMarker411" class="pcalibre1 calibre6 pcalibre"/> the development process by enforcing a single, linear history on the <strong class="source-inline1">main</strong> branch. Every feature, bug fix, or improvement is developed on a separate branch created from <strong class="source-inline1">main</strong>, and once ready, it’s merged back into <strong class="source-inline1">main</strong>. There are no long-lived branches apart from <strong class="source-inline1">main</strong>, avoiding the complications of managing, syncing, and maintaining multiple <span>long-term branches.</span></li>
				<li class="calibre14"><strong class="bold">Isolation of changes</strong>: In a monorepo, it’s crucial to ensure changes to one project don’t unintentionally impact another. GitHub Flow’s practice of isolated branches for each new feature or bug fix aids in containing the scope of changes, reducing the risk of <span>cross-project interference.</span></li>
				<li class="calibre14"><strong class="bold">Continuous Integration/Continuous Deployment</strong> (<strong class="bold">CI/CD</strong>): GitHub Flow is designed with CD in mind. In monorepos, this can be even more beneficial. Since all projects live within the same repository, it’s easier to ensure that all changes are tested and <span>deployed consistently.</span></li>
				<li class="calibre14"><strong class="bold">Reduced merge conflicts</strong>: With a strategy such as Git Flow, where changes are often merged into <strong class="source-inline1">develop</strong> or <strong class="source-inline1">release</strong> branches before <strong class="source-inline1">main</strong>, there can be significant delays <a id="_idIndexMarker412" class="pcalibre1 calibre6 pcalibre"/>between when code is written and when it’s deployed. In a fast-paced monorepo, this can lead to complex merge conflicts. GitHub Flow mitigates this by encouraging frequent merges directly <span>into </span><span><strong class="source-inline1">main</strong></span><span>.</span></li>
			</ul>
			<p class="calibre3">While working with GitFlow we’ve also <a id="_idIndexMarker413" class="pcalibre1 calibre6 pcalibre"/>seen that it is beneficial to slightly switch how code is merged to <strong class="source-inline">main</strong> based on whether you are in active development or post your first <span>production deployment.</span></p>
			<h3 class="calibre9">During active development</h3>
			<p class="calibre3">During the active development phase of a project, team members diligently generate feature branches, merging<a id="_idIndexMarker414" class="pcalibre1 calibre6 pcalibre"/> them back into the <strong class="source-inline">main</strong> branch only after the pull requests have received the necessary approvals. It’s common practice, and possibly part of your CI builds, to initiate an array of automated unit tests on each pull request prior to merging into the <strong class="source-inline">main</strong> branch. Additionally, a suite of integration and end-to-end tests are preferably executed on the <strong class="source-inline">main</strong> branch each night. This routine helps ensure that any disruptions in the <strong class="source-inline">main</strong> branch are identified and <span>rectified promptly.</span></p>
			<p class="calibre3">Let us look at the branching and merging workflow with GitHub Flow during <span>active development:</span></p>
			<div class="calibre2">
				<div id="_idContainer063" class="img---figure">
					<img src="image/Figure_9.01_B18987.jpg" alt="Figure 9.1 – Branching and merging strategy during active development" class="calibre4"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.1 – Branching and merging strategy during active development</p>
			<p class="calibre3">As you can see, with <a id="_idIndexMarker415" class="pcalibre1 calibre6 pcalibre"/>GitHub Flow, branching and merging is quite straightforward. Developers branch off the <strong class="source-inline">main</strong> branch and merge back <span>into </span><span><strong class="source-inline">main</strong></span><span>.</span></p>
			<h3 class="calibre9">After the first release to production</h3>
			<p class="calibre3">Subsequent to your inaugural production release, the merging strategy undergoes a subtle evolution. The teams continue to create feature branches off the <strong class="source-inline">main</strong> branch as before; however, the process <a id="_idIndexMarker416" class="pcalibre1 calibre6 pcalibre"/>diverges post-feature testing and approval. The tested feature release is rebased with <strong class="source-inline">main</strong>, tagged and deployed directly from the feature branch into production. It is only once stability in production is confirmed that the feature branch is merged into the <span><strong class="source-inline">main</strong></span><span> branch.</span></p>
			<p class="calibre3">The following workflow will help illustrate <span>the process:</span></p>
			<div class="calibre2">
				<div id="_idContainer064" class="img---figure">
					<img src="image/Figure_9.02_B18987.jpg" alt="Figure 9.2 – Branching and releasing after the first release" class="calibre4"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.2 – Branching and releasing after the first release</p>
			<p class="calibre3">As you can see in <span><em class="italic">Figure 9</em></span><em class="italic">.2</em>, the process to deploy a feature, bug, or hotfix is the same, keeping things simple. A key step here is to rebase the <strong class="source-inline">main</strong> branch before you deploy your feature <span>or bug.</span></p>
			<p class="calibre3">Although this may sound <a id="_idIndexMarker417" class="pcalibre1 calibre6 pcalibre"/>unconventional, adhering to this approach has several benefits, <span>as follows:</span></p>
			<ul class="calibre15">
				<li class="calibre14">The <strong class="source-inline1">main</strong> branch perpetually mirrors the stable, current version <span>in production.</span></li>
				<li class="calibre14">The team is given the opportunity to swiftly address and resolve any minor issues encountered during feature deployment, stabilizing the release prior to its merge into the <span><strong class="source-inline1">main</strong></span><span> branch.</span></li>
				<li class="calibre14">It eliminates the necessity of prohibiting commits to the <strong class="source-inline1">main</strong> branch until the release stabilizes, an impractical strategy when executing multiple <span>daily deployments.</span></li>
				<li class="calibre14">As the <strong class="source-inline1">main</strong> branch is always in alignment with the current production version, the process of deploying a feature or hotfix <span>remains consistent.</span></li>
				<li class="calibre14">Since all merges into the <strong class="source-inline1">main</strong> branch are post-release, the likelihood of a disrupted <strong class="source-inline1">main</strong> branch is significantly reduced. Such disruptions can impede a large development team and halt further production deployments until the issue <span>is resolved.</span></li>
			</ul>
			<p class="calibre3">In the context of GitHub Flow, it is vital to note <span>the following:</span></p>
			<ul class="calibre15">
				<li class="calibre14">Prior to deploying your feature branch, ensure a final rebase from the <strong class="source-inline1">main</strong> branch. This ensures that your feature branch encompasses all previous deployments executed while your feature was <span>in development.</span></li>
			</ul>
			<p class="calibre3">Contrary to popular <a id="_idIndexMarker418" class="pcalibre1 calibre6 pcalibre"/>belief, GitHub Flow development is not exclusive to small 2-3-member teams. It is, in fact, notably advantageous for large teams operating in small, focused squads <span>or pods.</span></p>
			<h2 id="_idParaDest-149" class="calibre5"><a id="_idTextAnchor148" class="pcalibre1 calibre6 pcalibre"/>Versioning micro apps</h2>
			<p class="calibre3">The versioning of applications being deployed to production is standard practice, and there are different ways <a id="_idIndexMarker419" class="pcalibre1 calibre6 pcalibre"/>of defining versioning strategies. Versioning is important from many aspects; it helps in managing changelogs and mapping the different features and bugs to a build. It also helps with <span>rollback strategies.</span></p>
			<p class="calibre3"><strong class="bold">Semantic versioning</strong>, also known as <strong class="bold">SemVer</strong>, is a popular<a id="_idIndexMarker420" class="pcalibre1 calibre6 pcalibre"/> technique to define versions. It follows the format <span>of </span><span><strong class="source-inline">MAJOR.MINOR.PATCH</strong></span><span>.</span></p>
			<p class="calibre3">This structure not only helps users to understand the nature of changes in the new release but also helps with dependency management in <span>software systems.</span></p>
			<p class="calibre3">Our recommended strategy is to use SemVer as a guide. Each micro app should adhere to its own versioning rules, ensuring that any changes to the application’s public features are reflected in its version number. A micro app can increment its version number following the <strong class="source-inline">MAJOR.MINOR.PATCH</strong> pattern each time there’s a major feature release, minor feature release, or a bug fix change. We recommend prefixing the app name to the semantic version—for example, <strong class="source-inline">catalog-2.8.3</strong> would mean <span>the following:</span></p>
			<ul class="calibre15">
				<li class="calibre14"><strong class="bold">Micro app </strong><span><strong class="bold">name</strong></span><span>: </span><span><strong class="source-inline1">catalog</strong></span></li>
				<li class="calibre14"><strong class="bold">Major </strong><span><strong class="bold">version</strong></span><span>: 2</span></li>
				<li class="calibre14"><strong class="bold">Minor </strong><span><strong class="bold">version</strong></span><span>: 8</span></li>
				<li class="calibre14"><strong class="bold">Path/bug fix </strong><span><strong class="bold">version</strong></span><span>: 3</span></li>
			</ul>
			<p class="calibre3">For a simple way to manage tagging, whenever you are working on a release, we recommend creating a release branch such <span>as </span><span><strong class="source-inline">releases/catalog-2.0.1</strong></span><span>.</span></p>
			<p class="calibre3">Once the release is tested and ready to deploy, we tag it <span>like so:</span></p>
			<ul class="calibre15">
				<li class="calibre14"><strong class="source-inline1">git </strong><span><strong class="source-inline1">tag catalog-2.0.0</strong></span></li>
				<li class="calibre14"><strong class="source-inline1">git push </strong><span><strong class="source-inline1">origin catalog-2</strong></span><span><strong class="source-inline1">.0.0</strong></span></li>
			</ul>
			<p class="calibre3">With a CI/CD pipeline, we can set it to automatically trigger a deployment to the test environments whenever a new tag <span>is detected.</span></p>
			<p class="calibre3">Note that while SemVer’s official definition uses the term <em class="italic">breaking changes</em> to define a major version, with microfrontends and module federation we can’t really have a breaking change. Hence for us, a micro app containing a major feature release would warrant a major version <span>number increment.</span></p>
			<p class="calibre3">A common scenario with multiple micro apps and multiple frequent releases is that it becomes challenging for everybody in the team to know which version of which micro app is currently in production. A simple way to solve this is to have a <strong class="source-inline">/versions</strong> route in every micro app that will display information such as the current version number, the date of release, the<a id="_idIndexMarker421" class="pcalibre1 calibre6 pcalibre"/> branch it was released from, and so on. This can be super helpful for developers trying to debug issues <span>in production.</span></p>
			<p class="calibre3">Here is an example of information we had on a <strong class="source-inline">/</strong><span><strong class="source-inline">versions</strong></span><span> route:</span></p>
			<pre class="source-code">
{
appName: Catalog
branchName: release/catalog-2.0.0
tagName: catalog-2.0.4
deployedDate: Thu 25 May 2023 13:34:04 GMT
}</pre>			<p class="calibre3">For a large number of micro apps or frequent releases, manually tagging every version might become tedious. You might want to consider automating this using a script. Here is an example of a <span><strong class="source-inline">bash</strong></span><span> script:</span></p>
			<pre class="source-code">
# Microfrontend names
MICROFRONTENDS=(home catalog checkout)
for i in ${MICROFRONTENDS[@]}
do
  cd apps/$i
  # Fetch latest tags
  git fetch --tags
  # Get latest version from Git
  VERSION=$(git describe --tags `git rev-list --tags --max-count=1`)
  # Increment version
  npm version patch
  # Add release notes
  git commit -am "Release v$VERSION [skip ci]"
  # Tag commit
  git tag v$VERSION
  # Push changes
  git push --follow-tags origin main
  # Build microfrontend
  pnpm run build
done</pre>			<p class="calibre3">In the preceding code, you will notice that the script loops through each micro app in the <strong class="source-inline">apps</strong> folder, fetches<a id="_idIndexMarker422" class="pcalibre1 calibre6 pcalibre"/> the latest tags from <strong class="source-inline">git</strong> using the <strong class="source-inline">git describe</strong> and <strong class="source-inline">git rev-list</strong> commands, runs the <strong class="source-inline">npm version</strong> command to update the version numbers, and then commits and pushes the updated tags back <span>to </span><span><strong class="source-inline">git</strong></span><span>.</span></p>
			<p class="calibre3">We can also use tools such as <strong class="source-inline">semantic-release</strong> or <strong class="source-inline">standard-version</strong>. These tools automate version management and changelog generation based on <span>commit messages.</span></p>
			<p class="calibre3">Versioning and tagging micro apps is critical to ensure that there is clarity with all stakeholders on the current status of which version of each micro app is currently in production. As we will see in the next section, it also plays a critical role in <span>rollback strategies.</span></p>
			<h1 id="_idParaDest-150" class="calibre7"><a id="_idTextAnchor149" class="pcalibre1 calibre6 pcalibre"/>Rolling back a micro app</h1>
			<p class="calibre3">A rollback strategy is a key component to managing any production software. This impacts the <em class="italic">Time to restore </em><span><em class="italic">service</em></span><span> metric.</span></p>
			<p class="calibre3">Rollback strategies for <a id="_idIndexMarker423" class="pcalibre1 calibre6 pcalibre"/>microfrontends center on the ability to revert a specific micro app or the entire system to a previous stable state when issues arise during or post-deployment. <em class="italic">Thanks to the independence of microfrontends, a rollback doesn’t necessarily affect the entire application but can be targeted to the problematic component, reducing overall </em><span><em class="italic">system disruption</em></span><span>.</span></p>
			<p class="calibre3">The simplest rollback strategy involves utilizing version control systems such as Git along with CI/CD pipelines. In this setup, each microfrontend has specific tagged releases, which are stored and can be redeployed if required. For instance, if the current version of a microfrontend is <strong class="source-inline">catalog-1.2.3</strong> and an issue is detected, you can quickly revert to the previous stable version, <strong class="source-inline">catalog-1.2.2</strong>, by triggering the corresponding deployment in your <span>CI/CD pipeline.</span></p>
			<p class="calibre3">Additionally, leveraging a blue-green deployment strategy can be effective. In this approach, two environments—blue and green—are maintained. While one serves live traffic (blue), the other (green) is idle or being prepared for the next release. If something goes wrong with the green environment post-deployment, you can quickly switch back to the blue environment, effectively rolling back <span>the changes.</span></p>
			<p class="calibre3">Rollbacks in Kubernetes are straightforward thanks to its declarative nature and built-in versioning mechanism. When a new deployment is created, Kubernetes automatically versions it and stores its details. If an issue arises with a new release, you can quickly roll back to a previous version using the <strong class="source-inline">kubectl rollout undo</strong> command. For instance, if you find a problem with a deployment named <strong class="source-inline">deployment/catalog</strong>, you can roll back using the <strong class="source-inline">kubectl rollout undo deployment/catalog</strong> command. Kubernetes will revert the deployment to the previous stable version gracefully without any downtime, making it a powerful tool for managing rollbacks in <span>microfrontend architectures.</span></p>
			<p class="calibre3">When rolling back a micro app, it is important to be aware of any incompatibilities with backend APIs and whether the corresponding backend API also needs to be <span>rolled back.</span></p>
			<p class="calibre3">Rollbacks at times can be<a id="_idIndexMarker424" class="pcalibre1 calibre6 pcalibre"/> painful, and the need for rollbacks can be mitigated by releasing new features or versions of micro apps using feature toggles, which we will see in the <span>next section.</span></p>
			<h1 id="_idParaDest-151" class="calibre7"><a id="_idTextAnchor150" class="pcalibre1 calibre6 pcalibre"/>Deploying micro apps with feature toggles</h1>
			<p class="calibre3">Feature toggling, also known as feature flagging, is a powerful technique that allows individual features to be turned on or off at runtime without requiring a redeployment. This is particularly <a id="_idIndexMarker425" class="pcalibre1 calibre6 pcalibre"/>useful in a microfrontend architecture, as it enables the independent release and control of micro apps across multiple <span>micro applications.</span></p>
			<p class="calibre3">With feature toggling, teams<a id="_idIndexMarker426" class="pcalibre1 calibre6 pcalibre"/> can deploy new features to production but have them “hidden” behind a toggle until they’re ready to be released. This allows for extensive testing in the live environment and enables progressive delivery techniques such as canary releases or A/B testing. If any issues arise with the new feature, it can be quickly “switched off” via the feature toggle, effectively mitigating the impact without requiring a full rollback <span>or redeployment.</span></p>
			<p class="calibre3">Unleash (<a href="https://www.getunleash.io/" class="pcalibre1 calibre6 pcalibre">https://www.getunleash.io/</a>) is a <a id="_idIndexMarker427" class="pcalibre1 calibre6 pcalibre"/>popular open source tool for <span>feature toggles.</span></p>
			<p class="calibre3">Feature toggles can be used to provide different experiences for different users. For instance, you can use them to selectively enable features for specific user groups, such as beta testers or <span>premium users.</span></p>
			<p class="calibre3">However, feature toggling needs to be managed carefully to avoid an accumulation of outdated toggles, which can lead to code complexity and technical debt. Regular audits and cleanup of feature toggles should be part of the <span>development process.</span></p>
			<p class="calibre3">With this, we come to the end of this section, which covered some of the foundational elements of managing your microfrontends in production. This goes in conjunction with everything we saw in the previous chapters about deploying microfrontends to the cloud and eventually helping reduce the overall stress involved with deploying and maintaining applications <span>in production.</span></p>
			<h1 id="_idParaDest-152" class="calibre7"><a id="_idTextAnchor151" class="pcalibre1 calibre6 pcalibre"/>Summary</h1>
			<p class="calibre3">As we conclude this chapter, let us quickly summarize what we’ve learned so far. We learned about DORA’s software delivery performance metrics: <em class="italic">Deployment frequency</em>, <em class="italic">Lead time for changes</em>, <em class="italic">Time to restore service</em>, and <em class="italic">Change failure rate</em>. We then had a look at some of the foundational elements that teams need to focus on to ensure they are set up <span>for success.</span></p>
			<p class="calibre3">We learned about branching strategies and that GitHub Flow is the preferred branching strategy. We also learned about the nuances of workflows when software is being built versus when <span>it’s deployed.</span></p>
			<p class="calibre3">We learned about the right way to version our micro apps. We also learned about the importance of rollback strategies and how microfrontends help minimize the blast radius. And finally, we learned about feature toggles and how we can gradually release new micro apps into production via feature toggles and, more importantly, if there are <span>any problems.</span></p>
			<p class="calibre3">In the next chapter, we will look at some common pitfalls to avoid when <span>building microfrontends.</span></p>
		</div>
	</body></html>