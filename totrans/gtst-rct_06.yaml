- en: Chapter 6. Reacting with Flux
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. 使用Flux进行响应
- en: So far in the previous chapters, we have dug deep into the react world. Let's
    now explore the new dimension of react world, Flux, which is nothing but a unidirectional
    dataflow architecture. Flux is developed by the Facebook internal development
    team and is used in order to build client-side web applications at Facebook.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在前面的章节中，我们已经深入探讨了React世界。现在让我们探索React世界的另一个维度，Flux，它实际上只是一个单向数据流架构。Flux是由Facebook内部开发团队开发的，用于在Facebook构建客户端Web应用程序。
- en: 'We will cover the following topics as we go along:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的进展，我们将涵盖以下主题：
- en: The synopsis of Flux versus the MVC architecture
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flux与MVC架构的概述
- en: Actions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动作
- en: Dispatchers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调度器
- en: Stores
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储
- en: Controller-Views and Views
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器-视图和视图
- en: An overview of Flux
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flux概述
- en: '**Flux** should not be confused as a framework based on ReactJS. Flux is an
    architecture and is designed in order to reduce the complexity of a huge application
    built with **Model View Controller** (**MVC**) architecture and has been designed
    as an alternative of MVC.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**Flux**不应与基于ReactJS的框架混淆。Flux是一种架构，旨在减少使用**模型-视图-控制器**（**MVC**）架构构建的大型应用程序的复杂性，并且被设计为MVC的替代方案。'
- en: 'The following are the different Flux components:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些不同的Flux组件：
- en: View—This is like for any web app, the views (basically the react component)
    receives the event and passes it to the Actions
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图—这就像任何Web应用程序一样，视图（基本上是React组件）接收事件并将其传递给动作。
- en: Action—They are helper methods (`actionCreators`) that pass the data (payload)
    and `actionType`, received from an external API/view to a dispatcher
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动作—它们是辅助方法（`actionCreators`），将来自外部API/视图的数据（有效载荷）和`actionType`传递给调度器。
- en: Dispatcher—These are Central hub of all registered callbacks. It receives the
    actions and acts as a "traffic controller" before it passes it to the Stores
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调度器—这些是所有注册回调的中心枢纽。它接收动作，并在将其传递给存储之前充当“交通控制器”。
- en: Store—It is a data layer that stores all the computations and business logic.
    It is also responsible for storing the application state and the single source
    of truth for the application state. It receives the action from the dispatchers
    based on the registered callbacks.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Store—它是一个数据层，存储所有计算和业务逻辑。它还负责存储应用程序状态和应用程序状态的单一真相来源。它根据注册的回调从调度器接收动作。
- en: Controller-View—This receives the state from the stores based on the `changeEvents`
    and passes it to the React views component via props.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器-视图—它根据`changeEvents`从存储中接收状态，并通过属性将状态传递给React视图组件。
- en: 'A diagram here illustrates this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了这一点：
- en: '![An overview of Flux](img/00033.jpeg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![Flux概述](img/00033.jpeg)'
- en: Typical Flux Data Flow Architecture
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的Flux数据流架构
- en: Flux versus the MVC architecture
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flux与MVC架构
- en: In a typical application built on the MVC architecture, the views get updated
    from the data, which is typically stored in the models. As the application grows,
    the number of models and views also grow, and there grows the interdependency
    among the various models. Therefore the views also get tdependent on multiple
    models, thus increasing the complexity of the application.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于MVC架构的典型应用程序中，视图从数据更新，这些数据通常存储在模型中。随着应用程序的增长，模型和视图的数量也增加，各种模型之间的相互依赖性也随之增加。因此，视图也变得依赖于多个模型，从而增加了应用程序的复杂性。
- en: The interdependence of views and models can create diffraction in the source
    of truth, leading to increased application complexity and unpredictability. As
    a result, there needs to be a solution to internalize the control by moving all
    the control into the individual pieces.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 视图和模型之间的相互依赖性可能导致真相来源的扩散，导致应用程序复杂性和不可预测性的增加。因此，需要有一种解决方案，通过将所有控制移入各个部分来内部化控制。
- en: '![Flux versus the MVC architecture](img/00034.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![Flux与MVC架构](img/00034.jpeg)'
- en: Issue with a growing app built with MVC
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MVC构建的日益增长的应用程序的问题
- en: Flux advantages
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Flux优势
- en: 'According to the Facebook Flux development team, the objects within a Flux
    application are highly decoupled, and adhere very strongly to the first part of
    the Law of Demeter: the principle that each object within a system should know
    as little as possible about the other objects in the system. This results in software
    that is more.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Facebook Flux开发团队的说法，Flux应用程序中的对象高度解耦，并且非常严格地遵循德米特法则的第一部分：系统中的每个对象应尽可能少地了解系统中的其他对象。这导致软件更加。
- en: Maintainable
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可维护性
- en: Adaptable
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可适应性
- en: Testable
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可测试性
- en: Easier and more predictable for new engineering team members to understand
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于新工程团队成员来说更容易理解且更可预测
- en: The following is a Flux application structure of our `library_app` application.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们 `library_app` 应用程序的 Flux 应用程序结构。
- en: '![Flux advantages](img/00035.jpeg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![Flux 优势](img/00035.jpeg)'
- en: Our Library App Structure
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的图书馆应用程序结构
- en: Flux components
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流量组件
- en: Let's dive into an application, built with Flux architecture with React View.
    Here, we will be building an app named `library_app`. This is a basic Flux-based
    ReactJS app, where we can borrow books from the `library_app` store to our reading
    list. Once we finish the book, we can strike it off from our reading list.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入一个使用 React 视图构建的 Flux 架构的应用程序。在这里，我们将构建一个名为 `library_app` 的应用程序。这是一个基本的基于
    Flux 的 ReactJS 应用程序，我们可以从 `library_app` 存储库借阅书籍到我们的阅读列表。一旦我们完成阅读书籍，我们可以将其从阅读列表中删除。
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'From the command line execute:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行执行：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The above will install the flux package as a node module and your library_app
    application will have a directory called node_modules with the flux library installed
    within it.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 上述操作将安装 flux 包作为节点模块，并且你的 library_app 应用程序将有一个名为 node_modules 的目录，其中包含安装的 flux
    库。
- en: Actions
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动作
- en: '**Actions** are typically the data that enters into an application, either
    directly from the View or from an external Web API. Each action is nothing but
    a JavaScript method, which contains two parts: the `actionType` and the actual
    data. The `actionCreators` methods are simply discrete, semantic helper functions
    that facilitate passing data to the *dispatcher* in the form of an *action*. The
    different types of actions are declared as a JavaScript object, in a file named
    `App-Constants.js`. According to the Flux app hierarchy, the `App-Contstants.js`
    file resides under `src/js/constants`. Typical example for such a file looks like
    the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**动作**通常是进入应用程序的数据，无论是直接来自视图还是来自外部 Web API。每个动作不过是一个 JavaScript 方法，它包含两部分：`actionType`
    和实际数据。`actionCreators` 方法仅仅是离散的、语义化的辅助函数，它简化了将数据以 `action` 的形式传递给 *dispatcher*
    的过程。不同类型的动作被声明为一个 JavaScript 对象，在一个名为 `App-Constants.js` 的文件中。根据 Flux 应用程序层次结构，`App-Constants.js`
    文件位于 `src/js/constants` 目录下。此类文件的典型示例如下：'
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, `ADD_BOOK`, `DELETE_BOOK` are the actions.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`ADD_BOOK`、`DELETE_BOOK` 是动作。
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Actions, by itself, do not contain any functionality of their own. Actions are
    typically executed by the stores and are available in order to trigger the views.
    In React, we have handful of helper methods named `actionCreators`, which ideally
    creates the action object and passes the action to the Flux dispatcher (`AppDispatcher`).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 动作本身不包含任何功能。动作通常由 stores 执行，并且可用于触发视图。在 React 中，我们有少量名为 `actionCreators` 的辅助方法，理想情况下，这些方法创建动作对象并将动作传递给
    Flux 分发器（`AppDispatcher`）。
- en: All the actions defined in the `AppConstants` are declared in the `AppActions`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `AppConstants` 中定义的所有动作都在 `AppActions` 中声明。
- en: The use of constants in the `AppConstants`, which declares the action names,
    helps the developer to understand the app's functionality. As in our case, it
    deals with books.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `AppConstants` 中使用常量来声明动作名称，有助于开发者理解应用程序的功能。正如我们的案例，它处理书籍。
- en: 'In the following example while adding books in a `library_app` store, we are
    dealing with four `actionTypes`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，在向 `library_app` 存储库添加书籍时，我们处理了四个 `actionTypes`：
- en: '`ADD_BOOK`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADD_BOOK`'
- en: '`DELETE_BOOK`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE_BOOK`'
- en: '`INC_BOOK_COUNT`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INC_BOOK_COUNT`'
- en: '`DEC_BOOK_COUNT`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DEC_BOOK_COUNT`'
- en: The actions (such as `addBook`, `removeBook`, `incBookCount`, and `decBookCount`)
    are unique based on their `actionType` attribute. Thus, when these actions are
    dispatched by the dispatchers to the stores, stores mutates themselves depending
    on the specific callback registered with the dispatchers.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 动作（如 `addBook`、`removeBook`、`incBookCount` 和 `decBookCount`）根据它们的 `actionType`
    属性是唯一的。因此，当这些动作由 dispatchers 分发到 stores 时，stores 会根据与 dispatchers 注册的特定回调进行自我更新。
- en: 'Typical action file resides in `library_app/src/js/actions/app-actions.js`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的动作文件位于 `library_app/src/js/actions/app-actions.js`：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Dispatchers
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分发器
- en: As the name aptly defines, **Flux dispatchers** dispatches the actions to the
    subsequent stores. Dispatchers can be called as a registry of callbacks. All the
    stores are registered with the dispatchers.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名所定义的，**Flux 分发器**将动作分发到后续的 stores。分发器可以被视为回调的注册表。所有 stores 都注册在分发器上。
- en: 'Some key points of dispatcher are the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 分发器的一些关键点如下：
- en: There is only one dispatcher per app.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个应用程序只有一个分发器。
- en: Dispatchers being used as a center for all the registered callbacks.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dispatchers 被用作所有注册回调的中心。
- en: 'It functions as a broadcaster of all the actions to the stores. Dispatchers
    acts as a queue, which sequentially broadcasts the actions. This is different
    from generic pub-sub systems in the following two ways:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它充当所有动作到商店的广播器。调度器作为一个队列，依次广播动作。这与通用的 pub-sub 系统在以下两个方面不同：
- en: Callbacks are not subscribed to particular events. Every payload is dispatched
    to every registered callback.
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回调没有订阅特定的事件。每个有效负载都会分发到每个已注册的回调。
- en: Callbacks can be deferred in whole or part until other callbacks have been executed.
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回调可以全部或部分地延迟，直到其他回调已执行。
- en: The dispatcher has the capability to invoke the callbacks in the order specified,
    and it waits for other updates (`waitFor()` method does that).
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调度器具有按指定顺序调用回调的能力，并且它等待其他更新（`waitFor()` 方法就是这样做的）。
- en: In the flux library (`npm install flux`) `node_module`, the `register()` and
    `dispatch()` methods are defined, in the flux `library_app`, within the dispatcher
    class.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 flux 库（`npm install flux`）的 `node_module` 中，定义了 `register()` 和 `dispatch()`
    方法，在 flux `library_app` 中的调度器类中。
- en: 'See the file located at `library_app/node_modules/Flux/lib/Dispatcher.js`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 查看位于 `library_app/node_modules/Flux/lib/Dispatcher.js` 的文件：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Thus, when the dispatchers receive the trigger (actions) from the Actions, it
    dispatches all the actions to the registered stores, one by one. This dispatching-flow
    is initiated with the `dispatch()` method, which passes the payload (data) to
    the registered store and has the callback registered to it.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当调度器从 Actions 接收触发（动作）时，它会逐个将所有动作分发到已注册的商店。这种分发流程是通过 `dispatch()` 方法启动的，该方法将有效负载（数据）传递到已注册的商店，并注册了回调。
- en: 'The following code is an excerpt from the `Flux.js` library within the `node_modules`
    for the dispatcher:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是从 `node_modules` 中的 `Flux.js` 库的调度器摘录：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The file location is at `library_app/src/js/dispatchers/app-dispatchers.js`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 文件位置在 `library_app/src/js/dispatchers/app-dispatchers.js`：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Before implementing the `library_app` store, let's check whether our payload
    (data) is printing out in the console. In order to do so, a handler function is
    created in the React `component app.js`, which is called when any part of the
    heading **My First Flux App** is clicked.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现 `library_app` 商店之前，让我们检查我们的有效负载（数据）是否在控制台中打印出来。为此，在 React `component app.js`
    中创建了一个处理函数，当点击标题 **My First Flux App** 的任何部分时会被调用。
- en: 'The file location is `library_app/src/js/components/app.js`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 文件位置是 `library_app/src/js/components/app.js`：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Run the httpster from your application''s root directory:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 从应用程序的根目录运行 httpster：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Open the browser and check the console, after clicking on the heading:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 打开浏览器并检查控制台，点击标题后：
- en: '![Dispatchers](img/00036.jpeg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![调度器](img/00036.jpeg)'
- en: A screenshot from library_app
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: library_app 的截图
- en: 'For a quick recap about the flow of our bookstore app till now:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速回顾我们书店应用到目前为止的流程：
- en: The default `index.html` page serves the static content (Sample Application)
    on `localhost:3333`
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的 `index.html` 页面在 `localhost:3333` 上提供静态内容（示例应用）。
- en: The `index.html` page internally calls the `main.js`, which internally creates
    the React class and renders the content in the `<App />` React component (from
    the `src/js/components/app.js`). The React component is rendered in the `div`
    tag with ID `main`
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html` 页面内部调用 `main.js`，然后内部创建 React 类并在 `<App />` React 组件（来自 `src/js/components/app.js`）中渲染内容。React
    组件在具有 ID `main` 的 `div` 标签中渲染。'
- en: Once we click on any portion of the `<App />` component (**My First Flux App**),
    an `onClick` event handler triggers the `handler()` function, which calls, `AppActions.addBook`
    (`This is the book..Sherlock Holmes`), here, `AppActions` in the `AppConstant`.
    `AddBook` is the specific action to be called with the `payload / item/ data`
    (`This is the book..Sherlock Holmes`).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们点击 `<App />` 组件（**My First Flux App**）的任何部分，一个 `onClick` 事件处理程序会触发 `handler()`
    函数，该函数调用 `AppActions.addBook` (`This is the book..Sherlock Holmes`)，在这里，`AppActions`
    在 `AppConstant` 中。`AddBook` 是要调用的特定动作，带有 `payload / item/ data` (`This is the
    book..Sherlock Holmes`)。
- en: 'Once `AppActions.addBook` method is called, it is assigned to the callback
    `handleViewAction` of the dispatcher, with the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦调用 `AppActions.addBook` 方法，它就会被分配给调度器的回调 `handleViewAction`，如下所示：
- en: '`actionType`: `AppConstants.ADD_BOOK`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`actionType`: `AppConstants.ADD_BOOK`'
- en: '`item`: `This is the book..Sherlock Holmes`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`item`: `This is the book..Sherlock Holmes`'
- en: The `handleViewAction` method of the dispatcher passes the action (with `action_type`
    and `item`) and logs the output in the console and dispatches it.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调度器的 `handleViewAction` 方法传递动作（带有 `action_type` 和 `item`）并在控制台记录输出，然后分发它。
- en: 'We see the following output in the `console.log` after clicking on **My First
    Flux App**:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在点击**我的第一个Flux应用程序**后，我们在`console.log`中看到以下输出：
- en: '`action Object { actionType: "ADD_BOOK", item: "This is the book..Sherlock
    Holmes" }`'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`action Object { actionType: "ADD_BOOK", item: "This is the book..Sherlock
    Holmes" }`'
- en: 'This is just a way to pass the JS objects (`item: "This is the book..Sherlock
    Holmes"`) in a uniform and expected manner for the store to handle. It simplifies
    the data flow of the application and makes tracing and debugging easier.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '这只是以统一和预期的方式将JS对象（`item: "This is the book..Sherlock Holmes"`）传递给商店处理的一种方式。它简化了应用程序的数据流，并使得跟踪和调试更容易。'
- en: Stores
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 商店
- en: Flux stores can be comparable with the models in MVC, though essentially they
    are not the same. From similar point of view, they are the same as all the business
    logic and computations happen in the Flux store. According to the Facebook team,
    "Stores manage the state of many objects—they do not represent a single record
    of data like ORM models do. Nor they are the same as Backbone's collections. More
    than simply managing a collection of ORM-style objects, stores manages the application
    state for a particular **domain** within the application."
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Flux商店可以与MVC中的模型相比较，尽管本质上它们并不相同。从类似的角度来看，它们与所有业务逻辑和计算都在Flux商店中发生是一样的。根据Facebook团队的说法，“商店管理许多对象的状态——它们不表示ORM模型那样的单个数据记录。它们也不与Backbone的集合相同。商店不仅管理ORM风格的集合，还管理应用程序中特定**领域**的应用状态。”
- en: Source [https://en.wikipedia.org/wiki/Object-relational_mapping](https://en.wikipedia.org/wiki/Object-relational_mapping).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 来源 [https://en.wikipedia.org/wiki/Object-relational_mapping](https://en.wikipedia.org/wiki/Object-relational_mapping).
- en: '*Object Relational Mapping (ORM) in computer science is a programming technique
    for converting data between incompatible type systems in object-oriented programming
    languages. This creates, in effect, a "virtual object database" that can be used
    from within the programming language. In object-oriented programming, data management
    tasks act on object-oriented (OO) objects that are almost always nonscalar values.
    For example, consider an address book entry that represents a single person along
    with zero or more phone numbers and zero or more addresses. This could be modeled
    in an object-oriented implementation by "Person object" with attributes/fields
    to hold each data item that the entry comprises: the person''s name, a list of
    phone numbers, and a list of addresses. The list of phone numbers would itself
    contain "PhoneNumber objects" and so on. The address book entry is treated as
    a single object by the programming language (it can be referenced by a single
    variable containing a pointer to the object, for instance). Various methods can
    be associated with the object, such as a method to return the preferred phone
    number, the home address, and so on.*'
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*在计算机科学中，对象关系映射（ORM）是一种编程技术，用于在面向对象编程语言中将数据在不可兼容的类型系统之间进行转换。实际上，它创建了一个“虚拟对象数据库”，可以在编程语言中使用。在面向对象编程中，数据管理任务作用于面向对象（OO）对象，这些对象几乎总是非标量值。例如，考虑一个代表一个人以及零个或多个电话号码和零个或多个地址的地址簿条目。这可以通过面向对象的实现来建模，通过“Person对象”具有属性/字段来保存条目包含的每个数据项：人的名字、电话号码列表和地址列表。电话号码列表本身将包含“PhoneNumber对象”，依此类推。编程语言将地址簿条目视为单个对象（例如，可以通过包含指向对象的指针的单个变量来引用它）。可以与对象关联各种方法，例如返回首选电话号码、家庭地址等方法。*'
- en: The store(s) receives the action(s) from the dispatchers. Depending on the registered
    callback (with the dispatcher), the Store decides whether it should respond to
    the action dispatched by the dispatcher. No objects outside the app are responsible
    for changing the values within the Store or the Views. Thus any change, which
    is brought by the actions, results in the data change based on the registered
    callbacks and never by any setter methods.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 商店从调度器接收动作。根据注册的回调（与调度器相关），商店决定是否应该响应调度器分发的动作。应用程序外部的任何对象都不负责更改商店或视图内的值。因此，任何由动作带来的更改，都是基于注册的回调导致的数据更改，而不是任何设置方法。
- en: As the Flux stores update themselves without any external intervention, hence
    it reduces the complexities typically found in MVC applications. The Flux stores
    controls what happens within them, only the input is via the dispatchers. In a
    MVC app, interdependency of various models with various views may lead to instability
    and complicated test cases.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Flux存储可以在没有任何外部干预的情况下自行更新，因此它减少了在MVC应用中通常发现的复杂性。Flux存储控制其内部发生的事情，只有输入是通过调度器进行的。在MVC应用中，各种模型与各种视图之间的相互依赖可能导致不稳定和复杂的测试用例。
- en: A single app can have multiple stores, based on its functionality, but each
    store deals with a single domain. A store exhibits characteristics of both collection
    of models and a singleton model of a logical domain.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一个应用可以根据其功能拥有多个存储，但每个存储只处理一个域。存储既表现出模型集合的特征，也表现出逻辑域的单例模型特征。
- en: 'The following is quick recap of Stores Functionality:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对存储功能的快速回顾：
- en: Stores register itself with the dispatchers through callbacks.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储注册自身到调度器中，通过回调函数。
- en: Computations of the business logic reside in the stores as JS functions.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务逻辑的计算位于存储中，作为JS函数。
- en: After the action been dispatched from the dispatcher to the Stores, they are
    identified by the registered callbacks.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调度器将操作从调度器发送到存储后，它们通过已注册的回调函数被识别。
- en: The action is acted upon within stores by the state update.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过状态更新在存储中执行操作。
- en: 'JS arrays: `_library` and `_readingItems` store the books available and what
    the reader wants to read.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JS数组：`_library`和`_readingItems`存储可用的书籍和读者想要阅读的内容。
- en: '`EventEmitter` is a class of the events module, which is part of the Node.js
    core library. In this example, the event emitter function is done by the `eventEmitter.on()`
    method, where the first argument is the event, and the second argument is the
    function to be added. Thus, the `eventEmitter.on()` method simply registers the
    function. When the the `emit()` method is called, then it executes all the functions
    that are registered with the on method.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EventEmitter`是事件模块的一个类，它是Node.js核心库的一部分。在这个例子中，事件发射器功能是通过`eventEmitter.on()`方法完成的，其中第一个参数是事件，第二个参数是要添加的函数。因此，`eventEmitter.on()`方法只是注册函数。当调用`emit()`方法时，它将执行通过on方法注册的所有函数。'
- en: The public methods `getReadingList()` and `getLibrary()` allow us to get the
    computed data from the `_readingItems` and `_readingList` JS arrays.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共方法`getReadingList()`和`getLibrary()`允许我们从`_readingItems`和`_readingList`JS数组中获取计算后的数据。
- en: '`dispatcherIndex` in the `app-stores.js` code is used in order to store the
    return value of the dispatcher''s registration method.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app-stores.js`代码中的`dispatcherIndex`用于存储调度器注册方法的返回值。'
- en: The switch statement is the determining factor, in case of a dispatcher's broadcast,
    for what actions has to be performed. If a relevant action is taken, a change
    event is emitted and views that are listening for this event update their states.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调度器广播的情况下，switch语句是决定要执行哪些操作的确定因素。如果采取了相关操作，则发出一个变更事件，并更新监听此事件的视图的状态。
- en: 'The following is the code for `app_stores.js` for our `library_app`. It has
    all the business logic and computations of our app:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们`library_app`的`app_stores.js`代码的代码，它包含了我们应用的所有业务逻辑和计算：
- en: '[PRE9]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`dispatcherIndex` is used to store the return value of the Dispatchers registration
    method. `dispatcherIndex` is used in case of `waitFor()` method, that is when
    one part of the app has to wait for another part of the app to get updated.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`dispatcherIndex`用于存储调度器注册方法的返回值。在`waitFor()`方法的情况下使用`dispatcherIndex`，即当应用的一部分需要等待应用的其他部分更新时。'
- en: 'The following is the code that shows the `dispatcherIndex`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了`dispatcherIndex`：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Controller-Views and Views
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制器-视图和视图
- en: 'Views are primarily the React Views, which essentially generate the actions.
    Controller-View listens to our stores, for any `changeEvent` been broadcasted.
    The `emitChange` events let our Controller-Views know if any change has to be
    performed into the state of the view or not. They are essentially React components.
    In our code, we have five such react components, as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 视图主要是React视图，它们本质上生成操作。控制器-视图监听我们的存储，以获取任何已广播的`changeEvent`。`emitChange`事件让我们的控制器-视图知道是否需要在视图的状态中执行任何更改。它们本质上都是React组件。在我们的代码中，我们有五个这样的React组件，如下所示：
- en: '`app-addbooktoreadinglist.js`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app-addbooktoreadinglist.js`'
- en: '`app-booklist.js`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app-booklist.js`'
- en: '`app.js`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.js`'
- en: '`app-readinglist.js`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app-readinglist.js`'
- en: '`app-removefromreadinglist.js`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app-removefromreadinglist.js`'
- en: 'The following is the code for `app-booklist.js`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为`app-booklist.js`的代码：
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following is the code that is internally called on the `AddBookToReadingList`
    React component:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在`AddBookToReadingList` React组件内部调用的代码：
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'At the end, the following component `<Booklist \>` is added in the `app.js`.
    This is essentially for the part where a user can see the books they have in the
    `ReadingList` list section:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`app.js`中添加了以下组件`<Booklist \>`。这主要是为了用户可以在`ReadingList`列表部分看到他们拥有的书籍：
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Revisiting the code
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视代码
- en: In each of the React components (`readingList` and `bookList`), `getInitialState()`
    is initialized with the store public method `getReadingList()` and `getLibrary()`,
    respectively.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个React组件（`readingList`和`bookList`）中，`getInitialState()`分别使用存储的公共方法`getReadingList()`和`getLibrary()`初始化。
- en: Various methods are executed at precise points in a component's lifecycle.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件的生命周期中，各种方法在精确的点被执行。
- en: '`componentWillMount()` is a React lifecycle method. It is invoked once, both
    on the client and server, immediately before the initial rendering occurs. If
    you call `setState` within this method, `render()` will see the updated state
    and will be executed only once despite change in the state:'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentWillMount()`是React的生命周期方法。它在客户端和服务器上都会被调用一次，在初始渲染发生之前立即执行。如果你在这个方法中调用`setState`，`render()`将看到更新的状态，并且即使状态发生变化，也只会执行一次：'
- en: '[PRE14]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Thus, `componentWillMount()` is listening to the `addChangeListener` (defined
    in the `AppStore` store). If the `_onChange` parameter is passed, then the current
    object (`_this`) is updated (`setState`) with the new/updated data/payload (`readingItems`).
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，`componentWillMount()`正在监听`addChangeListener`（在`AppStore`存储中定义）。如果传递了`_onChange`参数，则当前对象（`_this`）会更新（`setState`）为新/更新的数据/有效载荷（`readingItems`）。
- en: In order to remove the items from the reading list, the event listener (`handleClick`)
    is unmounted.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了从阅读列表中删除项目，事件监听器（`handleClick`）被卸载。
- en: 'The following is the code of app-`removebookfromreadinglist.js`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为`app-`removebookfromreadinglist.js`的代码：
- en: '[PRE15]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following is the code of `app.js`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为`app.js`的代码：
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The final view of our `library_app` Flux application
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`library_app` Flux应用程序的最终视图
- en: On clicking on the button **I want to borrow**, the corresponding book will
    come to my Reading List. Once I am done with the book, click on the button **Book
    Completed**, to remove the book from the reading list.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 点击按钮**我想借阅**时，相应的书籍将出现在我的阅读列表中。一旦我完成这本书，点击按钮**书籍完成**，从阅读列表中删除这本书。
- en: The following is a screenshot of our `library_app` application.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们`library_app`应用程序的截图。
- en: '![Revisiting the code](img/00037.jpeg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![重新审视代码](img/00037.jpeg)'
- en: How to run this Flux app will be covered in the building and deployment structure
    later.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如何运行这个Flux应用将在构建和部署结构中稍后介绍。
- en: 'The following are the details of the components of a Flux-based app:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是基于Flux的应用程序组件的详细信息：
- en: Actions
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动作
- en: Dispatchers (registry of callbacks)
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 派发器（回调注册的注册表）
- en: Stores (callbacks registered with dispatchers)
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储（与派发器注册的回调）
- en: Views
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图
- en: Controllers Views![Revisiting the code](img/00038.jpeg)
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器 视图![重新审视代码](img/00038.jpeg)
- en: data flow in Flux app
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Flux应用中的数据流
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Through our `libary_app` application, we have explored how the unidirectional
    data flow in a simple Flux-based application. The users can see the booklist in
    the views. They can add books in the reading list, thus the actions (adding books
    ) gets passed to the dispatchers. Internally the dispatchers have the registered
    callbacks with the stores. The stores then adds/removes the books based on the
    user's action and computes the business logic and re-renders the changes accordingly
    again to the views.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们的`libary_app`应用程序，我们探讨了简单Flux应用中单向数据流的工作方式。用户可以在视图中看到书单。他们可以在阅读列表中添加书籍，因此动作（添加书籍）被传递到派发器。内部，派发器有与存储注册的回调。然后存储根据用户的动作添加/删除书籍，并计算业务逻辑，相应地重新渲染视图。
- en: In the next chapter, we will cover React good practices and patterns. This includes
    practices to develop reusable components, how to structure your components hierarchically
    to a better data flow, and how to validate your components behavior. In our app,
    we'll be improving our components developed so far.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍React的良好实践和模式。这包括开发可重用组件的实践，如何以更好的数据流结构化组件层次结构，以及如何验证组件的行为。在我们的应用中，我们将改进到目前为止开发的组件。
