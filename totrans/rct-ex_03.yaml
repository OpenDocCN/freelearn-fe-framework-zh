- en: Chapter 3. Data Flow and Life Cycle Events
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 数据流和生命周期事件
- en: In the previous chapter, we saw the power of JSX. JSX makes it easy to write
    the React components.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了JSX的强大功能。JSX使得编写React组件变得容易。
- en: In this chapter, we will focus on the data flow between components and how to
    manage state and life cycle of components.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将关注组件之间的数据流以及如何管理组件的状态和生命周期。
- en: 'In this chapter, we will cover the following points:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Data flow in React
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React中的数据流
- en: Props
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Props
- en: PropTypes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PropTypes
- en: State
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态
- en: State versus props
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态与props
- en: When to use state and props
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时使用状态和props
- en: Component life cycle overview
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件生命周期概述
- en: Component life cycle methods
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件生命周期方法
- en: At the end of the chapter, we will get familiar with the data flow in the React
    components and the ways of maintaining and managing state. We will also get used
    to the life cycle of a component and various life cycle hooks provided by React.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们将熟悉React组件中的数据流以及维护和管理状态的方法。我们还将习惯于组件的生命周期以及React提供的各种生命周期钩子。
- en: Data flow in React
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React中的数据流
- en: Shawn and Mark were getting ready to start working on a rainy day with a cup
    of coffee.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 肖恩和马克正准备在雨天喝着咖啡开始工作。
- en: '"Hey Mike, I have a question about props that we used to pass the `headings`
    and `changeSet` data to other components."'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: “迈克，我对我们用来传递`headings`和`changeSet`数据的props有一个问题。”
- en: '"Shoot!" Mike exclaimed.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: “哎呀！”迈克惊呼。
- en: '"It seems to me that we are passing data to the components that are below the
    current component, but how can a component pass the data to the parent component?"'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: “在我看来，我们似乎正在将数据传递给当前组件下方的组件，但一个组件如何将数据传递给父组件呢？”
- en: '"Ah. In React, by default, all the data flows only in one direction: from parent
    component to child component. That''s it."'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: “啊。在React中，默认情况下，所有数据都只在一个方向上流动：从父组件到子组件。就是这样。”
- en: This makes the job of the child component simple and predictable. Take props
    from the parent and render." Mike explained.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得子组件的工作变得简单且可预测。从父组件接收props并渲染。”迈克解释道。
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '"Let''s look at our example. The `RecentChangesTables` component passes the
    props to the `Headings` and `Rows` components. So basically, we can say that `RecentChangesTables`
    owns the `Headings` and `Rows` components."'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: “让我们看看我们的例子。`RecentChangesTables`组件将props传递给`Headings`和`Rows`组件。所以基本上，我们可以这样说，`RecentChangesTables`拥有`Headings`和`Rows`组件。”
- en: '"In React, an owner component sets props for another components." Mike explained.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: “在React中，一个拥有者组件为另一个组件设置props。”迈克解释道。
- en: '"Got it. Therefore, in the preceding case, `<table>` is also owned by `RecentChangesTables`?"
    Shawn asked.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: “明白了。因此，在前面的例子中，`<table>`也是`RecentChangesTables`的拥有者吗？”肖恩问道。
- en: '"No. The owner relationship is specific to the React components. In this case,
    table is the parent of `Headings` and `Rows`, similar to the parent-child relationship
    in DOM. But it''s not an owner of them." explained Mike.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: “不。拥有者关系是特定于React组件的。在这种情况下，表格是`Headings`和`Rows`的父组件，类似于DOM中的父子关系。但它不是它们的拥有者。”迈克解释道。
- en: '"A component is the owner of a child component if that child gets created in
    the render method of the parent. I guess this will solve the confusion." Mike
    added.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: “如果一个子组件是在父组件的渲染方法中创建的，那么这个组件就是子组件的拥有者。我想这会解决混淆。”迈克补充道。
- en: '"Yes. Got the difference between owner and parent-child relationship." said
    Shawn.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: “是的。我明白了拥有者和父子关系之间的区别。”肖恩说。
- en: '"Furthermore, a component should not mutate its props. They should always be
    consistent with what the parent has set. It''s a very important point that makes
    React''s behavior consistent as well as fast, as we''ll see soon." Mike further
    added.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: “此外，一个组件不应该修改其props。它们应该始终与父组件设置的保持一致。这是一个非常重要的点，它使得React的行为既一致又快速，正如我们很快就会看到的。”迈克进一步补充道。
- en: '"Props can be accessed by `this.props`, as we have already seen. If anything
    in the parent''s props changes, React will make sure that the changes are flown
    downstream and will re-render the component tree." Mike.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: “可以通过`this.props`访问props，正如我们之前看到的。如果父组件的props中有任何变化，React将确保这些变化会向下流动，并重新渲染组件树。”迈克说。
- en: '"Excellent. Yesterday, I was reading something about validating the props."
    remembered Shawn.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: “太好了。昨天，我读了一些关于验证props的内容。”肖恩回忆道。
- en: '"Yes. React allows validating the props using `PropTypes`. Let''s take a look
    at them." said Mike, taking a sip from his freshly ground coffee.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: “是的。React允许使用`PropTypes`验证props。让我们看看它们。”迈克一边说着，一边喝了一口新鲜磨的咖啡。
- en: Props validation
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Props验证
- en: '"React provides a way to validate the props using PropTypes. This is extremely
    useful to ensure that the components are used correctly. Here is an example of
    using `propTypes` for our app." explained Mike.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '"React提供了一个使用PropTypes来验证props的方法。这非常有用，可以确保组件被正确使用。这里是一个使用`propTypes`为我们应用程序的例子。"
    迈克解释说。'
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '"Oh! Will it show an error as we are not passing the author, which is required,
    I assume? I see that `propTypes` has set the author value to be `isRequired`."
    Shawn asked.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '"哦！它会不会显示错误，因为我们没有传递作者，这是必需的，我猜？我看到`propTypes`已经将作者值设置为`isRequired`。" 肖恩问道。'
- en: '![Props validation](img/4730_03_01.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![Props validation](img/4730_03_01.jpg)'
- en: '"No. It will not throw an error, but it will show a nice warning for us to
    take a look at." said Mike.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '"不。它不会抛出错误，但它会显示一个漂亮的警告，让我们看看。" 迈克说。'
- en: '"Also, `propTypes` are only checked in development. Their job is to just check
    that all the assumptions that we are making about our components are being met."
    Mike added.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '"此外，`propTypes`只在开发时进行检查。它们的工作只是检查我们对我们组件所做的所有假设是否得到满足。" 迈克补充说。'
- en: '"Got it. I agree that it''s better to have it rather than getting surprised
    by random hiccups during production," Shawn.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '"明白了。我同意有它比在生产过程中被随机的小故障所惊讶要好得多," 肖恩说。'
- en: '"Yes. It''s especially useful as, along with standard types, we can also validate
    the custom types." Mike informed.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '"是的。它特别有用，因为我们不仅可以用标准类型，还可以验证自定义类型。" 迈克通知说。'
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '"Therefore, if the structure of the props is not as per your assumption, you
    can raise a warning by defining a custom validator as shown in the previous case",
    Mike explained.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '"因此，如果props的结构与你的假设不符，你可以通过定义一个自定义验证器来发出警告，就像上一个案例中展示的那样"，迈克解释说。'
- en: Specifying default props
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定默认props
- en: '"Shawn, React also allows us to define some default values for props. This
    is useful when parent component is passing props based on some condition or not
    passing some props at all due to some change," Mike said.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '"肖恩，React还允许我们为props定义一些默认值。这在父组件根据某些条件传递props或者由于某些变化而没有传递任何props时非常有用"，迈克说。'
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '"Here, we updated the code to not send the headings from props. Instead, we
    used the `getDefaultProps` function to define the default props that will be used
    in case they are not passed."'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '"在这里，我们更新了代码，不再从props中发送标题。相反，我们使用了`getDefaultProps`函数来定义在它们未传递时将使用的默认props。"'
- en: '![Specifying default props](img/4730_03_02.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![Specifying default props](img/4730_03_02.jpg)'
- en: '"Therefore, our output looks like this."'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '"因此，我们的输出看起来像这样。"'
- en: '"Oh, ok. Makes sense. Rather than fiddling with the if-else clauses to check
    whether the prop is present, default props make it simple enough to predefine
    our data." said Shawn.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '"哦，好的。这很有道理。与其通过if-else语句检查props是否存在，不如使用默认props来预先定义我们的数据简单得多。" 肖恩说。'
- en: Modifying this.props.children
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改this.props.children
- en: '"Shawn. There is one special prop that we should know about. It''s `this.props.children`,"
    continued Mike.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '"肖恩。我们应该了解一个特殊的props。它是`this.props.children`," 迈克继续说。'
- en: '"React captures all the children that are present in the opening and closing
    tag into props that can be accessed through `this.props.children`." said Mike.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '"React会将所有存在于开始和结束标签之间的子元素捕获到props中，这些props可以通过`this.props.children`访问。" 迈克说。'
- en: '"Let''s try to modify our code to use `this.props.children`. This is also required
    as we want to display a header for our output table." Mike added.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '"让我们尝试修改我们的代码以使用`this.props.children`。这也很有必要，因为我们想为我们的输出表格显示一个标题。" 迈克补充道。'
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![Modifying this.props.children](img/4730_03_03.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![Modifying this.props.children](img/4730_03_03.jpg)'
- en: '"Cool. So we extracted the table in its own component and also added a header."
    Shawn confirmed.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '"太好了。所以我们提取了表格到它自己的组件中，并添加了一个标题。" 肖恩确认道。'
- en: '"Yes and we rendered `Headings` and `Rows` using `this.props.children`." Mike
    explained.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '"是的，我们使用`this.props.children`来渲染`标题`和`行`。" 迈克解释道。'
- en: '"Awesome. Let me change our code based on our discussion about props." Shawn
    said excitedly.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '"太棒了。让我根据我们关于props的讨论来修改我们的代码。" 肖恩兴奋地说。'
- en: State
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态
- en: '"Shawn, let''s talk about one more technique of handling data in a component,
    state. Every component can have its own state in React. The main difference between
    state and props is that props are passed to the component from the parent component;
    whereas, state is something that is internal to the component.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '"肖恩，让我们再讨论一种在组件中处理数据的技术，状态。在React中，每个组件都可以有自己的状态。状态和props之间的主要区别是，props是从父组件传递给组件的；而状态是组件内部的东西。'
- en: Props are passed when a component gets instantiated. State is something that
    can change over time. Therefore, changes in state affect the rendering of components.
    Consider state as some sort of private data structure of the component." Mike
    added.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 组件实例化时传递props。state是随时间可以变化的东西。因此，state的变化会影响组件的渲染。可以把state看作是组件的一种私有数据结构。"迈克补充道。
- en: '"Mike, but then we have not used state at all until now. We were just using
    props." Shawn asked.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '"迈克，但到目前为止我们根本没使用过state。我们只是使用了props。"肖恩问道。'
- en: '"True. That is because state should be introduced only when it is required.
    You already know managing state is hard. As we were playing with static data of
    `ChangeSets` API, we didn''t require state. However, we will need it very soon."
    Mike added.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '"确实。这是因为只有在需要的时候才应该引入state。你已经知道管理state是困难的。当我们玩`ChangeSets` API的静态数据时，我们不需要state。然而，我们很快就会需要它。"迈克补充道。'
- en: Setting initial state
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置初始状态
- en: '"The initial state can be set using the `getInitialState` function." said Mike.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '"可以使用`getInitialState`函数设置初始状态。"迈克说。'
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '"State can be accessed similar to props using `this.state`." Mike explained
    further.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '"state可以通过`this.state`类似props的方式访问。"迈克进一步解释。'
- en: Setting state
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置state
- en: '"We might need to update the initial state based on some user events. Updating
    state is also easy using the `setState()` function." informed Mike.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '"我们可能需要根据某些用户事件更新初始状态。使用`setState()`函数更新state也很简单。"迈克通知道。'
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Avoiding state
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免使用state
- en: '"Currently, we don''t need state; however, when we fetch the dynamic data from
    `RecentChanges` API, we will use state with props." Mike added.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '"目前，我们不需要state；然而，当我们从`RecentChanges` API获取动态数据时，我们将使用state和props。"迈克进一步补充。'
- en: '"Cool. Based on our discussion, I think that we should avoid state as much
    as possible." Shawn suggested.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '"太好了。基于我们的讨论，我认为我们应该尽可能避免使用state。"肖恩建议。'
- en: '"True. If a component does not change, then there is no need to use state.
    It''s better to depend on props passed by the parent component in that case. This
    also avoids re-rendering of the component again and again as changes to state
    initiate a re-render of the component." Mike explained.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '"确实。如果一个组件没有变化，那么就没有必要使用state。在这种情况下，最好依赖于父组件传递的props。这也避免了组件因为state的变化而反复重新渲染。"迈克解释道。'
- en: State versus props
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: state与props的区别
- en: '"Shawn, it''s important to understand the difference between props and state
    and where to use what." informed Mike.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '"肖恩，理解props和state之间的区别以及何时使用什么非常重要。"迈克说道。'
- en: '"Props are immutable. They should not be updated by the component to which
    they are passed. They are are owned by the component which passes them to some
    other component. State is something internal and private to the component. State
    can and will change depending on the interactions with the outer world." said
    Mike.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '"props是不可变的。它们不应该被传递给它们的组件更新。它们属于将它们传递给其他组件的组件。state是组件内部和私有的东西。state会根据与外部世界的交互而改变。"迈克说。'
- en: '"State should store as simple data as possible, such as whether an input checkbox
    is checked or not or a CSS class that hides or displays the component." Mike added.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '"state应该存储尽可能简单的数据，例如输入复选框是否被选中或一个用于隐藏或显示组件的CSS类。"迈克补充道。'
- en: '"Another thing to make sure is to not duplicate props in state." said Mike.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '"还有一点需要确保的是，不要在state中重复props。"迈克说。'
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '"It is possible to set the state based on data passed in props. However, the
    parent component can update the props and send them again. In this case, the state
    will be muddled up with new data if there have been any changes to the state."'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '"根据传递给props的数据设置state是可能的。然而，父组件可以更新props并将它们再次发送。在这种情况下，如果state有任何变化，它将与新数据混淆。"'
- en: '"Also, the data is present at two places now, therefore, it becomes harder
    to manage two sources of data." Mike explained.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '"此外，数据现在存在于两个地方，因此，管理两个数据源变得更加困难。"迈克解释道。'
- en: '"I think that in such cases, it''s best to use props directly, right?" Shawn
    asked.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '"我想在这种情况下，直接使用props是最好的，对吧？"肖恩问道。'
- en: '"Yes. The state is entirely optional. It''s best to avoid it as much as possible.
    You got that right." Mike said happily.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '"是的。state完全是可选的。最好尽可能避免使用。你理解得对。"迈克高兴地说。'
- en: Component life cycle overview
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件生命周期概述
- en: '"Shawn, now let''s start taking a look at how to dynamically fetch data from
    [https://openlibrary.org/](https://openlibrary.org/), store it in our component,
    and render it after making it compatible to render.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '"肖恩，现在让我们开始看看如何从[https://openlibrary.org/](https://openlibrary.org/)动态获取数据，将其存储在我们的组件中，并在使其兼容渲染后进行渲染。'
- en: A component goes through different life cycle events. They help facilitate when
    we should initialize which part of a component or when should some external data
    be fetched.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 组件会经历不同的生命周期事件。它们帮助我们确定何时初始化组件的哪个部分，或者何时获取外部数据。
- en: We have already seen some of these methods such as `render`, `getInitialState`,
    and `getDefaultProps`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一些这些方法，例如`render`、`getInitialState`和`getDefaultProps`。
- en: An updated detailed list and example for the same can be found at [http://videos.bigbinary.com/react/react-life-cycle-methods-in-depth.html](http://videos.bigbinary.com/react/react-life-cycle-methods-in-depth.html).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[http://videos.bigbinary.com/react/react-life-cycle-methods-in-depth.html](http://videos.bigbinary.com/react/react-life-cycle-methods-in-depth.html)找到关于同一内容的更新详细列表和示例。
- en: 'Let''s go through each of these, one by one, and how they can be used so that
    we can start fetching dynamic information for display. Here is a list of methods
    that we will discuss:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一了解这些方法以及它们的使用方式，这样我们就可以开始获取用于显示的动态信息。以下是我们将讨论的方法列表：
- en: '`componentWillMount`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentWillMount`'
- en: '`componentDidMount`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentDidMount`'
- en: '`componentWillReceiveProps(object nextProps)`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentWillReceiveProps(object nextProps)`'
- en: '`boolean shouldComponentUpdate(object nextProps, object nextState)`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean shouldComponentUpdate(object nextProps, object nextState)`'
- en: '`componentWillUpdate(object nextProps, object nextState)`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentWillUpdate(object nextProps, object nextState)`'
- en: '`componentDidUpdate(object prevProps, object prevState)`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentDidUpdate(object prevProps, object prevState)`'
- en: '`componentWillUnmount()`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentWillUnmount()`'
- en: '`React.unmountComponentAtNode(document.body)`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`React.unmountComponentAtNode(document.body)`'
- en: Tip
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can follow along the next example at [http://jsbin.com/tijeco/3/edit](http://jsbin.com/tijeco/3/edit).
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以跟随下一个示例在[http://jsbin.com/tijeco/3/edit](http://jsbin.com/tijeco/3/edit)。
- en: Component life cycle methods
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件生命周期方法
- en: '"Shawn, let''s start with an exhaustive example that triggers these methods."
    Mike informed.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '"肖恩，让我们从一个能够触发这些方法的详尽示例开始。"迈克通知说。'
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![Component life cycle methods](img/4730_03_04.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![组件生命周期方法](img/4730_03_04.jpg)'
- en: '"It simply displays a body with the `true` text and then on clicking, it changes
    it to display `false`." Mike.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '"它只是显示一个带有`true`文本的正文，然后点击后，它会改变以显示`false`。"迈克。'
- en: '"Shawn, to keep things simple, I have added just a simple `console.log()` method
    for every life cycle method so that we know it was called. If we do a fresh run,
    the following is printed:"'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '"肖恩，为了使事情简单，我为每个生命周期方法添加了一个简单的`console.log()`方法，这样我们就可以知道它被调用了。如果我们进行一次全新的运行，以下内容会被打印出来："'
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '"Ah, got it. Basically, the window first printed `Start` to signal the file
    has been loaded." Shawn said.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '"啊，明白了。基本上，窗口首先打印了`Start`来表示文件已被加载。"肖恩说。'
- en: '"Correct. Next, it printed out `componentWillMount`. That''s the entry point
    for our component. This method is called when a component gets mounted on the
    body for the first time. If you can see, we are calling `React.render`."'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '"正确。接下来，它打印出了`componentWillMount`。这是我们组件的入口点。当组件第一次在主体上挂载时，会调用此方法。如果你能看到，我们正在调用`React.render`。”'
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is what triggers `componentWillMount`. In this method, we can call `setState`
    to perform some changes to our internal data. However, that doesn't call a new
    re-render or this method again.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这会触发`componentWillMount`。在这个方法中，我们可以调用`setState`来对我们内部数据进行一些更改。然而，这不会调用新的重新渲染或此方法再次调用。
- en: Next is the actual `render` method call. This is responsible for the actual
    component display.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是实际的`render`方法调用。这负责实际的组件显示。
- en: Finally, we have a call to `componentDidMount`. This is invoked immediately
    after mounting the component and only once after the component is rendered.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个对`componentDidMount`的调用。这会在组件挂载后立即调用，并且仅在组件渲染后调用一次。
- en: We can make use of this to fetch the dynamic information that we want to display
    in our component after the initial render of the component.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用这个方法在组件的初始渲染之后获取我们想要在组件中显示的动态信息。
- en: '"Once that''s done, we are done with our initial run for the display of a component!"'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '"一旦完成，我们就完成了组件显示的初始运行！"'
- en: '"Nice." exclaimed Shawn.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '"不错。"肖恩惊呼。'
- en: '"Now, we have added a simple `onClick` event. This calls `this.toggleState`,
    which toggles the current status from `true` to `false` and vice versa."'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '"现在，我们添加了一个简单的`onClick`事件。这会调用`this.toggleState`，它会将当前状态从`true`切换到`false`，反之亦然。"迈克说。'
- en: As the state is affected, React re-renders the `App` component. We can see the
    method call sequence when this happens, as follows:"
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于状态受到影响，React重新渲染了`App`组件。当发生这种情况时，我们可以看到方法调用序列，如下所示："
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '"Ah, nice. It went through another re-render cycle." said Shawn.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '"啊，不错。它又经历了一个重新渲染周期。"肖恩说。'
- en: '"Correct. When the state was changed, React knew it needed to re-render the
    `App` component. It calls `shouldComponentUpdate` first. This method returns `true`
    or `false` indicating React to render the component or not.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '"正确。当状态发生变化时，React知道它需要重新渲染`App`组件。它首先调用`shouldComponentUpdate`。这个方法返回`true`或`false`，指示React是否渲染组件。"'
- en: '"We can also control whether the component should be re-rendered or not even
    if the state gets updated. This method can return `false` and then React will
    not re-render the component even if the state is changed."'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '"我们甚至可以在状态更新时控制组件是否应该重新渲染。这种方法可以返回`false`，然后即使状态发生变化，React也不会重新渲染组件。"'
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '"We can also compare `nextProps` and `nextState` to the existing values and
    then decide whether to re-render."'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '"我们还可以比较`nextProps`和`nextState`与现有值，然后决定是否重新渲染。"'
- en: '"Awesome, this means that we could get faster components!" Shawn exclaimed.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '"太棒了，这意味着我们可以得到更快的组件！"肖恩兴奋地说。'
- en: '"Exactly. By default, it always returns true, to always render on changes."
    Mike concluded.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '"确实如此。默认情况下，它总是返回`true`，这意味着在变化时总是渲染。"迈克总结道。'
- en: '"Next up, `componentWillUpdate` will get called just before `rendering`. We
    can take care of any changes that we would like to do or any housekeeping. One
    thing to note is that we can''t call `setState` in this method. State updates
    should be handled elsewhere."'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '"接下来，`componentWillUpdate`将在渲染之前被调用。我们可以处理任何我们想要做的更改或任何家务工作。需要注意的是，我们在这个方法中不能调用`setState`。状态更新应该在别处处理。"'
- en: '"Oh, ok," Shawn.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '"哦，好的，"肖恩。'
- en: '"We are only left with `componentWillReceiveProps`."'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '"我们只剩下`componentWillReceiveProps`了。"'
- en: '[PRE13]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '"It receives `nextProps`, which are the new props that the child component
    receives from the parent component. This method is not called for initial render.
    We can update the state or do some other housekeeping work based on the changes
    in props."'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '"它接收`nextProps`，这是子组件从父组件接收的新属性。这个方法在初始渲染时不会被调用。我们可以根据属性的变化更新状态或做一些其他家务工作。"'
- en: '"Nice, Mike. I think I am getting a better hang of this."'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '"很好，迈克。我觉得我对这个越来越有感觉了。"'
- en: '"Finally, we have `componentWillUnmount`. This is called when the component
    is unmounted from the body. We can use this to release the resources, perform
    cleanups, unset any timers, and so on."'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '"最后，我们有`componentWillUnmount`。当组件从主体中卸载时会被调用。我们可以使用这个方法释放资源，执行清理工作，取消任何定时器等等。"'
- en: '"Got it."'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '"明白了。"'
- en: '"Alright! Let''s update our component to start fetching the information from
    [https://openlibrary.org/](https://openlibrary.org/)."'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '"好的！让我们更新我们的组件，开始从[https://openlibrary.org/](https://openlibrary.org/)获取信息。"'
- en: '"So, what we will be doing is updating the `componentDidMount` to perform an
    AJAX call and fetch data to display."'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '"所以，我们将更新`componentDidMount`来执行AJAX调用并获取要显示的数据。"'
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '"Here, we are making a call to [http://openlibrary.org/recentchanges.json?limit=10](http://openlibrary.org/recentchanges.json?limit=10)
    and asking for the ten most-recent changes. We will get the data in the following
    format:"'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '"在这里，我们正在调用[http://openlibrary.org/recentchanges.json?limit=10](http://openlibrary.org/recentchanges.json?limit=10)并请求最近的十个更改。我们将以以下格式获取数据："'
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '"We will need to format the data as per our requirements so that it''s displayed
    nicely. Let''s take a look at it:"'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '"我们需要根据我们的要求格式化数据，以便它能够很好地显示。让我们看看它："'
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '"Here, we are extracting the timestamp, author information, and description
    of the change, which is the comment in the change. As the changed time is a timestamp,
    we have made use of the `jQuery.timeago` plugin to get desirable display of time,
    such as `2 minutes ago` and so forth. To use this plugin, we need to include it
    in our HTML `head` tag." Mike explained.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '"在这里，我们正在提取时间戳、作者信息和更改的描述，即更改中的评论。由于更改的时间是一个时间戳，我们使用了`jQuery.timeago`插件来获取期望的显示时间，如`2分钟前`等等。要使用此插件，我们需要将其包含在我们的HTML`head`标签中。"迈克解释道。'
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '"Looks like it''s all coming together." Shawn.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '"看起来一切都在顺利进行。"肖恩说。'
- en: '"It is, let''s take a look at everything in action, shall we?"'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '"是的，让我们看看所有这些是如何实际运作的，怎么样？"'
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '"Here''s our final product!", exclaimed Mike.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '"这就是我们的最终产品！"迈克兴奋地说。'
- en: '"Awesome, I can''t wait to see what we build next!" Shawn added.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '"太棒了，我迫不及待想看看我们接下来会构建什么！"肖恩补充道。'
- en: Another productive day at Adequate. Mike and Shawn, happy with the progress,
    headed back.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在Adequate又一个高效的一天。迈克和肖恩对进度感到满意，于是返回了。
- en: Summary
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at how to pass around data in the React components
    using props and state. We also discussed how and when to use state and props.
    We looked at how `propTypes` can be used to validate the props. After that, we
    discussed the component's life cycle. We discussed about the various life cycle
    methods and how they can be used. After that, we used these life cycle methods
    to get real-time data from Open Library API.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何在 React 组件中使用 props 和 state 来传递数据。我们还讨论了何时以及如何使用 state 和 props。我们了解了如何使用
    `propTypes` 来验证 props。之后，我们讨论了组件的生命周期。我们讨论了各种生命周期方法及其使用方式。随后，我们利用这些生命周期方法从 Open
    Library API 获取实时数据。
