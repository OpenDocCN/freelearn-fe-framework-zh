- en: '*Chapter 4*: Integration Testing and Third-Party Libraries in Your Application'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 4 章*：在您的应用程序中使用集成测试和第三方库'
- en: In previous chapters, we learned how to test components in isolation separate
    from dependencies. We also learned how to test components that manage state. In
    many applications, teams can increase velocity by incorporating third-party tools
    to manage state and build components. By the end of this chapter, you will have
    learned about the benefits of using the integration approach to testing. You will
    understand how to configure tests to make assertions against components using
    advanced state management tools. You will learn how to test for errors rendered
    in applications. You will test components that interact with API servers that
    structure data differently from traditional **Representational State Transfer**
    (**REST**) APIs by allowing you to describe and receive only the specific data
    needed by your frontend application. Finally, you will learn how to test components
    that use a popular React component library.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了如何测试与依赖项隔离的组件，以及如何测试管理状态的组件。在许多应用程序中，团队可以通过引入第三方工具来管理状态和构建组件来提高速度。到本章结束时，你将了解使用集成测试方法的好处。你将了解如何配置测试，以使用高级状态管理工具对组件进行断言。你将学习如何测试应用程序中渲染的错误。你将测试与
    API 服务器交互的组件，这些服务器以与传统 **表示状态传输**（**REST**）API 不同的方式结构化数据，允许你描述并接收前端应用程序所需的具体数据。最后，你将学习如何测试使用流行的
    React 组件库的组件。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Gaining value with integration testing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过集成测试获得价值
- en: Testing components that use the Context API
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试使用 Context API 的组件
- en: Testing components that use Redux
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试使用 Redux 的组件
- en: Testing components that use GraphQL
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试使用 GraphQL 的组件
- en: Testing components built with Material-UI
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试使用 Material-UI 构建的组件
- en: The skills gained in this chapter will deepen our understanding of testing React
    components in various scenarios.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中获得的知识将加深我们对在各种场景下测试 React 组件的理解。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For the examples in this chapter, you will need to have Node.js installed on
    your machine. We will be using the `create-react-app` CLI tool for all code examples.
    Please familiarize yourself with the tool before starting the chapter if needed.
    Also, you will need to have a basic understanding of Redux and the React Context
    API. Code snippets will be provided throughout the chapter to help you understand
    the code under test, but the objective is understanding how to test the code.
    You can find code examples for this chapter here: [https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter04](https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter04).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的示例，您需要在您的机器上安装 Node.js。我们将使用 `create-react-app` CLI 工具来展示所有代码示例。如果需要，请在开始本章之前熟悉该工具。此外，您还需要对
    Redux 和 React Context API 有基本的了解。本章将提供代码片段以帮助您理解要测试的代码，但目标是理解如何测试代码。您可以在以下位置找到本章的代码示例：[https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter04](https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter04)。
- en: Testing integrated components
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试集成组件
- en: In the previous chapter, we learned how to test components in isolation from
    dependencies, including other components. Isolated testing has its advantages
    but also has drawbacks because real dependencies are replaced with test doubles.
    In this section, we will learn how to test components that integrate with other
    components. In many scenarios, integration testing can add more value than isolated
    testing because we can test the code in ways that are closer to its production
    use. We can also add test coverage faster for components because one test can
    cover multiple components at once. We will use integration testing in a few examples
    in this section.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何测试与依赖项（包括其他组件）隔离的组件。隔离测试有其优点，但也有缺点，因为真实依赖项被测试替身所取代。在本节中，我们将学习如何测试与其他组件集成的组件。在许多场景中，集成测试可以比隔离测试带来更多的价值，因为我们可以在更接近其生产使用的方式下测试代码。我们还可以更快地为组件添加测试覆盖率，因为一个测试可以同时覆盖多个组件。在本节中，我们将通过几个示例使用集成测试。
- en: Using integration testing with the Vote component
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用投票组件进行集成测试
- en: 'In the previous chapter, we tested the `Vote` component, which allowed users
    to click a button to increase or decrease the total likes. In this section, we
    will break up the implementation into separate components and write integration
    tests. The component included two `button` elements:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们测试了`Vote`组件，允许用户点击按钮来增加或减少总点赞数。在本节中，我们将将实现拆分为单独的组件，并编写集成测试。该组件包含两个`button`元素：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the previous code, the properties for the two button elements are very similar
    and could be extracted into their own component files to be reusable in other
    parts of the application:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，两个按钮元素的属性非常相似，可以提取到它们自己的组件文件中，以便在其他应用部分重复使用：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the previous code, we have a `VoteBtn` component created in its own file
    that can be reused anywhere throughout the application. `VoteBtn` can be used
    inside the `Vote` component to replace the hardcoded `button` element:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们创建了一个`VoteBtn`组件，它可以在整个应用中任何地方重复使用。`VoteBtn`可以在`Vote`组件中使用，以替换硬编码的`button`元素：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the previous code, two instances of `VoteBtn` are integrated into the `Vote`
    component. We could test `VoteBtn` in isolation from the `Vote` component, but
    we can gain more value by testing the integration of the two together. For the
    first test, we can verify that an `"up"` vote increases the sum of total likes
    by one:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，两个`VoteBtn`实例被集成到`Vote`组件中。我们可以从`Vote`组件中单独测试`VoteBtn`，但通过一起测试这两个组件的集成，我们可以获得更多的价值。对于第一个测试，我们可以验证一个`"up"`投票会增加总点赞数一个：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the previous code, first, we rendered the `Vote` component into the DOM
    with a value of `10` passed into the `totalGlobalLikes` property. Next, we click
    the `11` in is the DOM. For the next test, we will verify that a `"down"` vote
    decreases the sum of total likes by one:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，首先，我们将`Vote`组件渲染到DOM中，并将`10`这个值传递给`totalGlobalLikes`属性。接下来，我们点击DOM中的`11`。对于下一个测试，我们将验证一个`"down"`投票会减少总点赞数一个：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the previous example, the code is similar to that in the first example.
    The only difference is instead of clicking the `9` is in the DOM. The last test
    we will write will verify that a user can only vote once:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的例子中，代码与第一个例子相似。唯一的区别是，我们没有点击DOM中的`9`。最后一个我们将要编写的测试将验证用户只能投票一次：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the previous code, first, we rendered the `Vote` component into the DOM with
    a value of `10` passed into the `totalGlobalLikes` property. Next, we grab the
    `11` is in the DOM. The number `11` is expected because the **thumbs up** button
    was clicked first, which disables the buttons. By using the integration testing
    approach, we were able to verify the outcome of the total likes displayed on the
    screen and the state of buttons after simulating click events all in the same
    test.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，首先，我们将`Vote`组件渲染到DOM中，并将`10`这个值传递给`totalGlobalLikes`属性。接下来，我们在DOM中抓取了`11`。这个数字`11`是预期的，因为首先点击了**点赞**按钮，这会禁用其他按钮。通过使用集成测试方法，我们能够在同一个测试中验证屏幕上显示的总点赞数以及模拟点击事件后的按钮状态。
- en: 'When we run all the `Vote` component tests, we get the following output:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行所有的`Vote`组件测试时，我们得到以下输出：
- en: '![Figure 4.1 – Vote component test results'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 4.1 – Vote组件测试结果'
- en: '](img/Figure_4.1_B16887.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 4.1 – Vote component test results](img/Figure_4.1_B16887.jpg)'
- en: Figure 4.1 – Vote component test results
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – Vote组件测试结果
- en: The preceding screenshot shows that tests `Vote.test.js` file.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图显示了`Vote.test.js`测试文件。
- en: Now you understand the advantages of testing components integrated with dependencies.
    However, there are scenarios where using the integrated approach may not be the
    best strategy. In the next section, we will look at a scenario where testing a
    component in isolation would provide more value than integration testing.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了与依赖项集成测试组件的优势。然而，在某些情况下，使用集成方法可能不是最佳策略。在下一节中，我们将探讨一个场景，其中单独测试组件比集成测试更有价值。
- en: Planning test scenarios better suited for isolated testing
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 规划更适合单独测试的测试场景
- en: 'In the previous section, we learned the advantages of testing components integrated
    with dependencies. However, there are some scenarios where using the isolated
    testing approach is a better fit. In the *Implementing test-driven development*
    section of [*Chapter 3*](B16887_03_Final_PG_ePub.xhtml#_idTextAnchor046), *Testing
    Complex Components with React Testing Library*, we built a registration form.
    As a reference, the output of the component was as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了测试与依赖项集成组件的优势。然而，有些情况下使用隔离测试方法更为合适。在[*第 3 章*](B16887_03_Final_PG_ePub.xhtml#_idTextAnchor046)的*实现测试驱动开发*部分，[*《使用
    React 测试库测试复杂组件》*]中，我们构建了一个注册表单。作为参考，组件的输出如下：
- en: '![Figure 4.2 – Registration form](img/Figure_4.2_B16887.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – 注册表单](img/Figure_4.2_B16887.jpg)'
- en: Figure 4.2 – Registration form
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 注册表单
- en: 'In the preceding screenshot, we see the registration component that allows
    a user to submit an email address and password. The test used the isolated approach
    and verified the happy path of invoking a `handleRegister` method when the form
    is submitted. Let''s say a new feature is added where a success message is sent
    to the frontend from the server and replaces the form on the screen when registration
    is successful:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们看到注册组件允许用户提交电子邮件地址和密码。测试使用了隔离方法，并验证了在表单提交时调用 `handleRegister` 方法的快乐路径。假设添加了一个新功能，其中成功消息从服务器发送到前端，并在注册成功时替换屏幕上的表单：
- en: '![Figure 4.3 – Registration success](img/Figure_4.3_B16887.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3 – 注册成功](img/Figure_4.3_B16887.jpg)'
- en: Figure 4.3 – Registration success
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – 注册成功
- en: In the preceding screenshot, the message **Registration Successful!** is displayed
    after successful form submission. Verifying the message is on the screen after
    submitting the form could be tested using the integration approach but might be
    a slow-running test. We could create a faster running isolated test by creating
    a mock server response. What about scenarios where form validation errors are
    displayed and prevent users from submitting the form? For example, form validation
    errors could be displayed when a user enters an invalid email or attempts to submit
    the form with blank fields. The password field could also present several test
    scenarios, such as displaying errors when the minimal password length is not met,
    or special characters are not included in the password.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，在成功提交表单后，显示消息**注册成功！**验证表单提交后屏幕上显示的消息可以使用集成方法进行测试，但可能是一个运行缓慢的测试。我们可以通过创建模拟服务器响应来创建一个运行速度更快的隔离测试。那么，当表单验证错误显示并阻止用户提交表单时会发生什么情况？例如，当用户输入无效的电子邮件或尝试提交空白字段时，会显示表单验证错误。密码字段也可能呈现几个测试场景，例如当密码长度不足或密码中不包含特殊字符时显示错误。
- en: The previous scenarios are all good use cases for the isolated test approach.
    The errors displayed on the screen do not depend on any code outside the component.
    We can test various combinations in the form and edge cases that will run extremely
    fast and quickly add a lot of value. In general, consider creating an isolated
    test for scenarios where a test setup using the integrated approach would prove
    cumbersome or when the integration approach yields slow-running tests. Also, keep
    in mind how many dependencies have to be mocked when creating an isolated test.
    Mocking multiple dependencies provides less value than testing with dependencies
    included.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 上述场景都是隔离测试方法的良好用例。屏幕上显示的错误不依赖于组件外的任何代码。我们可以在表单中测试各种组合和边缘情况，这些情况将运行得非常快，并迅速增加大量价值。一般来说，考虑在集成方法设置测试会显得繁琐或集成方法产生运行缓慢的测试时创建隔离测试。同时，记住在创建隔离测试时需要模拟多少依赖项。模拟多个依赖项提供的价值不如包含依赖项的测试。
- en: Now you know how to test components integrated with dependencies. You understand
    the benefits of integration testing compared to testing in isolation. You also
    know that in some scenarios, testing a component using the isolated approach can
    yield better outcomes for your testing plan than solely using the integrated approach.
    The decision to test a component in isolation or integrated with dependencies
    will depend on your test plans. In the next section, we will visit more examples
    using the isolated and integrated testing approach and learn how to test components
    that use the Context API for state management.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何测试与依赖项集成的组件。你理解了集成测试与单独测试相比的优势。你还知道在某些情况下，使用隔离方法测试组件可能比仅使用集成方法为你的测试计划带来更好的结果。是否单独测试组件或与依赖项集成将取决于你的测试计划。在下一节中，我们将探讨更多使用隔离和集成测试方法的示例，并学习如何测试使用Context
    API进行状态管理的组件。
- en: Testing components that use the Context API
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试使用Context API的组件
- en: 'In this section, we will learn how to test components that use the React library''s
    `Context Provider` component:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何测试使用React库的`Context Provider`组件的组件：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code, the `LikesProvider` component, responsible for providing
    the Context state to Context consumers, is rendered with `Vote` as a child component.
    `LikesProvider` provides all the consuming components with an `initialLikes` count
    of `10`. Since `Vote` is rendered within `LikesProvider`, it can view and update
    state provided by `LikesProvider`. To test the `Context` `Provider` component's
    consumers, we need a way to access `Context Provider` within our tests. We will
    use a retail application to demonstrate how to implement the requirements.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，负责向Context消费者提供Context状态的`LikesProvider`组件以`Vote`作为子组件进行渲染。`LikesProvider`为所有消费组件提供了一个`initialLikes`计数为`10`。由于`Vote`在`LikesProvider`内部渲染，它可以查看和更新`LikesProvider`提供的状态。为了测试`Context`
    `Provider`组件的消费者，我们需要一种方法在测试中访问`Context Provider`。我们将使用零售应用程序来演示如何实现这些要求。
- en: Testing a context consuming Retail component
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试使用Context的`Retail`组件
- en: 'In this section, we will test a `Retail` component that consumes state provided
    by a `RetailContext` component. The UI of the `Retail` component looks as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将测试一个`Retail`组件，该组件使用由`RetailContext`组件提供的状态。`Retail`组件的UI如下所示：
- en: '![Figure 4.4 – Retail component UI'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.4 – `Retail`组件UI'
- en: '](img/Figure_4.4_B16887.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.4_B16887.jpg)'
- en: Figure 4.4 – Retail component UI
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 – `Retail`组件UI
- en: 'The preceding screenshot shows the initial screen output of the `Retail` component.
    A list of clothing products and a shopping cart is shown. There is also a section
    with the text **Retail Store** that will display product details once clicked:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图显示了`Retail`组件的初始屏幕输出。显示了一列服装产品和购物车。还有一个带有文本**Retail Store**的板块，点击后会显示产品详情：
- en: '![Figure 4.5 – Product details'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.5 – 产品详情'
- en: '](img/Figure_4.5_B16887.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.5_B16887.jpg)'
- en: Figure 4.5 – Product details
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 – 产品详情
- en: 'The preceding screenshot shows details for **Mens Casual Premium Slim Fit T-Shirts**
    after being clicked by the user. A user can click the **ADD TO FAVORITES** button
    to *favorite* the item:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图显示了用户点击后的**男士休闲高级修身T恤**的详情。用户可以点击**添加到收藏**按钮来**收藏**该商品：
- en: '![Figure 4.6 –Favorited product details](img/Figure_4.6_B16887.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图4.6 – 收藏的产品详情](img/Figure_4.6_B16887.jpg)'
- en: Figure 4.6 –Favorited product details
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 – 收藏的产品详情
- en: 'The preceding screenshot shows that the text **ADD TO FAVORITES** changes to
    **ADDED TO FAVORITES** once the button is clicked. Finally, a user can add a quantity
    and click the **ADD TO CART** button to add the product to their cart:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图显示，一旦点击按钮，文本**添加到收藏**会变为**已添加到收藏**。最后，用户可以输入数量并点击**添加到购物车**按钮将产品添加到购物车中：
- en: '![Figure 4.7 – Product added to cart](img/Figure_4.7_B16887.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图4.7 – 已添加到购物车的产品](img/Figure_4.7_B16887.jpg)'
- en: Figure 4.7 – Product added to cart
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 – 已添加到购物车的产品
- en: The preceding screenshot shows a quantity of **3** of the item **Mens Casual
    Premium Slim Fit T-Shirts** added to the cart. The cart displays **1 Items**,
    representing the total items in the cart. The cart also shows the **Subtotal**
    for all items added to the cart.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图显示了购物车中添加了**3**件**男士休闲高级修身T恤**。购物车显示了**1 Items**，代表购物车中的总商品数。购物车还显示了所有添加到购物车的商品的**小计**。
- en: 'In the code implementation, the `Retail` component is rendered as a child component
    of `RetailProvider` inside `App`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码实现中，`Retail`组件作为`App`内部的`RetailProvider`的子组件进行渲染：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding code, `RetailProvider` receives an array of products via `retailProducts`.
    The `retailProducts` data is a local subset of data from the `Fake Store API`
    ([https://fakestoreapi.com](https://fakestoreapi.com)) API, a free open source
    REST API that provides sample products. The `Retail` component includes three
    separate child components – `ProductList`, `ProductDetail`, and `Cart` – that
    integrate together to consume and manage `RetailContext` state:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`RetailProvider` 通过 `retailProducts` 接收产品数组。`retailProducts` 数据是来自 `Fake
    Store API` ([https://fakestoreapi.com](https://fakestoreapi.com)) API 的本地数据子集，这是一个免费的开放源代码
    REST API，提供示例产品。`Retail` 组件包括三个独立的子组件 – `ProductList`、`ProductDetail` 和 `Cart`
    – 它们集成在一起以消费和管理 `RetailContext` 状态：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `Retail` component renders the `ProductList`, `ProductDetail`, and `Cart`
    components as child components inside `div` elements in the preceding code.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`Retail` 组件在前面代码中的 `div` 元素内渲染 `ProductList`、`ProductDetail` 和 `Cart` 组件作为子组件。'
- en: We will use a combination of isolated unit tests and integration tests to verify
    that the `Retail` code works as expected.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用隔离单元测试和集成测试的组合来验证 `Retail` 代码按预期工作。
- en: Testing the Cart component in isolation
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 独立测试购物车组件
- en: 'In this section, we will verify the initial state of the `Cart` component.
    We will use a unit test approach because the initial state depends on `RetailContext`
    and not other `Retail` components:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将验证 `Cart` 组件的初始状态。我们将使用单元测试方法，因为初始状态依赖于 `RetailContext` 而不是其他 `Retail`
    组件：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the previous code, we first render the `Cart` component as a child of `RetailProvider`.
    Next, we make two assertions. First, we assert the text `0 items` is in the DOM.
    Then, we assert the text `$0.00` is in the DOM. When we run the test for the `Cart`
    component, we get the following output:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先将 `Cart` 组件作为 `RetailProvider` 的子组件进行渲染。然后，我们进行两个断言。首先，我们断言文本 `0
    items` 在 DOM 中。然后，我们断言文本 `$0.00` 在 DOM 中。当我们为 `Cart` 组件运行测试时，我们得到以下输出：
- en: '![Figure 4.8 – Cart component test result'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.8 – 购物车组件测试结果'
- en: '](img/Figure_4.8_B16887.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.8_B16887.jpg)'
- en: Figure 4.8 – Cart component test result
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 – 购物车组件测试结果
- en: The preceding screenshot shows the test `Cart` component.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图显示了测试的 `Cart` 组件。
- en: In the next section, we will test the `Product` component.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将测试 `Product` 组件。
- en: Testing the Product component in isolation
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 独立测试产品组件
- en: 'In this section, we will verify the `Product` component can display passed-in
    product data to the DOM. We will use `faker`, a popular library, to generate test
    data. We can write the following test:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将验证 `Product` 组件能否将传入的产品数据显示到 DOM 中。我们将使用流行的库 `faker` 生成测试数据。我们可以编写以下测试：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the previous code snippet, we use `faker` to generate random `productName`,
    `price`, and `fashion image` data for our test. Using `faker` to generate our
    test data automatically, we can eliminate any confusion for new team members looking
    at our code to learn about the component under test. A new team member may see
    hardcoded data and think the component must have that specific data to work properly.
    Random data created by `faker` can make it clearer that the component does not
    need to be specifically hardcoded to function as expected. Next, we write the
    remaining code for the test:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用 `faker` 为我们的测试生成随机的 `productName`、`price` 和 `fashion image` 数据。使用
    `faker` 自动生成我们的测试数据，我们可以消除新团队成员查看我们的代码学习测试组件时的任何困惑。新团队成员可能会看到硬编码的数据，并认为组件必须具有特定的数据才能正常工作。由
    `faker` 创建的随机数据可以使它更清晰，即组件不需要被特别硬编码才能按预期工作。接下来，我们为测试编写剩余的代码：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the previous code snippet, we wrap the `Product` component inside `RetailProvider`,
    pass in test data as props, and render the DOM component. Finally, assert that
    the product `title` and `price` is in the DOM. Now we have verified that the `Product`
    component accepts and renders prop data into the DOM as expected. When we run
    the test for the `Product` component, we get the following output:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们将 `Product` 组件包裹在 `RetailProvider` 中，将测试数据作为 props 传入，并渲染 DOM 组件。最后，断言产品
    `title` 和 `price` 在 DOM 中。现在我们已经验证了 `Product` 组件能够按预期接受并渲染 prop 数据到 DOM 中。当我们为
    `Product` 组件运行测试时，我们得到以下输出：
- en: '![Figure 4.9 – Product component test result'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.9 – 产品组件测试结果'
- en: '](img/Figure_4.9_B16887.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.9_B16887.jpg)'
- en: Figure 4.9 – Product component test result
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9 – 产品组件测试结果
- en: The preceding screenshot shows the test `Product` component correctly displays
    passed in data to the screen.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图显示了测试的 `Product` 组件正确地将传入的数据显示到屏幕上。
- en: Next, we will test the `ProductDetail` component.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将测试 `ProductDetail` 组件。
- en: Testing the ProductDetail component in isolation
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 独立测试 ProductDetail 组件
- en: 'This section will verify that `ProductDetail` initially renders the text **Retail
    Store** into the DOM. The **Retail Store** text serves as a placeholder until
    a user clicks one of the products. We can test the component as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将验证 `ProductDetail` 组件最初将文本 **Retail Store** 渲染到 DOM 中。**Retail Store** 文本作为占位符，直到用户点击其中一个产品。我们可以按照以下方式测试组件：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the preceding code, we wrap `ProductDetail` inside `RetailProvider`. Then,
    we assert that the text **Retail Store** is in the DOM. Running the test results
    in the following output:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将 `ProductDetail` 包裹在 `RetailProvider` 中。然后，我们断言文本 **Retail Store**
    在 DOM 中。运行测试会产生以下输出：
- en: '![Figure 4.10 – ProductDetail component test result](img/Figure_4.10_B16887.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.10 – ProductDetail 组件测试结果](img/Figure_4.10_B16887.jpg)'
- en: Figure 4.10 – ProductDetail component test result
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10 – `ProductDetail` 组件测试结果
- en: The preceding screenshot shows the test `ProductDetail` renders the correct
    text on the initial render.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图显示了测试中 `ProductDetail` 在初始渲染时正确显示了文本。
- en: Next, we will verify the error displayed when a consumer is used outside of
    `Context Provider`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将验证当消费者在 `Context Provider` 之外使用时显示的错误。
- en: Testing context errors using error boundaries
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用错误边界测试上下文错误
- en: 'In this section, we will verify that the `Retail` component must be wrapped
    in `RetailProvider` before using it in the first test. This test is important
    because the `Retail` component cannot work as expected without the stateful data
    provided by `RetailContext`. Inside the `RetailContext` code, we have a check
    to make sure the methods used to access `RetailContext` are used within `Provider`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将验证在使用 `Retail` 组件进行第一次测试之前，必须将其包裹在 `RetailProvider` 中。这个测试很重要，因为如果没有
    `RetailContext` 提供的状态数据，`Retail` 组件无法按预期工作。在 `RetailContext` 代码内部，我们有一个检查来确保用于访问
    `RetailContext` 的方法是在 `Provider` 内部使用的：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the previous code snippet, if a user attempts to use the `useRetail` method
    to access `RetailContent`''s stateful data outside of `RetailProvider`, a *throw
    error* will occur and stop the application from running. We can write the test
    as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码片段中，如果用户尝试在 `RetailProvider` 之外使用 `useRetail` 方法访问 `RetailContent` 的状态数据，将会抛出一个
    *错误* 并停止应用程序的运行。我们可以按照以下方式编写测试：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code, we use the `jest.spyOn` method to keep an eye on the
    `console.log` method throughout the test. We also attach an empty callback method
    as `mockImplementation`. We use `mockImplementation` to control what happens when
    `console.error` is called. We don't want anything specific logged to the console
    in our test results related to the console for this `test.error` execution, so
    we pass in the empty callback function.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用 `jest.spyOn` 方法在整个测试过程中监视 `console.log` 方法。我们还附加了一个空的回调方法作为 `mockImplementation`。我们使用
    `mockImplementation` 来控制 `console.error` 被调用时会发生什么。我们不想在我们的测试结果中记录任何与 `test.error`
    执行相关的特定内容，所以我们传递了一个空的回调函数。
- en: Next, we create `ErrorFallback`, a component we will use to receive the message
    included in the error thrown by `RetailContext`. Next, we wrap `Retail` in `ErrorBoundary`,
    which gives us control over errors thrown by components. We can manually create
    an error boundary component but `react-error-boundary` ([https://github.com/bvaughn/react-error-boundary](https://github.com/bvaughn/react-error-boundary))
    provides an easy-to-use error boundary component. We provide `ErrorFallback` as
    the value for `FallbackComponent`. When `Retail` is rendered, and the error is
    thrown, the `ErrorBoundary` component will pass the error on to `ErrorFallback`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建 `ErrorFallback` 组件，这是我们用来接收 `RetailContext` 抛出的错误信息的组件。然后，我们将 `Retail`
    组件包裹在 `ErrorBoundary` 中，这样我们可以控制组件抛出的错误。我们可以手动创建一个错误边界组件，但 `react-error-boundary`
    ([https://github.com/bvaughn/react-error-boundary](https://github.com/bvaughn/react-error-boundary))
    提供了一个易于使用的错误边界组件。我们将 `ErrorFallback` 作为 `FallbackComponent` 的值。当 `Retail` 组件渲染时，如果抛出错误，`ErrorBoundary`
    组件会将错误传递给 `ErrorFallback`。
- en: 'Next, we perform assertions:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们执行断言：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding code, first, we query the DOM for the error message `must be
    used within the RetailProvider`. Next, we expect `console.error` to have been
    called. Finally, as a test clean-up step, we restore `console.error` back to its
    original state, allowing it to be called wherever necessary for successive tests.
    Now you know how to verify that a context-consuming component cannot be rendered
    outside of `Context Provider`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先，我们在 DOM 中查询错误消息 `必须在使用 RetailProvider 时使用`。然后，我们期望 `console.error`
    被调用。最后，作为测试清理步骤，我们将 `console.error` 恢复到其原始状态，允许它在后续测试中必要时被调用。现在你知道如何验证消耗上下文的组件不能在
    `Context Provider` 之外渲染。
- en: Using integration testing to test view product details
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用集成测试来测试查看产品详情
- en: 'For our next test, we will verify that a user can click a product and see product
    details. The steps involved in viewing a product''s details is a user workflow
    that would be good to test using the integration approach. We can write the test
    as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的下一个测试，我们将验证用户能否点击产品并查看产品详情。查看产品详情的步骤是一个用户工作流程，使用集成方法进行测试会很好。我们可以这样编写测试：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the preceding code, we wrap the `Retail` component in `RetailProvider` and
    render it in the DOM. Next, we grab the first item in the `testProducts` array
    and assign it to the variable `firstProduct`. Then, we click the `title` of the
    first product on the screen. Finally, we assert the output:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们在 DOM 中包装了 `Retail` 组件并在其中渲染。接下来，我们获取 `testProducts` 数组中的第一个项目并将其分配给变量
    `firstProduct`。然后，我们点击屏幕上第一个产品的 `title`。最后，我们断言输出：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding code, we assert the first product's title is displayed twice
    on the screen. Finally, we assert the product's `description` and `price` data
    is displayed on the screen.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们断言第一个产品的标题在屏幕上显示两次。最后，我们断言产品的 `description` 和 `price` 数据在屏幕上显示。
- en: 'For our next test, we will verify that a user can add a product to the cart.
    We can write the following test code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的下一个测试，我们将验证用户能否将产品添加到购物车。我们可以编写以下测试代码：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the previous code snippet, we create an `addFirstItemToCart` function to
    execute the same test steps in successive tests and avoid code duplication. Next,
    we write the main test code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们创建了一个 `addFirstItemToCart` 函数来执行连续测试中的相同测试步骤并避免代码重复。接下来，我们编写主要的测试代码：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the previous code, we render the `Retail` component inside `RetailProvider`.
    Next, we execute the `addFirstItemToCart` method. Finally, we assert that the
    text `1 items` is in the DOM. Now we are confident a user can add an item to the
    cart using `Retail` integrated with the `Product`, `ProductDetail`, and `Cart`
    components.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们在 `RetailProvider` 内部渲染了 `Retail` 组件。接下来，我们执行 `addFirstItemToCart`
    方法。最后，我们断言文本 `1 items` 出现在 DOM 中。现在我们确信用户可以使用 `Retail` 与 `Product`、`ProductDetail`
    和 `Cart` 组件集成来添加商品到购物车。
- en: 'As a challenge, try to write the code for the following test scenarios: **A
    user can update the quantity for cart items**, **A user cannot submit a quantity
    greater than 10**, **A user cannot submit a quantity less than 1**, and **A user
    can add an item to favorites**. The solutions for these test scenarios can be
    found in the [*Chapter 4*](B16887_04_Final_PG_ePub.xhtml#_idTextAnchor062) *code
    samples* ([https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter04/ch_04_context](https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter04/ch_04_context)).
    Now you know how to write integration tests for components that use the Context
    API. You have a better understanding of unit testing components in isolation through
    multiple examples. You also know how to test for errors thrown using error boundaries.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 作为挑战，尝试编写以下测试场景的代码：**用户可以更新购物车中商品的数量**、**用户不能提交大于 10 的数量**、**用户不能提交小于 1 的数量**，以及**用户可以将商品添加到收藏夹**。这些测试场景的解决方案可以在[*第
    4 章*](B16887_04_Final_PG_ePub.xhtml#_idTextAnchor062) *代码示例*中找到（[https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter04/ch_04_context](https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter04/ch_04_context)）。现在你知道如何编写使用
    Context API 的组件的集成测试。你通过多个示例更好地理解了如何单独测试组件。你还知道如何使用错误边界测试抛出的错误。
- en: This section's learnings will be beneficial in the next section when we learn
    how to test components that manage state using Redux. There will be a few differences,
    but similar strategies from this section will be used in general.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的学习内容将在下一节中受益，那时我们将学习如何使用 Redux 测试管理状态组件。会有一些差异，但本节中的相似策略将普遍使用。
- en: Testing components that use Redux
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试使用 Redux 的组件
- en: This section will teach you how to test components that use the popular `Context
    Provider`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将教你如何测试使用流行的 `Context Provider` 的组件。
- en: 'To test components using Redux, components must be used within the Redux state
    providing context:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Redux 测试组件，组件必须在 Redux 状态提供上下文中使用：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding code, we have a top-level `App` passed in as a child component
    of the Redux `Provider` component. Wrapping the top-level `App` component is a
    common pattern in Redux that allows any child component in the application to
    access the stateful data provided by Redux. Stateful data and methods to modify
    state are passed to the Provider's `store` property. Typically, you will create
    this code in separate files, wire everything together using Redux's API methods,
    and pass the combined result to the `store` property.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有一个作为 Redux `Provider` 组件子组件传递的顶层 `App`。将顶层 `App` 组件包裹起来是 Redux 中的一种常见模式，它允许应用程序中的任何子组件访问
    Redux 提供的状态数据。状态数据和修改状态的方法通过传递给 Provider 的 `store` 属性。通常，你将在单独的文件中创建此代码，使用 Redux
    的 API 方法将所有内容连接起来，并将组合结果传递给 `store` 属性。
- en: 'When designing Redux-consuming component tests, we need to pass in test data
    that we can use as the Redux state. Simply passing in test data to the `store`
    property of the Redux Provider will not work because we also need to include the
    Redux methods used to consume and update the stateful data:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计消耗 Redux 的组件测试时，我们需要传递测试数据，我们可以将其用作 Redux 状态。仅仅将测试数据传递给 Redux Provider 的
    `store` 属性是不够的，因为我们还需要包括用于消耗和更新状态数据的 Redux 方法：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the previous code snippet, we have a `Cart` component test that passes in
    the string **some test data** as test data to the Redux store. When we run the
    test, we receive the following output:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们有一个 `Cart` 组件测试，它将字符串 **一些测试数据** 作为测试数据传递给 Redux 存储。当我们运行测试时，我们收到以下输出：
- en: '![Figure 4.11 – Failed Cart Redux component test'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.11 – 失败的购物车 Redux 组件测试](img/Figure_4.11_B16887.jpg)'
- en: '](img/Figure_4.11_B16887.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.11 – 失败的购物车 Redux 组件测试](img/Figure_4.11_B16887.jpg)'
- en: Figure 4.11 – Failed Cart Redux component test
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11 – 失败的购物车 Redux 组件测试
- en: 'The preceding screenshot shows the test `TypeError: store.getState is not a
    function` to the console. The `render` method. The test failed because when the
    component under test renders, it tries to access a method provided by Redux to
    access the Redux store''s state, but the method is not available. We need a way
    to pass all associated Redux state methods and controllable test data to the test.
    We will learn a strategy in the next section.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '前面的截图显示了测试 `TypeError: store.getState is not a function` 被输出到控制台。测试失败是因为当被测试的组件渲染时，它试图访问
    Redux 提供的用于访问 Redux 存储状态的方法，但该方法不可用。我们需要一种方法来传递所有相关的 Redux 状态方法和可控制测试数据到测试中。我们将在下一节中学习一种策略。'
- en: Creating a custom render method for testing Redux consuming components
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为测试消耗 Redux 组件创建自定义的 `render` 方法
- en: 'In this section, we will learn how to create a custom `render` function for
    use in our tests. In [*Chapter 1*](B16887_01_Final_PG_ePub.xhtml#_idTextAnchor013),
    *Exploring React Testing Library*, we learned that React Testing Library''s `render`
    method is used to place components in the DOM to be tested. The custom `render`
    method uses React Testing Library `render` method''s `wrapper` option to place
    components into the DOM wrapped in a Redux Provider component that provides access
    to Redux API methods. The custom `render` method will also allow us to pass in
    controllable test data unique to each test. To get started, we will create a file
    for our method and import a number of modules:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何为我们的测试创建一个自定义的 `render` 函数。在 [*第 1 章*](B16887_01_Final_PG_ePub.xhtml#_idTextAnchor013)，*探索
    React 测试库* 中，我们了解到 React 测试库的 `render` 方法用于将组件放置在待测试的 DOM 中。自定义 `render` 方法使用
    React 测试库 `render` 方法的 `wrapper` 选项，将组件放置在包含 Redux Provider 组件的 DOM 中，该组件提供对 Redux
    API 方法的访问。自定义 `render` 方法还将允许我们为每个测试传递独特的可控制测试数据。要开始，我们将为我们的方法创建一个文件并导入多个模块：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the previous code, we import the `configureStore` method from the Redux Toolkit
    library. The `configureStore` method is an abstraction over the standard Redux
    `createStore()` used to set up the Redux store. Next, we import the `render` method
    from React Testing Library and name it `rtlRender`. The `rtlRender` name is short
    for `React Testing Library Render`. Later in the file, we will create a custom
    `render` method to eliminate problems resulting from using identical method names.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们从 Redux Toolkit 库中导入 `configureStore` 方法。`configureStore` 方法是对标准 Redux
    `createStore()` 的抽象，用于设置 Redux 存储。接下来，我们导入 React Testing Library 的 `render` 方法，并将其命名为
    `rtlRender`。`rtlRender` 名称是 `React Testing Library Render` 的简称。稍后在该文件中，我们将创建一个自定义的
    `render` 方法，以消除使用相同方法名引起的问题。
- en: Next, we import the `faker` module. We will use `faker` to automatically generate
    data for the initial state to pass into our component. Then, we import the `Provider`
    method from `React-redux` to accept and give `store` to components. Finally, we
    import `retailReducer` that provides methods components can use to access and
    modify state.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们导入 `faker` 模块。我们将使用 `faker` 自动生成初始状态的数据，并将其传递到我们的组件中。然后，我们从 `React-redux`
    中导入 `Provider` 方法，以接受并将 `store` 传递给组件。最后，我们导入 `retailReducer`，它提供了组件可以用来访问和修改状态的方法。
- en: 'Next, we will create an object to serve as the `initialState` values for the
    Redux store:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个对象，作为 Redux 存储的 `initialState` 值：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the previous code, the variable `fakeStore` holds all initial state values
    for `products`, `cartItems`, `favorites`, and `showProductDetails`. The products
    data is an array of objects with values created by `faker`. Next, we will create
    a custom `render` method to use in place of React Testing Library''s `render`
    method:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，变量 `fakeStore` 包含了 `products`、`cartItems`、`favorites` 和 `showProductDetails`
    的所有初始状态值。产品数据是由 `faker` 创建的值的对象数组。接下来，我们将创建一个自定义的 `render` 方法，以替代 React Testing
    Library 的 `render` 方法：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the previous code snippet, the method accepts two arguments as parameters.
    First, the `ui` parameter accepts the component under test as a child to be wrapped
    within the custom method. The following parameter is an object with many properties.
    First, `initialState` accepts custom test data we can pass into our components
    within the test file. Next, `store` uses the `configureStore` method to set up
    the Redux store with `reducer` and `preloadedState`. The `reducer` property is
    an object that accepts `reducers` we create to manage the application state. The
    `preloadedState` property accepts `initialState` passed into the component in
    the test file. Finally, any other passed-in parameters are handled by `renderOptions`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，该方法接受两个参数作为参数。首先，`ui` 参数接受要测试的组件作为子组件，并将其包裹在自定义方法中。下一个参数是一个具有许多属性的对象。首先，`initialState`
    接受我们可以传递到测试文件中的组件内的自定义测试数据。接下来，`store` 使用 `configureStore` 方法设置 Redux 存储，包括 `reducer`
    和 `preloadedState`。`reducer` 属性是一个对象，它接受我们创建的 `reducers` 来管理应用程序状态。`preloadedState`
    属性接受传递到测试文件组件中的 `initialState`。最后，任何其他传入的参数都由 `renderOptions` 处理。
- en: 'Next, we will create the `Wrapper` method:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建 `Wrapper` 方法：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding code, `Wrapper` accepts `children`, which will be the component
    under test. Next, the method returns `Provider` with `store` and `children` passed
    in. Finally, `render` method returns a call to `rtlRender` with `ui` and an object
    including the `Wrapper` method and other `renderOptions` passed in.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`Wrapper` 接受 `children`，它将是被测试的组件。接下来，该方法返回带有 `store` 和 `children` 传入的
    `Provider`。最后，`render` 方法返回对 `rtlRender` 的调用，其中包含 `ui` 和一个包含 `Wrapper` 方法和其他 `renderOptions`
    传入的对象。
- en: 'The last step is to export the custom code to be imported and used in test
    files:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将自定义代码导出，以便在测试文件中导入和使用：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding code, first, we export everything from React Testing Library.
    Finally, we export an object that includes the custom `render` method that overrides
    React Testing Library `render` method and `fakeStore` as the custom test data
    to use in any test. Now you know how to create a custom `render` method to use
    for testing Redux consuming components.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先，我们导出 React Testing Library 的所有内容。最后，我们导出一个包含自定义 `render` 方法（该方法覆盖
    React Testing Library 的 `render` 方法）和 `fakeStore`（作为自定义测试数据，用于任何测试）的对象。现在你已了解如何创建一个用于测试
    Redux 消费组件的自定义 `render` 方法。
- en: Next, we will use the custom method in a test.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在测试中使用自定义方法。
- en: Using the test Redux Provider in tests
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在测试中使用测试 Redux Provider
- en: 'In this section, we will use the custom `render` method to test a component.
    In the *Testing a context consuming Retail component* section of this chapter,
    we tested a `Retail` component and its child components. The development team
    could have decided to build the component state using Redux. The `Retail` component
    included `Cart` that we can test with the custom `render` method:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用自定义的 `render` 方法来测试一个组件。在本章的“测试一个上下文消费的零售组件”部分，我们测试了一个 `Retail` 组件及其子组件。开发团队可能决定使用
    Redux 来构建组件状态。`Retail` 组件包括我们可以用自定义 `render` 方法测试的 `Cart`：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the previous code, first, we import the `Cart` component to test in the
    test file. Next, we import the `render`, `screen`, and `fakeStore` methods from
    our custom method file. The `render` method is the custom method created in the
    file. The `screen` method is the real `screen` method from React Testing Library.
    The `fakeStore` method is the custom test data we created in the custom method
    file. Next, we will write the main test code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先，我们在测试文件中导入要测试的 `Cart` 组件。接下来，我们从自定义方法文件中导入 `render`、`screen` 和 `fakeStore`
    方法。`render` 方法是在文件中创建的自定义方法。`screen` 方法是来自 React Testing Library 的真实 `screen`
    方法。`fakeStore` 方法是我们自定义方法文件中创建的自定义测试数据。接下来，我们将编写主要的测试代码：
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the previous code, first, we use the customer `render` method to render
    the `Cart` component in the DOM. As a second argument to the `render` method,
    we pass in an object and `fakeStore` as the value to `initialState`. `fakeStore`
    is the default test data we can use, but we can create and pass different data
    specific to the test. The custom `render` method makes our code cleaner because
    we don''t see the test code''s `Provider` method. Finally, we assert that the
    text `0 items` and `$0.00` is in the DOM. When we run the test, we get the following
    output:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先，我们使用自定义的 `render` 方法在 DOM 中渲染 `Cart` 组件。作为 `render` 方法的第二个参数，我们将一个对象和
    `fakeStore` 作为 `initialState` 的值传递。`fakeStore` 是我们可以使用的默认测试数据，但我们可以创建并传递特定于测试的不同数据。自定义
    `render` 方法使我们的代码更简洁，因为我们看不到测试代码的 `Provider` 方法。最后，我们断言文本 `0 件` 和 `$0.00` 在 DOM
    中。当我们运行测试时，我们得到以下输出：
- en: '![Figure 4.12 – Passing Cart Redux component test'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.12 – 通过 Redux 组件测试购物车 Redux 组件'
- en: '](img/Figure_4.12_B16887.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.12_B16887.jpg)'
- en: Figure 4.12 – Passing Cart Redux component test
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12 – 通过 Redux 组件测试购物车 Redux 组件
- en: The preceding screenshot shows the test `render` method as expected. Please
    see the [*Chapter 4*](B16887_04_Final_PG_ePub.xhtml#_idTextAnchor062) *code samples*
    ([https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter04/ch_04_redux](https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter04/ch_04_redux))
    for more examples testing Redux consuming components. Now you know how to create
    a custom `render` method to test components that consume Redux state. The custom
    method can be used to test practically any Redux-consuming React component.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图显示了预期的测试 `render` 方法。请参阅 [*第 4 章*](B16887_04_Final_PG_ePub.xhtml#_idTextAnchor062)
    的 *代码示例* ([https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter04/ch_04_redux](https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter04/ch_04_redux))
    以获取更多测试 Redux 消费组件的示例。现在您知道了如何创建一个自定义的 `render` 方法来测试消费 Redux 状态的组件。这个自定义方法可以用来测试几乎任何消费
    Redux 的 React 组件。
- en: In the next section, we will learn how to test components that consume API data
    via GraphQL.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何测试通过 GraphQL 消费 API 数据的组件。
- en: Testing components that use GraphQL
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试使用 GraphQL 的组件
- en: In this section, you will learn how to test components that use `Table` component
    we tested in the *Testing integrated components* section of this chapter, only
    now the component will be refactored to receive data via the GraphQL server using
    `Apollo Client` ([https://www.apollographql.com/docs/react/](https://www.apollographql.com/docs/react/)).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何测试使用我们在本章“测试集成组件”部分测试过的 `Table` 组件的组件，但现在该组件将被重构以通过 `Apollo Client`（[https://www.apollographql.com/docs/react/](https://www.apollographql.com/docs/react/))
    从 GraphQL 服务器接收数据。
- en: 'We can look at the implementation details of the `Table` component to understand
    how it interacts with GraphQL:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以查看 `Table` 组件的实现细节，以了解它如何与 GraphQL 交互：
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the preceding code, we create an `employees` GraphQL query to access the
    `employees` data to render in `table` row elements within the component. The query
    will automatically communicate with the GraphQL server when the component renders
    and return `employee` data for the component to use. We will later use this query
    inside our test file.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个`employees` GraphQL查询，用于访问组件中渲染在`table`行元素内的`employees`数据。当组件渲染时，查询将自动与GraphQL服务器通信，并返回组件可用的`employee`数据。我们将在稍后的测试文件中使用此查询。
- en: 'The `App` component plays an important role in communicating with the GraphQL
    server:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`App`组件在与GraphQL服务器通信中扮演着重要的角色：'
- en: '[PRE30]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding code, a `client` variable is created and set to a new instance
    of `ApolloClient`, imported from `ApolloClient` has a `uri` property that we can
    set to the URL of the running GraphQL server, which is `http://localhost:4000`
    in the code snippet. `ApolloClient` also sets the `cache` property to the `InMemoryCache`
    method.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，创建了一个名为`client`的变量，并将其设置为从`ApolloClient`导入的新实例。`ApolloClient`有一个`uri`属性，我们可以将其设置为运行中的GraphQL服务器的URL，在代码片段中是`http://localhost:4000`。`ApolloClient`还将`cache`属性设置为`InMemoryCache`方法。
- en: The `InMemoryCache` method is an excellent performance-enhancing feature because
    it will store data received from GraphQL locally and only make additional calls
    to the GraphQL server when the data needs updating. The `App` component also uses
    `ApolloProvider` from the Apollo library to render `Table` as a child component.
    The `Table` component can now make queries to the GraphQL server. `ApolloProvider`
    behaves similarly to the Redux `Provider` component we learned about in this chapter's
    *Testing components that use Redux* section. Now that we understand the connection
    between GraphQL and the consuming `Table` component, we can start writing tests.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`InMemoryCache`方法是一个出色的性能增强特性，因为它将存储从GraphQL接收到的数据本地存储，并且只有在数据需要更新时才会向GraphQL服务器发出额外的调用。`App`组件还使用来自Apollo库的`ApolloProvider`来渲染`Table`作为子组件。现在`Table`组件可以查询GraphQL服务器。`ApolloProvider`的行为与我们在本章的*测试使用Redux的组件*部分中学习的Redux
    `Provider`组件类似。现在我们理解了GraphQL与消费`Table`组件之间的联系，我们可以开始编写测试。'
- en: 'The first test we will write will verify that a loading message appears on
    the screen when `Table` initially renders:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要编写的第一个测试将验证当`Table`组件首次渲染时，屏幕上会显示一个加载消息：
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the preceding code, we import `MockedProvider`. `MockedProvider` is a particular
    method from Apollo that we can use for testing. Using `MockedProvider`, we do
    not need to create any custom `Provider` component as we did in the *Testing components
    that use Redux* section of this chapter.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们导入了`MockedProvider`。`MockedProvider`是Apollo的一个特定方法，我们可以用于测试。使用`MockedProvider`，我们不需要创建任何自定义的`Provider`组件，就像我们在本章的*测试使用Redux的组件*部分中所做的那样。
- en: Next, we import `act`, `render`, and `screen` from React Testing Library. The
    `act` method will let React know we are explicitly performing actions it does
    not expect. We will cover this in detail in the associated test. Then, we import
    `faker` to help generate test data. Finally, we import the `Table` component to
    test and the `EMPLOYEES` GraphQL query.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们从React Testing Library中导入`act`、`render`和`screen`。`act`方法将让React知道我们正在显式执行它不期望的操作。我们将在相关的测试中详细说明这一点。然后，我们导入`faker`以帮助生成测试数据。最后，我们导入要测试的`Table`组件和`EMPLOYEES`
    GraphQL查询。
- en: 'Next, we can create a mock GraphQL response:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以创建一个模拟的GraphQL响应：
- en: '[PRE32]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We create a `mocks` variable set to an array in the preceding code, with a
    `request` property set to our `EMPLOYEES` query. The `mocks` variable will replace
    the real GraphQL query with a version we can use for testing. Next, we can create
    the test data our test will respond with:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个`mocks`变量，并将其设置为包含一个数组的实例，其中`request`属性设置为我们的`EMPLOYEES`查询。`mocks`变量将用我们用于测试的版本替换实际的GraphQL查询。接下来，我们可以创建测试将响应的测试数据：
- en: '[PRE33]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the preceding code, we create a `data` property set to an array of `employees`
    for the `Table` component to consume and display on the screen. The `faker` module
    is used to eliminate the need to create hardcoded values. Now we can write the
    main test code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们为`Table`组件创建了一个`data`属性，将其设置为`employees`数组的实例，以便组件可以消费并在屏幕上显示。使用`faker`模块可以消除创建硬编码值的需要。现在我们可以编写主要的测试代码：
- en: '[PRE34]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the previous code, we render the `Table` component inside `MockedProvider`
    with passed-in `mocks` data. Then, we assert that the text **Loading…** is in
    the DOM. The loading text is the first thing to display when the component renders
    until the frontend React application receives data from the GraphQL server.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们在`MockedProvider`内部渲染了`Table`组件，并传递了`mocks`数据。然后，我们断言文本**加载中…**在DOM中。加载文本是组件渲染时首先显示的内容，直到前端React应用程序从GraphQL服务器接收数据。
- en: 'For the next test, we will verify the `completed` state is achieved, meaning
    the component has received and rendered employee data:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下一次测试，我们将验证是否达到了`完成`状态，这意味着组件已接收并渲染了员工数据：
- en: '[PRE35]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the previous code, we render the `Table` component inside `MockedProvider`
    with passed-in `mocks` data. Then, we set `Promise` to the `resolved` state wrapped
    in the `act` method. Although we are not accessing the real GraphQL server, the
    Apollo methods we use are asynchronous and take some time to complete. We explicitly
    complete the asynchronous process after `0` seconds to continue the test steps.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们在`MockedProvider`内部渲染了`Table`组件，并传递了`mocks`数据。然后，我们将`Promise`设置为`resolved`状态，并用`act`方法包裹。尽管我们没有访问真实的GraphQL服务器，但我们使用的Apollo方法都是异步的，需要一些时间来完成。我们在`0`秒后显式完成异步过程，以继续测试步骤。
- en: 'The `0` second value may seem odd to force the `resolved` state but is necessary
    because asynchronous JavaScript actions will wait for some time before completion
    and continuing with the following action. If we do not use the `act` method, our
    test will pass but also render an error message to the screen:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`0`秒的值可能看起来很奇怪，但强制`resolved`状态是必要的，因为异步JavaScript操作会在完成之前等待一段时间，然后继续执行下一个操作。如果我们不使用`act`方法，我们的测试将通过，但也会在屏幕上渲染一个错误消息：'
- en: '![Figure 4.13 – Not wrapped in act error'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.13 – 未包裹在act中的错误'
- en: '](img/Figure_4.13_B16887.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.13_B16887.jpg)'
- en: Figure 4.13 – Not wrapped in act error
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.13 – 未包裹在act中的错误
- en: The preceding screenshot shows the error message displayed in the console when
    we do not use the `act` method to handle explicit component updates that React
    does not know about. Finally, we assert that two `row` elements are found in the
    DOM.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图显示了当我们不使用`act`方法处理React不知道的显式组件更新时，在控制台显示的错误消息。最后，我们断言在DOM中找到了两个`row`元素。
- en: 'For the last test, we will verify that the error state results in the error
    message being displayed on the screen:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最后一个测试，我们将验证错误状态会导致错误消息在屏幕上显示：
- en: '[PRE36]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the previous code, we render the `Table` component inside `MockedProvider`
    with passed-in `mocks` data. However, unlike previous tests, we set the `error`
    property to a new instance of the `Error` object. When the `error` property is
    set, it means that something happened, preventing the process of sending and receiving
    data from the GraphQL server to the frontend.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们在`MockedProvider`内部渲染了`Table`组件，并传递了`mocks`数据。然而，与之前的测试不同，我们将`error`属性设置为`Error`对象的新实例。当设置`error`属性时，意味着发生了某些事情，阻止了从GraphQL服务器到前端的数据发送和接收过程。
- en: 'Next, we set `Promise` to the `resolved` state wrapped in the `act` method
    as we did in the previous test. Finally, we assert that the text `Error` is in
    the document. When we run the tests, we get the following output:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将`Promise`设置为`resolved`状态，并用`act`方法包裹，就像之前的测试一样。最后，我们断言文本`Error`在文档中。当我们运行测试时，我们得到以下输出：
- en: '![Figure 4.14 – Table component test results'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.14 – 表组件测试结果'
- en: '](img/Figure_4.14_B16887.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.14_B16887.jpg)'
- en: Figure 4.14 – Table component test results
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.14 – 表组件测试结果
- en: Now you know how to test components that consume GraphQL server data using Apollo
    Client. As GraphQL continues to gain popularity, it will be helpful to have the
    testing strategies we covered in your toolbox to verify expected behavior quickly.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经知道了如何使用Apollo Client测试消耗GraphQL服务器数据的组件。随着GraphQL继续获得人气，将我们讨论的测试策略放入你的工具箱中，以快速验证预期行为将是有帮助的。
- en: In the next section, we will learn how to test components that use the popular
    Material-UI component library for frontend development.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何测试使用流行的Material-UI组件库进行前端开发的组件。
- en: Testing Components that use Material-UI
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试使用Material-UI的组件
- en: In this section, we will learn how to test components that use the Material-UI
    component library. You can select DOM elements rendered by Material-UI components
    out of the box with React Testing Library in most cases. However, sometimes it
    is helpful to add component properties that render as attributes on resulting
    DOM elements. We will learn how to add properties to test the `Vote` and `Customer
    Table` components.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何测试使用 Material-UI 组件库的组件。在大多数情况下，您可以使用 React Testing Library 直接选择
    Material-UI 组件渲染的 DOM 元素。然而，有时添加作为结果 DOM 元素属性渲染的组件属性是有帮助的。我们将学习如何添加属性以测试 `Vote`
    和 `Customer Table` 组件。
- en: Adding an ARIA label to test a Vote component
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 ARIA 标签以测试投票组件
- en: In the *Testing a context consuming Vote component* section of this chapter,
    we tested a `Vote` component.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的 *测试一个使用上下文的投票组件* 部分，我们测试了一个 `Vote` 组件。
- en: 'We could use components from Material-UI to rebuild the component:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Material-UI 的组件来重建该组件：
- en: '[PRE37]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the previous code, we used the `Box`, `Button`, and `ThumbUpIcon` components
    from Material-UI to quickly build the **thumbs up** button complete with **Cascading
    Style Sheet** (**CSS**) styles already included to make the button look nice.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了 Material-UI 的 `Box`、`Button` 和 `ThumbUpIcon` 组件来快速构建一个带有 **CSS**（**层叠样式表**）样式的
    **点赞** 按钮，使其看起来很漂亮。
- en: 'Next, we will build the remaining parts of the component:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将构建组件的其余部分：
- en: '[PRE38]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the preceding code, we use the `Typography`, `Button`, and `ThumbDownAltIcon`
    components from Material-UI to build the thumbs down button and display the total
    likes number on the screen. When we render the component in the browser, we get
    the following output:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了 Material-UI 的 `Typography`、`Button` 和 `ThumbDownAltIcon` 组件来构建点赞按钮，并在屏幕上显示总点赞数。当我们将在浏览器中渲染组件时，我们得到以下输出：
- en: '![Figure 4.15 – Material-UI Vote component'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.15 – Material-UI 投票组件'
- en: '](img/Figure_4.15_B16887.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.15 – Material-UI 投票组件](img/Figure_4.15_B16887.jpg)'
- en: Figure 4.15 – Material-UI Vote component
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.15 – Material-UI 投票组件
- en: The preceding screenshot shows a `Vote` component we tested in previous sections
    of this chapter, a user can vote up or down to change the total likes. However,
    grabbing and clicking the buttons with React Testing Library would be difficult
    with the current component implementation. There are no accessible ways to access
    the buttons, such as a label.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图显示了我们在本章前面的部分测试的 `Vote` 组件，用户可以通过点赞或点踩来改变总点赞数。然而，使用 React Testing Library
    抓取按钮会有困难，因为当前的组件实现没有可访问的方式，例如标签。
- en: 'To solve this problem, we can add `aria-label` properties to the `Button` components.
    `aria-label` will add a visible label to elements allowing users with screen readers
    to understand the elements'' purpose. We can add `aria-label` to the component
    like so:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以在 `Button` 组件中添加 `aria-label` 属性。`aria-label` 将为元素添加一个可见的标签，使用屏幕阅读器的用户可以理解元素的目的。我们可以这样给组件添加
    `aria-label`：
- en: '[PRE39]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We added `aria-label` to the first `Button` component in the previous code
    snippet. Next, we will add `aria-label` to the other `Button` component:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的代码片段中为第一个 `Button` 组件添加了 `aria-label`。接下来，我们将为另一个 `Button` 组件添加 `aria-label`：
- en: '[PRE40]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the previous code, we added `aria-label` to the second `Button` component.
    Material UI will forward the `Button aria-label` properties to the resulting button
    element that will render in the DOM. Since `aria-label` attributes are accessible
    by all users, including those using assistive devices to navigate the screen,
    React Testing Library can grab elements by those attributes. Now that we can select
    the elements, we can write tests and assert the resulting behavior.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们为第二个 `Button` 组件添加了 `aria-label`。Material UI 将将 `Button aria-label`
    属性转发到将在 DOM 中渲染的按钮元素。由于 `aria-label` 属性对所有用户都是可访问的，包括使用辅助设备导航屏幕的用户，React Testing
    Library 可以通过这些属性抓取元素。现在我们可以选择元素，我们可以编写测试并断言结果行为。
- en: 'For the first test, we will verify that a user can only decrease the total
    like count by one:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个测试，我们将验证用户只能将总点赞数减少一个：
- en: '[PRE41]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the previous code, we render the `Vote` component with the value of `10`
    for `totalGlobalLikes`. Next, we grab the `aria-label` attribute we added and
    assign it to the `thumbsUpBtn` variable. Next, we click the `11` is in the DOM.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用 `totalGlobalLikes` 的值为 `10` 渲染 `Vote` 组件。接下来，我们抓取我们添加的 `aria-label`
    属性并将其分配给 `thumbsUpBtn` 变量。然后，我们点击 DOM 中的 `11`。
- en: 'For the next test, we will verify that a user can remove their **"up"** vote:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下一个测试，我们将验证用户可以移除他们的 **"up"** 投票：
- en: '[PRE42]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the previous code, we render the `Vote` component with the value of `10`
    for `totalGlobalLikes`. Next, we grab the `aria-label` properties we added to
    both `Buttons` and assign them to variables.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们使用 `totalGlobalLikes` 的值为 `10` 渲染了 `Vote` 组件。接下来，我们抓取添加到两个 `Buttons`
    上的 `aria-label` 属性并将它们分配给变量。
- en: 'Next, we click the `10` is on the screen. When we run the test, we get the
    following results:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们点击屏幕上的 `10`。当我们运行测试时，我们得到以下结果：
- en: '![Figure 4.16 – Material-UI Vote test results'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.16 – Material-UI 投票测试结果'
- en: '](img/Figure_4.16_B16887.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.16_B16887.jpg)'
- en: Figure 4.16 – Material-UI Vote test results
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.16 – Material-UI 投票测试结果
- en: The previous screenshot shows that the tests **given multiple "down" votes,
    total likes only decrease by one**, and **given retracted "up" vote, returns original
    total likes** pass as expected.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图显示，测试 **给定多个 "down" 投票，总喜欢数只减少一个**，以及 **给定撤回的 "up" 投票，返回原始总喜欢数** 如预期通过。
- en: 'As a challenge, try writing tests for the following scenarios: **given "up"
    vote, total likes increases by one**; **given multiple "up" votes, total likes
    only increase by one**; and **given retracted "down" vote, returns original total
    likes**. The solutions for these test scenarios can be found in the *chapter 4
    code samples*. Now you know how to make Material-UI components testable by adding
    aria-labels.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 作为挑战，尝试为以下场景编写测试：**给定 "up" 投票，总喜欢数增加一个**；**给定多个 "up" 投票，总喜欢数只增加一个**；以及**给定撤回的
    "down" 投票，返回原始总喜欢数**。这些测试场景的解决方案可以在 *第 4 章代码示例* 中找到。现在你知道了如何通过添加 aria-labels 来使
    Material-UI 组件可测试。
- en: In the next section, we will learn how to add an attribute specific to React
    Testing Library to make components testable.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何添加一个特定于 React Testing Library 的属性，以便使组件可测试。
- en: Adding a test ID to test a CustomerTable component
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为 CustomerTable 组件添加测试 ID 进行测试
- en: 'In the previous section, we learned how to make Material-UI components testable
    by adding `aria-labels`. In this section, we will learn how to add `data-testid`
    to make components testable. `data-testid` is another option to query DOM elements
    with React Testing Library. The `data-testid` query is a last-resort way to grab
    DOM elements when other preferred methods such as `*byText` or `*byRole` cannot
    be used, and we want to avoid using `class` or `ID` selectors. We can use `data-testid`
    by attaching it as an attribute to a DOM element:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何通过添加 `aria-labels` 来使 Material-UI 组件可测试。在本节中，我们将学习如何添加 `data-testid`
    来使组件可测试。`data-testid` 是 React Testing Library 查询 DOM 元素时的另一种选项。`data-testid` 查询是在无法使用其他首选方法（如
    `*byText` 或 `*byRole`）且我们希望避免使用 `class` 或 `ID` 选择器时的一种最后手段。我们可以通过将 `data-testid`
    作为属性附加到 DOM 元素上来使用它：
- en: '[PRE43]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We add a `"product-type"` `data-testid` to select the heading element uniquely
    in the previous code snippet. We will test a `CustomerTable` component in this
    section that accepts customer data and renders the following to the screen:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的代码片段中添加了一个 `"product-type"` `data-testid`，以唯一选择标题元素。在本节中，我们将测试一个接受客户数据并渲染以下内容的
    `CustomerTable` 组件：
- en: '![Figure 4.17 – Material-UI table component'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.17 – Material-UI 表格组件'
- en: '](img/Figure_4.17_B16887.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.17_B16887.jpg)'
- en: Figure 4.17 – Material-UI table component
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.17 – Material-UI 表格组件
- en: 'The previous screenshot shows a table with multiple rows of customer data.
    A user can use the `da`, the following results will be displayed:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图显示了一个包含多行客户数据的表格。用户可以使用 `da`，以下结果将被显示：
- en: '![Figure 4.18 – Material-UI table filtered results'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.18 – Material-UI 表格过滤结果'
- en: '](img/Figure_4.18_B16887.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.18_B16887.jpg)'
- en: Figure 4.18 – Material-UI table filtered results
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.18 – Material-UI 表格过滤结果
- en: The preceding screenshot shows two resulting rows. The two rows are displayed
    as matching results because the text **da** is visible in the rows' associated
    columns. We will write three tests for the component.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图显示了两个结果行。这两行被显示为匹配结果，因为文本 **da** 在行相关列中可见。我们将为该组件编写三个测试。
- en: 'For the first test, we will verify that the component can receive and render
    passed-in customer data:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个测试，我们将验证组件是否可以接收并渲染传入的客户数据：
- en: '[PRE44]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the preceding code, we create an array of test objects to pass into the component.
    It should be noted that the code snippet only shows one customer object. The code
    sample for the `CustomerTable` test file will have three.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个测试对象数组，将其传递到组件中。需要注意的是，代码片段只显示了单个客户对象。`CustomerTable` 测试文件的代码示例将包含三个。
- en: 'Next, we can write the main test code:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以编写主要的测试代码：
- en: '[PRE45]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In the previous code, first, we render `CustomerTable` with `fakeCustomers`
    passed into the `data` property. Finally, we assert that the number of rows is
    equal to `3`. We use the `getAllByTestId` query to access all the rows. The `*allBy`
    queries allow us to grab multiple, similar DOM elements. In the code implementation
    for `CustomerTable`, `data-testid` is added as a property to each `TableRow` component
    created for each customer data object:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，首先，我们通过将`fakeCustomers`传递给`data`属性来渲染`CustomerTable`。最后，我们断言行数等于`3`。我们使用`getAllByTestId`查询来访问所有行。`*allBy`查询允许我们获取多个相似DOM元素。在`CustomerTable`的代码实现中，`data-testid`被添加为每个为每个客户数据对象创建的`TableRow`组件的属性：
- en: '[PRE46]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In the previous code, a `data-testid` property is added to the `TableRow` component.
    The `data-testid` is used because the preferred query methods cannot be used to
    select all the rows in this scenario. For the second test, we verify that queries
    returning one match return one result:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，向`TableRow`组件添加了`data-testid`属性。使用`data-testid`是因为在此场景中不能使用首选的查询方法来选择所有行。对于第二个测试，我们验证返回单个匹配的查询返回一个结果：
- en: '[PRE47]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In the previous code, first, we render `CustomerTable` with `testData` passed
    into the `data` property. Then, we grab the textbox and store it in the `searchBox`
    variable. Finally, we assert that the number of rows in the DOM is 1.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，首先，我们通过将`testData`传递给`data`属性来渲染`CustomerTable`。然后，我们获取文本框并将其存储在`searchBox`变量中。最后，我们断言DOM中的行数为1。
- en: 'For the final test, we will verify that non-matching queries return no `row`
    elements to the screen:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最终测试，我们将验证非匹配查询不会向屏幕返回任何`row`元素：
- en: '[PRE48]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The preceding code is similar to the previous test with two differences. First,
    we type `zzz` into `searchBox`. Then, we assert that `0 row` elements are found
    in the DOM. When we run the tests, we get the following output:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码与之前的测试类似，有两个不同之处。首先，我们在`searchBox`中输入`zzz`。然后，我们断言在DOM中找到`0 row`元素。当我们运行测试时，我们得到以下输出：
- en: '![Figure 4.19 – Material-UI table test results ](img/Figure_4.19_B16887.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![图4.19 – Material-UI表格测试结果](img/Figure_4.19_B16887.jpg)'
- en: Figure 4.19 – Material-UI table test results
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.19 – Material-UI表格测试结果
- en: The previous screenshot shows that the tests **given data, renders table rows**,
    **given single-matching query, single result returned**, and **given non-matching
    query, no results returned** all pass as expected. As a challenge, try writing
    a test for the scenario **given multi-matching query, multiple results returned**.
    The previous test scenario solution can be found in the [*Chapter 4*](B16887_04_Final_PG_ePub.xhtml#_idTextAnchor062)
    *code samples* ([https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter04/ch_04_mui](https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter04/ch_04_mui)).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的截图显示，测试**给定数据，渲染表格行**、**给定单个匹配查询，返回单个结果**和**给定非匹配查询，没有返回结果**都按预期通过。作为挑战，尝试编写一个针对场景**给定多匹配查询，返回多个结果**的测试。之前的测试场景解决方案可以在[*第4章*](B16887_04_Final_PG_ePub.xhtml#_idTextAnchor062)的*代码示例*中找到([https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter04/ch_04_mui](https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter04/ch_04_mui))。
- en: This section's content has provided you with the skills to test specific Material-UI
    components by adding `aria-label` and `data-testid` attributes to grab them with
    React Testing Library when needed.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 本节内容已为您提供技能，通过添加`aria-label`和`data-testid`属性，在需要时使用React Testing Library获取特定Material-UI组件。
- en: Summary
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have learned how to test components using the integration
    test approach compared to the unit test approach with mocked dependencies. You
    know how to test components that use the Context API to manage application state.
    You also learned how to create a custom method to test components in projects
    using the third-party Redux library. Finally, you learned how to add attributes
    to test components built using the popular Material-UI library.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经学习了如何使用集成测试方法测试组件，而不是使用带有模拟依赖项的单元测试方法。您知道如何测试使用Context API管理应用程序状态的组件。您还学习了如何在使用第三方Redux库的项目中创建自定义方法来测试组件。最后，您学习了如何向使用流行的Material-UI库构建的组件添加属性。
- en: In the next chapter, we will learn how to refactor tests for legacy projects.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何重构遗留项目的测试。
- en: Questions
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Explain the benefits of testing integrated components versus in isolation.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释测试集成组件与独立测试的优点。
- en: When should you use the `data-testid` attribute to grab components?
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该在何时使用 `data-testid` 属性来获取组件？
- en: When should you use the `act` method from React Testing Library?
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该在何时使用 React Testing Library 中的 `act` 方法？
