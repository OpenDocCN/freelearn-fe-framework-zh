<html><head></head><body>
<div id="sbo-rt-content"><div class="Basic-Text-Frame" id="_idContainer026">
<h1 class="chapterNumber">4</h1>
<h1 class="chapterTitle" id="_idParaDest-78">Exploring Popular Composition Patterns </h1>
<p class="normal">In this chapter, we will learn how to make components communicate with each other effectively, which is a crucial part of building complex React applications using small, testable, and maintainable components. By mastering the popular composition patterns and tools in React, you will be able to take control of every single part of your application and build scalable and extensible software.</p>
<p class="normal">Let’s dive in and explore how we can leverage these patterns and tools to build better React applications. We will cover the following topics:</p>
<ul>
<li class="bulletList">How components communicate with each other using props and children</li>
<li class="bulletList">The container and presentational patterns and how they can make our code more maintainable</li>
<li class="bulletList">What <strong class="keyWord">higher-order components</strong> (<strong class="keyWord">HOCs</strong>) are and how, thanks to them, we can structure our applications in a better way</li>
<li class="bulletList">What the function of the child component pattern is and what its benefits are</li>
</ul>
<h1 class="heading-1" id="_idParaDest-79">Technical requirements</h1>
<p class="normal">To complete this chapter, you will need the following:</p>
<ul>
<li class="bulletList">Node.js 19+</li>
<li class="bulletList">Visual Studio Code</li>
</ul>
<p class="normal">You can find the code for this chapter in the book’s GitHub repository at <a href="https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter04"><span class="url">https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter04</span></a>. </p>
<h1 class="heading-1" id="_idParaDest-80">Communicating components</h1>
<p class="normal">Composing React components is one of the key benefits of building applications with React. By creating small, <strong class="keyWord">reusable components</strong> with clean interfaces, you can easily compose them together to <a id="_idIndexMarker143"/>create complex applications that are both powerful and maintainable.</p>
<p class="normal">Small components with a <a id="_idIndexMarker144"/>clean interface can be composed together to create complex applications that are powerful and maintainable at the same time.</p>
<p class="normal">Composing React components is straightforward; you just have to include them in the render:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">Profile</span> = (<span class="hljs-params">{ user }</span>) =&gt; ( 
  <span class="hljs-tag">&lt;&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">Picture</span><span class="hljs-tag"> </span><span class="hljs-attr">profileImageUrl</span><span class="hljs-tag">=</span><span class="hljs-string">{user.profileImageUrl}</span><span class="hljs-tag"> /&gt;</span> 
    <span class="hljs-tag">&lt;</span><span class="hljs-name">UserName</span><span class="hljs-tag"> </span><span class="hljs-attr">name</span><span class="hljs-tag">=</span><span class="hljs-string">{user.name}</span><span class="hljs-tag"> </span><span class="hljs-attr">screenName</span><span class="hljs-tag">=</span><span class="hljs-string">{user.screenName}</span><span class="hljs-tag"> /&gt;</span> 
  <span class="hljs-tag">&lt;/&gt;</span> 
)
</code></pre>
<p class="normal">For example, you can create a <code class="inlineCode">Profile</code> component by simply composing a <code class="inlineCode">Picture</code> component to display the profile image and a <code class="inlineCode">UserName</code> component to display the name and the screen name of the user.</p>
<p class="normal">In this way, you can produce new parts of the user interface very quickly, writing only a few lines of code. Whenever you compose components, as in the preceding example, you share data between them using props. Props are the way a parent component can pass its data down the tree to every component that needs it (or part of it).</p>
<p class="normal">When a component passes some props to another component, it is called the <code class="inlineCode">owner</code>, irrespective of the parent-child relationship between them. For example, in the preceding snippet, <code class="inlineCode">Profile</code> is not the direct parent of <code class="inlineCode">Picture</code> (the <code class="inlineCode">div</code> tag is), but <code class="inlineCode">Profile</code> owns <code class="inlineCode">Picture</code> because it passes down the props to it.</p>
<p class="normal">In the next section, you will learn about the <code class="inlineCode">children</code> prop and how to use it correctly.</p>
<h2 class="heading-2" id="_idParaDest-81">Using the children prop</h2>
<p class="normal">There is a special <a id="_idIndexMarker145"/>prop that can be passed from the owners to the components defined inside their render—<code class="inlineCode">children</code>.</p>
<p class="normal">In the React documentation, it is described as <code class="inlineCode">opaque</code> because it is a property that does not tell you anything about the value it contains. Subcomponents defined inside the render of a parent component usually receive props that are passed as attributes of the component itself in JSX, or as a second parameter of the <code class="inlineCode">_jsx</code> function. Components can also be defined with nested components inside them, and they can access those children using the <code class="inlineCode">children</code> prop.</p>
<p class="normal">Consider that we have a <code class="inlineCode">Button</code> component that has a text property representing the text of the button:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">Button</span> = (<span class="hljs-params">{ text }</span>) =&gt; <span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag"> </span><span class="hljs-attr">className</span><span class="hljs-tag">=</span><span class="hljs-string">"btn"</span><span class="hljs-tag">&gt;</span>{text}<span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span> 
</code></pre>
<p class="normal">The component can be used in the following way:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;<span class="hljs-title">Button</span> text=<span class="hljs-string">"Click me!"</span> /&gt;
</code></pre>
<p class="normal">And this will render the following code:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag"> </span><span class="hljs-attr">class</span><span class="hljs-tag">=</span><span class="hljs-string">"btn"</span><span class="hljs-tag">&gt;</span>Click me!<span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>
</code></pre>
<p class="normal">Now, suppose we want to use the same button with the same class name in multiple parts of our application, and we also want to be able to display more than a simple string. Our UI consists of buttons with text, buttons with text and icons, and buttons with text and labels.</p>
<p class="normal">In most cases, a good solution would be to add multiple parameters to <code class="inlineCode">Button</code> or to create different versions of <code class="inlineCode">Button</code>, each one with its single specialization, for example, <code class="inlineCode">IconButton</code>.</p>
<p class="normal">However, we should realize that <code class="inlineCode">Button</code> could just be a wrapper, and we are able to render any element inside it and use the <code class="inlineCode">children</code> property:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">Button</span> = (<span class="hljs-params">{ children }</span>) =&gt; <span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag"> </span><span class="hljs-attr">className</span><span class="hljs-tag">=</span><span class="hljs-string">"btn"</span><span class="hljs-tag">&gt;</span>{children}<span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span> 
</code></pre>
<p class="normal">By passing the <code class="inlineCode">children</code> prop, we are not limited to a simple single text property, but we can pass any element to <code class="inlineCode">Button</code>, and it is rendered in place of the <code class="inlineCode">children</code> property.</p>
<p class="normal">In this case, any element that we wrap inside the <code class="inlineCode">Button</code> component will be rendered as a child of the button element with <code class="inlineCode">btn</code> as the class name.</p>
<p class="normal">For example, if we want to<a id="_idIndexMarker146"/> render an image inside the button and some text wrapped in a <code class="inlineCode">span</code> tag, we can do this:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag">&lt;</span><span class="hljs-name">Button</span><span class="hljs-tag">&gt;</span> 
    <span class="hljs-tag">&lt;</span><span class="hljs-name">img</span><span class="hljs-tag"> </span><span class="hljs-attr">src</span><span class="hljs-tag">=</span><span class="hljs-string">"..."</span><span class="hljs-tag"> </span><span class="hljs-attr">alt</span><span class="hljs-tag">=</span><span class="hljs-string">"..."</span><span class="hljs-tag"> /&gt;</span> 
    <span class="hljs-tag">&lt;</span><span class="hljs-name">span</span><span class="hljs-tag">&gt;</span>Click me!<span class="hljs-tag">&lt;/</span><span class="hljs-name">span</span><span class="hljs-tag">&gt;</span> 
<span class="hljs-tag">&lt;/</span><span class="hljs-name">Button</span><span class="hljs-tag">&gt;</span>
</code></pre>
<p class="normal">The preceding snippet gets rendered in the browser as follows:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag"> </span><span class="hljs-attr">class</span><span class="hljs-tag">=</span><span class="hljs-string">"btn"</span><span class="hljs-tag">&gt;</span> 
    <span class="hljs-tag">&lt;</span><span class="hljs-name">img</span><span class="hljs-tag"> </span><span class="hljs-attr">src</span><span class="hljs-tag">=</span><span class="hljs-string">"..."</span><span class="hljs-tag"> </span><span class="hljs-attr">alt</span><span class="hljs-tag">=</span><span class="hljs-string">"..."</span><span class="hljs-tag"> /&gt;</span> 
    <span class="hljs-tag">&lt;</span><span class="hljs-name">span</span><span class="hljs-tag">&gt;</span>Click me!<span class="hljs-tag">&lt;/</span><span class="hljs-name">span</span><span class="hljs-tag">&gt;</span> 
<span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>  
</code></pre>
<p class="normal">This is a pretty convenient way to allow components to accept any children elements and wrap those elements inside a predefined parent.</p>
<p class="normal">Now, we can pass images, labels, and even other React components inside the <code class="inlineCode">Button</code> component, and they will be rendered as its children. As you can see in the preceding example, we defined the <code class="inlineCode">children</code> property as an array, which means that we can pass any number of elements as the component’s children.</p>
<p class="normal">We can pass a single child, as shown in the following code:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag">&lt;</span><span class="hljs-name">Button</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">span</span><span class="hljs-tag">&gt;</span>Click me!<span class="hljs-tag">&lt;/</span><span class="hljs-name">span</span><span class="hljs-tag">&gt;</span> 
<span class="hljs-tag">&lt;/</span><span class="hljs-name">Button</span><span class="hljs-tag">&gt;</span>
</code></pre>
<p class="normal">Let’s now explore the container and the presentational pattern in the next section.</p>
<h1 class="heading-1" id="_idParaDest-82">Exploring the container and presentational patterns</h1>
<p class="normal">In the last chapter, we<a id="_idIndexMarker147"/> saw how to take a coupled component and make it reusable step by step. Now <a id="_idIndexMarker148"/>we will see how to apply a similar pattern to our components to make them clearer and more maintainable.</p>
<p class="normal">React components typically contain a mix of <em class="italic">logic</em> and <em class="italic">presentation</em>. By logic, we refer to anything that is unrelated to the UI, such as API calls, data manipulation, and event handlers. The presentation is the part of the render where we create the elements to be displayed on the UI.</p>
<p class="normal">In React, there are simple and powerful patterns, known as <code class="inlineCode">container</code> and <code class="inlineCode">presentational</code>, which we can apply when creating components that help us to separate those two concerns.</p>
<p class="normal">Creating well-defined boundaries between logic and presentation not only makes components more reusable, but also provides many other benefits, which you will learn about in this section. Again, one of the best ways to learn new concepts is by seeing practical examples, so let’s delve into some code.</p>
<p class="normal">Suppose we have a component that uses<a id="_idIndexMarker149"/> geolocation APIs to get the position of the user and displays the latitude and longitude on the page in the browser.</p>
<p class="normal">First, we create a <code class="inlineCode">Geolocation.tsx</code> file in our <code class="inlineCode">components</code> folder and define the <code class="inlineCode">Geolocation</code> component<a id="_idIndexMarker150"/> using a functional component:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { useState, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">const</span> <span class="hljs-title">Geolocation</span> = () =&gt; {}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title">Geolocation</span>
</code></pre>
<p class="normal">We then define our states:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> [latitude, setLatitude] = useState&lt;number | <span class="hljs-literal">null</span>&gt;(<span class="hljs-literal">null</span>)
<span class="hljs-keyword">const</span> [longitude, setLongitude] = useState&lt;number | <span class="hljs-literal">null</span>&gt;(<span class="hljs-literal">null</span>)
</code></pre>
<p class="normal">Now, we can use the <code class="inlineCode">useEffect</code> Hook to fire the request to the APIs:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-title">useEffect</span>(<span class="hljs-function">() =&gt;</span> { 
    <span class="hljs-keyword">if</span> (navigator.<span class="hljs-property">geolocation</span>) {
      navigator.<span class="hljs-property">geolocation</span>.<span class="hljs-title">getCurrentPosition</span>(handleSuccess)
        } 
}, [navigator])
</code></pre>
<p class="normal">When the browser returns the data, we store the result in the state using the following function (place this function before the <code class="inlineCode">useEffect</code> Hook):</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">handleSuccess</span> = (<span class="hljs-params">{ </span>
<span class="hljs-params">    coords: { latitude, longitude } </span>
<span class="hljs-params">  }: { coords: { latitude: number; longitude: number }}</span>) =&gt; { 
    <span class="hljs-title">setLatitude</span>(latitude)
    <span class="hljs-title">setLongitude</span>(longitude)
}
</code></pre>
<p class="normal">Finally, we show the latitude and longitude values:</p>
<pre class="programlisting code"><code class="hljs-code">return ( 
    <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>Geolocation:<span class="hljs-tag">&lt;/</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>Latitude: {latitude}<span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span> 
      <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>Longitude: {longitude}<span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span> 
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span> 
)
</code></pre>
<p class="normal">It is important to note that, during the first render, the latitude and longitude are null because we asked the<a id="_idIndexMarker151"/> browser for the coordinates when the component was mounted. In a real-world component, you might want to <a id="_idIndexMarker152"/>display a spinner until the data gets returned. To do that, you can use one of the conditional techniques we saw in <em class="chapterRef">Chapter 3</em>, <em class="italic">Cleaning Up Your Code</em>.</p>
<p class="normal">Now, this component does not have any problems, and it works as expected. Wouldn’t it be nice to separate it from the part where the position gets requested and loaded to iterate faster on it?</p>
<p class="normal">We will use the container and presentational patterns to isolate the presentational part. In this pattern, every component is split into two smaller ones, each one with its clear responsibilities. The container knows everything about the logic of the component and is where the APIs are called. It also deals with data manipulation and event handling.</p>
<p class="normal">The presentational component is where the UI is defined, and it receives data in the form of props from the container. Since the presentational component is usually logic-free, we can create it as a functional, stateless component.</p>
<p class="normal">There are no rules that say that the presentational component must not have a state (for example, it could keep a UI state inside it). In this case, we need a component to display the latitude and longitude, so we are going to use a simple function.</p>
<p class="normal">First of all, we should rename our <code class="inlineCode">Geolocation</code> component <code class="inlineCode">GeolocationContainer</code>:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">GeolocationContainer</span> = () =&gt; {...}
</code></pre>
<p class="normal">We will also change the filename from <code class="inlineCode">Geolocation.tsx</code> to <code class="inlineCode">GeolocationContainer.tsx</code>.</p>
<p class="normal">This rule is not strict, but it is a best practice that’s widely used in the React community to append <code class="inlineCode">Container</code> to the end of the <code class="inlineCode">Container</code> component name and give the original name to the <a id="_idIndexMarker153"/>presentational one.</p>
<p class="normal">We also have to <a id="_idIndexMarker154"/>change the implementation of <code class="inlineCode">render</code> and remove all the UI parts of it, as follows:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span> <span class="hljs-tag">&lt;</span><span class="hljs-name">Geolocation</span><span class="hljs-tag"> </span><span class="hljs-attr">latitude</span><span class="hljs-tag">=</span><span class="hljs-string">{latitude}</span><span class="hljs-tag"> </span><span class="hljs-attr">longitude</span><span class="hljs-tag">=</span><span class="hljs-string">{longitude}</span><span class="hljs-tag"> /&gt;</span>
</code></pre>
<p class="normal">As you can see in the preceding snippet, instead of creating the HTML elements inside the return of the container, we just use the presentational one (which we will create next), and we pass the state to it. The states are the latitude and longitude, which are null by default, and they contain the real position of the user when the browser fires the callback.</p>
<p class="normal">Let’s create a new file, called <code class="inlineCode">Geolocation.tsx</code>, where we define the functional component as follows:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { <span class="hljs-variable">FC</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
type <span class="hljs-title">Props</span> = {
  <span class="hljs-attr">latitude</span>: number
  <span class="hljs-attr">longitude</span>: number
}
<span class="hljs-keyword">const</span> <span class="hljs-title">Geolocation</span>: <span class="hljs-variable">FC</span>&lt;<span class="hljs-title">Props</span>&gt; = <span class="hljs-function">(</span><span class="hljs-params">{ latitude, longitude }</span><span class="hljs-function">) =&gt;</span> (
  <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>Geolocation:<span class="hljs-tag">&lt;/</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>Latitude: {latitude}<span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>Longitude: {longitude}<span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
  <span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title">Geolocation</span>
</code></pre>
<p class="normal">Functional components are an incredibly elegant way to define UIs. They are pure functions that, given a state, return the elements of it. In this case, our function receives the latitude and longitude from the owner, and it returns the markup structure to display it.</p>
<p class="normal">The first time you run the components in the browser, the browser will require your permission to allow it to know your location.</p>
<figure class="mediaobject"><img alt="Graphical user interface, text, application  Description automatically generated" height="260" src="../Images/B18414_04_01.png" width="720"/></figure>
<p class="packt_figref">Figure 4.1: Browser will require your permission to access your location</p>
<p class="normal">After you allow the browser to<a id="_idIndexMarker155"/> know your location, you will see<a id="_idIndexMarker156"/> something like this:</p>
<figure class="mediaobject"><img alt="Graphical user interface, text, application  Description automatically generated" height="151" src="../Images/B18414_04_02.png" width="825"/></figure>
<p class="packt_figref">Figure 4.2: Displaying latitude and longitude</p>
<p class="normal">In adherence to the container and presentational pattern, we have created a “dumb” or presentational component that is reusable and can be effortlessly integrated into our components. This enables us to conveniently pass mock coordinates for testing or demonstration purposes. If a similar data structure is needed elsewhere in the application, it eliminates the necessity of building a new component from scratch. Instead, we can encapsulate this existing component within a new container. This container could, for example, be designed to retrieve latitude and longitude information from a separate endpoint.</p>
<p class="normal">At the same time, other developers in our team can improve the container that uses geolocation by adding some error-handling logic, without affecting its presentation. They can even build a temporary presentational component just to display and debug data and then replace it with the real presentational component when it is ready.</p>
<p class="normal">Being able to work in parallel on the <a id="_idIndexMarker157"/>same component is a big win for teams, especially for those companies where building interfaces is an iterative process.</p>
<p class="normal">This pattern is simple but<a id="_idIndexMarker158"/> very powerful, and when applied to big applications, it can make a difference when it comes to the speed of development and the maintainability of the project. On the other hand, applying this pattern without a real reason can give us the opposite problem and make the code base less useful as it involves the creation of more files and components.</p>
<p class="normal">So, we should think carefully when we decide that a component has to be refactored following the container and presentational patterns. In general, the right path to follow is starting with a single component and splitting it only when the logic and the presentation become too coupled where they shouldn’t be.</p>
<p class="normal">In our example, we began with a single component, and we realized that we could separate the API call from the markup. Deciding what to put in the container and what goes into the presentation is not always straightforward; the following points should help you make that decision:</p>
<p class="normal">The following are the characteristics of <a id="_idIndexMarker159"/>container components:</p>
<ul>
<li class="bulletList">They are more concerned with behavior.</li>
<li class="bulletList">They render their presentational components.</li>
<li class="bulletList">They make API calls and manipulate data.</li>
<li class="bulletList">They define event handlers.</li>
</ul>
<p class="normal">The following are the characteristics of presentational components:</p>
<ul>
<li class="bulletList">They are more concerned with the<a id="_idIndexMarker160"/> visual representation.</li>
<li class="bulletList">They render the HTML markup (or other components).</li>
<li class="bulletList">They receive data from the parents in the form of props.</li>
<li class="bulletList">They are often written as stateless functional components.</li>
</ul>
<p class="normal">As you can see, these patterns form a really powerful tool that will help you to develop your web applications faster. Let’s see what HOCs are in the next section.</p>
<h1 class="heading-1" id="_idParaDest-83">Understanding HOCs</h1>
<p class="normal">In the <em class="italic">functional programming</em> section of <em class="chapterRef">Chapter 3</em>, <em class="italic">Cleaning Up Your Code</em>, we introduced the<a id="_idIndexMarker161"/> concept of <strong class="keyWord">higher-order functions</strong> (<strong class="keyWord">HOFs</strong>). HOFs are functions that accept another function as an argument, enhance its behavior, and return a new function. Applying the idea of HOFs to<a id="_idIndexMarker162"/> components results in <strong class="keyWord">higher-order components</strong> (<strong class="keyWord">HOCs</strong>).</p>
<p class="normal">An HOC looks like this:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">HoC</span> = <span class="hljs-title">Component</span> =&gt; <span class="hljs-title">EnhancedComponent</span>
</code></pre>
<p class="normal">HOCs are functions that take a component as input and return an enhanced component as output. Let’s start with a simple example to understand what an enhanced component looks like.</p>
<p class="normal">Suppose you need to attach the same <code class="inlineCode">className</code> property to every component. You could manually add the <code class="inlineCode">className</code> property to each render method, or you could write an HOC like this:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">withClassName</span> = <span class="hljs-title">Component</span> =&gt; <span class="hljs-params">props</span><span class="hljs-function"> =&gt;</span> (
  <span class="hljs-tag">&lt;</span><span class="hljs-name">Component</span><span class="hljs-tag"> {</span><span class="hljs-attr">...props</span><span class="hljs-tag">} </span><span class="hljs-attr">className</span><span class="hljs-tag">=</span><span class="hljs-string">"my-class"</span><span class="hljs-tag"> /&gt;</span>
)
</code></pre>
<p class="normal">In the React community, it’s common to use the <code class="inlineCode">with</code> prefix for HOCs.</p>
<p class="normal">The code above might be confusing at first, so let’s break it down. We declare a <code class="inlineCode">withClassName</code> function that takes a <code class="inlineCode">Component</code> and returns another function. The returned function is a functional component that receives some props and renders the original component. The collected props are spread, and a <code class="inlineCode">className</code> property with the <code class="inlineCode">"my-class"</code> value is passed to the functional component.</p>
<p class="normal">HOCs typically spread the props they receive on the component because they aim to be transparent and only add new behavior.</p>
<p class="normal">While this example is simple and not particularly useful, it should give you a better understanding of what HOCs are and what they look like. Now, let’s see how we can use the <code class="inlineCode">withClassName</code> HOC in our components.</p>
<p class="normal">First, create a stateless functional component that receives the <code class="inlineCode">className</code> and applies it to a <code class="inlineCode">div</code> tag:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">MyComponent</span> = (<span class="hljs-params">{ className }</span>) =&gt; <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag"> </span><span class="hljs-attr">className</span><span class="hljs-tag">=</span><span class="hljs-string">{className}</span><span class="hljs-tag"> /&gt;</span>
</code></pre>
<p class="normal">Instead of using the component directly, we pass it to an HOC like this:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">MyComponentWithClassName</span> = <span class="hljs-title">withClassName</span>(<span class="hljs-title">MyComponent</span>)
</code></pre>
<p class="normal">Wrapping our components in the <code class="inlineCode">withClassName</code> function ensures that they receive the <code class="inlineCode">className</code> property.</p>
<p class="normal">Now, let’s create a more exciting<a id="_idIndexMarker163"/> HOC to detect the <code class="inlineCode">innerWidth</code>. First, create a function that receives a <code class="inlineCode">Component</code>:</p>
<pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">import</span> { useEffect, useState } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
  <span class="hljs-keyword">const</span> <span class="hljs-title">withInnerWidth</span> = <span class="hljs-title">Component</span> =&gt; <span class="hljs-params">props</span><span class="hljs-function"> =&gt;</span> <span class="hljs-tag">&lt;</span><span class="hljs-name">Component</span><span class="hljs-tag"> {</span><span class="hljs-attr">...props</span><span class="hljs-tag">} /&gt;</span>
</code></pre>
<p class="normal">It’s common practice to prefix HOCs that provide information to the components they enhance using the <code class="inlineCode">with</code> pattern.</p>
<p class="normal">Next, define the <code class="inlineCode">innerWidth</code> state and the <code class="inlineCode">handleResize</code> function:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">withInnerWidth</span> = <span class="hljs-title">Component</span> =&gt; <span class="hljs-params">props</span><span class="hljs-function"> =&gt;</span> {
  <span class="hljs-keyword">const</span> [innerWidth, setInnerWidth] = <span class="hljs-title">useState</span>(<span class="hljs-variable">window</span>.<span class="hljs-property">innerWidth</span>)
  <span class="hljs-keyword">const</span> <span class="hljs-title">handleResize</span> = () =&gt; {
    <span class="hljs-title">setInnerWidth</span>(<span class="hljs-variable">window</span>.<span class="hljs-property">innerWidth</span>)
  }
  <span class="hljs-keyword">return</span> <span class="hljs-tag">&lt;</span><span class="hljs-name">Component</span><span class="hljs-tag"> {</span><span class="hljs-attr">...props</span><span class="hljs-tag">} /&gt;</span>
}
</code></pre>
<p class="normal">Then, add the effects:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-title">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable">window</span>.<span class="hljs-title">addEventListener</span>(<span class="hljs-string">'resize'</span>, handleResize)
  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable">window</span>.<span class="hljs-title">removeEventListener</span>(<span class="hljs-string">'resize'</span>, handleResize)
  }
}, [])
</code></pre>
<p class="normal">Finally, render the original component like this:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span> <span class="hljs-tag">&lt;</span><span class="hljs-name">Component</span><span class="hljs-tag"> {</span><span class="hljs-attr">...props</span><span class="hljs-tag">} </span><span class="hljs-attr">innerWidth</span><span class="hljs-tag">=</span><span class="hljs-string">{innerWidth}</span><span class="hljs-tag"> /&gt;</span>
</code></pre>
<p class="normal">Here, we spread the props as before, but we also pass the <code class="inlineCode">innerWidth</code> state.</p>
<p class="normal">We store the <code class="inlineCode">innerWidth</code> value as a state to<a id="_idIndexMarker164"/> achieve the original behavior without polluting the component’s state. Instead, we use props. Using props is an excellent way to promote reusability.</p>
<p class="normal">Now, using an HOC and getting the <code class="inlineCode">innerWidth</code> value is straightforward. The new React Hooks can easily replace an HOC by creating custom Hooks. Create a functional component that expects <code class="inlineCode">innerWidth</code> as a property:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">MyComponent</span> = (<span class="hljs-params">{ innerWidth }</span>) =&gt; {
  <span class="hljs-variable">console</span>.<span class="hljs-title">log</span>(<span class="hljs-string">'window.innerWidth'</span>, innerWidth)
  <span class="hljs-comment">// ...</span>
}
</code></pre>
<p class="normal">Enhance it as follows:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">MyComponentWithInnerWidth</span> = <span class="hljs-title">withInnerWidth</span>(<span class="hljs-title">MyComponent</span>)
</code></pre>
<p class="normal">By using HOCs, we avoid polluting any state and don’t require the component to implement any function. This means the component and HOC are not coupled, and both can be reused throughout the application.</p>
<p class="normal">Using props instead of state allows us to create a “dumb” component that can be used in our style guide, ignoring complex logic and just passing down the props.</p>
<p class="normal">In this specific case, we could create a component for each of the different <code class="inlineCode">innerWidth</code> sizes we support. Consider the following example:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;<span class="hljs-title">MyComponent</span> innerWidth={<span class="hljs-number">320</span>} /&gt;
</code></pre>
<p class="normal">Or the following:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;<span class="hljs-title">MyComponent</span> innerWidth={<span class="hljs-number">960</span>} /&gt;
</code></pre>
<p class="normal">As you can see, by using HOCs, we can pass a component and then return a new component with additional functionalities. Some common HOCs are <code class="inlineCode">connect</code> from Redux and <code class="inlineCode">createFragmentContainer</code> from Relay.</p>
<h1 class="heading-1" id="_idParaDest-84">Understanding FunctionAsChild</h1>
<p class="normal">The <code class="inlineCode">FunctionAsChild</code><strong class="keyWord"> </strong>pattern is gaining <a id="_idIndexMarker165"/>consensus within the React community. It is widely used in popular libraries like <strong class="keyWord">react-motion</strong>, which we will explore in <em class="chapterRef">Chapter 5</em>, <em class="italic">Writing Code for the Browser</em>.</p>
<p class="normal">The main concept is that instead of passing a child as a component, we define a function that can receive parameters from the parent. Let’s see what it looks like:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">FunctionAsChild</span> = (<span class="hljs-params">{ children }</span>) =&gt; <span class="hljs-title">children</span>()
</code></pre>
<p class="normal">As you can see, <code class="inlineCode">FunctionAsChild</code> is a component with a children property defined as a function. Instead of being used as a JSX expression, it gets called.</p>
<p class="normal">The preceding component can be used like this:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;<span class="hljs-title">FunctionAsChild</span>&gt;
  {<span class="hljs-function">() =&gt;</span> <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>Hello, World!<span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>}
&lt;/<span class="hljs-title">FunctionAsChild</span>&gt;
</code></pre>
<p class="normal">This example is quite simple: the children function is executed within the parent’s render method, returning the <code class="inlineCode">Hello, World!</code> text wrapped in a <code class="inlineCode">div</code> tag, which is displayed on the screen.</p>
<p class="normal">Now, let’s explore a more meaningful example where the parent component passes some parameters to the children function.</p>
<p class="normal">Create a <code class="inlineCode">Name</code> component that expects a function as children and passes it the <code class="inlineCode">'World'</code> string:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">Name</span> = (<span class="hljs-params">{ children }</span>) =&gt; <span class="hljs-title">children</span>(<span class="hljs-string">'World'</span>)
</code></pre>
<p class="normal">The preceding component can be used like this:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag">&lt;</span><span class="hljs-name">Name</span><span class="hljs-tag">&gt;</span>
  {name =&gt; <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>Hello, {name}!<span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>}
<span class="hljs-tag">&lt;/</span><span class="hljs-name">Name</span><span class="hljs-tag">&gt;</span>
</code></pre>
<p class="normal">The snippet renders <code class="inlineCode">Hello, World!</code> again, but this time the name has been passed by the parent. It should now be clear how this pattern works. Let’s look at the advantages of this approach:</p>
<ul>
<li class="bulletList">The primary advantage is the ability to encapsulate components, delivering variables dynamically, as opposed to utilizing static properties, which is a common practice with HOCs. An excellent illustration of this is a <code class="inlineCode">Fetch</code> component, designed to retrieve data from a specific API endpoint and subsequently return it to its child function:
        <pre class="programlisting code"><code class="hljs-code">&lt;<span class="hljs-title">Fetch</span> url=<span class="hljs-string">"..."</span>&gt;
  {<span class="hljs-params">data</span><span class="hljs-function"> =&gt;</span> <span class="hljs-tag">&lt;</span><span class="hljs-name">List</span><span class="hljs-tag"> </span><span class="hljs-attr">data</span><span class="hljs-tag">=</span><span class="hljs-string">{data}</span><span class="hljs-tag"> /&gt;</span>}
&lt;/<span class="hljs-title">Fetch</span>&gt;
</code></pre>
</li>
<li class="bulletList">Secondly, composing components with this approach does not force children to use predefined prop names. Since the function receives variables, developers who use the component can decide on their names. This flexibility makes the Function as Child solution more versatile.</li>
<li class="bulletList">Lastly, the wrapper is highly reusable because it does not make any assumptions about the children it receives—it just expects a function. Due to this, the same <code class="inlineCode">FunctionAsChild</code> component can be used in different parts of the<a id="_idIndexMarker166"/> application to serve various children components.</li>
</ul>
<p class="normal">By adopting the Function as Child pattern, you can create more flexible, versatile, and reusable components in your React applications.</p>
<h1 class="heading-1" id="_idParaDest-85">Summary</h1>
<p class="normal">In this chapter, we learned how to effectively compose and communicate between our reusable components using props. By using props, we can create well-defined interfaces and decouple our components from each other.</p>
<p class="normal">We also explored two popular composition patterns: the container and presentational pattern, which help us separate our logic and presentation for more specialized and focused components. Additionally, we discovered <strong class="keyWord">Higher-Order Components</strong> (<strong class="keyWord">HOCs</strong>) as a way to handle context without tightly coupling our components to it, and the Function as Child pattern for composing components dynamically.</p>
<p class="normal">In the next chapter, we will dive into controlled vs. uncontrolled components, refs, handling events, and animations in React.</p>
</div>
</div></body></html>